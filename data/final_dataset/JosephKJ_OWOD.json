{"home.repos.pwc.inspect_result.JosephKJ_OWOD.None.setup.get_version": [[18, 39], ["os.path.join", "open().readlines", "[].strip().strip", "os.getenv", "os.path.abspath", "os.getenv", "datetime.today().strftime", "new_init_py.append", "os.path.dirname", "open", "l.strip", "[].strip", "open", "f.write", "l.startswith", "datetime.today", "l.startswith", "version_line.split"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write"], ["def", "get_version", "(", ")", ":", "\n", "    ", "init_py_path", "=", "path", ".", "join", "(", "path", ".", "abspath", "(", "path", ".", "dirname", "(", "__file__", ")", ")", ",", "\"detectron2\"", ",", "\"__init__.py\"", ")", "\n", "init_py", "=", "open", "(", "init_py_path", ",", "\"r\"", ")", ".", "readlines", "(", ")", "\n", "version_line", "=", "[", "l", ".", "strip", "(", ")", "for", "l", "in", "init_py", "if", "l", ".", "startswith", "(", "\"__version__\"", ")", "]", "[", "0", "]", "\n", "version", "=", "version_line", ".", "split", "(", "\"=\"", ")", "[", "-", "1", "]", ".", "strip", "(", ")", ".", "strip", "(", "\"'\\\"\"", ")", "\n", "\n", "# The following is used to build release packages.", "\n", "# Users should never use it.", "\n", "suffix", "=", "os", ".", "getenv", "(", "\"D2_VERSION_SUFFIX\"", ",", "\"\"", ")", "\n", "version", "=", "version", "+", "suffix", "\n", "if", "os", ".", "getenv", "(", "\"BUILD_NIGHTLY\"", ",", "\"0\"", ")", "==", "\"1\"", ":", "\n", "        ", "from", "datetime", "import", "datetime", "\n", "\n", "date_str", "=", "datetime", ".", "today", "(", ")", ".", "strftime", "(", "\"%y%m%d\"", ")", "\n", "version", "=", "version", "+", "\".dev\"", "+", "date_str", "\n", "\n", "new_init_py", "=", "[", "l", "for", "l", "in", "init_py", "if", "not", "l", ".", "startswith", "(", "\"__version__\"", ")", "]", "\n", "new_init_py", ".", "append", "(", "'__version__ = \"{}\"\\n'", ".", "format", "(", "version", ")", ")", "\n", "with", "open", "(", "init_py_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "\"\"", ".", "join", "(", "new_init_py", ")", ")", "\n", "", "", "return", "version", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.None.setup.get_extensions": [[41, 138], ["os.path.dirname", "os.path.join", "os.path.join", "glob.glob", "os.path.abspath", "os.path.join", "torch.utils.hipify.hipify_python.hipify", "shutil.copy", "shutil.copy", "os.environ.get", "extension", "glob.glob", "glob.glob", "glob.glob", "glob.glob", "torch.cuda.is_available", "os.getenv", "extra_compile_args[].append", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "s.endswith"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "get_extensions", "(", ")", ":", "\n", "    ", "this_dir", "=", "path", ".", "dirname", "(", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "extensions_dir", "=", "path", ".", "join", "(", "this_dir", ",", "\"detectron2\"", ",", "\"layers\"", ",", "\"csrc\"", ")", "\n", "\n", "main_source", "=", "path", ".", "join", "(", "extensions_dir", ",", "\"vision.cpp\"", ")", "\n", "sources", "=", "glob", ".", "glob", "(", "path", ".", "join", "(", "extensions_dir", ",", "\"**\"", ",", "\"*.cpp\"", ")", ")", "\n", "\n", "is_rocm_pytorch", "=", "False", "\n", "if", "torch_ver", ">=", "[", "1", ",", "5", "]", ":", "\n", "        ", "from", "torch", ".", "utils", ".", "cpp_extension", "import", "ROCM_HOME", "\n", "\n", "is_rocm_pytorch", "=", "(", "\n", "True", "if", "(", "(", "torch", ".", "version", ".", "hip", "is", "not", "None", ")", "and", "(", "ROCM_HOME", "is", "not", "None", ")", ")", "else", "False", "\n", ")", "\n", "\n", "", "if", "is_rocm_pytorch", ":", "\n", "        ", "hipify_python", ".", "hipify", "(", "\n", "project_directory", "=", "this_dir", ",", "\n", "output_directory", "=", "this_dir", ",", "\n", "includes", "=", "\"/detectron2/layers/csrc/*\"", ",", "\n", "show_detailed", "=", "True", ",", "\n", "is_pytorch_extension", "=", "True", ",", "\n", ")", "\n", "\n", "# Current version of hipify function in pytorch creates an intermediate directory", "\n", "# named \"hip\" at the same level of the path hierarchy if a \"cuda\" directory exists,", "\n", "# or modifying the hierarchy, if it doesn't. Once pytorch supports", "\n", "# \"same directory\" hipification (https://github.com/pytorch/pytorch/pull/40523),", "\n", "# the source_cuda will be set similarly in both cuda and hip paths, and the explicit", "\n", "# header file copy (below) will not be needed.", "\n", "source_cuda", "=", "glob", ".", "glob", "(", "path", ".", "join", "(", "extensions_dir", ",", "\"**\"", ",", "\"hip\"", ",", "\"*.hip\"", ")", ")", "+", "glob", ".", "glob", "(", "\n", "path", ".", "join", "(", "extensions_dir", ",", "\"hip\"", ",", "\"*.hip\"", ")", "\n", ")", "\n", "\n", "shutil", ".", "copy", "(", "\n", "\"detectron2/layers/csrc/box_iou_rotated/box_iou_rotated_utils.h\"", ",", "\n", "\"detectron2/layers/csrc/box_iou_rotated/hip/box_iou_rotated_utils.h\"", ",", "\n", ")", "\n", "shutil", ".", "copy", "(", "\n", "\"detectron2/layers/csrc/deformable/deform_conv.h\"", ",", "\n", "\"detectron2/layers/csrc/deformable/hip/deform_conv.h\"", ",", "\n", ")", "\n", "\n", "", "else", ":", "\n", "        ", "source_cuda", "=", "glob", ".", "glob", "(", "path", ".", "join", "(", "extensions_dir", ",", "\"**\"", ",", "\"*.cu\"", ")", ")", "+", "glob", ".", "glob", "(", "\n", "path", ".", "join", "(", "extensions_dir", ",", "\"*.cu\"", ")", "\n", ")", "\n", "\n", "", "sources", "=", "[", "main_source", "]", "+", "sources", "\n", "sources", "=", "[", "\n", "s", "\n", "for", "s", "in", "sources", "\n", "if", "not", "is_rocm_pytorch", "or", "torch_ver", "<", "[", "1", ",", "7", "]", "or", "not", "s", ".", "endswith", "(", "\"hip/vision.cpp\"", ")", "\n", "]", "\n", "\n", "extension", "=", "CppExtension", "\n", "\n", "extra_compile_args", "=", "{", "\"cxx\"", ":", "[", "]", "}", "\n", "define_macros", "=", "[", "]", "\n", "\n", "if", "(", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "(", "(", "CUDA_HOME", "is", "not", "None", ")", "or", "is_rocm_pytorch", ")", ")", "or", "os", ".", "getenv", "(", "\n", "\"FORCE_CUDA\"", ",", "\"0\"", "\n", ")", "==", "\"1\"", ":", "\n", "        ", "extension", "=", "CUDAExtension", "\n", "sources", "+=", "source_cuda", "\n", "\n", "if", "not", "is_rocm_pytorch", ":", "\n", "            ", "define_macros", "+=", "[", "(", "\"WITH_CUDA\"", ",", "None", ")", "]", "\n", "extra_compile_args", "[", "\"nvcc\"", "]", "=", "[", "\n", "\"-O3\"", ",", "\n", "\"-DCUDA_HAS_FP16=1\"", ",", "\n", "\"-D__CUDA_NO_HALF_OPERATORS__\"", ",", "\n", "\"-D__CUDA_NO_HALF_CONVERSIONS__\"", ",", "\n", "\"-D__CUDA_NO_HALF2_OPERATORS__\"", ",", "\n", "]", "\n", "", "else", ":", "\n", "            ", "define_macros", "+=", "[", "(", "\"WITH_HIP\"", ",", "None", ")", "]", "\n", "extra_compile_args", "[", "\"nvcc\"", "]", "=", "[", "]", "\n", "\n", "# It's better if pytorch can do this by default ..", "\n", "", "CC", "=", "os", ".", "environ", ".", "get", "(", "\"CC\"", ",", "None", ")", "\n", "if", "CC", "is", "not", "None", ":", "\n", "            ", "extra_compile_args", "[", "\"nvcc\"", "]", ".", "append", "(", "\"-ccbin={}\"", ".", "format", "(", "CC", ")", ")", "\n", "\n", "", "", "include_dirs", "=", "[", "extensions_dir", "]", "\n", "\n", "ext_modules", "=", "[", "\n", "extension", "(", "\n", "\"detectron2._C\"", ",", "\n", "sources", ",", "\n", "include_dirs", "=", "include_dirs", ",", "\n", "define_macros", "=", "define_macros", ",", "\n", "extra_compile_args", "=", "extra_compile_args", ",", "\n", ")", "\n", "]", "\n", "\n", "return", "ext_modules", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.None.setup.get_model_zoo_configs": [[140, 169], ["os.path.join", "os.path.join", "os.path.exists", "glob.glob", "os.path.dirname", "os.path.dirname", "os.path.islink", "os.path.exists", "os.path.realpath", "os.path.realpath", "os.unlink", "os.path.isdir", "os.symlink", "shutil.rmtree", "shutil.copytree"], "function", ["None"], ["", "def", "get_model_zoo_configs", "(", ")", "->", "List", "[", "str", "]", ":", "\n", "    ", "\"\"\"\n    Return a list of configs to include in package for model zoo. Copy over these configs inside\n    detectron2/model_zoo.\n    \"\"\"", "\n", "\n", "# Use absolute paths while symlinking.", "\n", "source_configs_dir", "=", "path", ".", "join", "(", "path", ".", "dirname", "(", "path", ".", "realpath", "(", "__file__", ")", ")", ",", "\"configs\"", ")", "\n", "destination", "=", "path", ".", "join", "(", "\n", "path", ".", "dirname", "(", "path", ".", "realpath", "(", "__file__", ")", ")", ",", "\"detectron2\"", ",", "\"model_zoo\"", ",", "\"configs\"", "\n", ")", "\n", "# Symlink the config directory inside package to have a cleaner pip install.", "\n", "\n", "# Remove stale symlink/directory from a previous build.", "\n", "if", "path", ".", "exists", "(", "source_configs_dir", ")", ":", "\n", "        ", "if", "path", ".", "islink", "(", "destination", ")", ":", "\n", "            ", "os", ".", "unlink", "(", "destination", ")", "\n", "", "elif", "path", ".", "isdir", "(", "destination", ")", ":", "\n", "            ", "shutil", ".", "rmtree", "(", "destination", ")", "\n", "\n", "", "", "if", "not", "path", ".", "exists", "(", "destination", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "os", ".", "symlink", "(", "source_configs_dir", ",", "destination", ")", "\n", "", "except", "OSError", ":", "\n", "# Fall back to copying if symlink fails: ex. on Windows.", "\n", "            ", "shutil", ".", "copytree", "(", "source_configs_dir", ",", "destination", ")", "\n", "\n", "", "", "config_paths", "=", "glob", ".", "glob", "(", "\"configs/**/*.yaml\"", ",", "recursive", "=", "True", ")", "\n", "return", "config_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.None.visualise_detections.create_distribution": [[16, 21], ["torch.distributions.weibull.Weibull", "torch.distributions.transforms.AffineTransform", "torch.distributions.transformed_distribution.TransformedDistribution"], "function", ["None"], ["def", "create_distribution", "(", "scale", ",", "shape", ",", "shift", ")", ":", "\n", "    ", "wd", "=", "Weibull", "(", "scale", "=", "scale", ",", "concentration", "=", "shape", ")", "\n", "transforms", "=", "AffineTransform", "(", "loc", "=", "shift", ",", "scale", "=", "1.", ")", "\n", "weibull", "=", "TransformedDistribution", "(", "wd", ",", "transforms", ")", "\n", "return", "weibull", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.None.visualise_detections.compute_prob": [[23, 33], ["torch.linspace", "distribution.log_prob().exp", "torch.sum", "distribution.log_prob"], "function", ["None"], ["", "def", "compute_prob", "(", "x", ",", "distribution", ")", ":", "\n", "    ", "eps_radius", "=", "0.5", "\n", "num_eval_points", "=", "100", "\n", "start_x", "=", "x", "-", "eps_radius", "\n", "end_x", "=", "x", "+", "eps_radius", "\n", "step", "=", "(", "end_x", "-", "start_x", ")", "/", "num_eval_points", "\n", "dx", "=", "torch", ".", "linspace", "(", "x", "-", "eps_radius", ",", "x", "+", "eps_radius", ",", "num_eval_points", ")", "\n", "pdf", "=", "distribution", ".", "log_prob", "(", "dx", ")", ".", "exp", "(", ")", "\n", "prob", "=", "torch", ".", "sum", "(", "pdf", "*", "step", ")", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.None.visualise_detections.update_label_based_on_energy": [[35, 48], ["torch.logsumexp", "enumerate", "visualise_detections.compute_prob", "visualise_detections.compute_prob", "torch.isnan", "torch.isnan"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_prob", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_prob"], ["", "def", "update_label_based_on_energy", "(", "logits", ",", "classes", ",", "unk_dist", ",", "known_dist", ")", ":", "\n", "    ", "unknown_class_index", "=", "80", "\n", "cls", "=", "classes", "\n", "lse", "=", "torch", ".", "logsumexp", "(", "logits", "[", ":", ",", ":", "5", "]", ",", "dim", "=", "1", ")", "\n", "for", "i", ",", "energy", "in", "enumerate", "(", "lse", ")", ":", "\n", "        ", "p_unk", "=", "compute_prob", "(", "energy", ",", "unk_dist", ")", "\n", "p_known", "=", "compute_prob", "(", "energy", ",", "known_dist", ")", "\n", "# print(str(p_unk) + '  --  ' + str(p_known))", "\n", "if", "torch", ".", "isnan", "(", "p_unk", ")", "or", "torch", ".", "isnan", "(", "p_known", ")", ":", "\n", "            ", "continue", "\n", "", "if", "p_unk", ">", "p_known", ":", "\n", "            ", "cls", "[", "i", "]", "=", "unknown_class_index", "\n", "", "", "return", "cls", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.packaging.gen_install_table.gen_header": [[13, 18], ["None"], "function", ["None"], ["def", "gen_header", "(", "torch_versions", ")", ":", "\n", "    ", "return", "'<table class=\"docutils\"><tbody><th width=\"80\"> CUDA </th>'", "+", "\"\"", ".", "join", "(", "\n", "[", "\n", "'<th valign=\"bottom\" align=\"left\" width=\"100\">torch {}</th>'", ".", "format", "(", "t", ")", "\n", "for", "t", "in", "torch_versions", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.prepare_ade20k_sem_seg.convert": [[11, 16], ["numpy.asarray", "PIL.Image.fromarray().save", "PIL.Image.open", "PIL.Image.fromarray"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save"], ["def", "convert", "(", "input", ",", "output", ")", ":", "\n", "    ", "img", "=", "np", ".", "asarray", "(", "Image", ".", "open", "(", "input", ")", ")", "\n", "assert", "img", ".", "dtype", "==", "np", ".", "uint8", "\n", "img", "=", "img", "-", "1", "# 0 (ignore) becomes 255. others are shifted by 1", "\n", "Image", ".", "fromarray", "(", "img", ")", ".", "save", "(", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.prepare_cocofied_lvis.cocofy_lvis": [[96, 167], ["json.load.pop", "copy.deepcopy", "set", "collections.defaultdict", "set", "print", "open", "json.load", "synset_to_coco_cat_id.keys", "copy.deepcopy", "new_annos.append", "set.keys", "copy.deepcopy", "new_categories.append", "open", "json.dump", "new_category_list.append"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump"], ["def", "cocofy_lvis", "(", "input_filename", ",", "output_filename", ")", ":", "\n", "    ", "\"\"\"\n    Filter LVIS instance segmentation annotations to remove all categories that are not included in\n    COCO. The new json files can be used to evaluate COCO AP using `lvis-api`. The category ids in\n    the output json are the incontiguous COCO dataset ids.\n\n    Args:\n        input_filename (str): path to the LVIS json file.\n        output_filename (str): path to the COCOfied json file.\n    \"\"\"", "\n", "\n", "with", "open", "(", "input_filename", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "lvis_json", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "lvis_annos", "=", "lvis_json", ".", "pop", "(", "\"annotations\"", ")", "\n", "cocofied_lvis", "=", "copy", ".", "deepcopy", "(", "lvis_json", ")", "\n", "lvis_json", "[", "\"annotations\"", "]", "=", "lvis_annos", "\n", "\n", "# Mapping from lvis cat id to coco cat id via synset", "\n", "lvis_cat_id_to_synset", "=", "{", "cat", "[", "\"id\"", "]", ":", "cat", "[", "\"synset\"", "]", "for", "cat", "in", "lvis_json", "[", "\"categories\"", "]", "}", "\n", "synset_to_coco_cat_id", "=", "{", "x", "[", "\"synset\"", "]", ":", "x", "[", "\"coco_cat_id\"", "]", "for", "x", "in", "COCO_SYNSET_CATEGORIES", "}", "\n", "# Synsets that we will keep in the dataset", "\n", "synsets_to_keep", "=", "set", "(", "synset_to_coco_cat_id", ".", "keys", "(", ")", ")", "\n", "coco_cat_id_with_instances", "=", "defaultdict", "(", "int", ")", "\n", "\n", "new_annos", "=", "[", "]", "\n", "ann_id", "=", "1", "\n", "for", "ann", "in", "lvis_annos", ":", "\n", "        ", "lvis_cat_id", "=", "ann", "[", "\"category_id\"", "]", "\n", "synset", "=", "lvis_cat_id_to_synset", "[", "lvis_cat_id", "]", "\n", "if", "synset", "not", "in", "synsets_to_keep", ":", "\n", "            ", "continue", "\n", "", "coco_cat_id", "=", "synset_to_coco_cat_id", "[", "synset", "]", "\n", "new_ann", "=", "copy", ".", "deepcopy", "(", "ann", ")", "\n", "new_ann", "[", "\"category_id\"", "]", "=", "coco_cat_id", "\n", "new_ann", "[", "\"id\"", "]", "=", "ann_id", "\n", "ann_id", "+=", "1", "\n", "new_annos", ".", "append", "(", "new_ann", ")", "\n", "coco_cat_id_with_instances", "[", "coco_cat_id", "]", "+=", "1", "\n", "", "cocofied_lvis", "[", "\"annotations\"", "]", "=", "new_annos", "\n", "\n", "for", "image", "in", "cocofied_lvis", "[", "\"images\"", "]", ":", "\n", "        ", "for", "key", "in", "[", "\"not_exhaustive_category_ids\"", ",", "\"neg_category_ids\"", "]", ":", "\n", "            ", "new_category_list", "=", "[", "]", "\n", "for", "lvis_cat_id", "in", "image", "[", "key", "]", ":", "\n", "                ", "synset", "=", "lvis_cat_id_to_synset", "[", "lvis_cat_id", "]", "\n", "if", "synset", "not", "in", "synsets_to_keep", ":", "\n", "                    ", "continue", "\n", "", "coco_cat_id", "=", "synset_to_coco_cat_id", "[", "synset", "]", "\n", "new_category_list", ".", "append", "(", "coco_cat_id", ")", "\n", "coco_cat_id_with_instances", "[", "coco_cat_id", "]", "+=", "1", "\n", "", "image", "[", "key", "]", "=", "new_category_list", "\n", "\n", "", "", "coco_cat_id_with_instances", "=", "set", "(", "coco_cat_id_with_instances", ".", "keys", "(", ")", ")", "\n", "\n", "new_categories", "=", "[", "]", "\n", "for", "cat", "in", "lvis_json", "[", "\"categories\"", "]", ":", "\n", "        ", "synset", "=", "cat", "[", "\"synset\"", "]", "\n", "if", "synset", "not", "in", "synsets_to_keep", ":", "\n", "            ", "continue", "\n", "", "coco_cat_id", "=", "synset_to_coco_cat_id", "[", "synset", "]", "\n", "if", "coco_cat_id", "not", "in", "coco_cat_id_with_instances", ":", "\n", "            ", "continue", "\n", "", "new_cat", "=", "copy", ".", "deepcopy", "(", "cat", ")", "\n", "new_cat", "[", "\"id\"", "]", "=", "coco_cat_id", "\n", "new_categories", ".", "append", "(", "new_cat", ")", "\n", "", "cocofied_lvis", "[", "\"categories\"", "]", "=", "new_categories", "\n", "\n", "with", "open", "(", "output_filename", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "cocofied_lvis", ",", "f", ")", "\n", "", "print", "(", "\"{} is COCOfied and stored in {}.\"", ".", "format", "(", "input_filename", ",", "output_filename", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.prepare_panoptic_fpn._process_panoptic_to_semantic": [[18, 27], ["numpy.asarray", "panopticapi.utils.rgb2id", "PIL.Image.fromarray().save", "PIL.Image.open", "numpy.zeros_like", "PIL.Image.fromarray"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save"], ["def", "_process_panoptic_to_semantic", "(", "input_panoptic", ",", "output_semantic", ",", "segments", ",", "id_map", ")", ":", "\n", "    ", "panoptic", "=", "np", ".", "asarray", "(", "Image", ".", "open", "(", "input_panoptic", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "panoptic", "=", "rgb2id", "(", "panoptic", ")", "\n", "output", "=", "np", ".", "zeros_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "+", "255", "\n", "for", "seg", "in", "segments", ":", "\n", "        ", "cat_id", "=", "seg", "[", "\"category_id\"", "]", "\n", "new_cat_id", "=", "id_map", "[", "cat_id", "]", "\n", "output", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "new_cat_id", "\n", "", "Image", ".", "fromarray", "(", "output", ")", ".", "save", "(", "output_semantic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.prepare_panoptic_fpn.separate_coco_semantic_from_panoptic": [[29, 78], ["os.makedirs", "enumerate", "multiprocessing.Pool", "print", "time.time", "mp.Pool.starmap", "print", "len", "open", "json.load", "functools.partial", "prepare_panoptic_fpn.separate_coco_semantic_from_panoptic.iter_annotations"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load"], ["", "def", "separate_coco_semantic_from_panoptic", "(", "panoptic_json", ",", "panoptic_root", ",", "sem_seg_root", ",", "categories", ")", ":", "\n", "    ", "\"\"\"\n    Create semantic segmentation annotations from panoptic segmentation\n    annotations, to be used by PanopticFPN.\n\n    It maps all thing categories to class 0, and maps all unlabeled pixels to class 255.\n    It maps all stuff categories to contiguous ids starting from 1.\n\n    Args:\n        panoptic_json (str): path to the panoptic json file, in COCO's format.\n        panoptic_root (str): a directory with panoptic annotation files, in COCO's format.\n        sem_seg_root (str): a directory to output semantic annotation files\n        categories (list[dict]): category metadata. Each dict needs to have:\n            \"id\": corresponds to the \"category_id\" in the json annotations\n            \"isthing\": 0 or 1\n    \"\"\"", "\n", "os", ".", "makedirs", "(", "sem_seg_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "stuff_ids", "=", "[", "k", "[", "\"id\"", "]", "for", "k", "in", "categories", "if", "k", "[", "\"isthing\"", "]", "==", "0", "]", "\n", "thing_ids", "=", "[", "k", "[", "\"id\"", "]", "for", "k", "in", "categories", "if", "k", "[", "\"isthing\"", "]", "==", "1", "]", "\n", "id_map", "=", "{", "}", "# map from category id to id in the output semantic annotation", "\n", "assert", "len", "(", "stuff_ids", ")", "<=", "254", "\n", "for", "i", ",", "stuff_id", "in", "enumerate", "(", "stuff_ids", ")", ":", "\n", "        ", "id_map", "[", "stuff_id", "]", "=", "i", "+", "1", "\n", "", "for", "thing_id", "in", "thing_ids", ":", "\n", "        ", "id_map", "[", "thing_id", "]", "=", "0", "\n", "", "id_map", "[", "0", "]", "=", "255", "\n", "\n", "with", "open", "(", "panoptic_json", ")", "as", "f", ":", "\n", "        ", "obj", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "pool", "=", "mp", ".", "Pool", "(", "processes", "=", "max", "(", "mp", ".", "cpu_count", "(", ")", "//", "2", ",", "4", ")", ")", "\n", "\n", "def", "iter_annotations", "(", ")", ":", "\n", "        ", "for", "anno", "in", "obj", "[", "\"annotations\"", "]", ":", "\n", "            ", "file_name", "=", "anno", "[", "\"file_name\"", "]", "\n", "segments", "=", "anno", "[", "\"segments_info\"", "]", "\n", "input", "=", "os", ".", "path", ".", "join", "(", "panoptic_root", ",", "file_name", ")", "\n", "output", "=", "os", ".", "path", ".", "join", "(", "sem_seg_root", ",", "file_name", ")", "\n", "yield", "input", ",", "output", ",", "segments", "\n", "\n", "", "", "print", "(", "\"Start writing to {} ...\"", ".", "format", "(", "sem_seg_root", ")", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "pool", ".", "starmap", "(", "\n", "functools", ".", "partial", "(", "_process_panoptic_to_semantic", ",", "id_map", "=", "id_map", ")", ",", "\n", "iter_annotations", "(", ")", ",", "\n", "chunksize", "=", "100", ",", "\n", ")", "\n", "print", "(", "\"Finished. time: {:.2f}s\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes_panoptic.get_cityscapes_panoptic_files": [[18, 49], ["fvcore.common.file_io.PathManager.ls", "logger.info", "len", "fvcore.common.file_io.PathManager.isfile", "fvcore.common.file_io.PathManager.isfile", "os.path.join", "fvcore.common.file_io.PathManager.ls", "image_dict.get", "os.path.join", "files.append", "os.path.join", "basename.endswith", "len", "os.path.basename", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "get_cityscapes_panoptic_files", "(", "image_dir", ",", "gt_dir", ",", "json_info", ")", ":", "\n", "    ", "files", "=", "[", "]", "\n", "# scan through the directory", "\n", "cities", "=", "PathManager", ".", "ls", "(", "image_dir", ")", "\n", "logger", ".", "info", "(", "f\"{len(cities)} cities found in '{image_dir}'.\"", ")", "\n", "image_dict", "=", "{", "}", "\n", "for", "city", "in", "cities", ":", "\n", "        ", "city_img_dir", "=", "os", ".", "path", ".", "join", "(", "image_dir", ",", "city", ")", "\n", "for", "basename", "in", "PathManager", ".", "ls", "(", "city_img_dir", ")", ":", "\n", "            ", "image_file", "=", "os", ".", "path", ".", "join", "(", "city_img_dir", ",", "basename", ")", "\n", "\n", "suffix", "=", "\"_leftImg8bit.png\"", "\n", "assert", "basename", ".", "endswith", "(", "suffix", ")", ",", "basename", "\n", "basename", "=", "os", ".", "path", ".", "basename", "(", "basename", ")", "[", ":", "-", "len", "(", "suffix", ")", "]", "\n", "\n", "image_dict", "[", "basename", "]", "=", "image_file", "\n", "\n", "", "", "for", "ann", "in", "json_info", "[", "\"annotations\"", "]", ":", "\n", "        ", "image_file", "=", "image_dict", ".", "get", "(", "ann", "[", "\"image_id\"", "]", ",", "None", ")", "\n", "assert", "image_file", "is", "not", "None", ",", "\"No image {} found for annotation {}\"", ".", "format", "(", "\n", "ann", "[", "\"image_id\"", "]", ",", "ann", "[", "\"file_name\"", "]", "\n", ")", "\n", "label_file", "=", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "ann", "[", "\"file_name\"", "]", ")", "\n", "segments_info", "=", "ann", "[", "\"segments_info\"", "]", "\n", "\n", "files", ".", "append", "(", "(", "image_file", ",", "label_file", ",", "segments_info", ")", ")", "\n", "\n", "", "assert", "len", "(", "files", ")", ",", "\"No images found in {}\"", ".", "format", "(", "image_dir", ")", "\n", "assert", "PathManager", ".", "isfile", "(", "files", "[", "0", "]", "[", "0", "]", ")", ",", "files", "[", "0", "]", "[", "0", "]", "\n", "assert", "PathManager", ".", "isfile", "(", "files", "[", "0", "]", "[", "1", "]", ")", ",", "files", "[", "0", "]", "[", "1", "]", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes_panoptic.load_cityscapes_panoptic": [[51, 110], ["os.path.exists", "cityscapes_panoptic.get_cityscapes_panoptic_files", "len", "fvcore.common.file_io.PathManager.isfile", "fvcore.common.file_io.PathManager.isfile", "open", "json.load", "ret.append", "cityscapes_panoptic.load_cityscapes_panoptic._convert_category_id"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes_panoptic.get_cityscapes_panoptic_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.panoptic_evaluation.COCOPanopticEvaluator._convert_category_id"], ["", "def", "load_cityscapes_panoptic", "(", "image_dir", ",", "gt_dir", ",", "gt_json", ",", "meta", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        image_dir (str): path to the raw dataset. e.g., \"~/cityscapes/leftImg8bit/train\".\n        gt_dir (str): path to the raw annotations. e.g.,\n            \"~/cityscapes/gtFine/cityscapes_panoptic_train\".\n        gt_json (str): path to the json file. e.g.,\n            \"~/cityscapes/gtFine/cityscapes_panoptic_train.json\".\n        meta (dict): dictionary containing \"thing_dataset_id_to_contiguous_id\"\n            and \"stuff_dataset_id_to_contiguous_id\" to map category ids to\n            contiguous ids for training.\n\n    Returns:\n        list[dict]: a list of dicts in Detectron2 standard format. (See\n        `Using Custom Datasets </tutorials/datasets.html>`_ )\n    \"\"\"", "\n", "\n", "def", "_convert_category_id", "(", "segment_info", ",", "meta", ")", ":", "\n", "        ", "if", "segment_info", "[", "\"category_id\"", "]", "in", "meta", "[", "\"thing_dataset_id_to_contiguous_id\"", "]", ":", "\n", "            ", "segment_info", "[", "\"category_id\"", "]", "=", "meta", "[", "\"thing_dataset_id_to_contiguous_id\"", "]", "[", "\n", "segment_info", "[", "\"category_id\"", "]", "\n", "]", "\n", "", "else", ":", "\n", "            ", "segment_info", "[", "\"category_id\"", "]", "=", "meta", "[", "\"stuff_dataset_id_to_contiguous_id\"", "]", "[", "\n", "segment_info", "[", "\"category_id\"", "]", "\n", "]", "\n", "", "return", "segment_info", "\n", "\n", "", "assert", "os", ".", "path", ".", "exists", "(", "\n", "gt_json", "\n", ")", ",", "\"Please run `python cityscapesscripts/preparation/createPanopticImgs.py` to generate label files.\"", "# noqa", "\n", "with", "open", "(", "gt_json", ")", "as", "f", ":", "\n", "        ", "json_info", "=", "json", ".", "load", "(", "f", ")", "\n", "", "files", "=", "get_cityscapes_panoptic_files", "(", "image_dir", ",", "gt_dir", ",", "json_info", ")", "\n", "ret", "=", "[", "]", "\n", "for", "image_file", ",", "label_file", ",", "segments_info", "in", "files", ":", "\n", "        ", "sem_label_file", "=", "(", "\n", "image_file", ".", "replace", "(", "\"leftImg8bit\"", ",", "\"gtFine\"", ")", ".", "split", "(", "\".\"", ")", "[", "0", "]", "+", "\"_labelTrainIds.png\"", "\n", ")", "\n", "segments_info", "=", "[", "_convert_category_id", "(", "x", ",", "meta", ")", "for", "x", "in", "segments_info", "]", "\n", "ret", ".", "append", "(", "\n", "{", "\n", "\"file_name\"", ":", "image_file", ",", "\n", "\"image_id\"", ":", "\"_\"", ".", "join", "(", "\n", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "image_file", ")", ")", "[", "0", "]", ".", "split", "(", "\"_\"", ")", "[", ":", "3", "]", "\n", ")", ",", "\n", "\"sem_seg_file_name\"", ":", "sem_label_file", ",", "\n", "\"pan_seg_file_name\"", ":", "label_file", ",", "\n", "\"segments_info\"", ":", "segments_info", ",", "\n", "}", "\n", ")", "\n", "", "assert", "len", "(", "ret", ")", ",", "f\"No images found in {image_dir}!\"", "\n", "assert", "PathManager", ".", "isfile", "(", "\n", "ret", "[", "0", "]", "[", "\"sem_seg_file_name\"", "]", "\n", ")", ",", "\"Please generate labelTrainIds.png with cityscapesscripts/preparation/createTrainIdLabelImgs.py\"", "# noqa", "\n", "assert", "PathManager", ".", "isfile", "(", "\n", "ret", "[", "0", "]", "[", "\"pan_seg_file_name\"", "]", "\n", ")", ",", "\"Please generate panoptic annotation with python cityscapesscripts/preparation/createPanopticImgs.py\"", "# noqa", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes_panoptic.register_all_cityscapes_panoptic": [[127, 189], ["_RAW_CITYSCAPES_PANOPTIC_SPLITS.items", "os.path.join", "os.path.join", "os.path.join", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "cityscapes_panoptic.load_cityscapes_panoptic", "detectron2.data.MetadataCatalog.get", "os.path.join.replace"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes_panoptic.load_cityscapes_panoptic", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "register_all_cityscapes_panoptic", "(", "root", ")", ":", "\n", "    ", "meta", "=", "{", "}", "\n", "# The following metadata maps contiguous id from [0, #thing categories +", "\n", "# #stuff categories) to their names and colors. We have to replica of the", "\n", "# same name and color under \"thing_*\" and \"stuff_*\" because the current", "\n", "# visualization function in D2 handles thing and class classes differently", "\n", "# due to some heuristic used in Panoptic FPN. We keep the same naming to", "\n", "# enable reusing existing visualization functions.", "\n", "thing_classes", "=", "[", "k", "[", "\"name\"", "]", "for", "k", "in", "CITYSCAPES_CATEGORIES", "]", "\n", "thing_colors", "=", "[", "k", "[", "\"color\"", "]", "for", "k", "in", "CITYSCAPES_CATEGORIES", "]", "\n", "stuff_classes", "=", "[", "k", "[", "\"name\"", "]", "for", "k", "in", "CITYSCAPES_CATEGORIES", "]", "\n", "stuff_colors", "=", "[", "k", "[", "\"color\"", "]", "for", "k", "in", "CITYSCAPES_CATEGORIES", "]", "\n", "\n", "meta", "[", "\"thing_classes\"", "]", "=", "thing_classes", "\n", "meta", "[", "\"thing_colors\"", "]", "=", "thing_colors", "\n", "meta", "[", "\"stuff_classes\"", "]", "=", "stuff_classes", "\n", "meta", "[", "\"stuff_colors\"", "]", "=", "stuff_colors", "\n", "\n", "# There are three types of ids in panoptic:", "\n", "# (1) category id: like semantic segmentation, it is the class id for each", "\n", "#   pixel. Since there are some classes not used in evaluation, the category", "\n", "#   id is not always contiguous and thus we have two set of category ids:", "\n", "#       - original category id: category id in the original dataset, mainly", "\n", "#           used for evaluation.", "\n", "#       - contiguous category id: [0, #classes), in order to train the linear", "\n", "#           softmax classifier.", "\n", "# (2) instance id: this id is used to differentiate different instances from", "\n", "#   the same category. For \"stuff\" classes, the instance id is always 0; for", "\n", "#   \"thing\" classes, the instance id starts from 1 and 0 is reserved for", "\n", "#   ignored instances (e.g. crowd annotation).", "\n", "# (3) panoptic id: this is the compact id that encode both category and", "\n", "#   instance id by: category_id * label_divisor + instance_id. Following", "\n", "#   the Cityscapes format, we set label_divisor = 1000.", "\n", "thing_dataset_id_to_contiguous_id", "=", "{", "}", "\n", "stuff_dataset_id_to_contiguous_id", "=", "{", "}", "\n", "\n", "for", "k", "in", "CITYSCAPES_CATEGORIES", ":", "\n", "        ", "if", "k", "[", "\"isthing\"", "]", "==", "1", ":", "\n", "            ", "thing_dataset_id_to_contiguous_id", "[", "k", "[", "\"id\"", "]", "]", "=", "k", "[", "\"trainId\"", "]", "\n", "", "else", ":", "\n", "            ", "stuff_dataset_id_to_contiguous_id", "[", "k", "[", "\"id\"", "]", "]", "=", "k", "[", "\"trainId\"", "]", "\n", "\n", "", "", "meta", "[", "\"thing_dataset_id_to_contiguous_id\"", "]", "=", "thing_dataset_id_to_contiguous_id", "\n", "meta", "[", "\"stuff_dataset_id_to_contiguous_id\"", "]", "=", "stuff_dataset_id_to_contiguous_id", "\n", "\n", "for", "key", ",", "(", "image_dir", ",", "gt_dir", ",", "gt_json", ")", "in", "_RAW_CITYSCAPES_PANOPTIC_SPLITS", ".", "items", "(", ")", ":", "\n", "        ", "image_dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "image_dir", ")", "\n", "gt_dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "gt_dir", ")", "\n", "gt_json", "=", "os", ".", "path", ".", "join", "(", "root", ",", "gt_json", ")", "\n", "\n", "DatasetCatalog", ".", "register", "(", "\n", "key", ",", "lambda", "x", "=", "image_dir", ",", "y", "=", "gt_dir", ",", "z", "=", "gt_json", ":", "load_cityscapes_panoptic", "(", "x", ",", "y", ",", "z", ",", "meta", ")", "\n", ")", "\n", "MetadataCatalog", ".", "get", "(", "key", ")", ".", "set", "(", "\n", "panoptic_root", "=", "gt_dir", ",", "\n", "image_root", "=", "image_dir", ",", "\n", "panoptic_json", "=", "gt_json", ",", "\n", "gt_dir", "=", "gt_dir", ".", "replace", "(", "\"cityscapes_panoptic_\"", ",", "\"\"", ")", ",", "\n", "evaluator_type", "=", "\"cityscapes_panoptic_seg\"", ",", "\n", "ignore_label", "=", "255", ",", "\n", "label_divisor", "=", "1000", ",", "\n", "**", "meta", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.load_coco_json": [[239, 281], ["coco._load_coco_annotations", "coco._add_categories_metadata", "sorted", "_load_coco_annotations.loadImgs", "logging.getLogger", "logging.getLogger.info", "coco._verify_annotations_have_unique_ids", "coco._combine_images_with_annotations", "fvcore.common.file_io.PathManager.get_local_path", "_load_coco_annotations.loadCats", "_load_coco_annotations.imgs.keys", "_load_coco_annotations.getCatIds", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._load_coco_annotations", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._add_categories_metadata", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._verify_annotations_have_unique_ids", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._combine_images_with_annotations"], ["# remove file extension", "\n", "image_id", "=", "os", ".", "path", ".", "splitext", "(", "image_id", ")", "[", "0", "]", "\n", "return", "image_id", "\n", "\n", "", "input_files", "=", "sorted", "(", "\n", "(", "os", ".", "path", ".", "join", "(", "image_root", ",", "f", ")", "for", "f", "in", "PathManager", ".", "ls", "(", "image_root", ")", "if", "f", ".", "endswith", "(", "image_ext", ")", ")", ",", "\n", "key", "=", "lambda", "file_path", ":", "file2id", "(", "image_root", ",", "file_path", ")", ",", "\n", ")", "\n", "gt_files", "=", "sorted", "(", "\n", "(", "os", ".", "path", ".", "join", "(", "gt_root", ",", "f", ")", "for", "f", "in", "PathManager", ".", "ls", "(", "gt_root", ")", "if", "f", ".", "endswith", "(", "gt_ext", ")", ")", ",", "\n", "key", "=", "lambda", "file_path", ":", "file2id", "(", "gt_root", ",", "file_path", ")", ",", "\n", ")", "\n", "\n", "assert", "len", "(", "gt_files", ")", ">", "0", ",", "\"No annotations found in {}.\"", ".", "format", "(", "gt_root", ")", "\n", "\n", "# Use the intersection, so that val2017_100 annotations can run smoothly with val2017 images", "\n", "if", "len", "(", "input_files", ")", "!=", "len", "(", "gt_files", ")", ":", "\n", "        ", "logger", ".", "warn", "(", "\n", "\"Directory {} and {} has {} and {} files, respectively.\"", ".", "format", "(", "\n", "image_root", ",", "gt_root", ",", "len", "(", "input_files", ")", ",", "len", "(", "gt_files", ")", "\n", ")", "\n", ")", "\n", "input_basenames", "=", "[", "os", ".", "path", ".", "basename", "(", "f", ")", "[", ":", "-", "len", "(", "image_ext", ")", "]", "for", "f", "in", "input_files", "]", "\n", "gt_basenames", "=", "[", "os", ".", "path", ".", "basename", "(", "f", ")", "[", ":", "-", "len", "(", "gt_ext", ")", "]", "for", "f", "in", "gt_files", "]", "\n", "intersect", "=", "list", "(", "set", "(", "input_basenames", ")", "&", "set", "(", "gt_basenames", ")", ")", "\n", "# sort, otherwise each worker may obtain a list[dict] in different order", "\n", "intersect", "=", "sorted", "(", "intersect", ")", "\n", "logger", ".", "warn", "(", "\"Will use their intersection of {} files.\"", ".", "format", "(", "len", "(", "intersect", ")", ")", ")", "\n", "input_files", "=", "[", "os", ".", "path", ".", "join", "(", "image_root", ",", "f", "+", "image_ext", ")", "for", "f", "in", "intersect", "]", "\n", "gt_files", "=", "[", "os", ".", "path", ".", "join", "(", "gt_root", ",", "f", "+", "gt_ext", ")", "for", "f", "in", "intersect", "]", "\n", "\n", "", "logger", ".", "info", "(", "\n", "\"Loaded {} images with semantic segmentation from {}\"", ".", "format", "(", "len", "(", "input_files", ")", ",", "image_root", ")", "\n", ")", "\n", "\n", "dataset_dicts", "=", "[", "]", "\n", "for", "(", "img_path", ",", "gt_path", ")", "in", "zip", "(", "input_files", ",", "gt_files", ")", ":", "\n", "        ", "record", "=", "{", "}", "\n", "record", "[", "\"file_name\"", "]", "=", "img_path", "\n", "record", "[", "\"sem_seg_file_name\"", "]", "=", "gt_path", "\n", "dataset_dicts", ".", "append", "(", "record", ")", "\n", "\n", "", "return", "dataset_dicts", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.load_sem_seg": [[208, 282], ["sorted", "sorted", "logger.info", "zip", "os.path.normpath", "len", "len", "len", "logger.warn", "list", "sorted", "logger.warn", "dataset_dicts.append", "os.path.relpath", "os.path.splitext", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "len", "fvcore.common.file_io.PathManager.ls", "f.endswith", "coco.load_sem_seg.file2id"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "load_sem_seg", "(", "gt_root", ",", "image_root", ",", "gt_ext", "=", "\"png\"", ",", "image_ext", "=", "\"jpg\"", ")", ":", "\n", "    ", "\"\"\"\n    Load semantic segmentation datasets. All files under \"gt_root\" with \"gt_ext\" extension are\n    treated as ground truth annotations and all files under \"image_root\" with \"image_ext\" extension\n    as input images. Ground truth and input images are matched using file paths relative to\n    \"gt_root\" and \"image_root\" respectively without taking into account file extensions.\n    This works for COCO as well as some other datasets.\n\n    Args:\n        gt_root (str): full path to ground truth semantic segmentation files. Semantic segmentation\n            annotations are stored as images with integer values in pixels that represent\n            corresponding semantic labels.\n        image_root (str): the directory where the input images are.\n        gt_ext (str): file extension for ground truth annotations.\n        image_ext (str): file extension for input images.\n\n    Returns:\n        list[dict]:\n            a list of dicts in detectron2 standard format without instance-level\n            annotation.\n\n    Notes:\n        1. This function does not read the image and ground truth files.\n           The results do not have the \"image\" and \"sem_seg\" fields.\n    \"\"\"", "\n", "\n", "# We match input images with ground truth based on their relative filepaths (without file", "\n", "# extensions) starting from 'image_root' and 'gt_root' respectively.", "\n", "def", "file2id", "(", "folder_path", ",", "file_path", ")", ":", "\n", "# extract relative path starting from `folder_path`", "\n", "        ", "image_id", "=", "os", ".", "path", ".", "normpath", "(", "os", ".", "path", ".", "relpath", "(", "file_path", ",", "start", "=", "folder_path", ")", ")", "\n", "# remove file extension", "\n", "image_id", "=", "os", ".", "path", ".", "splitext", "(", "image_id", ")", "[", "0", "]", "\n", "return", "image_id", "\n", "\n", "", "input_files", "=", "sorted", "(", "\n", "(", "os", ".", "path", ".", "join", "(", "image_root", ",", "f", ")", "for", "f", "in", "PathManager", ".", "ls", "(", "image_root", ")", "if", "f", ".", "endswith", "(", "image_ext", ")", ")", ",", "\n", "key", "=", "lambda", "file_path", ":", "file2id", "(", "image_root", ",", "file_path", ")", ",", "\n", ")", "\n", "gt_files", "=", "sorted", "(", "\n", "(", "os", ".", "path", ".", "join", "(", "gt_root", ",", "f", ")", "for", "f", "in", "PathManager", ".", "ls", "(", "gt_root", ")", "if", "f", ".", "endswith", "(", "gt_ext", ")", ")", ",", "\n", "key", "=", "lambda", "file_path", ":", "file2id", "(", "gt_root", ",", "file_path", ")", ",", "\n", ")", "\n", "\n", "assert", "len", "(", "gt_files", ")", ">", "0", ",", "\"No annotations found in {}.\"", ".", "format", "(", "gt_root", ")", "\n", "\n", "# Use the intersection, so that val2017_100 annotations can run smoothly with val2017 images", "\n", "if", "len", "(", "input_files", ")", "!=", "len", "(", "gt_files", ")", ":", "\n", "        ", "logger", ".", "warn", "(", "\n", "\"Directory {} and {} has {} and {} files, respectively.\"", ".", "format", "(", "\n", "image_root", ",", "gt_root", ",", "len", "(", "input_files", ")", ",", "len", "(", "gt_files", ")", "\n", ")", "\n", ")", "\n", "input_basenames", "=", "[", "os", ".", "path", ".", "basename", "(", "f", ")", "[", ":", "-", "len", "(", "image_ext", ")", "]", "for", "f", "in", "input_files", "]", "\n", "gt_basenames", "=", "[", "os", ".", "path", ".", "basename", "(", "f", ")", "[", ":", "-", "len", "(", "gt_ext", ")", "]", "for", "f", "in", "gt_files", "]", "\n", "intersect", "=", "list", "(", "set", "(", "input_basenames", ")", "&", "set", "(", "gt_basenames", ")", ")", "\n", "# sort, otherwise each worker may obtain a list[dict] in different order", "\n", "intersect", "=", "sorted", "(", "intersect", ")", "\n", "logger", ".", "warn", "(", "\"Will use their intersection of {} files.\"", ".", "format", "(", "len", "(", "intersect", ")", ")", ")", "\n", "input_files", "=", "[", "os", ".", "path", ".", "join", "(", "image_root", ",", "f", "+", "image_ext", ")", "for", "f", "in", "intersect", "]", "\n", "gt_files", "=", "[", "os", ".", "path", ".", "join", "(", "gt_root", ",", "f", "+", "gt_ext", ")", "for", "f", "in", "intersect", "]", "\n", "\n", "", "logger", ".", "info", "(", "\n", "\"Loaded {} images with semantic segmentation from {}\"", ".", "format", "(", "len", "(", "input_files", ")", ",", "image_root", ")", "\n", ")", "\n", "\n", "dataset_dicts", "=", "[", "]", "\n", "for", "(", "img_path", ",", "gt_path", ")", "in", "zip", "(", "input_files", ",", "gt_files", ")", ":", "\n", "        ", "record", "=", "{", "}", "\n", "record", "[", "\"file_name\"", "]", "=", "img_path", "\n", "record", "[", "\"sem_seg_file_name\"", "]", "=", "gt_path", "\n", "dataset_dicts", ".", "append", "(", "record", ")", "\n", "\n", "", "return", "dataset_dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.convert_to_coco_dict": [[284, 411], ["DatasetCatalog.get", "MetadataCatalog.get", "hasattr", "logger.info", "enumerate", "logger.info", "coco_images.append", "image_dict.get", "str", "len", "reverse_id_mapper", "enumerate", "image_dict.get", "int", "int", "str", "detectron2.structures.BoxMode.convert", "float", "int", "int", "coco_annotations.append", "datetime.datetime.now", "MetadataCatalog.get.thing_dataset_id_to_contiguous_id.items", "isinstance", "detectron2.structures.BoxMode.convert", "[].item", "enumerate", "len", "round", "annotation.get", "reverse_id_mapper", "isinstance", "len", "len", "detectron2.structures.PolygonMasks", "[].item", "isinstance", "sum", "float", "pycocotools.area().item", "TypeError", "isinstance", "counts.decode", "detectron2.structures.Boxes().area", "detectron2.structures.PolygonMasks.area", "pycocotools.area", "type", "detectron2.structures.Boxes"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area"], ["", "def", "convert_to_coco_dict", "(", "dataset_name", ")", ":", "\n", "    ", "\"\"\"\n    Convert an instance detection/segmentation or keypoint detection dataset\n    in detectron2's standard format into COCO json format.\n\n    Generic dataset description can be found here:\n    https://detectron2.readthedocs.io/tutorials/datasets.html#register-a-dataset\n\n    COCO data format description can be found here:\n    http://cocodataset.org/#format-data\n\n    Args:\n        dataset_name (str):\n            name of the source dataset\n            Must be registered in DatastCatalog and in detectron2's standard format.\n            Must have corresponding metadata \"thing_classes\"\n    Returns:\n        coco_dict: serializable dict in COCO json format\n    \"\"\"", "\n", "\n", "dataset_dicts", "=", "DatasetCatalog", ".", "get", "(", "dataset_name", ")", "\n", "metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "\n", "# unmap the category mapping ids for COCO", "\n", "if", "hasattr", "(", "metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n", "        ", "reverse_id_mapping", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "}", "\n", "reverse_id_mapper", "=", "lambda", "contiguous_id", ":", "reverse_id_mapping", "[", "contiguous_id", "]", "# noqa", "\n", "", "else", ":", "\n", "        ", "reverse_id_mapper", "=", "lambda", "contiguous_id", ":", "contiguous_id", "# noqa", "\n", "\n", "", "categories", "=", "[", "\n", "{", "\"id\"", ":", "reverse_id_mapper", "(", "id", ")", ",", "\"name\"", ":", "name", "}", "\n", "for", "id", ",", "name", "in", "enumerate", "(", "metadata", ".", "thing_classes", ")", "\n", "]", "\n", "\n", "logger", ".", "info", "(", "\"Converting dataset dicts into COCO format\"", ")", "\n", "coco_images", "=", "[", "]", "\n", "coco_annotations", "=", "[", "]", "\n", "\n", "for", "image_id", ",", "image_dict", "in", "enumerate", "(", "dataset_dicts", ")", ":", "\n", "        ", "coco_image", "=", "{", "\n", "\"id\"", ":", "image_dict", ".", "get", "(", "\"image_id\"", ",", "image_id", ")", ",", "\n", "\"width\"", ":", "int", "(", "image_dict", "[", "\"width\"", "]", ")", ",", "\n", "\"height\"", ":", "int", "(", "image_dict", "[", "\"height\"", "]", ")", ",", "\n", "\"file_name\"", ":", "str", "(", "image_dict", "[", "\"file_name\"", "]", ")", ",", "\n", "}", "\n", "coco_images", ".", "append", "(", "coco_image", ")", "\n", "\n", "anns_per_image", "=", "image_dict", ".", "get", "(", "\"annotations\"", ",", "[", "]", ")", "\n", "for", "annotation", "in", "anns_per_image", ":", "\n", "# create a new dict with only COCO fields", "\n", "            ", "coco_annotation", "=", "{", "}", "\n", "\n", "# COCO requirement: XYWH box format", "\n", "bbox", "=", "annotation", "[", "\"bbox\"", "]", "\n", "bbox_mode", "=", "annotation", "[", "\"bbox_mode\"", "]", "\n", "bbox", "=", "BoxMode", ".", "convert", "(", "bbox", ",", "bbox_mode", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "\n", "# COCO requirement: instance area", "\n", "if", "\"segmentation\"", "in", "annotation", ":", "\n", "# Computing areas for instances by counting the pixels", "\n", "                ", "segmentation", "=", "annotation", "[", "\"segmentation\"", "]", "\n", "# TODO: check segmentation type: RLE, BinaryMask or Polygon", "\n", "if", "isinstance", "(", "segmentation", ",", "list", ")", ":", "\n", "                    ", "polygons", "=", "PolygonMasks", "(", "[", "segmentation", "]", ")", "\n", "area", "=", "polygons", ".", "area", "(", ")", "[", "0", "]", ".", "item", "(", ")", "\n", "", "elif", "isinstance", "(", "segmentation", ",", "dict", ")", ":", "# RLE", "\n", "                    ", "area", "=", "mask_util", ".", "area", "(", "segmentation", ")", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "TypeError", "(", "f\"Unknown segmentation type {type(segmentation)}!\"", ")", "\n", "", "", "else", ":", "\n", "# Computing areas using bounding boxes", "\n", "                ", "bbox_xy", "=", "BoxMode", ".", "convert", "(", "bbox", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "area", "=", "Boxes", "(", "[", "bbox_xy", "]", ")", ".", "area", "(", ")", "[", "0", "]", ".", "item", "(", ")", "\n", "\n", "", "if", "\"keypoints\"", "in", "annotation", ":", "\n", "                ", "keypoints", "=", "annotation", "[", "\"keypoints\"", "]", "# list[int]", "\n", "for", "idx", ",", "v", "in", "enumerate", "(", "keypoints", ")", ":", "\n", "                    ", "if", "idx", "%", "3", "!=", "2", ":", "\n", "# COCO's segmentation coordinates are floating points in [0, H or W],", "\n", "# but keypoint coordinates are integers in [0, H-1 or W-1]", "\n", "# For COCO format consistency we substract 0.5", "\n", "# https://github.com/facebookresearch/detectron2/pull/175#issuecomment-551202163", "\n", "                        ", "keypoints", "[", "idx", "]", "=", "v", "-", "0.5", "\n", "", "", "if", "\"num_keypoints\"", "in", "annotation", ":", "\n", "                    ", "num_keypoints", "=", "annotation", "[", "\"num_keypoints\"", "]", "\n", "", "else", ":", "\n", "                    ", "num_keypoints", "=", "sum", "(", "kp", ">", "0", "for", "kp", "in", "keypoints", "[", "2", ":", ":", "3", "]", ")", "\n", "\n", "# COCO requirement:", "\n", "#   linking annotations to images", "\n", "#   \"id\" field must start with 1", "\n", "", "", "coco_annotation", "[", "\"id\"", "]", "=", "len", "(", "coco_annotations", ")", "+", "1", "\n", "coco_annotation", "[", "\"image_id\"", "]", "=", "coco_image", "[", "\"id\"", "]", "\n", "coco_annotation", "[", "\"bbox\"", "]", "=", "[", "round", "(", "float", "(", "x", ")", ",", "3", ")", "for", "x", "in", "bbox", "]", "\n", "coco_annotation", "[", "\"area\"", "]", "=", "float", "(", "area", ")", "\n", "coco_annotation", "[", "\"iscrowd\"", "]", "=", "int", "(", "annotation", ".", "get", "(", "\"iscrowd\"", ",", "0", ")", ")", "\n", "coco_annotation", "[", "\"category_id\"", "]", "=", "int", "(", "reverse_id_mapper", "(", "annotation", "[", "\"category_id\"", "]", ")", ")", "\n", "\n", "# Add optional fields", "\n", "if", "\"keypoints\"", "in", "annotation", ":", "\n", "                ", "coco_annotation", "[", "\"keypoints\"", "]", "=", "keypoints", "\n", "coco_annotation", "[", "\"num_keypoints\"", "]", "=", "num_keypoints", "\n", "\n", "", "if", "\"segmentation\"", "in", "annotation", ":", "\n", "                ", "seg", "=", "coco_annotation", "[", "\"segmentation\"", "]", "=", "annotation", "[", "\"segmentation\"", "]", "\n", "if", "isinstance", "(", "seg", ",", "dict", ")", ":", "# RLE", "\n", "                    ", "counts", "=", "seg", "[", "\"counts\"", "]", "\n", "if", "not", "isinstance", "(", "counts", ",", "str", ")", ":", "\n", "# make it json-serializable", "\n", "                        ", "seg", "[", "\"counts\"", "]", "=", "counts", ".", "decode", "(", "\"ascii\"", ")", "\n", "\n", "", "", "", "coco_annotations", ".", "append", "(", "coco_annotation", ")", "\n", "\n", "", "", "logger", ".", "info", "(", "\n", "\"Conversion finished, \"", "\n", "f\"#images: {len(coco_images)}, #annotations: {len(coco_annotations)}\"", "\n", ")", "\n", "\n", "info", "=", "{", "\n", "\"date_created\"", ":", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ")", ",", "\n", "\"description\"", ":", "\"Automatically generated COCO json file for Detectron2.\"", ",", "\n", "}", "\n", "coco_dict", "=", "{", "\"info\"", ":", "info", ",", "\"images\"", ":", "coco_images", ",", "\"categories\"", ":", "categories", ",", "\"licenses\"", ":", "None", "}", "\n", "if", "len", "(", "coco_annotations", ")", ">", "0", ":", "\n", "        ", "coco_dict", "[", "\"annotations\"", "]", "=", "coco_annotations", "\n", "", "return", "coco_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.convert_to_coco_json": [[413, 445], ["fvcore.common.file_io.PathManager.mkdirs", "os.path.dirname", "fvcore.common.file_io.file_lock", "fvcore.common.file_io.PathManager.exists", "logger.warning", "logger.info", "coco.convert_to_coco_dict", "logger.info", "shutil.move", "fvcore.common.file_io.PathManager.open", "json.dump"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.convert_to_coco_dict", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump"], ["", "def", "convert_to_coco_json", "(", "dataset_name", ",", "output_file", ",", "allow_cached", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Converts dataset into COCO format and saves it to a json file.\n    dataset_name must be registered in DatasetCatalog and in detectron2's standard format.\n\n    Args:\n        dataset_name:\n            reference from the config file to the catalogs\n            must be registered in DatasetCatalog and in detectron2's standard format\n        output_file: path of json file that will be saved to\n        allow_cached: if json file is already present then skip conversion\n    \"\"\"", "\n", "\n", "# TODO: The dataset or the conversion script *may* change,", "\n", "# a checksum would be useful for validating the cached data", "\n", "\n", "PathManager", ".", "mkdirs", "(", "os", ".", "path", ".", "dirname", "(", "output_file", ")", ")", "\n", "with", "file_lock", "(", "output_file", ")", ":", "\n", "        ", "if", "PathManager", ".", "exists", "(", "output_file", ")", "and", "allow_cached", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "f\"Using previously cached COCO format annotations at '{output_file}'. \"", "\n", "\"You need to clear the cache file if your dataset has been modified.\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Converting annotations of dataset '{dataset_name}' to COCO format ...)\"", ")", "\n", "coco_dict", "=", "convert_to_coco_dict", "(", "dataset_name", ")", "\n", "\n", "logger", ".", "info", "(", "f\"Caching COCO format annotations at '{output_file}' ...\"", ")", "\n", "tmp_file", "=", "output_file", "+", "\".tmp\"", "\n", "with", "PathManager", ".", "open", "(", "tmp_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "json", ".", "dump", "(", "coco_dict", ",", "f", ")", "\n", "", "shutil", ".", "move", "(", "tmp_file", ",", "output_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.pascal_voc_basic.load_voc_instances": [[29, 90], ["fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.file_io.PathManager.open", "numpy.loadtxt", "os.path.join", "os.path.join", "os.path.join", "ET.parse.findall", "dicts.append", "os.path.join", "fileid.replace.replace", "fvcore.common.file_io.PathManager.open", "xml.parse", "int", "int", "obj.find", "instances.append", "obj.find", "float", "class_names.index", "ET.parse.findall", "ET.parse.findall", "obj.find.find"], "function", ["None"], ["def", "load_voc_instances", "(", "dirname", ":", "str", ",", "split", ":", "str", ",", "class_names", ":", "Union", "[", "List", "[", "str", "]", ",", "Tuple", "[", "str", ",", "...", "]", "]", ")", ":", "\n", "    ", "\"\"\"\n    Load Pascal VOC detection annotations to Detectron2 format.\n\n    Args:\n        dirname: Contain \"Annotations\", \"ImageSets\", \"JPEGImages\"\n        split (str): one of \"train\", \"test\", \"val\", \"trainval\"\n        class_names: list or tuple of class names\n    \"\"\"", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"ImageSets\"", ",", "\"Main\"", ",", "split", "+", "\".txt\"", ")", ")", "as", "f", ":", "\n", "        ", "fileids", "=", "np", ".", "loadtxt", "(", "f", ",", "dtype", "=", "np", ".", "str", ")", "\n", "\n", "# Needs to read many small annotation files. Makes sense at local", "\n", "", "annotation_dirname", "=", "PathManager", ".", "get_local_path", "(", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"Annotations/\"", ")", ")", "\n", "dicts", "=", "[", "]", "\n", "for", "fileid", "in", "fileids", ":", "\n", "        ", "has_unk", "=", "False", "\n", "if", "'unk'", "in", "fileid", ":", "\n", "            ", "has_unk", "=", "True", "\n", "fileid", "=", "fileid", ".", "replace", "(", "'_unk'", ",", "''", ")", "\n", "\n", "", "anno_file", "=", "os", ".", "path", ".", "join", "(", "annotation_dirname", ",", "fileid", "+", "\".xml\"", ")", "\n", "jpeg_file", "=", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"JPEGImages\"", ",", "fileid", "+", "\".jpg\"", ")", "\n", "\n", "with", "PathManager", ".", "open", "(", "anno_file", ")", "as", "f", ":", "\n", "            ", "tree", "=", "ET", ".", "parse", "(", "f", ")", "\n", "\n", "", "r", "=", "{", "\n", "\"file_name\"", ":", "jpeg_file", ",", "\n", "\"image_id\"", ":", "fileid", ",", "\n", "\"height\"", ":", "int", "(", "tree", ".", "findall", "(", "\"./size/height\"", ")", "[", "0", "]", ".", "text", ")", ",", "\n", "\"width\"", ":", "int", "(", "tree", ".", "findall", "(", "\"./size/width\"", ")", "[", "0", "]", ".", "text", ")", ",", "\n", "}", "\n", "instances", "=", "[", "]", "\n", "\n", "for", "obj", "in", "tree", ".", "findall", "(", "\"object\"", ")", ":", "\n", "            ", "cls", "=", "obj", ".", "find", "(", "\"name\"", ")", ".", "text", "\n", "if", "has_unk", ":", "\n", "                ", "if", "cls", "not", "in", "class_names", ":", "\n", "                    ", "cls", "=", "'unknown'", "\n", "# else:", "\n", "#     continue", "\n", "# We include \"difficult\" samples in training.", "\n", "# Based on limited experiments, they don't hurt accuracy.", "\n", "# difficult = int(obj.find(\"difficult\").text)", "\n", "# if difficult == 1:", "\n", "# continue", "\n", "", "", "bbox", "=", "obj", ".", "find", "(", "\"bndbox\"", ")", "\n", "bbox", "=", "[", "float", "(", "bbox", ".", "find", "(", "x", ")", ".", "text", ")", "for", "x", "in", "[", "\"xmin\"", ",", "\"ymin\"", ",", "\"xmax\"", ",", "\"ymax\"", "]", "]", "\n", "# Original annotations are integers in the range [1, W or H]", "\n", "# Assuming they mean 1-based pixel indices (inclusive),", "\n", "# a box with annotation (xmin=1, xmax=W) covers the whole image.", "\n", "# In coordinate space this is represented by (xmin=0, xmax=W)", "\n", "bbox", "[", "0", "]", "-=", "1.0", "\n", "bbox", "[", "1", "]", "-=", "1.0", "\n", "instances", ".", "append", "(", "\n", "{", "\"category_id\"", ":", "class_names", ".", "index", "(", "cls", ")", ",", "\"bbox\"", ":", "bbox", ",", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", "}", "\n", ")", "\n", "", "r", "[", "\"annotations\"", "]", "=", "instances", "\n", "dicts", ".", "append", "(", "r", ")", "\n", "", "return", "dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.pascal_voc_basic.register_pascal_voc": [[92, 96], ["detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "pascal_voc_basic.load_voc_instances", "detectron2.data.MetadataCatalog.get", "list"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.pascal_voc.load_voc_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "register_pascal_voc", "(", "name", ",", "dirname", ",", "split", ",", "year", ",", "class_names", "=", "CLASS_NAMES", ")", ":", "\n", "    ", "DatasetCatalog", ".", "register", "(", "name", ",", "lambda", ":", "load_voc_instances", "(", "dirname", ",", "split", ",", "class_names", ")", ")", "\n", "MetadataCatalog", ".", "get", "(", "name", ")", ".", "set", "(", "\n", "thing_classes", "=", "list", "(", "class_names", ")", ",", "dirname", "=", "dirname", ",", "year", "=", "year", ",", "split", "=", "split", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_coco_instances_meta": [[222, 235], ["len", "len", "enumerate"], "function", ["None"], ["def", "_get_coco_instances_meta", "(", ")", ":", "\n", "    ", "thing_ids", "=", "[", "k", "[", "\"id\"", "]", "for", "k", "in", "COCO_CATEGORIES", "if", "k", "[", "\"isthing\"", "]", "==", "1", "]", "\n", "thing_colors", "=", "[", "k", "[", "\"color\"", "]", "for", "k", "in", "COCO_CATEGORIES", "if", "k", "[", "\"isthing\"", "]", "==", "1", "]", "\n", "assert", "len", "(", "thing_ids", ")", "==", "80", ",", "len", "(", "thing_ids", ")", "\n", "# Mapping from the incontiguous COCO category id to an id in [0, 79]", "\n", "thing_dataset_id_to_contiguous_id", "=", "{", "k", ":", "i", "for", "i", ",", "k", "in", "enumerate", "(", "thing_ids", ")", "}", "\n", "thing_classes", "=", "[", "k", "[", "\"name\"", "]", "for", "k", "in", "COCO_CATEGORIES", "if", "k", "[", "\"isthing\"", "]", "==", "1", "]", "\n", "ret", "=", "{", "\n", "\"thing_dataset_id_to_contiguous_id\"", ":", "thing_dataset_id_to_contiguous_id", ",", "\n", "\"thing_classes\"", ":", "thing_classes", ",", "\n", "\"thing_colors\"", ":", "thing_colors", ",", "\n", "}", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_coco_panoptic_separated_meta": [[237, 268], ["len", "ret.update", "len", "builtin_meta._get_coco_instances_meta", "enumerate", "k[].replace().replace", "k[].replace"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_coco_instances_meta"], ["", "def", "_get_coco_panoptic_separated_meta", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns metadata for \"separated\" version of the panoptic segmentation dataset.\n    \"\"\"", "\n", "stuff_ids", "=", "[", "k", "[", "\"id\"", "]", "for", "k", "in", "COCO_CATEGORIES", "if", "k", "[", "\"isthing\"", "]", "==", "0", "]", "\n", "assert", "len", "(", "stuff_ids", ")", "==", "53", ",", "len", "(", "stuff_ids", ")", "\n", "\n", "# For semantic segmentation, this mapping maps from contiguous stuff id", "\n", "# (in [0, 53], used in models) to ids in the dataset (used for processing results)", "\n", "# The id 0 is mapped to an extra category \"thing\".", "\n", "stuff_dataset_id_to_contiguous_id", "=", "{", "k", ":", "i", "+", "1", "for", "i", ",", "k", "in", "enumerate", "(", "stuff_ids", ")", "}", "\n", "# When converting COCO panoptic annotations to semantic annotations", "\n", "# We label the \"thing\" category to 0", "\n", "stuff_dataset_id_to_contiguous_id", "[", "0", "]", "=", "0", "\n", "\n", "# 54 names for COCO stuff categories (including \"things\")", "\n", "stuff_classes", "=", "[", "\"things\"", "]", "+", "[", "\n", "k", "[", "\"name\"", "]", ".", "replace", "(", "\"-other\"", ",", "\"\"", ")", ".", "replace", "(", "\"-merged\"", ",", "\"\"", ")", "\n", "for", "k", "in", "COCO_CATEGORIES", "\n", "if", "k", "[", "\"isthing\"", "]", "==", "0", "\n", "]", "\n", "\n", "# NOTE: I randomly picked a color for things", "\n", "stuff_colors", "=", "[", "[", "82", ",", "18", ",", "128", "]", "]", "+", "[", "k", "[", "\"color\"", "]", "for", "k", "in", "COCO_CATEGORIES", "if", "k", "[", "\"isthing\"", "]", "==", "0", "]", "\n", "ret", "=", "{", "\n", "\"stuff_dataset_id_to_contiguous_id\"", ":", "stuff_dataset_id_to_contiguous_id", ",", "\n", "\"stuff_classes\"", ":", "stuff_classes", ",", "\n", "\"stuff_colors\"", ":", "stuff_colors", ",", "\n", "}", "\n", "ret", ".", "update", "(", "_get_coco_instances_meta", "(", ")", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_builtin_metadata": [[270, 299], ["KeyError", "builtin_meta._get_coco_instances_meta", "builtin_meta._get_coco_panoptic_separated_meta"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_coco_instances_meta", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_coco_panoptic_separated_meta"], ["", "def", "_get_builtin_metadata", "(", "dataset_name", ")", ":", "\n", "    ", "if", "dataset_name", "==", "\"coco\"", ":", "\n", "        ", "return", "_get_coco_instances_meta", "(", ")", "\n", "", "if", "dataset_name", "==", "\"coco_panoptic_separated\"", ":", "\n", "        ", "return", "_get_coco_panoptic_separated_meta", "(", ")", "\n", "", "elif", "dataset_name", "==", "\"coco_person\"", ":", "\n", "        ", "return", "{", "\n", "\"thing_classes\"", ":", "[", "\"person\"", "]", ",", "\n", "\"keypoint_names\"", ":", "COCO_PERSON_KEYPOINT_NAMES", ",", "\n", "\"keypoint_flip_map\"", ":", "COCO_PERSON_KEYPOINT_FLIP_MAP", ",", "\n", "\"keypoint_connection_rules\"", ":", "KEYPOINT_CONNECTION_RULES", ",", "\n", "}", "\n", "", "elif", "dataset_name", "==", "\"cityscapes\"", ":", "\n", "# fmt: off", "\n", "        ", "CITYSCAPES_THING_CLASSES", "=", "[", "\n", "\"person\"", ",", "\"rider\"", ",", "\"car\"", ",", "\"truck\"", ",", "\n", "\"bus\"", ",", "\"train\"", ",", "\"motorcycle\"", ",", "\"bicycle\"", ",", "\n", "]", "\n", "CITYSCAPES_STUFF_CLASSES", "=", "[", "\n", "\"road\"", ",", "\"sidewalk\"", ",", "\"building\"", ",", "\"wall\"", ",", "\"fence\"", ",", "\"pole\"", ",", "\"traffic light\"", ",", "\n", "\"traffic sign\"", ",", "\"vegetation\"", ",", "\"terrain\"", ",", "\"sky\"", ",", "\"person\"", ",", "\"rider\"", ",", "\"car\"", ",", "\n", "\"truck\"", ",", "\"bus\"", ",", "\"train\"", ",", "\"motorcycle\"", ",", "\"bicycle\"", ",", "\n", "]", "\n", "# fmt: on", "\n", "return", "{", "\n", "\"thing_classes\"", ":", "CITYSCAPES_THING_CLASSES", ",", "\n", "\"stuff_classes\"", ":", "CITYSCAPES_STUFF_CLASSES", ",", "\n", "}", "\n", "", "raise", "KeyError", "(", "\"No built-in metadata for dataset {}\"", ".", "format", "(", "dataset_name", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes.get_cityscapes_files": [[27, 51], ["fvcore.common.file_io.PathManager.ls", "logger.info", "len", "os.path.join", "os.path.join", "fvcore.common.file_io.PathManager.ls", "fvcore.common.file_io.PathManager.isfile", "os.path.join", "basename.endswith", "os.path.join", "os.path.join", "os.path.join", "files.append", "len", "len"], "function", ["None"], ["def", "get_cityscapes_files", "(", "image_dir", ",", "gt_dir", ")", ":", "\n", "    ", "files", "=", "[", "]", "\n", "# scan through the directory", "\n", "cities", "=", "PathManager", ".", "ls", "(", "image_dir", ")", "\n", "logger", ".", "info", "(", "f\"{len(cities)} cities found in '{image_dir}'.\"", ")", "\n", "for", "city", "in", "cities", ":", "\n", "        ", "city_img_dir", "=", "os", ".", "path", ".", "join", "(", "image_dir", ",", "city", ")", "\n", "city_gt_dir", "=", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "city", ")", "\n", "for", "basename", "in", "PathManager", ".", "ls", "(", "city_img_dir", ")", ":", "\n", "            ", "image_file", "=", "os", ".", "path", ".", "join", "(", "city_img_dir", ",", "basename", ")", "\n", "\n", "suffix", "=", "\"leftImg8bit.png\"", "\n", "assert", "basename", ".", "endswith", "(", "suffix", ")", ",", "basename", "\n", "basename", "=", "basename", "[", ":", "-", "len", "(", "suffix", ")", "]", "\n", "\n", "instance_file", "=", "os", ".", "path", ".", "join", "(", "city_gt_dir", ",", "basename", "+", "\"gtFine_instanceIds.png\"", ")", "\n", "label_file", "=", "os", ".", "path", ".", "join", "(", "city_gt_dir", ",", "basename", "+", "\"gtFine_labelIds.png\"", ")", "\n", "json_file", "=", "os", ".", "path", ".", "join", "(", "city_gt_dir", ",", "basename", "+", "\"gtFine_polygons.json\"", ")", "\n", "\n", "files", ".", "append", "(", "(", "image_file", ",", "instance_file", ",", "label_file", ",", "json_file", ")", ")", "\n", "", "", "assert", "len", "(", "files", ")", ",", "\"No images found in {}\"", ".", "format", "(", "image_dir", ")", "\n", "for", "f", "in", "files", "[", "0", "]", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "f", ")", ",", "f", "\n", "", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes.load_cityscapes_instances": [[53, 93], ["cityscapes.get_cityscapes_files", "logger.info", "multiprocessing.Pool", "mp.Pool.map", "logger.info", "functools.partial", "max", "len", "enumerate", "multiprocessing.cpu_count", "detectron2.utils.comm.get_world_size"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes.get_cityscapes_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], ["", "def", "load_cityscapes_instances", "(", "image_dir", ",", "gt_dir", ",", "from_json", "=", "True", ",", "to_polygons", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        image_dir (str): path to the raw dataset. e.g., \"~/cityscapes/leftImg8bit/train\".\n        gt_dir (str): path to the raw annotations. e.g., \"~/cityscapes/gtFine/train\".\n        from_json (bool): whether to read annotations from the raw json file or the png files.\n        to_polygons (bool): whether to represent the segmentation as polygons\n            (COCO's format) instead of masks (cityscapes's format).\n\n    Returns:\n        list[dict]: a list of dicts in Detectron2 standard format. (See\n        `Using Custom Datasets </tutorials/datasets.html>`_ )\n    \"\"\"", "\n", "if", "from_json", ":", "\n", "        ", "assert", "to_polygons", ",", "(", "\n", "\"Cityscapes's json annotations are in polygon format. \"", "\n", "\"Converting to mask format is not supported now.\"", "\n", ")", "\n", "", "files", "=", "get_cityscapes_files", "(", "image_dir", ",", "gt_dir", ")", "\n", "\n", "logger", ".", "info", "(", "\"Preprocessing cityscapes annotations ...\"", ")", "\n", "# This is still not fast: all workers will execute duplicate works and will", "\n", "# take up to 10m on a 8GPU server.", "\n", "pool", "=", "mp", ".", "Pool", "(", "processes", "=", "max", "(", "mp", ".", "cpu_count", "(", ")", "//", "get_world_size", "(", ")", "//", "2", ",", "4", ")", ")", "\n", "\n", "ret", "=", "pool", ".", "map", "(", "\n", "functools", ".", "partial", "(", "cityscapes_files_to_dict", ",", "from_json", "=", "from_json", ",", "to_polygons", "=", "to_polygons", ")", ",", "\n", "files", ",", "\n", ")", "\n", "logger", ".", "info", "(", "\"Loaded {} images from {}\"", ".", "format", "(", "len", "(", "ret", ")", ",", "image_dir", ")", ")", "\n", "\n", "# Map cityscape ids to contiguous ids", "\n", "from", "cityscapesscripts", ".", "helpers", ".", "labels", "import", "labels", "\n", "\n", "labels", "=", "[", "l", "for", "l", "in", "labels", "if", "l", ".", "hasInstances", "and", "not", "l", ".", "ignoreInEval", "]", "\n", "dataset_id_to_contiguous_id", "=", "{", "l", ".", "id", ":", "idx", "for", "idx", ",", "l", "in", "enumerate", "(", "labels", ")", "}", "\n", "for", "dict_per_image", "in", "ret", ":", "\n", "        ", "for", "anno", "in", "dict_per_image", "[", "\"annotations\"", "]", ":", "\n", "            ", "anno", "[", "\"category_id\"", "]", "=", "dataset_id_to_contiguous_id", "[", "anno", "[", "\"category_id\"", "]", "]", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes.load_cityscapes_semantic": [[95, 126], ["fvcore.common.file_io.PathManager.get_local_path", "cityscapes.get_cityscapes_files", "len", "fvcore.common.file_io.PathManager.isfile", "label_file.replace.replace", "ret.append", "fvcore.common.file_io.PathManager.open", "json.load"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes.get_cityscapes_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load"], ["", "def", "load_cityscapes_semantic", "(", "image_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        image_dir (str): path to the raw dataset. e.g., \"~/cityscapes/leftImg8bit/train\".\n        gt_dir (str): path to the raw annotations. e.g., \"~/cityscapes/gtFine/train\".\n\n    Returns:\n        list[dict]: a list of dict, each has \"file_name\" and\n            \"sem_seg_file_name\".\n    \"\"\"", "\n", "ret", "=", "[", "]", "\n", "# gt_dir is small and contain many small files. make sense to fetch to local first", "\n", "gt_dir", "=", "PathManager", ".", "get_local_path", "(", "gt_dir", ")", "\n", "for", "image_file", ",", "_", ",", "label_file", ",", "json_file", "in", "get_cityscapes_files", "(", "image_dir", ",", "gt_dir", ")", ":", "\n", "        ", "label_file", "=", "label_file", ".", "replace", "(", "\"labelIds\"", ",", "\"labelTrainIds\"", ")", "\n", "\n", "with", "PathManager", ".", "open", "(", "json_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "jsonobj", "=", "json", ".", "load", "(", "f", ")", "\n", "", "ret", ".", "append", "(", "\n", "{", "\n", "\"file_name\"", ":", "image_file", ",", "\n", "\"sem_seg_file_name\"", ":", "label_file", ",", "\n", "\"height\"", ":", "jsonobj", "[", "\"imgHeight\"", "]", ",", "\n", "\"width\"", ":", "jsonobj", "[", "\"imgWidth\"", "]", ",", "\n", "}", "\n", ")", "\n", "", "assert", "len", "(", "ret", ")", ",", "f\"No images found in {image_dir}!\"", "\n", "assert", "PathManager", ".", "isfile", "(", "\n", "ret", "[", "0", "]", "[", "\"sem_seg_file_name\"", "]", "\n", ")", ",", "\"Please generate labelTrainIds.png with cityscapesscripts/preparation/createTrainIdLabelImgs.py\"", "# noqa", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes.cityscapes_files_to_dict": [[128, 279], ["Polygon", "numpy.unique", "fvcore.common.file_io.PathManager.open", "json.load", "os.path.basename", "Polygon().buffer", "Polygon().buffer.difference", "polygons_union.union.union", "label_name.endswith", "isinstance", "annos.append", "fvcore.common.file_io.PathManager.open", "numpy.asarray", "os.path.basename", "numpy.asarray", "numpy.nonzero", "annos.append", "numpy.asarray", "polygons_union.union.union", "isinstance", "poly_coord.append", "PIL.Image.open", "inds[].min", "inds[].max", "inds[].min", "inds[].max", "label_name.endswith", "Polygon", "NotImplementedError", "list", "cv2.findContours", "c.reshape().tolist", "len", "pycocotools.encode", "itertools.chain", "np.asarray.copy", "c.reshape", "len", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "cityscapes_files_to_dict", "(", "files", ",", "from_json", ",", "to_polygons", ")", ":", "\n", "    ", "\"\"\"\n    Parse cityscapes annotation files to a instance segmentation dataset dict.\n\n    Args:\n        files (tuple): consists of (image_file, instance_id_file, label_id_file, json_file)\n        from_json (bool): whether to read annotations from the raw json file or the png files.\n        to_polygons (bool): whether to represent the segmentation as polygons\n            (COCO's format) instead of masks (cityscapes's format).\n\n    Returns:\n        A dict in Detectron2 Dataset format.\n    \"\"\"", "\n", "from", "cityscapesscripts", ".", "helpers", ".", "labels", "import", "id2label", ",", "name2label", "\n", "\n", "image_file", ",", "instance_id_file", ",", "_", ",", "json_file", "=", "files", "\n", "\n", "annos", "=", "[", "]", "\n", "\n", "if", "from_json", ":", "\n", "        ", "from", "shapely", ".", "geometry", "import", "MultiPolygon", ",", "Polygon", "\n", "\n", "with", "PathManager", ".", "open", "(", "json_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "jsonobj", "=", "json", ".", "load", "(", "f", ")", "\n", "", "ret", "=", "{", "\n", "\"file_name\"", ":", "image_file", ",", "\n", "\"image_id\"", ":", "os", ".", "path", ".", "basename", "(", "image_file", ")", ",", "\n", "\"height\"", ":", "jsonobj", "[", "\"imgHeight\"", "]", ",", "\n", "\"width\"", ":", "jsonobj", "[", "\"imgWidth\"", "]", ",", "\n", "}", "\n", "\n", "# `polygons_union` contains the union of all valid polygons.", "\n", "polygons_union", "=", "Polygon", "(", ")", "\n", "\n", "# CityscapesScripts draw the polygons in sequential order", "\n", "# and each polygon *overwrites* existing ones. See", "\n", "# (https://github.com/mcordts/cityscapesScripts/blob/master/cityscapesscripts/preparation/json2instanceImg.py) # noqa", "\n", "# We use reverse order, and each polygon *avoids* early ones.", "\n", "# This will resolve the ploygon overlaps in the same way as CityscapesScripts.", "\n", "for", "obj", "in", "jsonobj", "[", "\"objects\"", "]", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "if", "\"deleted\"", "in", "obj", ":", "# cityscapes data format specific", "\n", "                ", "continue", "\n", "", "label_name", "=", "obj", "[", "\"label\"", "]", "\n", "\n", "try", ":", "\n", "                ", "label", "=", "name2label", "[", "label_name", "]", "\n", "", "except", "KeyError", ":", "\n", "                ", "if", "label_name", ".", "endswith", "(", "\"group\"", ")", ":", "# crowd area", "\n", "                    ", "label", "=", "name2label", "[", "label_name", "[", ":", "-", "len", "(", "\"group\"", ")", "]", "]", "\n", "", "else", ":", "\n", "                    ", "raise", "\n", "", "", "if", "label", ".", "id", "<", "0", ":", "# cityscapes data format", "\n", "                ", "continue", "\n", "\n", "# Cityscapes's raw annotations uses integer coordinates", "\n", "# Therefore +0.5 here", "\n", "", "poly_coord", "=", "np", ".", "asarray", "(", "obj", "[", "\"polygon\"", "]", ",", "dtype", "=", "\"f4\"", ")", "+", "0.5", "\n", "# CityscapesScript uses PIL.ImageDraw.polygon to rasterize", "\n", "# polygons for evaluation. This function operates in integer space", "\n", "# and draws each pixel whose center falls into the polygon.", "\n", "# Therefore it draws a polygon which is 0.5 \"fatter\" in expectation.", "\n", "# We therefore dilate the input polygon by 0.5 as our input.", "\n", "poly", "=", "Polygon", "(", "poly_coord", ")", ".", "buffer", "(", "0.5", ",", "resolution", "=", "4", ")", "\n", "\n", "if", "not", "label", ".", "hasInstances", "or", "label", ".", "ignoreInEval", ":", "\n", "# even if we won't store the polygon it still contributes to overlaps resolution", "\n", "                ", "polygons_union", "=", "polygons_union", ".", "union", "(", "poly", ")", "\n", "continue", "\n", "\n", "# Take non-overlapping part of the polygon", "\n", "", "poly_wo_overlaps", "=", "poly", ".", "difference", "(", "polygons_union", ")", "\n", "if", "poly_wo_overlaps", ".", "is_empty", ":", "\n", "                ", "continue", "\n", "", "polygons_union", "=", "polygons_union", ".", "union", "(", "poly", ")", "\n", "\n", "anno", "=", "{", "}", "\n", "anno", "[", "\"iscrowd\"", "]", "=", "label_name", ".", "endswith", "(", "\"group\"", ")", "\n", "anno", "[", "\"category_id\"", "]", "=", "label", ".", "id", "\n", "\n", "if", "isinstance", "(", "poly_wo_overlaps", ",", "Polygon", ")", ":", "\n", "                ", "poly_list", "=", "[", "poly_wo_overlaps", "]", "\n", "", "elif", "isinstance", "(", "poly_wo_overlaps", ",", "MultiPolygon", ")", ":", "\n", "                ", "poly_list", "=", "poly_wo_overlaps", ".", "geoms", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\"Unknown geometric structure {}\"", ".", "format", "(", "poly_wo_overlaps", ")", ")", "\n", "\n", "", "poly_coord", "=", "[", "]", "\n", "for", "poly_el", "in", "poly_list", ":", "\n", "# COCO API can work only with exterior boundaries now, hence we store only them.", "\n", "# TODO: store both exterior and interior boundaries once other parts of the", "\n", "# codebase support holes in polygons.", "\n", "                ", "poly_coord", ".", "append", "(", "list", "(", "chain", "(", "*", "poly_el", ".", "exterior", ".", "coords", ")", ")", ")", "\n", "", "anno", "[", "\"segmentation\"", "]", "=", "poly_coord", "\n", "(", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", ")", "=", "poly_wo_overlaps", ".", "bounds", "\n", "\n", "anno", "[", "\"bbox\"", "]", "=", "(", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", ")", "\n", "anno", "[", "\"bbox_mode\"", "]", "=", "BoxMode", ".", "XYXY_ABS", "\n", "\n", "annos", ".", "append", "(", "anno", ")", "\n", "", "", "else", ":", "\n", "# See also the official annotation parsing scripts at", "\n", "# https://github.com/mcordts/cityscapesScripts/blob/master/cityscapesscripts/evaluation/instances2dict.py  # noqa", "\n", "        ", "with", "PathManager", ".", "open", "(", "instance_id_file", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "inst_image", "=", "np", ".", "asarray", "(", "Image", ".", "open", "(", "f", ")", ",", "order", "=", "\"F\"", ")", "\n", "# ids < 24 are stuff labels (filtering them first is about 5% faster)", "\n", "", "flattened_ids", "=", "np", ".", "unique", "(", "inst_image", "[", "inst_image", ">=", "24", "]", ")", "\n", "\n", "ret", "=", "{", "\n", "\"file_name\"", ":", "image_file", ",", "\n", "\"image_id\"", ":", "os", ".", "path", ".", "basename", "(", "image_file", ")", ",", "\n", "\"height\"", ":", "inst_image", ".", "shape", "[", "0", "]", ",", "\n", "\"width\"", ":", "inst_image", ".", "shape", "[", "1", "]", ",", "\n", "}", "\n", "\n", "for", "instance_id", "in", "flattened_ids", ":", "\n", "# For non-crowd annotations, instance_id // 1000 is the label_id", "\n", "# Crowd annotations have <1000 instance ids", "\n", "            ", "label_id", "=", "instance_id", "//", "1000", "if", "instance_id", ">=", "1000", "else", "instance_id", "\n", "label", "=", "id2label", "[", "label_id", "]", "\n", "if", "not", "label", ".", "hasInstances", "or", "label", ".", "ignoreInEval", ":", "\n", "                ", "continue", "\n", "\n", "", "anno", "=", "{", "}", "\n", "anno", "[", "\"iscrowd\"", "]", "=", "instance_id", "<", "1000", "\n", "anno", "[", "\"category_id\"", "]", "=", "label", ".", "id", "\n", "\n", "mask", "=", "np", ".", "asarray", "(", "inst_image", "==", "instance_id", ",", "dtype", "=", "np", ".", "uint8", ",", "order", "=", "\"F\"", ")", "\n", "\n", "inds", "=", "np", ".", "nonzero", "(", "mask", ")", "\n", "ymin", ",", "ymax", "=", "inds", "[", "0", "]", ".", "min", "(", ")", ",", "inds", "[", "0", "]", ".", "max", "(", ")", "\n", "xmin", ",", "xmax", "=", "inds", "[", "1", "]", ".", "min", "(", ")", ",", "inds", "[", "1", "]", ".", "max", "(", ")", "\n", "anno", "[", "\"bbox\"", "]", "=", "(", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", ")", "\n", "if", "xmax", "<=", "xmin", "or", "ymax", "<=", "ymin", ":", "\n", "                ", "continue", "\n", "", "anno", "[", "\"bbox_mode\"", "]", "=", "BoxMode", ".", "XYXY_ABS", "\n", "if", "to_polygons", ":", "\n", "# This conversion comes from D4809743 and D5171122,", "\n", "# when Mask-RCNN was first developed.", "\n", "                ", "contours", "=", "cv2", ".", "findContours", "(", "mask", ".", "copy", "(", ")", ",", "cv2", ".", "RETR_EXTERNAL", ",", "cv2", ".", "CHAIN_APPROX_NONE", ")", "[", "\n", "-", "2", "\n", "]", "\n", "polygons", "=", "[", "c", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", "for", "c", "in", "contours", "if", "len", "(", "c", ")", ">=", "3", "]", "\n", "# opencv's can produce invalid polygons", "\n", "if", "len", "(", "polygons", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "", "anno", "[", "\"segmentation\"", "]", "=", "polygons", "\n", "", "else", ":", "\n", "                ", "anno", "[", "\"segmentation\"", "]", "=", "mask_util", ".", "encode", "(", "mask", "[", ":", ",", ":", ",", "None", "]", ")", "[", "0", "]", "\n", "", "annos", ".", "append", "(", "anno", ")", "\n", "", "", "ret", "[", "\"annotations\"", "]", "=", "annos", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.register_coco.register_coco_instances": [[16, 43], ["isinstance", "isinstance", "isinstance", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "coco.load_coco_json", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.load_coco_json", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "register_coco_instances", "(", "name", ",", "metadata", ",", "json_file", ",", "image_root", ")", ":", "\n", "    ", "\"\"\"\n    Register a dataset in COCO's json annotation format for\n    instance detection, instance segmentation and keypoint detection.\n    (i.e., Type 1 and 2 in http://cocodataset.org/#format-data.\n    `instances*.json` and `person_keypoints*.json` in the dataset).\n\n    This is an example of how to register a new dataset.\n    You can do something similar to this function, to register new datasets.\n\n    Args:\n        name (str): the name that identifies a dataset, e.g. \"coco_2014_train\".\n        metadata (dict): extra metadata associated with this dataset.  You can\n            leave it as an empty dict.\n        json_file (str): path to the json instance annotation file.\n        image_root (str or path-like): directory which contains all the images.\n    \"\"\"", "\n", "assert", "isinstance", "(", "name", ",", "str", ")", ",", "name", "\n", "assert", "isinstance", "(", "json_file", ",", "(", "str", ",", "os", ".", "PathLike", ")", ")", ",", "json_file", "\n", "assert", "isinstance", "(", "image_root", ",", "(", "str", ",", "os", ".", "PathLike", ")", ")", ",", "image_root", "\n", "# 1. register a function which returns dicts", "\n", "DatasetCatalog", ".", "register", "(", "name", ",", "lambda", ":", "load_coco_json", "(", "json_file", ",", "image_root", ",", "name", ")", ")", "\n", "\n", "# 2. Optionally, add metadata about this dataset,", "\n", "# since they might be useful in evaluation, visualization or logging", "\n", "MetadataCatalog", ".", "get", "(", "name", ")", ".", "set", "(", "\n", "json_file", "=", "json_file", ",", "image_root", "=", "image_root", ",", "evaluator_type", "=", "\"coco\"", ",", "**", "metadata", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.register_coco.register_coco_panoptic_separated": [[46, 104], ["detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "register_coco.merge_to_panoptic", "detectron2.data.MetadataCatalog.get", "coco.load_sem_seg", "detectron2.data.MetadataCatalog.get", "coco.load_coco_json", "coco.load_sem_seg"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.register_coco.merge_to_panoptic", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.load_sem_seg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.load_coco_json", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.load_sem_seg"], ["", "def", "register_coco_panoptic_separated", "(", "\n", "name", ",", "metadata", ",", "image_root", ",", "panoptic_root", ",", "panoptic_json", ",", "sem_seg_root", ",", "instances_json", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Register a COCO panoptic segmentation dataset named `name`.\n    The annotations in this registered dataset will contain both instance annotations and\n    semantic annotations, each with its own contiguous ids. Hence it's called \"separated\".\n\n    It follows the setting used by the PanopticFPN paper:\n\n    1. The instance annotations directly come from polygons in the COCO\n       instances annotation task, rather than from the masks in the COCO panoptic annotations.\n\n       The two format have small differences:\n       Polygons in the instance annotations may have overlaps.\n       The mask annotations are produced by labeling the overlapped polygons\n       with depth ordering.\n\n    2. The semantic annotations are converted from panoptic annotations, where\n       all \"things\" are assigned a semantic id of 0.\n       All semantic categories will therefore have ids in contiguous\n       range [1, #stuff_categories].\n\n    This function will also register a pure semantic segmentation dataset\n    named ``name + '_stuffonly'``.\n\n    Args:\n        name (str): the name that identifies a dataset,\n            e.g. \"coco_2017_train_panoptic\"\n        metadata (dict): extra metadata associated with this dataset.\n        image_root (str): directory which contains all the images\n        panoptic_root (str): directory which contains panoptic annotation images\n        panoptic_json (str): path to the json panoptic annotation file\n        sem_seg_root (str): directory which contains all the ground truth segmentation annotations.\n        instances_json (str): path to the json instance annotation file\n    \"\"\"", "\n", "panoptic_name", "=", "name", "+", "\"_separated\"", "\n", "DatasetCatalog", ".", "register", "(", "\n", "panoptic_name", ",", "\n", "lambda", ":", "merge_to_panoptic", "(", "\n", "load_coco_json", "(", "instances_json", ",", "image_root", ",", "panoptic_name", ")", ",", "\n", "load_sem_seg", "(", "sem_seg_root", ",", "image_root", ")", ",", "\n", ")", ",", "\n", ")", "\n", "MetadataCatalog", ".", "get", "(", "panoptic_name", ")", ".", "set", "(", "\n", "panoptic_root", "=", "panoptic_root", ",", "\n", "image_root", "=", "image_root", ",", "\n", "panoptic_json", "=", "panoptic_json", ",", "\n", "sem_seg_root", "=", "sem_seg_root", ",", "\n", "json_file", "=", "instances_json", ",", "# TODO rename", "\n", "evaluator_type", "=", "\"coco_panoptic_seg\"", ",", "\n", "**", "metadata", "\n", ")", "\n", "\n", "semantic_name", "=", "name", "+", "\"_stuffonly\"", "\n", "DatasetCatalog", ".", "register", "(", "semantic_name", ",", "lambda", ":", "load_sem_seg", "(", "sem_seg_root", ",", "image_root", ")", ")", "\n", "MetadataCatalog", ".", "get", "(", "semantic_name", ")", ".", "set", "(", "\n", "sem_seg_root", "=", "sem_seg_root", ",", "image_root", "=", "image_root", ",", "evaluator_type", "=", "\"sem_seg\"", ",", "**", "metadata", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.register_coco.merge_to_panoptic": [[107, 130], ["len", "copy.copy", "copy.copy.update", "results.append"], "function", ["None"], ["", "def", "merge_to_panoptic", "(", "detection_dicts", ",", "sem_seg_dicts", ")", ":", "\n", "    ", "\"\"\"\n    Create dataset dicts for panoptic segmentation, by\n    merging two dicts using \"file_name\" field to match their entries.\n\n    Args:\n        detection_dicts (list[dict]): lists of dicts for object detection or instance segmentation.\n        sem_seg_dicts (list[dict]): lists of dicts for semantic segmentation.\n\n    Returns:\n        list[dict] (one per input image): Each dict contains all (key, value) pairs from dicts in\n            both detection_dicts and sem_seg_dicts that correspond to the same image.\n            The function assumes that the same key in different dicts has the same value.\n    \"\"\"", "\n", "results", "=", "[", "]", "\n", "sem_seg_file_to_entry", "=", "{", "x", "[", "\"file_name\"", "]", ":", "x", "for", "x", "in", "sem_seg_dicts", "}", "\n", "assert", "len", "(", "sem_seg_file_to_entry", ")", ">", "0", "\n", "\n", "for", "det_dict", "in", "detection_dicts", ":", "\n", "        ", "dic", "=", "copy", ".", "copy", "(", "det_dict", ")", "\n", "dic", ".", "update", "(", "sem_seg_file_to_entry", "[", "dic", "[", "\"file_name\"", "]", "]", ")", "\n", "results", ".", "append", "(", "dic", ")", "\n", "", "return", "results", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.voc_style_coco.load_voc_coco_instances": [[57, 137], ["tuple", "fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.file_io.PathManager.open", "numpy.loadtxt", "itertools.chain", "os.path.join", "os.path.join", "os.path.join", "ET.parse.findall", "dicts.append", "os.path.join", "fvcore.common.file_io.PathManager.open", "xml.parse", "int", "int", "obj.find", "obj.find", "float", "instances.append", "print", "print", "print", "ET.parse.findall", "ET.parse.findall", "obj.find.find", "INCR_CLASS_NAMES_2.index"], "function", ["None"], ["def", "load_voc_coco_instances", "(", "dirname", ":", "str", ",", "split", ":", "str", ",", "class_names", ":", "Union", "[", "List", "[", "str", "]", ",", "Tuple", "[", "str", ",", "...", "]", "]", ")", ":", "\n", "    ", "\"\"\"\n    Load Pascal VOC detection annotations to Detectron2 format.\n\n    Args:\n        dirname: Contain \"Annotations\", \"ImageSets\", \"JPEGImages\"\n        split (str): one of \"train\", \"test\", \"val\", \"trainval\": t1_train, t1_test\n        class_names: list or tuple of class names\n    \"\"\"", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"ImageSets\"", ",", "\"Main\"", ",", "split", "+", "\".txt\"", ")", ")", "as", "f", ":", "\n", "        ", "fileids", "=", "np", ".", "loadtxt", "(", "f", ",", "dtype", "=", "np", ".", "str", ")", "\n", "\n", "", "known_class_list", "=", "None", "\n", "if", "'t2'", "in", "split", ":", "\n", "        ", "known_class_list", "=", "T2_CLASS_NAMES", "\n", "", "elif", "'t3'", "in", "split", ":", "\n", "        ", "known_class_list", "=", "T3_CLASS_NAMES", "\n", "", "elif", "'t4'", "in", "split", ":", "\n", "        ", "known_class_list", "=", "T4_CLASS_NAMES", "\n", "\n", "", "unknown_class_list", "=", "tuple", "(", "itertools", ".", "chain", "(", "T2_CLASS_NAMES", ",", "T3_CLASS_NAMES", ",", "T4_CLASS_NAMES", ")", ")", "\n", "\n", "# Needs to read many small annotation files. Makes sense at local", "\n", "annotation_dirname", "=", "PathManager", ".", "get_local_path", "(", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"Annotations/\"", ")", ")", "\n", "dicts", "=", "[", "]", "\n", "for", "fileid", "in", "fileids", ":", "\n", "        ", "anno_file", "=", "os", ".", "path", ".", "join", "(", "annotation_dirname", ",", "fileid", "+", "\".xml\"", ")", "\n", "jpeg_file", "=", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"JPEGImages\"", ",", "fileid", "+", "\".jpg\"", ")", "\n", "\n", "with", "PathManager", ".", "open", "(", "anno_file", ")", "as", "f", ":", "\n", "            ", "tree", "=", "ET", ".", "parse", "(", "f", ")", "\n", "\n", "", "r", "=", "{", "\n", "\"file_name\"", ":", "jpeg_file", ",", "\n", "\"image_id\"", ":", "fileid", ",", "\n", "\"height\"", ":", "int", "(", "tree", ".", "findall", "(", "\"./size/height\"", ")", "[", "0", "]", ".", "text", ")", ",", "\n", "\"width\"", ":", "int", "(", "tree", ".", "findall", "(", "\"./size/width\"", ")", "[", "0", "]", ".", "text", ")", ",", "\n", "}", "\n", "instances", "=", "[", "]", "\n", "\n", "for", "obj", "in", "tree", ".", "findall", "(", "\"object\"", ")", ":", "\n", "            ", "cls_name", "=", "obj", ".", "find", "(", "\"name\"", ")", ".", "text", "\n", "\n", "cls", "=", "cls_name", "\n", "\n", "if", "cls_name", "in", "unknown_class_list", ":", "\n", "                ", "cls", "=", "\"unknown\"", "\n", "\n", "# if cls_name not in known_class_list:", "\n", "#     continue", "\n", "#", "\n", "# if 'unk' in split:", "\n", "#     cls = \"unknown\"", "\n", "# else:", "\n", "#     cls = cls_name", "\n", "\n", "# We include \"difficult\" samples in training.", "\n", "# Based on limited experiments, they don't hurt accuracy.", "\n", "# difficult = int(obj.find(\"difficult\").text)", "\n", "# if difficult == 1:", "\n", "# continue", "\n", "", "bbox", "=", "obj", ".", "find", "(", "\"bndbox\"", ")", "\n", "bbox", "=", "[", "float", "(", "bbox", ".", "find", "(", "x", ")", ".", "text", ")", "for", "x", "in", "[", "\"xmin\"", ",", "\"ymin\"", ",", "\"xmax\"", ",", "\"ymax\"", "]", "]", "\n", "# Original annotations are integers in the range [1, W or H]", "\n", "# Assuming they mean 1-based pixel indices (inclusive),", "\n", "# a box with annotation (xmin=1, xmax=W) covers the whole image.", "\n", "# In coordinate space this is represented by (xmin=0, xmax=W)", "\n", "bbox", "[", "0", "]", "-=", "1.0", "\n", "bbox", "[", "1", "]", "-=", "1.0", "\n", "try", ":", "\n", "                ", "instances", ".", "append", "(", "\n", "{", "\"category_id\"", ":", "INCR_CLASS_NAMES_2", ".", "index", "(", "cls", ")", ",", "\"bbox\"", ":", "bbox", ",", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", "}", "\n", ")", "\n", "", "except", ":", "\n", "                ", "print", "(", "cls", ")", "\n", "print", "(", "class_names", ")", "\n", "print", "(", "unknown_class_list", ")", "\n", "", "", "r", "[", "\"annotations\"", "]", "=", "instances", "\n", "dicts", ".", "append", "(", "r", ")", "\n", "", "return", "dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.voc_style_coco.register_voc_style_coco": [[139, 143], ["detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "voc_style_coco.load_voc_coco_instances", "detectron2.data.MetadataCatalog.get", "list"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.voc_style_coco.load_voc_coco_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "register_voc_style_coco", "(", "name", ",", "dirname", ",", "split", ",", "year", ",", "class_names", "=", "INCR_CLASS_NAMES", ")", ":", "\n", "    ", "DatasetCatalog", ".", "register", "(", "name", ",", "lambda", ":", "load_voc_coco_instances", "(", "dirname", ",", "split", ",", "class_names", ")", ")", "\n", "MetadataCatalog", ".", "get", "(", "name", ")", ".", "set", "(", "\n", "thing_classes", "=", "list", "(", "class_names", ")", ",", "dirname", "=", "dirname", ",", "year", "=", "year", ",", "split", "=", "split", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis.register_lvis_instances": [[24, 37], ["detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "lvis.load_lvis_json", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis.load_lvis_json", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "register_lvis_instances", "(", "name", ",", "metadata", ",", "json_file", ",", "image_root", ")", ":", "\n", "    ", "\"\"\"\n    Register a dataset in LVIS's json annotation format for instance detection and segmentation.\n\n    Args:\n        name (str): a name that identifies the dataset, e.g. \"lvis_v0.5_train\".\n        metadata (dict): extra metadata associated with this dataset. It can be an empty dict.\n        json_file (str): path to the json instance annotation file.\n        image_root (str or path-like): directory which contains all the images.\n    \"\"\"", "\n", "DatasetCatalog", ".", "register", "(", "name", ",", "lambda", ":", "load_lvis_json", "(", "json_file", ",", "image_root", ",", "name", ")", ")", "\n", "MetadataCatalog", ".", "get", "(", "name", ")", ".", "set", "(", "\n", "json_file", "=", "json_file", ",", "image_root", "=", "image_root", ",", "evaluator_type", "=", "\"lvis\"", ",", "**", "metadata", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis.load_lvis_json": [[40, 148], ["fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.timer.Timer", "LVIS", "sorted", "LVIS.load_imgs", "list", "logger.info", "fvcore.common.timer.Timer.seconds", "logger.info", "lvis.get_lvis_instances_meta", "detectron2.data.MetadataCatalog.get().set", "LVIS.imgs.keys", "len", "len", "zip", "os.path.join", "lvis.load_lvis_json.get_file_name"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis.get_lvis_instances_meta", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "def", "load_lvis_json", "(", "json_file", ",", "image_root", ",", "dataset_name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Load a json file in LVIS's annotation format.\n\n    Args:\n        json_file (str): full path to the LVIS json annotation file.\n        image_root (str): the directory where the images in this json file exists.\n        dataset_name (str): the name of the dataset (e.g., \"lvis_v0.5_train\").\n            If provided, this function will put \"thing_classes\" into the metadata\n            associated with this dataset.\n\n    Returns:\n        list[dict]: a list of dicts in Detectron2 standard format. (See\n        `Using Custom Datasets </tutorials/datasets.html>`_ )\n\n    Notes:\n        1. This function does not read the image files.\n           The results do not have the \"image\" field.\n    \"\"\"", "\n", "from", "lvis", "import", "LVIS", "\n", "\n", "json_file", "=", "PathManager", ".", "get_local_path", "(", "json_file", ")", "\n", "\n", "timer", "=", "Timer", "(", ")", "\n", "lvis_api", "=", "LVIS", "(", "json_file", ")", "\n", "if", "timer", ".", "seconds", "(", ")", ">", "1", ":", "\n", "        ", "logger", ".", "info", "(", "\"Loading {} takes {:.2f} seconds.\"", ".", "format", "(", "json_file", ",", "timer", ".", "seconds", "(", ")", ")", ")", "\n", "\n", "", "if", "dataset_name", "is", "not", "None", ":", "\n", "        ", "meta", "=", "get_lvis_instances_meta", "(", "dataset_name", ")", "\n", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "set", "(", "**", "meta", ")", "\n", "\n", "# sort indices for reproducible results", "\n", "", "img_ids", "=", "sorted", "(", "lvis_api", ".", "imgs", ".", "keys", "(", ")", ")", "\n", "# imgs is a list of dicts, each looks something like:", "\n", "# {'license': 4,", "\n", "#  'url': 'http://farm6.staticflickr.com/5454/9413846304_881d5e5c3b_z.jpg',", "\n", "#  'file_name': 'COCO_val2014_000000001268.jpg',", "\n", "#  'height': 427,", "\n", "#  'width': 640,", "\n", "#  'date_captured': '2013-11-17 05:57:24',", "\n", "#  'id': 1268}", "\n", "imgs", "=", "lvis_api", ".", "load_imgs", "(", "img_ids", ")", "\n", "# anns is a list[list[dict]], where each dict is an annotation", "\n", "# record for an object. The inner list enumerates the objects in an image", "\n", "# and the outer list enumerates over images. Example of anns[0]:", "\n", "# [{'segmentation': [[192.81,", "\n", "#     247.09,", "\n", "#     ...", "\n", "#     219.03,", "\n", "#     249.06]],", "\n", "#   'area': 1035.749,", "\n", "#   'image_id': 1268,", "\n", "#   'bbox': [192.81, 224.8, 74.73, 33.43],", "\n", "#   'category_id': 16,", "\n", "#   'id': 42986},", "\n", "#  ...]", "\n", "anns", "=", "[", "lvis_api", ".", "img_ann_map", "[", "img_id", "]", "for", "img_id", "in", "img_ids", "]", "\n", "\n", "# Sanity check that each annotation has a unique id", "\n", "ann_ids", "=", "[", "ann", "[", "\"id\"", "]", "for", "anns_per_image", "in", "anns", "for", "ann", "in", "anns_per_image", "]", "\n", "assert", "len", "(", "set", "(", "ann_ids", ")", ")", "==", "len", "(", "ann_ids", ")", ",", "\"Annotation ids in '{}' are not unique\"", ".", "format", "(", "\n", "json_file", "\n", ")", "\n", "\n", "imgs_anns", "=", "list", "(", "zip", "(", "imgs", ",", "anns", ")", ")", "\n", "\n", "logger", ".", "info", "(", "\"Loaded {} images in the LVIS format from {}\"", ".", "format", "(", "len", "(", "imgs_anns", ")", ",", "json_file", ")", ")", "\n", "\n", "def", "get_file_name", "(", "img_root", ",", "img_dict", ")", ":", "\n", "# Determine the path including the split folder (\"train2017\", \"val2017\", \"test2017\") from", "\n", "# the coco_url field. Example:", "\n", "#   'coco_url': 'http://images.cocodataset.org/train2017/000000155379.jpg'", "\n", "        ", "split_folder", ",", "file_name", "=", "img_dict", "[", "\"coco_url\"", "]", ".", "split", "(", "\"/\"", ")", "[", "-", "2", ":", "]", "\n", "return", "os", ".", "path", ".", "join", "(", "img_root", "+", "split_folder", ",", "file_name", ")", "\n", "\n", "", "dataset_dicts", "=", "[", "]", "\n", "\n", "for", "(", "img_dict", ",", "anno_dict_list", ")", "in", "imgs_anns", ":", "\n", "        ", "record", "=", "{", "}", "\n", "record", "[", "\"file_name\"", "]", "=", "get_file_name", "(", "image_root", ",", "img_dict", ")", "\n", "record", "[", "\"height\"", "]", "=", "img_dict", "[", "\"height\"", "]", "\n", "record", "[", "\"width\"", "]", "=", "img_dict", "[", "\"width\"", "]", "\n", "record", "[", "\"not_exhaustive_category_ids\"", "]", "=", "img_dict", ".", "get", "(", "\"not_exhaustive_category_ids\"", ",", "[", "]", ")", "\n", "record", "[", "\"neg_category_ids\"", "]", "=", "img_dict", ".", "get", "(", "\"neg_category_ids\"", ",", "[", "]", ")", "\n", "image_id", "=", "record", "[", "\"image_id\"", "]", "=", "img_dict", "[", "\"id\"", "]", "\n", "\n", "objs", "=", "[", "]", "\n", "for", "anno", "in", "anno_dict_list", ":", "\n", "# Check that the image_id in this annotation is the same as", "\n", "# the image_id we're looking at.", "\n", "# This fails only when the data parsing logic or the annotation file is buggy.", "\n", "            ", "assert", "anno", "[", "\"image_id\"", "]", "==", "image_id", "\n", "obj", "=", "{", "\"bbox\"", ":", "anno", "[", "\"bbox\"", "]", ",", "\"bbox_mode\"", ":", "BoxMode", ".", "XYWH_ABS", "}", "\n", "obj", "[", "\"category_id\"", "]", "=", "anno", "[", "\"category_id\"", "]", "-", "1", "# Convert 1-indexed to 0-indexed", "\n", "segm", "=", "anno", "[", "\"segmentation\"", "]", "# list[list[float]]", "\n", "# filter out invalid polygons (< 3 points)", "\n", "valid_segm", "=", "[", "poly", "for", "poly", "in", "segm", "if", "len", "(", "poly", ")", "%", "2", "==", "0", "and", "len", "(", "poly", ")", ">=", "6", "]", "\n", "assert", "len", "(", "segm", ")", "==", "len", "(", "\n", "valid_segm", "\n", ")", ",", "\"Annotation contains an invalid polygon with < 3 points\"", "\n", "assert", "len", "(", "segm", ")", ">", "0", "\n", "obj", "[", "\"segmentation\"", "]", "=", "segm", "\n", "objs", ".", "append", "(", "obj", ")", "\n", "", "record", "[", "\"annotations\"", "]", "=", "objs", "\n", "dataset_dicts", ".", "append", "(", "record", ")", "\n", "\n", "", "return", "dataset_dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis.get_lvis_instances_meta": [[150, 167], ["ValueError", "builtin_meta._get_coco_instances_meta", "lvis._get_lvis_instances_meta_v0_5", "lvis._get_lvis_instances_meta_v1"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_coco_instances_meta", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis._get_lvis_instances_meta_v0_5", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis._get_lvis_instances_meta_v1"], ["", "def", "get_lvis_instances_meta", "(", "dataset_name", ")", ":", "\n", "    ", "\"\"\"\n    Load LVIS metadata.\n\n    Args:\n        dataset_name (str): LVIS dataset name without the split name (e.g., \"lvis_v0.5\").\n\n    Returns:\n        dict: LVIS metadata with keys: thing_classes\n    \"\"\"", "\n", "if", "\"cocofied\"", "in", "dataset_name", ":", "\n", "        ", "return", "_get_coco_instances_meta", "(", ")", "\n", "", "if", "\"v0.5\"", "in", "dataset_name", ":", "\n", "        ", "return", "_get_lvis_instances_meta_v0_5", "(", ")", "\n", "", "elif", "\"v1\"", "in", "dataset_name", ":", "\n", "        ", "return", "_get_lvis_instances_meta_v1", "(", ")", "\n", "", "raise", "ValueError", "(", "\"No built-in metadata for dataset {}\"", ".", "format", "(", "dataset_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis._get_lvis_instances_meta_v0_5": [[169, 180], ["sorted", "len", "min", "max", "len"], "function", ["None"], ["", "def", "_get_lvis_instances_meta_v0_5", "(", ")", ":", "\n", "    ", "assert", "len", "(", "LVIS_V0_5_CATEGORIES", ")", "==", "1230", "\n", "cat_ids", "=", "[", "k", "[", "\"id\"", "]", "for", "k", "in", "LVIS_V0_5_CATEGORIES", "]", "\n", "assert", "min", "(", "cat_ids", ")", "==", "1", "and", "max", "(", "cat_ids", ")", "==", "len", "(", "\n", "cat_ids", "\n", ")", ",", "\"Category ids are not in [1, #categories], as expected\"", "\n", "# Ensure that the category list is sorted by id", "\n", "lvis_categories", "=", "sorted", "(", "LVIS_V0_5_CATEGORIES", ",", "key", "=", "lambda", "x", ":", "x", "[", "\"id\"", "]", ")", "\n", "thing_classes", "=", "[", "k", "[", "\"synonyms\"", "]", "[", "0", "]", "for", "k", "in", "lvis_categories", "]", "\n", "meta", "=", "{", "\"thing_classes\"", ":", "thing_classes", "}", "\n", "return", "meta", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis._get_lvis_instances_meta_v1": [[182, 193], ["sorted", "len", "min", "max", "len"], "function", ["None"], ["", "def", "_get_lvis_instances_meta_v1", "(", ")", ":", "\n", "    ", "assert", "len", "(", "LVIS_V1_CATEGORIES", ")", "==", "1203", "\n", "cat_ids", "=", "[", "k", "[", "\"id\"", "]", "for", "k", "in", "LVIS_V1_CATEGORIES", "]", "\n", "assert", "min", "(", "cat_ids", ")", "==", "1", "and", "max", "(", "cat_ids", ")", "==", "len", "(", "\n", "cat_ids", "\n", ")", ",", "\"Category ids are not in [1, #categories], as expected\"", "\n", "# Ensure that the category list is sorted by id", "\n", "lvis_categories", "=", "sorted", "(", "LVIS_V1_CATEGORIES", ",", "key", "=", "lambda", "x", ":", "x", "[", "\"id\"", "]", ")", "\n", "thing_classes", "=", "[", "k", "[", "\"synonyms\"", "]", "[", "0", "]", "for", "k", "in", "lvis_categories", "]", "\n", "meta", "=", "{", "\"thing_classes\"", ":", "thing_classes", "}", "\n", "return", "meta", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin.register_all_coco": [[107, 133], ["_PREDEFINED_SPLITS_COCO.items", "_PREDEFINED_SPLITS_COCO_PANOPTIC.items", "splits_per_dataset.items", "detectron2.data.MetadataCatalog.get", "register_coco.register_coco_panoptic_separated", "register_coco.register_coco_instances", "builtin_meta._get_builtin_metadata", "os.path.join", "os.path.join", "os.path.join", "builtin_meta._get_builtin_metadata", "os.path.join", "os.path.join", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.register_coco.register_coco_panoptic_separated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.register_coco.register_coco_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_builtin_metadata", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_builtin_metadata"], ["def", "register_all_coco", "(", "root", ")", ":", "\n", "    ", "for", "dataset_name", ",", "splits_per_dataset", "in", "_PREDEFINED_SPLITS_COCO", ".", "items", "(", ")", ":", "\n", "        ", "for", "key", ",", "(", "image_root", ",", "json_file", ")", "in", "splits_per_dataset", ".", "items", "(", ")", ":", "\n", "# Assume pre-defined datasets live in `./datasets`.", "\n", "            ", "register_coco_instances", "(", "\n", "key", ",", "\n", "_get_builtin_metadata", "(", "dataset_name", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "json_file", ")", "if", "\"://\"", "not", "in", "json_file", "else", "json_file", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "image_root", ")", ",", "\n", ")", "\n", "\n", "", "", "for", "(", "\n", "prefix", ",", "\n", "(", "panoptic_root", ",", "panoptic_json", ",", "semantic_root", ")", ",", "\n", ")", "in", "_PREDEFINED_SPLITS_COCO_PANOPTIC", ".", "items", "(", ")", ":", "\n", "        ", "prefix_instances", "=", "prefix", "[", ":", "-", "len", "(", "\"_panoptic\"", ")", "]", "\n", "instances_meta", "=", "MetadataCatalog", ".", "get", "(", "prefix_instances", ")", "\n", "image_root", ",", "instances_json", "=", "instances_meta", ".", "image_root", ",", "instances_meta", ".", "json_file", "\n", "register_coco_panoptic_separated", "(", "\n", "prefix", ",", "\n", "_get_builtin_metadata", "(", "\"coco_panoptic_separated\"", ")", ",", "\n", "image_root", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "panoptic_root", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "panoptic_json", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "semantic_root", ")", ",", "\n", "instances_json", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin.register_all_lvis": [[159, 168], ["_PREDEFINED_SPLITS_LVIS.items", "splits_per_dataset.items", "lvis.register_lvis_instances", "lvis.get_lvis_instances_meta", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis.register_lvis_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.lvis.get_lvis_instances_meta"], ["def", "register_all_lvis", "(", "root", ")", ":", "\n", "    ", "for", "dataset_name", ",", "splits_per_dataset", "in", "_PREDEFINED_SPLITS_LVIS", ".", "items", "(", ")", ":", "\n", "        ", "for", "key", ",", "(", "image_root", ",", "json_file", ")", "in", "splits_per_dataset", ".", "items", "(", ")", ":", "\n", "# Assume pre-defined datasets live in `./datasets`.", "\n", "            ", "register_lvis_instances", "(", "\n", "key", ",", "\n", "get_lvis_instances_meta", "(", "dataset_name", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "json_file", ")", "if", "\"://\"", "not", "in", "json_file", "else", "json_file", ",", "\n", "os", ".", "path", ".", "join", "(", "root", ",", "image_root", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin.register_all_cityscapes": [[181, 204], ["_RAW_CITYSCAPES_SPLITS.items", "builtin_meta._get_builtin_metadata", "os.path.join", "os.path.join", "key.format", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "key.format", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "cityscapes.load_cityscapes_instances", "detectron2.data.MetadataCatalog.get", "cityscapes.load_cityscapes_semantic", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin_meta._get_builtin_metadata", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes.load_cityscapes_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.cityscapes.load_cityscapes_semantic", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "register_all_cityscapes", "(", "root", ")", ":", "\n", "    ", "for", "key", ",", "(", "image_dir", ",", "gt_dir", ")", "in", "_RAW_CITYSCAPES_SPLITS", ".", "items", "(", ")", ":", "\n", "        ", "meta", "=", "_get_builtin_metadata", "(", "\"cityscapes\"", ")", "\n", "image_dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "image_dir", ")", "\n", "gt_dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "gt_dir", ")", "\n", "\n", "inst_key", "=", "key", ".", "format", "(", "task", "=", "\"instance_seg\"", ")", "\n", "DatasetCatalog", ".", "register", "(", "\n", "inst_key", ",", "\n", "lambda", "x", "=", "image_dir", ",", "y", "=", "gt_dir", ":", "load_cityscapes_instances", "(", "\n", "x", ",", "y", ",", "from_json", "=", "True", ",", "to_polygons", "=", "True", "\n", ")", ",", "\n", ")", "\n", "MetadataCatalog", ".", "get", "(", "inst_key", ")", ".", "set", "(", "\n", "image_dir", "=", "image_dir", ",", "gt_dir", "=", "gt_dir", ",", "evaluator_type", "=", "\"cityscapes_instance\"", ",", "**", "meta", "\n", ")", "\n", "\n", "sem_key", "=", "key", ".", "format", "(", "task", "=", "\"sem_seg\"", ")", "\n", "DatasetCatalog", ".", "register", "(", "\n", "sem_key", ",", "lambda", "x", "=", "image_dir", ",", "y", "=", "gt_dir", ":", "load_cityscapes_semantic", "(", "x", ",", "y", ")", "\n", ")", "\n", "MetadataCatalog", ".", "get", "(", "sem_key", ")", ".", "set", "(", "\n", "image_dir", "=", "image_dir", ",", "gt_dir", "=", "gt_dir", ",", "evaluator_type", "=", "\"cityscapes_sem_seg\"", ",", "**", "meta", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin.register_all_pascal_voc": [[208, 237], ["pascal_voc.register_pascal_voc", "os.path.join", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.pascal_voc.register_pascal_voc", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "register_all_pascal_voc", "(", "root", ")", ":", "\n", "    ", "SPLITS", "=", "[", "\n", "(", "\"voc_2007_trainval\"", ",", "\"VOC2007\"", ",", "\"trainval\"", ")", ",", "\n", "(", "\"voc_2007_train\"", ",", "\"VOC2007\"", ",", "\"train\"", ")", ",", "\n", "(", "\"voc_2007_trn_ft\"", ",", "\"VOC2007\"", ",", "\"train_ft_1\"", ")", ",", "\n", "(", "\"voc_2007_val\"", ",", "\"VOC2007\"", ",", "\"val\"", ")", ",", "\n", "(", "\"voc_2007_test\"", ",", "\"VOC2007\"", ",", "\"test\"", ")", ",", "\n", "(", "\"voc_2012_trainval\"", ",", "\"VOC2012\"", ",", "\"trainval\"", ")", ",", "\n", "(", "\"voc_2012_train\"", ",", "\"VOC2012\"", ",", "\"train\"", ")", ",", "\n", "(", "\"voc_2012_val\"", ",", "\"VOC2012\"", ",", "\"val\"", ")", ",", "\n", "(", "\"t1_voc_coco_2007_train\"", ",", "\"VOC2007\"", ",", "\"t1_train\"", ")", ",", "\n", "(", "\"t1_voc_coco_2007_val_with_known_and_unk\"", ",", "\"VOC2007\"", ",", "\"t1_train_with_unk\"", ")", ",", "\n", "(", "\"t2_voc_coco_2007_val_with_known_and_unk\"", ",", "\"VOC2007\"", ",", "\"t2_train_with_unk\"", ")", ",", "\n", "(", "\"t3_voc_coco_2007_val_with_known_and_unk\"", ",", "\"VOC2007\"", ",", "\"t3_train_with_unk\"", ")", ",", "\n", "(", "\"t4_voc_coco_2007_val_with_known_and_unk\"", ",", "\"VOC2007\"", ",", "\"t4_train\"", ")", ",", "\n", "(", "\"t1_voc_coco_2007_known_test\"", ",", "\"VOC2007\"", ",", "\"t1_known_test\"", ")", ",", "\n", "(", "\"voc_coco_2007_test\"", ",", "\"VOC2007\"", ",", "\"all_task_test\"", ")", ",", "\n", "(", "\"voc_coco_2007_val\"", ",", "\"VOC2007\"", ",", "\"all_task_val\"", ")", ",", "\n", "(", "\"t2_voc_coco_2007_train\"", ",", "\"VOC2007\"", ",", "\"t2_train\"", ")", ",", "\n", "(", "\"t2_voc_coco_2007_ft\"", ",", "\"VOC2007\"", ",", "\"t2_ft\"", ")", ",", "\n", "(", "\"t3_voc_coco_2007_train\"", ",", "\"VOC2007\"", ",", "\"t3_train\"", ")", ",", "\n", "(", "\"t3_voc_coco_2007_ft\"", ",", "\"VOC2007\"", ",", "\"t3_ft\"", ")", ",", "\n", "(", "\"t4_voc_coco_2007_train\"", ",", "\"VOC2007\"", ",", "\"t4_train\"", ")", ",", "\n", "(", "\"t4_voc_coco_2007_ft\"", ",", "\"VOC2007\"", ",", "\"t4_ft\"", ")", ",", "\n", "]", "\n", "for", "name", ",", "dirname", ",", "split", "in", "SPLITS", ":", "\n", "        ", "year", "=", "2007", "if", "\"2007\"", "in", "name", "else", "2012", "\n", "register_pascal_voc", "(", "name", ",", "os", ".", "path", ".", "join", "(", "root", ",", "dirname", ")", ",", "split", ",", "year", ")", "\n", "MetadataCatalog", ".", "get", "(", "name", ")", ".", "evaluator_type", "=", "\"pascal_voc\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.builtin.register_all_ade20k": [[258, 272], ["os.path.join", "os.path.join", "os.path.join", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "coco.load_sem_seg", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.load_sem_seg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "register_all_ade20k", "(", "root", ")", ":", "\n", "    ", "root", "=", "os", ".", "path", ".", "join", "(", "root", ",", "\"ADEChallengeData2016\"", ")", "\n", "for", "name", ",", "dirname", "in", "[", "(", "\"train\"", ",", "\"training\"", ")", ",", "(", "\"val\"", ",", "\"validation\"", ")", "]", ":", "\n", "        ", "image_dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "\"images\"", ",", "dirname", ")", "\n", "gt_dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "\"annotations_detectron2\"", ",", "dirname", ")", "\n", "name", "=", "f\"ade20k_sem_seg_{name}\"", "\n", "DatasetCatalog", ".", "register", "(", "\n", "name", ",", "lambda", "x", "=", "image_dir", ",", "y", "=", "gt_dir", ":", "load_sem_seg", "(", "y", ",", "x", ",", "gt_ext", "=", "\"png\"", ",", "image_ext", "=", "\"jpg\"", ")", "\n", ")", "\n", "MetadataCatalog", ".", "get", "(", "name", ")", ".", "set", "(", "\n", "stuff_classes", "=", "ADE20K_SEM_SEG_CATEGORIES", "[", ":", "]", ",", "\n", "image_root", "=", "image_dir", ",", "\n", "sem_seg_root", "=", "gt_dir", ",", "\n", "evaluator_type", "=", "\"sem_seg\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.pascal_voc.load_voc_instances": [[72, 130], ["fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.file_io.PathManager.open", "numpy.loadtxt", "os.path.join", "os.path.join", "os.path.join", "ET.parse.findall", "dicts.append", "os.path.join", "int", "int", "obj.find", "instances.append", "fvcore.common.file_io.PathManager.open", "xml.parse", "logging.getLogger", "logging.getLogger.info", "obj.find", "float", "class_names.index", "ET.parse.findall", "ET.parse.findall", "VOC_CLASS_NAMES_COCOFIED.index", "obj.find.find"], "function", ["None"], ["def", "load_voc_instances", "(", "dirname", ":", "str", ",", "split", ":", "str", ",", "class_names", ":", "Union", "[", "List", "[", "str", "]", ",", "Tuple", "[", "str", ",", "...", "]", "]", ")", ":", "\n", "    ", "\"\"\"\n    Load Pascal VOC detection annotations to Detectron2 format.\n\n    Args:\n        dirname: Contain \"Annotations\", \"ImageSets\", \"JPEGImages\"\n        split (str): one of \"train\", \"test\", \"val\", \"trainval\"\n        class_names: list or tuple of class names\n    \"\"\"", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"ImageSets\"", ",", "\"Main\"", ",", "split", "+", "\".txt\"", ")", ")", "as", "f", ":", "\n", "        ", "fileids", "=", "np", ".", "loadtxt", "(", "f", ",", "dtype", "=", "np", ".", "str", ")", "\n", "\n", "# Needs to read many small annotation files. Makes sense at local", "\n", "", "annotation_dirname", "=", "PathManager", ".", "get_local_path", "(", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"Annotations/\"", ")", ")", "\n", "dicts", "=", "[", "]", "\n", "for", "fileid", "in", "fileids", ":", "\n", "        ", "anno_file", "=", "os", ".", "path", ".", "join", "(", "annotation_dirname", ",", "fileid", "+", "\".xml\"", ")", "\n", "jpeg_file", "=", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"JPEGImages\"", ",", "fileid", "+", "\".jpg\"", ")", "\n", "\n", "try", ":", "\n", "            ", "with", "PathManager", ".", "open", "(", "anno_file", ")", "as", "f", ":", "\n", "                ", "tree", "=", "ET", ".", "parse", "(", "f", ")", "\n", "", "", "except", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "'Not able to load: '", "+", "anno_file", "+", "'. Continuing without aboarting...'", ")", "\n", "continue", "\n", "\n", "", "r", "=", "{", "\n", "\"file_name\"", ":", "jpeg_file", ",", "\n", "\"image_id\"", ":", "fileid", ",", "\n", "\"height\"", ":", "int", "(", "tree", ".", "findall", "(", "\"./size/height\"", ")", "[", "0", "]", ".", "text", ")", ",", "\n", "\"width\"", ":", "int", "(", "tree", ".", "findall", "(", "\"./size/width\"", ")", "[", "0", "]", ".", "text", ")", ",", "\n", "}", "\n", "instances", "=", "[", "]", "\n", "\n", "for", "obj", "in", "tree", ".", "findall", "(", "\"object\"", ")", ":", "\n", "            ", "cls", "=", "obj", ".", "find", "(", "\"name\"", ")", ".", "text", "\n", "if", "cls", "in", "VOC_CLASS_NAMES_COCOFIED", ":", "\n", "                ", "cls", "=", "BASE_VOC_CLASS_NAMES", "[", "VOC_CLASS_NAMES_COCOFIED", ".", "index", "(", "cls", ")", "]", "\n", "# We include \"difficult\" samples in training.", "\n", "# Based on limited experiments, they don't hurt accuracy.", "\n", "# difficult = int(obj.find(\"difficult\").text)", "\n", "# if difficult == 1:", "\n", "# continue", "\n", "", "bbox", "=", "obj", ".", "find", "(", "\"bndbox\"", ")", "\n", "bbox", "=", "[", "float", "(", "bbox", ".", "find", "(", "x", ")", ".", "text", ")", "for", "x", "in", "[", "\"xmin\"", ",", "\"ymin\"", ",", "\"xmax\"", ",", "\"ymax\"", "]", "]", "\n", "# Original annotations are integers in the range [1, W or H]", "\n", "# Assuming they mean 1-based pixel indices (inclusive),", "\n", "# a box with annotation (xmin=1, xmax=W) covers the whole image.", "\n", "# In coordinate space this is represented by (xmin=0, xmax=W)", "\n", "bbox", "[", "0", "]", "-=", "1.0", "\n", "bbox", "[", "1", "]", "-=", "1.0", "\n", "instances", ".", "append", "(", "\n", "{", "\"category_id\"", ":", "class_names", ".", "index", "(", "cls", ")", ",", "\"bbox\"", ":", "bbox", ",", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", "}", "\n", ")", "\n", "", "r", "[", "\"annotations\"", "]", "=", "instances", "\n", "dicts", ".", "append", "(", "r", ")", "\n", "", "return", "dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.pascal_voc.register_pascal_voc": [[132, 141], ["detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "pascal_voc.load_voc_instances", "detectron2.data.MetadataCatalog.get", "list"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.pascal_voc.load_voc_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "register_pascal_voc", "(", "name", ",", "dirname", ",", "split", ",", "year", ")", ":", "\n", "# if \"voc_coco\" in name:", "\n", "#     class_names = VOC_COCO_CLASS_NAMES", "\n", "# else:", "\n", "#     class_names = tuple(VOC_CLASS_NAMES)", "\n", "    ", "class_names", "=", "VOC_COCO_CLASS_NAMES", "\n", "DatasetCatalog", ".", "register", "(", "name", ",", "lambda", ":", "load_voc_instances", "(", "dirname", ",", "split", ",", "class_names", ")", ")", "\n", "MetadataCatalog", ".", "get", "(", "name", ")", ".", "set", "(", "\n", "thing_classes", "=", "list", "(", "class_names", ")", ",", "dirname", "=", "dirname", ",", "year", "=", "year", ",", "split", "=", "split", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.get_metadata": [[88, 108], ["utils.maybe_prepend_base_path", "utils.maybe_prepend_base_path", "utils.maybe_prepend_base_path"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.maybe_prepend_base_path", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.maybe_prepend_base_path", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.maybe_prepend_base_path"], ["meta", ".", "thing_dataset_id_to_contiguous_id", "=", "id_map", "\n", "\n", "# sort indices for reproducible results", "\n", "", "img_ids", "=", "sorted", "(", "coco_api", ".", "imgs", ".", "keys", "(", ")", ")", "\n", "# imgs is a list of dicts, each looks something like:", "\n", "# {'license': 4,", "\n", "#  'url': 'http://farm6.staticflickr.com/5454/9413846304_881d5e5c3b_z.jpg',", "\n", "#  'file_name': 'COCO_val2014_000000001268.jpg',", "\n", "#  'height': 427,", "\n", "#  'width': 640,", "\n", "#  'date_captured': '2013-11-17 05:57:24',", "\n", "#  'id': 1268}", "\n", "imgs", "=", "coco_api", ".", "loadImgs", "(", "img_ids", ")", "\n", "# anns is a list[list[dict]], where each dict is an annotation", "\n", "# record for an object. The inner list enumerates the objects in an image", "\n", "# and the outer list enumerates over images. Example of anns[0]:", "\n", "# [{'segmentation': [[192.81,", "\n", "#     247.09,", "\n", "#     ...", "\n", "#     219.03,", "\n", "#     249.06]],", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._load_coco_annotations": [[110, 130], ["logging.getLogger", "fvcore.common.timer.Timer", "contextlib.redirect_stdout", "COCO", "fvcore.common.timer.Timer.seconds", "logging.getLogger.info", "io.StringIO", "fvcore.common.timer.Timer.seconds"], "function", ["None"], ["#   'iscrowd': 0,", "\n", "#   'image_id': 1268,", "\n", "#   'bbox': [192.81, 224.8, 74.73, 33.43],", "\n", "#   'category_id': 16,", "\n", "#   'id': 42986},", "\n", "#  ...]", "\n", "anns", "=", "[", "coco_api", ".", "imgToAnns", "[", "img_id", "]", "for", "img_id", "in", "img_ids", "]", "\n", "total_num_valid_anns", "=", "sum", "(", "[", "len", "(", "x", ")", "for", "x", "in", "anns", "]", ")", "\n", "total_num_anns", "=", "len", "(", "coco_api", ".", "anns", ")", "\n", "if", "total_num_valid_anns", "<", "total_num_anns", ":", "\n", "        ", "logger", ".", "warning", "(", "\n", "f\"{json_file} contains {total_num_anns} annotations, but only \"", "\n", "f\"{total_num_valid_anns} of them match to images in the file.\"", "\n", ")", "\n", "\n", "", "if", "\"minival\"", "not", "in", "json_file", ":", "\n", "# The popular valminusminival & minival annotations for COCO2014 contain this bug.", "\n", "# However the ratio of buggy annotations there is tiny and does not affect accuracy.", "\n", "# Therefore we explicitly white-list them.", "\n", "        ", "ann_ids", "=", "[", "ann", "[", "\"id\"", "]", "for", "anns_per_image", "in", "anns", "for", "ann", "in", "anns_per_image", "]", "\n", "assert", "len", "(", "set", "(", "ann_ids", ")", ")", "==", "len", "(", "ann_ids", ")", ",", "\"Annotation ids in '{}' are not unique!\"", ".", "format", "(", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._add_categories_metadata": [[132, 137], ["detectron2.data.MetadataCatalog.get", "logging.getLogger", "logging.getLogger.info"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], [")", "\n", "\n", "", "imgs_anns", "=", "list", "(", "zip", "(", "imgs", ",", "anns", ")", ")", "\n", "logger", ".", "info", "(", "\"Loaded {} images in COCO format from {}\"", ".", "format", "(", "len", "(", "imgs_anns", ")", ",", "json_file", ")", ")", "\n", "\n", "dataset_dicts", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._verify_annotations_have_unique_ids": [[139, 148], ["len", "len", "set"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["ann_keys", "=", "[", "\"iscrowd\"", ",", "\"bbox\"", ",", "\"keypoints\"", ",", "\"category_id\"", "]", "+", "(", "extra_annotation_keys", "or", "[", "]", ")", "\n", "\n", "num_instances_without_valid_segmentation", "=", "0", "\n", "\n", "for", "(", "img_dict", ",", "anno_dict_list", ")", "in", "imgs_anns", ":", "\n", "        ", "record", "=", "{", "}", "\n", "record", "[", "\"file_name\"", "]", "=", "os", ".", "path", ".", "join", "(", "image_root", ",", "img_dict", "[", "\"file_name\"", "]", ")", "\n", "record", "[", "\"height\"", "]", "=", "img_dict", "[", "\"height\"", "]", "\n", "record", "[", "\"width\"", "]", "=", "img_dict", "[", "\"width\"", "]", "\n", "image_id", "=", "record", "[", "\"image_id\"", "]", "=", "img_dict", "[", "\"id\"", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._maybe_add_bbox": [[151, 156], ["None"], "function", ["None"], ["for", "anno", "in", "anno_dict_list", ":", "\n", "# Check that the image_id in this annotation is the same as", "\n", "# the image_id we're looking at.", "\n", "# This fails only when the data parsing logic or the annotation file is buggy.", "\n", "\n", "# The original COCO valminusminival2014 & minival2014 annotation files", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._maybe_add_segm": [[158, 168], ["isinstance", "len", "len", "len"], "function", ["None"], ["# can trigger this assertion.", "\n", "            ", "assert", "anno", "[", "\"image_id\"", "]", "==", "image_id", "\n", "\n", "assert", "anno", ".", "get", "(", "\"ignore\"", ",", "0", ")", "==", "0", ",", "'\"ignore\" in COCO json file is not supported.'", "\n", "\n", "obj", "=", "{", "key", ":", "anno", "[", "key", "]", "for", "key", "in", "ann_keys", "if", "key", "in", "anno", "}", "\n", "\n", "segm", "=", "anno", ".", "get", "(", "\"segmentation\"", ",", "None", ")", "\n", "if", "segm", ":", "# either list[list[float]] or dict(RLE)", "\n", "                ", "if", "isinstance", "(", "segm", ",", "dict", ")", ":", "\n", "                    ", "if", "isinstance", "(", "segm", "[", "\"counts\"", "]", ",", "list", ")", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._maybe_add_keypoints": [[170, 182], ["enumerate"], "function", ["None"], ["                        ", "segm", "=", "mask_util", ".", "frPyObjects", "(", "segm", ",", "*", "segm", "[", "\"size\"", "]", ")", "\n", "", "", "else", ":", "\n", "# filter out invalid polygons (< 3 points)", "\n", "                    ", "segm", "=", "[", "poly", "for", "poly", "in", "segm", "if", "len", "(", "poly", ")", "%", "2", "==", "0", "and", "len", "(", "poly", ")", ">=", "6", "]", "\n", "if", "len", "(", "segm", ")", "==", "0", ":", "\n", "                        ", "num_instances_without_valid_segmentation", "+=", "1", "\n", "continue", "# ignore this instance", "\n", "", "", "obj", "[", "\"segmentation\"", "]", "=", "segm", "\n", "\n", "", "keypts", "=", "anno", ".", "get", "(", "\"keypoints\"", ",", "None", ")", "\n", "if", "keypts", ":", "# list[int]", "\n", "                ", "for", "idx", ",", "v", "in", "enumerate", "(", "keypts", ")", ":", "\n", "                    ", "if", "idx", "%", "3", "!=", "2", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._maybe_add_densepose": [[184, 188], ["None"], "function", ["None"], ["# but keypoint coordinates are integers in [0, H-1 or W-1]", "\n", "# Therefore we assume the coordinates are \"pixel indices\" and", "\n", "# add 0.5 to convert to floating point coordinates.", "\n", "                        ", "keypts", "[", "idx", "]", "=", "v", "+", "0.5", "\n", "", "", "obj", "[", "\"keypoints\"", "]", "=", "keypts", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._combine_images_with_annotations": [[190, 227], ["zip", "os.path.join", "dataset_dicts.append", "coco.create_video_frame_mapping", "img_dict.get", "coco._maybe_add_bbox", "coco._maybe_add_segm", "coco._maybe_add_keypoints", "coco._maybe_add_densepose", "objs.append", "ann_dict.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.create_video_frame_mapping", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._maybe_add_bbox", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._maybe_add_segm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._maybe_add_keypoints", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco._maybe_add_densepose", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "obj", "[", "\"bbox_mode\"", "]", "=", "BoxMode", ".", "XYWH_ABS", "\n", "if", "id_map", ":", "\n", "                ", "obj", "[", "\"category_id\"", "]", "=", "id_map", "[", "obj", "[", "\"category_id\"", "]", "]", "\n", "", "objs", ".", "append", "(", "obj", ")", "\n", "", "record", "[", "\"annotations\"", "]", "=", "objs", "\n", "dataset_dicts", ".", "append", "(", "record", ")", "\n", "\n", "", "if", "num_instances_without_valid_segmentation", ">", "0", ":", "\n", "        ", "logger", ".", "warning", "(", "\n", "\"Filtered out {} instances without valid segmentation. \"", ".", "format", "(", "\n", "num_instances_without_valid_segmentation", "\n", ")", "\n", "+", "\"There might be issues in your dataset generation process. \"", "\n", "\"A valid polygon should be a list[float] with even length >= 6.\"", "\n", ")", "\n", "", "return", "dataset_dicts", "\n", "\n", "\n", "", "def", "load_sem_seg", "(", "gt_root", ",", "image_root", ",", "gt_ext", "=", "\"png\"", ",", "image_ext", "=", "\"jpg\"", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.create_video_frame_mapping": [[229, 237], ["collections.defaultdict", "detectron2.data.MetadataCatalog.get().set", "d.get", "mapping[].update", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["\n", "\n", "# We match input images with ground truth based on their relative filepaths (without file", "\n", "# extensions) starting from 'image_root' and 'gt_root' respectively.", "\n", "def", "file2id", "(", "folder_path", ",", "file_path", ")", ":", "\n", "# extract relative path starting from `folder_path`", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.register_dataset": [[283, 308], ["utils.maybe_prepend_base_path", "utils.maybe_prepend_base_path", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "coco.load_coco_json", "detectron2.data.MetadataCatalog.get", "coco.get_metadata"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.maybe_prepend_base_path", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.maybe_prepend_base_path", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.load_coco_json", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.get_metadata"], ["\n", "", "def", "convert_to_coco_dict", "(", "dataset_name", ")", ":", "\n", "    ", "\"\"\"\n    Convert an instance detection/segmentation or keypoint detection dataset\n    in detectron2's standard format into COCO json format.\n\n    Generic dataset description can be found here:\n    https://detectron2.readthedocs.io/tutorials/datasets.html#register-a-dataset\n\n    COCO data format description can be found here:\n    http://cocodataset.org/#format-data\n\n    Args:\n        dataset_name (str):\n            name of the source dataset\n            Must be registered in DatastCatalog and in detectron2's standard format.\n            Must have corresponding metadata \"thing_classes\"\n    Returns:\n        coco_dict: serializable dict in COCO json format\n    \"\"\"", "\n", "\n", "dataset_dicts", "=", "DatasetCatalog", ".", "get", "(", "dataset_name", ")", "\n", "metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "\n", "# unmap the category mapping ids for COCO", "\n", "if", "hasattr", "(", "metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.register_datasets": [[311, 325], ["coco.register_dataset"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.chimpnsee.register_dataset"], ["", "else", ":", "\n", "        ", "reverse_id_mapper", "=", "lambda", "contiguous_id", ":", "contiguous_id", "# noqa", "\n", "\n", "", "categories", "=", "[", "\n", "{", "\"id\"", ":", "reverse_id_mapper", "(", "id", ")", ",", "\"name\"", ":", "name", "}", "\n", "for", "id", ",", "name", "in", "enumerate", "(", "metadata", ".", "thing_classes", ")", "\n", "]", "\n", "\n", "logger", ".", "info", "(", "\"Converting dataset dicts into COCO format\"", ")", "\n", "coco_images", "=", "[", "]", "\n", "coco_annotations", "=", "[", "]", "\n", "\n", "for", "image_id", ",", "image_dict", "in", "enumerate", "(", "dataset_dicts", ")", ":", "\n", "        ", "coco_image", "=", "{", "\n", "\"id\"", ":", "image_dict", ".", "get", "(", "\"image_id\"", ",", "image_id", ")", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.chimpnsee.register_dataset": [[14, 28], ["utils.maybe_prepend_base_path", "utils.maybe_prepend_base_path", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.maybe_prepend_base_path", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.maybe_prepend_base_path", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "register_dataset", "(", "datasets_root", ":", "Optional", "[", "os", ".", "PathLike", "]", "=", "None", ")", ":", "\n", "    ", "def", "empty_load_callback", "(", ")", ":", "\n", "        ", "pass", "\n", "\n", "", "video_list_fpath", "=", "maybe_prepend_base_path", "(", "\n", "datasets_root", ",", "\"chimpnsee/cdna.eva.mpg.de/video_list.txt\"", "\n", ")", "\n", "video_base_path", "=", "maybe_prepend_base_path", "(", "datasets_root", ",", "\"chimpnsee/cdna.eva.mpg.de\"", ")", "\n", "\n", "DatasetCatalog", ".", "register", "(", "CHIMPNSEE_DATASET_NAME", ",", "empty_load_callback", ")", "\n", "MetadataCatalog", ".", "get", "(", "CHIMPNSEE_DATASET_NAME", ")", ".", "set", "(", "\n", "dataset_type", "=", "DatasetType", ".", "VIDEO_LIST", ",", "\n", "video_list_fpath", "=", "video_list_fpath", ",", "\n", "video_base_path", "=", "video_base_path", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.coco_utils.coco_annotation_to_voc_style.coco_to_voc_detection": [[7, 34], ["os.makedirs", "pycocotools.coco.COCO", "enumerate", "os.path.join", "xml.Element", "xml.SubElement", "str", "str", "str", "xml.ElementTree().write", "xml.SubElement", "xml.SubElement", "xml.SubElement", "xml.SubElement", "xml.SubElement", "xml.SubElement", "str", "str", "str", "str", "os.path.join", "print", "xml.SubElement", "xml.SubElement", "xml.SubElement", "int", "xml.SubElement", "int", "xml.SubElement", "int", "xml.SubElement", "int", "xml.ElementTree", "image_details[].split", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write"], ["def", "coco_to_voc_detection", "(", "coco_annotation_file", ",", "target_folder", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "target_folder", ",", "'Annotations'", ")", ",", "exist_ok", "=", "True", ")", "\n", "coco_instance", "=", "COCO", "(", "coco_annotation_file", ")", "\n", "for", "index", ",", "image_id", "in", "enumerate", "(", "coco_instance", ".", "imgToAnns", ")", ":", "\n", "        ", "image_details", "=", "coco_instance", ".", "imgs", "[", "image_id", "]", "\n", "annotation_el", "=", "ET", ".", "Element", "(", "'annotation'", ")", "\n", "ET", ".", "SubElement", "(", "annotation_el", ",", "'filename'", ")", ".", "text", "=", "image_details", "[", "'file_name'", "]", "\n", "\n", "size_el", "=", "ET", ".", "SubElement", "(", "annotation_el", ",", "'size'", ")", "\n", "ET", ".", "SubElement", "(", "size_el", ",", "'width'", ")", ".", "text", "=", "str", "(", "image_details", "[", "'width'", "]", ")", "\n", "ET", ".", "SubElement", "(", "size_el", ",", "'height'", ")", ".", "text", "=", "str", "(", "image_details", "[", "'height'", "]", ")", "\n", "ET", ".", "SubElement", "(", "size_el", ",", "'depth'", ")", ".", "text", "=", "str", "(", "3", ")", "\n", "\n", "for", "annotation", "in", "coco_instance", ".", "imgToAnns", "[", "image_id", "]", ":", "\n", "            ", "object_el", "=", "ET", ".", "SubElement", "(", "annotation_el", ",", "'object'", ")", "\n", "ET", ".", "SubElement", "(", "object_el", ",", "'name'", ")", ".", "text", "=", "coco_instance", ".", "cats", "[", "annotation", "[", "'category_id'", "]", "]", "[", "'name'", "]", "\n", "# ET.SubElement(object_el, 'name').text = 'unknown'", "\n", "ET", ".", "SubElement", "(", "object_el", ",", "'difficult'", ")", ".", "text", "=", "'0'", "\n", "bb_el", "=", "ET", ".", "SubElement", "(", "object_el", ",", "'bndbox'", ")", "\n", "ET", ".", "SubElement", "(", "bb_el", ",", "'xmin'", ")", ".", "text", "=", "str", "(", "int", "(", "annotation", "[", "'bbox'", "]", "[", "0", "]", "+", "1.0", ")", ")", "\n", "ET", ".", "SubElement", "(", "bb_el", ",", "'ymin'", ")", ".", "text", "=", "str", "(", "int", "(", "annotation", "[", "'bbox'", "]", "[", "1", "]", "+", "1.0", ")", ")", "\n", "ET", ".", "SubElement", "(", "bb_el", ",", "'xmax'", ")", ".", "text", "=", "str", "(", "int", "(", "annotation", "[", "'bbox'", "]", "[", "0", "]", "+", "annotation", "[", "'bbox'", "]", "[", "2", "]", "+", "1.0", ")", ")", "\n", "ET", ".", "SubElement", "(", "bb_el", ",", "'ymax'", ")", ".", "text", "=", "str", "(", "int", "(", "annotation", "[", "'bbox'", "]", "[", "1", "]", "+", "annotation", "[", "'bbox'", "]", "[", "3", "]", "+", "1.0", ")", ")", "\n", "\n", "", "ET", ".", "ElementTree", "(", "annotation_el", ")", ".", "write", "(", "os", ".", "path", ".", "join", "(", "target_folder", ",", "'Annotations'", ",", "image_details", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "'.xml'", ")", ")", "\n", "if", "index", "%", "10000", "==", "0", ":", "\n", "            ", "print", "(", "'Processed '", "+", "str", "(", "index", ")", "+", "' images.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.demo.setup_cfg": [[20, 34], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze"], ["def", "setup_cfg", "(", "args", ")", ":", "\n", "# load config from file and command-line arguments", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "# To use demo for Panoptic-DeepLab, please uncomment the following two lines.", "\n", "# from detectron2.projects.panoptic_deeplab import add_panoptic_deeplab_config  # noqa", "\n", "# add_panoptic_deeplab_config(cfg)", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "# Set score_threshold for builtin models", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.demo.get_parser": [[36, 71], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["", "def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Detectron2 demo for builtin configs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config-file\"", ",", "\n", "default", "=", "\"configs/quick_schedules/mask_rcnn_R_50_FPN_inference_acc_test.yaml\"", ",", "\n", "metavar", "=", "\"FILE\"", ",", "\n", "help", "=", "\"path to config file\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--webcam\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Take inputs from webcam.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--video-input\"", ",", "help", "=", "\"Path to video file.\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--input\"", ",", "\n", "nargs", "=", "\"+\"", ",", "\n", "help", "=", "\"A list of space separated input images; \"", "\n", "\"or a single glob pattern such as 'directory/*.jpg'\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "help", "=", "\"A file or directory to save output visualizations. \"", "\n", "\"If not given, will show output in an OpenCV window.\"", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--confidence-threshold\"", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.5", ",", "\n", "help", "=", "\"Minimum score for instance predictions to be shown\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line 'KEY VALUE' pairs\"", ",", "\n", "default", "=", "[", "]", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.VisualizationDemo.__init__": [[16, 36], ["detectron2.data.MetadataCatalog.get", "torch.device", "torch.cuda.device_count", "predictor.AsyncPredictor", "detectron2.engine.defaults.DefaultPredictor", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ",", "parallel", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            instance_mode (ColorMode):\n            parallel (bool): whether to run the model in different processes from visualization.\n                Useful since the visualization logic can be slow.\n        \"\"\"", "\n", "self", ".", "metadata", "=", "MetadataCatalog", ".", "get", "(", "\n", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", "if", "len", "(", "cfg", ".", "DATASETS", ".", "TEST", ")", "else", "\"__unused\"", "\n", ")", "\n", "self", ".", "cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "instance_mode", "=", "instance_mode", "\n", "\n", "self", ".", "parallel", "=", "parallel", "\n", "if", "parallel", ":", "\n", "            ", "num_gpu", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "self", ".", "predictor", "=", "AsyncPredictor", "(", "cfg", ",", "num_gpus", "=", "num_gpu", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "predictor", "=", "DefaultPredictor", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.VisualizationDemo.run_on_image": [[37, 67], ["predictor.VisualizationDemo.predictor", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_panoptic_seg_predictions", "panoptic_seg.to", "detectron2.utils.visualizer.Visualizer.draw_sem_seg", "predictions[].to", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "predictions[].argmax().to", "predictions[].argmax"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_sem_seg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "", "def", "run_on_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image (np.ndarray): an image of shape (H, W, C) (in BGR order).\n                This is the format used by OpenCV.\n\n        Returns:\n            predictions (dict): the output of the model.\n            vis_output (VisImage): the visualized image output.\n        \"\"\"", "\n", "vis_output", "=", "None", "\n", "predictions", "=", "self", ".", "predictor", "(", "image", ")", "\n", "# Convert image from OpenCV BGR format to Matplotlib RGB format.", "\n", "image", "=", "image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "visualizer", "=", "Visualizer", "(", "image", ",", "self", ".", "metadata", ",", "instance_mode", "=", "self", ".", "instance_mode", ")", "\n", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "            ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_output", "=", "visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_output", "=", "visualizer", ".", "draw_sem_seg", "(", "\n", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", ")", "\n", "", "if", "\"instances\"", "in", "predictions", ":", "\n", "                ", "instances", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_output", "=", "visualizer", ".", "draw_instance_predictions", "(", "predictions", "=", "instances", ")", "\n", "\n", "", "", "return", "predictions", ",", "vis_output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.VisualizationDemo._frame_from_video": [[68, 75], ["video.isOpened", "video.read"], "methods", ["None"], ["", "def", "_frame_from_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "while", "video", ".", "isOpened", "(", ")", ":", "\n", "            ", "success", ",", "frame", "=", "video", ".", "read", "(", ")", "\n", "if", "success", ":", "\n", "                ", "yield", "frame", "\n", "", "else", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.VisualizationDemo.run_on_video": [[76, 130], ["detectron2.utils.video_visualizer.VideoVisualizer", "predictor.VisualizationDemo._frame_from_video", "cv2.cvtColor", "cv2.cvtColor", "collections.deque", "enumerate", "len", "detectron2.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "detectron2.utils.video_visualizer.VideoVisualizer.draw_sem_seg.get_image", "collections.deque.append", "predictor.VisualizationDemo.predictor.put", "collections.deque.popleft", "predictor.VisualizationDemo.predictor.get", "panoptic_seg.to", "predictions[].to", "detectron2.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "collections.deque.popleft", "predictor.VisualizationDemo.predictor.get", "predictor.VisualizationDemo.run_on_video.process_predictions"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.VisualizationDemo._frame_from_video", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "", "def", "run_on_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "\"\"\"\n        Visualizes predictions on frames of the input video.\n\n        Args:\n            video (cv2.VideoCapture): a :class:`VideoCapture` object, whose source can be\n                either a webcam or a video file.\n\n        Yields:\n            ndarray: BGR visualizations of each video frame.\n        \"\"\"", "\n", "video_visualizer", "=", "VideoVisualizer", "(", "self", ".", "metadata", ",", "self", ".", "instance_mode", ")", "\n", "\n", "def", "process_predictions", "(", "frame", ",", "predictions", ")", ":", "\n", "            ", "frame", "=", "cv2", ".", "cvtColor", "(", "frame", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "                ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "frame", ",", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "elif", "\"instances\"", "in", "predictions", ":", "\n", "                ", "predictions", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_instance_predictions", "(", "frame", ",", "predictions", ")", "\n", "", "elif", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_frame", "=", "video_visualizer", ".", "draw_sem_seg", "(", "\n", "frame", ",", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", ")", "\n", "\n", "# Converts Matplotlib RGB format to OpenCV BGR format", "\n", "", "vis_frame", "=", "cv2", ".", "cvtColor", "(", "vis_frame", ".", "get_image", "(", ")", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "return", "vis_frame", "\n", "\n", "", "frame_gen", "=", "self", ".", "_frame_from_video", "(", "video", ")", "\n", "if", "self", ".", "parallel", ":", "\n", "            ", "buffer_size", "=", "self", ".", "predictor", ".", "default_buffer_size", "\n", "\n", "frame_data", "=", "deque", "(", ")", "\n", "\n", "for", "cnt", ",", "frame", "in", "enumerate", "(", "frame_gen", ")", ":", "\n", "                ", "frame_data", ".", "append", "(", "frame", ")", "\n", "self", ".", "predictor", ".", "put", "(", "frame", ")", "\n", "\n", "if", "cnt", ">=", "buffer_size", ":", "\n", "                    ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "\n", "", "", "while", "len", "(", "frame_data", ")", ":", "\n", "                ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "frame", "in", "frame_gen", ":", "\n", "                ", "yield", "process_predictions", "(", "frame", ",", "self", ".", "predictor", "(", "frame", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.__init__": [[160, 186], ["max", "multiprocessing.Queue", "multiprocessing.Queue", "range", "atexit.register", "max", "cfg.clone.clone.clone", "cfg.clone.clone.defrost", "predictor.AsyncPredictor.procs.append", "p.start", "AsyncPredictor._PredictWorker"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "", "", "def", "__init__", "(", "self", ",", "cfg", ",", "num_gpus", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            num_gpus (int): if 0, will run on CPU\n        \"\"\"", "\n", "num_workers", "=", "max", "(", "num_gpus", ",", "1", ")", "\n", "self", ".", "task_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "result_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "procs", "=", "[", "]", "\n", "for", "gpuid", "in", "range", "(", "max", "(", "num_gpus", ",", "1", ")", ")", ":", "\n", "            ", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "MODEL", ".", "DEVICE", "=", "\"cuda:{}\"", ".", "format", "(", "gpuid", ")", "if", "num_gpus", ">", "0", "else", "\"cpu\"", "\n", "self", ".", "procs", ".", "append", "(", "\n", "AsyncPredictor", ".", "_PredictWorker", "(", "cfg", ",", "self", ".", "task_queue", ",", "self", ".", "result_queue", ")", "\n", ")", "\n", "\n", "", "self", ".", "put_idx", "=", "0", "\n", "self", ".", "get_idx", "=", "0", "\n", "self", ".", "result_rank", "=", "[", "]", "\n", "self", ".", "result_data", "=", "[", "]", "\n", "\n", "for", "p", "in", "self", ".", "procs", ":", "\n", "            ", "p", ".", "start", "(", ")", "\n", "", "atexit", ".", "register", "(", "self", ".", "shutdown", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.put": [[187, 190], ["predictor.AsyncPredictor.task_queue.put"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.put"], ["", "def", "put", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put_idx", "+=", "1", "\n", "self", ".", "task_queue", ".", "put", "(", "(", "self", ".", "put_idx", ",", "image", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.get": [[191, 206], ["len", "predictor.AsyncPredictor.result_queue.get", "bisect.bisect", "predictor.AsyncPredictor.result_rank.insert", "predictor.AsyncPredictor.result_data.insert"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "self", ".", "get_idx", "+=", "1", "# the index needed for this request", "\n", "if", "len", "(", "self", ".", "result_rank", ")", "and", "self", ".", "result_rank", "[", "0", "]", "==", "self", ".", "get_idx", ":", "\n", "            ", "res", "=", "self", ".", "result_data", "[", "0", "]", "\n", "del", "self", ".", "result_data", "[", "0", "]", ",", "self", ".", "result_rank", "[", "0", "]", "\n", "return", "res", "\n", "\n", "", "while", "True", ":", "\n", "# make sure the results are returned in the correct order", "\n", "            ", "idx", ",", "res", "=", "self", ".", "result_queue", ".", "get", "(", ")", "\n", "if", "idx", "==", "self", ".", "get_idx", ":", "\n", "                ", "return", "res", "\n", "", "insert", "=", "bisect", ".", "bisect", "(", "self", ".", "result_rank", ",", "idx", ")", "\n", "self", ".", "result_rank", ".", "insert", "(", "insert", ",", "idx", ")", "\n", "self", ".", "result_data", ".", "insert", "(", "insert", ",", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.__len__": [[207, 209], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "put_idx", "-", "self", ".", "get_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.__call__": [[210, 213], ["predictor.AsyncPredictor.put", "predictor.AsyncPredictor.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "__call__", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put", "(", "image", ")", "\n", "return", "self", ".", "get", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.shutdown": [[214, 217], ["predictor.AsyncPredictor.task_queue.put", "AsyncPredictor._StopToken"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.put"], ["", "def", "shutdown", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "self", ".", "procs", ":", "\n", "            ", "self", ".", "task_queue", ".", "put", "(", "AsyncPredictor", ".", "_StopToken", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.demo.predictor.AsyncPredictor.default_buffer_size": [[218, 221], ["len"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "default_buffer_size", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "procs", ")", "*", "5", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.tsne.plot_tsne": [[12, 37], ["matplotlib.subplots", "enumerate", "matplotlib.savefig", "time.time", "sklearn.manifold.TSNE", "manifold.TSNE.fit_transform", "time.time", "print", "ax.set_title", "ax.scatter", "ax.xaxis.set_major_formatter", "ax.yaxis.set_major_formatter", "ax.axis", "matplotlib.legend", "matplotlib.ticker.NullFormatter", "matplotlib.ticker.NullFormatter", "ax.scatter.legend_elements"], "function", ["None"], ["def", "plot_tsne", "(", "X", ",", "label", ")", ":", "\n", "    ", "n_components", "=", "2", "\n", "(", "fig", ",", "subplots", ")", "=", "plt", ".", "subplots", "(", "1", ",", "5", ",", "figsize", "=", "(", "15", ",", "8", ")", ")", "\n", "\n", "perplexities", "=", "[", "5", ",", "30", ",", "50", ",", "100", ",", "150", "]", "\n", "\n", "for", "i", ",", "perplexity", "in", "enumerate", "(", "perplexities", ")", ":", "\n", "        ", "ax", "=", "subplots", "[", "i", "]", "\n", "\n", "t0", "=", "time", "(", ")", "\n", "tsne", "=", "manifold", ".", "TSNE", "(", "n_components", "=", "n_components", ",", "init", "=", "'random'", ",", "\n", "random_state", "=", "0", ",", "perplexity", "=", "perplexity", ")", "\n", "Y", "=", "tsne", ".", "fit_transform", "(", "X", ")", "\n", "t1", "=", "time", "(", ")", "\n", "print", "(", "\"circles, perplexity=%d in %.2g sec\"", "%", "(", "perplexity", ",", "t1", "-", "t0", ")", ")", "\n", "ax", ".", "set_title", "(", "\"Perplexity=%d\"", "%", "perplexity", ")", "\n", "sc", "=", "ax", ".", "scatter", "(", "Y", "[", ":", ",", "0", "]", ",", "Y", "[", ":", ",", "1", "]", ",", "c", "=", "label", ",", "cmap", "=", "\"Set1\"", ")", "\n", "ax", ".", "xaxis", ".", "set_major_formatter", "(", "NullFormatter", "(", ")", ")", "\n", "ax", ".", "yaxis", ".", "set_major_formatter", "(", "NullFormatter", "(", ")", ")", "\n", "ax", ".", "axis", "(", "'tight'", ")", "\n", "plt", ".", "legend", "(", "handles", "=", "sc", ".", "legend_elements", "(", ")", "[", "0", "]", ",", "labels", "=", "[", "'0'", ",", "'1'", "]", ")", "\n", "\n", "# plt.show()", "\n", "\n", "", "plt", ".", "savefig", "(", "'tsne.png'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.get_evaluator": [[61, 107], ["detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.PascalVOCDetectionEvaluator", "detectron2.evaluation.LVISEvaluator", "len", "NotImplementedError", "len", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.COCOPanopticEvaluator", "torch.cuda.device_count", "detectron2.get_rank", "torch.cuda.device_count", "detectron2.get_rank"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["def", "get_evaluator", "(", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Create evaluator(s) for a given dataset.\n    This uses the special metadata \"evaluator_type\" associated with each builtin dataset.\n    For your own dataset, you can simply create an evaluator manually in your\n    script and do not have to worry about the hacky if-else logic here.\n    \"\"\"", "\n", "if", "output_folder", "is", "None", ":", "\n", "        ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluator_list", "=", "[", "]", "\n", "evaluator_type", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "evaluator_type", "\n", "if", "evaluator_type", "in", "[", "\"sem_seg\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "        ", "evaluator_list", ".", "append", "(", "\n", "SemSegEvaluator", "(", "\n", "dataset_name", ",", "\n", "distributed", "=", "True", ",", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", ",", "\n", "ignore_label", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", ",", "\n", "output_dir", "=", "output_folder", ",", "\n", ")", "\n", ")", "\n", "", "if", "evaluator_type", "in", "[", "\"coco\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "        ", "evaluator_list", ".", "append", "(", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"coco_panoptic_seg\"", ":", "\n", "        ", "evaluator_list", ".", "append", "(", "COCOPanopticEvaluator", "(", "dataset_name", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_instance\"", ":", "\n", "        ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesInstanceEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_sem_seg\"", ":", "\n", "        ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesSemSegEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"pascal_voc\"", ":", "\n", "        ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"lvis\"", ":", "\n", "        ", "return", "LVISEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "", "if", "len", "(", "evaluator_list", ")", "==", "0", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\n", "\"no Evaluator for the dataset {} with the type {}\"", ".", "format", "(", "dataset_name", ",", "evaluator_type", ")", "\n", ")", "\n", "", "if", "len", "(", "evaluator_list", ")", "==", "1", ":", "\n", "        ", "return", "evaluator_list", "[", "0", "]", "\n", "", "return", "DatasetEvaluators", "(", "evaluator_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.do_test": [[109, 124], ["collections.OrderedDict", "detectron2.data.build_detection_test_loader", "plain_train_net.get_evaluator", "detectron2.evaluation.inference_on_dataset", "detectron2.is_main_process", "len", "os.path.join", "logger.info", "detectron2.evaluation.print_csv_format", "list", "collections.OrderedDict.values"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_test_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.get_evaluator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.inference_on_dataset", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.print_csv_format", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "do_test", "(", "cfg", ",", "model", ")", ":", "\n", "    ", "results", "=", "OrderedDict", "(", ")", "\n", "for", "dataset_name", "in", "cfg", ".", "DATASETS", ".", "TEST", ":", "\n", "        ", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "dataset_name", ")", "\n", "evaluator", "=", "get_evaluator", "(", "\n", "cfg", ",", "dataset_name", ",", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ",", "dataset_name", ")", "\n", ")", "\n", "results_i", "=", "inference_on_dataset", "(", "model", ",", "data_loader", ",", "evaluator", ")", "\n", "results", "[", "dataset_name", "]", "=", "results_i", "\n", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "logger", ".", "info", "(", "\"Evaluation results for {} in csv format:\"", ".", "format", "(", "dataset_name", ")", ")", "\n", "print_csv_format", "(", "results_i", ")", "\n", "", "", "if", "len", "(", "results", ")", "==", "1", ":", "\n", "        ", "results", "=", "list", "(", "results", ".", "values", "(", ")", ")", "[", "0", "]", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.do_train": [[126, 191], ["model.train", "detectron2.solver.build_optimizer", "detectron2.solver.build_lr_scheduler", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.checkpoint.PeriodicCheckpointer", "detectron2.data.build_detection_train_loader", "logger.info", "detectron2.checkpoint.DetectionCheckpointer.resume_or_load().get", "detectron2.is_main_process", "detectron2.utils.events.EventStorage", "zip", "detectron2.utils.events.CommonMetricPrinter", "detectron2.utils.events.JSONWriter", "detectron2.utils.events.TensorboardXWriter", "range", "model", "sum", "torch.isfinite().all", "sum", "detectron2.is_main_process", "detectron2.solver.build_optimizer.zero_grad", "sum.backward", "detectron2.solver.build_optimizer.step", "storage.put_scalar", "detectron2.solver.build_lr_scheduler.step", "detectron2.checkpoint.PeriodicCheckpointer.step", "detectron2.checkpoint.DetectionCheckpointer.resume_or_load", "os.path.join", "model.values", "v.item", "storage.put_scalars", "plain_train_net.do_test", "detectron2.synchronize", "torch.isfinite", "detectron2.reduce_dict().items", "writer.write", "loss_dict_reduced.values", "detectron2.reduce_dict"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.Trainer.build_optimizer", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.build_solver.build_lr_scheduler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalars", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.do_test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.reduce_dict"], ["", "def", "do_train", "(", "cfg", ",", "model", ",", "resume", "=", "False", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "optimizer", "=", "build_optimizer", "(", "cfg", ",", "model", ")", "\n", "scheduler", "=", "build_lr_scheduler", "(", "cfg", ",", "optimizer", ")", "\n", "\n", "checkpointer", "=", "DetectionCheckpointer", "(", "\n", "model", ",", "cfg", ".", "OUTPUT_DIR", ",", "optimizer", "=", "optimizer", ",", "scheduler", "=", "scheduler", "\n", ")", "\n", "start_iter", "=", "(", "\n", "checkpointer", ".", "resume_or_load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "resume", ")", ".", "get", "(", "\"iteration\"", ",", "-", "1", ")", "+", "1", "\n", ")", "\n", "max_iter", "=", "cfg", ".", "SOLVER", ".", "MAX_ITER", "\n", "\n", "periodic_checkpointer", "=", "PeriodicCheckpointer", "(", "\n", "checkpointer", ",", "cfg", ".", "SOLVER", ".", "CHECKPOINT_PERIOD", ",", "max_iter", "=", "max_iter", "\n", ")", "\n", "\n", "writers", "=", "(", "\n", "[", "\n", "CommonMetricPrinter", "(", "max_iter", ")", ",", "\n", "JSONWriter", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"metrics.json\"", ")", ")", ",", "\n", "TensorboardXWriter", "(", "cfg", ".", "OUTPUT_DIR", ")", ",", "\n", "]", "\n", "if", "comm", ".", "is_main_process", "(", ")", "\n", "else", "[", "]", "\n", ")", "\n", "\n", "# compared to \"train_net.py\", we do not support accurate timing and", "\n", "# precise BN here, because they are not trivial to implement in a small training loop", "\n", "data_loader", "=", "build_detection_train_loader", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Starting training from iteration {}\"", ".", "format", "(", "start_iter", ")", ")", "\n", "with", "EventStorage", "(", "start_iter", ")", "as", "storage", ":", "\n", "        ", "for", "data", ",", "iteration", "in", "zip", "(", "data_loader", ",", "range", "(", "start_iter", ",", "max_iter", ")", ")", ":", "\n", "            ", "storage", ".", "iter", "=", "iteration", "\n", "\n", "loss_dict", "=", "model", "(", "data", ")", "\n", "losses", "=", "sum", "(", "loss_dict", ".", "values", "(", ")", ")", "\n", "assert", "torch", ".", "isfinite", "(", "losses", ")", ".", "all", "(", ")", ",", "loss_dict", "\n", "\n", "loss_dict_reduced", "=", "{", "k", ":", "v", ".", "item", "(", ")", "for", "k", ",", "v", "in", "comm", ".", "reduce_dict", "(", "loss_dict", ")", ".", "items", "(", ")", "}", "\n", "losses_reduced", "=", "sum", "(", "loss", "for", "loss", "in", "loss_dict_reduced", ".", "values", "(", ")", ")", "\n", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "                ", "storage", ".", "put_scalars", "(", "total_loss", "=", "losses_reduced", ",", "**", "loss_dict_reduced", ")", "\n", "\n", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"lr\"", ",", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", ",", "smoothing_hint", "=", "False", ")", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n", "if", "(", "\n", "cfg", ".", "TEST", ".", "EVAL_PERIOD", ">", "0", "\n", "and", "(", "iteration", "+", "1", ")", "%", "cfg", ".", "TEST", ".", "EVAL_PERIOD", "==", "0", "\n", "and", "iteration", "!=", "max_iter", "-", "1", "\n", ")", ":", "\n", "                ", "do_test", "(", "cfg", ",", "model", ")", "\n", "# Compared to \"train_net.py\", the test results are not dumped to EventStorage", "\n", "comm", ".", "synchronize", "(", ")", "\n", "\n", "", "if", "iteration", "-", "start_iter", ">", "5", "and", "(", "\n", "(", "iteration", "+", "1", ")", "%", "20", "==", "0", "or", "iteration", "==", "max_iter", "-", "1", "\n", ")", ":", "\n", "                ", "for", "writer", "in", "writers", ":", "\n", "                    ", "writer", ".", "write", "(", ")", "\n", "", "", "periodic_checkpointer", ".", "step", "(", "iteration", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.setup": [[193, 205], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup"], ["", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "\n", "cfg", ",", "args", "\n", ")", "# if you don't like any of the default setup, write your own setup code", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.main": [[207, 226], ["plain_train_net.setup", "detectron2.modeling.build_model", "logger.info", "plain_train_net.do_train", "plain_train_net.do_test", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "plain_train_net.do_test", "detectron2.get_world_size", "torch.nn.parallel.DistributedDataParallel", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.get_local_rank"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.do_train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.do_test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plain_train_net.do_test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_local_rank"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Model:\\n{}\"", ".", "format", "(", "model", ")", ")", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "DetectionCheckpointer", "(", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", "\n", ")", "\n", "return", "do_test", "(", "cfg", ",", "model", ")", "\n", "\n", "", "distributed", "=", "comm", ".", "get_world_size", "(", ")", ">", "1", "\n", "if", "distributed", ":", "\n", "        ", "model", "=", "DistributedDataParallel", "(", "\n", "model", ",", "device_ids", "=", "[", "comm", ".", "get_local_rank", "(", ")", "]", ",", "broadcast_buffers", "=", "False", "\n", ")", "\n", "\n", "", "do_train", "(", "cfg", ",", "model", ",", "resume", "=", "args", ".", "resume", ")", "\n", "return", "do_test", "(", "cfg", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plot_tsne.plot_tsne": [[16, 45], ["matplotlib.subplots", "enumerate", "matplotlib.savefig", "time.time", "sklearn.manifold.TSNE", "manifold.TSNE.fit_transform", "time.time", "print", "ax.set_title", "seaborn.scatterplot", "ax.xaxis.set_major_formatter", "ax.yaxis.set_major_formatter", "ax.axis", "matplotlib.ticker.NullFormatter", "matplotlib.ticker.NullFormatter"], "function", ["None"], ["def", "plot_tsne", "(", "X", ",", "label", ",", "total_num_classes", ")", ":", "\n", "    ", "n_components", "=", "2", "\n", "(", "fig", ",", "subplots", ")", "=", "plt", ".", "subplots", "(", "1", ",", "5", ",", "figsize", "=", "(", "15", ",", "8", ")", ")", "\n", "\n", "perplexities", "=", "[", "5", ",", "30", ",", "50", ",", "100", ",", "150", "]", "\n", "\n", "for", "i", ",", "perplexity", "in", "enumerate", "(", "perplexities", ")", ":", "\n", "        ", "ax", "=", "subplots", "[", "i", "]", "\n", "\n", "t0", "=", "time", "(", ")", "\n", "tsne", "=", "manifold", ".", "TSNE", "(", "n_components", "=", "n_components", ",", "init", "=", "'random'", ",", "\n", "random_state", "=", "0", ",", "perplexity", "=", "perplexity", ")", "\n", "Y", "=", "tsne", ".", "fit_transform", "(", "X", ")", "\n", "t1", "=", "time", "(", ")", "\n", "print", "(", "\"circles, perplexity=%d in %.2g sec\"", "%", "(", "perplexity", ",", "t1", "-", "t0", ")", ")", "\n", "ax", ".", "set_title", "(", "\"Perplexity=%d\"", "%", "perplexity", ")", "\n", "#", "\n", "# sc = ax.scatter(Y[:, 0], Y[:, 1], c=label, cmap=\"plasma\")", "\n", "sns", ".", "scatterplot", "(", "x", "=", "Y", "[", ":", ",", "0", "]", ",", "y", "=", "Y", "[", ":", ",", "1", "]", ",", "hue", "=", "label", ",", "ax", "=", "ax", ",", "legend", "=", "'full'", ",", "palette", "=", "'colorblind'", ")", "\n", "ax", ".", "xaxis", ".", "set_major_formatter", "(", "NullFormatter", "(", ")", ")", "\n", "ax", ".", "yaxis", ".", "set_major_formatter", "(", "NullFormatter", "(", ")", ")", "\n", "ax", ".", "axis", "(", "'tight'", ")", "\n", "# plt.legend(handles=sc.legend_elements()[0], labels=range(total_num_classes))", "\n", "\n", "# plt.legend(handles=sc.legend_elements()[0], labels=['0', '1'])", "\n", "\n", "# plt.show()", "\n", "\n", "", "plt", ".", "savefig", "(", "'tsne.png'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.plot_tsne.plot_tsne_indiv": [[46, 90], ["list", "enumerate", "range", "matplotlib.subplots", "time.time", "sklearn.manifold.TSNE", "manifold.TSNE.fit_transform", "time.time", "print", "seaborn.scatterplot", "ax.xaxis.set_major_formatter", "ax.yaxis.set_major_formatter", "ax.axis", "matplotlib.legend", "matplotlib.savefig", "matplotlib.pause", "matplotlib.clf", "matplotlib.ticker.NullFormatter", "matplotlib.ticker.NullFormatter", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "plot_tsne_indiv", "(", "X", ",", "label", ",", "total_num_classes", ")", ":", "\n", "    ", "n_components", "=", "2", "\n", "\n", "# perplexities = [5, 30, 50, 100, 150]", "\n", "perplexities", "=", "list", "(", "range", "(", "10", ",", "150", ",", "10", ")", ")", "\n", "\n", "for", "i", ",", "perplexity", "in", "enumerate", "(", "perplexities", ")", ":", "\n", "        ", "__", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "t0", "=", "time", "(", ")", "\n", "tsne", "=", "manifold", ".", "TSNE", "(", "n_components", "=", "n_components", ",", "init", "=", "'random'", ",", "\n", "random_state", "=", "0", ",", "perplexity", "=", "perplexity", ")", "\n", "Y", "=", "tsne", ".", "fit_transform", "(", "X", ")", "\n", "t1", "=", "time", "(", ")", "\n", "print", "(", "\"circles, perplexity=%d in %.2g sec\"", "%", "(", "perplexity", ",", "t1", "-", "t0", ")", ")", "\n", "# ax.set_title(\"Perplexity=%d\" % perplexity)", "\n", "#", "\n", "# sc = ax.scatter(Y[:, 0], Y[:, 1], c=label, cmap=\"plasma\")", "\n", "\n", "# palette = sns.color_palette(None, total_num_classes)", "\n", "# palette = sns.color_palette(\"flare\", as_cmap=True)", "\n", "\n", "flatui", "=", "[", "'#e6194b'", ",", "'#3cb44b'", ",", "'#ffe119'", ",", "'#4363d8'", ",", "'#f58231'", ",", "'#911eb4'", ",", "'#46f0f0'", ",", "'#f032e6'", ",", "'#bcf60c'", ",", "'#fabebe'", ",", "'#008080'", ",", "'#e6beff'", ",", "'#9a6324'", ",", "'#fffac8'", ",", "'#800000'", ",", "'#aaffc3'", ",", "'#808000'", ",", "'#ffd8b1'", ",", "'#000075'", ",", "'#808080'", ",", "'#3498db'", "]", "\n", "# sns.set_palette(flatui)", "\n", "sns", ".", "scatterplot", "(", "x", "=", "Y", "[", ":", ",", "0", "]", ",", "y", "=", "Y", "[", ":", ",", "1", "]", ",", "hue", "=", "label", ",", "ax", "=", "ax", ",", "legend", "=", "'full'", ",", "palette", "=", "flatui", ")", "\n", "\n", "# sns.scatterplot(x=Y[:, 0], y=Y[:, 1], hue=label, ax=ax, legend='full', palette='colorblind')", "\n", "ax", ".", "xaxis", ".", "set_major_formatter", "(", "NullFormatter", "(", ")", ")", "\n", "ax", ".", "yaxis", ".", "set_major_formatter", "(", "NullFormatter", "(", ")", ")", "\n", "ax", ".", "axis", "(", "'tight'", ")", "\n", "# plt.legend(handles=sc.legend_elements()[0], labels=range(total_num_classes))", "\n", "\n", "# plt.legend(handles=sc.legend_elements()[0], labels=['0', '1'])", "\n", "\n", "# plt.show()", "\n", "#     plt.legend(fontsize='xx-large', ncol=2, handleheight=2.4, labelspacing=0.05)", "\n", "plt", ".", "legend", "(", "ncol", "=", "6", ")", "\n", "\n", "plt", ".", "savefig", "(", "'tsne_'", "+", "str", "(", "perplexity", ")", "+", "'.png'", ")", "\n", "plt", ".", "pause", "(", "0.0001", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.benchmark.setup": [[34, 42], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.utils.logger.setup_logger", "detectron2.utils.comm.get_rank"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "SOLVER", ".", "BASE_LR", "=", "0.001", "# Avoid NaNs. Not useful in this script anyway.", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "setup_logger", "(", "distributed_rank", "=", "comm", ".", "get_rank", "(", ")", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.benchmark.benchmark_data": [[44, 83], ["benchmark.setup", "fvcore.common.timer.Timer", "detectron2.data.build_detection_train_loader", "logger.info", "fvcore.common.timer.Timer.reset", "iter", "range", "fvcore.common.timer.Timer", "tqdm.trange", "logger.info", "logger.info", "psutil.virtual_memory", "logger.info", "range", "next", "next", "fvcore.common.timer.Timer", "tqdm.trange", "logger.info", "fvcore.common.timer.Timer.seconds", "fvcore.common.timer.Timer.seconds", "fvcore.common.timer.Timer.seconds", "next", "fvcore.common.timer.Timer.seconds"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.reset", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter"], ["", "def", "benchmark_data", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "timer", "=", "Timer", "(", ")", "\n", "dataloader", "=", "build_detection_train_loader", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Initialize loader using {} seconds.\"", ".", "format", "(", "timer", ".", "seconds", "(", ")", ")", ")", "\n", "\n", "timer", ".", "reset", "(", ")", "\n", "itr", "=", "iter", "(", "dataloader", ")", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "# warmup", "\n", "        ", "next", "(", "itr", ")", "\n", "if", "i", "==", "0", ":", "\n", "            ", "startup_time", "=", "timer", ".", "seconds", "(", ")", "\n", "", "", "timer", "=", "Timer", "(", ")", "\n", "max_iter", "=", "1000", "\n", "for", "_", "in", "tqdm", ".", "trange", "(", "max_iter", ")", ":", "\n", "        ", "next", "(", "itr", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"{} iters ({} images) in {} seconds.\"", ".", "format", "(", "\n", "max_iter", ",", "max_iter", "*", "cfg", ".", "SOLVER", ".", "IMS_PER_BATCH", ",", "timer", ".", "seconds", "(", ")", "\n", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\"Startup time: {} seconds\"", ".", "format", "(", "startup_time", ")", ")", "\n", "vram", "=", "psutil", ".", "virtual_memory", "(", ")", "\n", "logger", ".", "info", "(", "\n", "\"RAM Usage: {:.2f}/{:.2f} GB\"", ".", "format", "(", "\n", "(", "vram", ".", "total", "-", "vram", ".", "available", ")", "/", "1024", "**", "3", ",", "vram", ".", "total", "/", "1024", "**", "3", "\n", ")", "\n", ")", "\n", "\n", "# test for a few more rounds", "\n", "for", "_", "in", "range", "(", "10", ")", ":", "\n", "        ", "timer", "=", "Timer", "(", ")", "\n", "max_iter", "=", "1000", "\n", "for", "_", "in", "tqdm", ".", "trange", "(", "max_iter", ")", ":", "\n", "            ", "next", "(", "itr", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"{} iters ({} images) in {} seconds.\"", ".", "format", "(", "\n", "max_iter", ",", "max_iter", "*", "cfg", ".", "SOLVER", ".", "IMS_PER_BATCH", ",", "timer", ".", "seconds", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.benchmark.benchmark_train": [[87, 115], ["benchmark.setup", "detectron2.modeling.build_model", "logger.info", "detectron2.solver.build_optimizer", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.checkpoint.DetectionCheckpointer.load", "setup.defrost", "detectron2.data.build_detection_train_loader", "list", "detectron2.engine.SimpleTrainer", "detectron2.engine.SimpleTrainer.register_hooks", "detectron2.engine.SimpleTrainer.train", "detectron2.utils.comm.get_world_size", "torch.nn.parallel.DistributedDataParallel", "itertools.islice", "detectron2.data.DatasetFromList", "benchmark.benchmark_train.f"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.Trainer.build_optimizer", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], ["", "", "def", "benchmark_train", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Model:\\n{}\"", ".", "format", "(", "model", ")", ")", "\n", "if", "comm", ".", "get_world_size", "(", ")", ">", "1", ":", "\n", "        ", "model", "=", "DistributedDataParallel", "(", "\n", "model", ",", "device_ids", "=", "[", "comm", ".", "get_local_rank", "(", ")", "]", ",", "broadcast_buffers", "=", "False", "\n", ")", "\n", "", "optimizer", "=", "build_optimizer", "(", "cfg", ",", "model", ")", "\n", "checkpointer", "=", "DetectionCheckpointer", "(", "model", ",", "optimizer", "=", "optimizer", ")", "\n", "checkpointer", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "data_loader", "=", "build_detection_train_loader", "(", "cfg", ")", "\n", "dummy_data", "=", "list", "(", "itertools", ".", "islice", "(", "data_loader", ",", "100", ")", ")", "\n", "\n", "def", "f", "(", ")", ":", "\n", "        ", "data", "=", "DatasetFromList", "(", "dummy_data", ",", "copy", "=", "False", ")", "\n", "while", "True", ":", "\n", "            ", "yield", "from", "data", "\n", "\n", "", "", "max_iter", "=", "400", "\n", "trainer", "=", "SimpleTrainer", "(", "model", ",", "f", "(", ")", ",", "optimizer", ")", "\n", "trainer", ".", "register_hooks", "(", "\n", "[", "hooks", ".", "IterationTimer", "(", ")", ",", "hooks", ".", "PeriodicWriter", "(", "[", "CommonMetricPrinter", "(", "max_iter", ")", "]", ")", "]", "\n", ")", "\n", "trainer", ".", "train", "(", "1", ",", "max_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.benchmark.benchmark_eval": [[117, 146], ["torch.no_grad", "benchmark.setup", "detectron2.modeling.build_model", "detectron2.modeling.build_model.eval", "logger.info", "detectron2.checkpoint.DetectionCheckpointer().load", "setup.defrost", "detectron2.data.build_detection_test_loader", "detectron2.data.DatasetFromList", "range", "fvcore.common.timer.Timer", "logger.info", "list", "detectron2.modeling.build_model.", "tqdm.tqdm", "enumerate", "detectron2.checkpoint.DetectionCheckpointer", "itertools.islice", "benchmark.benchmark_train.f"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_test_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "benchmark_eval", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "model", ".", "eval", "(", ")", "\n", "logger", ".", "info", "(", "\"Model:\\n{}\"", ".", "format", "(", "model", ")", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "dummy_data", "=", "DatasetFromList", "(", "list", "(", "itertools", ".", "islice", "(", "data_loader", ",", "100", ")", ")", ",", "copy", "=", "False", ")", "\n", "\n", "def", "f", "(", ")", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "yield", "from", "dummy_data", "\n", "\n", "", "", "for", "k", "in", "range", "(", "5", ")", ":", "# warmup", "\n", "        ", "model", "(", "dummy_data", "[", "k", "]", ")", "\n", "\n", "", "max_iter", "=", "300", "\n", "timer", "=", "Timer", "(", ")", "\n", "with", "tqdm", ".", "tqdm", "(", "total", "=", "max_iter", ")", "as", "pbar", ":", "\n", "        ", "for", "idx", ",", "d", "in", "enumerate", "(", "f", "(", ")", ")", ":", "\n", "            ", "if", "idx", "==", "max_iter", ":", "\n", "                ", "break", "\n", "", "model", "(", "d", ")", "\n", "pbar", ".", "update", "(", ")", "\n", "", "", "logger", ".", "info", "(", "\"{} iters in {} seconds.\"", ".", "format", "(", "max_iter", ",", "timer", ".", "seconds", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.analyze_model.setup": [[24, 32], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.utils.logger.setup_logger"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger"], ["def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "setup_logger", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.analyze_model.do_flop": [[34, 50], ["detectron2.data.build_detection_test_loader", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "detectron2.modeling.build_model.eval", "collections.Counter", "zip", "logger.info", "logger.info", "tqdm.trange", "detectron2.utils.analysis.flop_count_operators", "total_flops.append", "detectron2.checkpoint.DetectionCheckpointer", "sum", "str", "numpy.mean", "numpy.std", "detectron2.utils.analysis.flop_count_operators.values", "collections.Counter.items"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_test_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis.flop_count_operators"], ["", "def", "do_flop", "(", "cfg", ")", ":", "\n", "    ", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "counts", "=", "Counter", "(", ")", "\n", "total_flops", "=", "[", "]", "\n", "for", "idx", ",", "data", "in", "zip", "(", "tqdm", ".", "trange", "(", "args", ".", "num_inputs", ")", ",", "data_loader", ")", ":", "# noqa", "\n", "        ", "count", "=", "flop_count_operators", "(", "model", ",", "data", ")", "\n", "counts", "+=", "count", "\n", "total_flops", ".", "append", "(", "sum", "(", "count", ".", "values", "(", ")", ")", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"(G)Flops for Each Type of Operators:\\n\"", "+", "str", "(", "[", "(", "k", ",", "v", "/", "idx", ")", "for", "k", ",", "v", "in", "counts", ".", "items", "(", ")", "]", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\"Total (G)Flops: {}\u00b1{}\"", ".", "format", "(", "np", ".", "mean", "(", "total_flops", ")", ",", "np", ".", "std", "(", "total_flops", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.analyze_model.do_activation": [[52, 71], ["detectron2.data.build_detection_test_loader", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "detectron2.modeling.build_model.eval", "collections.Counter", "zip", "logger.info", "logger.info", "tqdm.trange", "detectron2.utils.analysis.activation_count_operators", "total_activations.append", "detectron2.checkpoint.DetectionCheckpointer", "sum", "str", "numpy.mean", "numpy.std", "detectron2.utils.analysis.activation_count_operators.values", "collections.Counter.items"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_test_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis.activation_count_operators"], ["", "def", "do_activation", "(", "cfg", ")", ":", "\n", "    ", "data_loader", "=", "build_detection_test_loader", "(", "cfg", ",", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "counts", "=", "Counter", "(", ")", "\n", "total_activations", "=", "[", "]", "\n", "for", "idx", ",", "data", "in", "zip", "(", "tqdm", ".", "trange", "(", "args", ".", "num_inputs", ")", ",", "data_loader", ")", ":", "# noqa", "\n", "        ", "count", "=", "activation_count_operators", "(", "model", ",", "data", ")", "\n", "counts", "+=", "count", "\n", "total_activations", ".", "append", "(", "sum", "(", "count", ".", "values", "(", ")", ")", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"(Million) Activations for Each Type of Operators:\\n\"", "\n", "+", "str", "(", "[", "(", "k", ",", "v", "/", "idx", ")", "for", "k", ",", "v", "in", "counts", ".", "items", "(", ")", "]", ")", "\n", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total (Million) Activations: {}\u00b1{}\"", ".", "format", "(", "\n", "np", ".", "mean", "(", "total_activations", ")", ",", "np", ".", "std", "(", "total_activations", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.analyze_model.do_parameter": [[75, 78], ["detectron2.modeling.build_model", "logger.info", "detectron2.utils.analysis.parameter_count_table"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model"], ["", "def", "do_parameter", "(", "cfg", ")", ":", "\n", "    ", "model", "=", "build_model", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Parameter Count:\\n\"", "+", "parameter_count_table", "(", "model", ",", "max_depth", "=", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.analyze_model.do_structure": [[80, 83], ["detectron2.modeling.build_model", "logger.info", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model"], ["", "def", "do_structure", "(", "cfg", ")", ":", "\n", "    ", "model", "=", "build_model", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "\"Model Structure:\\n\"", "+", "str", "(", "model", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.visualize_data.setup": [[17, 24], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.config.get_cfg.merge_from_file"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file"], ["def", "setup", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "if", "args", ".", "config_file", ":", "\n", "        ", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.visualize_data.parse_args": [[26, 44], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.visualize_data.parse_args"], ["", "def", "parse_args", "(", "in_args", "=", "None", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Visualize ground-truth data\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--source\"", ",", "\n", "choices", "=", "[", "\"annotation\"", ",", "\"dataloader\"", "]", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"visualize the annotations or the data loader (with pre-processing)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--config-file\"", ",", "metavar", "=", "\"FILE\"", ",", "help", "=", "\"path to config file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--output-dir\"", ",", "default", "=", "\"./\"", ",", "help", "=", "\"path to output directory\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--show\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"show output in a window\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line\"", ",", "\n", "default", "=", "None", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n", "return", "parser", ".", "parse_args", "(", "in_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.visualize_json_results.create_instances": [[19, 39], ["detectron2.structures.Instances", "numpy.asarray", "numpy.asarray().reshape", "detectron2.structures.BoxMode.convert", "numpy.asarray", "detectron2.structures.Boxes", "numpy.asarray", "dataset_id_map"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["def", "create_instances", "(", "predictions", ",", "image_size", ")", ":", "\n", "    ", "ret", "=", "Instances", "(", "image_size", ")", "\n", "\n", "score", "=", "np", ".", "asarray", "(", "[", "x", "[", "\"score\"", "]", "for", "x", "in", "predictions", "]", ")", "\n", "chosen", "=", "(", "score", ">", "args", ".", "conf_threshold", ")", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "score", "=", "score", "[", "chosen", "]", "\n", "bbox", "=", "np", ".", "asarray", "(", "[", "predictions", "[", "i", "]", "[", "\"bbox\"", "]", "for", "i", "in", "chosen", "]", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "bbox", "=", "BoxMode", ".", "convert", "(", "bbox", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "\n", "labels", "=", "np", ".", "asarray", "(", "[", "dataset_id_map", "(", "predictions", "[", "i", "]", "[", "\"category_id\"", "]", ")", "for", "i", "in", "chosen", "]", ")", "\n", "\n", "ret", ".", "scores", "=", "score", "\n", "ret", ".", "pred_boxes", "=", "Boxes", "(", "bbox", ")", "\n", "ret", ".", "pred_classes", "=", "labels", "\n", "\n", "try", ":", "\n", "        ", "ret", ".", "pred_masks", "=", "[", "predictions", "[", "i", "]", "[", "\"segmentation\"", "]", "for", "i", "in", "chosen", "]", "\n", "", "except", "KeyError", ":", "\n", "        ", "pass", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.train_net.Trainer.build_evaluator": [[51, 100], ["detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "len", "NotImplementedError", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.COCOPanopticEvaluator", "torch.cuda.device_count", "detectron2.get_rank", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.evaluation.PascalVOCDetectionEvaluator", "len", "detectron2.evaluation.LVISEvaluator"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Create evaluator(s) for a given dataset.\n        This uses the special metadata \"evaluator_type\" associated with each builtin dataset.\n        For your own dataset, you can simply create an evaluator manually in your\n        script and do not have to worry about the hacky if-else logic here.\n        \"\"\"", "\n", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluator_list", "=", "[", "]", "\n", "evaluator_type", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "evaluator_type", "\n", "if", "evaluator_type", "in", "[", "\"sem_seg\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "\n", "SemSegEvaluator", "(", "\n", "dataset_name", ",", "\n", "distributed", "=", "True", ",", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", ",", "\n", "ignore_label", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", ",", "\n", "output_dir", "=", "output_folder", ",", "\n", ")", "\n", ")", "\n", "", "if", "evaluator_type", "in", "[", "\"coco\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"coco_panoptic_seg\"", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOPanopticEvaluator", "(", "dataset_name", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_instance\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesInstanceEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_sem_seg\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesSemSegEvaluator", "(", "dataset_name", ")", "\n", "", "elif", "evaluator_type", "==", "\"pascal_voc\"", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ",", "cfg", ")", "\n", "", "elif", "evaluator_type", "==", "\"lvis\"", ":", "\n", "            ", "return", "LVISEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "", "if", "len", "(", "evaluator_list", ")", "==", "0", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"no Evaluator for the dataset {} with the type {}\"", ".", "format", "(", "\n", "dataset_name", ",", "evaluator_type", "\n", ")", "\n", ")", "\n", "", "elif", "len", "(", "evaluator_list", ")", "==", "1", ":", "\n", "            ", "return", "evaluator_list", "[", "0", "]", "\n", "", "return", "DatasetEvaluators", "(", "evaluator_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.train_net.Trainer.test_with_TTA": [[101, 117], ["logging.getLogger", "logging.getLogger.info", "detectron2.modeling.GeneralizedRCNNWithTTA", "cls.test", "collections.OrderedDict", "cls.build_evaluator", "os.path.join", "collections.OrderedDict.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.Trainer.build_evaluator"], ["", "@", "classmethod", "\n", "def", "test_with_TTA", "(", "cls", ",", "cfg", ",", "model", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "\"detectron2.trainer\"", ")", "\n", "# In the end of training, run an evaluation with TTA", "\n", "# Only support some R-CNN models.", "\n", "logger", ".", "info", "(", "\"Running inference with test-time augmentation ...\"", ")", "\n", "model", "=", "GeneralizedRCNNWithTTA", "(", "cfg", ",", "model", ")", "\n", "evaluators", "=", "[", "\n", "cls", ".", "build_evaluator", "(", "\n", "cfg", ",", "name", ",", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference_TTA\"", ")", "\n", ")", "\n", "for", "name", "in", "cfg", ".", "DATASETS", ".", "TEST", "\n", "]", "\n", "res", "=", "cls", ".", "test", "(", "cfg", ",", "model", ",", "evaluators", ")", "\n", "res", "=", "OrderedDict", "(", "{", "k", "+", "\"_TTA\"", ":", "v", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "}", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.train_net.setup": [[119, 129], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup"], ["", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.train_net.main": [[131, 158], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.is_main_process", "Trainer.register_hooks", "Trainer.test.update", "detectron2.evaluation.verify_results", "detectron2.checkpoint.DetectionCheckpointer", "train_net.Trainer.test_with_TTA", "detectron2.engine.hooks.EvalHook", "train_net.Trainer.test_with_TTA"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.verify_results", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.test_with_TTA", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.test_with_TTA"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", "\n", ")", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ")", "\n", "if", "cfg", ".", "TEST", ".", "AUG", ".", "ENABLED", ":", "\n", "            ", "res", ".", "update", "(", "Trainer", ".", "test_with_TTA", "(", "cfg", ",", "model", ")", ")", "\n", "", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "verify_results", "(", "cfg", ",", "res", ")", "\n", "", "return", "res", "\n", "\n", "", "\"\"\"\n    If you'd like to do anything fancier than the standard training logic,\n    consider writing your own training loop (see plain_train_net.py) or\n    subclassing the trainer.\n    \"\"\"", "\n", "trainer", "=", "Trainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ")", "\n", "if", "cfg", ".", "TEST", ".", "AUG", ".", "ENABLED", ":", "\n", "        ", "trainer", ".", "register_hooks", "(", "\n", "[", "hooks", ".", "EvalHook", "(", "0", ",", "lambda", ":", "trainer", ".", "test_with_TTA", "(", "cfg", ",", "trainer", ".", "model", ")", ")", "]", "\n", ")", "\n", "", "return", "trainer", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deploy.caffe2_converter.setup_cfg": [[17, 28], ["detectron2.config.get_cfg", "detectron2.export.add_export_config", "detectron2.export.add_export_config.merge_from_file", "detectron2.export.add_export_config.merge_from_list", "detectron2.export.add_export_config.freeze"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.add_export_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze"], ["def", "setup_cfg", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "# cuda context is initialized before creating dataloader, so we don't fork anymore", "\n", "cfg", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "0", "\n", "cfg", "=", "add_export_config", "(", "cfg", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "if", "cfg", ".", "MODEL", ".", "DEVICE", "!=", "\"cpu\"", ":", "\n", "        ", "assert", "TORCH_VERSION", ">=", "(", "1", ",", "5", ")", ",", "\"PyTorch>=1.5 required for GPU conversion!\"", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.docs.conf.GithubURLDomain.resolve_any_xref": [[39, 58], ["target.startswith", "target.replace", "print", "target.endswith", "github_url.endswith", "github_url.endswith"], "methods", ["None"], ["def", "resolve_any_xref", "(", "self", ",", "env", ",", "fromdocname", ",", "builder", ",", "target", ",", "node", ",", "contnode", ")", ":", "\n", "        ", "github_url", "=", "None", "\n", "if", "not", "target", ".", "endswith", "(", "\"html\"", ")", "and", "target", ".", "startswith", "(", "\"../../\"", ")", ":", "\n", "            ", "url", "=", "target", ".", "replace", "(", "\"../\"", ",", "\"\"", ")", "\n", "github_url", "=", "url", "\n", "", "if", "fromdocname", "in", "self", ".", "LINKED_DOC", ":", "\n", "# unresolved links in these docs are all github links", "\n", "            ", "github_url", "=", "target", "\n", "\n", "", "if", "github_url", "is", "not", "None", ":", "\n", "            ", "if", "github_url", ".", "endswith", "(", "\"MODEL_ZOO\"", ")", "or", "github_url", ".", "endswith", "(", "\"README\"", ")", ":", "\n", "# bug of recommonmark.", "\n", "# https://github.com/readthedocs/recommonmark/blob/ddd56e7717e9745f11300059e4268e204138a6b1/recommonmark/parser.py#L152-L155", "\n", "                ", "github_url", "+=", "\".md\"", "\n", "", "print", "(", "\"Ref {} resolved to github:{}\"", ".", "format", "(", "target", ",", "github_url", ")", ")", "\n", "contnode", "[", "\"refuri\"", "]", "=", "self", ".", "ROOT", "+", "github_url", "\n", "return", "[", "(", "\"githuburl:any\"", ",", "contnode", ")", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.docs.conf.autodoc_skip_member": [[262, 286], ["getattr", "obj.__doc__.lower().strip().startswith", "print", "obj.__doc__.lower().strip", "obj.__doc__.lower"], "function", ["None"], ["def", "autodoc_skip_member", "(", "app", ",", "what", ",", "name", ",", "obj", ",", "skip", ",", "options", ")", ":", "\n", "# we hide something deliberately", "\n", "    ", "if", "getattr", "(", "obj", ",", "\"__HIDE_SPHINX_DOC__\"", ",", "False", ")", ":", "\n", "        ", "return", "True", "\n", "\n", "# Hide some that are deprecated or not intended to be used", "\n", "", "HIDDEN", "=", "{", "\n", "\"ResNetBlockBase\"", ",", "\n", "\"GroupedBatchSampler\"", ",", "\n", "\"build_transform_gen\"", ",", "\n", "\"export_caffe2_model\"", ",", "\n", "\"export_onnx_model\"", ",", "\n", "\"apply_transform_gens\"", ",", "\n", "\"TransformGen\"", ",", "\n", "\"apply_augmentations\"", ",", "\n", "\"StandardAugInput\"", ",", "\n", "}", "\n", "try", ":", "\n", "        ", "if", "obj", ".", "__doc__", ".", "lower", "(", ")", ".", "strip", "(", ")", ".", "startswith", "(", "\"deprecated\"", ")", "or", "name", "in", "HIDDEN", ":", "\n", "            ", "print", "(", "\"Skipping deprecated object: {}\"", ".", "format", "(", "name", ")", ")", "\n", "return", "True", "\n", "", "", "except", ":", "\n", "        ", "pass", "\n", "", "return", "skip", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.docs.conf.paper_ref_role": [[307, 336], ["utils.unescape", "split_explicit_title", "link.lower.lower", "nodes.reference", "inliner.reporter.warning"], "function", ["None"], ["def", "paper_ref_role", "(", "\n", "typ", ":", "str", ",", "\n", "rawtext", ":", "str", ",", "\n", "text", ":", "str", ",", "\n", "lineno", ":", "int", ",", "\n", "inliner", ",", "\n", "options", ":", "Dict", "=", "{", "}", ",", "\n", "content", ":", "List", "[", "str", "]", "=", "[", "]", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Parse :paper:`xxx`. Similar to the \"extlinks\" sphinx extension.\n    \"\"\"", "\n", "from", "docutils", "import", "nodes", ",", "utils", "\n", "from", "sphinx", ".", "util", ".", "nodes", "import", "split_explicit_title", "\n", "\n", "text", "=", "utils", ".", "unescape", "(", "text", ")", "\n", "has_explicit_title", ",", "title", ",", "link", "=", "split_explicit_title", "(", "text", ")", "\n", "link", "=", "link", ".", "lower", "(", ")", "\n", "if", "link", "not", "in", "_PAPER_DATA", ":", "\n", "        ", "inliner", ".", "reporter", ".", "warning", "(", "\"Cannot find paper \"", "+", "link", ")", "\n", "paper_url", ",", "paper_title", "=", "\"#\"", ",", "link", "\n", "", "else", ":", "\n", "        ", "paper_url", ",", "paper_title", "=", "_PAPER_DATA", "[", "link", "]", "\n", "if", "\"/\"", "not", "in", "paper_url", ":", "\n", "            ", "paper_url", "=", "\"https://arxiv.org/abs/\"", "+", "paper_url", "\n", "", "", "if", "not", "has_explicit_title", ":", "\n", "        ", "title", "=", "paper_title", "\n", "", "pnode", "=", "nodes", ".", "reference", "(", "title", ",", "title", ",", "internal", "=", "False", ",", "refuri", "=", "paper_url", ")", "\n", "return", "[", "pnode", "]", ",", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.docs.conf.setup": [[338, 350], ["app.add_domain", "app.connect", "app.add_role", "app.add_config_value", "app.add_transform"], "function", ["None"], ["", "def", "setup", "(", "app", ")", ":", "\n", "    ", "from", "recommonmark", ".", "transform", "import", "AutoStructify", "\n", "\n", "app", ".", "add_domain", "(", "GithubURLDomain", ")", "\n", "app", ".", "connect", "(", "\"autodoc-skip-member\"", ",", "autodoc_skip_member", ")", "\n", "app", ".", "add_role", "(", "\"paper\"", ",", "paper_ref_role", ")", "\n", "app", ".", "add_config_value", "(", "\n", "\"recommonmark_config\"", ",", "\n", "{", "\"enable_math\"", ":", "True", ",", "\"enable_inline_math\"", ":", "True", ",", "\"enable_eval_rst\"", ":", "True", "}", ",", "\n", "True", ",", "\n", ")", "\n", "app", ".", "add_transform", "(", "AutoStructify", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.serialize.PicklableWrapper.__init__": [[15, 17], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "obj", ")", ":", "\n", "        ", "self", ".", "_obj", "=", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.serialize.PicklableWrapper.__reduce__": [[18, 21], ["cloudpickle.dumps"], "methods", ["None"], ["", "def", "__reduce__", "(", "self", ")", ":", "\n", "        ", "s", "=", "cloudpickle", ".", "dumps", "(", "self", ".", "_obj", ")", "\n", "return", "cloudpickle", ".", "loads", ",", "(", "s", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.serialize.PicklableWrapper.__call__": [[22, 24], ["serialize.PicklableWrapper._obj"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "_obj", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.serialize.PicklableWrapper.__getattr__": [[25, 30], ["getattr", "getattr"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "attr", ")", ":", "\n", "# Ensure that the wrapped object can be used seamlessly as the previous object.", "\n", "        ", "if", "attr", "not", "in", "[", "\"_obj\"", "]", ":", "\n", "            ", "return", "getattr", "(", "self", ".", "_obj", ",", "attr", ")", "\n", "", "return", "getattr", "(", "self", ",", "attr", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.colormap.colormap": [[95, 109], ["None"], "function", ["None"], ["def", "colormap", "(", "rgb", "=", "False", ",", "maximum", "=", "255", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        rgb (bool): whether to return RGB colors or BGR colors.\n        maximum (int): either 255 or 1\n\n    Returns:\n        ndarray: a float32 array of Nx3 colors, in range [0, 255] or [0, 1]\n    \"\"\"", "\n", "assert", "maximum", "in", "[", "255", ",", "1", "]", ",", "maximum", "\n", "c", "=", "_COLORS", "*", "maximum", "\n", "if", "not", "rgb", ":", "\n", "        ", "c", "=", "c", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "", "return", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.colormap.random_color": [[111, 125], ["numpy.random.randint", "len"], "function", ["None"], ["", "def", "random_color", "(", "rgb", "=", "False", ",", "maximum", "=", "255", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        rgb (bool): whether to return RGB colors or BGR colors.\n        maximum (int): either 255 or 1\n\n    Returns:\n        ndarray: a vector of 3 numbers\n    \"\"\"", "\n", "idx", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "_COLORS", ")", ")", "\n", "ret", "=", "_COLORS", "[", "idx", "]", "*", "maximum", "\n", "if", "not", "rgb", ":", "\n", "        ", "ret", "=", "ret", "[", ":", ":", "-", "1", "]", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventWriter.write": [[41, 43], ["None"], "methods", ["None"], ["def", "write", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventWriter.close": [[44, 46], ["None"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.JSONWriter.__init__": [[92, 102], ["fvcore.common.file_io.PathManager.open"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "json_file", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            json_file (str): path to the json file. New data will be appended if the file exists.\n            window_size (int): the window size of median smoothing for the scalars whose\n                `smoothing_hint` are True.\n        \"\"\"", "\n", "self", ".", "_file_handle", "=", "PathManager", ".", "open", "(", "json_file", ",", "\"a\"", ")", "\n", "self", ".", "_window_size", "=", "window_size", "\n", "self", ".", "_last_write", "=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.JSONWriter.write": [[103, 124], ["events.get_event_storage", "collections.defaultdict", "get_event_storage.latest_with_smoothing_hint().items", "len", "collections.defaultdict.items", "events.JSONWriter._file_handle.flush", "sorted", "max", "events.JSONWriter._file_handle.write", "os.fsync", "get_event_storage.latest_with_smoothing_hint", "collections.defaultdict.keys", "events.JSONWriter._file_handle.fileno", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.latest_with_smoothing_hint"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "to_save", "=", "defaultdict", "(", "dict", ")", "\n", "\n", "for", "k", ",", "(", "v", ",", "iter", ")", "in", "storage", ".", "latest_with_smoothing_hint", "(", "self", ".", "_window_size", ")", ".", "items", "(", ")", ":", "\n", "# keep scalars that have not been written", "\n", "            ", "if", "iter", "<=", "self", ".", "_last_write", ":", "\n", "                ", "continue", "\n", "", "to_save", "[", "iter", "]", "[", "k", "]", "=", "v", "\n", "", "if", "len", "(", "to_save", ")", ":", "\n", "            ", "all_iters", "=", "sorted", "(", "to_save", ".", "keys", "(", ")", ")", "\n", "self", ".", "_last_write", "=", "max", "(", "all_iters", ")", "\n", "\n", "", "for", "itr", ",", "scalars_per_iter", "in", "to_save", ".", "items", "(", ")", ":", "\n", "            ", "scalars_per_iter", "[", "\"iteration\"", "]", "=", "itr", "\n", "self", ".", "_file_handle", ".", "write", "(", "json", ".", "dumps", "(", "scalars_per_iter", ",", "sort_keys", "=", "True", ")", "+", "\"\\n\"", ")", "\n", "", "self", ".", "_file_handle", ".", "flush", "(", ")", "\n", "try", ":", "\n", "            ", "os", ".", "fsync", "(", "self", ".", "_file_handle", ".", "fileno", "(", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.JSONWriter.close": [[125, 127], ["events.JSONWriter._file_handle.close"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "_file_handle", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.__init__": [[134, 147], ["SummaryWriter"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log_dir", ":", "str", ",", "window_size", ":", "int", "=", "20", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            log_dir (str): the directory to save the output events\n            window_size (int): the scalars will be median-smoothed by this window size\n\n            kwargs: other arguments passed to `torch.utils.tensorboard.SummaryWriter(...)`\n        \"\"\"", "\n", "self", ".", "_window_size", "=", "window_size", "\n", "from", "torch", ".", "utils", ".", "tensorboard", "import", "SummaryWriter", "\n", "\n", "self", ".", "_writer", "=", "SummaryWriter", "(", "log_dir", ",", "**", "kwargs", ")", "\n", "self", ".", "_last_write", "=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.write": [[148, 173], ["events.get_event_storage", "get_event_storage.latest_with_smoothing_hint().items", "len", "get_event_storage.clear_images", "len", "get_event_storage.clear_histograms", "get_event_storage.latest_with_smoothing_hint", "events.TensorboardXWriter._writer.add_scalar", "max", "events.TensorboardXWriter._writer.add_image", "events.TensorboardXWriter._writer.add_histogram_raw"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.clear_images", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.clear_histograms", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.latest_with_smoothing_hint"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "new_last_write", "=", "self", ".", "_last_write", "\n", "for", "k", ",", "(", "v", ",", "iter", ")", "in", "storage", ".", "latest_with_smoothing_hint", "(", "self", ".", "_window_size", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "iter", ">", "self", ".", "_last_write", ":", "\n", "                ", "self", ".", "_writer", ".", "add_scalar", "(", "k", ",", "v", ",", "iter", ")", "\n", "new_last_write", "=", "max", "(", "new_last_write", ",", "iter", ")", "\n", "", "", "self", ".", "_last_write", "=", "new_last_write", "\n", "\n", "# storage.put_{image,histogram} is only meant to be used by", "\n", "# tensorboard writer. So we access its internal fields directly from here.", "\n", "if", "len", "(", "storage", ".", "_vis_data", ")", ">=", "1", ":", "\n", "            ", "for", "img_name", ",", "img", ",", "step_num", "in", "storage", ".", "_vis_data", ":", "\n", "                ", "self", ".", "_writer", ".", "add_image", "(", "img_name", ",", "img", ",", "step_num", ")", "\n", "# Storage stores all image data and rely on this writer to clear them.", "\n", "# As a result it assumes only one writer will use its image data.", "\n", "# An alternative design is to let storage store limited recent", "\n", "# data (e.g. only the most recent image) that all writers can access.", "\n", "# In that case a writer may not see all image data if its period is long.", "\n", "", "storage", ".", "clear_images", "(", ")", "\n", "\n", "", "if", "len", "(", "storage", ".", "_histograms", ")", ">=", "1", ":", "\n", "            ", "for", "params", "in", "storage", ".", "_histograms", ":", "\n", "                ", "self", ".", "_writer", ".", "add_histogram_raw", "(", "**", "params", ")", "\n", "", "storage", ".", "clear_histograms", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close": [[174, 177], ["hasattr", "events.TensorboardXWriter._writer.close"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "\"_writer\"", ")", ":", "# doesn't exist when the code fails at import", "\n", "            ", "self", ".", "_writer", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.CommonMetricPrinter.__init__": [[189, 198], ["logging.getLogger"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "max_iter", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            max_iter (int): the maximum number of iterations to train.\n                Used to compute ETA.\n        \"\"\"", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "self", ".", "_max_iter", "=", "max_iter", "\n", "self", ".", "_last_write", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.CommonMetricPrinter.write": [[199, 258], ["events.get_event_storage", "torch.cuda.is_available", "events.CommonMetricPrinter.logger.info", "get_event_storage.history().avg", "get_event_storage.history().global_avg", "get_event_storage.put_scalar", "str", "get_event_storage.history().median", "datetime.timedelta", "get_event_storage.history().latest", "get_event_storage.history", "get_event_storage.history", "str", "time.perf_counter", "torch.cuda.max_memory_allocated", "get_event_storage.history", "int", "datetime.timedelta", "get_event_storage.history", "time.perf_counter", "int", "v.median", "get_event_storage.histories().items", "get_event_storage.histories"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.latest", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.history", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.histories"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "iteration", "=", "storage", ".", "iter", "\n", "if", "iteration", "==", "self", ".", "_max_iter", ":", "\n", "# This hook only reports training progress (loss, ETA, etc) but not other data,", "\n", "# therefore do not write anything after training succeeds, even if this method", "\n", "# is called.", "\n", "            ", "return", "\n", "\n", "", "try", ":", "\n", "            ", "data_time", "=", "storage", ".", "history", "(", "\"data_time\"", ")", ".", "avg", "(", "20", ")", "\n", "", "except", "KeyError", ":", "\n", "# they may not exist in the first few iterations (due to warmup)", "\n", "# or when SimpleTrainer is not used", "\n", "            ", "data_time", "=", "None", "\n", "\n", "", "eta_string", "=", "None", "\n", "try", ":", "\n", "            ", "iter_time", "=", "storage", ".", "history", "(", "\"time\"", ")", ".", "global_avg", "(", ")", "\n", "eta_seconds", "=", "storage", ".", "history", "(", "\"time\"", ")", ".", "median", "(", "1000", ")", "*", "(", "self", ".", "_max_iter", "-", "iteration", "-", "1", ")", "\n", "storage", ".", "put_scalar", "(", "\"eta_seconds\"", ",", "eta_seconds", ",", "smoothing_hint", "=", "False", ")", "\n", "eta_string", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "eta_seconds", ")", ")", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "iter_time", "=", "None", "\n", "# estimate eta on our own - more noisy", "\n", "if", "self", ".", "_last_write", "is", "not", "None", ":", "\n", "                ", "estimate_iter_time", "=", "(", "time", ".", "perf_counter", "(", ")", "-", "self", ".", "_last_write", "[", "1", "]", ")", "/", "(", "\n", "iteration", "-", "self", ".", "_last_write", "[", "0", "]", "\n", ")", "\n", "eta_seconds", "=", "estimate_iter_time", "*", "(", "self", ".", "_max_iter", "-", "iteration", "-", "1", ")", "\n", "eta_string", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "eta_seconds", ")", ")", ")", "\n", "", "self", ".", "_last_write", "=", "(", "iteration", ",", "time", ".", "perf_counter", "(", ")", ")", "\n", "\n", "", "try", ":", "\n", "            ", "lr", "=", "\"{:.5g}\"", ".", "format", "(", "storage", ".", "history", "(", "\"lr\"", ")", ".", "latest", "(", ")", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "lr", "=", "\"N/A\"", "\n", "\n", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "max_mem_mb", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "/", "1024.0", "/", "1024.0", "\n", "", "else", ":", "\n", "            ", "max_mem_mb", "=", "None", "\n", "\n", "# NOTE: max_mem is parsed by grep in \"dev/parse_results.sh\"", "\n", "", "self", ".", "logger", ".", "info", "(", "\n", "\" {eta}iter: {iter}  {losses}  {time}{data_time}lr: {lr}  {memory}\"", ".", "format", "(", "\n", "eta", "=", "f\"eta: {eta_string}  \"", "if", "eta_string", "else", "\"\"", ",", "\n", "iter", "=", "iteration", ",", "\n", "losses", "=", "\"  \"", ".", "join", "(", "\n", "[", "\n", "\"{}: {:.4g}\"", ".", "format", "(", "k", ",", "v", ".", "median", "(", "20", ")", ")", "\n", "for", "k", ",", "v", "in", "storage", ".", "histories", "(", ")", ".", "items", "(", ")", "\n", "if", "\"loss\"", "in", "k", "\n", "]", "\n", ")", ",", "\n", "time", "=", "\"time: {:.4f}  \"", ".", "format", "(", "iter_time", ")", "if", "iter_time", "is", "not", "None", "else", "\"\"", ",", "\n", "data_time", "=", "\"data_time: {:.4f}  \"", ".", "format", "(", "data_time", ")", "if", "data_time", "is", "not", "None", "else", "\"\"", ",", "\n", "lr", "=", "lr", ",", "\n", "memory", "=", "\"max_mem: {:.0f}M\"", ".", "format", "(", "max_mem_mb", ")", "if", "max_mem_mb", "is", "not", "None", "else", "\"\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.__init__": [[269, 281], ["collections.defaultdict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "start_iter", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            start_iter (int): the iteration number to start with\n        \"\"\"", "\n", "self", ".", "_history", "=", "defaultdict", "(", "HistoryBuffer", ")", "\n", "self", ".", "_smoothing_hints", "=", "{", "}", "\n", "self", ".", "_latest_scalars", "=", "{", "}", "\n", "self", ".", "_iter", "=", "start_iter", "\n", "self", ".", "_current_prefix", "=", "\"\"", "\n", "self", ".", "_vis_data", "=", "[", "]", "\n", "self", ".", "_histograms", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_image": [[282, 296], ["events.EventStorage._vis_data.append"], "methods", ["None"], ["", "def", "put_image", "(", "self", ",", "img_name", ",", "img_tensor", ")", ":", "\n", "        ", "\"\"\"\n        Add an `img_tensor` associated with `img_name`, to be shown on\n        tensorboard.\n\n        Args:\n            img_name (str): The name of the image to put into tensorboard.\n            img_tensor (torch.Tensor or numpy.array): An `uint8` or `float`\n                Tensor of shape `[channel, height, width]` where `channel` is\n                3. The image format should be RGB. The elements in img_tensor\n                can either have values in [0, 1] (float32) or [0, 255] (uint8).\n                The `img_tensor` will be visualized in tensorboard.\n        \"\"\"", "\n", "self", ".", "_vis_data", ".", "append", "(", "(", "img_name", ",", "img_tensor", ",", "self", ".", "_iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar": [[297, 323], ["float", "history.update", "events.EventStorage._smoothing_hints.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "put_scalar", "(", "self", ",", "name", ",", "value", ",", "smoothing_hint", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Add a scalar `value` to the `HistoryBuffer` associated with `name`.\n\n        Args:\n            smoothing_hint (bool): a 'hint' on whether this scalar is noisy and should be\n                smoothed when logged. The hint will be accessible through\n                :meth:`EventStorage.smoothing_hints`.  A writer may ignore the hint\n                and apply custom smoothing rule.\n\n                It defaults to True because most scalars we save need to be smoothed to\n                provide any useful signal.\n        \"\"\"", "\n", "name", "=", "self", ".", "_current_prefix", "+", "name", "\n", "history", "=", "self", ".", "_history", "[", "name", "]", "\n", "value", "=", "float", "(", "value", ")", "\n", "history", ".", "update", "(", "value", ",", "self", ".", "_iter", ")", "\n", "self", ".", "_latest_scalars", "[", "name", "]", "=", "(", "value", ",", "self", ".", "_iter", ")", "\n", "\n", "existing_hint", "=", "self", ".", "_smoothing_hints", ".", "get", "(", "name", ")", "\n", "if", "existing_hint", "is", "not", "None", ":", "\n", "            ", "assert", "(", "\n", "existing_hint", "==", "smoothing_hint", "\n", ")", ",", "\"Scalar {} was put with a different smoothing_hint!\"", ".", "format", "(", "name", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_smoothing_hints", "[", "name", "]", "=", "smoothing_hint", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalars": [[324, 334], ["kwargs.items", "events.EventStorage.put_scalar"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar"], ["", "", "def", "put_scalars", "(", "self", ",", "*", ",", "smoothing_hint", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Put multiple scalars from keyword arguments.\n\n        Examples:\n\n            storage.put_scalars(loss=my_loss, accuracy=my_accuracy, smoothing_hint=True)\n        \"\"\"", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "put_scalar", "(", "k", ",", "v", ",", "smoothing_hint", "=", "smoothing_hint", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_histogram": [[335, 364], ["torch.histc", "torch.linspace", "dict", "events.EventStorage._histograms.append", "hist_tensor.min().item", "hist_tensor.max().item", "len", "float", "float", "hist_edges[].tolist", "torch.histc.tolist", "hist_tensor.min", "hist_tensor.max", "hist_tensor.sum", "torch.sum"], "methods", ["None"], ["", "", "def", "put_histogram", "(", "self", ",", "hist_name", ",", "hist_tensor", ",", "bins", "=", "1000", ")", ":", "\n", "        ", "\"\"\"\n        Create a histogram from a tensor.\n\n        Args:\n            hist_name (str): The name of the histogram to put into tensorboard.\n            hist_tensor (torch.Tensor): A Tensor of arbitrary shape to be converted\n                into a histogram.\n            bins (int): Number of histogram bins.\n        \"\"\"", "\n", "ht_min", ",", "ht_max", "=", "hist_tensor", ".", "min", "(", ")", ".", "item", "(", ")", ",", "hist_tensor", ".", "max", "(", ")", ".", "item", "(", ")", "\n", "\n", "# Create a histogram with PyTorch", "\n", "hist_counts", "=", "torch", ".", "histc", "(", "hist_tensor", ",", "bins", "=", "bins", ")", "\n", "hist_edges", "=", "torch", ".", "linspace", "(", "start", "=", "ht_min", ",", "end", "=", "ht_max", ",", "steps", "=", "bins", "+", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# Parameter for the add_histogram_raw function of SummaryWriter", "\n", "hist_params", "=", "dict", "(", "\n", "tag", "=", "hist_name", ",", "\n", "min", "=", "ht_min", ",", "\n", "max", "=", "ht_max", ",", "\n", "num", "=", "len", "(", "hist_tensor", ")", ",", "\n", "sum", "=", "float", "(", "hist_tensor", ".", "sum", "(", ")", ")", ",", "\n", "sum_squares", "=", "float", "(", "torch", ".", "sum", "(", "hist_tensor", "**", "2", ")", ")", ",", "\n", "bucket_limits", "=", "hist_edges", "[", "1", ":", "]", ".", "tolist", "(", ")", ",", "\n", "bucket_counts", "=", "hist_counts", ".", "tolist", "(", ")", ",", "\n", "global_step", "=", "self", ".", "_iter", ",", "\n", ")", "\n", "self", ".", "_histograms", ".", "append", "(", "hist_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.history": [[365, 374], ["events.EventStorage._history.get", "KeyError"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "history", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            HistoryBuffer: the scalar history for name\n        \"\"\"", "\n", "ret", "=", "self", ".", "_history", ".", "get", "(", "name", ",", "None", ")", "\n", "if", "ret", "is", "None", ":", "\n", "            ", "raise", "KeyError", "(", "\"No history metric available for {}!\"", ".", "format", "(", "name", ")", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.histories": [[375, 381], ["None"], "methods", ["None"], ["", "def", "histories", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> HistoryBuffer]: the HistoryBuffer for all scalars\n        \"\"\"", "\n", "return", "self", ".", "_history", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.latest": [[382, 389], ["None"], "methods", ["None"], ["", "def", "latest", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[str -> (float, int)]: mapping from the name of each scalar to the most\n                recent value and the iteration number its added.\n        \"\"\"", "\n", "return", "self", ".", "_latest_scalars", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.latest_with_smoothing_hint": [[390, 406], ["events.EventStorage._latest_scalars.items", "events.EventStorage._history[].median"], "methods", ["None"], ["", "def", "latest_with_smoothing_hint", "(", "self", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Similar to :meth:`latest`, but the returned values\n        are either the un-smoothed original latest value,\n        or a median of the given window_size,\n        depend on whether the smoothing_hint is True.\n\n        This provides a default behavior that other writers can use.\n        \"\"\"", "\n", "result", "=", "{", "}", "\n", "for", "k", ",", "(", "v", ",", "itr", ")", "in", "self", ".", "_latest_scalars", ".", "items", "(", ")", ":", "\n", "            ", "result", "[", "k", "]", "=", "(", "\n", "self", ".", "_history", "[", "k", "]", ".", "median", "(", "window_size", ")", "if", "self", ".", "_smoothing_hints", "[", "k", "]", "else", "v", ",", "\n", "itr", ",", "\n", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.smoothing_hints": [[407, 414], ["None"], "methods", ["None"], ["", "def", "smoothing_hints", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> bool]: the user-provided hint on whether the scalar\n                is noisy and needs smoothing.\n        \"\"\"", "\n", "return", "self", ".", "_smoothing_hints", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step": [[415, 423], ["None"], "methods", ["None"], ["", "def", "step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        User should either: (1) Call this function to increment storage.iter when needed. Or\n        (2) Set `storage.iter` to the correct iteration number before each iteration.\n\n        The storage will then be able to associate the new data with an iteration number.\n        \"\"\"", "\n", "self", ".", "_iter", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter": [[433, 436], ["int"], "methods", ["None"], ["", "@", "iter", ".", "setter", "\n", "def", "iter", "(", "self", ",", "val", ")", ":", "\n", "        ", "self", ".", "_iter", "=", "int", "(", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iteration": [[437, 441], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "iteration", "(", "self", ")", ":", "\n", "# for backward compatibility", "\n", "        ", "return", "self", ".", "_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.__enter__": [[442, 445], ["_CURRENT_STORAGE_STACK.append"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "_CURRENT_STORAGE_STACK", ".", "append", "(", "self", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.__exit__": [[446, 449], ["_CURRENT_STORAGE_STACK.pop"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "exc_type", ",", "exc_val", ",", "exc_tb", ")", ":", "\n", "        ", "assert", "_CURRENT_STORAGE_STACK", "[", "-", "1", "]", "==", "self", "\n", "_CURRENT_STORAGE_STACK", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.name_scope": [[450, 461], ["name.rstrip"], "methods", ["None"], ["", "@", "contextmanager", "\n", "def", "name_scope", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"\n        Yields:\n            A context within which all the events added to this storage\n            will be prefixed by the name scope.\n        \"\"\"", "\n", "old_prefix", "=", "self", ".", "_current_prefix", "\n", "self", ".", "_current_prefix", "=", "name", ".", "rstrip", "(", "\"/\"", ")", "+", "\"/\"", "\n", "yield", "\n", "self", ".", "_current_prefix", "=", "old_prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.clear_images": [[462, 468], ["None"], "methods", ["None"], ["", "def", "clear_images", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Delete all the stored images for visualization. This should be called\n        after images are written to tensorboard.\n        \"\"\"", "\n", "self", ".", "_vis_data", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.clear_histograms": [[469, 475], ["None"], "methods", ["None"], ["", "def", "clear_histograms", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Delete all the stored histograms for visualization.\n        This should be called after histograms are written to tensorboard.\n        \"\"\"", "\n", "self", ".", "_histograms", "=", "[", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage": [[24, 34], ["len"], "function", ["None"], ["def", "get_event_storage", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The :class:`EventStorage` object that's currently being used.\n        Throws an error if no :class:`EventStorage` is currently enabled.\n    \"\"\"", "\n", "assert", "len", "(", "\n", "_CURRENT_STORAGE_STACK", "\n", ")", ",", "\"get_event_storage() has to be called inside a 'with EventStorage(...)' context!\"", "\n", "return", "_CURRENT_STORAGE_STACK", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size": [[21, 27], ["torch.get_world_size", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], ["def", "get_world_size", "(", ")", "->", "int", ":", "\n", "    ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "return", "dist", ".", "get_world_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank": [[29, 35], ["torch.get_rank", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["", "def", "get_rank", "(", ")", "->", "int", ":", "\n", "    ", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "return", "dist", ".", "get_rank", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_local_rank": [[37, 48], ["torch.get_rank", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["", "def", "get_local_rank", "(", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The rank of the current process within the local (per-machine) process group.\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "0", "\n", "", "assert", "_LOCAL_PROCESS_GROUP", "is", "not", "None", "\n", "return", "dist", ".", "get_rank", "(", "group", "=", "_LOCAL_PROCESS_GROUP", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_local_size": [[50, 61], ["torch.get_world_size", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], ["", "def", "get_local_size", "(", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The size of the per-machine process group,\n        i.e. the number of processes per machine.\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "1", "\n", "", "return", "dist", ".", "get_world_size", "(", "group", "=", "_LOCAL_PROCESS_GROUP", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process": [[63, 65], ["comm.get_rank"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["", "def", "is_main_process", "(", ")", "->", "bool", ":", "\n", "    ", "return", "get_rank", "(", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize": [[67, 80], ["torch.get_world_size", "torch.barrier", "torch.is_available", "torch.is_initialized"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], ["", "def", "synchronize", "(", ")", ":", "\n", "    ", "\"\"\"\n    Helper function to synchronize (barrier) among all processes when\n    using distributed training\n    \"\"\"", "\n", "if", "not", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "\n", "", "if", "not", "dist", ".", "is_initialized", "(", ")", ":", "\n", "        ", "return", "\n", "", "world_size", "=", "dist", ".", "get_world_size", "(", ")", "\n", "if", "world_size", "==", "1", ":", "\n", "        ", "return", "\n", "", "dist", ".", "barrier", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm._get_global_gloo_group": [[82, 92], ["functools.lru_cache", "torch.get_backend", "torch.new_group"], "function", ["None"], ["", "@", "functools", ".", "lru_cache", "(", ")", "\n", "def", "_get_global_gloo_group", "(", ")", ":", "\n", "    ", "\"\"\"\n    Return a process group based on gloo backend, containing all the ranks\n    The result is cached.\n    \"\"\"", "\n", "if", "dist", ".", "get_backend", "(", ")", "==", "\"nccl\"", ":", "\n", "        ", "return", "dist", ".", "new_group", "(", "backend", "=", "\"gloo\"", ")", "\n", "", "else", ":", "\n", "        ", "return", "dist", ".", "group", ".", "WORLD", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm._serialize_to_tensor": [[94, 110], ["torch.get_backend", "torch.device", "torch.device", "pickle.dumps", "torch.ByteStorage.from_buffer", "torch.ByteStorage.from_buffer", "torch.ByteTensor().to", "torch.ByteTensor().to", "len", "logging.getLogger", "logging.getLogger.warning", "torch.ByteTensor", "torch.ByteTensor", "comm.get_rank", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["", "", "def", "_serialize_to_tensor", "(", "data", ",", "group", ")", ":", "\n", "    ", "backend", "=", "dist", ".", "get_backend", "(", "group", ")", "\n", "assert", "backend", "in", "[", "\"gloo\"", ",", "\"nccl\"", "]", "\n", "device", "=", "torch", ".", "device", "(", "\"cpu\"", "if", "backend", "==", "\"gloo\"", "else", "\"cuda\"", ")", "\n", "\n", "buffer", "=", "pickle", ".", "dumps", "(", "data", ")", "\n", "if", "len", "(", "buffer", ")", ">", "1024", "**", "3", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"Rank {} trying to all-gather {:.2f} GB of data on device {}\"", ".", "format", "(", "\n", "get_rank", "(", ")", ",", "len", "(", "buffer", ")", "/", "(", "1024", "**", "3", ")", ",", "device", "\n", ")", "\n", ")", "\n", "", "storage", "=", "torch", ".", "ByteStorage", ".", "from_buffer", "(", "buffer", ")", "\n", "tensor", "=", "torch", ".", "ByteTensor", "(", "storage", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm._pad_to_largest_tensor": [[112, 137], ["torch.get_world_size", "torch.tensor", "torch.tensor", "torch.all_gather", "max", "torch.zeros", "torch.zeros", "int", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat.numel", "range", "size.item"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "_pad_to_largest_tensor", "(", "tensor", ",", "group", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        list[int]: size of the tensor, on each rank\n        Tensor: padded tensor that has the max size\n    \"\"\"", "\n", "world_size", "=", "dist", ".", "get_world_size", "(", "group", "=", "group", ")", "\n", "assert", "(", "\n", "world_size", ">=", "1", "\n", ")", ",", "\"comm.gather/all_gather must be called from ranks within the given group!\"", "\n", "local_size", "=", "torch", ".", "tensor", "(", "[", "tensor", ".", "numel", "(", ")", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "tensor", ".", "device", ")", "\n", "size_list", "=", "[", "\n", "torch", ".", "zeros", "(", "[", "1", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "tensor", ".", "device", ")", "for", "_", "in", "range", "(", "world_size", ")", "\n", "]", "\n", "dist", ".", "all_gather", "(", "size_list", ",", "local_size", ",", "group", "=", "group", ")", "\n", "size_list", "=", "[", "int", "(", "size", ".", "item", "(", ")", ")", "for", "size", "in", "size_list", "]", "\n", "\n", "max_size", "=", "max", "(", "size_list", ")", "\n", "\n", "# we pad the tensor because torch all_gather does not support", "\n", "# gathering tensors of different shapes", "\n", "if", "local_size", "!=", "max_size", ":", "\n", "        ", "padding", "=", "torch", ".", "zeros", "(", "(", "max_size", "-", "local_size", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "tensor", ".", "device", ")", "\n", "tensor", "=", "torch", ".", "cat", "(", "(", "tensor", ",", "padding", ")", ",", "dim", "=", "0", ")", "\n", "", "return", "size_list", ",", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather": [[139, 175], ["comm._serialize_to_tensor", "comm._pad_to_largest_tensor", "max", "torch.all_gather", "zip", "comm.get_world_size", "comm._get_global_gloo_group", "torch.get_world_size", "torch.empty", "torch.empty", "data_list.append", "_serialize_to_tensor.cpu().numpy().tobytes", "pickle.loads", "_serialize_to_tensor.cpu().numpy", "_serialize_to_tensor.cpu"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm._serialize_to_tensor", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm._pad_to_largest_tensor", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm._get_global_gloo_group", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], ["", "def", "all_gather", "(", "data", ",", "group", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Run all_gather on arbitrary picklable data (not necessarily tensors).\n\n    Args:\n        data: any picklable object\n        group: a torch process group. By default, will use a group which\n            contains all ranks on gloo backend.\n\n    Returns:\n        list[data]: list of data gathered from each rank\n    \"\"\"", "\n", "if", "get_world_size", "(", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "", "if", "group", "is", "None", ":", "\n", "        ", "group", "=", "_get_global_gloo_group", "(", ")", "\n", "", "if", "dist", ".", "get_world_size", "(", "group", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "\n", "", "tensor", "=", "_serialize_to_tensor", "(", "data", ",", "group", ")", "\n", "\n", "size_list", ",", "tensor", "=", "_pad_to_largest_tensor", "(", "tensor", ",", "group", ")", "\n", "max_size", "=", "max", "(", "size_list", ")", "\n", "\n", "# receiving Tensor from all ranks", "\n", "tensor_list", "=", "[", "\n", "torch", ".", "empty", "(", "(", "max_size", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "tensor", ".", "device", ")", "for", "_", "in", "size_list", "\n", "]", "\n", "dist", ".", "all_gather", "(", "tensor_list", ",", "tensor", ",", "group", "=", "group", ")", "\n", "\n", "data_list", "=", "[", "]", "\n", "for", "size", ",", "tensor", "in", "zip", "(", "size_list", ",", "tensor_list", ")", ":", "\n", "        ", "buffer", "=", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", "[", ":", "size", "]", "\n", "data_list", ".", "append", "(", "pickle", ".", "loads", "(", "buffer", ")", ")", "\n", "\n", "", "return", "data_list", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.gather": [[177, 218], ["torch.get_rank", "comm._serialize_to_tensor", "comm._pad_to_largest_tensor", "comm.get_world_size", "comm._get_global_gloo_group", "torch.get_world_size", "max", "torch.gather", "zip", "torch.gather", "torch.empty", "torch.empty", "data_list.append", "_serialize_to_tensor.cpu().numpy().tobytes", "pickle.loads", "_serialize_to_tensor.cpu().numpy", "_serialize_to_tensor.cpu"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm._serialize_to_tensor", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm._pad_to_largest_tensor", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm._get_global_gloo_group", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.gather"], ["", "def", "gather", "(", "data", ",", "dst", "=", "0", ",", "group", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Run gather on arbitrary picklable data (not necessarily tensors).\n\n    Args:\n        data: any picklable object\n        dst (int): destination rank\n        group: a torch process group. By default, will use a group which\n            contains all ranks on gloo backend.\n\n    Returns:\n        list[data]: on dst, a list of data gathered from each rank. Otherwise,\n            an empty list.\n    \"\"\"", "\n", "if", "get_world_size", "(", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "", "if", "group", "is", "None", ":", "\n", "        ", "group", "=", "_get_global_gloo_group", "(", ")", "\n", "", "if", "dist", ".", "get_world_size", "(", "group", "=", "group", ")", "==", "1", ":", "\n", "        ", "return", "[", "data", "]", "\n", "", "rank", "=", "dist", ".", "get_rank", "(", "group", "=", "group", ")", "\n", "\n", "tensor", "=", "_serialize_to_tensor", "(", "data", ",", "group", ")", "\n", "size_list", ",", "tensor", "=", "_pad_to_largest_tensor", "(", "tensor", ",", "group", ")", "\n", "\n", "# receiving Tensor from all ranks", "\n", "if", "rank", "==", "dst", ":", "\n", "        ", "max_size", "=", "max", "(", "size_list", ")", "\n", "tensor_list", "=", "[", "\n", "torch", ".", "empty", "(", "(", "max_size", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "tensor", ".", "device", ")", "for", "_", "in", "size_list", "\n", "]", "\n", "dist", ".", "gather", "(", "tensor", ",", "tensor_list", ",", "dst", "=", "dst", ",", "group", "=", "group", ")", "\n", "\n", "data_list", "=", "[", "]", "\n", "for", "size", ",", "tensor", "in", "zip", "(", "size_list", ",", "tensor_list", ")", ":", "\n", "            ", "buffer", "=", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", "[", ":", "size", "]", "\n", "data_list", ".", "append", "(", "pickle", ".", "loads", "(", "buffer", ")", ")", "\n", "", "return", "data_list", "\n", "", "else", ":", "\n", "        ", "dist", ".", "gather", "(", "tensor", ",", "[", "]", ",", "dst", "=", "dst", ",", "group", "=", "group", ")", "\n", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.shared_random_seed": [[220, 232], ["numpy.random.randint", "comm.all_gather"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather"], ["", "", "def", "shared_random_seed", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        int: a random number that is the same across all workers.\n            If workers need a shared RNG, they can use this shared seed to\n            create one.\n\n    All workers must call this function, otherwise it will deadlock.\n    \"\"\"", "\n", "ints", "=", "np", ".", "random", ".", "randint", "(", "2", "**", "31", ")", "\n", "all_ints", "=", "all_gather", "(", "ints", ")", "\n", "return", "all_ints", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.reduce_dict": [[234, 264], ["comm.get_world_size", "torch.no_grad", "torch.no_grad", "sorted", "torch.stack", "torch.stack", "torch.reduce", "input_dict.keys", "names.append", "torch.stack.append", "torch.get_rank", "zip"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["", "def", "reduce_dict", "(", "input_dict", ",", "average", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Reduce the values in the dictionary from all processes so that process with rank\n    0 has the reduced results.\n\n    Args:\n        input_dict (dict): inputs to be reduced. All the values must be scalar CUDA Tensor.\n        average (bool): whether to do average or sum\n\n    Returns:\n        a dict with the same keys as input_dict, after reduction.\n    \"\"\"", "\n", "world_size", "=", "get_world_size", "(", ")", "\n", "if", "world_size", "<", "2", ":", "\n", "        ", "return", "input_dict", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "names", "=", "[", "]", "\n", "values", "=", "[", "]", "\n", "# sort the keys so that they are consistent across processes", "\n", "for", "k", "in", "sorted", "(", "input_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "names", ".", "append", "(", "k", ")", "\n", "values", ".", "append", "(", "input_dict", "[", "k", "]", ")", "\n", "", "values", "=", "torch", ".", "stack", "(", "values", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "values", ",", "dst", "=", "0", ")", "\n", "if", "dist", ".", "get_rank", "(", ")", "==", "0", "and", "average", ":", "\n", "# only main process gets accumulated, so only divide by", "\n", "# world_size in this case", "\n", "            ", "values", "/=", "world_size", "\n", "", "reduced_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "names", ",", "values", ")", "}", "\n", "", "return", "reduced_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.__init__": [[67, 94], ["isinstance", "isinstance", "isinstance", "ValueError", "isinstance", "pycocotools.frPyObjects.astype", "pycocotools.frPyObjects", "pycocotools.decode", "numpy.asarray().reshape", "type", "numpy.asarray"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mask_or_polygons", ",", "height", ",", "width", ")", ":", "\n", "        ", "self", ".", "_mask", "=", "self", ".", "_polygons", "=", "self", ".", "_has_holes", "=", "None", "\n", "self", ".", "height", "=", "height", "\n", "self", ".", "width", "=", "width", "\n", "\n", "m", "=", "mask_or_polygons", "\n", "if", "isinstance", "(", "m", ",", "dict", ")", ":", "\n", "# RLEs", "\n", "            ", "assert", "\"counts\"", "in", "m", "and", "\"size\"", "in", "m", "\n", "if", "isinstance", "(", "m", "[", "\"counts\"", "]", ",", "list", ")", ":", "# uncompressed RLEs", "\n", "                ", "h", ",", "w", "=", "m", "[", "\"size\"", "]", "\n", "assert", "h", "==", "height", "and", "w", "==", "width", "\n", "m", "=", "mask_util", ".", "frPyObjects", "(", "m", ",", "h", ",", "w", ")", "\n", "", "self", ".", "_mask", "=", "mask_util", ".", "decode", "(", "m", ")", "[", ":", ",", ":", "]", "\n", "return", "\n", "\n", "", "if", "isinstance", "(", "m", ",", "list", ")", ":", "# list[ndarray]", "\n", "            ", "self", ".", "_polygons", "=", "[", "np", ".", "asarray", "(", "x", ")", ".", "reshape", "(", "-", "1", ")", "for", "x", "in", "m", "]", "\n", "return", "\n", "\n", "", "if", "isinstance", "(", "m", ",", "np", ".", "ndarray", ")", ":", "# assumed to be a binary mask", "\n", "            ", "assert", "m", ".", "shape", "[", "1", "]", "!=", "2", ",", "m", ".", "shape", "\n", "assert", "m", ".", "shape", "==", "(", "height", ",", "width", ")", ",", "m", ".", "shape", "\n", "self", ".", "_mask", "=", "m", ".", "astype", "(", "\"uint8\"", ")", "\n", "return", "\n", "\n", "", "raise", "ValueError", "(", "\"GenericMask cannot handle object {} of type '{}'\"", ".", "format", "(", "m", ",", "type", "(", "m", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.mask": [[95, 100], ["visualizer.GenericMask.polygons_to_mask"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.polygons_to_mask"], ["", "@", "property", "\n", "def", "mask", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_mask", "is", "None", ":", "\n", "            ", "self", ".", "_mask", "=", "self", ".", "polygons_to_mask", "(", "self", ".", "_polygons", ")", "\n", "", "return", "self", ".", "_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.polygons": [[101, 106], ["visualizer.GenericMask.mask_to_polygons"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.mask_to_polygons"], ["", "@", "property", "\n", "def", "polygons", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_polygons", "is", "None", ":", "\n", "            ", "self", ".", "_polygons", ",", "self", ".", "_has_holes", "=", "self", ".", "mask_to_polygons", "(", "self", ".", "_mask", ")", "\n", "", "return", "self", ".", "_polygons", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.has_holes": [[107, 115], ["visualizer.GenericMask.mask_to_polygons"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.mask_to_polygons"], ["", "@", "property", "\n", "def", "has_holes", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_has_holes", "is", "None", ":", "\n", "            ", "if", "self", ".", "_mask", "is", "not", "None", ":", "\n", "                ", "self", ".", "_polygons", ",", "self", ".", "_has_holes", "=", "self", ".", "mask_to_polygons", "(", "self", ".", "_mask", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_has_holes", "=", "False", "# if original format is polygon, does not have holes", "\n", "", "", "return", "self", ".", "_has_holes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.mask_to_polygons": [[116, 131], ["numpy.ascontiguousarray", "cv2.findContours", "numpy.ascontiguousarray.astype", "x.flatten", "len", "hierarchy.reshape"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "def", "mask_to_polygons", "(", "self", ",", "mask", ")", ":", "\n", "# cv2.RETR_CCOMP flag retrieves all the contours and arranges them to a 2-level", "\n", "# hierarchy. External contours (boundary) of the object are placed in hierarchy-1.", "\n", "# Internal contours (holes) are placed in hierarchy-2.", "\n", "# cv2.CHAIN_APPROX_NONE flag gets vertices of polygons from contours.", "\n", "        ", "mask", "=", "np", ".", "ascontiguousarray", "(", "mask", ")", "# some versions of cv2 does not support incontiguous arr", "\n", "res", "=", "cv2", ".", "findContours", "(", "mask", ".", "astype", "(", "\"uint8\"", ")", ",", "cv2", ".", "RETR_CCOMP", ",", "cv2", ".", "CHAIN_APPROX_NONE", ")", "\n", "hierarchy", "=", "res", "[", "-", "1", "]", "\n", "if", "hierarchy", "is", "None", ":", "# empty mask", "\n", "            ", "return", "[", "]", ",", "False", "\n", "", "has_holes", "=", "(", "hierarchy", ".", "reshape", "(", "-", "1", ",", "4", ")", "[", ":", ",", "3", "]", ">=", "0", ")", ".", "sum", "(", ")", ">", "0", "\n", "res", "=", "res", "[", "-", "2", "]", "\n", "res", "=", "[", "x", ".", "flatten", "(", ")", "for", "x", "in", "res", "]", "\n", "res", "=", "[", "x", "for", "x", "in", "res", "if", "len", "(", "x", ")", ">=", "6", "]", "\n", "return", "res", ",", "has_holes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.polygons_to_mask": [[132, 136], ["pycocotools.frPyObjects", "pycocotools.merge", "pycocotools.decode"], "methods", ["None"], ["", "def", "polygons_to_mask", "(", "self", ",", "polygons", ")", ":", "\n", "        ", "rle", "=", "mask_util", ".", "frPyObjects", "(", "polygons", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "rle", "=", "mask_util", ".", "merge", "(", "rle", ")", "\n", "return", "mask_util", ".", "decode", "(", "rle", ")", "[", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.area": [[137, 139], ["visualizer.GenericMask.mask.sum"], "methods", ["None"], ["", "def", "area", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "mask", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.bbox": [[140, 147], ["pycocotools.frPyObjects", "pycocotools.merge", "pycocotools.toBbox"], "methods", ["None"], ["", "def", "bbox", "(", "self", ")", ":", "\n", "        ", "p", "=", "mask_util", ".", "frPyObjects", "(", "self", ".", "polygons", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "p", "=", "mask_util", ".", "merge", "(", "p", ")", "\n", "bbox", "=", "mask_util", ".", "toBbox", "(", "p", ")", "\n", "bbox", "[", "2", "]", "+=", "bbox", "[", "0", "]", "\n", "bbox", "[", "3", "]", "+=", "bbox", "[", "1", "]", "\n", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.__init__": [[150, 185], ["torch.unique", "areas.numpy.numpy.numpy", "numpy.argsort", "visualizer._PanopticPrediction._seg_ids.tolist", "zip", "numpy.unique", "panoptic_seg.numpy", "segments_info.append", "float", "metadata.thing_dataset_id_to_contiguous_id.values", "int", "int", "bool"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "panoptic_seg", ",", "segments_info", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "if", "segments_info", "is", "None", ":", "\n", "            ", "assert", "metadata", "is", "not", "None", "\n", "# If \"segments_info\" is None, we assume \"panoptic_img\" is a", "\n", "# H*W int32 image storing the panoptic_id in the format of", "\n", "# category_id * label_divisor + instance_id. We reserve -1 for", "\n", "# VOID label.", "\n", "label_divisor", "=", "metadata", ".", "label_divisor", "\n", "segments_info", "=", "[", "]", "\n", "for", "panoptic_label", "in", "np", ".", "unique", "(", "panoptic_seg", ".", "numpy", "(", ")", ")", ":", "\n", "                ", "if", "panoptic_label", "==", "-", "1", ":", "\n", "# VOID region.", "\n", "                    ", "continue", "\n", "", "pred_class", "=", "panoptic_label", "//", "label_divisor", "\n", "isthing", "=", "pred_class", "in", "metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", "\n", "segments_info", ".", "append", "(", "\n", "{", "\n", "\"id\"", ":", "int", "(", "panoptic_label", ")", ",", "\n", "\"category_id\"", ":", "int", "(", "pred_class", ")", ",", "\n", "\"isthing\"", ":", "bool", "(", "isthing", ")", ",", "\n", "}", "\n", ")", "\n", "", "", "del", "metadata", "\n", "\n", "self", ".", "_seg", "=", "panoptic_seg", "\n", "\n", "self", ".", "_sinfo", "=", "{", "s", "[", "\"id\"", "]", ":", "s", "for", "s", "in", "segments_info", "}", "# seg id -> seg info", "\n", "segment_ids", ",", "areas", "=", "torch", ".", "unique", "(", "panoptic_seg", ",", "sorted", "=", "True", ",", "return_counts", "=", "True", ")", "\n", "areas", "=", "areas", ".", "numpy", "(", ")", "\n", "sorted_idxs", "=", "np", ".", "argsort", "(", "-", "areas", ")", "\n", "self", ".", "_seg_ids", ",", "self", ".", "_seg_areas", "=", "segment_ids", "[", "sorted_idxs", "]", ",", "areas", "[", "sorted_idxs", "]", "\n", "self", ".", "_seg_ids", "=", "self", ".", "_seg_ids", ".", "tolist", "(", ")", "\n", "for", "sid", ",", "area", "in", "zip", "(", "self", ".", "_seg_ids", ",", "self", ".", "_seg_areas", ")", ":", "\n", "            ", "if", "sid", "in", "self", ".", "_sinfo", ":", "\n", "                ", "self", ".", "_sinfo", "[", "sid", "]", "[", "\"area\"", "]", "=", "float", "(", "area", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.non_empty_mask": [[186, 201], ["len", "numpy.zeros", "len", "empty_ids.append"], "methods", ["None"], ["", "", "", "def", "non_empty_mask", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            (H, W) array, a mask for all pixels that have a prediction\n        \"\"\"", "\n", "empty_ids", "=", "[", "]", "\n", "for", "id", "in", "self", ".", "_seg_ids", ":", "\n", "            ", "if", "id", "not", "in", "self", ".", "_sinfo", ":", "\n", "                ", "empty_ids", ".", "append", "(", "id", ")", "\n", "", "", "if", "len", "(", "empty_ids", ")", "==", "0", ":", "\n", "            ", "return", "np", ".", "zeros", "(", "self", ".", "_seg", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "assert", "(", "\n", "len", "(", "empty_ids", ")", "==", "1", "\n", ")", ",", "\">1 ids corresponds to no labels. This is currently not supported\"", "\n", "return", "(", "self", ".", "_seg", "!=", "empty_ids", "[", "0", "]", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.semantic_masks": [[202, 209], ["visualizer._PanopticPrediction._sinfo.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "semantic_masks", "(", "self", ")", ":", "\n", "        ", "for", "sid", "in", "self", ".", "_seg_ids", ":", "\n", "            ", "sinfo", "=", "self", ".", "_sinfo", ".", "get", "(", "sid", ")", "\n", "if", "sinfo", "is", "None", "or", "sinfo", "[", "\"isthing\"", "]", ":", "\n", "# Some pixels (e.g. id 0 in PanopticFPN) have no instance or semantic predictions.", "\n", "                ", "continue", "\n", "", "yield", "(", "self", ".", "_seg", "==", "sid", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "bool", ")", ",", "sinfo", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.instance_masks": [[210, 218], ["visualizer._PanopticPrediction._sinfo.get", "mask.sum"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "instance_masks", "(", "self", ")", ":", "\n", "        ", "for", "sid", "in", "self", ".", "_seg_ids", ":", "\n", "            ", "sinfo", "=", "self", ".", "_sinfo", ".", "get", "(", "sid", ")", "\n", "if", "sinfo", "is", "None", "or", "not", "sinfo", "[", "\"isthing\"", "]", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "(", "self", ".", "_seg", "==", "sid", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "if", "mask", ".", "sum", "(", ")", ">", "0", ":", "\n", "                ", "yield", "mask", ",", "sinfo", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.__init__": [[242, 252], ["visualizer.VisImage._setup_figure"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage._setup_figure"], ["    ", "def", "__init__", "(", "self", ",", "img", ",", "scale", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (ndarray): an RGB image of shape (H, W, 3).\n            scale (float): scale the input image\n        \"\"\"", "\n", "self", ".", "img", "=", "img", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "width", ",", "self", ".", "height", "=", "img", ".", "shape", "[", "1", "]", ",", "img", ".", "shape", "[", "0", "]", "\n", "self", ".", "_setup_figure", "(", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage._setup_figure": [[253, 279], ["matplotlib.Figure", "matplotlib.Figure", "matplotlib.Figure", "matplotlib.Figure.get_dpi", "matplotlib.Figure.set_size_inches", "matplotlib.backends.backend_agg.FigureCanvasAgg", "matplotlib.backends.backend_agg.FigureCanvasAgg", "matplotlib.backends.backend_agg.FigureCanvasAgg", "matplotlib.Figure.add_axes", "mplfigure.Figure.add_axes.axis", "mplfigure.Figure.add_axes.imshow"], "methods", ["None"], ["", "def", "_setup_figure", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            Same as in :meth:`__init__()`.\n\n        Returns:\n            fig (matplotlib.pyplot.figure): top level container for all the image plot elements.\n            ax (matplotlib.pyplot.Axes): contains figure elements and sets the coordinate system.\n        \"\"\"", "\n", "fig", "=", "mplfigure", ".", "Figure", "(", "frameon", "=", "False", ")", "\n", "self", ".", "dpi", "=", "fig", ".", "get_dpi", "(", ")", "\n", "# add a small 1e-2 to avoid precision lost due to matplotlib's truncation", "\n", "# (https://github.com/matplotlib/matplotlib/issues/15363)", "\n", "fig", ".", "set_size_inches", "(", "\n", "(", "self", ".", "width", "*", "self", ".", "scale", "+", "1e-2", ")", "/", "self", ".", "dpi", ",", "\n", "(", "self", ".", "height", "*", "self", ".", "scale", "+", "1e-2", ")", "/", "self", ".", "dpi", ",", "\n", ")", "\n", "self", ".", "canvas", "=", "FigureCanvasAgg", "(", "fig", ")", "\n", "# self.canvas = mpl.backends.backend_cairo.FigureCanvasCairo(fig)", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "ax", ".", "axis", "(", "\"off\"", ")", "\n", "# Need to imshow this first so that other patches can be drawn on top", "\n", "ax", ".", "imshow", "(", "img", ",", "extent", "=", "(", "0", ",", "self", ".", "width", ",", "self", ".", "height", ",", "0", ")", ",", "interpolation", "=", "\"nearest\"", ")", "\n", "\n", "self", ".", "fig", "=", "fig", "\n", "self", ".", "ax", "=", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save": [[280, 287], ["visualizer.VisImage.fig.savefig"], "methods", ["None"], ["", "def", "save", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            filepath (str): a string that contains the absolute path, including the file name, where\n                the visualized image will be saved.\n        \"\"\"", "\n", "self", ".", "fig", ".", "savefig", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image": [[288, 307], ["canvas.print_to_buffer", "numpy.frombuffer", "numpy.frombuffer.reshape", "numpy.split", "rgb.astype"], "methods", ["None"], ["", "def", "get_image", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            ndarray:\n                the visualized image of shape (H, W, 3) (RGB) in uint8 type.\n                The shape is scaled w.r.t the input image using the given `scale` argument.\n        \"\"\"", "\n", "canvas", "=", "self", ".", "canvas", "\n", "s", ",", "(", "width", ",", "height", ")", "=", "canvas", ".", "print_to_buffer", "(", ")", "\n", "# buf = io.BytesIO()  # works for cairo backend", "\n", "# canvas.print_rgba(buf)", "\n", "# width, height = self.width, self.height", "\n", "# s = buf.getvalue()", "\n", "\n", "buffer", "=", "np", ".", "frombuffer", "(", "s", ",", "dtype", "=", "\"uint8\"", ")", "\n", "\n", "img_rgba", "=", "buffer", ".", "reshape", "(", "height", ",", "width", ",", "4", ")", "\n", "rgb", ",", "alpha", "=", "np", ".", "split", "(", "img_rgba", ",", "[", "3", "]", ",", "axis", "=", "2", ")", "\n", "return", "rgb", ".", "astype", "(", "\"uint8\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.__init__": [[331, 355], ["numpy.asarray().clip().astype", "visualizer.VisImage", "torch.device", "max", "detectron2.data.MetadataCatalog.get", "numpy.asarray().clip", "numpy.sqrt", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["def", "__init__", "(", "self", ",", "img_rgb", ",", "metadata", "=", "None", ",", "scale", "=", "1.0", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img_rgb: a numpy array of shape (H, W, C), where H and W correspond to\n                the height and width of the image respectively. C is the number of\n                color channels. The image is required to be in RGB format since that\n                is a requirement of the Matplotlib library. The image is also expected\n                to be in the range [0, 255].\n            metadata (Metadata): image metadata.\n            instance_mode (ColorMode): defines one of the pre-defined style for drawing\n                instances on an image.\n        \"\"\"", "\n", "self", ".", "img", "=", "np", ".", "asarray", "(", "img_rgb", ")", ".", "clip", "(", "0", ",", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "if", "metadata", "is", "None", ":", "\n", "            ", "metadata", "=", "MetadataCatalog", ".", "get", "(", "\"__nonexist__\"", ")", "\n", "", "self", ".", "metadata", "=", "metadata", "\n", "self", ".", "output", "=", "VisImage", "(", "self", ".", "img", ",", "scale", "=", "scale", ")", "\n", "self", ".", "cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "# too small texts are useless, therefore clamp to 9", "\n", "self", ".", "_default_font_size", "=", "max", "(", "\n", "np", ".", "sqrt", "(", "self", ".", "output", ".", "height", "*", "self", ".", "output", ".", "width", ")", "//", "90", ",", "10", "//", "scale", "\n", ")", "\n", "self", ".", "_instance_mode", "=", "instance_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_instance_predictions": [[356, 406], ["visualizer._create_text_labels", "predictions.has", "visualizer.Visualizer.overlay_instances", "predictions.has", "predictions.has", "predictions.has", "visualizer.Visualizer.metadata.get", "predictions.has", "numpy.asarray", "visualizer.Visualizer.metadata.get", "visualizer.Visualizer._create_grayscale_image", "visualizer.GenericMask", "visualizer.Visualizer._jitter", "predictions.has", "predictions.pred_masks.any"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._create_text_labels", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._create_grayscale_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._jitter", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has"], ["", "def", "draw_instance_predictions", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Draw instance-level prediction results on an image.\n\n        Args:\n            predictions (Instances): the output of an instance detection/segmentation\n                model. Following fields will be used to draw:\n                \"pred_boxes\", \"pred_classes\", \"scores\", \"pred_masks\" (or \"pred_masks_rle\").\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "boxes", "=", "predictions", ".", "pred_boxes", "if", "predictions", ".", "has", "(", "\"pred_boxes\"", ")", "else", "None", "\n", "scores", "=", "predictions", ".", "scores", "if", "predictions", ".", "has", "(", "\"scores\"", ")", "else", "None", "\n", "classes", "=", "predictions", ".", "pred_classes", "if", "predictions", ".", "has", "(", "\"pred_classes\"", ")", "else", "None", "\n", "labels", "=", "_create_text_labels", "(", "classes", ",", "scores", ",", "self", ".", "metadata", ".", "get", "(", "\"thing_classes\"", ",", "None", ")", ")", "\n", "keypoints", "=", "predictions", ".", "pred_keypoints", "if", "predictions", ".", "has", "(", "\"pred_keypoints\"", ")", "else", "None", "\n", "\n", "if", "predictions", ".", "has", "(", "\"pred_masks\"", ")", ":", "\n", "            ", "masks", "=", "np", ".", "asarray", "(", "predictions", ".", "pred_masks", ")", "\n", "masks", "=", "[", "GenericMask", "(", "x", ",", "self", ".", "output", ".", "height", ",", "self", ".", "output", ".", "width", ")", "for", "x", "in", "masks", "]", "\n", "", "else", ":", "\n", "            ", "masks", "=", "None", "\n", "\n", "", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "SEGMENTATION", "and", "self", ".", "metadata", ".", "get", "(", "\"thing_colors\"", ")", ":", "\n", "            ", "colors", "=", "[", "\n", "self", ".", "_jitter", "(", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "thing_colors", "[", "c", "]", "]", ")", "for", "c", "in", "classes", "\n", "]", "\n", "alpha", "=", "0.8", "\n", "", "else", ":", "\n", "            ", "colors", "=", "None", "\n", "alpha", "=", "0.5", "\n", "\n", "", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "            ", "self", ".", "output", ".", "img", "=", "self", ".", "_create_grayscale_image", "(", "\n", "(", "predictions", ".", "pred_masks", ".", "any", "(", "dim", "=", "0", ")", ">", "0", ")", ".", "numpy", "(", ")", "\n", "if", "predictions", ".", "has", "(", "\"pred_masks\"", ")", "\n", "else", "None", "\n", ")", "\n", "alpha", "=", "0.3", "\n", "\n", "", "self", ".", "overlay_instances", "(", "\n", "masks", "=", "masks", ",", "\n", "boxes", "=", "boxes", ",", "\n", "labels", "=", "labels", ",", "\n", "keypoints", "=", "keypoints", ",", "\n", "assigned_colors", "=", "colors", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_sem_seg": [[407, 442], ["isinstance", "numpy.unique", "numpy.argsort().tolist", "filter", "sem_seg.numpy.numpy.numpy", "visualizer.Visualizer.draw_binary_mask", "numpy.argsort", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_binary_mask"], ["", "def", "draw_sem_seg", "(", "self", ",", "sem_seg", ",", "area_threshold", "=", "None", ",", "alpha", "=", "0.8", ")", ":", "\n", "        ", "\"\"\"\n        Draw semantic segmentation predictions/labels.\n\n        Args:\n            sem_seg (Tensor or ndarray): the segmentation of shape (H, W).\n                Each value is the integer label of the pixel.\n            area_threshold (int): segments with less than `area_threshold` are not drawn.\n            alpha (float): the larger it is, the more opaque the segmentations are.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "if", "isinstance", "(", "sem_seg", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "sem_seg", "=", "sem_seg", ".", "numpy", "(", ")", "\n", "", "labels", ",", "areas", "=", "np", ".", "unique", "(", "sem_seg", ",", "return_counts", "=", "True", ")", "\n", "sorted_idxs", "=", "np", ".", "argsort", "(", "-", "areas", ")", ".", "tolist", "(", ")", "\n", "labels", "=", "labels", "[", "sorted_idxs", "]", "\n", "for", "label", "in", "filter", "(", "lambda", "l", ":", "l", "<", "len", "(", "self", ".", "metadata", ".", "stuff_classes", ")", ",", "labels", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "mask_color", "=", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "stuff_colors", "[", "label", "]", "]", "\n", "", "except", "(", "AttributeError", ",", "IndexError", ")", ":", "\n", "                ", "mask_color", "=", "None", "\n", "\n", "", "binary_mask", "=", "(", "sem_seg", "==", "label", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "text", "=", "self", ".", "metadata", ".", "stuff_classes", "[", "label", "]", "\n", "self", ".", "draw_binary_mask", "(", "\n", "binary_mask", ",", "\n", "color", "=", "mask_color", ",", "\n", "edge_color", "=", "_OFF_WHITE", ",", "\n", "text", "=", "text", ",", "\n", "alpha", "=", "alpha", ",", "\n", "area_threshold", "=", "area_threshold", ",", "\n", ")", "\n", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_panoptic_seg_predictions": [[443, 504], ["visualizer._PanopticPrediction", "visualizer._PanopticPrediction.semantic_masks", "list", "list", "visualizer._create_text_labels", "visualizer.Visualizer.overlay_instances", "visualizer.Visualizer._create_grayscale_image", "visualizer.Visualizer.draw_binary_mask", "visualizer._PanopticPrediction.instance_masks", "len", "zip", "visualizer._PanopticPrediction.non_empty_mask", "visualizer.Visualizer._jitter"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.semantic_masks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._create_text_labels", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._create_grayscale_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_binary_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.instance_masks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.non_empty_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._jitter"], ["", "def", "draw_panoptic_seg_predictions", "(", "\n", "self", ",", "panoptic_seg", ",", "segments_info", ",", "area_threshold", "=", "None", ",", "alpha", "=", "0.7", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Draw panoptic prediction results on an image.\n\n        Args:\n            panoptic_seg (Tensor): of shape (height, width) where the values are ids for each\n                segment.\n            segments_info (list[dict]): Describe each segment in `panoptic_seg`.\n                Each dict contains keys \"id\", \"category_id\", \"isthing\".\n            area_threshold (int): stuff segments with less than `area_threshold` are not drawn.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "pred", "=", "_PanopticPrediction", "(", "panoptic_seg", ",", "segments_info", ",", "self", ".", "metadata", ")", "\n", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "            ", "self", ".", "output", ".", "img", "=", "self", ".", "_create_grayscale_image", "(", "pred", ".", "non_empty_mask", "(", ")", ")", "\n", "\n", "# draw mask for all semantic segments first i.e. \"stuff\"", "\n", "", "for", "mask", ",", "sinfo", "in", "pred", ".", "semantic_masks", "(", ")", ":", "\n", "            ", "category_idx", "=", "sinfo", "[", "\"category_id\"", "]", "\n", "try", ":", "\n", "                ", "mask_color", "=", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "stuff_colors", "[", "category_idx", "]", "]", "\n", "", "except", "AttributeError", ":", "\n", "                ", "mask_color", "=", "None", "\n", "\n", "", "text", "=", "self", ".", "metadata", ".", "stuff_classes", "[", "category_idx", "]", "\n", "self", ".", "draw_binary_mask", "(", "\n", "mask", ",", "\n", "color", "=", "mask_color", ",", "\n", "edge_color", "=", "_OFF_WHITE", ",", "\n", "text", "=", "text", ",", "\n", "alpha", "=", "alpha", ",", "\n", "area_threshold", "=", "area_threshold", ",", "\n", ")", "\n", "\n", "# draw mask for all instances second", "\n", "", "all_instances", "=", "list", "(", "pred", ".", "instance_masks", "(", ")", ")", "\n", "if", "len", "(", "all_instances", ")", "==", "0", ":", "\n", "            ", "return", "self", ".", "output", "\n", "", "masks", ",", "sinfo", "=", "list", "(", "zip", "(", "*", "all_instances", ")", ")", "\n", "category_ids", "=", "[", "x", "[", "\"category_id\"", "]", "for", "x", "in", "sinfo", "]", "\n", "\n", "try", ":", "\n", "            ", "scores", "=", "[", "x", "[", "\"score\"", "]", "for", "x", "in", "sinfo", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "scores", "=", "None", "\n", "", "labels", "=", "_create_text_labels", "(", "category_ids", ",", "scores", ",", "self", ".", "metadata", ".", "thing_classes", ")", "\n", "\n", "try", ":", "\n", "            ", "colors", "=", "[", "\n", "self", ".", "_jitter", "(", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "thing_colors", "[", "c", "]", "]", ")", "for", "c", "in", "category_ids", "\n", "]", "\n", "", "except", "AttributeError", ":", "\n", "            ", "colors", "=", "None", "\n", "", "self", ".", "overlay_instances", "(", "masks", "=", "masks", ",", "labels", "=", "labels", ",", "assigned_colors", "=", "colors", ",", "alpha", "=", "alpha", ")", "\n", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_dataset_dict": [[505, 554], ["dic.get", "dic.get", "visualizer.Visualizer.metadata.get", "visualizer.Visualizer.overlay_instances", "visualizer.Visualizer.draw_sem_seg", "numpy.array().reshape", "detectron2.structures.BoxMode.convert", "visualizer.Visualizer.metadata.get", "fvcore.common.file_io.PathManager.open", "PIL.Image.open", "numpy.asarray", "len", "visualizer.Visualizer._jitter", "zip", "numpy.array", "a.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_sem_seg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._jitter", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "draw_dataset_dict", "(", "self", ",", "dic", ")", ":", "\n", "        ", "\"\"\"\n        Draw annotations/segmentaions in Detectron2 Dataset format.\n\n        Args:\n            dic (dict): annotation/segmentation data of one image, in Detectron2 Dataset format.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "annos", "=", "dic", ".", "get", "(", "\"annotations\"", ",", "None", ")", "\n", "if", "annos", ":", "\n", "            ", "if", "\"segmentation\"", "in", "annos", "[", "0", "]", ":", "\n", "                ", "masks", "=", "[", "x", "[", "\"segmentation\"", "]", "for", "x", "in", "annos", "]", "\n", "", "else", ":", "\n", "                ", "masks", "=", "None", "\n", "", "if", "\"keypoints\"", "in", "annos", "[", "0", "]", ":", "\n", "                ", "keypts", "=", "[", "x", "[", "\"keypoints\"", "]", "for", "x", "in", "annos", "]", "\n", "keypts", "=", "np", ".", "array", "(", "keypts", ")", ".", "reshape", "(", "len", "(", "annos", ")", ",", "-", "1", ",", "3", ")", "\n", "", "else", ":", "\n", "                ", "keypts", "=", "None", "\n", "\n", "", "boxes", "=", "[", "BoxMode", ".", "convert", "(", "x", "[", "\"bbox\"", "]", ",", "x", "[", "\"bbox_mode\"", "]", ",", "BoxMode", ".", "XYXY_ABS", ")", "for", "x", "in", "annos", "]", "\n", "\n", "labels", "=", "[", "x", "[", "\"category_id\"", "]", "for", "x", "in", "annos", "]", "\n", "colors", "=", "None", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "SEGMENTATION", "and", "self", ".", "metadata", ".", "get", "(", "\"thing_colors\"", ")", ":", "\n", "                ", "colors", "=", "[", "\n", "self", ".", "_jitter", "(", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "thing_colors", "[", "c", "]", "]", ")", "for", "c", "in", "labels", "\n", "]", "\n", "", "names", "=", "self", ".", "metadata", ".", "get", "(", "\"thing_classes\"", ",", "None", ")", "\n", "if", "names", ":", "\n", "                ", "labels", "=", "[", "names", "[", "i", "]", "for", "i", "in", "labels", "]", "\n", "", "labels", "=", "[", "\n", "\"{}\"", ".", "format", "(", "i", ")", "+", "(", "\"|crowd\"", "if", "a", ".", "get", "(", "\"iscrowd\"", ",", "0", ")", "else", "\"\"", ")", "\n", "for", "i", ",", "a", "in", "zip", "(", "labels", ",", "annos", ")", "\n", "]", "\n", "self", ".", "overlay_instances", "(", "\n", "labels", "=", "labels", ",", "boxes", "=", "boxes", ",", "masks", "=", "masks", ",", "keypoints", "=", "keypts", ",", "assigned_colors", "=", "colors", "\n", ")", "\n", "\n", "", "sem_seg", "=", "dic", ".", "get", "(", "\"sem_seg\"", ",", "None", ")", "\n", "if", "sem_seg", "is", "None", "and", "\"sem_seg_file_name\"", "in", "dic", ":", "\n", "            ", "with", "PathManager", ".", "open", "(", "dic", "[", "\"sem_seg_file_name\"", "]", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "sem_seg", "=", "Image", ".", "open", "(", "f", ")", "\n", "sem_seg", "=", "np", ".", "asarray", "(", "sem_seg", ",", "dtype", "=", "\"uint8\"", ")", "\n", "", "", "if", "sem_seg", "is", "not", "None", ":", "\n", "            ", "self", ".", "draw_sem_seg", "(", "sem_seg", ",", "area_threshold", "=", "0", ",", "alpha", "=", "0.5", ")", "\n", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances": [[555, 697], ["range", "visualizer.Visualizer._convert_boxes", "len", "visualizer.Visualizer._convert_masks", "visualizer.Visualizer._convert_keypoints", "visualizer.Visualizer.overlay_rotated_instances", "numpy.prod", "numpy.argsort().tolist", "len", "len", "len", "colormap.random_color", "numpy.asarray", "visualizer.Visualizer.draw_box", "visualizer.Visualizer._change_color_brightness", "visualizer.Visualizer.draw_text", "visualizer.Visualizer.draw_and_connect_keypoints", "len", "len", "range", "numpy.argsort", "visualizer.Visualizer.draw_polygon", "numpy.sqrt", "x.area", "segment.reshape", "masks[].bbox", "numpy.clip", "len", "numpy.median", "masks[].mask.nonzero"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._convert_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._convert_masks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._convert_keypoints", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_rotated_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.colormap.random_color", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_box", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._change_color_brightness", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_text", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_and_connect_keypoints", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_polygon", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.GenericMask.bbox", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "def", "overlay_instances", "(", "\n", "self", ",", "\n", "*", ",", "\n", "boxes", "=", "None", ",", "\n", "labels", "=", "None", ",", "\n", "masks", "=", "None", ",", "\n", "keypoints", "=", "None", ",", "\n", "assigned_colors", "=", "None", ",", "\n", "alpha", "=", "0.5", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            boxes (Boxes, RotatedBoxes or ndarray): either a :class:`Boxes`,\n                or an Nx4 numpy array of XYXY_ABS format for the N objects in a single image,\n                or a :class:`RotatedBoxes`,\n                or an Nx5 numpy array of (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image,\n            labels (list[str]): the text to be displayed for each instance.\n            masks (masks-like object): Supported types are:\n\n                * :class:`detectron2.structures.PolygonMasks`,\n                  :class:`detectron2.structures.BitMasks`.\n                * list[list[ndarray]]: contains the segmentation masks for all objects in one image.\n                  The first level of the list corresponds to individual instances. The second\n                  level to all the polygon that compose the instance, and the third level\n                  to the polygon coordinates. The third level should have the format of\n                  [x0, y0, x1, y1, ..., xn, yn] (n >= 3).\n                * list[ndarray]: each ndarray is a binary mask of shape (H, W).\n                * list[dict]: each dict is a COCO-style RLE.\n            keypoints (Keypoint or array like): an array-like object of shape (N, K, 3),\n                where the N is the number of instances and K is the number of keypoints.\n                The last dimension corresponds to (x, y, visibility or score).\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "num_instances", "=", "None", "\n", "if", "boxes", "is", "not", "None", ":", "\n", "            ", "boxes", "=", "self", ".", "_convert_boxes", "(", "boxes", ")", "\n", "num_instances", "=", "len", "(", "boxes", ")", "\n", "", "if", "masks", "is", "not", "None", ":", "\n", "            ", "masks", "=", "self", ".", "_convert_masks", "(", "masks", ")", "\n", "if", "num_instances", ":", "\n", "                ", "assert", "len", "(", "masks", ")", "==", "num_instances", "\n", "", "else", ":", "\n", "                ", "num_instances", "=", "len", "(", "masks", ")", "\n", "", "", "if", "keypoints", "is", "not", "None", ":", "\n", "            ", "if", "num_instances", ":", "\n", "                ", "assert", "len", "(", "keypoints", ")", "==", "num_instances", "\n", "", "else", ":", "\n", "                ", "num_instances", "=", "len", "(", "keypoints", ")", "\n", "", "keypoints", "=", "self", ".", "_convert_keypoints", "(", "keypoints", ")", "\n", "", "if", "labels", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "labels", ")", "==", "num_instances", "\n", "", "if", "assigned_colors", "is", "None", ":", "\n", "            ", "assigned_colors", "=", "[", "random_color", "(", "rgb", "=", "True", ",", "maximum", "=", "1", ")", "for", "_", "in", "range", "(", "num_instances", ")", "]", "\n", "", "if", "num_instances", "==", "0", ":", "\n", "            ", "return", "self", ".", "output", "\n", "", "if", "boxes", "is", "not", "None", "and", "boxes", ".", "shape", "[", "1", "]", "==", "5", ":", "\n", "            ", "return", "self", ".", "overlay_rotated_instances", "(", "\n", "boxes", "=", "boxes", ",", "labels", "=", "labels", ",", "assigned_colors", "=", "assigned_colors", "\n", ")", "\n", "\n", "# Display in largest to smallest order to reduce occlusion.", "\n", "", "areas", "=", "None", "\n", "if", "boxes", "is", "not", "None", ":", "\n", "            ", "areas", "=", "np", ".", "prod", "(", "boxes", "[", ":", ",", "2", ":", "]", "-", "boxes", "[", ":", ",", ":", "2", "]", ",", "axis", "=", "1", ")", "\n", "", "elif", "masks", "is", "not", "None", ":", "\n", "            ", "areas", "=", "np", ".", "asarray", "(", "[", "x", ".", "area", "(", ")", "for", "x", "in", "masks", "]", ")", "\n", "\n", "", "if", "areas", "is", "not", "None", ":", "\n", "            ", "sorted_idxs", "=", "np", ".", "argsort", "(", "-", "areas", ")", ".", "tolist", "(", ")", "\n", "# Re-order overlapped instances in descending order.", "\n", "boxes", "=", "boxes", "[", "sorted_idxs", "]", "if", "boxes", "is", "not", "None", "else", "None", "\n", "labels", "=", "[", "labels", "[", "k", "]", "for", "k", "in", "sorted_idxs", "]", "if", "labels", "is", "not", "None", "else", "None", "\n", "masks", "=", "[", "masks", "[", "idx", "]", "for", "idx", "in", "sorted_idxs", "]", "if", "masks", "is", "not", "None", "else", "None", "\n", "assigned_colors", "=", "[", "assigned_colors", "[", "idx", "]", "for", "idx", "in", "sorted_idxs", "]", "\n", "keypoints", "=", "keypoints", "[", "sorted_idxs", "]", "if", "keypoints", "is", "not", "None", "else", "None", "\n", "\n", "", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "            ", "color", "=", "assigned_colors", "[", "i", "]", "\n", "if", "boxes", "is", "not", "None", ":", "\n", "                ", "self", ".", "draw_box", "(", "boxes", "[", "i", "]", ",", "edge_color", "=", "color", ")", "\n", "\n", "", "if", "masks", "is", "not", "None", ":", "\n", "                ", "for", "segment", "in", "masks", "[", "i", "]", ".", "polygons", ":", "\n", "                    ", "self", ".", "draw_polygon", "(", "segment", ".", "reshape", "(", "-", "1", ",", "2", ")", ",", "color", ",", "alpha", "=", "alpha", ")", "\n", "\n", "", "", "if", "labels", "is", "not", "None", ":", "\n", "# first get a box", "\n", "                ", "if", "boxes", "is", "not", "None", ":", "\n", "                    ", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "boxes", "[", "i", "]", "\n", "text_pos", "=", "(", "x0", ",", "y0", ")", "# if drawing boxes, put text on the box corner.", "\n", "horiz_align", "=", "\"left\"", "\n", "", "elif", "masks", "is", "not", "None", ":", "\n", "# skip small mask without polygon", "\n", "                    ", "if", "len", "(", "masks", "[", "i", "]", ".", "polygons", ")", "==", "0", ":", "\n", "                        ", "continue", "\n", "\n", "", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "masks", "[", "i", "]", ".", "bbox", "(", ")", "\n", "\n", "# draw text in the center (defined by median) when box is not drawn", "\n", "# median is less sensitive to outliers.", "\n", "text_pos", "=", "np", ".", "median", "(", "masks", "[", "i", "]", ".", "mask", ".", "nonzero", "(", ")", ",", "axis", "=", "1", ")", "[", ":", ":", "-", "1", "]", "\n", "horiz_align", "=", "\"center\"", "\n", "", "else", ":", "\n", "                    ", "continue", "# drawing the box confidence for keypoints isn't very useful.", "\n", "# for small objects, draw text at the side to avoid occlusion", "\n", "", "instance_area", "=", "(", "y1", "-", "y0", ")", "*", "(", "x1", "-", "x0", ")", "\n", "if", "(", "\n", "instance_area", "<", "_SMALL_OBJECT_AREA_THRESH", "*", "self", ".", "output", ".", "scale", "\n", "or", "y1", "-", "y0", "<", "40", "*", "self", ".", "output", ".", "scale", "\n", ")", ":", "\n", "                    ", "if", "y1", ">=", "self", ".", "output", ".", "height", "-", "5", ":", "\n", "                        ", "text_pos", "=", "(", "x1", ",", "y0", ")", "\n", "", "else", ":", "\n", "                        ", "text_pos", "=", "(", "x0", ",", "y1", ")", "\n", "\n", "", "", "height_ratio", "=", "(", "y1", "-", "y0", ")", "/", "np", ".", "sqrt", "(", "self", ".", "output", ".", "height", "*", "self", ".", "output", ".", "width", ")", "\n", "lighter_color", "=", "self", ".", "_change_color_brightness", "(", "color", ",", "brightness_factor", "=", "0.7", ")", "\n", "font_size", "=", "(", "\n", "np", ".", "clip", "(", "(", "height_ratio", "-", "0.02", ")", "/", "0.08", "+", "1", ",", "1.2", ",", "2", ")", "\n", "*", "0.5", "\n", "*", "self", ".", "_default_font_size", "\n", ")", "\n", "self", ".", "draw_text", "(", "\n", "labels", "[", "i", "]", ",", "\n", "text_pos", ",", "\n", "color", "=", "lighter_color", ",", "\n", "horizontal_alignment", "=", "horiz_align", ",", "\n", "font_size", "=", "font_size", ",", "\n", ")", "\n", "\n", "# draw keypoints", "\n", "", "", "if", "keypoints", "is", "not", "None", ":", "\n", "            ", "for", "keypoints_per_instance", "in", "keypoints", ":", "\n", "                ", "self", ".", "draw_and_connect_keypoints", "(", "keypoints_per_instance", ")", "\n", "\n", "", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_rotated_instances": [[698, 735], ["len", "numpy.argsort().tolist", "range", "visualizer.Visualizer.draw_rotated_box_with_label", "colormap.random_color", "numpy.argsort", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_rotated_box_with_label", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.colormap.random_color"], ["", "def", "overlay_rotated_instances", "(", "self", ",", "boxes", "=", "None", ",", "labels", "=", "None", ",", "assigned_colors", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            boxes (ndarray): an Nx5 numpy array of\n                (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image.\n            labels (list[str]): the text to be displayed for each instance.\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "num_instances", "=", "len", "(", "boxes", ")", "\n", "\n", "if", "assigned_colors", "is", "None", ":", "\n", "            ", "assigned_colors", "=", "[", "random_color", "(", "rgb", "=", "True", ",", "maximum", "=", "1", ")", "for", "_", "in", "range", "(", "num_instances", ")", "]", "\n", "", "if", "num_instances", "==", "0", ":", "\n", "            ", "return", "self", ".", "output", "\n", "\n", "# Display in largest to smallest order to reduce occlusion.", "\n", "", "if", "boxes", "is", "not", "None", ":", "\n", "            ", "areas", "=", "boxes", "[", ":", ",", "2", "]", "*", "boxes", "[", ":", ",", "3", "]", "\n", "\n", "", "sorted_idxs", "=", "np", ".", "argsort", "(", "-", "areas", ")", ".", "tolist", "(", ")", "\n", "# Re-order overlapped instances in descending order.", "\n", "boxes", "=", "boxes", "[", "sorted_idxs", "]", "\n", "labels", "=", "[", "labels", "[", "k", "]", "for", "k", "in", "sorted_idxs", "]", "if", "labels", "is", "not", "None", "else", "None", "\n", "colors", "=", "[", "assigned_colors", "[", "idx", "]", "for", "idx", "in", "sorted_idxs", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "            ", "self", ".", "draw_rotated_box_with_label", "(", "\n", "boxes", "[", "i", "]", ",", "edge_color", "=", "colors", "[", "i", "]", ",", "label", "=", "labels", "[", "i", "]", "if", "labels", "is", "not", "None", "else", "None", "\n", ")", "\n", "\n", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_and_connect_keypoints": [[736, 793], ["visualizer.Visualizer.metadata.get", "enumerate", "visualizer.Visualizer.metadata.get", "visible.get", "visualizer.Visualizer.draw_circle", "visualizer.Visualizer.draw_line", "visualizer.Visualizer.draw_line", "tuple", "visualizer.Visualizer.draw_line"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_circle", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_line", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_line", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_line"], ["", "def", "draw_and_connect_keypoints", "(", "self", ",", "keypoints", ")", ":", "\n", "        ", "\"\"\"\n        Draws keypoints of an instance and follows the rules for keypoint connections\n        to draw lines between appropriate keypoints. This follows color heuristics for\n        line color.\n\n        Args:\n            keypoints (Tensor): a tensor of shape (K, 3), where K is the number of keypoints\n                and the last dimension corresponds to (x, y, probability).\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "visible", "=", "{", "}", "\n", "keypoint_names", "=", "self", ".", "metadata", ".", "get", "(", "\"keypoint_names\"", ")", "\n", "for", "idx", ",", "keypoint", "in", "enumerate", "(", "keypoints", ")", ":", "\n", "# draw keypoint", "\n", "            ", "x", ",", "y", ",", "prob", "=", "keypoint", "\n", "if", "prob", ">", "_KEYPOINT_THRESHOLD", ":", "\n", "                ", "self", ".", "draw_circle", "(", "(", "x", ",", "y", ")", ",", "color", "=", "_RED", ")", "\n", "if", "keypoint_names", ":", "\n", "                    ", "keypoint_name", "=", "keypoint_names", "[", "idx", "]", "\n", "visible", "[", "keypoint_name", "]", "=", "(", "x", ",", "y", ")", "\n", "\n", "", "", "", "if", "self", ".", "metadata", ".", "get", "(", "\"keypoint_connection_rules\"", ")", ":", "\n", "            ", "for", "kp0", ",", "kp1", ",", "color", "in", "self", ".", "metadata", ".", "keypoint_connection_rules", ":", "\n", "                ", "if", "kp0", "in", "visible", "and", "kp1", "in", "visible", ":", "\n", "                    ", "x0", ",", "y0", "=", "visible", "[", "kp0", "]", "\n", "x1", ",", "y1", "=", "visible", "[", "kp1", "]", "\n", "color", "=", "tuple", "(", "x", "/", "255.0", "for", "x", "in", "color", ")", "\n", "self", ".", "draw_line", "(", "[", "x0", ",", "x1", "]", ",", "[", "y0", ",", "y1", "]", ",", "color", "=", "color", ")", "\n", "\n", "# draw lines from nose to mid-shoulder and mid-shoulder to mid-hip", "\n", "# Note that this strategy is specific to person keypoints.", "\n", "# For other keypoints, it should just do nothing", "\n", "", "", "", "try", ":", "\n", "            ", "ls_x", ",", "ls_y", "=", "visible", "[", "\"left_shoulder\"", "]", "\n", "rs_x", ",", "rs_y", "=", "visible", "[", "\"right_shoulder\"", "]", "\n", "mid_shoulder_x", ",", "mid_shoulder_y", "=", "(", "ls_x", "+", "rs_x", ")", "/", "2", ",", "(", "ls_y", "+", "rs_y", ")", "/", "2", "\n", "", "except", "KeyError", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "# draw line from nose to mid-shoulder", "\n", "            ", "nose_x", ",", "nose_y", "=", "visible", ".", "get", "(", "\"nose\"", ",", "(", "None", ",", "None", ")", ")", "\n", "if", "nose_x", "is", "not", "None", ":", "\n", "                ", "self", ".", "draw_line", "(", "[", "nose_x", ",", "mid_shoulder_x", "]", ",", "[", "nose_y", ",", "mid_shoulder_y", "]", ",", "color", "=", "_RED", ")", "\n", "\n", "", "try", ":", "\n", "# draw line from mid-shoulder to mid-hip", "\n", "                ", "lh_x", ",", "lh_y", "=", "visible", "[", "\"left_hip\"", "]", "\n", "rh_x", ",", "rh_y", "=", "visible", "[", "\"right_hip\"", "]", "\n", "", "except", "KeyError", ":", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "mid_hip_x", ",", "mid_hip_y", "=", "(", "lh_x", "+", "rh_x", ")", "/", "2", ",", "(", "lh_y", "+", "rh_y", ")", "/", "2", "\n", "self", ".", "draw_line", "(", "[", "mid_hip_x", ",", "mid_shoulder_x", "]", ",", "[", "mid_hip_y", ",", "mid_shoulder_y", "]", ",", "color", "=", "_RED", ")", "\n", "", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_text": [[798, 844], ["numpy.maximum", "max", "visualizer.Visualizer.output.ax.text", "list", "numpy.max", "matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["def", "draw_text", "(", "\n", "self", ",", "\n", "text", ",", "\n", "position", ",", "\n", "*", ",", "\n", "font_size", "=", "None", ",", "\n", "color", "=", "\"g\"", ",", "\n", "horizontal_alignment", "=", "\"center\"", ",", "\n", "rotation", "=", "0", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            text (str): class label\n            position (tuple): a tuple of the x and y coordinates to place text on image.\n            font_size (int, optional): font of the text. If not provided, a font size\n                proportional to the image width is calculated and used.\n            color: color of the text. Refer to `matplotlib.colors` for full list\n                of formats that are accepted.\n            horizontal_alignment (str): see `matplotlib.text.Text`\n            rotation: rotation angle in degrees CCW\n\n        Returns:\n            output (VisImage): image object with text drawn.\n        \"\"\"", "\n", "if", "not", "font_size", ":", "\n", "            ", "font_size", "=", "self", ".", "_default_font_size", "\n", "\n", "# since the text background is dark, we don't want the text to be dark", "\n", "", "color", "=", "np", ".", "maximum", "(", "list", "(", "mplc", ".", "to_rgb", "(", "color", ")", ")", ",", "0.2", ")", "\n", "color", "[", "np", ".", "argmax", "(", "color", ")", "]", "=", "max", "(", "0.8", ",", "np", ".", "max", "(", "color", ")", ")", "\n", "\n", "x", ",", "y", "=", "position", "\n", "self", ".", "output", ".", "ax", ".", "text", "(", "\n", "x", ",", "\n", "y", ",", "\n", "text", ",", "\n", "size", "=", "25", ",", "\n", "family", "=", "\"sans-serif\"", ",", "\n", "bbox", "=", "{", "\"facecolor\"", ":", "\"black\"", ",", "\"alpha\"", ":", "0.8", ",", "\"pad\"", ":", "0.7", ",", "\"edgecolor\"", ":", "\"none\"", "}", ",", "\n", "verticalalignment", "=", "\"top\"", ",", "\n", "horizontalalignment", "=", "horizontal_alignment", ",", "\n", "color", "=", "color", ",", "\n", "zorder", "=", "10", ",", "\n", "rotation", "=", "rotation", ",", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_box": [[845, 878], ["max", "visualizer.Visualizer.output.ax.add_patch", "matplotlib.patches.Rectangle", "matplotlib.patches.Rectangle", "matplotlib.patches.Rectangle"], "methods", ["None"], ["", "def", "draw_box", "(", "self", ",", "box_coord", ",", "alpha", "=", "0.5", ",", "edge_color", "=", "\"g\"", ",", "line_style", "=", "\"-\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            box_coord (tuple): a tuple containing x0, y0, x1, y1 coordinates, where x0 and y0\n                are the coordinates of the image's top left corner. x1 and y1 are the\n                coordinates of the image's bottom right corner.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"", "\n", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "box_coord", "\n", "width", "=", "x1", "-", "x0", "\n", "height", "=", "y1", "-", "y0", "\n", "\n", "linewidth", "=", "max", "(", "self", ".", "_default_font_size", "/", "4", ",", "1", ")", "\n", "\n", "self", ".", "output", ".", "ax", ".", "add_patch", "(", "\n", "mpl", ".", "patches", ".", "Rectangle", "(", "\n", "(", "x0", ",", "y0", ")", ",", "\n", "width", ",", "\n", "height", ",", "\n", "fill", "=", "False", ",", "\n", "edgecolor", "=", "edge_color", ",", "\n", "linewidth", "=", "15", ",", "\n", "alpha", "=", "alpha", ",", "\n", "linestyle", "=", "line_style", ",", "\n", ")", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_rotated_box_with_label": [[879, 933], ["math.cos", "math.sin", "range", "visualizer.Visualizer.draw_line", "visualizer.Visualizer._change_color_brightness", "visualizer.Visualizer.draw_text", "numpy.sqrt", "numpy.clip"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_line", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._change_color_brightness", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_text", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "def", "draw_rotated_box_with_label", "(", "\n", "self", ",", "rotated_box", ",", "alpha", "=", "0.5", ",", "edge_color", "=", "\"g\"", ",", "line_style", "=", "\"-\"", ",", "label", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Draw a rotated box with label on its top-left corner.\n\n        Args:\n            rotated_box (tuple): a tuple containing (cnt_x, cnt_y, w, h, angle),\n                where cnt_x and cnt_y are the center coordinates of the box.\n                w and h are the width and height of the box. angle represents how\n                many degrees the box is rotated CCW with regard to the 0-degree box.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n            label (string): label for rotated box. It will not be rendered when set to None.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"", "\n", "cnt_x", ",", "cnt_y", ",", "w", ",", "h", ",", "angle", "=", "rotated_box", "\n", "area", "=", "w", "*", "h", "\n", "# use thinner lines when the box is small", "\n", "linewidth", "=", "self", ".", "_default_font_size", "/", "(", "\n", "6", "if", "area", "<", "_SMALL_OBJECT_AREA_THRESH", "*", "self", ".", "output", ".", "scale", "else", "3", "\n", ")", "\n", "\n", "theta", "=", "angle", "*", "math", ".", "pi", "/", "180.0", "\n", "c", "=", "math", ".", "cos", "(", "theta", ")", "\n", "s", "=", "math", ".", "sin", "(", "theta", ")", "\n", "rect", "=", "[", "(", "-", "w", "/", "2", ",", "h", "/", "2", ")", ",", "(", "-", "w", "/", "2", ",", "-", "h", "/", "2", ")", ",", "(", "w", "/", "2", ",", "-", "h", "/", "2", ")", ",", "(", "w", "/", "2", ",", "h", "/", "2", ")", "]", "\n", "# x: left->right ; y: top->down", "\n", "rotated_rect", "=", "[", "(", "s", "*", "yy", "+", "c", "*", "xx", "+", "cnt_x", ",", "c", "*", "yy", "-", "s", "*", "xx", "+", "cnt_y", ")", "for", "(", "xx", ",", "yy", ")", "in", "rect", "]", "\n", "for", "k", "in", "range", "(", "4", ")", ":", "\n", "            ", "j", "=", "(", "k", "+", "1", ")", "%", "4", "\n", "self", ".", "draw_line", "(", "\n", "[", "rotated_rect", "[", "k", "]", "[", "0", "]", ",", "rotated_rect", "[", "j", "]", "[", "0", "]", "]", ",", "\n", "[", "rotated_rect", "[", "k", "]", "[", "1", "]", ",", "rotated_rect", "[", "j", "]", "[", "1", "]", "]", ",", "\n", "color", "=", "edge_color", ",", "\n", "linestyle", "=", "\"--\"", "if", "k", "==", "1", "else", "line_style", ",", "\n", "linewidth", "=", "linewidth", ",", "\n", ")", "\n", "\n", "", "if", "label", "is", "not", "None", ":", "\n", "            ", "text_pos", "=", "rotated_rect", "[", "1", "]", "# topleft corner", "\n", "\n", "height_ratio", "=", "h", "/", "np", ".", "sqrt", "(", "self", ".", "output", ".", "height", "*", "self", ".", "output", ".", "width", ")", "\n", "label_color", "=", "self", ".", "_change_color_brightness", "(", "edge_color", ",", "brightness_factor", "=", "0.7", ")", "\n", "font_size", "=", "(", "\n", "np", ".", "clip", "(", "(", "height_ratio", "-", "0.02", ")", "/", "0.08", "+", "1", ",", "1.2", ",", "2", ")", "*", "0.5", "*", "self", ".", "_default_font_size", "\n", ")", "\n", "self", ".", "draw_text", "(", "label", ",", "text_pos", ",", "color", "=", "label_color", ",", "font_size", "=", "font_size", ",", "rotation", "=", "angle", ")", "\n", "\n", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_circle": [[934, 951], ["visualizer.Visualizer.output.ax.add_patch", "matplotlib.patches.Circle", "matplotlib.patches.Circle", "matplotlib.patches.Circle"], "methods", ["None"], ["", "def", "draw_circle", "(", "self", ",", "circle_coord", ",", "color", ",", "radius", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            circle_coord (list(int) or tuple(int)): contains the x and y coordinates\n                of the center of the circle.\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            radius (int): radius of the circle.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"", "\n", "x", ",", "y", "=", "circle_coord", "\n", "self", ".", "output", ".", "ax", ".", "add_patch", "(", "\n", "mpl", ".", "patches", ".", "Circle", "(", "circle_coord", ",", "radius", "=", "radius", ",", "fill", "=", "True", ",", "color", "=", "color", ")", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_line": [[952, 982], ["max", "visualizer.Visualizer.output.ax.add_line", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D", "matplotlib.lines.Line2D"], "methods", ["None"], ["", "def", "draw_line", "(", "self", ",", "x_data", ",", "y_data", ",", "color", ",", "linestyle", "=", "\"-\"", ",", "linewidth", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x_data (list[int]): a list containing x values of all the points being drawn.\n                Length of list should match the length of y_data.\n            y_data (list[int]): a list containing y values of all the points being drawn.\n                Length of list should match the length of x_data.\n            color: color of the line. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            linestyle: style of the line. Refer to `matplotlib.lines.Line2D`\n                for a full list of formats that are accepted.\n            linewidth (float or None): width of the line. When it's None,\n                a default value will be computed and used.\n\n        Returns:\n            output (VisImage): image object with line drawn.\n        \"\"\"", "\n", "if", "linewidth", "is", "None", ":", "\n", "            ", "linewidth", "=", "self", ".", "_default_font_size", "/", "3", "\n", "", "linewidth", "=", "max", "(", "linewidth", ",", "1", ")", "\n", "self", ".", "output", ".", "ax", ".", "add_line", "(", "\n", "mpl", ".", "lines", ".", "Line2D", "(", "\n", "x_data", ",", "\n", "y_data", ",", "\n", "linewidth", "=", "linewidth", "*", "self", ".", "output", ".", "scale", ",", "\n", "color", "=", "color", ",", "\n", "linestyle", "=", "linestyle", ",", "\n", ")", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_binary_mask": [[983, 1043], ["matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "binary_mask.astype.astype.astype", "visualizer.GenericMask", "colormap.random_color", "numpy.zeros", "visualizer.Visualizer.output.ax.imshow", "visualizer.Visualizer._change_color_brightness", "cv2.connectedComponentsWithStats", "range", "pycocotools.area", "segment.reshape.reshape.reshape", "visualizer.Visualizer.draw_polygon", "numpy.argmax", "pycocotools.frPyObjects", "visualizer.Visualizer.draw_text", "numpy.median"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.colormap.random_color", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._change_color_brightness", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_polygon", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_text"], ["", "def", "draw_binary_mask", "(", "\n", "self", ",", "binary_mask", ",", "color", "=", "None", ",", "*", ",", "edge_color", "=", "None", ",", "text", "=", "None", ",", "alpha", "=", "0.5", ",", "area_threshold", "=", "0", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            binary_mask (ndarray): numpy array of shape (H, W), where H is the image height and\n                W is the image width. Each value in the array is either a 0 or 1 value of uint8\n                type.\n            color: color of the mask. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted. If None, will pick a random color.\n            edge_color: color of the polygon edges. Refer to `matplotlib.colors` for a\n                full list of formats that are accepted.\n            text (str): if None, will be drawn in the object's center of mass.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            area_threshold (float): a connected component small than this will not be shown.\n\n        Returns:\n            output (VisImage): image object with mask drawn.\n        \"\"\"", "\n", "if", "color", "is", "None", ":", "\n", "            ", "color", "=", "random_color", "(", "rgb", "=", "True", ",", "maximum", "=", "1", ")", "\n", "", "color", "=", "mplc", ".", "to_rgb", "(", "color", ")", "\n", "\n", "has_valid_segment", "=", "False", "\n", "binary_mask", "=", "binary_mask", ".", "astype", "(", "\"uint8\"", ")", "# opencv needs uint8", "\n", "mask", "=", "GenericMask", "(", "binary_mask", ",", "self", ".", "output", ".", "height", ",", "self", ".", "output", ".", "width", ")", "\n", "shape2d", "=", "(", "binary_mask", ".", "shape", "[", "0", "]", ",", "binary_mask", ".", "shape", "[", "1", "]", ")", "\n", "\n", "if", "not", "mask", ".", "has_holes", ":", "\n", "# draw polygons for regular masks", "\n", "            ", "for", "segment", "in", "mask", ".", "polygons", ":", "\n", "                ", "area", "=", "mask_util", ".", "area", "(", "mask_util", ".", "frPyObjects", "(", "[", "segment", "]", ",", "shape2d", "[", "0", "]", ",", "shape2d", "[", "1", "]", ")", ")", "\n", "if", "area", "<", "(", "area_threshold", "or", "0", ")", ":", "\n", "                    ", "continue", "\n", "", "has_valid_segment", "=", "True", "\n", "segment", "=", "segment", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "self", ".", "draw_polygon", "(", "segment", ",", "color", "=", "color", ",", "edge_color", "=", "edge_color", ",", "alpha", "=", "alpha", ")", "\n", "", "", "else", ":", "\n", "# TODO: Use Path/PathPatch to draw vector graphics:", "\n", "# https://stackoverflow.com/questions/8919719/how-to-plot-a-complex-polygon", "\n", "            ", "rgba", "=", "np", ".", "zeros", "(", "shape2d", "+", "(", "4", ",", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "rgba", "[", ":", ",", ":", ",", ":", "3", "]", "=", "color", "\n", "rgba", "[", ":", ",", ":", ",", "3", "]", "=", "(", "mask", ".", "mask", "==", "1", ")", ".", "astype", "(", "\"float32\"", ")", "*", "alpha", "\n", "has_valid_segment", "=", "True", "\n", "self", ".", "output", ".", "ax", ".", "imshow", "(", "rgba", ",", "extent", "=", "(", "0", ",", "self", ".", "output", ".", "width", ",", "self", ".", "output", ".", "height", ",", "0", ")", ")", "\n", "\n", "", "if", "text", "is", "not", "None", "and", "has_valid_segment", ":", "\n", "# TODO sometimes drawn on wrong objects. the heuristics here can improve.", "\n", "            ", "lighter_color", "=", "self", ".", "_change_color_brightness", "(", "color", ",", "brightness_factor", "=", "0.7", ")", "\n", "_num_cc", ",", "cc_labels", ",", "stats", ",", "centroids", "=", "cv2", ".", "connectedComponentsWithStats", "(", "binary_mask", ",", "8", ")", "\n", "largest_component_id", "=", "np", ".", "argmax", "(", "stats", "[", "1", ":", ",", "-", "1", "]", ")", "+", "1", "\n", "\n", "# draw text on the largest component, as well as other very large components.", "\n", "for", "cid", "in", "range", "(", "1", ",", "_num_cc", ")", ":", "\n", "                ", "if", "cid", "==", "largest_component_id", "or", "stats", "[", "cid", ",", "-", "1", "]", ">", "_LARGE_MASK_AREA_THRESH", ":", "\n", "# median is more stable than centroid", "\n", "# center = centroids[largest_component_id]", "\n", "                    ", "center", "=", "np", ".", "median", "(", "(", "cc_labels", "==", "cid", ")", ".", "nonzero", "(", ")", ",", "axis", "=", "1", ")", "[", ":", ":", "-", "1", "]", "\n", "self", ".", "draw_text", "(", "text", ",", "center", ",", "color", "=", "lighter_color", ")", "\n", "", "", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_polygon": [[1044, 1075], ["matplotlib.patches.Polygon", "matplotlib.patches.Polygon", "matplotlib.patches.Polygon", "visualizer.Visualizer.output.ax.add_patch", "matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "visualizer.Visualizer._change_color_brightness", "max", "matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._change_color_brightness"], ["", "def", "draw_polygon", "(", "self", ",", "segment", ",", "color", ",", "edge_color", "=", "None", ",", "alpha", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            segment: numpy array of shape Nx2, containing all the points in the polygon.\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            edge_color: color of the polygon edges. Refer to `matplotlib.colors` for a\n                full list of formats that are accepted. If not provided, a darker shade\n                of the polygon color will be used instead.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n\n        Returns:\n            output (VisImage): image object with polygon drawn.\n        \"\"\"", "\n", "if", "edge_color", "is", "None", ":", "\n", "# make edge color darker than the polygon color", "\n", "            ", "if", "alpha", ">", "0.8", ":", "\n", "                ", "edge_color", "=", "self", ".", "_change_color_brightness", "(", "color", ",", "brightness_factor", "=", "-", "0.7", ")", "\n", "", "else", ":", "\n", "                ", "edge_color", "=", "color", "\n", "", "", "edge_color", "=", "mplc", ".", "to_rgb", "(", "edge_color", ")", "+", "(", "1", ",", ")", "\n", "\n", "polygon", "=", "mpl", ".", "patches", ".", "Polygon", "(", "\n", "segment", ",", "\n", "fill", "=", "True", ",", "\n", "facecolor", "=", "mplc", ".", "to_rgb", "(", "color", ")", "+", "(", "alpha", ",", ")", ",", "\n", "edgecolor", "=", "edge_color", ",", "\n", "linewidth", "=", "max", "(", "self", ".", "_default_font_size", "//", "15", "*", "self", ".", "output", ".", "scale", ",", "1", ")", ",", "\n", ")", "\n", "self", ".", "output", ".", "ax", ".", "add_patch", "(", "polygon", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._jitter": [[1080, 1098], ["matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "numpy.random.rand", "numpy.clip", "tuple", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["def", "_jitter", "(", "self", ",", "color", ")", ":", "\n", "        ", "\"\"\"\n        Randomly modifies given color to produce a slightly different color than the color given.\n\n        Args:\n            color (tuple[double]): a tuple of 3 elements, containing the RGB values of the color\n                picked. The values in the list are in the [0.0, 1.0] range.\n\n        Returns:\n            jittered_color (tuple[double]): a tuple of 3 elements, containing the RGB values of the\n                color after being jittered. The values in the list are in the [0.0, 1.0] range.\n        \"\"\"", "\n", "color", "=", "mplc", ".", "to_rgb", "(", "color", ")", "\n", "vec", "=", "np", ".", "random", ".", "rand", "(", "3", ")", "\n", "# better to do it in another color space", "\n", "vec", "=", "vec", "/", "np", ".", "linalg", ".", "norm", "(", "vec", ")", "*", "0.5", "\n", "res", "=", "np", ".", "clip", "(", "vec", "+", "color", ",", "0", ",", "1", ")", "\n", "return", "tuple", "(", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._create_grayscale_image": [[1099, 1109], ["visualizer.Visualizer.img.astype().mean", "numpy.stack", "visualizer.Visualizer.img.astype"], "methods", ["None"], ["", "def", "_create_grayscale_image", "(", "self", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Create a grayscale version of the original image.\n        The colors in masked area, if given, will be kept.\n        \"\"\"", "\n", "img_bw", "=", "self", ".", "img", ".", "astype", "(", "\"f4\"", ")", ".", "mean", "(", "axis", "=", "2", ")", "\n", "img_bw", "=", "np", ".", "stack", "(", "[", "img_bw", "]", "*", "3", ",", "axis", "=", "2", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "img_bw", "[", "mask", "]", "=", "self", ".", "img", "[", "mask", "]", "\n", "", "return", "img_bw", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._change_color_brightness": [[1110, 1134], ["matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "colorsys.rgb_to_hls", "colorsys.hls_to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb", "matplotlib.to_rgb"], "methods", ["None"], ["", "def", "_change_color_brightness", "(", "self", ",", "color", ",", "brightness_factor", ")", ":", "\n", "        ", "\"\"\"\n        Depending on the brightness_factor, gives a lighter or darker color i.e. a color with\n        less or more saturation than the original color.\n\n        Args:\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            brightness_factor (float): a value in [-1.0, 1.0] range. A lightness factor of\n                0 will correspond to no change, a factor in [-1.0, 0) range will result in\n                a darker color and a factor in (0, 1.0] range will result in a lighter color.\n\n        Returns:\n            modified_color (tuple[double]): a tuple containing the RGB values of the\n                modified color. Each value in the tuple is in the [0.0, 1.0] range.\n        \"\"\"", "\n", "assert", "brightness_factor", ">=", "-", "1.0", "and", "brightness_factor", "<=", "1.0", "\n", "color", "=", "mplc", ".", "to_rgb", "(", "color", ")", "\n", "polygon_color", "=", "colorsys", ".", "rgb_to_hls", "(", "*", "mplc", ".", "to_rgb", "(", "color", ")", ")", "\n", "modified_lightness", "=", "polygon_color", "[", "1", "]", "+", "(", "brightness_factor", "*", "polygon_color", "[", "1", "]", ")", "\n", "modified_lightness", "=", "0.0", "if", "modified_lightness", "<", "0.0", "else", "modified_lightness", "\n", "modified_lightness", "=", "1.0", "if", "modified_lightness", ">", "1.0", "else", "modified_lightness", "\n", "modified_color", "=", "colorsys", ".", "hls_to_rgb", "(", "polygon_color", "[", "0", "]", ",", "modified_lightness", ",", "polygon_color", "[", "2", "]", ")", "\n", "return", "modified_color", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._convert_boxes": [[1135, 1143], ["isinstance", "isinstance", "boxes.tensor.numpy", "numpy.asarray"], "methods", ["None"], ["", "def", "_convert_boxes", "(", "self", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"\n        Convert different format of boxes to an NxB array, where B = 4 or 5 is the box dimension.\n        \"\"\"", "\n", "if", "isinstance", "(", "boxes", ",", "Boxes", ")", "or", "isinstance", "(", "boxes", ",", "RotatedBoxes", ")", ":", "\n", "            ", "return", "boxes", ".", "tensor", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "asarray", "(", "boxes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._convert_masks": [[1144, 1166], ["isinstance", "isinstance", "isinstance", "m.numpy.numpy.tensor.numpy", "m.numpy.numpy.numpy", "isinstance", "ret.append", "ret.append", "visualizer.GenericMask"], "methods", ["None"], ["", "", "def", "_convert_masks", "(", "self", ",", "masks_or_polygons", ")", ":", "\n", "        ", "\"\"\"\n        Convert different format of masks or polygons to a tuple of masks and polygons.\n\n        Returns:\n            list[GenericMask]:\n        \"\"\"", "\n", "\n", "m", "=", "masks_or_polygons", "\n", "if", "isinstance", "(", "m", ",", "PolygonMasks", ")", ":", "\n", "            ", "m", "=", "m", ".", "polygons", "\n", "", "if", "isinstance", "(", "m", ",", "BitMasks", ")", ":", "\n", "            ", "m", "=", "m", ".", "tensor", ".", "numpy", "(", ")", "\n", "", "if", "isinstance", "(", "m", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "m", "=", "m", ".", "numpy", "(", ")", "\n", "", "ret", "=", "[", "]", "\n", "for", "x", "in", "m", ":", "\n", "            ", "if", "isinstance", "(", "x", ",", "GenericMask", ")", ":", "\n", "                ", "ret", ".", "append", "(", "x", ")", "\n", "", "else", ":", "\n", "                ", "ret", ".", "append", "(", "GenericMask", "(", "x", ",", "self", ".", "output", ".", "height", ",", "self", ".", "output", ".", "width", ")", ")", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._convert_keypoints": [[1167, 1172], ["isinstance", "numpy.asarray"], "methods", ["None"], ["", "def", "_convert_keypoints", "(", "self", ",", "keypoints", ")", ":", "\n", "        ", "if", "isinstance", "(", "keypoints", ",", "Keypoints", ")", ":", "\n", "            ", "keypoints", "=", "keypoints", ".", "tensor", "\n", "", "keypoints", "=", "np", ".", "asarray", "(", "keypoints", ")", "\n", "return", "keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.get_output": [[1173, 1180], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            output (VisImage): the image output containing the visualizations added\n            to the image.\n        \"\"\"", "\n", "return", "self", ".", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._create_text_labels": [[220, 239], ["len", "zip"], "function", ["None"], ["", "", "", "", "def", "_create_text_labels", "(", "classes", ",", "scores", ",", "class_names", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        classes (list[int] or None):\n        scores (list[float] or None):\n        class_names (list[str] or None):\n\n    Returns:\n        list[str] or None\n    \"\"\"", "\n", "labels", "=", "None", "\n", "if", "classes", "is", "not", "None", "and", "class_names", "is", "not", "None", "and", "len", "(", "class_names", ")", ">", "0", ":", "\n", "        ", "labels", "=", "[", "class_names", "[", "i", "]", "for", "i", "in", "classes", "]", "\n", "", "if", "scores", "is", "not", "None", ":", "\n", "        ", "if", "labels", "is", "None", ":", "\n", "            ", "labels", "=", "[", "\"{:.0f}%\"", ".", "format", "(", "s", "*", "100", ")", "for", "s", "in", "scores", "]", "\n", "", "else", ":", "\n", "            ", "labels", "=", "[", "\"{} {:.0f}%\"", ".", "format", "(", "l", ",", "s", "*", "100", ")", "for", "l", ",", "s", "in", "zip", "(", "labels", ",", "scores", ")", "]", "\n", "", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer._DetectedInstance.__init__": [[31, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "label", ",", "bbox", ",", "mask_rle", ",", "color", ",", "ttl", ")", ":", "\n", "        ", "self", ".", "label", "=", "label", "\n", "self", ".", "bbox", "=", "bbox", "\n", "self", ".", "mask_rle", "=", "mask_rle", "\n", "self", ".", "color", "=", "color", "\n", "self", ".", "ttl", "=", "ttl", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.__init__": [[40, 52], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "metadata", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            metadata (MetadataCatalog): image metadata.\n        \"\"\"", "\n", "self", ".", "metadata", "=", "metadata", "\n", "self", ".", "_old_instances", "=", "[", "]", "\n", "assert", "instance_mode", "in", "[", "\n", "ColorMode", ".", "IMAGE", ",", "\n", "ColorMode", ".", "IMAGE_BW", ",", "\n", "]", ",", "\"Other mode not supported yet.\"", "\n", "self", ".", "_instance_mode", "=", "instance_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_instance_predictions": [[53, 111], ["detectron2.utils.visualizer.Visualizer", "len", "predictions.has", "video_visualizer.VideoVisualizer._assign_colors", "detectron2.utils.visualizer._create_text_labels", "detectron2.utils.visualizer.Visualizer.overlay_instances", "predictions.has", "predictions.pred_boxes.tensor.numpy", "predictions.has", "predictions.has", "predictions.pred_classes.numpy", "predictions.has", "video_visualizer._DetectedInstance", "video_visualizer.VideoVisualizer.metadata.get", "detectron2.utils.visualizer.Visualizer._create_grayscale_image", "range", "masks.any"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer._assign_colors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._create_text_labels", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._create_grayscale_image"], ["", "def", "draw_instance_predictions", "(", "self", ",", "frame", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Draw instance-level prediction results on an image.\n\n        Args:\n            frame (ndarray): an RGB image of shape (H, W, C), in the range [0, 255].\n            predictions (Instances): the output of an instance detection/segmentation\n                model. Following fields will be used to draw:\n                \"pred_boxes\", \"pred_classes\", \"scores\", \"pred_masks\" (or \"pred_masks_rle\").\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "frame_visualizer", "=", "Visualizer", "(", "frame", ",", "self", ".", "metadata", ")", "\n", "num_instances", "=", "len", "(", "predictions", ")", "\n", "if", "num_instances", "==", "0", ":", "\n", "            ", "return", "frame_visualizer", ".", "output", "\n", "\n", "", "boxes", "=", "predictions", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "if", "predictions", ".", "has", "(", "\"pred_boxes\"", ")", "else", "None", "\n", "scores", "=", "predictions", ".", "scores", "if", "predictions", ".", "has", "(", "\"scores\"", ")", "else", "None", "\n", "classes", "=", "predictions", ".", "pred_classes", ".", "numpy", "(", ")", "if", "predictions", ".", "has", "(", "\"pred_classes\"", ")", "else", "None", "\n", "keypoints", "=", "predictions", ".", "pred_keypoints", "if", "predictions", ".", "has", "(", "\"pred_keypoints\"", ")", "else", "None", "\n", "\n", "if", "predictions", ".", "has", "(", "\"pred_masks\"", ")", ":", "\n", "            ", "masks", "=", "predictions", ".", "pred_masks", "\n", "# mask IOU is not yet enabled", "\n", "# masks_rles = mask_util.encode(np.asarray(masks.permute(1, 2, 0), order=\"F\"))", "\n", "# assert len(masks_rles) == num_instances", "\n", "", "else", ":", "\n", "            ", "masks", "=", "None", "\n", "\n", "", "detected", "=", "[", "\n", "_DetectedInstance", "(", "classes", "[", "i", "]", ",", "boxes", "[", "i", "]", ",", "mask_rle", "=", "None", ",", "color", "=", "None", ",", "ttl", "=", "8", ")", "\n", "for", "i", "in", "range", "(", "num_instances", ")", "\n", "]", "\n", "colors", "=", "self", ".", "_assign_colors", "(", "detected", ")", "\n", "\n", "labels", "=", "_create_text_labels", "(", "classes", ",", "scores", ",", "self", ".", "metadata", ".", "get", "(", "\"thing_classes\"", ",", "None", ")", ")", "\n", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "# any() returns uint8 tensor", "\n", "            ", "frame_visualizer", ".", "output", ".", "img", "=", "frame_visualizer", ".", "_create_grayscale_image", "(", "\n", "(", "masks", ".", "any", "(", "dim", "=", "0", ")", ">", "0", ")", ".", "numpy", "(", ")", "if", "masks", "is", "not", "None", "else", "None", "\n", ")", "\n", "alpha", "=", "0.3", "\n", "", "else", ":", "\n", "            ", "alpha", "=", "0.5", "\n", "\n", "", "frame_visualizer", ".", "overlay_instances", "(", "\n", "boxes", "=", "None", "if", "masks", "is", "not", "None", "else", "boxes", ",", "# boxes are a bit distracting", "\n", "masks", "=", "masks", ",", "\n", "labels", "=", "labels", ",", "\n", "keypoints", "=", "keypoints", ",", "\n", "assigned_colors", "=", "colors", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n", "\n", "return", "frame_visualizer", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_sem_seg": [[112, 123], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_sem_seg"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_sem_seg"], ["", "def", "draw_sem_seg", "(", "self", ",", "frame", ",", "sem_seg", ",", "area_threshold", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            sem_seg (ndarray or Tensor): semantic segmentation of shape (H, W),\n                each value is the integer label.\n            area_threshold (Optional[int]): only draw segmentations larger than the threshold\n        \"\"\"", "\n", "# don't need to do anything special", "\n", "frame_visualizer", "=", "Visualizer", "(", "frame", ",", "self", ".", "metadata", ")", "\n", "frame_visualizer", ".", "draw_sem_seg", "(", "sem_seg", ",", "area_threshold", "=", "None", ")", "\n", "return", "frame_visualizer", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions": [[124, 179], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer._PanopticPrediction", "detectron2.utils.visualizer._PanopticPrediction.semantic_masks", "list", "list", "len", "pycocotools.encode", "video_visualizer.VideoVisualizer._assign_colors", "detectron2.utils.visualizer.Visualizer.overlay_instances", "detectron2.utils.visualizer.Visualizer._create_grayscale_image", "detectron2.utils.visualizer.Visualizer.draw_binary_mask", "detectron2.utils.visualizer._PanopticPrediction.instance_masks", "len", "zip", "numpy.asarray", "len", "video_visualizer._DetectedInstance", "detectron2.utils.visualizer._PanopticPrediction.non_empty_mask", "numpy.asarray().transpose", "range", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.semantic_masks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer._assign_colors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer._create_grayscale_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_binary_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.instance_masks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer._PanopticPrediction.non_empty_mask"], ["", "def", "draw_panoptic_seg_predictions", "(", "\n", "self", ",", "frame", ",", "panoptic_seg", ",", "segments_info", ",", "area_threshold", "=", "None", ",", "alpha", "=", "0.5", "\n", ")", ":", "\n", "        ", "frame_visualizer", "=", "Visualizer", "(", "frame", ",", "self", ".", "metadata", ")", "\n", "pred", "=", "_PanopticPrediction", "(", "panoptic_seg", ",", "segments_info", ",", "self", ".", "metadata", ")", "\n", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "            ", "frame_visualizer", ".", "output", ".", "img", "=", "frame_visualizer", ".", "_create_grayscale_image", "(", "\n", "pred", ".", "non_empty_mask", "(", ")", "\n", ")", "\n", "\n", "# draw mask for all semantic segments first i.e. \"stuff\"", "\n", "", "for", "mask", ",", "sinfo", "in", "pred", ".", "semantic_masks", "(", ")", ":", "\n", "            ", "category_idx", "=", "sinfo", "[", "\"category_id\"", "]", "\n", "try", ":", "\n", "                ", "mask_color", "=", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "stuff_colors", "[", "category_idx", "]", "]", "\n", "", "except", "AttributeError", ":", "\n", "                ", "mask_color", "=", "None", "\n", "\n", "", "frame_visualizer", ".", "draw_binary_mask", "(", "\n", "mask", ",", "\n", "color", "=", "mask_color", ",", "\n", "text", "=", "self", ".", "metadata", ".", "stuff_classes", "[", "category_idx", "]", ",", "\n", "alpha", "=", "alpha", ",", "\n", "area_threshold", "=", "area_threshold", ",", "\n", ")", "\n", "\n", "", "all_instances", "=", "list", "(", "pred", ".", "instance_masks", "(", ")", ")", "\n", "if", "len", "(", "all_instances", ")", "==", "0", ":", "\n", "            ", "return", "frame_visualizer", ".", "output", "\n", "# draw mask for all instances second", "\n", "", "masks", ",", "sinfo", "=", "list", "(", "zip", "(", "*", "all_instances", ")", ")", "\n", "num_instances", "=", "len", "(", "masks", ")", "\n", "masks_rles", "=", "mask_util", ".", "encode", "(", "\n", "np", ".", "asarray", "(", "np", ".", "asarray", "(", "masks", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "order", "=", "\"F\"", ")", "\n", ")", "\n", "assert", "len", "(", "masks_rles", ")", "==", "num_instances", "\n", "\n", "category_ids", "=", "[", "x", "[", "\"category_id\"", "]", "for", "x", "in", "sinfo", "]", "\n", "detected", "=", "[", "\n", "_DetectedInstance", "(", "category_ids", "[", "i", "]", ",", "bbox", "=", "None", ",", "mask_rle", "=", "masks_rles", "[", "i", "]", ",", "color", "=", "None", ",", "ttl", "=", "8", ")", "\n", "for", "i", "in", "range", "(", "num_instances", ")", "\n", "]", "\n", "colors", "=", "self", ".", "_assign_colors", "(", "detected", ")", "\n", "labels", "=", "[", "self", ".", "metadata", ".", "thing_classes", "[", "k", "]", "for", "k", "in", "category_ids", "]", "\n", "\n", "frame_visualizer", ".", "overlay_instances", "(", "\n", "boxes", "=", "None", ",", "\n", "masks", "=", "masks", ",", "\n", "labels", "=", "labels", ",", "\n", "keypoints", "=", "None", ",", "\n", "assigned_colors", "=", "colors", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n", "return", "frame_visualizer", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer._assign_colors": [[180, 236], ["numpy.zeros", "enumerate", "numpy.asarray().argmax", "numpy.asarray().max", "enumerate", "pycocotools.iou", "pycocotools.iou", "len", "numpy.zeros", "enumerate", "len", "numpy.asarray", "numpy.asarray", "extra_instances.append", "colormap.random_color", "len", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.colormap.random_color"], ["", "def", "_assign_colors", "(", "self", ",", "instances", ")", ":", "\n", "        ", "\"\"\"\n        Naive tracking heuristics to assign same color to the same instance,\n        will update the internal state of tracked instances.\n\n        Returns:\n            list[tuple[float]]: list of colors.\n        \"\"\"", "\n", "\n", "# Compute iou with either boxes or masks:", "\n", "is_crowd", "=", "np", ".", "zeros", "(", "(", "len", "(", "instances", ")", ",", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "if", "instances", "[", "0", "]", ".", "bbox", "is", "None", ":", "\n", "            ", "assert", "instances", "[", "0", "]", ".", "mask_rle", "is", "not", "None", "\n", "# use mask iou only when box iou is None", "\n", "# because box seems good enough", "\n", "rles_old", "=", "[", "x", ".", "mask_rle", "for", "x", "in", "self", ".", "_old_instances", "]", "\n", "rles_new", "=", "[", "x", ".", "mask_rle", "for", "x", "in", "instances", "]", "\n", "ious", "=", "mask_util", ".", "iou", "(", "rles_old", ",", "rles_new", ",", "is_crowd", ")", "\n", "threshold", "=", "0.5", "\n", "", "else", ":", "\n", "            ", "boxes_old", "=", "[", "x", ".", "bbox", "for", "x", "in", "self", ".", "_old_instances", "]", "\n", "boxes_new", "=", "[", "x", ".", "bbox", "for", "x", "in", "instances", "]", "\n", "ious", "=", "mask_util", ".", "iou", "(", "boxes_old", ",", "boxes_new", ",", "is_crowd", ")", "\n", "threshold", "=", "0.6", "\n", "", "if", "len", "(", "ious", ")", "==", "0", ":", "\n", "            ", "ious", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "_old_instances", ")", ",", "len", "(", "instances", ")", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "\n", "# Only allow matching instances of the same label:", "\n", "", "for", "old_idx", ",", "old", "in", "enumerate", "(", "self", ".", "_old_instances", ")", ":", "\n", "            ", "for", "new_idx", ",", "new", "in", "enumerate", "(", "instances", ")", ":", "\n", "                ", "if", "old", ".", "label", "!=", "new", ".", "label", ":", "\n", "                    ", "ious", "[", "old_idx", ",", "new_idx", "]", "=", "0", "\n", "\n", "", "", "", "matched_new_per_old", "=", "np", ".", "asarray", "(", "ious", ")", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "max_iou_per_old", "=", "np", ".", "asarray", "(", "ious", ")", ".", "max", "(", "axis", "=", "1", ")", "\n", "\n", "# Try to find match for each old instance:", "\n", "extra_instances", "=", "[", "]", "\n", "for", "idx", ",", "inst", "in", "enumerate", "(", "self", ".", "_old_instances", ")", ":", "\n", "            ", "if", "max_iou_per_old", "[", "idx", "]", ">", "threshold", ":", "\n", "                ", "newidx", "=", "matched_new_per_old", "[", "idx", "]", "\n", "if", "instances", "[", "newidx", "]", ".", "color", "is", "None", ":", "\n", "                    ", "instances", "[", "newidx", "]", ".", "color", "=", "inst", ".", "color", "\n", "continue", "\n", "# If an old instance does not match any new instances,", "\n", "# keep it for the next frame in case it is just missed by the detector", "\n", "", "", "inst", ".", "ttl", "-=", "1", "\n", "if", "inst", ".", "ttl", ">", "0", ":", "\n", "                ", "extra_instances", ".", "append", "(", "inst", ")", "\n", "\n", "# Assign random color to newly-detected instances:", "\n", "", "", "for", "inst", "in", "instances", ":", "\n", "            ", "if", "inst", ".", "color", "is", "None", ":", "\n", "                ", "inst", ".", "color", "=", "random_color", "(", "rgb", "=", "True", ",", "maximum", "=", "1", ")", "\n", "", "", "self", ".", "_old_instances", "=", "instances", "[", ":", "]", "+", "extra_instances", "\n", "return", "[", "d", ".", "color", "for", "d", "in", "instances", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis.flop_count_operators": [[55, 76], ["analysis._wrapper_count_operators"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis._wrapper_count_operators"], ["def", "flop_count_operators", "(", "\n", "model", ":", "nn", ".", "Module", ",", "inputs", ":", "list", ",", "**", "kwargs", "\n", ")", "->", "typing", ".", "DefaultDict", "[", "str", ",", "float", "]", ":", "\n", "    ", "\"\"\"\n    Implement operator-level flops counting using jit.\n    This is a wrapper of fvcore.nn.flop_count, that supports standard detection models\n    in detectron2.\n\n    Note:\n        The function runs the input through the model to compute flops.\n        The flops of a detection model is often input-dependent, for example,\n        the flops of box & mask head depends on the number of proposals &\n        the number of detected objects.\n        Therefore, the flops counting using a single input may not accurately\n        reflect the computation cost of a model.\n\n    Args:\n        model: a detectron2 model that takes `list[dict]` as input.\n        inputs (list[dict]): inputs to model, in detectron2's standard format.\n    \"\"\"", "\n", "return", "_wrapper_count_operators", "(", "model", "=", "model", ",", "inputs", "=", "inputs", ",", "mode", "=", "FLOPS_MODE", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis.activation_count_operators": [[78, 97], ["analysis._wrapper_count_operators"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis._wrapper_count_operators"], ["", "def", "activation_count_operators", "(", "\n", "model", ":", "nn", ".", "Module", ",", "inputs", ":", "list", ",", "**", "kwargs", "\n", ")", "->", "typing", ".", "DefaultDict", "[", "str", ",", "float", "]", ":", "\n", "    ", "\"\"\"\n    Implement operator-level activations counting using jit.\n    This is a wrapper of fvcore.nn.activation_count, that supports standard detection models\n    in detectron2.\n\n    Note:\n        The function runs the input through the model to compute activations.\n        The activations of a detection model is often input-dependent, for example,\n        the activations of box & mask head depends on the number of proposals &\n        the number of detected objects.\n\n    Args:\n        model: a detectron2 model that takes `list[dict]` as input.\n        inputs (list[dict]): inputs to model, in detectron2's standard format.\n    \"\"\"", "\n", "return", "_wrapper_count_operators", "(", "model", "=", "model", ",", "inputs", "=", "inputs", ",", "mode", "=", "ACTIVATIONS_MODE", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis._flatten_to_tuple": [[99, 120], ["isinstance", "tuple", "result.append", "isinstance", "isinstance", "result.extend", "outputs.items", "isinstance", "analysis._flatten_to_tuple", "result.extend", "result.extend", "isinstance", "analysis._flatten_to_tuple", "analysis._flatten_to_tuple", "result.append", "logger.log_first_n", "outputs.get_fields", "type"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis._flatten_to_tuple", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis._flatten_to_tuple", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis._flatten_to_tuple", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.log_first_n", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.get_fields"], ["", "def", "_flatten_to_tuple", "(", "outputs", ")", ":", "\n", "    ", "result", "=", "[", "]", "\n", "if", "isinstance", "(", "outputs", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "result", ".", "append", "(", "outputs", ")", "\n", "", "elif", "isinstance", "(", "outputs", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "for", "v", "in", "outputs", ":", "\n", "            ", "result", ".", "extend", "(", "_flatten_to_tuple", "(", "v", ")", ")", "\n", "", "", "elif", "isinstance", "(", "outputs", ",", "dict", ")", ":", "\n", "        ", "for", "_", ",", "v", "in", "outputs", ".", "items", "(", ")", ":", "\n", "            ", "result", ".", "extend", "(", "_flatten_to_tuple", "(", "v", ")", ")", "\n", "", "", "elif", "isinstance", "(", "outputs", ",", "Instances", ")", ":", "\n", "        ", "result", ".", "extend", "(", "_flatten_to_tuple", "(", "outputs", ".", "get_fields", "(", ")", ")", ")", "\n", "", "elif", "isinstance", "(", "outputs", ",", "(", "Boxes", ",", "BitMasks", ",", "ImageList", ")", ")", ":", "\n", "        ", "result", ".", "append", "(", "outputs", ".", "tensor", ")", "\n", "", "else", ":", "\n", "        ", "log_first_n", "(", "\n", "logging", ".", "WARN", ",", "\n", "f\"Output of type {type(outputs)} not included in flops/activations count.\"", ",", "\n", "n", "=", "10", ",", "\n", ")", "\n", "", "return", "tuple", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis._wrapper_count_operators": [[122, 165], ["supported_ops.update", "isinstance", "model.train", "kwargs.pop", "len", "torch.no_grad", "super().__init__", "isinstance", "analysis..model.forward", "analysis._flatten_to_tuple", "fvcore.nn.flop_count", "WrapModel().train", "fvcore.nn.activation_count", "NotImplementedError", "WrapModel().train", "WrapModel", "WrapModel"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis._flatten_to_tuple", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train"], ["", "def", "_wrapper_count_operators", "(", "\n", "model", ":", "nn", ".", "Module", ",", "inputs", ":", "list", ",", "mode", ":", "str", ",", "**", "kwargs", "\n", ")", "->", "typing", ".", "DefaultDict", "[", "str", ",", "float", "]", ":", "\n", "\n", "# ignore some ops", "\n", "    ", "supported_ops", "=", "{", "k", ":", "lambda", "*", "args", ",", "**", "kwargs", ":", "{", "}", "for", "k", "in", "_IGNORED_OPS", "}", "\n", "supported_ops", ".", "update", "(", "kwargs", ".", "pop", "(", "\"supported_ops\"", ",", "{", "}", ")", ")", "\n", "kwargs", "[", "\"supported_ops\"", "]", "=", "supported_ops", "\n", "\n", "assert", "len", "(", "inputs", ")", "==", "1", ",", "\"Please use batch size=1\"", "\n", "tensor_input", "=", "inputs", "[", "0", "]", "[", "\"image\"", "]", "\n", "\n", "class", "WrapModel", "(", "nn", ".", "Module", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "model", ")", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "\n", "model", ",", "(", "nn", ".", "parallel", ".", "distributed", ".", "DistributedDataParallel", ",", "nn", ".", "DataParallel", ")", "\n", ")", ":", "\n", "                ", "self", ".", "model", "=", "model", ".", "module", "\n", "", "else", ":", "\n", "                ", "self", ".", "model", "=", "model", "\n", "\n", "", "", "def", "forward", "(", "self", ",", "image", ")", ":", "\n", "# jit requires the input/output to be Tensors", "\n", "            ", "inputs", "=", "[", "{", "\"image\"", ":", "image", "}", "]", "\n", "outputs", "=", "self", ".", "model", ".", "forward", "(", "inputs", ")", "\n", "# Only the subgraph that computes the returned tuple of tensor will be", "\n", "# counted. So we flatten everything we found to tuple of tensors.", "\n", "return", "_flatten_to_tuple", "(", "outputs", ")", "\n", "\n", "", "", "old_train", "=", "model", ".", "training", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "if", "mode", "==", "FLOPS_MODE", ":", "\n", "            ", "ret", "=", "flop_count", "(", "WrapModel", "(", "model", ")", ".", "train", "(", "False", ")", ",", "(", "tensor_input", ",", ")", ",", "**", "kwargs", ")", "\n", "", "elif", "mode", "==", "ACTIVATIONS_MODE", ":", "\n", "            ", "ret", "=", "activation_count", "(", "WrapModel", "(", "model", ")", ".", "train", "(", "False", ")", ",", "(", "tensor_input", ",", ")", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Count for mode {} is not supported yet.\"", ".", "format", "(", "mode", ")", ")", "\n", "# compatible with change in fvcore", "\n", "", "", "if", "isinstance", "(", "ret", ",", "tuple", ")", ":", "\n", "        ", "ret", "=", "ret", "[", "0", "]", "\n", "", "model", ".", "train", "(", "old_train", ")", "\n", "return", "ret", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store_non_list.Store.__init__": [[6, 11], ["collections.deque", "range"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "total_num_classes", ",", "items_per_class", ",", "shuffle", "=", "False", ")", ":", "\n", "        ", "self", ".", "shuffle", "=", "shuffle", "\n", "self", ".", "items_per_class", "=", "items_per_class", "\n", "self", ".", "total_num_classes", "=", "total_num_classes", "\n", "self", ".", "store", "=", "[", "deque", "(", "maxlen", "=", "self", ".", "items_per_class", ")", "for", "_", "in", "range", "(", "self", ".", "total_num_classes", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store_non_list.Store.add": [[12, 15], ["enumerate", "store_non_list.Store.store[].append"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "items", ",", "class_ids", ")", ":", "\n", "        ", "for", "idx", ",", "class_id", "in", "enumerate", "(", "class_ids", ")", ":", "\n", "            ", "self", ".", "store", "[", "class_id", "]", ".", "append", "(", "items", "[", "idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store_non_list.Store.retrieve": [[16, 32], ["range", "items.extend", "random.shuffle", "all_items.append", "items.append"], "methods", ["None"], ["", "", "def", "retrieve", "(", "self", ",", "class_id", ")", ":", "\n", "        ", "if", "class_id", "!=", "-", "1", ":", "\n", "            ", "items", "=", "[", "]", "\n", "for", "item", "in", "self", ".", "store", "[", "class_id", "]", ":", "\n", "                ", "items", ".", "extend", "(", "item", ")", "\n", "", "if", "self", ".", "shuffle", ":", "\n", "                ", "random", ".", "shuffle", "(", "items", ")", "\n", "", "return", "items", "\n", "", "else", ":", "\n", "            ", "all_items", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "total_num_classes", ")", ":", "\n", "                ", "items", "=", "[", "]", "\n", "for", "item", "in", "self", ".", "store", "[", "i", "]", ":", "\n", "                    ", "items", ".", "append", "(", "item", ")", "\n", "", "all_items", ".", "append", "(", "items", ")", "\n", "", "return", "all_items", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store_non_list.Store.reset": [[33, 35], ["collections.deque", "range"], "methods", ["None"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "store", "=", "[", "deque", "(", "maxlen", "=", "self", ".", "items_per_class", ")", "for", "_", "in", "range", "(", "self", ".", "total_num_classes", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store_non_list.Store.__str__": [[36, 42], ["enumerate", "str", "len", "str", "list"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "'('", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "self", ".", "store", ")", ":", "\n", "            ", "s", "+=", "'\\n Class '", "+", "str", "(", "idx", ")", "+", "' --> '", "+", "str", "(", "len", "(", "list", "(", "item", ")", ")", ")", "+", "' items'", "\n", "", "s", "=", "s", "+", "' )'", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store_non_list.Store.__repr__": [[43, 45], ["store_non_list.Store.__str__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.CompoundVisualizer.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store_non_list.Store.__len__": [[46, 48], ["sum", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "sum", "(", "[", "len", "(", "s", ")", "for", "s", "in", "self", ".", "store", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger._ColorfulFormatter.__init__": [[14, 20], ["kwargs.pop", "len", "logging.Formatter.__init__", "kwargs.pop"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "_root_name", "=", "kwargs", ".", "pop", "(", "\"root_name\"", ")", "+", "\".\"", "\n", "self", ".", "_abbrev_name", "=", "kwargs", ".", "pop", "(", "\"abbrev_name\"", ",", "\"\"", ")", "\n", "if", "len", "(", "self", ".", "_abbrev_name", ")", ":", "\n", "            ", "self", ".", "_abbrev_name", "=", "self", ".", "_abbrev_name", "+", "\".\"", "\n", "", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger._ColorfulFormatter.formatMessage": [[21, 31], ["record.name.replace", "super().formatMessage", "termcolor.colored", "termcolor.colored"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger._ColorfulFormatter.formatMessage"], ["", "def", "formatMessage", "(", "self", ",", "record", ")", ":", "\n", "        ", "record", ".", "name", "=", "record", ".", "name", ".", "replace", "(", "self", ".", "_root_name", ",", "self", ".", "_abbrev_name", ")", "\n", "log", "=", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "formatMessage", "(", "record", ")", "\n", "if", "record", ".", "levelno", "==", "logging", ".", "WARNING", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"WARNING\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", "]", ")", "\n", "", "elif", "record", ".", "levelno", "==", "logging", ".", "ERROR", "or", "record", ".", "levelno", "==", "logging", ".", "CRITICAL", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"ERROR\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", ",", "\"underline\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "log", "\n", "", "return", "prefix", "+", "\" \"", "+", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger": [[33, 95], ["functools.lru_cache", "logging.getLogger", "logging.getLogger.setLevel", "logging.Formatter", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "fvcore.common.file_io.PathManager.mkdirs", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logger._ColorfulFormatter", "output.endswith", "output.endswith", "os.path.join", "os.path.dirname", "logger._cached_log_stream", "termcolor.colored", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger._cached_log_stream"], ["", "", "@", "functools", ".", "lru_cache", "(", ")", "# so that calling setup_logger multiple times won't add many handlers", "\n", "def", "setup_logger", "(", "\n", "output", "=", "None", ",", "distributed_rank", "=", "0", ",", "*", ",", "color", "=", "True", ",", "name", "=", "\"detectron2\"", ",", "abbrev_name", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Initialize the detectron2 logger and set its verbosity level to \"DEBUG\".\n\n    Args:\n        output (str): a file name or a directory to save log. If None, will not save log file.\n            If ends with \".txt\" or \".log\", assumed to be a file name.\n            Otherwise, logs will be saved to `output/log.txt`.\n        name (str): the root module name of this logger\n        abbrev_name (str): an abbreviation of the module, to avoid long names in logs.\n            Set to \"\" to not log the root module in logs.\n            By default, will abbreviate \"detectron2\" to \"d2\" and leave other\n            modules unchanged.\n\n    Returns:\n        logging.Logger: a logger\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "name", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "logger", ".", "propagate", "=", "False", "\n", "\n", "if", "abbrev_name", "is", "None", ":", "\n", "        ", "abbrev_name", "=", "\"d2\"", "if", "name", "==", "\"detectron2\"", "else", "name", "\n", "\n", "", "plain_formatter", "=", "logging", ".", "Formatter", "(", "\n", "\"[%(asctime)s] %(name)s %(levelname)s: %(message)s\"", ",", "datefmt", "=", "\"%m/%d %H:%M:%S\"", "\n", ")", "\n", "# stdout logging: master only", "\n", "if", "distributed_rank", "==", "0", ":", "\n", "        ", "ch", "=", "logging", ".", "StreamHandler", "(", "stream", "=", "sys", ".", "stdout", ")", "\n", "ch", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "if", "color", ":", "\n", "            ", "formatter", "=", "_ColorfulFormatter", "(", "\n", "colored", "(", "\"[%(asctime)s %(name)s]: \"", ",", "\"green\"", ")", "+", "\"%(message)s\"", ",", "\n", "datefmt", "=", "\"%m/%d %H:%M:%S\"", ",", "\n", "root_name", "=", "name", ",", "\n", "abbrev_name", "=", "str", "(", "abbrev_name", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "formatter", "=", "plain_formatter", "\n", "", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "logger", ".", "addHandler", "(", "ch", ")", "\n", "\n", "# file logging: all workers", "\n", "", "if", "output", "is", "not", "None", ":", "\n", "        ", "if", "output", ".", "endswith", "(", "\".txt\"", ")", "or", "output", ".", "endswith", "(", "\".log\"", ")", ":", "\n", "            ", "filename", "=", "output", "\n", "", "else", ":", "\n", "            ", "filename", "=", "os", ".", "path", ".", "join", "(", "output", ",", "\"log.txt\"", ")", "\n", "", "if", "distributed_rank", ">", "0", ":", "\n", "            ", "filename", "=", "filename", "+", "\".rank{}\"", ".", "format", "(", "distributed_rank", ")", "\n", "", "PathManager", ".", "mkdirs", "(", "os", ".", "path", ".", "dirname", "(", "filename", ")", ")", "\n", "\n", "fh", "=", "logging", ".", "StreamHandler", "(", "_cached_log_stream", "(", "filename", ")", ")", "\n", "fh", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "fh", ".", "setFormatter", "(", "plain_formatter", ")", "\n", "logger", ".", "addHandler", "(", "fh", ")", "\n", "\n", "", "return", "logger", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger._cached_log_stream": [[99, 102], ["functools.lru_cache", "fvcore.common.file_io.PathManager.open"], "function", ["None"], ["", "@", "functools", ".", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "_cached_log_stream", "(", "filename", ")", ":", "\n", "    ", "return", "PathManager", ".", "open", "(", "filename", ",", "\"a\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger._find_caller": [[111, 126], ["sys._getframe", "os.path.join"], "function", ["None"], ["def", "_find_caller", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        str: module name of the caller\n        tuple: a hashable key to be used to identify different callers\n    \"\"\"", "\n", "frame", "=", "sys", ".", "_getframe", "(", "2", ")", "\n", "while", "frame", ":", "\n", "        ", "code", "=", "frame", ".", "f_code", "\n", "if", "os", ".", "path", ".", "join", "(", "\"utils\"", ",", "\"logger.\"", ")", "not", "in", "code", ".", "co_filename", ":", "\n", "            ", "mod_name", "=", "frame", ".", "f_globals", "[", "\"__name__\"", "]", "\n", "if", "mod_name", "==", "\"__main__\"", ":", "\n", "                ", "mod_name", "=", "\"detectron2\"", "\n", "", "return", "mod_name", ",", "(", "code", ".", "co_filename", ",", "frame", ".", "f_lineno", ",", "code", ".", "co_name", ")", "\n", "", "frame", "=", "frame", ".", "f_back", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.log_first_n": [[132, 165], ["isinstance", "logger._find_caller", "len", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger._find_caller"], ["def", "log_first_n", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ",", "key", "=", "\"caller\"", ")", ":", "\n", "    ", "\"\"\"\n    Log only for the first n times.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by default.\n        key (str or tuple[str]): the string(s) can be one of \"caller\" or\n            \"message\", which defines how to identify duplicated logs.\n            For example, if called with `n=1, key=\"caller\"`, this function\n            will only log the first call from the same caller, regardless of\n            the message content.\n            If called with `n=1, key=\"message\"`, this function will log the\n            same content only once, even if they are called from different places.\n            If called with `n=1, key=(\"caller\", \"message\")`, this function\n            will not log only if the same caller has logged the same message before.\n    \"\"\"", "\n", "if", "isinstance", "(", "key", ",", "str", ")", ":", "\n", "        ", "key", "=", "(", "key", ",", ")", "\n", "", "assert", "len", "(", "key", ")", ">", "0", "\n", "\n", "caller_module", ",", "caller_key", "=", "_find_caller", "(", ")", "\n", "hash_key", "=", "(", ")", "\n", "if", "\"caller\"", "in", "key", ":", "\n", "        ", "hash_key", "=", "hash_key", "+", "caller_key", "\n", "", "if", "\"message\"", "in", "key", ":", "\n", "        ", "hash_key", "=", "hash_key", "+", "(", "msg", ",", ")", "\n", "\n", "", "_LOG_COUNTER", "[", "hash_key", "]", "+=", "1", "\n", "if", "_LOG_COUNTER", "[", "hash_key", "]", "<=", "n", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.log_every_n": [[167, 181], ["logger._find_caller", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger._find_caller"], ["", "", "def", "log_every_n", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Log once per n times.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by default.\n    \"\"\"", "\n", "caller_module", ",", "key", "=", "_find_caller", "(", ")", "\n", "_LOG_COUNTER", "[", "key", "]", "+=", "1", "\n", "if", "n", "==", "1", "or", "_LOG_COUNTER", "[", "key", "]", "%", "n", "==", "1", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.log_every_n_seconds": [[183, 199], ["logger._find_caller", "_LOG_TIMER.get", "time.time", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger._find_caller", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "log_every_n_seconds", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Log no more than once per n seconds.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by default.\n    \"\"\"", "\n", "caller_module", ",", "key", "=", "_find_caller", "(", ")", "\n", "last_logged", "=", "_LOG_TIMER", ".", "get", "(", "key", ",", "None", ")", "\n", "current_time", "=", "time", ".", "time", "(", ")", "\n", "if", "last_logged", "is", "None", "or", "current_time", "-", "last_logged", ">=", "n", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "_LOG_TIMER", "[", "key", "]", "=", "current_time", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.create_small_table": [[201, 222], ["tuple", "tabulate.tabulate", "zip", "small_dict.items"], "function", ["None"], ["", "", "def", "create_small_table", "(", "small_dict", ")", ":", "\n", "    ", "\"\"\"\n    Create a small table using the keys of small_dict as headers. This is only\n    suitable for small dictionaries.\n\n    Args:\n        small_dict (dict): a result dictionary of only a few items.\n\n    Returns:\n        str: the table as a string.\n    \"\"\"", "\n", "keys", ",", "values", "=", "tuple", "(", "zip", "(", "*", "small_dict", ".", "items", "(", ")", ")", ")", "\n", "table", "=", "tabulate", "(", "\n", "[", "values", "]", ",", "\n", "headers", "=", "keys", ",", "\n", "tablefmt", "=", "\"pipe\"", ",", "\n", "floatfmt", "=", "\".3f\"", ",", "\n", "stralign", "=", "\"center\"", ",", "\n", "numalign", "=", "\"center\"", ",", "\n", ")", "\n", "return", "table", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.collect_torch_env": [[17, 27], ["torch.__config__.show", "get_pretty_env_info"], "function", ["None"], ["def", "collect_torch_env", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "import", "torch", ".", "__config__", "\n", "\n", "return", "torch", ".", "__config__", ".", "show", "(", ")", "\n", "", "except", "ImportError", ":", "\n", "# compatible with older versions of pytorch", "\n", "        ", "from", "torch", ".", "utils", ".", "collect_env", "import", "get_pretty_env_info", "\n", "\n", "return", "get_pretty_env_info", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.get_env_module": [[29, 32], ["os.environ.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "get_env_module", "(", ")", ":", "\n", "    ", "var_name", "=", "\"DETECTRON2_ENV_MODULE\"", "\n", "return", "var_name", ",", "os", ".", "environ", ".", "get", "(", "var_name", ",", "\"<not set>\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.detect_compute_compatibility": [[34, 53], ["os.path.join", "os.path.isfile", "subprocess.check_output", "output.decode().strip().split.decode().strip().split", "sorted", "sorted.append", "set", "output.decode().strip().split.decode().strip", "re.findall", "output.decode().strip().split.decode"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "def", "detect_compute_compatibility", "(", "CUDA_HOME", ",", "so_file", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "cuobjdump", "=", "os", ".", "path", ".", "join", "(", "CUDA_HOME", ",", "\"bin\"", ",", "\"cuobjdump\"", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "cuobjdump", ")", ":", "\n", "            ", "output", "=", "subprocess", ".", "check_output", "(", "\n", "\"'{}' --list-elf '{}'\"", ".", "format", "(", "cuobjdump", ",", "so_file", ")", ",", "shell", "=", "True", "\n", ")", "\n", "output", "=", "output", ".", "decode", "(", "\"utf-8\"", ")", ".", "strip", "(", ")", ".", "split", "(", "\"\\n\"", ")", "\n", "arch", "=", "[", "]", "\n", "for", "line", "in", "output", ":", "\n", "                ", "line", "=", "re", ".", "findall", "(", "r\"\\.sm_([0-9]*)\\.\"", ",", "line", ")", "[", "0", "]", "\n", "arch", ".", "append", "(", "\".\"", ".", "join", "(", "line", ")", ")", "\n", "", "arch", "=", "sorted", "(", "set", "(", "arch", ")", ")", "\n", "return", "\", \"", ".", "join", "(", "arch", ")", "\n", "", "else", ":", "\n", "            ", "return", "so_file", "+", "\"; cannot find cuobjdump\"", "\n", "", "", "except", "Exception", ":", "\n", "# unhandled failure", "\n", "        ", "return", "so_file", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.collect_env_info": [[55, 177], ["torch.cuda.is_available", "data.append", "data.append", "data.append", "data.append", "data.append", "data.append", "data.append", "data.append", "collect_env.collect_torch_env", "tuple", "data.append", "data.append", "data.append", "collect_env.get_env_module", "collections.defaultdict", "range", "collections.defaultdict.items", "data.append", "data.append", "data.append", "tabulate.tabulate", "map", "sys.version.replace", "data.append", "data.append", "data.append", "torch.cuda.device_count", "devices[].append", "data.append", "data.append", "data.append", "os.environ.get", "data.append", "data.append", "getattr", "data.append", "_C.get_compiler_version", "_C.get_cuda_version", "os.path.dirname", "torch.cuda.get_device_name", "str", "data.append", "collect_env.detect_compute_compatibility", "data.append", "torch_version.split", "os.path.dirname", "os.environ.get", "subprocess.check_output", "data.append", "collect_env.detect_compute_compatibility", "str", "os.path.isdir", "os.path.isdir", "os.path.dirname", "importlib.util.find_spec", "data.append", "subprocess.check_output.decode().strip().split", "os.path.join", "subprocess.check_output", "torch.cuda.get_device_capability", "str", "str", "str", "subprocess.check_output.decode().strip().split", "subprocess.check_output.decode().strip", "subprocess.check_output.decode().strip", "subprocess.check_output.decode", "subprocess.check_output.decode"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.collect_torch_env", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.get_env_module", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.detect_compute_compatibility", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.detect_compute_compatibility"], ["", "", "def", "collect_env_info", "(", ")", ":", "\n", "    ", "has_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "# true for both CUDA & ROCM", "\n", "torch_version", "=", "torch", ".", "__version__", "\n", "\n", "# NOTE: the use of CUDA_HOME and ROCM_HOME requires the CUDA/ROCM build deps, though in", "\n", "# theory detectron2 should be made runnable with only the corresponding runtimes", "\n", "from", "torch", ".", "utils", ".", "cpp_extension", "import", "CUDA_HOME", "\n", "\n", "has_rocm", "=", "False", "\n", "if", "tuple", "(", "map", "(", "int", ",", "torch_version", ".", "split", "(", "\".\"", ")", "[", ":", "2", "]", ")", ")", ">=", "(", "1", ",", "5", ")", ":", "\n", "        ", "from", "torch", ".", "utils", ".", "cpp_extension", "import", "ROCM_HOME", "\n", "\n", "if", "(", "getattr", "(", "torch", ".", "version", ",", "\"hip\"", ",", "None", ")", "is", "not", "None", ")", "and", "(", "ROCM_HOME", "is", "not", "None", ")", ":", "\n", "            ", "has_rocm", "=", "True", "\n", "", "", "has_cuda", "=", "has_gpu", "and", "(", "not", "has_rocm", ")", "\n", "\n", "data", "=", "[", "]", "\n", "data", ".", "append", "(", "(", "\"sys.platform\"", ",", "sys", ".", "platform", ")", ")", "\n", "data", ".", "append", "(", "(", "\"Python\"", ",", "sys", ".", "version", ".", "replace", "(", "\"\\n\"", ",", "\"\"", ")", ")", ")", "\n", "data", ".", "append", "(", "(", "\"numpy\"", ",", "np", ".", "__version__", ")", ")", "\n", "\n", "try", ":", "\n", "        ", "import", "detectron2", "# noqa", "\n", "\n", "data", ".", "append", "(", "\n", "(", "\"detectron2\"", ",", "detectron2", ".", "__version__", "+", "\" @\"", "+", "os", ".", "path", ".", "dirname", "(", "detectron2", ".", "__file__", ")", ")", "\n", ")", "\n", "", "except", "ImportError", ":", "\n", "        ", "data", ".", "append", "(", "(", "\"detectron2\"", ",", "\"failed to import\"", ")", ")", "\n", "\n", "", "try", ":", "\n", "        ", "from", "detectron2", "import", "_C", "\n", "", "except", "ImportError", ":", "\n", "        ", "data", ".", "append", "(", "(", "\"detectron2._C\"", ",", "\"failed to import. detectron2 is not built correctly\"", ")", ")", "\n", "\n", "# print system compilers when extension fails to build", "\n", "if", "sys", ".", "platform", "!=", "\"win32\"", ":", "# don't know what to do for windows", "\n", "            ", "try", ":", "\n", "# this is how torch/utils/cpp_extensions.py choose compiler", "\n", "                ", "cxx", "=", "os", ".", "environ", ".", "get", "(", "\"CXX\"", ",", "\"c++\"", ")", "\n", "cxx", "=", "subprocess", ".", "check_output", "(", "\"'{}' --version\"", ".", "format", "(", "cxx", ")", ",", "shell", "=", "True", ")", "\n", "cxx", "=", "cxx", ".", "decode", "(", "\"utf-8\"", ")", ".", "strip", "(", ")", ".", "split", "(", "\"\\n\"", ")", "[", "0", "]", "\n", "", "except", "subprocess", ".", "SubprocessError", ":", "\n", "                ", "cxx", "=", "\"Not found\"", "\n", "", "data", ".", "append", "(", "(", "\"Compiler\"", ",", "cxx", ")", ")", "\n", "\n", "if", "has_cuda", "and", "CUDA_HOME", "is", "not", "None", ":", "\n", "                ", "try", ":", "\n", "                    ", "nvcc", "=", "os", ".", "path", ".", "join", "(", "CUDA_HOME", ",", "\"bin\"", ",", "\"nvcc\"", ")", "\n", "nvcc", "=", "subprocess", ".", "check_output", "(", "\"'{}' -V\"", ".", "format", "(", "nvcc", ")", ",", "shell", "=", "True", ")", "\n", "nvcc", "=", "nvcc", ".", "decode", "(", "\"utf-8\"", ")", ".", "strip", "(", ")", ".", "split", "(", "\"\\n\"", ")", "[", "-", "1", "]", "\n", "", "except", "subprocess", ".", "SubprocessError", ":", "\n", "                    ", "nvcc", "=", "\"Not found\"", "\n", "", "data", ".", "append", "(", "(", "\"CUDA compiler\"", ",", "nvcc", ")", ")", "\n", "", "", "", "else", ":", "\n", "# print compilers that are used to build extension", "\n", "        ", "data", ".", "append", "(", "(", "\"Compiler\"", ",", "_C", ".", "get_compiler_version", "(", ")", ")", ")", "\n", "data", ".", "append", "(", "(", "\"CUDA compiler\"", ",", "_C", ".", "get_cuda_version", "(", ")", ")", ")", "# cuda or hip", "\n", "if", "has_cuda", ":", "\n", "            ", "data", ".", "append", "(", "\n", "(", "\"detectron2 arch flags\"", ",", "detect_compute_compatibility", "(", "CUDA_HOME", ",", "_C", ".", "__file__", ")", ")", "\n", ")", "\n", "\n", "", "", "data", ".", "append", "(", "get_env_module", "(", ")", ")", "\n", "data", ".", "append", "(", "(", "\"PyTorch\"", ",", "torch_version", "+", "\" @\"", "+", "os", ".", "path", ".", "dirname", "(", "torch", ".", "__file__", ")", ")", ")", "\n", "data", ".", "append", "(", "(", "\"PyTorch debug build\"", ",", "torch", ".", "version", ".", "debug", ")", ")", "\n", "\n", "data", ".", "append", "(", "(", "\"GPU available\"", ",", "has_gpu", ")", ")", "\n", "if", "has_gpu", ":", "\n", "        ", "devices", "=", "defaultdict", "(", "list", ")", "\n", "for", "k", "in", "range", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", ":", "\n", "            ", "cap", "=", "\".\"", ".", "join", "(", "(", "str", "(", "x", ")", "for", "x", "in", "torch", ".", "cuda", ".", "get_device_capability", "(", "k", ")", ")", ")", "\n", "name", "=", "torch", ".", "cuda", ".", "get_device_name", "(", "k", ")", "+", "f\" (arch={cap})\"", "\n", "devices", "[", "name", "]", ".", "append", "(", "str", "(", "k", ")", ")", "\n", "", "for", "name", ",", "devids", "in", "devices", ".", "items", "(", ")", ":", "\n", "            ", "data", ".", "append", "(", "(", "\"GPU \"", "+", "\",\"", ".", "join", "(", "devids", ")", ",", "name", ")", ")", "\n", "\n", "", "if", "has_rocm", ":", "\n", "            ", "msg", "=", "\" - invalid!\"", "if", "not", "os", ".", "path", ".", "isdir", "(", "ROCM_HOME", ")", "else", "\"\"", "\n", "data", ".", "append", "(", "(", "\"ROCM_HOME\"", ",", "str", "(", "ROCM_HOME", ")", "+", "msg", ")", ")", "\n", "", "else", ":", "\n", "            ", "msg", "=", "\" - invalid!\"", "if", "not", "os", ".", "path", ".", "isdir", "(", "CUDA_HOME", ")", "else", "\"\"", "\n", "data", ".", "append", "(", "(", "\"CUDA_HOME\"", ",", "str", "(", "CUDA_HOME", ")", "+", "msg", ")", ")", "\n", "\n", "cuda_arch_list", "=", "os", ".", "environ", ".", "get", "(", "\"TORCH_CUDA_ARCH_LIST\"", ",", "None", ")", "\n", "if", "cuda_arch_list", ":", "\n", "                ", "data", ".", "append", "(", "(", "\"TORCH_CUDA_ARCH_LIST\"", ",", "cuda_arch_list", ")", ")", "\n", "", "", "", "data", ".", "append", "(", "(", "\"Pillow\"", ",", "PIL", ".", "__version__", ")", ")", "\n", "\n", "try", ":", "\n", "        ", "data", ".", "append", "(", "\n", "(", "\n", "\"torchvision\"", ",", "\n", "str", "(", "torchvision", ".", "__version__", ")", "+", "\" @\"", "+", "os", ".", "path", ".", "dirname", "(", "torchvision", ".", "__file__", ")", ",", "\n", ")", "\n", ")", "\n", "if", "has_cuda", ":", "\n", "            ", "try", ":", "\n", "                ", "torchvision_C", "=", "importlib", ".", "util", ".", "find_spec", "(", "\"torchvision._C\"", ")", ".", "origin", "\n", "msg", "=", "detect_compute_compatibility", "(", "CUDA_HOME", ",", "torchvision_C", ")", "\n", "data", ".", "append", "(", "(", "\"torchvision arch flags\"", ",", "msg", ")", ")", "\n", "", "except", "ImportError", ":", "\n", "                ", "data", ".", "append", "(", "(", "\"torchvision._C\"", ",", "\"Not found\"", ")", ")", "\n", "", "", "", "except", "AttributeError", ":", "\n", "        ", "data", ".", "append", "(", "(", "\"torchvision\"", ",", "\"unknown\"", ")", ")", "\n", "\n", "", "try", ":", "\n", "        ", "import", "fvcore", "\n", "\n", "data", ".", "append", "(", "(", "\"fvcore\"", ",", "fvcore", ".", "__version__", ")", ")", "\n", "", "except", "ImportError", ":", "\n", "        ", "pass", "\n", "\n", "", "try", ":", "\n", "        ", "import", "cv2", "\n", "\n", "data", ".", "append", "(", "(", "\"cv2\"", ",", "cv2", ".", "__version__", ")", ")", "\n", "", "except", "ImportError", ":", "\n", "        ", "data", ".", "append", "(", "(", "\"cv2\"", ",", "\"Not found\"", ")", ")", "\n", "", "env_str", "=", "tabulate", "(", "data", ")", "+", "\"\\n\"", "\n", "env_str", "+=", "collect_torch_env", "(", ")", "\n", "return", "env_str", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env.seed_all_rng": [[21, 39], ["numpy.random.seed", "torch.set_rng_state", "random.seed", "logging.getLogger", "logging.getLogger.info", "torch.manual_seed().get_state", "int.from_bytes", "os.getpid", "int", "os.urandom", "torch.manual_seed", "datetime.datetime.now().strftime", "datetime.datetime.now"], "function", ["None"], ["def", "seed_all_rng", "(", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Set the random seed for the RNG in torch, numpy and python.\n\n    Args:\n        seed (int): if None, will use a strong random seed.\n    \"\"\"", "\n", "if", "seed", "is", "None", ":", "\n", "        ", "seed", "=", "(", "\n", "os", ".", "getpid", "(", ")", "\n", "+", "int", "(", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%S%f\"", ")", ")", "\n", "+", "int", ".", "from_bytes", "(", "os", ".", "urandom", "(", "2", ")", ",", "\"big\"", ")", "\n", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Using a generated random seed {}\"", ".", "format", "(", "seed", ")", ")", "\n", "", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "set_rng_state", "(", "torch", ".", "manual_seed", "(", "seed", ")", ".", "get_state", "(", ")", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env._import_file": [[42, 49], ["importlib.util.spec_from_file_location", "importlib.util.spec_from_file_location", "importlib.util.module_from_spec", "importlib.util.module_from_spec", "importlib.util.spec_from_file_location.loader.exec_module"], "function", ["None"], ["", "def", "_import_file", "(", "module_name", ",", "file_path", ",", "make_importable", "=", "False", ")", ":", "\n", "    ", "spec", "=", "importlib", ".", "util", ".", "spec_from_file_location", "(", "module_name", ",", "file_path", ")", "\n", "module", "=", "importlib", ".", "util", ".", "module_from_spec", "(", "spec", ")", "\n", "spec", ".", "loader", ".", "exec_module", "(", "module", ")", "\n", "if", "make_importable", ":", "\n", "        ", "sys", ".", "modules", "[", "module_name", "]", "=", "module", "\n", "", "return", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env._configure_libraries": [[51, 84], ["int", "os.environ.get", "tuple", "env._configure_libraries.get_version"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.None.setup.get_version"], ["", "def", "_configure_libraries", "(", ")", ":", "\n", "    ", "\"\"\"\n    Configurations for some libraries.\n    \"\"\"", "\n", "# An environment option to disable `import cv2` globally,", "\n", "# in case it leads to negative performance impact", "\n", "disable_cv2", "=", "int", "(", "os", ".", "environ", ".", "get", "(", "\"DETECTRON2_DISABLE_CV2\"", ",", "False", ")", ")", "\n", "if", "disable_cv2", ":", "\n", "        ", "sys", ".", "modules", "[", "\"cv2\"", "]", "=", "None", "\n", "", "else", ":", "\n", "# Disable opencl in opencv since its interaction with cuda often has negative effects", "\n", "# This envvar is supported after OpenCV 3.4.0", "\n", "        ", "os", ".", "environ", "[", "\"OPENCV_OPENCL_RUNTIME\"", "]", "=", "\"disabled\"", "\n", "try", ":", "\n", "            ", "import", "cv2", "\n", "\n", "if", "int", "(", "cv2", ".", "__version__", ".", "split", "(", "\".\"", ")", "[", "0", "]", ")", ">=", "3", ":", "\n", "                ", "cv2", ".", "ocl", ".", "setUseOpenCL", "(", "False", ")", "\n", "", "", "except", "ModuleNotFoundError", ":", "\n", "# Other types of ImportError, if happened, should not be ignored.", "\n", "# Because a failed opencv import could mess up address space", "\n", "# https://github.com/skvark/opencv-python/issues/381", "\n", "            ", "pass", "\n", "\n", "", "", "def", "get_version", "(", "module", ",", "digit", "=", "2", ")", ":", "\n", "        ", "return", "tuple", "(", "map", "(", "int", ",", "module", ".", "__version__", ".", "split", "(", "\".\"", ")", "[", ":", "digit", "]", ")", ")", "\n", "\n", "# fmt: off", "\n", "", "assert", "get_version", "(", "torch", ")", ">=", "(", "1", ",", "4", ")", ",", "\"Requires torch>=1.4\"", "\n", "import", "fvcore", "\n", "assert", "get_version", "(", "fvcore", ",", "3", ")", ">=", "(", "0", ",", "1", ",", "1", ")", ",", "\"Requires fvcore>=0.1.1\"", "\n", "import", "yaml", "\n", "assert", "get_version", "(", "yaml", ")", ">=", "(", "5", ",", "1", ")", ",", "\"Requires pyyaml>=5.1\"", "\n", "# fmt: on", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env.setup_environment": [[90, 110], ["env._configure_libraries", "os.environ.get", "env.setup_custom_environment"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env._configure_libraries", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env.setup_custom_environment"], ["def", "setup_environment", "(", ")", ":", "\n", "    ", "\"\"\"Perform environment setup work. The default setup is a no-op, but this\n    function allows the user to specify a Python source file or a module in\n    the $DETECTRON2_ENV_MODULE environment variable, that performs\n    custom setup work that may be necessary to their computing environment.\n    \"\"\"", "\n", "global", "_ENV_SETUP_DONE", "\n", "if", "_ENV_SETUP_DONE", ":", "\n", "        ", "return", "\n", "", "_ENV_SETUP_DONE", "=", "True", "\n", "\n", "_configure_libraries", "(", ")", "\n", "\n", "custom_module_path", "=", "os", ".", "environ", ".", "get", "(", "\"DETECTRON2_ENV_MODULE\"", ")", "\n", "\n", "if", "custom_module_path", ":", "\n", "        ", "setup_custom_environment", "(", "custom_module_path", ")", "\n", "", "else", ":", "\n", "# The default setup is a no-op", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env.setup_custom_environment": [[112, 126], ["custom_module.endswith", "importlib.import_module.setup_environment", "env._import_file", "importlib.import_module", "importlib.import_module", "hasattr", "callable"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env.setup_environment", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env._import_file"], ["", "", "def", "setup_custom_environment", "(", "custom_module", ")", ":", "\n", "    ", "\"\"\"\n    Load custom environment setup by importing a Python source file or a\n    module, and run the setup function.\n    \"\"\"", "\n", "if", "custom_module", ".", "endswith", "(", "\".py\"", ")", ":", "\n", "        ", "module", "=", "_import_file", "(", "\"detectron2.utils.env.custom_module\"", ",", "custom_module", ")", "\n", "", "else", ":", "\n", "        ", "module", "=", "importlib", ".", "import_module", "(", "custom_module", ")", "\n", "", "assert", "hasattr", "(", "module", ",", "\"setup_environment\"", ")", "and", "callable", "(", "module", ".", "setup_environment", ")", ",", "(", "\n", "\"Custom environment module defined in {} does not have the \"", "\n", "\"required callable attribute 'setup_environment'.\"", "\n", ")", ".", "format", "(", "custom_module", ")", "\n", "module", ".", "setup_environment", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.__init__": [[6, 11], ["collections.deque", "range"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "total_num_classes", ",", "items_per_class", ",", "shuffle", "=", "False", ")", ":", "\n", "        ", "self", ".", "shuffle", "=", "shuffle", "\n", "self", ".", "items_per_class", "=", "items_per_class", "\n", "self", ".", "total_num_classes", "=", "total_num_classes", "\n", "self", ".", "store", "=", "[", "deque", "(", "maxlen", "=", "self", ".", "items_per_class", ")", "for", "_", "in", "range", "(", "self", ".", "total_num_classes", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.add": [[12, 15], ["enumerate", "store.Store.store[].append"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "items", ",", "class_ids", ")", ":", "\n", "        ", "for", "idx", ",", "class_id", "in", "enumerate", "(", "class_ids", ")", ":", "\n", "            ", "self", ".", "store", "[", "class_id", "]", ".", "append", "(", "items", "[", "idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.retrieve": [[16, 32], ["range", "items.extend", "random.shuffle", "all_items.append", "list", "items.append", "list"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "", "def", "retrieve", "(", "self", ",", "class_id", ")", ":", "\n", "        ", "if", "class_id", "!=", "-", "1", ":", "\n", "            ", "items", "=", "[", "]", "\n", "for", "item", "in", "self", ".", "store", "[", "class_id", "]", ":", "\n", "                ", "items", ".", "extend", "(", "list", "(", "item", ")", ")", "\n", "", "if", "self", ".", "shuffle", ":", "\n", "                ", "random", ".", "shuffle", "(", "items", ")", "\n", "", "return", "items", "\n", "", "else", ":", "\n", "            ", "all_items", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "total_num_classes", ")", ":", "\n", "                ", "items", "=", "[", "]", "\n", "for", "item", "in", "self", ".", "store", "[", "i", "]", ":", "\n", "                    ", "items", ".", "append", "(", "list", "(", "item", ")", ")", "\n", "", "all_items", ".", "append", "(", "items", ")", "\n", "", "return", "all_items", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.reset": [[33, 35], ["collections.deque", "range"], "methods", ["None"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "store", "=", "[", "deque", "(", "maxlen", "=", "self", ".", "items_per_class", ")", "for", "_", "in", "range", "(", "self", ".", "total_num_classes", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.__str__": [[36, 42], ["enumerate", "str", "len", "str", "list"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "'('", "\n", "for", "idx", ",", "item", "in", "enumerate", "(", "self", ".", "store", ")", ":", "\n", "            ", "s", "+=", "'\\n Class '", "+", "str", "(", "idx", ")", "+", "' --> '", "+", "str", "(", "len", "(", "list", "(", "item", ")", ")", ")", "+", "' items'", "\n", "", "s", "=", "s", "+", "' )'", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.__repr__": [[43, 45], ["store.Store.__str__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.CompoundVisualizer.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.__len__": [[46, 48], ["sum", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "sum", "(", "[", "len", "(", "s", ")", "for", "s", "in", "self", ".", "store", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.memory._ignore_torch_cuda_oom": [[11, 24], ["str"], "function", ["None"], ["@", "contextmanager", "\n", "def", "_ignore_torch_cuda_oom", "(", ")", ":", "\n", "    ", "\"\"\"\n    A context which ignores CUDA OOM exception from pytorch.\n    \"\"\"", "\n", "try", ":", "\n", "        ", "yield", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "# NOTE: the string may change?", "\n", "        ", "if", "\"CUDA out of memory. \"", "in", "str", "(", "e", ")", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.memory.retry_if_cuda_oom": [[26, 85], ["functools.wraps", "torch.cuda.empty_cache", "logging.getLogger", "logging.getLogger.info", "func", "x.to", "memory._ignore_torch_cuda_oom", "func", "memory._ignore_torch_cuda_oom", "func", "memory.retry_if_cuda_oom.maybe_to_cpu"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.memory._ignore_torch_cuda_oom", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.memory._ignore_torch_cuda_oom"], ["", "", "", "def", "retry_if_cuda_oom", "(", "func", ")", ":", "\n", "    ", "\"\"\"\n    Makes a function retry itself after encountering\n    pytorch's CUDA OOM error.\n    It will first retry after calling `torch.cuda.empty_cache()`.\n\n    If that still fails, it will then retry by trying to convert inputs to CPUs.\n    In this case, it expects the function to dispatch to CPU implementation.\n    The return values may become CPU tensors as well and it's user's\n    responsibility to convert it back to CUDA tensor if needed.\n\n    Args:\n        func: a stateless callable that takes tensor-like objects as arguments\n\n    Returns:\n        a callable which retries `func` if OOM is encountered.\n\n    Examples:\n    ::\n        output = retry_if_cuda_oom(some_torch_function)(input1, input2)\n        # output may be on CPU even if inputs are on GPU\n\n    Note:\n        1. When converting inputs to CPU, it will only look at each argument and check\n           if it has `.device` and `.to` for conversion. Nested structures of tensors\n           are not supported.\n\n        2. Since the function might be called more than once, it has to be\n           stateless.\n    \"\"\"", "\n", "\n", "def", "maybe_to_cpu", "(", "x", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "like_gpu_tensor", "=", "x", ".", "device", ".", "type", "==", "\"cuda\"", "and", "hasattr", "(", "x", ",", "\"to\"", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "like_gpu_tensor", "=", "False", "\n", "", "if", "like_gpu_tensor", ":", "\n", "            ", "return", "x", ".", "to", "(", "device", "=", "\"cpu\"", ")", "\n", "", "else", ":", "\n", "            ", "return", "x", "\n", "\n", "", "", "@", "wraps", "(", "func", ")", "\n", "def", "wrapped", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "with", "_ignore_torch_cuda_oom", "(", ")", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "# Clear cache and retry", "\n", "", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "with", "_ignore_torch_cuda_oom", "(", ")", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "# Try on CPU. This slows down the code significantly, therefore print a notice.", "\n", "", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Attempting to copy inputs of {} to CPU due to CUDA OOM\"", ".", "format", "(", "str", "(", "func", ")", ")", ")", "\n", "new_args", "=", "(", "maybe_to_cpu", "(", "x", ")", "for", "x", "in", "args", ")", "\n", "new_kwargs", "=", "{", "k", ":", "maybe_to_cpu", "(", "v", ")", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "}", "\n", "return", "func", "(", "*", "new_args", ",", "**", "new_kwargs", ")", "\n", "\n", "", "return", "wrapped", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.EntrySelector.from_string": [[10, 15], ["dbhelper.FieldEntrySelector", "dbhelper.AllEntrySelector"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "from_string", "(", "spec", ":", "str", ")", "->", "\"EntrySelector\"", ":", "\n", "        ", "if", "spec", "==", "\"*\"", ":", "\n", "            ", "return", "AllEntrySelector", "(", ")", "\n", "", "return", "FieldEntrySelector", "(", "spec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.AllEntrySelector.__call__": [[24, 26], ["None"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "entry", ")", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector.__init__": [[85, 87], ["dbhelper.FieldEntrySelector._parse_specifier_into_predicates"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._parse_specifier_into_predicates"], ["", "", "def", "__init__", "(", "self", ",", "spec", ":", "str", ")", ":", "\n", "        ", "self", ".", "_predicates", "=", "self", ".", "_parse_specifier_into_predicates", "(", "spec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector.__call__": [[88, 93], ["predicate"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "for", "predicate", "in", "self", ".", "_predicates", ":", "\n", "            ", "if", "not", "predicate", "(", "entry", ")", ":", "\n", "                ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._parse_specifier_into_predicates": [[94, 118], ["spec.split", "subspec.find", "dbhelper.FieldEntrySelector._parse_field_name_type", "dbhelper.FieldEntrySelector._is_range_spec", "predicates.append", "dbhelper.FieldEntrySelector._get_range_spec", "FieldEntrySelector._FieldEntryRangePredicate", "FieldEntrySelector._FieldEntryValuePredicate", "dbhelper.FieldEntrySelector._parse_error", "dbhelper.FieldEntrySelector._parse_error"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._parse_field_name_type", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._is_range_spec", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._get_range_spec", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._parse_error", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._parse_error"], ["", "def", "_parse_specifier_into_predicates", "(", "self", ",", "spec", ":", "str", ")", ":", "\n", "        ", "predicates", "=", "[", "]", "\n", "specs", "=", "spec", ".", "split", "(", "self", ".", "_SPEC_DELIM", ")", "\n", "for", "subspec", "in", "specs", ":", "\n", "            ", "eq_idx", "=", "subspec", ".", "find", "(", "self", ".", "_EQUAL", ")", "\n", "if", "eq_idx", ">", "0", ":", "\n", "                ", "field_name_with_type", "=", "subspec", "[", ":", "eq_idx", "]", "\n", "field_name", ",", "field_type", "=", "self", ".", "_parse_field_name_type", "(", "field_name_with_type", ")", "\n", "field_value_or_range", "=", "subspec", "[", "eq_idx", "+", "1", ":", "]", "\n", "if", "self", ".", "_is_range_spec", "(", "field_value_or_range", ")", ":", "\n", "                    ", "vmin", ",", "vmax", "=", "self", ".", "_get_range_spec", "(", "field_value_or_range", ")", "\n", "predicate", "=", "FieldEntrySelector", ".", "_FieldEntryRangePredicate", "(", "\n", "field_name", ",", "field_type", ",", "vmin", ",", "vmax", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "predicate", "=", "FieldEntrySelector", ".", "_FieldEntryValuePredicate", "(", "\n", "field_name", ",", "field_type", ",", "field_value_or_range", "\n", ")", "\n", "", "predicates", ".", "append", "(", "predicate", ")", "\n", "", "elif", "eq_idx", "==", "0", ":", "\n", "                ", "self", ".", "_parse_error", "(", "f'\"{subspec}\", field name is empty!'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_parse_error", "(", "f'\"{subspec}\", should have format '", "\"<field>=<value_or_range>!\"", ")", "\n", "", "", "return", "predicates", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._parse_field_name_type": [[119, 130], ["field_name_with_type.find", "dbhelper.FieldEntrySelector._parse_error"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._parse_error"], ["", "def", "_parse_field_name_type", "(", "self", ",", "field_name_with_type", ":", "str", ")", "->", "Tuple", "[", "str", ",", "Optional", "[", "str", "]", "]", ":", "\n", "        ", "type_delim_idx", "=", "field_name_with_type", ".", "find", "(", "self", ".", "_TYPE_DELIM", ")", "\n", "if", "type_delim_idx", ">", "0", ":", "\n", "            ", "field_name", "=", "field_name_with_type", "[", ":", "type_delim_idx", "]", "\n", "field_type", "=", "field_name_with_type", "[", "type_delim_idx", "+", "1", ":", "]", "\n", "", "elif", "type_delim_idx", "==", "0", ":", "\n", "            ", "self", ".", "_parse_error", "(", "f'\"{field_name_with_type}\", field name is empty!'", ")", "\n", "", "else", ":", "\n", "            ", "field_name", "=", "field_name_with_type", "\n", "field_type", "=", "None", "\n", "", "return", "field_name", ",", "field_type", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._is_range_spec": [[131, 134], ["field_value_or_range.find"], "methods", ["None"], ["", "def", "_is_range_spec", "(", "self", ",", "field_value_or_range", ")", ":", "\n", "        ", "delim_idx", "=", "field_value_or_range", ".", "find", "(", "self", ".", "_RANGE_DELIM", ")", "\n", "return", "delim_idx", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._get_range_spec": [[135, 143], ["dbhelper.FieldEntrySelector._is_range_spec", "field_value_or_range.find", "dbhelper.FieldEntrySelector._parse_error"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._is_range_spec", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._parse_error"], ["", "def", "_get_range_spec", "(", "self", ",", "field_value_or_range", ")", ":", "\n", "        ", "if", "self", ".", "_is_range_spec", "(", "field_value_or_range", ")", ":", "\n", "            ", "delim_idx", "=", "field_value_or_range", ".", "find", "(", "self", ".", "_RANGE_DELIM", ")", "\n", "vmin", "=", "field_value_or_range", "[", ":", "delim_idx", "]", "\n", "vmax", "=", "field_value_or_range", "[", "delim_idx", "+", "1", ":", "]", "\n", "return", "vmin", ",", "vmax", "\n", "", "else", ":", "\n", "            ", "self", ".", "_parse_error", "(", "'\"field_value_or_range\", range of values expected!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.FieldEntrySelector._parse_error": [[144, 146], ["ValueError"], "methods", ["None"], ["", "", "def", "_parse_error", "(", "self", ",", "msg", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f\"{self._ERROR_PREFIX}: {msg}\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.verbosity_to_level": [[5, 14], ["None"], "function", ["None"], ["import", "sys", "\n", "import", "time", "\n", "from", "collections", "import", "Counter", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "from", "tabulate", "import", "tabulate", "\n", "from", "termcolor", "import", "colored", "\n", "\n", "\n", "class", "_ColorfulFormatter", "(", "logging", ".", "Formatter", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.transform.load_for_dataset": [[9, 13], ["fvcore.common.file_io.PathManager.get_local_path", "densepose.DensePoseTransformData.load", "detectron2.data.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["CropTransform", ",", "\n", "HFlipTransform", ",", "\n", "NoOpTransform", ",", "\n", "Transform", ",", "\n", "TransformList", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.transform.load_from_cfg": [[15, 17], ["transform.load_for_dataset"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.transform.load_for_dataset"], ["from", "PIL", "import", "Image", "\n", "\n", "try", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.detector_postprocess": [[11, 73], ["isinstance", "isinstance", "detectron2.structures.Instances", "detectron2.structures.Instances.has", "output_boxes.scale", "output_boxes.clip", "detectron2.structures.Instances.has", "detectron2.structures.Instances.has", "output_width.float", "output_height.float", "detectron2.structures.Instances.has", "detectron2.structures.Instances.get_fields", "output_boxes.nonempty", "detectron2.utils.memory.retry_if_cuda_oom"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.scale", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.get_fields", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.memory.retry_if_cuda_oom"], ["def", "detector_postprocess", "(", "results", ",", "output_height", ",", "output_width", ",", "mask_threshold", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"\n    Resize the output instances.\n    The input images are often resized when entering an object detector.\n    As a result, we often need the outputs of the detector in a different\n    resolution from its inputs.\n\n    This function will resize the raw outputs of an R-CNN detector\n    to produce outputs according to the desired output resolution.\n\n    Args:\n        results (Instances): the raw outputs from the detector.\n            `results.image_size` contains the input image resolution the detector sees.\n            This object might be modified in-place.\n        output_height, output_width: the desired output resolution.\n\n    Returns:\n        Instances: the resized output from the model, based on the output resolution\n    \"\"\"", "\n", "\n", "# Converts integer tensors to float temporaries", "\n", "#   to ensure true division is performed when", "\n", "#   computing scale_x and scale_y.", "\n", "if", "isinstance", "(", "output_width", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "output_width_tmp", "=", "output_width", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "        ", "output_width_tmp", "=", "output_width", "\n", "\n", "", "if", "isinstance", "(", "output_height", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "output_height_tmp", "=", "output_height", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "        ", "output_height_tmp", "=", "output_height", "\n", "\n", "", "scale_x", ",", "scale_y", "=", "(", "\n", "output_width_tmp", "/", "results", ".", "image_size", "[", "1", "]", ",", "\n", "output_height_tmp", "/", "results", ".", "image_size", "[", "0", "]", ",", "\n", ")", "\n", "results", "=", "Instances", "(", "(", "output_height", ",", "output_width", ")", ",", "**", "results", ".", "get_fields", "(", ")", ")", "\n", "\n", "if", "results", ".", "has", "(", "\"pred_boxes\"", ")", ":", "\n", "        ", "output_boxes", "=", "results", ".", "pred_boxes", "\n", "", "elif", "results", ".", "has", "(", "\"proposal_boxes\"", ")", ":", "\n", "        ", "output_boxes", "=", "results", ".", "proposal_boxes", "\n", "\n", "", "output_boxes", ".", "scale", "(", "scale_x", ",", "scale_y", ")", "\n", "output_boxes", ".", "clip", "(", "results", ".", "image_size", ")", "\n", "\n", "results", "=", "results", "[", "output_boxes", ".", "nonempty", "(", ")", "]", "\n", "\n", "if", "results", ".", "has", "(", "\"pred_masks\"", ")", ":", "\n", "        ", "results", ".", "pred_masks", "=", "retry_if_cuda_oom", "(", "paste_masks_in_image", ")", "(", "\n", "results", ".", "pred_masks", "[", ":", ",", "0", ",", ":", ",", ":", "]", ",", "# N, 1, M, M", "\n", "results", ".", "pred_boxes", ",", "\n", "results", ".", "image_size", ",", "\n", "threshold", "=", "mask_threshold", ",", "\n", ")", "\n", "\n", "", "if", "results", ".", "has", "(", "\"pred_keypoints\"", ")", ":", "\n", "        ", "results", ".", "pred_keypoints", "[", ":", ",", ":", ",", "0", "]", "*=", "scale_x", "\n", "results", ".", "pred_keypoints", "[", ":", ",", ":", ",", "1", "]", "*=", "scale_y", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.sem_seg_postprocess": [[75, 99], ["result[].expand", "torch.nn.functional.interpolate"], "function", ["None"], ["", "def", "sem_seg_postprocess", "(", "result", ",", "img_size", ",", "output_height", ",", "output_width", ")", ":", "\n", "    ", "\"\"\"\n    Return semantic segmentation predictions in the original resolution.\n\n    The input images are often resized when entering semantic segmentor. Moreover, in same\n    cases, they also padded inside segmentor to be divisible by maximum network stride.\n    As a result, we often need the predictions of the segmentor in a different\n    resolution from its inputs.\n\n    Args:\n        result (Tensor): semantic segmentation prediction logits. A tensor of shape (C, H, W),\n            where C is the number of classes, and H, W are the height and width of the prediction.\n        img_size (tuple): image size that segmentor is taking as input.\n        output_height, output_width: the desired output resolution.\n\n    Returns:\n        semantic segmentation prediction (Tensor): A tensor of the shape\n            (C, output_height, output_width) that contains per-pixel soft predictions.\n    \"\"\"", "\n", "result", "=", "result", "[", ":", ",", ":", "img_size", "[", "0", "]", ",", ":", "img_size", "[", "1", "]", "]", ".", "expand", "(", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ")", "\n", "result", "=", "F", ".", "interpolate", "(", "\n", "result", ",", "size", "=", "(", "output_height", ",", "output_width", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "[", "0", "]", "\n", "return", "result", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.matcher.Matcher.__init__": [[24, 60], ["thresholds.insert", "thresholds.append", "all", "all", "float", "len", "float", "len", "zip"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "thresholds", ":", "List", "[", "float", "]", ",", "labels", ":", "List", "[", "int", "]", ",", "allow_low_quality_matches", ":", "bool", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            thresholds (list): a list of thresholds used to stratify predictions\n                into levels.\n            labels (list): a list of values to label predictions belonging at\n                each level. A label can be one of {-1, 0, 1} signifying\n                {ignore, negative class, positive class}, respectively.\n            allow_low_quality_matches (bool): if True, produce additional matches\n                for predictions with maximum match quality lower than high_threshold.\n                See set_low_quality_matches_ for more details.\n\n            For example,\n                thresholds = [0.3, 0.5]\n                labels = [0, -1, 1]\n                All predictions with iou < 0.3 will be marked with 0 and\n                thus will be considered as false positives while training.\n                All predictions with 0.3 <= iou < 0.5 will be marked with -1 and\n                thus will be ignored.\n                All predictions with 0.5 <= iou will be marked with 1 and\n                thus will be considered as true positives.\n        \"\"\"", "\n", "# Add -inf and +inf to first and last position in thresholds", "\n", "thresholds", "=", "thresholds", "[", ":", "]", "\n", "assert", "thresholds", "[", "0", "]", ">", "0", "\n", "thresholds", ".", "insert", "(", "0", ",", "-", "float", "(", "\"inf\"", ")", ")", "\n", "thresholds", ".", "append", "(", "float", "(", "\"inf\"", ")", ")", "\n", "# Currently torchscript does not support all + generator", "\n", "assert", "all", "(", "[", "low", "<=", "high", "for", "(", "low", ",", "high", ")", "in", "zip", "(", "thresholds", "[", ":", "-", "1", "]", ",", "thresholds", "[", "1", ":", "]", ")", "]", ")", "\n", "assert", "all", "(", "[", "l", "in", "[", "-", "1", ",", "0", ",", "1", "]", "for", "l", "in", "labels", "]", ")", "\n", "assert", "len", "(", "labels", ")", "==", "len", "(", "thresholds", ")", "-", "1", "\n", "self", ".", "thresholds", "=", "thresholds", "\n", "self", ".", "labels", "=", "labels", "\n", "self", ".", "allow_low_quality_matches", "=", "allow_low_quality_matches", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.matcher.Matcher.__call__": [[61, 104], ["torch.all", "match_quality_matrix.max", "matches.new_full", "zip", "match_quality_matrix.dim", "match_quality_matrix.numel", "match_quality_matrix.new_full", "match_quality_matrix.new_full", "matches.size", "matcher.Matcher.set_low_quality_matches_", "match_quality_matrix.size", "match_quality_matrix.size"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.matcher.Matcher.set_low_quality_matches_"], ["", "def", "__call__", "(", "self", ",", "match_quality_matrix", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            match_quality_matrix (Tensor[float]): an MxN tensor, containing the\n                pairwise quality between M ground-truth elements and N predicted\n                elements. All elements must be >= 0 (due to the us of `torch.nonzero`\n                for selecting indices in :meth:`set_low_quality_matches_`).\n\n        Returns:\n            matches (Tensor[int64]): a vector of length N, where matches[i] is a matched\n                ground-truth index in [0, M)\n            match_labels (Tensor[int8]): a vector of length N, where pred_labels[i] indicates\n                whether a prediction is a true or false positive or ignored\n        \"\"\"", "\n", "assert", "match_quality_matrix", ".", "dim", "(", ")", "==", "2", "\n", "if", "match_quality_matrix", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "default_matches", "=", "match_quality_matrix", ".", "new_full", "(", "\n", "(", "match_quality_matrix", ".", "size", "(", "1", ")", ",", ")", ",", "0", ",", "dtype", "=", "torch", ".", "int64", "\n", ")", "\n", "# When no gt boxes exist, we define IOU = 0 and therefore set labels", "\n", "# to `self.labels[0]`, which usually defaults to background class 0", "\n", "# To choose to ignore instead, can make labels=[-1,0,-1,1] + set appropriate thresholds", "\n", "default_match_labels", "=", "match_quality_matrix", ".", "new_full", "(", "\n", "(", "match_quality_matrix", ".", "size", "(", "1", ")", ",", ")", ",", "self", ".", "labels", "[", "0", "]", ",", "dtype", "=", "torch", ".", "int8", "\n", ")", "\n", "return", "default_matches", ",", "default_match_labels", "\n", "\n", "", "assert", "torch", ".", "all", "(", "match_quality_matrix", ">=", "0", ")", "\n", "\n", "# match_quality_matrix is M (gt) x N (predicted)", "\n", "# Max over gt elements (dim 0) to find best gt candidate for each prediction", "\n", "matched_vals", ",", "matches", "=", "match_quality_matrix", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "match_labels", "=", "matches", ".", "new_full", "(", "matches", ".", "size", "(", ")", ",", "1", ",", "dtype", "=", "torch", ".", "int8", ")", "\n", "\n", "for", "(", "l", ",", "low", ",", "high", ")", "in", "zip", "(", "self", ".", "labels", ",", "self", ".", "thresholds", "[", ":", "-", "1", "]", ",", "self", ".", "thresholds", "[", "1", ":", "]", ")", ":", "\n", "            ", "low_high", "=", "(", "matched_vals", ">=", "low", ")", "&", "(", "matched_vals", "<", "high", ")", "\n", "match_labels", "[", "low_high", "]", "=", "l", "\n", "\n", "", "if", "self", ".", "allow_low_quality_matches", ":", "\n", "            ", "self", ".", "set_low_quality_matches_", "(", "match_labels", ",", "match_quality_matrix", ")", "\n", "\n", "", "return", "matches", ",", "match_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.matcher.Matcher.set_low_quality_matches_": [[105, 127], ["match_quality_matrix.max", "detectron2.layers.nonzero_tuple"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.nonzero_tuple"], ["", "def", "set_low_quality_matches_", "(", "self", ",", "match_labels", ",", "match_quality_matrix", ")", ":", "\n", "        ", "\"\"\"\n        Produce additional matches for predictions that have only low-quality matches.\n        Specifically, for each ground-truth G find the set of predictions that have\n        maximum overlap with it (including ties); for each prediction in that set, if\n        it is unmatched, then match it to the ground-truth G.\n\n        This function implements the RPN assignment case (i) in Sec. 3.1.2 of\n        :paper:`Faster R-CNN`.\n        \"\"\"", "\n", "# For each gt, find the prediction with which it has highest quality", "\n", "highest_quality_foreach_gt", ",", "_", "=", "match_quality_matrix", ".", "max", "(", "dim", "=", "1", ")", "\n", "# Find the highest quality match available, even if it is low, including ties.", "\n", "# Note that the matches qualities must be positive due to the use of", "\n", "# `torch.nonzero`.", "\n", "_", ",", "pred_inds_with_highest_quality", "=", "nonzero_tuple", "(", "\n", "match_quality_matrix", "==", "highest_quality_foreach_gt", "[", ":", ",", "None", "]", "\n", ")", "\n", "# If an anchor was labeled positive only due to a low-quality match", "\n", "# with gt_A, but it has larger overlap with gt_B, it's matched index will still be gt_B.", "\n", "# This follows the implementation in Detectron, and is found to have no significant impact.", "\n", "match_labels", "[", "pred_inds_with_highest_quality", "]", "=", "1", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.BufferList.__init__": [[25, 29], ["torch.nn.Module.__init__", "enumerate", "anchor_generator.BufferList.register_buffer", "str"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "buffers", ")", ":", "\n", "        ", "super", "(", "BufferList", ",", "self", ")", ".", "__init__", "(", ")", "\n", "for", "i", ",", "buffer", "in", "enumerate", "(", "buffers", ")", ":", "\n", "            ", "self", ".", "register_buffer", "(", "str", "(", "i", ")", ",", "buffer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.BufferList.__len__": [[30, 32], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_buffers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.BufferList.__iter__": [[33, 35], ["iter", "anchor_generator.BufferList._buffers.values"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "_buffers", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.DefaultAnchorGenerator.__init__": [[96, 125], ["torch.nn.Module.__init__", "len", "anchor_generator._broadcast_params", "anchor_generator._broadcast_params", "anchor_generator.DefaultAnchorGenerator._calculate_anchors"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator._calculate_anchors"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "sizes", ",", "aspect_ratios", ",", "strides", ",", "offset", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        This interface is experimental.\n\n        Args:\n            sizes (list[list[float]] or list[float]):\n                If sizes is list[list[float]], sizes[i] is the list of anchor sizes\n                (i.e. sqrt of anchor area) to use for the i-th feature map.\n                If sizes is list[float], the sizes are used for all feature maps.\n                Anchor sizes are given in absolute lengths in units of\n                the input image; they do not dynamically scale if the input image size changes.\n            aspect_ratios (list[list[float]] or list[float]): list of aspect ratios\n                (i.e. height / width) to use for anchors. Same \"broadcast\" rule for `sizes` applies.\n            strides (list[int]): stride of each input feature.\n            offset (float): Relative offset between the center of the first anchor and the top-left\n                corner of the image. Value has to be in [0, 1).\n                Recommend to use 0.5, which means half stride.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "num_features", "=", "len", "(", "self", ".", "strides", ")", "\n", "sizes", "=", "_broadcast_params", "(", "sizes", ",", "self", ".", "num_features", ",", "\"sizes\"", ")", "\n", "aspect_ratios", "=", "_broadcast_params", "(", "aspect_ratios", ",", "self", ".", "num_features", ",", "\"aspect_ratios\"", ")", "\n", "self", ".", "cell_anchors", "=", "self", ".", "_calculate_anchors", "(", "sizes", ",", "aspect_ratios", ")", "\n", "\n", "self", ".", "offset", "=", "offset", "\n", "assert", "0.0", "<=", "self", ".", "offset", "<", "1.0", ",", "self", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.DefaultAnchorGenerator.from_config": [[126, 133], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ":", "List", "[", "ShapeSpec", "]", ")", ":", "\n", "        ", "return", "{", "\n", "\"sizes\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", ",", "\n", "\"aspect_ratios\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", ",", "\n", "\"strides\"", ":", "[", "x", ".", "stride", "for", "x", "in", "input_shape", "]", ",", "\n", "\"offset\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "OFFSET", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.DefaultAnchorGenerator._calculate_anchors": [[135, 140], ["anchor_generator.BufferList", "anchor_generator.DefaultAnchorGenerator.generate_cell_anchors().float", "zip", "anchor_generator.DefaultAnchorGenerator.generate_cell_anchors"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator.generate_cell_anchors"], ["", "def", "_calculate_anchors", "(", "self", ",", "sizes", ",", "aspect_ratios", ")", ":", "\n", "        ", "cell_anchors", "=", "[", "\n", "self", ".", "generate_cell_anchors", "(", "s", ",", "a", ")", ".", "float", "(", ")", "for", "s", ",", "a", "in", "zip", "(", "sizes", ",", "aspect_ratios", ")", "\n", "]", "\n", "return", "BufferList", "(", "cell_anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.DefaultAnchorGenerator.num_cell_anchors": [[141, 147], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_cell_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Alias of `num_anchors`.\n        \"\"\"", "\n", "return", "self", ".", "num_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.DefaultAnchorGenerator.num_anchors": [[148, 161], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[int]: Each int is the number of anchors at every pixel\n                location, on that feature map.\n                For example, if at every pixel we use anchors of 3 aspect\n                ratios and 5 sizes, the number of anchors is 15.\n                (See also ANCHOR_GENERATOR.SIZES and ANCHOR_GENERATOR.ASPECT_RATIOS in config)\n\n                In standard RPN models, `num_anchors` on every feature map is the same.\n        \"\"\"", "\n", "return", "[", "len", "(", "cell_anchors", ")", "for", "cell_anchors", "in", "self", ".", "cell_anchors", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.DefaultAnchorGenerator._grid_anchors": [[162, 177], ["zip", "anchor_generator._create_grid_offsets", "torch.stack", "anchors.append", "anchor_generator.DefaultAnchorGenerator.cell_anchors.named_buffers", "torch.stack.view", "base_anchors.view"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator._create_grid_offsets"], ["", "def", "_grid_anchors", "(", "self", ",", "grid_sizes", ":", "List", "[", "List", "[", "int", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[Tensor]: #featuremap tensors, each is (#locations x #cell_anchors) x 4\n        \"\"\"", "\n", "anchors", "=", "[", "]", "\n", "# buffers() not supported by torchscript. use named_buffers() instead", "\n", "buffers", ":", "List", "[", "torch", ".", "Tensor", "]", "=", "[", "x", "[", "1", "]", "for", "x", "in", "self", ".", "cell_anchors", ".", "named_buffers", "(", ")", "]", "\n", "for", "size", ",", "stride", ",", "base_anchors", "in", "zip", "(", "grid_sizes", ",", "self", ".", "strides", ",", "buffers", ")", ":", "\n", "            ", "shift_x", ",", "shift_y", "=", "_create_grid_offsets", "(", "size", ",", "stride", ",", "self", ".", "offset", ",", "base_anchors", ".", "device", ")", "\n", "shifts", "=", "torch", ".", "stack", "(", "(", "shift_x", ",", "shift_y", ",", "shift_x", ",", "shift_y", ")", ",", "dim", "=", "1", ")", "\n", "\n", "anchors", ".", "append", "(", "(", "shifts", ".", "view", "(", "-", "1", ",", "1", ",", "4", ")", "+", "base_anchors", ".", "view", "(", "1", ",", "-", "1", ",", "4", ")", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", ")", "\n", "\n", "", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.DefaultAnchorGenerator.generate_cell_anchors": [[178, 214], ["torch.tensor", "math.sqrt", "anchors.append"], "methods", ["None"], ["", "def", "generate_cell_anchors", "(", "self", ",", "sizes", "=", "(", "32", ",", "64", ",", "128", ",", "256", ",", "512", ")", ",", "aspect_ratios", "=", "(", "0.5", ",", "1", ",", "2", ")", ")", ":", "\n", "        ", "\"\"\"\n        Generate a tensor storing canonical anchor boxes, which are all anchor\n        boxes of different sizes and aspect_ratios centered at (0, 0).\n        We can later build the set of anchors for a full feature map by\n        shifting and tiling these tensors (see `meth:_grid_anchors`).\n\n        Args:\n            sizes (tuple[float]):\n            aspect_ratios (tuple[float]]):\n\n        Returns:\n            Tensor of shape (len(sizes) * len(aspect_ratios), 4) storing anchor boxes\n                in XYXY format.\n        \"\"\"", "\n", "\n", "# This is different from the anchor generator defined in the original Faster R-CNN", "\n", "# code or Detectron. They yield the same AP, however the old version defines cell", "\n", "# anchors in a less natural way with a shift relative to the feature grid and", "\n", "# quantization that results in slightly different sizes for different aspect ratios.", "\n", "# See also https://github.com/facebookresearch/Detectron/issues/227", "\n", "\n", "anchors", "=", "[", "]", "\n", "for", "size", "in", "sizes", ":", "\n", "            ", "area", "=", "size", "**", "2.0", "\n", "for", "aspect_ratio", "in", "aspect_ratios", ":", "\n", "# s * s = w * h", "\n", "# a = h / w", "\n", "# ... some algebra ...", "\n", "# w = sqrt(s * s / a)", "\n", "# h = a * w", "\n", "                ", "w", "=", "math", ".", "sqrt", "(", "area", "/", "aspect_ratio", ")", "\n", "h", "=", "aspect_ratio", "*", "w", "\n", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "-", "w", "/", "2.0", ",", "-", "h", "/", "2.0", ",", "w", "/", "2.0", ",", "h", "/", "2.0", "\n", "anchors", ".", "append", "(", "[", "x0", ",", "y0", ",", "x1", ",", "y1", "]", ")", "\n", "", "", "return", "torch", ".", "tensor", "(", "anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.DefaultAnchorGenerator.forward": [[215, 229], ["anchor_generator.DefaultAnchorGenerator._grid_anchors", "detectron2.structures.Boxes"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator._grid_anchors"], ["", "def", "forward", "(", "self", ",", "features", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[Boxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"", "\n", "grid_sizes", "=", "[", "feature_map", ".", "shape", "[", "-", "2", ":", "]", "for", "feature_map", "in", "features", "]", "\n", "anchors_over_all_feature_maps", "=", "self", ".", "_grid_anchors", "(", "grid_sizes", ")", "\n", "return", "[", "Boxes", "(", "x", ")", "for", "x", "in", "anchors_over_all_feature_maps", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator.__init__": [[243, 275], ["torch.nn.Module.__init__", "len", "anchor_generator._broadcast_params", "anchor_generator._broadcast_params", "anchor_generator._broadcast_params", "anchor_generator.RotatedAnchorGenerator._calculate_anchors"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator._broadcast_params", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator._calculate_anchors"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "sizes", ",", "aspect_ratios", ",", "strides", ",", "angles", ",", "offset", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        This interface is experimental.\n\n        Args:\n            sizes (list[list[float]] or list[float]):\n                If sizes is list[list[float]], sizes[i] is the list of anchor sizes\n                (i.e. sqrt of anchor area) to use for the i-th feature map.\n                If sizes is list[float], the sizes are used for all feature maps.\n                Anchor sizes are given in absolute lengths in units of\n                the input image; they do not dynamically scale if the input image size changes.\n            aspect_ratios (list[list[float]] or list[float]): list of aspect ratios\n                (i.e. height / width) to use for anchors. Same \"broadcast\" rule for `sizes` applies.\n            strides (list[int]): stride of each input feature.\n            angles (list[list[float]] or list[float]): list of angles (in degrees CCW)\n                to use for anchors. Same \"broadcast\" rule for `sizes` applies.\n            offset (float): Relative offset between the center of the first anchor and the top-left\n                corner of the image. Value has to be in [0, 1).\n                Recommend to use 0.5, which means half stride.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "num_features", "=", "len", "(", "self", ".", "strides", ")", "\n", "sizes", "=", "_broadcast_params", "(", "sizes", ",", "self", ".", "num_features", ",", "\"sizes\"", ")", "\n", "aspect_ratios", "=", "_broadcast_params", "(", "aspect_ratios", ",", "self", ".", "num_features", ",", "\"aspect_ratios\"", ")", "\n", "angles", "=", "_broadcast_params", "(", "angles", ",", "self", ".", "num_features", ",", "\"angles\"", ")", "\n", "self", ".", "cell_anchors", "=", "self", ".", "_calculate_anchors", "(", "sizes", ",", "aspect_ratios", ",", "angles", ")", "\n", "\n", "self", ".", "offset", "=", "offset", "\n", "assert", "0.0", "<=", "self", ".", "offset", "<", "1.0", ",", "self", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator.from_config": [[276, 284], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ":", "List", "[", "ShapeSpec", "]", ")", ":", "\n", "        ", "return", "{", "\n", "\"sizes\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", ",", "\n", "\"aspect_ratios\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", ",", "\n", "\"strides\"", ":", "[", "x", ".", "stride", "for", "x", "in", "input_shape", "]", ",", "\n", "\"offset\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "OFFSET", ",", "\n", "\"angles\"", ":", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ANGLES", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator._calculate_anchors": [[286, 292], ["anchor_generator.BufferList", "anchor_generator.RotatedAnchorGenerator.generate_cell_anchors().float", "zip", "anchor_generator.RotatedAnchorGenerator.generate_cell_anchors"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator.generate_cell_anchors"], ["", "def", "_calculate_anchors", "(", "self", ",", "sizes", ",", "aspect_ratios", ",", "angles", ")", ":", "\n", "        ", "cell_anchors", "=", "[", "\n", "self", ".", "generate_cell_anchors", "(", "size", ",", "aspect_ratio", ",", "angle", ")", ".", "float", "(", ")", "\n", "for", "size", ",", "aspect_ratio", ",", "angle", "in", "zip", "(", "sizes", ",", "aspect_ratios", ",", "angles", ")", "\n", "]", "\n", "return", "BufferList", "(", "cell_anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator.num_cell_anchors": [[293, 299], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_cell_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Alias of `num_anchors`.\n        \"\"\"", "\n", "return", "self", ".", "num_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator.num_anchors": [[300, 314], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[int]: Each int is the number of anchors at every pixel\n                location, on that feature map.\n                For example, if at every pixel we use anchors of 3 aspect\n                ratios, 2 sizes and 5 angles, the number of anchors is 30.\n                (See also ANCHOR_GENERATOR.SIZES, ANCHOR_GENERATOR.ASPECT_RATIOS\n                and ANCHOR_GENERATOR.ANGLES in config)\n\n                In standard RRPN models, `num_anchors` on every feature map is the same.\n        \"\"\"", "\n", "return", "[", "len", "(", "cell_anchors", ")", "for", "cell_anchors", "in", "self", ".", "cell_anchors", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator._grid_anchors": [[315, 325], ["zip", "anchor_generator._create_grid_offsets", "torch.zeros_like", "torch.stack", "anchors.append", "torch.stack.view", "base_anchors.view"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator._create_grid_offsets"], ["", "def", "_grid_anchors", "(", "self", ",", "grid_sizes", ")", ":", "\n", "        ", "anchors", "=", "[", "]", "\n", "for", "size", ",", "stride", ",", "base_anchors", "in", "zip", "(", "grid_sizes", ",", "self", ".", "strides", ",", "self", ".", "cell_anchors", ")", ":", "\n", "            ", "shift_x", ",", "shift_y", "=", "_create_grid_offsets", "(", "size", ",", "stride", ",", "self", ".", "offset", ",", "base_anchors", ".", "device", ")", "\n", "zeros", "=", "torch", ".", "zeros_like", "(", "shift_x", ")", "\n", "shifts", "=", "torch", ".", "stack", "(", "(", "shift_x", ",", "shift_y", ",", "zeros", ",", "zeros", ",", "zeros", ")", ",", "dim", "=", "1", ")", "\n", "\n", "anchors", ".", "append", "(", "(", "shifts", ".", "view", "(", "-", "1", ",", "1", ",", "5", ")", "+", "base_anchors", ".", "view", "(", "1", ",", "-", "1", ",", "5", ")", ")", ".", "reshape", "(", "-", "1", ",", "5", ")", ")", "\n", "\n", "", "return", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator.generate_cell_anchors": [[326, 361], ["torch.tensor", "math.sqrt", "anchors.extend"], "methods", ["None"], ["", "def", "generate_cell_anchors", "(", "\n", "self", ",", "\n", "sizes", "=", "(", "32", ",", "64", ",", "128", ",", "256", ",", "512", ")", ",", "\n", "aspect_ratios", "=", "(", "0.5", ",", "1", ",", "2", ")", ",", "\n", "angles", "=", "(", "-", "90", ",", "-", "60", ",", "-", "30", ",", "0", ",", "30", ",", "60", ",", "90", ")", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Generate a tensor storing canonical anchor boxes, which are all anchor\n        boxes of different sizes, aspect_ratios, angles centered at (0, 0).\n        We can later build the set of anchors for a full feature map by\n        shifting and tiling these tensors (see `meth:_grid_anchors`).\n\n        Args:\n            sizes (tuple[float]):\n            aspect_ratios (tuple[float]]):\n            angles (tuple[float]]):\n\n        Returns:\n            Tensor of shape (len(sizes) * len(aspect_ratios) * len(angles), 5)\n                storing anchor boxes in (x_ctr, y_ctr, w, h, angle) format.\n        \"\"\"", "\n", "anchors", "=", "[", "]", "\n", "for", "size", "in", "sizes", ":", "\n", "            ", "area", "=", "size", "**", "2.0", "\n", "for", "aspect_ratio", "in", "aspect_ratios", ":", "\n", "# s * s = w * h", "\n", "# a = h / w", "\n", "# ... some algebra ...", "\n", "# w = sqrt(s * s / a)", "\n", "# h = a * w", "\n", "                ", "w", "=", "math", ".", "sqrt", "(", "area", "/", "aspect_ratio", ")", "\n", "h", "=", "aspect_ratio", "*", "w", "\n", "anchors", ".", "extend", "(", "[", "0", ",", "0", ",", "w", ",", "h", ",", "a", "]", "for", "a", "in", "angles", ")", "\n", "\n", "", "", "return", "torch", ".", "tensor", "(", "anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator.forward": [[362, 376], ["anchor_generator.RotatedAnchorGenerator._grid_anchors", "detectron2.structures.RotatedBoxes"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.RotatedAnchorGenerator._grid_anchors"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[RotatedBoxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"", "\n", "grid_sizes", "=", "[", "feature_map", ".", "shape", "[", "-", "2", ":", "]", "for", "feature_map", "in", "features", "]", "\n", "anchors_over_all_feature_maps", "=", "self", ".", "_grid_anchors", "(", "grid_sizes", ")", "\n", "return", "[", "RotatedBoxes", "(", "x", ")", "for", "x", "in", "anchors_over_all_feature_maps", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator._create_grid_offsets": [[37, 50], ["torch.arange", "torch.arange", "torch.meshgrid", "shift_x.reshape.reshape", "shift_y.reshape.reshape"], "function", ["None"], ["", "", "def", "_create_grid_offsets", "(", "size", ":", "List", "[", "int", "]", ",", "stride", ":", "int", ",", "offset", ":", "float", ",", "device", ":", "torch", ".", "device", ")", ":", "\n", "    ", "grid_height", ",", "grid_width", "=", "size", "\n", "shifts_x", "=", "torch", ".", "arange", "(", "\n", "offset", "*", "stride", ",", "grid_width", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shifts_y", "=", "torch", ".", "arange", "(", "\n", "offset", "*", "stride", ",", "grid_height", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "\n", "shift_y", ",", "shift_x", "=", "torch", ".", "meshgrid", "(", "shifts_y", ",", "shifts_x", ")", "\n", "shift_x", "=", "shift_x", ".", "reshape", "(", "-", "1", ")", "\n", "shift_y", "=", "shift_y", ".", "reshape", "(", "-", "1", ")", "\n", "return", "shift_x", ",", "shift_y", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator._broadcast_params": [[52, 77], ["isinstance", "len", "isinstance", "len", "len", "list", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "_broadcast_params", "(", "params", ",", "num_features", ",", "name", ")", ":", "\n", "    ", "\"\"\"\n    If one size (or aspect ratio) is specified and there are multiple feature\n    maps, we \"broadcast\" anchors of that single size (or aspect ratio)\n    over all feature maps.\n\n    If params is list[float], or list[list[float]] with len(params) == 1, repeat\n    it num_features time.\n\n    Returns:\n        list[list[float]]: param for each feature\n    \"\"\"", "\n", "assert", "isinstance", "(", "\n", "params", ",", "(", "list", ",", "tuple", ")", "\n", ")", ",", "f\"{name} in anchor generator has to be a list! Got {params}.\"", "\n", "assert", "len", "(", "params", ")", ",", "f\"{name} in anchor generator cannot be empty!\"", "\n", "if", "not", "isinstance", "(", "params", "[", "0", "]", ",", "(", "list", ",", "tuple", ")", ")", ":", "# list[float]", "\n", "        ", "return", "[", "params", "]", "*", "num_features", "\n", "", "if", "len", "(", "params", ")", "==", "1", ":", "\n", "        ", "return", "list", "(", "params", ")", "*", "num_features", "\n", "", "assert", "len", "(", "params", ")", "==", "num_features", ",", "(", "\n", "f\"Got {name} of length {len(params)} in anchor generator, \"", "\n", "f\"but the number of input features is {num_features}!\"", "\n", ")", "\n", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.build_anchor_generator": [[378, 384], ["ANCHOR_GENERATOR_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "build_anchor_generator", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Built an anchor generator from `cfg.MODEL.ANCHOR_GENERATOR.NAME`.\n    \"\"\"", "\n", "anchor_generator", "=", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "NAME", "\n", "return", "ANCHOR_GENERATOR_REGISTRY", ".", "get", "(", "anchor_generator", ")", "(", "cfg", ",", "input_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DatasetMapperTTA.__init__": [[36, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "self", ".", "min_sizes", "=", "cfg", ".", "TEST", ".", "AUG", ".", "MIN_SIZES", "\n", "self", ".", "max_size", "=", "cfg", ".", "TEST", ".", "AUG", ".", "MAX_SIZE", "\n", "self", ".", "flip", "=", "cfg", ".", "TEST", ".", "AUG", ".", "FLIP", "\n", "self", ".", "image_format", "=", "cfg", ".", "INPUT", ".", "FORMAT", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DatasetMapperTTA.__call__": [[42, 83], ["dataset_dict[].permute().numpy", "detectron2.data.transforms.ResizeTransform", "fvcore.transforms.NoOpTransform", "detectron2.data.transforms.ResizeShortestEdge", "aug_candidates.append", "detectron2.data.transforms.apply_augmentations", "torch.from_numpy", "copy.deepcopy", "ret.append", "dataset_dict[].permute", "detectron2.data.transforms.RandomFlip", "aug_candidates.append", "numpy.copy", "numpy.ascontiguousarray", "new_image.transpose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.apply_augmentations"], ["", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dict: a dict in standard model input format. See tutorials for details.\n\n        Returns:\n            list[dict]:\n                a list of dicts, which contain augmented version of the input image.\n                The total number of dicts is ``len(min_sizes) * (2 if flip else 1)``.\n                Each dict has field \"transforms\" which is a TransformList,\n                containing the transforms that are used to generate this image.\n        \"\"\"", "\n", "numpy_image", "=", "dataset_dict", "[", "\"image\"", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "numpy", "(", ")", "\n", "shape", "=", "numpy_image", ".", "shape", "\n", "orig_shape", "=", "(", "dataset_dict", "[", "\"height\"", "]", ",", "dataset_dict", "[", "\"width\"", "]", ")", "\n", "if", "shape", "[", ":", "2", "]", "!=", "orig_shape", ":", "\n", "# It transforms the \"original\" image in the dataset to the input image", "\n", "            ", "pre_tfm", "=", "ResizeTransform", "(", "orig_shape", "[", "0", "]", ",", "orig_shape", "[", "1", "]", ",", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "pre_tfm", "=", "NoOpTransform", "(", ")", "\n", "\n", "# Create all combinations of augmentations to use", "\n", "", "aug_candidates", "=", "[", "]", "# each element is a list[Augmentation]", "\n", "for", "min_size", "in", "self", ".", "min_sizes", ":", "\n", "            ", "resize", "=", "ResizeShortestEdge", "(", "min_size", ",", "self", ".", "max_size", ")", "\n", "aug_candidates", ".", "append", "(", "[", "resize", "]", ")", "# resize only", "\n", "if", "self", ".", "flip", ":", "\n", "                ", "flip", "=", "RandomFlip", "(", "prob", "=", "1.0", ")", "\n", "aug_candidates", ".", "append", "(", "[", "resize", ",", "flip", "]", ")", "# resize + flip", "\n", "\n", "# Apply all the augmentations", "\n", "", "", "ret", "=", "[", "]", "\n", "for", "aug", "in", "aug_candidates", ":", "\n", "            ", "new_image", ",", "tfms", "=", "apply_augmentations", "(", "aug", ",", "np", ".", "copy", "(", "numpy_image", ")", ")", "\n", "torch_image", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "new_image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "\n", "dic", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "\n", "dic", "[", "\"transforms\"", "]", "=", "pre_tfm", "+", "tfms", "\n", "dic", "[", "\"image\"", "]", "=", "torch_image", "\n", "ret", ".", "append", "(", "dic", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA.__init__": [[91, 119], ["torch.nn.Module.__init__", "isinstance", "isinstance", "cfg.clone", "type", "test_time_augmentation.DatasetMapperTTA"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["def", "__init__", "(", "self", ",", "cfg", ",", "model", ",", "tta_mapper", "=", "None", ",", "batch_size", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            model (GeneralizedRCNN): a GeneralizedRCNN to apply TTA on.\n            tta_mapper (callable): takes a dataset dict and returns a list of\n                augmented versions of the dataset dict. Defaults to\n                `DatasetMapperTTA(cfg)`.\n            batch_size (int): batch the augmented images into this batch size for inference.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "model", ",", "DistributedDataParallel", ")", ":", "\n", "            ", "model", "=", "model", ".", "module", "\n", "", "assert", "isinstance", "(", "\n", "model", ",", "GeneralizedRCNN", "\n", ")", ",", "\"TTA is only supported on GeneralizedRCNN. Got a model of type {}\"", ".", "format", "(", "type", "(", "model", ")", ")", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "assert", "not", "self", ".", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ",", "\"TTA for keypoint is not supported yet\"", "\n", "assert", "(", "\n", "not", "self", ".", "cfg", ".", "MODEL", ".", "LOAD_PROPOSALS", "\n", ")", ",", "\"TTA for pre-computed proposals is not supported yet\"", "\n", "\n", "self", ".", "model", "=", "model", "\n", "\n", "if", "tta_mapper", "is", "None", ":", "\n", "            ", "tta_mapper", "=", "DatasetMapperTTA", "(", "cfg", ")", "\n", "", "self", ".", "tta_mapper", "=", "tta_mapper", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._turn_off_roi_heads": [[120, 145], ["len", "old.keys", "old.keys", "getattr", "old.keys", "setattr", "setattr"], "methods", ["None"], ["", "@", "contextmanager", "\n", "def", "_turn_off_roi_heads", "(", "self", ",", "attrs", ")", ":", "\n", "        ", "\"\"\"\n        Open a context where some heads in `model.roi_heads` are temporarily turned off.\n        Args:\n            attr (list[str]): the attribute in `model.roi_heads` which can be used\n                to turn off a specific head, e.g., \"mask_on\", \"keypoint_on\".\n        \"\"\"", "\n", "roi_heads", "=", "self", ".", "model", ".", "roi_heads", "\n", "old", "=", "{", "}", "\n", "for", "attr", "in", "attrs", ":", "\n", "            ", "try", ":", "\n", "                ", "old", "[", "attr", "]", "=", "getattr", "(", "roi_heads", ",", "attr", ")", "\n", "", "except", "AttributeError", ":", "\n", "# The head may not be implemented in certain ROIHeads", "\n", "                ", "pass", "\n", "\n", "", "", "if", "len", "(", "old", ".", "keys", "(", ")", ")", "==", "0", ":", "\n", "            ", "yield", "\n", "", "else", ":", "\n", "            ", "for", "attr", "in", "old", ".", "keys", "(", ")", ":", "\n", "                ", "setattr", "(", "roi_heads", ",", "attr", ",", "False", ")", "\n", "", "yield", "\n", "for", "attr", "in", "old", ".", "keys", "(", ")", ":", "\n", "                ", "setattr", "(", "roi_heads", ",", "attr", ",", "old", "[", "attr", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference": [[146, 171], ["zip", "itertools.count", "inputs.append", "instances.append", "len", "outputs.extend", "len", "test_time_augmentation.GeneralizedRCNNWithTTA.model.inference", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference"], ["", "", "", "def", "_batch_inference", "(", "self", ",", "batched_inputs", ",", "detected_instances", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Execute inference on a list of inputs,\n        using batch size = self.batch_size, instead of the length of the list.\n\n        Inputs & outputs have the same format as :meth:`GeneralizedRCNN.inference`\n        \"\"\"", "\n", "if", "detected_instances", "is", "None", ":", "\n", "            ", "detected_instances", "=", "[", "None", "]", "*", "len", "(", "batched_inputs", ")", "\n", "\n", "", "outputs", "=", "[", "]", "\n", "inputs", ",", "instances", "=", "[", "]", ",", "[", "]", "\n", "for", "idx", ",", "input", ",", "instance", "in", "zip", "(", "count", "(", ")", ",", "batched_inputs", ",", "detected_instances", ")", ":", "\n", "            ", "inputs", ".", "append", "(", "input", ")", "\n", "instances", ".", "append", "(", "instance", ")", "\n", "if", "len", "(", "inputs", ")", "==", "self", ".", "batch_size", "or", "idx", "==", "len", "(", "batched_inputs", ")", "-", "1", ":", "\n", "                ", "outputs", ".", "extend", "(", "\n", "self", ".", "model", ".", "inference", "(", "\n", "inputs", ",", "\n", "instances", "if", "instances", "[", "0", "]", "is", "not", "None", "else", "None", ",", "\n", "do_postprocess", "=", "False", ",", "\n", ")", "\n", ")", "\n", "inputs", ",", "instances", "=", "[", "]", ",", "[", "]", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA.__call__": [[172, 189], ["copy.copy", "test_time_augmentation.GeneralizedRCNNWithTTA._inference_one_image", "detectron2.data.detection_utils.read_image", "torch.from_numpy().permute", "test_time_augmentation.GeneralizedRCNNWithTTA.__call__._maybe_read_image"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._inference_one_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.read_image"], ["", "def", "__call__", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Same input/output format as :meth:`GeneralizedRCNN.forward`\n        \"\"\"", "\n", "\n", "def", "_maybe_read_image", "(", "dataset_dict", ")", ":", "\n", "            ", "ret", "=", "copy", ".", "copy", "(", "dataset_dict", ")", "\n", "if", "\"image\"", "not", "in", "ret", ":", "\n", "                ", "image", "=", "read_image", "(", "ret", ".", "pop", "(", "\"file_name\"", ")", ",", "self", ".", "tta_mapper", ".", "image_format", ")", "\n", "image", "=", "torch", ".", "from_numpy", "(", "image", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "# CHW", "\n", "ret", "[", "\"image\"", "]", "=", "image", "\n", "", "if", "\"height\"", "not", "in", "ret", "and", "\"width\"", "not", "in", "ret", ":", "\n", "                ", "ret", "[", "\"height\"", "]", "=", "image", ".", "shape", "[", "1", "]", "\n", "ret", "[", "\"width\"", "]", "=", "image", ".", "shape", "[", "2", "]", "\n", "", "return", "ret", "\n", "\n", "", "return", "[", "self", ".", "_inference_one_image", "(", "_maybe_read_image", "(", "x", ")", ")", "for", "x", "in", "batched_inputs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._inference_one_image": [[190, 222], ["test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_inputs", "test_time_augmentation.GeneralizedRCNNWithTTA._merge_detections", "test_time_augmentation.GeneralizedRCNNWithTTA._turn_off_roi_heads", "test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_boxes", "test_time_augmentation.GeneralizedRCNNWithTTA._rescale_detected_boxes", "test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "test_time_augmentation.GeneralizedRCNNWithTTA._reduce_pred_masks", "postprocessing.detector_postprocess"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_inputs", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._merge_detections", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._turn_off_roi_heads", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._rescale_detected_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._reduce_pred_masks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.detector_postprocess"], ["", "def", "_inference_one_image", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (dict): one dataset dict with \"image\" field being a CHW tensor\n\n        Returns:\n            dict: one output dict\n        \"\"\"", "\n", "orig_shape", "=", "(", "input", "[", "\"height\"", "]", ",", "input", "[", "\"width\"", "]", ")", "\n", "augmented_inputs", ",", "tfms", "=", "self", ".", "_get_augmented_inputs", "(", "input", ")", "\n", "# Detect boxes from all augmented versions", "\n", "with", "self", ".", "_turn_off_roi_heads", "(", "[", "\"mask_on\"", ",", "\"keypoint_on\"", "]", ")", ":", "\n", "# temporarily disable roi heads", "\n", "            ", "all_boxes", ",", "all_scores", ",", "all_classes", "=", "self", ".", "_get_augmented_boxes", "(", "augmented_inputs", ",", "tfms", ")", "\n", "# merge all detected boxes to obtain final predictions for boxes", "\n", "", "merged_instances", "=", "self", ".", "_merge_detections", "(", "all_boxes", ",", "all_scores", ",", "all_classes", ",", "orig_shape", ")", "\n", "\n", "if", "self", ".", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "# Use the detected boxes to obtain masks", "\n", "            ", "augmented_instances", "=", "self", ".", "_rescale_detected_boxes", "(", "\n", "augmented_inputs", ",", "merged_instances", ",", "tfms", "\n", ")", "\n", "# run forward on the detected boxes", "\n", "outputs", "=", "self", ".", "_batch_inference", "(", "augmented_inputs", ",", "augmented_instances", ")", "\n", "# Delete now useless variables to avoid being out of memory", "\n", "del", "augmented_inputs", ",", "augmented_instances", "\n", "# average the predictions", "\n", "merged_instances", ".", "pred_masks", "=", "self", ".", "_reduce_pred_masks", "(", "outputs", ",", "tfms", ")", "\n", "merged_instances", "=", "detector_postprocess", "(", "merged_instances", ",", "*", "orig_shape", ")", "\n", "return", "{", "\"instances\"", ":", "merged_instances", "}", "\n", "", "else", ":", "\n", "            ", "return", "{", "\"instances\"", ":", "merged_instances", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_inputs": [[223, 227], ["test_time_augmentation.GeneralizedRCNNWithTTA.tta_mapper", "x.pop"], "methods", ["None"], ["", "", "def", "_get_augmented_inputs", "(", "self", ",", "input", ")", ":", "\n", "        ", "augmented_inputs", "=", "self", ".", "tta_mapper", "(", "input", ")", "\n", "tfms", "=", "[", "x", ".", "pop", "(", "\"transforms\"", ")", "for", "x", "in", "augmented_inputs", "]", "\n", "return", "augmented_inputs", ",", "tfms", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_boxes": [[228, 245], ["test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "zip", "torch.cat", "tfm.inverse().apply_box", "torch.cat.append", "all_scores.extend", "all_classes.extend", "pred_boxes.cpu().numpy", "torch.from_numpy().to", "tfm.inverse", "pred_boxes.cpu", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.inverse"], ["", "def", "_get_augmented_boxes", "(", "self", ",", "augmented_inputs", ",", "tfms", ")", ":", "\n", "# 1: forward with all augmented images", "\n", "        ", "outputs", "=", "self", ".", "_batch_inference", "(", "augmented_inputs", ")", "\n", "# 2: union the results", "\n", "all_boxes", "=", "[", "]", "\n", "all_scores", "=", "[", "]", "\n", "all_classes", "=", "[", "]", "\n", "for", "output", ",", "tfm", "in", "zip", "(", "outputs", ",", "tfms", ")", ":", "\n", "# Need to inverse the transforms on boxes, to obtain results on original image", "\n", "            ", "pred_boxes", "=", "output", ".", "pred_boxes", ".", "tensor", "\n", "original_pred_boxes", "=", "tfm", ".", "inverse", "(", ")", ".", "apply_box", "(", "pred_boxes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "all_boxes", ".", "append", "(", "torch", ".", "from_numpy", "(", "original_pred_boxes", ")", ".", "to", "(", "pred_boxes", ".", "device", ")", ")", "\n", "\n", "all_scores", ".", "extend", "(", "output", ".", "scores", ")", "\n", "all_classes", ".", "extend", "(", "output", ".", "pred_classes", ")", "\n", "", "all_boxes", "=", "torch", ".", "cat", "(", "all_boxes", ",", "dim", "=", "0", ")", "\n", "return", "all_boxes", ",", "all_scores", ",", "all_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._merge_detections": [[246, 265], ["len", "torch.zeros", "zip", "roi_heads.fast_rcnn.fast_rcnn_inference_single_image", "itertools.count"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.fast_rcnn_inference_single_image"], ["", "def", "_merge_detections", "(", "self", ",", "all_boxes", ",", "all_scores", ",", "all_classes", ",", "shape_hw", ")", ":", "\n", "# select from the union of all results", "\n", "        ", "num_boxes", "=", "len", "(", "all_boxes", ")", "\n", "num_classes", "=", "self", ".", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "# +1 because fast_rcnn_inference expects background scores as well", "\n", "all_scores_2d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "num_classes", "+", "1", ",", "device", "=", "all_boxes", ".", "device", ")", "\n", "for", "idx", ",", "cls", ",", "score", "in", "zip", "(", "count", "(", ")", ",", "all_classes", ",", "all_scores", ")", ":", "\n", "            ", "all_scores_2d", "[", "idx", ",", "cls", "]", "=", "score", "\n", "\n", "", "merged_instances", ",", "_", "=", "fast_rcnn_inference_single_image", "(", "\n", "all_boxes", ",", "\n", "all_scores_2d", ",", "\n", "shape_hw", ",", "\n", "1e-8", ",", "\n", "self", ".", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NMS_THRESH_TEST", ",", "\n", "self", ".", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", ",", "\n", ")", "\n", "\n", "return", "merged_instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._rescale_detected_boxes": [[266, 281], ["zip", "merged_instances.pred_boxes.tensor.cpu().numpy", "torch.from_numpy", "detectron2.structures.Instances", "augmented_instances.append", "tfm.apply_box", "merged_instances.pred_boxes.tensor.cpu", "detectron2.structures.Boxes"], "methods", ["None"], ["", "def", "_rescale_detected_boxes", "(", "self", ",", "augmented_inputs", ",", "merged_instances", ",", "tfms", ")", ":", "\n", "        ", "augmented_instances", "=", "[", "]", "\n", "for", "input", ",", "tfm", "in", "zip", "(", "augmented_inputs", ",", "tfms", ")", ":", "\n", "# Transform the target box to the augmented image's coordinate space", "\n", "            ", "pred_boxes", "=", "merged_instances", ".", "pred_boxes", ".", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "tfm", ".", "apply_box", "(", "pred_boxes", ")", ")", "\n", "\n", "aug_instances", "=", "Instances", "(", "\n", "image_size", "=", "input", "[", "\"image\"", "]", ".", "shape", "[", "1", ":", "3", "]", ",", "\n", "pred_boxes", "=", "Boxes", "(", "pred_boxes", ")", ",", "\n", "pred_classes", "=", "merged_instances", ".", "pred_classes", ",", "\n", "scores", "=", "merged_instances", ".", "scores", ",", "\n", ")", "\n", "augmented_instances", ".", "append", "(", "aug_instances", ")", "\n", "", "return", "augmented_instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._reduce_pred_masks": [[282, 292], ["zip", "torch.stack", "torch.mean", "any", "output.pred_masks.flip", "isinstance"], "methods", ["None"], ["", "def", "_reduce_pred_masks", "(", "self", ",", "outputs", ",", "tfms", ")", ":", "\n", "# Should apply inverse transforms on masks.", "\n", "# We assume only resize & flip are used. pred_masks is a scale-invariant", "\n", "# representation, so we handle flip specially", "\n", "        ", "for", "output", ",", "tfm", "in", "zip", "(", "outputs", ",", "tfms", ")", ":", "\n", "            ", "if", "any", "(", "isinstance", "(", "t", ",", "HFlipTransform", ")", "for", "t", "in", "tfm", ".", "transforms", ")", ":", "\n", "                ", "output", ".", "pred_masks", "=", "output", ".", "pred_masks", ".", "flip", "(", "dims", "=", "[", "3", "]", ")", "\n", "", "", "all_pred_masks", "=", "torch", ".", "stack", "(", "[", "o", ".", "pred_masks", "for", "o", "in", "outputs", "]", ",", "dim", "=", "0", ")", "\n", "avg_pred_masks", "=", "torch", ".", "mean", "(", "all_pred_masks", ",", "dim", "=", "0", ")", "\n", "return", "avg_pred_masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.poolers.ROIPooler.__init__": [[104, 189], ["torch.nn.Module.__init__", "isinstance", "int", "int", "len", "isinstance", "isinstance", "torch.nn.ModuleList", "math.log2", "math.log2", "math.isclose", "math.isclose", "len", "torch.nn.ModuleList", "int", "int", "detectron2.layers.ROIAlign", "torch.nn.ModuleList", "detectron2.layers.ROIAlign", "torch.nn.ModuleList", "ValueError", "torchvision.ops.RoIPool", "detectron2.layers.ROIAlignRotated"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "output_size", ",", "\n", "scales", ",", "\n", "sampling_ratio", ",", "\n", "pooler_type", ",", "\n", "canonical_box_size", "=", "224", ",", "\n", "canonical_level", "=", "4", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            output_size (int, tuple[int] or list[int]): output size of the pooled region,\n                e.g., 14 x 14. If tuple or list is given, the length must be 2.\n            scales (list[float]): The scale for each low-level pooling op relative to\n                the input image. For a feature map with stride s relative to the input\n                image, scale is defined as a 1 / s. The stride must be power of 2.\n                When there are multiple scales, they must form a pyramid, i.e. they must be\n                a monotically decreasing geometric sequence with a factor of 1/2.\n            sampling_ratio (int): The `sampling_ratio` parameter for the ROIAlign op.\n            pooler_type (string): Name of the type of pooling operation that should be applied.\n                For instance, \"ROIPool\" or \"ROIAlignV2\".\n            canonical_box_size (int): A canonical box size in pixels (sqrt(box area)). The default\n                is heuristically defined as 224 pixels in the FPN paper (based on ImageNet\n                pre-training).\n            canonical_level (int): The feature map level index from which a canonically-sized box\n                should be placed. The default is defined as level 4 (stride=16) in the FPN paper,\n                i.e., a box of size 224x224 will be placed on the feature with stride=16.\n                The box placement for all boxes will be determined from their sizes w.r.t\n                canonical_box_size. For example, a box whose area is 4x that of a canonical box\n                should be used to pool features from feature level ``canonical_level+1``.\n\n                Note that the actual input feature maps given to this module may not have\n                sufficiently many levels for the input boxes. If the boxes are too large or too\n                small for the input feature maps, the closest level will be used.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "isinstance", "(", "output_size", ",", "int", ")", ":", "\n", "            ", "output_size", "=", "(", "output_size", ",", "output_size", ")", "\n", "", "assert", "len", "(", "output_size", ")", "==", "2", "\n", "assert", "isinstance", "(", "output_size", "[", "0", "]", ",", "int", ")", "and", "isinstance", "(", "output_size", "[", "1", "]", ",", "int", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "\n", "if", "pooler_type", "==", "\"ROIAlign\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "ROIAlign", "(", "\n", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", ",", "aligned", "=", "False", "\n", ")", "\n", "for", "scale", "in", "scales", "\n", ")", "\n", "", "elif", "pooler_type", "==", "\"ROIAlignV2\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "ROIAlign", "(", "\n", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", ",", "aligned", "=", "True", "\n", ")", "\n", "for", "scale", "in", "scales", "\n", ")", "\n", "", "elif", "pooler_type", "==", "\"ROIPool\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "RoIPool", "(", "output_size", ",", "spatial_scale", "=", "scale", ")", "for", "scale", "in", "scales", "\n", ")", "\n", "", "elif", "pooler_type", "==", "\"ROIAlignRotated\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "ROIAlignRotated", "(", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", ")", "\n", "for", "scale", "in", "scales", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown pooler type: {}\"", ".", "format", "(", "pooler_type", ")", ")", "\n", "\n", "# Map scale (defined as 1 / stride) to its feature map level under the", "\n", "# assumption that stride is a power of 2.", "\n", "", "min_level", "=", "-", "(", "math", ".", "log2", "(", "scales", "[", "0", "]", ")", ")", "\n", "max_level", "=", "-", "(", "math", ".", "log2", "(", "scales", "[", "-", "1", "]", ")", ")", "\n", "assert", "math", ".", "isclose", "(", "min_level", ",", "int", "(", "min_level", ")", ")", "and", "math", ".", "isclose", "(", "\n", "max_level", ",", "int", "(", "max_level", ")", "\n", ")", ",", "\"Featuremap stride is not power of 2!\"", "\n", "self", ".", "min_level", "=", "int", "(", "min_level", ")", "\n", "self", ".", "max_level", "=", "int", "(", "max_level", ")", "\n", "assert", "(", "\n", "len", "(", "scales", ")", "==", "self", ".", "max_level", "-", "self", ".", "min_level", "+", "1", "\n", ")", ",", "\"[ROIPooler] Sizes of input featuremaps do not form a pyramid!\"", "\n", "assert", "0", "<=", "self", ".", "min_level", "and", "self", ".", "min_level", "<=", "self", ".", "max_level", "\n", "self", ".", "canonical_level", "=", "canonical_level", "\n", "assert", "canonical_box_size", ">", "0", "\n", "self", ".", "canonical_box_size", "=", "canonical_box_size", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.poolers.ROIPooler.forward": [[190, 250], ["len", "poolers.convert_boxes_to_pooler_format", "poolers.assign_boxes_to_levels", "len", "torch.zeros", "enumerate", "isinstance", "isinstance", "len", "len", "len", "x[].size", "x[].size", "len", "len", "torch.zeros", "pooler", "detectron2.layers.nonzero_tuple"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.poolers.convert_boxes_to_pooler_format", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.poolers.assign_boxes_to_levels", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.nonzero_tuple"], ["", "def", "forward", "(", "self", ",", "x", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "box_lists", ":", "List", "[", "Boxes", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (list[Tensor]): A list of feature maps of NCHW shape, with scales matching those\n                used to construct this module.\n            box_lists (list[Boxes] | list[RotatedBoxes]):\n                A list of N Boxes or N RotatedBoxes, where N is the number of images in the batch.\n                The box coordinates are defined on the original image and\n                will be scaled by the `scales` argument of :class:`ROIPooler`.\n\n        Returns:\n            Tensor:\n                A tensor of shape (M, C, output_size, output_size) where M is the total number of\n                boxes aggregated over all N batch images and C is the number of channels in `x`.\n        \"\"\"", "\n", "num_level_assignments", "=", "len", "(", "self", ".", "level_poolers", ")", "\n", "\n", "assert", "isinstance", "(", "x", ",", "list", ")", "and", "isinstance", "(", "\n", "box_lists", ",", "list", "\n", ")", ",", "\"Arguments to pooler must be lists\"", "\n", "assert", "(", "\n", "len", "(", "x", ")", "==", "num_level_assignments", "\n", ")", ",", "\"unequal value, num_level_assignments={}, but x is list of {} Tensors\"", ".", "format", "(", "\n", "num_level_assignments", ",", "len", "(", "x", ")", "\n", ")", "\n", "\n", "assert", "len", "(", "box_lists", ")", "==", "x", "[", "0", "]", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"unequal value, x[0] batch dim 0 is {}, but box_list has length {}\"", ".", "format", "(", "\n", "x", "[", "0", "]", ".", "size", "(", "0", ")", ",", "len", "(", "box_lists", ")", "\n", ")", "\n", "if", "len", "(", "box_lists", ")", "==", "0", ":", "\n", "            ", "return", "torch", ".", "zeros", "(", "\n", "(", "0", ",", "x", "[", "0", "]", ".", "shape", "[", "1", "]", ")", "+", "self", ".", "output_size", ",", "device", "=", "x", "[", "0", "]", ".", "device", ",", "dtype", "=", "x", "[", "0", "]", ".", "dtype", "\n", ")", "\n", "\n", "", "pooler_fmt_boxes", "=", "convert_boxes_to_pooler_format", "(", "box_lists", ")", "\n", "\n", "if", "num_level_assignments", "==", "1", ":", "\n", "            ", "return", "self", ".", "level_poolers", "[", "0", "]", "(", "x", "[", "0", "]", ",", "pooler_fmt_boxes", ")", "\n", "\n", "", "level_assignments", "=", "assign_boxes_to_levels", "(", "\n", "box_lists", ",", "self", ".", "min_level", ",", "self", ".", "max_level", ",", "self", ".", "canonical_box_size", ",", "self", ".", "canonical_level", "\n", ")", "\n", "\n", "num_boxes", "=", "len", "(", "pooler_fmt_boxes", ")", "\n", "num_channels", "=", "x", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "output_size", "=", "self", ".", "output_size", "[", "0", "]", "\n", "\n", "dtype", ",", "device", "=", "x", "[", "0", "]", ".", "dtype", ",", "x", "[", "0", "]", ".", "device", "\n", "output", "=", "torch", ".", "zeros", "(", "\n", "(", "num_boxes", ",", "num_channels", ",", "output_size", ",", "output_size", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", "\n", ")", "\n", "\n", "for", "level", ",", "pooler", "in", "enumerate", "(", "self", ".", "level_poolers", ")", ":", "\n", "            ", "inds", "=", "nonzero_tuple", "(", "level_assignments", "==", "level", ")", "[", "0", "]", "\n", "pooler_fmt_boxes_level", "=", "pooler_fmt_boxes", "[", "inds", "]", "\n", "output", "[", "inds", "]", "=", "pooler", "(", "x", "[", "level", "]", ",", "pooler_fmt_boxes_level", ")", "\n", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.poolers.assign_boxes_to_levels": [[22, 59], ["torch.sqrt", "torch.floor", "torch.clamp", "detectron2.layers.cat", "torch.clamp.to", "torch.log2", "boxes.area"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area"], ["def", "assign_boxes_to_levels", "(", "\n", "box_lists", ":", "List", "[", "Boxes", "]", ",", "\n", "min_level", ":", "int", ",", "\n", "max_level", ":", "int", ",", "\n", "canonical_box_size", ":", "int", ",", "\n", "canonical_level", ":", "int", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Map each box in `box_lists` to a feature map level index and return the assignment\n    vector.\n\n    Args:\n        box_lists (list[Boxes] | list[RotatedBoxes]): A list of N Boxes or N RotatedBoxes,\n            where N is the number of images in the batch.\n        min_level (int): Smallest feature map level index. The input is considered index 0,\n            the output of stage 1 is index 1, and so.\n        max_level (int): Largest feature map level index.\n        canonical_box_size (int): A canonical box size in pixels (sqrt(box area)).\n        canonical_level (int): The feature map level index on which a canonically-sized box\n            should be placed.\n\n    Returns:\n        A tensor of length M, where M is the total number of boxes aggregated over all\n            N batch images. The memory layout corresponds to the concatenation of boxes\n            from all images. Each element is the feature map index, as an offset from\n            `self.min_level`, for the corresponding box (so value i means the box is at\n            `self.min_level + i`).\n    \"\"\"", "\n", "box_sizes", "=", "torch", ".", "sqrt", "(", "cat", "(", "[", "boxes", ".", "area", "(", ")", "for", "boxes", "in", "box_lists", "]", ")", ")", "\n", "# Eqn.(1) in FPN paper", "\n", "level_assignments", "=", "torch", ".", "floor", "(", "\n", "canonical_level", "+", "torch", ".", "log2", "(", "box_sizes", "/", "canonical_box_size", "+", "1e-8", ")", "\n", ")", "\n", "# clamp level to (min, max), in case the box size is too large or too small", "\n", "# for the available feature maps", "\n", "level_assignments", "=", "torch", ".", "clamp", "(", "level_assignments", ",", "min", "=", "min_level", ",", "max", "=", "max_level", ")", "\n", "return", "level_assignments", ".", "to", "(", "torch", ".", "int64", ")", "-", "min_level", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.poolers._fmt_box_list": [[61, 66], ["torch.full", "detectron2.layers.cat", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "_fmt_box_list", "(", "box_tensor", ",", "batch_index", ":", "int", ")", ":", "\n", "    ", "repeated_index", "=", "torch", ".", "full", "(", "\n", "(", "len", "(", "box_tensor", ")", ",", "1", ")", ",", "batch_index", ",", "dtype", "=", "box_tensor", ".", "dtype", ",", "device", "=", "box_tensor", ".", "device", "\n", ")", "\n", "return", "cat", "(", "(", "repeated_index", ",", "box_tensor", ")", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.poolers.convert_boxes_to_pooler_format": [[68, 96], ["detectron2.layers.cat", "poolers._fmt_box_list", "enumerate"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.poolers._fmt_box_list"], ["", "def", "convert_boxes_to_pooler_format", "(", "box_lists", ":", "List", "[", "Boxes", "]", ")", ":", "\n", "    ", "\"\"\"\n    Convert all boxes in `box_lists` to the low-level format used by ROI pooling ops\n    (see description under Returns).\n\n    Args:\n        box_lists (list[Boxes] | list[RotatedBoxes]):\n            A list of N Boxes or N RotatedBoxes, where N is the number of images in the batch.\n\n    Returns:\n        When input is list[Boxes]:\n            A tensor of shape (M, 5), where M is the total number of boxes aggregated over all\n            N batch images.\n            The 5 columns are (batch index, x0, y0, x1, y1), where batch index\n            is the index in [0, N) identifying which batch image the box with corners at\n            (x0, y0, x1, y1) comes from.\n        When input is list[RotatedBoxes]:\n            A tensor of shape (M, 6), where M is the total number of boxes aggregated over all\n            N batch images.\n            The 6 columns are (batch index, x_ctr, y_ctr, width, height, angle_degrees),\n            where batch index is the index in [0, N) identifying which batch image the\n            rotated box (x_ctr, y_ctr, width, height, angle_degrees) comes from.\n    \"\"\"", "\n", "pooler_fmt_boxes", "=", "cat", "(", "\n", "[", "_fmt_box_list", "(", "box_list", ".", "tensor", ",", "i", ")", "for", "i", ",", "box_list", "in", "enumerate", "(", "box_lists", ")", "]", ",", "dim", "=", "0", "\n", ")", "\n", "\n", "return", "pooler_fmt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransform.__init__": [[23, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "weights", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "scale_clamp", ":", "float", "=", "_DEFAULT_SCALE_CLAMP", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            weights (4-element tuple): Scaling factors that are applied to the\n                (dx, dy, dw, dh) deltas. In Fast R-CNN, these were originally set\n                such that the deltas have unit variance; now they are treated as\n                hyperparameters of the system.\n            scale_clamp (float): When predicting deltas, the predicted box scaling\n                factors (dw and dh) are clamped such that they are <= scale_clamp.\n        \"\"\"", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "scale_clamp", "=", "scale_clamp", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransform.get_deltas": [[38, 72], ["isinstance", "type", "isinstance", "type", "torch.stack", "torch.log", "torch.log"], "methods", ["None"], ["", "def", "get_deltas", "(", "self", ",", "src_boxes", ",", "target_boxes", ")", ":", "\n", "        ", "\"\"\"\n        Get box regression transformation deltas (dx, dy, dw, dh) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true (unless\n        any delta is too large and is clamped).\n\n        Args:\n            src_boxes (Tensor): source boxes, e.g., object proposals\n            target_boxes (Tensor): target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"", "\n", "assert", "isinstance", "(", "src_boxes", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "src_boxes", ")", "\n", "assert", "isinstance", "(", "target_boxes", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "target_boxes", ")", "\n", "\n", "src_widths", "=", "src_boxes", "[", ":", ",", "2", "]", "-", "src_boxes", "[", ":", ",", "0", "]", "\n", "src_heights", "=", "src_boxes", "[", ":", ",", "3", "]", "-", "src_boxes", "[", ":", ",", "1", "]", "\n", "src_ctr_x", "=", "src_boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "src_widths", "\n", "src_ctr_y", "=", "src_boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "src_heights", "\n", "\n", "target_widths", "=", "target_boxes", "[", ":", ",", "2", "]", "-", "target_boxes", "[", ":", ",", "0", "]", "\n", "target_heights", "=", "target_boxes", "[", ":", ",", "3", "]", "-", "target_boxes", "[", ":", ",", "1", "]", "\n", "target_ctr_x", "=", "target_boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "target_widths", "\n", "target_ctr_y", "=", "target_boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "target_heights", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", "=", "self", ".", "weights", "\n", "dx", "=", "wx", "*", "(", "target_ctr_x", "-", "src_ctr_x", ")", "/", "src_widths", "\n", "dy", "=", "wy", "*", "(", "target_ctr_y", "-", "src_ctr_y", ")", "/", "src_heights", "\n", "dw", "=", "ww", "*", "torch", ".", "log", "(", "target_widths", "/", "src_widths", ")", "\n", "dh", "=", "wh", "*", "torch", ".", "log", "(", "target_heights", "/", "src_heights", ")", "\n", "\n", "deltas", "=", "torch", ".", "stack", "(", "(", "dx", ",", "dy", ",", "dw", ",", "dh", ")", ",", "dim", "=", "1", ")", "\n", "assert", "(", "src_widths", ">", "0", ")", ".", "all", "(", ")", ".", "item", "(", ")", ",", "\"Input boxes to Box2BoxTransform are not valid!\"", "\n", "return", "deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransform.apply_deltas": [[73, 111], ["boxes.to.to.to", "torch.clamp", "torch.clamp", "torch.zeros_like", "torch.exp", "torch.exp"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "apply_deltas", "(", "self", ",", "deltas", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"\n        Apply transformation `deltas` (dx, dy, dw, dh) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*4), where k >= 1.\n                deltas[i] represents k potentially different class-specific\n                box transformations for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 4)\n        \"\"\"", "\n", "boxes", "=", "boxes", ".", "to", "(", "deltas", ".", "dtype", ")", "\n", "\n", "widths", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "heights", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "ctr_x", "=", "boxes", "[", ":", ",", "0", "]", "+", "0.5", "*", "widths", "\n", "ctr_y", "=", "boxes", "[", ":", ",", "1", "]", "+", "0.5", "*", "heights", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", "=", "self", ".", "weights", "\n", "dx", "=", "deltas", "[", ":", ",", "0", ":", ":", "4", "]", "/", "wx", "\n", "dy", "=", "deltas", "[", ":", ",", "1", ":", ":", "4", "]", "/", "wy", "\n", "dw", "=", "deltas", "[", ":", ",", "2", ":", ":", "4", "]", "/", "ww", "\n", "dh", "=", "deltas", "[", ":", ",", "3", ":", ":", "4", "]", "/", "wh", "\n", "\n", "# Prevent sending too large values into torch.exp()", "\n", "dw", "=", "torch", ".", "clamp", "(", "dw", ",", "max", "=", "self", ".", "scale_clamp", ")", "\n", "dh", "=", "torch", ".", "clamp", "(", "dh", ",", "max", "=", "self", ".", "scale_clamp", ")", "\n", "\n", "pred_ctr_x", "=", "dx", "*", "widths", "[", ":", ",", "None", "]", "+", "ctr_x", "[", ":", ",", "None", "]", "\n", "pred_ctr_y", "=", "dy", "*", "heights", "[", ":", ",", "None", "]", "+", "ctr_y", "[", ":", ",", "None", "]", "\n", "pred_w", "=", "torch", ".", "exp", "(", "dw", ")", "*", "widths", "[", ":", ",", "None", "]", "\n", "pred_h", "=", "torch", ".", "exp", "(", "dh", ")", "*", "heights", "[", ":", ",", "None", "]", "\n", "\n", "pred_boxes", "=", "torch", ".", "zeros_like", "(", "deltas", ")", "\n", "pred_boxes", "[", ":", ",", "0", ":", ":", "4", "]", "=", "pred_ctr_x", "-", "0.5", "*", "pred_w", "# x1", "\n", "pred_boxes", "[", ":", ",", "1", ":", ":", "4", "]", "=", "pred_ctr_y", "-", "0.5", "*", "pred_h", "# y1", "\n", "pred_boxes", "[", ":", ",", "2", ":", ":", "4", "]", "=", "pred_ctr_x", "+", "0.5", "*", "pred_w", "# x2", "\n", "pred_boxes", "[", ":", ",", "3", ":", ":", "4", "]", "=", "pred_ctr_y", "+", "0.5", "*", "pred_h", "# y2", "\n", "return", "pred_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.__init__": [[123, 138], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "weights", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "scale_clamp", ":", "float", "=", "_DEFAULT_SCALE_CLAMP", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            weights (5-element tuple): Scaling factors that are applied to the\n                (dx, dy, dw, dh, da) deltas. These are treated as\n                hyperparameters of the system.\n            scale_clamp (float): When predicting deltas, the predicted box scaling\n                factors (dw and dh) are clamped such that they are <= scale_clamp.\n        \"\"\"", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "scale_clamp", "=", "scale_clamp", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.get_deltas": [[139, 176], ["isinstance", "type", "isinstance", "type", "torch.unbind", "torch.unbind", "torch.stack", "torch.log", "torch.log"], "methods", ["None"], ["", "def", "get_deltas", "(", "self", ",", "src_boxes", ",", "target_boxes", ")", ":", "\n", "        ", "\"\"\"\n        Get box regression transformation deltas (dx, dy, dw, dh, da) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true (unless\n        any delta is too large and is clamped).\n\n        Args:\n            src_boxes (Tensor): Nx5 source boxes, e.g., object proposals\n            target_boxes (Tensor): Nx5 target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"", "\n", "assert", "isinstance", "(", "src_boxes", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "src_boxes", ")", "\n", "assert", "isinstance", "(", "target_boxes", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "target_boxes", ")", "\n", "\n", "src_ctr_x", ",", "src_ctr_y", ",", "src_widths", ",", "src_heights", ",", "src_angles", "=", "torch", ".", "unbind", "(", "src_boxes", ",", "dim", "=", "1", ")", "\n", "\n", "target_ctr_x", ",", "target_ctr_y", ",", "target_widths", ",", "target_heights", ",", "target_angles", "=", "torch", ".", "unbind", "(", "\n", "target_boxes", ",", "dim", "=", "1", "\n", ")", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", ",", "wa", "=", "self", ".", "weights", "\n", "dx", "=", "wx", "*", "(", "target_ctr_x", "-", "src_ctr_x", ")", "/", "src_widths", "\n", "dy", "=", "wy", "*", "(", "target_ctr_y", "-", "src_ctr_y", ")", "/", "src_heights", "\n", "dw", "=", "ww", "*", "torch", ".", "log", "(", "target_widths", "/", "src_widths", ")", "\n", "dh", "=", "wh", "*", "torch", ".", "log", "(", "target_heights", "/", "src_heights", ")", "\n", "# Angles of deltas are in radians while angles of boxes are in degrees.", "\n", "# the conversion to radians serve as a way to normalize the values", "\n", "da", "=", "target_angles", "-", "src_angles", "\n", "da", "=", "(", "da", "+", "180.0", ")", "%", "360.0", "-", "180.0", "# make it in [-180, 180)", "\n", "da", "*=", "wa", "*", "math", ".", "pi", "/", "180.0", "\n", "\n", "deltas", "=", "torch", ".", "stack", "(", "(", "dx", ",", "dy", ",", "dw", ",", "dh", ",", "da", ")", ",", "dim", "=", "1", ")", "\n", "assert", "(", "\n", "(", "src_widths", ">", "0", ")", ".", "all", "(", ")", ".", "item", "(", ")", "\n", ")", ",", "\"Input boxes to Box2BoxTransformRotated are not valid!\"", "\n", "return", "deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas": [[177, 222], ["boxes.to().unsqueeze.to().unsqueeze.to().unsqueeze", "torch.clamp", "torch.clamp", "torch.zeros_like", "torch.exp", "torch.exp", "boxes.to().unsqueeze.to().unsqueeze.to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "apply_deltas", "(", "self", ",", "deltas", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"\n        Apply transformation `deltas` (dx, dy, dw, dh, da) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*5).\n                deltas[i] represents box transformation for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 5)\n        \"\"\"", "\n", "assert", "deltas", ".", "shape", "[", "1", "]", "%", "5", "==", "0", "and", "boxes", ".", "shape", "[", "1", "]", "==", "5", "\n", "\n", "boxes", "=", "boxes", ".", "to", "(", "deltas", ".", "dtype", ")", ".", "unsqueeze", "(", "2", ")", "\n", "\n", "ctr_x", "=", "boxes", "[", ":", ",", "0", "]", "\n", "ctr_y", "=", "boxes", "[", ":", ",", "1", "]", "\n", "widths", "=", "boxes", "[", ":", ",", "2", "]", "\n", "heights", "=", "boxes", "[", ":", ",", "3", "]", "\n", "angles", "=", "boxes", "[", ":", ",", "4", "]", "\n", "\n", "wx", ",", "wy", ",", "ww", ",", "wh", ",", "wa", "=", "self", ".", "weights", "\n", "\n", "dx", "=", "deltas", "[", ":", ",", "0", ":", ":", "5", "]", "/", "wx", "\n", "dy", "=", "deltas", "[", ":", ",", "1", ":", ":", "5", "]", "/", "wy", "\n", "dw", "=", "deltas", "[", ":", ",", "2", ":", ":", "5", "]", "/", "ww", "\n", "dh", "=", "deltas", "[", ":", ",", "3", ":", ":", "5", "]", "/", "wh", "\n", "da", "=", "deltas", "[", ":", ",", "4", ":", ":", "5", "]", "/", "wa", "\n", "\n", "# Prevent sending too large values into torch.exp()", "\n", "dw", "=", "torch", ".", "clamp", "(", "dw", ",", "max", "=", "self", ".", "scale_clamp", ")", "\n", "dh", "=", "torch", ".", "clamp", "(", "dh", ",", "max", "=", "self", ".", "scale_clamp", ")", "\n", "\n", "pred_boxes", "=", "torch", ".", "zeros_like", "(", "deltas", ")", "\n", "pred_boxes", "[", ":", ",", "0", ":", ":", "5", "]", "=", "dx", "*", "widths", "+", "ctr_x", "# x_ctr", "\n", "pred_boxes", "[", ":", ",", "1", ":", ":", "5", "]", "=", "dy", "*", "heights", "+", "ctr_y", "# y_ctr", "\n", "pred_boxes", "[", ":", ",", "2", ":", ":", "5", "]", "=", "torch", ".", "exp", "(", "dw", ")", "*", "widths", "# width", "\n", "pred_boxes", "[", ":", ",", "3", ":", ":", "5", "]", "=", "torch", ".", "exp", "(", "dh", ")", "*", "heights", "# height", "\n", "\n", "# Following original RRPN implementation,", "\n", "# angles of deltas are in radians while angles of boxes are in degrees.", "\n", "pred_angle", "=", "da", "*", "180.0", "/", "math", ".", "pi", "+", "angles", "\n", "pred_angle", "=", "(", "pred_angle", "+", "180.0", ")", "%", "360.0", "-", "180.0", "# make it in [-180, 180)", "\n", "\n", "pred_boxes", "[", ":", ",", "4", ":", ":", "5", "]", "=", "pred_angle", "\n", "\n", "return", "pred_boxes", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.sampling.subsample_labels": [[9, 55], ["int", "min", "min", "detectron2.layers.nonzero_tuple", "detectron2.layers.nonzero_tuple", "positive.numel", "negative.numel", "torch.randperm", "torch.randperm", "positive.numel", "negative.numel"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.nonzero_tuple", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.nonzero_tuple"], ["def", "subsample_labels", "(", "\n", "labels", ":", "torch", ".", "Tensor", ",", "num_samples", ":", "int", ",", "positive_fraction", ":", "float", ",", "bg_label", ":", "int", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Return `num_samples` (or fewer, if not enough found)\n    random samples from `labels` which is a mixture of positives & negatives.\n    It will try to return as many positives as possible without\n    exceeding `positive_fraction * num_samples`, and then try to\n    fill the remaining slots with negatives.\n\n    Args:\n        labels (Tensor): (N, ) label vector with values:\n            * -1: ignore\n            * bg_label: background (\"negative\") class\n            * otherwise: one or more foreground (\"positive\") classes\n        num_samples (int): The total number of labels with value >= 0 to return.\n            Values that are not sampled will be filled with -1 (ignore).\n        positive_fraction (float): The number of subsampled labels with values > 0\n            is `min(num_positives, int(positive_fraction * num_samples))`. The number\n            of negatives sampled is `min(num_negatives, num_samples - num_positives_sampled)`.\n            In order words, if there are not enough positives, the sample is filled with\n            negatives. If there are also not enough negatives, then as many elements are\n            sampled as is possible.\n        bg_label (int): label index of background (\"negative\") class.\n\n    Returns:\n        pos_idx, neg_idx (Tensor):\n            1D vector of indices. The total length of both is `num_samples` or fewer.\n    \"\"\"", "\n", "positive", "=", "nonzero_tuple", "(", "(", "labels", "!=", "-", "1", ")", "&", "(", "labels", "!=", "bg_label", ")", ")", "[", "0", "]", "\n", "negative", "=", "nonzero_tuple", "(", "labels", "==", "bg_label", ")", "[", "0", "]", "\n", "\n", "num_pos", "=", "int", "(", "num_samples", "*", "positive_fraction", ")", "\n", "# protect against not enough positive examples", "\n", "num_pos", "=", "min", "(", "positive", ".", "numel", "(", ")", ",", "num_pos", ")", "\n", "num_neg", "=", "num_samples", "-", "num_pos", "\n", "# protect against not enough negative examples", "\n", "num_neg", "=", "min", "(", "negative", ".", "numel", "(", ")", ",", "num_neg", ")", "\n", "\n", "# randomly select positive and negative examples", "\n", "perm1", "=", "torch", ".", "randperm", "(", "positive", ".", "numel", "(", ")", ",", "device", "=", "positive", ".", "device", ")", "[", ":", "num_pos", "]", "\n", "perm2", "=", "torch", ".", "randperm", "(", "negative", ".", "numel", "(", ")", ",", "device", "=", "negative", ".", "device", ")", "[", ":", "num_neg", "]", "\n", "\n", "pos_idx", "=", "positive", "[", "perm1", "]", "\n", "neg_idx", "=", "negative", "[", "perm2", "]", "\n", "return", "pos_idx", ",", "neg_idx", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.densepose_checkpoint.DensePoseCheckpointer.__init__": [[27, 29], ["detectron2.checkpoint.DetectionCheckpointer.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "save_dir", "=", "\"\"", ",", "*", ",", "save_to_disk", "=", "None", ",", "**", "checkpointables", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "model", ",", "save_dir", ",", "save_to_disk", "=", "save_to_disk", ",", "**", "checkpointables", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.densepose_checkpoint.DensePoseCheckpointer._load_file": [[30, 36], ["super()._load_file", "densepose_checkpoint._rename_HRNet_weights"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.detection_checkpoint.DetectionCheckpointer._load_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.densepose_checkpoint._rename_HRNet_weights"], ["", "def", "_load_file", "(", "self", ",", "filename", ":", "str", ")", "->", "object", ":", "\n", "        ", "\"\"\"\n        Adding hrnet support\n        \"\"\"", "\n", "weights", "=", "super", "(", ")", ".", "_load_file", "(", "filename", ")", "\n", "return", "_rename_HRNet_weights", "(", "weights", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.densepose_checkpoint._rename_HRNet_weights": [[7, 20], ["collections.OrderedDict", "weights[].keys", "len", "len", "weights[].keys", "weights[].keys", "k.startswith", "str"], "function", ["None"], ["def", "_rename_HRNet_weights", "(", "weights", ")", ":", "\n", "# We detect and  rename HRNet weights for DensePose. 1956 and 1716 are values that are", "\n", "# common to all HRNet pretrained weights, and should be enough to accurately identify them", "\n", "    ", "if", "(", "\n", "len", "(", "weights", "[", "\"model\"", "]", ".", "keys", "(", ")", ")", "==", "1956", "\n", "and", "len", "(", "[", "k", "for", "k", "in", "weights", "[", "\"model\"", "]", ".", "keys", "(", ")", "if", "k", ".", "startswith", "(", "\"stage\"", ")", "]", ")", "==", "1716", "\n", ")", ":", "\n", "        ", "hrnet_weights", "=", "OrderedDict", "(", ")", "\n", "for", "k", "in", "weights", "[", "\"model\"", "]", ".", "keys", "(", ")", ":", "\n", "            ", "hrnet_weights", "[", "\"backbone.bottom_up.\"", "+", "str", "(", "k", ")", "]", "=", "weights", "[", "\"model\"", "]", "[", "k", "]", "\n", "", "return", "{", "\"model\"", ":", "hrnet_weights", "}", "\n", "", "else", ":", "\n", "        ", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.build.build_densepose_predictor": [[10, 22], ["predictors.DensePoseChartWithConfidencePredictor"], "function", ["None"], ["\n", "\n", "\n", "def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.build.build_densepose_data_filter": [[24, 38], ["filter.DensePoseDataFilter"], "function", ["None"], ["", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.build.build_densepose_head": [[40, 54], ["ROI_DENSEPOSE_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.build.build_densepose_losses": [[56, 67], ["losses.DensePoseLosses"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.inference.densepose_inference": [[10, 84], ["len", "locals", "data.structures.DensePoseOutput", "locals.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "densepose_inference", "(", "\n", "densepose_outputs", ":", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ",", "\n", "densepose_confidences", ":", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ",", "\n", "detections", ":", "List", "[", "Instances", "]", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Infer dense pose estimate based on outputs from the DensePose head\n    and detections. The estimate for each detection instance is stored in its\n    \"pred_densepose\" attribute.\n\n    Args:\n        densepose_outputs (tuple(`torch.Tensor`)): iterable containing 4 elements:\n            - s (:obj: `torch.Tensor`): coarse segmentation tensor of size (N, A, H, W),\n            - i (:obj: `torch.Tensor`): fine segmentation tensor of size (N, C, H, W),\n            - u (:obj: `torch.Tensor`): U coordinates for each class of size (N, C, H, W),\n            - v (:obj: `torch.Tensor`): V coordinates for each class of size (N, C, H, W),\n            where N is the total number of detections in a batch,\n                  A is the number of coarse segmentations labels\n                      (e.g. 15 for coarse body parts + background),\n                  C is the number of fine segmentation labels\n                      (e.g. 25 for fine body parts + background),\n                  W is the resolution along the X axis\n                  H is the resolution along the Y axis\n        densepose_confidences (tuple(`torch.Tensor`)): iterable containing 4 elements:\n            - sigma_1 (:obj: `torch.Tensor`): global confidences for UV coordinates\n                of size (N, C, H, W)\n            - sigma_2 (:obj: `torch.Tensor`): individual confidences for UV coordinates\n                of size (N, C, H, W)\n            - kappa_u (:obj: `torch.Tensor`): first component of confidence direction\n                vector of size (N, C, H, W)\n            - kappa_v (:obj: `torch.Tensor`): second component of confidence direction\n                vector of size (N, C, H, W)\n            - fine_segm_confidence (:obj: `torch.Tensor`): confidence for fine\n                segmentation of size (N, 1, H, W)\n            - coarse_segm_confidence (:obj: `torch.Tensor`): confidence for coarse\n                segmentation of size (N, 1, H, W)\n        detections (list[Instances]): A list of N Instances, where N is the number of images\n            in the batch. Instances are modified by this method: \"pred_densepose\" attribute\n            is added to each instance, the attribute contains the corresponding\n            DensePoseOutput object.\n    \"\"\"", "\n", "# DensePose outputs: segmentation, body part indices, U, V", "\n", "s", ",", "index_uv", ",", "u", ",", "v", "=", "densepose_outputs", "\n", "(", "\n", "sigma_1", ",", "\n", "sigma_2", ",", "\n", "kappa_u", ",", "\n", "kappa_v", ",", "\n", "fine_segm_confidence", ",", "\n", "coarse_segm_confidence", ",", "\n", ")", "=", "densepose_confidences", "\n", "k", "=", "0", "\n", "for", "detection", "in", "detections", ":", "\n", "        ", "n_i", "=", "len", "(", "detection", ")", "\n", "s_i", "=", "s", "[", "k", ":", "k", "+", "n_i", "]", "\n", "index_uv_i", "=", "index_uv", "[", "k", ":", "k", "+", "n_i", "]", "\n", "u_i", "=", "u", "[", "k", ":", "k", "+", "n_i", "]", "\n", "v_i", "=", "v", "[", "k", ":", "k", "+", "n_i", "]", "\n", "_local_vars", "=", "locals", "(", ")", "\n", "confidences", "=", "{", "\n", "name", ":", "_local_vars", "[", "name", "]", "[", "k", ":", "k", "+", "n_i", "]", "\n", "for", "name", "in", "(", "\n", "\"sigma_1\"", ",", "\n", "\"sigma_2\"", ",", "\n", "\"kappa_u\"", ",", "\n", "\"kappa_v\"", ",", "\n", "\"fine_segm_confidence\"", ",", "\n", "\"coarse_segm_confidence\"", ",", "\n", ")", "\n", "if", "_local_vars", ".", "get", "(", "name", ")", "is", "not", "None", "\n", "}", "\n", "densepose_output_i", "=", "DensePoseOutput", "(", "s_i", ",", "index_uv_i", ",", "u_i", ",", "v_i", ",", "confidences", ")", "\n", "detection", ".", "pred_densepose", "=", "densepose_output_i", "\n", "k", "+=", "n_i", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.BasicBlock.__init__": [[31, 40], ["torch.Module.__init__", "hrnet.conv3x3", "torch.BatchNorm2d", "torch.ReLU", "hrnet.conv3x3", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.conv3x3", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.conv3x3"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.BasicBlock.forward": [[41, 58], ["hrnet.BasicBlock.conv1", "hrnet.BasicBlock.bn1", "hrnet.BasicBlock.relu", "hrnet.BasicBlock.conv2", "hrnet.BasicBlock.bn2", "hrnet.BasicBlock.relu", "hrnet.BasicBlock.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.Bottleneck.__init__": [[63, 74], ["torch.Module.__init__", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "self", ".", "expansion", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.Bottleneck.forward": [[75, 96], ["hrnet.Bottleneck.conv1", "hrnet.Bottleneck.bn1", "hrnet.Bottleneck.relu", "hrnet.Bottleneck.conv2", "hrnet.Bottleneck.bn2", "hrnet.Bottleneck.relu", "hrnet.Bottleneck.conv3", "hrnet.Bottleneck.bn3", "hrnet.Bottleneck.relu", "hrnet.Bottleneck.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule.__init__": [[111, 131], ["torch.Module.__init__", "hrnet.HighResolutionModule._check_branches", "hrnet.HighResolutionModule._make_branches", "hrnet.HighResolutionModule._make_fuse_layers", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule._check_branches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule._make_branches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule._make_fuse_layers"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_branches", ",", "\n", "blocks", ",", "\n", "num_blocks", ",", "\n", "num_inchannels", ",", "\n", "num_channels", ",", "\n", "multi_scale_output", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", "HighResolutionModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_check_branches", "(", "num_branches", ",", "blocks", ",", "num_blocks", ",", "num_inchannels", ",", "num_channels", ")", "\n", "\n", "self", ".", "num_inchannels", "=", "num_inchannels", "\n", "self", ".", "num_branches", "=", "num_branches", "\n", "\n", "self", ".", "multi_scale_output", "=", "multi_scale_output", "\n", "\n", "self", ".", "branches", "=", "self", ".", "_make_branches", "(", "num_branches", ",", "blocks", ",", "num_blocks", ",", "num_channels", ")", "\n", "self", ".", "fuse_layers", "=", "self", ".", "_make_fuse_layers", "(", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule._check_branches": [[132, 151], ["len", "logger.error", "ValueError", "len", "logger.error", "ValueError", "len", "logger.error", "ValueError", "len", "len", "len"], "methods", ["None"], ["", "def", "_check_branches", "(", "self", ",", "num_branches", ",", "blocks", ",", "num_blocks", ",", "num_inchannels", ",", "num_channels", ")", ":", "\n", "        ", "if", "num_branches", "!=", "len", "(", "num_blocks", ")", ":", "\n", "            ", "error_msg", "=", "\"NUM_BRANCHES({}) <> NUM_BLOCKS({})\"", ".", "format", "(", "num_branches", ",", "len", "(", "num_blocks", ")", ")", "\n", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n", "", "if", "num_branches", "!=", "len", "(", "num_channels", ")", ":", "\n", "            ", "error_msg", "=", "\"NUM_BRANCHES({}) <> NUM_CHANNELS({})\"", ".", "format", "(", "\n", "num_branches", ",", "len", "(", "num_channels", ")", "\n", ")", "\n", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n", "", "if", "num_branches", "!=", "len", "(", "num_inchannels", ")", ":", "\n", "            ", "error_msg", "=", "\"NUM_BRANCHES({}) <> NUM_INCHANNELS({})\"", ".", "format", "(", "\n", "num_branches", ",", "len", "(", "num_inchannels", ")", "\n", ")", "\n", "logger", ".", "error", "(", "error_msg", ")", "\n", "raise", "ValueError", "(", "error_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule._make_one_branch": [[152, 178], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torch.Conv2d", "torch.BatchNorm2d", "block"], "methods", ["None"], ["", "", "def", "_make_one_branch", "(", "self", ",", "branch_index", ",", "block", ",", "num_blocks", ",", "num_channels", ",", "stride", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "(", "\n", "stride", "!=", "1", "\n", "or", "self", ".", "num_inchannels", "[", "branch_index", "]", "!=", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", "\n", ")", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "self", ".", "num_inchannels", "[", "branch_index", "]", ",", "\n", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", ",", "momentum", "=", "BN_MOMENTUM", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "block", "(", "self", ".", "num_inchannels", "[", "branch_index", "]", ",", "num_channels", "[", "branch_index", "]", ",", "stride", ",", "downsample", ")", "\n", ")", "\n", "self", ".", "num_inchannels", "[", "branch_index", "]", "=", "num_channels", "[", "branch_index", "]", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "num_blocks", "[", "branch_index", "]", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "num_inchannels", "[", "branch_index", "]", ",", "num_channels", "[", "branch_index", "]", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule._make_branches": [[179, 186], ["range", "torch.ModuleList", "branches.append", "hrnet.HighResolutionModule._make_one_branch"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule._make_one_branch"], ["", "def", "_make_branches", "(", "self", ",", "num_branches", ",", "block", ",", "num_blocks", ",", "num_channels", ")", ":", "\n", "        ", "branches", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_branches", ")", ":", "\n", "            ", "branches", ".", "append", "(", "self", ".", "_make_one_branch", "(", "i", ",", "block", ",", "num_blocks", ",", "num_channels", ")", ")", "\n", "\n", "", "return", "nn", ".", "ModuleList", "(", "branches", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule._make_fuse_layers": [[187, 245], ["range", "torch.ModuleList", "range", "fuse_layers.append", "torch.ModuleList", "fuse_layer.append", "torch.Sequential", "fuse_layer.append", "range", "fuse_layer.append", "torch.Conv2d", "torch.BatchNorm2d", "torch.Upsample", "torch.Sequential", "conv3x3s.append", "conv3x3s.append", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU"], "methods", ["None"], ["", "def", "_make_fuse_layers", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "num_branches", "==", "1", ":", "\n", "            ", "return", "None", "\n", "\n", "", "num_branches", "=", "self", ".", "num_branches", "\n", "num_inchannels", "=", "self", ".", "num_inchannels", "\n", "fuse_layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_branches", "if", "self", ".", "multi_scale_output", "else", "1", ")", ":", "\n", "            ", "fuse_layer", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "num_branches", ")", ":", "\n", "                ", "if", "j", ">", "i", ":", "\n", "                    ", "fuse_layer", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "num_inchannels", "[", "j", "]", ",", "num_inchannels", "[", "i", "]", ",", "1", ",", "1", ",", "0", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_inchannels", "[", "i", "]", ")", ",", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", "**", "(", "j", "-", "i", ")", ",", "mode", "=", "\"nearest\"", ")", ",", "\n", ")", "\n", ")", "\n", "", "elif", "j", "==", "i", ":", "\n", "                    ", "fuse_layer", ".", "append", "(", "None", ")", "\n", "", "else", ":", "\n", "                    ", "conv3x3s", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "i", "-", "j", ")", ":", "\n", "                        ", "if", "k", "==", "i", "-", "j", "-", "1", ":", "\n", "                            ", "num_outchannels_conv3x3", "=", "num_inchannels", "[", "i", "]", "\n", "conv3x3s", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "num_inchannels", "[", "j", "]", ",", "\n", "num_outchannels_conv3x3", ",", "\n", "3", ",", "\n", "2", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_outchannels_conv3x3", ")", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                            ", "num_outchannels_conv3x3", "=", "num_inchannels", "[", "j", "]", "\n", "conv3x3s", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "num_inchannels", "[", "j", "]", ",", "\n", "num_outchannels_conv3x3", ",", "\n", "3", ",", "\n", "2", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_outchannels_conv3x3", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", ",", "\n", ")", "\n", ")", "\n", "", "", "fuse_layer", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "conv3x3s", ")", ")", "\n", "", "", "fuse_layers", ".", "append", "(", "nn", ".", "ModuleList", "(", "fuse_layer", ")", ")", "\n", "\n", "", "return", "nn", ".", "ModuleList", "(", "fuse_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule.get_num_inchannels": [[246, 248], ["None"], "methods", ["None"], ["", "def", "get_num_inchannels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_inchannels", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule.forward": [[249, 269], ["range", "range", "len", "range", "x_fuse.append", "hrnet.HighResolutionModule.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "num_branches", "==", "1", ":", "\n", "            ", "return", "[", "self", ".", "branches", "[", "0", "]", "(", "x", "[", "0", "]", ")", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "num_branches", ")", ":", "\n", "            ", "x", "[", "i", "]", "=", "self", ".", "branches", "[", "i", "]", "(", "x", "[", "i", "]", ")", "\n", "\n", "", "x_fuse", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "fuse_layers", ")", ")", ":", "\n", "            ", "y", "=", "x", "[", "0", "]", "if", "i", "==", "0", "else", "self", ".", "fuse_layers", "[", "i", "]", "[", "0", "]", "(", "x", "[", "0", "]", ")", "\n", "for", "j", "in", "range", "(", "1", ",", "self", ".", "num_branches", ")", ":", "\n", "                ", "if", "i", "==", "j", ":", "\n", "                    ", "y", "=", "y", "+", "x", "[", "j", "]", "\n", "", "else", ":", "\n", "                    ", "z", "=", "self", ".", "fuse_layers", "[", "i", "]", "[", "j", "]", "(", "x", "[", "j", "]", ")", "[", ":", ",", ":", ",", ":", "y", ".", "shape", "[", "2", "]", ",", ":", "y", ".", "shape", "[", "3", "]", "]", "\n", "y", "=", "y", "+", "z", "\n", "", "", "x_fuse", ".", "append", "(", "self", ".", "relu", "(", "y", ")", ")", "\n", "\n", "", "return", "x_fuse", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet.__init__": [[281, 326], ["detectron2.modeling.backbone.backbone.Backbone.__init__", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "hrnet.PoseHigherResolutionNet._make_layer", "hrnet.PoseHigherResolutionNet._make_transition_layer", "hrnet.PoseHigherResolutionNet._make_stage", "hrnet.PoseHigherResolutionNet._make_transition_layer", "hrnet.PoseHigherResolutionNet._make_stage", "hrnet.PoseHigherResolutionNet._make_transition_layer", "hrnet.PoseHigherResolutionNet._make_stage", "range", "hrnet.PoseHigherResolutionNet._out_features.append", "hrnet.PoseHigherResolutionNet._out_feature_channels.update", "hrnet.PoseHigherResolutionNet._out_feature_strides.update", "range", "range", "range", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_layer", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_transition_layer", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_stage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_transition_layer", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_stage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_transition_layer", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_stage"], ["def", "__init__", "(", "self", ",", "cfg", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "inplanes", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STEM_INPLANES", "\n", "super", "(", "PoseHigherResolutionNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# stem net", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "64", ",", "momentum", "=", "BN_MOMENTUM", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "Bottleneck", ",", "64", ",", "4", ")", "\n", "\n", "self", ".", "stage2_cfg", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE2", "\n", "num_channels", "=", "self", ".", "stage2_cfg", ".", "NUM_CHANNELS", "\n", "block", "=", "blocks_dict", "[", "self", ".", "stage2_cfg", ".", "BLOCK", "]", "\n", "num_channels", "=", "[", "num_channels", "[", "i", "]", "*", "block", ".", "expansion", "for", "i", "in", "range", "(", "len", "(", "num_channels", ")", ")", "]", "\n", "self", ".", "transition1", "=", "self", ".", "_make_transition_layer", "(", "[", "256", "]", ",", "num_channels", ")", "\n", "self", ".", "stage2", ",", "pre_stage_channels", "=", "self", ".", "_make_stage", "(", "self", ".", "stage2_cfg", ",", "num_channels", ")", "\n", "\n", "self", ".", "stage3_cfg", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE3", "\n", "num_channels", "=", "self", ".", "stage3_cfg", ".", "NUM_CHANNELS", "\n", "block", "=", "blocks_dict", "[", "self", ".", "stage3_cfg", ".", "BLOCK", "]", "\n", "num_channels", "=", "[", "num_channels", "[", "i", "]", "*", "block", ".", "expansion", "for", "i", "in", "range", "(", "len", "(", "num_channels", ")", ")", "]", "\n", "self", ".", "transition2", "=", "self", ".", "_make_transition_layer", "(", "pre_stage_channels", ",", "num_channels", ")", "\n", "self", ".", "stage3", ",", "pre_stage_channels", "=", "self", ".", "_make_stage", "(", "self", ".", "stage3_cfg", ",", "num_channels", ")", "\n", "\n", "self", ".", "stage4_cfg", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", "\n", "num_channels", "=", "self", ".", "stage4_cfg", ".", "NUM_CHANNELS", "\n", "block", "=", "blocks_dict", "[", "self", ".", "stage4_cfg", ".", "BLOCK", "]", "\n", "num_channels", "=", "[", "num_channels", "[", "i", "]", "*", "block", ".", "expansion", "for", "i", "in", "range", "(", "len", "(", "num_channels", ")", ")", "]", "\n", "self", ".", "transition3", "=", "self", ".", "_make_transition_layer", "(", "pre_stage_channels", ",", "num_channels", ")", "\n", "self", ".", "stage4", ",", "pre_stage_channels", "=", "self", ".", "_make_stage", "(", "\n", "self", ".", "stage4_cfg", ",", "num_channels", ",", "multi_scale_output", "=", "True", "\n", ")", "\n", "\n", "self", ".", "_out_features", "=", "[", "]", "\n", "self", ".", "_out_feature_channels", "=", "{", "}", "\n", "self", ".", "_out_feature_strides", "=", "{", "}", "\n", "\n", "for", "i", "in", "range", "(", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", ".", "NUM_BRANCHES", ")", ":", "\n", "            ", "self", ".", "_out_features", ".", "append", "(", "\"p%d\"", "%", "(", "i", "+", "1", ")", ")", "\n", "self", ".", "_out_feature_channels", ".", "update", "(", "\n", "{", "self", ".", "_out_features", "[", "-", "1", "]", ":", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", ".", "NUM_CHANNELS", "[", "i", "]", "}", "\n", ")", "\n", "self", ".", "_out_feature_strides", ".", "update", "(", "{", "self", ".", "_out_features", "[", "-", "1", "]", ":", "1", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._get_deconv_cfg": [[327, 339], ["None"], "methods", ["None"], ["", "", "def", "_get_deconv_cfg", "(", "self", ",", "deconv_kernel", ")", ":", "\n", "        ", "if", "deconv_kernel", "==", "4", ":", "\n", "            ", "padding", "=", "1", "\n", "output_padding", "=", "0", "\n", "", "elif", "deconv_kernel", "==", "3", ":", "\n", "            ", "padding", "=", "1", "\n", "output_padding", "=", "1", "\n", "", "elif", "deconv_kernel", "==", "2", ":", "\n", "            ", "padding", "=", "0", "\n", "output_padding", "=", "0", "\n", "\n", "", "return", "deconv_kernel", ",", "padding", ",", "output_padding", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_transition_layer": [[340, 381], ["len", "len", "range", "torch.ModuleList", "range", "transition_layers.append", "transition_layers.append", "transition_layers.append", "conv3x3s.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU"], "methods", ["None"], ["", "def", "_make_transition_layer", "(", "self", ",", "num_channels_pre_layer", ",", "num_channels_cur_layer", ")", ":", "\n", "        ", "num_branches_cur", "=", "len", "(", "num_channels_cur_layer", ")", "\n", "num_branches_pre", "=", "len", "(", "num_channels_pre_layer", ")", "\n", "\n", "transition_layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_branches_cur", ")", ":", "\n", "            ", "if", "i", "<", "num_branches_pre", ":", "\n", "                ", "if", "num_channels_cur_layer", "[", "i", "]", "!=", "num_channels_pre_layer", "[", "i", "]", ":", "\n", "                    ", "transition_layers", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "num_channels_pre_layer", "[", "i", "]", ",", "\n", "num_channels_cur_layer", "[", "i", "]", ",", "\n", "3", ",", "\n", "1", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "num_channels_cur_layer", "[", "i", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "transition_layers", ".", "append", "(", "None", ")", "\n", "", "", "else", ":", "\n", "                ", "conv3x3s", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "i", "+", "1", "-", "num_branches_pre", ")", ":", "\n", "                    ", "inchannels", "=", "num_channels_pre_layer", "[", "-", "1", "]", "\n", "outchannels", "=", "(", "\n", "num_channels_cur_layer", "[", "i", "]", "if", "j", "==", "i", "-", "num_branches_pre", "else", "inchannels", "\n", ")", "\n", "conv3x3s", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "inchannels", ",", "outchannels", ",", "3", ",", "2", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "outchannels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", ")", "\n", "", "transition_layers", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "conv3x3s", ")", ")", "\n", "\n", "", "", "return", "nn", ".", "ModuleList", "(", "transition_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_layer": [[382, 403], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torch.Conv2d", "torch.BatchNorm2d", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "self", ".", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "planes", "*", "block", ".", "expansion", ",", "momentum", "=", "BN_MOMENTUM", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet._make_stage": [[404, 432], ["range", "modules.append", "modules[].get_num_inchannels", "torch.Sequential", "hrnet.HighResolutionModule"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.HighResolutionModule.get_num_inchannels"], ["", "def", "_make_stage", "(", "self", ",", "layer_config", ",", "num_inchannels", ",", "multi_scale_output", "=", "True", ")", ":", "\n", "        ", "num_modules", "=", "layer_config", "[", "\"NUM_MODULES\"", "]", "\n", "num_branches", "=", "layer_config", "[", "\"NUM_BRANCHES\"", "]", "\n", "num_blocks", "=", "layer_config", "[", "\"NUM_BLOCKS\"", "]", "\n", "num_channels", "=", "layer_config", "[", "\"NUM_CHANNELS\"", "]", "\n", "block", "=", "blocks_dict", "[", "layer_config", "[", "\"BLOCK\"", "]", "]", "\n", "\n", "modules", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_modules", ")", ":", "\n", "# multi_scale_output is only used last module", "\n", "            ", "if", "not", "multi_scale_output", "and", "i", "==", "num_modules", "-", "1", ":", "\n", "                ", "reset_multi_scale_output", "=", "False", "\n", "", "else", ":", "\n", "                ", "reset_multi_scale_output", "=", "True", "\n", "\n", "", "modules", ".", "append", "(", "\n", "HighResolutionModule", "(", "\n", "num_branches", ",", "\n", "block", ",", "\n", "num_blocks", ",", "\n", "num_inchannels", ",", "\n", "num_channels", ",", "\n", "reset_multi_scale_output", ",", "\n", ")", "\n", ")", "\n", "num_inchannels", "=", "modules", "[", "-", "1", "]", ".", "get_num_inchannels", "(", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "modules", ")", ",", "num_inchannels", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.PoseHigherResolutionNet.forward": [[433, 468], ["hrnet.PoseHigherResolutionNet.conv1", "hrnet.PoseHigherResolutionNet.bn1", "hrnet.PoseHigherResolutionNet.relu", "hrnet.PoseHigherResolutionNet.conv2", "hrnet.PoseHigherResolutionNet.bn2", "hrnet.PoseHigherResolutionNet.relu", "hrnet.PoseHigherResolutionNet.layer1", "range", "hrnet.PoseHigherResolutionNet.stage2", "range", "hrnet.PoseHigherResolutionNet.stage3", "range", "hrnet.PoseHigherResolutionNet.stage4", "dict", "len", "len", "zip", "x_list.append", "x_list.append", "x_list.append", "x_list.append", "x_list.append", "x_list.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "\n", "x_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "stage2_cfg", ".", "NUM_BRANCHES", ")", ":", "\n", "            ", "if", "self", ".", "transition1", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "x_list", ".", "append", "(", "self", ".", "transition1", "[", "i", "]", "(", "x", ")", ")", "\n", "", "else", ":", "\n", "                ", "x_list", ".", "append", "(", "x", ")", "\n", "", "", "y_list", "=", "self", ".", "stage2", "(", "x_list", ")", "\n", "\n", "x_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "stage3_cfg", ".", "NUM_BRANCHES", ")", ":", "\n", "            ", "if", "self", ".", "transition2", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "x_list", ".", "append", "(", "self", ".", "transition2", "[", "i", "]", "(", "y_list", "[", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "x_list", ".", "append", "(", "y_list", "[", "i", "]", ")", "\n", "", "", "y_list", "=", "self", ".", "stage3", "(", "x_list", ")", "\n", "\n", "x_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "stage4_cfg", ".", "NUM_BRANCHES", ")", ":", "\n", "            ", "if", "self", ".", "transition3", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "x_list", ".", "append", "(", "self", ".", "transition3", "[", "i", "]", "(", "y_list", "[", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "x_list", ".", "append", "(", "y_list", "[", "i", "]", ")", "\n", "", "", "y_list", "=", "self", ".", "stage4", "(", "x_list", ")", "\n", "\n", "assert", "len", "(", "self", ".", "_out_features", ")", "==", "len", "(", "y_list", ")", "\n", "return", "dict", "(", "zip", "(", "self", ".", "_out_features", ",", "y_list", ")", ")", "# final_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.conv3x3": [[23, 26], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.build_pose_hrnet_backbone": [[470, 474], ["detectron2.modeling.backbone.BACKBONE_REGISTRY.register", "hrnet.PoseHigherResolutionNet"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register"], ["", "", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_pose_hrnet_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "model", "=", "PoseHigherResolutionNet", "(", "cfg", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseDatasetMapperTTA.__init__": [[14, 17], ["detectron2.modeling.test_time_augmentation.DatasetMapperTTA.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["ResizeShortestEdge", ",", "\n", "ResizeTransform", ",", "\n", "apply_augmentations", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseDatasetMapperTTA.__call__": [[18, 34], ["super().__call__", "dataset_dict[].permute().numpy", "detectron2.data.transforms.RandomRotation", "detectron2.data.transforms.apply_transform_gens", "torch.from_numpy", "copy.deepcopy", "fvcore.transforms.TransformList", "super().__call__.append", "dataset_dict[].permute", "numpy.copy", "numpy.ascontiguousarray", "new_numpy_image.transpose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.ScoreThresholdedExtractor.__call__"], ["from", "detectron2", ".", "structures", "import", "Boxes", ",", "Instances", "\n", "\n", "from", ".", "meta_arch", "import", "GeneralizedRCNN", "\n", "from", ".", "postprocessing", "import", "detector_postprocess", "\n", "from", ".", "roi_heads", ".", "fast_rcnn", "import", "fast_rcnn_inference_single_image", "\n", "\n", "__all__", "=", "[", "\"DatasetMapperTTA\"", ",", "\"GeneralizedRCNNWithTTA\"", "]", "\n", "\n", "\n", "class", "DatasetMapperTTA", ":", "\n", "    ", "\"\"\"\n    Implement test-time augmentation for detection data.\n    It is a callable which takes a dataset dict from a detection dataset,\n    and returns a list of dataset dicts where the images\n    are augmented from the input image by the transformations defined in the config.\n    This is used for test-time augmentation.\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA.__init__": [[37, 51], ["transform_data.to", "detectron2.modeling.test_time_augmentation.GeneralizedRCNNWithTTA.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["        ", "self", ".", "min_sizes", "=", "cfg", ".", "TEST", ".", "AUG", ".", "MIN_SIZES", "\n", "self", ".", "max_size", "=", "cfg", ".", "TEST", ".", "AUG", ".", "MAX_SIZE", "\n", "self", ".", "flip", "=", "cfg", ".", "TEST", ".", "AUG", ".", "FLIP", "\n", "self", ".", "image_format", "=", "cfg", ".", "INPUT", ".", "FORMAT", "\n", "\n", "", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._inference_one_image": [[53, 90], ["input[].to", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_inputs", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._merge_detections", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._turn_off_roi_heads", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_boxes", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._rescale_detected_boxes", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._batch_inference", "detectron2.modeling.postprocessing.detector_postprocess", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._reduce_pred_masks", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._reduce_pred_densepose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._get_augmented_inputs", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._merge_detections", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._turn_off_roi_heads", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._rescale_detected_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._reduce_pred_masks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._reduce_pred_densepose"], ["\n", "numpy_image", "=", "dataset_dict", "[", "\"image\"", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "numpy", "(", ")", "\n", "shape", "=", "numpy_image", ".", "shape", "\n", "orig_shape", "=", "(", "dataset_dict", "[", "\"height\"", "]", ",", "dataset_dict", "[", "\"width\"", "]", ")", "\n", "if", "shape", "[", ":", "2", "]", "!=", "orig_shape", ":", "\n", "# It transforms the \"original\" image in the dataset to the input image", "\n", "            ", "pre_tfm", "=", "ResizeTransform", "(", "orig_shape", "[", "0", "]", ",", "orig_shape", "[", "1", "]", ",", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "pre_tfm", "=", "NoOpTransform", "(", ")", "\n", "\n", "# Create all combinations of augmentations to use", "\n", "", "aug_candidates", "=", "[", "]", "# each element is a list[Augmentation]", "\n", "for", "min_size", "in", "self", ".", "min_sizes", ":", "\n", "            ", "resize", "=", "ResizeShortestEdge", "(", "min_size", ",", "self", ".", "max_size", ")", "\n", "aug_candidates", ".", "append", "(", "[", "resize", "]", ")", "# resize only", "\n", "if", "self", ".", "flip", ":", "\n", "                ", "flip", "=", "RandomFlip", "(", "prob", "=", "1.0", ")", "\n", "aug_candidates", ".", "append", "(", "[", "resize", ",", "flip", "]", ")", "# resize + flip", "\n", "\n", "# Apply all the augmentations", "\n", "", "", "ret", "=", "[", "]", "\n", "for", "aug", "in", "aug_candidates", ":", "\n", "            ", "new_image", ",", "tfms", "=", "apply_augmentations", "(", "aug", ",", "np", ".", "copy", "(", "numpy_image", ")", ")", "\n", "torch_image", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "new_image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "\n", "dic", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "\n", "dic", "[", "\"transforms\"", "]", "=", "pre_tfm", "+", "tfms", "\n", "dic", "[", "\"image\"", "]", "=", "torch_image", "\n", "ret", ".", "append", "(", "dic", ")", "\n", "", "return", "ret", "\n", "\n", "\n", "", "", "class", "GeneralizedRCNNWithTTA", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    A GeneralizedRCNN with test-time augmentation enabled.\n    Its :meth:`__call__` method has the same interface as :meth:`GeneralizedRCNN.forward`.\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._get_augmented_boxes": [[91, 111], ["test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._batch_inference", "zip", "torch.cat", "any", "tfm.inverse().apply_box", "torch.cat.append", "all_scores.extend", "all_classes.extend", "pred_boxes.cpu().numpy", "torch.from_numpy().to", "isinstance", "tfm.inverse", "pred_boxes.cpu", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.GeneralizedRCNNWithTTA._batch_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.inverse"], ["def", "__init__", "(", "self", ",", "cfg", ",", "model", ",", "tta_mapper", "=", "None", ",", "batch_size", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            model (GeneralizedRCNN): a GeneralizedRCNN to apply TTA on.\n            tta_mapper (callable): takes a dataset dict and returns a list of\n                augmented versions of the dataset dict. Defaults to\n                `DatasetMapperTTA(cfg)`.\n            batch_size (int): batch the augmented images into this batch size for inference.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "model", ",", "DistributedDataParallel", ")", ":", "\n", "            ", "model", "=", "model", ".", "module", "\n", "", "assert", "isinstance", "(", "\n", "model", ",", "GeneralizedRCNN", "\n", ")", ",", "\"TTA is only supported on GeneralizedRCNN. Got a model of type {}\"", ".", "format", "(", "type", "(", "model", ")", ")", "\n", "self", ".", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "assert", "not", "self", ".", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ",", "\"TTA for keypoint is not supported yet\"", "\n", "assert", "(", "\n", "not", "self", ".", "cfg", ".", "MODEL", ".", "LOAD_PROPOSALS", "\n", ")", ",", "\"TTA for pre-computed proposals is not supported yet\"", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._reduce_pred_densepose": [[112, 130], ["enumerate", "zip", "any", "test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._incremental_avg_dp", "output.pred_densepose.hflip", "setattr", "isinstance", "test_time_augmentation._inverse_rotation", "getattr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._incremental_avg_dp", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.hflip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation._inverse_rotation"], ["\n", "self", ".", "model", "=", "model", "\n", "\n", "if", "tta_mapper", "is", "None", ":", "\n", "            ", "tta_mapper", "=", "DatasetMapperTTA", "(", "cfg", ")", "\n", "", "self", ".", "tta_mapper", "=", "tta_mapper", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "", "@", "contextmanager", "\n", "def", "_turn_off_roi_heads", "(", "self", ",", "attrs", ")", ":", "\n", "        ", "\"\"\"\n        Open a context where some heads in `model.roi_heads` are temporarily turned off.\n        Args:\n            attr (list[str]): the attribute in `model.roi_heads` which can be used\n                to turn off a specific head, e.g., \"mask_on\", \"keypoint_on\".\n        \"\"\"", "\n", "roi_heads", "=", "self", ".", "model", ".", "roi_heads", "\n", "old", "=", "{", "}", "\n", "for", "attr", "in", "attrs", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.DensePoseGeneralizedRCNNWithTTA._incremental_avg_dp": [[132, 139], ["setattr", "setattr", "getattr", "getattr"], "methods", ["None"], ["                ", "old", "[", "attr", "]", "=", "getattr", "(", "roi_heads", ",", "attr", ")", "\n", "", "except", "AttributeError", ":", "\n", "# The head may not be implemented in certain ROIHeads", "\n", "                ", "pass", "\n", "\n", "", "", "if", "len", "(", "old", ".", "keys", "(", ")", ")", "==", "0", ":", "\n", "            ", "yield", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation._inverse_rotation": [[141, 179], ["boxes.int().cpu().numpy.int().cpu().numpy", "rotate_box_inverse().astype", "torch.tensor().to().float", "numpy.maximum", "range", "len", "densepose_attrs[].clone", "torch.nn.functional.interpolate", "torch.nn.functional.pad", "torch.nn.functional.affine_grid", "torch.nn.functional.grid_sample", "len", "isinstance", "boxes.int().cpu().numpy.int().cpu", "test_time_augmentation.rotate_box_inverse", "torch.tensor().to", "min", "tuple", "min", "torch.nn.functional.interpolate", "wh_boxes[].tolist", "numpy.repeat", "boxes.int().cpu().numpy.int", "torch.tensor", "numpy.maximum"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.rotate_box_inverse", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["                ", "setattr", "(", "roi_heads", ",", "attr", ",", "False", ")", "\n", "", "yield", "\n", "for", "attr", "in", "old", ".", "keys", "(", ")", ":", "\n", "                ", "setattr", "(", "roi_heads", ",", "attr", ",", "old", "[", "attr", "]", ")", "\n", "\n", "", "", "", "def", "_batch_inference", "(", "self", ",", "batched_inputs", ",", "detected_instances", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Execute inference on a list of inputs,\n        using batch size = self.batch_size, instead of the length of the list.\n\n        Inputs & outputs have the same format as :meth:`GeneralizedRCNN.inference`\n        \"\"\"", "\n", "if", "detected_instances", "is", "None", ":", "\n", "            ", "detected_instances", "=", "[", "None", "]", "*", "len", "(", "batched_inputs", ")", "\n", "\n", "", "outputs", "=", "[", "]", "\n", "inputs", ",", "instances", "=", "[", "]", ",", "[", "]", "\n", "for", "idx", ",", "input", ",", "instance", "in", "zip", "(", "count", "(", ")", ",", "batched_inputs", ",", "detected_instances", ")", ":", "\n", "            ", "inputs", ".", "append", "(", "input", ")", "\n", "instances", ".", "append", "(", "instance", ")", "\n", "if", "len", "(", "inputs", ")", "==", "self", ".", "batch_size", "or", "idx", "==", "len", "(", "batched_inputs", ")", "-", "1", ":", "\n", "                ", "outputs", ".", "extend", "(", "\n", "self", ".", "model", ".", "inference", "(", "\n", "inputs", ",", "\n", "instances", "if", "instances", "[", "0", "]", "is", "not", "None", "else", "None", ",", "\n", "do_postprocess", "=", "False", ",", "\n", ")", "\n", ")", "\n", "inputs", ",", "instances", "=", "[", "]", ",", "[", "]", "\n", "", "", "return", "outputs", "\n", "\n", "", "def", "__call__", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Same input/output format as :meth:`GeneralizedRCNN.forward`\n        \"\"\"", "\n", "\n", "def", "_maybe_read_image", "(", "dataset_dict", ")", ":", "\n", "            ", "ret", "=", "copy", ".", "copy", "(", "dataset_dict", ")", "\n", "if", "\"image\"", "not", "in", "ret", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_time_augmentation.rotate_box_inverse": [[181, 204], ["rot_tfm.inverse().apply_box", "rot_tfm.inverse"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.inverse"], ["image", "=", "torch", ".", "from_numpy", "(", "image", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "# CHW", "\n", "ret", "[", "\"image\"", "]", "=", "image", "\n", "", "if", "\"height\"", "not", "in", "ret", "and", "\"width\"", "not", "in", "ret", ":", "\n", "                ", "ret", "[", "\"height\"", "]", "=", "image", ".", "shape", "[", "1", "]", "\n", "ret", "[", "\"width\"", "]", "=", "image", ".", "shape", "[", "2", "]", "\n", "", "return", "ret", "\n", "\n", "", "return", "[", "self", ".", "_inference_one_image", "(", "_maybe_read_image", "(", "x", ")", ")", "for", "x", "in", "batched_inputs", "]", "\n", "\n", "", "def", "_inference_one_image", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (dict): one dataset dict with \"image\" field being a CHW tensor\n\n        Returns:\n            dict: one output dict\n        \"\"\"", "\n", "orig_shape", "=", "(", "input", "[", "\"height\"", "]", ",", "input", "[", "\"width\"", "]", ")", "\n", "augmented_inputs", ",", "tfms", "=", "self", ".", "_get_augmented_inputs", "(", "input", ")", "\n", "# Detect boxes from all augmented versions", "\n", "with", "self", ".", "_turn_off_roi_heads", "(", "[", "\"mask_on\"", ",", "\"keypoint_on\"", "]", ")", ":", "\n", "# temporarily disable roi heads", "\n", "            ", "all_boxes", ",", "all_scores", ",", "all_classes", "=", "self", ".", "_get_augmented_boxes", "(", "augmented_inputs", ",", "tfms", ")", "\n", "# merge all detected boxes to obtain final predictions for boxes", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrfpn.HRFPN.__init__": [[47, 126], ["detectron2.modeling.backbone.backbone.Backbone.__init__", "isinstance", "len", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "range", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "len", "hrfpn.HRFPN.interp_conv.append", "hrfpn.HRFPN.reduction_pooling_conv.append", "hrfpn.HRFPN._out_features.append", "hrfpn.HRFPN._out_feature_channels.update", "hrfpn.HRFPN._out_feature_strides.update", "hrfpn.HRFPN.fpn_conv.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "sum"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "bottom_up", ",", "\n", "in_features", ",", "\n", "n_out_features", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "pooling", "=", "\"AVG\"", ",", "\n", "share_conv", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", "HRFPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "list", ")", "\n", "self", ".", "bottom_up", "=", "bottom_up", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "n_out_features", "=", "n_out_features", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "\n", "self", ".", "share_conv", "=", "share_conv", "\n", "\n", "if", "self", ".", "share_conv", ":", "\n", "            ", "self", ".", "fpn_conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "out_channels", ",", "out_channels", "=", "out_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fpn_conv", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "n_out_features", ")", ":", "\n", "                ", "self", ".", "fpn_conv", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", ")", "\n", ")", "\n", "\n", "# Custom change: Replaces a simple bilinear interpolation", "\n", "", "", "self", ".", "interp_conv", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "in_features", ")", ")", ":", "\n", "            ", "self", ".", "interp_conv", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ConvTranspose2d", "(", "\n", "in_channels", "=", "in_channels", "[", "i", "]", ",", "\n", "out_channels", "=", "in_channels", "[", "i", "]", ",", "\n", "kernel_size", "=", "4", ",", "\n", "stride", "=", "2", "**", "i", ",", "\n", "padding", "=", "0", ",", "\n", "output_padding", "=", "0", ",", "\n", "bias", "=", "False", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "in_channels", "[", "i", "]", ",", "momentum", "=", "0.1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "# Custom change: Replaces a couple (reduction conv + pooling) by one conv", "\n", "", "self", ".", "reduction_pooling_conv", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_out_features", ")", ":", "\n", "            ", "self", ".", "reduction_pooling_conv", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "sum", "(", "in_channels", ")", ",", "out_channels", ",", "kernel_size", "=", "2", "**", "i", ",", "stride", "=", "2", "**", "i", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_channels", ",", "momentum", "=", "0.1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "", "if", "pooling", "==", "\"MAX\"", ":", "\n", "            ", "self", ".", "pooling", "=", "F", ".", "max_pool2d", "\n", "", "else", ":", "\n", "            ", "self", ".", "pooling", "=", "F", ".", "avg_pool2d", "\n", "\n", "", "self", ".", "_out_features", "=", "[", "]", "\n", "self", ".", "_out_feature_channels", "=", "{", "}", "\n", "self", ".", "_out_feature_strides", "=", "{", "}", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "n_out_features", ")", ":", "\n", "            ", "self", ".", "_out_features", ".", "append", "(", "\"p%d\"", "%", "(", "i", "+", "1", ")", ")", "\n", "self", ".", "_out_feature_channels", ".", "update", "(", "{", "self", ".", "_out_features", "[", "-", "1", "]", ":", "self", ".", "out_channels", "}", ")", "\n", "self", ".", "_out_feature_strides", ".", "update", "(", "{", "self", ".", "_out_features", "[", "-", "1", "]", ":", "2", "**", "(", "i", "+", "2", ")", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrfpn.HRFPN.init_weights": [[128, 133], ["hrfpn.HRFPN.modules", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ",", "a", "=", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrfpn.HRFPN.forward": [[134, 161], ["hrfpn.HRFPN.bottom_up", "range", "min", "min", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "range", "range", "dict", "len", "len", "len", "outs.append", "outs.append", "len", "len", "len", "len", "zip", "outputs.append", "outputs.append", "hrfpn.HRFPN.fpn_conv"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "bottom_up_features", "=", "self", ".", "bottom_up", "(", "inputs", ")", "\n", "assert", "len", "(", "bottom_up_features", ")", "==", "len", "(", "self", ".", "in_features", ")", "\n", "inputs", "=", "[", "bottom_up_features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "inputs", ")", ")", ":", "\n", "            ", "outs", ".", "append", "(", "self", ".", "interp_conv", "[", "i", "]", "(", "inputs", "[", "i", "]", ")", ")", "\n", "", "shape_2", "=", "min", "(", "o", ".", "shape", "[", "2", "]", "for", "o", "in", "outs", ")", "\n", "shape_3", "=", "min", "(", "o", ".", "shape", "[", "3", "]", "for", "o", "in", "outs", ")", "\n", "out", "=", "torch", ".", "cat", "(", "[", "o", "[", ":", ",", ":", ",", ":", "shape_2", ",", ":", "shape_3", "]", "for", "o", "in", "outs", "]", ",", "dim", "=", "1", ")", "\n", "outs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_out_features", ")", ":", "\n", "            ", "outs", ".", "append", "(", "self", ".", "reduction_pooling_conv", "[", "i", "]", "(", "out", ")", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "outs", ")", ")", ":", "# Make shapes consistent", "\n", "            ", "outs", "[", "-", "1", "-", "i", "]", "=", "outs", "[", "-", "1", "-", "i", "]", "[", "\n", ":", ",", ":", ",", ":", "outs", "[", "-", "1", "]", ".", "shape", "[", "2", "]", "*", "2", "**", "i", ",", ":", "outs", "[", "-", "1", "]", ".", "shape", "[", "3", "]", "*", "2", "**", "i", "\n", "]", "\n", "", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "outs", ")", ")", ":", "\n", "            ", "if", "self", ".", "share_conv", ":", "\n", "                ", "outputs", ".", "append", "(", "self", ".", "fpn_conv", "(", "outs", "[", "i", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "outputs", ".", "append", "(", "self", ".", "fpn_conv", "[", "i", "]", "(", "outs", "[", "i", "]", ")", ")", "\n", "\n", "", "", "assert", "len", "(", "self", ".", "_out_features", ")", "==", "len", "(", "outputs", ")", "\n", "return", "dict", "(", "zip", "(", "self", ".", "_out_features", ",", "outputs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrfpn.build_hrfpn_backbone": [[163, 182], ["detectron2.modeling.backbone.BACKBONE_REGISTRY.register", "len", "hrnet.build_pose_hrnet_backbone", "hrfpn.HRFPN", "range"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.hrnet.build_pose_hrnet_backbone"], ["", "", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_hrfpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "\n", "    ", "in_channels", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", ".", "NUM_CHANNELS", "\n", "in_features", "=", "[", "\"p%d\"", "%", "(", "i", "+", "1", ")", "for", "i", "in", "range", "(", "cfg", ".", "MODEL", ".", "HRNET", ".", "STAGE4", ".", "NUM_BRANCHES", ")", "]", "\n", "n_out_features", "=", "len", "(", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", ")", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "HRNET", ".", "HRFPN", ".", "OUT_CHANNELS", "\n", "hrnet", "=", "build_pose_hrnet_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "hrfpn", "=", "HRFPN", "(", "\n", "hrnet", ",", "\n", "in_features", ",", "\n", "n_out_features", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "pooling", "=", "\"AVG\"", ",", "\n", "share_conv", "=", "False", ",", "\n", ")", "\n", "\n", "return", "hrfpn", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.utils.initialize_module_params": [[6, 12], ["module.named_parameters", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_"], "function", ["None"], ["def", "initialize_module_params", "(", "module", ":", "nn", ".", "Module", ")", ":", "\n", "    ", "for", "name", ",", "param", "in", "module", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "\"bias\"", "in", "name", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "param", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.confidence.DensePoseConfidenceModelConfig.from_cfg": [[61, 72], ["confidence.DensePoseConfidenceModelConfig", "confidence.DensePoseUVConfidenceConfig", "confidence.DensePoseSegmConfidenceConfig", "confidence.DensePoseUVConfidenceType"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "from_cfg", "(", "cfg", ":", "CfgNode", ")", "->", "\"DensePoseConfidenceModelConfig\"", ":", "\n", "        ", "return", "DensePoseConfidenceModelConfig", "(", "\n", "uv_confidence", "=", "DensePoseUVConfidenceConfig", "(", "\n", "enabled", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "UV_CONFIDENCE", ".", "ENABLED", ",", "\n", "epsilon", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "UV_CONFIDENCE", ".", "EPSILON", ",", "\n", "type", "=", "DensePoseUVConfidenceType", "(", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "UV_CONFIDENCE", ".", "TYPE", ")", ",", "\n", ")", ",", "\n", "segm_confidence", "=", "DensePoseSegmConfidenceConfig", "(", "\n", "enabled", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "SEGM_CONFIDENCE", ".", "ENABLED", ",", "\n", "epsilon", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "SEGM_CONFIDENCE", ".", "EPSILON", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.filter.DensePoseDataFilter.__init__": [[12, 15], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ")", ":", "\n", "        ", "self", ".", "iou_threshold", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "FG_IOU_THRESHOLD", "\n", "self", ".", "keep_masks", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "COARSE_SEGM_TRAINED_BY_MASKS", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.filter.DensePoseDataFilter.__call__": [[16, 95], ["torch.no_grad", "enumerate", "detectron2.structures.boxes.matched_boxlist_iou", "len", "proposals_filtered.append", "len", "hasattr", "len", "len", "len", "len", "len", "proposals_per_image.has", "len", "hasattr", "enumerate", "proposals_per_image.has", "zip"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.matched_boxlist_iou", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "__call__", "(", "self", ",", "features", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "proposals_with_targets", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Filters proposals with targets to keep only the ones relevant for\n        DensePose training\n\n        Args:\n            features (list[Tensor]): input data as a list of features,\n                each feature is a tensor. Axis 0 represents the number of\n                images `N` in the input data; axes 1-3 are channels,\n                height, and width, which may vary between features\n                (e.g., if a feature pyramid is used).\n            proposals_with_targets (list[Instances]): length `N` list of\n                `Instances`. The i-th `Instances` contains instances\n                (proposals, GT) for the i-th input image,\n        Returns:\n            list[Tensor]: filtered features\n            list[Instances]: filtered proposals\n        \"\"\"", "\n", "proposals_filtered", "=", "[", "]", "\n", "# TODO: the commented out code was supposed to correctly deal with situations", "\n", "# where no valid DensePose GT is available for certain images. The corresponding", "\n", "# image features were sliced and proposals were filtered. This led to performance", "\n", "# deterioration, both in terms of runtime and in terms of evaluation results.", "\n", "#", "\n", "# feature_mask = torch.ones(", "\n", "#    len(proposals_with_targets),", "\n", "#    dtype=torch.bool,", "\n", "#    device=features[0].device if len(features) > 0 else torch.device(\"cpu\"),", "\n", "# )", "\n", "for", "i", ",", "proposals_per_image", "in", "enumerate", "(", "proposals_with_targets", ")", ":", "\n", "            ", "if", "not", "proposals_per_image", ".", "has", "(", "\"gt_densepose\"", ")", "and", "(", "\n", "not", "proposals_per_image", ".", "has", "(", "\"gt_masks\"", ")", "or", "not", "self", ".", "keep_masks", "\n", ")", ":", "\n", "# feature_mask[i] = 0", "\n", "                ", "continue", "\n", "", "gt_boxes", "=", "proposals_per_image", ".", "gt_boxes", "\n", "est_boxes", "=", "proposals_per_image", ".", "proposal_boxes", "\n", "# apply match threshold for densepose head", "\n", "iou", "=", "matched_boxlist_iou", "(", "gt_boxes", ",", "est_boxes", ")", "\n", "iou_select", "=", "iou", ">", "self", ".", "iou_threshold", "\n", "proposals_per_image", "=", "proposals_per_image", "[", "iou_select", "]", "\n", "\n", "N_gt_boxes", "=", "len", "(", "proposals_per_image", ".", "gt_boxes", ")", "\n", "assert", "N_gt_boxes", "==", "len", "(", "proposals_per_image", ".", "proposal_boxes", ")", ",", "(", "\n", "f\"The number of GT boxes {N_gt_boxes} is different from the \"", "\n", "f\"number of proposal boxes {len(proposals_per_image.proposal_boxes)}\"", "\n", ")", "\n", "# filter out any target without suitable annotation", "\n", "if", "self", ".", "keep_masks", ":", "\n", "                ", "gt_masks", "=", "(", "\n", "proposals_per_image", ".", "gt_masks", "\n", "if", "hasattr", "(", "proposals_per_image", ",", "\"gt_masks\"", ")", "\n", "else", "[", "None", "]", "*", "N_gt_boxes", "\n", ")", "\n", "", "else", ":", "\n", "                ", "gt_masks", "=", "[", "None", "]", "*", "N_gt_boxes", "\n", "", "gt_densepose", "=", "(", "\n", "proposals_per_image", ".", "gt_densepose", "\n", "if", "hasattr", "(", "proposals_per_image", ",", "\"gt_densepose\"", ")", "\n", "else", "[", "None", "]", "*", "N_gt_boxes", "\n", ")", "\n", "assert", "len", "(", "gt_masks", ")", "==", "N_gt_boxes", "\n", "assert", "len", "(", "gt_densepose", ")", "==", "N_gt_boxes", "\n", "selected_indices", "=", "[", "\n", "i", "\n", "for", "i", ",", "(", "dp_target", ",", "mask_target", ")", "in", "enumerate", "(", "zip", "(", "gt_densepose", ",", "gt_masks", ")", ")", "\n", "if", "(", "dp_target", "is", "not", "None", ")", "or", "(", "mask_target", "is", "not", "None", ")", "\n", "]", "\n", "# if not len(selected_indices):", "\n", "#     feature_mask[i] = 0", "\n", "#     continue", "\n", "if", "len", "(", "selected_indices", ")", "!=", "N_gt_boxes", ":", "\n", "                ", "proposals_per_image", "=", "proposals_per_image", "[", "selected_indices", "]", "\n", "", "assert", "len", "(", "proposals_per_image", ".", "gt_boxes", ")", "==", "len", "(", "proposals_per_image", ".", "proposal_boxes", ")", "\n", "proposals_filtered", ".", "append", "(", "proposals_per_image", ")", "\n", "# features_filtered = [feature[feature_mask] for feature in features]", "\n", "# return features_filtered, proposals_filtered", "\n", "", "return", "features", ",", "proposals_filtered", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler._rand_boxes": [[14, 26], ["torch.rand", "torch.zeros", "torch.min", "torch.min", "torch.max", "torch.max"], "methods", ["None"], ["    ", "def", "_rand_boxes", "(", "self", ",", "num_boxes", ",", "x_max", ",", "y_max", ")", ":", "\n", "        ", "coords", "=", "torch", ".", "rand", "(", "num_boxes", ",", "4", ")", "\n", "coords", "[", ":", ",", "0", "]", "*=", "x_max", "\n", "coords", "[", ":", ",", "1", "]", "*=", "y_max", "\n", "coords", "[", ":", ",", "2", "]", "*=", "x_max", "\n", "coords", "[", ":", ",", "3", "]", "*=", "y_max", "\n", "boxes", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "4", ")", "\n", "boxes", "[", ":", ",", "0", "]", "=", "torch", ".", "min", "(", "coords", "[", ":", ",", "0", "]", ",", "coords", "[", ":", ",", "2", "]", ")", "\n", "boxes", "[", ":", ",", "1", "]", "=", "torch", ".", "min", "(", "coords", "[", ":", ",", "1", "]", ",", "coords", "[", ":", ",", "3", "]", ")", "\n", "boxes", "[", ":", ",", "2", "]", "=", "torch", ".", "max", "(", "coords", "[", ":", ",", "0", "]", ",", "coords", "[", ":", ",", "2", "]", ")", "\n", "boxes", "[", ":", ",", "3", "]", "=", "torch", ".", "max", "(", "coords", "[", ":", ",", "1", "]", ",", "coords", "[", ":", ",", "3", "]", ")", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match": [[27, 76], ["range", "detectron2.modeling.poolers.ROIPooler", "detectron2.modeling.poolers.ROIPooler.", "detectron2.modeling.poolers.ROIPooler", "detectron2.modeling.poolers.ROIPooler.", "test_roi_pooler.TestROIPooler.assertTrue", "feature.to", "test_roi_pooler.TestROIPooler._rand_boxes", "torch.zeros", "rois.append", "rois_rotated.append", "torch.allclose", "detectron2.structures.Boxes().to", "detectron2.structures.RotatedBoxes().to", "torch.rand", "detectron2.structures.Boxes", "detectron2.structures.RotatedBoxes"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler._rand_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "_test_roialignv2_roialignrotated_match", "(", "self", ",", "device", ")", ":", "\n", "        ", "pooler_resolution", "=", "14", "\n", "canonical_level", "=", "4", "\n", "canonical_scale_factor", "=", "2", "**", "canonical_level", "\n", "pooler_scales", "=", "(", "1.0", "/", "canonical_scale_factor", ",", ")", "\n", "sampling_ratio", "=", "0", "\n", "\n", "N", ",", "C", ",", "H", ",", "W", "=", "2", ",", "4", ",", "10", ",", "8", "\n", "N_rois", "=", "10", "\n", "std", "=", "11", "\n", "mean", "=", "0", "\n", "feature", "=", "(", "torch", ".", "rand", "(", "N", ",", "C", ",", "H", ",", "W", ")", "-", "0.5", ")", "*", "2", "*", "std", "+", "mean", "\n", "\n", "features", "=", "[", "feature", ".", "to", "(", "device", ")", "]", "\n", "\n", "rois", "=", "[", "]", "\n", "rois_rotated", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "N", ")", ":", "\n", "            ", "boxes", "=", "self", ".", "_rand_boxes", "(", "\n", "num_boxes", "=", "N_rois", ",", "x_max", "=", "W", "*", "canonical_scale_factor", ",", "y_max", "=", "H", "*", "canonical_scale_factor", "\n", ")", "\n", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N_rois", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "rois", ".", "append", "(", "Boxes", "(", "boxes", ")", ".", "to", "(", "device", ")", ")", "\n", "rois_rotated", ".", "append", "(", "RotatedBoxes", "(", "rotated_boxes", ")", ".", "to", "(", "device", ")", ")", "\n", "\n", "", "roialignv2_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "\"ROIAlignV2\"", ",", "\n", ")", "\n", "\n", "roialignv2_out", "=", "roialignv2_pooler", "(", "features", ",", "rois", ")", "\n", "\n", "roialignrotated_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "\"ROIAlignRotated\"", ",", "\n", ")", "\n", "\n", "roialignrotated_out", "=", "roialignrotated_pooler", "(", "features", ",", "rois_rotated", ")", "\n", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "roialignv2_out", ",", "roialignrotated_out", ",", "atol", "=", "1e-4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler.test_roialignv2_roialignrotated_match_cpu": [[77, 79], ["test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match"], ["", "def", "test_roialignv2_roialignrotated_match_cpu", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_roialignv2_roialignrotated_match", "(", "device", "=", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler.test_roialignv2_roialignrotated_match_cuda": [[80, 83], ["unittest.skipIf", "test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler._test_roialignv2_roialignrotated_match"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_roialignv2_roialignrotated_match_cuda", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_roialignv2_roialignrotated_match", "(", "device", "=", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler._test_scriptability": [[84, 117], ["range", "detectron2.modeling.poolers.ROIPooler", "detectron2.modeling.poolers.ROIPooler.", "test_roi_pooler.TestROIPooler.assertTrue", "feature.to", "test_roi_pooler.TestROIPooler._rand_boxes", "rois.append", "torch.jit.script", "torch.equal", "detectron2.structures.Boxes().to", "torch.rand", "detectron2.structures.Boxes"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler._rand_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "_test_scriptability", "(", "self", ",", "device", ")", ":", "\n", "        ", "pooler_resolution", "=", "14", "\n", "canonical_level", "=", "4", "\n", "canonical_scale_factor", "=", "2", "**", "canonical_level", "\n", "pooler_scales", "=", "(", "1.0", "/", "canonical_scale_factor", ",", ")", "\n", "sampling_ratio", "=", "0", "\n", "\n", "N", ",", "C", ",", "H", ",", "W", "=", "2", ",", "4", ",", "10", ",", "8", "\n", "N_rois", "=", "10", "\n", "std", "=", "11", "\n", "mean", "=", "0", "\n", "feature", "=", "(", "torch", ".", "rand", "(", "N", ",", "C", ",", "H", ",", "W", ")", "-", "0.5", ")", "*", "2", "*", "std", "+", "mean", "\n", "\n", "features", "=", "[", "feature", ".", "to", "(", "device", ")", "]", "\n", "\n", "rois", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "N", ")", ":", "\n", "            ", "boxes", "=", "self", ".", "_rand_boxes", "(", "\n", "num_boxes", "=", "N_rois", ",", "x_max", "=", "W", "*", "canonical_scale_factor", ",", "y_max", "=", "H", "*", "canonical_scale_factor", "\n", ")", "\n", "\n", "rois", ".", "append", "(", "Boxes", "(", "boxes", ")", ".", "to", "(", "device", ")", ")", "\n", "\n", "", "roialignv2_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "\"ROIAlignV2\"", ",", "\n", ")", "\n", "\n", "roialignv2_out", "=", "roialignv2_pooler", "(", "features", ",", "rois", ")", "\n", "scripted_roialignv2_out", "=", "torch", ".", "jit", ".", "script", "(", "roialignv2_pooler", ")", "(", "features", ",", "rois", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "roialignv2_out", ",", "scripted_roialignv2_out", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler.test_scriptability_cpu": [[118, 121], ["unittest.skipIf", "test_roi_pooler.TestROIPooler._test_scriptability"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler._test_scriptability"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_scriptability_cpu", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_scriptability", "(", "device", "=", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler.test_scriptability_gpu": [[122, 126], ["unittest.skipIf", "unittest.skipIf", "test_roi_pooler.TestROIPooler._test_scriptability", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler._test_scriptability"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_scriptability_gpu", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_scriptability", "(", "device", "=", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_pooler.TestROIPooler.test_no_images": [[127, 136], ["detectron2.modeling.poolers.ROIPooler", "detectron2.modeling.poolers.ROIPooler.forward", "test_roi_pooler.TestROIPooler.assertEqual", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward"], ["", "def", "test_no_images", "(", "self", ")", ":", "\n", "        ", "N", ",", "C", ",", "H", ",", "W", "=", "0", ",", "32", ",", "32", ",", "32", "\n", "feature", "=", "torch", ".", "rand", "(", "N", ",", "C", ",", "H", ",", "W", ")", "-", "0.5", "\n", "features", "=", "[", "feature", "]", "\n", "pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "14", ",", "scales", "=", "(", "1.0", ",", ")", ",", "sampling_ratio", "=", "0.0", ",", "pooler_type", "=", "\"ROIAlignV2\"", "\n", ")", "\n", "output", "=", "pooler", ".", "forward", "(", "features", ",", "[", "]", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "(", "0", ",", "C", ",", "14", ",", "14", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_matcher.TestMatcher.test_scriptability": [[13, 42], ["unittest.skipIf", "detectron2.config.get_cfg", "detectron2.modeling.matcher.Matcher", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.modeling.matcher.Matcher.", "test_matcher.TestMatcher.assertTrue", "test_matcher.TestMatcher.assertTrue", "scripted_anchor_matcher", "test_matcher.TestMatcher.assertTrue", "test_matcher.TestMatcher.assertTrue", "torch.allclose", "torch.allclose", "detectron2.modeling.matcher.Matcher", "torch.jit.script", "torch.allclose", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg"], ["    ", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "6", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_scriptability", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "anchor_matcher", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_THRESHOLDS", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_LABELS", ",", "allow_low_quality_matches", "=", "True", "\n", ")", "\n", "match_quality_matrix", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0.15", ",", "0.45", ",", "0.2", ",", "0.6", "]", ",", "[", "0.3", ",", "0.65", ",", "0.05", ",", "0.1", "]", ",", "[", "0.05", ",", "0.4", ",", "0.25", ",", "0.4", "]", "]", "\n", ")", "\n", "expected_matches", "=", "torch", ".", "tensor", "(", "[", "1", ",", "1", ",", "2", ",", "0", "]", ")", "\n", "expected_match_labels", "=", "torch", ".", "tensor", "(", "[", "-", "1", ",", "1", ",", "0", ",", "1", "]", ",", "dtype", "=", "torch", ".", "int8", ")", "\n", "\n", "matches", ",", "match_labels", "=", "anchor_matcher", "(", "match_quality_matrix", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "matches", ",", "expected_matches", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "match_labels", ",", "expected_match_labels", ")", ")", "\n", "\n", "# nonzero_tuple must be import explicitly to let jit know what it is.", "\n", "# https://github.com/pytorch/pytorch/issues/38964", "\n", "from", "detectron2", ".", "layers", "import", "nonzero_tuple", "# noqa F401", "\n", "\n", "def", "f", "(", "thresholds", ":", "List", "[", "float", "]", ",", "labels", ":", "List", "[", "int", "]", ")", ":", "\n", "            ", "return", "Matcher", "(", "thresholds", ",", "labels", ",", "allow_low_quality_matches", "=", "True", ")", "\n", "\n", "", "scripted_anchor_matcher", "=", "torch", ".", "jit", ".", "script", "(", "f", ")", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_THRESHOLDS", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_LABELS", "\n", ")", "\n", "matches", ",", "match_labels", "=", "scripted_anchor_matcher", "(", "match_quality_matrix", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "matches", ",", "expected_matches", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "match_labels", ",", "expected_match_labels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn": [[17, 46], ["torch.manual_seed", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers", "torch.rand", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers.", "torch.tensor", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "detectron2.structures.Boxes", "torch.tensor", "expected_losses.keys", "detectron2.layers.ShapeSpec", "detectron2.utils.events.EventStorage", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers.losses", "torch.tensor", "torch.tensor", "torch.allclose", "detectron2.modeling.box_regression.Box2BoxTransform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses"], ["    ", "def", "test_fast_rcnn", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "132", ")", "\n", "\n", "box_head_output_size", "=", "8", "\n", "\n", "box_predictor", "=", "FastRCNNOutputLayers", "(", "\n", "ShapeSpec", "(", "channels", "=", "box_head_output_size", ")", ",", "\n", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "(", "10", ",", "10", ",", "5", ",", "5", ")", ")", ",", "\n", "num_classes", "=", "5", ",", "\n", ")", "\n", "feature_pooled", "=", "torch", ".", "rand", "(", "2", ",", "box_head_output_size", ")", "\n", "predictions", "=", "box_predictor", "(", "feature_pooled", ")", "\n", "\n", "proposal_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "0.8", ",", "1.1", ",", "3.2", ",", "2.8", "]", ",", "[", "2.3", ",", "2.5", ",", "7", ",", "8", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "[", "2", ",", "2", ",", "6", ",", "6", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "proposal", "=", "Instances", "(", "(", "10", ",", "10", ")", ")", "\n", "proposal", ".", "proposal_boxes", "=", "Boxes", "(", "proposal_boxes", ")", "\n", "proposal", ".", "gt_boxes", "=", "Boxes", "(", "gt_boxes", ")", "\n", "proposal", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", "]", ")", "\n", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "losses", "=", "box_predictor", ".", "losses", "(", "predictions", ",", "[", "proposal", "]", ")", "\n", "\n", "", "expected_losses", "=", "{", "\n", "\"loss_cls\"", ":", "torch", ".", "tensor", "(", "1.7951188087", ")", ",", "\n", "\"loss_box_reg\"", ":", "torch", ".", "tensor", "(", "4.0357131958", ")", ",", "\n", "}", "\n", "for", "name", "in", "expected_losses", ".", "keys", "(", ")", ":", "\n", "            ", "assert", "torch", ".", "allclose", "(", "losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn_empty_batch": [[47, 65], ["detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers().to", "torch.randn", "torch.randn", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers().to.losses", "FastRCNNOutputLayers().to.losses.values", "sum().backward", "test_fast_rcnn.FastRCNNTest.assertTrue", "test_fast_rcnn.FastRCNNTest.assertTrue", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers().to.inference", "test_fast_rcnn.FastRCNNTest.assertEqual", "test_fast_rcnn.FastRCNNTest.assertTrue", "len", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers", "torch.allclose", "sum", "detectron2.layers.ShapeSpec", "torch.zeros_like", "FastRCNNOutputLayers().to.losses.values", "detectron2.modeling.box_regression.Box2BoxTransform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference"], ["", "", "def", "test_fast_rcnn_empty_batch", "(", "self", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "        ", "box_predictor", "=", "FastRCNNOutputLayers", "(", "\n", "ShapeSpec", "(", "channels", "=", "10", ")", ",", "\n", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "(", "10", ",", "10", ",", "5", ",", "5", ")", ")", ",", "\n", "num_classes", "=", "8", ",", "\n", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n", "logits", "=", "torch", ".", "randn", "(", "0", ",", "100", ",", "requires_grad", "=", "True", ",", "device", "=", "device", ")", "\n", "deltas", "=", "torch", ".", "randn", "(", "0", ",", "4", ",", "requires_grad", "=", "True", ",", "device", "=", "device", ")", "\n", "losses", "=", "box_predictor", ".", "losses", "(", "[", "logits", ",", "deltas", "]", ",", "[", "]", ")", "\n", "for", "value", "in", "losses", ".", "values", "(", ")", ":", "\n", "            ", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "value", ",", "torch", ".", "zeros_like", "(", "value", ")", ")", ")", "\n", "", "sum", "(", "losses", ".", "values", "(", ")", ")", ".", "backward", "(", ")", "\n", "self", ".", "assertTrue", "(", "logits", ".", "grad", "is", "not", "None", ")", "\n", "self", ".", "assertTrue", "(", "deltas", ".", "grad", "is", "not", "None", ")", "\n", "\n", "predictions", ",", "_", "=", "box_predictor", ".", "inference", "(", "[", "logits", ",", "deltas", "]", ",", "[", "]", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "predictions", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn_empty_batch_cuda": [[66, 69], ["unittest.skipIf", "test_fast_rcnn.FastRCNNTest.test_fast_rcnn_empty_batch", "torch.cuda.is_available", "torch.device"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn_empty_batch", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_fast_rcnn_empty_batch_cuda", "(", "self", ")", ":", "\n", "        ", "self", ".", "test_fast_rcnn_empty_batch", "(", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_fast_rcnn.FastRCNNTest.test_fast_rcnn_rotated": [[70, 103], ["torch.manual_seed", "detectron2.modeling.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers", "torch.rand", "detectron2.modeling.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers.", "torch.tensor", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "detectron2.structures.RotatedBoxes", "torch.tensor", "expected_losses.keys", "detectron2.layers.ShapeSpec", "detectron2.utils.events.EventStorage", "detectron2.modeling.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers.losses", "torch.tensor", "torch.tensor", "torch.allclose", "detectron2.modeling.box_regression.Box2BoxTransformRotated"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "test_fast_rcnn_rotated", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "132", ")", "\n", "box_head_output_size", "=", "8", "\n", "\n", "box_predictor", "=", "RotatedFastRCNNOutputLayers", "(", "\n", "ShapeSpec", "(", "channels", "=", "box_head_output_size", ")", ",", "\n", "box2box_transform", "=", "Box2BoxTransformRotated", "(", "weights", "=", "(", "10", ",", "10", ",", "5", ",", "5", ",", "1", ")", ")", ",", "\n", "num_classes", "=", "5", ",", "\n", ")", "\n", "feature_pooled", "=", "torch", ".", "rand", "(", "2", ",", "box_head_output_size", ")", "\n", "predictions", "=", "box_predictor", "(", "feature_pooled", ")", "\n", "proposal_boxes", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "2", ",", "1.95", ",", "2.4", ",", "1.7", ",", "0", "]", ",", "[", "4.65", ",", "5.25", ",", "4.7", ",", "5.5", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", "\n", ")", "\n", "gt_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "2", ",", "2", ",", "2", ",", "0", "]", ",", "[", "4", ",", "4", ",", "4", ",", "4", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "proposal", "=", "Instances", "(", "(", "10", ",", "10", ")", ")", "\n", "proposal", ".", "proposal_boxes", "=", "RotatedBoxes", "(", "proposal_boxes", ")", "\n", "proposal", ".", "gt_boxes", "=", "RotatedBoxes", "(", "gt_boxes", ")", "\n", "proposal", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", "]", ")", "\n", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "losses", "=", "box_predictor", ".", "losses", "(", "predictions", ",", "[", "proposal", "]", ")", "\n", "\n", "# Note: the expected losses are slightly different even if", "\n", "# the boxes are essentially the same as in the FastRCNNOutput test, because", "\n", "# bbox_pred in FastRCNNOutputLayers have different Linear layers/initialization", "\n", "# between the two cases.", "\n", "", "expected_losses", "=", "{", "\n", "\"loss_cls\"", ":", "torch", ".", "tensor", "(", "1.7920907736", ")", ",", "\n", "\"loss_box_reg\"", ":", "torch", ".", "tensor", "(", "4.0410838127", ")", ",", "\n", "}", "\n", "for", "name", "in", "expected_losses", ".", "keys", "(", ")", ":", "\n", "            ", "assert", "torch", ".", "allclose", "(", "losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_heads.ROIHeadsTest.test_roi_heads": [[32, 84], ["torch.manual_seed", "detectron2.config.get_cfg", "torch.rand", "detectron2.structures.ImageList", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor", "detectron2.structures.BitMasks", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor", "detectron2.structures.BitMasks", "detectron2.modeling.proposal_generator.build.build_proposal_generator", "detectron2.modeling.roi_heads.StandardROIHeads", "detector_losses.update", "all", "test_roi_heads.ROIHeadsTest.assertTrue", "torch.rand", "detectron2.layers.ShapeSpec", "detectron2.utils.events.EventStorage", "detectron2.modeling.proposal_generator.build.build_proposal_generator.", "detectron2.modeling.roi_heads.StandardROIHeads.", "torch.rand", "torch.rand", "torch.allclose", "torch.tensor", "detector_losses.keys", "v.item", "expected_losses.get", "detector_losses.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["    ", "def", "test_roi_heads", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "121", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NAME", "=", "\"FastRCNNConvFCHead\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_FC", "=", "2", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignV2\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", "=", "(", "10", ",", "10", ",", "5", ",", "5", ")", "\n", "cfg", ".", "MODEL", ".", "MASK_ON", "=", "True", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "20", ",", "30", ")", "\n", "image_sizes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "20", ",", "30", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "num_channels", "=", "1024", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "num_channels", ",", "1", ",", "2", ")", "}", "\n", "feature_shape", "=", "{", "\"res4\"", ":", "ShapeSpec", "(", "channels", "=", "num_channels", ",", "stride", "=", "16", ")", "}", "\n", "\n", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "gt_boxes0", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "[", "2", ",", "2", ",", "6", ",", "6", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instance0", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instance0", ".", "gt_boxes", "=", "Boxes", "(", "gt_boxes0", ")", "\n", "gt_instance0", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "2", ",", "1", "]", ")", "\n", "gt_instance0", ".", "gt_masks", "=", "BitMasks", "(", "torch", ".", "rand", "(", "(", "2", ",", ")", "+", "image_shape", ")", ">", "0.5", ")", "\n", "gt_boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "5", ",", "2", ",", "8", "]", ",", "[", "7", ",", "3", ",", "10", ",", "5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instance1", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instance1", ".", "gt_boxes", "=", "Boxes", "(", "gt_boxes1", ")", "\n", "gt_instance1", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", "]", ")", "\n", "gt_instance1", ".", "gt_masks", "=", "BitMasks", "(", "torch", ".", "rand", "(", "(", "2", ",", ")", "+", "image_shape", ")", ">", "0.5", ")", "\n", "gt_instances", "=", "[", "gt_instance0", ",", "gt_instance1", "]", "\n", "\n", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "feature_shape", ")", "\n", "roi_heads", "=", "StandardROIHeads", "(", "cfg", ",", "feature_shape", ")", "\n", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "proposals", ",", "proposal_losses", "=", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "_", ",", "detector_losses", "=", "roi_heads", "(", "images", ",", "features", ",", "proposals", ",", "gt_instances", ")", "\n", "\n", "", "detector_losses", ".", "update", "(", "proposal_losses", ")", "\n", "expected_losses", "=", "{", "\n", "\"loss_cls\"", ":", "4.5253729820251465", ",", "\n", "\"loss_box_reg\"", ":", "0.009785720147192478", ",", "\n", "\"loss_mask\"", ":", "0.693184494972229", ",", "\n", "\"loss_rpn_cls\"", ":", "0.08186662942171097", ",", "\n", "\"loss_rpn_loc\"", ":", "0.1104838103055954", ",", "\n", "}", "\n", "succ", "=", "all", "(", "\n", "torch", ".", "allclose", "(", "detector_losses", "[", "name", "]", ",", "torch", ".", "tensor", "(", "expected_losses", ".", "get", "(", "name", ",", "0.0", ")", ")", ")", "\n", "for", "name", "in", "detector_losses", ".", "keys", "(", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "succ", ",", "\n", "\"Losses has changed! New losses: {}\"", ".", "format", "(", "\n", "{", "k", ":", "v", ".", "item", "(", ")", "for", "k", ",", "v", "in", "detector_losses", ".", "items", "(", ")", "}", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_heads.ROIHeadsTest.test_rroi_heads": [[87, 140], ["torch.manual_seed", "detectron2.config.get_cfg", "torch.rand", "detectron2.structures.ImageList", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "torch.tensor", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "torch.tensor", "detectron2.modeling.proposal_generator.build.build_proposal_generator", "detectron2.modeling.roi_heads.build_roi_heads", "detector_losses.update", "all", "test_roi_heads.ROIHeadsTest.assertTrue", "torch.rand", "detectron2.layers.ShapeSpec", "detectron2.utils.events.EventStorage", "detectron2.modeling.proposal_generator.build.build_proposal_generator.", "detectron2.modeling.roi_heads.build_roi_heads.", "torch.allclose", "torch.tensor", "detector_losses.keys", "v.item", "expected_losses.get", "detector_losses.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.build_roi_heads", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "test_rroi_heads", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "121", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "PROPOSAL_GENERATOR", ".", "NAME", "=", "\"RRPN\"", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "NAME", "=", "\"RotatedAnchorGenerator\"", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NAME", "=", "\"RROIHeads\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NAME", "=", "\"FastRCNNConvFCHead\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_FC", "=", "2", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_WEIGHTS", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", "=", "\"StandardRPNHead\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignRotated\"", "\n", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", "=", "(", "10", ",", "10", ",", "5", ",", "5", ",", "1", ")", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "20", ",", "30", ")", "\n", "image_sizes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "20", ",", "30", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "num_channels", "=", "1024", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "num_channels", ",", "1", ",", "2", ")", "}", "\n", "feature_shape", "=", "{", "\"res4\"", ":", "ShapeSpec", "(", "channels", "=", "num_channels", ",", "stride", "=", "16", ")", "}", "\n", "\n", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "gt_boxes0", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "2", ",", "2", ",", "2", ",", "30", "]", ",", "[", "4", ",", "4", ",", "4", ",", "4", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instance0", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instance0", ".", "gt_boxes", "=", "RotatedBoxes", "(", "gt_boxes0", ")", "\n", "gt_instance0", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "2", ",", "1", "]", ")", "\n", "gt_boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "5.5", ",", "1", ",", "3", ",", "0", "]", ",", "[", "8.5", ",", "4", ",", "3", ",", "2", ",", "-", "50", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instance1", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instance1", ".", "gt_boxes", "=", "RotatedBoxes", "(", "gt_boxes1", ")", "\n", "gt_instance1", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", "]", ")", "\n", "gt_instances", "=", "[", "gt_instance0", ",", "gt_instance1", "]", "\n", "\n", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "feature_shape", ")", "\n", "roi_heads", "=", "build_roi_heads", "(", "cfg", ",", "feature_shape", ")", "\n", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "proposals", ",", "proposal_losses", "=", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "_", ",", "detector_losses", "=", "roi_heads", "(", "images", ",", "features", ",", "proposals", ",", "gt_instances", ")", "\n", "\n", "", "detector_losses", ".", "update", "(", "proposal_losses", ")", "\n", "expected_losses", "=", "{", "\n", "\"loss_cls\"", ":", "4.365657806396484", ",", "\n", "\"loss_box_reg\"", ":", "0.0015851043863222003", ",", "\n", "\"loss_rpn_cls\"", ":", "0.2427729219198227", ",", "\n", "\"loss_rpn_loc\"", ":", "0.3646621108055115", ",", "\n", "}", "\n", "succ", "=", "all", "(", "\n", "torch", ".", "allclose", "(", "detector_losses", "[", "name", "]", ",", "torch", ".", "tensor", "(", "expected_losses", ".", "get", "(", "name", ",", "0.0", ")", ")", ")", "\n", "for", "name", "in", "detector_losses", ".", "keys", "(", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "succ", ",", "\n", "\"Losses has changed! New losses: {}\"", ".", "format", "(", "\n", "{", "k", ":", "v", ".", "item", "(", ")", "for", "k", ",", "v", "in", "detector_losses", ".", "items", "(", ")", "}", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_heads.ROIHeadsTest.test_box_head_scriptability": [[143, 156], ["unittest.skipIf", "detectron2.layers.ShapeSpec", "torch.randn", "detectron2.modeling.roi_heads.FastRCNNConvFCHead().eval", "torch.jit.script", "detectron2.modeling.roi_heads.FastRCNNConvFCHead().eval.", "torch.jit.script.", "test_roi_heads.ROIHeadsTest.assertTrue", "torch.equal", "detectron2.modeling.roi_heads.FastRCNNConvFCHead"], "methods", ["None"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_box_head_scriptability", "(", "self", ")", ":", "\n", "        ", "input_shape", "=", "ShapeSpec", "(", "channels", "=", "1024", ",", "height", "=", "14", ",", "width", "=", "14", ")", "\n", "box_features", "=", "torch", ".", "randn", "(", "4", ",", "1024", ",", "14", ",", "14", ")", "\n", "\n", "box_head", "=", "FastRCNNConvFCHead", "(", "\n", "input_shape", ",", "conv_dims", "=", "[", "512", ",", "512", "]", ",", "fc_dims", "=", "[", "1024", ",", "1024", "]", "\n", ")", ".", "eval", "(", ")", "\n", "script_box_head", "=", "torch", ".", "jit", ".", "script", "(", "box_head", ")", "\n", "\n", "origin_output", "=", "box_head", "(", "box_features", ")", "\n", "script_output", "=", "script_box_head", "(", "box_features", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "origin_output", ",", "script_output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_heads.ROIHeadsTest.test_mask_head_scriptability": [[157, 188], ["unittest.skipIf", "detectron2.layers.ShapeSpec", "torch.randn", "detectron2.structures.Instances", "torch.tensor", "detectron2.structures.Instances", "torch.tensor", "detectron2.modeling.roi_heads.MaskRCNNConvUpsampleHead().eval", "detectron2.modeling.roi_heads.MaskRCNNConvUpsampleHead().eval.", "zip", "copy.deepcopy", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "NewInstances.from_instances", "NewInstances.from_instances", "torch.jit.script.", "test_roi_heads.ROIHeadsTest.assertEqual", "test_roi_heads.ROIHeadsTest.assertTrue", "test_roi_heads.ROIHeadsTest.assertTrue", "detectron2.modeling.roi_heads.MaskRCNNConvUpsampleHead", "torch.equal", "torch.equal"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_mask_head_scriptability", "(", "self", ")", ":", "\n", "        ", "input_shape", "=", "ShapeSpec", "(", "channels", "=", "1024", ")", "\n", "mask_features", "=", "torch", ".", "randn", "(", "4", ",", "1024", ",", "14", ",", "14", ")", "\n", "\n", "image_shapes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "15", ",", "15", ")", "]", "\n", "pred_instance0", "=", "Instances", "(", "image_shapes", "[", "0", "]", ")", "\n", "pred_classes0", "=", "torch", ".", "tensor", "(", "[", "1", ",", "2", ",", "3", "]", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "pred_instance0", ".", "pred_classes", "=", "pred_classes0", "\n", "pred_instance1", "=", "Instances", "(", "image_shapes", "[", "1", "]", ")", "\n", "pred_classes1", "=", "torch", ".", "tensor", "(", "[", "4", "]", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "pred_instance1", ".", "pred_classes", "=", "pred_classes1", "\n", "\n", "mask_head", "=", "MaskRCNNConvUpsampleHead", "(", "\n", "input_shape", ",", "num_classes", "=", "80", ",", "conv_dims", "=", "[", "256", ",", "256", "]", "\n", ")", ".", "eval", "(", ")", "\n", "# pred_instance will be in-place changed during the inference", "\n", "# process of `MaskRCNNConvUpsampleHead`", "\n", "origin_outputs", "=", "mask_head", "(", "mask_features", ",", "deepcopy", "(", "[", "pred_instance0", ",", "pred_instance1", "]", ")", ")", "\n", "\n", "fields", "=", "{", "\"pred_masks\"", ":", "\"Tensor\"", ",", "\"pred_classes\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "NewInstances", ":", "\n", "            ", "sciript_mask_head", "=", "torch", ".", "jit", ".", "script", "(", "mask_head", ")", "\n", "pred_instance0", "=", "NewInstances", ".", "from_instances", "(", "pred_instance0", ")", "\n", "pred_instance1", "=", "NewInstances", ".", "from_instances", "(", "pred_instance1", ")", "\n", "script_outputs", "=", "sciript_mask_head", "(", "mask_features", ",", "[", "pred_instance0", ",", "pred_instance1", "]", ")", "\n", "\n", "", "for", "origin_ins", ",", "script_ins", "in", "zip", "(", "origin_outputs", ",", "script_outputs", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "origin_ins", ".", "image_size", ",", "script_ins", ".", "image_size", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "origin_ins", ".", "pred_classes", ",", "script_ins", ".", "pred_classes", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "origin_ins", ".", "pred_masks", ",", "script_ins", ".", "pred_masks", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_roi_heads.ROIHeadsTest.test_keypoint_head_scriptability": [[189, 227], ["unittest.skipIf", "detectron2.layers.ShapeSpec", "torch.randn", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "detectron2.modeling.roi_heads.KRCNNConvDeconvUpsampleHead().eval", "detectron2.modeling.roi_heads.KRCNNConvDeconvUpsampleHead().eval.", "zip", "copy.deepcopy", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "NewInstances.from_instances", "NewInstances.from_instances", "torch.jit.script.", "test_roi_heads.ROIHeadsTest.assertEqual", "test_roi_heads.ROIHeadsTest.assertTrue", "test_roi_heads.ROIHeadsTest.assertTrue", "detectron2.modeling.roi_heads.KRCNNConvDeconvUpsampleHead", "torch.equal", "torch.equal"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances"], ["", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_keypoint_head_scriptability", "(", "self", ")", ":", "\n", "        ", "input_shape", "=", "ShapeSpec", "(", "channels", "=", "1024", ",", "height", "=", "14", ",", "width", "=", "14", ")", "\n", "keypoint_features", "=", "torch", ".", "randn", "(", "4", ",", "1024", ",", "14", ",", "14", ")", "\n", "\n", "image_shapes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "15", ",", "15", ")", "]", "\n", "pred_boxes0", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "[", "2", ",", "2", ",", "6", ",", "6", "]", ",", "[", "1", ",", "5", ",", "2", ",", "8", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "pred_instance0", "=", "Instances", "(", "image_shapes", "[", "0", "]", ")", "\n", "pred_instance0", ".", "pred_boxes", "=", "Boxes", "(", "pred_boxes0", ")", "\n", "pred_boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "7", ",", "3", ",", "10", ",", "5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "pred_instance1", "=", "Instances", "(", "image_shapes", "[", "1", "]", ")", "\n", "pred_instance1", ".", "pred_boxes", "=", "Boxes", "(", "pred_boxes1", ")", "\n", "\n", "keypoint_head", "=", "KRCNNConvDeconvUpsampleHead", "(", "\n", "input_shape", ",", "num_keypoints", "=", "17", ",", "conv_dims", "=", "[", "512", ",", "512", "]", "\n", ")", ".", "eval", "(", ")", "\n", "origin_outputs", "=", "keypoint_head", "(", "\n", "keypoint_features", ",", "deepcopy", "(", "[", "pred_instance0", ",", "pred_instance1", "]", ")", "\n", ")", "\n", "\n", "fields", "=", "{", "\n", "\"pred_boxes\"", ":", "\"Boxes\"", ",", "\n", "\"pred_keypoints\"", ":", "\"Tensor\"", ",", "\n", "\"pred_keypoint_heatmaps\"", ":", "\"Tensor\"", ",", "\n", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "NewInstances", ":", "\n", "            ", "sciript_keypoint_head", "=", "torch", ".", "jit", ".", "script", "(", "keypoint_head", ")", "\n", "pred_instance0", "=", "NewInstances", ".", "from_instances", "(", "pred_instance0", ")", "\n", "pred_instance1", "=", "NewInstances", ".", "from_instances", "(", "pred_instance1", ")", "\n", "script_outputs", "=", "sciript_keypoint_head", "(", "\n", "keypoint_features", ",", "[", "pred_instance0", ",", "pred_instance1", "]", "\n", ")", "\n", "\n", "", "for", "origin_ins", ",", "script_ins", "in", "zip", "(", "origin_outputs", ",", "script_outputs", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "origin_ins", ".", "image_size", ",", "script_ins", ".", "image_size", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "origin_ins", ".", "pred_keypoints", ",", "script_ins", ".", "pred_keypoints", ")", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "equal", "(", "origin_ins", ".", "pred_keypoint_heatmaps", ",", "script_ins", ".", "pred_keypoint_heatmaps", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.ModelE2ETest.setUp": [[52, 55], ["torch.manual_seed", "test_model_e2e.get_model_zoo"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.get_model_zoo"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.ModelE2ETest._test_eval": [[56, 60], ["test_model_e2e.ModelE2ETest.model.eval", "test_model_e2e.ModelE2ETest.model", "test_model_e2e.create_model_input", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.create_model_input"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.ModelE2ETest._test_train": [[61, 72], ["test_model_e2e.ModelE2ETest.model.train", "len", "len", "test_model_e2e.create_model_input", "detectron2.utils.events.EventStorage", "test_model_e2e.ModelE2ETest.model", "sum().backward", "torch.rand", "zip", "sum", "test_model_e2e.ModelE2ETest.values"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.create_model_input", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat._SwapAlign2Nat.backward"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.ModelE2ETest._inf_tensor": [[73, 75], ["torch.zeros"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.ModelE2ETest._nan_tensor": [[76, 78], ["torch.zeros().fill_", "float", "torch.zeros"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.ModelE2ETest.test_empty_data": [[79, 83], ["test_model_e2e.ModelE2ETest._test_eval", "test_model_e2e.ModelE2ETest._test_train", "test_model_e2e.get_empty_instance", "test_model_e2e.get_empty_instance"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_e2e.ModelE2ETest._test_eval", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.ModelE2ETest._test_train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.get_empty_instance", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.get_empty_instance"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.ModelE2ETest.test_eval_tocpu": [[84, 91], ["unittest.skipIf", "get_model_zoo().cpu", "get_model_zoo().cpu.eval", "get_model_zoo().cpu.", "test_model_e2e.create_model_input", "torch.cuda.is_available", "test_model_e2e.get_model_zoo", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.create_model_input", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.get_model_zoo"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.MaskRCNNE2ETest.test_half_empty_data": [[96, 99], ["test_model_e2e.MaskRCNNE2ETest._test_train", "test_model_e2e.get_empty_instance", "test_model_e2e.get_regular_bitmask_instances"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.ModelE2ETest._test_train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.get_empty_instance", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.get_regular_bitmask_instances"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.MaskRCNNE2ETest.test_roiheads_inf_nan_data": [[115, 131], ["test_model_e2e.MaskRCNNE2ETest.model.eval", "detectron2.structures.ImageList", "detectron2.structures.Boxes().to", "torch.tensor().reshape", "test_model_e2e.MaskRCNNE2ETest.model.roi_heads", "test_model_e2e.MaskRCNNE2ETest.assertEqual", "tensor", "tensor", "tensor", "tensor", "tensor", "tensor", "detectron2.structures.Instances", "len", "detectron2.structures.Boxes", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.RetinaNetE2ETest.test_inf_nan_data": [[136, 158], ["test_model_e2e.RetinaNetE2ETest.model.eval", "detectron2.structures.ImageList", "test_model_e2e.RetinaNetE2ETest.model.anchor_generator", "test_model_e2e.RetinaNetE2ETest.model.head", "test_model_e2e.RetinaNetE2ETest.model.inference", "len", "tensor", "tensor", "tensor", "tensor", "tensor", "tensor", "tensor", "tensor", "test_model_e2e.RetinaNetE2ETest.assertTrue", "numpy.prod", "torch.isfinite().sum", "torch.isfinite"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.get_model_zoo": [[15, 25], ["detectron2.get_config_file", "detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.modeling.build_model", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get_config_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model"], ["\n", "", "return", "{", "\"image\"", ":", "image", ",", "\"instances\"", ":", "instances", "}", "\n", "\n", "\n", "", "def", "make_empty_instances", "(", "h", ",", "w", ")", ":", "\n", "    ", "instances", "=", "Instances", "(", "(", "h", ",", "w", ")", ")", "\n", "instances", ".", "gt_boxes", "=", "Boxes", "(", "torch", ".", "rand", "(", "0", ",", "4", ")", ")", "\n", "instances", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "]", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int64", ")", "\n", "instances", ".", "gt_masks", "=", "BitMasks", "(", "torch", ".", "rand", "(", "0", ",", "h", ",", "w", ")", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.create_model_input": [[27, 32], ["None"], "function", ["None"], ["", "class", "ModelE2ETest", "(", "unittest", ".", "TestCase", ")", ":", "\n", "    ", "CONFIG_PATH", "=", "\"\"", "\n", "\n", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", "=", "get_model", "(", "self", ".", "CONFIG_PATH", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.get_empty_instance": [[34, 40], ["detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor().to", "detectron2.structures.BitMasks", "torch.rand", "torch.rand", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["        ", "inputs", "=", "[", "make_model_inputs", "(", "torch", ".", "rand", "(", "3", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ")", ")", "for", "size", "in", "sizes", "]", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "model", "(", "inputs", ")", "\n", "\n", "\n", "", "", "class", "DensePoseRCNNE2ETest", "(", "ModelE2ETest", ")", ":", "\n", "    ", "CONFIG_PATH", "=", "\"densepose_rcnn_R_101_FPN_s1x.yaml\"", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_model_e2e.get_regular_bitmask_instances": [[42, 49], ["detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor().to", "detectron2.structures.BitMasks", "torch.rand", "torch.tensor", "torch.rand"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["def", "test_empty_data", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_eval", "(", "[", "(", "200", ",", "250", ")", ",", "(", "200", ",", "249", ")", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_anchor_generator.TestAnchorGenerator.test_default_anchor_generator": [[15, 44], ["detectron2.config.get_cfg", "detectron2.modeling.anchor_generator.DefaultAnchorGenerator", "detectron2.modeling.anchor_generator.DefaultAnchorGenerator.", "torch.tensor", "torch.allclose", "torch.rand", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg"], ["    ", "def", "test_default_anchor_generator", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "=", "[", "[", "32", ",", "64", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", "=", "[", "[", "0.25", ",", "1", ",", "4", "]", "]", "\n", "\n", "anchor_generator", "=", "DefaultAnchorGenerator", "(", "cfg", ",", "[", "ShapeSpec", "(", "stride", "=", "4", ")", "]", ")", "\n", "\n", "# only the last two dimensions of features matter here", "\n", "num_images", "=", "2", "\n", "features", "=", "{", "\"stage3\"", ":", "torch", ".", "rand", "(", "num_images", ",", "96", ",", "1", ",", "2", ")", "}", "\n", "anchors", "=", "anchor_generator", "(", "[", "features", "[", "\"stage3\"", "]", "]", ")", "\n", "expected_anchor_tensor", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "-", "32.0", ",", "-", "8.0", ",", "32.0", ",", "8.0", "]", ",", "\n", "[", "-", "16.0", ",", "-", "16.0", ",", "16.0", ",", "16.0", "]", ",", "\n", "[", "-", "8.0", ",", "-", "32.0", ",", "8.0", ",", "32.0", "]", ",", "\n", "[", "-", "64.0", ",", "-", "16.0", ",", "64.0", ",", "16.0", "]", ",", "\n", "[", "-", "32.0", ",", "-", "32.0", ",", "32.0", ",", "32.0", "]", ",", "\n", "[", "-", "16.0", ",", "-", "64.0", ",", "16.0", ",", "64.0", "]", ",", "\n", "[", "-", "28.0", ",", "-", "8.0", ",", "36.0", ",", "8.0", "]", ",", "# -28.0 == -32.0 + STRIDE (4)", "\n", "[", "-", "12.0", ",", "-", "16.0", ",", "20.0", ",", "16.0", "]", ",", "\n", "[", "-", "4.0", ",", "-", "32.0", ",", "12.0", ",", "32.0", "]", ",", "\n", "[", "-", "60.0", ",", "-", "16.0", ",", "68.0", ",", "16.0", "]", ",", "\n", "[", "-", "28.0", ",", "-", "32.0", ",", "36.0", ",", "32.0", "]", ",", "\n", "[", "-", "12.0", ",", "-", "64.0", ",", "20.0", ",", "64.0", "]", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "anchors", "[", "0", "]", ".", "tensor", ",", "expected_anchor_tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_anchor_generator.TestAnchorGenerator.test_default_anchor_generator_centered": [[45, 77], ["detectron2.modeling.anchor_generator.DefaultAnchorGenerator", "torch.tensor", "detectron2.modeling.anchor_generator.DefaultAnchorGenerator.", "torch.allclose", "torch.rand", "torch.allclose", "torch.jit.script"], "methods", ["None"], ["", "def", "test_default_anchor_generator_centered", "(", "self", ")", ":", "\n", "# test explicit args", "\n", "        ", "anchor_generator", "=", "DefaultAnchorGenerator", "(", "\n", "sizes", "=", "[", "32", ",", "64", "]", ",", "aspect_ratios", "=", "[", "0.25", ",", "1", ",", "4", "]", ",", "strides", "=", "[", "4", "]", "\n", ")", "\n", "\n", "# only the last two dimensions of features matter here", "\n", "num_images", "=", "2", "\n", "features", "=", "{", "\"stage3\"", ":", "torch", ".", "rand", "(", "num_images", ",", "96", ",", "1", ",", "2", ")", "}", "\n", "expected_anchor_tensor", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "-", "30.0", ",", "-", "6.0", ",", "34.0", ",", "10.0", "]", ",", "\n", "[", "-", "14.0", ",", "-", "14.0", ",", "18.0", ",", "18.0", "]", ",", "\n", "[", "-", "6.0", ",", "-", "30.0", ",", "10.0", ",", "34.0", "]", ",", "\n", "[", "-", "62.0", ",", "-", "14.0", ",", "66.0", ",", "18.0", "]", ",", "\n", "[", "-", "30.0", ",", "-", "30.0", ",", "34.0", ",", "34.0", "]", ",", "\n", "[", "-", "14.0", ",", "-", "62.0", ",", "18.0", ",", "66.0", "]", ",", "\n", "[", "-", "26.0", ",", "-", "6.0", ",", "38.0", ",", "10.0", "]", ",", "\n", "[", "-", "10.0", ",", "-", "14.0", ",", "22.0", ",", "18.0", "]", ",", "\n", "[", "-", "2.0", ",", "-", "30.0", ",", "14.0", ",", "34.0", "]", ",", "\n", "[", "-", "58.0", ",", "-", "14.0", ",", "70.0", ",", "18.0", "]", ",", "\n", "[", "-", "26.0", ",", "-", "30.0", ",", "38.0", ",", "34.0", "]", ",", "\n", "[", "-", "10.0", ",", "-", "62.0", ",", "22.0", ",", "66.0", "]", ",", "\n", "]", "\n", ")", "\n", "\n", "anchors", "=", "anchor_generator", "(", "[", "features", "[", "\"stage3\"", "]", "]", ")", "\n", "assert", "torch", ".", "allclose", "(", "anchors", "[", "0", "]", ".", "tensor", ",", "expected_anchor_tensor", ")", "\n", "\n", "if", "TORCH_VERSION", ">=", "(", "1", ",", "6", ")", ":", "\n", "            ", "anchors", "=", "torch", ".", "jit", ".", "script", "(", "anchor_generator", ")", "(", "[", "features", "[", "\"stage3\"", "]", "]", ")", "\n", "assert", "torch", ".", "allclose", "(", "anchors", "[", "0", "]", ".", "tensor", ",", "expected_anchor_tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_anchor_generator.TestAnchorGenerator.test_rrpn_anchor_generator": [[78, 119], ["detectron2.config.get_cfg", "detectron2.modeling.anchor_generator.RotatedAnchorGenerator", "detectron2.modeling.anchor_generator.RotatedAnchorGenerator.", "torch.tensor", "torch.allclose", "torch.rand", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg"], ["", "", "def", "test_rrpn_anchor_generator", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "=", "[", "[", "32", ",", "64", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", "=", "[", "[", "0.25", ",", "1", ",", "4", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ANGLES", "=", "[", "0", ",", "45", "]", "# test single list[float]", "\n", "anchor_generator", "=", "RotatedAnchorGenerator", "(", "cfg", ",", "[", "ShapeSpec", "(", "stride", "=", "4", ")", "]", ")", "\n", "\n", "# only the last two dimensions of features matter here", "\n", "num_images", "=", "2", "\n", "features", "=", "{", "\"stage3\"", ":", "torch", ".", "rand", "(", "num_images", ",", "96", ",", "1", ",", "2", ")", "}", "\n", "anchors", "=", "anchor_generator", "(", "[", "features", "[", "\"stage3\"", "]", "]", ")", "\n", "expected_anchor_tensor", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.0", ",", "0.0", ",", "64.0", ",", "16.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "64.0", ",", "16.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "32.0", ",", "32.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "32.0", ",", "32.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "16.0", ",", "64.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "16.0", ",", "64.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "128.0", ",", "32.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "128.0", ",", "32.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "64.0", ",", "64.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "64.0", ",", "64.0", ",", "45.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "32.0", ",", "128.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "32.0", ",", "128.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "64.0", ",", "16.0", ",", "0.0", "]", ",", "# 4.0 == 0.0 + STRIDE (4)", "\n", "[", "4.0", ",", "0.0", ",", "64.0", ",", "16.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "32.0", ",", "32.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "32.0", ",", "32.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "16.0", ",", "64.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "16.0", ",", "64.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "128.0", ",", "32.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "128.0", ",", "32.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "64.0", ",", "64.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "64.0", ",", "64.0", ",", "45.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "32.0", ",", "128.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "0.0", ",", "32.0", ",", "128.0", ",", "45.0", "]", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "anchors", "[", "0", "]", ".", "tensor", ",", "expected_anchor_tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_box2box_transform.TestBox2BoxTransform.test_reconstruction": [[16, 31], ["detectron2.modeling.box_regression.Box2BoxTransform", "test_box2box_transform.random_boxes", "test_box2box_transform.random_boxes", "torch.cuda.is_available", "torch.device", "devices.append", "src_boxes.to.to.to", "dst_boxes.to.to.to", "detectron2.modeling.box_regression.Box2BoxTransform.get_deltas", "detectron2.modeling.box_regression.Box2BoxTransform.apply_deltas", "torch.allclose", "torch.device"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_box2box_transform.random_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_box2box_transform.random_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["    ", "def", "test_reconstruction", "(", "self", ")", ":", "\n", "        ", "weights", "=", "(", "5", ",", "5", ",", "10", ",", "10", ")", "\n", "b2b_tfm", "=", "Box2BoxTransform", "(", "weights", "=", "weights", ")", "\n", "src_boxes", "=", "random_boxes", "(", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "1", ",", "10", ")", "\n", "dst_boxes", "=", "random_boxes", "(", "[", "10", ",", "10", ",", "20", ",", "20", "]", ",", "1", ",", "10", ")", "\n", "\n", "devices", "=", "[", "torch", ".", "device", "(", "\"cpu\"", ")", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "devices", ".", "append", "(", "torch", ".", "device", "(", "\"cuda\"", ")", ")", "\n", "", "for", "device", "in", "devices", ":", "\n", "            ", "src_boxes", "=", "src_boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "dst_boxes", "=", "dst_boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "deltas", "=", "b2b_tfm", ".", "get_deltas", "(", "src_boxes", ",", "dst_boxes", ")", "\n", "dst_boxes_reconstructed", "=", "b2b_tfm", ".", "apply_deltas", "(", "deltas", ",", "src_boxes", ")", "\n", "assert", "torch", ".", "allclose", "(", "dst_boxes", ",", "dst_boxes_reconstructed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_box2box_transform.TestBox2BoxTransformRotated.test_reconstruction": [[40, 60], ["detectron2.modeling.box_regression.Box2BoxTransformRotated", "test_box2box_transform.random_rotated_boxes", "test_box2box_transform.random_rotated_boxes", "torch.cuda.is_available", "torch.device", "devices.append", "src_boxes.to.to.to", "dst_boxes.to.to.to", "detectron2.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "detectron2.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "torch.allclose", "torch.allclose", "torch.device", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_box2box_transform.random_rotated_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_box2box_transform.random_rotated_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["    ", "def", "test_reconstruction", "(", "self", ")", ":", "\n", "        ", "weights", "=", "(", "5", ",", "5", ",", "10", ",", "10", ",", "1", ")", "\n", "b2b_transform", "=", "Box2BoxTransformRotated", "(", "weights", "=", "weights", ")", "\n", "src_boxes", "=", "random_rotated_boxes", "(", "[", "10", ",", "10", ",", "20", ",", "20", ",", "-", "30", "]", ",", "5", ",", "60.0", ",", "10", ")", "\n", "dst_boxes", "=", "random_rotated_boxes", "(", "[", "10", ",", "10", ",", "20", ",", "20", ",", "-", "30", "]", ",", "5", ",", "60.0", ",", "10", ")", "\n", "\n", "devices", "=", "[", "torch", ".", "device", "(", "\"cpu\"", ")", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "devices", ".", "append", "(", "torch", ".", "device", "(", "\"cuda\"", ")", ")", "\n", "", "for", "device", "in", "devices", ":", "\n", "            ", "src_boxes", "=", "src_boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "dst_boxes", "=", "dst_boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "deltas", "=", "b2b_transform", ".", "get_deltas", "(", "src_boxes", ",", "dst_boxes", ")", "\n", "dst_boxes_reconstructed", "=", "b2b_transform", ".", "apply_deltas", "(", "deltas", ",", "src_boxes", ")", "\n", "assert", "torch", ".", "allclose", "(", "dst_boxes", "[", ":", ",", ":", "4", "]", ",", "dst_boxes_reconstructed", "[", ":", ",", ":", "4", "]", ",", "atol", "=", "1e-5", ")", "\n", "# angle difference has to be normalized", "\n", "assert", "torch", ".", "allclose", "(", "\n", "(", "dst_boxes", "[", ":", ",", "4", "]", "-", "dst_boxes_reconstructed", "[", ":", ",", "4", "]", "+", "180.0", ")", "%", "360.0", "-", "180.0", ",", "\n", "torch", ".", "zeros_like", "(", "dst_boxes", "[", ":", ",", "4", "]", ")", ",", "\n", "atol", "=", "1e-4", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_box2box_transform.random_boxes": [[11, 13], ["torch.tensor", "torch.rand"], "function", ["None"], ["def", "random_boxes", "(", "mean_box", ",", "stdev", ",", "N", ")", ":", "\n", "    ", "return", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "stdev", "+", "torch", ".", "tensor", "(", "mean_box", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_box2box_transform.random_rotated_boxes": [[33, 37], ["torch.cat", "torch.tensor", "torch.rand", "torch.rand"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "", "", "def", "random_rotated_boxes", "(", "mean_box", ",", "std_length", ",", "std_angle", ",", "N", ")", ":", "\n", "    ", "return", "torch", ".", "cat", "(", "\n", "[", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "std_length", ",", "torch", ".", "rand", "(", "N", ",", "1", ")", "*", "std_angle", "]", ",", "dim", "=", "1", "\n", ")", "+", "torch", ".", "tensor", "(", "mean_box", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_rpn.RPNTest.test_rpn": [[20, 79], ["torch.manual_seed", "detectron2.config.get_cfg", "detectron2.modeling.backbone.build_backbone", "detectron2.modeling.proposal_generator.RPN", "torch.rand", "detectron2.structures.ImageList", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.Boxes", "expected_losses.keys", "zip", "detectron2.modeling.backbone.build_backbone.output_shape", "torch.rand", "detectron2.utils.events.EventStorage", "detectron2.modeling.proposal_generator.RPN.", "torch.tensor", "torch.tensor", "test_rpn.RPNTest.assertTrue", "detectron2.structures.Boxes", "detectron2.structures.Boxes", "torch.tensor", "torch.tensor", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertTrue", "test_rpn.RPNTest.assertTrue", "torch.allclose", "torch.tensor", "torch.tensor", "len", "len", "torch.allclose", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape"], ["    ", "def", "test_rpn", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "121", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "proposal_generator", "=", "RPN", "(", "cfg", ",", "backbone", ".", "output_shape", "(", ")", ")", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "20", ",", "30", ")", "\n", "image_sizes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "20", ",", "30", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "num_channels", "=", "1024", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "num_channels", ",", "1", ",", "2", ")", "}", "\n", "gt_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "[", "2", ",", "2", ",", "6", ",", "6", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instances", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instances", ".", "gt_boxes", "=", "Boxes", "(", "gt_boxes", ")", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "proposals", ",", "proposal_losses", "=", "proposal_generator", "(", "\n", "images", ",", "features", ",", "[", "gt_instances", "[", "0", "]", ",", "gt_instances", "[", "1", "]", "]", "\n", ")", "\n", "\n", "", "expected_losses", "=", "{", "\n", "\"loss_rpn_cls\"", ":", "torch", ".", "tensor", "(", "0.0804563984", ")", ",", "\n", "\"loss_rpn_loc\"", ":", "torch", ".", "tensor", "(", "0.0990132466", ")", ",", "\n", "}", "\n", "for", "name", "in", "expected_losses", ".", "keys", "(", ")", ":", "\n", "            ", "err_msg", "=", "\"proposal_losses[{}] = {}, expected losses = {}\"", ".", "format", "(", "\n", "name", ",", "proposal_losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", "\n", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "proposal_losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", ")", ",", "err_msg", ")", "\n", "\n", "", "expected_proposal_boxes", "=", "[", "\n", "Boxes", "(", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "[", "7.3365392685", ",", "0", ",", "10", ",", "10", "]", "]", ")", ")", ",", "\n", "Boxes", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0", ",", "0", ",", "30", ",", "20", "]", ",", "\n", "[", "0", ",", "0", ",", "16.7862777710", ",", "13.1362524033", "]", ",", "\n", "[", "0", ",", "0", ",", "30", ",", "13.3173446655", "]", ",", "\n", "[", "0", ",", "0", ",", "10.8602609634", ",", "20", "]", ",", "\n", "[", "7.7165775299", ",", "0", ",", "27.3875980377", ",", "20", "]", ",", "\n", "]", "\n", ")", "\n", ")", ",", "\n", "]", "\n", "\n", "expected_objectness_logits", "=", "[", "\n", "torch", ".", "tensor", "(", "[", "0.1225359365", ",", "-", "0.0133192837", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "0.1415634006", ",", "0.0989848152", ",", "0.0565387346", ",", "-", "0.0072308783", ",", "-", "0.0428492837", "]", ")", ",", "\n", "]", "\n", "\n", "for", "proposal", ",", "expected_proposal_box", ",", "im_size", ",", "expected_objectness_logit", "in", "zip", "(", "\n", "proposals", ",", "expected_proposal_boxes", ",", "image_sizes", ",", "expected_objectness_logits", "\n", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "len", "(", "proposal", ")", ",", "len", "(", "expected_proposal_box", ")", ")", "\n", "self", ".", "assertEqual", "(", "proposal", ".", "image_size", ",", "im_size", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "proposal", ".", "proposal_boxes", ".", "tensor", ",", "expected_proposal_box", ".", "tensor", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "proposal", ".", "objectness_logits", ",", "expected_objectness_logit", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_rpn.RPNTest.test_rpn_scriptability": [[80, 102], ["unittest.skipIf", "detectron2.config.get_cfg", "detectron2.modeling.proposal_generator.RPN().eval", "torch.rand", "detectron2.structures.ImageList", "detectron2.export.torchscript.export_torchscript_with_instances", "detectron2.modeling.proposal_generator.RPN().eval.", "detectron2.export.torchscript.export_torchscript_with_instances.", "zip", "torch.rand", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertTrue", "test_rpn.RPNTest.assertTrue", "detectron2.modeling.proposal_generator.RPN", "torch.equal", "torch.equal", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.export_torchscript_with_instances"], ["", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_rpn_scriptability", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "proposal_generator", "=", "RPN", "(", "cfg", ",", "{", "\"res4\"", ":", "ShapeSpec", "(", "channels", "=", "1024", ",", "stride", "=", "16", ")", "}", ")", ".", "eval", "(", ")", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "30", ",", "40", ")", "\n", "image_sizes", "=", "[", "(", "32", ",", "32", ")", ",", "(", "30", ",", "40", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "1024", ",", "1", ",", "2", ")", "}", "\n", "\n", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", ",", "\"objectness_logits\"", ":", "\"Tensor\"", "}", "\n", "proposal_generator_ts", "=", "export_torchscript_with_instances", "(", "proposal_generator", ",", "fields", ")", "\n", "\n", "proposals", ",", "_", "=", "proposal_generator", "(", "images", ",", "features", ")", "\n", "proposals_ts", ",", "_", "=", "proposal_generator_ts", "(", "images", ",", "features", ")", "\n", "\n", "for", "proposal", ",", "proposal_ts", "in", "zip", "(", "proposals", ",", "proposals_ts", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "proposal", ".", "image_size", ",", "proposal_ts", ".", "image_size", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "equal", "(", "proposal", ".", "proposal_boxes", ".", "tensor", ",", "proposal_ts", ".", "proposal_boxes", ".", "tensor", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "proposal", ".", "objectness_logits", ",", "proposal_ts", ".", "objectness_logits", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_rpn.RPNTest.test_rrpn": [[103, 245], ["torch.manual_seed", "detectron2.config.get_cfg", "detectron2.modeling.backbone.build_backbone", "detectron2.modeling.proposal_generator.build_proposal_generator", "torch.rand", "detectron2.structures.ImageList", "torch.tensor", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "expected_losses.keys", "torch.set_printoptions", "zip", "detectron2.modeling.backbone.build_backbone.output_shape", "torch.rand", "detectron2.utils.events.EventStorage", "detectron2.modeling.proposal_generator.build_proposal_generator.", "torch.tensor", "torch.tensor", "test_rpn.RPNTest.assertTrue", "detectron2.structures.RotatedBoxes", "detectron2.structures.RotatedBoxes", "torch.tensor", "torch.tensor", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertEqual", "test_rpn.RPNTest.assertTrue", "test_rpn.RPNTest.assertTrue", "torch.allclose", "torch.tensor", "torch.tensor", "len", "len", "torch.allclose", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape"], ["", "", "def", "test_rrpn", "(", "self", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "121", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "MODEL", ".", "PROPOSAL_GENERATOR", ".", "NAME", "=", "\"RRPN\"", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "NAME", "=", "\"RotatedAnchorGenerator\"", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "=", "[", "[", "32", ",", "64", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ASPECT_RATIOS", "=", "[", "[", "0.25", ",", "1", "]", "]", "\n", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ANGLES", "=", "[", "[", "0", ",", "60", "]", "]", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_WEIGHTS", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", "=", "\"StandardRPNHead\"", "\n", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "backbone", ".", "output_shape", "(", ")", ")", "\n", "num_images", "=", "2", "\n", "images_tensor", "=", "torch", ".", "rand", "(", "num_images", ",", "20", ",", "30", ")", "\n", "image_sizes", "=", "[", "(", "10", ",", "10", ")", ",", "(", "20", ",", "30", ")", "]", "\n", "images", "=", "ImageList", "(", "images_tensor", ",", "image_sizes", ")", "\n", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "num_channels", "=", "1024", "\n", "features", "=", "{", "\"res4\"", ":", "torch", ".", "rand", "(", "num_images", ",", "num_channels", ",", "1", ",", "2", ")", "}", "\n", "gt_boxes", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "2", ",", "2", ",", "2", ",", "0", "]", ",", "[", "4", ",", "4", ",", "4", ",", "4", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_instances", "=", "Instances", "(", "image_shape", ")", "\n", "gt_instances", ".", "gt_boxes", "=", "RotatedBoxes", "(", "gt_boxes", ")", "\n", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "proposals", ",", "proposal_losses", "=", "proposal_generator", "(", "\n", "images", ",", "features", ",", "[", "gt_instances", "[", "0", "]", ",", "gt_instances", "[", "1", "]", "]", "\n", ")", "\n", "\n", "", "expected_losses", "=", "{", "\n", "\"loss_rpn_cls\"", ":", "torch", ".", "tensor", "(", "0.043263837695121765", ")", ",", "\n", "\"loss_rpn_loc\"", ":", "torch", ".", "tensor", "(", "0.14432406425476074", ")", ",", "\n", "}", "\n", "for", "name", "in", "expected_losses", ".", "keys", "(", ")", ":", "\n", "            ", "err_msg", "=", "\"proposal_losses[{}] = {}, expected losses = {}\"", ".", "format", "(", "\n", "name", ",", "proposal_losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", "\n", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "proposal_losses", "[", "name", "]", ",", "expected_losses", "[", "name", "]", ")", ",", "err_msg", ")", "\n", "\n", "", "expected_proposal_boxes", "=", "[", "\n", "RotatedBoxes", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.60189795", ",", "1.24095452", ",", "61.98131943", ",", "18.03621292", ",", "-", "4.07244873", "]", ",", "\n", "[", "15.64940453", ",", "1.69624567", ",", "59.59749603", ",", "16.34339333", ",", "2.62692475", "]", ",", "\n", "[", "-", "3.02982378", ",", "-", "2.69752932", ",", "67.90952301", ",", "59.62455750", ",", "59.97010040", "]", ",", "\n", "[", "16.71863365", ",", "1.98309708", ",", "35.61507797", ",", "32.81484985", ",", "62.92267227", "]", ",", "\n", "[", "0.49432933", ",", "-", "7.92979717", ",", "67.77606201", ",", "62.93098450", ",", "-", "1.85656738", "]", ",", "\n", "[", "8.00880814", ",", "1.36017394", ",", "121.81007385", ",", "32.74150467", ",", "50.44297409", "]", ",", "\n", "[", "16.44299889", ",", "-", "4.82221127", ",", "63.39775848", ",", "61.22503662", ",", "54.12270737", "]", ",", "\n", "[", "5.00000000", ",", "5.00000000", ",", "10.00000000", ",", "10.00000000", ",", "-", "0.76943970", "]", ",", "\n", "[", "17.64130402", ",", "-", "0.98095351", ",", "61.40377808", ",", "16.28918839", ",", "55.53118134", "]", ",", "\n", "[", "0.13016054", ",", "4.60568953", ",", "35.80157471", ",", "32.30180359", ",", "62.52872086", "]", ",", "\n", "[", "-", "4.26460743", ",", "0.39604485", ",", "124.30079651", ",", "31.84611320", ",", "-", "1.58203125", "]", ",", "\n", "[", "7.52815342", ",", "-", "0.91636634", ",", "62.39784622", ",", "15.45565224", ",", "60.79549789", "]", ",", "\n", "]", "\n", ")", "\n", ")", ",", "\n", "RotatedBoxes", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.07734215", ",", "0.81635046", ",", "65.33510590", ",", "17.34688377", ",", "-", "1.51821899", "]", ",", "\n", "[", "-", "3.41833067", ",", "-", "3.11320257", ",", "64.17595673", ",", "60.55617905", ",", "58.27033234", "]", ",", "\n", "[", "20.67383385", ",", "-", "6.16561556", ",", "63.60531998", ",", "62.52315903", ",", "54.85546494", "]", ",", "\n", "[", "15.00000000", ",", "10.00000000", ",", "30.00000000", ",", "20.00000000", ",", "-", "0.18218994", "]", ",", "\n", "[", "9.22646523", ",", "-", "6.84775209", ",", "62.09895706", ",", "65.46472931", ",", "-", "2.74307251", "]", ",", "\n", "[", "15.00000000", ",", "4.93451595", ",", "30.00000000", ",", "9.86903191", ",", "-", "0.60272217", "]", ",", "\n", "[", "8.88342094", ",", "2.65560246", ",", "120.95362854", ",", "32.45022202", ",", "55.75970078", "]", ",", "\n", "[", "16.39088631", ",", "2.33887148", ",", "34.78761292", ",", "35.61492920", ",", "60.81977463", "]", ",", "\n", "[", "9.78298569", ",", "10.00000000", ",", "19.56597137", ",", "20.00000000", ",", "-", "0.86660767", "]", ",", "\n", "[", "1.28576660", ",", "5.49873352", ",", "34.93610382", ",", "33.22600174", ",", "60.51599884", "]", ",", "\n", "[", "17.58912468", ",", "-", "1.63270092", ",", "62.96052551", ",", "16.45713997", ",", "52.91245270", "]", ",", "\n", "[", "5.64749718", ",", "-", "1.90428460", ",", "62.37649155", ",", "16.19474792", ",", "61.09543991", "]", ",", "\n", "[", "0.82255805", ",", "2.34931135", ",", "118.83985901", ",", "32.83671188", ",", "56.50753784", "]", ",", "\n", "[", "-", "5.33874989", ",", "1.64404404", ",", "125.28501892", ",", "33.35424042", ",", "-", "2.80731201", "]", ",", "\n", "]", "\n", ")", "\n", ")", ",", "\n", "]", "\n", "\n", "expected_objectness_logits", "=", "[", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "0.10111768", ",", "\n", "0.09112845", ",", "\n", "0.08466332", ",", "\n", "0.07589971", ",", "\n", "0.06650183", ",", "\n", "0.06350251", ",", "\n", "0.04299347", ",", "\n", "0.01864817", ",", "\n", "0.00986163", ",", "\n", "0.00078543", ",", "\n", "-", "0.04573630", ",", "\n", "-", "0.04799230", ",", "\n", "]", "\n", ")", ",", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "0.11373727", ",", "\n", "0.09377633", ",", "\n", "0.05281663", ",", "\n", "0.05143715", ",", "\n", "0.04040275", ",", "\n", "0.03250912", ",", "\n", "0.01307789", ",", "\n", "0.01177734", ",", "\n", "0.00038105", ",", "\n", "-", "0.00540255", ",", "\n", "-", "0.01194804", ",", "\n", "-", "0.01461012", ",", "\n", "-", "0.03061717", ",", "\n", "-", "0.03599222", ",", "\n", "]", "\n", ")", ",", "\n", "]", "\n", "\n", "torch", ".", "set_printoptions", "(", "precision", "=", "8", ",", "sci_mode", "=", "False", ")", "\n", "\n", "for", "proposal", ",", "expected_proposal_box", ",", "im_size", ",", "expected_objectness_logit", "in", "zip", "(", "\n", "proposals", ",", "expected_proposal_boxes", ",", "image_sizes", ",", "expected_objectness_logits", "\n", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "len", "(", "proposal", ")", ",", "len", "(", "expected_proposal_box", ")", ")", "\n", "self", ".", "assertEqual", "(", "proposal", ".", "image_size", ",", "im_size", ")", "\n", "# It seems that there's some randomness in the result across different machines:", "\n", "# This test can be run on a local machine for 100 times with exactly the same result,", "\n", "# However, a different machine might produce slightly different results,", "\n", "# thus the atol here.", "\n", "err_msg", "=", "\"computed proposal boxes = {}, expected {}\"", ".", "format", "(", "\n", "proposal", ".", "proposal_boxes", ".", "tensor", ",", "expected_proposal_box", ".", "tensor", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "\n", "proposal", ".", "proposal_boxes", ".", "tensor", ",", "expected_proposal_box", ".", "tensor", ",", "atol", "=", "1e-5", "\n", ")", ",", "\n", "err_msg", ",", "\n", ")", "\n", "\n", "err_msg", "=", "\"computed objectness logits = {}, expected {}\"", ".", "format", "(", "\n", "proposal", ".", "objectness_logits", ",", "expected_objectness_logit", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "proposal", ".", "objectness_logits", ",", "expected_objectness_logit", ",", "atol", "=", "1e-5", ")", ",", "\n", "err_msg", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_rpn.RPNTest.test_rpn_proposals_inf": [[247, 253], ["[].fill_", "detectron2.modeling.proposal_generator.proposal_utils.find_top_rpn_proposals", "torch.rand", "torch.rand", "float"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.proposal_utils.find_top_rpn_proposals"], ["", "", "def", "test_rpn_proposals_inf", "(", "self", ")", ":", "\n", "        ", "N", ",", "Hi", ",", "Wi", ",", "A", "=", "3", ",", "3", ",", "3", ",", "3", "\n", "proposals", "=", "[", "torch", ".", "rand", "(", "N", ",", "Hi", "*", "Wi", "*", "A", ",", "4", ")", "]", "\n", "pred_logits", "=", "[", "torch", ".", "rand", "(", "N", ",", "Hi", "*", "Wi", "*", "A", ")", "]", "\n", "pred_logits", "[", "0", "]", "[", "1", "]", "[", "3", ":", "5", "]", ".", "fill_", "(", "float", "(", "\"inf\"", ")", ")", "\n", "find_top_rpn_proposals", "(", "proposals", ",", "pred_logits", ",", "[", "(", "10", ",", "10", ")", "]", ",", "0.5", ",", "1000", ",", "1000", ",", "0", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.GeneralizedRCNN.__init__": [[32, 72], ["torch.nn.Module.__init__", "rcnn.GeneralizedRCNN.register_buffer", "rcnn.GeneralizedRCNN.register_buffer", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "backbone", ":", "Backbone", ",", "\n", "proposal_generator", ":", "nn", ".", "Module", ",", "\n", "roi_heads", ":", "nn", ".", "Module", ",", "\n", "pixel_mean", ":", "Tuple", "[", "float", "]", ",", "\n", "pixel_std", ":", "Tuple", "[", "float", "]", ",", "\n", "input_format", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "vis_period", ":", "int", "=", "0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            backbone: a backbone module, must follow detectron2's backbone interface\n            proposal_generator: a module that generates proposals using backbone features\n            roi_heads: a ROI head that performs per-region computation\n            pixel_mean, pixel_std: list or tuple with #channels element,\n                representing the per-channel mean and std to be used to normalize\n                the input image\n            input_format: describe the meaning of channels of input. Needed by visualization\n            vis_period: the period to run visualization. Set to 0 to disable.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "backbone", "\n", "self", ".", "proposal_generator", "=", "proposal_generator", "\n", "self", ".", "roi_heads", "=", "roi_heads", "\n", "\n", "self", ".", "input_format", "=", "input_format", "\n", "self", ".", "vis_period", "=", "vis_period", "\n", "if", "vis_period", ">", "0", ":", "\n", "            ", "assert", "input_format", "is", "not", "None", ",", "\"input_format is required for visualization!\"", "\n", "\n", "", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "pixel_mean", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "pixel_std", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "assert", "(", "\n", "self", ".", "pixel_mean", ".", "shape", "==", "self", ".", "pixel_std", ".", "shape", "\n", ")", ",", "f\"{self.pixel_mean} and {self.pixel_std} have different shapes!\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.GeneralizedRCNN.from_config": [[73, 84], ["backbone.build_backbone.build_backbone", "proposal_generator.build_proposal_generator", "roi_heads.build_roi_heads", "backbone.build_backbone.build_backbone.output_shape", "backbone.build_backbone.build_backbone.output_shape"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.build_roi_heads", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "return", "{", "\n", "\"backbone\"", ":", "backbone", ",", "\n", "\"proposal_generator\"", ":", "build_proposal_generator", "(", "cfg", ",", "backbone", ".", "output_shape", "(", ")", ")", ",", "\n", "\"roi_heads\"", ":", "build_roi_heads", "(", "cfg", ",", "backbone", ".", "output_shape", "(", ")", ")", ",", "\n", "\"input_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", ",", "\n", "\"pixel_mean\"", ":", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ",", "\n", "\"pixel_std\"", ":", "cfg", ".", "MODEL", ".", "PIXEL_STD", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.GeneralizedRCNN.device": [[86, 89], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.GeneralizedRCNN.visualize_training": [[90, 124], ["detectron2.utils.events.get_event_storage", "zip", "detectron2.data.detection_utils.convert_image_to_rgb", "Visualizer", "v_gt.overlay_instances.overlay_instances.overlay_instances", "v_gt.overlay_instances.overlay_instances.get_image", "min", "Visualizer", "v_pred.overlay_instances.overlay_instances.overlay_instances", "v_pred.overlay_instances.overlay_instances.get_image", "numpy.concatenate", "vis_img.transpose.transpose.transpose", "detectron2.utils.events.get_event_storage.put_image", "detectron2.data.detection_utils.convert_image_to_rgb.permute", "len", "prop.proposal_boxes[].tensor.cpu().numpy", "prop.proposal_boxes[].tensor.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.convert_image_to_rgb", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_image"], ["", "def", "visualize_training", "(", "self", ",", "batched_inputs", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        A function used to visualize images and proposals. It shows ground truth\n        bounding boxes on the original image and up to 20 top-scoring predicted\n        object proposals on the original image. Users can implement different\n        visualization functions for different models.\n\n        Args:\n            batched_inputs (list): a list that contains input to the model.\n            proposals (list): a list that contains predicted proposals. Both\n                batched_inputs and proposals should have the same length.\n        \"\"\"", "\n", "from", "detectron2", ".", "utils", ".", "visualizer", "import", "Visualizer", "\n", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "max_vis_prop", "=", "20", "\n", "\n", "for", "input", ",", "prop", "in", "zip", "(", "batched_inputs", ",", "proposals", ")", ":", "\n", "            ", "img", "=", "input", "[", "\"image\"", "]", "\n", "img", "=", "convert_image_to_rgb", "(", "img", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ",", "self", ".", "input_format", ")", "\n", "v_gt", "=", "Visualizer", "(", "img", ",", "None", ")", "\n", "v_gt", "=", "v_gt", ".", "overlay_instances", "(", "boxes", "=", "input", "[", "\"instances\"", "]", ".", "gt_boxes", ")", "\n", "anno_img", "=", "v_gt", ".", "get_image", "(", ")", "\n", "box_size", "=", "min", "(", "len", "(", "prop", ".", "proposal_boxes", ")", ",", "max_vis_prop", ")", "\n", "v_pred", "=", "Visualizer", "(", "img", ",", "None", ")", "\n", "v_pred", "=", "v_pred", ".", "overlay_instances", "(", "\n", "boxes", "=", "prop", ".", "proposal_boxes", "[", "0", ":", "box_size", "]", ".", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", ")", "\n", "prop_img", "=", "v_pred", ".", "get_image", "(", ")", "\n", "vis_img", "=", "np", ".", "concatenate", "(", "(", "anno_img", ",", "prop_img", ")", ",", "axis", "=", "1", ")", "\n", "vis_img", "=", "vis_img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "vis_name", "=", "\"Left: GT bounding boxes;  Right: Predicted proposals\"", "\n", "storage", ".", "put_image", "(", "vis_name", ",", "vis_img", ")", "\n", "break", "# only visualize one image in a batch", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.GeneralizedRCNN.forward": [[125, 176], ["rcnn.GeneralizedRCNN.preprocess_image", "rcnn.GeneralizedRCNN.backbone", "rcnn.GeneralizedRCNN.roi_heads", "losses.update", "losses.update", "rcnn.GeneralizedRCNN.inference", "rcnn.GeneralizedRCNN.proposal_generator", "detectron2.utils.events.get_event_storage", "x[].to", "x[].to", "rcnn.GeneralizedRCNN.visualize_training"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.preprocess_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.visualize_training"], ["", "", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper` .\n                Each item in the list contains the inputs for one image.\n                For now, each item in the list is a dict that contains:\n\n                * image: Tensor, image in (C, H, W) format.\n                * instances (optional): groundtruth :class:`Instances`\n                * proposals (optional): :class:`Instances`, precomputed proposals.\n\n                Other information that's included in the original dicts, such as:\n\n                * \"height\", \"width\" (int): the output resolution of the model, used in inference.\n                  See :meth:`postprocess` for details.\n\n        Returns:\n            list[dict]:\n                Each dict is the output for one input image.\n                The dict contains one key \"instances\" whose value is a :class:`Instances`.\n                The :class:`Instances` object has the following keys:\n                \"pred_boxes\", \"pred_classes\", \"scores\", \"pred_masks\", \"pred_keypoints\"\n        \"\"\"", "\n", "if", "not", "self", ".", "training", ":", "\n", "            ", "return", "self", ".", "inference", "(", "batched_inputs", ")", "\n", "\n", "", "images", "=", "self", ".", "preprocess_image", "(", "batched_inputs", ")", "\n", "if", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "else", ":", "\n", "            ", "gt_instances", "=", "None", "\n", "\n", "", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "self", ".", "proposal_generator", ":", "\n", "            ", "proposals", ",", "proposal_losses", "=", "self", ".", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "", "else", ":", "\n", "            ", "assert", "\"proposals\"", "in", "batched_inputs", "[", "0", "]", "\n", "proposals", "=", "[", "x", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "proposal_losses", "=", "{", "}", "\n", "\n", "", "_", ",", "detector_losses", "=", "self", ".", "roi_heads", "(", "images", ",", "features", ",", "proposals", ",", "gt_instances", ")", "\n", "if", "self", ".", "vis_period", ">", "0", ":", "\n", "            ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                ", "self", ".", "visualize_training", "(", "batched_inputs", ",", "proposals", ")", "\n", "\n", "", "", "losses", "=", "{", "}", "\n", "losses", ".", "update", "(", "detector_losses", ")", "\n", "losses", ".", "update", "(", "proposal_losses", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.GeneralizedRCNN.inference": [[177, 215], ["rcnn.GeneralizedRCNN.preprocess_image", "rcnn.GeneralizedRCNN.backbone", "rcnn.GeneralizedRCNN.roi_heads", "rcnn.GeneralizedRCNN.roi_heads.forward_with_given_boxes", "rcnn.GeneralizedRCNN._postprocess", "rcnn.GeneralizedRCNN.proposal_generator", "x.to", "x[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.preprocess_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch._postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "inference", "(", "self", ",", "batched_inputs", ",", "detected_instances", "=", "None", ",", "do_postprocess", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Run inference on the given inputs.\n\n        Args:\n            batched_inputs (list[dict]): same as in :meth:`forward`\n            detected_instances (None or list[Instances]): if not None, it\n                contains an `Instances` object per image. The `Instances`\n                object contains \"pred_boxes\" and \"pred_classes\" which are\n                known boxes in the image.\n                The inference will then skip the detection of bounding boxes,\n                and only predict other per-ROI outputs.\n            do_postprocess (bool): whether to apply post-processing on the outputs.\n\n        Returns:\n            same as in :meth:`forward`.\n        \"\"\"", "\n", "assert", "not", "self", ".", "training", "\n", "\n", "images", "=", "self", ".", "preprocess_image", "(", "batched_inputs", ")", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "detected_instances", "is", "None", ":", "\n", "            ", "if", "self", ".", "proposal_generator", ":", "\n", "                ", "proposals", ",", "_", "=", "self", ".", "proposal_generator", "(", "images", ",", "features", ",", "None", ")", "\n", "", "else", ":", "\n", "                ", "assert", "\"proposals\"", "in", "batched_inputs", "[", "0", "]", "\n", "proposals", "=", "[", "x", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "\n", "", "results", ",", "_", "=", "self", ".", "roi_heads", "(", "images", ",", "features", ",", "proposals", ",", "None", ")", "\n", "", "else", ":", "\n", "            ", "detected_instances", "=", "[", "x", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "detected_instances", "]", "\n", "results", "=", "self", ".", "roi_heads", ".", "forward_with_given_boxes", "(", "features", ",", "detected_instances", ")", "\n", "\n", "", "if", "do_postprocess", ":", "\n", "            ", "return", "GeneralizedRCNN", ".", "_postprocess", "(", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", ")", "\n", "", "else", ":", "\n", "            ", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.GeneralizedRCNN.preprocess_image": [[216, 224], ["detectron2.structures.ImageList.from_tensors", "x[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "", "def", "preprocess_image", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Normalize, pad and batch the input images.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.GeneralizedRCNN._postprocess": [[225, 240], ["zip", "input_per_image.get", "input_per_image.get", "postprocessing.detector_postprocess", "processed_results.append"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.detector_postprocess"], ["", "@", "staticmethod", "\n", "def", "_postprocess", "(", "instances", ",", "batched_inputs", ",", "image_sizes", ")", ":", "\n", "        ", "\"\"\"\n        Rescale the output instances to the target size.\n        \"\"\"", "\n", "# note: private function; subject to changes", "\n", "processed_results", "=", "[", "]", "\n", "for", "results_per_image", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "instances", ",", "batched_inputs", ",", "image_sizes", "\n", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "r", "=", "detector_postprocess", "(", "results_per_image", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"instances\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.ProposalNetwork.__init__": [[248, 255], ["torch.nn.Module.__init__", "backbone.build_backbone", "proposal_generator.build_proposal_generator", "rcnn.ProposalNetwork.register_buffer", "rcnn.ProposalNetwork.register_buffer", "rcnn.ProposalNetwork.backbone.output_shape", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.ProposalNetwork.device": [[256, 259], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.rcnn.ProposalNetwork.forward": [[260, 300], ["detectron2.structures.ImageList.from_tensors", "rcnn.ProposalNetwork.backbone", "rcnn.ProposalNetwork.proposal_generator", "zip", "x[].to", "input_per_image.get", "input_per_image.get", "postprocessing.detector_postprocess", "processed_results.append", "x[].to", "detectron2.utils.logger.log_first_n", "x[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.log_first_n", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            Same as in :class:`GeneralizedRCNN.forward`\n\n        Returns:\n            list[dict]:\n                Each dict is the output for one input image.\n                The dict contains one key \"proposals\" whose value is a\n                :class:`Instances` with keys \"proposal_boxes\" and \"objectness_logits\".\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "elif", "\"targets\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "log_first_n", "(", "\n", "logging", ".", "WARN", ",", "\"'targets' in the model inputs is now renamed to 'instances'!\"", ",", "n", "=", "10", "\n", ")", "\n", "gt_instances", "=", "[", "x", "[", "\"targets\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "else", ":", "\n", "            ", "gt_instances", "=", "None", "\n", "", "proposals", ",", "proposal_losses", "=", "self", ".", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "# In training, the proposals are not useful at all but we generate them anyway.", "\n", "# This makes RPN-only models about 5% slower.", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "proposal_losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "results_per_image", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "proposals", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "r", "=", "detector_postprocess", "(", "results_per_image", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"proposals\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.__init__": [[45, 91], ["torch.nn.Module.__init__", "backbone.build_backbone", "retinanet.RetinaNet.backbone.output_shape", "retinanet.RetinaNetHead", "anchor_generator.build_anchor_generator", "box_regression.Box2BoxTransform", "matcher.Matcher", "retinanet.RetinaNet.register_buffer", "retinanet.RetinaNet.register_buffer", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.build_anchor_generator"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "self", ".", "num_classes", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NUM_CLASSES", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "IN_FEATURES", "\n", "# Loss parameters:", "\n", "self", ".", "focal_loss_alpha", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "FOCAL_LOSS_ALPHA", "\n", "self", ".", "focal_loss_gamma", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "FOCAL_LOSS_GAMMA", "\n", "self", ".", "smooth_l1_loss_beta", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SMOOTH_L1_LOSS_BETA", "\n", "self", ".", "box_reg_loss_type", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "BBOX_REG_LOSS_TYPE", "\n", "# Inference parameters:", "\n", "self", ".", "score_threshold", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "\n", "self", ".", "topk_candidates", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "TOPK_CANDIDATES_TEST", "\n", "self", ".", "nms_threshold", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NMS_THRESH_TEST", "\n", "self", ".", "max_detections_per_image", "=", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", "\n", "# Vis parameters", "\n", "self", ".", "vis_period", "=", "cfg", ".", "VIS_PERIOD", "\n", "self", ".", "input_format", "=", "cfg", ".", "INPUT", ".", "FORMAT", "\n", "# fmt: on", "\n", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "\n", "backbone_shape", "=", "self", ".", "backbone", ".", "output_shape", "(", ")", "\n", "feature_shapes", "=", "[", "backbone_shape", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "self", ".", "head", "=", "RetinaNetHead", "(", "cfg", ",", "feature_shapes", ")", "\n", "self", ".", "anchor_generator", "=", "build_anchor_generator", "(", "cfg", ",", "feature_shapes", ")", "\n", "\n", "# Matching and loss", "\n", "self", ".", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "cfg", ".", "MODEL", ".", "RETINANET", ".", "BBOX_REG_WEIGHTS", ")", "\n", "self", ".", "anchor_matcher", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "IOU_THRESHOLDS", ",", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "IOU_LABELS", ",", "\n", "allow_low_quality_matches", "=", "True", ",", "\n", ")", "\n", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "\"\"\"\n        In Detectron1, loss is normalized by number of foreground samples in the batch.\n        When batch size is 1 per GPU, #foreground has a large variance and\n        using it lead to lower performance. Here we maintain an EMA of #foreground to\n        stabilize the normalizer.\n        \"\"\"", "\n", "self", ".", "loss_normalizer", "=", "100", "# initialize with any reasonable #fg that's not too small", "\n", "self", ".", "loss_normalizer_momentum", "=", "0.9", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.device": [[92, 95], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.visualize_training": [[96, 130], ["detectron2.utils.events.get_event_storage", "detectron2.data.detection_utils.convert_image_to_rgb", "Visualizer", "v_gt.overlay_instances.overlay_instances.overlay_instances", "v_gt.overlay_instances.overlay_instances.get_image", "postprocessing.detector_postprocess", "postprocessing.detector_postprocess.pred_boxes.tensor.detach().cpu().numpy", "Visualizer", "v_pred.overlay_instances.overlay_instances.overlay_instances", "v_pred.overlay_instances.overlay_instances.get_image", "numpy.vstack", "vis_img.transpose.transpose.transpose", "detectron2.utils.events.get_event_storage.put_image", "len", "len", "detectron2.data.detection_utils.convert_image_to_rgb.permute", "postprocessing.detector_postprocess.pred_boxes.tensor.detach().cpu", "postprocessing.detector_postprocess.pred_boxes.tensor.detach"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.convert_image_to_rgb", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_image"], ["", "def", "visualize_training", "(", "self", ",", "batched_inputs", ",", "results", ")", ":", "\n", "        ", "\"\"\"\n        A function used to visualize ground truth images and final network predictions.\n        It shows ground truth bounding boxes on the original image and up to 20\n        predicted object bounding boxes on the original image.\n\n        Args:\n            batched_inputs (list): a list that contains input to the model.\n            results (List[Instances]): a list of #images elements.\n        \"\"\"", "\n", "from", "detectron2", ".", "utils", ".", "visualizer", "import", "Visualizer", "\n", "\n", "assert", "len", "(", "batched_inputs", ")", "==", "len", "(", "\n", "results", "\n", ")", ",", "\"Cannot visualize inputs and results of different sizes\"", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "max_boxes", "=", "20", "\n", "\n", "image_index", "=", "0", "# only visualize a single image", "\n", "img", "=", "batched_inputs", "[", "image_index", "]", "[", "\"image\"", "]", "\n", "img", "=", "convert_image_to_rgb", "(", "img", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ",", "self", ".", "input_format", ")", "\n", "v_gt", "=", "Visualizer", "(", "img", ",", "None", ")", "\n", "v_gt", "=", "v_gt", ".", "overlay_instances", "(", "boxes", "=", "batched_inputs", "[", "image_index", "]", "[", "\"instances\"", "]", ".", "gt_boxes", ")", "\n", "anno_img", "=", "v_gt", ".", "get_image", "(", ")", "\n", "processed_results", "=", "detector_postprocess", "(", "results", "[", "image_index", "]", ",", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", "\n", "predicted_boxes", "=", "processed_results", ".", "pred_boxes", ".", "tensor", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "v_pred", "=", "Visualizer", "(", "img", ",", "None", ")", "\n", "v_pred", "=", "v_pred", ".", "overlay_instances", "(", "boxes", "=", "predicted_boxes", "[", "0", ":", "max_boxes", "]", ")", "\n", "prop_img", "=", "v_pred", ".", "get_image", "(", ")", "\n", "vis_img", "=", "np", ".", "vstack", "(", "(", "anno_img", ",", "prop_img", ")", ")", "\n", "vis_img", "=", "vis_img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "vis_name", "=", "f\"Top: GT bounding boxes; Bottom: {max_boxes} Highest Scoring Results\"", "\n", "storage", ".", "put_image", "(", "vis_name", ",", "vis_img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.forward": [[131, 186], ["retinanet.RetinaNet.preprocess_image", "retinanet.RetinaNet.backbone", "retinanet.RetinaNet.anchor_generator", "retinanet.RetinaNet.head", "retinanet.permute_to_N_HWA_K", "retinanet.permute_to_N_HWA_K", "retinanet.RetinaNet.label_anchors", "retinanet.RetinaNet.losses", "retinanet.RetinaNet.inference", "zip", "x[].to", "detectron2.utils.events.get_event_storage", "input_per_image.get", "input_per_image.get", "postprocessing.detector_postprocess", "processed_results.append", "retinanet.RetinaNet.inference", "retinanet.RetinaNet.visualize_training"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.preprocess_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.label_anchors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.visualize_training"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper` .\n                Each item in the list contains the inputs for one image.\n                For now, each item in the list is a dict that contains:\n\n                * image: Tensor, image in (C, H, W) format.\n                * instances: Instances\n\n                Other information that's included in the original dicts, such as:\n\n                * \"height\", \"width\" (int): the output resolution of the model, used in inference.\n                  See :meth:`postprocess` for details.\n        Returns:\n            dict[str: Tensor]:\n                mapping from a named loss to a tensor storing the loss. Used during training only.\n        \"\"\"", "\n", "images", "=", "self", ".", "preprocess_image", "(", "batched_inputs", ")", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "\n", "anchors", "=", "self", ".", "anchor_generator", "(", "features", ")", "\n", "pred_logits", ",", "pred_anchor_deltas", "=", "self", ".", "head", "(", "features", ")", "\n", "# Transpose the Hi*Wi*A dimension to the middle:", "\n", "pred_logits", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "self", ".", "num_classes", ")", "for", "x", "in", "pred_logits", "]", "\n", "pred_anchor_deltas", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "4", ")", "for", "x", "in", "pred_anchor_deltas", "]", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ",", "\"Instance annotations are missing in training!\"", "\n", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "\n", "gt_labels", ",", "gt_boxes", "=", "self", ".", "label_anchors", "(", "anchors", ",", "gt_instances", ")", "\n", "losses", "=", "self", ".", "losses", "(", "anchors", ",", "pred_logits", ",", "gt_labels", ",", "pred_anchor_deltas", ",", "gt_boxes", ")", "\n", "\n", "if", "self", ".", "vis_period", ">", "0", ":", "\n", "                ", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "storage", ".", "iter", "%", "self", ".", "vis_period", "==", "0", ":", "\n", "                    ", "results", "=", "self", ".", "inference", "(", "\n", "anchors", ",", "pred_logits", ",", "pred_anchor_deltas", ",", "images", ".", "image_sizes", "\n", ")", "\n", "self", ".", "visualize_training", "(", "batched_inputs", ",", "results", ")", "\n", "\n", "", "", "return", "losses", "\n", "", "else", ":", "\n", "            ", "results", "=", "self", ".", "inference", "(", "anchors", ",", "pred_logits", ",", "pred_anchor_deltas", ",", "images", ".", "image_sizes", ")", "\n", "processed_results", "=", "[", "]", "\n", "for", "results_per_image", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "                ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "r", "=", "detector_postprocess", "(", "results_per_image", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"instances\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.losses": [[187, 251], ["len", "torch.stack", "torch.stack", "pos_mask.sum().item", "detectron2.utils.events.get_event_storage().put_scalar", "fvcore.nn.sigmoid_focal_loss_jit", "type().cat", "retinanet.RetinaNet.box2box_transform.get_deltas", "torch.nn.functional.one_hot", "gt_labels_target.to", "fvcore.nn.smooth_l1_loss", "pos_mask.sum", "detectron2.utils.events.get_event_storage", "max", "detectron2.layers.cat", "fvcore.nn.giou_loss", "ValueError", "type", "detectron2.layers.cat", "retinanet.RetinaNet.box2box_transform.apply_deltas", "detectron2.layers.cat", "torch.stack", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "", "def", "losses", "(", "self", ",", "anchors", ",", "pred_logits", ",", "gt_labels", ",", "pred_anchor_deltas", ",", "gt_boxes", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[Boxes]): a list of #feature level Boxes\n            gt_labels, gt_boxes: see output of :meth:`RetinaNet.label_anchors`.\n                Their shapes are (N, R) and (N, R, 4), respectively, where R is\n                the total number of anchors across levels, i.e. sum(Hi x Wi x Ai)\n            pred_logits, pred_anchor_deltas: both are list[Tensor]. Each element in the\n                list corresponds to one level and has shape (N, Hi * Wi * Ai, K or 4).\n                Where K is the number of classes used in `pred_logits`.\n\n        Returns:\n            dict[str, Tensor]:\n                mapping from a named loss to a scalar tensor\n                storing the loss. Used during training only. The dict keys are:\n                \"loss_cls\" and \"loss_box_reg\"\n        \"\"\"", "\n", "num_images", "=", "len", "(", "gt_labels", ")", "\n", "gt_labels", "=", "torch", ".", "stack", "(", "gt_labels", ")", "# (N, R)", "\n", "anchors", "=", "type", "(", "anchors", "[", "0", "]", ")", ".", "cat", "(", "anchors", ")", ".", "tensor", "# (R, 4)", "\n", "gt_anchor_deltas", "=", "[", "self", ".", "box2box_transform", ".", "get_deltas", "(", "anchors", ",", "k", ")", "for", "k", "in", "gt_boxes", "]", "\n", "gt_anchor_deltas", "=", "torch", ".", "stack", "(", "gt_anchor_deltas", ")", "# (N, R, 4)", "\n", "\n", "valid_mask", "=", "gt_labels", ">=", "0", "\n", "pos_mask", "=", "(", "gt_labels", ">=", "0", ")", "&", "(", "gt_labels", "!=", "self", ".", "num_classes", ")", "\n", "num_pos_anchors", "=", "pos_mask", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "get_event_storage", "(", ")", ".", "put_scalar", "(", "\"num_pos_anchors\"", ",", "num_pos_anchors", "/", "num_images", ")", "\n", "self", ".", "loss_normalizer", "=", "self", ".", "loss_normalizer_momentum", "*", "self", ".", "loss_normalizer", "+", "(", "\n", "1", "-", "self", ".", "loss_normalizer_momentum", "\n", ")", "*", "max", "(", "num_pos_anchors", ",", "1", ")", "\n", "\n", "# classification and regression loss", "\n", "gt_labels_target", "=", "F", ".", "one_hot", "(", "gt_labels", "[", "valid_mask", "]", ",", "num_classes", "=", "self", ".", "num_classes", "+", "1", ")", "[", "\n", ":", ",", ":", "-", "1", "\n", "]", "# no loss for the last (background) class", "\n", "loss_cls", "=", "sigmoid_focal_loss_jit", "(", "\n", "cat", "(", "pred_logits", ",", "dim", "=", "1", ")", "[", "valid_mask", "]", ",", "\n", "gt_labels_target", ".", "to", "(", "pred_logits", "[", "0", "]", ".", "dtype", ")", ",", "\n", "alpha", "=", "self", ".", "focal_loss_alpha", ",", "\n", "gamma", "=", "self", ".", "focal_loss_gamma", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "\n", "if", "self", ".", "box_reg_loss_type", "==", "\"smooth_l1\"", ":", "\n", "            ", "loss_box_reg", "=", "smooth_l1_loss", "(", "\n", "cat", "(", "pred_anchor_deltas", ",", "dim", "=", "1", ")", "[", "pos_mask", "]", ",", "\n", "gt_anchor_deltas", "[", "pos_mask", "]", ",", "\n", "beta", "=", "self", ".", "smooth_l1_loss_beta", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "", "elif", "self", ".", "box_reg_loss_type", "==", "\"giou\"", ":", "\n", "            ", "pred_boxes", "=", "[", "\n", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "k", ",", "anchors", ")", "\n", "for", "k", "in", "cat", "(", "pred_anchor_deltas", ",", "dim", "=", "1", ")", "\n", "]", "\n", "loss_box_reg", "=", "giou_loss", "(", "\n", "torch", ".", "stack", "(", "pred_boxes", ")", "[", "pos_mask", "]", ",", "torch", ".", "stack", "(", "gt_boxes", ")", "[", "pos_mask", "]", ",", "reduction", "=", "\"sum\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Invalid bbox reg loss type '{self.box_reg_loss_type}'\"", ")", "\n", "\n", "", "return", "{", "\n", "\"loss_cls\"", ":", "loss_cls", "/", "self", ".", "loss_normalizer", ",", "\n", "\"loss_box_reg\"", ":", "loss_box_reg", "/", "self", ".", "loss_normalizer", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.label_anchors": [[253, 298], ["torch.no_grad", "detectron2.structures.Boxes.cat", "detectron2.structures.pairwise_iou", "retinanet.RetinaNet.anchor_matcher", "gt_labels.append", "matched_gt_boxes.append", "len", "torch.zeros_like", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_anchors", "(", "self", ",", "anchors", ",", "gt_instances", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[Boxes]): A list of #feature level Boxes.\n                The Boxes contains anchors of this image on the specific feature level.\n            gt_instances (list[Instances]): a list of N `Instances`s. The i-th\n                `Instances` contains the ground-truth per-instance annotations\n                for the i-th input image.\n\n        Returns:\n            list[Tensor]:\n                List of #img tensors. i-th element is a vector of labels whose length is\n                the total number of anchors across all feature maps (sum(Hi * Wi * A)).\n                Label values are in {-1, 0, ..., K}, with -1 means ignore, and K means background.\n            list[Tensor]:\n                i-th element is a Rx4 tensor, where R is the total number of anchors across\n                feature maps. The values are the matched gt boxes for each anchor.\n                Values are undefined for those anchors not labeled as foreground.\n        \"\"\"", "\n", "anchors", "=", "Boxes", ".", "cat", "(", "anchors", ")", "# Rx4", "\n", "\n", "gt_labels", "=", "[", "]", "\n", "matched_gt_boxes", "=", "[", "]", "\n", "for", "gt_per_image", "in", "gt_instances", ":", "\n", "            ", "match_quality_matrix", "=", "pairwise_iou", "(", "gt_per_image", ".", "gt_boxes", ",", "anchors", ")", "\n", "matched_idxs", ",", "anchor_labels", "=", "self", ".", "anchor_matcher", "(", "match_quality_matrix", ")", "\n", "del", "match_quality_matrix", "\n", "\n", "if", "len", "(", "gt_per_image", ")", ">", "0", ":", "\n", "                ", "matched_gt_boxes_i", "=", "gt_per_image", ".", "gt_boxes", ".", "tensor", "[", "matched_idxs", "]", "\n", "\n", "gt_labels_i", "=", "gt_per_image", ".", "gt_classes", "[", "matched_idxs", "]", "\n", "# Anchors with label 0 are treated as background.", "\n", "gt_labels_i", "[", "anchor_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "# Anchors with label -1 are ignored.", "\n", "gt_labels_i", "[", "anchor_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "                ", "matched_gt_boxes_i", "=", "torch", ".", "zeros_like", "(", "anchors", ".", "tensor", ")", "\n", "gt_labels_i", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "\n", "", "gt_labels", ".", "append", "(", "gt_labels_i", ")", "\n", "matched_gt_boxes", ".", "append", "(", "matched_gt_boxes_i", ")", "\n", "\n", "", "return", "gt_labels", ",", "matched_gt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.inference": [[299, 320], ["enumerate", "retinanet.RetinaNet.inference_single_image", "results.append", "tuple"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference_single_image"], ["", "def", "inference", "(", "self", ",", "anchors", ",", "pred_logits", ",", "pred_anchor_deltas", ",", "image_sizes", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            anchors (list[Boxes]): A list of #feature level Boxes.\n                The Boxes contain anchors of this image on the specific feature level.\n            pred_logits, pred_anchor_deltas: list[Tensor], one per level. Each\n                has shape (N, Hi * Wi * Ai, K or 4)\n            image_sizes (List[torch.Size]): the input image sizes\n\n        Returns:\n            results (List[Instances]): a list of #images elements.\n        \"\"\"", "\n", "results", "=", "[", "]", "\n", "for", "img_idx", ",", "image_size", "in", "enumerate", "(", "image_sizes", ")", ":", "\n", "            ", "pred_logits_per_image", "=", "[", "x", "[", "img_idx", "]", "for", "x", "in", "pred_logits", "]", "\n", "deltas_per_image", "=", "[", "x", "[", "img_idx", "]", "for", "x", "in", "pred_anchor_deltas", "]", "\n", "results_per_image", "=", "self", ".", "inference_single_image", "(", "\n", "anchors", ",", "pred_logits_per_image", ",", "deltas_per_image", ",", "tuple", "(", "image_size", ")", "\n", ")", "\n", "results", ".", "append", "(", "results_per_image", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.inference_single_image": [[321, 382], ["zip", "detectron2.layers.batched_nms", "detectron2.structures.Instances", "detectron2.structures.Boxes", "box_cls_i.flatten().sigmoid_", "min", "box_cls_i.flatten().sigmoid_.sort", "retinanet.RetinaNet.box2box_transform.apply_deltas", "boxes_all.append", "scores_all.append", "class_idxs_all.append", "detectron2.layers.cat", "torch.nonzero", "topk_idxs.size", "box_cls_i.flatten"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "def", "inference_single_image", "(", "self", ",", "anchors", ",", "box_cls", ",", "box_delta", ",", "image_size", ")", ":", "\n", "        ", "\"\"\"\n        Single-image inference. Return bounding-box detection results by thresholding\n        on scores and applying non-maximum suppression (NMS).\n\n        Arguments:\n            anchors (list[Boxes]): list of #feature levels. Each entry contains\n                a Boxes object, which contains all the anchors in that feature level.\n            box_cls (list[Tensor]): list of #feature levels. Each entry contains\n                tensor of size (H x W x A, K)\n            box_delta (list[Tensor]): Same shape as 'box_cls' except that K becomes 4.\n            image_size (tuple(H, W)): a tuple of the image height and width.\n\n        Returns:\n            Same as `inference`, but for only one image.\n        \"\"\"", "\n", "boxes_all", "=", "[", "]", "\n", "scores_all", "=", "[", "]", "\n", "class_idxs_all", "=", "[", "]", "\n", "\n", "# Iterate over every feature level", "\n", "for", "box_cls_i", ",", "box_reg_i", ",", "anchors_i", "in", "zip", "(", "box_cls", ",", "box_delta", ",", "anchors", ")", ":", "\n", "# (HxWxAxK,)", "\n", "            ", "predicted_prob", "=", "box_cls_i", ".", "flatten", "(", ")", ".", "sigmoid_", "(", ")", "\n", "\n", "# Apply two filtering below to make NMS faster.", "\n", "# 1. Keep boxes with confidence score higher than threshold", "\n", "keep_idxs", "=", "predicted_prob", ">", "self", ".", "score_threshold", "\n", "predicted_prob", "=", "predicted_prob", "[", "keep_idxs", "]", "\n", "topk_idxs", "=", "torch", ".", "nonzero", "(", "keep_idxs", ",", "as_tuple", "=", "True", ")", "[", "0", "]", "\n", "\n", "# 2. Keep top k top scoring boxes only", "\n", "num_topk", "=", "min", "(", "self", ".", "topk_candidates", ",", "topk_idxs", ".", "size", "(", "0", ")", ")", "\n", "# torch.sort is actually faster than .topk (at least on GPUs)", "\n", "predicted_prob", ",", "idxs", "=", "predicted_prob", ".", "sort", "(", "descending", "=", "True", ")", "\n", "predicted_prob", "=", "predicted_prob", "[", ":", "num_topk", "]", "\n", "topk_idxs", "=", "topk_idxs", "[", "idxs", "[", ":", "num_topk", "]", "]", "\n", "\n", "anchor_idxs", "=", "topk_idxs", "//", "self", ".", "num_classes", "\n", "classes_idxs", "=", "topk_idxs", "%", "self", ".", "num_classes", "\n", "\n", "box_reg_i", "=", "box_reg_i", "[", "anchor_idxs", "]", "\n", "anchors_i", "=", "anchors_i", "[", "anchor_idxs", "]", "\n", "# predict boxes", "\n", "predicted_boxes", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "box_reg_i", ",", "anchors_i", ".", "tensor", ")", "\n", "\n", "boxes_all", ".", "append", "(", "predicted_boxes", ")", "\n", "scores_all", ".", "append", "(", "predicted_prob", ")", "\n", "class_idxs_all", ".", "append", "(", "classes_idxs", ")", "\n", "\n", "", "boxes_all", ",", "scores_all", ",", "class_idxs_all", "=", "[", "\n", "cat", "(", "x", ")", "for", "x", "in", "[", "boxes_all", ",", "scores_all", ",", "class_idxs_all", "]", "\n", "]", "\n", "keep", "=", "batched_nms", "(", "boxes_all", ",", "scores_all", ",", "class_idxs_all", ",", "self", ".", "nms_threshold", ")", "\n", "keep", "=", "keep", "[", ":", "self", ".", "max_detections_per_image", "]", "\n", "\n", "result", "=", "Instances", "(", "image_size", ")", "\n", "result", ".", "pred_boxes", "=", "Boxes", "(", "boxes_all", "[", "keep", "]", ")", "\n", "result", ".", "scores", "=", "scores_all", "[", "keep", "]", "\n", "result", ".", "pred_classes", "=", "class_idxs_all", "[", "keep", "]", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNet.preprocess_image": [[383, 391], ["detectron2.structures.ImageList.from_tensors", "x[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "preprocess_image", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Normalize, pad and batch the input images.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNetHead.__init__": [[399, 464], ["torch.nn.Module.__init__", "zip", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.constant_", "logging.getLogger", "logging.getLogger.warn", "cls_subnet.append", "cls_subnet.append", "bbox_subnet.append", "bbox_subnet.append", "modules.modules", "math.log", "torch.nn.Conv2d", "cls_subnet.append", "torch.nn.ReLU", "torch.nn.Conv2d", "bbox_subnet.append", "torch.nn.ReLU", "isinstance", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "torch.nn.init.normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "input_shape", ":", "List", "[", "ShapeSpec", "]", ",", "\n", "num_classes", ",", "\n", "num_anchors", ",", "\n", "conv_dims", ":", "List", "[", "int", "]", ",", "\n", "norm", "=", "\"\"", ",", "\n", "prior_prob", "=", "0.01", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (List[ShapeSpec]): input shape\n            num_classes (int): number of classes. Used to label background proposals.\n            num_anchors (int): number of generated anchors\n            conv_dims (List[int]): dimensions for each convolution layer\n            norm (str or callable):\n                    Normalization for conv layers except for the two output layers.\n                    See :func:`detectron2.layers.get_norm` for supported types.\n            prior_prob (float): Prior weight for computing bias\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "norm", "==", "\"BN\"", "or", "norm", "==", "\"SyncBN\"", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warn", "(", "\"Shared norm does not work well for BN, SyncBN, expect poor results\"", ")", "\n", "\n", "", "cls_subnet", "=", "[", "]", "\n", "bbox_subnet", "=", "[", "]", "\n", "for", "in_channels", ",", "out_channels", "in", "zip", "(", "[", "input_shape", "[", "0", "]", ".", "channels", "]", "+", "conv_dims", ",", "conv_dims", ")", ":", "\n", "            ", "cls_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "if", "norm", ":", "\n", "                ", "cls_subnet", ".", "append", "(", "get_norm", "(", "norm", ",", "out_channels", ")", ")", "\n", "", "cls_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "bbox_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "if", "norm", ":", "\n", "                ", "bbox_subnet", ".", "append", "(", "get_norm", "(", "norm", ",", "out_channels", ")", ")", "\n", "", "bbox_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "self", ".", "cls_subnet", "=", "nn", ".", "Sequential", "(", "*", "cls_subnet", ")", "\n", "self", ".", "bbox_subnet", "=", "nn", ".", "Sequential", "(", "*", "bbox_subnet", ")", "\n", "self", ".", "cls_score", "=", "nn", ".", "Conv2d", "(", "\n", "conv_dims", "[", "-", "1", "]", ",", "num_anchors", "*", "num_classes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Conv2d", "(", "\n", "conv_dims", "[", "-", "1", "]", ",", "num_anchors", "*", "4", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "\n", "# Initialization", "\n", "for", "modules", "in", "[", "self", ".", "cls_subnet", ",", "self", ".", "bbox_subnet", ",", "self", ".", "cls_score", ",", "self", ".", "bbox_pred", "]", ":", "\n", "            ", "for", "layer", "in", "modules", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "layer", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "layer", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "layer", ".", "bias", ",", "0", ")", "\n", "\n", "# Use prior in model initialization to improve stability", "\n", "", "", "", "bias_value", "=", "-", "(", "math", ".", "log", "(", "(", "1", "-", "prior_prob", ")", "/", "prior_prob", ")", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "self", ".", "cls_score", ".", "bias", ",", "bias_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNetHead.from_config": [[465, 481], ["anchor_generator.build_anchor_generator", "len", "set"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.build_anchor_generator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ":", "List", "[", "ShapeSpec", "]", ")", ":", "\n", "        ", "num_anchors", "=", "build_anchor_generator", "(", "cfg", ",", "input_shape", ")", ".", "num_cell_anchors", "\n", "# fmt: on", "\n", "assert", "(", "\n", "len", "(", "set", "(", "num_anchors", ")", ")", "==", "1", "\n", ")", ",", "\"Using different number of anchors between levels is not currently supported!\"", "\n", "num_anchors", "=", "num_anchors", "[", "0", "]", "\n", "\n", "return", "{", "\n", "\"input_shape\"", ":", "input_shape", ",", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NUM_CLASSES", ",", "\n", "\"conv_dims\"", ":", "[", "input_shape", "[", "0", "]", ".", "channels", "]", "*", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NUM_CONVS", ",", "\n", "\"prior_prob\"", ":", "cfg", ".", "MODEL", ".", "RETINANET", ".", "PRIOR_PROB", ",", "\n", "\"norm\"", ":", "cfg", ".", "MODEL", ".", "RETINANET", ".", "NORM", ",", "\n", "\"num_anchors\"", ":", "num_anchors", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.RetinaNetHead.forward": [[483, 505], ["logits.append", "bbox_reg.append", "retinanet.RetinaNetHead.cls_score", "retinanet.RetinaNetHead.bbox_pred", "retinanet.RetinaNetHead.cls_subnet", "retinanet.RetinaNetHead.bbox_subnet"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            features (list[Tensor]): FPN feature map tensors in high to low resolution.\n                Each tensor in the list correspond to different feature levels.\n\n        Returns:\n            logits (list[Tensor]): #lvl tensors, each has shape (N, AxK, Hi, Wi).\n                The tensor predicts the classification probability\n                at each spatial position for each of the A anchors and K object\n                classes.\n            bbox_reg (list[Tensor]): #lvl tensors, each has shape (N, Ax4, Hi, Wi).\n                The tensor predicts 4-vector (dx,dy,dw,dh) box\n                regression values for every anchor. These values are the\n                relative offset between the anchor and the ground truth box.\n        \"\"\"", "\n", "logits", "=", "[", "]", "\n", "bbox_reg", "=", "[", "]", "\n", "for", "feature", "in", "features", ":", "\n", "            ", "logits", ".", "append", "(", "self", ".", "cls_score", "(", "self", ".", "cls_subnet", "(", "feature", ")", ")", ")", "\n", "bbox_reg", ".", "append", "(", "self", ".", "bbox_pred", "(", "self", ".", "bbox_subnet", "(", "feature", ")", ")", ")", "\n", "", "return", "logits", ",", "bbox_reg", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.permute_to_N_HWA_K": [[27, 37], ["tensor.reshape.view", "tensor.reshape.permute", "tensor.reshape.reshape", "tensor.reshape.dim"], "function", ["None"], ["def", "permute_to_N_HWA_K", "(", "tensor", ",", "K", ")", ":", "\n", "    ", "\"\"\"\n    Transpose/reshape a tensor from (N, (Ai x K), H, W) to (N, (HxWxAi), K)\n    \"\"\"", "\n", "assert", "tensor", ".", "dim", "(", ")", "==", "4", ",", "tensor", ".", "shape", "\n", "N", ",", "_", ",", "H", ",", "W", "=", "tensor", ".", "shape", "\n", "tensor", "=", "tensor", ".", "view", "(", "N", ",", "-", "1", ",", "K", ",", "H", ",", "W", ")", "\n", "tensor", "=", "tensor", ".", "permute", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ")", "\n", "tensor", "=", "tensor", ".", "reshape", "(", "N", ",", "-", "1", ",", "K", ")", "# Size=(N,HWA,K)", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.build.build_model": [[15, 24], ["model.to", "META_ARCH_REGISTRY.get", "torch.device"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.panoptic_fpn.PanopticFPN.__init__": [[25, 45], ["torch.nn.Module.__init__", "backbone.build_backbone", "proposal_generator.build_proposal_generator", "roi_heads.build_roi_heads", "semantic_seg.build_sem_seg_head", "panoptic_fpn.PanopticFPN.register_buffer", "panoptic_fpn.PanopticFPN.register_buffer", "panoptic_fpn.PanopticFPN.backbone.output_shape", "panoptic_fpn.PanopticFPN.backbone.output_shape", "panoptic_fpn.PanopticFPN.backbone.output_shape", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.build.build_proposal_generator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.build_roi_heads", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.build_sem_seg_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "instance_loss_weight", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "INSTANCE_LOSS_WEIGHT", "\n", "\n", "# options when combining instance & semantic outputs", "\n", "self", ".", "combine_on", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "ENABLED", "\n", "self", ".", "combine_overlap_threshold", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "OVERLAP_THRESH", "\n", "self", ".", "combine_stuff_area_limit", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "STUFF_AREA_LIMIT", "\n", "self", ".", "combine_instances_confidence_threshold", "=", "(", "\n", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "\n", ")", "\n", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "proposal_generator", "=", "build_proposal_generator", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "roi_heads", "=", "build_roi_heads", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "sem_seg_head", "=", "build_sem_seg_head", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.panoptic_fpn.PanopticFPN.device": [[46, 49], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.panoptic_fpn.PanopticFPN.forward": [[50, 131], ["detectron2.structures.ImageList.from_tensors", "panoptic_fpn.PanopticFPN.backbone", "panoptic_fpn.PanopticFPN.sem_seg_head", "panoptic_fpn.PanopticFPN.roi_heads", "zip", "x[].to", "panoptic_fpn.PanopticFPN.proposal_generator", "losses.update", "losses.update", "losses.update", "input_per_image.get", "input_per_image.get", "postprocessing.sem_seg_postprocess", "postprocessing.detector_postprocess", "processed_results.append", "x[].to", "x[].to", "detectron2.structures.ImageList.from_tensors", "x[].to", "panoptic_fpn.combine_semantic_and_instance_outputs", "postprocessing.sem_seg_postprocess.argmax", "detector_losses.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.panoptic_fpn.combine_semantic_and_instance_outputs"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.\n                Each item in the list contains the inputs for one image.\n\n                For now, each item in the list is a dict that contains:\n\n                * \"image\": Tensor, image in (C, H, W) format.\n                * \"instances\": Instances\n                * \"sem_seg\": semantic segmentation ground truth.\n                * Other information that's included in the original dicts, such as:\n                  \"height\", \"width\" (int): the output resolution of the model, used in inference.\n                  See :meth:`postprocess` for details.\n\n        Returns:\n            list[dict]:\n                each dict is the results for one image. The dict contains the following keys:\n\n                * \"instances\": see :meth:`GeneralizedRCNN.forward` for its format.\n                * \"sem_seg\": see :meth:`SemanticSegmentor.forward` for its format.\n                * \"panoptic_seg\": available when `PANOPTIC_FPN.COMBINE.ENABLED`.\n                  See the return value of\n                  :func:`combine_semantic_and_instance_outputs` for its format.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"proposals\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "proposals", "=", "[", "x", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "proposal_losses", "=", "{", "}", "\n", "\n", "", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_sem_seg", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "gt_sem_seg", "=", "ImageList", ".", "from_tensors", "(", "\n", "gt_sem_seg", ",", "self", ".", "backbone", ".", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "gt_sem_seg", "=", "None", "\n", "", "sem_seg_results", ",", "sem_seg_losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "gt_sem_seg", ")", "\n", "\n", "if", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "else", ":", "\n", "            ", "gt_instances", "=", "None", "\n", "", "if", "self", ".", "proposal_generator", ":", "\n", "            ", "proposals", ",", "proposal_losses", "=", "self", ".", "proposal_generator", "(", "images", ",", "features", ",", "gt_instances", ")", "\n", "", "detector_results", ",", "detector_losses", "=", "self", ".", "roi_heads", "(", "\n", "images", ",", "features", ",", "proposals", ",", "gt_instances", "\n", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "{", "}", "\n", "losses", ".", "update", "(", "sem_seg_losses", ")", "\n", "losses", ".", "update", "(", "{", "k", ":", "v", "*", "self", ".", "instance_loss_weight", "for", "k", ",", "v", "in", "detector_losses", ".", "items", "(", ")", "}", ")", "\n", "losses", ".", "update", "(", "proposal_losses", ")", "\n", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "sem_seg_result", ",", "detector_result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "sem_seg_results", ",", "detector_results", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "sem_seg_r", "=", "sem_seg_postprocess", "(", "sem_seg_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "detector_r", "=", "detector_postprocess", "(", "detector_result", ",", "height", ",", "width", ")", "\n", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "sem_seg_r", ",", "\"instances\"", ":", "detector_r", "}", ")", "\n", "\n", "if", "self", ".", "combine_on", ":", "\n", "                ", "panoptic_r", "=", "combine_semantic_and_instance_outputs", "(", "\n", "detector_r", ",", "\n", "sem_seg_r", ".", "argmax", "(", "dim", "=", "0", ")", ",", "\n", "self", ".", "combine_overlap_threshold", ",", "\n", "self", ".", "combine_stuff_area_limit", ",", "\n", "self", ".", "combine_instances_confidence_threshold", ",", "\n", ")", "\n", "processed_results", "[", "-", "1", "]", "[", "\"panoptic_seg\"", "]", "=", "panoptic_r", "\n", "", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.panoptic_fpn.combine_semantic_and_instance_outputs": [[133, 219], ["torch.zeros_like", "torch.argsort", "instance_results.pred_masks.to", "torch.unique().cpu().tolist", "instance_results.scores[].item", "mask.sum().item", "intersect.sum().item", "segments_info.append", "mask.sum().item", "segments_info.append", "torch.unique().cpu", "mask.sum", "intersect.sum", "instance_results.pred_classes[].item", "inst_id.item", "mask.sum", "torch.unique"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "", "def", "combine_semantic_and_instance_outputs", "(", "\n", "instance_results", ",", "\n", "semantic_results", ",", "\n", "overlap_threshold", ",", "\n", "stuff_area_limit", ",", "\n", "instances_confidence_threshold", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Implement a simple combining logic following\n    \"combine_semantic_and_instance_predictions.py\" in panopticapi\n    to produce panoptic segmentation outputs.\n\n    Args:\n        instance_results: output of :func:`detector_postprocess`.\n        semantic_results: an (H, W) tensor, each is the contiguous semantic\n            category id\n\n    Returns:\n        panoptic_seg (Tensor): of shape (height, width) where the values are ids for each segment.\n        segments_info (list[dict]): Describe each segment in `panoptic_seg`.\n            Each dict contains keys \"id\", \"category_id\", \"isthing\".\n    \"\"\"", "\n", "panoptic_seg", "=", "torch", ".", "zeros_like", "(", "semantic_results", ",", "dtype", "=", "torch", ".", "int32", ")", "\n", "\n", "# sort instance outputs by scores", "\n", "sorted_inds", "=", "torch", ".", "argsort", "(", "-", "instance_results", ".", "scores", ")", "\n", "\n", "current_segment_id", "=", "0", "\n", "segments_info", "=", "[", "]", "\n", "\n", "instance_masks", "=", "instance_results", ".", "pred_masks", ".", "to", "(", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "panoptic_seg", ".", "device", ")", "\n", "\n", "# Add instances one-by-one, check for overlaps with existing ones", "\n", "for", "inst_id", "in", "sorted_inds", ":", "\n", "        ", "score", "=", "instance_results", ".", "scores", "[", "inst_id", "]", ".", "item", "(", ")", "\n", "if", "score", "<", "instances_confidence_threshold", ":", "\n", "            ", "break", "\n", "", "mask", "=", "instance_masks", "[", "inst_id", "]", "# H,W", "\n", "mask_area", "=", "mask", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "if", "mask_area", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "intersect", "=", "(", "mask", ">", "0", ")", "&", "(", "panoptic_seg", ">", "0", ")", "\n", "intersect_area", "=", "intersect", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "if", "intersect_area", "*", "1.0", "/", "mask_area", ">", "overlap_threshold", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "intersect_area", ">", "0", ":", "\n", "            ", "mask", "=", "mask", "&", "(", "panoptic_seg", "==", "0", ")", "\n", "\n", "", "current_segment_id", "+=", "1", "\n", "panoptic_seg", "[", "mask", "]", "=", "current_segment_id", "\n", "segments_info", ".", "append", "(", "\n", "{", "\n", "\"id\"", ":", "current_segment_id", ",", "\n", "\"isthing\"", ":", "True", ",", "\n", "\"score\"", ":", "score", ",", "\n", "\"category_id\"", ":", "instance_results", ".", "pred_classes", "[", "inst_id", "]", ".", "item", "(", ")", ",", "\n", "\"instance_id\"", ":", "inst_id", ".", "item", "(", ")", ",", "\n", "}", "\n", ")", "\n", "\n", "# Add semantic results to remaining empty areas", "\n", "", "semantic_labels", "=", "torch", ".", "unique", "(", "semantic_results", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "for", "semantic_label", "in", "semantic_labels", ":", "\n", "        ", "if", "semantic_label", "==", "0", ":", "# 0 is a special \"thing\" class", "\n", "            ", "continue", "\n", "", "mask", "=", "(", "semantic_results", "==", "semantic_label", ")", "&", "(", "panoptic_seg", "==", "0", ")", "\n", "mask_area", "=", "mask", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "if", "mask_area", "<", "stuff_area_limit", ":", "\n", "            ", "continue", "\n", "\n", "", "current_segment_id", "+=", "1", "\n", "panoptic_seg", "[", "mask", "]", "=", "current_segment_id", "\n", "segments_info", ".", "append", "(", "\n", "{", "\n", "\"id\"", ":", "current_segment_id", ",", "\n", "\"isthing\"", ":", "False", ",", "\n", "\"category_id\"", ":", "semantic_label", ",", "\n", "\"area\"", ":", "mask_area", ",", "\n", "}", "\n", ")", "\n", "\n", "", "return", "panoptic_seg", ",", "segments_info", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.SemanticSegmentor.__init__": [[33, 39], ["torch.nn.Module.__init__", "backbone.build_backbone", "semantic_seg.build_sem_seg_head", "semantic_seg.SemanticSegmentor.register_buffer", "semantic_seg.SemanticSegmentor.register_buffer", "semantic_seg.SemanticSegmentor.backbone.output_shape", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.build_sem_seg_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "sem_seg_head", "=", "build_sem_seg_head", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.SemanticSegmentor.device": [[40, 43], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.SemanticSegmentor.forward": [[44, 93], ["detectron2.structures.ImageList.from_tensors", "semantic_seg.SemanticSegmentor.backbone", "semantic_seg.SemanticSegmentor.sem_seg_head", "zip", "x[].to", "input_per_image.get", "input_per_image.get", "postprocessing.sem_seg_postprocess", "processed_results.append", "x[].to", "detectron2.structures.ImageList.from_tensors"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.\n                Each item in the list contains the inputs for one image.\n\n                For now, each item in the list is a dict that contains:\n\n                   * \"image\": Tensor, image in (C, H, W) format.\n                   * \"sem_seg\": semantic segmentation ground truth\n                   * Other information that's included in the original dicts, such as:\n                     \"height\", \"width\" (int): the output resolution of the model (may be different\n                     from input resolution), used in inference.\n\n\n        Returns:\n            list[dict]:\n              Each dict is the output for one input image.\n              The dict contains one key \"sem_seg\" whose value is a\n              Tensor that represents the\n              per-pixel segmentation prediced by the head.\n              The prediction has shape KxHxW that represents the logits of\n              each class for each pixel.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "targets", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "targets", ",", "self", ".", "backbone", ".", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "targets", "=", "None", "\n", "", "results", ",", "losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "targets", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ")", "\n", "r", "=", "sem_seg_postprocess", "(", "result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.SemSegFPNHead.__init__": [[111, 154], ["torch.nn.Module.__init__", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "max", "range", "semantic_seg.SemSegFPNHead.scale_heads.append", "semantic_seg.SemSegFPNHead.add_module", "input_shape.items", "input_shape.items", "int", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "head_ops.append", "torch.nn.Sequential", "torch.nn.GroupNorm", "head_ops.append", "numpy.log2", "numpy.log2", "torch.nn.Upsample"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IN_FEATURES", "\n", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "feature_channels", "=", "{", "k", ":", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "self", ".", "ignore_value", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "CONVS_DIM", "\n", "self", ".", "common_stride", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "COMMON_STRIDE", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NORM", "\n", "self", ".", "loss_weight", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_WEIGHT", "\n", "# fmt: on", "\n", "\n", "self", ".", "scale_heads", "=", "[", "]", "\n", "for", "in_feature", "in", "self", ".", "in_features", ":", "\n", "            ", "head_ops", "=", "[", "]", "\n", "head_length", "=", "max", "(", "\n", "1", ",", "int", "(", "np", ".", "log2", "(", "feature_strides", "[", "in_feature", "]", ")", "-", "np", ".", "log2", "(", "self", ".", "common_stride", ")", ")", "\n", ")", "\n", "for", "k", "in", "range", "(", "head_length", ")", ":", "\n", "                ", "norm_module", "=", "nn", ".", "GroupNorm", "(", "32", ",", "conv_dims", ")", "if", "norm", "==", "\"GN\"", "else", "None", "\n", "conv", "=", "Conv2d", "(", "\n", "feature_channels", "[", "in_feature", "]", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "norm", ",", "\n", "norm", "=", "norm_module", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "conv", ")", "\n", "head_ops", ".", "append", "(", "conv", ")", "\n", "if", "feature_strides", "[", "in_feature", "]", "!=", "self", ".", "common_stride", ":", "\n", "                    ", "head_ops", ".", "append", "(", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", ")", "\n", "", "", "self", ".", "scale_heads", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "head_ops", ")", ")", "\n", "self", ".", "add_module", "(", "in_feature", ",", "self", ".", "scale_heads", "[", "-", "1", "]", ")", "\n", "", "self", ".", "predictor", "=", "Conv2d", "(", "conv_dims", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "predictor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.SemSegFPNHead.forward": [[155, 169], ["semantic_seg.SemSegFPNHead.layers", "torch.nn.functional.interpolate", "semantic_seg.SemSegFPNHead.losses"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "forward", "(", "self", ",", "features", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            In training, returns (None, dict of losses)\n            In inference, returns (CxHxW logits, {})\n        \"\"\"", "\n", "x", "=", "self", ".", "layers", "(", "features", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "None", ",", "self", ".", "losses", "(", "x", ",", "targets", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "\n", "x", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "return", "x", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.SemSegFPNHead.layers": [[170, 178], ["enumerate", "semantic_seg.SemSegFPNHead.predictor"], "methods", ["None"], ["", "", "def", "layers", "(", "self", ",", "features", ")", ":", "\n", "        ", "for", "i", ",", "f", "in", "enumerate", "(", "self", ".", "in_features", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "x", "=", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "f", "]", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "x", "+", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "f", "]", ")", "\n", "", "", "x", "=", "self", ".", "predictor", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.SemSegFPNHead.losses": [[179, 188], ["torch.nn.functional.interpolate", "torch.nn.functional.cross_entropy"], "methods", ["None"], ["", "def", "losses", "(", "self", ",", "predictions", ",", "targets", ")", ":", "\n", "        ", "predictions", "=", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "\n", "predictions", ",", "targets", ",", "reduction", "=", "\"mean\"", ",", "ignore_index", "=", "self", ".", "ignore_value", "\n", ")", "\n", "losses", "=", "{", "\"loss_sem_seg\"", ":", "loss", "*", "self", ".", "loss_weight", "}", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.build_sem_seg_head": [[95, 101], ["SEM_SEG_HEADS_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "build_sem_seg_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a semantic segmentation head from `cfg.MODEL.SEM_SEG_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NAME", "\n", "return", "SEM_SEG_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.proposal_utils.find_top_rpn_proposals": [[13, 119], ["len", "torch.arange", "enumerate", "detectron2.layers.cat", "detectron2.layers.cat", "detectron2.layers.cat", "enumerate", "zip", "min", "logits_i.sort", "detectron2.layers.cat.append", "detectron2.layers.cat.append", "detectron2.layers.cat.append", "detectron2.structures.Boxes", "detectron2.structures.Boxes.clip", "detectron2.structures.Boxes.nonempty", "detectron2.layers.batched_nms", "detectron2.structures.Instances", "results.append", "torch.full", "torch.isfinite().all", "torch.isfinite", "valid_mask.all", "detectron2.layers.batched_nms.sum().item", "len", "FloatingPointError", "torch.isfinite", "detectron2.layers.batched_nms.sum"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms"], ["def", "find_top_rpn_proposals", "(", "\n", "proposals", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "pred_objectness_logits", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "image_sizes", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ",", "\n", "nms_thresh", ":", "float", ",", "\n", "pre_nms_topk", ":", "int", ",", "\n", "post_nms_topk", ":", "int", ",", "\n", "min_box_size", ":", "float", ",", "\n", "training", ":", "bool", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    For each feature map, select the `pre_nms_topk` highest scoring proposals,\n    apply NMS, clip proposals, and remove small boxes. Return the `post_nms_topk`\n    highest scoring proposals among all the feature maps for each image.\n\n    Args:\n        proposals (list[Tensor]): A list of L tensors. Tensor i has shape (N, Hi*Wi*A, 4).\n            All proposal predictions on the feature maps.\n        pred_objectness_logits (list[Tensor]): A list of L tensors. Tensor i has shape (N, Hi*Wi*A).\n        image_sizes (list[tuple]): sizes (h, w) for each image\n        nms_thresh (float): IoU threshold to use for NMS\n        pre_nms_topk (int): number of top k scoring proposals to keep before applying NMS.\n            When RPN is run on multiple feature maps (as in FPN) this number is per\n            feature map.\n        post_nms_topk (int): number of top k scoring proposals to keep after applying NMS.\n            When RPN is run on multiple feature maps (as in FPN) this number is total,\n            over all feature maps.\n        min_box_size (float): minimum proposal box side length in pixels (absolute units\n            wrt input images).\n        training (bool): True if proposals are to be used in training, otherwise False.\n            This arg exists only to support a legacy bug; look for the \"NB: Legacy bug ...\"\n            comment.\n\n    Returns:\n        list[Instances]: list of N Instances. The i-th Instances\n            stores post_nms_topk object proposals for image i, sorted by their\n            objectness score in descending order.\n    \"\"\"", "\n", "num_images", "=", "len", "(", "image_sizes", ")", "\n", "device", "=", "proposals", "[", "0", "]", ".", "device", "\n", "\n", "# 1. Select top-k anchor for every level and every image", "\n", "topk_scores", "=", "[", "]", "# #lvl Tensor, each of shape N x topk", "\n", "topk_proposals", "=", "[", "]", "\n", "level_ids", "=", "[", "]", "# #lvl Tensor, each of shape (topk,)", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "num_images", ",", "device", "=", "device", ")", "\n", "for", "level_id", ",", "(", "proposals_i", ",", "logits_i", ")", "in", "enumerate", "(", "zip", "(", "proposals", ",", "pred_objectness_logits", ")", ")", ":", "\n", "        ", "Hi_Wi_A", "=", "logits_i", ".", "shape", "[", "1", "]", "\n", "num_proposals_i", "=", "min", "(", "pre_nms_topk", ",", "Hi_Wi_A", ")", "\n", "\n", "# sort is faster than topk (https://github.com/pytorch/pytorch/issues/22812)", "\n", "# topk_scores_i, topk_idx = logits_i.topk(num_proposals_i, dim=1)", "\n", "logits_i", ",", "idx", "=", "logits_i", ".", "sort", "(", "descending", "=", "True", ",", "dim", "=", "1", ")", "\n", "topk_scores_i", "=", "logits_i", "[", "batch_idx", ",", ":", "num_proposals_i", "]", "\n", "topk_idx", "=", "idx", "[", "batch_idx", ",", ":", "num_proposals_i", "]", "\n", "\n", "# each is N x topk", "\n", "topk_proposals_i", "=", "proposals_i", "[", "batch_idx", "[", ":", ",", "None", "]", ",", "topk_idx", "]", "# N x topk x 4", "\n", "\n", "topk_proposals", ".", "append", "(", "topk_proposals_i", ")", "\n", "topk_scores", ".", "append", "(", "topk_scores_i", ")", "\n", "level_ids", ".", "append", "(", "torch", ".", "full", "(", "(", "num_proposals_i", ",", ")", ",", "level_id", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", ")", "\n", "\n", "# 2. Concat all levels together", "\n", "", "topk_scores", "=", "cat", "(", "topk_scores", ",", "dim", "=", "1", ")", "\n", "topk_proposals", "=", "cat", "(", "topk_proposals", ",", "dim", "=", "1", ")", "\n", "level_ids", "=", "cat", "(", "level_ids", ",", "dim", "=", "0", ")", "\n", "\n", "# 3. For each image, run a per-level NMS, and choose topk results.", "\n", "results", ":", "List", "[", "Instances", "]", "=", "[", "]", "\n", "for", "n", ",", "image_size", "in", "enumerate", "(", "image_sizes", ")", ":", "\n", "        ", "boxes", "=", "Boxes", "(", "topk_proposals", "[", "n", "]", ")", "\n", "scores_per_img", "=", "topk_scores", "[", "n", "]", "\n", "lvl", "=", "level_ids", "\n", "\n", "valid_mask", "=", "torch", ".", "isfinite", "(", "boxes", ".", "tensor", ")", ".", "all", "(", "dim", "=", "1", ")", "&", "torch", ".", "isfinite", "(", "scores_per_img", ")", "\n", "if", "not", "valid_mask", ".", "all", "(", ")", ":", "\n", "            ", "if", "training", ":", "\n", "                ", "raise", "FloatingPointError", "(", "\n", "\"Predicted boxes or scores contain Inf/NaN. Training has diverged.\"", "\n", ")", "\n", "", "boxes", "=", "boxes", "[", "valid_mask", "]", "\n", "scores_per_img", "=", "scores_per_img", "[", "valid_mask", "]", "\n", "lvl", "=", "lvl", "[", "valid_mask", "]", "\n", "", "boxes", ".", "clip", "(", "image_size", ")", "\n", "\n", "# filter empty boxes", "\n", "keep", "=", "boxes", ".", "nonempty", "(", "threshold", "=", "min_box_size", ")", "\n", "if", "keep", ".", "sum", "(", ")", ".", "item", "(", ")", "!=", "len", "(", "boxes", ")", ":", "\n", "            ", "boxes", ",", "scores_per_img", ",", "lvl", "=", "boxes", "[", "keep", "]", ",", "scores_per_img", "[", "keep", "]", ",", "lvl", "[", "keep", "]", "\n", "\n", "", "keep", "=", "batched_nms", "(", "boxes", ".", "tensor", ",", "scores_per_img", ",", "lvl", ",", "nms_thresh", ")", "\n", "# In Detectron1, there was different behavior during training vs. testing.", "\n", "# (https://github.com/facebookresearch/Detectron/issues/459)", "\n", "# During training, topk is over the proposals from *all* images in the training batch.", "\n", "# During testing, it is over the proposals for each image separately.", "\n", "# As a result, the training behavior becomes batch-dependent,", "\n", "# and the configuration \"POST_NMS_TOPK_TRAIN\" end up relying on the batch size.", "\n", "# This bug is addressed in Detectron2 to make the behavior independent of batch size.", "\n", "keep", "=", "keep", "[", ":", "post_nms_topk", "]", "# keep is already sorted", "\n", "\n", "res", "=", "Instances", "(", "image_size", ")", "\n", "res", ".", "proposal_boxes", "=", "boxes", "[", "keep", "]", "\n", "res", ".", "objectness_logits", "=", "scores_per_img", "[", "keep", "]", "\n", "results", ".", "append", "(", "res", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.proposal_utils.add_ground_truth_to_proposals": [[121, 144], ["len", "len", "len", "proposal_utils.add_ground_truth_to_proposals_single_image", "zip"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.proposal_utils.add_ground_truth_to_proposals_single_image"], ["", "def", "add_ground_truth_to_proposals", "(", "gt_boxes", ",", "proposals", ")", ":", "\n", "    ", "\"\"\"\n    Call `add_ground_truth_to_proposals_single_image` for all images.\n\n    Args:\n        gt_boxes(list[Boxes]): list of N elements. Element i is a Boxes\n            representing the gound-truth for image i.\n        proposals (list[Instances]): list of N elements. Element i is a Instances\n            representing the proposals for image i.\n\n    Returns:\n        list[Instances]: list of N Instances. Each is the proposals for the image,\n            with field \"proposal_boxes\" and \"objectness_logits\".\n    \"\"\"", "\n", "assert", "gt_boxes", "is", "not", "None", "\n", "\n", "assert", "len", "(", "proposals", ")", "==", "len", "(", "gt_boxes", ")", "\n", "if", "len", "(", "proposals", ")", "==", "0", ":", "\n", "        ", "return", "proposals", "\n", "\n", "", "return", "[", "\n", "add_ground_truth_to_proposals_single_image", "(", "gt_boxes_i", ",", "proposals_i", ")", "\n", "for", "gt_boxes_i", ",", "proposals_i", "in", "zip", "(", "gt_boxes", ",", "proposals", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.proposal_utils.add_ground_truth_to_proposals_single_image": [[147, 171], ["math.log", "detectron2.structures.Instances", "detectron2.structures.Instances.cat", "torch.ones", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "add_ground_truth_to_proposals_single_image", "(", "gt_boxes", ",", "proposals", ")", ":", "\n", "    ", "\"\"\"\n    Augment `proposals` with ground-truth boxes from `gt_boxes`.\n\n    Args:\n        Same as `add_ground_truth_to_proposals`, but with gt_boxes and proposals\n        per image.\n\n    Returns:\n        Same as `add_ground_truth_to_proposals`, but for only one image.\n    \"\"\"", "\n", "device", "=", "proposals", ".", "objectness_logits", ".", "device", "\n", "# Assign all ground-truth boxes an objectness logit corresponding to", "\n", "# P(object) = sigmoid(logit) =~ 1.", "\n", "gt_logit_value", "=", "math", ".", "log", "(", "(", "1.0", "-", "1e-10", ")", "/", "(", "1", "-", "(", "1.0", "-", "1e-10", ")", ")", ")", "\n", "gt_logits", "=", "gt_logit_value", "*", "torch", ".", "ones", "(", "len", "(", "gt_boxes", ")", ",", "device", "=", "device", ")", "\n", "\n", "# Concatenating gt_boxes with proposals requires them to have the same fields", "\n", "gt_proposal", "=", "Instances", "(", "proposals", ".", "image_size", ")", "\n", "gt_proposal", ".", "proposal_boxes", "=", "gt_boxes", "\n", "gt_proposal", ".", "objectness_logits", "=", "gt_logits", "\n", "new_proposals", "=", "Instances", ".", "cat", "(", "[", "proposals", ",", "gt_proposal", "]", ")", "\n", "\n", "return", "new_proposals", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.StandardRPNHead.__init__": [[76, 102], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "in_channels", ":", "int", ",", "num_anchors", ":", "int", ",", "box_dim", ":", "int", "=", "4", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            in_channels (int): number of input feature channels. When using multiple\n                input features, they must have the same number of channels.\n            num_anchors (int): number of anchors to predict for *each spatial position*\n                on the feature map. The total number of anchors for each\n                feature map will be `num_anchors * H * W`.\n            box_dim (int): dimension of a box, which is also the number of box regression\n                predictions to make for each anchor. An axis aligned box has\n                box_dim=4, while a rotated box has box_dim=5.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# 3x3 conv for the hidden representation", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "in_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "# 1x1 conv for predicting objectness logits", "\n", "self", ".", "objectness_logits", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "num_anchors", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "# 1x1 conv for predicting box2box transform deltas", "\n", "self", ".", "anchor_deltas", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "num_anchors", "*", "box_dim", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "\n", "for", "l", "in", "[", "self", ".", "conv", ",", "self", ".", "objectness_logits", ",", "self", ".", "anchor_deltas", "]", ":", "\n", "            ", "nn", ".", "init", ".", "normal_", "(", "l", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.StandardRPNHead.from_config": [[103, 119], ["anchor_generator.build_anchor_generator.build_anchor_generator", "len", "len", "set", "set"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.build_anchor_generator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# Standard RPN is shared across levels:", "\n", "        ", "in_channels", "=", "[", "s", ".", "channels", "for", "s", "in", "input_shape", "]", "\n", "assert", "len", "(", "set", "(", "in_channels", ")", ")", "==", "1", ",", "\"Each level must have the same channel!\"", "\n", "in_channels", "=", "in_channels", "[", "0", "]", "\n", "\n", "# RPNHead should take the same input as anchor generator", "\n", "# NOTE: it assumes that creating an anchor generator does not have unwanted side effect.", "\n", "anchor_generator", "=", "build_anchor_generator", "(", "cfg", ",", "input_shape", ")", "\n", "num_anchors", "=", "anchor_generator", ".", "num_anchors", "\n", "box_dim", "=", "anchor_generator", ".", "box_dim", "\n", "assert", "(", "\n", "len", "(", "set", "(", "num_anchors", ")", ")", "==", "1", "\n", ")", ",", "\"Each level must have the same number of anchors per spatial position\"", "\n", "return", "{", "\"in_channels\"", ":", "in_channels", ",", "\"num_anchors\"", ":", "num_anchors", "[", "0", "]", ",", "\"box_dim\"", ":", "box_dim", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.StandardRPNHead.forward": [[120, 140], ["torch.relu", "torch.relu", "pred_objectness_logits.append", "pred_anchor_deltas.append", "rpn.StandardRPNHead.conv", "rpn.StandardRPNHead.objectness_logits", "rpn.StandardRPNHead.anchor_deltas"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features (list[Tensor]): list of feature maps\n\n        Returns:\n            list[Tensor]: A list of L elements.\n                Element i is a tensor of shape (N, A, Hi, Wi) representing\n                the predicted objectness logits for all anchors. A is the number of cell anchors.\n            list[Tensor]: A list of L elements. Element i is a tensor of shape\n                (N, A*box_dim, Hi, Wi) representing the predicted \"deltas\" used to transform anchors\n                to proposals.\n        \"\"\"", "\n", "pred_objectness_logits", "=", "[", "]", "\n", "pred_anchor_deltas", "=", "[", "]", "\n", "for", "x", "in", "features", ":", "\n", "            ", "t", "=", "F", ".", "relu", "(", "self", ".", "conv", "(", "x", ")", ")", "\n", "pred_objectness_logits", ".", "append", "(", "self", ".", "objectness_logits", "(", "t", ")", ")", "\n", "pred_anchor_deltas", ".", "append", "(", "self", ".", "anchor_deltas", "(", "t", ")", ")", "\n", "", "return", "pred_objectness_logits", ",", "pred_anchor_deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN.__init__": [[148, 219], ["torch.nn.Module.__init__", "float", "isinstance"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "in_features", ":", "List", "[", "str", "]", ",", "\n", "head", ":", "nn", ".", "Module", ",", "\n", "anchor_generator", ":", "nn", ".", "Module", ",", "\n", "anchor_matcher", ":", "Matcher", ",", "\n", "box2box_transform", ":", "Box2BoxTransform", ",", "\n", "batch_size_per_image", ":", "int", ",", "\n", "positive_fraction", ":", "float", ",", "\n", "pre_nms_topk", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "post_nms_topk", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "nms_thresh", ":", "float", "=", "0.7", ",", "\n", "min_box_size", ":", "float", "=", "0.0", ",", "\n", "anchor_boundary_thresh", ":", "float", "=", "-", "1.0", ",", "\n", "loss_weight", ":", "Union", "[", "float", ",", "Dict", "[", "str", ",", "float", "]", "]", "=", "1.0", ",", "\n", "box_reg_loss_type", ":", "str", "=", "\"smooth_l1\"", ",", "\n", "smooth_l1_beta", ":", "float", "=", "0.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            in_features (list[str]): list of names of input features to use\n            head (nn.Module): a module that predicts logits and regression deltas\n                for each level from a list of per-level features\n            anchor_generator (nn.Module): a module that creates anchors from a\n                list of features. Usually an instance of :class:`AnchorGenerator`\n            anchor_matcher (Matcher): label the anchors by matching them with ground truth.\n            box2box_transform (Box2BoxTransform): defines the transform from anchors boxes to\n                instance boxes\n            batch_size_per_image (int): number of anchors per image to sample for training\n            positive_fraction (float): fraction of foreground anchors to sample for training\n            pre_nms_topk (tuple[float]): (train, test) that represents the\n                number of top k proposals to select before NMS, in\n                training and testing.\n            post_nms_topk (tuple[float]): (train, test) that represents the\n                number of top k proposals to select after NMS, in\n                training and testing.\n            nms_thresh (float): NMS threshold used to de-duplicate the predicted proposals\n            min_box_size (float): remove proposal boxes with any side smaller than this threshold,\n                in the unit of input image pixels\n            anchor_boundary_thresh (float): legacy option\n            loss_weight (float|dict): weights to use for losses. Can be single float for weighting\n                all rpn losses together, or a dict of individual weightings. Valid dict keys are:\n                    \"loss_rpn_cls\" - applied to classification loss\n                    \"loss_rpn_loc\" - applied to box regression loss\n            box_reg_loss_type (str): Loss type to use. Supported losses: \"smooth_l1\", \"giou\".\n            smooth_l1_beta (float): beta parameter for the smooth L1 regression loss. Default to\n                use L1 loss. Only used when `box_reg_loss_type` is \"smooth_l1\"\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "rpn_head", "=", "head", "\n", "self", ".", "anchor_generator", "=", "anchor_generator", "\n", "self", ".", "anchor_matcher", "=", "anchor_matcher", "\n", "self", ".", "box2box_transform", "=", "box2box_transform", "\n", "self", ".", "batch_size_per_image", "=", "batch_size_per_image", "\n", "self", ".", "positive_fraction", "=", "positive_fraction", "\n", "# Map from self.training state to train/test settings", "\n", "self", ".", "pre_nms_topk", "=", "{", "True", ":", "pre_nms_topk", "[", "0", "]", ",", "False", ":", "pre_nms_topk", "[", "1", "]", "}", "\n", "self", ".", "post_nms_topk", "=", "{", "True", ":", "post_nms_topk", "[", "0", "]", ",", "False", ":", "post_nms_topk", "[", "1", "]", "}", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "self", ".", "min_box_size", "=", "float", "(", "min_box_size", ")", "\n", "self", ".", "anchor_boundary_thresh", "=", "anchor_boundary_thresh", "\n", "if", "isinstance", "(", "loss_weight", ",", "float", ")", ":", "\n", "            ", "loss_weight", "=", "{", "\"loss_rpn_cls\"", ":", "loss_weight", ",", "\"loss_rpn_loc\"", ":", "loss_weight", "}", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "self", ".", "box_reg_loss_type", "=", "box_reg_loss_type", "\n", "self", ".", "smooth_l1_beta", "=", "smooth_l1_beta", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN.from_config": [[220, 248], ["anchor_generator.build_anchor_generator", "matcher.Matcher", "rpn.build_rpn_head", "box_regression.Box2BoxTransform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.anchor_generator.build_anchor_generator", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.build_rpn_head"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "in_features", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "IN_FEATURES", "\n", "ret", "=", "{", "\n", "\"in_features\"", ":", "in_features", ",", "\n", "\"min_box_size\"", ":", "cfg", ".", "MODEL", ".", "PROPOSAL_GENERATOR", ".", "MIN_SIZE", ",", "\n", "\"nms_thresh\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "NMS_THRESH", ",", "\n", "\"batch_size_per_image\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "BATCH_SIZE_PER_IMAGE", ",", "\n", "\"positive_fraction\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "POSITIVE_FRACTION", ",", "\n", "\"loss_weight\"", ":", "{", "\n", "\"loss_rpn_cls\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "LOSS_WEIGHT", ",", "\n", "\"loss_rpn_loc\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_LOSS_WEIGHT", "*", "cfg", ".", "MODEL", ".", "RPN", ".", "LOSS_WEIGHT", ",", "\n", "}", ",", "\n", "\"anchor_boundary_thresh\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "BOUNDARY_THRESH", ",", "\n", "\"box2box_transform\"", ":", "Box2BoxTransform", "(", "weights", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_WEIGHTS", ")", ",", "\n", "\"box_reg_loss_type\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_LOSS_TYPE", ",", "\n", "\"smooth_l1_beta\"", ":", "cfg", ".", "MODEL", ".", "RPN", ".", "SMOOTH_L1_BETA", ",", "\n", "}", "\n", "\n", "ret", "[", "\"pre_nms_topk\"", "]", "=", "(", "cfg", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOPK_TRAIN", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "PRE_NMS_TOPK_TEST", ")", "\n", "ret", "[", "\"post_nms_topk\"", "]", "=", "(", "cfg", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOPK_TRAIN", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "POST_NMS_TOPK_TEST", ")", "\n", "\n", "ret", "[", "\"anchor_generator\"", "]", "=", "build_anchor_generator", "(", "cfg", ",", "[", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "]", ")", "\n", "ret", "[", "\"anchor_matcher\"", "]", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_THRESHOLDS", ",", "cfg", ".", "MODEL", ".", "RPN", ".", "IOU_LABELS", ",", "allow_low_quality_matches", "=", "True", "\n", ")", "\n", "ret", "[", "\"head\"", "]", "=", "build_rpn_head", "(", "cfg", ",", "[", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "]", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN._subsample_labels": [[249, 266], ["sampling.subsample_labels", "label.fill_", "label.scatter_", "label.scatter_"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.sampling.subsample_labels"], ["", "def", "_subsample_labels", "(", "self", ",", "label", ")", ":", "\n", "        ", "\"\"\"\n        Randomly sample a subset of positive and negative examples, and overwrite\n        the label vector to the ignore value (-1) for all elements that are not\n        included in the sample.\n\n        Args:\n            labels (Tensor): a vector of -1, 0, 1. Will be modified in-place and returned.\n        \"\"\"", "\n", "pos_idx", ",", "neg_idx", "=", "subsample_labels", "(", "\n", "label", ",", "self", ".", "batch_size_per_image", ",", "self", ".", "positive_fraction", ",", "0", "\n", ")", "\n", "# Fill with the ignore label (-1), then set positive and negative labels", "\n", "label", ".", "fill_", "(", "-", "1", ")", "\n", "label", ".", "scatter_", "(", "0", ",", "pos_idx", ",", "1", ")", "\n", "label", ".", "scatter_", "(", "0", ",", "neg_idx", ",", "0", ")", "\n", "return", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN.label_and_sample_anchors": [[267, 326], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "detectron2.structures.Boxes.cat", "zip", "rpn.RPN.to", "rpn.RPN._subsample_labels", "gt_labels.append", "matched_gt_boxes.append", "detectron2.utils.memory.retry_if_cuda_oom", "detectron2.utils.memory.retry_if_cuda_oom", "detectron2.structures.Boxes.cat.inside_box", "len", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN._subsample_labels", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.memory.retry_if_cuda_oom", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.memory.retry_if_cuda_oom", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.inside_box"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_anchors", "(", "\n", "self", ",", "anchors", ":", "List", "[", "Boxes", "]", ",", "gt_instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Tuple", "[", "List", "[", "torch", ".", "Tensor", "]", ",", "List", "[", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[Boxes]): anchors for each feature map.\n            gt_instances: the ground-truth instances for each image.\n\n        Returns:\n            list[Tensor]:\n                List of #img tensors. i-th element is a vector of labels whose length is\n                the total number of anchors across all feature maps R = sum(Hi * Wi * A).\n                Label values are in {-1, 0, 1}, with meanings: -1 = ignore; 0 = negative\n                class; 1 = positive class.\n            list[Tensor]:\n                i-th element is a Rx4 tensor. The values are the matched gt boxes for each\n                anchor. Values are undefined for those anchors not labeled as 1.\n        \"\"\"", "\n", "anchors", "=", "Boxes", ".", "cat", "(", "anchors", ")", "\n", "\n", "gt_boxes", "=", "[", "x", ".", "gt_boxes", "for", "x", "in", "gt_instances", "]", "\n", "image_sizes", "=", "[", "x", ".", "image_size", "for", "x", "in", "gt_instances", "]", "\n", "del", "gt_instances", "\n", "\n", "gt_labels", "=", "[", "]", "\n", "matched_gt_boxes", "=", "[", "]", "\n", "for", "image_size_i", ",", "gt_boxes_i", "in", "zip", "(", "image_sizes", ",", "gt_boxes", ")", ":", "\n", "            ", "\"\"\"\n            image_size_i: (h, w) for the i-th image\n            gt_boxes_i: ground-truth boxes for i-th image\n            \"\"\"", "\n", "\n", "match_quality_matrix", "=", "retry_if_cuda_oom", "(", "pairwise_iou", ")", "(", "gt_boxes_i", ",", "anchors", ")", "\n", "matched_idxs", ",", "gt_labels_i", "=", "retry_if_cuda_oom", "(", "self", ".", "anchor_matcher", ")", "(", "match_quality_matrix", ")", "\n", "# Matching is memory-expensive and may result in CPU tensors. But the result is small", "\n", "gt_labels_i", "=", "gt_labels_i", ".", "to", "(", "device", "=", "gt_boxes_i", ".", "device", ")", "\n", "del", "match_quality_matrix", "\n", "\n", "if", "self", ".", "anchor_boundary_thresh", ">=", "0", ":", "\n", "# Discard anchors that go out of the boundaries of the image", "\n", "# NOTE: This is legacy functionality that is turned off by default in Detectron2", "\n", "                ", "anchors_inside_image", "=", "anchors", ".", "inside_box", "(", "image_size_i", ",", "self", ".", "anchor_boundary_thresh", ")", "\n", "gt_labels_i", "[", "~", "anchors_inside_image", "]", "=", "-", "1", "\n", "\n", "# A vector of labels (-1, 0, 1) for each anchor", "\n", "", "gt_labels_i", "=", "self", ".", "_subsample_labels", "(", "gt_labels_i", ")", "\n", "\n", "if", "len", "(", "gt_boxes_i", ")", "==", "0", ":", "\n", "# These values won't be used anyway since the anchor is labeled as background", "\n", "                ", "matched_gt_boxes_i", "=", "torch", ".", "zeros_like", "(", "anchors", ".", "tensor", ")", "\n", "", "else", ":", "\n", "# TODO wasted indexing computation for ignored boxes", "\n", "                ", "matched_gt_boxes_i", "=", "gt_boxes_i", "[", "matched_idxs", "]", ".", "tensor", "\n", "\n", "", "gt_labels", ".", "append", "(", "gt_labels_i", ")", "# N,AHW", "\n", "matched_gt_boxes", ".", "append", "(", "matched_gt_boxes_i", ")", "\n", "", "return", "gt_labels", ",", "matched_gt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN.losses": [[327, 401], ["len", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "pos_mask.view.view.sum().item", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "fvcore.nn.smooth_l1_loss", "gt_labels[].to", "pos_mask.view.view.sum", "type().cat", "rpn.RPN.box2box_transform.get_deltas", "rpn.RPN._decode_proposals", "detectron2.layers.cat", "pred_proposals.view.view.view", "pos_mask.view.view.view", "fvcore.nn.giou_loss", "ValueError", "detectron2.layers.cat", "rpn.RPN.loss_weight.get", "losses.items", "detectron2.layers.cat", "type", "detectron2.layers.cat"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN._decode_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "losses", "(", "\n", "self", ",", "\n", "anchors", ":", "List", "[", "Boxes", "]", ",", "\n", "pred_objectness_logits", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "gt_labels", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "pred_anchor_deltas", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "gt_boxes", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Return the losses from a set of RPN predictions and their associated ground-truth.\n\n        Args:\n            anchors (list[Boxes or RotatedBoxes]): anchors for each feature map, each\n                has shape (Hi*Wi*A, B), where B is box dimension (4 or 5).\n            pred_objectness_logits (list[Tensor]): A list of L elements.\n                Element i is a tensor of shape (N, Hi*Wi*A) representing\n                the predicted objectness logits for all anchors.\n            gt_labels (list[Tensor]): Output of :meth:`label_and_sample_anchors`.\n            pred_anchor_deltas (list[Tensor]): A list of L elements. Element i is a tensor of shape\n                (N, Hi*Wi*A, 4 or 5) representing the predicted \"deltas\" used to transform anchors\n                to proposals.\n            gt_boxes (list[Tensor]): Output of :meth:`label_and_sample_anchors`.\n\n        Returns:\n            dict[loss name -> loss value]: A dict mapping from loss name to loss value.\n                Loss names are: `loss_rpn_cls` for objectness classification and\n                `loss_rpn_loc` for proposal localization.\n        \"\"\"", "\n", "num_images", "=", "len", "(", "gt_labels", ")", "\n", "gt_labels", "=", "torch", ".", "stack", "(", "gt_labels", ")", "# (N, sum(Hi*Wi*Ai))", "\n", "\n", "# Log the number of positive/negative anchors per-image that's used in training", "\n", "pos_mask", "=", "gt_labels", "==", "1", "\n", "num_pos_anchors", "=", "pos_mask", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "num_neg_anchors", "=", "(", "gt_labels", "==", "0", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"rpn/num_pos_anchors\"", ",", "num_pos_anchors", "/", "num_images", ")", "\n", "storage", ".", "put_scalar", "(", "\"rpn/num_neg_anchors\"", ",", "num_neg_anchors", "/", "num_images", ")", "\n", "\n", "if", "self", ".", "box_reg_loss_type", "==", "\"smooth_l1\"", ":", "\n", "            ", "anchors", "=", "type", "(", "anchors", "[", "0", "]", ")", ".", "cat", "(", "anchors", ")", ".", "tensor", "# Ax(4 or 5)", "\n", "gt_anchor_deltas", "=", "[", "self", ".", "box2box_transform", ".", "get_deltas", "(", "anchors", ",", "k", ")", "for", "k", "in", "gt_boxes", "]", "\n", "gt_anchor_deltas", "=", "torch", ".", "stack", "(", "gt_anchor_deltas", ")", "# (N, sum(Hi*Wi*Ai), 4 or 5)", "\n", "localization_loss", "=", "smooth_l1_loss", "(", "\n", "cat", "(", "pred_anchor_deltas", ",", "dim", "=", "1", ")", "[", "pos_mask", "]", ",", "\n", "gt_anchor_deltas", "[", "pos_mask", "]", ",", "\n", "self", ".", "smooth_l1_beta", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "", "elif", "self", ".", "box_reg_loss_type", "==", "\"giou\"", ":", "\n", "            ", "pred_proposals", "=", "self", ".", "_decode_proposals", "(", "anchors", ",", "pred_anchor_deltas", ")", "\n", "pred_proposals", "=", "cat", "(", "pred_proposals", ",", "dim", "=", "1", ")", "\n", "pred_proposals", "=", "pred_proposals", ".", "view", "(", "-", "1", ",", "pred_proposals", ".", "shape", "[", "-", "1", "]", ")", "\n", "pos_mask", "=", "pos_mask", ".", "view", "(", "-", "1", ")", "\n", "localization_loss", "=", "giou_loss", "(", "\n", "pred_proposals", "[", "pos_mask", "]", ",", "cat", "(", "gt_boxes", ")", "[", "pos_mask", "]", ",", "reduction", "=", "\"sum\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Invalid rpn box reg loss type '{self.box_reg_loss_type}'\"", ")", "\n", "\n", "", "valid_mask", "=", "gt_labels", ">=", "0", "\n", "objectness_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "cat", "(", "pred_objectness_logits", ",", "dim", "=", "1", ")", "[", "valid_mask", "]", ",", "\n", "gt_labels", "[", "valid_mask", "]", ".", "to", "(", "torch", ".", "float32", ")", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "normalizer", "=", "self", ".", "batch_size_per_image", "*", "num_images", "\n", "losses", "=", "{", "\n", "\"loss_rpn_cls\"", ":", "objectness_loss", "/", "normalizer", ",", "\n", "\"loss_rpn_loc\"", ":", "localization_loss", "/", "normalizer", ",", "\n", "}", "\n", "losses", "=", "{", "k", ":", "v", "*", "self", ".", "loss_weight", ".", "get", "(", "k", ",", "1.0", ")", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", "}", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN.forward": [[402, 452], ["rpn.RPN.anchor_generator", "rpn.RPN.rpn_head", "rpn.RPN.predict_proposals", "score.permute().flatten", "x.view().permute().flatten", "rpn.RPN.label_and_sample_anchors", "rpn.RPN.losses", "score.permute", "x.view().permute", "x.view"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rrpn.RRPN.predict_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rrpn.RRPN.label_and_sample_anchors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "gt_instances", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            images (ImageList): input images of length `N`\n            features (dict[str, Tensor]): input data as a mapping from feature\n                map name to tensor. Axis 0 represents the number of images `N` in\n                the input data; axes 1-3 are channels, height, and width, which may\n                vary between feature maps (e.g., if a feature pyramid is used).\n            gt_instances (list[Instances], optional): a length `N` list of `Instances`s.\n                Each `Instances` stores ground-truth instances for the corresponding image.\n\n        Returns:\n            proposals: list[Instances]: contains fields \"proposal_boxes\", \"objectness_logits\"\n            loss: dict[Tensor] or None\n        \"\"\"", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "anchors", "=", "self", ".", "anchor_generator", "(", "features", ")", "\n", "\n", "pred_objectness_logits", ",", "pred_anchor_deltas", "=", "self", ".", "rpn_head", "(", "features", ")", "\n", "# Transpose the Hi*Wi*A dimension to the middle:", "\n", "pred_objectness_logits", "=", "[", "\n", "# (N, A, Hi, Wi) -> (N, Hi, Wi, A) -> (N, Hi*Wi*A)", "\n", "score", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "flatten", "(", "1", ")", "\n", "for", "score", "in", "pred_objectness_logits", "\n", "]", "\n", "pred_anchor_deltas", "=", "[", "\n", "# (N, A*B, Hi, Wi) -> (N, A, B, Hi, Wi) -> (N, Hi, Wi, A, B) -> (N, Hi*Wi*A, B)", "\n", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "self", ".", "anchor_generator", ".", "box_dim", ",", "x", ".", "shape", "[", "-", "2", "]", ",", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", ".", "permute", "(", "0", ",", "3", ",", "4", ",", "1", ",", "2", ")", "\n", ".", "flatten", "(", "1", ",", "-", "2", ")", "\n", "for", "x", "in", "pred_anchor_deltas", "\n", "]", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "gt_instances", "is", "not", "None", ",", "\"RPN requires gt_instances in training!\"", "\n", "gt_labels", ",", "gt_boxes", "=", "self", ".", "label_and_sample_anchors", "(", "anchors", ",", "gt_instances", ")", "\n", "losses", "=", "self", ".", "losses", "(", "\n", "anchors", ",", "pred_objectness_logits", ",", "gt_labels", ",", "pred_anchor_deltas", ",", "gt_boxes", "\n", ")", "\n", "", "else", ":", "\n", "            ", "losses", "=", "{", "}", "\n", "", "proposals", "=", "self", ".", "predict_proposals", "(", "\n", "anchors", ",", "pred_objectness_logits", ",", "pred_anchor_deltas", ",", "images", ".", "image_sizes", "\n", ")", "\n", "return", "proposals", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN.predict_proposals": [[453, 483], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "rpn.RPN._decode_proposals", "proposal_utils.find_top_rpn_proposals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN._decode_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.proposal_utils.find_top_rpn_proposals"], ["", "def", "predict_proposals", "(", "\n", "self", ",", "\n", "anchors", ":", "List", "[", "Boxes", "]", ",", "\n", "pred_objectness_logits", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "pred_anchor_deltas", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "image_sizes", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Decode all the predicted box regression deltas to proposals. Find the top proposals\n        by applying NMS and removing boxes that are too small.\n\n        Returns:\n            proposals (list[Instances]): list of N Instances. The i-th Instances\n                stores post_nms_topk object proposals for image i, sorted by their\n                objectness score in descending order.\n        \"\"\"", "\n", "# The proposals are treated as fixed for joint training with roi heads.", "\n", "# This approach ignores the derivative w.r.t. the proposal boxes\u2019 coordinates that", "\n", "# are also network responses.", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "pred_proposals", "=", "self", ".", "_decode_proposals", "(", "anchors", ",", "pred_anchor_deltas", ")", "\n", "return", "find_top_rpn_proposals", "(", "\n", "pred_proposals", ",", "\n", "pred_objectness_logits", ",", "\n", "image_sizes", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "self", ".", "pre_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "self", ".", "post_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "self", ".", "min_box_size", ",", "\n", "self", ".", "training", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN._decode_proposals": [[485, 505], ["zip", "anchors_i.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape.tensor.size", "pred_anchor_deltas_i.reshape.reshape.reshape", "anchors_i.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape", "rpn.RPN.box2box_transform.apply_deltas", "proposals.append", "rpn.RPN.view", "anchors_i.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand", "anchors_i.tensor.unsqueeze().expand().reshape.tensor.unsqueeze().expand().reshape.tensor.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas"], ["", "", "def", "_decode_proposals", "(", "self", ",", "anchors", ":", "List", "[", "Boxes", "]", ",", "pred_anchor_deltas", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "\"\"\"\n        Transform anchors into proposals by applying the predicted anchor deltas.\n\n        Returns:\n            proposals (list[Tensor]): A list of L tensors. Tensor i has shape\n                (N, Hi*Wi*A, B)\n        \"\"\"", "\n", "N", "=", "pred_anchor_deltas", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "proposals", "=", "[", "]", "\n", "# For each feature map", "\n", "for", "anchors_i", ",", "pred_anchor_deltas_i", "in", "zip", "(", "anchors", ",", "pred_anchor_deltas", ")", ":", "\n", "            ", "B", "=", "anchors_i", ".", "tensor", ".", "size", "(", "1", ")", "\n", "pred_anchor_deltas_i", "=", "pred_anchor_deltas_i", ".", "reshape", "(", "-", "1", ",", "B", ")", "\n", "# Expand anchors to shape (N*Hi*Wi*A, B)", "\n", "anchors_i", "=", "anchors_i", ".", "tensor", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "N", ",", "-", "1", ",", "-", "1", ")", ".", "reshape", "(", "-", "1", ",", "B", ")", "\n", "proposals_i", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "pred_anchor_deltas_i", ",", "anchors_i", ")", "\n", "# Append feature map proposals with shape (N, Hi*Wi*A, B)", "\n", "proposals", ".", "append", "(", "proposals_i", ".", "view", "(", "N", ",", "-", "1", ",", "B", ")", ")", "\n", "", "return", "proposals", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.build_rpn_head": [[59, 65], ["RPN_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "build_rpn_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build an RPN head defined by `cfg.MODEL.RPN.HEAD_NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", "\n", "return", "RPN_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rrpn.RRPN.__init__": [[129, 135], ["box_regression.Box2BoxTransformRotated", "rpn.RPN.__init__", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "box2box_transform", "=", "Box2BoxTransformRotated", "(", "weights", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_WEIGHTS", ")", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ",", "box2box_transform", "=", "box2box_transform", ")", "\n", "if", "self", ".", "anchor_boundary_thresh", ">=", "0", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"anchor_boundary_thresh is a legacy option not implemented for RRPN.\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rrpn.RRPN.label_and_sample_anchors": [[137, 183], ["torch.no_grad", "detectron2.structures.RotatedBoxes.cat", "rrpn.RRPN.to", "rrpn.RRPN._subsample_labels", "gt_labels.append", "matched_gt_boxes.append", "detectron2.utils.memory.retry_if_cuda_oom", "detectron2.utils.memory.retry_if_cuda_oom", "len", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN._subsample_labels", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.memory.retry_if_cuda_oom", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.memory.retry_if_cuda_oom"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_anchors", "(", "self", ",", "anchors", ":", "List", "[", "RotatedBoxes", "]", ",", "gt_instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[RotatedBoxes]): anchors for each feature map.\n            gt_instances: the ground-truth instances for each image.\n\n        Returns:\n            list[Tensor]:\n                List of #img tensors. i-th element is a vector of labels whose length is\n                the total number of anchors across feature maps. Label values are in {-1, 0, 1},\n                with meanings: -1 = ignore; 0 = negative class; 1 = positive class.\n            list[Tensor]:\n                i-th element is a Nx5 tensor, where N is the total number of anchors across\n                feature maps.  The values are the matched gt boxes for each anchor.\n                Values are undefined for those anchors not labeled as 1.\n        \"\"\"", "\n", "anchors", "=", "RotatedBoxes", ".", "cat", "(", "anchors", ")", "\n", "\n", "gt_boxes", "=", "[", "x", ".", "gt_boxes", "for", "x", "in", "gt_instances", "]", "\n", "del", "gt_instances", "\n", "\n", "gt_labels", "=", "[", "]", "\n", "matched_gt_boxes", "=", "[", "]", "\n", "for", "gt_boxes_i", "in", "gt_boxes", ":", "\n", "            ", "\"\"\"\n            gt_boxes_i: ground-truth boxes for i-th image\n            \"\"\"", "\n", "match_quality_matrix", "=", "retry_if_cuda_oom", "(", "pairwise_iou_rotated", ")", "(", "gt_boxes_i", ",", "anchors", ")", "\n", "matched_idxs", ",", "gt_labels_i", "=", "retry_if_cuda_oom", "(", "self", ".", "anchor_matcher", ")", "(", "match_quality_matrix", ")", "\n", "# Matching is memory-expensive and may result in CPU tensors. But the result is small", "\n", "gt_labels_i", "=", "gt_labels_i", ".", "to", "(", "device", "=", "gt_boxes_i", ".", "device", ")", "\n", "\n", "# A vector of labels (-1, 0, 1) for each anchor", "\n", "gt_labels_i", "=", "self", ".", "_subsample_labels", "(", "gt_labels_i", ")", "\n", "\n", "if", "len", "(", "gt_boxes_i", ")", "==", "0", ":", "\n", "# These values won't be used anyway since the anchor is labeled as background", "\n", "                ", "matched_gt_boxes_i", "=", "torch", ".", "zeros_like", "(", "anchors", ".", "tensor", ")", "\n", "", "else", ":", "\n", "# TODO wasted indexing computation for ignored boxes", "\n", "                ", "matched_gt_boxes_i", "=", "gt_boxes_i", "[", "matched_idxs", "]", ".", "tensor", "\n", "\n", "", "gt_labels", ".", "append", "(", "gt_labels_i", ")", "# N,AHW", "\n", "matched_gt_boxes", ".", "append", "(", "matched_gt_boxes_i", ")", "\n", "", "return", "gt_labels", ",", "matched_gt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rrpn.RRPN.predict_proposals": [[184, 196], ["torch.no_grad", "rrpn.RRPN._decode_proposals", "rrpn.find_top_rrpn_proposals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rpn.RPN._decode_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rrpn.find_top_rrpn_proposals"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "predict_proposals", "(", "self", ",", "anchors", ",", "pred_objectness_logits", ",", "pred_anchor_deltas", ",", "image_sizes", ")", ":", "\n", "        ", "pred_proposals", "=", "self", ".", "_decode_proposals", "(", "anchors", ",", "pred_anchor_deltas", ")", "\n", "return", "find_top_rrpn_proposals", "(", "\n", "pred_proposals", ",", "\n", "pred_objectness_logits", ",", "\n", "image_sizes", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "self", ".", "pre_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "self", ".", "post_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "self", ".", "min_box_size", ",", "\n", "self", ".", "training", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.rrpn.find_top_rrpn_proposals": [[18, 121], ["len", "torch.arange", "zip", "detectron2.layers.cat", "detectron2.layers.cat", "detectron2.layers.cat", "enumerate", "itertools.count", "min", "logits_i.sort", "detectron2.layers.cat.append", "detectron2.layers.cat.append", "detectron2.layers.cat.append", "detectron2.structures.RotatedBoxes", "detectron2.structures.RotatedBoxes.clip", "detectron2.structures.RotatedBoxes.nonempty", "detectron2.layers.batched_nms_rotated", "detectron2.structures.Instances", "results.append", "torch.full", "torch.isfinite().all", "torch.isfinite", "valid_mask.all", "detectron2.layers.batched_nms_rotated.sum().item", "len", "torch.isfinite", "detectron2.layers.batched_nms_rotated.sum"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms_rotated"], ["def", "find_top_rrpn_proposals", "(", "\n", "proposals", ",", "\n", "pred_objectness_logits", ",", "\n", "image_sizes", ",", "\n", "nms_thresh", ",", "\n", "pre_nms_topk", ",", "\n", "post_nms_topk", ",", "\n", "min_box_size", ",", "\n", "training", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    For each feature map, select the `pre_nms_topk` highest scoring proposals,\n    apply NMS, clip proposals, and remove small boxes. Return the `post_nms_topk`\n    highest scoring proposals among all the feature maps if `training` is True,\n    otherwise, returns the highest `post_nms_topk` scoring proposals for each\n    feature map.\n\n    Args:\n        proposals (list[Tensor]): A list of L tensors. Tensor i has shape (N, Hi*Wi*A, 5).\n            All proposal predictions on the feature maps.\n        pred_objectness_logits (list[Tensor]): A list of L tensors. Tensor i has shape (N, Hi*Wi*A).\n        image_sizes (list[tuple]): sizes (h, w) for each image\n        nms_thresh (float): IoU threshold to use for NMS\n        pre_nms_topk (int): number of top k scoring proposals to keep before applying NMS.\n            When RRPN is run on multiple feature maps (as in FPN) this number is per\n            feature map.\n        post_nms_topk (int): number of top k scoring proposals to keep after applying NMS.\n            When RRPN is run on multiple feature maps (as in FPN) this number is total,\n            over all feature maps.\n        min_box_size(float): minimum proposal box side length in pixels (absolute units wrt\n            input images).\n        training (bool): True if proposals are to be used in training, otherwise False.\n            This arg exists only to support a legacy bug; look for the \"NB: Legacy bug ...\"\n            comment.\n\n    Returns:\n        proposals (list[Instances]): list of N Instances. The i-th Instances\n            stores post_nms_topk object proposals for image i.\n    \"\"\"", "\n", "num_images", "=", "len", "(", "image_sizes", ")", "\n", "device", "=", "proposals", "[", "0", "]", ".", "device", "\n", "\n", "# 1. Select top-k anchor for every level and every image", "\n", "topk_scores", "=", "[", "]", "# #lvl Tensor, each of shape N x topk", "\n", "topk_proposals", "=", "[", "]", "\n", "level_ids", "=", "[", "]", "# #lvl Tensor, each of shape (topk,)", "\n", "batch_idx", "=", "torch", ".", "arange", "(", "num_images", ",", "device", "=", "device", ")", "\n", "for", "level_id", ",", "proposals_i", ",", "logits_i", "in", "zip", "(", "\n", "itertools", ".", "count", "(", ")", ",", "proposals", ",", "pred_objectness_logits", "\n", ")", ":", "\n", "        ", "Hi_Wi_A", "=", "logits_i", ".", "shape", "[", "1", "]", "\n", "num_proposals_i", "=", "min", "(", "pre_nms_topk", ",", "Hi_Wi_A", ")", "\n", "\n", "# sort is faster than topk (https://github.com/pytorch/pytorch/issues/22812)", "\n", "# topk_scores_i, topk_idx = logits_i.topk(num_proposals_i, dim=1)", "\n", "logits_i", ",", "idx", "=", "logits_i", ".", "sort", "(", "descending", "=", "True", ",", "dim", "=", "1", ")", "\n", "topk_scores_i", "=", "logits_i", "[", "batch_idx", ",", ":", "num_proposals_i", "]", "\n", "topk_idx", "=", "idx", "[", "batch_idx", ",", ":", "num_proposals_i", "]", "\n", "\n", "# each is N x topk", "\n", "topk_proposals_i", "=", "proposals_i", "[", "batch_idx", "[", ":", ",", "None", "]", ",", "topk_idx", "]", "# N x topk x 5", "\n", "\n", "topk_proposals", ".", "append", "(", "topk_proposals_i", ")", "\n", "topk_scores", ".", "append", "(", "topk_scores_i", ")", "\n", "level_ids", ".", "append", "(", "torch", ".", "full", "(", "(", "num_proposals_i", ",", ")", ",", "level_id", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", ")", "\n", "\n", "# 2. Concat all levels together", "\n", "", "topk_scores", "=", "cat", "(", "topk_scores", ",", "dim", "=", "1", ")", "\n", "topk_proposals", "=", "cat", "(", "topk_proposals", ",", "dim", "=", "1", ")", "\n", "level_ids", "=", "cat", "(", "level_ids", ",", "dim", "=", "0", ")", "\n", "\n", "# 3. For each image, run a per-level NMS, and choose topk results.", "\n", "results", "=", "[", "]", "\n", "for", "n", ",", "image_size", "in", "enumerate", "(", "image_sizes", ")", ":", "\n", "        ", "boxes", "=", "RotatedBoxes", "(", "topk_proposals", "[", "n", "]", ")", "\n", "scores_per_img", "=", "topk_scores", "[", "n", "]", "\n", "valid_mask", "=", "torch", ".", "isfinite", "(", "boxes", ".", "tensor", ")", ".", "all", "(", "dim", "=", "1", ")", "&", "torch", ".", "isfinite", "(", "scores_per_img", ")", "\n", "if", "not", "valid_mask", ".", "all", "(", ")", ":", "\n", "            ", "boxes", "=", "boxes", "[", "valid_mask", "]", "\n", "scores_per_img", "=", "scores_per_img", "[", "valid_mask", "]", "\n", "", "boxes", ".", "clip", "(", "image_size", ")", "\n", "\n", "# filter empty boxes", "\n", "keep", "=", "boxes", ".", "nonempty", "(", "threshold", "=", "min_box_size", ")", "\n", "lvl", "=", "level_ids", "\n", "if", "keep", ".", "sum", "(", ")", ".", "item", "(", ")", "!=", "len", "(", "boxes", ")", ":", "\n", "            ", "boxes", ",", "scores_per_img", ",", "lvl", "=", "(", "boxes", "[", "keep", "]", ",", "scores_per_img", "[", "keep", "]", ",", "level_ids", "[", "keep", "]", ")", "\n", "\n", "", "keep", "=", "batched_nms_rotated", "(", "boxes", ".", "tensor", ",", "scores_per_img", ",", "lvl", ",", "nms_thresh", ")", "\n", "# In Detectron1, there was different behavior during training vs. testing.", "\n", "# (https://github.com/facebookresearch/Detectron/issues/459)", "\n", "# During training, topk is over the proposals from *all* images in the training batch.", "\n", "# During testing, it is over the proposals for each image separately.", "\n", "# As a result, the training behavior becomes batch-dependent,", "\n", "# and the configuration \"POST_NMS_TOPK_TRAIN\" end up relying on the batch size.", "\n", "# This bug is addressed in Detectron2 to make the behavior independent of batch size.", "\n", "keep", "=", "keep", "[", ":", "post_nms_topk", "]", "\n", "\n", "res", "=", "Instances", "(", "image_size", ")", "\n", "res", ".", "proposal_boxes", "=", "boxes", "[", "keep", "]", "\n", "res", ".", "objectness_logits", "=", "scores_per_img", "[", "keep", "]", "\n", "results", ".", "append", "(", "res", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.build.build_proposal_generator": [[15, 25], ["PROPOSAL_GENERATOR_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Build the whole model architecture, defined by ``cfg.MODEL.META_ARCHITECTURE``.\n    Note that it does not load any weights from ``cfg``.\n    \"\"\"", "\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.BaseMaskRCNNHead.__init__": [[160, 170], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "vis_period", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            vis_period (int): visualization period\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "vis_period", "=", "vis_period", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.BaseMaskRCNNHead.from_config": [[171, 174], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "return", "{", "\"vis_period\"", ":", "cfg", ".", "VIS_PERIOD", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.BaseMaskRCNNHead.forward": [[175, 195], ["mask_head.BaseMaskRCNNHead.layers", "mask_head.mask_rcnn_inference", "mask_head.mask_rcnn_loss"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.mask_rcnn_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.mask_rcnn_loss"], ["", "def", "forward", "(", "self", ",", "x", ",", "instances", ":", "List", "[", "Instances", "]", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: input region feature(s) provided by :class:`ROIHeads`.\n            instances (list[Instances]): contains the boxes & labels corresponding\n                to the input features.\n                Exact format is up to its caller to decide.\n                Typically, this is the foreground instances in training, with\n                \"proposal_boxes\" field and other gt annotations.\n                In inference, it contains boxes that are already predicted.\n\n        Returns:\n            A dict of losses in training. The predicted \"instances\" in inference.\n        \"\"\"", "\n", "x", "=", "self", ".", "layers", "(", "x", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "{", "\"loss_mask\"", ":", "mask_rcnn_loss", "(", "x", ",", "instances", ",", "self", ".", "vis_period", ")", "}", "\n", "", "else", ":", "\n", "            ", "mask_rcnn_inference", "(", "x", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.BaseMaskRCNNHead.layers": [[196, 201], ["None"], "methods", ["None"], ["", "", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Neural network layers that makes predictions from input features.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.MaskRCNNConvUpsampleHead.__init__": [[213, 261], ["super().__init__", "enumerate", "detectron2.layers.ConvTranspose2d", "mask_head.MaskRCNNConvUpsampleHead.add_module", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "len", "detectron2.layers.Conv2d", "mask_head.MaskRCNNConvUpsampleHead.add_module", "mask_head.MaskRCNNConvUpsampleHead.conv_norm_relus.append", "torch.nn.ReLU", "fvcore.c2_msra_fill", "torch.nn.init.constant_", "detectron2.layers.get_norm", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ":", "ShapeSpec", ",", "*", ",", "num_classes", ",", "conv_dims", ",", "conv_norm", "=", "\"\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature\n            num_classes (int): the number of classes. 1 if using class agnostic prediction.\n            conv_dims (list[int]): a list of N>0 integers representing the output dimensions\n                of N-1 conv layers and the last upsample layer.\n            conv_norm (str or callable): normalization for the conv layers.\n                See :func:`detectron2.layers.get_norm` for supported types.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "assert", "len", "(", "conv_dims", ")", ">=", "1", ",", "\"conv_dims have to be non-empty!\"", "\n", "\n", "self", ".", "conv_norm_relus", "=", "[", "]", "\n", "\n", "cur_channels", "=", "input_shape", ".", "channels", "\n", "for", "k", ",", "conv_dim", "in", "enumerate", "(", "conv_dims", "[", ":", "-", "1", "]", ")", ":", "\n", "            ", "conv", "=", "Conv2d", "(", "\n", "cur_channels", ",", "\n", "conv_dim", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "conv_norm", ",", "\n", "norm", "=", "get_norm", "(", "conv_norm", ",", "conv_dim", ")", ",", "\n", "activation", "=", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "self", ".", "add_module", "(", "\"mask_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_norm_relus", ".", "append", "(", "conv", ")", "\n", "cur_channels", "=", "conv_dim", "\n", "\n", "", "self", ".", "deconv", "=", "ConvTranspose2d", "(", "\n", "cur_channels", ",", "conv_dims", "[", "-", "1", "]", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", "\n", ")", "\n", "self", ".", "add_module", "(", "\"deconv_relu\"", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "cur_channels", "=", "conv_dims", "[", "-", "1", "]", "\n", "\n", "self", ".", "predictor", "=", "Conv2d", "(", "cur_channels", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_norm_relus", "+", "[", "self", ".", "deconv", "]", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "# use normal distribution initialization for mask prediction layer", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "predictor", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "if", "self", ".", "predictor", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "predictor", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.MaskRCNNConvUpsampleHead.from_config": [[262, 277], ["super().from_config", "super().from_config.update"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.from_config"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "conv_dim", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NUM_CONV", "\n", "ret", ".", "update", "(", "\n", "conv_dims", "=", "[", "conv_dim", "]", "*", "(", "num_conv", "+", "1", ")", ",", "# +1 for ConvTranspose", "\n", "conv_norm", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NORM", ",", "\n", "input_shape", "=", "input_shape", ",", "\n", ")", "\n", "if", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CLS_AGNOSTIC_MASK", ":", "\n", "            ", "ret", "[", "\"num_classes\"", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "ret", "[", "\"num_classes\"", "]", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.MaskRCNNConvUpsampleHead.layers": [[278, 282], ["layer"], "methods", ["None"], ["", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "layer", "in", "self", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.mask_rcnn_loss": [[31, 112], ["pred_mask_logits.size", "pred_mask_logits.size", "detectron2.layers.cat", "gt_masks.to.to", "gt_masks_bool.sum().item", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "torch.nn.functional.binary_cross_entropy_with_logits", "pred_mask_logits.size", "pred_mask_logits.size", "pred_mask_logits.size", "instances_per_image.gt_masks.crop_and_resize().to", "gt_masks.to.append", "len", "torch.arange", "detectron2.layers.cat", "max", "max", "pred_mask_logits.sigmoid", "torch.cat", "enumerate", "len", "instances_per_image.gt_classes.to", "detectron2.layers.cat.append", "pred_mask_logits.sum", "mask_incorrect.sum().item", "max", "gt_masks_bool.sum", "torch.stack", "detectron2.utils.events.get_event_storage.put_image", "instances_per_image.gt_masks.crop_and_resize", "mask_incorrect.numel", "gt_masks_bool.numel", "mask_incorrect.sum"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.crop_and_resize"], ["@", "torch", ".", "jit", ".", "unused", "\n", "def", "mask_rcnn_loss", "(", "pred_mask_logits", ":", "torch", ".", "Tensor", ",", "instances", ":", "List", "[", "Instances", "]", ",", "vis_period", ":", "int", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Compute the mask prediction loss defined in the Mask R-CNN paper.\n\n    Args:\n        pred_mask_logits (Tensor): A tensor of shape (B, C, Hmask, Wmask) or (B, 1, Hmask, Wmask)\n            for class-specific or class-agnostic, where B is the total number of predicted masks\n            in all images, C is the number of foreground classes, and Hmask, Wmask are the height\n            and width of the mask predictions. The values are logits.\n        instances (list[Instances]): A list of N Instances, where N is the number of images\n            in the batch. These instances are in 1:1\n            correspondence with the pred_mask_logits. The ground-truth labels (class, box, mask,\n            ...) associated with each instance are stored in fields.\n        vis_period (int): the period (in steps) to dump visualization.\n\n    Returns:\n        mask_loss (Tensor): A scalar tensor containing the loss.\n    \"\"\"", "\n", "cls_agnostic_mask", "=", "pred_mask_logits", ".", "size", "(", "1", ")", "==", "1", "\n", "total_num_masks", "=", "pred_mask_logits", ".", "size", "(", "0", ")", "\n", "mask_side_len", "=", "pred_mask_logits", ".", "size", "(", "2", ")", "\n", "assert", "pred_mask_logits", ".", "size", "(", "2", ")", "==", "pred_mask_logits", ".", "size", "(", "3", ")", ",", "\"Mask prediction must be square!\"", "\n", "\n", "gt_classes", "=", "[", "]", "\n", "gt_masks", "=", "[", "]", "\n", "for", "instances_per_image", "in", "instances", ":", "\n", "        ", "if", "len", "(", "instances_per_image", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "if", "not", "cls_agnostic_mask", ":", "\n", "            ", "gt_classes_per_image", "=", "instances_per_image", ".", "gt_classes", ".", "to", "(", "dtype", "=", "torch", ".", "int64", ")", "\n", "gt_classes", ".", "append", "(", "gt_classes_per_image", ")", "\n", "\n", "", "gt_masks_per_image", "=", "instances_per_image", ".", "gt_masks", ".", "crop_and_resize", "(", "\n", "instances_per_image", ".", "proposal_boxes", ".", "tensor", ",", "mask_side_len", "\n", ")", ".", "to", "(", "device", "=", "pred_mask_logits", ".", "device", ")", "\n", "# A tensor of shape (N, M, M), N=#instances in the image; M=mask_side_len", "\n", "gt_masks", ".", "append", "(", "gt_masks_per_image", ")", "\n", "\n", "", "if", "len", "(", "gt_masks", ")", "==", "0", ":", "\n", "        ", "return", "pred_mask_logits", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "gt_masks", "=", "cat", "(", "gt_masks", ",", "dim", "=", "0", ")", "\n", "\n", "if", "cls_agnostic_mask", ":", "\n", "        ", "pred_mask_logits", "=", "pred_mask_logits", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "        ", "indices", "=", "torch", ".", "arange", "(", "total_num_masks", ")", "\n", "gt_classes", "=", "cat", "(", "gt_classes", ",", "dim", "=", "0", ")", "\n", "pred_mask_logits", "=", "pred_mask_logits", "[", "indices", ",", "gt_classes", "]", "\n", "\n", "", "if", "gt_masks", ".", "dtype", "==", "torch", ".", "bool", ":", "\n", "        ", "gt_masks_bool", "=", "gt_masks", "\n", "", "else", ":", "\n", "# Here we allow gt_masks to be float as well (depend on the implementation of rasterize())", "\n", "        ", "gt_masks_bool", "=", "gt_masks", ">", "0.5", "\n", "", "gt_masks", "=", "gt_masks", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# Log the training accuracy (using gt classes and 0.5 threshold)", "\n", "mask_incorrect", "=", "(", "pred_mask_logits", ">", "0.0", ")", "!=", "gt_masks_bool", "\n", "mask_accuracy", "=", "1", "-", "(", "mask_incorrect", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "max", "(", "mask_incorrect", ".", "numel", "(", ")", ",", "1.0", ")", ")", "\n", "num_positive", "=", "gt_masks_bool", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "false_positive", "=", "(", "mask_incorrect", "&", "~", "gt_masks_bool", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "max", "(", "\n", "gt_masks_bool", ".", "numel", "(", ")", "-", "num_positive", ",", "1.0", "\n", ")", "\n", "false_negative", "=", "(", "mask_incorrect", "&", "gt_masks_bool", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "max", "(", "num_positive", ",", "1.0", ")", "\n", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"mask_rcnn/accuracy\"", ",", "mask_accuracy", ")", "\n", "storage", ".", "put_scalar", "(", "\"mask_rcnn/false_positive\"", ",", "false_positive", ")", "\n", "storage", ".", "put_scalar", "(", "\"mask_rcnn/false_negative\"", ",", "false_negative", ")", "\n", "if", "vis_period", ">", "0", "and", "storage", ".", "iter", "%", "vis_period", "==", "0", ":", "\n", "        ", "pred_masks", "=", "pred_mask_logits", ".", "sigmoid", "(", ")", "\n", "vis_masks", "=", "torch", ".", "cat", "(", "[", "pred_masks", ",", "gt_masks", "]", ",", "axis", "=", "2", ")", "\n", "name", "=", "\"Left: mask prediction;   Right: mask GT\"", "\n", "for", "idx", ",", "vis_mask", "in", "enumerate", "(", "vis_masks", ")", ":", "\n", "            ", "vis_mask", "=", "torch", ".", "stack", "(", "[", "vis_mask", "]", "*", "3", ",", "axis", "=", "0", ")", "\n", "storage", ".", "put_image", "(", "name", "+", "f\" ({idx})\"", ",", "vis_mask", ")", "\n", "\n", "", "", "mask_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "pred_mask_logits", ",", "gt_masks", ",", "reduction", "=", "\"mean\"", ")", "\n", "return", "mask_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.mask_rcnn_inference": [[114, 153], ["[].sigmoid.split", "zip", "pred_mask_logits.size", "pred_mask_logits.sigmoid", "detectron2.layers.cat", "torch.arange", "[].sigmoid", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "mask_rcnn_inference", "(", "pred_mask_logits", ":", "torch", ".", "Tensor", ",", "pred_instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "    ", "\"\"\"\n    Convert pred_mask_logits to estimated foreground probability masks while also\n    extracting only the masks for the predicted classes in pred_instances. For each\n    predicted box, the mask of the same class is attached to the instance by adding a\n    new \"pred_masks\" field to pred_instances.\n\n    Args:\n        pred_mask_logits (Tensor): A tensor of shape (B, C, Hmask, Wmask) or (B, 1, Hmask, Wmask)\n            for class-specific or class-agnostic, where B is the total number of predicted masks\n            in all images, C is the number of foreground classes, and Hmask, Wmask are the height\n            and width of the mask predictions. The values are logits.\n        pred_instances (list[Instances]): A list of N Instances, where N is the number of images\n            in the batch. Each Instances must have field \"pred_classes\".\n\n    Returns:\n        None. pred_instances will contain an extra \"pred_masks\" field storing a mask of size (Hmask,\n            Wmask) for predicted class. Note that the masks are returned as a soft (non-quantized)\n            masks the resolution predicted by the network; post-processing steps, such as resizing\n            the predicted masks to the original image resolution and/or binarizing them, is left\n            to the caller.\n    \"\"\"", "\n", "cls_agnostic_mask", "=", "pred_mask_logits", ".", "size", "(", "1", ")", "==", "1", "\n", "\n", "if", "cls_agnostic_mask", ":", "\n", "        ", "mask_probs_pred", "=", "pred_mask_logits", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "# Select masks corresponding to the predicted classes", "\n", "        ", "num_masks", "=", "pred_mask_logits", ".", "shape", "[", "0", "]", "\n", "class_pred", "=", "cat", "(", "[", "i", ".", "pred_classes", "for", "i", "in", "pred_instances", "]", ")", "\n", "indices", "=", "torch", ".", "arange", "(", "num_masks", ",", "device", "=", "class_pred", ".", "device", ")", "\n", "mask_probs_pred", "=", "pred_mask_logits", "[", "indices", ",", "class_pred", "]", "[", ":", ",", "None", "]", ".", "sigmoid", "(", ")", "\n", "# mask_probs_pred.shape: (B, 1, Hmask, Wmask)", "\n", "\n", "", "num_boxes_per_image", "=", "[", "len", "(", "i", ")", "for", "i", "in", "pred_instances", "]", "\n", "mask_probs_pred", "=", "mask_probs_pred", ".", "split", "(", "num_boxes_per_image", ",", "dim", "=", "0", ")", "\n", "\n", "for", "prob", ",", "instances", "in", "zip", "(", "mask_probs_pred", ",", "pred_instances", ")", ":", "\n", "        ", "instances", ".", "pred_masks", "=", "prob", "# (1, Hmask, Wmask)", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.build_mask_head": [[284, 290], ["ROI_MASK_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "build_mask_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a mask head defined by `cfg.MODEL.ROI_MASK_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NAME", "\n", "return", "ROI_MASK_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.__init__": [[150, 209], ["len", "len", "type", "type.cat", "proposals[].has", "detectron2.structures.Boxes", "len", "type.cat", "proposals[].has", "detectron2.layers.cat", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["def", "__init__", "(", "\n", "self", ",", "\n", "box2box_transform", ",", "\n", "pred_class_logits", ",", "\n", "pred_proposal_deltas", ",", "\n", "proposals", ",", "\n", "invalid_class_range", ",", "\n", "smooth_l1_beta", "=", "0.0", ",", "\n", "box_reg_loss_type", "=", "\"smooth_l1\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            box2box_transform (Box2BoxTransform/Box2BoxTransformRotated):\n                box2box transform instance for proposal-to-detection transformations.\n            pred_class_logits (Tensor): A tensor of shape (R, K + 1) storing the predicted class\n                logits for all R predicted object instances.\n                Each row corresponds to a predicted object instance.\n            pred_proposal_deltas (Tensor): A tensor of shape (R, K * B) or (R, B) for\n                class-specific or class-agnostic regression. It stores the predicted deltas that\n                transform proposals into final box detections.\n                B is the box dimension (4 or 5).\n                When B is 4, each row is [dx, dy, dw, dh (, ....)].\n                When B is 5, each row is [dx, dy, dw, dh, da (, ....)].\n            proposals (list[Instances]): A list of N Instances, where Instances i stores the\n                proposals for image i, in the field \"proposal_boxes\".\n                When training, each Instances must have ground-truth labels\n                stored in the field \"gt_classes\" and \"gt_boxes\".\n                The total number of all instances must be equal to R.\n            smooth_l1_beta (float): The transition point between L1 and L2 loss in\n                the smooth L1 loss function. When set to 0, the loss becomes L1. When\n                set to +inf, the loss becomes constant 0.\n            box_reg_loss_type (str): Box regression loss type. One of: \"smooth_l1\", \"giou\"\n        \"\"\"", "\n", "self", ".", "box2box_transform", "=", "box2box_transform", "\n", "self", ".", "num_preds_per_image", "=", "[", "len", "(", "p", ")", "for", "p", "in", "proposals", "]", "\n", "self", ".", "pred_class_logits", "=", "pred_class_logits", "\n", "self", ".", "pred_proposal_deltas", "=", "pred_proposal_deltas", "\n", "self", ".", "smooth_l1_beta", "=", "smooth_l1_beta", "\n", "self", ".", "box_reg_loss_type", "=", "box_reg_loss_type", "\n", "\n", "self", ".", "image_shapes", "=", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "\n", "self", ".", "invalid_class_range", "=", "invalid_class_range", "\n", "\n", "if", "len", "(", "proposals", ")", ":", "\n", "            ", "box_type", "=", "type", "(", "proposals", "[", "0", "]", ".", "proposal_boxes", ")", "\n", "# cat(..., dim=0) concatenates over all images in the batch", "\n", "self", ".", "proposals", "=", "box_type", ".", "cat", "(", "[", "p", ".", "proposal_boxes", "for", "p", "in", "proposals", "]", ")", "\n", "assert", "(", "\n", "not", "self", ".", "proposals", ".", "tensor", ".", "requires_grad", "\n", ")", ",", "\"Proposals should not require gradients!\"", "\n", "\n", "# The following fields should exist only when training.", "\n", "if", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_boxes\"", ")", ":", "\n", "                ", "self", ".", "gt_boxes", "=", "box_type", ".", "cat", "(", "[", "p", ".", "gt_boxes", "for", "p", "in", "proposals", "]", ")", "\n", "assert", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_classes\"", ")", "\n", "self", ".", "gt_classes", "=", "cat", "(", "[", "p", ".", "gt_classes", "for", "p", "in", "proposals", "]", ",", "dim", "=", "0", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "proposals", "=", "Boxes", "(", "torch", ".", "zeros", "(", "0", ",", "4", ",", "device", "=", "self", ".", "pred_proposal_deltas", ".", "device", ")", ")", "\n", "", "self", ".", "_no_instances", "=", "len", "(", "proposals", ")", "==", "0", "# no instances found", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs._log_accuracy": [[210, 233], ["fast_rcnn.FastRCNNOutputs.gt_classes.numel", "fast_rcnn.FastRCNNOutputs.pred_class_logits.argmax", "fg_inds.nonzero().numel", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "fg_inds.nonzero", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar"], ["", "def", "_log_accuracy", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Log the accuracy metrics to EventStorage.\n        \"\"\"", "\n", "num_instances", "=", "self", ".", "gt_classes", ".", "numel", "(", ")", "\n", "pred_classes", "=", "self", ".", "pred_class_logits", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "bg_class_ind", "=", "self", ".", "pred_class_logits", ".", "shape", "[", "1", "]", "-", "1", "\n", "\n", "fg_inds", "=", "(", "self", ".", "gt_classes", ">=", "0", ")", "&", "(", "self", ".", "gt_classes", "<", "bg_class_ind", ")", "\n", "num_fg", "=", "fg_inds", ".", "nonzero", "(", ")", ".", "numel", "(", ")", "\n", "fg_gt_classes", "=", "self", ".", "gt_classes", "[", "fg_inds", "]", "\n", "fg_pred_classes", "=", "pred_classes", "[", "fg_inds", "]", "\n", "\n", "num_false_negative", "=", "(", "fg_pred_classes", "==", "bg_class_ind", ")", ".", "nonzero", "(", ")", ".", "numel", "(", ")", "\n", "num_accurate", "=", "(", "pred_classes", "==", "self", ".", "gt_classes", ")", ".", "nonzero", "(", ")", ".", "numel", "(", ")", "\n", "fg_num_accurate", "=", "(", "fg_pred_classes", "==", "fg_gt_classes", ")", ".", "nonzero", "(", ")", ".", "numel", "(", ")", "\n", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "if", "num_instances", ">", "0", ":", "\n", "            ", "storage", ".", "put_scalar", "(", "\"fast_rcnn/cls_accuracy\"", ",", "num_accurate", "/", "num_instances", ")", "\n", "if", "num_fg", ">", "0", ":", "\n", "                ", "storage", ".", "put_scalar", "(", "\"fast_rcnn/fg_cls_accuracy\"", ",", "fg_num_accurate", "/", "num_fg", ")", "\n", "storage", ".", "put_scalar", "(", "\"fast_rcnn/false_negative\"", ",", "num_false_negative", "/", "num_fg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.softmax_cross_entropy_loss": [[234, 248], ["fast_rcnn.FastRCNNOutputs._log_accuracy", "torch.nn.functional.cross_entropy", "fast_rcnn.FastRCNNOutputs.pred_class_logits.sum"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs._log_accuracy"], ["", "", "", "def", "softmax_cross_entropy_loss", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute the softmax cross entropy loss for box classification.\n\n        Returns:\n            scalar Tensor\n        \"\"\"", "\n", "if", "self", ".", "_no_instances", ":", "\n", "            ", "return", "0.0", "*", "self", ".", "pred_class_logits", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_log_accuracy", "(", ")", "\n", "self", ".", "pred_class_logits", "[", ":", ",", "self", ".", "invalid_class_range", "]", "=", "-", "10e10", "\n", "# self.log_logits(self.pred_class_logits, self.gt_classes)", "\n", "return", "F", ".", "cross_entropy", "(", "self", ".", "pred_class_logits", ",", "self", ".", "gt_classes", ",", "reduction", "=", "\"mean\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.log_logits": [[249, 253], ["torch.save", "shortuuid.uuid"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save"], ["", "", "def", "log_logits", "(", "self", ",", "logits", ",", "cls", ")", ":", "\n", "        ", "data", "=", "(", "logits", ",", "cls", ")", "\n", "location", "=", "'/home/fk1/workspace/OWOD/output/logits/'", "+", "shortuuid", ".", "uuid", "(", ")", "+", "'.pkl'", "\n", "torch", ".", "save", "(", "data", ",", "location", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.box_reg_loss": [[254, 320], ["fast_rcnn.FastRCNNOutputs.gt_boxes.tensor.size", "fast_rcnn.FastRCNNOutputs.pred_proposal_deltas.size", "detectron2.layers.nonzero_tuple", "torch.arange", "fast_rcnn.FastRCNNOutputs.box2box_transform.get_deltas", "fvcore.nn.smooth_l1_loss", "fast_rcnn.FastRCNNOutputs.gt_classes.numel", "fast_rcnn.FastRCNNOutputs.pred_proposal_deltas.sum", "torch.arange", "fvcore.nn.giou_loss", "ValueError", "fast_rcnn.FastRCNNOutputs._predict_boxes"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.nonzero_tuple", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs._predict_boxes"], ["", "def", "box_reg_loss", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute the smooth L1 loss for box regression.\n\n        Returns:\n            scalar Tensor\n        \"\"\"", "\n", "if", "self", ".", "_no_instances", ":", "\n", "            ", "return", "0.0", "*", "self", ".", "pred_proposal_deltas", ".", "sum", "(", ")", "\n", "\n", "", "box_dim", "=", "self", ".", "gt_boxes", ".", "tensor", ".", "size", "(", "1", ")", "# 4 or 5", "\n", "cls_agnostic_bbox_reg", "=", "self", ".", "pred_proposal_deltas", ".", "size", "(", "1", ")", "==", "box_dim", "\n", "device", "=", "self", ".", "pred_proposal_deltas", ".", "device", "\n", "\n", "bg_class_ind", "=", "self", ".", "pred_class_logits", ".", "shape", "[", "1", "]", "-", "1", "\n", "\n", "# Box delta loss is only computed between the prediction for the gt class k", "\n", "# (if 0 <= k < bg_class_ind) and the target; there is no loss defined on predictions", "\n", "# for non-gt classes and background.", "\n", "# Empty fg_inds produces a valid loss of zero as long as the size_average", "\n", "# arg to smooth_l1_loss is False (otherwise it uses torch.mean internally", "\n", "# and would produce a nan loss).", "\n", "fg_inds", "=", "nonzero_tuple", "(", "(", "self", ".", "gt_classes", ">=", "0", ")", "&", "(", "self", ".", "gt_classes", "<", "bg_class_ind", ")", ")", "[", "0", "]", "\n", "if", "cls_agnostic_bbox_reg", ":", "\n", "# pred_proposal_deltas only corresponds to foreground class for agnostic", "\n", "            ", "gt_class_cols", "=", "torch", ".", "arange", "(", "box_dim", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "            ", "fg_gt_classes", "=", "self", ".", "gt_classes", "[", "fg_inds", "]", "\n", "# pred_proposal_deltas for class k are located in columns [b * k : b * k + b],", "\n", "# where b is the dimension of box representation (4 or 5)", "\n", "# Note that compared to Detectron1,", "\n", "# we do not perform bounding box regression for background classes.", "\n", "gt_class_cols", "=", "box_dim", "*", "fg_gt_classes", "[", ":", ",", "None", "]", "+", "torch", ".", "arange", "(", "box_dim", ",", "device", "=", "device", ")", "\n", "\n", "", "if", "self", ".", "box_reg_loss_type", "==", "\"smooth_l1\"", ":", "\n", "            ", "gt_proposal_deltas", "=", "self", ".", "box2box_transform", ".", "get_deltas", "(", "\n", "self", ".", "proposals", ".", "tensor", ",", "self", ".", "gt_boxes", ".", "tensor", "\n", ")", "\n", "loss_box_reg", "=", "smooth_l1_loss", "(", "\n", "self", ".", "pred_proposal_deltas", "[", "fg_inds", "[", ":", ",", "None", "]", ",", "gt_class_cols", "]", ",", "\n", "gt_proposal_deltas", "[", "fg_inds", "]", ",", "\n", "self", ".", "smooth_l1_beta", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "", "elif", "self", ".", "box_reg_loss_type", "==", "\"giou\"", ":", "\n", "            ", "loss_box_reg", "=", "giou_loss", "(", "\n", "self", ".", "_predict_boxes", "(", ")", "[", "fg_inds", "[", ":", ",", "None", "]", ",", "gt_class_cols", "]", ",", "\n", "self", ".", "gt_boxes", ".", "tensor", "[", "fg_inds", "]", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Invalid bbox reg loss type '{self.box_reg_loss_type}'\"", ")", "\n", "\n", "# The loss is normalized using the total number of regions (R), not the number", "\n", "# of foreground regions even though the box regression loss is only defined on", "\n", "# foreground regions. Why? Because doing so gives equal training influence to", "\n", "# each foreground example. To see how, consider two different minibatches:", "\n", "#  (1) Contains a single foreground region", "\n", "#  (2) Contains 100 foreground regions", "\n", "# If we normalize by the number of foreground regions, the single example in", "\n", "# minibatch (1) will be given 100 times as much influence as each foreground", "\n", "# example in minibatch (2). Normalizing by the total number of regions, R,", "\n", "# means that the single example in minibatch (1) and each of the 100 examples", "\n", "# in minibatch (2) are given equal influence.", "\n", "", "loss_box_reg", "=", "loss_box_reg", "/", "self", ".", "gt_classes", ".", "numel", "(", ")", "\n", "return", "loss_box_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs._predict_boxes": [[321, 329], ["fast_rcnn.FastRCNNOutputs.box2box_transform.apply_deltas"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas"], ["", "def", "_predict_boxes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Tensor: A Tensors of predicted class-specific or class-agnostic boxes\n                for all images in a batch. Element i has shape (Ri, K * B) or (Ri, B), where Ri is\n                the number of predicted objects for image i and B is the box dimension (4 or 5)\n        \"\"\"", "\n", "return", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "self", ".", "pred_proposal_deltas", ",", "self", ".", "proposals", ".", "tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.losses": [[335, 344], ["fast_rcnn.FastRCNNOutputs.softmax_cross_entropy_loss", "fast_rcnn.FastRCNNOutputs.box_reg_loss"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.softmax_cross_entropy_loss", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.box_reg_loss"], ["def", "losses", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute the default losses for box head in Fast(er) R-CNN,\n        with softmax cross entropy loss and smooth L1 loss.\n\n        Returns:\n            A dict of losses (scalar tensors) containing keys \"loss_cls\" and \"loss_box_reg\".\n        \"\"\"", "\n", "return", "{", "\"loss_cls\"", ":", "self", ".", "softmax_cross_entropy_loss", "(", ")", ",", "\"loss_box_reg\"", ":", "self", ".", "box_reg_loss", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.predict_boxes": [[345, 350], ["fast_rcnn.FastRCNNOutputs._predict_boxes().split", "fast_rcnn.FastRCNNOutputs._predict_boxes"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs._predict_boxes"], ["", "def", "predict_boxes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Deprecated\n        \"\"\"", "\n", "return", "self", ".", "_predict_boxes", "(", ")", ".", "split", "(", "self", ".", "num_preds_per_image", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.predict_probs": [[351, 357], ["torch.nn.functional.softmax", "torch.nn.functional.softmax.split"], "methods", ["None"], ["", "def", "predict_probs", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Deprecated\n        \"\"\"", "\n", "probs", "=", "F", ".", "softmax", "(", "self", ".", "pred_class_logits", ",", "dim", "=", "-", "1", ")", "\n", "return", "probs", ".", "split", "(", "self", ".", "num_preds_per_image", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputs.inference": [[358, 367], ["fast_rcnn.FastRCNNOutputs.predict_boxes", "fast_rcnn.FastRCNNOutputs.predict_probs", "fast_rcnn.fast_rcnn_inference"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.fast_rcnn_inference"], ["", "def", "inference", "(", "self", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", ")", ":", "\n", "        ", "\"\"\"\n        Deprecated\n        \"\"\"", "\n", "boxes", "=", "self", ".", "predict_boxes", "(", ")", "\n", "scores", "=", "self", ".", "predict_probs", "(", ")", "\n", "image_shapes", "=", "self", ".", "image_shapes", "\n", "return", "fast_rcnn_inference", "(", "\n", "boxes", ",", "scores", ",", "image_shapes", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.AE.__init__": [[370, 374], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "z_dim", ")", ":", "\n", "        ", "super", "(", "AE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "e1", "=", "nn", ".", "Linear", "(", "input_size", ",", "z_dim", ")", "\n", "self", ".", "d1", "=", "nn", ".", "Linear", "(", "z_dim", ",", "input_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.AE.encoder": [[375, 379], ["fast_rcnn.AE.e1", "torch.relu"], "methods", ["None"], ["", "def", "encoder", "(", "self", ",", "x", ")", ":", "\n", "        ", "z", "=", "self", ".", "e1", "(", "x", ")", "\n", "z", "=", "torch", ".", "relu", "(", "z", ")", "\n", "return", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.AE.decoder": [[380, 384], ["fast_rcnn.AE.d1", "torch.relu"], "methods", ["None"], ["", "def", "decoder", "(", "self", ",", "z", ")", ":", "\n", "        ", "x", "=", "self", ".", "d1", "(", "z", ")", "\n", "x", "=", "torch", ".", "relu", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.AE.forward": [[385, 388], ["fast_rcnn.AE.encoder", "fast_rcnn.AE.decoder"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.AE.encoder", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.AE.decoder"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "z", "=", "self", ".", "encoder", "(", "x", ")", "\n", "return", "self", ".", "decoder", "(", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.__init__": [[405, 505], ["torch.nn.Module.__init__", "isinstance", "detectron2.layers.Linear", "len", "detectron2.layers.Linear", "torch.nn.init.normal_", "torch.nn.init.normal_", "isinstance", "torch.nn.HingeEmbeddingLoss", "list", "logging.getLogger().info", "os.path.join", "os.path.isfile", "detectron2.layers.ShapeSpec", "torch.nn.init.constant_", "range", "logging.getLogger().info", "torch.load", "logging.getLogger().info", "detectron2.utils.store.Store", "logging.getLogger", "str", "range", "logging.getLogger", "logging.getLogger"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "input_shape", ":", "ShapeSpec", ",", "\n", "*", ",", "\n", "box2box_transform", ",", "\n", "clustering_items_per_class", ",", "\n", "clustering_start_iter", ",", "\n", "clustering_update_mu_iter", ",", "\n", "clustering_momentum", ",", "\n", "clustering_z_dimension", ",", "\n", "enable_clustering", ",", "\n", "prev_intro_cls", ",", "\n", "curr_intro_cls", ",", "\n", "max_iterations", ",", "\n", "output_dir", ",", "\n", "feat_store_path", ",", "\n", "margin", ",", "\n", "num_classes", ":", "int", ",", "\n", "test_score_thresh", ":", "float", "=", "0.0", ",", "\n", "test_nms_thresh", ":", "float", "=", "0.5", ",", "\n", "test_topk_per_image", ":", "int", "=", "100", ",", "\n", "cls_agnostic_bbox_reg", ":", "bool", "=", "False", ",", "\n", "smooth_l1_beta", ":", "float", "=", "0.0", ",", "\n", "box_reg_loss_type", ":", "str", "=", "\"smooth_l1\"", ",", "\n", "loss_weight", ":", "Union", "[", "float", ",", "Dict", "[", "str", ",", "float", "]", "]", "=", "1.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature to this module\n            box2box_transform (Box2BoxTransform or Box2BoxTransformRotated):\n            num_classes (int): number of foreground classes\n            test_score_thresh (float): threshold to filter predictions results.\n            test_nms_thresh (float): NMS threshold for prediction results.\n            test_topk_per_image (int): number of top predictions to produce per image.\n            cls_agnostic_bbox_reg (bool): whether to use class agnostic for bbox regression\n            smooth_l1_beta (float): transition point from L1 to L2 loss. Only used if\n                `box_reg_loss_type` is \"smooth_l1\"\n            box_reg_loss_type (str): Box regression loss type. One of: \"smooth_l1\", \"giou\"\n            loss_weight (float|dict): weights to use for losses. Can be single float for weighting\n                all losses, or a dict of individual weightings. Valid dict keys are:\n                    * \"loss_cls\": applied to classification loss\n                    * \"loss_box_reg\": applied to box regression loss\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "input_shape", ",", "int", ")", ":", "# some backward compatibility", "\n", "            ", "input_shape", "=", "ShapeSpec", "(", "channels", "=", "input_shape", ")", "\n", "", "input_size", "=", "input_shape", ".", "channels", "*", "(", "input_shape", ".", "width", "or", "1", ")", "*", "(", "input_shape", ".", "height", "or", "1", ")", "\n", "# prediction layer for num_classes foreground classes and one background class (hence + 1)", "\n", "self", ".", "cls_score", "=", "Linear", "(", "input_size", ",", "num_classes", "+", "1", ")", "\n", "num_bbox_reg_classes", "=", "1", "if", "cls_agnostic_bbox_reg", "else", "num_classes", "\n", "box_dim", "=", "len", "(", "box2box_transform", ".", "weights", ")", "\n", "self", ".", "bbox_pred", "=", "Linear", "(", "input_size", ",", "num_bbox_reg_classes", "*", "box_dim", ")", "\n", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "cls_score", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "bbox_pred", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "for", "l", "in", "[", "self", ".", "cls_score", ",", "self", ".", "bbox_pred", "]", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "self", ".", "box2box_transform", "=", "box2box_transform", "\n", "self", ".", "smooth_l1_beta", "=", "smooth_l1_beta", "\n", "self", ".", "test_score_thresh", "=", "test_score_thresh", "\n", "self", ".", "test_nms_thresh", "=", "test_nms_thresh", "\n", "self", ".", "test_topk_per_image", "=", "test_topk_per_image", "\n", "self", ".", "box_reg_loss_type", "=", "box_reg_loss_type", "\n", "if", "isinstance", "(", "loss_weight", ",", "float", ")", ":", "\n", "            ", "loss_weight", "=", "{", "\"loss_cls\"", ":", "loss_weight", ",", "\"loss_box_reg\"", ":", "loss_weight", "}", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "clustering_start_iter", "=", "clustering_start_iter", "\n", "self", ".", "clustering_update_mu_iter", "=", "clustering_update_mu_iter", "\n", "self", ".", "clustering_momentum", "=", "clustering_momentum", "\n", "\n", "self", ".", "hingeloss", "=", "nn", ".", "HingeEmbeddingLoss", "(", "2", ")", "\n", "self", ".", "enable_clustering", "=", "enable_clustering", "\n", "\n", "self", ".", "prev_intro_cls", "=", "prev_intro_cls", "\n", "self", ".", "curr_intro_cls", "=", "curr_intro_cls", "\n", "self", ".", "seen_classes", "=", "self", ".", "prev_intro_cls", "+", "self", ".", "curr_intro_cls", "\n", "self", ".", "invalid_class_range", "=", "list", "(", "range", "(", "self", ".", "seen_classes", ",", "self", ".", "num_classes", "-", "1", ")", ")", "\n", "logging", ".", "getLogger", "(", "__name__", ")", ".", "info", "(", "\"Invalid class range: \"", "+", "str", "(", "self", ".", "invalid_class_range", ")", ")", "\n", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "self", ".", "feature_store_is_stored", "=", "False", "\n", "self", ".", "output_dir", "=", "output_dir", "\n", "self", ".", "feat_store_path", "=", "feat_store_path", "\n", "self", ".", "feature_store_save_loc", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "self", ".", "feat_store_path", ",", "'feat.pt'", ")", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "self", ".", "feature_store_save_loc", ")", ":", "\n", "            ", "logging", ".", "getLogger", "(", "__name__", ")", ".", "info", "(", "'Trying to load feature store from '", "+", "self", ".", "feature_store_save_loc", ")", "\n", "self", ".", "feature_store", "=", "torch", ".", "load", "(", "self", ".", "feature_store_save_loc", ")", "\n", "", "else", ":", "\n", "            ", "logging", ".", "getLogger", "(", "__name__", ")", ".", "info", "(", "'Feature store not found in '", "+", "\n", "self", ".", "feature_store_save_loc", "+", "'. Creating new feature store.'", ")", "\n", "self", ".", "feature_store", "=", "Store", "(", "num_classes", "+", "1", ",", "clustering_items_per_class", ")", "\n", "", "self", ".", "means", "=", "[", "None", "for", "_", "in", "range", "(", "num_classes", "+", "1", ")", "]", "\n", "self", ".", "margin", "=", "margin", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.from_config": [[509, 535], ["detectron2.modeling.box_regression.Box2BoxTransform"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "return", "{", "\n", "\"input_shape\"", ":", "input_shape", ",", "\n", "\"box2box_transform\"", ":", "Box2BoxTransform", "(", "weights", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", ")", ",", "\n", "# fmt: off", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", ",", "\n", "\"cls_agnostic_bbox_reg\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CLS_AGNOSTIC_BBOX_REG", ",", "\n", "\"smooth_l1_beta\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "SMOOTH_L1_BETA", ",", "\n", "\"test_score_thresh\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", ",", "\n", "\"test_nms_thresh\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NMS_THRESH_TEST", ",", "\n", "\"test_topk_per_image\"", ":", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", ",", "\n", "\"box_reg_loss_type\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_LOSS_TYPE", ",", "\n", "\"loss_weight\"", ":", "{", "\"loss_box_reg\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_LOSS_WEIGHT", ",", "\"loss_clustering\"", ":", "0.1", "}", ",", "\n", "\"clustering_items_per_class\"", ":", "cfg", ".", "OWOD", ".", "CLUSTERING", ".", "ITEMS_PER_CLASS", ",", "\n", "\"clustering_start_iter\"", ":", "cfg", ".", "OWOD", ".", "CLUSTERING", ".", "START_ITER", ",", "\n", "\"clustering_update_mu_iter\"", ":", "cfg", ".", "OWOD", ".", "CLUSTERING", ".", "UPDATE_MU_ITER", ",", "\n", "\"clustering_momentum\"", ":", "cfg", ".", "OWOD", ".", "CLUSTERING", ".", "MOMENTUM", ",", "\n", "\"clustering_z_dimension\"", ":", "cfg", ".", "OWOD", ".", "CLUSTERING", ".", "Z_DIMENSION", ",", "\n", "\"enable_clustering\"", ":", "cfg", ".", "OWOD", ".", "ENABLE_CLUSTERING", ",", "\n", "\"prev_intro_cls\"", ":", "cfg", ".", "OWOD", ".", "PREV_INTRODUCED_CLS", ",", "\n", "\"curr_intro_cls\"", ":", "cfg", ".", "OWOD", ".", "CUR_INTRODUCED_CLS", ",", "\n", "\"max_iterations\"", ":", "cfg", ".", "SOLVER", ".", "MAX_ITER", ",", "\n", "\"output_dir\"", ":", "cfg", ".", "OUTPUT_DIR", ",", "\n", "\"feat_store_path\"", ":", "cfg", ".", "OWOD", ".", "FEATURE_STORE_SAVE_PATH", ",", "\n", "\"margin\"", ":", "cfg", ".", "OWOD", ".", "CLUSTERING", ".", "MARGIN", ",", "\n", "# fmt: on", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.forward": [[538, 556], ["fast_rcnn.FastRCNNOutputLayers.cls_score", "fast_rcnn.FastRCNNOutputLayers.bbox_pred", "torch.flatten.dim", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: per-region features of shape (N, ...) for N bounding boxes to predict.\n\n        Returns:\n            (Tensor, Tensor):\n            First tensor: shape (N,K+1), scores for each of the N box. Each row contains the\n            scores for K object categories and 1 background class.\n\n            Second tensor: bounding box regression deltas for each box. Shape is shape (N,Kx4),\n            or (N,4) for class-agnostic regression.\n        \"\"\"", "\n", "if", "x", ".", "dim", "(", ")", ">", "2", ":", "\n", "            ", "x", "=", "torch", ".", "flatten", "(", "x", ",", "start_dim", "=", "1", ")", "\n", "", "scores", "=", "self", ".", "cls_score", "(", "x", ")", "\n", "proposal_deltas", "=", "self", ".", "bbox_pred", "(", "x", ")", "\n", "return", "scores", ",", "proposal_deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.update_feature_store": [[557, 568], ["torch.cat", "fast_rcnn.FastRCNNOutputLayers.feature_store.add", "detectron2.utils.events.get_event_storage", "detectron2.is_main_process", "logging.getLogger().info", "torch.save", "logging.getLogger", "str"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.add", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save"], ["", "def", "update_feature_store", "(", "self", ",", "features", ",", "proposals", ")", ":", "\n", "# cat(..., dim=0) concatenates over all images in the batch", "\n", "        ", "gt_classes", "=", "torch", ".", "cat", "(", "[", "p", ".", "gt_classes", "for", "p", "in", "proposals", "]", ")", "\n", "self", ".", "feature_store", ".", "add", "(", "features", ",", "gt_classes", ")", "\n", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "\n", "if", "storage", ".", "iter", "==", "self", ".", "max_iterations", "-", "1", "and", "self", ".", "feature_store_is_stored", "is", "False", "and", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "logging", ".", "getLogger", "(", "__name__", ")", ".", "info", "(", "'Saving image store at iteration '", "+", "str", "(", "storage", ".", "iter", ")", "+", "' to '", "+", "self", ".", "feature_store_save_loc", ")", "\n", "torch", ".", "save", "(", "self", ".", "feature_store", ",", "self", ".", "feature_store_save_loc", ")", "\n", "self", ".", "feature_store_is_stored", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.clstr_loss_l2_cdist": [[573, 616], ["torch.cat", "enumerate", "torch.cdist", "enumerate", "fast_rcnn.FastRCNNOutputLayers.hingeloss", "torch.stack().cuda", "enumerate", "torch.tensor().reshape().cuda", "torch.zeros", "torch.stack", "labels.append", "torch.tensor().reshape", "labels.append", "labels.append", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "", "def", "clstr_loss_l2_cdist", "(", "self", ",", "input_features", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Get the foreground input_features, generate distributions for the class,\n        get probability of each feature from each distribution;\n        Compute loss: if belonging to a class -> likelihood should be higher\n                      else -> lower\n        :param input_features:\n        :param proposals:\n        :return:\n        \"\"\"", "\n", "gt_classes", "=", "torch", ".", "cat", "(", "[", "p", ".", "gt_classes", "for", "p", "in", "proposals", "]", ")", "\n", "mask", "=", "gt_classes", "!=", "self", ".", "num_classes", "\n", "fg_features", "=", "input_features", "[", "mask", "]", "\n", "classes", "=", "gt_classes", "[", "mask", "]", "\n", "# fg_features = F.normalize(fg_features, dim=0)", "\n", "# fg_features = self.ae_model.encoder(fg_features)", "\n", "\n", "all_means", "=", "self", ".", "means", "\n", "for", "item", "in", "all_means", ":", "\n", "            ", "if", "item", "!=", "None", ":", "\n", "                ", "length", "=", "item", ".", "shape", "\n", "break", "\n", "\n", "", "", "for", "i", ",", "item", "in", "enumerate", "(", "all_means", ")", ":", "\n", "            ", "if", "item", "==", "None", ":", "\n", "                ", "all_means", "[", "i", "]", "=", "torch", ".", "zeros", "(", "(", "length", ")", ")", "\n", "\n", "", "", "distances", "=", "torch", ".", "cdist", "(", "fg_features", ",", "torch", ".", "stack", "(", "all_means", ")", ".", "cuda", "(", ")", ",", "p", "=", "self", ".", "margin", ")", "\n", "labels", "=", "[", "]", "\n", "\n", "for", "index", ",", "feature", "in", "enumerate", "(", "fg_features", ")", ":", "\n", "            ", "for", "cls_index", ",", "mu", "in", "enumerate", "(", "self", ".", "means", ")", ":", "\n", "                ", "if", "mu", "is", "not", "None", "and", "feature", "is", "not", "None", ":", "\n", "                    ", "if", "classes", "[", "index", "]", "==", "cls_index", ":", "\n", "                        ", "labels", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "                        ", "labels", ".", "append", "(", "-", "1", ")", "\n", "", "", "else", ":", "\n", "                    ", "labels", ".", "append", "(", "0", ")", "\n", "\n", "", "", "", "loss", "=", "self", ".", "hingeloss", "(", "distances", ",", "torch", ".", "tensor", "(", "labels", ")", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "num_classes", "+", "1", ")", ")", ".", "cuda", "(", ")", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.get_clustering_loss": [[617, 653], ["detectron2.utils.events.get_event_storage", "fast_rcnn.FastRCNNOutputLayers.feature_store.retrieve", "enumerate", "fast_rcnn.FastRCNNOutputLayers.clstr_loss_l2_cdist", "fast_rcnn.FastRCNNOutputLayers.clstr_loss_l2_cdist", "len", "torch.tensor().mean", "fast_rcnn.FastRCNNOutputLayers.feature_store.retrieve", "enumerate", "enumerate", "torch.tensor", "range", "len", "torch.tensor().mean", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.retrieve", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.clstr_loss_l2_cdist", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.clstr_loss_l2_cdist", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.retrieve"], ["", "def", "get_clustering_loss", "(", "self", ",", "input_features", ",", "proposals", ")", ":", "\n", "        ", "if", "not", "self", ".", "enable_clustering", ":", "\n", "            ", "return", "0", "\n", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "c_loss", "=", "0", "\n", "if", "storage", ".", "iter", "==", "self", ".", "clustering_start_iter", ":", "\n", "            ", "items", "=", "self", ".", "feature_store", ".", "retrieve", "(", "-", "1", ")", "\n", "for", "index", ",", "item", "in", "enumerate", "(", "items", ")", ":", "\n", "                ", "if", "len", "(", "item", ")", "==", "0", ":", "\n", "                    ", "self", ".", "means", "[", "index", "]", "=", "None", "\n", "", "else", ":", "\n", "                    ", "mu", "=", "torch", ".", "tensor", "(", "item", ")", ".", "mean", "(", "dim", "=", "0", ")", "\n", "self", ".", "means", "[", "index", "]", "=", "mu", "\n", "", "", "c_loss", "=", "self", ".", "clstr_loss_l2_cdist", "(", "input_features", ",", "proposals", ")", "\n", "# Freeze the parameters when clustering starts", "\n", "# for param in self.ae_model.parameters():", "\n", "#     param.requires_grad = False", "\n", "", "elif", "storage", ".", "iter", ">", "self", ".", "clustering_start_iter", ":", "\n", "            ", "if", "storage", ".", "iter", "%", "self", ".", "clustering_update_mu_iter", "==", "0", ":", "\n", "# Compute new MUs", "\n", "                ", "items", "=", "self", ".", "feature_store", ".", "retrieve", "(", "-", "1", ")", "\n", "new_means", "=", "[", "None", "for", "_", "in", "range", "(", "self", ".", "num_classes", "+", "1", ")", "]", "\n", "for", "index", ",", "item", "in", "enumerate", "(", "items", ")", ":", "\n", "                    ", "if", "len", "(", "item", ")", "==", "0", ":", "\n", "                        ", "new_means", "[", "index", "]", "=", "None", "\n", "", "else", ":", "\n", "                        ", "new_means", "[", "index", "]", "=", "torch", ".", "tensor", "(", "item", ")", ".", "mean", "(", "dim", "=", "0", ")", "\n", "# Update the MUs", "\n", "", "", "for", "i", ",", "mean", "in", "enumerate", "(", "self", ".", "means", ")", ":", "\n", "                    ", "if", "(", "mean", ")", "is", "not", "None", "and", "new_means", "[", "i", "]", "is", "not", "None", ":", "\n", "                        ", "self", ".", "means", "[", "i", "]", "=", "self", ".", "clustering_momentum", "*", "mean", "+", "(", "1", "-", "self", ".", "clustering_momentum", ")", "*", "new_means", "[", "i", "]", "\n", "\n", "", "", "", "c_loss", "=", "self", ".", "clstr_loss_l2_cdist", "(", "input_features", ",", "proposals", ")", "\n", "", "return", "c_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.losses": [[663, 688], ["fast_rcnn.FastRCNNOutputs.losses", "fast_rcnn.FastRCNNOutputLayers.get_clustering_loss", "fast_rcnn.FastRCNNOutputs", "fast_rcnn.FastRCNNOutputLayers.loss_weight.get", "fast_rcnn.FastRCNNOutputs.losses"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.get_clustering_loss", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "losses", "(", "self", ",", "predictions", ",", "proposals", ",", "input_features", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were used\n                to compute predictions. The fields ``proposal_boxes``, ``gt_boxes``,\n                ``gt_classes`` are expected.\n\n        Returns:\n            Dict[str, Tensor]: dict of losses\n        \"\"\"", "\n", "scores", ",", "proposal_deltas", "=", "predictions", "\n", "losses", "=", "FastRCNNOutputs", "(", "\n", "self", ".", "box2box_transform", ",", "\n", "scores", ",", "\n", "proposal_deltas", ",", "\n", "proposals", ",", "\n", "self", ".", "invalid_class_range", ",", "\n", "self", ".", "smooth_l1_beta", ",", "\n", "self", ".", "box_reg_loss_type", ",", "\n", ")", ".", "losses", "(", ")", "\n", "if", "input_features", "is", "not", "None", ":", "\n", "# losses[\"loss_cluster_encoder\"] = self.get_ae_loss(input_features)", "\n", "            ", "losses", "[", "\"loss_clustering\"", "]", "=", "self", ".", "get_clustering_loss", "(", "input_features", ",", "proposals", ")", "\n", "", "return", "{", "k", ":", "v", "*", "self", ".", "loss_weight", ".", "get", "(", "k", ",", "1.0", ")", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.inference": [[689, 711], ["fast_rcnn.FastRCNNOutputLayers.predict_boxes", "fast_rcnn.FastRCNNOutputLayers.predict_probs", "fast_rcnn.fast_rcnn_inference"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.fast_rcnn_inference"], ["", "def", "inference", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Instances]: same as `fast_rcnn_inference`.\n            list[Tensor]: same as `fast_rcnn_inference`.\n        \"\"\"", "\n", "boxes", "=", "self", ".", "predict_boxes", "(", "predictions", ",", "proposals", ")", "\n", "scores", "=", "self", ".", "predict_probs", "(", "predictions", ",", "proposals", ")", "\n", "image_shapes", "=", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "\n", "return", "fast_rcnn_inference", "(", "\n", "boxes", ",", "\n", "scores", ",", "\n", "image_shapes", ",", "\n", "predictions", ",", "\n", "self", ".", "test_score_thresh", ",", "\n", "self", ".", "test_nms_thresh", ",", "\n", "self", ".", "test_topk_per_image", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes_for_gt_classes": [[713, 748], ["fast_rcnn.FastRCNNOutputLayers.box2box_transform.apply_deltas", "fast_rcnn.FastRCNNOutputLayers.split", "len", "proposal_boxes[].cat", "torch.cat", "gt_classes.clamp_.clamp_.clamp_", "len", "fast_rcnn.FastRCNNOutputLayers.view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "predict_boxes_for_gt_classes", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were used\n                to compute predictions. The fields ``proposal_boxes``, ``gt_classes`` are expected.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted boxes for GT classes in case of\n                class-specific box head. Element i of the list has shape (Ri, B), where Ri is\n                the number of proposals for image i and B is the box dimension (4 or 5)\n        \"\"\"", "\n", "if", "not", "len", "(", "proposals", ")", ":", "\n", "            ", "return", "[", "]", "\n", "", "scores", ",", "proposal_deltas", "=", "predictions", "\n", "proposal_boxes", "=", "[", "p", ".", "proposal_boxes", "for", "p", "in", "proposals", "]", "\n", "proposal_boxes", "=", "proposal_boxes", "[", "0", "]", ".", "cat", "(", "proposal_boxes", ")", ".", "tensor", "\n", "N", ",", "B", "=", "proposal_boxes", ".", "shape", "\n", "predict_boxes", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "\n", "proposal_deltas", ",", "proposal_boxes", "\n", ")", "# Nx(KxB)", "\n", "\n", "K", "=", "predict_boxes", ".", "shape", "[", "1", "]", "//", "B", "\n", "if", "K", ">", "1", ":", "\n", "            ", "gt_classes", "=", "torch", ".", "cat", "(", "[", "p", ".", "gt_classes", "for", "p", "in", "proposals", "]", ",", "dim", "=", "0", ")", "\n", "# Some proposals are ignored or have a background class. Their gt_classes", "\n", "# cannot be used as index.", "\n", "gt_classes", "=", "gt_classes", ".", "clamp_", "(", "0", ",", "K", "-", "1", ")", "\n", "\n", "predict_boxes", "=", "predict_boxes", ".", "view", "(", "N", ",", "K", ",", "B", ")", "[", "\n", "torch", ".", "arange", "(", "N", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "predict_boxes", ".", "device", ")", ",", "gt_classes", "\n", "]", "\n", "", "num_prop_per_image", "=", "[", "len", "(", "p", ")", "for", "p", "in", "proposals", "]", "\n", "return", "predict_boxes", ".", "split", "(", "num_prop_per_image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes": [[749, 772], ["fast_rcnn.FastRCNNOutputLayers.box2box_transform.apply_deltas", "fast_rcnn.FastRCNNOutputLayers.split", "len", "len", "proposal_boxes[].cat"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "predict_boxes", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class-specific or class-agnostic boxes\n                for each image. Element i has shape (Ri, K * B) or (Ri, B), where Ri is\n                the number of proposals for image i and B is the box dimension (4 or 5)\n        \"\"\"", "\n", "if", "not", "len", "(", "proposals", ")", ":", "\n", "            ", "return", "[", "]", "\n", "", "_", ",", "proposal_deltas", "=", "predictions", "\n", "num_prop_per_image", "=", "[", "len", "(", "p", ")", "for", "p", "in", "proposals", "]", "\n", "proposal_boxes", "=", "[", "p", ".", "proposal_boxes", "for", "p", "in", "proposals", "]", "\n", "proposal_boxes", "=", "proposal_boxes", "[", "0", "]", ".", "cat", "(", "proposal_boxes", ")", ".", "tensor", "\n", "predict_boxes", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "\n", "proposal_deltas", ",", "proposal_boxes", "\n", ")", "# Nx(KxB)", "\n", "return", "predict_boxes", ".", "split", "(", "num_prop_per_image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs": [[773, 789], ["torch.nn.functional.softmax", "torch.nn.functional.softmax.split", "len"], "methods", ["None"], ["", "def", "predict_probs", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class probabilities for each image.\n                Element i has shape (Ri, K + 1), where Ri is the number of proposals for image i.\n        \"\"\"", "\n", "scores", ",", "_", "=", "predictions", "\n", "num_inst_per_image", "=", "[", "len", "(", "p", ")", "for", "p", "in", "proposals", "]", "\n", "probs", "=", "F", ".", "softmax", "(", "scores", ",", "dim", "=", "-", "1", ")", "\n", "return", "probs", ".", "split", "(", "num_inst_per_image", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.fast_rcnn_inference": [[52, 85], ["fast_rcnn.fast_rcnn_inference_single_image", "zip"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.fast_rcnn_inference_single_image"], ["def", "fast_rcnn_inference", "(", "boxes", ",", "scores", ",", "image_shapes", ",", "predictions", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", ")", ":", "\n", "    ", "\"\"\"\n    Call `fast_rcnn_inference_single_image` for all images.\n\n    Args:\n        boxes (list[Tensor]): A list of Tensors of predicted class-specific or class-agnostic\n            boxes for each image. Element i has shape (Ri, K * 4) if doing\n            class-specific regression, or (Ri, 4) if doing class-agnostic\n            regression, where Ri is the number of predicted objects for image i.\n            This is compatible with the output of :meth:`FastRCNNOutputLayers.predict_boxes`.\n        scores (list[Tensor]): A list of Tensors of predicted class scores for each image.\n            Element i has shape (Ri, K + 1), where Ri is the number of predicted objects\n            for image i. Compatible with the output of :meth:`FastRCNNOutputLayers.predict_probs`.\n        image_shapes (list[tuple]): A list of (width, height) tuples for each image in the batch.\n        score_thresh (float): Only return detections with a confidence score exceeding this\n            threshold.\n        nms_thresh (float):  The threshold to use for box non-maximum suppression. Value in [0, 1].\n        topk_per_image (int): The number of top scoring detections to return. Set < 0 to return\n            all detections.\n\n    Returns:\n        instances: (list[Instances]): A list of N instances, one for each image in the batch,\n            that stores the topk most confidence detections.\n        kept_indices: (list[Tensor]): A list of 1D tensor of length of N, each element indicates\n            the corresponding boxes/scores index in [0, Ri) from the input, for image i.\n    \"\"\"", "\n", "result_per_image", "=", "[", "\n", "fast_rcnn_inference_single_image", "(", "\n", "boxes_per_image", ",", "scores_per_image", ",", "image_shape", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", ",", "prediction", "\n", ")", "\n", "for", "scores_per_image", ",", "boxes_per_image", ",", "image_shape", ",", "prediction", "in", "zip", "(", "scores", ",", "boxes", ",", "image_shapes", ",", "predictions", ")", "\n", "]", "\n", "return", "[", "x", "[", "0", "]", "for", "x", "in", "result_per_image", "]", ",", "[", "x", "[", "1", "]", "for", "x", "in", "result_per_image", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.fast_rcnn_inference_single_image": [[87, 142], ["detectron2.structures.Boxes", "boxes.tensor.view.clip", "boxes.tensor.view.tensor.view", "filter_mask.nonzero", "detectron2.layers.batched_nms", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.isfinite().all", "torch.isfinite().all", "valid_mask.all", "boxes.tensor.view.reshape", "torch.isfinite", "torch.isfinite"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms"], ["", "def", "fast_rcnn_inference_single_image", "(", "\n", "boxes", ",", "scores", ",", "image_shape", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", ",", "prediction", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Single-image inference. Return bounding-box detection results by thresholding\n    on scores and applying non-maximum suppression (NMS).\n\n    Args:\n        Same as `fast_rcnn_inference`, but with boxes, scores, and image shapes\n        per image.\n\n    Returns:\n        Same as `fast_rcnn_inference`, but for only one image.\n    \"\"\"", "\n", "logits", "=", "prediction", "\n", "valid_mask", "=", "torch", ".", "isfinite", "(", "boxes", ")", ".", "all", "(", "dim", "=", "1", ")", "&", "torch", ".", "isfinite", "(", "scores", ")", ".", "all", "(", "dim", "=", "1", ")", "\n", "if", "not", "valid_mask", ".", "all", "(", ")", ":", "\n", "        ", "boxes", "=", "boxes", "[", "valid_mask", "]", "\n", "scores", "=", "scores", "[", "valid_mask", "]", "\n", "logits", "=", "logits", "[", "valid_mask", "]", "\n", "\n", "", "scores", "=", "scores", "[", ":", ",", ":", "-", "1", "]", "\n", "logits", "=", "logits", "[", ":", ",", ":", "-", "1", "]", "\n", "num_bbox_reg_classes", "=", "boxes", ".", "shape", "[", "1", "]", "//", "4", "\n", "# Convert to Boxes to use the `clip` function ...", "\n", "boxes", "=", "Boxes", "(", "boxes", ".", "reshape", "(", "-", "1", ",", "4", ")", ")", "\n", "boxes", ".", "clip", "(", "image_shape", ")", "\n", "boxes", "=", "boxes", ".", "tensor", ".", "view", "(", "-", "1", ",", "num_bbox_reg_classes", ",", "4", ")", "# R x C x 4", "\n", "\n", "# 1. Filter results based on detection scores. It can make NMS more efficient", "\n", "#    by filtering out low-confidence detections.", "\n", "filter_mask", "=", "scores", ">", "score_thresh", "# R x K", "\n", "# R' x 2. First column contains indices of the R predictions;", "\n", "# Second column contains indices of classes.", "\n", "filter_inds", "=", "filter_mask", ".", "nonzero", "(", ")", "\n", "if", "num_bbox_reg_classes", "==", "1", ":", "\n", "        ", "boxes", "=", "boxes", "[", "filter_inds", "[", ":", ",", "0", "]", ",", "0", "]", "\n", "", "else", ":", "\n", "        ", "boxes", "=", "boxes", "[", "filter_mask", "]", "\n", "", "scores", "=", "scores", "[", "filter_mask", "]", "\n", "logits", "=", "logits", "[", "filter_inds", "[", ":", ",", "0", "]", "]", "\n", "\n", "# 2. Apply NMS for each class independently.", "\n", "keep", "=", "batched_nms", "(", "boxes", ",", "scores", ",", "filter_inds", "[", ":", ",", "1", "]", ",", "nms_thresh", ")", "\n", "if", "topk_per_image", ">=", "0", ":", "\n", "        ", "keep", "=", "keep", "[", ":", "topk_per_image", "]", "\n", "", "boxes", ",", "scores", ",", "filter_inds", "=", "boxes", "[", "keep", "]", ",", "scores", "[", "keep", "]", ",", "filter_inds", "[", "keep", "]", "\n", "logits", "=", "logits", "[", "keep", "]", "\n", "\n", "result", "=", "Instances", "(", "image_shape", ")", "\n", "result", ".", "pred_boxes", "=", "Boxes", "(", "boxes", ")", "\n", "result", ".", "scores", "=", "scores", "\n", "result", ".", "pred_classes", "=", "filter_inds", "[", ":", ",", "1", "]", "\n", "result", ".", "logits", "=", "logits", "\n", "return", "result", ",", "filter_inds", "[", ":", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.Xavier": [[389, 396], ["m.weight.data.uniform_", "m.bias.data.fill_", "m.weight.data.size", "m.weight.data.size", "math.sqrt", "math.sqrt"], "function", ["None"], ["", "", "def", "Xavier", "(", "m", ")", ":", "\n", "    ", "if", "m", ".", "__class__", ".", "__name__", "==", "'Linear'", ":", "\n", "        ", "fan_in", ",", "fan_out", "=", "m", ".", "weight", ".", "data", ".", "size", "(", "1", ")", ",", "m", ".", "weight", ".", "data", ".", "size", "(", "0", ")", "\n", "std", "=", "1.0", "*", "math", ".", "sqrt", "(", "2.0", "/", "(", "fan_in", "+", "fan_out", ")", ")", "\n", "a", "=", "math", ".", "sqrt", "(", "3.0", ")", "*", "std", "\n", "m", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "a", ",", "a", ")", "\n", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers.from_config": [[139, 146], ["super().from_config", "box_regression.Box2BoxTransformRotated"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.from_config"], ["@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "args", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "args", "[", "\"box2box_transform\"", "]", "=", "Box2BoxTransformRotated", "(", "\n", "weights", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", "\n", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.rotated_fast_rcnn.RotatedFastRCNNOutputLayers.inference": [[147, 164], ["rotated_fast_rcnn.RotatedFastRCNNOutputLayers.predict_boxes", "rotated_fast_rcnn.RotatedFastRCNNOutputLayers.predict_probs", "rotated_fast_rcnn.fast_rcnn_inference_rotated"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.rotated_fast_rcnn.fast_rcnn_inference_rotated"], ["", "def", "inference", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[Instances]: same as `fast_rcnn_inference_rotated`.\n            list[Tensor]: same as `fast_rcnn_inference_rotated`.\n        \"\"\"", "\n", "boxes", "=", "self", ".", "predict_boxes", "(", "predictions", ",", "proposals", ")", "\n", "scores", "=", "self", ".", "predict_probs", "(", "predictions", ",", "proposals", ")", "\n", "image_shapes", "=", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "\n", "\n", "return", "fast_rcnn_inference_rotated", "(", "\n", "boxes", ",", "\n", "scores", ",", "\n", "image_shapes", ",", "\n", "self", ".", "test_score_thresh", ",", "\n", "self", ".", "test_nms_thresh", ",", "\n", "self", ".", "test_topk_per_image", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.rotated_fast_rcnn.RROIHeads.__init__": [[174, 184], ["roi_heads.StandardROIHeads.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "assert", "(", "\n", "not", "self", ".", "mask_on", "and", "not", "self", ".", "keypoint_on", "\n", ")", ",", "\"Mask/Keypoints not supported in Rotated ROIHeads.\"", "\n", "assert", "not", "self", ".", "train_on_pred_boxes", ",", "\"train_on_pred_boxes not implemented for RROIHeads!\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.rotated_fast_rcnn.RROIHeads._init_box_head": [[185, 214], ["tuple", "poolers.ROIPooler", "box_head.build_box_head.build_box_head", "rotated_fast_rcnn.RotatedFastRCNNOutputLayers", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.box_head.build_box_head"], ["", "@", "classmethod", "\n", "def", "_init_box_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "assert", "pooler_type", "in", "[", "\"ROIAlignRotated\"", "]", ",", "pooler_type", "\n", "# assume all channel counts are equal", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "[", "0", "]", "\n", "\n", "box_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "box_head", "=", "build_box_head", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "in_channels", ",", "height", "=", "pooler_resolution", ",", "width", "=", "pooler_resolution", ")", "\n", ")", "\n", "# This line is the only difference v.s. StandardROIHeads", "\n", "box_predictor", "=", "RotatedFastRCNNOutputLayers", "(", "cfg", ",", "box_head", ".", "output_shape", ")", "\n", "return", "{", "\n", "\"box_in_features\"", ":", "in_features", ",", "\n", "\"box_pooler\"", ":", "box_pooler", ",", "\n", "\"box_head\"", ":", "box_head", ",", "\n", "\"box_predictor\"", ":", "box_predictor", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.rotated_fast_rcnn.RROIHeads.label_and_sample_proposals": [[216, 277], ["torch.no_grad", "zip", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "proposal_generator.proposal_utils.add_ground_truth_to_proposals", "detectron2.structures.pairwise_iou_rotated", "rotated_fast_rcnn.RROIHeads.proposal_matcher", "rotated_fast_rcnn.RROIHeads._sample_proposals", "num_bg_samples.append", "num_fg_samples.append", "proposals_with_gt.append", "numpy.mean", "numpy.mean", "len", "detectron2.structures.RotatedBoxes", "targets_per_image.gt_boxes.tensor.new_zeros", "gt_classes.numel", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.proposal_utils.add_ground_truth_to_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads._sample_proposals"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_proposals", "(", "self", ",", "proposals", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Prepare some proposals to be used to train the RROI heads.\n        It performs box matching between `proposals` and `targets`, and assigns\n        training labels to the proposals.\n        It returns `self.batch_size_per_image` random samples from proposals and groundtruth boxes,\n        with a fraction of positives that is no larger than `self.positive_sample_fraction.\n\n        Args:\n            See :meth:`StandardROIHeads.forward`\n\n        Returns:\n            list[Instances]: length `N` list of `Instances`s containing the proposals\n                sampled for training. Each `Instances` has the following fields:\n                - proposal_boxes: the rotated proposal boxes\n                - gt_boxes: the ground-truth rotated boxes that the proposal is assigned to\n                  (this is only meaningful if the proposal has a label > 0; if label = 0\n                   then the ground-truth box is random)\n                - gt_classes: the ground-truth classification lable for each proposal\n        \"\"\"", "\n", "gt_boxes", "=", "[", "x", ".", "gt_boxes", "for", "x", "in", "targets", "]", "\n", "if", "self", ".", "proposal_append_gt", ":", "\n", "            ", "proposals", "=", "add_ground_truth_to_proposals", "(", "gt_boxes", ",", "proposals", ")", "\n", "\n", "", "proposals_with_gt", "=", "[", "]", "\n", "\n", "num_fg_samples", "=", "[", "]", "\n", "num_bg_samples", "=", "[", "]", "\n", "for", "proposals_per_image", ",", "targets_per_image", "in", "zip", "(", "proposals", ",", "targets", ")", ":", "\n", "            ", "has_gt", "=", "len", "(", "targets_per_image", ")", ">", "0", "\n", "match_quality_matrix", "=", "pairwise_iou_rotated", "(", "\n", "targets_per_image", ".", "gt_boxes", ",", "proposals_per_image", ".", "proposal_boxes", "\n", ")", "\n", "matched_idxs", ",", "matched_labels", "=", "self", ".", "proposal_matcher", "(", "match_quality_matrix", ")", "\n", "sampled_idxs", ",", "gt_classes", "=", "self", ".", "_sample_proposals", "(", "\n", "matched_idxs", ",", "matched_labels", ",", "targets_per_image", ".", "gt_classes", "\n", ")", "\n", "\n", "proposals_per_image", "=", "proposals_per_image", "[", "sampled_idxs", "]", "\n", "proposals_per_image", ".", "gt_classes", "=", "gt_classes", "\n", "\n", "if", "has_gt", ":", "\n", "                ", "sampled_targets", "=", "matched_idxs", "[", "sampled_idxs", "]", "\n", "proposals_per_image", ".", "gt_boxes", "=", "targets_per_image", ".", "gt_boxes", "[", "sampled_targets", "]", "\n", "", "else", ":", "\n", "                ", "gt_boxes", "=", "RotatedBoxes", "(", "\n", "targets_per_image", ".", "gt_boxes", ".", "tensor", ".", "new_zeros", "(", "(", "len", "(", "sampled_idxs", ")", ",", "5", ")", ")", "\n", ")", "\n", "proposals_per_image", ".", "gt_boxes", "=", "gt_boxes", "\n", "\n", "", "num_bg_samples", ".", "append", "(", "(", "gt_classes", "==", "self", ".", "num_classes", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "num_fg_samples", ".", "append", "(", "gt_classes", ".", "numel", "(", ")", "-", "num_bg_samples", "[", "-", "1", "]", ")", "\n", "proposals_with_gt", ".", "append", "(", "proposals_per_image", ")", "\n", "\n", "# Log the number of fg/bg samples that are selected for training ROI heads", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "num_fg_samples", ")", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_bg_samples\"", ",", "np", ".", "mean", "(", "num_bg_samples", ")", ")", "\n", "\n", "return", "proposals_with_gt", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.rotated_fast_rcnn.fast_rcnn_inference_rotated": [[46, 81], ["rotated_fast_rcnn.fast_rcnn_inference_single_image_rotated", "zip"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.rotated_fast_rcnn.fast_rcnn_inference_single_image_rotated"], ["def", "fast_rcnn_inference_rotated", "(", "\n", "boxes", ",", "scores", ",", "image_shapes", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Call `fast_rcnn_inference_single_image_rotated` for all images.\n\n    Args:\n        boxes (list[Tensor]): A list of Tensors of predicted class-specific or class-agnostic\n            boxes for each image. Element i has shape (Ri, K * 5) if doing\n            class-specific regression, or (Ri, 5) if doing class-agnostic\n            regression, where Ri is the number of predicted objects for image i.\n            This is compatible with the output of :meth:`FastRCNNOutputs.predict_boxes`.\n        scores (list[Tensor]): A list of Tensors of predicted class scores for each image.\n            Element i has shape (Ri, K + 1), where Ri is the number of predicted objects\n            for image i. Compatible with the output of :meth:`FastRCNNOutputs.predict_probs`.\n        image_shapes (list[tuple]): A list of (width, height) tuples for each image in the batch.\n        score_thresh (float): Only return detections with a confidence score exceeding this\n            threshold.\n        nms_thresh (float):  The threshold to use for box non-maximum suppression. Value in [0, 1].\n        topk_per_image (int): The number of top scoring detections to return. Set < 0 to return\n            all detections.\n\n    Returns:\n        instances: (list[Instances]): A list of N instances, one for each image in the batch,\n            that stores the topk most confidence detections.\n        kept_indices: (list[Tensor]): A list of 1D tensor of length of N, each element indicates\n            the corresponding boxes/scores index in [0, Ri) from the input, for image i.\n    \"\"\"", "\n", "result_per_image", "=", "[", "\n", "fast_rcnn_inference_single_image_rotated", "(", "\n", "boxes_per_image", ",", "scores_per_image", ",", "image_shape", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", "\n", "for", "scores_per_image", ",", "boxes_per_image", ",", "image_shape", "in", "zip", "(", "scores", ",", "boxes", ",", "image_shapes", ")", "\n", "]", "\n", "return", "[", "x", "[", "0", "]", "for", "x", "in", "result_per_image", "]", ",", "[", "x", "[", "1", "]", "for", "x", "in", "result_per_image", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.rotated_fast_rcnn.fast_rcnn_inference_single_image_rotated": [[83, 132], ["detectron2.structures.RotatedBoxes", "boxes.tensor.view.clip", "boxes.tensor.view.tensor.view", "filter_mask.nonzero", "detectron2.layers.batched_nms_rotated", "detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "torch.isfinite().all", "torch.isfinite().all", "valid_mask.all", "boxes.tensor.view.reshape", "torch.isfinite", "torch.isfinite"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms_rotated"], ["", "def", "fast_rcnn_inference_single_image_rotated", "(", "\n", "boxes", ",", "scores", ",", "image_shape", ",", "score_thresh", ",", "nms_thresh", ",", "topk_per_image", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Single-image inference. Return rotated bounding-box detection results by thresholding\n    on scores and applying rotated non-maximum suppression (Rotated NMS).\n\n    Args:\n        Same as `fast_rcnn_inference_rotated`, but with rotated boxes, scores, and image shapes\n        per image.\n\n    Returns:\n        Same as `fast_rcnn_inference_rotated`, but for only one image.\n    \"\"\"", "\n", "valid_mask", "=", "torch", ".", "isfinite", "(", "boxes", ")", ".", "all", "(", "dim", "=", "1", ")", "&", "torch", ".", "isfinite", "(", "scores", ")", ".", "all", "(", "dim", "=", "1", ")", "\n", "if", "not", "valid_mask", ".", "all", "(", ")", ":", "\n", "        ", "boxes", "=", "boxes", "[", "valid_mask", "]", "\n", "scores", "=", "scores", "[", "valid_mask", "]", "\n", "\n", "", "B", "=", "5", "# box dimension", "\n", "scores", "=", "scores", "[", ":", ",", ":", "-", "1", "]", "\n", "num_bbox_reg_classes", "=", "boxes", ".", "shape", "[", "1", "]", "//", "B", "\n", "# Convert to Boxes to use the `clip` function ...", "\n", "boxes", "=", "RotatedBoxes", "(", "boxes", ".", "reshape", "(", "-", "1", ",", "B", ")", ")", "\n", "boxes", ".", "clip", "(", "image_shape", ")", "\n", "boxes", "=", "boxes", ".", "tensor", ".", "view", "(", "-", "1", ",", "num_bbox_reg_classes", ",", "B", ")", "# R x C x B", "\n", "# Filter results based on detection scores", "\n", "filter_mask", "=", "scores", ">", "score_thresh", "# R x K", "\n", "# R' x 2. First column contains indices of the R predictions;", "\n", "# Second column contains indices of classes.", "\n", "filter_inds", "=", "filter_mask", ".", "nonzero", "(", ")", "\n", "if", "num_bbox_reg_classes", "==", "1", ":", "\n", "        ", "boxes", "=", "boxes", "[", "filter_inds", "[", ":", ",", "0", "]", ",", "0", "]", "\n", "", "else", ":", "\n", "        ", "boxes", "=", "boxes", "[", "filter_mask", "]", "\n", "", "scores", "=", "scores", "[", "filter_mask", "]", "\n", "\n", "# Apply per-class Rotated NMS", "\n", "keep", "=", "batched_nms_rotated", "(", "boxes", ",", "scores", ",", "filter_inds", "[", ":", ",", "1", "]", ",", "nms_thresh", ")", "\n", "if", "topk_per_image", ">=", "0", ":", "\n", "        ", "keep", "=", "keep", "[", ":", "topk_per_image", "]", "\n", "", "boxes", ",", "scores", ",", "filter_inds", "=", "boxes", "[", "keep", "]", ",", "scores", "[", "keep", "]", ",", "filter_inds", "[", "keep", "]", "\n", "\n", "result", "=", "Instances", "(", "image_shape", ")", "\n", "result", ".", "pred_boxes", "=", "RotatedBoxes", "(", "boxes", ")", "\n", "result", ".", "scores", "=", "scores", "\n", "result", ".", "pred_classes", "=", "filter_inds", "[", ":", ",", "1", "]", "\n", "\n", "return", "result", ",", "filter_inds", "[", ":", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads.__init__": [[143, 174], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "num_classes", ",", "\n", "batch_size_per_image", ",", "\n", "positive_fraction", ",", "\n", "proposal_matcher", ",", "\n", "enable_thresold_autolabelling", ",", "\n", "unk_k", ",", "\n", "proposal_append_gt", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            num_classes (int): number of classes. Used to label background proposals.\n            batch_size_per_image (int): number of proposals to sample for training\n            positive_fraction (float): fraction of positive (foreground) proposals\n                to sample for training.\n            proposal_matcher (Matcher): matcher that matches proposals and ground truth\n            proposal_append_gt (bool): whether to include ground truth as proposals as well\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "batch_size_per_image", "=", "batch_size_per_image", "\n", "self", ".", "positive_fraction", "=", "positive_fraction", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "proposal_append_gt", "=", "proposal_append_gt", "\n", "self", ".", "enable_thresold_autolabelling", "=", "enable_thresold_autolabelling", "\n", "self", ".", "unk_k", "=", "unk_k", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads.from_config": [[175, 190], ["matcher.Matcher"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "return", "{", "\n", "\"batch_size_per_image\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "BATCH_SIZE_PER_IMAGE", ",", "\n", "\"positive_fraction\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "POSITIVE_FRACTION", ",", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", ",", "\n", "\"proposal_append_gt\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "PROPOSAL_APPEND_GT", ",", "\n", "# Matcher to assign box proposals to gt boxes", "\n", "\"proposal_matcher\"", ":", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_THRESHOLDS", ",", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_LABELS", ",", "\n", "allow_low_quality_matches", "=", "False", ",", "\n", ")", ",", "\n", "\"enable_thresold_autolabelling\"", ":", "cfg", ".", "OWOD", ".", "ENABLE_THRESHOLD_AUTOLABEL_UNK", ",", "\n", "\"unk_k\"", ":", "cfg", ".", "OWOD", ".", "NUM_UNK_PER_IMAGE", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads._sample_proposals": [[192, 245], ["sampling.subsample_labels", "torch.cat", "gt_classes.numel", "torch.zeros", "torch.zeros_like", "list", "zip", "heapq.nlargest", "enumerate", "operator.itemgetter"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.sampling.subsample_labels", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "_sample_proposals", "(", "\n", "self", ",", "matched_idxs", ":", "torch", ".", "Tensor", ",", "matched_labels", ":", "torch", ".", "Tensor", ",", "gt_classes", ":", "torch", ".", "Tensor", ",", "\n", "objectness_logits", ":", "torch", ".", "Tensor", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Based on the matching between N proposals and M groundtruth,\n        sample the proposals and set their classification labels.\n\n        Args:\n            matched_idxs (Tensor): a vector of length N, each is the best-matched\n                gt index in [0, M) for each proposal.\n            matched_labels (Tensor): a vector of length N, the matcher's label\n                (one of cfg.MODEL.ROI_HEADS.IOU_LABELS) for each proposal.\n            gt_classes (Tensor): a vector of length M.\n\n        Returns:\n            Tensor: a vector of indices of sampled proposals. Each is in [0, N).\n            Tensor: a vector of the same length, the classification label for\n                each sampled proposal. Each sample is labeled as either a category in\n                [0, num_classes) or the background (num_classes).\n        \"\"\"", "\n", "has_gt", "=", "gt_classes", ".", "numel", "(", ")", ">", "0", "\n", "# Get the corresponding GT for each proposal", "\n", "if", "has_gt", ":", "\n", "            ", "gt_classes", "=", "gt_classes", "[", "matched_idxs", "]", "\n", "# Label unmatched proposals (0 label from matcher) as background (label=num_classes)", "\n", "gt_classes", "[", "matched_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "# Label ignore proposals (-1 label)", "\n", "gt_classes", "[", "matched_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "            ", "gt_classes", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "\n", "", "sampled_fg_idxs", ",", "sampled_bg_idxs", "=", "subsample_labels", "(", "\n", "gt_classes", ",", "self", ".", "batch_size_per_image", ",", "self", ".", "positive_fraction", ",", "self", ".", "num_classes", "\n", ")", "\n", "\n", "sampled_idxs", "=", "torch", ".", "cat", "(", "[", "sampled_fg_idxs", ",", "sampled_bg_idxs", "]", ",", "dim", "=", "0", ")", "\n", "gt_classes_ss", "=", "gt_classes", "[", "sampled_idxs", "]", "\n", "\n", "if", "self", ".", "enable_thresold_autolabelling", ":", "\n", "            ", "matched_labels_ss", "=", "matched_labels", "[", "sampled_idxs", "]", "\n", "pred_objectness_score_ss", "=", "objectness_logits", "[", "sampled_idxs", "]", "\n", "\n", "# 1) Remove FG objectness score. 2) Sort and select top k. 3) Build and apply mask.", "\n", "mask", "=", "torch", ".", "zeros", "(", "(", "pred_objectness_score_ss", ".", "shape", ")", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "pred_objectness_score_ss", "[", "matched_labels_ss", "!=", "0", "]", "=", "-", "1", "\n", "sorted_indices", "=", "list", "(", "zip", "(", "\n", "*", "heapq", ".", "nlargest", "(", "self", ".", "unk_k", ",", "enumerate", "(", "pred_objectness_score_ss", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", ")", ")", "[", "0", "]", "\n", "for", "index", "in", "sorted_indices", ":", "\n", "                ", "mask", "[", "index", "]", "=", "True", "\n", "", "gt_classes_ss", "[", "mask", "]", "=", "self", ".", "num_classes", "-", "1", "\n", "\n", "", "return", "sampled_idxs", ",", "gt_classes_ss", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads.label_and_sample_proposals": [[246, 333], ["torch.no_grad", "zip", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "proposal_generator.proposal_utils.add_ground_truth_to_proposals", "detectron2.structures.pairwise_iou", "roi_heads.ROIHeads.proposal_matcher", "roi_heads.ROIHeads._sample_proposals", "num_bg_samples.append", "num_fg_samples.append", "proposals_with_gt.append", "numpy.mean", "numpy.mean", "len", "targets_per_image.get_fields().items", "detectron2.structures.Boxes", "targets_per_image.gt_boxes.tensor.new_zeros", "gt_classes.numel", "targets_per_image.get_fields", "trg_name.startswith", "proposals_per_image.set", "proposals_per_image.has", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.proposal_generator.proposal_utils.add_ground_truth_to_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads._sample_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.get_fields", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_proposals", "(", "\n", "self", ",", "proposals", ":", "List", "[", "Instances", "]", ",", "targets", ":", "List", "[", "Instances", "]", "\n", ")", "->", "List", "[", "Instances", "]", ":", "\n", "        ", "\"\"\"\n        Prepare some proposals to be used to train the ROI heads.\n        It performs box matching between `proposals` and `targets`, and assigns\n        training labels to the proposals.\n        It returns ``self.batch_size_per_image`` random samples from proposals and groundtruth\n        boxes, with a fraction of positives that is no larger than\n        ``self.positive_fraction``.\n\n        Args:\n            See :meth:`ROIHeads.forward`\n\n        Returns:\n            list[Instances]:\n                length `N` list of `Instances`s containing the proposals\n                sampled for training. Each `Instances` has the following fields:\n\n                - proposal_boxes: the proposal boxes\n                - gt_boxes: the ground-truth box that the proposal is assigned to\n                  (this is only meaningful if the proposal has a label > 0; if label = 0\n                  then the ground-truth box is random)\n\n                Other fields such as \"gt_classes\", \"gt_masks\", that's included in `targets`.\n        \"\"\"", "\n", "gt_boxes", "=", "[", "x", ".", "gt_boxes", "for", "x", "in", "targets", "]", "\n", "# Augment proposals with ground-truth boxes.", "\n", "# In the case of learned proposals (e.g., RPN), when training starts", "\n", "# the proposals will be low quality due to random initialization.", "\n", "# It's possible that none of these initial", "\n", "# proposals have high enough overlap with the gt objects to be used", "\n", "# as positive examples for the second stage components (box head,", "\n", "# cls head, mask head). Adding the gt boxes to the set of proposals", "\n", "# ensures that the second stage components will have some positive", "\n", "# examples from the start of training. For RPN, this augmentation improves", "\n", "# convergence and empirically improves box AP on COCO by about 0.5", "\n", "# points (under one tested configuration).", "\n", "if", "self", ".", "proposal_append_gt", ":", "\n", "            ", "proposals", "=", "add_ground_truth_to_proposals", "(", "gt_boxes", ",", "proposals", ")", "\n", "\n", "", "proposals_with_gt", "=", "[", "]", "\n", "\n", "num_fg_samples", "=", "[", "]", "\n", "num_bg_samples", "=", "[", "]", "\n", "for", "proposals_per_image", ",", "targets_per_image", "in", "zip", "(", "proposals", ",", "targets", ")", ":", "\n", "            ", "has_gt", "=", "len", "(", "targets_per_image", ")", ">", "0", "\n", "match_quality_matrix", "=", "pairwise_iou", "(", "\n", "targets_per_image", ".", "gt_boxes", ",", "proposals_per_image", ".", "proposal_boxes", "\n", ")", "\n", "matched_idxs", ",", "matched_labels", "=", "self", ".", "proposal_matcher", "(", "match_quality_matrix", ")", "\n", "sampled_idxs", ",", "gt_classes", "=", "self", ".", "_sample_proposals", "(", "\n", "matched_idxs", ",", "matched_labels", ",", "targets_per_image", ".", "gt_classes", ",", "proposals_per_image", ".", "objectness_logits", "\n", ")", "\n", "\n", "# Set target attributes of the sampled proposals:", "\n", "proposals_per_image", "=", "proposals_per_image", "[", "sampled_idxs", "]", "\n", "proposals_per_image", ".", "gt_classes", "=", "gt_classes", "\n", "\n", "# We index all the attributes of targets that start with \"gt_\"", "\n", "# and have not been added to proposals yet (=\"gt_classes\").", "\n", "if", "has_gt", ":", "\n", "                ", "sampled_targets", "=", "matched_idxs", "[", "sampled_idxs", "]", "\n", "# NOTE: here the indexing waste some compute, because heads", "\n", "# like masks, keypoints, etc, will filter the proposals again,", "\n", "# (by foreground/background, or number of keypoints in the image, etc)", "\n", "# so we essentially index the data twice.", "\n", "for", "(", "trg_name", ",", "trg_value", ")", "in", "targets_per_image", ".", "get_fields", "(", ")", ".", "items", "(", ")", ":", "\n", "                    ", "if", "trg_name", ".", "startswith", "(", "\"gt_\"", ")", "and", "not", "proposals_per_image", ".", "has", "(", "trg_name", ")", ":", "\n", "                        ", "proposals_per_image", ".", "set", "(", "trg_name", ",", "trg_value", "[", "sampled_targets", "]", ")", "\n", "", "", "", "else", ":", "\n", "                ", "gt_boxes", "=", "Boxes", "(", "\n", "targets_per_image", ".", "gt_boxes", ".", "tensor", ".", "new_zeros", "(", "(", "len", "(", "sampled_idxs", ")", ",", "4", ")", ")", "\n", ")", "\n", "proposals_per_image", ".", "gt_boxes", "=", "gt_boxes", "\n", "\n", "", "num_bg_samples", ".", "append", "(", "(", "gt_classes", "==", "self", ".", "num_classes", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "num_fg_samples", ".", "append", "(", "gt_classes", ".", "numel", "(", ")", "-", "num_bg_samples", "[", "-", "1", "]", ")", "\n", "proposals_with_gt", ".", "append", "(", "proposals_per_image", ")", "\n", "\n", "# Log the number of fg/bg samples that are selected for training ROI heads", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "num_fg_samples", ")", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_bg_samples\"", ",", "np", ".", "mean", "(", "num_bg_samples", ")", ")", "\n", "\n", "return", "proposals_with_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads.forward": [[334, 369], ["NotImplementedError"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "\n", "targets", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        Args:\n            images (ImageList):\n            features (dict[str,Tensor]): input data as a mapping from feature\n                map name to tensor. Axis 0 represents the number of images `N` in\n                the input data; axes 1-3 are channels, height, and width, which may\n                vary between feature maps (e.g., if a feature pyramid is used).\n            proposals (list[Instances]): length `N` list of `Instances`. The i-th\n                `Instances` contains object proposals for the i-th input image,\n                with fields \"proposal_boxes\" and \"objectness_logits\".\n            targets (list[Instances], optional): length `N` list of `Instances`. The i-th\n                `Instances` contains the ground-truth per-instance annotations\n                for the i-th input image.  Specify `targets` during training only.\n                It may have the following fields:\n\n                - gt_boxes: the bounding box of each instance.\n                - gt_classes: the label for each instance with a category ranging in [0, #class].\n                - gt_masks: PolygonMasks or BitMasks, the ground-truth masks of each instance.\n                - gt_keypoints: NxKx3, the groud-truth keypoints for each instance.\n\n        Returns:\n            list[Instances]: length `N` list of `Instances` containing the\n            detected instances. Returned during inference only; may be [] during training.\n\n            dict[str->Tensor]:\n            mapping from a named loss to a tensor storing the loss. Used during training only.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads.__init__": [[379, 412], ["roi_heads.ROIHeads.__init__", "os.path.join", "poolers.ROIPooler", "roi_heads.Res5ROIHeads._build_res5_block", "fast_rcnn.FastRCNNOutputLayers", "len", "detectron2.layers.ShapeSpec", "mask_head.build_mask_head", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads._build_res5_block", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.build_mask_head"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "\n", "pooler_scales", "=", "(", "1.0", "/", "input_shape", "[", "self", ".", "in_features", "[", "0", "]", "]", ".", "stride", ",", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "self", ".", "mask_on", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "self", ".", "enable_clustering", "=", "cfg", ".", "OWOD", ".", "ENABLE_CLUSTERING", "\n", "self", ".", "compute_energy_flag", "=", "cfg", ".", "OWOD", ".", "COMPUTE_ENERGY", "\n", "self", ".", "energy_save_path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "cfg", ".", "OWOD", ".", "ENERGY_SAVE_PATH", ")", "\n", "# fmt: on", "\n", "assert", "not", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", "\n", "assert", "len", "(", "self", ".", "in_features", ")", "==", "1", "\n", "\n", "self", ".", "pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "\n", "self", ".", "res5", ",", "out_channels", "=", "self", ".", "_build_res5_block", "(", "cfg", ")", "\n", "self", ".", "box_predictor", "=", "FastRCNNOutputLayers", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "out_channels", ",", "height", "=", "1", ",", "width", "=", "1", ")", "\n", ")", "\n", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "self", ".", "mask_head", "=", "build_mask_head", "(", "\n", "cfg", ",", "\n", "ShapeSpec", "(", "channels", "=", "out_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads._build_res5_block": [[414, 439], ["backbone.resnet.ResNet.make_stage", "torch.nn.Sequential"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.make_stage"], ["", "", "def", "_build_res5_block", "(", "self", ",", "cfg", ")", ":", "\n", "# fmt: off", "\n", "        ", "stage_channel_factor", "=", "2", "**", "3", "# res5 is 8x res2", "\n", "num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", "\n", "width_per_group", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", "\n", "bottleneck_channels", "=", "num_groups", "*", "width_per_group", "*", "stage_channel_factor", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "*", "stage_channel_factor", "\n", "stride_in_1x1", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STRIDE_IN_1X1", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "assert", "not", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_ON_PER_STAGE", "[", "-", "1", "]", ",", "\"Deformable conv is not yet supported in res5 head.\"", "\n", "# fmt: on", "\n", "\n", "blocks", "=", "ResNet", ".", "make_stage", "(", "\n", "BottleneckBlock", ",", "\n", "3", ",", "\n", "stride_per_block", "=", "[", "2", ",", "1", ",", "1", "]", ",", "\n", "in_channels", "=", "out_channels", "//", "2", ",", "\n", "bottleneck_channels", "=", "bottleneck_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "num_groups", "=", "num_groups", ",", "\n", "norm", "=", "norm", ",", "\n", "stride_in_1x1", "=", "stride_in_1x1", ",", "\n", ")", "\n", "return", "nn", ".", "Sequential", "(", "*", "blocks", ")", ",", "out_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads._shared_roi_transform": [[440, 443], ["roi_heads.Res5ROIHeads.pooler", "roi_heads.Res5ROIHeads.res5"], "methods", ["None"], ["", "def", "_shared_roi_transform", "(", "self", ",", "features", ",", "boxes", ")", ":", "\n", "        ", "x", "=", "self", ".", "pooler", "(", "features", ",", "boxes", ")", "\n", "return", "self", ".", "res5", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads.log_features": [[444, 449], ["torch.cat", "torch.save", "shortuuid.uuid", "shortuuid.uuid", "shortuuid.uuid", "shortuuid.uuid"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save"], ["", "def", "log_features", "(", "self", ",", "features", ",", "proposals", ")", ":", "\n", "        ", "gt_classes", "=", "torch", ".", "cat", "(", "[", "p", ".", "gt_classes", "for", "p", "in", "proposals", "]", ")", "\n", "data", "=", "(", "features", ",", "gt_classes", ")", "\n", "location", "=", "'/home/fk1/workspace/OWOD/output/features/'", "+", "shortuuid", ".", "uuid", "(", ")", "+", "'.pkl'", "\n", "torch", ".", "save", "(", "data", ",", "location", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads.compute_energy": [[450, 456], ["torch.cat", "os.path.join", "torch.save", "shortuuid.uuid", "shortuuid.uuid", "shortuuid.uuid", "shortuuid.uuid"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save"], ["", "def", "compute_energy", "(", "self", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "gt_classes", "=", "torch", ".", "cat", "(", "[", "p", ".", "gt_classes", "for", "p", "in", "proposals", "]", ")", "\n", "logits", "=", "predictions", "[", "0", "]", "\n", "data", "=", "(", "logits", ",", "gt_classes", ")", "\n", "location", "=", "os", ".", "path", ".", "join", "(", "self", ".", "energy_save_path", ",", "shortuuid", ".", "uuid", "(", ")", "+", "'.pkl'", ")", "\n", "torch", ".", "save", "(", "data", ",", "location", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads.forward": [[457, 499], ["roi_heads.Res5ROIHeads._shared_roi_transform", "roi_heads.Res5ROIHeads.mean", "roi_heads.Res5ROIHeads.box_predictor", "roi_heads.Res5ROIHeads.label_and_sample_proposals", "roi_heads.Res5ROIHeads.box_predictor.losses", "roi_heads.Res5ROIHeads.box_predictor.inference", "roi_heads.Res5ROIHeads.forward_with_given_boxes", "roi_heads.Res5ROIHeads.box_predictor.update_feature_store", "roi_heads.Res5ROIHeads.compute_energy", "roi_heads.select_foreground_proposals", "roi_heads.Res5ROIHeads.update", "roi_heads.Res5ROIHeads.mask_head", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads._shared_roi_transform", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads.label_and_sample_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.update_feature_store", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads.compute_energy", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        See :meth:`ROIHeads.forward`.\n        \"\"\"", "\n", "del", "images", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "targets", "\n", "proposals", "=", "self", ".", "label_and_sample_proposals", "(", "proposals", ",", "targets", ")", "\n", "", "del", "targets", "\n", "\n", "proposal_boxes", "=", "[", "x", ".", "proposal_boxes", "for", "x", "in", "proposals", "]", "\n", "box_features", "=", "self", ".", "_shared_roi_transform", "(", "\n", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", ",", "proposal_boxes", "\n", ")", "\n", "input_features", "=", "box_features", ".", "mean", "(", "dim", "=", "[", "2", ",", "3", "]", ")", "\n", "predictions", "=", "self", ".", "box_predictor", "(", "input_features", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "# self.log_features(input_features, proposals)", "\n", "            ", "if", "self", ".", "enable_clustering", ":", "\n", "                ", "self", ".", "box_predictor", ".", "update_feature_store", "(", "input_features", ",", "proposals", ")", "\n", "", "del", "features", "\n", "if", "self", ".", "compute_energy_flag", ":", "\n", "                ", "self", ".", "compute_energy", "(", "predictions", ",", "proposals", ")", "\n", "", "losses", "=", "self", ".", "box_predictor", ".", "losses", "(", "predictions", ",", "proposals", ",", "input_features", ")", "\n", "if", "self", ".", "mask_on", ":", "\n", "                ", "proposals", ",", "fg_selection_masks", "=", "select_foreground_proposals", "(", "\n", "proposals", ",", "self", ".", "num_classes", "\n", ")", "\n", "# Since the ROI feature transform is shared between boxes and masks,", "\n", "# we don't need to recompute features. The mask loss is only defined", "\n", "# on foreground proposals, so we need to select out the foreground", "\n", "# features.", "\n", "mask_features", "=", "box_features", "[", "torch", ".", "cat", "(", "fg_selection_masks", ",", "dim", "=", "0", ")", "]", "\n", "del", "box_features", "\n", "losses", ".", "update", "(", "self", ".", "mask_head", "(", "mask_features", ",", "proposals", ")", ")", "\n", "", "return", "[", "]", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", ",", "_", "=", "self", ".", "box_predictor", ".", "inference", "(", "predictions", ",", "proposals", ")", "\n", "pred_instances", "=", "self", ".", "forward_with_given_boxes", "(", "features", ",", "pred_instances", ")", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads.forward_with_given_boxes": [[500, 523], ["instances[].has", "instances[].has", "roi_heads.Res5ROIHeads._shared_roi_transform", "roi_heads.Res5ROIHeads.mask_head"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.Res5ROIHeads._shared_roi_transform"], ["", "", "def", "forward_with_given_boxes", "(", "self", ",", "features", ",", "instances", ")", ":", "\n", "        ", "\"\"\"\n        Use the given boxes in `instances` to produce other (non-box) per-ROI outputs.\n\n        Args:\n            features: same as in `forward()`\n            instances (list[Instances]): instances to predict other outputs. Expect the keys\n                \"pred_boxes\" and \"pred_classes\" to exist.\n\n        Returns:\n            instances (Instances):\n                the same `Instances` object, with extra\n                fields such as `pred_masks` or `pred_keypoints`.\n        \"\"\"", "\n", "assert", "not", "self", ".", "training", "\n", "assert", "instances", "[", "0", "]", ".", "has", "(", "\"pred_boxes\"", ")", "and", "instances", "[", "0", "]", ".", "has", "(", "\"pred_classes\"", ")", "\n", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "x", "=", "self", ".", "_shared_roi_transform", "(", "features", ",", "[", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", ")", "\n", "return", "self", ".", "mask_head", "(", "x", ",", "instances", ")", "\n", "", "else", ":", "\n", "            ", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads.__init__": [[538, 594], ["roi_heads.ROIHeads.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "box_in_features", ":", "List", "[", "str", "]", ",", "\n", "box_pooler", ":", "ROIPooler", ",", "\n", "box_head", ":", "nn", ".", "Module", ",", "\n", "box_predictor", ":", "nn", ".", "Module", ",", "\n", "mask_in_features", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "mask_pooler", ":", "Optional", "[", "ROIPooler", "]", "=", "None", ",", "\n", "mask_head", ":", "Optional", "[", "nn", ".", "Module", "]", "=", "None", ",", "\n", "keypoint_in_features", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "keypoint_pooler", ":", "Optional", "[", "ROIPooler", "]", "=", "None", ",", "\n", "keypoint_head", ":", "Optional", "[", "nn", ".", "Module", "]", "=", "None", ",", "\n", "train_on_pred_boxes", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            box_in_features (list[str]): list of feature names to use for the box head.\n            box_pooler (ROIPooler): pooler to extra region features for box head\n            box_head (nn.Module): transform features to make box predictions\n            box_predictor (nn.Module): make box predictions from the feature.\n                Should have the same interface as :class:`FastRCNNOutputLayers`.\n            mask_in_features (list[str]): list of feature names to use for the mask\n                pooler or mask head. None if not using mask head.\n            mask_pooler (ROIPooler): pooler to extract region features from image features.\n                The mask head will then take region features to make predictions.\n                If None, the mask head will directly take the dict of image features\n                defined by `mask_in_features`\n            mask_head (nn.Module): transform features to make mask predictions\n            keypoint_in_features, keypoint_pooler, keypoint_head: similar to ``mask_*``.\n            train_on_pred_boxes (bool): whether to use proposal boxes or\n                predicted boxes from the box head to train other heads.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "# keep self.in_features for backward compatibility", "\n", "self", ".", "in_features", "=", "self", ".", "box_in_features", "=", "box_in_features", "\n", "self", ".", "box_pooler", "=", "box_pooler", "\n", "self", ".", "box_head", "=", "box_head", "\n", "self", ".", "box_predictor", "=", "box_predictor", "\n", "\n", "self", ".", "mask_on", "=", "mask_in_features", "is", "not", "None", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "self", ".", "mask_in_features", "=", "mask_in_features", "\n", "self", ".", "mask_pooler", "=", "mask_pooler", "\n", "self", ".", "mask_head", "=", "mask_head", "\n", "", "self", ".", "keypoint_on", "=", "keypoint_in_features", "is", "not", "None", "\n", "if", "self", ".", "keypoint_on", ":", "\n", "            ", "self", ".", "keypoint_in_features", "=", "keypoint_in_features", "\n", "self", ".", "keypoint_pooler", "=", "keypoint_pooler", "\n", "self", ".", "keypoint_head", "=", "keypoint_head", "\n", "\n", "", "self", ".", "train_on_pred_boxes", "=", "train_on_pred_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads.from_config": [[595, 611], ["roi_heads.ROIHeads.from_config", "inspect.ismethod", "inspect.ismethod", "inspect.ismethod", "super().from_config.update", "super().from_config.update", "super().from_config.update", "cls._init_box_head", "cls._init_mask_head", "cls._init_keypoint_head"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.from_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._init_box_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._init_mask_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._init_keypoint_head"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ")", "\n", "ret", "[", "\"train_on_pred_boxes\"", "]", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "TRAIN_ON_PRED_BOXES", "\n", "# Subclasses that have not been updated to use from_config style construction", "\n", "# may have overridden _init_*_head methods. In this case, those overridden methods", "\n", "# will not be classmethods and we need to avoid trying to call them here.", "\n", "# We test for this with ismethod which only returns True for bound methods of cls.", "\n", "# Such subclasses will need to handle calling their overridden _init_*_head methods.", "\n", "if", "inspect", ".", "ismethod", "(", "cls", ".", "_init_box_head", ")", ":", "\n", "            ", "ret", ".", "update", "(", "cls", ".", "_init_box_head", "(", "cfg", ",", "input_shape", ")", ")", "\n", "", "if", "inspect", ".", "ismethod", "(", "cls", ".", "_init_mask_head", ")", ":", "\n", "            ", "ret", ".", "update", "(", "cls", ".", "_init_mask_head", "(", "cfg", ",", "input_shape", ")", ")", "\n", "", "if", "inspect", ".", "ismethod", "(", "cls", ".", "_init_keypoint_head", ")", ":", "\n", "            ", "ret", ".", "update", "(", "cls", ".", "_init_keypoint_head", "(", "cfg", ",", "input_shape", ")", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._init_box_head": [[612, 647], ["tuple", "poolers.ROIPooler", "box_head.build_box_head.build_box_head", "fast_rcnn.FastRCNNOutputLayers", "len", "detectron2.layers.ShapeSpec", "set"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.box_head.build_box_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "@", "classmethod", "\n", "def", "_init_box_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "\n", "# If StandardROIHeads is applied on multiple feature maps (as in FPN),", "\n", "# then we share the same predictors and therefore the channel counts must be the same", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "\n", "# Check all channel counts are equal", "\n", "assert", "len", "(", "set", "(", "in_channels", ")", ")", "==", "1", ",", "in_channels", "\n", "in_channels", "=", "in_channels", "[", "0", "]", "\n", "\n", "box_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "# Here we split \"box head\" and \"box predictor\", which is mainly due to historical reasons.", "\n", "# They are used together so the \"box predictor\" layers should be part of the \"box head\".", "\n", "# New subclasses of ROIHeads do not need \"box predictor\"s.", "\n", "box_head", "=", "build_box_head", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "in_channels", ",", "height", "=", "pooler_resolution", ",", "width", "=", "pooler_resolution", ")", "\n", ")", "\n", "box_predictor", "=", "FastRCNNOutputLayers", "(", "cfg", ",", "box_head", ".", "output_shape", ")", "\n", "return", "{", "\n", "\"box_in_features\"", ":", "in_features", ",", "\n", "\"box_pooler\"", ":", "box_pooler", ",", "\n", "\"box_head\"", ":", "box_head", ",", "\n", "\"box_predictor\"", ":", "box_predictor", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._init_mask_head": [[649, 682], ["tuple", "mask_head.build_mask_head", "poolers.ROIPooler", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.build_mask_head"], ["", "@", "classmethod", "\n", "def", "_init_mask_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "if", "not", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "            ", "return", "{", "}", "\n", "# fmt: off", "\n", "", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "[", "0", "]", "\n", "\n", "ret", "=", "{", "\"mask_in_features\"", ":", "in_features", "}", "\n", "ret", "[", "\"mask_pooler\"", "]", "=", "(", "\n", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "if", "pooler_type", "\n", "else", "None", "\n", ")", "\n", "if", "pooler_type", ":", "\n", "            ", "shape", "=", "ShapeSpec", "(", "\n", "channels", "=", "in_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", "\n", ")", "\n", "", "else", ":", "\n", "            ", "shape", "=", "{", "f", ":", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "}", "\n", "", "ret", "[", "\"mask_head\"", "]", "=", "build_mask_head", "(", "cfg", ",", "shape", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._init_keypoint_head": [[683, 716], ["tuple", "keypoint_head.build_keypoint_head", "poolers.ROIPooler", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.build_keypoint_head"], ["", "@", "classmethod", "\n", "def", "_init_keypoint_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "if", "not", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "return", "{", "}", "\n", "# fmt: off", "\n", "", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "# noqa", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "[", "0", "]", "\n", "\n", "ret", "=", "{", "\"keypoint_in_features\"", ":", "in_features", "}", "\n", "ret", "[", "\"keypoint_pooler\"", "]", "=", "(", "\n", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "if", "pooler_type", "\n", "else", "None", "\n", ")", "\n", "if", "pooler_type", ":", "\n", "            ", "shape", "=", "ShapeSpec", "(", "\n", "channels", "=", "in_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", "\n", ")", "\n", "", "else", ":", "\n", "            ", "shape", "=", "{", "f", ":", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "}", "\n", "", "ret", "[", "\"keypoint_head\"", "]", "=", "build_keypoint_head", "(", "cfg", ",", "shape", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads.forward": [[717, 747], ["roi_heads.StandardROIHeads.label_and_sample_proposals", "roi_heads.StandardROIHeads._forward_box", "roi_heads.StandardROIHeads.update", "roi_heads.StandardROIHeads.update", "roi_heads.StandardROIHeads._forward_box", "roi_heads.StandardROIHeads.forward_with_given_boxes", "roi_heads.StandardROIHeads._forward_mask", "roi_heads.StandardROIHeads._forward_keypoint"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads.label_and_sample_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._forward_keypoint"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "\n", "targets", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        See :class:`ROIHeads.forward`.\n        \"\"\"", "\n", "del", "images", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "targets", "\n", "proposals", "=", "self", ".", "label_and_sample_proposals", "(", "proposals", ",", "targets", ")", "\n", "", "del", "targets", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ")", "\n", "# Usually the original proposals used by the box head are used by the mask, keypoint", "\n", "# heads. But when `self.train_on_pred_boxes is True`, proposals will contain boxes", "\n", "# predicted by the box head.", "\n", "losses", ".", "update", "(", "self", ".", "_forward_mask", "(", "features", ",", "proposals", ")", ")", "\n", "losses", ".", "update", "(", "self", ".", "_forward_keypoint", "(", "features", ",", "proposals", ")", ")", "\n", "return", "proposals", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ")", "\n", "# During inference cascaded prediction is used: the mask and keypoints heads are only", "\n", "# applied to the top scoring box detections.", "\n", "pred_instances", "=", "self", ".", "forward_with_given_boxes", "(", "features", ",", "pred_instances", ")", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads.forward_with_given_boxes": [[748, 774], ["roi_heads.StandardROIHeads._forward_mask", "roi_heads.StandardROIHeads._forward_keypoint", "instances[].has", "instances[].has"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._forward_keypoint", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has"], ["", "", "def", "forward_with_given_boxes", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "List", "[", "Instances", "]", ":", "\n", "        ", "\"\"\"\n        Use the given boxes in `instances` to produce other (non-box) per-ROI outputs.\n\n        This is useful for downstream tasks where a box is known, but need to obtain\n        other attributes (outputs of other heads).\n        Test-time augmentation also uses this.\n\n        Args:\n            features: same as in `forward()`\n            instances (list[Instances]): instances to predict other outputs. Expect the keys\n                \"pred_boxes\" and \"pred_classes\" to exist.\n\n        Returns:\n            instances (list[Instances]):\n                the same `Instances` objects, with extra\n                fields such as `pred_masks` or `pred_keypoints`.\n        \"\"\"", "\n", "assert", "not", "self", ".", "training", "\n", "assert", "instances", "[", "0", "]", ".", "has", "(", "\"pred_boxes\"", ")", "and", "instances", "[", "0", "]", ".", "has", "(", "\"pred_classes\"", ")", "\n", "\n", "instances", "=", "self", ".", "_forward_mask", "(", "features", ",", "instances", ")", "\n", "instances", "=", "self", ".", "_forward_keypoint", "(", "features", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._forward_box": [[775, 814], ["roi_heads.StandardROIHeads.box_pooler", "roi_heads.StandardROIHeads.box_head", "roi_heads.StandardROIHeads.box_predictor", "roi_heads.StandardROIHeads.box_predictor.losses", "roi_heads.StandardROIHeads.box_predictor.inference", "torch.no_grad", "roi_heads.StandardROIHeads.box_predictor.predict_boxes_for_gt_classes", "zip", "detectron2.structures.Boxes"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes_for_gt_classes"], ["", "def", "_forward_box", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "proposals", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Union", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "List", "[", "Instances", "]", "]", ":", "\n", "        ", "\"\"\"\n        Forward logic of the box prediction branch. If `self.train_on_pred_boxes is True`,\n            the function puts predicted boxes in the `proposal_boxes` field of `proposals` argument.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            proposals (list[Instances]): the per-image object proposals with\n                their matching ground truth.\n                Each has fields \"proposal_boxes\", and \"objectness_logits\",\n                \"gt_classes\", \"gt_boxes\".\n\n        Returns:\n            In training, a dict of losses.\n            In inference, a list of `Instances`, the predicted instances.\n        \"\"\"", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "box_in_features", "]", "\n", "box_features", "=", "self", ".", "box_pooler", "(", "features", ",", "[", "x", ".", "proposal_boxes", "for", "x", "in", "proposals", "]", ")", "\n", "box_features", "=", "self", ".", "box_head", "(", "box_features", ")", "\n", "predictions", "=", "self", ".", "box_predictor", "(", "box_features", ")", "\n", "del", "box_features", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "self", ".", "box_predictor", ".", "losses", "(", "predictions", ",", "proposals", ")", "\n", "# proposals is modified in-place below, so losses must be computed first.", "\n", "if", "self", ".", "train_on_pred_boxes", ":", "\n", "                ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "pred_boxes", "=", "self", ".", "box_predictor", ".", "predict_boxes_for_gt_classes", "(", "\n", "predictions", ",", "proposals", "\n", ")", "\n", "for", "proposals_per_image", ",", "pred_boxes_per_image", "in", "zip", "(", "proposals", ",", "pred_boxes", ")", ":", "\n", "                        ", "proposals_per_image", ".", "proposal_boxes", "=", "Boxes", "(", "pred_boxes_per_image", ")", "\n", "", "", "", "return", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", ",", "_", "=", "self", ".", "box_predictor", ".", "inference", "(", "predictions", ",", "proposals", ")", "\n", "return", "pred_instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._forward_mask": [[815, 846], ["roi_heads.StandardROIHeads.mask_head", "roi_heads.select_foreground_proposals", "roi_heads.StandardROIHeads.mask_pooler"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.select_foreground_proposals"], ["", "", "def", "_forward_mask", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Union", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "List", "[", "Instances", "]", "]", ":", "\n", "        ", "\"\"\"\n        Forward logic of the mask prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            instances (list[Instances]): the per-image instances to train/predict masks.\n                In training, they can be the proposals.\n                In inference, they can be the boxes predicted by R-CNN box head.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"pred_masks\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "mask_on", ":", "\n", "            ", "return", "{", "}", "if", "self", ".", "training", "else", "instances", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "# head is only trained on positive proposals.", "\n", "            ", "instances", ",", "_", "=", "select_foreground_proposals", "(", "instances", ",", "self", ".", "num_classes", ")", "\n", "\n", "", "if", "self", ".", "mask_pooler", "is", "not", "None", ":", "\n", "            ", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "mask_in_features", "]", "\n", "boxes", "=", "[", "x", ".", "proposal_boxes", "if", "self", ".", "training", "else", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "features", "=", "self", ".", "mask_pooler", "(", "features", ",", "boxes", ")", "\n", "", "else", ":", "\n", "            ", "features", "=", "{", "f", ":", "features", "[", "f", "]", "for", "f", "in", "self", ".", "mask_in_features", "}", "\n", "", "return", "self", ".", "mask_head", "(", "features", ",", "instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._forward_keypoint": [[847, 879], ["roi_heads.StandardROIHeads.keypoint_head", "roi_heads.select_foreground_proposals", "roi_heads.select_proposals_with_visible_keypoints", "roi_heads.StandardROIHeads.keypoint_pooler"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.select_proposals_with_visible_keypoints"], ["", "def", "_forward_keypoint", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Union", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "List", "[", "Instances", "]", "]", ":", "\n", "        ", "\"\"\"\n        Forward logic of the keypoint prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            instances (list[Instances]): the per-image instances to train/predict keypoints.\n                In training, they can be the proposals.\n                In inference, they can be the boxes predicted by R-CNN box head.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"pred_keypoints\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "keypoint_on", ":", "\n", "            ", "return", "{", "}", "if", "self", ".", "training", "else", "instances", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "# head is only trained on positive proposals with >=1 visible keypoints.", "\n", "            ", "instances", ",", "_", "=", "select_foreground_proposals", "(", "instances", ",", "self", ".", "num_classes", ")", "\n", "instances", "=", "select_proposals_with_visible_keypoints", "(", "instances", ")", "\n", "\n", "", "if", "self", ".", "keypoint_pooler", "is", "not", "None", ":", "\n", "            ", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "keypoint_in_features", "]", "\n", "boxes", "=", "[", "x", ".", "proposal_boxes", "if", "self", ".", "training", "else", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "features", "=", "self", ".", "keypoint_pooler", "(", "features", ",", "boxes", ")", "\n", "", "else", ":", "\n", "            ", "features", "=", "{", "f", ":", "features", "[", "f", "]", "for", "f", "in", "self", ".", "keypoint_in_features", "}", "\n", "", "return", "self", ".", "keypoint_head", "(", "features", ",", "instances", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.build_roi_heads": [[43, 49], ["ROI_HEADS_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "build_roi_heads", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build ROIHeads defined by `cfg.MODEL.ROI_HEADS.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NAME", "\n", "return", "ROI_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.select_foreground_proposals": [[51, 81], ["isinstance", "isinstance", "proposals[].has", "fg_selection_mask.nonzero().squeeze", "fg_proposals.append", "fg_selection_masks.append", "fg_selection_mask.nonzero"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has"], ["", "def", "select_foreground_proposals", "(", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "bg_label", ":", "int", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "List", "[", "torch", ".", "Tensor", "]", "]", ":", "\n", "    ", "\"\"\"\n    Given a list of N Instances (for N images), each containing a `gt_classes` field,\n    return a list of Instances that contain only instances with `gt_classes != -1 &&\n    gt_classes != bg_label`.\n\n    Args:\n        proposals (list[Instances]): A list of N Instances, where N is the number of\n            images in the batch.\n        bg_label: label index of background class.\n\n    Returns:\n        list[Instances]: N Instances, each contains only the selected foreground instances.\n        list[Tensor]: N boolean vector, correspond to the selection mask of\n            each Instances object. True for selected instances.\n    \"\"\"", "\n", "assert", "isinstance", "(", "proposals", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "proposals", "[", "0", "]", ",", "Instances", ")", "\n", "assert", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_classes\"", ")", "\n", "fg_proposals", "=", "[", "]", "\n", "fg_selection_masks", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "        ", "gt_classes", "=", "proposals_per_image", ".", "gt_classes", "\n", "fg_selection_mask", "=", "(", "gt_classes", "!=", "-", "1", ")", "&", "(", "gt_classes", "!=", "bg_label", ")", "\n", "fg_idxs", "=", "fg_selection_mask", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "fg_proposals", ".", "append", "(", "proposals_per_image", "[", "fg_idxs", "]", ")", "\n", "fg_selection_masks", ".", "append", "(", "fg_selection_mask", ")", "\n", "", "return", "fg_proposals", ",", "fg_selection_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.select_proposals_with_visible_keypoints": [[83, 126], ["detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "proposals_per_image.proposal_boxes.tensor.unsqueeze", "all_num_fg.append", "ret.append", "numpy.mean", "len", "ret.append", "detectron2.layers.nonzero_tuple", "selection_idxs.numel"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.nonzero_tuple"], ["", "def", "select_proposals_with_visible_keypoints", "(", "proposals", ":", "List", "[", "Instances", "]", ")", "->", "List", "[", "Instances", "]", ":", "\n", "    ", "\"\"\"\n    Args:\n        proposals (list[Instances]): a list of N Instances, where N is the\n            number of images.\n\n    Returns:\n        proposals: only contains proposals with at least one visible keypoint.\n\n    Note that this is still slightly different from Detectron.\n    In Detectron, proposals for training keypoint head are re-sampled from\n    all the proposals with IOU>threshold & >=1 visible keypoint.\n\n    Here, the proposals are first sampled from all proposals with\n    IOU>threshold, then proposals with no visible keypoint are filtered out.\n    This strategy seems to make no difference on Detectron and is easier to implement.\n    \"\"\"", "\n", "ret", "=", "[", "]", "\n", "all_num_fg", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "# If empty/unannotated image (hard negatives), skip filtering for train", "\n", "        ", "if", "len", "(", "proposals_per_image", ")", "==", "0", ":", "\n", "            ", "ret", ".", "append", "(", "proposals_per_image", ")", "\n", "continue", "\n", "", "gt_keypoints", "=", "proposals_per_image", ".", "gt_keypoints", ".", "tensor", "\n", "# #fg x K x 3", "\n", "vis_mask", "=", "gt_keypoints", "[", ":", ",", ":", ",", "2", "]", ">=", "1", "\n", "xs", ",", "ys", "=", "gt_keypoints", "[", ":", ",", ":", ",", "0", "]", ",", "gt_keypoints", "[", ":", ",", ":", ",", "1", "]", "\n", "proposal_boxes", "=", "proposals_per_image", ".", "proposal_boxes", ".", "tensor", ".", "unsqueeze", "(", "dim", "=", "1", ")", "# #fg x 1 x 4", "\n", "kp_in_box", "=", "(", "\n", "(", "xs", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "&", "(", "xs", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "2", "]", ")", "\n", "&", "(", "ys", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "1", "]", ")", "\n", "&", "(", "ys", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "3", "]", ")", "\n", ")", "\n", "selection", "=", "(", "kp_in_box", "&", "vis_mask", ")", ".", "any", "(", "dim", "=", "1", ")", "\n", "selection_idxs", "=", "nonzero_tuple", "(", "selection", ")", "[", "0", "]", "\n", "all_num_fg", ".", "append", "(", "selection_idxs", ".", "numel", "(", ")", ")", "\n", "ret", ".", "append", "(", "proposals_per_image", "[", "selection_idxs", "]", ")", "\n", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"keypoint_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "all_num_fg", ")", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.BaseKeypointRCNNHead.__init__": [[144, 162], ["torch.nn.Module.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "*", ",", "num_keypoints", ",", "loss_weight", "=", "1.0", ",", "loss_normalizer", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            num_keypoints (int): number of keypoints to predict\n            loss_weight (float): weight to multiple on the keypoint loss\n            loss_normalizer (float or str):\n                If float, divide the loss by `loss_normalizer * #images`.\n                If 'visible', the loss is normalized by the total number of\n                visible keypoints across images.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_keypoints", "=", "num_keypoints", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "assert", "loss_normalizer", "==", "\"visible\"", "or", "isinstance", "(", "loss_normalizer", ",", "float", ")", ",", "loss_normalizer", "\n", "self", ".", "loss_normalizer", "=", "loss_normalizer", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.BaseKeypointRCNNHead.from_config": [[163, 181], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "{", "\n", "\"loss_weight\"", ":", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "LOSS_WEIGHT", ",", "\n", "\"num_keypoints\"", ":", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NUM_KEYPOINTS", ",", "\n", "}", "\n", "normalize_by_visible", "=", "(", "\n", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NORMALIZE_LOSS_BY_VISIBLE_KEYPOINTS", "\n", ")", "# noqa", "\n", "if", "not", "normalize_by_visible", ":", "\n", "            ", "batch_size_per_image", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "BATCH_SIZE_PER_IMAGE", "\n", "positive_sample_fraction", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "POSITIVE_FRACTION", "\n", "ret", "[", "\"loss_normalizer\"", "]", "=", "(", "\n", "ret", "[", "\"num_keypoints\"", "]", "*", "batch_size_per_image", "*", "positive_sample_fraction", "\n", ")", "\n", "", "else", ":", "\n", "            ", "ret", "[", "\"loss_normalizer\"", "]", "=", "\"visible\"", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.BaseKeypointRCNNHead.forward": [[182, 210], ["keypoint_head.BaseKeypointRCNNHead.layers", "len", "keypoint_head.keypoint_rcnn_inference", "torch.jit.is_scripting", "keypoint_head.keypoint_rcnn_loss"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.keypoint_rcnn_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.keypoint_rcnn_loss"], ["", "def", "forward", "(", "self", ",", "x", ",", "instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: input region feature(s) provided by :class:`ROIHeads`.\n            instances (list[Instances]): contains the boxes & labels corresponding\n                to the input features.\n                Exact format is up to its caller to decide.\n                Typically, this is the foreground instances in training, with\n                \"proposal_boxes\" field and other gt annotations.\n                In inference, it contains boxes that are already predicted.\n\n        Returns:\n            A dict of losses if in training. The predicted \"instances\" if in inference.\n        \"\"\"", "\n", "x", "=", "self", ".", "layers", "(", "x", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "not", "torch", ".", "jit", ".", "is_scripting", "(", ")", "\n", "num_images", "=", "len", "(", "instances", ")", "\n", "normalizer", "=", "(", "\n", "None", "if", "self", ".", "loss_normalizer", "==", "\"visible\"", "else", "num_images", "*", "self", ".", "loss_normalizer", "\n", ")", "\n", "return", "{", "\n", "\"loss_keypoint\"", ":", "keypoint_rcnn_loss", "(", "x", ",", "instances", ",", "normalizer", "=", "normalizer", ")", "\n", "*", "self", ".", "loss_weight", "\n", "}", "\n", "", "else", ":", "\n", "            ", "keypoint_rcnn_inference", "(", "x", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.BaseKeypointRCNNHead.layers": [[211, 216], ["None"], "methods", ["None"], ["", "", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Neural network layers that makes predictions from regional input features.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.KRCNNConvDeconvUpsampleHead.__init__": [[229, 264], ["super().__init__", "enumerate", "detectron2.layers.ConvTranspose2d", "keypoint_head.KRCNNConvDeconvUpsampleHead.named_parameters", "detectron2.layers.Conv2d", "keypoint_head.KRCNNConvDeconvUpsampleHead.add_module", "keypoint_head.KRCNNConvDeconvUpsampleHead.add_module", "torch.nn.ReLU", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ",", "*", ",", "num_keypoints", ",", "conv_dims", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature\n            conv_dims: an iterable of output channel counts for each conv in the head\n                         e.g. (512, 512, 512) for three convs outputting 512 channels.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "num_keypoints", "=", "num_keypoints", ",", "**", "kwargs", ")", "\n", "\n", "# default up_scale to 2.0 (this can be made an option)", "\n", "up_scale", "=", "2.0", "\n", "in_channels", "=", "input_shape", ".", "channels", "\n", "\n", "for", "idx", ",", "layer_channels", "in", "enumerate", "(", "conv_dims", ",", "1", ")", ":", "\n", "            ", "module", "=", "Conv2d", "(", "in_channels", ",", "layer_channels", ",", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "add_module", "(", "\"conv_fcn{}\"", ".", "format", "(", "idx", ")", ",", "module", ")", "\n", "self", ".", "add_module", "(", "\"conv_fcn_relu{}\"", ".", "format", "(", "idx", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "in_channels", "=", "layer_channels", "\n", "\n", "", "deconv_kernel", "=", "4", "\n", "self", ".", "score_lowres", "=", "ConvTranspose2d", "(", "\n", "in_channels", ",", "num_keypoints", ",", "deconv_kernel", ",", "stride", "=", "2", ",", "padding", "=", "deconv_kernel", "//", "2", "-", "1", "\n", ")", "\n", "self", ".", "up_scale", "=", "up_scale", "\n", "\n", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "\"bias\"", "in", "name", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n", "# Caffe2 implementation uses MSRAFill, which in fact", "\n", "# corresponds to kaiming_normal_ in PyTorch", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "param", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.KRCNNConvDeconvUpsampleHead.from_config": [[265, 271], ["super().from_config"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.from_config"], ["", "", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "ret", "[", "\"input_shape\"", "]", "=", "input_shape", "\n", "ret", "[", "\"conv_dims\"", "]", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "CONV_DIMS", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.KRCNNConvDeconvUpsampleHead.layers": [[272, 277], ["detectron2.layers.interpolate", "layer"], "methods", ["None"], ["", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "layer", "in", "self", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "interpolate", "(", "x", ",", "scale_factor", "=", "self", ".", "up_scale", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.build_keypoint_head": [[32, 38], ["ROI_KEYPOINT_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "build_keypoint_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a keypoint head from `cfg.MODEL.ROI_KEYPOINT_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NAME", "\n", "return", "ROI_KEYPOINT_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.keypoint_rcnn_loss": [[40, 97], ["len", "pred_keypoint_logits.view.view", "torch.nn.functional.cross_entropy", "keypoints.to_heatmap", "heatmaps.append", "torch.nonzero().squeeze.append", "detectron2.layers.cat", "detectron2.layers.cat().to", "torch.nonzero().squeeze", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "torch.nonzero().squeeze.numel", "len", "heatmaps_per_image.view", "valid_per_image.view", "len", "torch.nonzero().squeeze.numel", "pred_keypoint_logits.view.sum", "detectron2.layers.cat", "torch.nonzero"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.Keypoints.to_heatmap", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "keypoint_rcnn_loss", "(", "pred_keypoint_logits", ",", "instances", ",", "normalizer", ")", ":", "\n", "    ", "\"\"\"\n    Arguments:\n        pred_keypoint_logits (Tensor): A tensor of shape (N, K, S, S) where N is the total number\n            of instances in the batch, K is the number of keypoints, and S is the side length\n            of the keypoint heatmap. The values are spatial logits.\n        instances (list[Instances]): A list of M Instances, where M is the batch size.\n            These instances are predictions from the model\n            that are in 1:1 correspondence with pred_keypoint_logits.\n            Each Instances should contain a `gt_keypoints` field containing a `structures.Keypoint`\n            instance.\n        normalizer (float): Normalize the loss by this amount.\n            If not specified, we normalize by the number of visible keypoints in the minibatch.\n\n    Returns a scalar tensor containing the loss.\n    \"\"\"", "\n", "heatmaps", "=", "[", "]", "\n", "valid", "=", "[", "]", "\n", "\n", "keypoint_side_len", "=", "pred_keypoint_logits", ".", "shape", "[", "2", "]", "\n", "for", "instances_per_image", "in", "instances", ":", "\n", "        ", "if", "len", "(", "instances_per_image", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "keypoints", "=", "instances_per_image", ".", "gt_keypoints", "\n", "heatmaps_per_image", ",", "valid_per_image", "=", "keypoints", ".", "to_heatmap", "(", "\n", "instances_per_image", ".", "proposal_boxes", ".", "tensor", ",", "keypoint_side_len", "\n", ")", "\n", "heatmaps", ".", "append", "(", "heatmaps_per_image", ".", "view", "(", "-", "1", ")", ")", "\n", "valid", ".", "append", "(", "valid_per_image", ".", "view", "(", "-", "1", ")", ")", "\n", "\n", "", "if", "len", "(", "heatmaps", ")", ":", "\n", "        ", "keypoint_targets", "=", "cat", "(", "heatmaps", ",", "dim", "=", "0", ")", "\n", "valid", "=", "cat", "(", "valid", ",", "dim", "=", "0", ")", ".", "to", "(", "dtype", "=", "torch", ".", "uint8", ")", "\n", "valid", "=", "torch", ".", "nonzero", "(", "valid", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "# torch.mean (in binary_cross_entropy_with_logits) doesn't", "\n", "# accept empty tensors, so handle it separately", "\n", "", "if", "len", "(", "heatmaps", ")", "==", "0", "or", "valid", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "global", "_TOTAL_SKIPPED", "\n", "_TOTAL_SKIPPED", "+=", "1", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"kpts_num_skipped_batches\"", ",", "_TOTAL_SKIPPED", ",", "smoothing_hint", "=", "False", ")", "\n", "return", "pred_keypoint_logits", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "N", ",", "K", ",", "H", ",", "W", "=", "pred_keypoint_logits", ".", "shape", "\n", "pred_keypoint_logits", "=", "pred_keypoint_logits", ".", "view", "(", "N", "*", "K", ",", "H", "*", "W", ")", "\n", "\n", "keypoint_loss", "=", "F", ".", "cross_entropy", "(", "\n", "pred_keypoint_logits", "[", "valid", "]", ",", "keypoint_targets", "[", "valid", "]", ",", "reduction", "=", "\"sum\"", "\n", ")", "\n", "\n", "# If a normalizer isn't specified, normalize by the number of visible keypoints in the minibatch", "\n", "if", "normalizer", "is", "None", ":", "\n", "        ", "normalizer", "=", "valid", ".", "numel", "(", ")", "\n", "", "keypoint_loss", "/=", "normalizer", "\n", "\n", "return", "keypoint_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.keypoint_rcnn_inference": [[99, 136], ["detectron2.layers.cat", "pred_keypoint_logits.detach.detach", "detectron2.structures.heatmaps_to_keypoints", "torch.tensor", "keypoint_results[].split", "pred_keypoint_logits.detach.split", "zip", "detectron2.layers.cat.detach", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.heatmaps_to_keypoints"], ["", "def", "keypoint_rcnn_inference", "(", "pred_keypoint_logits", ":", "torch", ".", "Tensor", ",", "pred_instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "    ", "\"\"\"\n    Post process each predicted keypoint heatmap in `pred_keypoint_logits` into (x, y, score)\n        and add it to the `pred_instances` as a `pred_keypoints` field.\n\n    Args:\n        pred_keypoint_logits (Tensor): A tensor of shape (R, K, S, S) where R is the total number\n           of instances in the batch, K is the number of keypoints, and S is the side length of\n           the keypoint heatmap. The values are spatial logits.\n        pred_instances (list[Instances]): A list of N Instances, where N is the number of images.\n\n    Returns:\n        None. Each element in pred_instances will contain extra \"pred_keypoints\" and\n            \"pred_keypoint_heatmaps\" fields. \"pred_keypoints\" is a tensor of shape\n            (#instance, K, 3) where the last dimension corresponds to (x, y, score).\n            The scores are larger than 0. \"pred_keypoint_heatmaps\" contains the raw\n            keypoint logits as passed to this function.\n    \"\"\"", "\n", "# flatten all bboxes from all images together (list[Boxes] -> Rx4 tensor)", "\n", "bboxes_flat", "=", "cat", "(", "[", "b", ".", "pred_boxes", ".", "tensor", "for", "b", "in", "pred_instances", "]", ",", "dim", "=", "0", ")", "\n", "\n", "pred_keypoint_logits", "=", "pred_keypoint_logits", ".", "detach", "(", ")", "\n", "keypoint_results", "=", "heatmaps_to_keypoints", "(", "pred_keypoint_logits", ",", "bboxes_flat", ".", "detach", "(", ")", ")", "\n", "num_instances_per_image", "=", "[", "len", "(", "i", ")", "for", "i", "in", "pred_instances", "]", "\n", "# slicing multiple dimensions with sequences is not supported by torchscript", "\n", "# https://github.com/pytorch/pytorch/issues/43943", "\n", "idx", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", ",", "3", "]", ")", "\n", "keypoint_results", "=", "keypoint_results", "[", ":", ",", ":", ",", "idx", "]", ".", "split", "(", "num_instances_per_image", ",", "dim", "=", "0", ")", "\n", "heatmap_results", "=", "pred_keypoint_logits", ".", "split", "(", "num_instances_per_image", ",", "dim", "=", "0", ")", "\n", "\n", "for", "keypoint_results_per_image", ",", "heatmap_results_per_image", ",", "instances_per_image", "in", "zip", "(", "\n", "keypoint_results", ",", "heatmap_results", ",", "pred_instances", "\n", ")", ":", "\n", "# keypoint_results_per_image is (num instances)x(num keypoints)x(x, y, score)", "\n", "# heatmap_results_per_image is (num instances)x(num keypoints)x(side)x(side)", "\n", "        ", "instances_per_image", ".", "pred_keypoints", "=", "keypoint_results_per_image", "\n", "instances_per_image", ".", "pred_keypoint_heatmaps", "=", "heatmap_results_per_image", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.box_head.FastRCNNConvFCHead.__init__": [[33, 81], ["torch.nn.Sequential.__init__", "enumerate", "enumerate", "detectron2.layers.Conv2d", "box_head.FastRCNNConvFCHead.add_module", "box_head.FastRCNNConvFCHead.conv_norm_relus.append", "detectron2.layers.Linear", "box_head.FastRCNNConvFCHead.add_module", "box_head.FastRCNNConvFCHead.add_module", "box_head.FastRCNNConvFCHead.fcs.append", "fvcore.c2_msra_fill", "fvcore.c2_xavier_fill", "len", "len", "box_head.FastRCNNConvFCHead.add_module", "int", "torch.nn.ReLU", "detectron2.layers.get_norm", "torch.nn.ReLU", "torch.nn.Flatten", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "input_shape", ":", "ShapeSpec", ",", "*", ",", "conv_dims", ":", "List", "[", "int", "]", ",", "fc_dims", ":", "List", "[", "int", "]", ",", "conv_norm", "=", "\"\"", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature.\n            conv_dims (list[int]): the output dimensions of the conv layers\n            fc_dims (list[int]): the output dimensions of the fc layers\n            conv_norm (str or callable): normalization for the conv layers.\n                See :func:`detectron2.layers.get_norm` for supported types.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "len", "(", "conv_dims", ")", "+", "len", "(", "fc_dims", ")", ">", "0", "\n", "\n", "self", ".", "_output_size", "=", "(", "input_shape", ".", "channels", ",", "input_shape", ".", "height", ",", "input_shape", ".", "width", ")", "\n", "\n", "self", ".", "conv_norm_relus", "=", "[", "]", "\n", "for", "k", ",", "conv_dim", "in", "enumerate", "(", "conv_dims", ")", ":", "\n", "            ", "conv", "=", "Conv2d", "(", "\n", "self", ".", "_output_size", "[", "0", "]", ",", "\n", "conv_dim", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "conv_norm", ",", "\n", "norm", "=", "get_norm", "(", "conv_norm", ",", "conv_dim", ")", ",", "\n", "activation", "=", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "self", ".", "add_module", "(", "\"conv{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_norm_relus", ".", "append", "(", "conv", ")", "\n", "self", ".", "_output_size", "=", "(", "conv_dim", ",", "self", ".", "_output_size", "[", "1", "]", ",", "self", ".", "_output_size", "[", "2", "]", ")", "\n", "\n", "", "self", ".", "fcs", "=", "[", "]", "\n", "for", "k", ",", "fc_dim", "in", "enumerate", "(", "fc_dims", ")", ":", "\n", "            ", "if", "k", "==", "0", ":", "\n", "                ", "self", ".", "add_module", "(", "\"flatten\"", ",", "nn", ".", "Flatten", "(", ")", ")", "\n", "", "fc", "=", "Linear", "(", "int", "(", "np", ".", "prod", "(", "self", ".", "_output_size", ")", ")", ",", "fc_dim", ")", "\n", "self", ".", "add_module", "(", "\"fc{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "fc", ")", "\n", "self", ".", "add_module", "(", "\"fc_relu{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "self", ".", "fcs", ".", "append", "(", "fc", ")", "\n", "self", ".", "_output_size", "=", "fc_dim", "\n", "\n", "", "for", "layer", "in", "self", ".", "conv_norm_relus", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "", "for", "layer", "in", "self", ".", "fcs", ":", "\n", "            ", "weight_init", ".", "c2_xavier_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.box_head.FastRCNNConvFCHead.from_config": [[82, 93], ["None"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "num_conv", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CONV", "\n", "conv_dim", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CONV_DIM", "\n", "num_fc", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_FC", "\n", "fc_dim", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "FC_DIM", "\n", "return", "{", "\n", "\"input_shape\"", ":", "input_shape", ",", "\n", "\"conv_dims\"", ":", "[", "conv_dim", "]", "*", "num_conv", ",", "\n", "\"fc_dims\"", ":", "[", "fc_dim", "]", "*", "num_fc", ",", "\n", "\"conv_norm\"", ":", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NORM", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.box_head.FastRCNNConvFCHead.forward": [[95, 99], ["layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "layer", "in", "self", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.box_head.FastRCNNConvFCHead.output_shape": [[100, 111], ["isinstance", "detectron2.layers.ShapeSpec", "detectron2.layers.ShapeSpec"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            ShapeSpec: the output feature shape\n        \"\"\"", "\n", "o", "=", "self", ".", "_output_size", "\n", "if", "isinstance", "(", "o", ",", "int", ")", ":", "\n", "            ", "return", "ShapeSpec", "(", "channels", "=", "o", ")", "\n", "", "else", ":", "\n", "            ", "return", "ShapeSpec", "(", "channels", "=", "o", "[", "0", "]", ",", "height", "=", "o", "[", "1", "]", ",", "width", "=", "o", "[", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.box_head.build_box_head": [[113, 119], ["ROI_BOX_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "", "def", "build_box_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a box head defined by `cfg.MODEL.ROI_BOX_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NAME", "\n", "return", "ROI_BOX_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn._ScaleGradient.forward": [[21, 25], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ",", "scale", ")", ":", "\n", "        ", "ctx", ".", "scale", "=", "scale", "\n", "return", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn._ScaleGradient.backward": [[26, 29], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "return", "grad_output", "*", "ctx", ".", "scale", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads.__init__": [[37, 79], ["len", "torch.nn.ModuleList", "torch.nn.ModuleList", "roi_heads.StandardROIHeads.__init__", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "box_in_features", ":", "List", "[", "str", "]", ",", "\n", "box_pooler", ":", "ROIPooler", ",", "\n", "box_heads", ":", "List", "[", "nn", ".", "Module", "]", ",", "\n", "box_predictors", ":", "List", "[", "nn", ".", "Module", "]", ",", "\n", "proposal_matchers", ":", "List", "[", "Matcher", "]", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            box_pooler (ROIPooler): pooler that extracts region features from given boxes\n            box_heads (list[nn.Module]): box head for each cascade stage\n            box_predictors (list[nn.Module]): box predictor for each cascade stage\n            proposal_matchers (list[Matcher]): matcher with different IoU thresholds to\n                match boxes with ground truth for each stage. The first matcher matches\n                RPN proposals with ground truth, the other matchers use boxes predicted\n                by the previous stage as proposals and match them with ground truth.\n        \"\"\"", "\n", "assert", "\"proposal_matcher\"", "not", "in", "kwargs", ",", "(", "\n", "\"CascadeROIHeads takes 'proposal_matchers=' for each stage instead \"", "\n", "\"of one 'proposal_matcher='.\"", "\n", ")", "\n", "# The first matcher matches RPN proposals with ground truth, done in the base class", "\n", "kwargs", "[", "\"proposal_matcher\"", "]", "=", "proposal_matchers", "[", "0", "]", "\n", "num_stages", "=", "self", ".", "num_cascade_stages", "=", "len", "(", "box_heads", ")", "\n", "box_heads", "=", "nn", ".", "ModuleList", "(", "box_heads", ")", "\n", "box_predictors", "=", "nn", ".", "ModuleList", "(", "box_predictors", ")", "\n", "assert", "len", "(", "box_predictors", ")", "==", "num_stages", ",", "f\"{len(box_predictors)} != {num_stages}!\"", "\n", "assert", "len", "(", "proposal_matchers", ")", "==", "num_stages", ",", "f\"{len(proposal_matchers)} != {num_stages}!\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "box_in_features", "=", "box_in_features", ",", "\n", "box_pooler", "=", "box_pooler", ",", "\n", "box_head", "=", "box_heads", ",", "\n", "box_predictor", "=", "box_predictors", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "proposal_matchers", "=", "proposal_matchers", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads.from_config": [[80, 85], ["super().from_config", "super().from_config.pop"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.from_config"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "ret", ".", "pop", "(", "\"proposal_matcher\"", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._init_box_head": [[86, 135], ["tuple", "poolers.ROIPooler", "detectron2.layers.ShapeSpec", "zip", "len", "len", "len", "box_head.build_box_head.build_box_head", "box_heads.append", "box_predictors.append", "proposal_matchers.append", "set", "fast_rcnn.FastRCNNOutputLayers", "matcher.Matcher", "box_regression.Box2BoxTransform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.box_head.build_box_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "@", "classmethod", "\n", "def", "_init_box_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "\n", "cascade_bbox_reg_weights", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_CASCADE_HEAD", ".", "BBOX_REG_WEIGHTS", "\n", "cascade_ious", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_CASCADE_HEAD", ".", "IOUS", "\n", "assert", "len", "(", "cascade_bbox_reg_weights", ")", "==", "len", "(", "cascade_ious", ")", "\n", "assert", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CLS_AGNOSTIC_BBOX_REG", ",", "\"CascadeROIHeads only support class-agnostic regression now!\"", "\n", "assert", "cascade_ious", "[", "0", "]", "==", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_THRESHOLDS", "[", "0", "]", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "\n", "# Check all channel counts are equal", "\n", "assert", "len", "(", "set", "(", "in_channels", ")", ")", "==", "1", ",", "in_channels", "\n", "in_channels", "=", "in_channels", "[", "0", "]", "\n", "\n", "box_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "pooled_shape", "=", "ShapeSpec", "(", "\n", "channels", "=", "in_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", "\n", ")", "\n", "\n", "box_heads", ",", "box_predictors", ",", "proposal_matchers", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "match_iou", ",", "bbox_reg_weights", "in", "zip", "(", "cascade_ious", ",", "cascade_bbox_reg_weights", ")", ":", "\n", "            ", "box_head", "=", "build_box_head", "(", "cfg", ",", "pooled_shape", ")", "\n", "box_heads", ".", "append", "(", "box_head", ")", "\n", "box_predictors", ".", "append", "(", "\n", "FastRCNNOutputLayers", "(", "\n", "cfg", ",", "\n", "box_head", ".", "output_shape", ",", "\n", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "bbox_reg_weights", ")", ",", "\n", ")", "\n", ")", "\n", "proposal_matchers", ".", "append", "(", "Matcher", "(", "[", "match_iou", "]", ",", "[", "0", ",", "1", "]", ",", "allow_low_quality_matches", "=", "False", ")", ")", "\n", "", "return", "{", "\n", "\"box_in_features\"", ":", "in_features", ",", "\n", "\"box_pooler\"", ":", "box_pooler", ",", "\n", "\"box_heads\"", ":", "box_heads", ",", "\n", "\"box_predictors\"", ":", "box_predictors", ",", "\n", "\"proposal_matchers\"", ":", "proposal_matchers", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads.forward": [[137, 152], ["cascade_rcnn.CascadeROIHeads.label_and_sample_proposals", "cascade_rcnn.CascadeROIHeads._forward_box", "cascade_rcnn.CascadeROIHeads.update", "cascade_rcnn.CascadeROIHeads.update", "cascade_rcnn.CascadeROIHeads._forward_box", "cascade_rcnn.CascadeROIHeads.forward_with_given_boxes", "cascade_rcnn.CascadeROIHeads._forward_mask", "cascade_rcnn.CascadeROIHeads._forward_keypoint"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.ROIHeads.label_and_sample_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.StandardROIHeads._forward_keypoint"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "del", "images", "\n", "if", "self", ".", "training", ":", "\n", "            ", "proposals", "=", "self", ".", "label_and_sample_proposals", "(", "proposals", ",", "targets", ")", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "# Need targets to box head", "\n", "            ", "losses", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ",", "targets", ")", "\n", "losses", ".", "update", "(", "self", ".", "_forward_mask", "(", "features", ",", "proposals", ")", ")", "\n", "losses", ".", "update", "(", "self", ".", "_forward_keypoint", "(", "features", ",", "proposals", ")", ")", "\n", "return", "proposals", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ")", "\n", "pred_instances", "=", "self", ".", "forward_with_given_boxes", "(", "features", ",", "pred_instances", ")", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._forward_box": [[153, 207], ["range", "cascade_rcnn.CascadeROIHeads._run_stage", "cascade_rcnn.CascadeROIHeads.box_predictor[].predict_boxes", "head_outputs.append", "detectron2.utils.events.get_event_storage", "enumerate", "predictor.predict_boxes", "fast_rcnn.fast_rcnn_inference", "cascade_rcnn.CascadeROIHeads._create_proposals_from_boxes", "losses.update", "h[].predict_probs", "cascade_rcnn.CascadeROIHeads._match_and_label_boxes", "detectron2.utils.events.get_event_storage.name_scope", "predictor.losses", "sum", "zip", "list", "predictor.losses.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._run_stage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.fast_rcnn_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._create_proposals_from_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.FastRCNNOutputLayers.predict_probs", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._match_and_label_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.name_scope", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "", "def", "_forward_box", "(", "self", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features, targets: the same as in\n                Same as in :meth:`ROIHeads.forward`.\n            proposals (list[Instances]): the per-image object proposals with\n                their matching ground truth.\n                Each has fields \"proposal_boxes\", and \"objectness_logits\",\n                \"gt_classes\", \"gt_boxes\".\n        \"\"\"", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "box_in_features", "]", "\n", "head_outputs", "=", "[", "]", "# (predictor, predictions, proposals)", "\n", "prev_pred_boxes", "=", "None", "\n", "image_sizes", "=", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "\n", "for", "k", "in", "range", "(", "self", ".", "num_cascade_stages", ")", ":", "\n", "            ", "if", "k", ">", "0", ":", "\n", "# The output boxes of the previous stage are used to create the input", "\n", "# proposals of the next stage.", "\n", "                ", "proposals", "=", "self", ".", "_create_proposals_from_boxes", "(", "prev_pred_boxes", ",", "image_sizes", ")", "\n", "if", "self", ".", "training", ":", "\n", "                    ", "proposals", "=", "self", ".", "_match_and_label_boxes", "(", "proposals", ",", "k", ",", "targets", ")", "\n", "", "", "predictions", "=", "self", ".", "_run_stage", "(", "features", ",", "proposals", ",", "k", ")", "\n", "prev_pred_boxes", "=", "self", ".", "box_predictor", "[", "k", "]", ".", "predict_boxes", "(", "predictions", ",", "proposals", ")", "\n", "head_outputs", ".", "append", "(", "(", "self", ".", "box_predictor", "[", "k", "]", ",", "predictions", ",", "proposals", ")", ")", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "{", "}", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "for", "stage", ",", "(", "predictor", ",", "predictions", ",", "proposals", ")", "in", "enumerate", "(", "head_outputs", ")", ":", "\n", "                ", "with", "storage", ".", "name_scope", "(", "\"stage{}\"", ".", "format", "(", "stage", ")", ")", ":", "\n", "                    ", "stage_losses", "=", "predictor", ".", "losses", "(", "predictions", ",", "proposals", ")", "\n", "", "losses", ".", "update", "(", "{", "k", "+", "\"_stage{}\"", ".", "format", "(", "stage", ")", ":", "v", "for", "k", ",", "v", "in", "stage_losses", ".", "items", "(", ")", "}", ")", "\n", "", "return", "losses", "\n", "", "else", ":", "\n", "# Each is a list[Tensor] of length #image. Each tensor is Ri x (K+1)", "\n", "            ", "scores_per_stage", "=", "[", "h", "[", "0", "]", ".", "predict_probs", "(", "h", "[", "1", "]", ",", "h", "[", "2", "]", ")", "for", "h", "in", "head_outputs", "]", "\n", "\n", "# Average the scores across heads", "\n", "scores", "=", "[", "\n", "sum", "(", "list", "(", "scores_per_image", ")", ")", "*", "(", "1.0", "/", "self", ".", "num_cascade_stages", ")", "\n", "for", "scores_per_image", "in", "zip", "(", "*", "scores_per_stage", ")", "\n", "]", "\n", "# Use the boxes of the last head", "\n", "predictor", ",", "predictions", ",", "proposals", "=", "head_outputs", "[", "-", "1", "]", "\n", "boxes", "=", "predictor", ".", "predict_boxes", "(", "predictions", ",", "proposals", ")", "\n", "pred_instances", ",", "_", "=", "fast_rcnn_inference", "(", "\n", "boxes", ",", "\n", "scores", ",", "\n", "image_sizes", ",", "\n", "predictor", ".", "test_score_thresh", ",", "\n", "predictor", ".", "test_nms_thresh", ",", "\n", "predictor", ".", "test_topk_per_image", ",", "\n", ")", "\n", "return", "pred_instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._match_and_label_boxes": [[208, 257], ["torch.no_grad", "zip", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.structures.pairwise_iou", "num_fg_samples.append", "num_bg_samples.append", "len", "detectron2.structures.Boxes", "sum", "len", "sum", "len", "torch.zeros_like", "targets_per_image.gt_boxes.tensor.new_zeros", "proposal_labels.numel", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_match_and_label_boxes", "(", "self", ",", "proposals", ",", "stage", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Match proposals with groundtruth using the matcher at the given stage.\n        Label the proposals as foreground or background based on the match.\n\n        Args:\n            proposals (list[Instances]): One Instances for each image, with\n                the field \"proposal_boxes\".\n            stage (int): the current stage\n            targets (list[Instances]): the ground truth instances\n\n        Returns:\n            list[Instances]: the same proposals, but with fields \"gt_classes\" and \"gt_boxes\"\n        \"\"\"", "\n", "num_fg_samples", ",", "num_bg_samples", "=", "[", "]", ",", "[", "]", "\n", "for", "proposals_per_image", ",", "targets_per_image", "in", "zip", "(", "proposals", ",", "targets", ")", ":", "\n", "            ", "match_quality_matrix", "=", "pairwise_iou", "(", "\n", "targets_per_image", ".", "gt_boxes", ",", "proposals_per_image", ".", "proposal_boxes", "\n", ")", "\n", "# proposal_labels are 0 or 1", "\n", "matched_idxs", ",", "proposal_labels", "=", "self", ".", "proposal_matchers", "[", "stage", "]", "(", "match_quality_matrix", ")", "\n", "if", "len", "(", "targets_per_image", ")", ">", "0", ":", "\n", "                ", "gt_classes", "=", "targets_per_image", ".", "gt_classes", "[", "matched_idxs", "]", "\n", "# Label unmatched proposals (0 label from matcher) as background (label=num_classes)", "\n", "gt_classes", "[", "proposal_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "gt_boxes", "=", "targets_per_image", ".", "gt_boxes", "[", "matched_idxs", "]", "\n", "", "else", ":", "\n", "                ", "gt_classes", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "gt_boxes", "=", "Boxes", "(", "\n", "targets_per_image", ".", "gt_boxes", ".", "tensor", ".", "new_zeros", "(", "(", "len", "(", "proposals_per_image", ")", ",", "4", ")", ")", "\n", ")", "\n", "", "proposals_per_image", ".", "gt_classes", "=", "gt_classes", "\n", "proposals_per_image", ".", "gt_boxes", "=", "gt_boxes", "\n", "\n", "num_fg_samples", ".", "append", "(", "(", "proposal_labels", "==", "1", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "num_bg_samples", ".", "append", "(", "proposal_labels", ".", "numel", "(", ")", "-", "num_fg_samples", "[", "-", "1", "]", ")", "\n", "\n", "# Log the number of fg/bg samples in each stage", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\n", "\"stage{}/roi_head/num_fg_samples\"", ".", "format", "(", "stage", ")", ",", "\n", "sum", "(", "num_fg_samples", ")", "/", "len", "(", "num_fg_samples", ")", ",", "\n", ")", "\n", "storage", ".", "put_scalar", "(", "\n", "\"stage{}/roi_head/num_bg_samples\"", ".", "format", "(", "stage", ")", ",", "\n", "sum", "(", "num_bg_samples", ")", "/", "len", "(", "num_bg_samples", ")", ",", "\n", ")", "\n", "return", "proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._run_stage": [[258, 276], ["cascade_rcnn.CascadeROIHeads.box_pooler", "_ScaleGradient.apply"], "methods", ["None"], ["", "def", "_run_stage", "(", "self", ",", "features", ",", "proposals", ",", "stage", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            features (list[Tensor]): #lvl input features to ROIHeads\n            proposals (list[Instances]): #image Instances, with the field \"proposal_boxes\"\n            stage (int): the current stage\n\n        Returns:\n            Same output as `FastRCNNOutputLayers.forward()`.\n        \"\"\"", "\n", "box_features", "=", "self", ".", "box_pooler", "(", "features", ",", "[", "x", ".", "proposal_boxes", "for", "x", "in", "proposals", "]", ")", "\n", "# The original implementation averages the losses among heads,", "\n", "# but scale up the parameter gradients of the heads.", "\n", "# This is equivalent to adding the losses among heads,", "\n", "# but scale down the gradients on features.", "\n", "box_features", "=", "_ScaleGradient", ".", "apply", "(", "box_features", ",", "1.0", "/", "self", ".", "num_cascade_stages", ")", "\n", "box_features", "=", "self", ".", "box_head", "[", "stage", "]", "(", "box_features", ")", "\n", "return", "self", ".", "box_predictor", "[", "stage", "]", "(", "box_features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.cascade_rcnn.CascadeROIHeads._create_proposals_from_boxes": [[277, 299], ["zip", "detectron2.structures.Boxes", "boxes_per_image.clip", "detectron2.structures.Instances", "proposals.append", "b.detach", "boxes_per_image.nonempty"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty"], ["", "def", "_create_proposals_from_boxes", "(", "self", ",", "boxes", ",", "image_sizes", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            boxes (list[Tensor]): per-image predicted boxes, each of shape Ri x 4\n            image_sizes (list[tuple]): list of image shapes in (h, w)\n\n        Returns:\n            list[Instances]: per-image proposals with the given boxes.\n        \"\"\"", "\n", "# Just like RPN, the proposals should not have gradients", "\n", "boxes", "=", "[", "Boxes", "(", "b", ".", "detach", "(", ")", ")", "for", "b", "in", "boxes", "]", "\n", "proposals", "=", "[", "]", "\n", "for", "boxes_per_image", ",", "image_size", "in", "zip", "(", "boxes", ",", "image_sizes", ")", ":", "\n", "            ", "boxes_per_image", ".", "clip", "(", "image_size", ")", "\n", "if", "self", ".", "training", ":", "\n", "# do not filter empty boxes at inference time,", "\n", "# because the scores from each stage need to be aligned and added later", "\n", "                ", "boxes_per_image", "=", "boxes_per_image", "[", "boxes_per_image", ".", "nonempty", "(", ")", "]", "\n", "", "prop", "=", "Instances", "(", "image_size", ")", "\n", "prop", ".", "proposal_boxes", "=", "boxes_per_image", "\n", "proposals", ".", "append", "(", "prop", ")", "\n", "", "return", "proposals", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.v1convx.DensePoseV1ConvXHead.__init__": [[20, 43], ["torch.nn.Module.__init__", "range", "utils.initialize_module_params", "detectron2.layers.Conv2d", "v1convx.DensePoseV1ConvXHead._get_layer_name", "v1convx.DensePoseV1ConvXHead.add_module"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.utils.initialize_module_params", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name"], ["def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize DensePose fully convolutional head\n\n        Args:\n            cfg (CfgNode): configuration options\n            input_channels (int): number of input channels\n        \"\"\"", "\n", "super", "(", "DensePoseV1ConvXHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "hidden_dim", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "CONV_HEAD_DIM", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "CONV_HEAD_KERNEL", "\n", "self", ".", "n_stacked_convs", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_STACKED_CONVS", "\n", "# fmt: on", "\n", "pad_size", "=", "kernel_size", "//", "2", "\n", "n_channels", "=", "input_channels", "\n", "for", "i", "in", "range", "(", "self", ".", "n_stacked_convs", ")", ":", "\n", "            ", "layer", "=", "Conv2d", "(", "n_channels", ",", "hidden_dim", ",", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "pad_size", ")", "\n", "layer_name", "=", "self", ".", "_get_layer_name", "(", "i", ")", "\n", "self", ".", "add_module", "(", "layer_name", ",", "layer", ")", "\n", "n_channels", "=", "hidden_dim", "\n", "", "self", ".", "n_out_channels", "=", "n_channels", "\n", "initialize_module_params", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.v1convx.DensePoseV1ConvXHead.forward": [[44, 61], ["range", "v1convx.DensePoseV1ConvXHead._get_layer_name", "torch.nn.functional.relu", "getattr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name"], ["", "def", "forward", "(", "self", ",", "features", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Apply DensePose fully convolutional head to the input features\n\n        Args:\n            features (tensor): input features\n        Result:\n            A tensor of DensePose head outputs\n        \"\"\"", "\n", "x", "=", "features", "\n", "output", "=", "x", "\n", "for", "i", "in", "range", "(", "self", ".", "n_stacked_convs", ")", ":", "\n", "            ", "layer_name", "=", "self", ".", "_get_layer_name", "(", "i", ")", "\n", "x", "=", "getattr", "(", "self", ",", "layer_name", ")", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "output", "=", "x", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.v1convx.DensePoseV1ConvXHead._get_layer_name": [[62, 65], ["None"], "methods", ["None"], ["", "def", "_get_layer_name", "(", "self", ",", "i", ":", "int", ")", ":", "\n", "        ", "layer_name", "=", "\"body_conv_fcn{}\"", ".", "format", "(", "i", "+", "1", ")", "\n", "return", "layer_name", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.DensePoseDeepLabHead.__init__": [[22, 58], ["torch.nn.Module.__init__", "deeplab.ASPP", "deeplab.DensePoseDeepLabHead.add_module", "range", "deeplab.NONLocalBlock2D", "deeplab.DensePoseDeepLabHead.add_module", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "deeplab.DensePoseDeepLabHead._get_layer_name", "deeplab.DensePoseDeepLabHead.add_module", "torch.nn.GroupNorm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name"], ["def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "super", "(", "DensePoseDeepLabHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "hidden_dim", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "CONV_HEAD_DIM", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "CONV_HEAD_KERNEL", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DEEPLAB", ".", "NORM", "\n", "self", ".", "n_stacked_convs", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_STACKED_CONVS", "\n", "self", ".", "use_nonlocal", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DEEPLAB", ".", "NONLOCAL_ON", "\n", "# fmt: on", "\n", "pad_size", "=", "kernel_size", "//", "2", "\n", "n_channels", "=", "input_channels", "\n", "\n", "self", ".", "ASPP", "=", "ASPP", "(", "input_channels", ",", "[", "6", ",", "12", ",", "56", "]", ",", "n_channels", ")", "# 6, 12, 56", "\n", "self", ".", "add_module", "(", "\"ASPP\"", ",", "self", ".", "ASPP", ")", "\n", "\n", "if", "self", ".", "use_nonlocal", ":", "\n", "            ", "self", ".", "NLBlock", "=", "NONLocalBlock2D", "(", "input_channels", ",", "bn_layer", "=", "True", ")", "\n", "self", ".", "add_module", "(", "\"NLBlock\"", ",", "self", ".", "NLBlock", ")", "\n", "# weight_init.c2_msra_fill(self.ASPP)", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "n_stacked_convs", ")", ":", "\n", "            ", "norm_module", "=", "nn", ".", "GroupNorm", "(", "32", ",", "hidden_dim", ")", "if", "norm", "==", "\"GN\"", "else", "None", "\n", "layer", "=", "Conv2d", "(", "\n", "n_channels", ",", "\n", "hidden_dim", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "pad_size", ",", "\n", "bias", "=", "not", "norm", ",", "\n", "norm", "=", "norm_module", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "n_channels", "=", "hidden_dim", "\n", "layer_name", "=", "self", ".", "_get_layer_name", "(", "i", ")", "\n", "self", ".", "add_module", "(", "layer_name", ",", "layer", ")", "\n", "", "self", ".", "n_out_channels", "=", "hidden_dim", "\n", "# initialize_module_params(self)", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.DensePoseDeepLabHead.forward": [[60, 72], ["deeplab.DensePoseDeepLabHead.ASPP", "range", "deeplab.DensePoseDeepLabHead.NLBlock", "deeplab.DensePoseDeepLabHead._get_layer_name", "torch.nn.functional.relu", "getattr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "x0", "=", "features", "\n", "x", "=", "self", ".", "ASPP", "(", "x0", ")", "\n", "if", "self", ".", "use_nonlocal", ":", "\n", "            ", "x", "=", "self", ".", "NLBlock", "(", "x", ")", "\n", "", "output", "=", "x", "\n", "for", "i", "in", "range", "(", "self", ".", "n_stacked_convs", ")", ":", "\n", "            ", "layer_name", "=", "self", ".", "_get_layer_name", "(", "i", ")", "\n", "x", "=", "getattr", "(", "self", ",", "layer_name", ")", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "output", "=", "x", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.DensePoseDeepLabHead._get_layer_name": [[73, 76], ["None"], "methods", ["None"], ["", "def", "_get_layer_name", "(", "self", ",", "i", ":", "int", ")", ":", "\n", "        ", "layer_name", "=", "\"body_conv_fcn{}\"", ".", "format", "(", "i", "+", "1", ")", "\n", "return", "layer_name", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.ASPPConv.__init__": [[82, 91], ["torch.nn.Sequential.__init__", "torch.nn.Conv2d", "torch.nn.GroupNorm", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "dilation", ")", ":", "\n", "        ", "modules", "=", "[", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "out_channels", ",", "3", ",", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ",", "bias", "=", "False", "\n", ")", ",", "\n", "nn", ".", "GroupNorm", "(", "32", ",", "out_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "]", "\n", "super", "(", "ASPPConv", ",", "self", ")", ".", "__init__", "(", "*", "modules", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.ASPPPooling.__init__": [[94, 100], ["torch.nn.Sequential.__init__", "torch.nn.AdaptiveAvgPool2d", "torch.nn.Conv2d", "torch.nn.GroupNorm", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", "ASPPPooling", ",", "self", ")", ".", "__init__", "(", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "GroupNorm", "(", "32", ",", "out_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.ASPPPooling.forward": [[102, 106], ["super().forward", "torch.nn.functional.interpolate"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "size", "=", "x", ".", "shape", "[", "-", "2", ":", "]", "\n", "x", "=", "super", "(", "ASPPPooling", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "return", "F", ".", "interpolate", "(", "x", ",", "size", "=", "size", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.ASPP.__init__": [[109, 132], ["torch.nn.Module.__init__", "modules.append", "tuple", "modules.append", "modules.append", "modules.append", "modules.append", "torch.nn.ModuleList", "torch.nn.Sequential", "torch.nn.Sequential", "deeplab.ASPPConv", "deeplab.ASPPConv", "deeplab.ASPPConv", "deeplab.ASPPPooling", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.GroupNorm", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "atrous_rates", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", "ASPP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "modules", "=", "[", "]", "\n", "modules", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "GroupNorm", "(", "32", ",", "out_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", ")", "\n", "\n", "rate1", ",", "rate2", ",", "rate3", "=", "tuple", "(", "atrous_rates", ")", "\n", "modules", ".", "append", "(", "ASPPConv", "(", "in_channels", ",", "out_channels", ",", "rate1", ")", ")", "\n", "modules", ".", "append", "(", "ASPPConv", "(", "in_channels", ",", "out_channels", ",", "rate2", ")", ")", "\n", "modules", ".", "append", "(", "ASPPConv", "(", "in_channels", ",", "out_channels", ",", "rate3", ")", ")", "\n", "modules", ".", "append", "(", "ASPPPooling", "(", "in_channels", ",", "out_channels", ")", ")", "\n", "\n", "self", ".", "convs", "=", "nn", ".", "ModuleList", "(", "modules", ")", "\n", "\n", "self", ".", "project", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "5", "*", "out_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "# nn.BatchNorm2d(out_channels),", "\n", "nn", ".", "ReLU", "(", ")", "\n", "# nn.Dropout(0.5)", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.ASPP.forward": [[135, 141], ["torch.cat", "deeplab.ASPP.project", "torch.cat.append", "conv"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "res", "=", "[", "]", "\n", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "res", ".", "append", "(", "conv", "(", "x", ")", ")", "\n", "", "res", "=", "torch", ".", "cat", "(", "res", ",", "dim", "=", "1", ")", "\n", "return", "self", ".", "project", "(", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab._NonLocalBlockND.__init__": [[147, 228], ["torch.nn.Module.__init__", "conv_nd", "conv_nd", "conv_nd", "torch.nn.MaxPool3d", "torch.nn.Sequential", "torch.nn.init.constant_", "torch.nn.init.constant_", "conv_nd", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.MaxPool2d", "torch.nn.MaxPool1d", "conv_nd", "bn"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "in_channels", ",", "inter_channels", "=", "None", ",", "dimension", "=", "3", ",", "sub_sample", "=", "True", ",", "bn_layer", "=", "True", "\n", ")", ":", "\n", "        ", "super", "(", "_NonLocalBlockND", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "dimension", "in", "[", "1", ",", "2", ",", "3", "]", "\n", "\n", "self", ".", "dimension", "=", "dimension", "\n", "self", ".", "sub_sample", "=", "sub_sample", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "inter_channels", "=", "inter_channels", "\n", "\n", "if", "self", ".", "inter_channels", "is", "None", ":", "\n", "            ", "self", ".", "inter_channels", "=", "in_channels", "//", "2", "\n", "if", "self", ".", "inter_channels", "==", "0", ":", "\n", "                ", "self", ".", "inter_channels", "=", "1", "\n", "\n", "", "", "if", "dimension", "==", "3", ":", "\n", "            ", "conv_nd", "=", "nn", ".", "Conv3d", "\n", "max_pool_layer", "=", "nn", ".", "MaxPool3d", "(", "kernel_size", "=", "(", "1", ",", "2", ",", "2", ")", ")", "\n", "bn", "=", "nn", ".", "GroupNorm", "# (32, hidden_dim) #nn.BatchNorm3d", "\n", "", "elif", "dimension", "==", "2", ":", "\n", "            ", "conv_nd", "=", "nn", ".", "Conv2d", "\n", "max_pool_layer", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "(", "2", ",", "2", ")", ")", "\n", "bn", "=", "nn", ".", "GroupNorm", "# (32, hidden_dim)nn.BatchNorm2d", "\n", "", "else", ":", "\n", "            ", "conv_nd", "=", "nn", ".", "Conv1d", "\n", "max_pool_layer", "=", "nn", ".", "MaxPool1d", "(", "kernel_size", "=", "2", ")", "\n", "bn", "=", "nn", ".", "GroupNorm", "# (32, hidden_dim)nn.BatchNorm1d", "\n", "\n", "", "self", ".", "g", "=", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "in_channels", ",", "\n", "out_channels", "=", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "\n", "if", "bn_layer", ":", "\n", "            ", "self", ".", "W", "=", "nn", ".", "Sequential", "(", "\n", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "inter_channels", ",", "\n", "out_channels", "=", "self", ".", "in_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", ",", "\n", "bn", "(", "32", ",", "self", ".", "in_channels", ")", ",", "\n", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "W", "[", "1", "]", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "W", "[", "1", "]", ".", "bias", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "W", "=", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "inter_channels", ",", "\n", "out_channels", "=", "self", ".", "in_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "W", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "W", ".", "bias", ",", "0", ")", "\n", "\n", "", "self", ".", "theta", "=", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "in_channels", ",", "\n", "out_channels", "=", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "self", ".", "phi", "=", "conv_nd", "(", "\n", "in_channels", "=", "self", ".", "in_channels", ",", "\n", "out_channels", "=", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "\n", "if", "sub_sample", ":", "\n", "            ", "self", ".", "g", "=", "nn", ".", "Sequential", "(", "self", ".", "g", ",", "max_pool_layer", ")", "\n", "self", ".", "phi", "=", "nn", ".", "Sequential", "(", "self", ".", "phi", ",", "max_pool_layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab._NonLocalBlockND.forward": [[229, 253], ["x.size", "deeplab._NonLocalBlockND.g().view", "g_x.permute.permute.permute", "deeplab._NonLocalBlockND.theta().view", "theta_x.permute.permute.permute", "deeplab._NonLocalBlockND.phi().view", "torch.matmul", "torch.nn.functional.softmax", "torch.matmul", "y.view.view.permute().contiguous", "y.view.view.view", "deeplab._NonLocalBlockND.W", "deeplab._NonLocalBlockND.g", "deeplab._NonLocalBlockND.theta", "deeplab._NonLocalBlockND.phi", "y.view.view.permute", "x.size"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        :param x: (b, c, t, h, w)\n        :return:\n        \"\"\"", "\n", "\n", "batch_size", "=", "x", ".", "size", "(", "0", ")", "\n", "\n", "g_x", "=", "self", ".", "g", "(", "x", ")", ".", "view", "(", "batch_size", ",", "self", ".", "inter_channels", ",", "-", "1", ")", "\n", "g_x", "=", "g_x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n", "theta_x", "=", "self", ".", "theta", "(", "x", ")", ".", "view", "(", "batch_size", ",", "self", ".", "inter_channels", ",", "-", "1", ")", "\n", "theta_x", "=", "theta_x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "phi_x", "=", "self", ".", "phi", "(", "x", ")", ".", "view", "(", "batch_size", ",", "self", ".", "inter_channels", ",", "-", "1", ")", "\n", "f", "=", "torch", ".", "matmul", "(", "theta_x", ",", "phi_x", ")", "\n", "f_div_C", "=", "F", ".", "softmax", "(", "f", ",", "dim", "=", "-", "1", ")", "\n", "\n", "y", "=", "torch", ".", "matmul", "(", "f_div_C", ",", "g_x", ")", "\n", "y", "=", "y", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "y", "=", "y", ".", "view", "(", "batch_size", ",", "self", ".", "inter_channels", ",", "*", "x", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "W_y", "=", "self", ".", "W", "(", "y", ")", "\n", "z", "=", "W_y", "+", "x", "\n", "\n", "return", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.deeplab.NONLocalBlock2D.__init__": [[256, 263], ["deeplab._NonLocalBlockND.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "inter_channels", "=", "None", ",", "sub_sample", "=", "True", ",", "bn_layer", "=", "True", ")", ":", "\n", "        ", "super", "(", "NONLocalBlock2D", ",", "self", ")", ".", "__init__", "(", "\n", "in_channels", ",", "\n", "inter_channels", "=", "inter_channels", ",", "\n", "dimension", "=", "2", ",", "\n", "sub_sample", "=", "sub_sample", ",", "\n", "bn_layer", "=", "bn_layer", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.Decoder.__init__": [[32, 72], ["torch.Module.__init__", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "max", "range", "roi_head.Decoder.scale_heads.append", "roi_head.Decoder.add_module", "input_shape.items", "input_shape.items", "int", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "head_ops.append", "torch.Sequential", "torch.Sequential", "head_ops.append", "numpy.log2", "numpy.log2", "detectron2.layers.get_norm", "torch.Upsample", "torch.Upsample"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ",", "in_features", ")", ":", "\n", "        ", "super", "(", "Decoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "in_features", "\n", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "feature_channels", "=", "{", "k", ":", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_CONV_DIMS", "\n", "self", ".", "common_stride", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_COMMON_STRIDE", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_NORM", "\n", "# fmt: on", "\n", "\n", "self", ".", "scale_heads", "=", "[", "]", "\n", "for", "in_feature", "in", "self", ".", "in_features", ":", "\n", "            ", "head_ops", "=", "[", "]", "\n", "head_length", "=", "max", "(", "\n", "1", ",", "int", "(", "np", ".", "log2", "(", "feature_strides", "[", "in_feature", "]", ")", "-", "np", ".", "log2", "(", "self", ".", "common_stride", ")", ")", "\n", ")", "\n", "for", "k", "in", "range", "(", "head_length", ")", ":", "\n", "                ", "conv", "=", "Conv2d", "(", "\n", "feature_channels", "[", "in_feature", "]", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "norm", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "conv_dims", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "conv", ")", "\n", "head_ops", ".", "append", "(", "conv", ")", "\n", "if", "feature_strides", "[", "in_feature", "]", "!=", "self", ".", "common_stride", ":", "\n", "                    ", "head_ops", ".", "append", "(", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", ")", "\n", "", "", "self", ".", "scale_heads", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "head_ops", ")", ")", "\n", "self", ".", "add_module", "(", "in_feature", ",", "self", ".", "scale_heads", "[", "-", "1", "]", ")", "\n", "", "self", ".", "predictor", "=", "Conv2d", "(", "conv_dims", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "predictor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.Decoder.forward": [[73, 81], ["enumerate", "roi_head.Decoder.predictor"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "for", "i", ",", "_", "in", "enumerate", "(", "self", ".", "in_features", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "x", "=", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "x", "+", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "i", "]", ")", "\n", "", "", "x", "=", "self", ".", "predictor", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads.__init__": [[89, 92], ["detectron2.modeling.StandardROIHeads.__init__", "roi_head.DensePoseROIHeads._init_densepose_head"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads._init_densepose_head"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "self", ".", "_init_densepose_head", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads._init_densepose_head": [[93, 124], ["build_densepose_data_filter", "detectron2.modeling.poolers.ROIPooler", "build_densepose_head", "build_densepose_predictor", "build_densepose_losses", "tuple", "roi_head.Decoder"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.build.build_densepose_data_filter", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.build.build_densepose_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.build.build_densepose_predictor", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.build.build_densepose_losses"], ["", "def", "_init_densepose_head", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "self", ".", "densepose_on", "=", "cfg", ".", "MODEL", ".", "DENSEPOSE_ON", "\n", "if", "not", "self", ".", "densepose_on", ":", "\n", "            ", "return", "\n", "", "self", ".", "densepose_data_filter", "=", "build_densepose_data_filter", "(", "cfg", ")", "\n", "dp_pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "POOLER_RESOLUTION", "\n", "dp_pooler_sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "dp_pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "POOLER_TYPE", "\n", "self", ".", "use_decoder", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECODER_ON", "\n", "# fmt: on", "\n", "if", "self", ".", "use_decoder", ":", "\n", "            ", "dp_pooler_scales", "=", "(", "1.0", "/", "input_shape", "[", "self", ".", "in_features", "[", "0", "]", "]", ".", "stride", ",", ")", "\n", "", "else", ":", "\n", "            ", "dp_pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "self", ".", "in_features", ")", "\n", "", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "self", ".", "in_features", "]", "[", "0", "]", "\n", "\n", "if", "self", ".", "use_decoder", ":", "\n", "            ", "self", ".", "decoder", "=", "Decoder", "(", "cfg", ",", "input_shape", ",", "self", ".", "in_features", ")", "\n", "\n", "", "self", ".", "densepose_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "dp_pooler_resolution", ",", "\n", "scales", "=", "dp_pooler_scales", ",", "\n", "sampling_ratio", "=", "dp_pooler_sampling_ratio", ",", "\n", "pooler_type", "=", "dp_pooler_type", ",", "\n", ")", "\n", "self", ".", "densepose_head", "=", "build_densepose_head", "(", "cfg", ",", "in_channels", ")", "\n", "self", ".", "densepose_predictor", "=", "build_densepose_predictor", "(", "\n", "cfg", ",", "self", ".", "densepose_head", ".", "n_out_channels", "\n", ")", "\n", "self", ".", "densepose_losses", "=", "build_densepose_losses", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads._forward_densepose": [[125, 186], ["detectron2.modeling.roi_heads.select_foreground_proposals", "roi_head.DensePoseROIHeads.densepose_data_filter", "roi_head.DensePoseROIHeads.densepose_pooler", "densepose_inference", "len", "roi_head.DensePoseROIHeads.densepose_pooler", "roi_head.DensePoseROIHeads.densepose_head", "roi_head.DensePoseROIHeads.densepose_predictor", "roi_head.DensePoseROIHeads.densepose_losses", "len", "roi_head.DensePoseROIHeads.densepose_head", "roi_head.DensePoseROIHeads.densepose_predictor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "tuple", "tuple", "roi_head.DensePoseROIHeads.decoder", "roi_head.DensePoseROIHeads.decoder"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.inference.densepose_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.AE.decoder", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.fast_rcnn.AE.decoder"], ["", "def", "_forward_densepose", "(", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Forward logic of the densepose prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): input data as a mapping from feature\n                map name to tensor. Axis 0 represents the number of images `N` in\n                the input data; axes 1-3 are channels, height, and width, which may\n                vary between feature maps (e.g., if a feature pyramid is used).\n            instances (list[Instances]): length `N` list of `Instances`. The i-th\n                `Instances` contains instances for the i-th input image,\n                In training, they can be the proposals.\n                In inference, they can be the predicted boxes.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"densepose\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "densepose_on", ":", "\n", "            ", "return", "{", "}", "if", "self", ".", "training", "else", "instances", "\n", "\n", "", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "if", "self", ".", "training", ":", "\n", "            ", "proposals", ",", "_", "=", "select_foreground_proposals", "(", "instances", ",", "self", ".", "num_classes", ")", "\n", "features", ",", "proposals", "=", "self", ".", "densepose_data_filter", "(", "features", ",", "proposals", ")", "\n", "if", "len", "(", "proposals", ")", ">", "0", ":", "\n", "                ", "proposal_boxes", "=", "[", "x", ".", "proposal_boxes", "for", "x", "in", "proposals", "]", "\n", "\n", "if", "self", ".", "use_decoder", ":", "\n", "                    ", "features", "=", "[", "self", ".", "decoder", "(", "features", ")", "]", "\n", "\n", "", "features_dp", "=", "self", ".", "densepose_pooler", "(", "features", ",", "proposal_boxes", ")", "\n", "densepose_head_outputs", "=", "self", ".", "densepose_head", "(", "features_dp", ")", "\n", "densepose_outputs", ",", "_", ",", "confidences", ",", "_", "=", "self", ".", "densepose_predictor", "(", "\n", "densepose_head_outputs", "\n", ")", "\n", "densepose_loss_dict", "=", "self", ".", "densepose_losses", "(", "\n", "proposals", ",", "densepose_outputs", ",", "confidences", "\n", ")", "\n", "return", "densepose_loss_dict", "\n", "", "", "else", ":", "\n", "            ", "pred_boxes", "=", "[", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "\n", "if", "self", ".", "use_decoder", ":", "\n", "                ", "features", "=", "[", "self", ".", "decoder", "(", "features", ")", "]", "\n", "\n", "", "features_dp", "=", "self", ".", "densepose_pooler", "(", "features", ",", "pred_boxes", ")", "\n", "if", "len", "(", "features_dp", ")", ">", "0", ":", "\n", "                ", "densepose_head_outputs", "=", "self", ".", "densepose_head", "(", "features_dp", ")", "\n", "densepose_outputs", ",", "_", ",", "confidences", ",", "_", "=", "self", ".", "densepose_predictor", "(", "\n", "densepose_head_outputs", "\n", ")", "\n", "", "else", ":", "\n", "# If no detection occurred instances", "\n", "# set densepose_outputs to empty tensors", "\n", "                ", "empty_tensor", "=", "torch", ".", "zeros", "(", "size", "=", "(", "0", ",", "0", ",", "0", ",", "0", ")", ",", "device", "=", "features_dp", ".", "device", ")", "\n", "densepose_outputs", "=", "tuple", "(", "[", "empty_tensor", "]", "*", "4", ")", "\n", "confidences", "=", "tuple", "(", "[", "empty_tensor", "]", "*", "6", ")", "\n", "\n", "", "densepose_inference", "(", "densepose_outputs", ",", "confidences", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads.forward": [[187, 200], ["super().forward", "losses.update", "roi_head.DensePoseROIHeads._forward_densepose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads._forward_densepose"], ["", "", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "\n", "targets", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "instances", ",", "losses", "=", "super", "(", ")", ".", "forward", "(", "images", ",", "features", ",", "proposals", ",", "targets", ")", "\n", "del", "targets", ",", "images", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", ".", "update", "(", "self", ".", "_forward_densepose", "(", "features", ",", "instances", ")", ")", "\n", "", "return", "instances", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes": [[201, 225], ["super().forward_with_given_boxes", "roi_head.DensePoseROIHeads._forward_densepose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_head.DensePoseROIHeads._forward_densepose"], ["", "def", "forward_with_given_boxes", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Use the given boxes in `instances` to produce other (non-box) per-ROI outputs.\n\n        This is useful for downstream tasks where a box is known, but need to obtain\n        other attributes (outputs of other heads).\n        Test-time augmentation also uses this.\n\n        Args:\n            features: same as in `forward()`\n            instances (list[Instances]): instances to predict other outputs. Expect the keys\n                \"pred_boxes\" and \"pred_classes\" to exist.\n\n        Returns:\n            instances (list[Instances]):\n                the same `Instances` objects, with extra\n                fields such as `pred_masks` or `pred_keypoints`.\n        \"\"\"", "\n", "\n", "instances", "=", "super", "(", ")", ".", "forward_with_given_boxes", "(", "features", ",", "instances", ")", "\n", "instances", "=", "self", ".", "_forward_densepose", "(", "features", ",", "instances", ")", "\n", "return", "instances", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone": [[20, 34], ["isinstance", "detectron2.layers.ShapeSpec", "BACKBONE_REGISTRY.get", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.FPN.__init__": [[22, 104], ["backbone.Backbone.__init__", "isinstance", "bottom_up.output_shape", "fpn._assert_strides_are_log2_contiguous", "enumerate", "list", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "int", "fpn.FPN.add_module", "fpn.FPN.add_module", "lateral_convs.append", "output_convs.append", "range", "fpn.FPN._out_feature_strides.keys", "math.log2", "int", "math.log2"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn._assert_strides_are_log2_contiguous", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["def", "__init__", "(", "\n", "self", ",", "bottom_up", ",", "in_features", ",", "out_channels", ",", "norm", "=", "\"\"", ",", "top_block", "=", "None", ",", "fuse_type", "=", "\"sum\"", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            bottom_up (Backbone): module representing the bottom up subnetwork.\n                Must be a subclass of :class:`Backbone`. The multi-scale feature\n                maps generated by the bottom up network, and listed in `in_features`,\n                are used to generate FPN levels.\n            in_features (list[str]): names of the input feature maps coming\n                from the backbone to which FPN is attached. For example, if the\n                backbone produces [\"res2\", \"res3\", \"res4\"], any *contiguous* sublist\n                of these may be used; order must be from high to low resolution.\n            out_channels (int): number of channels in the output feature maps.\n            norm (str): the normalization to use.\n            top_block (nn.Module or None): if provided, an extra operation will\n                be performed on the output of the last (smallest resolution)\n                FPN output, and the result will extend the result list. The top_block\n                further downsamples the feature map. It must have an attribute\n                \"num_levels\", meaning the number of extra FPN levels added by\n                this block, and \"in_feature\", which is a string representing\n                its input feature (e.g., p5).\n            fuse_type (str): types for fusing the top down features and the lateral\n                ones. It can be \"sum\" (default), which sums up element-wise; or \"avg\",\n                which takes the element-wise mean of the two.\n        \"\"\"", "\n", "super", "(", "FPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "bottom_up", ",", "Backbone", ")", "\n", "\n", "# Feature map strides and channels from the bottom up network (e.g. ResNet)", "\n", "input_shapes", "=", "bottom_up", ".", "output_shape", "(", ")", "\n", "strides", "=", "[", "input_shapes", "[", "f", "]", ".", "stride", "for", "f", "in", "in_features", "]", "\n", "in_channels_per_feature", "=", "[", "input_shapes", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "\n", "\n", "_assert_strides_are_log2_contiguous", "(", "strides", ")", "\n", "lateral_convs", "=", "[", "]", "\n", "output_convs", "=", "[", "]", "\n", "\n", "use_bias", "=", "norm", "==", "\"\"", "\n", "for", "idx", ",", "in_channels", "in", "enumerate", "(", "in_channels_per_feature", ")", ":", "\n", "            ", "lateral_norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "output_norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "\n", "lateral_conv", "=", "Conv2d", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ",", "bias", "=", "use_bias", ",", "norm", "=", "lateral_norm", "\n", ")", "\n", "output_conv", "=", "Conv2d", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "output_norm", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "lateral_conv", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "output_conv", ")", "\n", "stage", "=", "int", "(", "math", ".", "log2", "(", "strides", "[", "idx", "]", ")", ")", "\n", "self", ".", "add_module", "(", "\"fpn_lateral{}\"", ".", "format", "(", "stage", ")", ",", "lateral_conv", ")", "\n", "self", ".", "add_module", "(", "\"fpn_output{}\"", ".", "format", "(", "stage", ")", ",", "output_conv", ")", "\n", "\n", "lateral_convs", ".", "append", "(", "lateral_conv", ")", "\n", "output_convs", ".", "append", "(", "output_conv", ")", "\n", "# Place convs into top-down order (from low to high resolution)", "\n", "# to make the top-down computation in forward clearer.", "\n", "", "self", ".", "lateral_convs", "=", "lateral_convs", "[", ":", ":", "-", "1", "]", "\n", "self", ".", "output_convs", "=", "output_convs", "[", ":", ":", "-", "1", "]", "\n", "self", ".", "top_block", "=", "top_block", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "bottom_up", "=", "bottom_up", "\n", "# Return feature names are \"p<stage>\", like [\"p2\", \"p3\", ..., \"p6\"]", "\n", "self", ".", "_out_feature_strides", "=", "{", "\"p{}\"", ".", "format", "(", "int", "(", "math", ".", "log2", "(", "s", ")", ")", ")", ":", "s", "for", "s", "in", "strides", "}", "\n", "# top block output feature maps.", "\n", "if", "self", ".", "top_block", "is", "not", "None", ":", "\n", "            ", "for", "s", "in", "range", "(", "stage", ",", "stage", "+", "self", ".", "top_block", ".", "num_levels", ")", ":", "\n", "                ", "self", ".", "_out_feature_strides", "[", "\"p{}\"", ".", "format", "(", "s", "+", "1", ")", "]", "=", "2", "**", "(", "s", "+", "1", ")", "\n", "\n", "", "", "self", ".", "_out_features", "=", "list", "(", "self", ".", "_out_feature_strides", ".", "keys", "(", ")", ")", "\n", "self", ".", "_out_feature_channels", "=", "{", "k", ":", "out_channels", "for", "k", "in", "self", ".", "_out_features", "}", "\n", "self", ".", "_size_divisibility", "=", "strides", "[", "-", "1", "]", "\n", "assert", "fuse_type", "in", "{", "\"avg\"", ",", "\"sum\"", "}", "\n", "self", ".", "_fuse_type", "=", "fuse_type", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.FPN.size_divisibility": [[105, 108], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "size_divisibility", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_size_divisibility", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.FPN.forward": [[109, 145], ["fpn.FPN.bottom_up", "results.append", "zip", "dict", "torch.interpolate", "lateral_conv", "results.insert", "fpn.FPN.get", "results.extend", "len", "len", "zip", "output_conv", "fpn.FPN.top_block", "fpn.FPN._out_features.index"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (dict[str->Tensor]): mapping feature map name (e.g., \"res5\") to\n                feature map tensor for each feature level in high to low resolution order.\n\n        Returns:\n            dict[str->Tensor]:\n                mapping from feature map name to FPN feature map tensor\n                in high to low resolution order. Returned feature names follow the FPN\n                paper convention: \"p<stage>\", where stage has stride = 2 ** stage e.g.,\n                [\"p2\", \"p3\", ..., \"p6\"].\n        \"\"\"", "\n", "# Reverse feature maps into top-down order (from low to high resolution)", "\n", "bottom_up_features", "=", "self", ".", "bottom_up", "(", "x", ")", "\n", "x", "=", "[", "bottom_up_features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "[", ":", ":", "-", "1", "]", "]", "\n", "results", "=", "[", "]", "\n", "prev_features", "=", "self", ".", "lateral_convs", "[", "0", "]", "(", "x", "[", "0", "]", ")", "\n", "results", ".", "append", "(", "self", ".", "output_convs", "[", "0", "]", "(", "prev_features", ")", ")", "\n", "for", "features", ",", "lateral_conv", ",", "output_conv", "in", "zip", "(", "\n", "x", "[", "1", ":", "]", ",", "self", ".", "lateral_convs", "[", "1", ":", "]", ",", "self", ".", "output_convs", "[", "1", ":", "]", "\n", ")", ":", "\n", "            ", "top_down_features", "=", "F", ".", "interpolate", "(", "prev_features", ",", "scale_factor", "=", "2", ",", "mode", "=", "\"nearest\"", ")", "\n", "lateral_features", "=", "lateral_conv", "(", "features", ")", "\n", "prev_features", "=", "lateral_features", "+", "top_down_features", "\n", "if", "self", ".", "_fuse_type", "==", "\"avg\"", ":", "\n", "                ", "prev_features", "/=", "2", "\n", "", "results", ".", "insert", "(", "0", ",", "output_conv", "(", "prev_features", ")", ")", "\n", "\n", "", "if", "self", ".", "top_block", "is", "not", "None", ":", "\n", "            ", "top_block_in_feature", "=", "bottom_up_features", ".", "get", "(", "self", ".", "top_block", ".", "in_feature", ",", "None", ")", "\n", "if", "top_block_in_feature", "is", "None", ":", "\n", "                ", "top_block_in_feature", "=", "results", "[", "self", ".", "_out_features", ".", "index", "(", "self", ".", "top_block", ".", "in_feature", ")", "]", "\n", "", "results", ".", "extend", "(", "self", ".", "top_block", "(", "top_block_in_feature", ")", ")", "\n", "", "assert", "len", "(", "self", ".", "_out_features", ")", "==", "len", "(", "results", ")", "\n", "return", "dict", "(", "zip", "(", "self", ".", "_out_features", ",", "results", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.FPN.output_shape": [[146, 152], ["detectron2.layers.ShapeSpec"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "name", ":", "ShapeSpec", "(", "\n", "channels", "=", "self", ".", "_out_feature_channels", "[", "name", "]", ",", "stride", "=", "self", ".", "_out_feature_strides", "[", "name", "]", "\n", ")", "\n", "for", "name", "in", "self", ".", "_out_features", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.LastLevelMaxPool.__init__": [[171, 175], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_levels", "=", "1", "\n", "self", ".", "in_feature", "=", "\"p5\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.LastLevelMaxPool.forward": [[176, 178], ["torch.max_pool2d"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "[", "F", ".", "max_pool2d", "(", "x", ",", "kernel_size", "=", "1", ",", "stride", "=", "2", ",", "padding", "=", "0", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.LastLevelP6P7.__init__": [[186, 194], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "fvcore.c2_xavier_fill"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "in_feature", "=", "\"res5\"", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_levels", "=", "2", "\n", "self", ".", "in_feature", "=", "in_feature", "\n", "self", ".", "p6", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "3", ",", "2", ",", "1", ")", "\n", "self", ".", "p7", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "out_channels", ",", "3", ",", "2", ",", "1", ")", "\n", "for", "module", "in", "[", "self", ".", "p6", ",", "self", ".", "p7", "]", ":", "\n", "            ", "weight_init", ".", "c2_xavier_fill", "(", "module", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.LastLevelP6P7.forward": [[195, 199], ["fpn.LastLevelP6P7.p6", "fpn.LastLevelP6P7.p7", "torch.relu"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "c5", ")", ":", "\n", "        ", "p6", "=", "self", ".", "p6", "(", "c5", ")", "\n", "p7", "=", "self", ".", "p7", "(", "F", ".", "relu", "(", "p6", ")", ")", "\n", "return", "[", "p6", ",", "p7", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn._assert_strides_are_log2_contiguous": [[155, 162], ["enumerate"], "function", ["None"], ["", "", "def", "_assert_strides_are_log2_contiguous", "(", "strides", ")", ":", "\n", "    ", "\"\"\"\n    Assert that each stride is 2x times its preceding stride, i.e. \"contiguous in log2\".\n    \"\"\"", "\n", "for", "i", ",", "stride", "in", "enumerate", "(", "strides", "[", "1", ":", "]", ",", "1", ")", ":", "\n", "        ", "assert", "stride", "==", "2", "*", "strides", "[", "i", "-", "1", "]", ",", "\"Strides {} {} are not log2 contiguous\"", ".", "format", "(", "\n", "stride", ",", "strides", "[", "i", "-", "1", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.build_resnet_fpn_backbone": [[201, 222], ["build.BACKBONE_REGISTRY.register", "resnet.build_resnet_backbone", "fpn.FPN", "fpn.LastLevelMaxPool"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.build_resnet_backbone"], ["", "", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_resnet_fpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg: a detectron2 CfgNode\n\n    Returns:\n        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.\n    \"\"\"", "\n", "bottom_up", "=", "build_resnet_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "\n", "backbone", "=", "FPN", "(", "\n", "bottom_up", "=", "bottom_up", ",", "\n", "in_features", "=", "in_features", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "NORM", ",", "\n", "top_block", "=", "LastLevelMaxPool", "(", ")", ",", "\n", "fuse_type", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", ",", "\n", ")", "\n", "return", "backbone", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.fpn.build_retinanet_resnet_fpn_backbone": [[224, 246], ["build.BACKBONE_REGISTRY.register", "resnet.build_resnet_backbone", "fpn.FPN", "resnet.build_resnet_backbone.output_shape", "fpn.LastLevelP6P7"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.build_resnet_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_retinanet_resnet_fpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg: a detectron2 CfgNode\n\n    Returns:\n        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.\n    \"\"\"", "\n", "bottom_up", "=", "build_resnet_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "\n", "in_channels_p6p7", "=", "bottom_up", ".", "output_shape", "(", ")", "[", "\"res5\"", "]", ".", "channels", "\n", "backbone", "=", "FPN", "(", "\n", "bottom_up", "=", "bottom_up", ",", "\n", "in_features", "=", "in_features", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "NORM", ",", "\n", "top_block", "=", "LastLevelP6P7", "(", "in_channels_p6p7", ",", "out_channels", ")", ",", "\n", "fuse_type", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", ",", "\n", ")", "\n", "return", "backbone", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.BasicBlock.__init__": [[39, 85], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "*", ",", "stride", "=", "1", ",", "norm", "=", "\"BN\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_channels (int): Number of input channels.\n            out_channels (int): Number of output channels.\n            stride (int): Stride for the first conv.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv2", "=", "Conv2d", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.BasicBlock.forward": [[86, 99], ["resnet.BasicBlock.conv1", "torch.relu_", "torch.relu_", "resnet.BasicBlock.conv2", "torch.relu_", "torch.relu_", "resnet.BasicBlock.shortcut"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.BottleneckBlock.__init__": [[108, 182], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "dilation", "=", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            bottleneck_channels (int): number of output channels for the 3x3\n                \"bottleneck\" conv layers.\n            num_groups (int): number of groups for the 3x3 conv layer.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n            stride_in_1x1 (bool): when stride>1, whether to put stride in the\n                first 1x1 convolution or the bottleneck 3x3 convolution.\n            dilation (int): the dilation rate of the 3x3 conv layer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "# The original MSRA ResNet models have stride in the first 1x1 conv", "\n", "# The subsequent fb.torch.resnet and Caffe2 ResNe[X]t implementations have", "\n", "# stride in the 3x3 conv", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv2", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "padding", "=", "1", "*", "dilation", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "num_groups", ",", "\n", "dilation", "=", "dilation", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv3", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.BottleneckBlock.forward": [[195, 212], ["resnet.BottleneckBlock.conv1", "torch.relu_", "torch.relu_", "resnet.BottleneckBlock.conv2", "torch.relu_", "torch.relu_", "resnet.BottleneckBlock.conv3", "torch.relu_", "torch.relu_", "resnet.BottleneckBlock.shortcut"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.DeformBottleneckBlock.__init__": [[220, 303], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "deform_conv_op", "detectron2.layers.Conv2d", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "dilation", "=", "1", ",", "\n", "deform_modulated", "=", "False", ",", "\n", "deform_num_groups", "=", "1", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "self", ".", "deform_modulated", "=", "deform_modulated", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "if", "deform_modulated", ":", "\n", "            ", "deform_conv_op", "=", "ModulatedDeformConv", "\n", "# offset channels are 2 or 3 (if with modulated) * kernel_size * kernel_size", "\n", "offset_channels", "=", "27", "\n", "", "else", ":", "\n", "            ", "deform_conv_op", "=", "DeformConv", "\n", "offset_channels", "=", "18", "\n", "\n", "", "self", ".", "conv2_offset", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "offset_channels", "*", "deform_num_groups", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "padding", "=", "1", "*", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", ")", "\n", "self", ".", "conv2", "=", "deform_conv_op", "(", "\n", "bottleneck_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "padding", "=", "1", "*", "dilation", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "num_groups", ",", "\n", "dilation", "=", "dilation", ",", "\n", "deformable_groups", "=", "deform_num_groups", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv3", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n", "", "", "nn", ".", "init", ".", "constant_", "(", "self", ".", "conv2_offset", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "conv2_offset", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.DeformBottleneckBlock.forward": [[304, 329], ["resnet.DeformBottleneckBlock.conv1", "torch.relu_", "torch.relu_", "torch.relu_", "torch.relu_", "resnet.DeformBottleneckBlock.conv3", "torch.relu_", "torch.relu_", "resnet.DeformBottleneckBlock.conv2_offset", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask.sigmoid.sigmoid.sigmoid", "resnet.DeformBottleneckBlock.conv2", "resnet.DeformBottleneckBlock.conv2_offset", "resnet.DeformBottleneckBlock.conv2", "resnet.DeformBottleneckBlock.shortcut"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "if", "self", ".", "deform_modulated", ":", "\n", "            ", "offset_mask", "=", "self", ".", "conv2_offset", "(", "out", ")", "\n", "offset_x", ",", "offset_y", ",", "mask", "=", "torch", ".", "chunk", "(", "offset_mask", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "offset_x", ",", "offset_y", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "mask", ".", "sigmoid", "(", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ",", "offset", ",", "mask", ")", "\n", "", "else", ":", "\n", "            ", "offset", "=", "self", ".", "conv2_offset", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ",", "offset", ")", "\n", "", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.BasicStem.__init__": [[336, 354], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["def", "__init__", "(", "self", ",", "in_channels", "=", "3", ",", "out_channels", "=", "64", ",", "norm", "=", "\"BN\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            norm (str or callable): norm after the first conv layer.\n                See :func:`layers.get_norm` for supported format.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "4", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "7", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "3", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "conv1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.BasicStem.forward": [[355, 360], ["resnet.BasicStem.conv1", "torch.relu_", "torch.relu_", "torch.max_pool2d", "torch.max_pool2d"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "F", ".", "relu_", "(", "x", ")", "\n", "x", "=", "F", ".", "max_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.ResNet.__init__": [[367, 421], ["backbone.Backbone.__init__", "enumerate", "len", "len", "torch.nn.Sequential", "torch.nn.Sequential", "resnet.ResNet.add_module", "resnet.ResNet.stages_and_names.append", "int", "torch.nn.AdaptiveAvgPool2d", "torch.nn.AdaptiveAvgPool2d", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.normal_", "torch.nn.init.normal_", "len", "isinstance", "str", "resnet.ResNet.named_children", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "stem", ",", "stages", ",", "num_classes", "=", "None", ",", "out_features", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            stem (nn.Module): a stem module\n            stages (list[list[CNNBlockBase]]): several (typically 4) stages,\n                each contains multiple :class:`CNNBlockBase`.\n            num_classes (None or int): if None, will not perform classification.\n                Otherwise, will create a linear layer.\n            out_features (list[str]): name of the layers whose outputs should\n                be returned in forward. Can be anything in \"stem\", \"linear\", or \"res2\" ...\n                If None, will return the output of the last layer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "stem", "=", "stem", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "current_stride", "=", "self", ".", "stem", ".", "stride", "\n", "self", ".", "_out_feature_strides", "=", "{", "\"stem\"", ":", "current_stride", "}", "\n", "self", ".", "_out_feature_channels", "=", "{", "\"stem\"", ":", "self", ".", "stem", ".", "out_channels", "}", "\n", "\n", "self", ".", "stages_and_names", "=", "[", "]", "\n", "for", "i", ",", "blocks", "in", "enumerate", "(", "stages", ")", ":", "\n", "            ", "assert", "len", "(", "blocks", ")", ">", "0", ",", "len", "(", "blocks", ")", "\n", "for", "block", "in", "blocks", ":", "\n", "                ", "assert", "isinstance", "(", "block", ",", "CNNBlockBase", ")", ",", "block", "\n", "\n", "", "name", "=", "\"res\"", "+", "str", "(", "i", "+", "2", ")", "\n", "stage", "=", "nn", ".", "Sequential", "(", "*", "blocks", ")", "\n", "\n", "self", ".", "add_module", "(", "name", ",", "stage", ")", "\n", "self", ".", "stages_and_names", ".", "append", "(", "(", "stage", ",", "name", ")", ")", "\n", "\n", "self", ".", "_out_feature_strides", "[", "name", "]", "=", "current_stride", "=", "int", "(", "\n", "current_stride", "*", "np", ".", "prod", "(", "[", "k", ".", "stride", "for", "k", "in", "blocks", "]", ")", "\n", ")", "\n", "self", ".", "_out_feature_channels", "[", "name", "]", "=", "curr_channels", "=", "blocks", "[", "-", "1", "]", ".", "out_channels", "\n", "\n", "", "if", "num_classes", "is", "not", "None", ":", "\n", "            ", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "curr_channels", ",", "num_classes", ")", "\n", "\n", "# Sec 5.1 in \"Accurate, Large Minibatch SGD: Training ImageNet in 1 Hour\":", "\n", "# \"The 1000-way fully-connected layer is initialized by", "\n", "# drawing weights from a zero-mean Gaussian with standard deviation of 0.01.\"", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "linear", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "name", "=", "\"linear\"", "\n", "\n", "", "if", "out_features", "is", "None", ":", "\n", "            ", "out_features", "=", "[", "name", "]", "\n", "", "self", ".", "_out_features", "=", "out_features", "\n", "assert", "len", "(", "self", ".", "_out_features", ")", "\n", "children", "=", "[", "x", "[", "0", "]", "for", "x", "in", "self", ".", "named_children", "(", ")", "]", "\n", "for", "out_feature", "in", "self", ".", "_out_features", ":", "\n", "            ", "assert", "out_feature", "in", "children", ",", "\"Available children: {}\"", ".", "format", "(", "\", \"", ".", "join", "(", "children", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.ResNet.forward": [[422, 446], ["resnet.ResNet.stem", "resnet.ResNet.dim", "stage", "resnet.ResNet.avgpool", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "resnet.ResNet.linear"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: Tensor of shape (N,C,H,W). H, W must be a multiple of ``self.size_divisibility``.\n\n        Returns:\n            dict[str->Tensor]: names and the corresponding features\n        \"\"\"", "\n", "assert", "x", ".", "dim", "(", ")", "==", "4", ",", "f\"ResNet takes an input of shape (N, C, H, W). Got {x.shape} instead!\"", "\n", "outputs", "=", "{", "}", "\n", "x", "=", "self", ".", "stem", "(", "x", ")", "\n", "if", "\"stem\"", "in", "self", ".", "_out_features", ":", "\n", "            ", "outputs", "[", "\"stem\"", "]", "=", "x", "\n", "", "for", "stage", ",", "name", "in", "self", ".", "stages_and_names", ":", "\n", "            ", "x", "=", "stage", "(", "x", ")", "\n", "if", "name", "in", "self", ".", "_out_features", ":", "\n", "                ", "outputs", "[", "name", "]", "=", "x", "\n", "", "", "if", "self", ".", "num_classes", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "if", "\"linear\"", "in", "self", ".", "_out_features", ":", "\n", "                ", "outputs", "[", "\"linear\"", "]", "=", "x", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.ResNet.output_shape": [[447, 453], ["detectron2.layers.ShapeSpec"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "name", ":", "ShapeSpec", "(", "\n", "channels", "=", "self", ".", "_out_feature_channels", "[", "name", "]", ",", "stride", "=", "self", ".", "_out_feature_strides", "[", "name", "]", "\n", ")", "\n", "for", "name", "in", "self", ".", "_out_features", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.ResNet.freeze": [[455, 478], ["enumerate", "resnet.ResNet.stem.freeze", "stage.children", "block.freeze"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze"], ["", "def", "freeze", "(", "self", ",", "freeze_at", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Freeze the first several stages of the ResNet. Commonly used in\n        fine-tuning.\n\n        Layers that produce the same feature map spatial size are defined as one\n        \"stage\" by :paper:`FPN`.\n\n        Args:\n            freeze_at (int): number of stages to freeze.\n                `1` means freezing the stem. `2` means freezing the stem and\n                one residual stage, etc.\n\n        Returns:\n            nn.Module: this ResNet itself\n        \"\"\"", "\n", "if", "freeze_at", ">=", "1", ":", "\n", "            ", "self", ".", "stem", ".", "freeze", "(", ")", "\n", "", "for", "idx", ",", "(", "stage", ",", "_", ")", "in", "enumerate", "(", "self", ".", "stages_and_names", ",", "start", "=", "2", ")", ":", "\n", "            ", "if", "freeze_at", ">=", "idx", ":", "\n", "                ", "for", "block", "in", "stage", ".", "children", "(", ")", ":", "\n", "                    ", "block", ".", "freeze", "(", ")", "\n", "", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.ResNet.make_stage": [[479, 545], ["range", "logging.getLogger", "logging.getLogger.warning", "kwargs.items", "blocks.append", "k.endswith", "block_class", "len", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_stage", "(", "\n", "block_class", ",", "num_blocks", ",", "first_stride", "=", "None", ",", "*", ",", "in_channels", ",", "out_channels", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Create a list of blocks of the same type that forms one ResNet stage.\n\n        Args:\n            block_class (type): a subclass of CNNBlockBase that's used to create all blocks in this\n                stage. A module of this type must not change spatial resolution of inputs unless its\n                stride != 1.\n            num_blocks (int): number of blocks in this stage\n            first_stride (int): deprecated\n            in_channels (int): input channels of the entire stage.\n            out_channels (int): output channels of **every block** in the stage.\n            kwargs: other arguments passed to the constructor of\n                `block_class`. If the argument name is \"xx_per_block\", the\n                argument is a list of values to be passed to each block in the\n                stage. Otherwise, the same argument is passed to every block\n                in the stage.\n\n        Returns:\n            list[nn.Module]: a list of block module.\n\n        Examples:\n        ::\n            stages = ResNet.make_stage(\n                BottleneckBlock, 3, in_channels=16, out_channels=64,\n                bottleneck_channels=16, num_groups=1,\n                stride_per_block=[2, 1, 1],\n                dilations_per_block=[1, 1, 2]\n            )\n\n        Usually, layers that produce the same feature map spatial size are defined as one\n        \"stage\" (in :paper:`FPN`). Under such definition, ``stride_per_block[1:]`` should\n        all be 1.\n        \"\"\"", "\n", "if", "first_stride", "is", "not", "None", ":", "\n", "            ", "assert", "\"stride\"", "not", "in", "kwargs", "and", "\"stride_per_block\"", "not", "in", "kwargs", "\n", "kwargs", "[", "\"stride_per_block\"", "]", "=", "[", "first_stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks", "-", "1", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"ResNet.make_stage(first_stride=) is deprecated!  \"", "\n", "\"Use 'stride_per_block' or 'stride' instead.\"", "\n", ")", "\n", "\n", "", "blocks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_blocks", ")", ":", "\n", "            ", "curr_kwargs", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", ".", "endswith", "(", "\"_per_block\"", ")", ":", "\n", "                    ", "assert", "len", "(", "v", ")", "==", "num_blocks", ",", "(", "\n", "f\"Argument '{k}' of make_stage should have the \"", "\n", "f\"same length as num_blocks={num_blocks}.\"", "\n", ")", "\n", "newk", "=", "k", "[", ":", "-", "len", "(", "\"_per_block\"", ")", "]", "\n", "assert", "newk", "not", "in", "kwargs", ",", "f\"Cannot call make_stage with both {k} and {newk}!\"", "\n", "curr_kwargs", "[", "newk", "]", "=", "v", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "curr_kwargs", "[", "k", "]", "=", "v", "\n", "\n", "", "", "blocks", ".", "append", "(", "\n", "block_class", "(", "in_channels", "=", "in_channels", ",", "out_channels", "=", "out_channels", ",", "**", "curr_kwargs", ")", "\n", ")", "\n", "in_channels", "=", "out_channels", "\n", "", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.make_stage": [[553, 558], ["resnet.ResNet.make_stage"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.make_stage"], ["def", "make_stage", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Deprecated alias for backward compatibiltiy.\n    \"\"\"", "\n", "return", "ResNet", ".", "make_stage", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.build_resnet_backbone": [[560, 645], ["build.BACKBONE_REGISTRY.register", "resnet.BasicStem", "max", "enumerate", "resnet.ResNet.freeze", "range", "resnet.ResNet.make_stage", "stages.append", "any", "resnet.ResNet"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.make_stage"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_resnet_backbone", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Create a ResNet instance from config.\n\n    Returns:\n        ResNet: a :class:`ResNet` instance.\n    \"\"\"", "\n", "# need registration of new blocks/stems?", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "stem", "=", "BasicStem", "(", "\n", "in_channels", "=", "input_shape", ".", "channels", ",", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", ",", "\n", "norm", "=", "norm", ",", "\n", ")", "\n", "\n", "# fmt: off", "\n", "freeze_at", "=", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "FREEZE_AT", "\n", "out_features", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "OUT_FEATURES", "\n", "depth", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEPTH", "\n", "num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", "\n", "width_per_group", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", "\n", "bottleneck_channels", "=", "num_groups", "*", "width_per_group", "\n", "in_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "\n", "stride_in_1x1", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STRIDE_IN_1X1", "\n", "res5_dilation", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES5_DILATION", "\n", "deform_on_per_stage", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_ON_PER_STAGE", "\n", "deform_modulated", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_MODULATED", "\n", "deform_num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_NUM_GROUPS", "\n", "# fmt: on", "\n", "assert", "res5_dilation", "in", "{", "1", ",", "2", "}", ",", "\"res5_dilation cannot be {}.\"", ".", "format", "(", "res5_dilation", ")", "\n", "\n", "num_blocks_per_stage", "=", "{", "\n", "18", ":", "[", "2", ",", "2", ",", "2", ",", "2", "]", ",", "\n", "34", ":", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "\n", "50", ":", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "\n", "101", ":", "[", "3", ",", "4", ",", "23", ",", "3", "]", ",", "\n", "152", ":", "[", "3", ",", "8", ",", "36", ",", "3", "]", ",", "\n", "}", "[", "depth", "]", "\n", "\n", "if", "depth", "in", "[", "18", ",", "34", "]", ":", "\n", "        ", "assert", "out_channels", "==", "64", ",", "\"Must set MODEL.RESNETS.RES2_OUT_CHANNELS = 64 for R18/R34\"", "\n", "assert", "not", "any", "(", "\n", "deform_on_per_stage", "\n", ")", ",", "\"MODEL.RESNETS.DEFORM_ON_PER_STAGE unsupported for R18/R34\"", "\n", "assert", "res5_dilation", "==", "1", ",", "\"Must set MODEL.RESNETS.RES5_DILATION = 1 for R18/R34\"", "\n", "assert", "num_groups", "==", "1", ",", "\"Must set MODEL.RESNETS.NUM_GROUPS = 1 for R18/R34\"", "\n", "\n", "", "stages", "=", "[", "]", "\n", "\n", "# Avoid creating variables without gradients", "\n", "# It consumes extra memory and may cause allreduce to fail", "\n", "out_stage_idx", "=", "[", "{", "\"res2\"", ":", "2", ",", "\"res3\"", ":", "3", ",", "\"res4\"", ":", "4", ",", "\"res5\"", ":", "5", "}", "[", "f", "]", "for", "f", "in", "out_features", "]", "\n", "max_stage_idx", "=", "max", "(", "out_stage_idx", ")", "\n", "for", "idx", ",", "stage_idx", "in", "enumerate", "(", "range", "(", "2", ",", "max_stage_idx", "+", "1", ")", ")", ":", "\n", "        ", "dilation", "=", "res5_dilation", "if", "stage_idx", "==", "5", "else", "1", "\n", "first_stride", "=", "1", "if", "idx", "==", "0", "or", "(", "stage_idx", "==", "5", "and", "dilation", "==", "2", ")", "else", "2", "\n", "stage_kargs", "=", "{", "\n", "\"num_blocks\"", ":", "num_blocks_per_stage", "[", "idx", "]", ",", "\n", "\"stride_per_block\"", ":", "[", "first_stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks_per_stage", "[", "idx", "]", "-", "1", ")", ",", "\n", "\"in_channels\"", ":", "in_channels", ",", "\n", "\"out_channels\"", ":", "out_channels", ",", "\n", "\"norm\"", ":", "norm", ",", "\n", "}", "\n", "# Use BasicBlock for R18 and R34.", "\n", "if", "depth", "in", "[", "18", ",", "34", "]", ":", "\n", "            ", "stage_kargs", "[", "\"block_class\"", "]", "=", "BasicBlock", "\n", "", "else", ":", "\n", "            ", "stage_kargs", "[", "\"bottleneck_channels\"", "]", "=", "bottleneck_channels", "\n", "stage_kargs", "[", "\"stride_in_1x1\"", "]", "=", "stride_in_1x1", "\n", "stage_kargs", "[", "\"dilation\"", "]", "=", "dilation", "\n", "stage_kargs", "[", "\"num_groups\"", "]", "=", "num_groups", "\n", "if", "deform_on_per_stage", "[", "idx", "]", ":", "\n", "                ", "stage_kargs", "[", "\"block_class\"", "]", "=", "DeformBottleneckBlock", "\n", "stage_kargs", "[", "\"deform_modulated\"", "]", "=", "deform_modulated", "\n", "stage_kargs", "[", "\"deform_num_groups\"", "]", "=", "deform_num_groups", "\n", "", "else", ":", "\n", "                ", "stage_kargs", "[", "\"block_class\"", "]", "=", "BottleneckBlock", "\n", "", "", "blocks", "=", "ResNet", ".", "make_stage", "(", "**", "stage_kargs", ")", "\n", "in_channels", "=", "out_channels", "\n", "out_channels", "*=", "2", "\n", "bottleneck_channels", "*=", "2", "\n", "stages", ".", "append", "(", "blocks", ")", "\n", "", "return", "ResNet", "(", "stem", ",", "stages", ",", "out_features", "=", "out_features", ")", ".", "freeze", "(", "freeze_at", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.__init__": [[15, 20], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        The `__init__` method of any subclass can specify its own set of arguments.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.forward": [[21, 30], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "forward", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Subclasses must override this method, but adhere to the same return type.\n\n        Returns:\n            dict[str->Tensor]: mapping from feature name (e.g., \"res2\") to tensor\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.size_divisibility": [[31, 41], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "size_divisibility", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Some backbones require the input height and width to be divisible by a\n        specific integer. This is typically true for encoder / decoder type networks\n        with lateral connection (e.g., FPN) for which feature maps need to match\n        dimension in the \"bottom up\" and \"top down\" paths. Set to 0 if no specific\n        input size divisibility is required.\n        \"\"\"", "\n", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape": [[42, 53], ["detectron2.layers.ShapeSpec"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[str->ShapeSpec]\n        \"\"\"", "\n", "# this is a backward-compatible default", "\n", "return", "{", "\n", "name", ":", "ShapeSpec", "(", "\n", "channels", "=", "self", ".", "_out_feature_channels", "[", "name", "]", ",", "stride", "=", "self", ".", "_out_feature_strides", "[", "name", "]", "\n", ")", "\n", "for", "name", "in", "self", ".", "_out_features", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.__init__": [[20, 222], ["torch.as_tensor", "tensor.reshape().to.reshape().to.size", "isinstance", "torch.device", "tensor.reshape().to.reshape().to.numel", "tensor.reshape().to.reshape().to.reshape().to", "tensor.reshape().to.reshape().to.dim", "tensor.reshape().to.reshape().to.size", "tensor.reshape().to.reshape().to.reshape"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["def", "__init__", "(", "self", ",", "tensor", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tensor (Tensor[float]): a Nx5 matrix.  Each row is\n                (x_center, y_center, width, height, angle),\n                in which angle is represented in degrees.\n                While there's no strict range restriction for it,\n                the recommended principal range is between [-180, 180) degrees.\n\n        Assume we have a horizontal box B = (x_center, y_center, width, height),\n        where width is along the x-axis and height is along the y-axis.\n        The rotated box B_rot (x_center, y_center, width, height, angle)\n        can be seen as:\n\n        1. When angle == 0:\n           B_rot == B\n        2. When angle > 0:\n           B_rot is obtained by rotating B w.r.t its center by :math:`|angle|` degrees CCW;\n        3. When angle < 0:\n           B_rot is obtained by rotating B w.r.t its center by :math:`|angle|` degrees CW.\n\n        Mathematically, since the right-handed coordinate system for image space\n        is (y, x), where y is top->down and x is left->right, the 4 vertices of the\n        rotated rectangle :math:`(yr_i, xr_i)` (i = 1, 2, 3, 4) can be obtained from\n        the vertices of the horizontal rectangle (y_i, x_i) (i = 1, 2, 3, 4)\n        in the following way (:math:`\\\\theta = angle*\\\\pi/180` is the angle in radians,\n        (y_c, x_c) is the center of the rectangle):\n\n        .. math::\n\n            yr_i = \\\\cos(\\\\theta) (y_i - y_c) - \\\\sin(\\\\theta) (x_i - x_c) + y_c,\n\n            xr_i = \\\\sin(\\\\theta) (y_i - y_c) + \\\\cos(\\\\theta) (x_i - x_c) + x_c,\n\n        which is the standard rigid-body rotation transformation.\n\n        Intuitively, the angle is\n        (1) the rotation angle from y-axis in image space\n        to the height vector (top->down in the box's local coordinate system)\n        of the box in CCW, and\n        (2) the rotation angle from x-axis in image space\n        to the width vector (left->right in the box's local coordinate system)\n        of the box in CCW.\n\n        More intuitively, consider the following horizontal box ABCD represented\n        in (x1, y1, x2, y2): (3, 2, 7, 4),\n        covering the [3, 7] x [2, 4] region of the continuous coordinate system\n        which looks like this:\n\n        .. code:: none\n\n            O--------> x\n            |\n            |  A---B\n            |  |   |\n            |  D---C\n            |\n            v y\n\n        Note that each capital letter represents one 0-dimensional geometric point\n        instead of a 'square pixel' here.\n\n        In the example above, using (x, y) to represent a point we have:\n\n        .. math::\n\n            O = (0, 0), A = (3, 2), B = (7, 2), C = (7, 4), D = (3, 4)\n\n        We name vector AB = vector DC as the width vector in box's local coordinate system, and\n        vector AD = vector BC as the height vector in box's local coordinate system. Initially,\n        when angle = 0 degree, they're aligned with the positive directions of x-axis and y-axis\n        in the image space, respectively.\n\n        For better illustration, we denote the center of the box as E,\n\n        .. code:: none\n\n            O--------> x\n            |\n            |  A---B\n            |  | E |\n            |  D---C\n            |\n            v y\n\n        where the center E = ((3+7)/2, (2+4)/2) = (5, 3).\n\n        Also,\n\n        .. math::\n\n            width = |AB| = |CD| = 7 - 3 = 4,\n            height = |AD| = |BC| = 4 - 2 = 2.\n\n        Therefore, the corresponding representation for the same shape in rotated box in\n        (x_center, y_center, width, height, angle) format is:\n\n        (5, 3, 4, 2, 0),\n\n        Now, let's consider (5, 3, 4, 2, 90), which is rotated by 90 degrees\n        CCW (counter-clockwise) by definition. It looks like this:\n\n        .. code:: none\n\n            O--------> x\n            |   B-C\n            |   | |\n            |   |E|\n            |   | |\n            |   A-D\n            v y\n\n        The center E is still located at the same point (5, 3), while the vertices\n        ABCD are rotated by 90 degrees CCW with regard to E:\n        A = (4, 5), B = (4, 1), C = (6, 1), D = (6, 5)\n\n        Here, 90 degrees can be seen as the CCW angle to rotate from y-axis to\n        vector AD or vector BC (the top->down height vector in box's local coordinate system),\n        or the CCW angle to rotate from x-axis to vector AB or vector DC (the left->right\n        width vector in box's local coordinate system).\n\n        .. math::\n\n            width = |AB| = |CD| = 5 - 1 = 4,\n            height = |AD| = |BC| = 6 - 4 = 2.\n\n        Next, how about (5, 3, 4, 2, -90), which is rotated by 90 degrees CW (clockwise)\n        by definition? It looks like this:\n\n        .. code:: none\n\n            O--------> x\n            |   D-A\n            |   | |\n            |   |E|\n            |   | |\n            |   C-B\n            v y\n\n        The center E is still located at the same point (5, 3), while the vertices\n        ABCD are rotated by 90 degrees CW with regard to E:\n        A = (6, 1), B = (6, 5), C = (4, 5), D = (4, 1)\n\n        .. math::\n\n            width = |AB| = |CD| = 5 - 1 = 4,\n            height = |AD| = |BC| = 6 - 4 = 2.\n\n        This covers exactly the same region as (5, 3, 4, 2, 90) does, and their IoU\n        will be 1. However, these two will generate different RoI Pooling results and\n        should not be treated as an identical box.\n\n        On the other hand, it's easy to see that (X, Y, W, H, A) is identical to\n        (X, Y, W, H, A+360N), for any integer N. For example (5, 3, 4, 2, 270) would be\n        identical to (5, 3, 4, 2, -90), because rotating the shape 270 degrees CCW is\n        equivalent to rotating the same shape 90 degrees CW.\n\n        We could rotate further to get (5, 3, 4, 2, 180), or (5, 3, 4, 2, -180):\n\n        .. code:: none\n\n            O--------> x\n            |\n            |  C---D\n            |  | E |\n            |  B---A\n            |\n            v y\n\n        .. math::\n\n            A = (7, 4), B = (3, 4), C = (3, 2), D = (7, 2),\n\n            width = |AB| = |CD| = 7 - 3 = 4,\n            height = |AD| = |BC| = 4 - 2 = 2.\n\n        Finally, this is a very inaccurate (heavily quantized) illustration of\n        how (5, 3, 4, 2, 60) looks like in case anyone wonders:\n\n        .. code:: none\n\n            O--------> x\n            |     B\\\n            |    /  C\n            |   /E /\n            |  A  /\n            |   `D\n            v y\n\n        It's still a rectangle with center of (5, 3), width of 4 and height of 2,\n        but its angle (and thus orientation) is somewhere between\n        (5, 3, 4, 2, 0) and (5, 3, 4, 2, 90).\n        \"\"\"", "\n", "device", "=", "tensor", ".", "device", "if", "isinstance", "(", "tensor", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "tensor", "=", "torch", ".", "as_tensor", "(", "tensor", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "if", "tensor", ".", "numel", "(", ")", "==", "0", ":", "\n", "# Use reshape, so we don't end up creating a new tensor that does not depend on", "\n", "# the inputs (and consequently confuses jit)", "\n", "            ", "tensor", "=", "tensor", ".", "reshape", "(", "(", "0", ",", "5", ")", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "", "assert", "tensor", ".", "dim", "(", ")", "==", "2", "and", "tensor", ".", "size", "(", "-", "1", ")", "==", "5", ",", "tensor", ".", "size", "(", ")", "\n", "\n", "self", ".", "tensor", "=", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.clone": [[223, 231], ["rotated_boxes.RotatedBoxes", "rotated_boxes.RotatedBoxes.tensor.clone"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "def", "clone", "(", "self", ")", "->", "\"RotatedBoxes\"", ":", "\n", "        ", "\"\"\"\n        Clone the RotatedBoxes.\n\n        Returns:\n            RotatedBoxes\n        \"\"\"", "\n", "return", "RotatedBoxes", "(", "self", ".", "tensor", ".", "clone", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.to": [[232, 234], ["rotated_boxes.RotatedBoxes", "rotated_boxes.RotatedBoxes.tensor.to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"RotatedBoxes\"", ":", "\n", "        ", "return", "RotatedBoxes", "(", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.area": [[235, 245], ["None"], "methods", ["None"], ["", "def", "area", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Computes the area of all the boxes.\n\n        Returns:\n            torch.Tensor: a vector with areas of each box.\n        \"\"\"", "\n", "box", "=", "self", ".", "tensor", "\n", "area", "=", "box", "[", ":", ",", "2", "]", "*", "box", "[", ":", ",", "3", "]", "\n", "return", "area", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.normalize_angles": [[246, 251], ["None"], "methods", ["None"], ["", "def", "normalize_angles", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Restrict angles to the range of [-180, 180) degrees\n        \"\"\"", "\n", "self", ".", "tensor", "[", ":", ",", "4", "]", "=", "(", "self", ".", "tensor", "[", ":", ",", "4", "]", "+", "180.0", ")", "%", "360.0", "-", "180.0", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.clip": [[252, 301], ["rotated_boxes.RotatedBoxes.normalize_angles", "x1.clamp_", "y1.clamp_", "x2.clamp_", "y2.clamp_", "torch.min", "torch.min", "torch.where", "torch.abs"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.normalize_angles"], ["", "def", "clip", "(", "self", ",", "box_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "clip_angle_threshold", ":", "float", "=", "1.0", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Clip (in place) the boxes by limiting x coordinates to the range [0, width]\n        and y coordinates to the range [0, height].\n\n        For RRPN:\n        Only clip boxes that are almost horizontal with a tolerance of\n        clip_angle_threshold to maintain backward compatibility.\n\n        Rotated boxes beyond this threshold are not clipped for two reasons:\n\n        1. There are potentially multiple ways to clip a rotated box to make it\n           fit within the image.\n        2. It's tricky to make the entire rectangular box fit within the image\n           and still be able to not leave out pixels of interest.\n\n        Therefore we rely on ops like RoIAlignRotated to safely handle this.\n\n        Args:\n            box_size (height, width): The clipping box's size.\n            clip_angle_threshold:\n                Iff. abs(normalized(angle)) <= clip_angle_threshold (in degrees),\n                we do the clipping as horizontal boxes.\n        \"\"\"", "\n", "h", ",", "w", "=", "box_size", "\n", "\n", "# normalize angles to be within (-180, 180] degrees", "\n", "self", ".", "normalize_angles", "(", ")", "\n", "\n", "idx", "=", "torch", ".", "where", "(", "torch", ".", "abs", "(", "self", ".", "tensor", "[", ":", ",", "4", "]", ")", "<=", "clip_angle_threshold", ")", "[", "0", "]", "\n", "\n", "# convert to (x1, y1, x2, y2)", "\n", "x1", "=", "self", ".", "tensor", "[", "idx", ",", "0", "]", "-", "self", ".", "tensor", "[", "idx", ",", "2", "]", "/", "2.0", "\n", "y1", "=", "self", ".", "tensor", "[", "idx", ",", "1", "]", "-", "self", ".", "tensor", "[", "idx", ",", "3", "]", "/", "2.0", "\n", "x2", "=", "self", ".", "tensor", "[", "idx", ",", "0", "]", "+", "self", ".", "tensor", "[", "idx", ",", "2", "]", "/", "2.0", "\n", "y2", "=", "self", ".", "tensor", "[", "idx", ",", "1", "]", "+", "self", ".", "tensor", "[", "idx", ",", "3", "]", "/", "2.0", "\n", "\n", "# clip", "\n", "x1", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "y1", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "x2", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "y2", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "\n", "# convert back to (xc, yc, w, h)", "\n", "self", ".", "tensor", "[", "idx", ",", "0", "]", "=", "(", "x1", "+", "x2", ")", "/", "2.0", "\n", "self", ".", "tensor", "[", "idx", ",", "1", "]", "=", "(", "y1", "+", "y2", ")", "/", "2.0", "\n", "# make sure widths and heights do not increase due to numerical errors", "\n", "self", ".", "tensor", "[", "idx", ",", "2", "]", "=", "torch", ".", "min", "(", "self", ".", "tensor", "[", "idx", ",", "2", "]", ",", "x2", "-", "x1", ")", "\n", "self", ".", "tensor", "[", "idx", ",", "3", "]", "=", "torch", ".", "min", "(", "self", ".", "tensor", "[", "idx", ",", "3", "]", ",", "y2", "-", "y1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.nonempty": [[302, 316], ["None"], "methods", ["None"], ["", "def", "nonempty", "(", "self", ",", "threshold", ":", "float", "=", "0.0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Find boxes that are non-empty.\n        A box is considered empty, if either of its side is no larger than threshold.\n\n        Returns:\n            Tensor: a binary vector which represents\n            whether each box is empty (False) or non-empty (True).\n        \"\"\"", "\n", "box", "=", "self", ".", "tensor", "\n", "widths", "=", "box", "[", ":", ",", "2", "]", "\n", "heights", "=", "box", "[", ":", ",", "3", "]", "\n", "keep", "=", "(", "widths", ">", "threshold", ")", "&", "(", "heights", ">", "threshold", ")", "\n", "return", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.__getitem__": [[317, 339], ["isinstance", "rotated_boxes.RotatedBoxes", "rotated_boxes.RotatedBoxes", "b.dim", "rotated_boxes.RotatedBoxes.tensor[].view"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"RotatedBoxes\"", ":", "\n", "        ", "\"\"\"\n        Returns:\n            RotatedBoxes: Create a new :class:`RotatedBoxes` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_boxes = boxes[3]`: return a `RotatedBoxes` which contains only one box.\n        2. `new_boxes = boxes[2:10]`: return a slice of boxes.\n        3. `new_boxes = boxes[vector]`, where vector is a torch.ByteTensor\n           with `length = len(boxes)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned RotatedBoxes might share storage with this RotatedBoxes,\n        subject to Pytorch's indexing semantics.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "return", "RotatedBoxes", "(", "self", ".", "tensor", "[", "item", "]", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "", "b", "=", "self", ".", "tensor", "[", "item", "]", "\n", "assert", "b", ".", "dim", "(", ")", "==", "2", ",", "\"Indexing on RotatedBoxes with {} failed to return a matrix!\"", ".", "format", "(", "\n", "item", "\n", ")", "\n", "return", "RotatedBoxes", "(", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.__len__": [[340, 342], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.__repr__": [[343, 345], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "\"RotatedBoxes(\"", "+", "str", "(", "self", ".", "tensor", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.inside_box": [[346, 382], ["torch.abs", "torch.abs", "torch.cos", "torch.sin"], "methods", ["None"], ["", "def", "inside_box", "(", "self", ",", "box_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "boundary_threshold", ":", "int", "=", "0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Args:\n            box_size (height, width): Size of the reference box covering\n                [0, width] x [0, height]\n            boundary_threshold (int): Boxes that extend beyond the reference box\n                boundary by more than boundary_threshold are considered \"outside\".\n\n        For RRPN, it might not be necessary to call this function since it's common\n        for rotated box to extend to outside of the image boundaries\n        (the clip function only clips the near-horizontal boxes)\n\n        Returns:\n            a binary vector, indicating whether each box is inside the reference box.\n        \"\"\"", "\n", "height", ",", "width", "=", "box_size", "\n", "\n", "cnt_x", "=", "self", ".", "tensor", "[", "...", ",", "0", "]", "\n", "cnt_y", "=", "self", ".", "tensor", "[", "...", ",", "1", "]", "\n", "half_w", "=", "self", ".", "tensor", "[", "...", ",", "2", "]", "/", "2.0", "\n", "half_h", "=", "self", ".", "tensor", "[", "...", ",", "3", "]", "/", "2.0", "\n", "a", "=", "self", ".", "tensor", "[", "...", ",", "4", "]", "\n", "c", "=", "torch", ".", "abs", "(", "torch", ".", "cos", "(", "a", "*", "math", ".", "pi", "/", "180.0", ")", ")", "\n", "s", "=", "torch", ".", "abs", "(", "torch", ".", "sin", "(", "a", "*", "math", ".", "pi", "/", "180.0", ")", ")", "\n", "# This basically computes the horizontal bounding rectangle of the rotated box", "\n", "max_rect_dx", "=", "c", "*", "half_w", "+", "s", "*", "half_h", "\n", "max_rect_dy", "=", "c", "*", "half_h", "+", "s", "*", "half_w", "\n", "\n", "inds_inside", "=", "(", "\n", "(", "cnt_x", "-", "max_rect_dx", ">=", "-", "boundary_threshold", ")", "\n", "&", "(", "cnt_y", "-", "max_rect_dy", ">=", "-", "boundary_threshold", ")", "\n", "&", "(", "cnt_x", "+", "max_rect_dx", "<", "width", "+", "boundary_threshold", ")", "\n", "&", "(", "cnt_y", "+", "max_rect_dy", "<", "height", "+", "boundary_threshold", ")", "\n", ")", "\n", "\n", "return", "inds_inside", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.get_centers": [[383, 389], ["None"], "methods", ["None"], ["", "def", "get_centers", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Returns:\n            The box centers in a Nx2 array of (x, y).\n        \"\"\"", "\n", "return", "self", ".", "tensor", "[", ":", ",", ":", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.scale": [[390, 454], ["torch.cos", "torch.sin", "torch.sqrt", "torch.sqrt", "torch.atan2"], "methods", ["None"], ["", "def", "scale", "(", "self", ",", "scale_x", ":", "float", ",", "scale_y", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Scale the rotated box with horizontal and vertical scaling factors\n        Note: when scale_factor_x != scale_factor_y,\n        the rotated box does not preserve the rectangular shape when the angle\n        is not a multiple of 90 degrees under resize transformation.\n        Instead, the shape is a parallelogram (that has skew)\n        Here we make an approximation by fitting a rotated rectangle to the parallelogram.\n        \"\"\"", "\n", "self", ".", "tensor", "[", ":", ",", "0", "]", "*=", "scale_x", "\n", "self", ".", "tensor", "[", ":", ",", "1", "]", "*=", "scale_y", "\n", "theta", "=", "self", ".", "tensor", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180.0", "\n", "c", "=", "torch", ".", "cos", "(", "theta", ")", "\n", "s", "=", "torch", ".", "sin", "(", "theta", ")", "\n", "\n", "# In image space, y is top->down and x is left->right", "\n", "# Consider the local coordintate system for the rotated box,", "\n", "# where the box center is located at (0, 0), and the four vertices ABCD are", "\n", "# A(-w / 2, -h / 2), B(w / 2, -h / 2), C(w / 2, h / 2), D(-w / 2, h / 2)", "\n", "# the midpoint of the left edge AD of the rotated box E is:", "\n", "# E = (A+D)/2 = (-w / 2, 0)", "\n", "# the midpoint of the top edge AB of the rotated box F is:", "\n", "# F(0, -h / 2)", "\n", "# To get the old coordinates in the global system, apply the rotation transformation", "\n", "# (Note: the right-handed coordinate system for image space is yOx):", "\n", "# (old_x, old_y) = (s * y + c * x, c * y - s * x)", "\n", "# E(old) = (s * 0 + c * (-w/2), c * 0 - s * (-w/2)) = (-c * w / 2, s * w / 2)", "\n", "# F(old) = (s * (-h / 2) + c * 0, c * (-h / 2) - s * 0) = (-s * h / 2, -c * h / 2)", "\n", "# After applying the scaling factor (sfx, sfy):", "\n", "# E(new) = (-sfx * c * w / 2, sfy * s * w / 2)", "\n", "# F(new) = (-sfx * s * h / 2, -sfy * c * h / 2)", "\n", "# The new width after scaling tranformation becomes:", "\n", "\n", "# w(new) = |E(new) - O| * 2", "\n", "#        = sqrt[(sfx * c * w / 2)^2 + (sfy * s * w / 2)^2] * 2", "\n", "#        = sqrt[(sfx * c)^2 + (sfy * s)^2] * w", "\n", "# i.e., scale_factor_w = sqrt[(sfx * c)^2 + (sfy * s)^2]", "\n", "#", "\n", "# For example,", "\n", "# when angle = 0 or 180, |c| = 1, s = 0, scale_factor_w == scale_factor_x;", "\n", "# when |angle| = 90, c = 0, |s| = 1, scale_factor_w == scale_factor_y", "\n", "self", ".", "tensor", "[", ":", ",", "2", "]", "*=", "torch", ".", "sqrt", "(", "(", "scale_x", "*", "c", ")", "**", "2", "+", "(", "scale_y", "*", "s", ")", "**", "2", ")", "\n", "\n", "# h(new) = |F(new) - O| * 2", "\n", "#        = sqrt[(sfx * s * h / 2)^2 + (sfy * c * h / 2)^2] * 2", "\n", "#        = sqrt[(sfx * s)^2 + (sfy * c)^2] * h", "\n", "# i.e., scale_factor_h = sqrt[(sfx * s)^2 + (sfy * c)^2]", "\n", "#", "\n", "# For example,", "\n", "# when angle = 0 or 180, |c| = 1, s = 0, scale_factor_h == scale_factor_y;", "\n", "# when |angle| = 90, c = 0, |s| = 1, scale_factor_h == scale_factor_x", "\n", "self", ".", "tensor", "[", ":", ",", "3", "]", "*=", "torch", ".", "sqrt", "(", "(", "scale_x", "*", "s", ")", "**", "2", "+", "(", "scale_y", "*", "c", ")", "**", "2", ")", "\n", "\n", "# The angle is the rotation angle from y-axis in image space to the height", "\n", "# vector (top->down in the box's local coordinate system) of the box in CCW.", "\n", "#", "\n", "# angle(new) = angle_yOx(O - F(new))", "\n", "#            = angle_yOx( (sfx * s * h / 2, sfy * c * h / 2) )", "\n", "#            = atan2(sfx * s * h / 2, sfy * c * h / 2)", "\n", "#            = atan2(sfx * s, sfy * c)", "\n", "#", "\n", "# For example,", "\n", "# when sfx == sfy, angle(new) == atan2(s, c) == angle(old)", "\n", "self", ".", "tensor", "[", ":", ",", "4", "]", "=", "torch", ".", "atan2", "(", "scale_x", "*", "s", ",", "scale_y", "*", "c", ")", "*", "180", "/", "math", ".", "pi", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.device": [[455, 458], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.__iter__": [[459, 464], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", "->", "Iterator", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Yield a box as a Tensor of shape (5,) at a time.\n        \"\"\"", "\n", "yield", "from", "self", ".", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.pairwise_iou": [[466, 482], ["detectron2.layers.rotated_boxes.pairwise_iou_rotated"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated"], ["", "", "def", "pairwise_iou", "(", "boxes1", ":", "RotatedBoxes", ",", "boxes2", ":", "RotatedBoxes", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Given two lists of rotated boxes of size N and M,\n    compute the IoU (intersection over union)\n    between __all__ N x M pairs of boxes.\n    The box order must be (x_center, y_center, width, height, angle).\n\n    Args:\n        boxes1, boxes2 (RotatedBoxes):\n            two `RotatedBoxes`. Contains N & M rotated boxes, respectively.\n\n    Returns:\n        Tensor: IoU, sized [N,M].\n    \"\"\"", "\n", "\n", "return", "pairwise_iou_rotated", "(", "boxes1", ".", "tensor", ",", "boxes2", ".", "tensor", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.__init__": [[20, 29], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "tensor", ":", "torch", ".", "Tensor", ",", "image_sizes", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            tensor (Tensor): of shape (N, H, W) or (N, C_1, ..., C_K, H, W) where K >= 1\n            image_sizes (list[tuple[int, int]]): Each tuple is (h, w). It can\n                be smaller than (H, W) due to padding.\n        \"\"\"", "\n", "self", ".", "tensor", "=", "tensor", "\n", "self", ".", "image_sizes", "=", "image_sizes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.__len__": [[30, 32], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "len", "(", "self", ".", "image_sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.__getitem__": [[33, 45], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Access the individual image in its original size.\n\n        Args:\n            idx: int or slice\n\n        Returns:\n            Tensor: an image of shape (H, W) or (C_1, ..., C_K, H, W) where K >= 1\n        \"\"\"", "\n", "size", "=", "self", ".", "image_sizes", "[", "idx", "]", "\n", "return", "self", ".", "tensor", "[", "idx", ",", "...", ",", ":", "size", "[", "0", "]", ",", ":", "size", "[", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.to": [[46, 50], ["image_list.ImageList.tensor.to", "image_list.ImageList"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"ImageList\"", ":", "\n", "        ", "cast_tensor", "=", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "return", "ImageList", "(", "cast_tensor", ",", "self", ".", "image_sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.device": [[51, 54], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "device", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors": [[55, 121], ["isinstance", "image_list.ImageList", "len", "isinstance", "type", "torch.stack().max", "torch.cat", "tuple", "len", "all", "tensors[].new_full", "zip", "F.pad.unsqueeze_.contiguous", "tensors[].unsqueeze", "torch.nn.functional.pad", "torch.nn.functional.pad.unsqueeze_", "tuple", "pad_img[].copy_", "torch.stack", "len", "torch.stack", "torch.as_tensor", "tuple"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "@", "staticmethod", "\n", "# https://github.com/pytorch/pytorch/issues/39308", "\n", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "from_tensors", "(", "\n", "tensors", ":", "Sequence", "[", "torch", ".", "Tensor", "]", ",", "size_divisibility", ":", "int", "=", "0", ",", "pad_value", ":", "float", "=", "0.0", "\n", ")", "->", "\"ImageList\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            tensors: a tuple or list of `torch.Tensors`, each of shape (Hi, Wi) or\n                (C_1, ..., C_K, Hi, Wi) where K >= 1. The Tensors will be padded\n                to the same shape with `pad_value`.\n            size_divisibility (int): If `size_divisibility > 0`, add padding to ensure\n                the common height and width is divisible by `size_divisibility`.\n                This depends on the model and many models need a divisibility of 32.\n            pad_value (float): value to pad\n\n        Returns:\n            an `ImageList`.\n        \"\"\"", "\n", "assert", "len", "(", "tensors", ")", ">", "0", "\n", "assert", "isinstance", "(", "tensors", ",", "(", "tuple", ",", "list", ")", ")", "\n", "for", "t", "in", "tensors", ":", "\n", "            ", "assert", "isinstance", "(", "t", ",", "torch", ".", "Tensor", ")", ",", "type", "(", "t", ")", "\n", "assert", "t", ".", "shape", "[", "1", ":", "-", "2", "]", "==", "tensors", "[", "0", "]", ".", "shape", "[", "1", ":", "-", "2", "]", ",", "t", ".", "shape", "\n", "# per dimension maximum (H, W) or (C_1, ..., C_K, H, W) where K >= 1 among all tensors", "\n", "", "max_size", "=", "(", "\n", "# In tracing mode, x.shape[i] is Tensor, and should not be converted", "\n", "# to int: this will cause the traced graph to have hard-coded shapes.", "\n", "# Instead we should make max_size a Tensor that depends on these tensors.", "\n", "# Using torch.stack twice seems to be the best way to convert", "\n", "# list[list[ScalarTensor]] to a Tensor", "\n", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "stack", "(", "[", "torch", ".", "as_tensor", "(", "dim", ")", "for", "dim", "in", "size", "]", ")", "\n", "for", "size", "in", "[", "tuple", "(", "img", ".", "shape", ")", "for", "img", "in", "tensors", "]", "\n", "]", "\n", ")", "\n", ".", "max", "(", "0", ")", "\n", ".", "values", "\n", ")", "\n", "\n", "if", "size_divisibility", ">", "1", ":", "\n", "            ", "stride", "=", "size_divisibility", "\n", "# the last two dims are H,W, both subject to divisibility requirement", "\n", "max_size", "=", "torch", ".", "cat", "(", "[", "max_size", "[", ":", "-", "2", "]", ",", "(", "max_size", "[", "-", "2", ":", "]", "+", "(", "stride", "-", "1", ")", ")", "//", "stride", "*", "stride", "]", ")", "\n", "\n", "", "image_sizes", "=", "[", "tuple", "(", "im", ".", "shape", "[", "-", "2", ":", "]", ")", "for", "im", "in", "tensors", "]", "\n", "\n", "if", "len", "(", "tensors", ")", "==", "1", ":", "\n", "# This seems slightly (2%) faster.", "\n", "# TODO: check whether it's faster for multiple images as well", "\n", "            ", "image_size", "=", "image_sizes", "[", "0", "]", "\n", "padding_size", "=", "[", "0", ",", "max_size", "[", "-", "1", "]", "-", "image_size", "[", "1", "]", ",", "0", ",", "max_size", "[", "-", "2", "]", "-", "image_size", "[", "0", "]", "]", "\n", "if", "all", "(", "x", "==", "0", "for", "x", "in", "padding_size", ")", ":", "# https://github.com/pytorch/pytorch/issues/31734", "\n", "                ", "batched_imgs", "=", "tensors", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "", "else", ":", "\n", "                ", "padded", "=", "F", ".", "pad", "(", "tensors", "[", "0", "]", ",", "padding_size", ",", "value", "=", "pad_value", ")", "\n", "batched_imgs", "=", "padded", ".", "unsqueeze_", "(", "0", ")", "\n", "", "", "else", ":", "\n", "# max_size can be a tensor in tracing mode, therefore use tuple()", "\n", "            ", "batch_shape", "=", "(", "len", "(", "tensors", ")", ",", ")", "+", "tuple", "(", "max_size", ")", "\n", "batched_imgs", "=", "tensors", "[", "0", "]", ".", "new_full", "(", "batch_shape", ",", "pad_value", ")", "\n", "for", "img", ",", "pad_img", "in", "zip", "(", "tensors", ",", "batched_imgs", ")", ":", "\n", "                ", "pad_img", "[", "...", ",", ":", "img", ".", "shape", "[", "-", "2", "]", ",", ":", "img", ".", "shape", "[", "-", "1", "]", "]", ".", "copy_", "(", "img", ")", "\n", "\n", "", "", "return", "ImageList", "(", "batched_imgs", ".", "contiguous", "(", ")", ",", "image_sizes", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.__init__": [[38, 48], ["kwargs.items", "instances.Instances.set"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["def", "__init__", "(", "self", ",", "image_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "**", "kwargs", ":", "Any", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image_size (height, width): the spatial size of the image.\n            kwargs: fields to add to this `Instances`.\n        \"\"\"", "\n", "self", ".", "_image_size", "=", "image_size", "\n", "self", ".", "_fields", ":", "Dict", "[", "str", ",", "Any", "]", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "set", "(", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.image_size": [[49, 56], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "image_size", "(", "self", ")", "->", "Tuple", "[", "int", ",", "int", "]", ":", "\n", "        ", "\"\"\"\n        Returns:\n            tuple: height, width\n        \"\"\"", "\n", "return", "self", ".", "_image_size", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.__setattr__": [[57, 62], ["name.startswith", "super().__setattr__", "instances.Instances.set"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.__setattr__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "def", "__setattr__", "(", "self", ",", "name", ":", "str", ",", "val", ":", "Any", ")", "->", "None", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "\"_\"", ")", ":", "\n", "            ", "super", "(", ")", ".", "__setattr__", "(", "name", ",", "val", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "set", "(", "name", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.__getattr__": [[63, 67], ["AttributeError"], "methods", ["None"], ["", "", "def", "__getattr__", "(", "self", ",", "name", ":", "str", ")", "->", "Any", ":", "\n", "        ", "if", "name", "==", "\"_fields\"", "or", "name", "not", "in", "self", ".", "_fields", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Cannot find field '{}' in the given Instances!\"", ".", "format", "(", "name", ")", ")", "\n", "", "return", "self", ".", "_fields", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.set": [[68, 80], ["len", "len", "len", "len"], "methods", ["None"], ["", "def", "set", "(", "self", ",", "name", ":", "str", ",", "value", ":", "Any", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Set the field named `name` to `value`.\n        The length of `value` must be the number of instances,\n        and must agree with other existing fields in this object.\n        \"\"\"", "\n", "data_len", "=", "len", "(", "value", ")", "\n", "if", "len", "(", "self", ".", "_fields", ")", ":", "\n", "            ", "assert", "(", "\n", "len", "(", "self", ")", "==", "data_len", "\n", ")", ",", "\"Adding a field of length {} to a Instances of length {}\"", ".", "format", "(", "data_len", ",", "len", "(", "self", ")", ")", "\n", "", "self", ".", "_fields", "[", "name", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.has": [[81, 87], ["None"], "methods", ["None"], ["", "def", "has", "(", "self", ",", "name", ":", "str", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Returns:\n            bool: whether the field called `name` exists.\n        \"\"\"", "\n", "return", "name", "in", "self", ".", "_fields", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.remove": [[88, 93], ["None"], "methods", ["None"], ["", "def", "remove", "(", "self", ",", "name", ":", "str", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Remove the field called `name`.\n        \"\"\"", "\n", "del", "self", ".", "_fields", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.get": [[94, 99], ["None"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "name", ":", "str", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Returns the field called `name`.\n        \"\"\"", "\n", "return", "self", ".", "_fields", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.get_fields": [[100, 108], ["None"], "methods", ["None"], ["", "def", "get_fields", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict: a dict which maps names (str) to data of the fields\n\n        Modifying the returned dict will modify this instance.\n        \"\"\"", "\n", "return", "self", ".", "_fields", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.to": [[110, 121], ["instances.Instances", "instances.Instances._fields.items", "hasattr", "instances.Instances.set", "v.to.to.to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"Instances\"", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Instances: all fields are called with a `to(device)`, if the field has this method.\n        \"\"\"", "\n", "ret", "=", "Instances", "(", "self", ".", "_image_size", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "_fields", ".", "items", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "v", ",", "\"to\"", ")", ":", "\n", "                ", "v", "=", "v", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "ret", ".", "set", "(", "k", ",", "v", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.__getitem__": [[122, 141], ["instances.Instances", "instances.Instances._fields.items", "type", "instances.Instances.set", "IndexError", "slice", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"Instances\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            item: an index-like object and will be used to index all the fields.\n\n        Returns:\n            If `item` is a string, return the data in the corresponding field.\n            Otherwise, returns an `Instances` where all fields are indexed by `item`.\n        \"\"\"", "\n", "if", "type", "(", "item", ")", "==", "int", ":", "\n", "            ", "if", "item", ">=", "len", "(", "self", ")", "or", "item", "<", "-", "len", "(", "self", ")", ":", "\n", "                ", "raise", "IndexError", "(", "\"Instances index out of range!\"", ")", "\n", "", "else", ":", "\n", "                ", "item", "=", "slice", "(", "item", ",", "None", ",", "len", "(", "self", ")", ")", "\n", "\n", "", "", "ret", "=", "Instances", "(", "self", ".", "_image_size", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "_fields", ".", "items", "(", ")", ":", "\n", "            ", "ret", ".", "set", "(", "k", ",", "v", "[", "item", "]", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.__len__": [[142, 146], ["instances.Instances._fields.values", "NotImplementedError", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "for", "v", "in", "self", ".", "_fields", ".", "values", "(", ")", ":", "\n", "            ", "return", "len", "(", "v", ")", "\n", "", "raise", "NotImplementedError", "(", "\"Empty Instances does not support __len__!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.__iter__": [[147, 149], ["NotImplementedError"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"`Instances` object is not iterable!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.cat": [[150, 181], ["all", "instances.Instances", "instance_lists[]._fields.keys", "len", "len", "isinstance", "instances.Instances.set", "isinstance", "i.get", "torch.cat", "isinstance", "list", "hasattr", "itertools.chain", "type", "type().cat", "ValueError", "type", "type"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "@", "staticmethod", "\n", "def", "cat", "(", "instance_lists", ":", "List", "[", "\"Instances\"", "]", ")", "->", "\"Instances\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            instance_lists (list[Instances])\n\n        Returns:\n            Instances\n        \"\"\"", "\n", "assert", "all", "(", "isinstance", "(", "i", ",", "Instances", ")", "for", "i", "in", "instance_lists", ")", "\n", "assert", "len", "(", "instance_lists", ")", ">", "0", "\n", "if", "len", "(", "instance_lists", ")", "==", "1", ":", "\n", "            ", "return", "instance_lists", "[", "0", "]", "\n", "\n", "", "image_size", "=", "instance_lists", "[", "0", "]", ".", "image_size", "\n", "for", "i", "in", "instance_lists", "[", "1", ":", "]", ":", "\n", "            ", "assert", "i", ".", "image_size", "==", "image_size", "\n", "", "ret", "=", "Instances", "(", "image_size", ")", "\n", "for", "k", "in", "instance_lists", "[", "0", "]", ".", "_fields", ".", "keys", "(", ")", ":", "\n", "            ", "values", "=", "[", "i", ".", "get", "(", "k", ")", "for", "i", "in", "instance_lists", "]", "\n", "v0", "=", "values", "[", "0", "]", "\n", "if", "isinstance", "(", "v0", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "values", "=", "torch", ".", "cat", "(", "values", ",", "dim", "=", "0", ")", "\n", "", "elif", "isinstance", "(", "v0", ",", "list", ")", ":", "\n", "                ", "values", "=", "list", "(", "itertools", ".", "chain", "(", "*", "values", ")", ")", "\n", "", "elif", "hasattr", "(", "type", "(", "v0", ")", ",", "\"cat\"", ")", ":", "\n", "                ", "values", "=", "type", "(", "v0", ")", ".", "cat", "(", "values", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Unsupported type {} for concatenation\"", ".", "format", "(", "type", "(", "v0", ")", ")", ")", "\n", "", "ret", ".", "set", "(", "k", ",", "values", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.instances.Instances.__str__": [[182, 189], ["len", "instances.Instances._fields.items"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={}, \"", ".", "format", "(", "len", "(", "self", ")", ")", "\n", "s", "+=", "\"image_height={}, \"", ".", "format", "(", "self", ".", "_image_size", "[", "0", "]", ")", "\n", "s", "+=", "\"image_width={}, \"", ".", "format", "(", "self", ".", "_image_size", "[", "1", "]", ")", "\n", "s", "+=", "\"fields=[{}])\"", ".", "format", "(", "\", \"", ".", "join", "(", "(", "f\"{k}: {v}\"", "for", "k", ",", "v", "in", "self", ".", "_fields", ".", "items", "(", ")", ")", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.Keypoints.__init__": [[21, 32], ["torch.as_tensor", "isinstance", "torch.device", "torch.as_tensor.dim"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["def", "__init__", "(", "self", ",", "keypoints", ":", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", ",", "List", "[", "List", "[", "float", "]", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            keypoints: A Tensor, numpy array, or list of the x, y, and visibility of each keypoint.\n                The shape should be (N, K, 3) where N is the number of\n                instances, and K is the number of keypoints per instance.\n        \"\"\"", "\n", "device", "=", "keypoints", ".", "device", "if", "isinstance", "(", "keypoints", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "keypoints", "=", "torch", ".", "as_tensor", "(", "keypoints", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "assert", "keypoints", ".", "dim", "(", ")", "==", "3", "and", "keypoints", ".", "shape", "[", "2", "]", "==", "3", ",", "keypoints", ".", "shape", "\n", "self", ".", "tensor", "=", "keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.Keypoints.__len__": [[33, 35], ["keypoints.Keypoints.tensor.size"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.Keypoints.to": [[36, 38], ["type", "keypoints.Keypoints.tensor.to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"Keypoints\"", ":", "\n", "        ", "return", "type", "(", "self", ")", "(", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.Keypoints.device": [[39, 42], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "torch", ".", "device", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.Keypoints.to_heatmap": [[43, 59], ["keypoints._keypoints_to_heatmap"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints._keypoints_to_heatmap"], ["", "def", "to_heatmap", "(", "self", ",", "boxes", ":", "torch", ".", "Tensor", ",", "heatmap_size", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Convert keypoint annotations to a heatmap of one-hot labels for training,\n        as described in :paper:`Mask R-CNN`.\n\n        Arguments:\n            boxes: Nx4 tensor, the boxes to draw the keypoints to\n\n        Returns:\n            heatmaps:\n                A tensor of shape (N, K), each element is integer spatial label\n                in the range [0, heatmap_size**2 - 1] for each keypoint in the input.\n            valid:\n                A tensor of shape (N, K) containing whether each keypoint is in the roi or not.\n        \"\"\"", "\n", "return", "_keypoints_to_heatmap", "(", "self", ".", "tensor", ",", "boxes", ",", "heatmap_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.Keypoints.__getitem__": [[60, 77], ["isinstance", "keypoints.Keypoints", "keypoints.Keypoints"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"Keypoints\"", ":", "\n", "        ", "\"\"\"\n        Create a new `Keypoints` by indexing on this `Keypoints`.\n\n        The following usage are allowed:\n\n        1. `new_kpts = kpts[3]`: return a `Keypoints` which contains only one instance.\n        2. `new_kpts = kpts[2:10]`: return a slice of key points.\n        3. `new_kpts = kpts[vector]`, where vector is a torch.ByteTensor\n           with `length = len(kpts)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned Keypoints might share storage with this Keypoints,\n        subject to Pytorch's indexing semantics.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "return", "Keypoints", "(", "[", "self", ".", "tensor", "[", "item", "]", "]", ")", "\n", "", "return", "Keypoints", "(", "self", ".", "tensor", "[", "item", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.Keypoints.__repr__": [[78, 82], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={})\"", ".", "format", "(", "len", "(", "self", ".", "tensor", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints._keypoints_to_heatmap": [[85, 142], ["x.floor().long.floor().long", "y.floor().long.floor().long", "rois.numel", "rois.new().long", "rois.new().long", "x.floor().long.floor", "y.floor().long.floor", "rois.new", "rois.new"], "function", ["None"], ["", "", "def", "_keypoints_to_heatmap", "(", "\n", "keypoints", ":", "torch", ".", "Tensor", ",", "rois", ":", "torch", ".", "Tensor", ",", "heatmap_size", ":", "int", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "    ", "\"\"\"\n    Encode keypoint locations into a target heatmap for use in SoftmaxWithLoss across space.\n\n    Maps keypoints from the half-open interval [x1, x2) on continuous image coordinates to the\n    closed interval [0, heatmap_size - 1] on discrete image coordinates. We use the\n    continuous-discrete conversion from Heckbert 1990 (\"What is the coordinate of a pixel?\"):\n    d = floor(c) and c = d + 0.5, where d is a discrete coordinate and c is a continuous coordinate.\n\n    Arguments:\n        keypoints: tensor of keypoint locations in of shape (N, K, 3).\n        rois: Nx4 tensor of rois in xyxy format\n        heatmap_size: integer side length of square heatmap.\n\n    Returns:\n        heatmaps: A tensor of shape (N, K) containing an integer spatial label\n            in the range [0, heatmap_size**2 - 1] for each keypoint in the input.\n        valid: A tensor of shape (N, K) containing whether each keypoint is in\n            the roi or not.\n    \"\"\"", "\n", "\n", "if", "rois", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "return", "rois", ".", "new", "(", ")", ".", "long", "(", ")", ",", "rois", ".", "new", "(", ")", ".", "long", "(", ")", "\n", "", "offset_x", "=", "rois", "[", ":", ",", "0", "]", "\n", "offset_y", "=", "rois", "[", ":", ",", "1", "]", "\n", "scale_x", "=", "heatmap_size", "/", "(", "rois", "[", ":", ",", "2", "]", "-", "rois", "[", ":", ",", "0", "]", ")", "\n", "scale_y", "=", "heatmap_size", "/", "(", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", ")", "\n", "\n", "offset_x", "=", "offset_x", "[", ":", ",", "None", "]", "\n", "offset_y", "=", "offset_y", "[", ":", ",", "None", "]", "\n", "scale_x", "=", "scale_x", "[", ":", ",", "None", "]", "\n", "scale_y", "=", "scale_y", "[", ":", ",", "None", "]", "\n", "\n", "x", "=", "keypoints", "[", "...", ",", "0", "]", "\n", "y", "=", "keypoints", "[", "...", ",", "1", "]", "\n", "\n", "x_boundary_inds", "=", "x", "==", "rois", "[", ":", ",", "2", "]", "[", ":", ",", "None", "]", "\n", "y_boundary_inds", "=", "y", "==", "rois", "[", ":", ",", "3", "]", "[", ":", ",", "None", "]", "\n", "\n", "x", "=", "(", "x", "-", "offset_x", ")", "*", "scale_x", "\n", "x", "=", "x", ".", "floor", "(", ")", ".", "long", "(", ")", "\n", "y", "=", "(", "y", "-", "offset_y", ")", "*", "scale_y", "\n", "y", "=", "y", ".", "floor", "(", ")", ".", "long", "(", ")", "\n", "\n", "x", "[", "x_boundary_inds", "]", "=", "heatmap_size", "-", "1", "\n", "y", "[", "y_boundary_inds", "]", "=", "heatmap_size", "-", "1", "\n", "\n", "valid_loc", "=", "(", "x", ">=", "0", ")", "&", "(", "y", ">=", "0", ")", "&", "(", "x", "<", "heatmap_size", ")", "&", "(", "y", "<", "heatmap_size", ")", "\n", "vis", "=", "keypoints", "[", "...", ",", "2", "]", ">", "0", "\n", "valid", "=", "(", "valid_loc", "&", "vis", ")", ".", "long", "(", ")", "\n", "\n", "lin_ind", "=", "y", "*", "heatmap_size", "+", "x", "\n", "heatmaps", "=", "lin_ind", "*", "valid", "\n", "\n", "return", "heatmaps", ",", "valid", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.keypoints.heatmaps_to_keypoints": [[144, 217], ["maps.detach.detach", "rois.detach.detach", "widths.ceil", "heights.ceil", "maps.detach.new_zeros", "torch.arange", "range", "detectron2.layers.interpolate().squeeze", "interpolate().squeeze.view().max", "max_score.view.view", "interpolate().squeeze.view().argmax", "int", "int", "tmp_pool_resolution.sum", "detectron2.layers.interpolate", "interpolate().squeeze.view", "interpolate().squeeze.view", "x_int.float", "y_int.float", "roi_map_scores.view().max", "roi_map_scores.view"], "function", ["None"], ["", "def", "heatmaps_to_keypoints", "(", "maps", ":", "torch", ".", "Tensor", ",", "rois", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Extract predicted keypoint locations from heatmaps.\n\n    Args:\n        maps (Tensor): (#ROIs, #keypoints, POOL_H, POOL_W). The predicted heatmap of logits for\n            each ROI and each keypoint.\n        rois (Tensor): (#ROIs, 4). The box of each ROI.\n\n    Returns:\n        Tensor of shape (#ROIs, #keypoints, 4) with the last dimension corresponding to\n        (x, y, logit, score) for each keypoint.\n\n    When converting discrete pixel indices in an NxN image to a continuous keypoint coordinate,\n    we maintain consistency with :meth:`Keypoints.to_heatmap` by using the conversion from\n    Heckbert 1990: c = d + 0.5, where d is a discrete coordinate and c is a continuous coordinate.\n    \"\"\"", "\n", "# The decorator use of torch.no_grad() was not supported by torchscript.", "\n", "# https://github.com/pytorch/pytorch/pull/41371", "\n", "maps", "=", "maps", ".", "detach", "(", ")", "\n", "rois", "=", "rois", ".", "detach", "(", ")", "\n", "\n", "offset_x", "=", "rois", "[", ":", ",", "0", "]", "\n", "offset_y", "=", "rois", "[", ":", ",", "1", "]", "\n", "\n", "widths", "=", "(", "rois", "[", ":", ",", "2", "]", "-", "rois", "[", ":", ",", "0", "]", ")", ".", "clamp", "(", "min", "=", "1", ")", "\n", "heights", "=", "(", "rois", "[", ":", ",", "3", "]", "-", "rois", "[", ":", ",", "1", "]", ")", ".", "clamp", "(", "min", "=", "1", ")", "\n", "widths_ceil", "=", "widths", ".", "ceil", "(", ")", "\n", "heights_ceil", "=", "heights", ".", "ceil", "(", ")", "\n", "\n", "num_rois", ",", "num_keypoints", "=", "maps", ".", "shape", "[", ":", "2", "]", "\n", "xy_preds", "=", "maps", ".", "new_zeros", "(", "rois", ".", "shape", "[", "0", "]", ",", "num_keypoints", ",", "4", ")", "\n", "\n", "width_corrections", "=", "widths", "/", "widths_ceil", "\n", "height_corrections", "=", "heights", "/", "heights_ceil", "\n", "\n", "keypoints_idx", "=", "torch", ".", "arange", "(", "num_keypoints", ",", "device", "=", "maps", ".", "device", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_rois", ")", ":", "\n", "        ", "outsize", "=", "(", "int", "(", "heights_ceil", "[", "i", "]", ")", ",", "int", "(", "widths_ceil", "[", "i", "]", ")", ")", "\n", "roi_map", "=", "interpolate", "(", "maps", "[", "[", "i", "]", "]", ",", "size", "=", "outsize", ",", "mode", "=", "\"bicubic\"", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", "\n", "0", "\n", ")", "# #keypoints x H x W", "\n", "\n", "# softmax over the spatial region", "\n", "max_score", ",", "_", "=", "roi_map", ".", "view", "(", "num_keypoints", ",", "-", "1", ")", ".", "max", "(", "1", ")", "\n", "max_score", "=", "max_score", ".", "view", "(", "num_keypoints", ",", "1", ",", "1", ")", "\n", "tmp_full_resolution", "=", "(", "roi_map", "-", "max_score", ")", ".", "exp_", "(", ")", "\n", "tmp_pool_resolution", "=", "(", "maps", "[", "i", "]", "-", "max_score", ")", ".", "exp_", "(", ")", "\n", "# Produce scores over the region H x W, but normalize with POOL_H x POOL_W,", "\n", "# so that the scores of objects of different absolute sizes will be more comparable", "\n", "roi_map_scores", "=", "tmp_full_resolution", "/", "tmp_pool_resolution", ".", "sum", "(", "(", "1", ",", "2", ")", ",", "keepdim", "=", "True", ")", "\n", "\n", "w", "=", "roi_map", ".", "shape", "[", "2", "]", "\n", "pos", "=", "roi_map", ".", "view", "(", "num_keypoints", ",", "-", "1", ")", ".", "argmax", "(", "1", ")", "\n", "\n", "x_int", "=", "pos", "%", "w", "\n", "y_int", "=", "(", "pos", "-", "x_int", ")", "//", "w", "\n", "\n", "assert", "(", "\n", "roi_map_scores", "[", "keypoints_idx", ",", "y_int", ",", "x_int", "]", "\n", "==", "roi_map_scores", ".", "view", "(", "num_keypoints", ",", "-", "1", ")", ".", "max", "(", "1", ")", "[", "0", "]", "\n", ")", ".", "all", "(", ")", "\n", "\n", "x", "=", "(", "x_int", ".", "float", "(", ")", "+", "0.5", ")", "*", "width_corrections", "[", "i", "]", "\n", "y", "=", "(", "y_int", ".", "float", "(", ")", "+", "0.5", ")", "*", "height_corrections", "[", "i", "]", "\n", "\n", "xy_preds", "[", "i", ",", ":", ",", "0", "]", "=", "x", "+", "offset_x", "[", "i", "]", "\n", "xy_preds", "[", "i", ",", ":", ",", "1", "]", "=", "y", "+", "offset_y", "[", "i", "]", "\n", "xy_preds", "[", "i", ",", ":", ",", "2", "]", "=", "roi_map", "[", "keypoints_idx", ",", "y_int", ",", "x_int", "]", "\n", "xy_preds", "[", "i", ",", ":", ",", "3", "]", "=", "roi_map_scores", "[", "keypoints_idx", ",", "y_int", ",", "x_int", "]", "\n", "\n", "", "return", "xy_preds", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.__init__": [[93, 103], ["torch.as_tensor", "torch.as_tensor.size", "isinstance", "torch.device", "torch.as_tensor.dim"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["def", "__init__", "(", "self", ",", "tensor", ":", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tensor: bool Tensor of N,H,W, representing N instances in the image.\n        \"\"\"", "\n", "device", "=", "tensor", ".", "device", "if", "isinstance", "(", "tensor", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "tensor", "=", "torch", ".", "as_tensor", "(", "tensor", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "assert", "tensor", ".", "dim", "(", ")", "==", "3", ",", "tensor", ".", "size", "(", ")", "\n", "self", ".", "image_size", "=", "tensor", ".", "shape", "[", "1", ":", "]", "\n", "self", ".", "tensor", "=", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.to": [[104, 106], ["masks.BitMasks", "masks.BitMasks.tensor.to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"BitMasks\"", ":", "\n", "        ", "return", "BitMasks", "(", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.device": [[107, 110], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "torch", ".", "device", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.__getitem__": [[111, 133], ["isinstance", "masks.BitMasks", "masks.BitMasks", "m.dim", "masks.BitMasks.tensor[].view"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"BitMasks\"", ":", "\n", "        ", "\"\"\"\n        Returns:\n            BitMasks: Create a new :class:`BitMasks` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_masks = masks[3]`: return a `BitMasks` which contains only one mask.\n        2. `new_masks = masks[2:10]`: return a slice of masks.\n        3. `new_masks = masks[vector]`, where vector is a torch.BoolTensor\n           with `length = len(masks)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned object might share storage with this object,\n        subject to Pytorch's indexing semantics.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "return", "BitMasks", "(", "self", ".", "tensor", "[", "item", "]", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "", "m", "=", "self", ".", "tensor", "[", "item", "]", "\n", "assert", "m", ".", "dim", "(", ")", "==", "3", ",", "\"Indexing on BitMasks with {} returns a tensor with shape {}!\"", ".", "format", "(", "\n", "item", ",", "m", ".", "shape", "\n", ")", "\n", "return", "BitMasks", "(", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.__iter__": [[134, 136], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "yield", "from", "self", ".", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.__repr__": [[137, 141], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={})\"", ".", "format", "(", "len", "(", "self", ".", "tensor", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.__len__": [[142, 144], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.nonempty": [[145, 154], ["masks.BitMasks.tensor.flatten().any", "masks.BitMasks.tensor.flatten"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "def", "nonempty", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Find masks that are non-empty.\n\n        Returns:\n            Tensor: a BoolTensor which represents\n                whether each mask is empty (False) or non-empty (True).\n        \"\"\"", "\n", "return", "self", ".", "tensor", ".", "flatten", "(", "1", ")", ".", "any", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.from_polygon_masks": [[155, 168], ["isinstance", "masks.BitMasks", "masks.polygons_to_bitmask", "torch.stack", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.polygons_to_bitmask"], ["", "@", "staticmethod", "\n", "def", "from_polygon_masks", "(", "\n", "polygon_masks", ":", "Union", "[", "\"PolygonMasks\"", ",", "List", "[", "List", "[", "np", ".", "ndarray", "]", "]", "]", ",", "height", ":", "int", ",", "width", ":", "int", "\n", ")", "->", "\"BitMasks\"", ":", "\n", "        ", "\"\"\"\n        Args:\n            polygon_masks (list[list[ndarray]] or PolygonMasks)\n            height, width (int)\n        \"\"\"", "\n", "if", "isinstance", "(", "polygon_masks", ",", "PolygonMasks", ")", ":", "\n", "            ", "polygon_masks", "=", "polygon_masks", ".", "polygons", "\n", "", "masks", "=", "[", "polygons_to_bitmask", "(", "p", ",", "height", ",", "width", ")", "for", "p", "in", "polygon_masks", "]", "\n", "return", "BitMasks", "(", "torch", ".", "stack", "(", "[", "torch", ".", "from_numpy", "(", "x", ")", "for", "x", "in", "masks", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.crop_and_resize": [[169, 201], ["torch.cat", "masks.BitMasks.tensor.to", "rois.to.to.to", "detectron2.layers.roi_align.ROIAlign().forward().squeeze", "len", "len", "len", "len", "torch.arange().to", "detectron2.layers.roi_align.ROIAlign().forward", "torch.arange", "len", "detectron2.layers.roi_align.ROIAlign"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward"], ["", "def", "crop_and_resize", "(", "self", ",", "boxes", ":", "torch", ".", "Tensor", ",", "mask_size", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Crop each bitmask by the given box, and resize results to (mask_size, mask_size).\n        This can be used to prepare training targets for Mask R-CNN.\n        It has less reconstruction error compared to rasterization with polygons.\n        However we observe no difference in accuracy,\n        but BitMasks requires more memory to store all the masks.\n\n        Args:\n            boxes (Tensor): Nx4 tensor storing the boxes for each mask\n            mask_size (int): the size of the rasterized mask.\n\n        Returns:\n            Tensor:\n                A bool tensor of shape (N, mask_size, mask_size), where\n                N is the number of predicted boxes for this image.\n        \"\"\"", "\n", "assert", "len", "(", "boxes", ")", "==", "len", "(", "self", ")", ",", "\"{} != {}\"", ".", "format", "(", "len", "(", "boxes", ")", ",", "len", "(", "self", ")", ")", "\n", "device", "=", "self", ".", "tensor", ".", "device", "\n", "\n", "batch_inds", "=", "torch", ".", "arange", "(", "len", "(", "boxes", ")", ",", "device", "=", "device", ")", ".", "to", "(", "dtype", "=", "boxes", ".", "dtype", ")", "[", ":", ",", "None", "]", "\n", "rois", "=", "torch", ".", "cat", "(", "[", "batch_inds", ",", "boxes", "]", ",", "dim", "=", "1", ")", "# Nx5", "\n", "\n", "bit_masks", "=", "self", ".", "tensor", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "rois", "=", "rois", ".", "to", "(", "device", "=", "device", ")", "\n", "output", "=", "(", "\n", "ROIAlign", "(", "(", "mask_size", ",", "mask_size", ")", ",", "1.0", ",", "0", ",", "aligned", "=", "True", ")", "\n", ".", "forward", "(", "bit_masks", "[", ":", ",", "None", ",", ":", ",", ":", "]", ",", "rois", ")", "\n", ".", "squeeze", "(", "1", ")", "\n", ")", "\n", "output", "=", "output", ">=", "0.5", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.get_bounding_boxes": [[202, 219], ["torch.zeros", "torch.any", "torch.any", "range", "torch.zeros.Boxes", "torch.where", "torch.where", "torch.as_tensor", "len", "len"], "methods", ["None"], ["", "def", "get_bounding_boxes", "(", "self", ")", "->", "Boxes", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Boxes: tight bounding boxes around bitmasks.\n            If a mask is empty, it's bounding box will be all zero.\n        \"\"\"", "\n", "boxes", "=", "torch", ".", "zeros", "(", "self", ".", "tensor", ".", "shape", "[", "0", "]", ",", "4", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "x_any", "=", "torch", ".", "any", "(", "self", ".", "tensor", ",", "dim", "=", "1", ")", "\n", "y_any", "=", "torch", ".", "any", "(", "self", ".", "tensor", ",", "dim", "=", "2", ")", "\n", "for", "idx", "in", "range", "(", "self", ".", "tensor", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "x", "=", "torch", ".", "where", "(", "x_any", "[", "idx", ",", ":", "]", ")", "[", "0", "]", "\n", "y", "=", "torch", ".", "where", "(", "y_any", "[", "idx", ",", ":", "]", ")", "[", "0", "]", "\n", "if", "len", "(", "x", ")", ">", "0", "and", "len", "(", "y", ")", ">", "0", ":", "\n", "                ", "boxes", "[", "idx", ",", ":", "]", "=", "torch", ".", "as_tensor", "(", "\n", "[", "x", "[", "0", "]", ",", "y", "[", "0", "]", ",", "x", "[", "-", "1", "]", "+", "1", ",", "y", "[", "-", "1", "]", "+", "1", "]", ",", "dtype", "=", "torch", ".", "float32", "\n", ")", "\n", "", "", "return", "Boxes", "(", "boxes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.BitMasks.cat": [[220, 237], ["isinstance", "all", "len", "type", "torch.cat", "isinstance"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "@", "staticmethod", "\n", "def", "cat", "(", "bitmasks_list", ":", "List", "[", "\"BitMasks\"", "]", ")", "->", "\"BitMasks\"", ":", "\n", "        ", "\"\"\"\n        Concatenates a list of BitMasks into a single BitMasks\n\n        Arguments:\n            bitmasks_list (list[BitMasks])\n\n        Returns:\n            BitMasks: the concatenated BitMasks\n        \"\"\"", "\n", "assert", "isinstance", "(", "bitmasks_list", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "len", "(", "bitmasks_list", ")", ">", "0", "\n", "assert", "all", "(", "isinstance", "(", "bitmask", ",", "BitMasks", ")", "for", "bitmask", "in", "bitmasks_list", ")", "\n", "\n", "cat_bitmasks", "=", "type", "(", "bitmasks_list", "[", "0", "]", ")", "(", "torch", ".", "cat", "(", "[", "bm", ".", "tensor", "for", "bm", "in", "bitmasks_list", "]", ",", "dim", "=", "0", ")", ")", "\n", "return", "cat_bitmasks", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.__init__": [[247, 286], ["isinstance", "type", "isinstance", "numpy.asarray().astype", "isinstance", "masks.PolygonMasks.__init__.process_polygons"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "polygons", ":", "List", "[", "List", "[", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", "]", "]", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            polygons (list[list[np.ndarray]]): The first\n                level of the list correspond to individual instances,\n                the second level to all the polygons that compose the\n                instance, and the third level to the polygon coordinates.\n                The third level array should have the format of\n                [x0, y0, x1, y1, ..., xn, yn] (n >= 3).\n        \"\"\"", "\n", "assert", "isinstance", "(", "polygons", ",", "list", ")", ",", "(", "\n", "\"Cannot create PolygonMasks: Expect a list of list of polygons per image. \"", "\n", "\"Got '{}' instead.\"", ".", "format", "(", "type", "(", "polygons", ")", ")", "\n", ")", "\n", "\n", "def", "_make_array", "(", "t", ":", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "# Use float64 for higher precision, because why not?", "\n", "# Always put polygons on CPU (self.to is a no-op) since they", "\n", "# are supposed to be small tensors.", "\n", "# May need to change this assumption if GPU placement becomes useful", "\n", "            ", "if", "isinstance", "(", "t", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "t", "=", "t", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "return", "np", ".", "asarray", "(", "t", ")", ".", "astype", "(", "\"float64\"", ")", "\n", "\n", "", "def", "process_polygons", "(", "\n", "polygons_per_instance", ":", "List", "[", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", "]", "\n", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "            ", "assert", "isinstance", "(", "polygons_per_instance", ",", "list", ")", ",", "(", "\n", "\"Cannot create polygons: Expect a list of polygons per instance. \"", "\n", "\"Got '{}' instead.\"", ".", "format", "(", "type", "(", "polygons_per_instance", ")", ")", "\n", ")", "\n", "# transform the polygon to a tensor", "\n", "polygons_per_instance", "=", "[", "_make_array", "(", "p", ")", "for", "p", "in", "polygons_per_instance", "]", "\n", "for", "polygon", "in", "polygons_per_instance", ":", "\n", "                ", "assert", "len", "(", "polygon", ")", "%", "2", "==", "0", "and", "len", "(", "polygon", ")", ">=", "6", "\n", "", "return", "polygons_per_instance", "\n", "\n", "", "self", ".", "polygons", ":", "List", "[", "List", "[", "np", ".", "ndarray", "]", "]", "=", "[", "\n", "process_polygons", "(", "polygons_per_instance", ")", "for", "polygons_per_instance", "in", "polygons", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.to": [[288, 290], ["None"], "methods", ["None"], ["", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", "->", "\"PolygonMasks\"", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.device": [[291, 294], ["torch.device"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "torch", ".", "device", ":", "\n", "        ", "return", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.get_bounding_boxes": [[295, 311], ["torch.zeros", "enumerate", "torch.zeros.Boxes", "len", "torch.as_tensor", "torch.zeros", "torch.from_numpy().view().to", "torch.min", "torch.max", "float", "float", "torch.from_numpy().view", "torch.min", "torch.max", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "get_bounding_boxes", "(", "self", ")", "->", "Boxes", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Boxes: tight bounding boxes around polygon masks.\n        \"\"\"", "\n", "boxes", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "polygons", ")", ",", "4", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "for", "idx", ",", "polygons_per_instance", "in", "enumerate", "(", "self", ".", "polygons", ")", ":", "\n", "            ", "minxy", "=", "torch", ".", "as_tensor", "(", "[", "float", "(", "\"inf\"", ")", ",", "float", "(", "\"inf\"", ")", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "maxxy", "=", "torch", ".", "zeros", "(", "2", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "for", "polygon", "in", "polygons_per_instance", ":", "\n", "                ", "coords", "=", "torch", ".", "from_numpy", "(", "polygon", ")", ".", "view", "(", "-", "1", ",", "2", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "minxy", "=", "torch", ".", "min", "(", "minxy", ",", "torch", ".", "min", "(", "coords", ",", "dim", "=", "0", ")", ".", "values", ")", "\n", "maxxy", "=", "torch", ".", "max", "(", "maxxy", ",", "torch", ".", "max", "(", "coords", ",", "dim", "=", "0", ")", ".", "values", ")", "\n", "", "boxes", "[", "idx", ",", ":", "2", "]", "=", "minxy", "\n", "boxes", "[", "idx", ",", "2", ":", "]", "=", "maxxy", "\n", "", "return", "Boxes", "(", "boxes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.nonempty": [[312, 322], ["torch.from_numpy", "numpy.asarray", "len"], "methods", ["None"], ["", "def", "nonempty", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Find masks that are non-empty.\n\n        Returns:\n            Tensor:\n                a BoolTensor which represents whether each mask is empty (False) or not (True).\n        \"\"\"", "\n", "keep", "=", "[", "1", "if", "len", "(", "polygon", ")", ">", "0", "else", "0", "for", "polygon", "in", "self", ".", "polygons", "]", "\n", "return", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "keep", ",", "dtype", "=", "np", ".", "bool", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.__getitem__": [[323, 352], ["isinstance", "masks.PolygonMasks", "isinstance", "isinstance", "isinstance", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero().squeeze().cpu().numpy().tolist", "item.cpu().numpy().tolist.cpu().numpy().tolist.dim", "item.cpu().numpy().tolist.cpu().numpy().tolist.cpu().numpy().tolist", "ValueError", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero().squeeze().cpu().numpy", "item.cpu().numpy().tolist.cpu().numpy().tolist.cpu().numpy", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero().squeeze().cpu", "item.cpu().numpy().tolist.cpu().numpy().tolist.cpu", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero().squeeze", "item.cpu().numpy().tolist.cpu().numpy().tolist.nonzero"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "Union", "[", "int", ",", "slice", ",", "List", "[", "int", "]", ",", "torch", ".", "BoolTensor", "]", ")", "->", "\"PolygonMasks\"", ":", "\n", "        ", "\"\"\"\n        Support indexing over the instances and return a `PolygonMasks` object.\n        `item` can be:\n\n        1. An integer. It will return an object with only one instance.\n        2. A slice. It will return an object with the selected instances.\n        3. A list[int]. It will return an object with the selected instances,\n           correpsonding to the indices in the list.\n        4. A vector mask of type BoolTensor, whose length is num_instances.\n           It will return an object with the instances whose mask is nonzero.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "selected_polygons", "=", "[", "self", ".", "polygons", "[", "item", "]", "]", "\n", "", "elif", "isinstance", "(", "item", ",", "slice", ")", ":", "\n", "            ", "selected_polygons", "=", "self", ".", "polygons", "[", "item", "]", "\n", "", "elif", "isinstance", "(", "item", ",", "list", ")", ":", "\n", "            ", "selected_polygons", "=", "[", "self", ".", "polygons", "[", "i", "]", "for", "i", "in", "item", "]", "\n", "", "elif", "isinstance", "(", "item", ",", "torch", ".", "Tensor", ")", ":", "\n", "# Polygons is a list, so we have to move the indices back to CPU.", "\n", "            ", "if", "item", ".", "dtype", "==", "torch", ".", "bool", ":", "\n", "                ", "assert", "item", ".", "dim", "(", ")", "==", "1", ",", "item", ".", "shape", "\n", "item", "=", "item", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "", "elif", "item", ".", "dtype", "in", "[", "torch", ".", "int32", ",", "torch", ".", "int64", "]", ":", "\n", "                ", "item", "=", "item", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Unsupported tensor dtype={} for indexing!\"", ".", "format", "(", "item", ".", "dtype", ")", ")", "\n", "", "selected_polygons", "=", "[", "self", ".", "polygons", "[", "i", "]", "for", "i", "in", "item", "]", "\n", "", "return", "PolygonMasks", "(", "selected_polygons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.__iter__": [[353, 360], ["iter"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter"], ["", "def", "__iter__", "(", "self", ")", "->", "Iterator", "[", "List", "[", "np", ".", "ndarray", "]", "]", ":", "\n", "        ", "\"\"\"\n        Yields:\n            list[ndarray]: the polygons for one instance.\n            Each Tensor is a float64 vector representing a polygon.\n        \"\"\"", "\n", "return", "iter", "(", "self", ".", "polygons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.__repr__": [[361, 365], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={})\"", ".", "format", "(", "len", "(", "self", ".", "polygons", ")", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.__len__": [[366, 368], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "len", "(", "self", ".", "polygons", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.crop_and_resize": [[369, 400], ["boxes.to.to.to", "torch.stack().to", "len", "len", "len", "len", "torch.device", "masks.rasterize_polygons_within_box", "len", "torch.empty", "box.numpy", "zip", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.rasterize_polygons_within_box"], ["", "def", "crop_and_resize", "(", "self", ",", "boxes", ":", "torch", ".", "Tensor", ",", "mask_size", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Crop each mask by the given box, and resize results to (mask_size, mask_size).\n        This can be used to prepare training targets for Mask R-CNN.\n\n        Args:\n            boxes (Tensor): Nx4 tensor storing the boxes for each mask\n            mask_size (int): the size of the rasterized mask.\n\n        Returns:\n            Tensor: A bool tensor of shape (N, mask_size, mask_size), where\n            N is the number of predicted boxes for this image.\n        \"\"\"", "\n", "assert", "len", "(", "boxes", ")", "==", "len", "(", "self", ")", ",", "\"{} != {}\"", ".", "format", "(", "len", "(", "boxes", ")", ",", "len", "(", "self", ")", ")", "\n", "\n", "device", "=", "boxes", ".", "device", "\n", "# Put boxes on the CPU, as the polygon representation is not efficient GPU-wise", "\n", "# (several small tensors for representing a single instance mask)", "\n", "boxes", "=", "boxes", ".", "to", "(", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "\n", "results", "=", "[", "\n", "rasterize_polygons_within_box", "(", "poly", ",", "box", ".", "numpy", "(", ")", ",", "mask_size", ")", "\n", "for", "poly", ",", "box", "in", "zip", "(", "self", ".", "polygons", ",", "boxes", ")", "\n", "]", "\n", "\"\"\"\n        poly: list[list[float]], the polygons for one instance\n        box: a tensor of shape (4,)\n        \"\"\"", "\n", "if", "len", "(", "results", ")", "==", "0", ":", "\n", "            ", "return", "torch", ".", "empty", "(", "0", ",", "mask_size", ",", "mask_size", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "", "return", "torch", ".", "stack", "(", "results", ",", "dim", "=", "0", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.area": [[401, 419], ["torch.tensor", "area.append", "masks.polygon_area"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.polygon_area"], ["", "def", "area", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Computes area of the mask.\n        Only works with Polygons, using the shoelace formula:\n        https://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates\n\n        Returns:\n            Tensor: a vector, area for each instance\n        \"\"\"", "\n", "\n", "area", "=", "[", "]", "\n", "for", "polygons_per_instance", "in", "self", ".", "polygons", ":", "\n", "            ", "area_per_instance", "=", "0", "\n", "for", "p", "in", "polygons_per_instance", ":", "\n", "                ", "area_per_instance", "+=", "polygon_area", "(", "p", "[", "0", ":", ":", "2", "]", ",", "p", "[", "1", ":", ":", "2", "]", ")", "\n", "", "area", ".", "append", "(", "area_per_instance", ")", "\n", "\n", "", "return", "torch", ".", "tensor", "(", "area", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.cat": [[420, 439], ["isinstance", "all", "len", "type", "list", "isinstance", "itertools.chain.from_iterable"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "@", "staticmethod", "\n", "def", "cat", "(", "polymasks_list", ":", "List", "[", "\"PolygonMasks\"", "]", ")", "->", "\"PolygonMasks\"", ":", "\n", "        ", "\"\"\"\n        Concatenates a list of PolygonMasks into a single PolygonMasks\n\n        Arguments:\n            polymasks_list (list[PolygonMasks])\n\n        Returns:\n            PolygonMasks: the concatenated PolygonMasks\n        \"\"\"", "\n", "assert", "isinstance", "(", "polymasks_list", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "len", "(", "polymasks_list", ")", ">", "0", "\n", "assert", "all", "(", "isinstance", "(", "polymask", ",", "PolygonMasks", ")", "for", "polymask", "in", "polymasks_list", ")", "\n", "\n", "cat_polymasks", "=", "type", "(", "polymasks_list", "[", "0", "]", ")", "(", "\n", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "pm", ".", "polygons", "for", "pm", "in", "polymasks_list", ")", ")", "\n", ")", "\n", "return", "cat_polymasks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.polygon_area": [[14, 18], ["numpy.abs", "numpy.dot", "numpy.dot", "numpy.roll", "numpy.roll"], "function", ["None"], ["def", "polygon_area", "(", "x", ",", "y", ")", ":", "\n", "# Using the shoelace formula", "\n", "# https://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates", "\n", "    ", "return", "0.5", "*", "np", ".", "abs", "(", "np", ".", "dot", "(", "x", ",", "np", ".", "roll", "(", "y", ",", "1", ")", ")", "-", "np", ".", "dot", "(", "y", ",", "np", ".", "roll", "(", "x", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.polygons_to_bitmask": [[20, 33], ["pycocotools.frPyObjects", "pycocotools.merge", "pycocotools.decode().astype", "len", "pycocotools.decode"], "function", ["None"], ["", "def", "polygons_to_bitmask", "(", "polygons", ":", "List", "[", "np", ".", "ndarray", "]", ",", "height", ":", "int", ",", "width", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Args:\n        polygons (list[ndarray]): each array has shape (Nx2,)\n        height, width (int)\n\n    Returns:\n        ndarray: a bool mask of shape (height, width)\n    \"\"\"", "\n", "assert", "len", "(", "polygons", ")", ">", "0", ",", "\"COCOAPI does not support empty polygons\"", "\n", "rles", "=", "mask_util", ".", "frPyObjects", "(", "polygons", ",", "height", ",", "width", ")", "\n", "rle", "=", "mask_util", ".", "merge", "(", "rles", ")", "\n", "return", "mask_util", ".", "decode", "(", "rle", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.rasterize_polygons_within_box": [[35, 82], ["copy.deepcopy", "masks.polygons_to_bitmask", "torch.from_numpy", "max", "max"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.polygons_to_bitmask"], ["", "def", "rasterize_polygons_within_box", "(", "\n", "polygons", ":", "List", "[", "np", ".", "ndarray", "]", ",", "box", ":", "np", ".", "ndarray", ",", "mask_size", ":", "int", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Rasterize the polygons into a mask image and\n    crop the mask content in the given box.\n    The cropped mask is resized to (mask_size, mask_size).\n\n    This function is used when generating training targets for mask head in Mask R-CNN.\n    Given original ground-truth masks for an image, new ground-truth mask\n    training targets in the size of `mask_size x mask_size`\n    must be provided for each predicted box. This function will be called to\n    produce such targets.\n\n    Args:\n        polygons (list[ndarray[float]]): a list of polygons, which represents an instance.\n        box: 4-element numpy array\n        mask_size (int):\n\n    Returns:\n        Tensor: BoolTensor of shape (mask_size, mask_size)\n    \"\"\"", "\n", "# 1. Shift the polygons w.r.t the boxes", "\n", "w", ",", "h", "=", "box", "[", "2", "]", "-", "box", "[", "0", "]", ",", "box", "[", "3", "]", "-", "box", "[", "1", "]", "\n", "\n", "polygons", "=", "copy", ".", "deepcopy", "(", "polygons", ")", "\n", "for", "p", "in", "polygons", ":", "\n", "        ", "p", "[", "0", ":", ":", "2", "]", "=", "p", "[", "0", ":", ":", "2", "]", "-", "box", "[", "0", "]", "\n", "p", "[", "1", ":", ":", "2", "]", "=", "p", "[", "1", ":", ":", "2", "]", "-", "box", "[", "1", "]", "\n", "\n", "# 2. Rescale the polygons to the new box size", "\n", "# max() to avoid division by small number", "\n", "", "ratio_h", "=", "mask_size", "/", "max", "(", "h", ",", "0.1", ")", "\n", "ratio_w", "=", "mask_size", "/", "max", "(", "w", ",", "0.1", ")", "\n", "\n", "if", "ratio_h", "==", "ratio_w", ":", "\n", "        ", "for", "p", "in", "polygons", ":", "\n", "            ", "p", "*=", "ratio_h", "\n", "", "", "else", ":", "\n", "        ", "for", "p", "in", "polygons", ":", "\n", "            ", "p", "[", "0", ":", ":", "2", "]", "*=", "ratio_w", "\n", "p", "[", "1", ":", ":", "2", "]", "*=", "ratio_h", "\n", "\n", "# 3. Rasterize the polygons with coco api", "\n", "", "", "mask", "=", "polygons_to_bitmask", "(", "polygons", ",", "mask_size", ",", "mask_size", ")", "\n", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.BoxMode.convert": [[43, 131], ["type", "isinstance", "isinstance", "torch.cat().to.double", "torch.abs", "torch.abs", "arr[].to", "type.", "torch.cat().to.numpy", "torch.tensor", "torch.from_numpy().clone", "box.clone", "torch.cos", "torch.sin", "torch.cat().to.double", "torch.zeros", "torch.cat().to", "torch.cat().to.flatten().tolist", "len", "len", "torch.from_numpy", "torch.cat", "NotImplementedError", "torch.cat().to.flatten", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["@", "staticmethod", "\n", "def", "convert", "(", "box", ":", "_RawBoxType", ",", "from_mode", ":", "\"BoxMode\"", ",", "to_mode", ":", "\"BoxMode\"", ")", "->", "_RawBoxType", ":", "\n", "        ", "\"\"\"\n        Args:\n            box: can be a k-tuple, k-list or an Nxk array/tensor, where k = 4 or 5\n            from_mode, to_mode (BoxMode)\n\n        Returns:\n            The converted box of the same type.\n        \"\"\"", "\n", "if", "from_mode", "==", "to_mode", ":", "\n", "            ", "return", "box", "\n", "\n", "", "original_type", "=", "type", "(", "box", ")", "\n", "is_numpy", "=", "isinstance", "(", "box", ",", "np", ".", "ndarray", ")", "\n", "single_box", "=", "isinstance", "(", "box", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "single_box", ":", "\n", "            ", "assert", "len", "(", "box", ")", "==", "4", "or", "len", "(", "box", ")", "==", "5", ",", "(", "\n", "\"BoxMode.convert takes either a k-tuple/list or an Nxk array/tensor,\"", "\n", "\" where k == 4 or 5\"", "\n", ")", "\n", "arr", "=", "torch", ".", "tensor", "(", "box", ")", "[", "None", ",", ":", "]", "\n", "", "else", ":", "\n", "# avoid modifying the input box", "\n", "            ", "if", "is_numpy", ":", "\n", "                ", "arr", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "box", ")", ")", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                ", "arr", "=", "box", ".", "clone", "(", ")", "\n", "\n", "", "", "assert", "to_mode", ".", "value", "not", "in", "[", "\n", "BoxMode", ".", "XYXY_REL", ",", "\n", "BoxMode", ".", "XYWH_REL", ",", "\n", "]", "and", "from_mode", ".", "value", "not", "in", "[", "\n", "BoxMode", ".", "XYXY_REL", ",", "\n", "BoxMode", ".", "XYWH_REL", ",", "\n", "]", ",", "\"Relative mode not yet supported!\"", "\n", "\n", "if", "from_mode", "==", "BoxMode", ".", "XYWHA_ABS", "and", "to_mode", "==", "BoxMode", ".", "XYXY_ABS", ":", "\n", "            ", "assert", "(", "\n", "arr", ".", "shape", "[", "-", "1", "]", "==", "5", "\n", ")", ",", "\"The last dimension of input shape must be 5 for XYWHA format\"", "\n", "original_dtype", "=", "arr", ".", "dtype", "\n", "arr", "=", "arr", ".", "double", "(", ")", "\n", "\n", "w", "=", "arr", "[", ":", ",", "2", "]", "\n", "h", "=", "arr", "[", ":", ",", "3", "]", "\n", "a", "=", "arr", "[", ":", ",", "4", "]", "\n", "c", "=", "torch", ".", "abs", "(", "torch", ".", "cos", "(", "a", "*", "math", ".", "pi", "/", "180.0", ")", ")", "\n", "s", "=", "torch", ".", "abs", "(", "torch", ".", "sin", "(", "a", "*", "math", ".", "pi", "/", "180.0", ")", ")", "\n", "# This basically computes the horizontal bounding rectangle of the rotated box", "\n", "new_w", "=", "c", "*", "w", "+", "s", "*", "h", "\n", "new_h", "=", "c", "*", "h", "+", "s", "*", "w", "\n", "\n", "# convert center to top-left corner", "\n", "arr", "[", ":", ",", "0", "]", "-=", "new_w", "/", "2.0", "\n", "arr", "[", ":", ",", "1", "]", "-=", "new_h", "/", "2.0", "\n", "# bottom-right corner", "\n", "arr", "[", ":", ",", "2", "]", "=", "arr", "[", ":", ",", "0", "]", "+", "new_w", "\n", "arr", "[", ":", ",", "3", "]", "=", "arr", "[", ":", ",", "1", "]", "+", "new_h", "\n", "\n", "arr", "=", "arr", "[", ":", ",", ":", "4", "]", ".", "to", "(", "dtype", "=", "original_dtype", ")", "\n", "", "elif", "from_mode", "==", "BoxMode", ".", "XYWH_ABS", "and", "to_mode", "==", "BoxMode", ".", "XYWHA_ABS", ":", "\n", "            ", "original_dtype", "=", "arr", ".", "dtype", "\n", "arr", "=", "arr", ".", "double", "(", ")", "\n", "arr", "[", ":", ",", "0", "]", "+=", "arr", "[", ":", ",", "2", "]", "/", "2.0", "\n", "arr", "[", ":", ",", "1", "]", "+=", "arr", "[", ":", ",", "3", "]", "/", "2.0", "\n", "angles", "=", "torch", ".", "zeros", "(", "(", "arr", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "arr", "=", "torch", ".", "cat", "(", "(", "arr", ",", "angles", ")", ",", "axis", "=", "1", ")", ".", "to", "(", "dtype", "=", "original_dtype", ")", "\n", "", "else", ":", "\n", "            ", "if", "to_mode", "==", "BoxMode", ".", "XYXY_ABS", "and", "from_mode", "==", "BoxMode", ".", "XYWH_ABS", ":", "\n", "                ", "arr", "[", ":", ",", "2", "]", "+=", "arr", "[", ":", ",", "0", "]", "\n", "arr", "[", ":", ",", "3", "]", "+=", "arr", "[", ":", ",", "1", "]", "\n", "", "elif", "from_mode", "==", "BoxMode", ".", "XYXY_ABS", "and", "to_mode", "==", "BoxMode", ".", "XYWH_ABS", ":", "\n", "                ", "arr", "[", ":", ",", "2", "]", "-=", "arr", "[", ":", ",", "0", "]", "\n", "arr", "[", ":", ",", "3", "]", "-=", "arr", "[", ":", ",", "1", "]", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\n", "\"Conversion from BoxMode {} to {} is not supported yet\"", ".", "format", "(", "\n", "from_mode", ",", "to_mode", "\n", ")", "\n", ")", "\n", "\n", "", "", "if", "single_box", ":", "\n", "            ", "return", "original_type", "(", "arr", ".", "flatten", "(", ")", ".", "tolist", "(", ")", ")", "\n", "", "if", "is_numpy", ":", "\n", "            ", "return", "arr", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "arr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.__init__": [[145, 159], ["torch.as_tensor", "tensor.reshape().to.reshape().to.size", "isinstance", "torch.device", "tensor.reshape().to.reshape().to.numel", "tensor.reshape().to.reshape().to.reshape().to", "tensor.reshape().to.reshape().to.dim", "tensor.reshape().to.reshape().to.size", "tensor.reshape().to.reshape().to.reshape"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["def", "__init__", "(", "self", ",", "tensor", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tensor (Tensor[float]): a Nx4 matrix.  Each row is (x1, y1, x2, y2).\n        \"\"\"", "\n", "device", "=", "tensor", ".", "device", "if", "isinstance", "(", "tensor", ",", "torch", ".", "Tensor", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "tensor", "=", "torch", ".", "as_tensor", "(", "tensor", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "if", "tensor", ".", "numel", "(", ")", "==", "0", ":", "\n", "# Use reshape, so we don't end up creating a new tensor that does not depend on", "\n", "# the inputs (and consequently confuses jit)", "\n", "            ", "tensor", "=", "tensor", ".", "reshape", "(", "(", "0", ",", "4", ")", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "", "assert", "tensor", ".", "dim", "(", ")", "==", "2", "and", "tensor", ".", "size", "(", "-", "1", ")", "==", "4", ",", "tensor", ".", "size", "(", ")", "\n", "\n", "self", ".", "tensor", "=", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone": [[160, 168], ["boxes.Boxes", "boxes.Boxes.tensor.clone"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "def", "clone", "(", "self", ")", "->", "\"Boxes\"", ":", "\n", "        ", "\"\"\"\n        Clone the Boxes.\n\n        Returns:\n            Boxes\n        \"\"\"", "\n", "return", "Boxes", "(", "self", ".", "tensor", ".", "clone", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.to": [[169, 172], ["boxes.Boxes", "boxes.Boxes.tensor.to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "to", "(", "self", ",", "*", "args", ":", "Any", ",", "**", "kwargs", ":", "Any", ")", ":", "\n", "        ", "return", "Boxes", "(", "self", ".", "tensor", ".", "to", "(", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area": [[173, 183], ["None"], "methods", ["None"], ["", "def", "area", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Computes the area of all the boxes.\n\n        Returns:\n            torch.Tensor: a vector with areas of each box.\n        \"\"\"", "\n", "box", "=", "self", ".", "tensor", "\n", "area", "=", "(", "box", "[", ":", ",", "2", "]", "-", "box", "[", ":", ",", "0", "]", ")", "*", "(", "box", "[", ":", ",", "3", "]", "-", "box", "[", ":", ",", "1", "]", ")", "\n", "return", "area", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip": [[184, 198], ["torch.isfinite().all", "boxes.Boxes.tensor[].clamp_", "boxes.Boxes.tensor[].clamp_", "boxes.Boxes.tensor[].clamp_", "boxes.Boxes.tensor[].clamp_", "torch.isfinite"], "methods", ["None"], ["", "def", "clip", "(", "self", ",", "box_size", ":", "Tuple", "[", "int", ",", "int", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Clip (in place) the boxes by limiting x coordinates to the range [0, width]\n        and y coordinates to the range [0, height].\n\n        Args:\n            box_size (height, width): The clipping box's size.\n        \"\"\"", "\n", "assert", "torch", ".", "isfinite", "(", "self", ".", "tensor", ")", ".", "all", "(", ")", ",", "\"Box tensor contains infinite or NaN!\"", "\n", "h", ",", "w", "=", "box_size", "\n", "self", ".", "tensor", "[", ":", ",", "0", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "self", ".", "tensor", "[", ":", ",", "1", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "self", ".", "tensor", "[", ":", ",", "2", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "w", ")", "\n", "self", ".", "tensor", "[", ":", ",", "3", "]", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "h", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty": [[199, 214], ["None"], "methods", ["None"], ["", "def", "nonempty", "(", "self", ",", "threshold", ":", "float", "=", "0.0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Find boxes that are non-empty.\n        A box is considered empty, if either of its side is no larger than threshold.\n\n        Returns:\n            Tensor:\n                a binary vector which represents whether each box is empty\n                (False) or non-empty (True).\n        \"\"\"", "\n", "box", "=", "self", ".", "tensor", "\n", "widths", "=", "box", "[", ":", ",", "2", "]", "-", "box", "[", ":", ",", "0", "]", "\n", "heights", "=", "box", "[", ":", ",", "3", "]", "-", "box", "[", ":", ",", "1", "]", "\n", "keep", "=", "(", "widths", ">", "threshold", ")", "&", "(", "heights", ">", "threshold", ")", "\n", "return", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.__getitem__": [[215, 238], ["isinstance", "boxes.Boxes", "boxes.Boxes", "b.dim", "boxes.Boxes.tensor[].view"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            item: int, slice, or a BoolTensor\n\n        Returns:\n            Boxes: Create a new :class:`Boxes` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_boxes = boxes[3]`: return a `Boxes` which contains only one box.\n        2. `new_boxes = boxes[2:10]`: return a slice of boxes.\n        3. `new_boxes = boxes[vector]`, where vector is a torch.BoolTensor\n           with `length = len(boxes)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned Boxes might share storage with this Boxes,\n        subject to Pytorch's indexing semantics.\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "return", "Boxes", "(", "self", ".", "tensor", "[", "item", "]", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "", "b", "=", "self", ".", "tensor", "[", "item", "]", "\n", "assert", "b", ".", "dim", "(", ")", "==", "2", ",", "\"Indexing on Boxes with {} failed to return a matrix!\"", ".", "format", "(", "item", ")", "\n", "return", "Boxes", "(", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.__len__": [[239, 241], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.__repr__": [[242, 244], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "\"Boxes(\"", "+", "str", "(", "self", ".", "tensor", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.inside_box": [[245, 263], ["None"], "methods", ["None"], ["", "def", "inside_box", "(", "self", ",", "box_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "boundary_threshold", ":", "int", "=", "0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Args:\n            box_size (height, width): Size of the reference box.\n            boundary_threshold (int): Boxes that extend beyond the reference box\n                boundary by more than boundary_threshold are considered \"outside\".\n\n        Returns:\n            a binary vector, indicating whether each box is inside the reference box.\n        \"\"\"", "\n", "height", ",", "width", "=", "box_size", "\n", "inds_inside", "=", "(", "\n", "(", "self", ".", "tensor", "[", "...", ",", "0", "]", ">=", "-", "boundary_threshold", ")", "\n", "&", "(", "self", ".", "tensor", "[", "...", ",", "1", "]", ">=", "-", "boundary_threshold", ")", "\n", "&", "(", "self", ".", "tensor", "[", "...", ",", "2", "]", "<", "width", "+", "boundary_threshold", ")", "\n", "&", "(", "self", ".", "tensor", "[", "...", ",", "3", "]", "<", "height", "+", "boundary_threshold", ")", "\n", ")", "\n", "return", "inds_inside", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.get_centers": [[264, 270], ["None"], "methods", ["None"], ["", "def", "get_centers", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Returns:\n            The box centers in a Nx2 array of (x, y).\n        \"\"\"", "\n", "return", "(", "self", ".", "tensor", "[", ":", ",", ":", "2", "]", "+", "self", ".", "tensor", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.scale": [[271, 277], ["None"], "methods", ["None"], ["", "def", "scale", "(", "self", ",", "scale_x", ":", "float", ",", "scale_y", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Scale the box with horizontal and vertical scaling factors\n        \"\"\"", "\n", "self", ".", "tensor", "[", ":", ",", "0", ":", ":", "2", "]", "*=", "scale_x", "\n", "self", ".", "tensor", "[", ":", ",", "1", ":", ":", "2", "]", "*=", "scale_y", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.cat": [[279, 299], ["isinstance", "all", "cls", "len", "cls", "torch.cat", "torch.empty", "isinstance"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "@", "classmethod", "\n", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "cat", "(", "cls", ",", "boxes_list", ")", ":", "\n", "        ", "\"\"\"\n        Concatenates a list of Boxes into a single Boxes\n\n        Arguments:\n            boxes_list (list[Boxes])\n\n        Returns:\n            Boxes: the concatenated Boxes\n        \"\"\"", "\n", "assert", "isinstance", "(", "boxes_list", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "len", "(", "boxes_list", ")", "==", "0", ":", "\n", "            ", "return", "cls", "(", "torch", ".", "empty", "(", "0", ")", ")", "\n", "", "assert", "all", "(", "[", "isinstance", "(", "box", ",", "Boxes", ")", "for", "box", "in", "boxes_list", "]", ")", "\n", "\n", "# use torch.cat (v.s. layers.cat) so the returned boxes never share storage with input", "\n", "cat_boxes", "=", "cls", "(", "torch", ".", "cat", "(", "[", "b", ".", "tensor", "for", "b", "in", "boxes_list", "]", ",", "dim", "=", "0", ")", ")", "\n", "return", "cat_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.device": [[300, 303], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "device", ":", "\n", "        ", "return", "self", ".", "tensor", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.__iter__": [[306, 312], ["None"], "methods", ["None"], ["", "@", "torch", ".", "jit", ".", "unused", "\n", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Yield a box as a Tensor of shape (4,) at a time.\n        \"\"\"", "\n", "yield", "from", "self", ".", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_intersection": [[314, 334], ["width_height.clamp_", "width_height.prod", "torch.min", "torch.max"], "function", ["None"], ["", "", "def", "pairwise_intersection", "(", "boxes1", ":", "Boxes", ",", "boxes2", ":", "Boxes", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Given two lists of boxes of size N and M,\n    compute the intersection area between __all__ N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax)\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: intersection, sized [N,M].\n    \"\"\"", "\n", "boxes1", ",", "boxes2", "=", "boxes1", ".", "tensor", ",", "boxes2", ".", "tensor", "\n", "width_height", "=", "torch", ".", "min", "(", "boxes1", "[", ":", ",", "None", ",", "2", ":", "]", ",", "boxes2", "[", ":", ",", "2", ":", "]", ")", "-", "torch", ".", "max", "(", "\n", "boxes1", "[", ":", ",", "None", ",", ":", "2", "]", ",", "boxes2", "[", ":", ",", ":", "2", "]", "\n", ")", "# [N,M,2]", "\n", "\n", "width_height", ".", "clamp_", "(", "min", "=", "0", ")", "# [N,M,2]", "\n", "intersection", "=", "width_height", ".", "prod", "(", "dim", "=", "2", ")", "# [N,M]", "\n", "return", "intersection", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou": [[338, 361], ["boxes1.area", "boxes2.area", "boxes.pairwise_intersection", "torch.where", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_intersection"], ["", "def", "pairwise_iou", "(", "boxes1", ":", "Boxes", ",", "boxes2", ":", "Boxes", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Given two lists of boxes of size N and M,\n    compute the IoU (intersection over union)\n    between __all__ N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax).\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoU, sized [N,M].\n    \"\"\"", "\n", "area1", "=", "boxes1", ".", "area", "(", ")", "# [N]", "\n", "area2", "=", "boxes2", ".", "area", "(", ")", "# [M]", "\n", "inter", "=", "pairwise_intersection", "(", "boxes1", ",", "boxes2", ")", "\n", "\n", "# handle empty boxes", "\n", "iou", "=", "torch", ".", "where", "(", "\n", "inter", ">", "0", ",", "\n", "inter", "/", "(", "area1", "[", ":", ",", "None", "]", "+", "area2", "-", "inter", ")", ",", "\n", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "inter", ".", "dtype", ",", "device", "=", "inter", ".", "device", ")", ",", "\n", ")", "\n", "return", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_ioa": [[363, 381], ["boxes2.area", "boxes.pairwise_intersection", "torch.where", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_intersection"], ["", "def", "pairwise_ioa", "(", "boxes1", ":", "Boxes", ",", "boxes2", ":", "Boxes", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Similar to pariwise_iou but compute the IoA (intersection over boxes2 area).\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoA, sized [N,M].\n    \"\"\"", "\n", "area2", "=", "boxes2", ".", "area", "(", ")", "# [M]", "\n", "inter", "=", "pairwise_intersection", "(", "boxes1", ",", "boxes2", ")", "\n", "\n", "# handle empty boxes", "\n", "ioa", "=", "torch", ".", "where", "(", "\n", "inter", ">", "0", ",", "inter", "/", "area2", ",", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "inter", ".", "dtype", ",", "device", "=", "inter", ".", "device", ")", "\n", ")", "\n", "return", "ioa", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.matched_boxlist_iou": [[383, 409], ["boxes1.area", "boxes2.area", "torch.max", "torch.min", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area"], ["", "def", "matched_boxlist_iou", "(", "boxes1", ":", "Boxes", ",", "boxes2", ":", "Boxes", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Compute pairwise intersection over union (IOU) of two sets of matched\n    boxes. The box order must be (xmin, ymin, xmax, ymax).\n    Similar to boxlist_iou, but computes only diagonal elements of the matrix\n\n    Args:\n        boxes1: (Boxes) bounding boxes, sized [N,4].\n        boxes2: (Boxes) bounding boxes, sized [N,4].\n    Returns:\n        Tensor: iou, sized [N].\n    \"\"\"", "\n", "assert", "len", "(", "boxes1", ")", "==", "len", "(", "\n", "boxes2", "\n", ")", ",", "\"boxlists should have the same\"", "\"number of entries, got {}, {}\"", ".", "format", "(", "\n", "len", "(", "boxes1", ")", ",", "len", "(", "boxes2", ")", "\n", ")", "\n", "area1", "=", "boxes1", ".", "area", "(", ")", "# [N]", "\n", "area2", "=", "boxes2", ".", "area", "(", ")", "# [N]", "\n", "box1", ",", "box2", "=", "boxes1", ".", "tensor", ",", "boxes2", ".", "tensor", "\n", "lt", "=", "torch", ".", "max", "(", "box1", "[", ":", ",", ":", "2", "]", ",", "box2", "[", ":", ",", ":", "2", "]", ")", "# [N,2]", "\n", "rb", "=", "torch", ".", "min", "(", "box1", "[", ":", ",", "2", ":", "]", ",", "box2", "[", ":", ",", "2", ":", "]", ")", "# [N,2]", "\n", "wh", "=", "(", "rb", "-", "lt", ")", ".", "clamp", "(", "min", "=", "0", ")", "# [N,2]", "\n", "inter", "=", "wh", "[", ":", ",", "0", "]", "*", "wh", "[", ":", ",", "1", "]", "# [N]", "\n", "iou", "=", "inter", "/", "(", "area1", "+", "area2", "-", "inter", ")", "# [N]", "\n", "return", "iou", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xy_to_wh": [[13, 15], ["detectron2.structures.BoxMode.convert"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["    ", "def", "_convert_xy_to_wh", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "BoxMode", ".", "convert", "(", "x", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy": [[16, 18], ["detectron2.structures.BoxMode.convert"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "_convert_xywha_to_xyxy", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "BoxMode", ".", "convert", "(", "x", ",", "BoxMode", ".", "XYWHA_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha": [[19, 21], ["detectron2.structures.BoxMode.convert"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "_convert_xywh_to_xywha", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "BoxMode", ".", "convert", "(", "x", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYWHA_ABS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_list": [[22, 32], ["tp", "test_boxes.TestBoxMode._convert_xy_to_wh", "test_boxes.TestBoxMode.assertIsInstance", "test_boxes.TestBoxMode.assertIsInstance", "test_boxes.TestBoxMode.assertEqual", "tp", "test_boxes.TestBoxMode.assertRaises", "test_boxes.TestBoxMode._convert_xy_to_wh"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xy_to_wh", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xy_to_wh"], ["", "def", "test_box_convert_list", "(", "self", ")", ":", "\n", "        ", "for", "tp", "in", "[", "list", ",", "tuple", "]", ":", "\n", "            ", "box", "=", "tp", "(", "[", "5.0", ",", "5.0", ",", "10.0", ",", "10.0", "]", ")", "\n", "output", "=", "self", ".", "_convert_xy_to_wh", "(", "box", ")", "\n", "self", ".", "assertIsInstance", "(", "output", ",", "tp", ")", "\n", "self", ".", "assertIsInstance", "(", "output", "[", "0", "]", ",", "float", ")", "\n", "self", ".", "assertEqual", "(", "output", ",", "tp", "(", "[", "5.0", ",", "5.0", ",", "5.0", ",", "5.0", "]", ")", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "self", ".", "_convert_xy_to_wh", "(", "[", "box", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_array": [[33, 40], ["numpy.asarray", "test_boxes.TestBoxMode._convert_xy_to_wh", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertTrue", "test_boxes.TestBoxMode.assertTrue"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xy_to_wh"], ["", "", "", "def", "test_box_convert_array", "(", "self", ")", ":", "\n", "        ", "box", "=", "np", ".", "asarray", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "output", "=", "self", ".", "_convert_xy_to_wh", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "box", ".", "shape", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "0", "]", "==", "[", "5", ",", "5", ",", "5", ",", "5", "]", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "1", "]", "==", "[", "1", ",", "1", ",", "1", ",", "2", "]", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_cpu_tensor": [[41, 49], ["torch.tensor", "test_boxes.TestBoxMode._convert_xy_to_wh", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertEqual", "output.numpy.numpy.numpy", "test_boxes.TestBoxMode.assertTrue", "test_boxes.TestBoxMode.assertTrue"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xy_to_wh"], ["", "def", "test_box_convert_cpu_tensor", "(", "self", ")", ":", "\n", "        ", "box", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "output", "=", "self", ".", "_convert_xy_to_wh", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "box", ".", "shape", ")", "\n", "output", "=", "output", ".", "numpy", "(", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "0", "]", "==", "[", "5", ",", "5", ",", "5", ",", "5", "]", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "1", "]", "==", "[", "1", ",", "1", ",", "1", ",", "2", "]", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_cuda_tensor": [[50, 60], ["unittest.skipIf", "torch.tensor().cuda", "test_boxes.TestBoxMode._convert_xy_to_wh", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertEqual", "test_boxes.TestBoxMode.assertEqual", "output.cpu().numpy.cpu().numpy.cpu().numpy", "test_boxes.TestBoxMode.assertTrue", "test_boxes.TestBoxMode.assertTrue", "torch.cuda.is_available", "torch.tensor", "output.cpu().numpy.cpu().numpy.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xy_to_wh"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_box_convert_cuda_tensor", "(", "self", ")", ":", "\n", "        ", "box", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", ".", "cuda", "(", ")", "\n", "output", "=", "self", ".", "_convert_xy_to_wh", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "box", ".", "shape", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "device", ",", "box", ".", "device", ")", "\n", "output", "=", "output", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "0", "]", "==", "[", "5", ",", "5", ",", "5", ",", "5", "]", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "1", "]", "==", "[", "1", ",", "1", ",", "1", ",", "2", "]", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_xywha_to_xyxy_list": [[61, 70], ["tp", "test_boxes.TestBoxMode._convert_xywha_to_xyxy", "test_boxes.TestBoxMode.assertIsInstance", "test_boxes.TestBoxMode.assertEqual", "tp", "test_boxes.TestBoxMode.assertRaises", "test_boxes.TestBoxMode._convert_xywha_to_xyxy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy"], ["", "def", "test_box_convert_xywha_to_xyxy_list", "(", "self", ")", ":", "\n", "        ", "for", "tp", "in", "[", "list", ",", "tuple", "]", ":", "\n", "            ", "box", "=", "tp", "(", "[", "50", ",", "50", ",", "30", ",", "20", ",", "0", "]", ")", "\n", "output", "=", "self", ".", "_convert_xywha_to_xyxy", "(", "box", ")", "\n", "self", ".", "assertIsInstance", "(", "output", ",", "tp", ")", "\n", "self", ".", "assertEqual", "(", "output", ",", "tp", "(", "[", "35", ",", "40", ",", "65", ",", "60", "]", ")", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "self", ".", "_convert_xywha_to_xyxy", "(", "[", "box", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_xywha_to_xyxy_array": [[71, 85], ["numpy.asarray", "test_boxes.TestBoxMode._convert_xywha_to_xyxy", "test_boxes.TestBoxMode.assertEqual", "numpy.asarray", "test_boxes.TestBoxMode.assertTrue", "numpy.allclose", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy"], ["", "", "", "def", "test_box_convert_xywha_to_xyxy_array", "(", "self", ")", ":", "\n", "        ", "for", "dtype", "in", "[", "np", ".", "float64", ",", "np", ".", "float32", "]", ":", "\n", "            ", "box", "=", "np", ".", "asarray", "(", "\n", "[", "\n", "[", "50", ",", "50", ",", "30", ",", "20", ",", "0", "]", ",", "\n", "[", "50", ",", "50", ",", "30", ",", "20", ",", "90", "]", ",", "\n", "[", "1", ",", "1", ",", "math", ".", "sqrt", "(", "2", ")", ",", "math", ".", "sqrt", "(", "2", ")", ",", "-", "45", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", ")", "\n", "output", "=", "self", ".", "_convert_xywha_to_xyxy", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "expected", "=", "np", ".", "asarray", "(", "[", "[", "35", ",", "40", ",", "65", ",", "60", "]", ",", "[", "40", ",", "35", ",", "60", ",", "65", "]", ",", "[", "0", ",", "0", ",", "2", ",", "2", "]", "]", ",", "dtype", "=", "dtype", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "output", ",", "expected", ",", "atol", "=", "1e-6", ")", ",", "\"output={}\"", ".", "format", "(", "output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_xywha_to_xyxy_tensor": [[86, 101], ["torch.tensor", "test_boxes.TestBoxMode._convert_xywha_to_xyxy", "test_boxes.TestBoxMode.assertEqual", "torch.tensor", "test_boxes.TestBoxMode.assertTrue", "torch.allclose", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywha_to_xyxy"], ["", "", "def", "test_box_convert_xywha_to_xyxy_tensor", "(", "self", ")", ":", "\n", "        ", "for", "dtype", "in", "[", "torch", ".", "float32", ",", "torch", ".", "float64", "]", ":", "\n", "            ", "box", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "50", ",", "50", ",", "30", ",", "20", ",", "0", "]", ",", "\n", "[", "50", ",", "50", ",", "30", ",", "20", ",", "90", "]", ",", "\n", "[", "1", ",", "1", ",", "math", ".", "sqrt", "(", "2", ")", ",", "math", ".", "sqrt", "(", "2", ")", ",", "-", "45", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", ")", "\n", "output", "=", "self", ".", "_convert_xywha_to_xyxy", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "expected", "=", "torch", ".", "tensor", "(", "[", "[", "35", ",", "40", ",", "65", ",", "60", "]", ",", "[", "40", ",", "35", ",", "60", ",", "65", "]", ",", "[", "0", ",", "0", ",", "2", ",", "2", "]", "]", ",", "dtype", "=", "dtype", ")", "\n", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "output", ",", "expected", ",", "atol", "=", "1e-6", ")", ",", "\"output={}\"", ".", "format", "(", "output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_xywh_to_xywha_list": [[102, 111], ["tp", "test_boxes.TestBoxMode._convert_xywh_to_xywha", "test_boxes.TestBoxMode.assertIsInstance", "test_boxes.TestBoxMode.assertEqual", "tp", "test_boxes.TestBoxMode.assertRaises", "test_boxes.TestBoxMode._convert_xywh_to_xywha"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha"], ["", "", "def", "test_box_convert_xywh_to_xywha_list", "(", "self", ")", ":", "\n", "        ", "for", "tp", "in", "[", "list", ",", "tuple", "]", ":", "\n", "            ", "box", "=", "tp", "(", "[", "50", ",", "50", ",", "30", ",", "20", "]", ")", "\n", "output", "=", "self", ".", "_convert_xywh_to_xywha", "(", "box", ")", "\n", "self", ".", "assertIsInstance", "(", "output", ",", "tp", ")", "\n", "self", ".", "assertEqual", "(", "output", ",", "tp", "(", "[", "65", ",", "60", ",", "30", ",", "20", ",", "0", "]", ")", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "self", ".", "_convert_xywh_to_xywha", "(", "[", "box", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_xywh_to_xywha_array": [[112, 121], ["numpy.asarray", "test_boxes.TestBoxMode._convert_xywh_to_xywha", "test_boxes.TestBoxMode.assertEqual", "numpy.asarray", "test_boxes.TestBoxMode.assertTrue", "numpy.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha"], ["", "", "", "def", "test_box_convert_xywh_to_xywha_array", "(", "self", ")", ":", "\n", "        ", "for", "dtype", "in", "[", "np", ".", "float64", ",", "np", ".", "float32", "]", ":", "\n", "            ", "box", "=", "np", ".", "asarray", "(", "[", "[", "30", ",", "40", ",", "70", ",", "60", "]", ",", "[", "30", ",", "40", ",", "60", ",", "70", "]", ",", "[", "-", "1", ",", "-", "1", ",", "2", ",", "2", "]", "]", ",", "dtype", "=", "dtype", ")", "\n", "output", "=", "self", ".", "_convert_xywh_to_xywha", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "expected", "=", "np", ".", "asarray", "(", "\n", "[", "[", "65", ",", "70", ",", "70", ",", "60", ",", "0", "]", ",", "[", "60", ",", "75", ",", "60", ",", "70", ",", "0", "]", ",", "[", "0", ",", "0", ",", "2", ",", "2", ",", "0", "]", "]", ",", "dtype", "=", "dtype", "\n", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "output", ",", "expected", ",", "atol", "=", "1e-6", ")", ",", "\"output={}\"", ".", "format", "(", "output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_box_convert_xywh_to_xywha_tensor": [[122, 132], ["torch.tensor", "test_boxes.TestBoxMode._convert_xywh_to_xywha", "test_boxes.TestBoxMode.assertEqual", "torch.tensor", "test_boxes.TestBoxMode.assertTrue", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode._convert_xywh_to_xywha"], ["", "", "def", "test_box_convert_xywh_to_xywha_tensor", "(", "self", ")", ":", "\n", "        ", "for", "dtype", "in", "[", "torch", ".", "float32", ",", "torch", ".", "float64", "]", ":", "\n", "            ", "box", "=", "torch", ".", "tensor", "(", "[", "[", "30", ",", "40", ",", "70", ",", "60", "]", ",", "[", "30", ",", "40", ",", "60", ",", "70", "]", ",", "[", "-", "1", ",", "-", "1", ",", "2", ",", "2", "]", "]", ",", "dtype", "=", "dtype", ")", "\n", "output", "=", "self", ".", "_convert_xywh_to_xywha", "(", "box", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "dtype", ",", "box", ".", "dtype", ")", "\n", "expected", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "65", ",", "70", ",", "70", ",", "60", ",", "0", "]", ",", "[", "60", ",", "75", ",", "60", ",", "70", ",", "0", "]", ",", "[", "0", ",", "0", ",", "2", ",", "2", ",", "0", "]", "]", ",", "dtype", "=", "dtype", "\n", ")", "\n", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "output", ",", "expected", ",", "atol", "=", "1e-6", ")", ",", "\"output={}\"", ".", "format", "(", "output", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_json_serializable": [[133, 139], ["json.dumps", "test_boxes.TestBoxMode.fail"], "methods", ["None"], ["", "", "def", "test_json_serializable", "(", "self", ")", ":", "\n", "        ", "payload", "=", "{", "\"box_mode\"", ":", "BoxMode", ".", "XYWH_REL", "}", "\n", "try", ":", "\n", "            ", "json", ".", "dumps", "(", "payload", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "self", ".", "fail", "(", "\"JSON serialization failed\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxMode.test_json_deserializable": [[140, 147], ["json.loads", "detectron2.structures.BoxMode", "test_boxes.TestBoxMode.fail"], "methods", ["None"], ["", "", "def", "test_json_deserializable", "(", "self", ")", ":", "\n", "        ", "payload", "=", "'{\"box_mode\": 2}'", "\n", "obj", "=", "json", ".", "loads", "(", "payload", ")", "\n", "try", ":", "\n", "            ", "obj", "[", "\"box_mode\"", "]", "=", "BoxMode", "(", "obj", "[", "\"box_mode\"", "]", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "self", ".", "fail", "(", "\"JSON deserialization failed\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxIOU.create_boxes": [[150, 164], ["torch.tensor", "torch.tensor"], "methods", ["None"], ["    ", "def", "create_boxes", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", "]", ")", "\n", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.5", ",", "1.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "1.0", ",", "0.5", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.5", ",", "0.5", "]", ",", "\n", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "0.5", ",", "0.5", ",", "1.5", ",", "1.5", "]", ",", "\n", "]", "\n", ")", "\n", "return", "boxes1", ",", "boxes2", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxIOU.test_pairwise_iou": [[165, 176], ["test_boxes.TestBoxIOU.create_boxes", "torch.tensor", "detectron2.structures.pairwise_iou", "test_boxes.TestBoxIOU.assertTrue", "detectron2.structures.Boxes", "detectron2.structures.Boxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxIOU.create_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "def", "test_pairwise_iou", "(", "self", ")", ":", "\n", "        ", "boxes1", ",", "boxes2", "=", "self", ".", "create_boxes", "(", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "1.0", ",", "0.5", ",", "0.5", ",", "0.25", ",", "0.25", ",", "0.25", "/", "(", "2", "-", "0.25", ")", "]", ",", "\n", "[", "1.0", ",", "0.5", ",", "0.5", ",", "0.25", ",", "0.25", ",", "0.25", "/", "(", "2", "-", "0.25", ")", "]", ",", "\n", "]", "\n", ")", "\n", "\n", "ious", "=", "pairwise_iou", "(", "Boxes", "(", "boxes1", ")", ",", "Boxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxIOU.test_pairwise_ioa": [[177, 184], ["test_boxes.TestBoxIOU.create_boxes", "torch.tensor", "detectron2.structures.pairwise_ioa", "test_boxes.TestBoxIOU.assertTrue", "detectron2.structures.Boxes", "detectron2.structures.Boxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxIOU.create_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_ioa"], ["", "def", "test_pairwise_ioa", "(", "self", ")", ":", "\n", "        ", "boxes1", ",", "boxes2", "=", "self", ".", "create_boxes", "(", ")", "\n", "expected_ioas", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "0.25", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "0.25", "]", "]", "\n", ")", "\n", "ioas", "=", "pairwise_ioa", "(", "Boxes", "(", "boxes1", ")", ",", "Boxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ioas", ",", "expected_ioas", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxes.test_empty_cat": [[187, 190], ["detectron2.structures.Boxes.cat", "test_boxes.TestBoxes.assertTrue"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["    ", "def", "test_empty_cat", "(", "self", ")", ":", "\n", "        ", "x", "=", "Boxes", ".", "cat", "(", "[", "]", ")", "\n", "self", ".", "assertTrue", "(", "x", ".", "tensor", ".", "shape", ",", "(", "0", ",", "4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_boxes.TestBoxes.test_scriptability": [[192, 200], ["unittest.skipIf", "torch.jit.script", "torch.jit.script.", "detectron2.structures.Boxes", "detectron2.structures.Boxes.area", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "6", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_scriptability", "(", "self", ")", ":", "\n", "        ", "def", "func", "(", "x", ")", ":", "\n", "            ", "boxes", "=", "Boxes", "(", "x", ")", "\n", "return", "boxes", ".", "area", "(", ")", "\n", "\n", "", "f", "=", "torch", ".", "jit", ".", "script", "(", "func", ")", "\n", "f", "(", "torch", ".", "rand", "(", "(", "3", ",", "4", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_imagelist.TestImageList.test_imagelist_padding_shape": [[12, 40], ["torch.jit.trace", "torch.jit.trace.", "test_imagelist.TestImageList.assertEqual", "torch.jit.trace", "torch.jit.trace.", "test_imagelist.TestImageList.assertEqual", "TensorToImageList", "list", "str", "TensorToImageList", "list", "str", "torch.ones", "torch.ones", "torch.ones", "detectron2.structures.ImageList.from_tensors", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors"], ["    ", "def", "test_imagelist_padding_shape", "(", "self", ")", ":", "\n", "        ", "class", "TensorToImageList", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "tensors", ":", "Sequence", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "                ", "return", "ImageList", ".", "from_tensors", "(", "tensors", ",", "4", ")", ".", "tensor", "\n", "\n", "", "", "func", "=", "torch", ".", "jit", ".", "trace", "(", "\n", "TensorToImageList", "(", ")", ",", "(", "[", "torch", ".", "ones", "(", "(", "3", ",", "10", ",", "10", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "]", ",", ")", "\n", ")", "\n", "ret", "=", "func", "(", "[", "torch", ".", "ones", "(", "(", "3", ",", "15", ",", "20", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "]", ")", "\n", "self", ".", "assertEqual", "(", "list", "(", "ret", ".", "shape", ")", ",", "[", "1", ",", "3", ",", "16", ",", "20", "]", ",", "str", "(", "ret", ".", "shape", ")", ")", "\n", "\n", "func", "=", "torch", ".", "jit", ".", "trace", "(", "\n", "TensorToImageList", "(", ")", ",", "\n", "(", "\n", "[", "\n", "torch", ".", "ones", "(", "(", "3", ",", "16", ",", "10", ")", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "torch", ".", "ones", "(", "(", "3", ",", "13", ",", "11", ")", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "]", ",", "\n", ")", ",", "\n", ")", "\n", "ret", "=", "func", "(", "\n", "[", "\n", "torch", ".", "ones", "(", "(", "3", ",", "25", ",", "20", ")", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "torch", ".", "ones", "(", "(", "3", ",", "10", ",", "10", ")", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "]", "\n", ")", "\n", "# does not support calling with different #images", "\n", "self", ".", "assertEqual", "(", "list", "(", "ret", ".", "shape", ")", ",", "[", "2", ",", "3", ",", "28", ",", "20", "]", ",", "str", "(", "ret", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_imagelist.TestImageList.test_imagelist_scriptability": [[41, 56], ["unittest.skipIf", "torch.randn", "test_imagelist.TestImageList.test_imagelist_scriptability.f"], "methods", ["None"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "6", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_imagelist_scriptability", "(", "self", ")", ":", "\n", "        ", "image_nums", "=", "2", "\n", "image_tensor", "=", "torch", ".", "randn", "(", "(", "image_nums", ",", "10", ",", "20", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "image_shape", "=", "[", "(", "10", ",", "20", ")", "]", "*", "image_nums", "\n", "\n", "def", "f", "(", "image_tensor", ",", "image_shape", ":", "List", "[", "Tuple", "[", "int", ",", "int", "]", "]", ")", ":", "\n", "            ", "return", "ImageList", "(", "image_tensor", ",", "image_shape", ")", "\n", "\n", "", "ret", "=", "f", "(", "image_tensor", ",", "image_shape", ")", "\n", "ret_script", "=", "torch", ".", "jit", ".", "script", "(", "f", ")", "(", "image_tensor", ",", "image_shape", ")", "\n", "\n", "self", ".", "assertEqual", "(", "len", "(", "ret", ")", ",", "len", "(", "ret_script", ")", ")", "\n", "for", "i", "in", "range", "(", "image_nums", ")", ":", "\n", "            ", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "ret", "[", "i", "]", ",", "ret_script", "[", "i", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_masks.TestBitMask.test_get_bounding_box": [[8, 39], ["torch.tensor", "detectron2.structures.masks.BitMasks", "torch.tensor", "detectron2.structures.masks.BitMasks.get_bounding_boxes", "test_masks.TestBitMask.assertTrue", "torch.all().item", "box[].numpy", "detectron2.structures.masks.polygons_to_bitmask", "test_masks.TestBitMask.assertTrue", "test_masks.TestBitMask.assertTrue", "torch.zeros", "torch.all().item", "torch.all().item", "torch.all", "detectron2.structures.masks.BitMasks().get_bounding_boxes", "detectron2.structures.masks.PolygonMasks().get_bounding_boxes", "torch.all", "torch.all", "detectron2.structures.masks.BitMasks", "detectron2.structures.masks.PolygonMasks"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.get_bounding_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.polygons_to_bitmask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.get_bounding_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.get_bounding_boxes"], ["    ", "def", "test_get_bounding_box", "(", "self", ")", ":", "\n", "        ", "masks", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "\n", "[", "False", ",", "False", ",", "False", ",", "True", "]", ",", "\n", "[", "False", ",", "False", ",", "True", ",", "True", "]", ",", "\n", "[", "False", ",", "True", ",", "True", ",", "False", "]", ",", "\n", "[", "False", ",", "True", ",", "True", ",", "False", "]", ",", "\n", "]", ",", "\n", "[", "\n", "[", "False", ",", "False", ",", "False", ",", "False", "]", ",", "\n", "[", "False", ",", "False", ",", "True", ",", "False", "]", ",", "\n", "[", "False", ",", "True", ",", "True", ",", "False", "]", ",", "\n", "[", "False", ",", "True", ",", "True", ",", "False", "]", ",", "\n", "]", ",", "\n", "torch", ".", "zeros", "(", "4", ",", "4", ")", ",", "\n", "]", "\n", ")", "\n", "bitmask", "=", "BitMasks", "(", "masks", ")", "\n", "box_true", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "0", ",", "4", ",", "4", "]", ",", "[", "1", ",", "1", ",", "3", ",", "4", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "box", "=", "bitmask", ".", "get_bounding_boxes", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "box", ".", "tensor", "==", "box_true", ")", ".", "item", "(", ")", ")", "\n", "\n", "for", "box", "in", "box_true", ":", "\n", "            ", "poly", "=", "box", "[", "[", "0", ",", "1", ",", "2", ",", "1", ",", "2", ",", "3", ",", "0", ",", "3", "]", "]", ".", "numpy", "(", ")", "\n", "mask", "=", "polygons_to_bitmask", "(", "[", "poly", "]", ",", "4", ",", "4", ")", "\n", "reconstruct_box", "=", "BitMasks", "(", "mask", "[", "None", ",", ":", ",", ":", "]", ")", ".", "get_bounding_boxes", "(", ")", "[", "0", "]", ".", "tensor", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "box", "==", "reconstruct_box", ")", ".", "item", "(", ")", ")", "\n", "\n", "reconstruct_box", "=", "PolygonMasks", "(", "[", "[", "poly", "]", "]", ")", ".", "get_bounding_boxes", "(", ")", "[", "0", "]", ".", "tensor", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "box", "==", "reconstruct_box", ")", ".", "item", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_instances.TestInstances.test_int_indexing": [[11, 24], ["torch.tensor", "torch.tensor", "detectron2.structures.Instances", "range", "test_instances.TestInstances.assertRaises", "test_instances.TestInstances.assertRaises", "len", "test_instances.TestInstances.assertEqual", "test_instances.TestInstances.assertEqual", "len", "len", "len"], "methods", ["None"], ["    ", "def", "test_int_indexing", "(", "self", ")", ":", "\n", "        ", "attr1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", ",", "0.5", "]", ",", "[", "0.0", ",", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.5", ",", "0.5", "]", "]", ")", "\n", "attr2", "=", "torch", ".", "tensor", "(", "[", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", "]", ")", "\n", "instances", "=", "Instances", "(", "(", "100", ",", "100", ")", ")", "\n", "instances", ".", "attr1", "=", "attr1", "\n", "instances", ".", "attr2", "=", "attr2", "\n", "for", "i", "in", "range", "(", "-", "len", "(", "instances", ")", ",", "len", "(", "instances", ")", ")", ":", "\n", "            ", "inst", "=", "instances", "[", "i", "]", "\n", "self", ".", "assertEqual", "(", "(", "inst", ".", "attr1", "==", "attr1", "[", "i", "]", ")", ".", "all", "(", ")", ",", "True", ")", "\n", "self", ".", "assertEqual", "(", "(", "inst", ".", "attr2", "==", "attr2", "[", "i", "]", ")", ".", "all", "(", ")", ",", "True", ")", "\n", "\n", "", "self", ".", "assertRaises", "(", "IndexError", ",", "lambda", ":", "instances", "[", "len", "(", "instances", ")", "]", ")", "\n", "self", ".", "assertRaises", "(", "IndexError", ",", "lambda", ":", "instances", "[", "-", "len", "(", "instances", ")", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_instances.TestInstances.test_script_new_fields": [[25, 56], ["unittest.skipIf", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "test_instances.TestInstances.assertRaises", "torch.jit.script", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "f", "g2", "g", "test_instances.TestInstances.assertRaises", "torch.jit.script", "g2"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_script_new_fields", "(", "self", ")", ":", "\n", "        ", "class", "f", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "proposal_boxes", "=", "x", ".", "proposal_boxes", "# noqa F841", "\n", "objectness_logits", "=", "x", ".", "objectness_logits", "# noqa F841", "\n", "return", "x", "\n", "\n", "", "", "class", "g", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "mask", "=", "x", ".", "mask", "# noqa F841", "\n", "return", "x", "\n", "\n", "", "", "class", "g2", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "proposal_boxes", "=", "x", ".", "proposal_boxes", "# noqa F841", "\n", "return", "x", "\n", "\n", "", "", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", ",", "\"objectness_logits\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", ":", "\n", "            ", "torch", ".", "jit", ".", "script", "(", "f", "(", ")", ")", "\n", "\n", "# can't script anymore after exiting the context", "\n", "", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "            ", "torch", ".", "jit", ".", "script", "(", "g2", "(", ")", ")", "\n", "\n", "", "new_fields", "=", "{", "\"mask\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "new_fields", ")", ":", "\n", "            ", "torch", ".", "jit", ".", "script", "(", "g", "(", ")", ")", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "torch", ".", "jit", ".", "script", "(", "g2", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_instances.TestInstances.test_script_access_fields": [[57, 68], ["unittest.skipIf", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "f"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances"], ["", "", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_script_access_fields", "(", "self", ")", ":", "\n", "        ", "class", "f", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "proposal_boxes", "=", "x", ".", "proposal_boxes", "\n", "objectness_logits", "=", "x", ".", "objectness_logits", "\n", "return", "proposal_boxes", ".", "tensor", "+", "objectness_logits", "\n", "\n", "", "", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", ",", "\"objectness_logits\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", ":", "\n", "            ", "torch", ".", "jit", ".", "script", "(", "f", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_instances.TestInstances.test_script_len": [[69, 100], ["unittest.skipIf", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "new_instance", "torch.tensor", "detectron2.structures.Boxes", "torch.jit.script.", "test_instances.TestInstances.assertEqual", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "new_instance", "torch.tensor().reshape", "torch.jit.script.", "test_instances.TestInstances.assertEqual", "len", "len", "f", "test_instances.TestInstances.assertRaises", "torch.jit.script.", "g", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances"], ["", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_script_len", "(", "self", ")", ":", "\n", "        ", "class", "f", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "return", "len", "(", "x", ")", "\n", "\n", "", "", "class", "g", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "return", "len", "(", "x", ")", "\n", "\n", "", "", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "\n", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "new_instance", ":", "\n", "            ", "script_module", "=", "torch", ".", "jit", ".", "script", "(", "f", "(", ")", ")", "\n", "x", "=", "new_instance", "(", "image_shape", ")", "\n", "with", "self", ".", "assertRaises", "(", "Exception", ")", ":", "\n", "                ", "script_module", "(", "x", ")", "\n", "", "box_tensors", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "x", ".", "proposal_boxes", "=", "Boxes", "(", "box_tensors", ")", "\n", "length", "=", "script_module", "(", "x", ")", "\n", "self", ".", "assertEqual", "(", "length", ",", "2", ")", "\n", "\n", "", "fields", "=", "{", "\"objectness_logits\"", ":", "\"Tensor\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "new_instance", ":", "\n", "            ", "script_module", "=", "torch", ".", "jit", ".", "script", "(", "g", "(", ")", ")", "\n", "x", "=", "new_instance", "(", "image_shape", ")", "\n", "objectness_logits", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ".", "reshape", "(", "1", ",", "1", ")", "\n", "x", ".", "objectness_logits", "=", "objectness_logits", "\n", "length", "=", "script_module", "(", "x", ")", "\n", "self", ".", "assertEqual", "(", "length", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_instances.TestInstances.test_script_has": [[101, 117], ["unittest.skipIf", "detectron2.export.torchscript.patch_instances", "torch.jit.script", "new_instance", "test_instances.TestInstances.assertFalse", "torch.tensor", "detectron2.structures.Boxes", "test_instances.TestInstances.assertTrue", "new_instance.has", "f", "torch.jit.script.", "torch.jit.script."], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has"], ["", "", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "7", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_script_has", "(", "self", ")", ":", "\n", "        ", "class", "f", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "forward", "(", "self", ",", "x", ":", "Instances", ")", ":", "\n", "                ", "return", "x", ".", "has", "(", "\"proposal_boxes\"", ")", "\n", "\n", "", "", "image_shape", "=", "(", "15", ",", "15", ")", "\n", "fields", "=", "{", "\"proposal_boxes\"", ":", "\"Boxes\"", "}", "\n", "with", "patch_instances", "(", "fields", ")", "as", "new_instance", ":", "\n", "            ", "script_module", "=", "torch", ".", "jit", ".", "script", "(", "f", "(", ")", ")", "\n", "x", "=", "new_instance", "(", "image_shape", ")", "\n", "self", ".", "assertFalse", "(", "script_module", "(", "x", ")", ")", "\n", "\n", "box_tensors", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "10", "]", ",", "[", "1", ",", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "x", ".", "proposal_boxes", "=", "Boxes", "(", "box_tensors", ")", "\n", "self", ".", "assertTrue", "(", "script_module", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_0_dim_cpu": [[18, 30], ["torch.rand", "torch.rand", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.rand", "torch.rand", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.allclose", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated"], ["    ", "def", "test_iou_0_dim_cpu", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "rand", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "rand", "(", "10", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "0", ",", "10", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n", "boxes1", "=", "torch", ".", "rand", "(", "10", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "rand", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "10", ",", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_0_dim_cuda": [[31, 44], ["unittest.skipIf", "torch.rand", "torch.rand", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.rand", "torch.rand", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.rand.cuda", "torch.rand.cuda", "torch.allclose", "torch.rand.cuda", "torch.rand.cuda", "torch.allclose", "torch.cuda.is_available", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.cpu", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_iou_0_dim_cuda", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "rand", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "rand", "(", "10", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "0", ",", "10", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious_cuda", "=", "pairwise_iou_rotated", "(", "boxes1", ".", "cuda", "(", ")", ",", "boxes2", ".", "cuda", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious_cuda", ".", "cpu", "(", ")", ",", "expected_ious", ")", ")", "\n", "\n", "boxes1", "=", "torch", ".", "rand", "(", "10", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "rand", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "10", ",", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious_cuda", "=", "pairwise_iou_rotated", "(", "boxes1", ".", "cuda", "(", ")", ",", "boxes2", ".", "cuda", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious_cuda", ".", "cpu", "(", ")", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_half_overlap_cpu": [[45, 51], ["torch.tensor", "torch.tensor", "torch.tensor", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated"], ["", "def", "test_iou_half_overlap_cpu", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "0.25", ",", "0.5", ",", "0.5", ",", "1.0", ",", "0.0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_half_overlap_cuda": [[52, 59], ["unittest.skipIf", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.tensor.cuda", "torch.tensor.cuda", "torch.allclose", "torch.cuda.is_available", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_iou_half_overlap_cuda", "(", "self", ")", ":", "\n", "        ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "0.25", ",", "0.5", ",", "0.5", ",", "1.0", ",", "0.0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious_cuda", "=", "pairwise_iou_rotated", "(", "boxes1", ".", "cuda", "(", ")", ",", "boxes2", ".", "cuda", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious_cuda", ".", "cpu", "(", ")", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_precision": [[60, 68], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "torch.allclose", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated"], ["", "def", "test_iou_precision", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "565", ",", "565", ",", "10", ",", "10.0", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "565", ",", "565", ",", "10", ",", "8.3", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "iou", "=", "8.3", "/", "10.0", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ".", "cpu", "(", ")", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_too_many_boxes_cuda": [[69, 76], ["unittest.skipIf", "torch.zeros", "torch.zeros", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTupleEqual", "torch.zeros.cuda", "torch.zeros.cuda", "tuple", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated"], ["", "", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_iou_too_many_boxes_cuda", "(", "self", ")", ":", "\n", "        ", "s1", ",", "s2", "=", "5", ",", "1289035", "\n", "boxes1", "=", "torch", ".", "zeros", "(", "s1", ",", "5", ")", "\n", "boxes2", "=", "torch", ".", "zeros", "(", "s2", ",", "5", ")", "\n", "ious_cuda", "=", "pairwise_iou_rotated", "(", "boxes1", ".", "cuda", "(", ")", ",", "boxes2", ".", "cuda", "(", ")", ")", "\n", "self", ".", "assertTupleEqual", "(", "tuple", "(", "ious_cuda", ".", "shape", ")", ",", "(", "s1", ",", "s2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesLayer.test_iou_extreme": [[77, 95], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "test_rotated_boxes.TestRotatedBoxesLayer.assertTrue", "detectron2.layers.rotated_boxes.pairwise_iou_rotated.min"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated"], ["", "def", "test_iou_extreme", "(", "self", ")", ":", "\n", "# Cause floating point issues in cuda kernels (#1266)", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "160.0", ",", "153.0", ",", "230.0", ",", "23.0", ",", "-", "37.0", "]", "]", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "\n", "-", "1.117407639806935e17", ",", "\n", "1.3858420478349148e18", ",", "\n", "1000.0000610351562", ",", "\n", "1000.0000610351562", ",", "\n", "1612.0", ",", "\n", "]", "\n", "]", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "ious", "=", "pairwise_iou_rotated", "(", "boxes1", ",", "boxes2", ")", "\n", "self", ".", "assertTrue", "(", "ious", ".", "min", "(", ")", ">=", "0", ",", "ious", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_clip_area_0_degree": [[98, 126], ["range", "torch.zeros", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.zeros", "detectron2.structures.boxes.Boxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.boxes.Boxes.area", "detectron2.structures.rotated_boxes.RotatedBoxes.area", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.boxes.Boxes.clip", "detectron2.structures.rotated_boxes.RotatedBoxes.clip", "detectron2.structures.boxes.Boxes.area", "detectron2.structures.rotated_boxes.RotatedBoxes.area", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "torch.allclose", "torch.allclose", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area"], ["    ", "def", "test_clip_area_0_degree", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "            ", "num_boxes", "=", "100", "\n", "boxes_5d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "5", ")", "\n", "boxes_5d", "[", ":", ",", "0", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "1", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "2", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "3", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "# Convert from (x_ctr, y_ctr, w, h, 0) to  (x1, y1, x2, y2)", "\n", "boxes_4d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "4", ")", "\n", "boxes_4d", "[", ":", ",", "0", "]", "=", "boxes_5d", "[", ":", ",", "0", "]", "-", "boxes_5d", "[", ":", ",", "2", "]", "/", "2.0", "\n", "boxes_4d", "[", ":", ",", "1", "]", "=", "boxes_5d", "[", ":", ",", "1", "]", "-", "boxes_5d", "[", ":", ",", "3", "]", "/", "2.0", "\n", "boxes_4d", "[", ":", ",", "2", "]", "=", "boxes_5d", "[", ":", ",", "0", "]", "+", "boxes_5d", "[", ":", ",", "2", "]", "/", "2.0", "\n", "boxes_4d", "[", ":", ",", "3", "]", "=", "boxes_5d", "[", ":", ",", "1", "]", "+", "boxes_5d", "[", ":", ",", "3", "]", "/", "2.0", "\n", "\n", "image_size", "=", "(", "500", ",", "600", ")", "\n", "test_boxes_4d", "=", "Boxes", "(", "boxes_4d", ")", "\n", "test_boxes_5d", "=", "RotatedBoxes", "(", "boxes_5d", ")", "\n", "# Before clip", "\n", "areas_4d", "=", "test_boxes_4d", ".", "area", "(", ")", "\n", "areas_5d", "=", "test_boxes_5d", ".", "area", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "areas_4d", ",", "areas_5d", ",", "atol", "=", "1e-1", ",", "rtol", "=", "1e-5", ")", ")", "\n", "# After clip", "\n", "test_boxes_4d", ".", "clip", "(", "image_size", ")", "\n", "test_boxes_5d", ".", "clip", "(", "image_size", ")", "\n", "areas_4d", "=", "test_boxes_4d", ".", "area", "(", ")", "\n", "areas_5d", "=", "test_boxes_5d", ".", "area", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "areas_4d", ",", "areas_5d", ",", "atol", "=", "1e-1", ",", "rtol", "=", "1e-5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_clip_area_arbitrary_angle": [[127, 153], ["torch.zeros", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "random.uniform", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes.area", "detectron2.structures.rotated_boxes.RotatedBoxes.clip", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes.area", "torch.all", "torch.all", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.abs", "torch.where"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area"], ["", "", "def", "test_clip_area_arbitrary_angle", "(", "self", ")", ":", "\n", "        ", "num_boxes", "=", "100", "\n", "boxes_5d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "5", ")", "\n", "boxes_5d", "[", ":", ",", "0", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "1", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "2", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "3", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "4", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "1800", ",", "1800", ")", "\n", "clip_angle_threshold", "=", "random", ".", "uniform", "(", "0", ",", "180", ")", "\n", "\n", "image_size", "=", "(", "500", ",", "600", ")", "\n", "test_boxes_5d", "=", "RotatedBoxes", "(", "boxes_5d", ")", "\n", "# Before clip", "\n", "areas_before", "=", "test_boxes_5d", ".", "area", "(", ")", "\n", "# After clip", "\n", "test_boxes_5d", ".", "clip", "(", "image_size", ",", "clip_angle_threshold", ")", "\n", "areas_diff", "=", "test_boxes_5d", ".", "area", "(", ")", "-", "areas_before", "\n", "\n", "# the areas should only decrease after clipping", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "areas_diff", "<=", "0", ")", ")", "\n", "# whenever the box is clipped (thus the area shrinks),", "\n", "# the angle for the box must be within the clip_angle_threshold", "\n", "# Note that the clip function will normalize the angle range", "\n", "# to be within (-180, 180]", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "all", "(", "torch", ".", "abs", "(", "boxes_5d", "[", ":", ",", "4", "]", "[", "torch", ".", "where", "(", "areas_diff", "<", "0", ")", "]", ")", "<", "clip_angle_threshold", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_normalize_angles": [[155, 187], ["range", "torch.zeros", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes.clone", "detectron2.structures.rotated_boxes.RotatedBoxes.clone.normalize_angles", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "torch.all", "torch.all", "torch.allclose", "torch.allclose", "torch.allclose", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.cos", "torch.cos", "torch.sin", "torch.sin"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.rotated_boxes.RotatedBoxes.normalize_angles"], ["", "def", "test_normalize_angles", "(", "self", ")", ":", "\n", "# torch.manual_seed(0)", "\n", "        ", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "            ", "num_boxes", "=", "100", "\n", "boxes_5d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "5", ")", "\n", "boxes_5d", "[", ":", ",", "0", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "1", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "100", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "2", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "3", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "500", ")", "\n", "boxes_5d", "[", ":", ",", "4", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "1800", ",", "1800", ")", "\n", "rotated_boxes", "=", "RotatedBoxes", "(", "boxes_5d", ")", "\n", "normalized_boxes", "=", "rotated_boxes", ".", "clone", "(", ")", "\n", "normalized_boxes", ".", "normalize_angles", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "normalized_boxes", ".", "tensor", "[", ":", ",", "4", "]", ">=", "-", "180", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "all", "(", "normalized_boxes", ".", "tensor", "[", ":", ",", "4", "]", "<", "180", ")", ")", "\n", "# x, y, w, h should not change", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "boxes_5d", "[", ":", ",", ":", "4", "]", ",", "normalized_boxes", ".", "tensor", "[", ":", ",", ":", "4", "]", ")", ")", "\n", "# the cos/sin values of the angles should stay the same", "\n", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "\n", "torch", ".", "cos", "(", "boxes_5d", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180", ")", ",", "\n", "torch", ".", "cos", "(", "normalized_boxes", ".", "tensor", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180", ")", ",", "\n", "atol", "=", "1e-5", ",", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "\n", "torch", ".", "sin", "(", "boxes_5d", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180", ")", ",", "\n", "torch", ".", "sin", "(", "normalized_boxes", ".", "tensor", "[", ":", ",", "4", "]", "*", "math", ".", "pi", "/", "180", ")", ",", "\n", "atol", "=", "1e-5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_0_degree": [[190, 219], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_0_degree", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", ",", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.5", ",", "0.5", ",", "1.0", ",", "1.0", ",", "0.0", "]", ",", "\n", "[", "0.25", ",", "0.5", ",", "0.5", ",", "1.0", ",", "0.0", "]", ",", "\n", "[", "0.5", ",", "0.25", ",", "1.0", ",", "0.5", ",", "0.0", "]", ",", "\n", "[", "0.25", ",", "0.25", ",", "0.5", ",", "0.5", ",", "0.0", "]", ",", "\n", "[", "0.75", ",", "0.75", ",", "0.5", ",", "0.5", ",", "0.0", "]", ",", "\n", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "0.0", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "1.0", ",", "0.5", ",", "0.5", ",", "0.25", ",", "0.25", ",", "0.25", "/", "(", "2", "-", "0.25", ")", "]", ",", "\n", "[", "1.0", ",", "0.5", ",", "0.5", ",", "0.25", ",", "0.25", ",", "0.25", "/", "(", "2", "-", "0.25", ")", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_45_degrees": [[220, 234], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_45_degrees", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "1", ",", "1", ",", "math", ".", "sqrt", "(", "2", ")", ",", "math", ".", "sqrt", "(", "2", ")", ",", "45", "]", ",", "\n", "[", "1", ",", "1", ",", "2", "*", "math", ".", "sqrt", "(", "2", ")", ",", "2", "*", "math", ".", "sqrt", "(", "2", ")", ",", "-", "45", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "2", ",", "2", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", "]", ",", "[", "0.5", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_orthogonal": [[235, 243], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_orthogonal", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "6", ",", "55", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "5", ",", "5", ",", "10", ",", "6", ",", "-", "35", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "iou", "=", "(", "6.0", "*", "6.0", ")", "/", "(", "6.0", "*", "6.0", "+", "4.0", "*", "6.0", "+", "4.0", "*", "6.0", ")", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_large_close_boxes": [[244, 260], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_large_close_boxes", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "299.500000", ",", "417.370422", ",", "600.000000", ",", "364.259186", ",", "27.1828", "]", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "299.500000", ",", "417.370422", ",", "600.000000", ",", "364.259155", ",", "27.1828", "]", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "iou", "=", "364.259155", "/", "364.259186", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_many_boxes": [[261, 288], ["torch.cuda.is_available", "torch.stack", "torch.stack", "torch.zeros", "range", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "min", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose", "torch.tensor", "torch.tensor", "range", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_many_boxes", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "num_boxes1", "=", "100", "\n", "num_boxes2", "=", "200", "\n", "boxes1", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "tensor", "(", "\n", "[", "5", "+", "20", "*", "i", ",", "5", "+", "20", "*", "i", ",", "10", ",", "10", ",", "0", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "for", "i", "in", "range", "(", "num_boxes1", ")", "\n", "]", "\n", ")", "\n", "boxes2", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "tensor", "(", "\n", "[", "5", "+", "20", "*", "i", ",", "5", "+", "20", "*", "i", ",", "10", ",", "1", "+", "9", "*", "i", "/", "num_boxes2", ",", "0", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "num_boxes2", ")", "\n", "]", "\n", ")", "\n", "expected_ious", "=", "torch", ".", "zeros", "(", "num_boxes1", ",", "num_boxes2", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "for", "i", "in", "range", "(", "min", "(", "num_boxes1", ",", "num_boxes2", ")", ")", ":", "\n", "                ", "expected_ious", "[", "i", "]", "[", "i", "]", "=", "(", "1", "+", "9", "*", "i", "/", "num_boxes2", ")", "/", "10.0", "\n", "", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_issue1207_simplified": [[289, 299], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_issue1207_simplified", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "# Simplified test case of D2-issue-1207", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "3", ",", "3", ",", "8", ",", "2", ",", "-", "45.0", "]", "]", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "6", ",", "0", ",", "8", ",", "2", ",", "-", "45.0", "]", "]", ",", "device", "=", "device", ")", "\n", "iou", "=", "0.0", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_pairwise_iou_issue1207": [[300, 311], ["torch.cuda.is_available", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.structures.rotated_boxes.pairwise_iou", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue", "detectron2.structures.rotated_boxes.RotatedBoxes", "detectron2.structures.rotated_boxes.RotatedBoxes", "torch.allclose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou"], ["", "", "def", "test_pairwise_iou_issue1207", "(", "self", ")", ":", "\n", "        ", "for", "device", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "# The original test case in D2-issue-1207", "\n", "            ", "boxes1", "=", "torch", ".", "tensor", "(", "[", "[", "160.0", ",", "153.0", ",", "230.0", ",", "23.0", ",", "-", "37.0", "]", "]", ",", "device", "=", "device", ")", "\n", "boxes2", "=", "torch", ".", "tensor", "(", "[", "[", "190.0", ",", "127.0", ",", "80.0", ",", "21.0", ",", "-", "46.0", "]", "]", ",", "device", "=", "device", ")", "\n", "\n", "iou", "=", "0.0", "\n", "expected_ious", "=", "torch", ".", "tensor", "(", "[", "[", "iou", "]", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "\n", "ious", "=", "pairwise_iou", "(", "RotatedBoxes", "(", "boxes1", ")", ",", "RotatedBoxes", "(", "boxes2", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "ious", ",", "expected_ious", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.TestRotatedBoxesStructure.test_empty_cat": [[312, 315], ["detectron2.structures.rotated_boxes.RotatedBoxes.cat", "test_rotated_boxes.TestRotatedBoxesStructure.assertTrue"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "", "def", "test_empty_cat", "(", "self", ")", ":", "\n", "        ", "x", "=", "RotatedBoxes", ".", "cat", "(", "[", "]", ")", "\n", "self", ".", "assertTrue", "(", "x", ".", "tensor", ".", "shape", ",", "(", "0", ",", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.test_rotated_boxes.benchmark_rotated_iou": [[317, 353], ["torch.stack", "torch.stack", "torch.cuda.is_available", "fvcore.common.benchmark.benchmark", "torch.stack.to", "torch.stack.to", "args.append", "torch.tensor", "torch.tensor", "range", "torch.device", "range", "range", "detectron2.layers.rotated_boxes.pairwise_iou_rotated", "torch.cuda.synchronize", "torch.device"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["", "", "def", "benchmark_rotated_iou", "(", ")", ":", "\n", "    ", "num_boxes1", "=", "200", "\n", "num_boxes2", "=", "500", "\n", "boxes1", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "tensor", "(", "[", "5", "+", "20", "*", "i", ",", "5", "+", "20", "*", "i", ",", "10", ",", "10", ",", "0", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "num_boxes1", ")", "\n", "]", "\n", ")", "\n", "boxes2", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "tensor", "(", "\n", "[", "5", "+", "20", "*", "i", ",", "5", "+", "20", "*", "i", ",", "10", ",", "1", "+", "9", "*", "i", "/", "num_boxes2", ",", "0", "]", ",", "dtype", "=", "torch", ".", "float32", "\n", ")", "\n", "for", "i", "in", "range", "(", "num_boxes2", ")", "\n", "]", "\n", ")", "\n", "\n", "def", "func", "(", "dev", ",", "n", "=", "1", ")", ":", "\n", "        ", "b1", "=", "boxes1", ".", "to", "(", "device", "=", "dev", ")", "\n", "b2", "=", "boxes2", ".", "to", "(", "device", "=", "dev", ")", "\n", "\n", "def", "bench", "(", ")", ":", "\n", "            ", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "                ", "pairwise_iou_rotated", "(", "b1", ",", "b2", ")", "\n", "", "if", "dev", ".", "type", "==", "\"cuda\"", ":", "\n", "                ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "\n", "", "", "return", "bench", "\n", "\n", "# only run it once per timed loop, since it's slow", "\n", "", "args", "=", "[", "{", "\"dev\"", ":", "torch", ".", "device", "(", "\"cpu\"", ")", ",", "\"n\"", ":", "1", "}", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "args", ".", "append", "(", "{", "\"dev\"", ":", "torch", ".", "device", "(", "\"cuda\"", ")", ",", "\"n\"", ":", "10", "}", ")", "\n", "\n", "", "benchmark", "(", "func", ",", "\"rotated_iou\"", ",", "args", ",", "warmup_iters", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file": [[24, 66], ["fvcore.common.file_io.PathManager.isfile", "fvcore.common.config.CfgNode.load_yaml_with_base", "logging.getLogger", "fvcore.common.config.CfgNode.load_yaml_with_base.get", "type", "guess_version", "config.CfgNode.merge_from_other_cfg", "logging.getLogger.warning", "downgrade_config", "downgrade_config.merge_from_other_cfg", "upgrade_config", "config.CfgNode.clear", "config.CfgNode.update"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.guess_version", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.downgrade_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.upgrade_config"], ["def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "", "else", ":", "\n", "# compat.py needs to import CfgNode", "\n", "            ", "from", ".", "compat", "import", "upgrade_config", ",", "downgrade_config", "\n", "\n", "logger", ".", "warning", "(", "\n", "\"Loading an old v{} config file '{}' by automatically upgrading to v{}. \"", "\n", "\"See docs/CHANGELOG.md for instructions to update your files.\"", ".", "format", "(", "\n", "loaded_ver", ",", "cfg_filename", ",", "self", ".", "VERSION", "\n", ")", "\n", ")", "\n", "# To convert, first obtain a full config at an old version", "\n", "old_self", "=", "downgrade_config", "(", "self", ",", "to_version", "=", "loaded_ver", ")", "\n", "old_self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "new_config", "=", "upgrade_config", "(", "old_self", ")", "\n", "self", ".", "clear", "(", ")", "\n", "self", ".", "update", "(", "new_config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump": [[67, 74], ["super().dump"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump"], ["", "", "def", "dump", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            str: a yaml string representation of the config\n        \"\"\"", "\n", "# to make it show up in docs", "\n", "return", "super", "(", ")", ".", "dump", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg": [[79, 89], ["_C.clone"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["def", "get_cfg", "(", ")", "->", "CfgNode", ":", "\n", "    ", "\"\"\"\n    Get a copy of the default config.\n\n    Returns:\n        a detectron2 CfgNode instance.\n    \"\"\"", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "return", "_C", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.set_global_cfg": [[91, 108], ["global_cfg.clear", "global_cfg.update"], "function", ["None"], ["", "def", "set_global_cfg", "(", "cfg", ":", "CfgNode", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Let the global config point to the given cfg.\n\n    Assume that the given \"cfg\" has the key \"KEY\", after calling\n    `set_global_cfg(cfg)`, the key can be accessed by:\n    ::\n        from detectron2.config import global_cfg\n        print(global_cfg.KEY)\n\n    By using a hacky global config, you can access these configs anywhere,\n    without having to pass the config object or the values deep into the code.\n    This is a hacky feature introduced for quick prototyping / research exploration.\n    \"\"\"", "\n", "global", "global_cfg", "\n", "global_cfg", ".", "clear", "(", ")", "\n", "global_cfg", ".", "update", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.configurable": [[110, 155], ["init_func.__module__.startswith", "functools.wraps", "config._called_with_cfg", "inspect.ismethod", "TypeError", "config._get_args_from_config", "init_func", "init_func", "type", "AttributeError"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config._called_with_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config._get_args_from_config"], ["", "def", "configurable", "(", "init_func", ")", ":", "\n", "    ", "\"\"\"\n    Decorate a class's __init__ method so that it can be called with a CfgNode\n    object using the class's from_config classmethod.\n\n    Examples:\n    ::\n        class A:\n            @configurable\n            def __init__(self, a, b=2, c=3):\n                pass\n\n            @classmethod\n            def from_config(cls, cfg):\n                # Returns kwargs to be passed to __init__\n                return {\"a\": cfg.A, \"b\": cfg.B}\n\n        a1 = A(a=1, b=2)  # regular construction\n        a2 = A(cfg)       # construct with a cfg\n        a3 = A(cfg, b=3, c=4)  # construct with extra overwrite\n    \"\"\"", "\n", "assert", "init_func", ".", "__name__", "==", "\"__init__\"", ",", "\"@configurable should only be used for __init__!\"", "\n", "if", "init_func", ".", "__module__", ".", "startswith", "(", "\"detectron2.\"", ")", ":", "\n", "        ", "assert", "(", "\n", "init_func", ".", "__doc__", "is", "not", "None", "and", "\"experimental\"", "in", "init_func", ".", "__doc__", "\n", ")", ",", "f\"configurable {init_func} should be marked experimental\"", "\n", "\n", "", "@", "functools", ".", "wraps", "(", "init_func", ")", "\n", "def", "wrapped", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from_config_func", "=", "type", "(", "self", ")", ".", "from_config", "\n", "", "except", "AttributeError", "as", "e", ":", "\n", "            ", "raise", "AttributeError", "(", "\n", "\"Class with @configurable must have a 'from_config' classmethod.\"", "\n", ")", "from", "e", "\n", "", "if", "not", "inspect", ".", "ismethod", "(", "from_config_func", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"Class with @configurable must have a 'from_config' classmethod.\"", ")", "\n", "\n", "", "if", "_called_with_cfg", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "explicit_args", "=", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "init_func", "(", "self", ",", "**", "explicit_args", ")", "\n", "", "else", ":", "\n", "            ", "init_func", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapped", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config._get_args_from_config": [[157, 186], ["inspect.signature", "any", "TypeError", "from_config_func", "set", "list", "from_config_func", "from_config_func.update", "list", "inspect.signature.parameters.keys", "kwargs.keys", "inspect.signature.parameters.keys", "inspect.signature.parameters.values", "kwargs.pop"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Use `from_config` to obtain explicit arguments.\n\n    Returns:\n        dict: arguments to be used for cls.__init__\n    \"\"\"", "\n", "signature", "=", "inspect", ".", "signature", "(", "from_config_func", ")", "\n", "if", "list", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "[", "0", "]", "!=", "\"cfg\"", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "f\"{from_config_func.__self__}.from_config must take 'cfg' as the first argument!\"", "\n", ")", "\n", "", "support_var_arg", "=", "any", "(", "\n", "param", ".", "kind", "in", "[", "param", ".", "VAR_POSITIONAL", ",", "param", ".", "VAR_KEYWORD", "]", "\n", "for", "param", "in", "signature", ".", "parameters", ".", "values", "(", ")", "\n", ")", "\n", "if", "support_var_arg", ":", "# forward all arguments to from_config, if from_config accepts them", "\n", "        ", "ret", "=", "from_config_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "# forward supported arguments to from_config", "\n", "        ", "supported_arg_names", "=", "set", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "\n", "extra_kwargs", "=", "{", "}", "\n", "for", "name", "in", "list", "(", "kwargs", ".", "keys", "(", ")", ")", ":", "\n", "            ", "if", "name", "not", "in", "supported_arg_names", ":", "\n", "                ", "extra_kwargs", "[", "name", "]", "=", "kwargs", ".", "pop", "(", "name", ")", "\n", "", "", "ret", "=", "from_config_func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "# forward the other arguments to __init__", "\n", "ret", ".", "update", "(", "extra_kwargs", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config._called_with_cfg": [[188, 201], ["isinstance", "len", "isinstance", "kwargs.pop"], "function", ["None"], ["", "def", "_called_with_cfg", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        bool: whether the arguments contain CfgNode and should be considered\n            forwarded to from_config.\n    \"\"\"", "\n", "if", "len", "(", "args", ")", "and", "isinstance", "(", "args", "[", "0", "]", ",", "_CfgNode", ")", ":", "\n", "        ", "return", "True", "\n", "", "if", "isinstance", "(", "kwargs", ".", "pop", "(", "\"cfg\"", ",", "None", ")", ",", "_CfgNode", ")", ":", "\n", "        ", "return", "True", "\n", "# `from_config`'s first argument is forced to be \"cfg\".", "\n", "# So the above check covers all cases.", "\n", "", "return", "False", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._RenameConverter.upgrade": [[153, 157], ["compat._rename"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._rename"], ["@", "classmethod", "\n", "def", "upgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "for", "old", ",", "new", "in", "cls", ".", "RENAME", ":", "\n", "            ", "_rename", "(", "cfg", ",", "old", ",", "new", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._RenameConverter.downgrade": [[158, 162], ["compat._rename"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._rename"], ["", "", "@", "classmethod", "\n", "def", "downgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "for", "old", ",", "new", "in", "cls", ".", "RENAME", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "_rename", "(", "cfg", ",", "new", ",", "old", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.ConverterV2.upgrade": [[203, 220], ["compat._RenameConverter.upgrade", "compat._rename", "compat._rename", "compat._rename", "compat._rename"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.ConverterV2.upgrade", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._rename", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._rename", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._rename", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._rename"], ["@", "classmethod", "\n", "def", "upgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "upgrade", "(", "cfg", ")", "\n", "\n", "if", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "==", "\"RetinaNet\"", ":", "\n", "            ", "_rename", "(", "\n", "cfg", ",", "\"MODEL.RETINANET.ANCHOR_ASPECT_RATIOS\"", ",", "\"MODEL.ANCHOR_GENERATOR.ASPECT_RATIOS\"", "\n", ")", "\n", "_rename", "(", "cfg", ",", "\"MODEL.RETINANET.ANCHOR_SIZES\"", ",", "\"MODEL.ANCHOR_GENERATOR.SIZES\"", ")", "\n", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RPN\"", "]", "[", "\"ANCHOR_SIZES\"", "]", "\n", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RPN\"", "]", "[", "\"ANCHOR_ASPECT_RATIOS\"", "]", "\n", "", "else", ":", "\n", "            ", "_rename", "(", "cfg", ",", "\"MODEL.RPN.ANCHOR_ASPECT_RATIOS\"", ",", "\"MODEL.ANCHOR_GENERATOR.ASPECT_RATIOS\"", ")", "\n", "_rename", "(", "cfg", ",", "\"MODEL.RPN.ANCHOR_SIZES\"", ",", "\"MODEL.ANCHOR_GENERATOR.SIZES\"", ")", "\n", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RETINANET\"", "]", "[", "\"ANCHOR_SIZES\"", "]", "\n", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RETINANET\"", "]", "[", "\"ANCHOR_ASPECT_RATIOS\"", "]", "\n", "", "del", "cfg", "[", "\"MODEL\"", "]", "[", "\"RETINANET\"", "]", "[", "\"ANCHOR_STRIDES\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.ConverterV2.downgrade": [[221, 230], ["compat._RenameConverter.downgrade", "compat._rename", "compat._rename"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.ConverterV2.downgrade", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._rename", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._rename"], ["", "@", "classmethod", "\n", "def", "downgrade", "(", "cls", ",", "cfg", ":", "CN", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "downgrade", "(", "cfg", ")", "\n", "\n", "_rename", "(", "cfg", ",", "\"MODEL.ANCHOR_GENERATOR.ASPECT_RATIOS\"", ",", "\"MODEL.RPN.ANCHOR_ASPECT_RATIOS\"", ")", "\n", "_rename", "(", "cfg", ",", "\"MODEL.ANCHOR_GENERATOR.SIZES\"", ",", "\"MODEL.RPN.ANCHOR_SIZES\"", ")", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "ANCHOR_ASPECT_RATIOS", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "ANCHOR_ASPECT_RATIOS", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "ANCHOR_SIZES", "=", "cfg", ".", "MODEL", ".", "RPN", ".", "ANCHOR_SIZES", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "ANCHOR_STRIDES", "=", "[", "]", "# this is not used anywhere in any version", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.upgrade_config": [[33, 53], ["cfg.clone.clone", "range", "converter.upgrade", "globals", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.ConverterV2.upgrade"], ["def", "upgrade_config", "(", "cfg", ":", "CN", ",", "to_version", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "CN", ":", "\n", "    ", "\"\"\"\n    Upgrade a config from its current version to a newer version.\n\n    Args:\n        cfg (CfgNode):\n        to_version (int): defaults to the latest version.\n    \"\"\"", "\n", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "if", "to_version", "is", "None", ":", "\n", "        ", "to_version", "=", "_C", ".", "VERSION", "\n", "\n", "", "assert", "cfg", ".", "VERSION", "<=", "to_version", ",", "\"Cannot upgrade from v{} to v{}!\"", ".", "format", "(", "\n", "cfg", ".", "VERSION", ",", "to_version", "\n", ")", "\n", "for", "k", "in", "range", "(", "cfg", ".", "VERSION", ",", "to_version", ")", ":", "\n", "        ", "converter", "=", "globals", "(", ")", "[", "\"ConverterV\"", "+", "str", "(", "k", "+", "1", ")", "]", "\n", "converter", ".", "upgrade", "(", "cfg", ")", "\n", "cfg", ".", "VERSION", "=", "k", "+", "1", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.downgrade_config": [[55, 80], ["cfg.clone.clone", "range", "converter.downgrade", "globals", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.ConverterV2.downgrade"], ["", "def", "downgrade_config", "(", "cfg", ":", "CN", ",", "to_version", ":", "int", ")", "->", "CN", ":", "\n", "    ", "\"\"\"\n    Downgrade a config from its current version to an older version.\n\n    Args:\n        cfg (CfgNode):\n        to_version (int):\n\n    Note:\n        A general downgrade of arbitrary configs is not always possible due to the\n        different functionalities in different versions.\n        The purpose of downgrade is only to recover the defaults in old versions,\n        allowing it to load an old partial yaml config.\n        Therefore, the implementation only needs to fill in the default values\n        in the old version when a general downgrade is not possible.\n    \"\"\"", "\n", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "assert", "cfg", ".", "VERSION", ">=", "to_version", ",", "\"Cannot downgrade from v{} to v{}!\"", ".", "format", "(", "\n", "cfg", ".", "VERSION", ",", "to_version", "\n", ")", "\n", "for", "k", "in", "range", "(", "cfg", ".", "VERSION", ",", "to_version", ",", "-", "1", ")", ":", "\n", "        ", "converter", "=", "globals", "(", ")", "[", "\"ConverterV\"", "+", "str", "(", "k", ")", "]", "\n", "converter", ".", "downgrade", "(", "cfg", ")", "\n", "cfg", ".", "VERSION", "=", "k", "-", "1", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.guess_version": [[82, 114], ["logging.getLogger", "name.split", "compat.guess_version._has"], "function", ["None"], ["", "def", "guess_version", "(", "cfg", ":", "CN", ",", "filename", ":", "str", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Guess the version of a partial config where the VERSION field is not specified.\n    Returns the version, or the latest if cannot make a guess.\n\n    This makes it easier for users to migrate.\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "def", "_has", "(", "name", ":", "str", ")", "->", "bool", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "n", "in", "name", ".", "split", "(", "\".\"", ")", ":", "\n", "            ", "if", "n", "not", "in", "cur", ":", "\n", "                ", "return", "False", "\n", "", "cur", "=", "cur", "[", "n", "]", "\n", "", "return", "True", "\n", "\n", "# Most users' partial configs have \"MODEL.WEIGHT\", so guess on it", "\n", "", "ret", "=", "None", "\n", "if", "_has", "(", "\"MODEL.WEIGHT\"", ")", "or", "_has", "(", "\"TEST.AUG_ON\"", ")", ":", "\n", "        ", "ret", "=", "1", "\n", "\n", "", "if", "ret", "is", "not", "None", ":", "\n", "        ", "logger", ".", "warning", "(", "\"Config '{}' has no VERSION. Assuming it to be v{}.\"", ".", "format", "(", "filename", ",", "ret", ")", ")", "\n", "", "else", ":", "\n", "        ", "ret", "=", "_C", ".", "VERSION", "\n", "logger", ".", "warning", "(", "\n", "\"Config '{}' has no VERSION. Assuming it to be compatible with latest v{}.\"", ".", "format", "(", "\n", "filename", ",", "ret", "\n", ")", "\n", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat._rename": [[116, 144], ["old.split", "new.split", "compat._rename._set"], "function", ["None"], ["", "def", "_rename", "(", "cfg", ":", "CN", ",", "old", ":", "str", ",", "new", ":", "str", ")", "->", "None", ":", "\n", "    ", "old_keys", "=", "old", ".", "split", "(", "\".\"", ")", "\n", "new_keys", "=", "new", ".", "split", "(", "\".\"", ")", "\n", "\n", "def", "_set", "(", "key_seq", ":", "List", "[", "str", "]", ",", "val", ":", "str", ")", "->", "None", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "k", "in", "key_seq", "[", ":", "-", "1", "]", ":", "\n", "            ", "if", "k", "not", "in", "cur", ":", "\n", "                ", "cur", "[", "k", "]", "=", "CN", "(", ")", "\n", "", "cur", "=", "cur", "[", "k", "]", "\n", "", "cur", "[", "key_seq", "[", "-", "1", "]", "]", "=", "val", "\n", "\n", "", "def", "_get", "(", "key_seq", ":", "List", "[", "str", "]", ")", "->", "CN", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "k", "in", "key_seq", ":", "\n", "            ", "cur", "=", "cur", "[", "k", "]", "\n", "", "return", "cur", "\n", "\n", "", "def", "_del", "(", "key_seq", ":", "List", "[", "str", "]", ")", "->", "None", ":", "\n", "        ", "cur", "=", "cfg", "\n", "for", "k", "in", "key_seq", "[", ":", "-", "1", "]", ":", "\n", "            ", "cur", "=", "cur", "[", "k", "]", "\n", "", "del", "cur", "[", "key_seq", "[", "-", "1", "]", "]", "\n", "if", "len", "(", "cur", ")", "==", "0", "and", "len", "(", "key_seq", ")", ">", "1", ":", "\n", "            ", "_del", "(", "key_seq", "[", ":", "-", "1", "]", ")", "\n", "\n", "", "", "_set", "(", "new_keys", ",", "_get", "(", "old_keys", ")", ")", "\n", "_del", "(", "old_keys", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers._NewEmptyTensorOp.forward": [[31, 35], ["x.new_empty"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "x", ",", "new_shape", ")", ":", "\n", "        ", "ctx", ".", "shape", "=", "x", ".", "shape", "\n", "return", "x", ".", "new_empty", "(", "new_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers._NewEmptyTensorOp.backward": [[36, 40], ["_NewEmptyTensorOp.apply"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad", ")", ":", "\n", "        ", "shape", "=", "ctx", ".", "shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "grad", ",", "shape", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.Conv2d.__init__": [[47, 63], ["kwargs.pop", "kwargs.pop", "super().__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Extra keyword arguments supported in addition to those in `torch.nn.Conv2d`:\n\n        Args:\n            norm (nn.Module, optional): a normalization layer\n            activation (callable(Tensor) -> Tensor): a callable activation function\n\n        It assumes that norm layer is used before activation.\n        \"\"\"", "\n", "norm", "=", "kwargs", ".", "pop", "(", "\"norm\"", ",", "None", ")", "\n", "activation", "=", "kwargs", ".", "pop", "(", "\"activation\"", ",", "None", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "activation", "=", "activation", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.Conv2d.forward": [[64, 110], ["torch.conv2d", "torch.conv2d", "torch.jit.is_scripting", "torch.jit.is_scripting", "torch.jit.is_scripting", "torch.jit.is_scripting", "wrappers.Conv2d.norm", "wrappers.Conv2d.activation", "_NewEmptyTensorOp.apply", "wrappers.Conv2d.numel", "isinstance", "wrappers.Conv2d.numel", "isinstance", "zip", "sum", "wrappers.Conv2d.view", "wrappers.Conv2d.parameters"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# torchscript does not support SyncBatchNorm yet", "\n", "# https://github.com/pytorch/pytorch/issues/40507", "\n", "# and we skip these codes in torchscript since:", "\n", "# 1. currently we only support torchscript in evaluation mode", "\n", "# 2. features needed by exporting module to torchscript are added in PyTorch 1.6 or", "\n", "# later version, `Conv2d` in these PyTorch versions has already supported empty inputs.", "\n", "        ", "if", "not", "torch", ".", "jit", ".", "is_scripting", "(", ")", ":", "\n", "            ", "if", "x", ".", "numel", "(", ")", "==", "0", "and", "self", ".", "training", ":", "\n", "# https://github.com/pytorch/pytorch/issues/12013", "\n", "                ", "assert", "not", "isinstance", "(", "\n", "self", ".", "norm", ",", "torch", ".", "nn", ".", "SyncBatchNorm", "\n", ")", ",", "\"SyncBatchNorm does not support empty inputs!\"", "\n", "\n", "", "if", "x", ".", "numel", "(", ")", "==", "0", "and", "TORCH_VERSION", "<=", "(", "1", ",", "4", ")", ":", "\n", "                ", "assert", "not", "isinstance", "(", "\n", "self", ".", "norm", ",", "torch", ".", "nn", ".", "GroupNorm", "\n", ")", ",", "\"GroupNorm does not support empty inputs in PyTorch <=1.4!\"", "\n", "# When input is empty, we want to return a empty tensor with \"correct\" shape,", "\n", "# So that the following operations will not panic", "\n", "# if they check for the shape of the tensor.", "\n", "# This computes the height and width of the output tensor", "\n", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "s", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "s", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "empty", "=", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "if", "self", ".", "training", ":", "\n", "# This is to make DDP happy.", "\n", "# DDP expects all workers to have gradient w.r.t the same set of parameters.", "\n", "                    ", "_dummy", "=", "sum", "(", "[", "x", ".", "view", "(", "-", "1", ")", "[", "0", "]", "for", "x", "in", "self", ".", "parameters", "(", ")", "]", ")", "*", "0.0", "\n", "return", "empty", "+", "_dummy", "\n", "", "else", ":", "\n", "                    ", "return", "empty", "\n", "\n", "", "", "", "x", "=", "F", ".", "conv2d", "(", "\n", "x", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "groups", "\n", ")", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat": [[20, 28], ["isinstance", "torch.cat", "torch.cat", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["def", "cat", "(", "tensors", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "dim", ":", "int", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Efficient version of torch.cat that avoids a copy if there is only a single element in a list\n    \"\"\"", "\n", "assert", "isinstance", "(", "tensors", ",", "(", "list", ",", "tuple", ")", ")", "\n", "if", "len", "(", "tensors", ")", "==", "1", ":", "\n", "        ", "return", "tensors", "[", "0", "]", "\n", "", "return", "torch", ".", "cat", "(", "tensors", ",", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.nonzero_tuple": [[233, 241], ["x.nonzero().unbind", "x.dim", "x.unsqueeze().nonzero().unbind", "x.nonzero", "x.unsqueeze().nonzero", "x.unsqueeze"], "function", ["None"], ["", "", "def", "nonzero_tuple", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    A 'as_tuple=True' version of torch.nonzero to support torchscript.\n    because of https://github.com/pytorch/pytorch/issues/38718\n    \"\"\"", "\n", "if", "x", ".", "dim", "(", ")", "==", "0", ":", "\n", "        ", "return", "x", ".", "unsqueeze", "(", "0", ")", ".", "nonzero", "(", ")", ".", "unbind", "(", "1", ")", "\n", "", "return", "x", ".", "nonzero", "(", ")", ".", "unbind", "(", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms": [[10, 30], ["scores.new_zeros", "torch.jit.annotate", "scores.new_zeros.nonzero().view", "len", "torchvision.ops.boxes.batched_nms", "scores.size", "torch.unique().cpu().tolist", "torchvision.ops.nms", "scores.new_zeros.nonzero", "scores[].argsort", "torch.unique().cpu", "torch.unique"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms"], ["def", "batched_nms", "(", "\n", "boxes", ":", "torch", ".", "Tensor", ",", "scores", ":", "torch", ".", "Tensor", ",", "idxs", ":", "torch", ".", "Tensor", ",", "iou_threshold", ":", "float", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Same as torchvision.ops.boxes.batched_nms, but safer.\n    \"\"\"", "\n", "assert", "boxes", ".", "shape", "[", "-", "1", "]", "==", "4", "\n", "# TODO may need better strategy.", "\n", "# Investigate after having a fully-cuda NMS op.", "\n", "if", "len", "(", "boxes", ")", "<", "40000", ":", "\n", "        ", "return", "box_ops", ".", "batched_nms", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou_threshold", ")", "\n", "\n", "", "result_mask", "=", "scores", ".", "new_zeros", "(", "scores", ".", "size", "(", ")", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "for", "id", "in", "torch", ".", "jit", ".", "annotate", "(", "List", "[", "int", "]", ",", "torch", ".", "unique", "(", "idxs", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", ":", "\n", "        ", "mask", "=", "(", "idxs", "==", "id", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "keep", "=", "nms", "(", "boxes", "[", "mask", "]", ",", "scores", "[", "mask", "]", ",", "iou_threshold", ")", "\n", "result_mask", "[", "mask", "[", "keep", "]", "]", "=", "True", "\n", "", "keep", "=", "result_mask", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "keep", "=", "keep", "[", "scores", "[", "keep", "]", ".", "argsort", "(", "descending", "=", "True", ")", "]", "\n", "return", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.nms_rotated": [[34, 98], ["_C.nms_rotated"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.nms_rotated"], ["", "def", "nms_rotated", "(", "boxes", ",", "scores", ",", "iou_threshold", ")", ":", "\n", "    ", "\"\"\"\n    Performs non-maximum suppression (NMS) on the rotated boxes according\n    to their intersection-over-union (IoU).\n\n    Rotated NMS iteratively removes lower scoring rotated boxes which have an\n    IoU greater than iou_threshold with another (higher scoring) rotated box.\n\n    Note that RotatedBox (5, 3, 4, 2, -90) covers exactly the same region as\n    RotatedBox (5, 3, 4, 2, 90) does, and their IoU will be 1. However, they\n    can be representing completely different objects in certain tasks, e.g., OCR.\n\n    As for the question of whether rotated-NMS should treat them as faraway boxes\n    even though their IOU is 1, it depends on the application and/or ground truth annotation.\n\n    As an extreme example, consider a single character v and the square box around it.\n\n    If the angle is 0 degree, the object (text) would be read as 'v';\n\n    If the angle is 90 degrees, the object (text) would become '>';\n\n    If the angle is 180 degrees, the object (text) would become '^';\n\n    If the angle is 270/-90 degrees, the object (text) would become '<'\n\n    All of these cases have IoU of 1 to each other, and rotated NMS that only\n    uses IoU as criterion would only keep one of them with the highest score -\n    which, practically, still makes sense in most cases because typically\n    only one of theses orientations is the correct one. Also, it does not matter\n    as much if the box is only used to classify the object (instead of transcribing\n    them with a sequential OCR recognition model) later.\n\n    On the other hand, when we use IoU to filter proposals that are close to the\n    ground truth during training, we should definitely take the angle into account if\n    we know the ground truth is labeled with the strictly correct orientation (as in,\n    upside-down words are annotated with -180 degrees even though they can be covered\n    with a 0/90/-90 degree box, etc.)\n\n    The way the original dataset is annotated also matters. For example, if the dataset\n    is a 4-point polygon dataset that does not enforce ordering of vertices/orientation,\n    we can estimate a minimum rotated bounding box to this polygon, but there's no way\n    we can tell the correct angle with 100% confidence (as shown above, there could be 4 different\n    rotated boxes, with angles differed by 90 degrees to each other, covering the exactly\n    same region). In that case we have to just use IoU to determine the box\n    proximity (as many detection benchmarks (even for text) do) unless there're other\n    assumptions we can make (like width is always larger than height, or the object is not\n    rotated by more than 90 degrees CCW/CW, etc.)\n\n    In summary, not considering angles in rotated NMS seems to be a good option for now,\n    but we should be aware of its implications.\n\n    Args:\n        boxes (Tensor[N, 5]): Rotated boxes to perform NMS on. They are expected to be in\n           (x_center, y_center, width, height, angle_degrees) format.\n        scores (Tensor[N]): Scores for each one of the rotated boxes\n        iou_threshold (float): Discards all overlapping rotated boxes with IoU < iou_threshold\n\n    Returns:\n        keep (Tensor): int64 tensor with the indices of the elements that have been kept\n        by Rotated NMS, sorted in decreasing order of scores\n    \"\"\"", "\n", "from", "detectron2", "import", "_C", "\n", "\n", "return", "_C", ".", "nms_rotated", "(", "boxes", ",", "scores", ",", "iou_threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms_rotated": [[102, 150], ["torchvision.ops.boxes.clone", "nms.nms_rotated", "torchvision.ops.boxes.numel", "torch.empty", "idxs.to", "torch.max", "torch.min", "torch.max", "torch.max"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "batched_nms_rotated", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou_threshold", ")", ":", "\n", "    ", "\"\"\"\n    Performs non-maximum suppression in a batched fashion.\n\n    Each index value correspond to a category, and NMS\n    will not be applied between elements of different categories.\n\n    Args:\n        boxes (Tensor[N, 5]):\n           boxes where NMS will be performed. They\n           are expected to be in (x_ctr, y_ctr, width, height, angle_degrees) format\n        scores (Tensor[N]):\n           scores for each one of the boxes\n        idxs (Tensor[N]):\n           indices of the categories for each one of the boxes.\n        iou_threshold (float):\n           discards all overlapping boxes\n           with IoU < iou_threshold\n\n    Returns:\n        Tensor:\n            int64 tensor with the indices of the elements that have been kept\n            by NMS, sorted in decreasing order of scores\n    \"\"\"", "\n", "assert", "boxes", ".", "shape", "[", "-", "1", "]", "==", "5", "\n", "\n", "if", "boxes", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "return", "torch", ".", "empty", "(", "(", "0", ",", ")", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "boxes", ".", "device", ")", "\n", "# Strategy: in order to perform NMS independently per class,", "\n", "# we add an offset to all the boxes. The offset is dependent", "\n", "# only on the class idx, and is large enough so that boxes", "\n", "# from different classes do not overlap", "\n", "\n", "# Note that batched_nms in torchvision/ops/boxes.py only uses max_coordinate,", "\n", "# which won't handle negative coordinates correctly.", "\n", "# Here by using min_coordinate we can make sure the negative coordinates are", "\n", "# correctly handled.", "\n", "", "max_coordinate", "=", "(", "\n", "torch", ".", "max", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "1", "]", ")", "+", "torch", ".", "max", "(", "boxes", "[", ":", ",", "2", "]", ",", "boxes", "[", ":", ",", "3", "]", ")", "/", "2", "\n", ")", ".", "max", "(", ")", "\n", "min_coordinate", "=", "(", "\n", "torch", ".", "min", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "1", "]", ")", "-", "torch", ".", "max", "(", "boxes", "[", ":", ",", "2", "]", ",", "boxes", "[", ":", ",", "3", "]", ")", "/", "2", "\n", ")", ".", "min", "(", ")", "\n", "offsets", "=", "idxs", ".", "to", "(", "boxes", ")", "*", "(", "max_coordinate", "-", "min_coordinate", "+", "1", ")", "\n", "boxes_for_nms", "=", "boxes", ".", "clone", "(", ")", "# avoid modifying the original values in boxes", "\n", "boxes_for_nms", "[", ":", ",", ":", "2", "]", "+=", "offsets", "[", ":", ",", "None", "]", "\n", "keep", "=", "nms_rotated", "(", "boxes_for_nms", ",", "scores", ",", "iou_threshold", ")", "\n", "return", "keep", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.aspp.ASPP.__init__": [[17, 107], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "aspp.ASPP.convs.append", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "aspp.ASPP.convs.append", "wrappers.Conv2d", "fvcore.c2_xavier_fill", "len", "len", "wrappers.Conv2d", "aspp.ASPP.convs.append", "fvcore.c2_xavier_fill", "torch.nn.Sequential", "torch.nn.Sequential", "wrappers.Conv2d", "torch.nn.AdaptiveAvgPool2d", "wrappers.Conv2d", "torch.nn.AvgPool2d", "wrappers.Conv2d", "batch_norm.get_norm", "batch_norm.get_norm", "batch_norm.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "dilations", ",", "\n", "norm", ",", "\n", "activation", ",", "\n", "pool_kernel_size", "=", "None", ",", "\n", "dropout", ":", "float", "=", "0.0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_channels (int): number of input channels for ASPP.\n            out_channels (int): number of output channels.\n            dilations (list): a list of 3 dilations in ASPP.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format. norm is\n                applied to all conv layers except the conv following\n                global average pooling.\n            activation (callable): activation function.\n            pool_kernel_size (tuple, list): the average pooling size (kh, kw)\n                for image pooling layer in ASPP. If set to None, it always\n                performs global average pooling. If not None, it must be\n                divisible by the shape of inputs in forward(). It is recommended\n                to use a fixed input feature size in training, and set this\n                option to match this size, so that it performs global average\n                pooling in training, and the size of the pooling window stays\n                consistent in inference.\n            dropout (float): apply dropout on the output of ASPP. It is used in\n                the official DeepLab implementation with a rate of 0.1:\n                https://github.com/tensorflow/models/blob/21b73d22f3ed05b650e85ac50849408dd36de32e/research/deeplab/model.py#L532  # noqa\n        \"\"\"", "\n", "super", "(", "ASPP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "len", "(", "dilations", ")", "==", "3", ",", "\"ASPP expects 3 dilations, got {}\"", ".", "format", "(", "len", "(", "dilations", ")", ")", "\n", "self", ".", "pool_kernel_size", "=", "pool_kernel_size", "\n", "self", ".", "dropout", "=", "dropout", "\n", "use_bias", "=", "norm", "==", "\"\"", "\n", "self", ".", "convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "# conv 1x1", "\n", "self", ".", "convs", ".", "append", "(", "\n", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", "activation", "=", "activation", ",", "\n", ")", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "convs", "[", "-", "1", "]", ")", "\n", "# atrous convs", "\n", "for", "dilation", "in", "dilations", ":", "\n", "            ", "self", ".", "convs", ".", "append", "(", "\n", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", "activation", "=", "activation", ",", "\n", ")", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "convs", "[", "-", "1", "]", ")", "\n", "# image pooling", "\n", "# We do not add BatchNorm because the spatial resolution is 1x1,", "\n", "# the original TF implementation has BatchNorm.", "\n", "", "if", "pool_kernel_size", "is", "None", ":", "\n", "            ", "image_pooling", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", ",", "\n", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "True", ",", "activation", "=", "activation", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "image_pooling", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "AvgPool2d", "(", "kernel_size", "=", "pool_kernel_size", ",", "stride", "=", "1", ")", ",", "\n", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "True", ",", "activation", "=", "activation", ")", ",", "\n", ")", "\n", "", "weight_init", ".", "c2_xavier_fill", "(", "image_pooling", "[", "1", "]", ")", "\n", "self", ".", "convs", ".", "append", "(", "image_pooling", ")", "\n", "\n", "self", ".", "project", "=", "Conv2d", "(", "\n", "5", "*", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", "activation", "=", "activation", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "project", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.aspp.ASPP.forward": [[108, 124], ["torch.nn.functional.interpolate", "torch.cat", "aspp.ASPP.project", "aspp.ASPP.append", "torch.nn.functional.dropout", "ValueError", "conv"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "size", "=", "x", ".", "shape", "[", "-", "2", ":", "]", "\n", "if", "self", ".", "pool_kernel_size", "is", "not", "None", ":", "\n", "            ", "if", "size", "[", "0", "]", "%", "self", ".", "pool_kernel_size", "[", "0", "]", "or", "size", "[", "1", "]", "%", "self", ".", "pool_kernel_size", "[", "1", "]", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"`pool_kernel_size` must be divisible by the shape of inputs. \"", "\n", "\"Input size: {} `pool_kernel_size`: {}\"", ".", "format", "(", "size", ",", "self", ".", "pool_kernel_size", ")", "\n", ")", "\n", "", "", "res", "=", "[", "]", "\n", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "res", ".", "append", "(", "conv", "(", "x", ")", ")", "\n", "", "res", "[", "-", "1", "]", "=", "F", ".", "interpolate", "(", "res", "[", "-", "1", "]", ",", "size", "=", "size", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "res", "=", "torch", ".", "cat", "(", "res", ",", "dim", "=", "1", ")", "\n", "res", "=", "self", ".", "project", "(", "res", ")", "\n", "res", "=", "F", ".", "dropout", "(", "res", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "if", "self", ".", "dropout", ">", "0", "else", "res", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated": [[7, 23], ["detectron2._C.box_iou_rotated"], "function", ["None"], ["\n", "from", ".", "boxes", "import", "Boxes", "\n", "\n", "\n", "class", "RotatedBoxes", "(", "Boxes", ")", ":", "\n", "    ", "\"\"\"\n    This structure stores a list of rotated boxes as a Nx5 torch.Tensor.\n    It supports some common methods about boxes\n    (`area`, `clip`, `nonempty`, etc),\n    and also behaves like a Tensor\n    (support indexing, `to(device)`, `.device`, and iteration over all boxes)\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "tensor", ":", "torch", ".", "Tensor", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._DeformConv.forward": [[16, 74], ["torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "ctx.save_for_backward", "input.new_empty", "ValueError", "deform_conv._DeformConv._output_size", "input.new_empty", "input.new_empty", "NotImplementedError", "deform_conv._DeformConv._cal_im2col_step", "detectron2._C.deform_conv_forward", "input.dim", "weight.size", "weight.size", "input.dim"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._DeformConv._output_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._DeformConv._cal_im2col_step"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "\n", "ctx", ",", "\n", "input", ",", "\n", "offset", ",", "\n", "weight", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "im2col_step", "=", "64", ",", "\n", ")", ":", "\n", "        ", "if", "input", "is", "not", "None", "and", "input", ".", "dim", "(", ")", "!=", "4", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Expected 4D tensor as input, got {}D tensor instead.\"", ".", "format", "(", "input", ".", "dim", "(", ")", ")", "\n", ")", "\n", "", "ctx", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "ctx", ".", "padding", "=", "_pair", "(", "padding", ")", "\n", "ctx", ".", "dilation", "=", "_pair", "(", "dilation", ")", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "im2col_step", "=", "im2col_step", "\n", "\n", "ctx", ".", "save_for_backward", "(", "input", ",", "offset", ",", "weight", ")", "\n", "\n", "output", "=", "input", ".", "new_empty", "(", "\n", "_DeformConv", ".", "_output_size", "(", "input", ",", "weight", ",", "ctx", ".", "padding", ",", "ctx", ".", "dilation", ",", "ctx", ".", "stride", ")", "\n", ")", "\n", "\n", "ctx", ".", "bufs_", "=", "[", "input", ".", "new_empty", "(", "0", ")", ",", "input", ".", "new_empty", "(", "0", ")", "]", "# columns, ones", "\n", "\n", "if", "not", "input", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Deformable Conv is not supported on CPUs!\"", ")", "\n", "", "else", ":", "\n", "            ", "cur_im2col_step", "=", "_DeformConv", ".", "_cal_im2col_step", "(", "input", ".", "shape", "[", "0", "]", ",", "ctx", ".", "im2col_step", ")", "\n", "assert", "(", "input", ".", "shape", "[", "0", "]", "%", "cur_im2col_step", ")", "==", "0", ",", "\"im2col step must divide batchsize\"", "\n", "\n", "_C", ".", "deform_conv_forward", "(", "\n", "input", ",", "\n", "weight", ",", "\n", "offset", ",", "\n", "output", ",", "\n", "ctx", ".", "bufs_", "[", "0", "]", ",", "\n", "ctx", ".", "bufs_", "[", "1", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "\n", "ctx", ".", "stride", "[", "1", "]", ",", "\n", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "\n", "ctx", ".", "padding", "[", "0", "]", ",", "\n", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "cur_im2col_step", ",", "\n", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._DeformConv.backward": [[75, 136], ["NotImplementedError", "deform_conv._DeformConv._cal_im2col_step", "torch.zeros_like", "torch.zeros_like", "detectron2._C.deform_conv_backward_input", "torch.zeros_like", "detectron2._C.deform_conv_backward_filter", "weight.size", "weight.size", "weight.size", "weight.size"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._DeformConv._cal_im2col_step"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "input", ",", "offset", ",", "weight", "=", "ctx", ".", "saved_tensors", "\n", "\n", "grad_input", "=", "grad_offset", "=", "grad_weight", "=", "None", "\n", "\n", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Deformable Conv is not supported on CPUs!\"", ")", "\n", "", "else", ":", "\n", "            ", "cur_im2col_step", "=", "_DeformConv", ".", "_cal_im2col_step", "(", "input", ".", "shape", "[", "0", "]", ",", "ctx", ".", "im2col_step", ")", "\n", "assert", "(", "input", ".", "shape", "[", "0", "]", "%", "cur_im2col_step", ")", "==", "0", ",", "\"im2col step must divide batchsize\"", "\n", "\n", "if", "ctx", ".", "needs_input_grad", "[", "0", "]", "or", "ctx", ".", "needs_input_grad", "[", "1", "]", ":", "\n", "                ", "grad_input", "=", "torch", ".", "zeros_like", "(", "input", ")", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "_C", ".", "deform_conv_backward_input", "(", "\n", "input", ",", "\n", "offset", ",", "\n", "grad_output", ",", "\n", "grad_input", ",", "\n", "grad_offset", ",", "\n", "weight", ",", "\n", "ctx", ".", "bufs_", "[", "0", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "\n", "ctx", ".", "stride", "[", "1", "]", ",", "\n", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "\n", "ctx", ".", "padding", "[", "0", "]", ",", "\n", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "cur_im2col_step", ",", "\n", ")", "\n", "\n", "", "if", "ctx", ".", "needs_input_grad", "[", "2", "]", ":", "\n", "                ", "grad_weight", "=", "torch", ".", "zeros_like", "(", "weight", ")", "\n", "_C", ".", "deform_conv_backward_filter", "(", "\n", "input", ",", "\n", "offset", ",", "\n", "grad_output", ",", "\n", "grad_weight", ",", "\n", "ctx", ".", "bufs_", "[", "0", "]", ",", "\n", "ctx", ".", "bufs_", "[", "1", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "\n", "ctx", ".", "stride", "[", "1", "]", ",", "\n", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "\n", "ctx", ".", "padding", "[", "0", "]", ",", "\n", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "1", ",", "\n", "cur_im2col_step", ",", "\n", ")", "\n", "\n", "", "", "return", "grad_input", ",", "grad_offset", ",", "grad_weight", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._DeformConv._output_size": [[137, 154], ["weight.size", "range", "input.size", "input.size", "all", "ValueError", "input.dim", "map", "weight.size", "map"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_output_size", "(", "input", ",", "weight", ",", "padding", ",", "dilation", ",", "stride", ")", ":", "\n", "        ", "channels", "=", "weight", ".", "size", "(", "0", ")", "\n", "output_size", "=", "(", "input", ".", "size", "(", "0", ")", ",", "channels", ")", "\n", "for", "d", "in", "range", "(", "input", ".", "dim", "(", ")", "-", "2", ")", ":", "\n", "            ", "in_size", "=", "input", ".", "size", "(", "d", "+", "2", ")", "\n", "pad", "=", "padding", "[", "d", "]", "\n", "kernel", "=", "dilation", "[", "d", "]", "*", "(", "weight", ".", "size", "(", "d", "+", "2", ")", "-", "1", ")", "+", "1", "\n", "stride_", "=", "stride", "[", "d", "]", "\n", "output_size", "+=", "(", "(", "in_size", "+", "(", "2", "*", "pad", ")", "-", "kernel", ")", "//", "stride_", "+", "1", ",", ")", "\n", "", "if", "not", "all", "(", "map", "(", "lambda", "s", ":", "s", ">", "0", ",", "output_size", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"convolution input is too small (output would be {})\"", ".", "format", "(", "\n", "\"x\"", ".", "join", "(", "map", "(", "str", ",", "output_size", ")", ")", "\n", ")", "\n", ")", "\n", "", "return", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._DeformConv._cal_im2col_step": [[155, 177], ["functools.lru_cache", "range", "min", "int", "math.sqrt"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "lru_cache", "(", "maxsize", "=", "128", ")", "\n", "def", "_cal_im2col_step", "(", "input_size", ",", "default_size", ")", ":", "\n", "        ", "\"\"\"\n        Calculate proper im2col step size, which should be divisible by input_size and not larger\n        than prefer_size. Meanwhile the step size should be as large as possible to be more\n        efficient. So we choose the largest one among all divisors of input_size which are smaller\n        than prefer_size.\n        :param input_size: input batch size .\n        :param default_size: default preferred im2col step size.\n        :return: the largest proper step size.\n        \"\"\"", "\n", "if", "input_size", "<=", "default_size", ":", "\n", "            ", "return", "input_size", "\n", "", "best_step", "=", "1", "\n", "for", "step", "in", "range", "(", "2", ",", "min", "(", "int", "(", "math", ".", "sqrt", "(", "input_size", ")", ")", "+", "1", ",", "default_size", ")", ")", ":", "\n", "            ", "if", "input_size", "%", "step", "==", "0", ":", "\n", "                ", "if", "input_size", "//", "step", "<=", "default_size", ":", "\n", "                    ", "return", "input_size", "//", "step", "\n", "", "best_step", "=", "step", "\n", "\n", "", "", "return", "best_step", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._ModulatedDeformConv.forward": [[180, 235], ["input.new_empty", "detectron2._C.modulated_deform_conv_forward", "input.new_empty", "NotImplementedError", "ctx.save_for_backward", "deform_conv._ModulatedDeformConv._infer_shape", "input.new_empty", "input.new_empty"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._ModulatedDeformConv._infer_shape"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "\n", "ctx", ",", "\n", "input", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "weight", ",", "\n", "bias", "=", "None", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", ")", ":", "\n", "        ", "ctx", ".", "stride", "=", "stride", "\n", "ctx", ".", "padding", "=", "padding", "\n", "ctx", ".", "dilation", "=", "dilation", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "with_bias", "=", "bias", "is", "not", "None", "\n", "if", "not", "ctx", ".", "with_bias", ":", "\n", "            ", "bias", "=", "input", ".", "new_empty", "(", "1", ")", "# fake tensor", "\n", "", "if", "not", "input", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Deformable Conv is not supported on CPUs!\"", ")", "\n", "", "if", "(", "\n", "weight", ".", "requires_grad", "\n", "or", "mask", ".", "requires_grad", "\n", "or", "offset", ".", "requires_grad", "\n", "or", "input", ".", "requires_grad", "\n", ")", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "input", ",", "offset", ",", "mask", ",", "weight", ",", "bias", ")", "\n", "", "output", "=", "input", ".", "new_empty", "(", "_ModulatedDeformConv", ".", "_infer_shape", "(", "ctx", ",", "input", ",", "weight", ")", ")", "\n", "ctx", ".", "_bufs", "=", "[", "input", ".", "new_empty", "(", "0", ")", ",", "input", ".", "new_empty", "(", "0", ")", "]", "\n", "_C", ".", "modulated_deform_conv_forward", "(", "\n", "input", ",", "\n", "weight", ",", "\n", "bias", ",", "\n", "ctx", ".", "_bufs", "[", "0", "]", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "output", ",", "\n", "ctx", ".", "_bufs", "[", "1", "]", ",", "\n", "weight", ".", "shape", "[", "2", "]", ",", "\n", "weight", ".", "shape", "[", "3", "]", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "ctx", ".", "with_bias", ",", "\n", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._ModulatedDeformConv.backward": [[236, 287], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "detectron2._C.modulated_deform_conv_backward", "NotImplementedError"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Deformable Conv is not supported on CPUs!\"", ")", "\n", "", "input", ",", "offset", ",", "mask", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "grad_input", "=", "torch", ".", "zeros_like", "(", "input", ")", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "grad_mask", "=", "torch", ".", "zeros_like", "(", "mask", ")", "\n", "grad_weight", "=", "torch", ".", "zeros_like", "(", "weight", ")", "\n", "grad_bias", "=", "torch", ".", "zeros_like", "(", "bias", ")", "\n", "_C", ".", "modulated_deform_conv_backward", "(", "\n", "input", ",", "\n", "weight", ",", "\n", "bias", ",", "\n", "ctx", ".", "_bufs", "[", "0", "]", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "ctx", ".", "_bufs", "[", "1", "]", ",", "\n", "grad_input", ",", "\n", "grad_weight", ",", "\n", "grad_bias", ",", "\n", "grad_offset", ",", "\n", "grad_mask", ",", "\n", "grad_output", ",", "\n", "weight", ".", "shape", "[", "2", "]", ",", "\n", "weight", ".", "shape", "[", "3", "]", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "stride", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "padding", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "groups", ",", "\n", "ctx", ".", "deformable_groups", ",", "\n", "ctx", ".", "with_bias", ",", "\n", ")", "\n", "if", "not", "ctx", ".", "with_bias", ":", "\n", "            ", "grad_bias", "=", "None", "\n", "\n", "", "return", "(", "\n", "grad_input", ",", "\n", "grad_offset", ",", "\n", "grad_mask", ",", "\n", "grad_weight", ",", "\n", "grad_bias", ",", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv._ModulatedDeformConv._infer_shape": [[289, 302], ["input.size", "weight.size"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_infer_shape", "(", "ctx", ",", "input", ",", "weight", ")", ":", "\n", "        ", "n", "=", "input", ".", "size", "(", "0", ")", "\n", "channels_out", "=", "weight", ".", "size", "(", "0", ")", "\n", "height", ",", "width", "=", "input", ".", "shape", "[", "2", ":", "4", "]", "\n", "kernel_h", ",", "kernel_w", "=", "weight", ".", "shape", "[", "2", ":", "4", "]", "\n", "height_out", "=", "(", "\n", "height", "+", "2", "*", "ctx", ".", "padding", "-", "(", "ctx", ".", "dilation", "*", "(", "kernel_h", "-", "1", ")", "+", "1", ")", "\n", ")", "//", "ctx", ".", "stride", "+", "1", "\n", "width_out", "=", "(", "\n", "width", "+", "2", "*", "ctx", ".", "padding", "-", "(", "ctx", ".", "dilation", "*", "(", "kernel_w", "-", "1", ")", "+", "1", ")", "\n", ")", "//", "ctx", ".", "stride", "+", "1", "\n", "return", "n", ",", "channels_out", ",", "height_out", ",", "width_out", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv.DeformConv.__init__": [[309, 360], ["torch.nn.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.Parameter", "torch.nn.init.kaiming_uniform_", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Deformable convolution from :paper:`deformconv`.\n\n        Arguments are similar to :class:`Conv2D`. Extra arguments:\n\n        Args:\n            deformable_groups (int): number of groups used in deformable convolution.\n            norm (nn.Module, optional): a normalization layer\n            activation (callable(Tensor) -> Tensor): a callable activation function\n        \"\"\"", "\n", "super", "(", "DeformConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "not", "bias", "\n", "assert", "in_channels", "%", "groups", "==", "0", ",", "\"in_channels {} cannot be divisible by groups {}\"", ".", "format", "(", "\n", "in_channels", ",", "groups", "\n", ")", "\n", "assert", "(", "\n", "out_channels", "%", "groups", "==", "0", "\n", ")", ",", "\"out_channels {} cannot be divisible by groups {}\"", ".", "format", "(", "out_channels", ",", "groups", ")", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "self", ".", "padding", "=", "_pair", "(", "padding", ")", "\n", "self", ".", "dilation", "=", "_pair", "(", "dilation", ")", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "deformable_groups", "=", "deformable_groups", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "self", ".", "groups", ",", "*", "self", ".", "kernel_size", ")", "\n", ")", "\n", "self", ".", "bias", "=", "None", "\n", "\n", "nn", ".", "init", ".", "kaiming_uniform_", "(", "self", ".", "weight", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv.DeformConv.forward": [[361, 391], ["deform_conv", "deform_conv.DeformConv.numel", "wrappers._NewEmptyTensorOp.apply", "deform_conv.DeformConv.norm", "deform_conv.DeformConv.activation", "zip"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "offset", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", "==", "0", ":", "\n", "# When input is empty, we want to return a empty tensor with \"correct\" shape,", "\n", "# So that the following operations will not panic", "\n", "# if they check for the shape of the tensor.", "\n", "# This computes the height and width of the output tensor", "\n", "            ", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "s", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "s", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "\n", "", "x", "=", "deform_conv", "(", "\n", "x", ",", "\n", "offset", ",", "\n", "self", ".", "weight", ",", "\n", "self", ".", "stride", ",", "\n", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "\n", "self", ".", "groups", ",", "\n", "self", ".", "deformable_groups", ",", "\n", ")", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv.DeformConv.extra_repr": [[392, 403], ["str", "str", "str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "\"in_channels=\"", "+", "str", "(", "self", ".", "in_channels", ")", "\n", "tmpstr", "+=", "\", out_channels=\"", "+", "str", "(", "self", ".", "out_channels", ")", "\n", "tmpstr", "+=", "\", kernel_size=\"", "+", "str", "(", "self", ".", "kernel_size", ")", "\n", "tmpstr", "+=", "\", stride=\"", "+", "str", "(", "self", ".", "stride", ")", "\n", "tmpstr", "+=", "\", padding=\"", "+", "str", "(", "self", ".", "padding", ")", "\n", "tmpstr", "+=", "\", dilation=\"", "+", "str", "(", "self", ".", "dilation", ")", "\n", "tmpstr", "+=", "\", groups=\"", "+", "str", "(", "self", ".", "groups", ")", "\n", "tmpstr", "+=", "\", deformable_groups=\"", "+", "str", "(", "self", ".", "deformable_groups", ")", "\n", "tmpstr", "+=", "\", bias=False\"", "\n", "return", "tmpstr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv.ModulatedDeformConv.__init__": [[406, 454], ["torch.nn.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.Parameter", "torch.nn.init.kaiming_uniform_", "torch.Tensor", "torch.nn.Parameter", "torch.nn.init.constant_", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "True", ",", "\n", "norm", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Modulated deformable convolution from :paper:`deformconv2`.\n\n        Arguments are similar to :class:`Conv2D`. Extra arguments:\n\n        Args:\n            deformable_groups (int): number of groups used in deformable convolution.\n            norm (nn.Module, optional): a normalization layer\n            activation (callable(Tensor) -> Tensor): a callable activation function\n        \"\"\"", "\n", "super", "(", "ModulatedDeformConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "deformable_groups", "=", "deformable_groups", "\n", "self", ".", "with_bias", "=", "bias", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "groups", ",", "*", "self", ".", "kernel_size", ")", "\n", ")", "\n", "if", "bias", ":", "\n", "            ", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_channels", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bias", "=", "None", "\n", "\n", "", "nn", ".", "init", ".", "kaiming_uniform_", "(", "self", ".", "weight", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv.ModulatedDeformConv.forward": [[455, 483], ["modulated_deform_conv", "deform_conv.ModulatedDeformConv.numel", "wrappers._NewEmptyTensorOp.apply", "deform_conv.ModulatedDeformConv.norm", "deform_conv.ModulatedDeformConv.activation", "zip"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "offset", ",", "mask", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "s", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "s", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "\n", "", "x", "=", "modulated_deform_conv", "(", "\n", "x", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "self", ".", "weight", ",", "\n", "self", ".", "bias", ",", "\n", "self", ".", "stride", ",", "\n", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "\n", "self", ".", "groups", ",", "\n", "self", ".", "deformable_groups", ",", "\n", ")", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "activation", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.deform_conv.ModulatedDeformConv.extra_repr": [[484, 495], ["str", "str", "str", "str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "\"in_channels=\"", "+", "str", "(", "self", ".", "in_channels", ")", "\n", "tmpstr", "+=", "\", out_channels=\"", "+", "str", "(", "self", ".", "out_channels", ")", "\n", "tmpstr", "+=", "\", kernel_size=\"", "+", "str", "(", "self", ".", "kernel_size", ")", "\n", "tmpstr", "+=", "\", stride=\"", "+", "str", "(", "self", ".", "stride", ")", "\n", "tmpstr", "+=", "\", padding=\"", "+", "str", "(", "self", ".", "padding", ")", "\n", "tmpstr", "+=", "\", dilation=\"", "+", "str", "(", "self", ".", "dilation", ")", "\n", "tmpstr", "+=", "\", groups=\"", "+", "str", "(", "self", ".", "groups", ")", "\n", "tmpstr", "+=", "\", deformable_groups=\"", "+", "str", "(", "self", ".", "deformable_groups", ")", "\n", "tmpstr", "+=", "\", bias=\"", "+", "str", "(", "self", ".", "with_bias", ")", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.__init__": [[22, 35], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "stride", ")", ":", "\n", "        ", "\"\"\"\n        The `__init__` method of any subclass should also contain these arguments.\n\n        Args:\n            in_channels (int):\n            out_channels (int):\n            stride (int):\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze": [[36, 49], ["blocks.CNNBlockBase.parameters", "batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm"], ["", "def", "freeze", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Make this block not trainable.\n        This method sets all parameters to `requires_grad=False`,\n        and convert all BatchNorm layers to FrozenBatchNorm\n\n        Returns:\n            the block itself\n        \"\"\"", "\n", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "", "FrozenBatchNorm2d", ".", "convert_frozen_batchnorm", "(", "self", ")", "\n", "return", "self", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops._do_paste_mask": [[16, 65], ["torch.split", "img_x[].expand", "img_y[].expand", "torch.stack", "torch.nn.functional.grid_sample", "torch.clamp().to", "torch.clamp().to", "torch.clamp().to", "torch.arange", "torch.arange", "img_y.size", "img_x.size", "img_y.size", "img_x.size", "masks.to", "torch.clamp", "torch.clamp", "torch.clamp", "slice", "slice", "boxes[].max().ceil", "boxes[].max().ceil", "boxes.min().values.floor", "boxes[].max", "boxes[].max", "boxes.min"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["def", "_do_paste_mask", "(", "masks", ",", "boxes", ",", "img_h", ",", "img_w", ",", "skip_empty", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        masks: N, 1, H, W\n        boxes: N, 4\n        img_h, img_w (int):\n        skip_empty (bool): only paste masks within the region that\n            tightly bound all boxes, and returns the results this region only.\n            An important optimization for CPU.\n\n    Returns:\n        if skip_empty == False, a mask of shape (N, img_h, img_w)\n        if skip_empty == True, a mask of shape (N, h', w'), and the slice\n            object for the corresponding region.\n    \"\"\"", "\n", "# On GPU, paste all masks together (up to chunk size)", "\n", "# by using the entire image to sample the masks", "\n", "# Compared to pasting them one by one,", "\n", "# this has more operations but is faster on COCO-scale dataset.", "\n", "device", "=", "masks", ".", "device", "\n", "if", "skip_empty", ":", "\n", "        ", "x0_int", ",", "y0_int", "=", "torch", ".", "clamp", "(", "boxes", ".", "min", "(", "dim", "=", "0", ")", ".", "values", ".", "floor", "(", ")", "[", ":", "2", "]", "-", "1", ",", "min", "=", "0", ")", ".", "to", "(", "\n", "dtype", "=", "torch", ".", "int32", "\n", ")", "\n", "x1_int", "=", "torch", ".", "clamp", "(", "boxes", "[", ":", ",", "2", "]", ".", "max", "(", ")", ".", "ceil", "(", ")", "+", "1", ",", "max", "=", "img_w", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int32", ")", "\n", "y1_int", "=", "torch", ".", "clamp", "(", "boxes", "[", ":", ",", "3", "]", ".", "max", "(", ")", ".", "ceil", "(", ")", "+", "1", ",", "max", "=", "img_h", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int32", ")", "\n", "", "else", ":", "\n", "        ", "x0_int", ",", "y0_int", "=", "0", ",", "0", "\n", "x1_int", ",", "y1_int", "=", "img_w", ",", "img_h", "\n", "", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "torch", ".", "split", "(", "boxes", ",", "1", ",", "dim", "=", "1", ")", "# each is Nx1", "\n", "\n", "N", "=", "masks", ".", "shape", "[", "0", "]", "\n", "\n", "img_y", "=", "torch", ".", "arange", "(", "y0_int", ",", "y1_int", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "+", "0.5", "\n", "img_x", "=", "torch", ".", "arange", "(", "x0_int", ",", "x1_int", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "+", "0.5", "\n", "img_y", "=", "(", "img_y", "-", "y0", ")", "/", "(", "y1", "-", "y0", ")", "*", "2", "-", "1", "\n", "img_x", "=", "(", "img_x", "-", "x0", ")", "/", "(", "x1", "-", "x0", ")", "*", "2", "-", "1", "\n", "# img_x, img_y have shapes (N, w), (N, h)", "\n", "\n", "gx", "=", "img_x", "[", ":", ",", "None", ",", ":", "]", ".", "expand", "(", "N", ",", "img_y", ".", "size", "(", "1", ")", ",", "img_x", ".", "size", "(", "1", ")", ")", "\n", "gy", "=", "img_y", "[", ":", ",", ":", ",", "None", "]", ".", "expand", "(", "N", ",", "img_y", ".", "size", "(", "1", ")", ",", "img_x", ".", "size", "(", "1", ")", ")", "\n", "grid", "=", "torch", ".", "stack", "(", "[", "gx", ",", "gy", "]", ",", "dim", "=", "3", ")", "\n", "\n", "img_masks", "=", "F", ".", "grid_sample", "(", "masks", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "grid", ",", "align_corners", "=", "False", ")", "\n", "\n", "if", "skip_empty", ":", "\n", "        ", "return", "img_masks", "[", ":", ",", "0", "]", ",", "(", "slice", "(", "y0_int", ",", "y1_int", ")", ",", "slice", "(", "x0_int", ",", "x1_int", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "img_masks", "[", ":", ",", "0", "]", ",", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.paste_masks_in_image": [[67, 136], ["len", "torch.chunk", "torch.zeros", "masks.new_empty", "isinstance", "len", "int", "torch.arange", "mask_ops._do_paste_mask", "numpy.ceil", "int", "int"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops._do_paste_mask"], ["", "", "def", "paste_masks_in_image", "(", "masks", ",", "boxes", ",", "image_shape", ",", "threshold", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"\n    Paste a set of masks that are of a fixed resolution (e.g., 28 x 28) into an image.\n    The location, height, and width for pasting each mask is determined by their\n    corresponding bounding boxes in boxes.\n\n    Note:\n        This is a complicated but more accurate implementation. In actual deployment, it is\n        often enough to use a faster but less accurate implementation.\n        See :func:`paste_mask_in_image_old` in this file for an alternative implementation.\n\n    Args:\n        masks (tensor): Tensor of shape (Bimg, Hmask, Wmask), where Bimg is the number of\n            detected object instances in the image and Hmask, Wmask are the mask width and mask\n            height of the predicted mask (e.g., Hmask = Wmask = 28). Values are in [0, 1].\n        boxes (Boxes or Tensor): A Boxes of length Bimg or Tensor of shape (Bimg, 4).\n            boxes[i] and masks[i] correspond to the same object instance.\n        image_shape (tuple): height, width\n        threshold (float): A threshold in [0, 1] for converting the (soft) masks to\n            binary masks.\n\n    Returns:\n        img_masks (Tensor): A tensor of shape (Bimg, Himage, Wimage), where Bimg is the\n        number of detected object instances and Himage, Wimage are the image width\n        and height. img_masks[i] is a binary mask for object instance i.\n    \"\"\"", "\n", "\n", "assert", "masks", ".", "shape", "[", "-", "1", "]", "==", "masks", ".", "shape", "[", "-", "2", "]", ",", "\"Only square mask predictions are supported\"", "\n", "N", "=", "len", "(", "masks", ")", "\n", "if", "N", "==", "0", ":", "\n", "        ", "return", "masks", ".", "new_empty", "(", "(", "0", ",", ")", "+", "image_shape", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "", "if", "not", "isinstance", "(", "boxes", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "boxes", "=", "boxes", ".", "tensor", "\n", "", "device", "=", "boxes", ".", "device", "\n", "assert", "len", "(", "boxes", ")", "==", "N", ",", "boxes", ".", "shape", "\n", "\n", "img_h", ",", "img_w", "=", "image_shape", "\n", "\n", "# The actual implementation split the input into chunks,", "\n", "# and paste them chunk by chunk.", "\n", "if", "device", ".", "type", "==", "\"cpu\"", ":", "\n", "# CPU is most efficient when they are pasted one by one with skip_empty=True", "\n", "# so that it performs minimal number of operations.", "\n", "        ", "num_chunks", "=", "N", "\n", "", "else", ":", "\n", "# GPU benefits from parallelism for larger chunks, but may have memory issue", "\n", "# int(img_h) because shape may be tensors in tracing", "\n", "        ", "num_chunks", "=", "int", "(", "np", ".", "ceil", "(", "N", "*", "int", "(", "img_h", ")", "*", "int", "(", "img_w", ")", "*", "BYTES_PER_FLOAT", "/", "GPU_MEM_LIMIT", ")", ")", "\n", "assert", "(", "\n", "num_chunks", "<=", "N", "\n", ")", ",", "\"Default GPU_MEM_LIMIT in mask_ops.py is too small; try increasing it\"", "\n", "", "chunks", "=", "torch", ".", "chunk", "(", "torch", ".", "arange", "(", "N", ",", "device", "=", "device", ")", ",", "num_chunks", ")", "\n", "\n", "img_masks", "=", "torch", ".", "zeros", "(", "\n", "N", ",", "img_h", ",", "img_w", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "bool", "if", "threshold", ">=", "0", "else", "torch", ".", "uint8", "\n", ")", "\n", "for", "inds", "in", "chunks", ":", "\n", "        ", "masks_chunk", ",", "spatial_inds", "=", "_do_paste_mask", "(", "\n", "masks", "[", "inds", ",", "None", ",", ":", ",", ":", "]", ",", "boxes", "[", "inds", "]", ",", "img_h", ",", "img_w", ",", "skip_empty", "=", "device", ".", "type", "==", "\"cpu\"", "\n", ")", "\n", "\n", "if", "threshold", ">=", "0", ":", "\n", "            ", "masks_chunk", "=", "(", "masks_chunk", ">=", "threshold", ")", ".", "to", "(", "dtype", "=", "torch", ".", "bool", ")", "\n", "", "else", ":", "\n", "# for visualization and debugging", "\n", "            ", "masks_chunk", "=", "(", "masks_chunk", "*", "255", ")", ".", "to", "(", "dtype", "=", "torch", ".", "uint8", ")", "\n", "\n", "", "img_masks", "[", "(", "inds", ",", ")", "+", "spatial_inds", "]", "=", "masks_chunk", "\n", "", "return", "img_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.paste_mask_in_image_old": [[143, 196], ["box.to.to", "PIL.Image.fromarray", "torch.from_numpy().to.resize", "numpy.array", "torch.zeros", "max", "min", "max", "min", "torch.from_numpy().to.cpu().numpy", "numpy.array", "torch.from_numpy", "torch.from_numpy().to", "torch.from_numpy().to.cpu", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.resize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "paste_mask_in_image_old", "(", "mask", ",", "box", ",", "img_h", ",", "img_w", ",", "threshold", ")", ":", "\n", "    ", "\"\"\"\n    Paste a single mask in an image.\n    This is a per-box implementation of :func:`paste_masks_in_image`.\n    This function has larger quantization error due to incorrect pixel\n    modeling and is not used any more.\n\n    Args:\n        mask (Tensor): A tensor of shape (Hmask, Wmask) storing the mask of a single\n            object instance. Values are in [0, 1].\n        box (Tensor): A tensor of shape (4, ) storing the x0, y0, x1, y1 box corners\n            of the object instance.\n        img_h, img_w (int): Image height and width.\n        threshold (float): Mask binarization threshold in [0, 1].\n\n    Returns:\n        im_mask (Tensor):\n            The resized and binarized object mask pasted into the original\n            image plane (a tensor of shape (img_h, img_w)).\n    \"\"\"", "\n", "# Conversion from continuous box coordinates to discrete pixel coordinates", "\n", "# via truncation (cast to int32). This determines which pixels to paste the", "\n", "# mask onto.", "\n", "box", "=", "box", ".", "to", "(", "dtype", "=", "torch", ".", "int32", ")", "# Continuous to discrete coordinate conversion", "\n", "# An example (1D) box with continuous coordinates (x0=0.7, x1=4.3) will map to", "\n", "# a discrete coordinates (x0=0, x1=4). Note that box is mapped to 5 = x1 - x0 + 1", "\n", "# pixels (not x1 - x0 pixels).", "\n", "samples_w", "=", "box", "[", "2", "]", "-", "box", "[", "0", "]", "+", "1", "# Number of pixel samples, *not* geometric width", "\n", "samples_h", "=", "box", "[", "3", "]", "-", "box", "[", "1", "]", "+", "1", "# Number of pixel samples, *not* geometric height", "\n", "\n", "# Resample the mask from it's original grid to the new samples_w x samples_h grid", "\n", "mask", "=", "Image", ".", "fromarray", "(", "mask", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "mask", "=", "mask", ".", "resize", "(", "(", "samples_w", ",", "samples_h", ")", ",", "resample", "=", "Image", ".", "BILINEAR", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask", ",", "copy", "=", "False", ")", "\n", "\n", "if", "threshold", ">=", "0", ":", "\n", "        ", "mask", "=", "np", ".", "array", "(", "mask", ">", "threshold", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ")", "\n", "", "else", ":", "\n", "# for visualization and debugging, we also", "\n", "# allow it to return an unmodified mask", "\n", "        ", "mask", "=", "torch", ".", "from_numpy", "(", "mask", "*", "255", ")", ".", "to", "(", "torch", ".", "uint8", ")", "\n", "\n", "", "im_mask", "=", "torch", ".", "zeros", "(", "(", "img_h", ",", "img_w", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "x_0", "=", "max", "(", "box", "[", "0", "]", ",", "0", ")", "\n", "x_1", "=", "min", "(", "box", "[", "2", "]", "+", "1", ",", "img_w", ")", "\n", "y_0", "=", "max", "(", "box", "[", "1", "]", ",", "0", ")", "\n", "y_1", "=", "min", "(", "box", "[", "3", "]", "+", "1", ",", "img_h", ")", "\n", "\n", "im_mask", "[", "y_0", ":", "y_1", ",", "x_0", ":", "x_1", "]", "=", "mask", "[", "\n", "(", "y_0", "-", "box", "[", "1", "]", ")", ":", "(", "y_1", "-", "box", "[", "1", "]", ")", ",", "(", "x_0", "-", "box", "[", "0", "]", ")", ":", "(", "x_1", "-", "box", "[", "0", "]", ")", "\n", "]", "\n", "return", "im_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.pad_masks": [[207, 223], ["masks.new_zeros", "float"], "function", ["None"], ["", "def", "pad_masks", "(", "masks", ",", "padding", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        masks (tensor): A tensor of shape (B, M, M) representing B masks.\n        padding (int): Number of cells to pad on all sides.\n\n    Returns:\n        The padded masks and the scale factor of the padding size / original size.\n    \"\"\"", "\n", "B", "=", "masks", ".", "shape", "[", "0", "]", "\n", "M", "=", "masks", ".", "shape", "[", "-", "1", "]", "\n", "pad2", "=", "2", "*", "padding", "\n", "scale", "=", "float", "(", "M", "+", "pad2", ")", "/", "M", "\n", "padded_masks", "=", "masks", ".", "new_zeros", "(", "(", "B", ",", "M", "+", "pad2", ",", "M", "+", "pad2", ")", ")", "\n", "padded_masks", "[", ":", ",", "padding", ":", "-", "padding", ",", "padding", ":", "-", "padding", "]", "=", "masks", "\n", "return", "padded_masks", ",", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.scale_boxes": [[225, 249], ["torch.zeros_like"], "function", ["None"], ["", "def", "scale_boxes", "(", "boxes", ",", "scale", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        boxes (tensor): A tensor of shape (B, 4) representing B boxes with 4\n            coords representing the corners x0, y0, x1, y1,\n        scale (float): The box scaling factor.\n\n    Returns:\n        Scaled boxes.\n    \"\"\"", "\n", "w_half", "=", "(", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", ")", "*", "0.5", "\n", "h_half", "=", "(", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", ")", "*", "0.5", "\n", "x_c", "=", "(", "boxes", "[", ":", ",", "2", "]", "+", "boxes", "[", ":", ",", "0", "]", ")", "*", "0.5", "\n", "y_c", "=", "(", "boxes", "[", ":", ",", "3", "]", "+", "boxes", "[", ":", ",", "1", "]", ")", "*", "0.5", "\n", "\n", "w_half", "*=", "scale", "\n", "h_half", "*=", "scale", "\n", "\n", "scaled_boxes", "=", "torch", ".", "zeros_like", "(", "boxes", ")", "\n", "scaled_boxes", "[", ":", ",", "0", "]", "=", "x_c", "-", "w_half", "\n", "scaled_boxes", "[", ":", ",", "2", "]", "=", "x_c", "+", "w_half", "\n", "scaled_boxes", "[", ":", ",", "1", "]", "=", "y_c", "-", "h_half", "\n", "scaled_boxes", "[", ":", ",", "3", "]", "=", "y_c", "+", "h_half", "\n", "return", "scaled_boxes", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.FrozenBatchNorm2d.__init__": [[36, 44], ["torch.nn.Module.__init__", "batch_norm.FrozenBatchNorm2d.register_buffer", "batch_norm.FrozenBatchNorm2d.register_buffer", "batch_norm.FrozenBatchNorm2d.register_buffer", "batch_norm.FrozenBatchNorm2d.register_buffer", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-5", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_features", "=", "num_features", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "register_buffer", "(", "\"weight\"", ",", "torch", ".", "ones", "(", "num_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"bias\"", ",", "torch", ".", "zeros", "(", "num_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"running_mean\"", ",", "torch", ".", "zeros", "(", "num_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"running_var\"", ",", "torch", ".", "ones", "(", "num_features", ")", "-", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.FrozenBatchNorm2d.forward": [[45, 65], ["scale.reshape.reshape.reshape", "bias.reshape.reshape.reshape", "torch.nn.functional.batch_norm", "torch.nn.functional.batch_norm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "requires_grad", ":", "\n", "# When gradients are needed, F.batch_norm will use extra memory", "\n", "# because its backward op computes gradients for weight/bias as well.", "\n", "            ", "scale", "=", "self", ".", "weight", "*", "(", "self", ".", "running_var", "+", "self", ".", "eps", ")", ".", "rsqrt", "(", ")", "\n", "bias", "=", "self", ".", "bias", "-", "self", ".", "running_mean", "*", "scale", "\n", "scale", "=", "scale", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "bias", "=", "bias", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "return", "x", "*", "scale", "+", "bias", "\n", "", "else", ":", "\n", "# When gradients are not needed, F.batch_norm is a single fused op", "\n", "# and provide more optimization opportunities.", "\n", "            ", "return", "F", ".", "batch_norm", "(", "\n", "x", ",", "\n", "self", ".", "running_mean", ",", "\n", "self", ".", "running_var", ",", "\n", "self", ".", "weight", ",", "\n", "self", ".", "bias", ",", "\n", "training", "=", "False", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.FrozenBatchNorm2d._load_from_state_dict": [[67, 88], ["local_metadata.get", "super()._load_from_state_dict", "logging.getLogger", "logging.getLogger.info", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "prefix.rstrip"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.FrozenBatchNorm2d._load_from_state_dict"], ["", "", "def", "_load_from_state_dict", "(", "\n", "self", ",", "state_dict", ",", "prefix", ",", "local_metadata", ",", "strict", ",", "missing_keys", ",", "unexpected_keys", ",", "error_msgs", "\n", ")", ":", "\n", "        ", "version", "=", "local_metadata", ".", "get", "(", "\"version\"", ",", "None", ")", "\n", "\n", "if", "version", "is", "None", "or", "version", "<", "2", ":", "\n", "# No running_mean/var in early versions", "\n", "# This will silent the warnings", "\n", "            ", "if", "prefix", "+", "\"running_mean\"", "not", "in", "state_dict", ":", "\n", "                ", "state_dict", "[", "prefix", "+", "\"running_mean\"", "]", "=", "torch", ".", "zeros_like", "(", "self", ".", "running_mean", ")", "\n", "", "if", "prefix", "+", "\"running_var\"", "not", "in", "state_dict", ":", "\n", "                ", "state_dict", "[", "prefix", "+", "\"running_var\"", "]", "=", "torch", ".", "ones_like", "(", "self", ".", "running_var", ")", "\n", "\n", "", "", "if", "version", "is", "not", "None", "and", "version", "<", "3", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"FrozenBatchNorm {} is upgraded to version 3.\"", ".", "format", "(", "prefix", ".", "rstrip", "(", "\".\"", ")", ")", ")", "\n", "# In version < 3, running_var are used without +eps.", "\n", "state_dict", "[", "prefix", "+", "\"running_var\"", "]", "-=", "self", ".", "eps", "\n", "\n", "", "super", "(", ")", ".", "_load_from_state_dict", "(", "\n", "state_dict", ",", "prefix", ",", "local_metadata", ",", "strict", ",", "missing_keys", ",", "unexpected_keys", ",", "error_msgs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.FrozenBatchNorm2d.__repr__": [[90, 92], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"FrozenBatchNorm2d(num_features={}, eps={})\"", ".", "format", "(", "self", ".", "num_features", ",", "self", ".", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm": [[93, 125], ["isinstance", "cls", "module.named_children", "module.weight.data.clone().detach", "module.bias.data.clone().detach", "cls.convert_frozen_batchnorm", "cls.add_module", "module.weight.data.clone", "module.bias.data.clone"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "@", "classmethod", "\n", "def", "convert_frozen_batchnorm", "(", "cls", ",", "module", ")", ":", "\n", "        ", "\"\"\"\n        Convert BatchNorm/SyncBatchNorm in module into FrozenBatchNorm.\n\n        Args:\n            module (torch.nn.Module):\n\n        Returns:\n            If module is BatchNorm/SyncBatchNorm, returns a new module.\n            Otherwise, in-place convert module and return it.\n\n        Similar to convert_sync_batchnorm in\n        https://github.com/pytorch/pytorch/blob/master/torch/nn/modules/batchnorm.py\n        \"\"\"", "\n", "bn_module", "=", "nn", ".", "modules", ".", "batchnorm", "\n", "bn_module", "=", "(", "bn_module", ".", "BatchNorm2d", ",", "bn_module", ".", "SyncBatchNorm", ")", "\n", "res", "=", "module", "\n", "if", "isinstance", "(", "module", ",", "bn_module", ")", ":", "\n", "            ", "res", "=", "cls", "(", "module", ".", "num_features", ")", "\n", "if", "module", ".", "affine", ":", "\n", "                ", "res", ".", "weight", ".", "data", "=", "module", ".", "weight", ".", "data", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "res", ".", "bias", ".", "data", "=", "module", ".", "bias", ".", "data", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "", "res", ".", "running_mean", ".", "data", "=", "module", ".", "running_mean", ".", "data", "\n", "res", ".", "running_var", ".", "data", "=", "module", ".", "running_var", ".", "data", "\n", "res", ".", "eps", "=", "module", ".", "eps", "\n", "", "else", ":", "\n", "            ", "for", "name", ",", "child", "in", "module", ".", "named_children", "(", ")", ":", "\n", "                ", "new_child", "=", "cls", ".", "convert_frozen_batchnorm", "(", "child", ")", "\n", "if", "new_child", "is", "not", "child", ":", "\n", "                    ", "res", ".", "add_module", "(", "name", ",", "new_child", ")", "\n", "", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.AllReduce.forward": [[154, 161], ["torch.all_gather", "torch.all_gather", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.get_world_size", "torch.get_world_size"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ")", ":", "\n", "        ", "input_list", "=", "[", "torch", ".", "zeros_like", "(", "input", ")", "for", "k", "in", "range", "(", "dist", ".", "get_world_size", "(", ")", ")", "]", "\n", "# Use allgather instead of allreduce since I don't trust in-place operations ..", "\n", "dist", ".", "all_gather", "(", "input_list", ",", "input", ",", "async_op", "=", "False", ")", "\n", "inputs", "=", "torch", ".", "stack", "(", "input_list", ",", "dim", "=", "0", ")", "\n", "return", "torch", ".", "sum", "(", "inputs", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.AllReduce.backward": [[162, 166], ["torch.all_reduce", "torch.all_reduce"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "dist", ".", "all_reduce", "(", "grad_output", ",", "async_op", "=", "False", ")", "\n", "return", "grad_output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.NaiveSyncBatchNorm.__init__": [[196, 200], ["wrappers.BatchNorm2d.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "stats_mode", "=", "\"\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "assert", "stats_mode", "in", "[", "\"\"", ",", "\"N\"", "]", "\n", "self", ".", "_stats_mode", "=", "stats_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.NaiveSyncBatchNorm.forward": [[201, 241], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.rsqrt", "torch.rsqrt", "torch.rsqrt", "torch.rsqrt", "scale.reshape.reshape.reshape", "bias.reshape.reshape.reshape", "super().forward", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.split", "torch.split", "torch.split", "torch.split", "AllReduce.apply", "vec[].detach", "torch.max", "torch.max", "torch.max", "torch.max", "torch.split", "torch.split", "torch.split", "torch.split", "detectron2.utils.comm.get_world_size", "AllReduce.apply", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.max.clamp", "torch.max.clamp", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.mean.detach", "torch.mean.detach", "var.detach", "torch.get_world_size", "torch.get_world_size", "input.sum", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "if", "comm", ".", "get_world_size", "(", ")", "==", "1", "or", "not", "self", ".", "training", ":", "\n", "            ", "return", "super", "(", ")", ".", "forward", "(", "input", ")", "\n", "\n", "", "B", ",", "C", "=", "input", ".", "shape", "[", "0", "]", ",", "input", ".", "shape", "[", "1", "]", "\n", "\n", "mean", "=", "torch", ".", "mean", "(", "input", ",", "dim", "=", "[", "0", ",", "2", ",", "3", "]", ")", "\n", "meansqr", "=", "torch", ".", "mean", "(", "input", "*", "input", ",", "dim", "=", "[", "0", ",", "2", ",", "3", "]", ")", "\n", "\n", "if", "self", ".", "_stats_mode", "==", "\"\"", ":", "\n", "            ", "assert", "B", ">", "0", ",", "'SyncBatchNorm(stats_mode=\"\") does not support zero batch size.'", "\n", "vec", "=", "torch", ".", "cat", "(", "[", "mean", ",", "meansqr", "]", ",", "dim", "=", "0", ")", "\n", "vec", "=", "AllReduce", ".", "apply", "(", "vec", ")", "*", "(", "1.0", "/", "dist", ".", "get_world_size", "(", ")", ")", "\n", "mean", ",", "meansqr", "=", "torch", ".", "split", "(", "vec", ",", "C", ")", "\n", "momentum", "=", "self", ".", "momentum", "\n", "", "else", ":", "\n", "            ", "if", "B", "==", "0", ":", "\n", "                ", "vec", "=", "torch", ".", "zeros", "(", "[", "2", "*", "C", "+", "1", "]", ",", "device", "=", "mean", ".", "device", ",", "dtype", "=", "mean", ".", "dtype", ")", "\n", "vec", "=", "vec", "+", "input", ".", "sum", "(", ")", "# make sure there is gradient w.r.t input", "\n", "", "else", ":", "\n", "                ", "vec", "=", "torch", ".", "cat", "(", "\n", "[", "mean", ",", "meansqr", ",", "torch", ".", "ones", "(", "[", "1", "]", ",", "device", "=", "mean", ".", "device", ",", "dtype", "=", "mean", ".", "dtype", ")", "]", ",", "dim", "=", "0", "\n", ")", "\n", "", "vec", "=", "AllReduce", ".", "apply", "(", "vec", "*", "B", ")", "\n", "\n", "total_batch", "=", "vec", "[", "-", "1", "]", ".", "detach", "(", ")", "\n", "momentum", "=", "total_batch", ".", "clamp", "(", "max", "=", "1", ")", "*", "self", ".", "momentum", "# no update if total_batch is 0", "\n", "total_batch", "=", "torch", ".", "max", "(", "total_batch", ",", "torch", ".", "ones_like", "(", "total_batch", ")", ")", "# avoid div-by-zero", "\n", "mean", ",", "meansqr", ",", "_", "=", "torch", ".", "split", "(", "vec", "/", "total_batch", ",", "C", ")", "\n", "\n", "", "var", "=", "meansqr", "-", "mean", "*", "mean", "\n", "invstd", "=", "torch", ".", "rsqrt", "(", "var", "+", "self", ".", "eps", ")", "\n", "scale", "=", "self", ".", "weight", "*", "invstd", "\n", "bias", "=", "self", ".", "bias", "-", "mean", "*", "scale", "\n", "scale", "=", "scale", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "bias", "=", "bias", ".", "reshape", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "\n", "self", ".", "running_mean", "+=", "momentum", "*", "(", "mean", ".", "detach", "(", ")", "-", "self", ".", "running_mean", ")", "\n", "self", ".", "running_var", "+=", "momentum", "*", "(", "var", ".", "detach", "(", ")", "-", "self", ".", "running_var", ")", "\n", "return", "input", "*", "scale", "+", "bias", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm": [[127, 151], ["isinstance", "norm", "len", "torch.nn.GroupNorm"], "function", ["None"], ["", "", "def", "get_norm", "(", "norm", ",", "out_channels", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        norm (str or callable): either one of BN, SyncBN, FrozenBN, GN;\n            or a callable that takes a channel number and returns\n            the normalization layer as a nn.Module.\n\n    Returns:\n        nn.Module or None: the normalization layer\n    \"\"\"", "\n", "if", "isinstance", "(", "norm", ",", "str", ")", ":", "\n", "        ", "if", "len", "(", "norm", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "", "norm", "=", "{", "\n", "\"BN\"", ":", "BatchNorm2d", ",", "\n", "# Fixed in https://github.com/pytorch/pytorch/pull/36382", "\n", "\"SyncBN\"", ":", "NaiveSyncBatchNorm", "if", "env", ".", "TORCH_VERSION", "<=", "(", "1", ",", "5", ")", "else", "nn", ".", "SyncBatchNorm", ",", "\n", "\"FrozenBN\"", ":", "FrozenBatchNorm2d", ",", "\n", "\"GN\"", ":", "lambda", "channels", ":", "nn", ".", "GroupNorm", "(", "32", ",", "channels", ")", ",", "\n", "# for debugging:", "\n", "\"nnSyncBN\"", ":", "nn", ".", "SyncBatchNorm", ",", "\n", "\"naiveSyncBN\"", ":", "NaiveSyncBatchNorm", ",", "\n", "}", "[", "norm", "]", "\n", "", "return", "norm", "(", "out_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.roi_align.ROIAlign.__init__": [[64, 98], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "output_size", ",", "spatial_scale", ",", "sampling_ratio", ",", "aligned", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            output_size (tuple): h, w\n            spatial_scale (float): scale the input boxes by this number\n            sampling_ratio (int): number of inputs samples to take for each output\n                sample. 0 to take samples densely.\n            aligned (bool): if False, use the legacy implementation in\n                Detectron. If True, align the results more perfectly.\n\n        Note:\n            The meaning of aligned=True:\n\n            Given a continuous coordinate c, its two neighboring pixel indices (in our\n            pixel model) are computed by floor(c - 0.5) and ceil(c - 0.5). For example,\n            c=1.3 has pixel neighbors with discrete indices [0] and [1] (which are sampled\n            from the underlying signal at continuous coordinates 0.5 and 1.5). But the original\n            roi_align (aligned=False) does not subtract the 0.5 when computing neighboring\n            pixel indices and therefore it uses pixels with a slightly incorrect alignment\n            (relative to our pixel model) when performing bilinear interpolation.\n\n            With `aligned=True`,\n            we first appropriately scale the ROI and then shift it by -0.5\n            prior to calling roi_align. This produces the correct neighbors; see\n            detectron2/tests/test_roi_align.py for verification.\n\n            The difference does not make a difference to the model's performance if\n            ROIAlign is used together with conv layers.\n        \"\"\"", "\n", "super", "(", "ROIAlign", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "self", ".", "sampling_ratio", "=", "sampling_ratio", "\n", "self", ".", "aligned", "=", "aligned", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.roi_align.ROIAlign.forward": [[99, 108], ["torchvision.ops.roi_align", "rois.dim", "rois.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "rois", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input: NCHW images\n            rois: Bx5 boxes. First column is the index into N. The other 4 columns are xyxy.\n        \"\"\"", "\n", "assert", "rois", ".", "dim", "(", ")", "==", "2", "and", "rois", ".", "size", "(", "1", ")", "==", "5", "\n", "return", "roi_align", "(", "\n", "input", ",", "rois", ",", "self", ".", "output_size", ",", "self", ".", "spatial_scale", ",", "self", ".", "sampling_ratio", ",", "self", ".", "aligned", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.roi_align.ROIAlign.__repr__": [[110, 118], ["str", "str", "str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "tmpstr", "+=", "\"output_size=\"", "+", "str", "(", "self", ".", "output_size", ")", "\n", "tmpstr", "+=", "\", spatial_scale=\"", "+", "str", "(", "self", ".", "spatial_scale", ")", "\n", "tmpstr", "+=", "\", sampling_ratio=\"", "+", "str", "(", "self", ".", "sampling_ratio", ")", "\n", "tmpstr", "+=", "\", aligned=\"", "+", "str", "(", "self", ".", "aligned", ")", "\n", "tmpstr", "+=", "\")\"", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.shape_spec.ShapeSpec.__new__": [[19, 21], ["super().__new__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.shape_spec.ShapeSpec.__new__"], ["def", "__new__", "(", "cls", ",", "*", ",", "channels", "=", "None", ",", "height", "=", "None", ",", "width", "=", "None", ",", "stride", "=", "None", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "__new__", "(", "cls", ",", "channels", ",", "height", ",", "width", ",", "stride", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.roi_align_rotated._ROIAlignRotated.forward": [[11, 22], ["ctx.save_for_backward", "torch.nn.modules.utils._pair", "input.size", "detectron2._C.roi_align_rotated_forward"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ",", "roi", ",", "output_size", ",", "spatial_scale", ",", "sampling_ratio", ")", ":", "\n", "        ", "ctx", ".", "save_for_backward", "(", "roi", ")", "\n", "ctx", ".", "output_size", "=", "_pair", "(", "output_size", ")", "\n", "ctx", ".", "spatial_scale", "=", "spatial_scale", "\n", "ctx", ".", "sampling_ratio", "=", "sampling_ratio", "\n", "ctx", ".", "input_shape", "=", "input", ".", "size", "(", ")", "\n", "output", "=", "_C", ".", "roi_align_rotated_forward", "(", "\n", "input", ",", "roi", ",", "spatial_scale", ",", "output_size", "[", "0", "]", ",", "output_size", "[", "1", "]", ",", "sampling_ratio", "\n", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.roi_align_rotated._ROIAlignRotated.backward": [[23, 44], ["detectron2._C.roi_align_rotated_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "(", "rois", ",", ")", "=", "ctx", ".", "saved_tensors", "\n", "output_size", "=", "ctx", ".", "output_size", "\n", "spatial_scale", "=", "ctx", ".", "spatial_scale", "\n", "sampling_ratio", "=", "ctx", ".", "sampling_ratio", "\n", "bs", ",", "ch", ",", "h", ",", "w", "=", "ctx", ".", "input_shape", "\n", "grad_input", "=", "_C", ".", "roi_align_rotated_backward", "(", "\n", "grad_output", ",", "\n", "rois", ",", "\n", "spatial_scale", ",", "\n", "output_size", "[", "0", "]", ",", "\n", "output_size", "[", "1", "]", ",", "\n", "bs", ",", "\n", "ch", ",", "\n", "h", ",", "\n", "w", ",", "\n", "sampling_ratio", ",", "\n", ")", "\n", "return", "grad_input", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.roi_align_rotated.ROIAlignRotated.__init__": [[50, 69], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "output_size", ",", "spatial_scale", ",", "sampling_ratio", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            output_size (tuple): h, w\n            spatial_scale (float): scale the input boxes by this number\n            sampling_ratio (int): number of inputs samples to take for each output\n                sample. 0 to take samples densely.\n\n        Note:\n            ROIAlignRotated supports continuous coordinate by default:\n            Given a continuous coordinate c, its two neighboring pixel indices (in our\n            pixel model) are computed by floor(c - 0.5) and ceil(c - 0.5). For example,\n            c=1.3 has pixel neighbors with discrete indices [0] and [1] (which are sampled\n            from the underlying signal at continuous coordinates 0.5 and 1.5).\n        \"\"\"", "\n", "super", "(", "ROIAlignRotated", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "self", ".", "sampling_ratio", "=", "sampling_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.roi_align_rotated.ROIAlignRotated.forward": [[70, 80], ["roi_align_rotated", "rois.dim", "rois.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "rois", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input: NCHW images\n            rois: Bx6 boxes. First column is the index into N.\n                The other 5 columns are (x_ctr, y_ctr, width, height, angle_degrees).\n        \"\"\"", "\n", "assert", "rois", ".", "dim", "(", ")", "==", "2", "and", "rois", ".", "size", "(", "1", ")", "==", "6", "\n", "return", "roi_align_rotated", "(", "\n", "input", ",", "rois", ",", "self", ".", "output_size", ",", "self", ".", "spatial_scale", ",", "self", ".", "sampling_ratio", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.roi_align_rotated.ROIAlignRotated.__repr__": [[82, 89], ["str", "str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "tmpstr", "+=", "\"output_size=\"", "+", "str", "(", "self", ".", "output_size", ")", "\n", "tmpstr", "+=", "\", spatial_scale=\"", "+", "str", "(", "self", ".", "spatial_scale", ")", "\n", "tmpstr", "+=", "\", sampling_ratio=\"", "+", "str", "(", "self", ".", "sampling_ratio", ")", "\n", "tmpstr", "+=", "\")\"", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat._SwapAlign2Nat.forward": [[10, 17], ["X.size", "tensormask._C.swap_align2nat_forward"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "X", ",", "lambda_val", ",", "pad_val", ")", ":", "\n", "        ", "ctx", ".", "lambda_val", "=", "lambda_val", "\n", "ctx", ".", "input_shape", "=", "X", ".", "size", "(", ")", "\n", "\n", "Y", "=", "_C", ".", "swap_align2nat_forward", "(", "X", ",", "lambda_val", ",", "pad_val", ")", "\n", "return", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat._SwapAlign2Nat.backward": [[18, 27], ["tensormask._C.swap_align2nat_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "gY", ")", ":", "\n", "        ", "lambda_val", "=", "ctx", ".", "lambda_val", "\n", "bs", ",", "ch", ",", "h", ",", "w", "=", "ctx", ".", "input_shape", "\n", "\n", "gX", "=", "_C", ".", "swap_align2nat_backward", "(", "gY", ",", "lambda_val", ",", "bs", ",", "ch", ",", "h", ",", "w", ")", "\n", "\n", "return", "gX", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat.SwapAlign2Nat.__init__": [[48, 52], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "lambda_val", ",", "pad_val", "=", "-", "6.0", ")", ":", "\n", "        ", "super", "(", "SwapAlign2Nat", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lambda_val", "=", "lambda_val", "\n", "self", ".", "pad_val", "=", "pad_val", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat.SwapAlign2Nat.forward": [[53, 55], ["swap_align2nat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "swap_align2nat", "(", "X", ",", "self", ".", "lambda_val", ",", "self", ".", "pad_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat.SwapAlign2Nat.__repr__": [[56, 62], ["str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "tmpstr", "+=", "\"lambda_val=\"", "+", "str", "(", "self", ".", "lambda_val", ")", "\n", "tmpstr", "+=", "\", pad_val=\"", "+", "str", "(", "self", ".", "pad_val", ")", "\n", "tmpstr", "+=", "\")\"", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest.test_forward_output": [[12, 45], ["numpy.arange().reshape().astype", "test_roi_align.ROIAlignTest._simple_roialign", "test_roi_align.ROIAlignTest._simple_roialign", "test_roi_align.ROIAlignTest.assertTrue", "test_roi_align.ROIAlignTest.assertTrue", "numpy.allclose", "numpy.allclose", "numpy.arange().reshape", "test_roi_align.ROIAlignTest.flatten", "numpy.asarray().flatten", "test_roi_align.ROIAlignTest.flatten", "numpy.asarray().flatten", "numpy.arange", "numpy.asarray", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest._simple_roialign", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest._simple_roialign", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["    ", "def", "test_forward_output", "(", "self", ")", ":", "\n", "        ", "input", "=", "np", ".", "arange", "(", "25", ")", ".", "reshape", "(", "5", ",", "5", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "\"\"\"\n        0  1  2   3 4\n        5  6  7   8 9\n        10 11 12 13 14\n        15 16 17 18 19\n        20 21 22 23 24\n        \"\"\"", "\n", "\n", "output", "=", "self", ".", "_simple_roialign", "(", "input", ",", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "(", "4", ",", "4", ")", ",", "aligned", "=", "False", ")", "\n", "output_correct", "=", "self", ".", "_simple_roialign", "(", "input", ",", "[", "1", ",", "1", ",", "3", ",", "3", "]", ",", "(", "4", ",", "4", ")", ",", "aligned", "=", "True", ")", "\n", "\n", "# without correction:", "\n", "old_results", "=", "[", "\n", "[", "7.5", ",", "8", ",", "8.5", ",", "9", "]", ",", "\n", "[", "10", ",", "10.5", ",", "11", ",", "11.5", "]", ",", "\n", "[", "12.5", ",", "13", ",", "13.5", ",", "14", "]", ",", "\n", "[", "15", ",", "15.5", ",", "16", ",", "16.5", "]", ",", "\n", "]", "\n", "\n", "# with 0.5 correction:", "\n", "correct_results", "=", "[", "\n", "[", "4.5", ",", "5.0", ",", "5.5", ",", "6.0", "]", ",", "\n", "[", "7.0", ",", "7.5", ",", "8.0", ",", "8.5", "]", ",", "\n", "[", "9.5", ",", "10.0", ",", "10.5", ",", "11.0", "]", ",", "\n", "[", "12.0", ",", "12.5", ",", "13.0", ",", "13.5", "]", ",", "\n", "]", "\n", "# This is an upsampled version of [[6, 7], [11, 12]]", "\n", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "output", ".", "flatten", "(", ")", ",", "np", ".", "asarray", "(", "old_results", ")", ".", "flatten", "(", ")", ")", ")", "\n", "self", ".", "assertTrue", "(", "\n", "np", ".", "allclose", "(", "output_correct", ".", "flatten", "(", ")", ",", "np", ".", "asarray", "(", "correct_results", ")", ".", "flatten", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest.test_resize": [[50, 61], ["test_roi_align.ROIAlignTest._simple_roialign", "cv2.resize", "test_roi_align.ROIAlignTest._simple_roialign", "numpy.abs", "test_roi_align.ROIAlignTest.assertTrue", "numpy.random.rand().astype", "numpy.abs.max", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest._simple_roialign", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.resize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest._simple_roialign"], ["", "def", "test_resize", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "30", ",", "30", "\n", "input", "=", "np", ".", "random", ".", "rand", "(", "H", ",", "W", ")", ".", "astype", "(", "\"float32\"", ")", "*", "100", "\n", "box", "=", "[", "10", ",", "10", ",", "20", ",", "20", "]", "\n", "output", "=", "self", ".", "_simple_roialign", "(", "input", ",", "box", ",", "(", "5", ",", "5", ")", ",", "aligned", "=", "True", ")", "\n", "\n", "input2x", "=", "cv2", ".", "resize", "(", "input", ",", "(", "W", "//", "2", ",", "H", "//", "2", ")", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", "\n", "box2x", "=", "[", "x", "/", "2", "for", "x", "in", "box", "]", "\n", "output2x", "=", "self", ".", "_simple_roialign", "(", "input2x", ",", "box2x", ",", "(", "5", ",", "5", ")", ",", "aligned", "=", "True", ")", "\n", "diff", "=", "np", ".", "abs", "(", "output2x", "-", "output", ")", "\n", "self", ".", "assertTrue", "(", "diff", ".", "max", "(", ")", "<", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest._simple_roialign": [[62, 78], ["isinstance", "detectron2.layers.roi_align.ROIAlign", "torch.from_numpy", "torch.from_numpy", "detectron2.layers.roi_align.ROIAlign.forward", "torch.cuda.is_available", "img[].astype", "list", "[].astype", "detectron2.layers.roi_align.ROIAlign.forward().cpu", "test_roi_align.ROIAlignTest.assertTrue", "torch.allclose", "detectron2.layers.roi_align.ROIAlign.forward", "numpy.asarray", "torch.from_numpy.cuda", "torch.from_numpy.cuda"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward"], ["", "def", "_simple_roialign", "(", "self", ",", "img", ",", "box", ",", "resolution", ",", "aligned", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        RoiAlign with scale 1.0 and 0 sample ratio.\n        \"\"\"", "\n", "if", "isinstance", "(", "resolution", ",", "int", ")", ":", "\n", "            ", "resolution", "=", "(", "resolution", ",", "resolution", ")", "\n", "", "op", "=", "ROIAlign", "(", "resolution", ",", "1.0", ",", "0", ",", "aligned", "=", "aligned", ")", "\n", "input", "=", "torch", ".", "from_numpy", "(", "img", "[", "None", ",", "None", ",", ":", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "\n", "rois", "=", "[", "0", "]", "+", "list", "(", "box", ")", "\n", "rois", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "rois", ")", "[", "None", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "output", "=", "op", ".", "forward", "(", "input", ",", "rois", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "output_cuda", "=", "op", ".", "forward", "(", "input", ".", "cuda", "(", ")", ",", "rois", ".", "cuda", "(", ")", ")", ".", "cpu", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "output", ",", "output_cuda", ")", ")", "\n", "", "return", "output", "[", "0", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest._simple_roialign_with_grad": [[79, 93], ["isinstance", "detectron2.layers.roi_align.ROIAlign", "torch.from_numpy", "torch.from_numpy", "input.to.to.to", "rois.to.to.to", "detectron2.layers.roi_align.ROIAlign.forward", "img[].astype", "list", "[].astype", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "_simple_roialign_with_grad", "(", "self", ",", "img", ",", "box", ",", "resolution", ",", "device", ")", ":", "\n", "        ", "if", "isinstance", "(", "resolution", ",", "int", ")", ":", "\n", "            ", "resolution", "=", "(", "resolution", ",", "resolution", ")", "\n", "\n", "", "op", "=", "ROIAlign", "(", "resolution", ",", "1.0", ",", "0", ",", "aligned", "=", "True", ")", "\n", "input", "=", "torch", ".", "from_numpy", "(", "img", "[", "None", ",", "None", ",", ":", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "\n", "rois", "=", "[", "0", "]", "+", "list", "(", "box", ")", "\n", "rois", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "rois", ")", "[", "None", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "input", "=", "input", ".", "to", "(", "device", "=", "device", ")", "\n", "rois", "=", "rois", ".", "to", "(", "device", "=", "device", ")", "\n", "input", ".", "requires_grad", "=", "True", "\n", "output", "=", "op", ".", "forward", "(", "input", ",", "rois", ")", "\n", "return", "input", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest.test_empty_box": [[94, 105], ["numpy.random.rand", "test_roi_align.ROIAlignTest._simple_roialign", "test_roi_align.ROIAlignTest.assertTrue", "test_roi_align.ROIAlignTest.assertTrue", "torch.cuda.is_available", "test_roi_align.ROIAlignTest._simple_roialign_with_grad", "output.sum().backward", "test_roi_align.ROIAlignTest.assertTrue", "torch.device", "torch.allclose", "output.sum", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest._simple_roialign", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest._simple_roialign_with_grad", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["", "def", "test_empty_box", "(", "self", ")", ":", "\n", "        ", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "box", "=", "[", "3", ",", "4", ",", "5", ",", "4", "]", "\n", "o", "=", "self", ".", "_simple_roialign", "(", "img", ",", "box", ",", "7", ")", "\n", "self", ".", "assertTrue", "(", "o", ".", "shape", "==", "(", "7", ",", "7", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "o", "==", "0", ")", ".", "all", "(", ")", ")", "\n", "\n", "for", "dev", "in", "[", "\"cpu\"", "]", "+", "[", "\"cuda\"", "]", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "[", "]", ":", "\n", "            ", "input", ",", "output", "=", "self", ".", "_simple_roialign_with_grad", "(", "img", ",", "box", ",", "7", ",", "torch", ".", "device", "(", "dev", ")", ")", "\n", "output", ".", "sum", "(", ")", ".", "backward", "(", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "input", ".", "grad", ",", "torch", ".", "zeros_like", "(", "input", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.ROIAlignTest.test_empty_batch": [[106, 112], ["torch.zeros", "torch.zeros", "detectron2.layers.roi_align.ROIAlign", "detectron2.layers.roi_align.ROIAlign.forward", "test_roi_align.ROIAlignTest.assertTrue"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward"], ["", "", "def", "test_empty_batch", "(", "self", ")", ":", "\n", "        ", "input", "=", "torch", ".", "zeros", "(", "0", ",", "3", ",", "10", ",", "10", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "rois", "=", "torch", ".", "zeros", "(", "0", ",", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "op", "=", "ROIAlign", "(", "(", "7", ",", "7", ")", ",", "1.0", ",", "0", ",", "aligned", "=", "True", ")", "\n", "output", "=", "op", ".", "forward", "(", "input", ",", "rois", ")", "\n", "self", ".", "assertTrue", "(", "output", ".", "shape", "==", "(", "0", ",", "3", ",", "7", ",", "7", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align.benchmark_roi_align": [[114, 147], ["fvcore.common.benchmark.benchmark", "ret.clamp_", "torch.rand", "range", "torch.cat", "torch.cat", "torch.cat", "input.cuda.cuda", "boxes.cuda.cuda", "dict", "torch.tensor", "test_roi_align.benchmark_roi_align.random_boxes"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.test_box2box_transform.random_boxes"], ["", "", "def", "benchmark_roi_align", "(", ")", ":", "\n", "    ", "from", "detectron2", "import", "_C", "\n", "\n", "def", "random_boxes", "(", "mean_box", ",", "stdev", ",", "N", ",", "maxsize", ")", ":", "\n", "        ", "ret", "=", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "stdev", "+", "torch", ".", "tensor", "(", "mean_box", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "ret", ".", "clamp_", "(", "min", "=", "0", ",", "max", "=", "maxsize", ")", "\n", "return", "ret", "\n", "\n", "", "def", "func", "(", "N", ",", "C", ",", "H", ",", "W", ",", "nboxes_per_img", ")", ":", "\n", "        ", "input", "=", "torch", ".", "rand", "(", "N", ",", "C", ",", "H", ",", "W", ")", "\n", "boxes", "=", "[", "]", "\n", "batch_idx", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "N", ")", ":", "\n", "            ", "b", "=", "random_boxes", "(", "[", "80", ",", "80", ",", "130", ",", "130", "]", ",", "24", ",", "nboxes_per_img", ",", "H", ")", "\n", "# try smaller boxes:", "\n", "# b = random_boxes([100, 100, 110, 110], 4, nboxes_per_img, H)", "\n", "boxes", ".", "append", "(", "b", ")", "\n", "batch_idx", ".", "append", "(", "torch", ".", "zeros", "(", "nboxes_per_img", ",", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "+", "k", ")", "\n", "", "boxes", "=", "torch", ".", "cat", "(", "boxes", ",", "axis", "=", "0", ")", "\n", "batch_idx", "=", "torch", ".", "cat", "(", "batch_idx", ",", "axis", "=", "0", ")", "\n", "boxes", "=", "torch", ".", "cat", "(", "[", "batch_idx", ",", "boxes", "]", ",", "axis", "=", "1", ")", "\n", "\n", "input", "=", "input", ".", "cuda", "(", ")", "\n", "boxes", "=", "boxes", ".", "cuda", "(", ")", "\n", "\n", "def", "bench", "(", ")", ":", "\n", "            ", "_C", ".", "roi_align_forward", "(", "input", ",", "boxes", ",", "1.0", ",", "7", ",", "7", ",", "0", ",", "True", ")", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "\n", "", "return", "bench", "\n", "\n", "", "args", "=", "[", "dict", "(", "N", "=", "2", ",", "C", "=", "512", ",", "H", "=", "256", ",", "W", "=", "256", ",", "nboxes_per_img", "=", "500", ")", "]", "\n", "benchmark", "(", "func", ",", "\"cuda_roialign\"", ",", "args", ",", "num_iters", "=", "20", ",", "warmup_iters", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box": [[15, 22], ["None"], "methods", ["None"], ["    ", "def", "_box_to_rotated_box", "(", "self", ",", "box", ",", "angle", ")", ":", "\n", "        ", "return", "[", "\n", "(", "box", "[", "0", "]", "+", "box", "[", "2", "]", ")", "/", "2.0", ",", "\n", "(", "box", "[", "1", "]", "+", "box", "[", "3", "]", ")", "/", "2.0", ",", "\n", "box", "[", "2", "]", "-", "box", "[", "0", "]", ",", "\n", "box", "[", "3", "]", "-", "box", "[", "1", "]", ",", "\n", "angle", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._rot90": [[24, 29], ["range", "img.transpose().flip.transpose().flip.transpose().flip", "img.transpose().flip.transpose().flip.transpose"], "methods", ["None"], ["", "def", "_rot90", "(", "self", ",", "img", ",", "num", ")", ":", "\n", "        ", "num", "=", "num", "%", "4", "# note: -1 % 4 == 3", "\n", "for", "_", "in", "range", "(", "num", ")", ":", "\n", "            ", "img", "=", "img", ".", "transpose", "(", "0", ",", "1", ")", ".", "flip", "(", "0", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_forward_output_0_90_180_270": [[30, 72], ["range", "torch.arange().reshape", "test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "torch.tensor", "test_roi_align_rotated.ROIAlignRotatedTest._rot90", "torch.allclose", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._rot90"], ["", "def", "test_forward_output_0_90_180_270", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "# i = 0, 1, 2, 3 corresponding to 0, 90, 180, 270 degrees", "\n", "            ", "img", "=", "torch", ".", "arange", "(", "25", ",", "dtype", "=", "torch", ".", "float32", ")", ".", "reshape", "(", "5", ",", "5", ")", "\n", "\"\"\"\n            0  1  2   3 4\n            5  6  7   8 9\n            10 11 12 13 14\n            15 16 17 18 19\n            20 21 22 23 24\n            \"\"\"", "\n", "box", "=", "[", "1", ",", "1", ",", "3", ",", "3", "]", "\n", "rotated_box", "=", "self", ".", "_box_to_rotated_box", "(", "box", "=", "box", ",", "angle", "=", "90", "*", "i", ")", "\n", "\n", "result", "=", "self", ".", "_simple_roi_align_rotated", "(", "img", "=", "img", ",", "box", "=", "rotated_box", ",", "resolution", "=", "(", "4", ",", "4", ")", ")", "\n", "\n", "# Here's an explanation for 0 degree case:", "\n", "# point 0 in the original input lies at [0.5, 0.5]", "\n", "# (the center of bin [0, 1] x [0, 1])", "\n", "# point 1 in the original input lies at [1.5, 0.5], etc.", "\n", "# since the resolution is (4, 4) that divides [1, 3] x [1, 3]", "\n", "# into 4 x 4 equal bins,", "\n", "# the top-left bin is [1, 1.5] x [1, 1.5], and its center", "\n", "# (1.25, 1.25) lies at the 3/4 position", "\n", "# between point 0 and point 1, point 5 and point 6,", "\n", "# point 0 and point 5, point 1 and point 6, so it can be calculated as", "\n", "# 0.25*(0*0.25+1*0.75)+(5*0.25+6*0.75)*0.75 = 4.5", "\n", "result_expected", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "4.5", ",", "5.0", ",", "5.5", ",", "6.0", "]", ",", "\n", "[", "7.0", ",", "7.5", ",", "8.0", ",", "8.5", "]", ",", "\n", "[", "9.5", ",", "10.0", ",", "10.5", ",", "11.0", "]", ",", "\n", "[", "12.0", ",", "12.5", ",", "13.0", ",", "13.5", "]", ",", "\n", "]", "\n", ")", "\n", "# This is also an upsampled version of [[6, 7], [11, 12]]", "\n", "\n", "# When the box is rotated by 90 degrees CCW,", "\n", "# the result would be rotated by 90 degrees CW, thus it's -i here", "\n", "result_expected", "=", "self", ".", "_rot90", "(", "result_expected", ",", "-", "i", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "result", ",", "result_expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_resize": [[73, 86], ["test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "cv2.resize", "torch.from_numpy", "test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "torch.allclose", "torch.rand", "input.numpy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.resize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._box_to_rotated_box", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated"], ["", "", "def", "test_resize", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "30", ",", "30", "\n", "input", "=", "torch", ".", "rand", "(", "H", ",", "W", ")", "*", "100", "\n", "box", "=", "[", "10", ",", "10", ",", "20", ",", "20", "]", "\n", "rotated_box", "=", "self", ".", "_box_to_rotated_box", "(", "box", ",", "angle", "=", "0", ")", "\n", "output", "=", "self", ".", "_simple_roi_align_rotated", "(", "img", "=", "input", ",", "box", "=", "rotated_box", ",", "resolution", "=", "(", "5", ",", "5", ")", ")", "\n", "\n", "input2x", "=", "cv2", ".", "resize", "(", "input", ".", "numpy", "(", ")", ",", "(", "W", "//", "2", ",", "H", "//", "2", ")", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", "\n", "input2x", "=", "torch", ".", "from_numpy", "(", "input2x", ")", "\n", "box2x", "=", "[", "x", "/", "2", "for", "x", "in", "box", "]", "\n", "rotated_box2x", "=", "self", ".", "_box_to_rotated_box", "(", "box2x", ",", "angle", "=", "0", ")", "\n", "output2x", "=", "self", ".", "_simple_roi_align_rotated", "(", "img", "=", "input2x", ",", "box", "=", "rotated_box2x", ",", "resolution", "=", "(", "5", ",", "5", ")", ")", "\n", "assert", "torch", ".", "allclose", "(", "output2x", ",", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated": [[87, 101], ["detectron2.layers.roi_align_rotated.ROIAlignRotated", "detectron2.layers.roi_align_rotated.ROIAlignRotated.forward", "torch.cuda.is_available", "list", "torch.tensor", "detectron2.layers.roi_align_rotated.ROIAlignRotated.forward", "torch.allclose", "input.cuda", "rois.cuda", "detectron2.layers.roi_align_rotated.ROIAlignRotated.forward.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward"], ["", "def", "_simple_roi_align_rotated", "(", "self", ",", "img", ",", "box", ",", "resolution", ")", ":", "\n", "        ", "\"\"\"\n        RoiAlignRotated with scale 1.0 and 0 sample ratio.\n        \"\"\"", "\n", "op", "=", "ROIAlignRotated", "(", "output_size", "=", "resolution", ",", "spatial_scale", "=", "1.0", ",", "sampling_ratio", "=", "0", ")", "\n", "input", "=", "img", "[", "None", ",", "None", ",", ":", ",", ":", "]", "\n", "\n", "rois", "=", "[", "0", "]", "+", "list", "(", "box", ")", "\n", "rois", "=", "torch", ".", "tensor", "(", "rois", ",", "dtype", "=", "torch", ".", "float32", ")", "[", "None", ",", ":", "]", "\n", "result_cpu", "=", "op", ".", "forward", "(", "input", ",", "rois", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "result_cuda", "=", "op", ".", "forward", "(", "input", ".", "cuda", "(", ")", ",", "rois", ".", "cuda", "(", ")", ")", "\n", "assert", "torch", ".", "allclose", "(", "result_cpu", ",", "result_cuda", ".", "cpu", "(", ")", ")", "\n", "", "return", "result_cpu", "[", "0", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_empty_box": [[102, 106], ["torch.rand", "test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated", "test_roi_align_rotated.ROIAlignRotatedTest.assertTrue"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest._simple_roi_align_rotated"], ["", "def", "test_empty_box", "(", "self", ")", ":", "\n", "        ", "img", "=", "torch", ".", "rand", "(", "5", ",", "5", ")", "\n", "out", "=", "self", ".", "_simple_roi_align_rotated", "(", "img", ",", "[", "2", ",", "3", ",", "0", ",", "0", ",", "0", "]", ",", "(", "7", ",", "7", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "out", "==", "0", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_roi_align_rotated_gradcheck_cpu": [[107, 126], ["torch.device", "detectron2.layers.roi_align_rotated.ROIAlignRotated().to", "torch.rand", "torch.tensor", "torch.autograd.gradcheck", "torch.autograd.gradcheck", "detectron2.layers.roi_align_rotated.ROIAlignRotated().to.", "detectron2.layers.roi_align_rotated.ROIAlignRotated", "torch.rand.transpose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "test_roi_align_rotated_gradcheck_cpu", "(", "self", ")", ":", "\n", "        ", "dtype", "=", "torch", ".", "float64", "\n", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "roi_align_rotated_op", "=", "ROIAlignRotated", "(", "\n", "output_size", "=", "(", "5", ",", "5", ")", ",", "spatial_scale", "=", "0.5", ",", "sampling_ratio", "=", "1", "\n", ")", ".", "to", "(", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "x", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "10", ",", "10", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ",", "requires_grad", "=", "True", ")", "\n", "# roi format is (batch index, x_center, y_center, width, height, angle)", "\n", "rois", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0", ",", "4.5", ",", "4.5", ",", "9", ",", "9", ",", "0", "]", ",", "[", "0", ",", "2", ",", "7", ",", "4", ",", "4", ",", "0", "]", ",", "[", "0", ",", "7", ",", "7", ",", "4", ",", "4", ",", "0", "]", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "\n", "def", "func", "(", "input", ")", ":", "\n", "            ", "return", "roi_align_rotated_op", "(", "input", ",", "rois", ")", "\n", "\n", "", "assert", "gradcheck", "(", "func", ",", "(", "x", ",", ")", ")", ",", "\"gradcheck failed for RoIAlignRotated CPU\"", "\n", "assert", "gradcheck", "(", "func", ",", "(", "x", ".", "transpose", "(", "2", ",", "3", ")", ",", ")", ")", ",", "\"gradcheck failed for RoIAlignRotated CPU\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_roi_align_rotated.ROIAlignRotatedTest.test_roi_align_rotated_gradient_cuda": [[127, 173], ["unittest.skipIf", "torch.device", "detectron2.layers.roi_align.ROIAlign().to", "detectron2.layers.roi_align_rotated.ROIAlignRotated().to", "torch.rand", "torch.autograd.Variable", "torch.tensor", "detectron2.layers.roi_align_rotated.ROIAlignRotated().to.", "ROIAlignRotated().to.sum", "roi_align_rotated.sum.backward", "torch.tensor", "detectron2.layers.roi_align.ROIAlign().to.", "ROIAlign().to.sum", "roi_align.sum.backward", "torch.allclose", "torch.rand.data.clone", "torch.cuda.is_available", "detectron2.layers.roi_align.ROIAlign", "detectron2.layers.roi_align_rotated.ROIAlignRotated"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_roi_align_rotated_gradient_cuda", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute gradients for ROIAlignRotated with multiple bounding boxes on the GPU,\n        and compare the result with ROIAlign\n        \"\"\"", "\n", "# torch.manual_seed(123)", "\n", "dtype", "=", "torch", ".", "float64", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ")", "\n", "pool_h", ",", "pool_w", "=", "(", "5", ",", "5", ")", "\n", "\n", "roi_align", "=", "ROIAlign", "(", "output_size", "=", "(", "pool_h", ",", "pool_w", ")", ",", "spatial_scale", "=", "1", ",", "sampling_ratio", "=", "2", ")", ".", "to", "(", "\n", "device", "=", "device", "\n", ")", "\n", "\n", "roi_align_rotated", "=", "ROIAlignRotated", "(", "\n", "output_size", "=", "(", "pool_h", ",", "pool_w", ")", ",", "spatial_scale", "=", "1", ",", "sampling_ratio", "=", "2", "\n", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n", "x", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "10", ",", "10", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ",", "requires_grad", "=", "True", ")", "\n", "# x_rotated = x.clone() won't work (will lead to grad_fun=CloneBackward)!", "\n", "x_rotated", "=", "Variable", "(", "x", ".", "data", ".", "clone", "(", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# roi_rotated format is (batch index, x_center, y_center, width, height, angle)", "\n", "rois_rotated", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0", ",", "4.5", ",", "4.5", ",", "9", ",", "9", ",", "0", "]", ",", "[", "0", ",", "2", ",", "7", ",", "4", ",", "4", ",", "0", "]", ",", "[", "0", ",", "7", ",", "7", ",", "4", ",", "4", ",", "0", "]", "]", ",", "\n", "dtype", "=", "dtype", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "\n", "y_rotated", "=", "roi_align_rotated", "(", "x_rotated", ",", "rois_rotated", ")", "\n", "s_rotated", "=", "y_rotated", ".", "sum", "(", ")", "\n", "s_rotated", ".", "backward", "(", ")", "\n", "\n", "# roi format is (batch index, x1, y1, x2, y2)", "\n", "rois", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0", ",", "0", ",", "0", ",", "9", ",", "9", "]", ",", "[", "0", ",", "0", ",", "5", ",", "4", ",", "9", "]", ",", "[", "0", ",", "5", ",", "5", ",", "9", ",", "9", "]", "]", ",", "dtype", "=", "dtype", ",", "device", "=", "device", "\n", ")", "\n", "\n", "y", "=", "roi_align", "(", "x", ",", "rois", ")", "\n", "s", "=", "y", ".", "sum", "(", ")", "\n", "s", ".", "backward", "(", ")", "\n", "\n", "assert", "torch", ".", "allclose", "(", "\n", "x", ".", "grad", ",", "x_rotated", ".", "grad", "\n", ")", ",", "\"gradients for ROIAlign and ROIAlignRotated mismatch on CUDA\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.TestMaskCropPaste.setUp": [[60, 67], ["detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.isfile", "unittest.SkipTest", "contextlib.redirect_stdout", "fvcore.common.file_io.PathManager.get_local_path", "pycocotools.coco.COCO", "io.StringIO"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "json_file", "=", "MetadataCatalog", ".", "get", "(", "\"coco_2017_val_100\"", ")", ".", "json_file", "\n", "if", "not", "PathManager", ".", "isfile", "(", "json_file", ")", ":", "\n", "            ", "raise", "unittest", ".", "SkipTest", "(", "\"{} not found\"", ".", "format", "(", "json_file", ")", ")", "\n", "", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "            ", "json_file", "=", "PathManager", ".", "get_local_path", "(", "json_file", ")", "\n", "self", ".", "coco", "=", "COCO", "(", "json_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.TestMaskCropPaste.test_crop_paste_consistency": [[68, 99], ["test_mask_ops.TestMaskCropPaste.coco.loadAnns", "tqdm.tqdm", "numpy.array", "numpy.array.mean", "collections.defaultdict", "zip", "print", "test_mask_ops.TestMaskCropPaste.assertTrue", "test_mask_ops.TestMaskCropPaste.assertTrue", "test_mask_ops.TestMaskCropPaste.coco.getAnnIds", "test_mask_ops.TestMaskCropPaste.process_annotation", "numpy.array.append", "table.append", "tabulate.tabulate.tabulate"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.TestMaskCropPaste.process_annotation"], ["", "", "def", "test_crop_paste_consistency", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        rasterize_polygons_within_box (used in training)\n        and\n        paste_masks_in_image (used in inference)\n        should be inverse operations to each other.\n\n        This function runs several implementation of the above two operations and prints\n        the reconstruction error.\n        \"\"\"", "\n", "\n", "anns", "=", "self", ".", "coco", ".", "loadAnns", "(", "self", ".", "coco", ".", "getAnnIds", "(", "iscrowd", "=", "False", ")", ")", "# avoid crowd annotations", "\n", "\n", "selected_anns", "=", "anns", "[", ":", "100", "]", "\n", "\n", "ious", "=", "[", "]", "\n", "for", "ann", "in", "tqdm", ".", "tqdm", "(", "selected_anns", ")", ":", "\n", "            ", "results", "=", "self", ".", "process_annotation", "(", "ann", ")", "\n", "ious", ".", "append", "(", "[", "k", "[", "2", "]", "for", "k", "in", "results", "]", ")", "\n", "\n", "", "ious", "=", "np", ".", "array", "(", "ious", ")", "\n", "mean_ious", "=", "ious", ".", "mean", "(", "axis", "=", "0", ")", "\n", "table", "=", "[", "]", "\n", "res_dic", "=", "defaultdict", "(", "dict", ")", "\n", "for", "row", ",", "iou", "in", "zip", "(", "results", ",", "mean_ious", ")", ":", "\n", "            ", "table", ".", "append", "(", "(", "row", "[", "0", "]", ",", "row", "[", "1", "]", ",", "iou", ")", ")", "\n", "res_dic", "[", "row", "[", "0", "]", "]", "[", "row", "[", "1", "]", "]", "=", "iou", "\n", "", "print", "(", "tabulate", "(", "table", ",", "headers", "=", "[", "\"rasterize\"", ",", "\"paste\"", ",", "\"iou\"", "]", ",", "tablefmt", "=", "\"simple\"", ")", ")", "\n", "# assert that the reconstruction is good:", "\n", "self", ".", "assertTrue", "(", "res_dic", "[", "\"polygon\"", "]", "[", "\"aligned\"", "]", ">", "0.94", ")", "\n", "self", ".", "assertTrue", "(", "res_dic", "[", "\"roialign\"", "]", "[", "\"aligned\"", "]", ">", "0.95", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.TestMaskCropPaste.process_annotation": [[100, 139], ["detectron2.structures.BoxMode.convert", "detectron2.structures.masks.polygons_to_bitmask", "torch.tensor().to().reshape", "collections.defaultdict", "box_bitmasks.items", "collections.defaultdict.items", "test_mask_ops.TestMaskCropPaste.coco.loadImgs", "numpy.array", "test_mask_ops.rasterize_polygons_with_grid_sample", "detectron2.layers.mask_ops.pad_masks", "detectron2.layers.mask_ops.scale_boxes", "detectron2.layers.mask_ops.paste_mask_in_image_old", "r.items", "torch.tensor().to", "detectron2.structures.PolygonMasks().crop_and_resize", "detectron2.structures.BitMasks().crop_and_resize", "detectron2.layers.mask_ops.paste_masks_in_image", "numpy.asarray", "test_mask_ops.iou_between_full_image_bit_masks", "table.append", "detectron2.structures.Boxes", "detectron2.structures.masks.polygons_to_bitmask.astype", "torch.tensor", "detectron2.structures.PolygonMasks", "detectron2.structures.BitMasks", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.polygons_to_bitmask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.rasterize_polygons_with_grid_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.pad_masks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.scale_boxes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.paste_mask_in_image_old", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.crop_and_resize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.crop_and_resize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.paste_masks_in_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.iou_between_full_image_bit_masks"], ["", "def", "process_annotation", "(", "self", ",", "ann", ",", "mask_side_len", "=", "28", ")", ":", "\n", "# Parse annotation data", "\n", "        ", "img_info", "=", "self", ".", "coco", ".", "loadImgs", "(", "ids", "=", "[", "ann", "[", "\"image_id\"", "]", "]", ")", "[", "0", "]", "\n", "height", ",", "width", "=", "img_info", "[", "\"height\"", "]", ",", "img_info", "[", "\"width\"", "]", "\n", "gt_polygons", "=", "[", "np", ".", "array", "(", "p", ",", "dtype", "=", "np", ".", "float64", ")", "for", "p", "in", "ann", "[", "\"segmentation\"", "]", "]", "\n", "gt_bbox", "=", "BoxMode", ".", "convert", "(", "ann", "[", "\"bbox\"", "]", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "gt_bit_mask", "=", "polygons_to_bitmask", "(", "gt_polygons", ",", "height", ",", "width", ")", "\n", "\n", "# Run rasterize ..", "\n", "torch_gt_bbox", "=", "torch", ".", "tensor", "(", "gt_bbox", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "box_bitmasks", "=", "{", "\n", "\"polygon\"", ":", "PolygonMasks", "(", "[", "gt_polygons", "]", ")", ".", "crop_and_resize", "(", "torch_gt_bbox", ",", "mask_side_len", ")", "[", "0", "]", ",", "\n", "\"gridsample\"", ":", "rasterize_polygons_with_grid_sample", "(", "gt_bit_mask", ",", "gt_bbox", ",", "mask_side_len", ")", ",", "\n", "\"roialign\"", ":", "BitMasks", "(", "torch", ".", "from_numpy", "(", "gt_bit_mask", "[", "None", ",", ":", ",", ":", "]", ")", ")", ".", "crop_and_resize", "(", "\n", "torch_gt_bbox", ",", "mask_side_len", "\n", ")", "[", "0", "]", ",", "\n", "}", "\n", "\n", "# Run paste ..", "\n", "results", "=", "defaultdict", "(", "dict", ")", "\n", "for", "k", ",", "box_bitmask", "in", "box_bitmasks", ".", "items", "(", ")", ":", "\n", "            ", "padded_bitmask", ",", "scale", "=", "pad_masks", "(", "box_bitmask", "[", "None", ",", ":", ",", ":", "]", ",", "1", ")", "\n", "scaled_boxes", "=", "scale_boxes", "(", "torch_gt_bbox", ",", "scale", ")", "\n", "\n", "r", "=", "results", "[", "k", "]", "\n", "r", "[", "\"old\"", "]", "=", "paste_mask_in_image_old", "(", "\n", "padded_bitmask", "[", "0", "]", ",", "scaled_boxes", "[", "0", "]", ",", "height", ",", "width", ",", "threshold", "=", "0.5", "\n", ")", "\n", "r", "[", "\"aligned\"", "]", "=", "paste_masks_in_image", "(", "\n", "box_bitmask", "[", "None", ",", ":", ",", ":", "]", ",", "Boxes", "(", "torch_gt_bbox", ")", ",", "(", "height", ",", "width", ")", "\n", ")", "[", "0", "]", "\n", "\n", "", "table", "=", "[", "]", "\n", "for", "rasterize_method", ",", "r", "in", "results", ".", "items", "(", ")", ":", "\n", "            ", "for", "paste_method", ",", "mask", "in", "r", ".", "items", "(", ")", ":", "\n", "                ", "mask", "=", "np", ".", "asarray", "(", "mask", ")", "\n", "iou", "=", "iou_between_full_image_bit_masks", "(", "gt_bit_mask", ".", "astype", "(", "\"uint8\"", ")", ",", "mask", ")", "\n", "table", ".", "append", "(", "(", "rasterize_method", ",", "paste_method", ",", "iou", ")", ")", "\n", "", "", "return", "table", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.TestMaskCropPaste.test_polygon_area": [[140, 154], ["detectron2.structures.PolygonMasks", "test_mask_ops.TestMaskCropPaste.assertEqual", "detectron2.structures.PolygonMasks", "test_mask_ops.TestMaskCropPaste.assertEqual", "detectron2.structures.PolygonMasks.area", "detectron2.structures.PolygonMasks.area"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.area"], ["", "def", "test_polygon_area", "(", "self", ")", ":", "\n", "# Draw polygon boxes", "\n", "        ", "for", "d", "in", "[", "5.0", ",", "10.0", ",", "1000.0", "]", ":", "\n", "            ", "polygon", "=", "PolygonMasks", "(", "[", "[", "[", "0", ",", "0", ",", "0", ",", "d", ",", "d", ",", "d", ",", "d", ",", "0", "]", "]", "]", ")", "\n", "area", "=", "polygon", ".", "area", "(", ")", "[", "0", "]", "\n", "target", "=", "d", "**", "2", "\n", "self", ".", "assertEqual", "(", "area", ",", "target", ")", "\n", "\n", "# Draw polygon triangles", "\n", "", "for", "d", "in", "[", "5.0", ",", "10.0", ",", "1000.0", "]", ":", "\n", "            ", "polygon", "=", "PolygonMasks", "(", "[", "[", "[", "0", ",", "0", ",", "0", ",", "d", ",", "d", ",", "d", "]", "]", "]", ")", "\n", "area", "=", "polygon", ".", "area", "(", ")", "[", "0", "]", "\n", "target", "=", "d", "**", "2", "/", "2", "\n", "self", ".", "assertEqual", "(", "area", ",", "target", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.iou_between_full_image_bit_masks": [[28, 32], ["None"], "function", ["None"], ["def", "iou_between_full_image_bit_masks", "(", "a", ",", "b", ")", ":", "\n", "    ", "intersect", "=", "(", "a", "&", "b", ")", ".", "sum", "(", ")", "\n", "union", "=", "(", "a", "|", "b", ")", ".", "sum", "(", ")", "\n", "return", "intersect", "/", "union", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.rasterize_polygons_with_grid_sample": [[34, 57], ["torch.meshgrid", "torch.stack().to", "torch.from_numpy", "torch.nn.functional.grid_sample", "numpy.arange", "numpy.arange", "torch.from_numpy", "torch.from_numpy", "full_image_bit_mask[].to", "torch.stack"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "rasterize_polygons_with_grid_sample", "(", "full_image_bit_mask", ",", "box", ",", "mask_size", ",", "threshold", "=", "0.5", ")", ":", "\n", "    ", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "box", "[", "0", "]", ",", "box", "[", "1", "]", ",", "box", "[", "2", "]", ",", "box", "[", "3", "]", "\n", "\n", "img_h", ",", "img_w", "=", "full_image_bit_mask", ".", "shape", "\n", "\n", "mask_y", "=", "np", ".", "arange", "(", "0.0", ",", "mask_size", ")", "+", "0.5", "# mask y sample coords in [0.5, mask_size - 0.5]", "\n", "mask_x", "=", "np", ".", "arange", "(", "0.0", ",", "mask_size", ")", "+", "0.5", "# mask x sample coords in [0.5, mask_size - 0.5]", "\n", "mask_y", "=", "mask_y", "/", "mask_size", "*", "(", "y1", "-", "y0", ")", "+", "y0", "\n", "mask_x", "=", "mask_x", "/", "mask_size", "*", "(", "x1", "-", "x0", ")", "+", "x0", "\n", "\n", "mask_x", "=", "(", "mask_x", "-", "0.5", ")", "/", "(", "img_w", "-", "1", ")", "*", "2", "+", "-", "1", "\n", "mask_y", "=", "(", "mask_y", "-", "0.5", ")", "/", "(", "img_h", "-", "1", ")", "*", "2", "+", "-", "1", "\n", "gy", ",", "gx", "=", "torch", ".", "meshgrid", "(", "torch", ".", "from_numpy", "(", "mask_y", ")", ",", "torch", ".", "from_numpy", "(", "mask_x", ")", ")", "\n", "ind", "=", "torch", ".", "stack", "(", "[", "gx", ",", "gy", "]", ",", "dim", "=", "-", "1", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "full_image_bit_mask", "=", "torch", ".", "from_numpy", "(", "full_image_bit_mask", ")", "\n", "mask", "=", "F", ".", "grid_sample", "(", "\n", "full_image_bit_mask", "[", "None", ",", "None", ",", ":", ",", ":", "]", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "ind", "[", "None", ",", ":", ",", ":", ",", ":", "]", ",", "\n", "align_corners", "=", "True", ",", "\n", ")", "\n", "\n", "return", "mask", "[", "0", ",", "0", "]", ">=", "threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_mask_ops.benchmark_paste": [[156, 186], ["torch.manual_seed", "torch.rand", "torch.clamp", "torch.clamp", "torch.clamp", "detectron2.structures.Boxes", "torch.cuda.is_available", "fvcore.common.benchmark.benchmark", "torch.cat", "torch.rand.to", "detectron2.structures.Boxes.to", "specs.append", "torch.rand", "range", "torch.device", "torch.randn", "detectron2.layers.mask_ops.paste_masks_in_image", "torch.cuda.synchronize", "torch.device"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.paste_masks_in_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["", "", "", "def", "benchmark_paste", "(", ")", ":", "\n", "    ", "S", "=", "800", "\n", "H", ",", "W", "=", "image_shape", "=", "(", "S", ",", "S", ")", "\n", "N", "=", "64", "\n", "torch", ".", "manual_seed", "(", "42", ")", "\n", "masks", "=", "torch", ".", "rand", "(", "N", ",", "28", ",", "28", ")", "\n", "\n", "center", "=", "torch", ".", "rand", "(", "N", ",", "2", ")", "*", "600", "+", "100", "\n", "wh", "=", "torch", ".", "clamp", "(", "torch", ".", "randn", "(", "N", ",", "2", ")", "*", "40", "+", "200", ",", "min", "=", "50", ")", "\n", "x0y0", "=", "torch", ".", "clamp", "(", "center", "-", "wh", "*", "0.5", ",", "min", "=", "0.0", ")", "\n", "x1y1", "=", "torch", ".", "clamp", "(", "center", "+", "wh", "*", "0.5", ",", "max", "=", "S", ")", "\n", "boxes", "=", "Boxes", "(", "torch", ".", "cat", "(", "[", "x0y0", ",", "x1y1", "]", ",", "axis", "=", "1", ")", ")", "\n", "\n", "def", "func", "(", "device", ",", "n", "=", "3", ")", ":", "\n", "        ", "m", "=", "masks", ".", "to", "(", "device", "=", "device", ")", "\n", "b", "=", "boxes", ".", "to", "(", "device", "=", "device", ")", "\n", "\n", "def", "bench", "(", ")", ":", "\n", "            ", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "                ", "paste_masks_in_image", "(", "m", ",", "b", ",", "image_shape", ")", "\n", "", "if", "device", ".", "type", "==", "\"cuda\"", ":", "\n", "                ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "\n", "", "", "return", "bench", "\n", "\n", "", "specs", "=", "[", "{", "\"device\"", ":", "torch", ".", "device", "(", "\"cpu\"", ")", ",", "\"n\"", ":", "3", "}", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "specs", ".", "append", "(", "{", "\"device\"", ":", "torch", ".", "device", "(", "\"cuda\"", ")", ",", "\"n\"", ":", "3", "}", ")", "\n", "\n", "", "benchmark", "(", "func", ",", "\"paste_masks\"", ",", "specs", ",", "num_iters", "=", "10", ",", "warmup_iters", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms.TestNMS._create_tensors": [[11, 20], ["torch.rand", "torch.rand"], "methods", ["None"], ["    ", "def", "_create_tensors", "(", "self", ",", "N", ")", ":", "\n", "        ", "boxes", "=", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "100", "\n", "# Note: the implementation of this function in torchvision is:", "\n", "# boxes[:, 2:] += torch.rand(N, 2) * 100", "\n", "# but it does not guarantee non-negative widths/heights constraints:", "\n", "# boxes[:, 2] >= boxes[:, 0] and boxes[:, 3] >= boxes[:, 1]:", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "\n", "scores", "=", "torch", ".", "rand", "(", "N", ")", "\n", "return", "boxes", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms.TestNMS.test_nms_scriptability": [[21, 36], ["unittest.skipIf", "test_nms.TestNMS._create_tensors", "torch.randint", "torch.jit.script", "detectron2.layers.batched_nms", "boxes.clone", "torch.jit.script.", "torch.allclose", "test_nms.TestNMS.assertTrue", "torch.equal", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "@", "unittest", ".", "skipIf", "(", "TORCH_VERSION", "<", "(", "1", ",", "6", ")", ",", "\"Insufficient pytorch version\"", ")", "\n", "def", "test_nms_scriptability", "(", "self", ")", ":", "\n", "        ", "N", "=", "2000", "\n", "num_classes", "=", "50", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "idxs", "=", "torch", ".", "randint", "(", "0", ",", "num_classes", ",", "(", "N", ",", ")", ")", "\n", "scripted_batched_nms", "=", "torch", ".", "jit", ".", "script", "(", "batched_nms", ")", "\n", "err_msg", "=", "\"NMS is incompatible with jit-scripted NMS for IoU={}\"", "\n", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "keep_ref", "=", "batched_nms", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou", ")", "\n", "backup", "=", "boxes", ".", "clone", "(", ")", "\n", "scripted_keep", "=", "scripted_batched_nms", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou", ")", "\n", "assert", "torch", ".", "allclose", "(", "boxes", ",", "backup", ")", ",", "\"boxes modified by jit-scripted batched_nms\"", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "keep_ref", ",", "scripted_keep", ")", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.reference_horizontal_nms": [[41, 64], ["scores.sort", "torch.as_tensor", "len", "picked.append", "torchvision.ops.box_iou().squeeze", "current.item", "len", "torchvision.ops.box_iou", "current_box.unsqueeze"], "methods", ["None"], ["    ", "def", "reference_horizontal_nms", "(", "self", ",", "boxes", ",", "scores", ",", "iou_threshold", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            box_scores (N, 5): boxes in corner-form and probabilities.\n                (Note here 5 == 4 + 1, i.e., 4-dim horizontal box + 1-dim prob)\n            iou_threshold: intersection over union threshold.\n        Returns:\n             picked: a list of indexes of the kept boxes\n        \"\"\"", "\n", "picked", "=", "[", "]", "\n", "_", ",", "indexes", "=", "scores", ".", "sort", "(", "descending", "=", "True", ")", "\n", "while", "len", "(", "indexes", ")", ">", "0", ":", "\n", "            ", "current", "=", "indexes", "[", "0", "]", "\n", "picked", ".", "append", "(", "current", ".", "item", "(", ")", ")", "\n", "if", "len", "(", "indexes", ")", "==", "1", ":", "\n", "                ", "break", "\n", "", "current_box", "=", "boxes", "[", "current", ",", ":", "]", "\n", "indexes", "=", "indexes", "[", "1", ":", "]", "\n", "rest_boxes", "=", "boxes", "[", "indexes", ",", ":", "]", "\n", "iou", "=", "ops", ".", "box_iou", "(", "rest_boxes", ",", "current_box", ".", "unsqueeze", "(", "0", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "indexes", "=", "indexes", "[", "iou", "<=", "iou_threshold", "]", "\n", "\n", "", "return", "torch", ".", "as_tensor", "(", "picked", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated._create_tensors": [[65, 74], ["torch.rand", "torch.rand"], "methods", ["None"], ["", "def", "_create_tensors", "(", "self", ",", "N", ")", ":", "\n", "        ", "boxes", "=", "torch", ".", "rand", "(", "N", ",", "4", ")", "*", "100", "\n", "# Note: the implementation of this function in torchvision is:", "\n", "# boxes[:, 2:] += torch.rand(N, 2) * 100", "\n", "# but it does not guarantee non-negative widths/heights constraints:", "\n", "# boxes[:, 2] >= boxes[:, 0] and boxes[:, 3] >= boxes[:, 1]:", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "\n", "scores", "=", "torch", ".", "rand", "(", "N", ")", "\n", "return", "boxes", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.test_batched_nms_rotated_0_degree_cpu": [[75, 96], ["test_nms_rotated.TestNMSRotated._create_tensors", "torch.randint", "torch.zeros", "boxes.clone", "detectron2.layers.batched_nms", "torch.allclose", "torch.zeros.clone", "detectron2.layers.batched_nms_rotated", "torch.allclose", "test_nms_rotated.TestNMSRotated.assertLessEqual", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.nms_edit_distance"], ["", "def", "test_batched_nms_rotated_0_degree_cpu", "(", "self", ")", ":", "\n", "        ", "N", "=", "2000", "\n", "num_classes", "=", "50", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "idxs", "=", "torch", ".", "randint", "(", "0", ",", "num_classes", ",", "(", "N", ",", ")", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "err_msg", "=", "\"Rotated NMS with 0 degree is incompatible with horizontal NMS for IoU={}\"", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "backup", "=", "boxes", ".", "clone", "(", ")", "\n", "keep_ref", "=", "batched_nms", "(", "boxes", ",", "scores", ",", "idxs", ",", "iou", ")", "\n", "assert", "torch", ".", "allclose", "(", "boxes", ",", "backup", ")", ",", "\"boxes modified by batched_nms\"", "\n", "backup", "=", "rotated_boxes", ".", "clone", "(", ")", "\n", "keep", "=", "batched_nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "idxs", ",", "iou", ")", "\n", "assert", "torch", ".", "allclose", "(", "\n", "rotated_boxes", ",", "backup", "\n", ")", ",", "\"rotated_boxes modified by batched_nms_rotated\"", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.test_batched_nms_rotated_0_degree_cuda": [[97, 120], ["unittest.skipIf", "test_nms_rotated.TestNMSRotated._create_tensors", "torch.randint", "torch.zeros", "boxes.clone", "detectron2.layers.batched_nms", "test_nms_rotated.TestNMSRotated.assertTrue", "torch.zeros.clone", "detectron2.layers.batched_nms_rotated", "test_nms_rotated.TestNMSRotated.assertTrue", "test_nms_rotated.TestNMSRotated.assertLessEqual", "torch.cuda.is_available", "boxes.cuda", "scores.cuda", "torch.allclose", "torch.zeros.cuda", "scores.cuda", "torch.allclose", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.nms_edit_distance"], ["", "", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_batched_nms_rotated_0_degree_cuda", "(", "self", ")", ":", "\n", "        ", "N", "=", "2000", "\n", "num_classes", "=", "50", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "idxs", "=", "torch", ".", "randint", "(", "0", ",", "num_classes", ",", "(", "N", ",", ")", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "err_msg", "=", "\"Rotated NMS with 0 degree is incompatible with horizontal NMS for IoU={}\"", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "backup", "=", "boxes", ".", "clone", "(", ")", "\n", "keep_ref", "=", "batched_nms", "(", "boxes", ".", "cuda", "(", ")", ",", "scores", ".", "cuda", "(", ")", ",", "idxs", ",", "iou", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "boxes", ",", "backup", ")", ",", "\"boxes modified by batched_nms\"", ")", "\n", "backup", "=", "rotated_boxes", ".", "clone", "(", ")", "\n", "keep", "=", "batched_nms_rotated", "(", "rotated_boxes", ".", "cuda", "(", ")", ",", "scores", ".", "cuda", "(", ")", ",", "idxs", ",", "iou", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "rotated_boxes", ",", "backup", ")", ",", "\n", "\"rotated_boxes modified by batched_nms_rotated\"", ",", "\n", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "2", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.test_nms_rotated_0_degree_cpu": [[121, 134], ["test_nms_rotated.TestNMSRotated._create_tensors", "torch.zeros", "test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "detectron2.layers.nms_rotated", "test_nms_rotated.TestNMSRotated.assertLessEqual", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.nms_edit_distance"], ["", "", "def", "test_nms_rotated_0_degree_cpu", "(", "self", ")", ":", "\n", "        ", "N", "=", "1000", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "err_msg", "=", "\"Rotated NMS incompatible between CPU and reference implementation for IoU={}\"", "\n", "for", "iou", "in", "[", "0.5", "]", ":", "\n", "            ", "keep_ref", "=", "self", ".", "reference_horizontal_nms", "(", "boxes", ",", "scores", ",", "iou", ")", "\n", "keep", "=", "nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "iou", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.test_nms_rotated_90_degrees_cpu": [[135, 153], ["test_nms_rotated.TestNMSRotated._create_tensors", "torch.zeros", "torch.ones", "test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "detectron2.layers.nms_rotated", "test_nms_rotated.TestNMSRotated.assertLessEqual", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.nms_edit_distance"], ["", "", "def", "test_nms_rotated_90_degrees_cpu", "(", "self", ")", ":", "\n", "        ", "N", "=", "1000", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "# Note for rotated_boxes[:, 2] and rotated_boxes[:, 3]:", "\n", "# widths and heights are intentionally swapped here for 90 degrees case", "\n", "# so that the reference horizontal nms could be used", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "\n", "rotated_boxes", "[", ":", ",", "4", "]", "=", "torch", ".", "ones", "(", "N", ")", "*", "90", "\n", "err_msg", "=", "\"Rotated NMS incompatible between CPU and reference implementation for IoU={}\"", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "keep_ref", "=", "self", ".", "reference_horizontal_nms", "(", "boxes", ",", "scores", ",", "iou", ")", "\n", "keep", "=", "nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "iou", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.test_nms_rotated_180_degrees_cpu": [[154, 168], ["test_nms_rotated.TestNMSRotated._create_tensors", "torch.zeros", "torch.ones", "test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "detectron2.layers.nms_rotated", "test_nms_rotated.TestNMSRotated.assertLessEqual", "test_nms_rotated.nms_edit_distance", "err_msg.format"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.reference_horizontal_nms", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.nms_edit_distance"], ["", "", "def", "test_nms_rotated_180_degrees_cpu", "(", "self", ")", ":", "\n", "        ", "N", "=", "1000", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "rotated_boxes", "[", ":", ",", "4", "]", "=", "torch", ".", "ones", "(", "N", ")", "*", "180", "\n", "err_msg", "=", "\"Rotated NMS incompatible between CPU and reference implementation for IoU={}\"", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "keep_ref", "=", "self", ".", "reference_horizontal_nms", "(", "boxes", ",", "scores", ",", "iou", ")", "\n", "keep", "=", "nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "iou", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "keep", ",", "keep_ref", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated.test_nms_rotated_0_degree_cuda": [[169, 184], ["unittest.skipIf", "test_nms_rotated.TestNMSRotated._create_tensors", "torch.zeros", "detectron2.layers.nms_rotated", "detectron2.layers.nms_rotated", "test_nms_rotated.TestNMSRotated.assertLessEqual", "torch.cuda.is_available", "torch.zeros.cuda", "scores.cuda", "test_nms_rotated.nms_edit_distance", "err_msg.format", "detectron2.layers.nms_rotated.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.TestNMSRotated._create_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.nms_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.nms_edit_distance"], ["", "", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_nms_rotated_0_degree_cuda", "(", "self", ")", ":", "\n", "        ", "N", "=", "1000", "\n", "boxes", ",", "scores", "=", "self", ".", "_create_tensors", "(", "N", ")", "\n", "rotated_boxes", "=", "torch", ".", "zeros", "(", "N", ",", "5", ")", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "=", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "2.0", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", "\n", "err_msg", "=", "\"Rotated NMS incompatible between CPU and CUDA for IoU={}\"", "\n", "\n", "for", "iou", "in", "[", "0.2", ",", "0.5", ",", "0.8", "]", ":", "\n", "            ", "r_cpu", "=", "nms_rotated", "(", "rotated_boxes", ",", "scores", ",", "iou", ")", "\n", "r_cuda", "=", "nms_rotated", "(", "rotated_boxes", ".", "cuda", "(", ")", ",", "scores", ".", "cuda", "(", ")", ",", "iou", ")", "\n", "self", ".", "assertLessEqual", "(", "nms_edit_distance", "(", "r_cpu", ",", "r_cuda", ".", "cpu", "(", ")", ")", ",", "1", ",", "err_msg", ".", "format", "(", "iou", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.test_nms_rotated.nms_edit_distance": [[11, 38], ["torch.equal", "range", "tuple", "tuple", "len", "len", "numpy.arange", "numpy.arange", "range", "keep1.cpu", "keep2.cpu", "min", "min"], "function", ["None"], ["def", "nms_edit_distance", "(", "keep1", ",", "keep2", ")", ":", "\n", "    ", "\"\"\"\n    Compare the \"keep\" result of two nms call.\n    They are allowed to be different in terms of edit distance\n    due to floating point precision issues, e.g.,\n    if a box happen to have an IoU of 0.5 with another box,\n    one implentation may choose to keep it while another may discard it.\n    \"\"\"", "\n", "if", "torch", ".", "equal", "(", "keep1", ",", "keep2", ")", ":", "\n", "# they should be equal most of the time", "\n", "        ", "return", "0", "\n", "", "keep1", ",", "keep2", "=", "tuple", "(", "keep1", ".", "cpu", "(", ")", ")", ",", "tuple", "(", "keep2", ".", "cpu", "(", ")", ")", "\n", "m", ",", "n", "=", "len", "(", "keep1", ")", ",", "len", "(", "keep2", ")", "\n", "\n", "# edit distance with DP", "\n", "f", "=", "[", "np", ".", "arange", "(", "n", "+", "1", ")", ",", "np", ".", "arange", "(", "n", "+", "1", ")", "]", "\n", "for", "i", "in", "range", "(", "m", ")", ":", "\n", "        ", "cur_row", "=", "i", "%", "2", "\n", "other_row", "=", "(", "i", "+", "1", ")", "%", "2", "\n", "f", "[", "other_row", "]", "[", "0", "]", "=", "i", "+", "1", "\n", "for", "j", "in", "range", "(", "n", ")", ":", "\n", "            ", "f", "[", "other_row", "]", "[", "j", "+", "1", "]", "=", "(", "\n", "f", "[", "cur_row", "]", "[", "j", "]", "\n", "if", "keep1", "[", "i", "]", "==", "keep2", "[", "j", "]", "\n", "else", "min", "(", "min", "(", "f", "[", "cur_row", "]", "[", "j", "]", ",", "f", "[", "cur_row", "]", "[", "j", "+", "1", "]", ")", ",", "f", "[", "other_row", "]", "[", "j", "]", ")", "+", "1", "\n", ")", "\n", "", "", "return", "f", "[", "m", "%", "2", "]", "[", "n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.ModelCatalog.get": [[56, 63], ["name.startswith", "name.startswith", "RuntimeError", "catalog.ModelCatalog._get_c2_detectron_baseline", "catalog.ModelCatalog._get_c2_imagenet_pretrained"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.ModelCatalog._get_c2_detectron_baseline", "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.ModelCatalog._get_c2_imagenet_pretrained"], ["@", "staticmethod", "\n", "def", "get", "(", "name", ")", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "\"Caffe2Detectron/COCO\"", ")", ":", "\n", "            ", "return", "ModelCatalog", ".", "_get_c2_detectron_baseline", "(", "name", ")", "\n", "", "if", "name", ".", "startswith", "(", "\"ImageNetPretrained/\"", ")", ":", "\n", "            ", "return", "ModelCatalog", ".", "_get_c2_imagenet_pretrained", "(", "name", ")", "\n", "", "raise", "RuntimeError", "(", "\"model not present in the catalog: {}\"", ".", "format", "(", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.ModelCatalog._get_c2_imagenet_pretrained": [[64, 71], ["len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_c2_imagenet_pretrained", "(", "name", ")", ":", "\n", "        ", "prefix", "=", "ModelCatalog", ".", "S3_C2_DETECTRON_PREFIX", "\n", "name", "=", "name", "[", "len", "(", "\"ImageNetPretrained/\"", ")", ":", "]", "\n", "name", "=", "ModelCatalog", ".", "C2_IMAGENET_MODELS", "[", "name", "]", "\n", "url", "=", "\"/\"", ".", "join", "(", "[", "prefix", ",", "name", "]", ")", "\n", "return", "url", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.ModelCatalog._get_c2_detectron_baseline": [[72, 92], ["ModelCatalog.C2_DETECTRON_PATH_FORMAT.format", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_c2_detectron_baseline", "(", "name", ")", ":", "\n", "        ", "name", "=", "name", "[", "len", "(", "\"Caffe2Detectron/COCO/\"", ")", ":", "]", "\n", "url", "=", "ModelCatalog", ".", "C2_DETECTRON_MODELS", "[", "name", "]", "\n", "if", "\"keypoint_rcnn\"", "in", "name", ":", "\n", "            ", "dataset", "=", "ModelCatalog", ".", "C2_DATASET_COCO_KEYPOINTS", "\n", "", "else", ":", "\n", "            ", "dataset", "=", "ModelCatalog", ".", "C2_DATASET_COCO", "\n", "\n", "", "if", "\"35998355/rpn_R-50-C4_1x\"", "in", "name", ":", "\n", "# this one model is somehow different from others ..", "\n", "            ", "type", "=", "\"rpn\"", "\n", "", "else", ":", "\n", "            ", "type", "=", "\"generalized_rcnn\"", "\n", "\n", "# Detectron C2 models are stored in the structure defined in `C2_DETECTRON_PATH_FORMAT`.", "\n", "", "url", "=", "ModelCatalog", ".", "C2_DETECTRON_PATH_FORMAT", ".", "format", "(", "\n", "prefix", "=", "ModelCatalog", ".", "S3_C2_DETECTRON_PREFIX", ",", "url", "=", "url", ",", "type", "=", "type", ",", "dataset", "=", "dataset", "\n", ")", "\n", "return", "url", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.ModelCatalogHandler._get_supported_prefixes": [[101, 103], ["None"], "methods", ["None"], ["def", "_get_supported_prefixes", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "PREFIX", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.ModelCatalogHandler._get_local_path": [[104, 109], ["logging.getLogger", "catalog.ModelCatalog.get", "logging.getLogger.info", "fvcore.common.file_io.PathManager.get_local_path", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "_get_local_path", "(", "self", ",", "path", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "catalog_path", "=", "ModelCatalog", ".", "get", "(", "path", "[", "len", "(", "self", ".", "PREFIX", ")", ":", "]", ")", "\n", "logger", ".", "info", "(", "\"Catalog entry {} points to {}\"", ".", "format", "(", "path", ",", "catalog_path", ")", ")", "\n", "return", "PathManager", ".", "get_local_path", "(", "catalog_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.ModelCatalogHandler._open": [[110, 112], ["fvcore.common.file_io.PathManager.open", "catalog.ModelCatalogHandler._get_local_path"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.Detectron2Handler._get_local_path"], ["", "def", "_open", "(", "self", ",", "path", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "PathManager", ".", "open", "(", "self", ".", "_get_local_path", "(", "path", ")", ",", "mode", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.Detectron2Handler._get_supported_prefixes": [[122, 124], ["None"], "methods", ["None"], ["def", "_get_supported_prefixes", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "PREFIX", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.Detectron2Handler._get_local_path": [[125, 128], ["fvcore.common.file_io.PathManager.get_local_path", "len"], "methods", ["None"], ["", "def", "_get_local_path", "(", "self", ",", "path", ")", ":", "\n", "        ", "name", "=", "path", "[", "len", "(", "self", ".", "PREFIX", ")", ":", "]", "\n", "return", "PathManager", ".", "get_local_path", "(", "self", ".", "S3_DETECTRON2_PREFIX", "+", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.Detectron2Handler._open": [[129, 131], ["fvcore.common.file_io.PathManager.open", "catalog.Detectron2Handler._get_local_path"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.catalog.Detectron2Handler._get_local_path"], ["", "def", "_open", "(", "self", ",", "path", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "PathManager", ".", "open", "(", "self", ".", "_get_local_path", "(", "path", ")", ",", "mode", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.detection_checkpoint.DetectionCheckpointer.__init__": [[17, 24], ["detectron2.is_main_process", "fvcore.common.checkpoint.Checkpointer.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "save_dir", "=", "\"\"", ",", "*", ",", "save_to_disk", "=", "None", ",", "**", "checkpointables", ")", ":", "\n", "        ", "is_main_process", "=", "comm", ".", "is_main_process", "(", ")", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "model", ",", "\n", "save_dir", ",", "\n", "save_to_disk", "=", "is_main_process", "if", "save_to_disk", "is", "None", "else", "save_to_disk", ",", "\n", "**", "checkpointables", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.detection_checkpoint.DetectionCheckpointer._load_file": [[26, 46], ["filename.endswith", "super()._load_file", "fvcore.common.file_io.PathManager.open", "pickle.load", "detection_checkpoint.DetectionCheckpointer.logger.info", "pickle.load.items", "k.endswith"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.detection_checkpoint.DetectionCheckpointer._load_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load"], ["", "def", "_load_file", "(", "self", ",", "filename", ")", ":", "\n", "        ", "if", "filename", ".", "endswith", "(", "\".pkl\"", ")", ":", "\n", "            ", "with", "PathManager", ".", "open", "(", "filename", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ",", "encoding", "=", "\"latin1\"", ")", "\n", "", "if", "\"model\"", "in", "data", "and", "\"__author__\"", "in", "data", ":", "\n", "# file is in Detectron2 model zoo format", "\n", "                ", "self", ".", "logger", ".", "info", "(", "\"Reading a file from '{}'\"", ".", "format", "(", "data", "[", "\"__author__\"", "]", ")", ")", "\n", "return", "data", "\n", "", "else", ":", "\n", "# assume file is from Caffe2 / Detectron1 model zoo", "\n", "                ", "if", "\"blobs\"", "in", "data", ":", "\n", "# Detection models have \"blobs\", but ImageNet models don't", "\n", "                    ", "data", "=", "data", "[", "\"blobs\"", "]", "\n", "", "data", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", "if", "not", "k", ".", "endswith", "(", "\"_momentum\"", ")", "}", "\n", "return", "{", "\"model\"", ":", "data", ",", "\"__author__\"", ":", "\"Caffe2\"", ",", "\"matching_heuristics\"", ":", "True", "}", "\n", "\n", "", "", "loaded", "=", "super", "(", ")", ".", "_load_file", "(", "filename", ")", "# load native pth checkpoint", "\n", "if", "\"model\"", "not", "in", "loaded", ":", "\n", "            ", "loaded", "=", "{", "\"model\"", ":", "loaded", "}", "\n", "", "return", "loaded", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.detection_checkpoint.DetectionCheckpointer._load_model": [[47, 74], ["checkpoint.get", "super()._load_model", "dict", "detection_checkpoint.DetectionCheckpointer._convert_ndarray_to_tensor", "detection_checkpoint.DetectionCheckpointer.model.state_dict", "c2_model_loading.align_and_update_state_dicts", "detection_checkpoint.DetectionCheckpointer.model.named_buffers", "super()._load_model.missing_keys.remove", "checkpoint.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.detection_checkpoint.DetectionCheckpointer._load_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.c2_model_loading.align_and_update_state_dicts", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "_load_model", "(", "self", ",", "checkpoint", ")", ":", "\n", "        ", "if", "checkpoint", ".", "get", "(", "\"matching_heuristics\"", ",", "False", ")", ":", "\n", "            ", "self", ".", "_convert_ndarray_to_tensor", "(", "checkpoint", "[", "\"model\"", "]", ")", "\n", "# convert weights by name-matching heuristics", "\n", "model_state_dict", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "align_and_update_state_dicts", "(", "\n", "model_state_dict", ",", "\n", "checkpoint", "[", "\"model\"", "]", ",", "\n", "c2_conversion", "=", "checkpoint", ".", "get", "(", "\"__author__\"", ",", "None", ")", "==", "\"Caffe2\"", ",", "\n", ")", "\n", "checkpoint", "[", "\"model\"", "]", "=", "model_state_dict", "\n", "# for non-caffe2 models, use standard ways to load it", "\n", "", "incompatible", "=", "super", "(", ")", ".", "_load_model", "(", "checkpoint", ")", "\n", "if", "incompatible", "is", "None", ":", "# support older versions of fvcore", "\n", "            ", "return", "None", "\n", "\n", "", "model_buffers", "=", "dict", "(", "self", ".", "model", ".", "named_buffers", "(", "recurse", "=", "False", ")", ")", "\n", "for", "k", "in", "[", "\"pixel_mean\"", ",", "\"pixel_std\"", "]", ":", "\n", "# Ignore missing key message about pixel_mean/std.", "\n", "# Though they may be missing in old checkpoints, they will be correctly", "\n", "# initialized from config anyway.", "\n", "            ", "if", "k", "in", "model_buffers", ":", "\n", "                ", "try", ":", "\n", "                    ", "incompatible", ".", "missing_keys", ".", "remove", "(", "k", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "pass", "\n", "", "", "", "return", "incompatible", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.c2_model_loading.convert_basic_c2_names": [[12, 66], ["copy.deepcopy", "k.replace", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "k.replace", "k.replace", "k.replace", "k.replace", "re.sub", "k.replace", "k.replace", "k.replace", "k.replace"], "function", ["None"], ["def", "convert_basic_c2_names", "(", "original_keys", ")", ":", "\n", "    ", "\"\"\"\n    Apply some basic name conversion to names in C2 weights.\n    It only deals with typical backbone models.\n\n    Args:\n        original_keys (list[str]):\n    Returns:\n        list[str]: The same number of strings matching those in original_keys.\n    \"\"\"", "\n", "layer_keys", "=", "copy", ".", "deepcopy", "(", "original_keys", ")", "\n", "layer_keys", "=", "[", "\n", "{", "\"pred_b\"", ":", "\"linear_b\"", ",", "\"pred_w\"", ":", "\"linear_w\"", "}", ".", "get", "(", "k", ",", "k", ")", "for", "k", "in", "layer_keys", "\n", "]", "# some hard-coded mappings", "\n", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"_\"", ",", "\".\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"\\\\.b$\"", ",", "\".bias\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"\\\\.w$\"", ",", "\".weight\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "# Uniform both bn and gn names to \"norm\"", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.s$\"", ",", "\"norm.weight\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.bias$\"", ",", "\"norm.bias\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.rm\"", ",", "\"norm.running_mean\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.running.mean$\"", ",", "\"norm.running_mean\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.riv$\"", ",", "\"norm.running_var\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.running.var$\"", ",", "\"norm.running_var\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.gamma$\"", ",", "\"norm.weight\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"bn\\\\.beta$\"", ",", "\"norm.bias\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"gn\\\\.s$\"", ",", "\"norm.weight\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"gn\\\\.bias$\"", ",", "\"norm.bias\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# stem", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^res\\\\.conv1\\\\.norm\\\\.\"", ",", "\"conv1.norm.\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "# to avoid mis-matching with \"conv1\" in other components (e.g. detection head)", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^conv1\\\\.\"", ",", "\"stem.conv1.\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# layer1-4 is used by torchvision, however we follow the C2 naming strategy (res2-5)", "\n", "# layer_keys = [re.sub(\"^res2.\", \"layer1.\", k) for k in layer_keys]", "\n", "# layer_keys = [re.sub(\"^res3.\", \"layer2.\", k) for k in layer_keys]", "\n", "# layer_keys = [re.sub(\"^res4.\", \"layer3.\", k) for k in layer_keys]", "\n", "# layer_keys = [re.sub(\"^res5.\", \"layer4.\", k) for k in layer_keys]", "\n", "\n", "# blocks", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch1.\"", ",", "\".shortcut.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2a.\"", ",", "\".conv1.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2b.\"", ",", "\".conv2.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".branch2c.\"", ",", "\".conv3.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# DensePose substitutions", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^body.conv.fcn\"", ",", "\"body_conv_fcn\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"AnnIndex.lowres\"", ",", "\"ann_index_lowres\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"Index.UV.lowres\"", ",", "\"index_uv_lowres\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"U.lowres\"", ",", "\"u_lowres\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"V.lowres\"", ",", "\"v_lowres\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "return", "layer_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.c2_model_loading.convert_c2_detectron_names": [[68, 207], ["logging.getLogger", "logging.getLogger.info", "sorted", "copy.deepcopy", "c2_model_loading.convert_basic_c2_names", "zip", "weights.keys", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "k.replace", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "name.split", "name.startswith", "c2_model_loading.convert_c2_detectron_names.fpn_map"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.c2_model_loading.convert_basic_c2_names"], ["", "def", "convert_c2_detectron_names", "(", "weights", ")", ":", "\n", "    ", "\"\"\"\n    Map Caffe2 Detectron weight names to Detectron2 names.\n\n    Args:\n        weights (dict): name -> tensor\n\n    Returns:\n        dict: detectron2 names -> tensor\n        dict: detectron2 names -> C2 names\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Remapping C2 weights ......\"", ")", "\n", "original_keys", "=", "sorted", "(", "weights", ".", "keys", "(", ")", ")", "\n", "layer_keys", "=", "copy", ".", "deepcopy", "(", "original_keys", ")", "\n", "\n", "layer_keys", "=", "convert_basic_c2_names", "(", "layer_keys", ")", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# RPN hidden representation conv", "\n", "# --------------------------------------------------------------------------", "\n", "# FPN case", "\n", "# In the C2 model, the RPN hidden layer conv is defined for FPN level 2 and then", "\n", "# shared for all other levels, hence the appearance of \"fpn2\"", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"conv.rpn.fpn2\"", ",", "\"proposal_generator.rpn_head.conv\"", ")", "for", "k", "in", "layer_keys", "\n", "]", "\n", "# Non-FPN case", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv.rpn\"", ",", "\"proposal_generator.rpn_head.conv\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# RPN box transformation conv", "\n", "# --------------------------------------------------------------------------", "\n", "# FPN case (see note above about \"fpn2\")", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"rpn.bbox.pred.fpn2\"", ",", "\"proposal_generator.rpn_head.anchor_deltas\"", ")", "\n", "for", "k", "in", "layer_keys", "\n", "]", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"rpn.cls.logits.fpn2\"", ",", "\"proposal_generator.rpn_head.objectness_logits\"", ")", "\n", "for", "k", "in", "layer_keys", "\n", "]", "\n", "# Non-FPN case", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"rpn.bbox.pred\"", ",", "\"proposal_generator.rpn_head.anchor_deltas\"", ")", "for", "k", "in", "layer_keys", "\n", "]", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"rpn.cls.logits\"", ",", "\"proposal_generator.rpn_head.objectness_logits\"", ")", "\n", "for", "k", "in", "layer_keys", "\n", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# Fast R-CNN box head", "\n", "# --------------------------------------------------------------------------", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^bbox\\\\.pred\"", ",", "\"bbox_pred\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^cls\\\\.score\"", ",", "\"cls_score\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^fc6\\\\.\"", ",", "\"box_head.fc1.\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^fc7\\\\.\"", ",", "\"box_head.fc2.\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "# 4conv1fc head tensor names: head_conv1_w, head_conv1_gn_s", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^head\\\\.conv\"", ",", "\"box_head.conv\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# FPN lateral and output convolutions", "\n", "# --------------------------------------------------------------------------", "\n", "def", "fpn_map", "(", "name", ")", ":", "\n", "        ", "\"\"\"\n        Look for keys with the following patterns:\n        1) Starts with \"fpn.inner.\"\n           Example: \"fpn.inner.res2.2.sum.lateral.weight\"\n           Meaning: These are lateral pathway convolutions\n        2) Starts with \"fpn.res\"\n           Example: \"fpn.res2.2.sum.weight\"\n           Meaning: These are FPN output convolutions\n        \"\"\"", "\n", "splits", "=", "name", ".", "split", "(", "\".\"", ")", "\n", "norm", "=", "\".norm\"", "if", "\"norm\"", "in", "splits", "else", "\"\"", "\n", "if", "name", ".", "startswith", "(", "\"fpn.inner.\"", ")", ":", "\n", "# splits example: ['fpn', 'inner', 'res2', '2', 'sum', 'lateral', 'weight']", "\n", "            ", "stage", "=", "int", "(", "splits", "[", "2", "]", "[", "len", "(", "\"res\"", ")", ":", "]", ")", "\n", "return", "\"fpn_lateral{}{}.{}\"", ".", "format", "(", "stage", ",", "norm", ",", "splits", "[", "-", "1", "]", ")", "\n", "", "elif", "name", ".", "startswith", "(", "\"fpn.res\"", ")", ":", "\n", "# splits example: ['fpn', 'res2', '2', 'sum', 'weight']", "\n", "            ", "stage", "=", "int", "(", "splits", "[", "1", "]", "[", "len", "(", "\"res\"", ")", ":", "]", ")", "\n", "return", "\"fpn_output{}{}.{}\"", ".", "format", "(", "stage", ",", "norm", ",", "splits", "[", "-", "1", "]", ")", "\n", "", "return", "name", "\n", "\n", "", "layer_keys", "=", "[", "fpn_map", "(", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# Mask R-CNN mask head", "\n", "# --------------------------------------------------------------------------", "\n", "# roi_heads.StandardROIHeads case", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\".[mask].fcn\"", ",", "\"mask_head.mask_fcn\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "re", ".", "sub", "(", "\"^\\\\.mask\\\\.fcn\"", ",", "\"mask_head.mask_fcn\"", ",", "k", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"mask.fcn.logits\"", ",", "\"mask_head.predictor\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "# roi_heads.Res5ROIHeads case", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv5.mask\"", ",", "\"mask_head.deconv\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# Keypoint R-CNN head", "\n", "# --------------------------------------------------------------------------", "\n", "# interestingly, the keypoint head convs have blob names that are simply \"conv_fcnX\"", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"conv.fcn\"", ",", "\"roi_heads.keypoint_head.conv_fcn\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "layer_keys", "=", "[", "\n", "k", ".", "replace", "(", "\"kps.score.lowres\"", ",", "\"roi_heads.keypoint_head.score_lowres\"", ")", "for", "k", "in", "layer_keys", "\n", "]", "\n", "layer_keys", "=", "[", "k", ".", "replace", "(", "\"kps.score.\"", ",", "\"roi_heads.keypoint_head.score.\"", ")", "for", "k", "in", "layer_keys", "]", "\n", "\n", "# --------------------------------------------------------------------------", "\n", "# Done with replacements", "\n", "# --------------------------------------------------------------------------", "\n", "assert", "len", "(", "set", "(", "layer_keys", ")", ")", "==", "len", "(", "layer_keys", ")", "\n", "assert", "len", "(", "original_keys", ")", "==", "len", "(", "layer_keys", ")", "\n", "\n", "new_weights", "=", "{", "}", "\n", "new_keys_to_original_keys", "=", "{", "}", "\n", "for", "orig", ",", "renamed", "in", "zip", "(", "original_keys", ",", "layer_keys", ")", ":", "\n", "        ", "new_keys_to_original_keys", "[", "renamed", "]", "=", "orig", "\n", "if", "renamed", ".", "startswith", "(", "\"bbox_pred.\"", ")", "or", "renamed", ".", "startswith", "(", "\"mask_head.predictor.\"", ")", ":", "\n", "# remove the meaningless prediction weight for background class", "\n", "            ", "new_start_idx", "=", "4", "if", "renamed", ".", "startswith", "(", "\"bbox_pred.\"", ")", "else", "1", "\n", "new_weights", "[", "renamed", "]", "=", "weights", "[", "orig", "]", "[", "new_start_idx", ":", "]", "\n", "logger", ".", "info", "(", "\n", "\"Remove prediction weight for background class in {}. The shape changes from \"", "\n", "\"{} to {}.\"", ".", "format", "(", "\n", "renamed", ",", "tuple", "(", "weights", "[", "orig", "]", ".", "shape", ")", ",", "tuple", "(", "new_weights", "[", "renamed", "]", ".", "shape", ")", "\n", ")", "\n", ")", "\n", "", "elif", "renamed", ".", "startswith", "(", "\"cls_score.\"", ")", ":", "\n", "# move weights of bg class from original index 0 to last index", "\n", "            ", "logger", ".", "info", "(", "\n", "\"Move classification weights for background class in {} from index 0 to \"", "\n", "\"index {}.\"", ".", "format", "(", "renamed", ",", "weights", "[", "orig", "]", ".", "shape", "[", "0", "]", "-", "1", ")", "\n", ")", "\n", "new_weights", "[", "renamed", "]", "=", "torch", ".", "cat", "(", "[", "weights", "[", "orig", "]", "[", "1", ":", "]", ",", "weights", "[", "orig", "]", "[", ":", "1", "]", "]", ")", "\n", "", "else", ":", "\n", "            ", "new_weights", "[", "renamed", "]", "=", "weights", "[", "orig", "]", "\n", "\n", "", "", "return", "new_weights", ",", "new_keys_to_original_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.c2_model_loading.align_and_update_state_dicts": [[211, 313], ["sorted", "sorted", "torch.as_tensor().view", "torch.as_tensor().view.max", "logging.getLogger", "enumerate", "matched_keys.values", "matched_keys.keys", "len", "len", "model_state_dict.keys", "c2_model_loading.convert_c2_detectron_names", "ckpt_state_dict.keys", "len", "len", "max", "max", "idxs.tolist", "value_ckpt.clone", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "a.endswith", "c2_model_loading.align_and_update_state_dicts.match"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.c2_model_loading.convert_c2_detectron_names", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "def", "align_and_update_state_dicts", "(", "model_state_dict", ",", "ckpt_state_dict", ",", "c2_conversion", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Match names between the two state-dict, and update the values of model_state_dict in-place with\n    copies of the matched tensor in ckpt_state_dict.\n    If `c2_conversion==True`, `ckpt_state_dict` is assumed to be a Caffe2\n    model and will be renamed at first.\n\n    Strategy: suppose that the models that we will create will have prefixes appended\n    to each of its keys, for example due to an extra level of nesting that the original\n    pre-trained weights from ImageNet won't contain. For example, model.state_dict()\n    might return backbone[0].body.res2.conv1.weight, while the pre-trained model contains\n    res2.conv1.weight. We thus want to match both parameters together.\n    For that, we look for each model weight, look among all loaded keys if there is one\n    that is a suffix of the current weight name, and use it if that's the case.\n    If multiple matches exist, take the one with longest size\n    of the corresponding name. For example, for the same model as before, the pretrained\n    weight file can contain both res2.conv1.weight, as well as conv1.weight. In this case,\n    we want to match backbone[0].body.conv1.weight to conv1.weight, and\n    backbone[0].body.res2.conv1.weight to res2.conv1.weight.\n    \"\"\"", "\n", "model_keys", "=", "sorted", "(", "model_state_dict", ".", "keys", "(", ")", ")", "\n", "if", "c2_conversion", ":", "\n", "        ", "ckpt_state_dict", ",", "original_keys", "=", "convert_c2_detectron_names", "(", "ckpt_state_dict", ")", "\n", "# original_keys: the name in the original dict (before renaming)", "\n", "", "else", ":", "\n", "        ", "original_keys", "=", "{", "x", ":", "x", "for", "x", "in", "ckpt_state_dict", ".", "keys", "(", ")", "}", "\n", "", "ckpt_keys", "=", "sorted", "(", "ckpt_state_dict", ".", "keys", "(", ")", ")", "\n", "\n", "def", "match", "(", "a", ",", "b", ")", ":", "\n", "# Matched ckpt_key should be a complete (starts with '.') suffix.", "\n", "# For example, roi_heads.mesh_head.whatever_conv1 does not match conv1,", "\n", "# but matches whatever_conv1 or mesh_head.whatever_conv1.", "\n", "        ", "return", "a", "==", "b", "or", "a", ".", "endswith", "(", "\".\"", "+", "b", ")", "\n", "\n", "# get a matrix of string matches, where each (i, j) entry correspond to the size of the", "\n", "# ckpt_key string, if it matches", "\n", "", "match_matrix", "=", "[", "len", "(", "j", ")", "if", "match", "(", "i", ",", "j", ")", "else", "0", "for", "i", "in", "model_keys", "for", "j", "in", "ckpt_keys", "]", "\n", "match_matrix", "=", "torch", ".", "as_tensor", "(", "match_matrix", ")", ".", "view", "(", "len", "(", "model_keys", ")", ",", "len", "(", "ckpt_keys", ")", ")", "\n", "# use the matched one with longest size in case of multiple matches", "\n", "max_match_size", ",", "idxs", "=", "match_matrix", ".", "max", "(", "1", ")", "\n", "# remove indices that correspond to no-match", "\n", "idxs", "[", "max_match_size", "==", "0", "]", "=", "-", "1", "\n", "\n", "# used for logging", "\n", "max_len_model", "=", "max", "(", "len", "(", "key", ")", "for", "key", "in", "model_keys", ")", "if", "model_keys", "else", "1", "\n", "max_len_ckpt", "=", "max", "(", "len", "(", "key", ")", "for", "key", "in", "ckpt_keys", ")", "if", "ckpt_keys", "else", "1", "\n", "log_str_template", "=", "\"{: <{}} loaded from {: <{}} of shape {}\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "# matched_pairs (matched checkpoint key --> matched model key)", "\n", "matched_keys", "=", "{", "}", "\n", "for", "idx_model", ",", "idx_ckpt", "in", "enumerate", "(", "idxs", ".", "tolist", "(", ")", ")", ":", "\n", "        ", "if", "idx_ckpt", "==", "-", "1", ":", "\n", "            ", "continue", "\n", "", "key_model", "=", "model_keys", "[", "idx_model", "]", "\n", "key_ckpt", "=", "ckpt_keys", "[", "idx_ckpt", "]", "\n", "value_ckpt", "=", "ckpt_state_dict", "[", "key_ckpt", "]", "\n", "shape_in_model", "=", "model_state_dict", "[", "key_model", "]", ".", "shape", "\n", "\n", "if", "shape_in_model", "!=", "value_ckpt", ".", "shape", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "\"Shape of {} in checkpoint is {}, while shape of {} in model is {}.\"", ".", "format", "(", "\n", "key_ckpt", ",", "value_ckpt", ".", "shape", ",", "key_model", ",", "shape_in_model", "\n", ")", "\n", ")", "\n", "logger", ".", "warning", "(", "\n", "\"{} will not be loaded. Please double check and see if this is desired.\"", ".", "format", "(", "\n", "key_ckpt", "\n", ")", "\n", ")", "\n", "continue", "\n", "\n", "", "model_state_dict", "[", "key_model", "]", "=", "value_ckpt", ".", "clone", "(", ")", "\n", "if", "key_ckpt", "in", "matched_keys", ":", "# already added to matched_keys", "\n", "            ", "logger", ".", "error", "(", "\n", "\"Ambiguity found for {} in checkpoint!\"", "\n", "\"It matches at least two keys in the model ({} and {}).\"", ".", "format", "(", "\n", "key_ckpt", ",", "key_model", ",", "matched_keys", "[", "key_ckpt", "]", "\n", ")", "\n", ")", "\n", "raise", "ValueError", "(", "\"Cannot match one checkpoint key to multiple keys in the model.\"", ")", "\n", "\n", "", "matched_keys", "[", "key_ckpt", "]", "=", "key_model", "\n", "logger", ".", "info", "(", "\n", "log_str_template", ".", "format", "(", "\n", "key_model", ",", "\n", "max_len_model", ",", "\n", "original_keys", "[", "key_ckpt", "]", ",", "\n", "max_len_ckpt", ",", "\n", "tuple", "(", "shape_in_model", ")", ",", "\n", ")", "\n", ")", "\n", "", "matched_model_keys", "=", "matched_keys", ".", "values", "(", ")", "\n", "matched_ckpt_keys", "=", "matched_keys", ".", "keys", "(", ")", "\n", "# print warnings about unmatched keys on both side", "\n", "unmatched_model_keys", "=", "[", "k", "for", "k", "in", "model_keys", "if", "k", "not", "in", "matched_model_keys", "]", "\n", "if", "len", "(", "unmatched_model_keys", ")", ":", "\n", "        ", "logger", ".", "info", "(", "get_missing_parameters_message", "(", "unmatched_model_keys", ")", ")", "\n", "\n", "", "unmatched_ckpt_keys", "=", "[", "k", "for", "k", "in", "ckpt_keys", "if", "k", "not", "in", "matched_ckpt_keys", "]", "\n", "if", "len", "(", "unmatched_ckpt_keys", ")", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "get_unexpected_parameters_message", "(", "original_keys", "[", "x", "]", "for", "x", "in", "unmatched_ckpt_keys", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get_checkpoint_url": [[85, 101], ["config_path.replace", "RuntimeError"], "function", ["None"], ["", "def", "get_checkpoint_url", "(", "config_path", ")", ":", "\n", "    ", "\"\"\"\n    Returns the URL to the model trained using the given config\n\n    Args:\n        config_path (str): config file name relative to detectron2's \"configs/\"\n            directory, e.g., \"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x.yaml\"\n\n    Returns:\n        str: a URL to the model\n    \"\"\"", "\n", "name", "=", "config_path", ".", "replace", "(", "\".yaml\"", ",", "\"\"", ")", "\n", "if", "config_path", "in", "_ModelZooUrls", ".", "CONFIG_PATH_TO_URL_SUFFIX", ":", "\n", "        ", "suffix", "=", "_ModelZooUrls", ".", "CONFIG_PATH_TO_URL_SUFFIX", "[", "config_path", "]", "\n", "return", "_ModelZooUrls", ".", "S3_PREFIX", "+", "name", "+", "\"/\"", "+", "suffix", "\n", "", "raise", "RuntimeError", "(", "\"{} not available in Model Zoo!\"", ".", "format", "(", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get_config_file": [[103, 120], ["pkg_resources.resource_filename", "os.path.join", "os.path.exists", "RuntimeError"], "function", ["None"], ["", "def", "get_config_file", "(", "config_path", ")", ":", "\n", "    ", "\"\"\"\n    Returns path to a builtin config file.\n\n    Args:\n        config_path (str): config file name relative to detectron2's \"configs/\"\n            directory, e.g., \"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x.yaml\"\n\n    Returns:\n        str: the real path to the config file.\n    \"\"\"", "\n", "cfg_file", "=", "pkg_resources", ".", "resource_filename", "(", "\n", "\"detectron2.model_zoo\"", ",", "os", ".", "path", ".", "join", "(", "\"configs\"", ",", "config_path", ")", "\n", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "cfg_file", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"{} not available in Model Zoo!\"", ".", "format", "(", "config_path", ")", ")", "\n", "", "return", "cfg_file", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get": [[122, 154], ["model_zoo.get_config_file", "detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "model_zoo.get_checkpoint_url", "torch.cuda.is_available", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get_config_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get_checkpoint_url"], ["", "def", "get", "(", "config_path", ",", "trained", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Get a model specified by relative path under Detectron2's official ``configs/`` directory.\n\n    Args:\n        config_path (str): config file name relative to detectron2's \"configs/\"\n            directory, e.g., \"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x.yaml\"\n        trained (bool): If True, will initialize the model with the trained model zoo weights.\n            If False, the checkpoint specified in the config file's ``MODEL.WEIGHTS`` is used\n            instead; this will typically (though not always) initialize a subset of weights using\n            an ImageNet pre-trained model, while randomly initializing the other weights.\n\n    Returns:\n        nn.Module: a detectron2 model\n\n    Example:\n    ::\n        from detectron2 import model_zoo\n        model = model_zoo.get(\"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x.yaml\", trained=True)\n    \"\"\"", "\n", "cfg_file", "=", "get_config_file", "(", "config_path", ")", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "cfg_file", ")", "\n", "if", "trained", ":", "\n", "        ", "cfg", ".", "MODEL", ".", "WEIGHTS", "=", "get_checkpoint_url", "(", "config_path", ")", "\n", "", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "cfg", ".", "MODEL", ".", "DEVICE", "=", "\"cpu\"", "\n", "\n", "", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "cfg", ".", "MODEL", ".", "WEIGHTS", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.Caffe2CompatibleConverter.__init__": [[32, 34], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "replaceCls", ")", ":", "\n", "        ", "self", ".", "replaceCls", "=", "replaceCls", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.Caffe2CompatibleConverter.create_from": [[35, 55], ["isinstance", "issubclass", "isinstance", "type"], "methods", ["None"], ["", "def", "create_from", "(", "self", ",", "module", ")", ":", "\n", "# update module's class to the new class", "\n", "        ", "assert", "isinstance", "(", "module", ",", "torch", ".", "nn", ".", "Module", ")", "\n", "if", "issubclass", "(", "self", ".", "replaceCls", ",", "GenericMixin", ")", ":", "\n", "# replaceCls should act as mixin, create a new class on-the-fly", "\n", "            ", "new_class", "=", "type", "(", "\n", "\"{}MixedWith{}\"", ".", "format", "(", "self", ".", "replaceCls", ".", "__name__", ",", "module", ".", "__class__", ".", "__name__", ")", ",", "\n", "(", "self", ".", "replaceCls", ",", "module", ".", "__class__", ")", ",", "\n", "{", "}", ",", "# {\"new_method\": lambda self: ...},", "\n", ")", "\n", "module", ".", "__class__", "=", "new_class", "\n", "", "else", ":", "\n", "# replaceCls is complete class, this allow arbitrary class swap", "\n", "            ", "module", ".", "__class__", "=", "self", ".", "replaceCls", "\n", "\n", "# initialize Caffe2Compatible", "\n", "", "if", "isinstance", "(", "module", ",", "Caffe2Compatible", ")", ":", "\n", "            ", "module", ".", "tensor_mode", "=", "False", "\n", "\n", "", "return", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.ROIHeadsPatcher.__init__": [[115, 119], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "heads", ")", ":", "\n", "        ", "self", ".", "heads", "=", "heads", "\n", "\n", "self", ".", "use_heatmap_max_keypoint", "=", "cfg", ".", "EXPORT_CAFFE2", ".", "USE_HEATMAP_MAX_KEYPOINT", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.ROIHeadsPatcher.mock_roi_heads": [[120, 154], ["getattr", "getattr", "patcher.mock_fastrcnn_outputs_inference", "contextlib.ExitStack", "patcher.mock_keypoint_rcnn_inference", "patcher.mock_mask_rcnn_inference", "stack.enter_context", "type"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.mock_fastrcnn_outputs_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.mock_keypoint_rcnn_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.mock_mask_rcnn_inference"], ["", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_roi_heads", "(", "self", ",", "tensor_mode", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Patching several inference functions inside ROIHeads and its subclasses\n\n        Args:\n            tensor_mode (bool): whether the inputs/outputs are caffe2's tensor\n                format or not. Default to True.\n        \"\"\"", "\n", "# NOTE: this requries the `keypoint_rcnn_inference` and `mask_rcnn_inference`", "\n", "# are called inside the same file as BaseXxxHead due to using mock.patch.", "\n", "kpt_heads_mod", "=", "keypoint_head", ".", "BaseKeypointRCNNHead", ".", "__module__", "\n", "mask_head_mod", "=", "mask_head", ".", "BaseMaskRCNNHead", ".", "__module__", "\n", "\n", "mock_ctx_managers", "=", "[", "\n", "mock_fastrcnn_outputs_inference", "(", "\n", "tensor_mode", "=", "tensor_mode", ",", "\n", "check", "=", "True", ",", "\n", "box_predictor_type", "=", "type", "(", "self", ".", "heads", ".", "box_predictor", ")", ",", "\n", ")", "\n", "]", "\n", "if", "getattr", "(", "self", ".", "heads", ",", "\"keypoint_on\"", ",", "False", ")", ":", "\n", "            ", "mock_ctx_managers", "+=", "[", "\n", "mock_keypoint_rcnn_inference", "(", "\n", "tensor_mode", ",", "kpt_heads_mod", ",", "self", ".", "use_heatmap_max_keypoint", "\n", ")", "\n", "]", "\n", "", "if", "getattr", "(", "self", ".", "heads", ",", "\"mask_on\"", ",", "False", ")", ":", "\n", "            ", "mock_ctx_managers", "+=", "[", "mock_mask_rcnn_inference", "(", "tensor_mode", ",", "mask_head_mod", ")", "]", "\n", "\n", "", "with", "contextlib", ".", "ExitStack", "(", ")", "as", "stack", ":", "# python 3.3+", "\n", "            ", "for", "mgr", "in", "mock_ctx_managers", ":", "\n", "                ", "stack", ".", "enter_context", "(", "mgr", ")", "\n", "", "yield", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch": [[57, 68], ["model.named_children", "isinstance", "patcher.patch", "updater.create_from", "detectron2.modeling.proposal_generator.rpn.RPN", "detectron2.modeling.poolers.ROIPooler"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.Caffe2CompatibleConverter.create_from"], ["", "", "def", "patch", "(", "model", ",", "target", ",", "updater", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    recursively (post-order) update all modules with the target type and its\n    subclasses, make a initialization/composition/inheritance/... via the\n    updater.create_from.\n    \"\"\"", "\n", "for", "name", ",", "module", "in", "model", ".", "named_children", "(", ")", ":", "\n", "        ", "model", ".", "_modules", "[", "name", "]", "=", "patch", "(", "module", ",", "target", ",", "updater", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "if", "isinstance", "(", "model", ",", "target", ")", ":", "\n", "        ", "return", "updater", ".", "create_from", "(", "model", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch_generalized_rcnn": [[70, 76], ["patcher.patch", "patcher.patch", "ccc", "ccc"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch"], ["", "def", "patch_generalized_rcnn", "(", "model", ")", ":", "\n", "    ", "ccc", "=", "Caffe2CompatibleConverter", "\n", "model", "=", "patch", "(", "model", ",", "rpn", ".", "RPN", ",", "ccc", "(", "Caffe2RPN", ")", ")", "\n", "model", "=", "patch", "(", "model", ",", "poolers", ".", "ROIPooler", ",", "ccc", "(", "Caffe2ROIPooler", ")", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.mock_fastrcnn_outputs_inference": [[78, 91], ["mock.patch.object", "c10.Caffe2FastRCNNOutputsInference"], "function", ["None"], ["", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_fastrcnn_outputs_inference", "(", "\n", "tensor_mode", ",", "check", "=", "True", ",", "box_predictor_type", "=", "FastRCNNOutputLayers", "\n", ")", ":", "\n", "    ", "with", "mock", ".", "patch", ".", "object", "(", "\n", "box_predictor_type", ",", "\n", "\"inference\"", ",", "\n", "autospec", "=", "True", ",", "\n", "side_effect", "=", "Caffe2FastRCNNOutputsInference", "(", "tensor_mode", ")", ",", "\n", ")", "as", "mocked_func", ":", "\n", "        ", "yield", "\n", "", "if", "check", ":", "\n", "        ", "assert", "mocked_func", ".", "call_count", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.mock_mask_rcnn_inference": [[93, 101], ["mock.patch", "c10.Caffe2MaskRCNNInference"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch"], ["", "", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_mask_rcnn_inference", "(", "tensor_mode", ",", "patched_module", ",", "check", "=", "True", ")", ":", "\n", "    ", "with", "mock", ".", "patch", "(", "\n", "\"{}.mask_rcnn_inference\"", ".", "format", "(", "patched_module", ")", ",", "side_effect", "=", "Caffe2MaskRCNNInference", "(", ")", "\n", ")", "as", "mocked_func", ":", "\n", "        ", "yield", "\n", "", "if", "check", ":", "\n", "        ", "assert", "mocked_func", ".", "call_count", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.mock_keypoint_rcnn_inference": [[103, 112], ["mock.patch", "c10.Caffe2KeypointRCNNInference"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch"], ["", "", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_keypoint_rcnn_inference", "(", "tensor_mode", ",", "patched_module", ",", "use_heatmap_max_keypoint", ",", "check", "=", "True", ")", ":", "\n", "    ", "with", "mock", ".", "patch", "(", "\n", "\"{}.keypoint_rcnn_inference\"", ".", "format", "(", "patched_module", ")", ",", "\n", "side_effect", "=", "Caffe2KeypointRCNNInference", "(", "use_heatmap_max_keypoint", ")", ",", "\n", ")", "as", "mocked_func", ":", "\n", "        ", "yield", "\n", "", "if", "check", ":", "\n", "        ", "assert", "mocked_func", ".", "call_count", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.export_torchscript_with_instances": [[16, 64], ["torchscript.patch_instances", "torch.jit.script"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances"], ["def", "export_torchscript_with_instances", "(", "model", ",", "fields", ")", ":", "\n", "    ", "\"\"\"\n    Run :func:`torch.jit.script` on a model that uses the :class:`Instances` class. Since\n    attributes of :class:`Instances` are \"dynamically\" added in eager mode\uff0cit is difficult\n    for torchscript to support it out of the box. This function is made to support scripting\n    a model that uses :class:`Instances`. It does the following:\n\n    1. Create a scriptable ``new_Instances`` class which behaves similarly to ``Instances``,\n       but with all attributes been \"static\".\n       The attributes need to be statically declared in the ``fields`` argument.\n    2. Register ``new_Instances`` to torchscript, and force torchscript to\n       use it when trying to compile ``Instances``.\n\n    After this function, the process will be reverted. User should be able to script another model\n    using different fields.\n\n    Example:\n        Assume that ``Instances`` in the model consist of two attributes named\n        ``proposal_boxes`` and ``objectness_logits`` with type :class:`Boxes` and\n        :class:`Tensor` respectively during inference. You can call this function like:\n\n        ::\n            fields = {\"proposal_boxes\": \"Boxes\", \"objectness_logits\": \"Tensor\"}\n            torchscipt_model =  export_torchscript_with_instances(model, fields)\n\n    Note:\n        Currently we only support models in evaluation mode. Exporting models in training mode\n        or running inference processes of torchscripts that are exported from models in training\n        mode may encounter unexpected errors.\n\n    Args:\n        model (nn.Module): The input model to be exported to torchscript.\n        fields (Dict[str, str]): Attribute names and corresponding type annotations that\n            ``Instances`` will use in the model. Note that all attributes used in ``Instances``\n            need to be added, regarldess of whether they are inputs/outputs of the model.\n            Custom data type is not supported for now.\n\n    Returns:\n        torch.jit.ScriptModule: the input model in torchscript format\n    \"\"\"", "\n", "\n", "assert", "(", "\n", "not", "model", ".", "training", "\n", ")", ",", "\"Currently we only support exporting models in evaluation mode to torchscript\"", "\n", "\n", "with", "patch_instances", "(", "fields", ")", ":", "\n", "        ", "scripted_model", "=", "torch", ".", "jit", ".", "script", "(", "model", ")", "\n", "return", "scripted_model", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript.patch_instances": [[66, 93], ["tempfile.TemporaryDirectory", "tempfile.NamedTemporaryFile", "torchscript._gen_module", "f.write", "f.flush", "f.close", "torchscript._import", "getattr", "torch.jit.script", "torch._jit_internal._qualified_name", "sys.modules.pop"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript._gen_module", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript._import"], ["", "", "@", "contextmanager", "\n", "def", "patch_instances", "(", "fields", ")", ":", "\n", "    ", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2\"", ")", "as", "dir", ",", "tempfile", ".", "NamedTemporaryFile", "(", "\n", "mode", "=", "\"w\"", ",", "encoding", "=", "\"utf-8\"", ",", "suffix", "=", "\".py\"", ",", "dir", "=", "dir", ",", "delete", "=", "False", "\n", ")", "as", "f", ":", "\n", "        ", "try", ":", "\n", "            ", "cls_name", ",", "s", "=", "_gen_module", "(", "fields", ")", "\n", "f", ".", "write", "(", "s", ")", "\n", "f", ".", "flush", "(", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n", "module", "=", "_import", "(", "f", ".", "name", ")", "\n", "new_instances", "=", "getattr", "(", "module", ",", "cls_name", ")", "\n", "_", "=", "torch", ".", "jit", ".", "script", "(", "new_instances", ")", "\n", "\n", "# let torchscript think Instances was scripted already", "\n", "Instances", ".", "__torch_script_class__", "=", "True", "\n", "# let torchscript find new_instances when looking for the jit type of Instances", "\n", "Instances", ".", "_jit_override_qualname", "=", "torch", ".", "_jit_internal", ".", "_qualified_name", "(", "new_instances", ")", "\n", "yield", "new_instances", "\n", "", "finally", ":", "\n", "            ", "try", ":", "\n", "                ", "del", "Instances", ".", "__torch_script_class__", "\n", "del", "Instances", ".", "_jit_override_qualname", "\n", "", "except", "AttributeError", ":", "\n", "                ", "pass", "\n", "", "sys", ".", "modules", ".", "pop", "(", "module", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript._gen_imports": [[96, 108], ["None"], "function", ["None"], ["", "", "", "def", "_gen_imports", "(", ")", ":", "\n", "    ", "imports_str", "=", "\"\"\"\nfrom copy import deepcopy\nimport torch\nfrom torch import Tensor\nimport typing\nfrom typing import *\n\nfrom detectron2.structures import Boxes, Instances\n\n\"\"\"", "\n", "return", "imports_str", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript._gen_class": [[110, 205], ["lines.append", "fields.items", "fields.items", "lines.append", "fields.items", "lines.append", "lines.append", "fields.items", "lines.append", "lines.append", "lines.append", "lines.append", "lines.append", "lines.append", "os.linesep.join", "torchscript._gen_class.indent"], "function", ["None"], ["", "def", "_gen_class", "(", "fields", ")", ":", "\n", "    ", "def", "indent", "(", "level", ",", "s", ")", ":", "\n", "        ", "return", "\" \"", "*", "4", "*", "level", "+", "s", "\n", "\n", "", "lines", "=", "[", "]", "\n", "\n", "global", "_counter", "\n", "_counter", "+=", "1", "\n", "\n", "cls_name", "=", "\"Instances_patched{}\"", ".", "format", "(", "_counter", ")", "\n", "\n", "lines", ".", "append", "(", "\n", "f\"\"\"\nclass {cls_name}:\n    def __init__(self, image_size: Tuple[int, int]):\n        self.image_size = image_size\n\"\"\"", "\n", ")", "\n", "\n", "for", "name", ",", "type_", "in", "fields", ".", "items", "(", ")", ":", "\n", "        ", "lines", ".", "append", "(", "indent", "(", "2", ",", "f\"self._{name} = torch.jit.annotate(Optional[{type_}], None)\"", ")", ")", "\n", "\n", "", "for", "name", ",", "type_", "in", "fields", ".", "items", "(", ")", ":", "\n", "        ", "lines", ".", "append", "(", "\n", "f\"\"\"\n    @property\n    def {name}(self) -> {type_}:\n        # has to use a local for type refinement\n        # https://pytorch.org/docs/stable/jit_language_reference.html#optional-type-refinement\n        t = self._{name}\n        assert t is not None\n        return t\n\n    @{name}.setter\n    def {name}(self, value: {type_}) -> None:\n        self._{name} = value\n\"\"\"", "\n", ")", "\n", "\n", "# support function attribute `__len__`", "\n", "", "lines", ".", "append", "(", "\n", "\"\"\"\n    def __len__(self) -> int:\n\"\"\"", "\n", ")", "\n", "for", "name", ",", "_", "in", "fields", ".", "items", "(", ")", ":", "\n", "        ", "lines", ".", "append", "(", "\n", "f\"\"\"\n        t = self._{name}\n        if t is not None:\n            return len(t)\n\"\"\"", "\n", ")", "\n", "", "lines", ".", "append", "(", "\n", "\"\"\"\n        raise NotImplementedError(\"Empty Instances does not support __len__!\")\n\"\"\"", "\n", ")", "\n", "\n", "# support function attribute `has`", "\n", "lines", ".", "append", "(", "\n", "\"\"\"\n    def has(self, name: str) -> bool:\n\"\"\"", "\n", ")", "\n", "for", "name", ",", "_", "in", "fields", ".", "items", "(", ")", ":", "\n", "        ", "lines", ".", "append", "(", "\n", "f\"\"\"\n        if name == \"{name}\":\n            return self._{name} is not None\n\"\"\"", "\n", ")", "\n", "", "lines", ".", "append", "(", "\n", "\"\"\"\n        return False\n\"\"\"", "\n", ")", "\n", "\n", "# support function attribute `from_instances`", "\n", "lines", ".", "append", "(", "\n", "f\"\"\"\n    @torch.jit.unused\n    @staticmethod\n    def from_instances(instances: Instances) -> \"{cls_name}\":\n        fields = instances.get_fields()\n        image_size = instances.image_size\n        new_instances = {cls_name}(image_size)\n        for name, val in fields.items():\n            assert hasattr(new_instances, '_{{}}'.format(name)), \\\\\n                \"No attribute named {{}} in {cls_name}\".format(name)\n            setattr(new_instances, name, deepcopy(val))\n        return new_instances\n\"\"\"", "\n", ")", "\n", "return", "cls_name", ",", "os", ".", "linesep", ".", "join", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript._gen_module": [[207, 213], ["torchscript._gen_imports", "torchscript._gen_class"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript._gen_imports", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript._gen_class"], ["", "def", "_gen_module", "(", "fields", ")", ":", "\n", "    ", "s", "=", "\"\"", "\n", "s", "+=", "_gen_imports", "(", ")", "\n", "cls_name", ",", "cls_def", "=", "_gen_class", "(", "fields", ")", "\n", "s", "+=", "cls_def", "\n", "return", "cls_name", ",", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.torchscript._import": [[215, 224], ["importlib.util.spec_from_file_location", "importlib.util.module_from_spec", "importlib.util.spec_from_file_location.loader.exec_module"], "function", ["None"], ["", "def", "_import", "(", "path", ")", ":", "\n", "# https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly", "\n", "    ", "spec", "=", "importlib", ".", "util", ".", "spec_from_file_location", "(", "\n", "\"{}{}\"", ".", "format", "(", "sys", ".", "modules", "[", "__name__", "]", ".", "__name__", ",", "_counter", ")", ",", "path", "\n", ")", "\n", "module", "=", "importlib", ".", "util", ".", "module_from_spec", "(", "spec", ")", "\n", "sys", ".", "modules", "[", "module", ".", "__name__", "]", "=", "module", "\n", "spec", ".", "loader", ".", "exec_module", "(", "module", ")", "\n", "return", "module", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.ScopedWS.__init__": [[130, 135], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "ws_name", ",", "is_reset", ",", "is_cleanup", "=", "False", ")", ":", "\n", "        ", "self", ".", "ws_name", "=", "ws_name", "\n", "self", ".", "is_reset", "=", "is_reset", "\n", "self", ".", "is_cleanup", "=", "is_cleanup", "\n", "self", ".", "org_ws", "=", "\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.ScopedWS.__enter__": [[136, 144], ["caffe2.python.workspace.CurrentWorkspace", "caffe2.python.workspace.SwitchWorkspace", "caffe2.python.workspace.ResetWorkspace"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "org_ws", "=", "workspace", ".", "CurrentWorkspace", "(", ")", "\n", "if", "self", ".", "ws_name", "is", "not", "None", ":", "\n", "            ", "workspace", ".", "SwitchWorkspace", "(", "self", ".", "ws_name", ",", "True", ")", "\n", "", "if", "self", ".", "is_reset", ":", "\n", "            ", "workspace", ".", "ResetWorkspace", "(", ")", "\n", "\n", "", "return", "workspace", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.ScopedWS.__exit__": [[145, 150], ["caffe2.python.workspace.ResetWorkspace", "caffe2.python.workspace.SwitchWorkspace"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "if", "self", ".", "is_cleanup", ":", "\n", "            ", "workspace", ".", "ResetWorkspace", "(", ")", "\n", "", "if", "self", ".", "ws_name", "is", "not", "None", ":", "\n", "            ", "workspace", ".", "SwitchWorkspace", "(", "self", ".", "org_ws", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.DiGraph.__init__": [[785, 788], ["set", "collections.defaultdict"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "vertices", "=", "set", "(", ")", "\n", "self", ".", "graph", "=", "collections", ".", "defaultdict", "(", "list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.DiGraph.add_edge": [[789, 793], ["shared.DiGraph.graph[].append", "shared.DiGraph.vertices.add", "shared.DiGraph.vertices.add"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.add", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.add"], ["", "def", "add_edge", "(", "self", ",", "u", ",", "v", ")", ":", "\n", "        ", "self", ".", "graph", "[", "u", "]", ".", "append", "(", "v", ")", "\n", "self", ".", "vertices", ".", "add", "(", "u", ")", "\n", "self", ".", "vertices", ".", "add", "(", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.DiGraph.get_all_paths": [[795, 814], ["shared.DiGraph.get_all_paths._get_all_paths_util"], "methods", ["None"], ["", "def", "get_all_paths", "(", "self", ",", "s", ",", "d", ")", ":", "\n", "        ", "visited", "=", "{", "k", ":", "False", "for", "k", "in", "self", ".", "vertices", "}", "\n", "path", "=", "[", "]", "\n", "all_paths", "=", "[", "]", "\n", "\n", "def", "_get_all_paths_util", "(", "graph", ",", "u", ",", "d", ",", "visited", ",", "path", ")", ":", "\n", "            ", "visited", "[", "u", "]", "=", "True", "\n", "path", ".", "append", "(", "u", ")", "\n", "if", "u", "==", "d", ":", "\n", "                ", "all_paths", ".", "append", "(", "copy", ".", "deepcopy", "(", "path", ")", ")", "\n", "", "else", ":", "\n", "                ", "for", "i", "in", "graph", "[", "u", "]", ":", "\n", "                    ", "if", "not", "visited", "[", "i", "]", ":", "\n", "                        ", "_get_all_paths_util", "(", "graph", ",", "i", ",", "d", ",", "visited", ",", "path", ")", "\n", "", "", "", "path", ".", "pop", "(", ")", "\n", "visited", "[", "u", "]", "=", "False", "\n", "\n", "", "_get_all_paths_util", "(", "self", ".", "graph", ",", "s", ",", "d", ",", "visited", ",", "path", ")", "\n", "return", "all_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.DiGraph.from_ssa": [[815, 823], ["shared.DiGraph", "range", "len", "shared.DiGraph.add_edge"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.DiGraph.add_edge"], ["", "@", "staticmethod", "\n", "def", "from_ssa", "(", "ssa", ")", ":", "\n", "        ", "graph", "=", "DiGraph", "(", ")", "\n", "for", "op_id", "in", "range", "(", "len", "(", "ssa", ")", ")", ":", "\n", "            ", "for", "inp", "in", "ssa", "[", "op_id", "]", "[", "0", "]", ":", "\n", "                ", "for", "outp", "in", "ssa", "[", "op_id", "]", "[", "1", "]", ":", "\n", "                    ", "graph", ".", "add_edge", "(", "inp", ",", "outp", ")", "\n", "", "", "", "return", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device": [[25, 42], ["torch.device", "torch.device", "torch.ops._caffe2.CopyGPUToCPU", "torch.ops._caffe2.CopyGPUToCPU", "torch.ops._caffe2.CopyCPUToGPU", "torch.ops._caffe2.CopyCPUToGPU", "RuntimeError"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["def", "to_device", "(", "t", ",", "device_str", ")", ":", "\n", "    ", "\"\"\"\n    This function is a replacement of .to(another_device) such that it allows the\n    casting to be traced properly by explicitly calling the underlying copy ops.\n    It also avoids introducing unncessary op when casting to the same device.\n    \"\"\"", "\n", "src", "=", "t", ".", "device", "\n", "dst", "=", "torch", ".", "device", "(", "device_str", ")", "\n", "\n", "if", "src", "==", "dst", ":", "\n", "        ", "return", "t", "\n", "", "elif", "src", ".", "type", "==", "\"cuda\"", "and", "dst", ".", "type", "==", "\"cpu\"", ":", "\n", "        ", "return", "torch", ".", "ops", ".", "_caffe2", ".", "CopyGPUToCPU", "(", "t", ")", "\n", "", "elif", "src", ".", "type", "==", "\"cpu\"", "and", "dst", ".", "type", "==", "\"cuda\"", ":", "\n", "        ", "return", "torch", ".", "ops", ".", "_caffe2", ".", "CopyCPUToGPU", "(", "t", ")", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Can't cast tensor from device {} to device {}\"", ".", "format", "(", "src", ",", "dst", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.BilinearInterpolation": [[48, 77], ["shared.BilinearInterpolation.upsample_filt"], "function", ["None"], ["", "", "def", "BilinearInterpolation", "(", "tensor_in", ",", "up_scale", ")", ":", "\n", "    ", "assert", "up_scale", "%", "2", "==", "0", ",", "\"Scale should be even\"", "\n", "\n", "def", "upsample_filt", "(", "size", ")", ":", "\n", "        ", "factor", "=", "(", "size", "+", "1", ")", "//", "2", "\n", "if", "size", "%", "2", "==", "1", ":", "\n", "            ", "center", "=", "factor", "-", "1", "\n", "", "else", ":", "\n", "            ", "center", "=", "factor", "-", "0.5", "\n", "\n", "", "og", "=", "np", ".", "ogrid", "[", ":", "size", ",", ":", "size", "]", "\n", "return", "(", "1", "-", "abs", "(", "og", "[", "0", "]", "-", "center", ")", "/", "factor", ")", "*", "(", "1", "-", "abs", "(", "og", "[", "1", "]", "-", "center", ")", "/", "factor", ")", "\n", "\n", "", "kernel_size", "=", "int", "(", "up_scale", ")", "*", "2", "\n", "bil_filt", "=", "upsample_filt", "(", "kernel_size", ")", "\n", "\n", "dim", "=", "int", "(", "tensor_in", ".", "shape", "[", "1", "]", ")", "\n", "kernel", "=", "np", ".", "zeros", "(", "(", "dim", ",", "dim", ",", "kernel_size", ",", "kernel_size", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "kernel", "[", "range", "(", "dim", ")", ",", "range", "(", "dim", ")", ",", ":", ",", ":", "]", "=", "bil_filt", "\n", "\n", "tensor_out", "=", "F", ".", "conv_transpose2d", "(", "\n", "tensor_in", ",", "\n", "weight", "=", "to_device", "(", "torch", ".", "Tensor", "(", "kernel", ")", ",", "tensor_in", ".", "device", ")", ",", "\n", "bias", "=", "None", ",", "\n", "stride", "=", "int", "(", "up_scale", ")", ",", "\n", "padding", "=", "int", "(", "up_scale", "/", "2", ")", ",", "\n", ")", "\n", "\n", "return", "tensor_out", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.onnx_compatibale_interpolate": [[82, 113], ["torch.nn.functional.interpolate", "logger.warning", "input.dim", "isinstance", "isinstance", "torch.ops._caffe2.ResizeNearest", "torch.ops._caffe2.ResizeNearest", "len", "logger.warning", "shared.BilinearInterpolation"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.BilinearInterpolation"], ["", "def", "onnx_compatibale_interpolate", "(", "\n", "input", ",", "size", "=", "None", ",", "scale_factor", "=", "None", ",", "mode", "=", "\"nearest\"", ",", "align_corners", "=", "None", "\n", ")", ":", "\n", "# NOTE: The input dimensions are interpreted in the form:", "\n", "# `mini-batch x channels x [optional depth] x [optional height] x width`.", "\n", "    ", "if", "size", "is", "None", "and", "scale_factor", "is", "not", "None", ":", "\n", "        ", "if", "input", ".", "dim", "(", ")", "==", "4", ":", "\n", "            ", "if", "isinstance", "(", "scale_factor", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "                ", "height_scale", ",", "width_scale", "=", "(", "scale_factor", ",", "scale_factor", ")", "\n", "", "else", ":", "\n", "                ", "assert", "isinstance", "(", "scale_factor", ",", "(", "tuple", ",", "list", ")", ")", "\n", "assert", "len", "(", "scale_factor", ")", "==", "2", "\n", "height_scale", ",", "width_scale", "=", "scale_factor", "\n", "\n", "", "assert", "not", "align_corners", ",", "\"No matching C2 op for align_corners == True\"", "\n", "if", "mode", "==", "\"nearest\"", ":", "\n", "                ", "return", "torch", ".", "ops", ".", "_caffe2", ".", "ResizeNearest", "(", "\n", "input", ",", "order", "=", "\"NCHW\"", ",", "width_scale", "=", "width_scale", ",", "height_scale", "=", "height_scale", "\n", ")", "\n", "", "elif", "mode", "==", "\"bilinear\"", ":", "\n", "                ", "logger", ".", "warning", "(", "\n", "\"Use F.conv_transpose2d for bilinear interpolate\"", "\n", "\" because there's no such C2 op, this may cause significant\"", "\n", "\" slowdown and the boundary pixels won't be as same as\"", "\n", "\" using F.interpolate due to padding.\"", "\n", ")", "\n", "assert", "height_scale", "==", "width_scale", "\n", "return", "BilinearInterpolation", "(", "input", ",", "up_scale", "=", "height_scale", ")", "\n", "", "", "logger", ".", "warning", "(", "\"Output size is not static, it might cause ONNX conversion issue\"", ")", "\n", "\n", "", "return", "interp", "(", "input", ",", "size", ",", "scale_factor", ",", "mode", ",", "align_corners", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.mock_torch_nn_functional_interpolate": [[115, 124], ["torch.onnx.is_in_onnx_export", "torch.onnx.is_in_onnx_export", "mock.patch"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch"], ["", "@", "contextlib", ".", "contextmanager", "\n", "def", "mock_torch_nn_functional_interpolate", "(", ")", ":", "\n", "    ", "if", "torch", ".", "onnx", ".", "is_in_onnx_export", "(", ")", ":", "\n", "        ", "with", "mock", ".", "patch", "(", "\n", "\"torch.nn.functional.interpolate\"", ",", "side_effect", "=", "onnx_compatibale_interpolate", "\n", ")", ":", "\n", "            ", "yield", "\n", "", "", "else", ":", "\n", "        ", "yield", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.fetch_any_blob": [[152, 162], ["caffe2.python.workspace.FetchBlob", "caffe2.python.workspace.FetchInt8Blob", "logger.error"], "function", ["None"], ["", "", "", "def", "fetch_any_blob", "(", "name", ")", ":", "\n", "    ", "bb", "=", "None", "\n", "try", ":", "\n", "        ", "bb", "=", "workspace", ".", "FetchBlob", "(", "name", ")", "\n", "", "except", "TypeError", ":", "\n", "        ", "bb", "=", "workspace", ".", "FetchInt8Blob", "(", "name", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "logger", ".", "error", "(", "\"Get blob {} error: {}\"", ".", "format", "(", "name", ",", "e", ")", ")", "\n", "\n", "", "return", "bb", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg": [[167, 172], ["None"], "function", ["None"], ["", "def", "get_pb_arg", "(", "pb", ",", "arg_name", ")", ":", "\n", "    ", "for", "x", "in", "pb", ".", "arg", ":", "\n", "        ", "if", "x", ".", "name", "==", "arg_name", ":", "\n", "            ", "return", "x", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_valf": [[174, 177], ["shared.get_pb_arg"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg"], ["", "def", "get_pb_arg_valf", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "arg", ".", "f", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_floats": [[179, 182], ["shared.get_pb_arg", "list", "map"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "get_pb_arg_floats", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "list", "(", "map", "(", "float", ",", "arg", ".", "floats", ")", ")", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_ints": [[184, 187], ["shared.get_pb_arg", "list", "map"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "get_pb_arg_ints", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "list", "(", "map", "(", "int", ",", "arg", ".", "ints", ")", ")", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali": [[189, 192], ["shared.get_pb_arg"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg"], ["", "def", "get_pb_arg_vali", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "arg", ".", "i", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vals": [[194, 197], ["shared.get_pb_arg"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg"], ["", "def", "get_pb_arg_vals", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "arg", ".", "s", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_valstrings": [[199, 202], ["shared.get_pb_arg", "list"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "get_pb_arg_valstrings", "(", "pb", ",", "arg_name", ",", "default_val", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "return", "list", "(", "arg", ".", "strings", ")", "if", "arg", "is", "not", "None", "else", "default_val", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg": [[204, 219], ["shared.get_pb_arg", "caffe2.MakeArgument", "hasattr", "pb.arg.extend", "logger.warning", "setattr", "getattr", "getattr", "getattr", "getattr"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg"], ["", "def", "check_set_pb_arg", "(", "pb", ",", "arg_name", ",", "arg_attr", ",", "arg_value", ",", "allow_override", "=", "False", ")", ":", "\n", "    ", "arg", "=", "get_pb_arg", "(", "pb", ",", "arg_name", ")", "\n", "if", "arg", "is", "None", ":", "\n", "        ", "arg", "=", "putils", ".", "MakeArgument", "(", "arg_name", ",", "arg_value", ")", "\n", "assert", "hasattr", "(", "arg", ",", "arg_attr", ")", "\n", "pb", ".", "arg", ".", "extend", "(", "[", "arg", "]", ")", "\n", "", "if", "allow_override", "and", "getattr", "(", "arg", ",", "arg_attr", ")", "!=", "arg_value", ":", "\n", "        ", "logger", ".", "warning", "(", "\n", "\"Override argument {}: {} -> {}\"", ".", "format", "(", "arg_name", ",", "getattr", "(", "arg", ",", "arg_attr", ")", ",", "arg_value", ")", "\n", ")", "\n", "setattr", "(", "arg", ",", "arg_attr", ",", "arg_value", ")", "\n", "", "else", ":", "\n", "        ", "assert", "arg", "is", "not", "None", "\n", "assert", "getattr", "(", "arg", ",", "arg_attr", ")", "==", "arg_value", ",", "\"Existing value {}, new value {}\"", ".", "format", "(", "\n", "getattr", "(", "arg", ",", "arg_attr", ")", ",", "arg_value", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._create_const_fill_op_from_numpy": [[222, 241], ["caffe2.python.core.CreateOperator", "type", "numpy.dtype", "numpy.dtype", "numpy.dtype", "numpy.dtype", "numpy.dtype", "args_dict.update", "args_dict.update", "str"], "function", ["None"], ["", "", "def", "_create_const_fill_op_from_numpy", "(", "name", ",", "tensor", ",", "device_option", "=", "None", ")", ":", "\n", "    ", "assert", "type", "(", "tensor", ")", "==", "np", ".", "ndarray", "\n", "kTypeNameMapper", "=", "{", "\n", "np", ".", "dtype", "(", "\"float32\"", ")", ":", "\"GivenTensorFill\"", ",", "\n", "np", ".", "dtype", "(", "\"int32\"", ")", ":", "\"GivenTensorIntFill\"", ",", "\n", "np", ".", "dtype", "(", "\"int64\"", ")", ":", "\"GivenTensorInt64Fill\"", ",", "\n", "np", ".", "dtype", "(", "\"uint8\"", ")", ":", "\"GivenTensorStringFill\"", ",", "\n", "}", "\n", "\n", "args_dict", "=", "{", "}", "\n", "if", "tensor", ".", "dtype", "==", "np", ".", "dtype", "(", "\"uint8\"", ")", ":", "\n", "        ", "args_dict", ".", "update", "(", "{", "\"values\"", ":", "[", "str", "(", "tensor", ".", "data", ")", "]", ",", "\"shape\"", ":", "[", "1", "]", "}", ")", "\n", "", "else", ":", "\n", "        ", "args_dict", ".", "update", "(", "{", "\"values\"", ":", "tensor", ",", "\"shape\"", ":", "tensor", ".", "shape", "}", ")", "\n", "\n", "", "if", "device_option", "is", "not", "None", ":", "\n", "        ", "args_dict", "[", "\"device_option\"", "]", "=", "device_option", "\n", "\n", "", "return", "core", ".", "CreateOperator", "(", "kTypeNameMapper", "[", "tensor", ".", "dtype", "]", ",", "[", "]", ",", "[", "name", "]", ",", "**", "args_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._create_const_fill_op_from_c2_int8_tensor": [[243, 262], ["caffe2.python.core.CreateOperator", "type", "numpy.dtype", "numpy.dtype", "tensor.tobytes", "numpy.dtype", "numpy.dtype", "numpy.dtype"], "function", ["None"], ["", "def", "_create_const_fill_op_from_c2_int8_tensor", "(", "name", ",", "int8_tensor", ")", ":", "\n", "    ", "assert", "type", "(", "int8_tensor", ")", "==", "workspace", ".", "Int8Tensor", "\n", "kTypeNameMapper", "=", "{", "\n", "np", ".", "dtype", "(", "\"int32\"", ")", ":", "\"Int8GivenIntTensorFill\"", ",", "\n", "np", ".", "dtype", "(", "\"uint8\"", ")", ":", "\"Int8GivenTensorFill\"", ",", "\n", "}", "\n", "\n", "tensor", "=", "int8_tensor", ".", "data", "\n", "assert", "tensor", ".", "dtype", "in", "[", "np", ".", "dtype", "(", "\"uint8\"", ")", ",", "np", ".", "dtype", "(", "\"int32\"", ")", "]", "\n", "values", "=", "tensor", ".", "tobytes", "(", ")", "if", "tensor", ".", "dtype", "==", "np", ".", "dtype", "(", "\"uint8\"", ")", "else", "tensor", "\n", "\n", "return", "core", ".", "CreateOperator", "(", "\n", "kTypeNameMapper", "[", "tensor", ".", "dtype", "]", ",", "\n", "[", "]", ",", "\n", "[", "name", "]", ",", "\n", "values", "=", "values", ",", "\n", "shape", "=", "tensor", ".", "shape", ",", "\n", "Y_scale", "=", "int8_tensor", ".", "scale", ",", "\n", "Y_zero_point", "=", "int8_tensor", ".", "zero_point", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.create_const_fill_op": [[265, 288], ["type", "type", "shared._create_const_fill_op_from_numpy", "shared._create_const_fill_op_from_c2_int8_tensor"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._create_const_fill_op_from_numpy", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._create_const_fill_op_from_c2_int8_tensor"], ["", "def", "create_const_fill_op", "(", "\n", "name", ":", "str", ",", "\n", "blob", ":", "Union", "[", "np", ".", "ndarray", ",", "workspace", ".", "Int8Tensor", "]", ",", "\n", "device_option", ":", "Optional", "[", "caffe2_pb2", ".", "DeviceOption", "]", "=", "None", ",", "\n", ")", "->", "caffe2_pb2", ".", "OperatorDef", ":", "\n", "    ", "\"\"\"\n    Given a blob object, return the Caffe2 operator that creates this blob\n    as constant. Currently support NumPy tensor and Caffe2 Int8Tensor.\n    \"\"\"", "\n", "\n", "tensor_type", "=", "type", "(", "blob", ")", "\n", "assert", "tensor_type", "in", "[", "\n", "np", ".", "ndarray", ",", "\n", "workspace", ".", "Int8Tensor", ",", "\n", "]", ",", "'Error when creating const fill op for \"{}\", unsupported blob type: {}'", ".", "format", "(", "\n", "name", ",", "type", "(", "blob", ")", "\n", ")", "\n", "\n", "if", "tensor_type", "==", "np", ".", "ndarray", ":", "\n", "        ", "return", "_create_const_fill_op_from_numpy", "(", "name", ",", "blob", ",", "device_option", ")", "\n", "", "elif", "tensor_type", "==", "workspace", ".", "Int8Tensor", ":", "\n", "        ", "assert", "device_option", "is", "None", "\n", "return", "_create_const_fill_op_from_c2_int8_tensor", "(", "name", ",", "blob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.construct_init_net_from_params": [[290, 312], ["caffe2.proto.caffe2_pb2.NetDef", "params.items", "isinstance", "caffe2_pb2.NetDef.op.extend", "caffe2_pb2.NetDef.external_output.append", "logger.warning", "shared.create_const_fill_op", "type", "device_options.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.create_const_fill_op", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "construct_init_net_from_params", "(", "\n", "params", ":", "Dict", "[", "str", ",", "Any", "]", ",", "device_options", ":", "Optional", "[", "Dict", "[", "str", ",", "caffe2_pb2", ".", "DeviceOption", "]", "]", "=", "None", "\n", ")", "->", "caffe2_pb2", ".", "NetDef", ":", "\n", "    ", "\"\"\"\n    Construct the init_net from params dictionary\n    \"\"\"", "\n", "init_net", "=", "caffe2_pb2", ".", "NetDef", "(", ")", "\n", "device_options", "=", "device_options", "or", "{", "}", "\n", "for", "name", ",", "blob", "in", "params", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "blob", ",", "str", ")", ":", "\n", "            ", "logger", ".", "warning", "(", "\n", "(", "\n", "\"Blob {} with type {} is not supported in generating init net,\"", "\n", "\" skipped.\"", ".", "format", "(", "name", ",", "type", "(", "blob", ")", ")", "\n", ")", "\n", ")", "\n", "continue", "\n", "", "init_net", ".", "op", ".", "extend", "(", "\n", "[", "create_const_fill_op", "(", "name", ",", "blob", ",", "device_option", "=", "device_options", ".", "get", "(", "name", ",", "None", ")", ")", "]", "\n", ")", "\n", "init_net", ".", "external_output", ".", "append", "(", "name", ")", "\n", "", "return", "init_net", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_producer_map": [[314, 325], ["range", "len", "enumerate"], "function", ["None"], ["", "def", "get_producer_map", "(", "ssa", ")", ":", "\n", "    ", "\"\"\"\n    Return dict from versioned blob to (i, j),\n        where i is index of producer op, j is the index of output of that op.\n    \"\"\"", "\n", "producer_map", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "ssa", ")", ")", ":", "\n", "        ", "outputs", "=", "ssa", "[", "i", "]", "[", "1", "]", "\n", "for", "j", ",", "outp", "in", "enumerate", "(", "outputs", ")", ":", "\n", "            ", "producer_map", "[", "outp", "]", "=", "(", "i", ",", "j", ")", "\n", "", "", "return", "producer_map", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_consumer_map": [[327, 338], ["collections.defaultdict", "range", "len", "enumerate", "consumer_map[].append"], "function", ["None"], ["", "def", "get_consumer_map", "(", "ssa", ")", ":", "\n", "    ", "\"\"\"\n    Return dict from versioned blob to list of (i, j),\n        where i is index of consumer op, j is the index of input of that op.\n    \"\"\"", "\n", "consumer_map", "=", "collections", ".", "defaultdict", "(", "list", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "ssa", ")", ")", ":", "\n", "        ", "inputs", "=", "ssa", "[", "i", "]", "[", "0", "]", "\n", "for", "j", ",", "inp", "in", "enumerate", "(", "inputs", ")", ":", "\n", "            ", "consumer_map", "[", "inp", "]", ".", "append", "(", "(", "i", ",", "j", ")", ")", "\n", "", "", "return", "consumer_map", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_params_from_init_net": [[340, 367], ["caffe2.python.core.get_ssa", "shared.get_producer_map", "shared.ScopedWS", "ws.RunNetOnce", "shared.get_params_from_init_net._get_device_option"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_producer_map"], ["", "def", "get_params_from_init_net", "(", "\n", "init_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", ")", "->", "[", "Dict", "[", "str", ",", "Any", "]", ",", "Dict", "[", "str", ",", "caffe2_pb2", ".", "DeviceOption", "]", "]", ":", "\n", "    ", "\"\"\"\n    Take the output blobs from init_net by running it.\n    Outputs:\n        params: dict from blob name to numpy array\n        device_options: dict from blob name to the device option of its creating op\n    \"\"\"", "\n", "# NOTE: this assumes that the params is determined by producer op with the", "\n", "# only exception be CopyGPUToCPU which is CUDA op but returns CPU tensor.", "\n", "def", "_get_device_option", "(", "producer_op", ")", ":", "\n", "        ", "if", "producer_op", ".", "type", "==", "\"CopyGPUToCPU\"", ":", "\n", "            ", "return", "caffe2_pb2", ".", "DeviceOption", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "producer_op", ".", "device_option", "\n", "\n", "", "", "with", "ScopedWS", "(", "\"__get_params_from_init_net__\"", ",", "is_reset", "=", "True", ",", "is_cleanup", "=", "True", ")", "as", "ws", ":", "\n", "        ", "ws", ".", "RunNetOnce", "(", "init_net", ")", "\n", "params", "=", "{", "b", ":", "fetch_any_blob", "(", "b", ")", "for", "b", "in", "init_net", ".", "external_output", "}", "\n", "", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "init_net", ")", "\n", "producer_map", "=", "get_producer_map", "(", "ssa", ")", "\n", "device_options", "=", "{", "\n", "b", ":", "_get_device_option", "(", "init_net", ".", "op", "[", "producer_map", "[", "(", "b", ",", "versions", "[", "b", "]", ")", "]", "[", "0", "]", "]", ")", "\n", "for", "b", "in", "init_net", ".", "external_output", "\n", "}", "\n", "return", "params", ",", "device_options", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._updater_raise": [[369, 373], ["RuntimeError"], "function", ["None"], ["", "def", "_updater_raise", "(", "op", ",", "input_types", ",", "output_types", ")", ":", "\n", "    ", "raise", "RuntimeError", "(", "\n", "\"Failed to apply updater for op {} given input_types {} and\"", "\n", "\" output_types {}\"", ".", "format", "(", "op", ",", "input_types", ",", "output_types", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._generic_status_identifier": [[376, 446], ["caffe2.python.core.get_ssa", "set().union", "set().union.union().union", "all", "all", "copy.deepcopy", "zip", "zip", "status_updater", "zip", "shared._generic_status_identifier._update_i"], "function", ["None"], ["", "def", "_generic_status_identifier", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "status_updater", ":", "Callable", ",", "\n", "known_status", ":", "Dict", "[", "Tuple", "[", "str", ",", "int", "]", ",", "Any", "]", ",", "\n", ")", "->", "Dict", "[", "Tuple", "[", "str", ",", "int", "]", ",", "Any", "]", ":", "\n", "    ", "\"\"\"\n    Statically infer the status of each blob, the status can be such as device type\n        (CPU/GPU), layout (NCHW/NHWC), data type (float32/int8), etc. \"Blob\" here\n        is versioned blob (Tuple[str, int]) in the format compatible with ssa.\n    Inputs:\n        predict_net: the caffe2 network\n        status_updater: a callable, given an op and the status of its input/output,\n            it returns the updated status of input/output. `None` is used for\n            representing unknown status.\n        known_status: a dict containing known status, used as initialization.\n    Outputs:\n        A dict mapping from versioned blob to its status\n    \"\"\"", "\n", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "versioned_ext_input", "=", "[", "(", "b", ",", "0", ")", "for", "b", "in", "predict_net", ".", "external_input", "]", "\n", "versioned_ext_output", "=", "[", "(", "b", ",", "versions", "[", "b", "]", ")", "for", "b", "in", "predict_net", ".", "external_output", "]", "\n", "all_versioned_blobs", "=", "set", "(", ")", ".", "union", "(", "*", "[", "set", "(", "x", "[", "0", "]", "+", "x", "[", "1", "]", ")", "for", "x", "in", "ssa", "]", ")", "\n", "\n", "allowed_vbs", "=", "all_versioned_blobs", ".", "union", "(", "versioned_ext_input", ")", ".", "union", "(", "versioned_ext_output", ")", "\n", "assert", "all", "(", "k", "in", "allowed_vbs", "for", "k", "in", "known_status", ")", "\n", "assert", "all", "(", "v", "is", "not", "None", "for", "v", "in", "known_status", ".", "values", "(", ")", ")", "\n", "_known_status", "=", "copy", ".", "deepcopy", "(", "known_status", ")", "\n", "\n", "def", "_check_and_update", "(", "key", ",", "value", ")", ":", "\n", "        ", "assert", "value", "is", "not", "None", "\n", "if", "key", "in", "_known_status", ":", "\n", "            ", "if", "not", "_known_status", "[", "key", "]", "==", "value", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "\"Confilict status for {}, existing status {}, new status {}\"", ".", "format", "(", "\n", "key", ",", "_known_status", "[", "key", "]", ",", "value", "\n", ")", "\n", ")", "\n", "", "", "_known_status", "[", "key", "]", "=", "value", "\n", "\n", "", "def", "_update_i", "(", "op", ",", "ssa_i", ")", ":", "\n", "        ", "versioned_inputs", "=", "ssa_i", "[", "0", "]", "\n", "versioned_outputs", "=", "ssa_i", "[", "1", "]", "\n", "\n", "inputs_status", "=", "[", "_known_status", ".", "get", "(", "b", ",", "None", ")", "for", "b", "in", "versioned_inputs", "]", "\n", "outputs_status", "=", "[", "_known_status", ".", "get", "(", "b", ",", "None", ")", "for", "b", "in", "versioned_outputs", "]", "\n", "\n", "new_inputs_status", ",", "new_outputs_status", "=", "status_updater", "(", "op", ",", "inputs_status", ",", "outputs_status", ")", "\n", "\n", "for", "versioned_blob", ",", "status", "in", "zip", "(", "\n", "versioned_inputs", "+", "versioned_outputs", ",", "new_inputs_status", "+", "new_outputs_status", "\n", ")", ":", "\n", "            ", "if", "status", "is", "not", "None", ":", "\n", "                ", "_check_and_update", "(", "versioned_blob", ",", "status", ")", "\n", "\n", "", "", "", "for", "op", ",", "ssa_i", "in", "zip", "(", "predict_net", ".", "op", ",", "ssa", ")", ":", "\n", "        ", "_update_i", "(", "op", ",", "ssa_i", ")", "\n", "", "for", "op", ",", "ssa_i", "in", "zip", "(", "reversed", "(", "predict_net", ".", "op", ")", ",", "reversed", "(", "ssa", ")", ")", ":", "\n", "        ", "_update_i", "(", "op", ",", "ssa_i", ")", "\n", "\n", "# NOTE: This strictly checks all the blob from predict_net must be assgined", "\n", "# a known status. However sometimes it's impossible (eg. having deadend op),", "\n", "# we may relax this constraint if", "\n", "", "for", "k", "in", "all_versioned_blobs", ":", "\n", "        ", "if", "k", "not", "in", "_known_status", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Can not infer the status for {}. Currently only support the case where\"", "\n", "\" a single forward and backward pass can identify status for all blobs.\"", ".", "format", "(", "k", ")", "\n", ")", "\n", "\n", "", "", "return", "_known_status", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.infer_device_type": [[448, 486], ["shared._generic_status_identifier", "shared._updater_raise", "shared._updater_raise", "len", "all", "shared._updater_raise"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._generic_status_identifier", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._updater_raise", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._updater_raise", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._updater_raise"], ["", "def", "infer_device_type", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "known_status", ":", "Dict", "[", "Tuple", "[", "str", ",", "int", "]", ",", "Any", "]", ",", "\n", "device_name_style", ":", "str", "=", "\"caffe2\"", ",", "\n", ")", "->", "Dict", "[", "Tuple", "[", "str", ",", "int", "]", ",", "str", "]", ":", "\n", "    ", "\"\"\" Return the device type (\"cpu\" or \"gpu\"/\"cuda\") of each (versioned) blob \"\"\"", "\n", "\n", "assert", "device_name_style", "in", "[", "\"caffe2\"", ",", "\"pytorch\"", "]", "\n", "_CPU_STR", "=", "\"cpu\"", "\n", "_GPU_STR", "=", "\"gpu\"", "if", "device_name_style", "==", "\"caffe2\"", "else", "\"cuda\"", "\n", "\n", "def", "_copy_cpu_to_gpu_updater", "(", "op", ",", "input_types", ",", "output_types", ")", ":", "\n", "        ", "if", "input_types", "[", "0", "]", "==", "_GPU_STR", "or", "output_types", "[", "0", "]", "==", "_CPU_STR", ":", "\n", "            ", "_updater_raise", "(", "op", ",", "input_types", ",", "output_types", ")", "\n", "", "return", "(", "[", "_CPU_STR", "]", ",", "[", "_GPU_STR", "]", ")", "\n", "\n", "", "def", "_copy_gpu_to_cpu_updater", "(", "op", ",", "input_types", ",", "output_types", ")", ":", "\n", "        ", "if", "input_types", "[", "0", "]", "==", "_CPU_STR", "or", "output_types", "[", "0", "]", "==", "_GPU_STR", ":", "\n", "            ", "_updater_raise", "(", "op", ",", "input_types", ",", "output_types", ")", "\n", "", "return", "(", "[", "_GPU_STR", "]", ",", "[", "_CPU_STR", "]", ")", "\n", "\n", "", "def", "_other_ops_updater", "(", "op", ",", "input_types", ",", "output_types", ")", ":", "\n", "        ", "non_none_types", "=", "[", "x", "for", "x", "in", "input_types", "+", "output_types", "if", "x", "is", "not", "None", "]", "\n", "if", "len", "(", "non_none_types", ")", ">", "0", ":", "\n", "            ", "the_type", "=", "non_none_types", "[", "0", "]", "\n", "if", "not", "all", "(", "x", "==", "the_type", "for", "x", "in", "non_none_types", ")", ":", "\n", "                ", "_updater_raise", "(", "op", ",", "input_types", ",", "output_types", ")", "\n", "", "", "else", ":", "\n", "            ", "the_type", "=", "None", "\n", "", "return", "(", "[", "the_type", "for", "_", "in", "op", ".", "input", "]", ",", "[", "the_type", "for", "_", "in", "op", ".", "output", "]", ")", "\n", "\n", "", "def", "_device_updater", "(", "op", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "{", "\n", "\"CopyCPUToGPU\"", ":", "_copy_cpu_to_gpu_updater", ",", "\n", "\"CopyGPUToCPU\"", ":", "_copy_gpu_to_cpu_updater", ",", "\n", "}", ".", "get", "(", "op", ".", "type", ",", "_other_ops_updater", ")", "(", "op", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "_generic_status_identifier", "(", "predict_net", ",", "_device_updater", ",", "known_status", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._modify_blob_names": [[491, 505], ["blob_list.extend", "copy.deepcopy", "shared._modify_blob_names._replace_list"], "function", ["None"], ["", "def", "_modify_blob_names", "(", "ops", ",", "blob_rename_f", ")", ":", "\n", "    ", "ret", "=", "[", "]", "\n", "\n", "def", "_replace_list", "(", "blob_list", ",", "replaced_list", ")", ":", "\n", "        ", "del", "blob_list", "[", ":", "]", "\n", "blob_list", ".", "extend", "(", "replaced_list", ")", "\n", "\n", "", "for", "x", "in", "ops", ":", "\n", "        ", "cur", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "_replace_list", "(", "cur", ".", "input", ",", "list", "(", "map", "(", "blob_rename_f", ",", "cur", ".", "input", ")", ")", ")", "\n", "_replace_list", "(", "cur", ".", "output", ",", "list", "(", "map", "(", "blob_rename_f", ",", "cur", ".", "output", ")", ")", ")", "\n", "ret", ".", "append", "(", "cur", ")", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._rename_blob": [[507, 520], ["shared._rename_blob._list_to_str"], "function", ["None"], ["", "def", "_rename_blob", "(", "name", ",", "blob_sizes", ",", "blob_ranges", ")", ":", "\n", "    ", "def", "_list_to_str", "(", "bsize", ")", ":", "\n", "        ", "ret", "=", "\", \"", ".", "join", "(", "[", "str", "(", "x", ")", "for", "x", "in", "bsize", "]", ")", "\n", "ret", "=", "\"[\"", "+", "ret", "+", "\"]\"", "\n", "return", "ret", "\n", "\n", "", "ret", "=", "name", "\n", "if", "blob_sizes", "is", "not", "None", "and", "name", "in", "blob_sizes", ":", "\n", "        ", "ret", "+=", "\"\\n\"", "+", "_list_to_str", "(", "blob_sizes", "[", "name", "]", ")", "\n", "", "if", "blob_ranges", "is", "not", "None", "and", "name", "in", "blob_ranges", ":", "\n", "        ", "ret", "+=", "\"\\n\"", "+", "_list_to_str", "(", "blob_ranges", "[", "name", "]", ")", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.save_graph": [[523, 526], ["functools.partial", "shared.save_graph_base"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.save_graph_base"], ["", "def", "save_graph", "(", "net", ",", "file_name", ",", "graph_name", "=", "\"net\"", ",", "op_only", "=", "True", ",", "blob_sizes", "=", "None", ",", "blob_ranges", "=", "None", ")", ":", "\n", "    ", "blob_rename_f", "=", "functools", ".", "partial", "(", "_rename_blob", ",", "blob_sizes", "=", "blob_sizes", ",", "blob_ranges", "=", "blob_ranges", ")", "\n", "return", "save_graph_base", "(", "net", ",", "file_name", ",", "graph_name", ",", "op_only", ",", "blob_rename_f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.save_graph_base": [[528, 558], ["shared._modify_blob_names", "caffe2.python.net_drawer.GetPydotGraph", "caffe2.python.net_drawer.GetPydotGraphMinimal", "os.path.dirname", "os.path.exists", "os.makedirs", "os.path.splitext", "net_drawer.GetPydotGraphMinimal.write_png", "print", "os.path.basename", "net_drawer.GetPydotGraphMinimal.write_pdf", "net_drawer.GetPydotGraphMinimal.write_svg", "print"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._modify_blob_names"], ["", "def", "save_graph_base", "(", "net", ",", "file_name", ",", "graph_name", "=", "\"net\"", ",", "op_only", "=", "True", ",", "blob_rename_func", "=", "None", ")", ":", "\n", "    ", "graph", "=", "None", "\n", "ops", "=", "net", ".", "op", "\n", "if", "blob_rename_func", "is", "not", "None", ":", "\n", "        ", "ops", "=", "_modify_blob_names", "(", "ops", ",", "blob_rename_func", ")", "\n", "", "if", "not", "op_only", ":", "\n", "        ", "graph", "=", "net_drawer", ".", "GetPydotGraph", "(", "ops", ",", "graph_name", ",", "rankdir", "=", "\"TB\"", ")", "\n", "", "else", ":", "\n", "        ", "graph", "=", "net_drawer", ".", "GetPydotGraphMinimal", "(", "\n", "ops", ",", "graph_name", ",", "rankdir", "=", "\"TB\"", ",", "minimal_dependency", "=", "True", "\n", ")", "\n", "\n", "", "try", ":", "\n", "        ", "par_dir", "=", "os", ".", "path", ".", "dirname", "(", "file_name", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "par_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "par_dir", ")", "\n", "\n", "", "format", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "file_name", ")", ")", "[", "-", "1", "]", "\n", "if", "format", "==", "\".png\"", ":", "\n", "            ", "graph", ".", "write_png", "(", "file_name", ")", "\n", "", "elif", "format", "==", "\".pdf\"", ":", "\n", "            ", "graph", ".", "write_pdf", "(", "file_name", ")", "\n", "", "elif", "format", "==", "\".svg\"", ":", "\n", "            ", "graph", ".", "write_svg", "(", "file_name", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Incorrect format {}\"", ".", "format", "(", "format", ")", ")", "\n", "", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "\"Error when writing graph to image {}\"", ".", "format", "(", "e", ")", ")", "\n", "\n", "", "return", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.group_norm_replace_aten_with_caffe2": [[563, 587], ["logger.info", "shared.get_pb_arg_vals", "op.arg.remove", "shared.get_pb_arg_vali", "shared.get_pb_arg_vali", "get_pb_arg_vals.decode", "shared.get_pb_arg", "op.arg.remove", "op.arg.remove", "shared.check_set_pb_arg", "shared.get_pb_arg", "shared.get_pb_arg"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg"], ["", "def", "group_norm_replace_aten_with_caffe2", "(", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ")", ":", "\n", "    ", "\"\"\"\n    For ONNX exported model, GroupNorm will be represented as ATen op,\n        this can be a drop in replacement from ATen to GroupNorm\n    \"\"\"", "\n", "count", "=", "0", "\n", "for", "op", "in", "predict_net", ".", "op", ":", "\n", "        ", "if", "op", ".", "type", "==", "\"ATen\"", ":", "\n", "            ", "op_name", "=", "get_pb_arg_vals", "(", "op", ",", "\"operator\"", ",", "None", ")", "# return byte in py3", "\n", "if", "op_name", "and", "op_name", ".", "decode", "(", ")", "==", "\"group_norm\"", ":", "\n", "                ", "op", ".", "arg", ".", "remove", "(", "get_pb_arg", "(", "op", ",", "\"operator\"", ")", ")", "\n", "\n", "if", "get_pb_arg_vali", "(", "op", ",", "\"cudnn_enabled\"", ",", "None", ")", ":", "\n", "                    ", "op", ".", "arg", ".", "remove", "(", "get_pb_arg", "(", "op", ",", "\"cudnn_enabled\"", ")", ")", "\n", "\n", "", "num_groups", "=", "get_pb_arg_vali", "(", "op", ",", "\"num_groups\"", ",", "None", ")", "\n", "if", "num_groups", "is", "not", "None", ":", "\n", "                    ", "op", ".", "arg", ".", "remove", "(", "get_pb_arg", "(", "op", ",", "\"num_groups\"", ")", ")", "\n", "check_set_pb_arg", "(", "op", ",", "\"group\"", ",", "\"i\"", ",", "num_groups", ")", "\n", "\n", "", "op", ".", "type", "=", "\"GroupNorm\"", "\n", "count", "+=", "1", "\n", "", "", "", "if", "count", ">", "1", ":", "\n", "        ", "logger", ".", "info", "(", "\"Replaced {} ATen operator to GroupNormOp\"", ".", "format", "(", "count", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias": [[592, 597], ["isinstance", "torch.ops._caffe2.AliasWithName", "torch.ops._caffe2.AliasWithName", "torch.onnx.is_in_onnx_export", "torch.onnx.is_in_onnx_export"], "function", ["None"], ["", "", "def", "alias", "(", "x", ",", "name", ",", "is_backward", "=", "False", ")", ":", "\n", "    ", "if", "not", "torch", ".", "onnx", ".", "is_in_onnx_export", "(", ")", ":", "\n", "        ", "return", "x", "\n", "", "assert", "isinstance", "(", "x", ",", "torch", ".", "Tensor", ")", "\n", "return", "torch", ".", "ops", ".", "_caffe2", ".", "AliasWithName", "(", "x", ",", "name", ",", "is_backward", "=", "is_backward", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.fuse_alias_placeholder": [[599, 622], ["enumerate", "predict_net.op.extend", "get_pb_arg_vals().decode", "bool", "shared.rename_op_input", "shared.rename_op_output", "new_ops.append", "len", "len", "shared.get_pb_arg_vali", "op.arg[].s.decode", "shared.get_pb_arg_vals"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.rename_op_input", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.rename_op_output", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vals"], ["", "def", "fuse_alias_placeholder", "(", "predict_net", ",", "init_net", ")", ":", "\n", "    ", "\"\"\" Remove AliasWithName placeholder and rename the input/output of it \"\"\"", "\n", "# First we finish all the re-naming", "\n", "for", "i", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", ":", "\n", "        ", "if", "op", ".", "type", "==", "\"AliasWithName\"", ":", "\n", "            ", "assert", "len", "(", "op", ".", "input", ")", "==", "1", "\n", "assert", "len", "(", "op", ".", "output", ")", "==", "1", "\n", "name", "=", "get_pb_arg_vals", "(", "op", ",", "\"name\"", ",", "None", ")", ".", "decode", "(", ")", "\n", "is_backward", "=", "bool", "(", "get_pb_arg_vali", "(", "op", ",", "\"is_backward\"", ",", "0", ")", ")", "\n", "rename_op_input", "(", "predict_net", ",", "init_net", ",", "i", ",", "0", ",", "name", ",", "from_producer", "=", "is_backward", ")", "\n", "rename_op_output", "(", "predict_net", ",", "i", ",", "0", ",", "name", ")", "\n", "\n", "# Remove AliasWithName, should be very safe since it's a non-op", "\n", "", "", "new_ops", "=", "[", "]", "\n", "for", "op", "in", "predict_net", ".", "op", ":", "\n", "        ", "if", "op", ".", "type", "!=", "\"AliasWithName\"", ":", "\n", "            ", "new_ops", ".", "append", "(", "op", ")", "\n", "", "else", ":", "\n", "# safety check", "\n", "            ", "assert", "op", ".", "input", "==", "op", ".", "output", "\n", "assert", "op", ".", "input", "[", "0", "]", "==", "op", ".", "arg", "[", "0", "]", ".", "s", ".", "decode", "(", ")", "\n", "", "", "del", "predict_net", ".", "op", "[", ":", "]", "\n", "predict_net", ".", "op", ".", "extend", "(", "new_ops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._rename_versioned_blob_in_proto": [[631, 660], ["zip", "range", "range", "start_versions.get", "range", "end_versions.get", "range", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "_rename_versioned_blob_in_proto", "(", "\n", "proto", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "old_name", ":", "str", ",", "\n", "new_name", ":", "str", ",", "\n", "version", ":", "int", ",", "\n", "ssa", ":", "List", "[", "Tuple", "[", "List", "[", "Tuple", "[", "str", ",", "int", "]", "]", ",", "List", "[", "Tuple", "[", "str", ",", "int", "]", "]", "]", "]", ",", "\n", "start_versions", ":", "Dict", "[", "str", ",", "int", "]", ",", "\n", "end_versions", ":", "Dict", "[", "str", ",", "int", "]", ",", "\n", ")", ":", "\n", "    ", "\"\"\" In given proto, rename all blobs with matched version \"\"\"", "\n", "# Operater list", "\n", "for", "op", ",", "i_th_ssa", "in", "zip", "(", "proto", ".", "op", ",", "ssa", ")", ":", "\n", "        ", "versioned_inputs", ",", "versioned_outputs", "=", "i_th_ssa", "\n", "for", "i", "in", "range", "(", "len", "(", "op", ".", "input", ")", ")", ":", "\n", "            ", "if", "versioned_inputs", "[", "i", "]", "==", "(", "old_name", ",", "version", ")", ":", "\n", "                ", "op", ".", "input", "[", "i", "]", "=", "new_name", "\n", "", "", "for", "i", "in", "range", "(", "len", "(", "op", ".", "output", ")", ")", ":", "\n", "            ", "if", "versioned_outputs", "[", "i", "]", "==", "(", "old_name", ",", "version", ")", ":", "\n", "                ", "op", ".", "output", "[", "i", "]", "=", "new_name", "\n", "# external_input", "\n", "", "", "", "if", "start_versions", ".", "get", "(", "old_name", ",", "0", ")", "==", "version", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "proto", ".", "external_input", ")", ")", ":", "\n", "            ", "if", "proto", ".", "external_input", "[", "i", "]", "==", "old_name", ":", "\n", "                ", "proto", ".", "external_input", "[", "i", "]", "=", "new_name", "\n", "# external_output", "\n", "", "", "", "if", "end_versions", ".", "get", "(", "old_name", ",", "0", ")", "==", "version", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "proto", ".", "external_output", ")", ")", ":", "\n", "            ", "if", "proto", ".", "external_output", "[", "i", "]", "==", "old_name", ":", "\n", "                ", "proto", ".", "external_output", "[", "i", "]", "=", "new_name", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.rename_op_input": [[662, 726], ["isinstance", "isinstance", "caffe2.python.core.get_ssa", "caffe2.python.core.get_ssa", "shared._rename_versioned_blob_in_proto", "shared._rename_versioned_blob_in_proto", "copy.deepcopy", "shared.get_producer_map", "shared.rename_op_output", "shared.rename_op_input.contain_targets"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._rename_versioned_blob_in_proto", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._rename_versioned_blob_in_proto", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_producer_map", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.rename_op_output"], ["", "", "", "", "def", "rename_op_input", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "init_net", ":", "caffe2_pb2", ".", "NetDef", ",", "\n", "op_id", ":", "int", ",", "\n", "input_id", ":", "int", ",", "\n", "new_name", ":", "str", ",", "\n", "from_producer", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Rename the op_id-th operator in predict_net, change it's input_id-th input's\n        name to the new_name. It also does automatic re-route and change\n        external_input and init_net if necessary.\n    - It requires the input is only consumed by this op.\n    - This function modifies predict_net and init_net in-place.\n    - When from_producer is enable, this also updates other operators that consumes\n        the same input. Be cautious because may trigger unintended behavior.\n    \"\"\"", "\n", "assert", "isinstance", "(", "predict_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "assert", "isinstance", "(", "init_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "\n", "init_net_ssa", ",", "init_net_versions", "=", "core", ".", "get_ssa", "(", "init_net", ")", "\n", "predict_net_ssa", ",", "predict_net_versions", "=", "core", ".", "get_ssa", "(", "\n", "predict_net", ",", "copy", ".", "deepcopy", "(", "init_net_versions", ")", "\n", ")", "\n", "\n", "versioned_inputs", ",", "versioned_outputs", "=", "predict_net_ssa", "[", "op_id", "]", "\n", "old_name", ",", "version", "=", "versioned_inputs", "[", "input_id", "]", "\n", "\n", "if", "from_producer", ":", "\n", "        ", "producer_map", "=", "get_producer_map", "(", "predict_net_ssa", ")", "\n", "if", "not", "(", "old_name", ",", "version", ")", "in", "producer_map", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Can't find producer, the input {} is probably from\"", "\n", "\" init_net, this is not supported yet.\"", ".", "format", "(", "old_name", ")", "\n", ")", "\n", "", "producer", "=", "producer_map", "[", "(", "old_name", ",", "version", ")", "]", "\n", "rename_op_output", "(", "predict_net", ",", "producer", "[", "0", "]", ",", "producer", "[", "1", "]", ",", "new_name", ")", "\n", "return", "\n", "\n", "", "def", "contain_targets", "(", "op_ssa", ")", ":", "\n", "        ", "return", "(", "old_name", ",", "version", ")", "in", "op_ssa", "[", "0", "]", "\n", "\n", "", "is_consumer", "=", "[", "contain_targets", "(", "op_ssa", ")", "for", "op_ssa", "in", "predict_net_ssa", "]", "\n", "if", "sum", "(", "is_consumer", ")", ">", "1", ":", "\n", "        ", "raise", "IllegalGraphTransformError", "(", "\n", "(", "\n", "\"Input '{}' of operator(#{}) are consumed by other ops, please use\"", "\n", "+", "\" rename_op_output on the producer instead. Offending op: \\n{}\"", "\n", ")", ".", "format", "(", "old_name", ",", "op_id", ",", "predict_net", ".", "op", "[", "op_id", "]", ")", "\n", ")", "\n", "\n", "# update init_net", "\n", "", "_rename_versioned_blob_in_proto", "(", "\n", "init_net", ",", "old_name", ",", "new_name", ",", "version", ",", "init_net_ssa", ",", "{", "}", ",", "init_net_versions", "\n", ")", "\n", "# update predict_net", "\n", "_rename_versioned_blob_in_proto", "(", "\n", "predict_net", ",", "\n", "old_name", ",", "\n", "new_name", ",", "\n", "version", ",", "\n", "predict_net_ssa", ",", "\n", "init_net_versions", ",", "\n", "predict_net_versions", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.rename_op_output": [[729, 747], ["isinstance", "caffe2.python.core.get_ssa", "shared._rename_versioned_blob_in_proto"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._rename_versioned_blob_in_proto"], ["", "def", "rename_op_output", "(", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "op_id", ":", "int", ",", "output_id", ":", "int", ",", "new_name", ":", "str", ")", ":", "\n", "    ", "\"\"\"\n    Rename the op_id-th operator in predict_net, change it's output_id-th input's\n        name to the new_name. It also does automatic re-route and change\n        external_output and if necessary.\n    - It allows multiple consumers of its output.\n    - This function modifies predict_net in-place, doesn't need init_net.\n    \"\"\"", "\n", "assert", "isinstance", "(", "predict_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "\n", "ssa", ",", "blob_versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "\n", "versioned_inputs", ",", "versioned_outputs", "=", "ssa", "[", "op_id", "]", "\n", "old_name", ",", "version", "=", "versioned_outputs", "[", "output_id", "]", "\n", "\n", "# update predict_net", "\n", "_rename_versioned_blob_in_proto", "(", "\n", "predict_net", ",", "old_name", ",", "new_name", ",", "version", ",", "ssa", ",", "{", "}", ",", "blob_versions", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_sub_graph_external_input_output": [[750, 780], ["caffe2.python.core.get_ssa", "sum", "list", "range", "set", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "def", "get_sub_graph_external_input_output", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "sub_graph_op_indices", ":", "List", "[", "int", "]", "\n", ")", "->", "Tuple", "[", "List", "[", "Tuple", "[", "str", ",", "int", "]", "]", ",", "List", "[", "Tuple", "[", "str", ",", "int", "]", "]", "]", ":", "\n", "    ", "\"\"\"\n    Return the list of external input/output of sub-graph,\n    each element is tuple of the name and corresponding version in predict_net.\n\n    external input/output is defined the same way as caffe2 NetDef.\n    \"\"\"", "\n", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "\n", "all_inputs", "=", "[", "]", "\n", "all_outputs", "=", "[", "]", "\n", "for", "op_id", "in", "sub_graph_op_indices", ":", "\n", "        ", "all_inputs", "+=", "[", "inp", "for", "inp", "in", "ssa", "[", "op_id", "]", "[", "0", "]", "if", "inp", "not", "in", "all_inputs", "]", "\n", "all_outputs", "+=", "list", "(", "ssa", "[", "op_id", "]", "[", "1", "]", ")", "# ssa output won't repeat", "\n", "\n", "# for versioned blobs, external inputs are just those blob in all_inputs", "\n", "# but not in all_outputs", "\n", "", "ext_inputs", "=", "[", "inp", "for", "inp", "in", "all_inputs", "if", "inp", "not", "in", "all_outputs", "]", "\n", "\n", "# external outputs are essentially outputs of this subgraph that are used", "\n", "# outside of this sub-graph (including predict_net.external_output)", "\n", "all_other_inputs", "=", "sum", "(", "\n", "(", "ssa", "[", "i", "]", "[", "0", "]", "for", "i", "in", "range", "(", "len", "(", "ssa", ")", ")", "if", "i", "not", "in", "sub_graph_op_indices", ")", ",", "\n", "[", "(", "outp", ",", "versions", "[", "outp", "]", ")", "for", "outp", "in", "predict_net", ".", "external_output", "]", ",", "\n", ")", "\n", "ext_outputs", "=", "[", "outp", "for", "outp", "in", "all_outputs", "if", "outp", "in", "set", "(", "all_other_inputs", ")", "]", "\n", "\n", "return", "ext_inputs", ",", "ext_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._get_dependency_chain": [[825, 853], ["shared.get_consumer_map", "shared.get_producer_map", "shared.DiGraph.from_ssa", "DiGraph.from_ssa.get_all_paths", "sorted", "min", "len", "logger.warning", "set().union", "set", "set"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_consumer_map", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_producer_map", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.DiGraph.from_ssa", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.DiGraph.get_all_paths", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "", "def", "_get_dependency_chain", "(", "ssa", ",", "versioned_target", ",", "versioned_source", ")", ":", "\n", "    ", "\"\"\"\n    Return the index list of relevant operator to produce target blob from source blob,\n        if there's no dependency, return empty list.\n    \"\"\"", "\n", "\n", "# finding all paths between nodes can be O(N!), thus we can only search", "\n", "# in the subgraph using the op starting from the first consumer of source blob", "\n", "# to the producer of the target blob.", "\n", "consumer_map", "=", "get_consumer_map", "(", "ssa", ")", "\n", "producer_map", "=", "get_producer_map", "(", "ssa", ")", "\n", "start_op", "=", "min", "(", "x", "[", "0", "]", "for", "x", "in", "consumer_map", "[", "versioned_source", "]", ")", "-", "15", "\n", "end_op", "=", "(", "\n", "producer_map", "[", "versioned_target", "]", "[", "0", "]", "+", "15", "if", "versioned_target", "in", "producer_map", "else", "start_op", "\n", ")", "\n", "sub_graph_ssa", "=", "ssa", "[", "start_op", ":", "end_op", "+", "1", "]", "\n", "if", "len", "(", "sub_graph_ssa", ")", ">", "30", ":", "\n", "        ", "logger", ".", "warning", "(", "\n", "\"Subgraph bebetween {} and {} is large (from op#{} to op#{}), it\"", "\n", "\" might take non-trival time to find all paths between them.\"", ".", "format", "(", "\n", "versioned_source", ",", "versioned_target", ",", "start_op", ",", "end_op", "\n", ")", "\n", ")", "\n", "\n", "", "dag", "=", "DiGraph", ".", "from_ssa", "(", "sub_graph_ssa", ")", "\n", "paths", "=", "dag", ".", "get_all_paths", "(", "versioned_source", ",", "versioned_target", ")", "# include two ends", "\n", "ops_in_paths", "=", "[", "[", "producer_map", "[", "blob", "]", "[", "0", "]", "for", "blob", "in", "path", "[", "1", ":", "]", "]", "for", "path", "in", "paths", "]", "\n", "return", "sorted", "(", "set", "(", ")", ".", "union", "(", "*", "[", "set", "(", "ops", ")", "for", "ops", "in", "ops_in_paths", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.identify_reshape_sub_graph": [[855, 880], ["caffe2.python.core.get_ssa", "enumerate", "shared._get_dependency_chain", "ret.append", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared._get_dependency_chain"], ["", "def", "identify_reshape_sub_graph", "(", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ")", "->", "List", "[", "List", "[", "int", "]", "]", ":", "\n", "    ", "\"\"\"\n    Idenfity the reshape sub-graph in a protobuf.\n    The reshape sub-graph is defined as matching the following pattern:\n\n    (input_blob) -> Op_1 -> ... -> Op_N -> (new_shape) -\u2500\u2510\n        \u2514-------------------------------------------> Reshape -> (output_blob)\n\n    Return:\n        List of sub-graphs, each sub-graph is represented as a list of indices\n        of the relavent ops, [Op_1, Op_2, ..., Op_N, Reshape]\n    \"\"\"", "\n", "\n", "ssa", ",", "_", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "\n", "ret", "=", "[", "]", "\n", "for", "i", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", ":", "\n", "        ", "if", "op", ".", "type", "==", "\"Reshape\"", ":", "\n", "            ", "assert", "len", "(", "op", ".", "input", ")", "==", "2", "\n", "input_ssa", "=", "ssa", "[", "i", "]", "[", "0", "]", "\n", "data_source", "=", "input_ssa", "[", "0", "]", "\n", "shape_source", "=", "input_ssa", "[", "1", "]", "\n", "op_indices", "=", "_get_dependency_chain", "(", "ssa", ",", "shape_source", ",", "data_source", ")", "\n", "ret", ".", "append", "(", "op_indices", "+", "[", "i", "]", ")", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.remove_reshape_for_fc": [[882, 950], ["shared.identify_reshape_sub_graph", "copy.deepcopy", "copy.deepcopy.op.extend", "caffe2.python.core.get_ssa", "all", "logger.info", "shared.rename_op_output", "shared.get_sub_graph_external_input_output", "remove_op_ids.extend", "params_to_remove.extend", "logger.info", "copy.deepcopy.external_input.remove", "shared.get_sub_graph_external_input_output", "enumerate", "range", "sub_graphs_to_remove.append", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.identify_reshape_sub_graph", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.rename_op_output", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_sub_graph_external_input_output", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_sub_graph_external_input_output"], ["", "def", "remove_reshape_for_fc", "(", "predict_net", ",", "params", ")", ":", "\n", "    ", "\"\"\"\n    In PyTorch nn.Linear has to take 2D tensor, this often leads to reshape\n        a 4D tensor to 2D by calling .view(). However this (dynamic) reshaping\n        doesn't work well with ONNX and Int8 tools, and cause using extra\n        ops (eg. ExpandDims) that might not be available on mobile.\n    Luckily Caffe2 supports 4D tensor for FC, so we can remove those reshape\n        after exporting ONNX model.\n    \"\"\"", "\n", "from", "caffe2", ".", "python", "import", "core", "\n", "\n", "# find all reshape sub-graph that can be removed, which is now all Reshape", "\n", "# sub-graph whose output is only consumed by FC.", "\n", "# TODO: to make it safer, we may need the actually value to better determine", "\n", "# if a Reshape before FC is removable.", "\n", "reshape_sub_graphs", "=", "identify_reshape_sub_graph", "(", "predict_net", ")", "\n", "sub_graphs_to_remove", "=", "[", "]", "\n", "for", "reshape_sub_graph", "in", "reshape_sub_graphs", ":", "\n", "        ", "reshape_op_id", "=", "reshape_sub_graph", "[", "-", "1", "]", "\n", "assert", "predict_net", ".", "op", "[", "reshape_op_id", "]", ".", "type", "==", "\"Reshape\"", "\n", "ssa", ",", "_", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "reshape_output", "=", "ssa", "[", "reshape_op_id", "]", "[", "1", "]", "[", "0", "]", "\n", "consumers", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "ssa", ")", ")", "if", "reshape_output", "in", "ssa", "[", "i", "]", "[", "0", "]", "]", "\n", "if", "all", "(", "predict_net", ".", "op", "[", "consumer", "]", ".", "type", "==", "\"FC\"", "for", "consumer", "in", "consumers", ")", ":", "\n", "# safety check if the sub-graph is isolated, for this reshape sub-graph,", "\n", "# it means it has one non-param external input and one external output.", "\n", "            ", "ext_inputs", ",", "ext_outputs", "=", "get_sub_graph_external_input_output", "(", "\n", "predict_net", ",", "reshape_sub_graph", "\n", ")", "\n", "non_params_ext_inputs", "=", "[", "inp", "for", "inp", "in", "ext_inputs", "if", "inp", "[", "1", "]", "!=", "0", "]", "\n", "if", "len", "(", "non_params_ext_inputs", ")", "==", "1", "and", "len", "(", "ext_outputs", ")", "==", "1", ":", "\n", "                ", "sub_graphs_to_remove", ".", "append", "(", "reshape_sub_graph", ")", "\n", "\n", "# perform removing subgraph by:", "\n", "# 1: rename the Reshape's output to its input, then the graph can be", "\n", "#   seen as in-place itentify, meaning whose external input/output are the same.", "\n", "# 2: simply remove those ops.", "\n", "", "", "", "remove_op_ids", "=", "[", "]", "\n", "params_to_remove", "=", "[", "]", "\n", "for", "sub_graph", "in", "sub_graphs_to_remove", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "\"Remove Reshape sub-graph:\\n{}\"", ".", "format", "(", "\n", "\"\"", ".", "join", "(", "[", "\"(#{:>4})\\n{}\"", ".", "format", "(", "i", ",", "predict_net", ".", "op", "[", "i", "]", ")", "for", "i", "in", "sub_graph", "]", ")", "\n", ")", "\n", ")", "\n", "reshape_op_id", "=", "sub_graph", "[", "-", "1", "]", "\n", "new_reshap_output", "=", "predict_net", ".", "op", "[", "reshape_op_id", "]", ".", "input", "[", "0", "]", "\n", "rename_op_output", "(", "predict_net", ",", "reshape_op_id", ",", "0", ",", "new_reshap_output", ")", "\n", "ext_inputs", ",", "ext_outputs", "=", "get_sub_graph_external_input_output", "(", "predict_net", ",", "sub_graph", ")", "\n", "non_params_ext_inputs", "=", "[", "inp", "for", "inp", "in", "ext_inputs", "if", "inp", "[", "1", "]", "!=", "0", "]", "\n", "params_ext_inputs", "=", "[", "inp", "for", "inp", "in", "ext_inputs", "if", "inp", "[", "1", "]", "==", "0", "]", "\n", "assert", "len", "(", "non_params_ext_inputs", ")", "==", "1", "and", "len", "(", "ext_outputs", ")", "==", "1", "\n", "assert", "ext_outputs", "[", "0", "]", "[", "0", "]", "==", "non_params_ext_inputs", "[", "0", "]", "[", "0", "]", "\n", "assert", "ext_outputs", "[", "0", "]", "[", "1", "]", "==", "non_params_ext_inputs", "[", "0", "]", "[", "1", "]", "+", "1", "\n", "remove_op_ids", ".", "extend", "(", "sub_graph", ")", "\n", "params_to_remove", ".", "extend", "(", "params_ext_inputs", ")", "\n", "\n", "", "predict_net", "=", "copy", ".", "deepcopy", "(", "predict_net", ")", "\n", "new_ops", "=", "[", "op", "for", "i", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", "if", "i", "not", "in", "remove_op_ids", "]", "\n", "del", "predict_net", ".", "op", "[", ":", "]", "\n", "predict_net", ".", "op", ".", "extend", "(", "new_ops", ")", "\n", "for", "versioned_params", "in", "params_to_remove", ":", "\n", "        ", "name", "=", "versioned_params", "[", "0", "]", "\n", "logger", ".", "info", "(", "\"Remove params: {} from init_net and predict_net.external_input\"", ".", "format", "(", "name", ")", ")", "\n", "del", "params", "[", "name", "]", "\n", "predict_net", ".", "external_input", ".", "remove", "(", "name", ")", "\n", "\n", "", "return", "predict_net", ",", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.fuse_copy_between_cpu_and_gpu": [[952, 1008], ["shared.fuse_copy_between_cpu_and_gpu._fuse_once"], "function", ["None"], ["", "def", "fuse_copy_between_cpu_and_gpu", "(", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ")", ":", "\n", "    ", "\"\"\"\n    In-place fuse extra copy ops between cpu/gpu for the following case:\n        a -CopyAToB-> b -CopyBToA> c1 -NextOp1-> d1\n                        -CopyBToA> c2 -NextOp2-> d2\n    The fused network will look like:\n        a -NextOp1-> d1\n          -NextOp2-> d2\n    \"\"\"", "\n", "\n", "_COPY_OPS", "=", "[", "\"CopyCPUToGPU\"", ",", "\"CopyGPUToCPU\"", "]", "\n", "\n", "def", "_fuse_once", "(", "predict_net", ")", ":", "\n", "        ", "ssa", ",", "blob_versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "consumer_map", "=", "get_consumer_map", "(", "ssa", ")", "\n", "versioned_external_output", "=", "[", "\n", "(", "name", ",", "blob_versions", "[", "name", "]", ")", "for", "name", "in", "predict_net", ".", "external_output", "\n", "]", "\n", "\n", "for", "op_id", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", ":", "\n", "            ", "if", "op", ".", "type", "in", "_COPY_OPS", ":", "\n", "                ", "fw_copy_versioned_output", "=", "ssa", "[", "op_id", "]", "[", "1", "]", "[", "0", "]", "\n", "consumer_ids", "=", "[", "x", "[", "0", "]", "for", "x", "in", "consumer_map", "[", "fw_copy_versioned_output", "]", "]", "\n", "reverse_op_type", "=", "_COPY_OPS", "[", "1", "-", "_COPY_OPS", ".", "index", "(", "op", ".", "type", ")", "]", "\n", "\n", "is_fusable", "=", "(", "\n", "len", "(", "consumer_ids", ")", ">", "0", "\n", "and", "fw_copy_versioned_output", "not", "in", "versioned_external_output", "\n", "and", "all", "(", "\n", "predict_net", ".", "op", "[", "_op_id", "]", ".", "type", "==", "reverse_op_type", "\n", "and", "ssa", "[", "_op_id", "]", "[", "1", "]", "[", "0", "]", "not", "in", "versioned_external_output", "\n", "for", "_op_id", "in", "consumer_ids", "\n", ")", "\n", ")", "\n", "\n", "if", "is_fusable", ":", "\n", "                    ", "for", "rv_copy_op_id", "in", "consumer_ids", ":", "\n", "# making each NextOp uses \"a\" directly and removing Copy ops", "\n", "                        ", "rs_copy_versioned_output", "=", "ssa", "[", "rv_copy_op_id", "]", "[", "1", "]", "[", "0", "]", "\n", "next_op_id", ",", "inp_id", "=", "consumer_map", "[", "rs_copy_versioned_output", "]", "[", "0", "]", "\n", "predict_net", ".", "op", "[", "next_op_id", "]", ".", "input", "[", "inp_id", "]", "=", "op", ".", "input", "[", "0", "]", "\n", "# remove CopyOps", "\n", "", "new_ops", "=", "[", "\n", "op", "\n", "for", "i", ",", "op", "in", "enumerate", "(", "predict_net", ".", "op", ")", "\n", "if", "i", "!=", "op_id", "and", "i", "not", "in", "consumer_ids", "\n", "]", "\n", "del", "predict_net", ".", "op", "[", ":", "]", "\n", "predict_net", ".", "op", ".", "extend", "(", "new_ops", ")", "\n", "return", "True", "\n", "\n", "", "", "", "return", "False", "\n", "\n", "# _fuse_once returns False is nothing can be fused", "\n", "", "while", "_fuse_once", "(", "predict_net", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.remove_dead_end_ops": [[1010, 1035], ["caffe2.python.core.get_ssa", "shared.get_consumer_map", "set", "reversed", "net_def.op.extend", "list", "all", "enumerate", "set.add", "enumerate", "shared.remove_dead_end_ops._is_dead_end"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_consumer_map", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.add"], ["", "", "def", "remove_dead_end_ops", "(", "net_def", ":", "caffe2_pb2", ".", "NetDef", ")", ":", "\n", "    ", "\"\"\" remove ops if its output is not used or not in external_output \"\"\"", "\n", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "net_def", ")", "\n", "versioned_external_output", "=", "[", "(", "name", ",", "versions", "[", "name", "]", ")", "for", "name", "in", "net_def", ".", "external_output", "]", "\n", "consumer_map", "=", "get_consumer_map", "(", "ssa", ")", "\n", "removed_op_ids", "=", "set", "(", ")", "\n", "\n", "def", "_is_dead_end", "(", "versioned_blob", ")", ":", "\n", "        ", "return", "not", "(", "\n", "versioned_blob", "in", "versioned_external_output", "\n", "or", "(", "\n", "len", "(", "consumer_map", "[", "versioned_blob", "]", ")", ">", "0", "\n", "and", "all", "(", "x", "[", "0", "]", "not", "in", "removed_op_ids", "for", "x", "in", "consumer_map", "[", "versioned_blob", "]", ")", "\n", ")", "\n", ")", "\n", "\n", "", "for", "i", ",", "ssa_i", "in", "reversed", "(", "list", "(", "enumerate", "(", "ssa", ")", ")", ")", ":", "\n", "        ", "versioned_outputs", "=", "ssa_i", "[", "1", "]", "\n", "if", "all", "(", "_is_dead_end", "(", "outp", ")", "for", "outp", "in", "versioned_outputs", ")", ":", "\n", "            ", "removed_op_ids", ".", "add", "(", "i", ")", "\n", "\n", "# simply removing those deadend ops should have no effect to external_output", "\n", "", "", "new_ops", "=", "[", "op", "for", "i", ",", "op", "in", "enumerate", "(", "net_def", ".", "op", ")", "if", "i", "not", "in", "removed_op_ids", "]", "\n", "del", "net_def", ".", "op", "[", ":", "]", "\n", "net_def", ".", "op", ".", "extend", "(", "new_ops", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch.__init__": [[145, 156], ["super().__init__", "caffe2_modeling.Caffe2MetaArch.eval", "caffe2_modeling.set_caffe2_compatible_tensor_mode"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.set_caffe2_compatible_tensor_mode"], ["def", "__init__", "(", "self", ",", "cfg", ",", "torch_model", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            torch_model (nn.Module): the detectron2 model (meta_arch) to be\n                converted.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_wrapped_model", "=", "torch_model", "\n", "self", ".", "eval", "(", ")", "\n", "set_caffe2_compatible_tensor_mode", "(", "self", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch.get_caffe2_inputs": [[157, 179], ["caffe2_modeling.convert_batched_inputs_to_c2_format"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.convert_batched_inputs_to_c2_format"], ["", "def", "get_caffe2_inputs", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Convert pytorch-style structured inputs to caffe2-style inputs that\n        are tuples of tensors.\n\n        Args:\n            batched_inputs (list[dict]): inputs to a detectron2 model\n                in its standard format. Each dict has \"image\" (CHW tensor), and optionally\n                \"height\" and \"width\".\n\n        Returns:\n            tuple[Tensor]:\n                tuple of tensors that will be the inputs to the\n                :meth:`forward` method. For existing models, the first\n                is an NCHW tensor (padded and batched); the second is\n                a im_info Nx3 tensor, where the rows are\n                (height, width, unused legacy parameter)\n        \"\"\"", "\n", "return", "convert_batched_inputs_to_c2_format", "(", "\n", "batched_inputs", ",", "\n", "self", ".", "_wrapped_model", ".", "backbone", ".", "size_divisibility", ",", "\n", "self", ".", "_wrapped_model", ".", "device", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch.encode_additional_info": [[181, 186], ["None"], "methods", ["None"], ["", "def", "encode_additional_info", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "\"\"\"\n        Save extra metadata that will be used by inference in the output protobuf.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch.forward": [[187, 201], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Run the forward in caffe2-style. It has to use caffe2-compatible ops\n        and the method will be used for tracing.\n\n        Args:\n            inputs (tuple[Tensor]): inputs defined by :meth:`get_caffe2_input`.\n                They will be the inputs of the converted caffe2 graph.\n\n        Returns:\n            tuple[Tensor]: output tensors. They will be the outputs of the\n                converted caffe2 graph.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch._caffe2_preprocess_image": [[202, 218], ["shared.alias", "shared.alias", "shared.alias", "detectron2.structures.ImageList"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias"], ["", "def", "_caffe2_preprocess_image", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Caffe2 implementation of preprocess_image, which is called inside each MetaArch's forward.\n        It normalizes the input images, and the final caffe2 graph assumes the\n        inputs have been batched already.\n        \"\"\"", "\n", "data", ",", "im_info", "=", "inputs", "\n", "data", "=", "alias", "(", "data", ",", "\"data\"", ")", "\n", "im_info", "=", "alias", "(", "im_info", ",", "\"im_info\"", ")", "\n", "mean", ",", "std", "=", "self", ".", "_wrapped_model", ".", "pixel_mean", ",", "self", ".", "_wrapped_model", ".", "pixel_std", "\n", "normalized_data", "=", "(", "data", "-", "mean", ")", "/", "std", "\n", "normalized_data", "=", "alias", "(", "normalized_data", ",", "\"normalized_data\"", ")", "\n", "\n", "# Pack (data, im_info) into ImageList which is recognized by self.inference.", "\n", "images", "=", "ImageList", "(", "tensor", "=", "normalized_data", ",", "image_sizes", "=", "im_info", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch.get_outputs_converter": [[219, 246], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "\"\"\"\n        Creates a function that converts outputs of the caffe2 model to\n        detectron2's standard format.\n        The function uses information in `predict_net` and `init_net` that are\n        available at inferene time. Therefore the function logic can be used in inference.\n\n        The returned function has the following signature:\n\n            def convert(batched_inputs, c2_inputs, c2_results) -> detectron2_outputs\n\n        Where\n\n            * batched_inputs (list[dict]): the original input format of the meta arch\n            * c2_inputs (dict[str, Tensor]): the caffe2 inputs.\n            * c2_results (dict[str, Tensor]): the caffe2 output format,\n                corresponding to the outputs of the :meth:`forward` function.\n            * detectron2_outputs: the original output format of the meta arch.\n\n        This function can be used to compare the outputs of the original meta arch and\n        the converted caffe2 graph.\n\n        Returns:\n            callable: a callable of the above signature.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2GeneralizedRCNN.__init__": [[249, 255], ["isinstance", "patcher.patch_generalized_rcnn", "caffe2_modeling.Caffe2MetaArch.__init__", "patcher.ROIHeadsPatcher"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch_generalized_rcnn", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "torch_model", ")", ":", "\n", "        ", "assert", "isinstance", "(", "torch_model", ",", "meta_arch", ".", "GeneralizedRCNN", ")", "\n", "torch_model", "=", "patch_generalized_rcnn", "(", "torch_model", ")", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "torch_model", ")", "\n", "\n", "self", ".", "roi_heads_patcher", "=", "ROIHeadsPatcher", "(", "cfg", ",", "self", ".", "_wrapped_model", ".", "roi_heads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2GeneralizedRCNN.encode_additional_info": [[256, 263], ["shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "str.encode", "str"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg"], ["", "def", "encode_additional_info", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "size_divisibility", "=", "self", ".", "_wrapped_model", ".", "backbone", ".", "size_divisibility", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"size_divisibility\"", ",", "\"i\"", ",", "size_divisibility", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"device\"", ",", "\"s\"", ",", "str", ".", "encode", "(", "str", "(", "self", ".", "_wrapped_model", ".", "device", ")", ",", "\"ascii\"", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"meta_architecture\"", ",", "\"s\"", ",", "b\"GeneralizedRCNN\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2GeneralizedRCNN.forward": [[264, 274], ["shared.mock_torch_nn_functional_interpolate", "caffe2_modeling.Caffe2GeneralizedRCNN._caffe2_preprocess_image", "caffe2_modeling.Caffe2GeneralizedRCNN._wrapped_model.backbone", "caffe2_modeling.Caffe2GeneralizedRCNN._wrapped_model.proposal_generator", "tuple", "caffe2_modeling.Caffe2GeneralizedRCNN._wrapped_model.inference", "caffe2_modeling.Caffe2GeneralizedRCNN.roi_heads_patcher.mock_roi_heads", "caffe2_modeling.Caffe2GeneralizedRCNN._wrapped_model.roi_heads", "detector_results[].flatten"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.mock_torch_nn_functional_interpolate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch._caffe2_preprocess_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.ROIHeadsPatcher.mock_roi_heads", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "@", "mock_torch_nn_functional_interpolate", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "not", "self", ".", "tensor_mode", ":", "\n", "            ", "return", "self", ".", "_wrapped_model", ".", "inference", "(", "inputs", ")", "\n", "", "images", "=", "self", ".", "_caffe2_preprocess_image", "(", "inputs", ")", "\n", "features", "=", "self", ".", "_wrapped_model", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "proposals", ",", "_", "=", "self", ".", "_wrapped_model", ".", "proposal_generator", "(", "images", ",", "features", ")", "\n", "with", "self", ".", "roi_heads_patcher", ".", "mock_roi_heads", "(", ")", ":", "\n", "            ", "detector_results", ",", "_", "=", "self", ".", "_wrapped_model", ".", "roi_heads", "(", "images", ",", "features", ",", "proposals", ")", "\n", "", "return", "tuple", "(", "detector_results", "[", "0", "]", ".", "flatten", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2GeneralizedRCNN.get_outputs_converter": [[275, 283], ["caffe2_modeling.assemble_rcnn_outputs_by_name", "detectron2.modeling.meta_arch.GeneralizedRCNN._postprocess", "int", "int"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.assemble_rcnn_outputs_by_name", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch._postprocess"], ["", "@", "staticmethod", "\n", "def", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "def", "f", "(", "batched_inputs", ",", "c2_inputs", ",", "c2_results", ")", ":", "\n", "            ", "image_sizes", "=", "[", "[", "int", "(", "im", "[", "0", "]", ")", ",", "int", "(", "im", "[", "1", "]", ")", "]", "for", "im", "in", "c2_inputs", "[", "\"im_info\"", "]", "]", "\n", "results", "=", "assemble_rcnn_outputs_by_name", "(", "image_sizes", ",", "c2_results", ")", "\n", "return", "meta_arch", ".", "GeneralizedRCNN", ".", "_postprocess", "(", "results", ",", "batched_inputs", ",", "image_sizes", ")", "\n", "\n", "", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2PanopticFPN.__init__": [[286, 292], ["isinstance", "patcher.patch_generalized_rcnn", "caffe2_modeling.Caffe2MetaArch.__init__", "patcher.ROIHeadsPatcher"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.patch_generalized_rcnn", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "torch_model", ")", ":", "\n", "        ", "assert", "isinstance", "(", "torch_model", ",", "meta_arch", ".", "PanopticFPN", ")", "\n", "torch_model", "=", "patch_generalized_rcnn", "(", "torch_model", ")", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "torch_model", ")", "\n", "\n", "self", ".", "roi_heads_patcher", "=", "ROIHeadsPatcher", "(", "cfg", ",", "self", ".", "_wrapped_model", ".", "roi_heads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2PanopticFPN.forward": [[293, 308], ["shared.mock_torch_nn_functional_interpolate", "caffe2_modeling.Caffe2PanopticFPN._caffe2_preprocess_image", "caffe2_modeling.Caffe2PanopticFPN._wrapped_model.backbone", "caffe2_modeling.Caffe2PanopticFPN._wrapped_model.sem_seg_head", "shared.alias", "caffe2_modeling.Caffe2PanopticFPN._wrapped_model.proposal_generator", "caffe2_modeling.Caffe2PanopticFPN.roi_heads_patcher.mock_roi_heads", "caffe2_modeling.Caffe2PanopticFPN._wrapped_model.roi_heads", "tuple", "detector_results[].flatten"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.mock_torch_nn_functional_interpolate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch._caffe2_preprocess_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.patcher.ROIHeadsPatcher.mock_roi_heads", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "@", "mock_torch_nn_functional_interpolate", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "assert", "self", ".", "tensor_mode", "\n", "images", "=", "self", ".", "_caffe2_preprocess_image", "(", "inputs", ")", "\n", "features", "=", "self", ".", "_wrapped_model", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "sem_seg_results", ",", "_", "=", "self", ".", "_wrapped_model", ".", "sem_seg_head", "(", "features", ")", "\n", "sem_seg_results", "=", "alias", "(", "sem_seg_results", ",", "\"sem_seg\"", ")", "\n", "\n", "proposals", ",", "_", "=", "self", ".", "_wrapped_model", ".", "proposal_generator", "(", "images", ",", "features", ")", "\n", "\n", "with", "self", ".", "roi_heads_patcher", ".", "mock_roi_heads", "(", "self", ".", "tensor_mode", ")", ":", "\n", "            ", "detector_results", ",", "_", "=", "self", ".", "_wrapped_model", ".", "roi_heads", "(", "images", ",", "features", ",", "proposals", ")", "\n", "\n", "", "return", "tuple", "(", "detector_results", "[", "0", "]", ".", "flatten", "(", ")", ")", "+", "(", "sem_seg_results", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2PanopticFPN.encode_additional_info": [[309, 336], ["shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "str.encode", "caffe2_modeling._cast_to_f32", "caffe2_modeling._cast_to_f32", "str"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling._cast_to_f32", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling._cast_to_f32"], ["", "def", "encode_additional_info", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "size_divisibility", "=", "self", ".", "_wrapped_model", ".", "backbone", ".", "size_divisibility", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"size_divisibility\"", ",", "\"i\"", ",", "size_divisibility", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"device\"", ",", "\"s\"", ",", "str", ".", "encode", "(", "str", "(", "self", ".", "_wrapped_model", ".", "device", ")", ",", "\"ascii\"", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"meta_architecture\"", ",", "\"s\"", ",", "b\"PanopticFPN\"", ")", "\n", "\n", "# Inference parameters:", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"combine_on\"", ",", "\"i\"", ",", "self", ".", "_wrapped_model", ".", "combine_on", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"combine_overlap_threshold\"", ",", "\n", "\"f\"", ",", "\n", "_cast_to_f32", "(", "self", ".", "_wrapped_model", ".", "combine_overlap_threshold", ")", ",", "\n", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"combine_stuff_area_limit\"", ",", "\n", "\"i\"", ",", "\n", "self", ".", "_wrapped_model", ".", "combine_stuff_area_limit", ",", "\n", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"combine_instances_confidence_threshold\"", ",", "\n", "\"f\"", ",", "\n", "_cast_to_f32", "(", "self", ".", "_wrapped_model", ".", "combine_instances_confidence_threshold", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2PanopticFPN.get_outputs_converter": [[338, 378], ["shared.get_pb_arg_vali", "shared.get_pb_arg_valf", "shared.get_pb_arg_vali", "shared.get_pb_arg_valf", "caffe2_modeling.assemble_rcnn_outputs_by_name", "zip", "input_per_image.get", "input_per_image.get", "detectron2.modeling.postprocessing.sem_seg_postprocess", "detectron2.modeling.postprocessing.detector_postprocess", "processed_results.append", "int", "int", "detectron2.modeling.meta_arch.panoptic_fpn.combine_semantic_and_instance_outputs", "detectron2.modeling.postprocessing.sem_seg_postprocess.argmax"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_valf", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_valf", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.assemble_rcnn_outputs_by_name", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.detector_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.panoptic_fpn.combine_semantic_and_instance_outputs"], ["", "@", "staticmethod", "\n", "def", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "combine_on", "=", "get_pb_arg_vali", "(", "predict_net", ",", "\"combine_on\"", ",", "None", ")", "\n", "combine_overlap_threshold", "=", "get_pb_arg_valf", "(", "predict_net", ",", "\"combine_overlap_threshold\"", ",", "None", ")", "\n", "combine_stuff_area_limit", "=", "get_pb_arg_vali", "(", "predict_net", ",", "\"combine_stuff_area_limit\"", ",", "None", ")", "\n", "combine_instances_confidence_threshold", "=", "get_pb_arg_valf", "(", "\n", "predict_net", ",", "\"combine_instances_confidence_threshold\"", ",", "None", "\n", ")", "\n", "\n", "def", "f", "(", "batched_inputs", ",", "c2_inputs", ",", "c2_results", ")", ":", "\n", "            ", "image_sizes", "=", "[", "[", "int", "(", "im", "[", "0", "]", ")", ",", "int", "(", "im", "[", "1", "]", ")", "]", "for", "im", "in", "c2_inputs", "[", "\"im_info\"", "]", "]", "\n", "detector_results", "=", "assemble_rcnn_outputs_by_name", "(", "\n", "image_sizes", ",", "c2_results", ",", "force_mask_on", "=", "True", "\n", ")", "\n", "sem_seg_results", "=", "c2_results", "[", "\"sem_seg\"", "]", "\n", "\n", "# copied from meta_arch/panoptic_fpn.py ...", "\n", "processed_results", "=", "[", "]", "\n", "for", "sem_seg_result", ",", "detector_result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "sem_seg_results", ",", "detector_results", ",", "batched_inputs", ",", "image_sizes", "\n", ")", ":", "\n", "                ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "sem_seg_r", "=", "sem_seg_postprocess", "(", "sem_seg_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "detector_r", "=", "detector_postprocess", "(", "detector_result", ",", "height", ",", "width", ")", "\n", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "sem_seg_r", ",", "\"instances\"", ":", "detector_r", "}", ")", "\n", "\n", "if", "combine_on", ":", "\n", "                    ", "panoptic_r", "=", "combine_semantic_and_instance_outputs", "(", "\n", "detector_r", ",", "\n", "sem_seg_r", ".", "argmax", "(", "dim", "=", "0", ")", ",", "\n", "combine_overlap_threshold", ",", "\n", "combine_stuff_area_limit", ",", "\n", "combine_instances_confidence_threshold", ",", "\n", ")", "\n", "processed_results", "[", "-", "1", "]", "[", "\"panoptic_seg\"", "]", "=", "panoptic_r", "\n", "", "", "return", "processed_results", "\n", "\n", "", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2RetinaNet.__init__": [[381, 384], ["isinstance", "caffe2_modeling.Caffe2MetaArch.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "torch_model", ")", ":", "\n", "        ", "assert", "isinstance", "(", "torch_model", ",", "meta_arch", ".", "RetinaNet", ")", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "torch_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2RetinaNet.forward": [[385, 406], ["shared.mock_torch_nn_functional_interpolate", "caffe2_modeling.Caffe2RetinaNet._caffe2_preprocess_image", "caffe2_modeling.Caffe2RetinaNet._wrapped_model.backbone", "enumerate", "caffe2_modeling.Caffe2RetinaNet._wrapped_model.head", "enumerate", "tuple", "shared.alias", "return_tensors.append", "zip", "return_tensors.append", "return_tensors.append", "shared.alias", "shared.alias"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.mock_torch_nn_functional_interpolate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch._caffe2_preprocess_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias"], ["", "@", "mock_torch_nn_functional_interpolate", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "assert", "self", ".", "tensor_mode", "\n", "images", "=", "self", ".", "_caffe2_preprocess_image", "(", "inputs", ")", "\n", "\n", "# explicitly return the images sizes to avoid removing \"im_info\" by ONNX", "\n", "# since it's not used in the forward path", "\n", "return_tensors", "=", "[", "images", ".", "image_sizes", "]", "\n", "\n", "features", "=", "self", ".", "_wrapped_model", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "_wrapped_model", ".", "in_features", "]", "\n", "for", "i", ",", "feature_i", "in", "enumerate", "(", "features", ")", ":", "\n", "            ", "features", "[", "i", "]", "=", "alias", "(", "feature_i", ",", "\"feature_{}\"", ".", "format", "(", "i", ")", ",", "is_backward", "=", "True", ")", "\n", "return_tensors", ".", "append", "(", "features", "[", "i", "]", ")", "\n", "\n", "", "pred_logits", ",", "pred_anchor_deltas", "=", "self", ".", "_wrapped_model", ".", "head", "(", "features", ")", "\n", "for", "i", ",", "(", "box_cls_i", ",", "box_delta_i", ")", "in", "enumerate", "(", "zip", "(", "pred_logits", ",", "pred_anchor_deltas", ")", ")", ":", "\n", "            ", "return_tensors", ".", "append", "(", "alias", "(", "box_cls_i", ",", "\"box_cls_{}\"", ".", "format", "(", "i", ")", ")", ")", "\n", "return_tensors", ".", "append", "(", "alias", "(", "box_delta_i", ",", "\"box_delta_{}\"", ".", "format", "(", "i", ")", ")", ")", "\n", "\n", "", "return", "tuple", "(", "return_tensors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2RetinaNet.encode_additional_info": [[407, 437], ["shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "shared.check_set_pb_arg", "caffe2_modeling.Caffe2RetinaNet._encode_anchor_generator_cfg", "str.encode", "caffe2_modeling._cast_to_f32", "caffe2_modeling._cast_to_f32", "str", "caffe2_modeling._cast_to_f32"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2RetinaNet._encode_anchor_generator_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling._cast_to_f32", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling._cast_to_f32", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling._cast_to_f32"], ["", "def", "encode_additional_info", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "size_divisibility", "=", "self", ".", "_wrapped_model", ".", "backbone", ".", "size_divisibility", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"size_divisibility\"", ",", "\"i\"", ",", "size_divisibility", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"device\"", ",", "\"s\"", ",", "str", ".", "encode", "(", "str", "(", "self", ".", "_wrapped_model", ".", "device", ")", ",", "\"ascii\"", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"meta_architecture\"", ",", "\"s\"", ",", "b\"RetinaNet\"", ")", "\n", "\n", "# Inference parameters:", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"score_threshold\"", ",", "\"f\"", ",", "_cast_to_f32", "(", "self", ".", "_wrapped_model", ".", "score_threshold", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"topk_candidates\"", ",", "\"i\"", ",", "self", ".", "_wrapped_model", ".", "topk_candidates", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\"nms_threshold\"", ",", "\"f\"", ",", "_cast_to_f32", "(", "self", ".", "_wrapped_model", ".", "nms_threshold", ")", "\n", ")", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"max_detections_per_image\"", ",", "\n", "\"i\"", ",", "\n", "self", ".", "_wrapped_model", ".", "max_detections_per_image", ",", "\n", ")", "\n", "\n", "check_set_pb_arg", "(", "\n", "predict_net", ",", "\n", "\"bbox_reg_weights\"", ",", "\n", "\"floats\"", ",", "\n", "[", "_cast_to_f32", "(", "w", ")", "for", "w", "in", "self", ".", "_wrapped_model", ".", "box2box_transform", ".", "weights", "]", ",", "\n", ")", "\n", "self", ".", "_encode_anchor_generator_cfg", "(", "predict_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2RetinaNet._encode_anchor_generator_cfg": [[438, 446], ["io.BytesIO", "torch.save", "io.BytesIO.getvalue", "shared.check_set_pb_arg"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.check_set_pb_arg"], ["", "def", "_encode_anchor_generator_cfg", "(", "self", ",", "predict_net", ")", ":", "\n", "# serialize anchor_generator for future use", "\n", "        ", "serialized_anchor_generator", "=", "io", ".", "BytesIO", "(", ")", "\n", "torch", ".", "save", "(", "self", ".", "_wrapped_model", ".", "anchor_generator", ",", "serialized_anchor_generator", ")", "\n", "# Ideally we can put anchor generating inside the model, then we don't", "\n", "# need to store this information.", "\n", "bytes", "=", "serialized_anchor_generator", ".", "getvalue", "(", ")", "\n", "check_set_pb_arg", "(", "predict_net", ",", "\"serialized_anchor_generator\"", ",", "\"s\"", ",", "bytes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2RetinaNet.get_outputs_converter": [[447, 491], ["types.SimpleNamespace", "io.BytesIO", "torch.load", "shared.get_pb_arg_floats", "detectron2.modeling.box_regression.Box2BoxTransform", "shared.get_pb_arg_valf", "shared.get_pb_arg_vali", "shared.get_pb_arg_valf", "shared.get_pb_arg_vali", "functools.partial", "functools.partial", "shared.get_pb_arg_vals", "len", "types.SimpleNamespace.anchor_generator", "types.SimpleNamespace.inference", "detectron2.modeling.meta_arch.GeneralizedRCNN._postprocess", "tuple", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "int", "int", "range", "range", "x.clone", "c2_results.keys", "x.startswith"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_floats", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_valf", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_valf", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch._postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "@", "staticmethod", "\n", "def", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "self", "=", "types", ".", "SimpleNamespace", "(", ")", "\n", "serialized_anchor_generator", "=", "io", ".", "BytesIO", "(", "\n", "get_pb_arg_vals", "(", "predict_net", ",", "\"serialized_anchor_generator\"", ",", "None", ")", "\n", ")", "\n", "self", ".", "anchor_generator", "=", "torch", ".", "load", "(", "serialized_anchor_generator", ")", "\n", "bbox_reg_weights", "=", "get_pb_arg_floats", "(", "predict_net", ",", "\"bbox_reg_weights\"", ",", "None", ")", "\n", "self", ".", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "tuple", "(", "bbox_reg_weights", ")", ")", "\n", "self", ".", "score_threshold", "=", "get_pb_arg_valf", "(", "predict_net", ",", "\"score_threshold\"", ",", "None", ")", "\n", "self", ".", "topk_candidates", "=", "get_pb_arg_vali", "(", "predict_net", ",", "\"topk_candidates\"", ",", "None", ")", "\n", "self", ".", "nms_threshold", "=", "get_pb_arg_valf", "(", "predict_net", ",", "\"nms_threshold\"", ",", "None", ")", "\n", "self", ".", "max_detections_per_image", "=", "get_pb_arg_vali", "(", "\n", "predict_net", ",", "\"max_detections_per_image\"", ",", "None", "\n", ")", "\n", "\n", "# hack to reuse inference code from RetinaNet", "\n", "self", ".", "inference", "=", "functools", ".", "partial", "(", "meta_arch", ".", "RetinaNet", ".", "inference", ",", "self", ")", "\n", "self", ".", "inference_single_image", "=", "functools", ".", "partial", "(", "\n", "meta_arch", ".", "RetinaNet", ".", "inference_single_image", ",", "self", "\n", ")", "\n", "\n", "def", "f", "(", "batched_inputs", ",", "c2_inputs", ",", "c2_results", ")", ":", "\n", "            ", "image_sizes", "=", "[", "[", "int", "(", "im", "[", "0", "]", ")", ",", "int", "(", "im", "[", "1", "]", ")", "]", "for", "im", "in", "c2_inputs", "[", "\"im_info\"", "]", "]", "\n", "\n", "num_features", "=", "len", "(", "[", "x", "for", "x", "in", "c2_results", ".", "keys", "(", ")", "if", "x", ".", "startswith", "(", "\"box_cls_\"", ")", "]", ")", "\n", "pred_logits", "=", "[", "c2_results", "[", "\"box_cls_{}\"", ".", "format", "(", "i", ")", "]", "for", "i", "in", "range", "(", "num_features", ")", "]", "\n", "pred_anchor_deltas", "=", "[", "c2_results", "[", "\"box_delta_{}\"", ".", "format", "(", "i", ")", "]", "for", "i", "in", "range", "(", "num_features", ")", "]", "\n", "\n", "# For each feature level, feature should have the same batch size and", "\n", "# spatial dimension as the box_cls and box_delta.", "\n", "dummy_features", "=", "[", "x", ".", "clone", "(", ")", "[", ":", ",", "0", ":", "0", ",", ":", ",", ":", "]", "for", "x", "in", "pred_logits", "]", "\n", "anchors", "=", "self", ".", "anchor_generator", "(", "dummy_features", ")", "\n", "\n", "# self.num_classess can be inferred", "\n", "self", ".", "num_classes", "=", "pred_logits", "[", "0", "]", ".", "shape", "[", "1", "]", "//", "(", "pred_anchor_deltas", "[", "0", "]", ".", "shape", "[", "1", "]", "//", "4", ")", "\n", "\n", "pred_logits", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "self", ".", "num_classes", ")", "for", "x", "in", "pred_logits", "]", "\n", "pred_anchor_deltas", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "4", ")", "for", "x", "in", "pred_anchor_deltas", "]", "\n", "\n", "results", "=", "self", ".", "inference", "(", "anchors", ",", "pred_logits", ",", "pred_anchor_deltas", ",", "image_sizes", ")", "\n", "return", "meta_arch", ".", "GeneralizedRCNN", ".", "_postprocess", "(", "results", ",", "batched_inputs", ",", "image_sizes", ")", "\n", "\n", "", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.assemble_rcnn_outputs_by_name": [[30, 96], ["tensor_outputs.get", "class_nms.to", "tensor_outputs.get", "tensor_outputs.get", "tensor_outputs.get", "detectron2.structures.Instances", "NotImplementedError", "len", "detectron2.structures.RotatedBoxes", "detectron2.structures.Boxes", "torch.arange", "torch.zeros", "keypoints_tensor.transpose", "detectron2.modeling.roi_heads.keypoint_head.keypoint_rcnn_inference"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.keypoint_head.keypoint_rcnn_inference"], ["def", "assemble_rcnn_outputs_by_name", "(", "image_sizes", ",", "tensor_outputs", ",", "force_mask_on", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    A function to assemble caffe2 model's outputs (i.e. Dict[str, Tensor])\n    to detectron2's format (i.e. list of Instances instance).\n    This only works when the model follows the Caffe2 detectron's naming convention.\n\n    Args:\n        image_sizes (List[List[int, int]]): [H, W] of every image.\n        tensor_outputs (Dict[str, Tensor]): external_output to its tensor.\n\n        force_mask_on (Bool): if true, the it make sure there'll be pred_masks even\n            if the mask is not found from tensor_outputs (usually due to model crash)\n    \"\"\"", "\n", "\n", "results", "=", "[", "Instances", "(", "image_size", ")", "for", "image_size", "in", "image_sizes", "]", "\n", "\n", "batch_splits", "=", "tensor_outputs", ".", "get", "(", "\"batch_splits\"", ",", "None", ")", "\n", "if", "batch_splits", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "", "assert", "len", "(", "image_sizes", ")", "==", "1", "\n", "result", "=", "results", "[", "0", "]", "\n", "\n", "bbox_nms", "=", "tensor_outputs", "[", "\"bbox_nms\"", "]", "\n", "score_nms", "=", "tensor_outputs", "[", "\"score_nms\"", "]", "\n", "class_nms", "=", "tensor_outputs", "[", "\"class_nms\"", "]", "\n", "# Detection will always success because Conv support 0-batch", "\n", "assert", "bbox_nms", "is", "not", "None", "\n", "assert", "score_nms", "is", "not", "None", "\n", "assert", "class_nms", "is", "not", "None", "\n", "if", "bbox_nms", ".", "shape", "[", "1", "]", "==", "5", ":", "\n", "        ", "result", ".", "pred_boxes", "=", "RotatedBoxes", "(", "bbox_nms", ")", "\n", "", "else", ":", "\n", "        ", "result", ".", "pred_boxes", "=", "Boxes", "(", "bbox_nms", ")", "\n", "", "result", ".", "scores", "=", "score_nms", "\n", "result", ".", "pred_classes", "=", "class_nms", ".", "to", "(", "torch", ".", "int64", ")", "\n", "\n", "mask_fcn_probs", "=", "tensor_outputs", ".", "get", "(", "\"mask_fcn_probs\"", ",", "None", ")", "\n", "if", "mask_fcn_probs", "is", "not", "None", ":", "\n", "# finish the mask pred", "\n", "        ", "mask_probs_pred", "=", "mask_fcn_probs", "\n", "num_masks", "=", "mask_probs_pred", ".", "shape", "[", "0", "]", "\n", "class_pred", "=", "result", ".", "pred_classes", "\n", "indices", "=", "torch", ".", "arange", "(", "num_masks", ",", "device", "=", "class_pred", ".", "device", ")", "\n", "mask_probs_pred", "=", "mask_probs_pred", "[", "indices", ",", "class_pred", "]", "[", ":", ",", "None", "]", "\n", "result", ".", "pred_masks", "=", "mask_probs_pred", "\n", "", "elif", "force_mask_on", ":", "\n", "# NOTE: there's no way to know the height/width of mask here, it won't be", "\n", "# used anyway when batch size is 0, so just set them to 0.", "\n", "        ", "result", ".", "pred_masks", "=", "torch", ".", "zeros", "(", "[", "0", ",", "1", ",", "0", ",", "0", "]", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "\n", "", "keypoints_out", "=", "tensor_outputs", ".", "get", "(", "\"keypoints_out\"", ",", "None", ")", "\n", "kps_score", "=", "tensor_outputs", ".", "get", "(", "\"kps_score\"", ",", "None", ")", "\n", "if", "keypoints_out", "is", "not", "None", ":", "\n", "# keypoints_out: [N, 4, #kypoints], where 4 is in order of (x, y, score, prob)", "\n", "        ", "keypoints_tensor", "=", "keypoints_out", "\n", "# NOTE: it's possible that prob is not calculated if \"should_output_softmax\"", "\n", "# is set to False in HeatmapMaxKeypoint, so just using raw score, seems", "\n", "# it doesn't affect mAP. TODO: check more carefully.", "\n", "keypoint_xyp", "=", "keypoints_tensor", ".", "transpose", "(", "1", ",", "2", ")", "[", ":", ",", ":", ",", "[", "0", ",", "1", ",", "2", "]", "]", "\n", "result", ".", "pred_keypoints", "=", "keypoint_xyp", "\n", "", "elif", "kps_score", "is", "not", "None", ":", "\n", "# keypoint heatmap to sparse data structure", "\n", "        ", "pred_keypoint_logits", "=", "kps_score", "\n", "keypoint_head", ".", "keypoint_rcnn_inference", "(", "pred_keypoint_logits", ",", "[", "result", "]", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling._cast_to_f32": [[98, 100], ["struct.unpack", "struct.pack"], "function", ["None"], ["", "def", "_cast_to_f32", "(", "f64", ")", ":", "\n", "    ", "return", "struct", ".", "unpack", "(", "\"f\"", ",", "struct", ".", "pack", "(", "\"f\"", ",", "f64", ")", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.set_caffe2_compatible_tensor_mode": [[102, 108], ["model.apply", "isinstance"], "function", ["None"], ["", "def", "set_caffe2_compatible_tensor_mode", "(", "model", ",", "enable", "=", "True", ")", ":", "\n", "    ", "def", "_fn", "(", "m", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "Caffe2Compatible", ")", ":", "\n", "            ", "m", ".", "tensor_mode", "=", "enable", "\n", "\n", "", "", "model", ".", "apply", "(", "_fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.convert_batched_inputs_to_c2_format": [[110, 136], ["all", "all", "detectron2.structures.ImageList.from_tensors", "zip", "torch.Tensor", "input_per_image.get", "input_per_image.get", "torch.Tensor.append", "ImageList.from_tensors.tensor.to", "torch.Tensor.to", "isinstance", "x[].dim"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "convert_batched_inputs_to_c2_format", "(", "batched_inputs", ",", "size_divisibility", ",", "device", ")", ":", "\n", "    ", "\"\"\"\n    See get_caffe2_inputs() below.\n    \"\"\"", "\n", "assert", "all", "(", "isinstance", "(", "x", ",", "dict", ")", "for", "x", "in", "batched_inputs", ")", "\n", "assert", "all", "(", "x", "[", "\"image\"", "]", ".", "dim", "(", ")", "==", "3", "for", "x", "in", "batched_inputs", ")", "\n", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "size_divisibility", ")", "\n", "\n", "im_info", "=", "[", "]", "\n", "for", "input_per_image", ",", "image_size", "in", "zip", "(", "batched_inputs", ",", "images", ".", "image_sizes", ")", ":", "\n", "        ", "target_height", "=", "input_per_image", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "target_width", "=", "input_per_image", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "# noqa", "\n", "# NOTE: The scale inside im_info is kept as convention and for providing", "\n", "# post-processing information if further processing is needed. For", "\n", "# current Caffe2 model definitions that don't include post-processing inside", "\n", "# the model, this number is not used.", "\n", "# NOTE: There can be a slight difference between width and height", "\n", "# scales, using a single number can results in numerical difference", "\n", "# compared with D2's post-processing.", "\n", "scale", "=", "target_height", "/", "image_size", "[", "0", "]", "\n", "im_info", ".", "append", "(", "[", "image_size", "[", "0", "]", ",", "image_size", "[", "1", "]", ",", "scale", "]", ")", "\n", "", "im_info", "=", "torch", ".", "Tensor", "(", "im_info", ")", "\n", "\n", "return", "images", ".", "tensor", ".", "to", "(", "device", ")", ",", "im_info", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export.export_onnx_model": [[33, 72], ["isinstance", "model.apply", "onnx.optimizer.get_available_passes", "all", "onnx.optimizer.optimize", "torch.no_grad", "io.BytesIO", "torch.onnx.export", "onnx.load_from_string", "f.getvalue"], "function", ["None"], ["def", "export_onnx_model", "(", "model", ",", "inputs", ")", ":", "\n", "    ", "\"\"\"\n    Trace and export a model to onnx format.\n\n    Args:\n        model (nn.Module):\n        inputs (tuple[args]): the model will be called by `model(*inputs)`\n\n    Returns:\n        an onnx model\n    \"\"\"", "\n", "assert", "isinstance", "(", "model", ",", "torch", ".", "nn", ".", "Module", ")", "\n", "\n", "# make sure all modules are in eval mode, onnx may change the training state", "\n", "# of the module if the states are not consistent", "\n", "def", "_check_eval", "(", "module", ")", ":", "\n", "        ", "assert", "not", "module", ".", "training", "\n", "\n", "", "model", ".", "apply", "(", "_check_eval", ")", "\n", "\n", "# Export the model to ONNX", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "with", "io", ".", "BytesIO", "(", ")", "as", "f", ":", "\n", "            ", "torch", ".", "onnx", ".", "export", "(", "\n", "model", ",", "\n", "inputs", ",", "\n", "f", ",", "\n", "operator_export_type", "=", "OperatorExportTypes", ".", "ONNX_ATEN_FALLBACK", ",", "\n", "# verbose=True,  # NOTE: uncomment this for debugging", "\n", "# export_params=True,", "\n", ")", "\n", "onnx_model", "=", "onnx", ".", "load_from_string", "(", "f", ".", "getvalue", "(", ")", ")", "\n", "\n", "# Apply ONNX's Optimization", "\n", "", "", "all_passes", "=", "onnx", ".", "optimizer", ".", "get_available_passes", "(", ")", "\n", "passes", "=", "[", "\"fuse_bn_into_conv\"", "]", "\n", "assert", "all", "(", "p", "in", "all_passes", "for", "p", "in", "passes", ")", "\n", "onnx_model", "=", "onnx", ".", "optimizer", ".", "optimize", "(", "onnx_model", ",", "passes", ")", "\n", "return", "onnx_model", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export._op_stats": [[74, 81], ["sorted", "sorted", "type_count.items", "type_count.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "_op_stats", "(", "net_def", ")", ":", "\n", "    ", "type_count", "=", "{", "}", "\n", "for", "t", "in", "[", "op", ".", "type", "for", "op", "in", "net_def", ".", "op", "]", ":", "\n", "        ", "type_count", "[", "t", "]", "=", "type_count", ".", "get", "(", "t", ",", "0", ")", "+", "1", "\n", "", "type_count_list", "=", "sorted", "(", "type_count", ".", "items", "(", ")", ",", "key", "=", "lambda", "kv", ":", "kv", "[", "0", "]", ")", "# alphabet", "\n", "type_count_list", "=", "sorted", "(", "type_count_list", ",", "key", "=", "lambda", "kv", ":", "-", "kv", "[", "1", "]", ")", "# count", "\n", "return", "\"\\n\"", ".", "join", "(", "\"{:>4}x {}\"", ".", "format", "(", "count", ",", "name", ")", "for", "name", ",", "count", "in", "type_count_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export._assign_device_option": [[83, 127], ["shared.infer_device_type", "caffe2.python.core.get_ssa", "caffe2_export._assign_device_option._assign_op_device_option"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.infer_device_type"], ["", "def", "_assign_device_option", "(", "\n", "predict_net", ":", "caffe2_pb2", ".", "NetDef", ",", "init_net", ":", "caffe2_pb2", ".", "NetDef", ",", "tensor_inputs", ":", "List", "[", "torch", ".", "Tensor", "]", "\n", ")", ":", "\n", "    ", "\"\"\"\n    ONNX exported network doesn't have concept of device, assign necessary\n    device option for each op in order to make it runable on GPU runtime.\n    \"\"\"", "\n", "\n", "def", "_get_device_type", "(", "torch_tensor", ")", ":", "\n", "        ", "assert", "torch_tensor", ".", "device", ".", "type", "in", "[", "\"cpu\"", ",", "\"cuda\"", "]", "\n", "assert", "torch_tensor", ".", "device", ".", "index", "==", "0", "\n", "return", "torch_tensor", ".", "device", ".", "type", "\n", "\n", "", "def", "_assign_op_device_option", "(", "net_proto", ",", "net_ssa", ",", "blob_device_types", ")", ":", "\n", "        ", "for", "op", ",", "ssa_i", "in", "zip", "(", "net_proto", ".", "op", ",", "net_ssa", ")", ":", "\n", "            ", "if", "op", ".", "type", "in", "[", "\"CopyCPUToGPU\"", ",", "\"CopyGPUToCPU\"", "]", ":", "\n", "                ", "op", ".", "device_option", ".", "CopyFrom", "(", "core", ".", "DeviceOption", "(", "caffe2_pb2", ".", "CUDA", ",", "0", ")", ")", "\n", "", "else", ":", "\n", "                ", "devices", "=", "[", "blob_device_types", "[", "b", "]", "for", "b", "in", "ssa_i", "[", "0", "]", "+", "ssa_i", "[", "1", "]", "]", "\n", "assert", "all", "(", "d", "==", "devices", "[", "0", "]", "for", "d", "in", "devices", ")", "\n", "if", "devices", "[", "0", "]", "==", "\"cuda\"", ":", "\n", "                    ", "op", ".", "device_option", ".", "CopyFrom", "(", "core", ".", "DeviceOption", "(", "caffe2_pb2", ".", "CUDA", ",", "0", ")", ")", "\n", "\n", "# update ops in predict_net", "\n", "", "", "", "", "predict_net_input_device_types", "=", "{", "\n", "(", "name", ",", "0", ")", ":", "_get_device_type", "(", "tensor", ")", "\n", "for", "name", ",", "tensor", "in", "zip", "(", "predict_net", ".", "external_input", ",", "tensor_inputs", ")", "\n", "}", "\n", "predict_net_device_types", "=", "infer_device_type", "(", "\n", "predict_net", ",", "known_status", "=", "predict_net_input_device_types", ",", "device_name_style", "=", "\"pytorch\"", "\n", ")", "\n", "predict_net_ssa", ",", "_", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "_assign_op_device_option", "(", "predict_net", ",", "predict_net_ssa", ",", "predict_net_device_types", ")", "\n", "\n", "# update ops in init_net", "\n", "init_net_ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "init_net", ")", "\n", "init_net_output_device_types", "=", "{", "\n", "(", "name", ",", "versions", "[", "name", "]", ")", ":", "predict_net_device_types", "[", "(", "name", ",", "0", ")", "]", "\n", "for", "name", "in", "init_net", ".", "external_output", "\n", "}", "\n", "init_net_device_types", "=", "infer_device_type", "(", "\n", "init_net", ",", "known_status", "=", "init_net_output_device_types", ",", "device_name_style", "=", "\"pytorch\"", "\n", ")", "\n", "_assign_op_device_option", "(", "init_net", ",", "init_net_ssa", ",", "init_net_device_types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export.export_caffe2_detection_model": [[129, 173], ["copy.deepcopy", "isinstance", "hasattr", "logger.info", "caffe2_export.export_onnx_model", "caffe2.python.onnx.backend.Caffe2Backend.onnx_graph_to_caffe2_net", "tabulate.tabulate", "logger.info", "shared.fuse_alias_placeholder", "any", "shared.get_params_from_init_net", "shared.remove_reshape_for_fc", "shared.construct_init_net_from_params", "shared.group_norm_replace_aten_with_caffe2", "copy.deepcopy.encode_additional_info", "logger.info", "logger.info", "shared.fuse_copy_between_cpu_and_gpu", "shared.remove_dead_end_ops", "caffe2_export._assign_device_option", "termcolor.colored", "caffe2_export._op_stats", "caffe2_export._op_stats", "type"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.export_onnx_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.fuse_alias_placeholder", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_params_from_init_net", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.remove_reshape_for_fc", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.construct_init_net_from_params", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.group_norm_replace_aten_with_caffe2", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2RetinaNet.encode_additional_info", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.fuse_copy_between_cpu_and_gpu", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.remove_dead_end_ops", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export._assign_device_option", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export._op_stats", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export._op_stats"], ["", "def", "export_caffe2_detection_model", "(", "model", ":", "torch", ".", "nn", ".", "Module", ",", "tensor_inputs", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "    ", "\"\"\"\n    Export a caffe2-compatible Detectron2 model to caffe2 format via ONNX.\n\n    Arg:\n        model: a caffe2-compatible version of detectron2 model, defined in caffe2_modeling.py\n        tensor_inputs: a list of tensors that caffe2 model takes as input.\n    \"\"\"", "\n", "model", "=", "copy", ".", "deepcopy", "(", "model", ")", "\n", "assert", "isinstance", "(", "model", ",", "torch", ".", "nn", ".", "Module", ")", "\n", "assert", "hasattr", "(", "model", ",", "\"encode_additional_info\"", ")", "\n", "\n", "# Export via ONNX", "\n", "logger", ".", "info", "(", "\n", "\"Exporting a {} model via ONNX ...\"", ".", "format", "(", "type", "(", "model", ")", ".", "__name__", ")", "\n", "+", "\" Some warnings from ONNX are expected and are usually not to worry about.\"", "\n", ")", "\n", "onnx_model", "=", "export_onnx_model", "(", "model", ",", "(", "tensor_inputs", ",", ")", ")", "\n", "# Convert ONNX model to Caffe2 protobuf", "\n", "init_net", ",", "predict_net", "=", "Caffe2Backend", ".", "onnx_graph_to_caffe2_net", "(", "onnx_model", ")", "\n", "ops_table", "=", "[", "[", "op", ".", "type", ",", "op", ".", "input", ",", "op", ".", "output", "]", "for", "op", "in", "predict_net", ".", "op", "]", "\n", "table", "=", "tabulate", "(", "ops_table", ",", "headers", "=", "[", "\"type\"", ",", "\"input\"", ",", "\"output\"", "]", ",", "tablefmt", "=", "\"pipe\"", ")", "\n", "logger", ".", "info", "(", "\n", "\"ONNX export Done. Exported predict_net (before optimizations):\\n\"", "+", "colored", "(", "table", ",", "\"cyan\"", ")", "\n", ")", "\n", "\n", "# Apply protobuf optimization", "\n", "fuse_alias_placeholder", "(", "predict_net", ",", "init_net", ")", "\n", "if", "any", "(", "t", ".", "device", ".", "type", "!=", "\"cpu\"", "for", "t", "in", "tensor_inputs", ")", ":", "\n", "        ", "fuse_copy_between_cpu_and_gpu", "(", "predict_net", ")", "\n", "remove_dead_end_ops", "(", "init_net", ")", "\n", "_assign_device_option", "(", "predict_net", ",", "init_net", ",", "tensor_inputs", ")", "\n", "", "params", ",", "device_options", "=", "get_params_from_init_net", "(", "init_net", ")", "\n", "predict_net", ",", "params", "=", "remove_reshape_for_fc", "(", "predict_net", ",", "params", ")", "\n", "init_net", "=", "construct_init_net_from_params", "(", "params", ",", "device_options", ")", "\n", "group_norm_replace_aten_with_caffe2", "(", "predict_net", ")", "\n", "\n", "# Record necessary information for running the pb model in Detectron2 system.", "\n", "model", ".", "encode_additional_info", "(", "predict_net", ",", "init_net", ")", "\n", "\n", "logger", ".", "info", "(", "\"Operators used in predict_net: \\n{}\"", ".", "format", "(", "_op_stats", "(", "predict_net", ")", ")", ")", "\n", "logger", ".", "info", "(", "\"Operators used in init_net: \\n{}\"", ".", "format", "(", "_op_stats", "(", "init_net", ")", ")", ")", "\n", "\n", "return", "predict_net", ",", "init_net", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export.run_and_save_graph": [[175, 208], ["logger.info", "shared.save_graph", "logger.info", "shared.ScopedWS", "ws.RunNetOnce", "set", "zip", "logger.info", "shared.save_graph", "ws.Blobs", "ws.FeedBlob", "ws.RunNetOnce", "ws.FetchBlob", "logger.warning", "ws.Blobs", "isinstance", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.save_graph", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.save_graph"], ["", "def", "run_and_save_graph", "(", "predict_net", ",", "init_net", ",", "tensor_inputs", ",", "graph_save_path", ")", ":", "\n", "    ", "\"\"\"\n    Run the caffe2 model on given inputs, recording the shape and draw the graph.\n\n    predict_net/init_net: caffe2 model.\n    tensor_inputs: a list of tensors that caffe2 model takes as input.\n    graph_save_path: path for saving graph of exported model.\n    \"\"\"", "\n", "\n", "logger", ".", "info", "(", "\"Saving graph of ONNX exported model to {} ...\"", ".", "format", "(", "graph_save_path", ")", ")", "\n", "save_graph", "(", "predict_net", ",", "graph_save_path", ",", "op_only", "=", "False", ")", "\n", "\n", "# Run the exported Caffe2 net", "\n", "logger", ".", "info", "(", "\"Running ONNX exported model ...\"", ")", "\n", "with", "ScopedWS", "(", "\"__ws_tmp__\"", ",", "True", ")", "as", "ws", ":", "\n", "        ", "ws", ".", "RunNetOnce", "(", "init_net", ")", "\n", "initialized_blobs", "=", "set", "(", "ws", ".", "Blobs", "(", ")", ")", "\n", "uninitialized", "=", "[", "inp", "for", "inp", "in", "predict_net", ".", "external_input", "if", "inp", "not", "in", "initialized_blobs", "]", "\n", "for", "name", ",", "blob", "in", "zip", "(", "uninitialized", ",", "tensor_inputs", ")", ":", "\n", "            ", "ws", ".", "FeedBlob", "(", "name", ",", "blob", ")", "\n", "\n", "", "try", ":", "\n", "            ", "ws", ".", "RunNetOnce", "(", "predict_net", ")", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "            ", "logger", ".", "warning", "(", "\"Encountered RuntimeError: \\n{}\"", ".", "format", "(", "str", "(", "e", ")", ")", ")", "\n", "\n", "", "ws_blobs", "=", "{", "b", ":", "ws", ".", "FetchBlob", "(", "b", ")", "for", "b", "in", "ws", ".", "Blobs", "(", ")", "}", "\n", "blob_sizes", "=", "{", "b", ":", "ws_blobs", "[", "b", "]", ".", "shape", "for", "b", "in", "ws_blobs", "if", "isinstance", "(", "ws_blobs", "[", "b", "]", ",", "np", ".", "ndarray", ")", "}", "\n", "\n", "logger", ".", "info", "(", "\"Saving graph with blob shapes to {} ...\"", ".", "format", "(", "graph_save_path", ")", ")", "\n", "save_graph", "(", "predict_net", ",", "graph_save_path", ",", "op_only", "=", "False", ",", "blob_sizes", "=", "blob_sizes", ")", "\n", "\n", "return", "ws_blobs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2Boxes.__init__": [[29, 35], ["isinstance", "tensor.size", "tensor.dim", "tensor.size"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "tensor", ")", ":", "\n", "        ", "assert", "isinstance", "(", "tensor", ",", "torch", ".", "Tensor", ")", "\n", "assert", "tensor", ".", "dim", "(", ")", "==", "2", "and", "tensor", ".", "size", "(", "-", "1", ")", "in", "[", "4", ",", "5", ",", "6", "]", ",", "tensor", ".", "size", "(", ")", "\n", "# TODO: make tensor immutable when dim is Nx5 for Boxes,", "\n", "# and Nx6 for RotatedBoxes?", "\n", "self", ".", "tensor", "=", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.__init__": [[48, 57], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "im_info", ",", "indices", ",", "extra_fields", "=", "None", ")", ":", "\n", "# [N, 3] -> (H, W, Scale)", "\n", "        ", "self", ".", "im_info", "=", "im_info", "\n", "# [N,] -> indice of batch to which the instance belongs", "\n", "self", ".", "indices", "=", "indices", "\n", "# [N, ...]", "\n", "self", ".", "batch_extra_fields", "=", "extra_fields", "or", "{", "}", "\n", "\n", "self", ".", "image_size", "=", "self", ".", "im_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.get_fields": [[58, 71], ["c10.InstancesList.batch_extra_fields.items"], "methods", ["None"], ["", "def", "get_fields", "(", "self", ")", ":", "\n", "        ", "\"\"\" like `get_fields` in the Instances object,\n        but return each field in tensor representations \"\"\"", "\n", "ret", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "self", ".", "batch_extra_fields", ".", "items", "(", ")", ":", "\n", "# if isinstance(v, torch.Tensor):", "\n", "#     tensor_rep = v", "\n", "# elif isinstance(v, (Boxes, Keypoints)):", "\n", "#     tensor_rep = v.tensor", "\n", "# else:", "\n", "#     raise ValueError(\"Can't find tensor representation for: {}\".format())", "\n", "            ", "ret", "[", "k", "]", "=", "v", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has": [[72, 74], ["None"], "methods", ["None"], ["", "def", "has", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "name", "in", "self", ".", "batch_extra_fields", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.set": [[75, 82], ["len", "len", "len", "len"], "methods", ["None"], ["", "def", "set", "(", "self", ",", "name", ",", "value", ")", ":", "\n", "        ", "data_len", "=", "len", "(", "value", ")", "\n", "if", "len", "(", "self", ".", "batch_extra_fields", ")", ":", "\n", "            ", "assert", "(", "\n", "len", "(", "self", ")", "==", "data_len", "\n", ")", ",", "\"Adding a field of length {} to a Instances of length {}\"", ".", "format", "(", "data_len", ",", "len", "(", "self", ")", ")", "\n", "", "self", ".", "batch_extra_fields", "[", "name", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.__setattr__": [[83, 88], ["object.__setattr__", "c10.InstancesList.set"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.__setattr__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "def", "__setattr__", "(", "self", ",", "name", ",", "val", ")", ":", "\n", "        ", "if", "name", "in", "[", "\"im_info\"", ",", "\"indices\"", ",", "\"batch_extra_fields\"", ",", "\"image_size\"", "]", ":", "\n", "            ", "super", "(", ")", ".", "__setattr__", "(", "name", ",", "val", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "set", "(", "name", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.__getattr__": [[89, 93], ["AttributeError"], "methods", ["None"], ["", "", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "if", "name", "not", "in", "self", ".", "batch_extra_fields", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Cannot find field '{}' in the given Instances!\"", ".", "format", "(", "name", ")", ")", "\n", "", "return", "self", ".", "batch_extra_fields", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.__len__": [[94, 96], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten": [[97, 105], ["c10.InstancesList.batch_extra_fields.items", "isinstance", "ret.append", "ret.append"], "methods", ["None"], ["", "def", "flatten", "(", "self", ")", ":", "\n", "        ", "ret", "=", "[", "]", "\n", "for", "_", ",", "v", "in", "self", ".", "batch_extra_fields", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "(", "Boxes", ",", "Keypoints", ")", ")", ":", "\n", "                ", "ret", ".", "append", "(", "v", ".", "tensor", ")", "\n", "", "else", ":", "\n", "                ", "ret", ".", "append", "(", "v", ")", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.to_d2_instances_list": [[106, 145], ["enumerate", "isinstance", "all", "detectron2.structures.Instances", "instances_list.batch_extra_fields.items", "ret.append", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "isinstance", "isinstance", "issubclass", "isinstance", "detectron2.structures.Instances.set", "isinstance", "detectron2.structures.Instances.set", "issubclass", "int", "int", "detectron2.structures.Instances.set", "detectron2.structures.Boxes", "detectron2.structures.Instances.set", "issubclass", "info[].item", "info[].item", "detectron2.structures.Keypoints", "detectron2.structures.Instances.set", "ValueError"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "@", "staticmethod", "\n", "def", "to_d2_instances_list", "(", "instances_list", ")", ":", "\n", "        ", "\"\"\"\n        Convert InstancesList to List[Instances]. The input `instances_list` can\n        also be a List[Instances], in this case this method is a non-op.\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "instances_list", ",", "InstancesList", ")", ":", "\n", "            ", "assert", "all", "(", "isinstance", "(", "x", ",", "Instances", ")", "for", "x", "in", "instances_list", ")", "\n", "return", "instances_list", "\n", "\n", "", "ret", "=", "[", "]", "\n", "for", "i", ",", "info", "in", "enumerate", "(", "instances_list", ".", "im_info", ")", ":", "\n", "            ", "instances", "=", "Instances", "(", "torch", ".", "Size", "(", "[", "int", "(", "info", "[", "0", "]", ".", "item", "(", ")", ")", ",", "int", "(", "info", "[", "1", "]", ".", "item", "(", ")", ")", "]", ")", ")", "\n", "\n", "ids", "=", "instances_list", ".", "indices", "==", "i", "\n", "for", "k", ",", "v", "in", "instances_list", ".", "batch_extra_fields", ".", "items", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "v", "[", "ids", "]", ")", "\n", "continue", "\n", "", "elif", "isinstance", "(", "v", ",", "Boxes", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "v", "[", "ids", ",", "-", "4", ":", "]", ")", "\n", "continue", "\n", "\n", "", "target_type", ",", "tensor_source", "=", "v", "\n", "assert", "isinstance", "(", "tensor_source", ",", "torch", ".", "Tensor", ")", "\n", "assert", "tensor_source", ".", "shape", "[", "0", "]", "==", "instances_list", ".", "indices", ".", "shape", "[", "0", "]", "\n", "tensor_source", "=", "tensor_source", "[", "ids", "]", "\n", "\n", "if", "issubclass", "(", "target_type", ",", "Boxes", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "Boxes", "(", "tensor_source", "[", ":", ",", "-", "4", ":", "]", ")", ")", "\n", "", "elif", "issubclass", "(", "target_type", ",", "Keypoints", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "Keypoints", "(", "tensor_source", ")", ")", "\n", "", "elif", "issubclass", "(", "target_type", ",", "torch", ".", "Tensor", ")", ":", "\n", "                    ", "instances", ".", "set", "(", "k", ",", "tensor_source", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\"Can't handle targe type: {}\"", ".", "format", "(", "target_type", ")", ")", "\n", "\n", "", "", "ret", ".", "append", "(", "instances", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2Compatible._get_tensor_mode": [[148, 150], ["None"], "methods", ["None"], ["    ", "def", "_get_tensor_mode", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_tensor_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2Compatible._set_tensor_mode": [[151, 153], ["None"], "methods", ["None"], ["", "def", "_set_tensor_mode", "(", "self", ",", "v", ")", ":", "\n", "        ", "self", ".", "_tensor_mode", "=", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2RPN.forward": [[161, 246], ["c10.Caffe2RPN.rpn_head", "isinstance", "isinstance", "zip", "c10.Caffe2RPN.c2_postprocess", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "iter", "scores.detach.detach.detach", "bbox_deltas.detach.detach.detach", "torch.ops._caffe2.GenerateProposals", "torch.ops._caffe2.GenerateProposals", "torch.ops._caffe2.GenerateProposals", "torch.ops._caffe2.GenerateProposals", "rpn_rois_list.append", "rpn_roi_probs_list.append", "len", "list", "int", "int", "torch.ops._caffe2.CollectRpnProposals", "torch.ops._caffe2.CollectRpnProposals", "torch.ops._caffe2.CollectRpnProposals", "torch.ops._caffe2.CollectRpnProposals", "shared.to_device", "len", "len", "shared.to_device", "math.log2", "math.log2", "len", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "len", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2RPN.c2_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device"], ["    ", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "gt_instances", "=", "None", ")", ":", "\n", "        ", "assert", "not", "self", ".", "training", "\n", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "objectness_logits_pred", ",", "anchor_deltas_pred", "=", "self", ".", "rpn_head", "(", "features", ")", "\n", "\n", "assert", "isinstance", "(", "images", ",", "ImageList", ")", "\n", "if", "self", ".", "tensor_mode", ":", "\n", "            ", "im_info", "=", "images", ".", "image_sizes", "\n", "", "else", ":", "\n", "            ", "im_info", "=", "torch", ".", "Tensor", "(", "\n", "[", "[", "im_sz", "[", "0", "]", ",", "im_sz", "[", "1", "]", ",", "torch", ".", "Tensor", "(", "[", "1.0", "]", ")", "]", "for", "im_sz", "in", "images", ".", "image_sizes", "]", "\n", ")", ".", "to", "(", "images", ".", "tensor", ".", "device", ")", "\n", "", "assert", "isinstance", "(", "im_info", ",", "torch", ".", "Tensor", ")", "\n", "\n", "rpn_rois_list", "=", "[", "]", "\n", "rpn_roi_probs_list", "=", "[", "]", "\n", "for", "scores", ",", "bbox_deltas", ",", "cell_anchors_tensor", ",", "feat_stride", "in", "zip", "(", "\n", "objectness_logits_pred", ",", "\n", "anchor_deltas_pred", ",", "\n", "iter", "(", "self", ".", "anchor_generator", ".", "cell_anchors", ")", ",", "\n", "self", ".", "anchor_generator", ".", "strides", ",", "\n", ")", ":", "\n", "            ", "scores", "=", "scores", ".", "detach", "(", ")", "\n", "bbox_deltas", "=", "bbox_deltas", ".", "detach", "(", ")", "\n", "\n", "rpn_rois", ",", "rpn_roi_probs", "=", "torch", ".", "ops", ".", "_caffe2", ".", "GenerateProposals", "(", "\n", "scores", ",", "\n", "bbox_deltas", ",", "\n", "im_info", ",", "\n", "cell_anchors_tensor", ",", "\n", "spatial_scale", "=", "1.0", "/", "feat_stride", ",", "\n", "pre_nms_topN", "=", "self", ".", "pre_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "post_nms_topN", "=", "self", ".", "post_nms_topk", "[", "self", ".", "training", "]", ",", "\n", "nms_thresh", "=", "self", ".", "nms_thresh", ",", "\n", "min_size", "=", "self", ".", "min_box_size", ",", "\n", "# correct_transform_coords=True,  # deprecated argument", "\n", "angle_bound_on", "=", "True", ",", "# Default", "\n", "angle_bound_lo", "=", "-", "180", ",", "\n", "angle_bound_hi", "=", "180", ",", "\n", "clip_angle_thresh", "=", "1.0", ",", "# Default", "\n", "legacy_plus_one", "=", "False", ",", "\n", ")", "\n", "rpn_rois_list", ".", "append", "(", "rpn_rois", ")", "\n", "rpn_roi_probs_list", ".", "append", "(", "rpn_roi_probs", ")", "\n", "\n", "# For FPN in D2, in RPN all proposals from different levels are concated", "\n", "# together, ranked and picked by top post_nms_topk. Then in ROIPooler", "\n", "# it calculates level_assignments and calls the RoIAlign from", "\n", "# the corresponding level.", "\n", "\n", "", "if", "len", "(", "objectness_logits_pred", ")", "==", "1", ":", "\n", "            ", "rpn_rois", "=", "rpn_rois_list", "[", "0", "]", "\n", "rpn_roi_probs", "=", "rpn_roi_probs_list", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "rpn_rois_list", ")", "==", "len", "(", "rpn_roi_probs_list", ")", "\n", "rpn_post_nms_topN", "=", "self", ".", "post_nms_topk", "[", "self", ".", "training", "]", "\n", "\n", "device", "=", "rpn_rois_list", "[", "0", "]", ".", "device", "\n", "input_list", "=", "[", "to_device", "(", "x", ",", "\"cpu\"", ")", "for", "x", "in", "(", "rpn_rois_list", "+", "rpn_roi_probs_list", ")", "]", "\n", "\n", "# TODO remove this after confirming rpn_max_level/rpn_min_level", "\n", "# is not needed in CollectRpnProposals.", "\n", "feature_strides", "=", "list", "(", "self", ".", "anchor_generator", ".", "strides", ")", "\n", "rpn_min_level", "=", "int", "(", "math", ".", "log2", "(", "feature_strides", "[", "0", "]", ")", ")", "\n", "rpn_max_level", "=", "int", "(", "math", ".", "log2", "(", "feature_strides", "[", "-", "1", "]", ")", ")", "\n", "assert", "(", "rpn_max_level", "-", "rpn_min_level", "+", "1", ")", "==", "len", "(", "\n", "rpn_rois_list", "\n", ")", ",", "\"CollectRpnProposals requires continuous levels\"", "\n", "\n", "rpn_rois", "=", "torch", ".", "ops", ".", "_caffe2", ".", "CollectRpnProposals", "(", "\n", "input_list", ",", "\n", "# NOTE: in current implementation, rpn_max_level and rpn_min_level", "\n", "# are not needed, only the subtraction of two matters and it", "\n", "# can be infer from the number of inputs. Keep them now for", "\n", "# consistency.", "\n", "rpn_max_level", "=", "2", "+", "len", "(", "rpn_rois_list", ")", "-", "1", ",", "\n", "rpn_min_level", "=", "2", ",", "\n", "rpn_post_nms_topN", "=", "rpn_post_nms_topN", ",", "\n", ")", "\n", "rpn_rois", "=", "to_device", "(", "rpn_rois", ",", "device", ")", "\n", "rpn_roi_probs", "=", "[", "]", "\n", "\n", "", "proposals", "=", "self", ".", "c2_postprocess", "(", "im_info", ",", "rpn_rois", ",", "rpn_roi_probs", ",", "self", ".", "tensor_mode", ")", "\n", "return", "proposals", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2RPN.c2_postprocess": [[247, 262], ["c10.InstancesList", "c10.InstancesList.to_d2_instances_list", "c10.Caffe2Boxes"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.to_d2_instances_list"], ["", "@", "staticmethod", "\n", "def", "c2_postprocess", "(", "im_info", ",", "rpn_rois", ",", "rpn_roi_probs", ",", "tensor_mode", ")", ":", "\n", "        ", "proposals", "=", "InstancesList", "(", "\n", "im_info", "=", "im_info", ",", "\n", "indices", "=", "rpn_rois", "[", ":", ",", "0", "]", ",", "\n", "extra_fields", "=", "{", "\n", "\"proposal_boxes\"", ":", "Caffe2Boxes", "(", "rpn_rois", ")", ",", "\n", "\"objectness_logits\"", ":", "(", "torch", ".", "Tensor", ",", "rpn_roi_probs", ")", ",", "\n", "}", ",", "\n", ")", "\n", "if", "not", "tensor_mode", ":", "\n", "            ", "proposals", "=", "InstancesList", ".", "to_d2_instances_list", "(", "proposals", ")", "\n", "", "else", ":", "\n", "            ", "proposals", "=", "[", "proposals", "]", "\n", "", "return", "proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2ROIPooler.c2_preprocess": [[265, 275], ["all", "all", "detectron2.modeling.poolers.convert_boxes_to_pooler_format", "isinstance", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.poolers.convert_boxes_to_pooler_format"], ["    ", "@", "staticmethod", "\n", "def", "c2_preprocess", "(", "box_lists", ")", ":", "\n", "        ", "assert", "all", "(", "isinstance", "(", "x", ",", "Boxes", ")", "for", "x", "in", "box_lists", ")", "\n", "if", "all", "(", "isinstance", "(", "x", ",", "Caffe2Boxes", ")", "for", "x", "in", "box_lists", ")", ":", "\n", "# input is pure-tensor based", "\n", "            ", "assert", "len", "(", "box_lists", ")", "==", "1", "\n", "pooler_fmt_boxes", "=", "box_lists", "[", "0", "]", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "pooler_fmt_boxes", "=", "poolers", ".", "convert_boxes_to_pooler_format", "(", "box_lists", ")", "\n", "", "return", "pooler_fmt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2ROIPooler.forward": [[276, 343], ["c10.Caffe2ROIPooler.c2_preprocess", "len", "torch.ops._caffe2.DistributeFpnProposals", "torch.ops._caffe2.DistributeFpnProposals", "torch.ops._caffe2.DistributeFpnProposals", "torch.ops._caffe2.DistributeFpnProposals", "zip", "detectron2.layers.cat", "torch.ops._caffe2.BatchPermutation", "torch.ops._caffe2.BatchPermutation", "torch.ops._caffe2.BatchPermutation", "torch.ops._caffe2.BatchPermutation", "isinstance", "c2_roi_align", "shared.to_device", "shared.to_device", "isinstance", "c2_roi_align", "roi_feat_fpn_list.append", "bool", "float", "int", "int", "int", "float", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2ROIPooler.c2_preprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device"], ["", "def", "forward", "(", "self", ",", "x", ",", "box_lists", ")", ":", "\n", "        ", "assert", "not", "self", ".", "training", "\n", "\n", "pooler_fmt_boxes", "=", "self", ".", "c2_preprocess", "(", "box_lists", ")", "\n", "num_level_assignments", "=", "len", "(", "self", ".", "level_poolers", ")", "\n", "\n", "if", "num_level_assignments", "==", "1", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "level_poolers", "[", "0", "]", ",", "ROIAlignRotated", ")", ":", "\n", "                ", "c2_roi_align", "=", "torch", ".", "ops", ".", "_caffe2", ".", "RoIAlignRotated", "\n", "aligned", "=", "True", "\n", "", "else", ":", "\n", "                ", "c2_roi_align", "=", "torch", ".", "ops", ".", "_caffe2", ".", "RoIAlign", "\n", "aligned", "=", "self", ".", "level_poolers", "[", "0", "]", ".", "aligned", "\n", "\n", "", "out", "=", "c2_roi_align", "(", "\n", "x", "[", "0", "]", ",", "\n", "pooler_fmt_boxes", ",", "\n", "order", "=", "\"NCHW\"", ",", "\n", "spatial_scale", "=", "float", "(", "self", ".", "level_poolers", "[", "0", "]", ".", "spatial_scale", ")", ",", "\n", "pooled_h", "=", "int", "(", "self", ".", "output_size", "[", "0", "]", ")", ",", "\n", "pooled_w", "=", "int", "(", "self", ".", "output_size", "[", "1", "]", ")", ",", "\n", "sampling_ratio", "=", "int", "(", "self", ".", "level_poolers", "[", "0", "]", ".", "sampling_ratio", ")", ",", "\n", "aligned", "=", "aligned", ",", "\n", ")", "\n", "return", "out", "\n", "\n", "", "device", "=", "pooler_fmt_boxes", ".", "device", "\n", "assert", "(", "\n", "self", ".", "max_level", "-", "self", ".", "min_level", "+", "1", "==", "4", "\n", ")", ",", "\"Currently DistributeFpnProposals only support 4 levels\"", "\n", "fpn_outputs", "=", "torch", ".", "ops", ".", "_caffe2", ".", "DistributeFpnProposals", "(", "\n", "to_device", "(", "pooler_fmt_boxes", ",", "\"cpu\"", ")", ",", "\n", "roi_canonical_scale", "=", "self", ".", "canonical_box_size", ",", "\n", "roi_canonical_level", "=", "self", ".", "canonical_level", ",", "\n", "roi_max_level", "=", "self", ".", "max_level", ",", "\n", "roi_min_level", "=", "self", ".", "min_level", ",", "\n", "legacy_plus_one", "=", "False", ",", "\n", ")", "\n", "fpn_outputs", "=", "[", "to_device", "(", "x", ",", "device", ")", "for", "x", "in", "fpn_outputs", "]", "\n", "\n", "rois_fpn_list", "=", "fpn_outputs", "[", ":", "-", "1", "]", "\n", "rois_idx_restore_int32", "=", "fpn_outputs", "[", "-", "1", "]", "\n", "\n", "roi_feat_fpn_list", "=", "[", "]", "\n", "for", "roi_fpn", ",", "x_level", ",", "pooler", "in", "zip", "(", "rois_fpn_list", ",", "x", ",", "self", ".", "level_poolers", ")", ":", "\n", "            ", "if", "isinstance", "(", "pooler", ",", "ROIAlignRotated", ")", ":", "\n", "                ", "c2_roi_align", "=", "torch", ".", "ops", ".", "_caffe2", ".", "RoIAlignRotated", "\n", "aligned", "=", "True", "\n", "", "else", ":", "\n", "                ", "c2_roi_align", "=", "torch", ".", "ops", ".", "_caffe2", ".", "RoIAlign", "\n", "aligned", "=", "bool", "(", "pooler", ".", "aligned", ")", "\n", "\n", "", "roi_feat_fpn", "=", "c2_roi_align", "(", "\n", "x_level", ",", "\n", "roi_fpn", ",", "\n", "order", "=", "\"NCHW\"", ",", "\n", "spatial_scale", "=", "float", "(", "pooler", ".", "spatial_scale", ")", ",", "\n", "pooled_h", "=", "int", "(", "self", ".", "output_size", "[", "0", "]", ")", ",", "\n", "pooled_w", "=", "int", "(", "self", ".", "output_size", "[", "1", "]", ")", ",", "\n", "sampling_ratio", "=", "int", "(", "pooler", ".", "sampling_ratio", ")", ",", "\n", "aligned", "=", "aligned", ",", "\n", ")", "\n", "roi_feat_fpn_list", ".", "append", "(", "roi_feat_fpn", ")", "\n", "\n", "", "roi_feat_shuffled", "=", "cat", "(", "roi_feat_fpn_list", ",", "dim", "=", "0", ")", "\n", "roi_feat", "=", "torch", ".", "ops", ".", "_caffe2", ".", "BatchPermutation", "(", "roi_feat_shuffled", ",", "rois_idx_restore_int32", ")", "\n", "return", "roi_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2FastRCNNOutputsInference.__init__": [[346, 348], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "tensor_mode", ")", ":", "\n", "        ", "self", ".", "tensor_mode", "=", "tensor_mode", "# whether the output is caffe2 tensor mode", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2FastRCNNOutputsInference.__call__": [[349, 469], ["torch.softmax", "torch.softmax", "type().cat", "torch.ops._caffe2.BBoxTransform", "torch.ops._caffe2.BBoxTransform", "torch.ops._caffe2.BBoxTransform", "torch.ops._caffe2.BBoxTransform", "shared.to_device", "shared.to_device", "torch.ops._caffe2.BoxWithNMSLimit", "torch.ops._caffe2.BoxWithNMSLimit", "torch.ops._caffe2.BoxWithNMSLimit", "torch.ops._caffe2.BoxWithNMSLimit", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "detectron2.layers.cat", "shared.alias", "shared.alias", "shared.alias", "shared.alias", "shared.alias", "shared.alias", "c10.InstancesList", "len", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "detectron2.layers.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "shared.to_device", "roi_class_nms.to.to.to", "c10.InstancesList.to_d2_instances_list", "shared.alias.int().tolist", "list", "type", "float", "float", "int", "torch.full", "torch.full", "torch.full", "torch.full", "shared.alias.to().split", "torch.full", "torch.full", "torch.full", "torch.full", "enumerate", "c10.Caffe2Boxes", "shared.alias.int", "enumerate", "shared.alias.to", "int", "len", "x.item"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.to_d2_instances_list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "__call__", "(", "self", ",", "box_predictor", ",", "predictions", ",", "proposals", ")", ":", "\n", "        ", "\"\"\" equivalent to FastRCNNOutputLayers.inference \"\"\"", "\n", "score_thresh", "=", "box_predictor", ".", "test_score_thresh", "\n", "nms_thresh", "=", "box_predictor", ".", "test_nms_thresh", "\n", "topk_per_image", "=", "box_predictor", ".", "test_topk_per_image", "\n", "is_rotated", "=", "len", "(", "box_predictor", ".", "box2box_transform", ".", "weights", ")", "==", "5", "\n", "\n", "if", "is_rotated", ":", "\n", "            ", "box_dim", "=", "5", "\n", "assert", "box_predictor", ".", "box2box_transform", ".", "weights", "[", "4", "]", "==", "1", ",", "(", "\n", "\"The weights for Rotated BBoxTransform in C2 have only 4 dimensions,\"", "\n", "+", "\" thus enforcing the angle weight to be 1 for now\"", "\n", ")", "\n", "box2box_transform_weights", "=", "box_predictor", ".", "box2box_transform", ".", "weights", "[", ":", "4", "]", "\n", "", "else", ":", "\n", "            ", "box_dim", "=", "4", "\n", "box2box_transform_weights", "=", "box_predictor", ".", "box2box_transform", ".", "weights", "\n", "\n", "", "class_logits", ",", "box_regression", "=", "predictions", "\n", "class_prob", "=", "F", ".", "softmax", "(", "class_logits", ",", "-", "1", ")", "\n", "\n", "assert", "box_regression", ".", "shape", "[", "1", "]", "%", "box_dim", "==", "0", "\n", "cls_agnostic_bbox_reg", "=", "box_regression", ".", "shape", "[", "1", "]", "//", "box_dim", "==", "1", "\n", "\n", "input_tensor_mode", "=", "proposals", "[", "0", "]", ".", "proposal_boxes", ".", "tensor", ".", "shape", "[", "1", "]", "==", "box_dim", "+", "1", "\n", "\n", "rois", "=", "type", "(", "proposals", "[", "0", "]", ".", "proposal_boxes", ")", ".", "cat", "(", "[", "p", ".", "proposal_boxes", "for", "p", "in", "proposals", "]", ")", "\n", "device", ",", "dtype", "=", "rois", ".", "tensor", ".", "device", ",", "rois", ".", "tensor", ".", "dtype", "\n", "if", "input_tensor_mode", ":", "\n", "            ", "im_info", "=", "proposals", "[", "0", "]", ".", "image_size", "\n", "rois", "=", "rois", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "im_info", "=", "torch", ".", "Tensor", "(", "\n", "[", "[", "sz", "[", "0", "]", ",", "sz", "[", "1", "]", ",", "1.0", "]", "for", "sz", "in", "[", "x", ".", "image_size", "for", "x", "in", "proposals", "]", "]", "\n", ")", "\n", "batch_ids", "=", "cat", "(", "\n", "[", "\n", "torch", ".", "full", "(", "(", "b", ",", "1", ")", ",", "i", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "for", "i", ",", "b", "in", "enumerate", "(", "len", "(", "p", ")", "for", "p", "in", "proposals", ")", "\n", "]", ",", "\n", "dim", "=", "0", ",", "\n", ")", "\n", "rois", "=", "torch", ".", "cat", "(", "[", "batch_ids", ",", "rois", ".", "tensor", "]", ",", "dim", "=", "1", ")", "\n", "\n", "", "roi_pred_bbox", ",", "roi_batch_splits", "=", "torch", ".", "ops", ".", "_caffe2", ".", "BBoxTransform", "(", "\n", "to_device", "(", "rois", ",", "\"cpu\"", ")", ",", "\n", "to_device", "(", "box_regression", ",", "\"cpu\"", ")", ",", "\n", "to_device", "(", "im_info", ",", "\"cpu\"", ")", ",", "\n", "weights", "=", "box2box_transform_weights", ",", "\n", "apply_scale", "=", "True", ",", "\n", "rotated", "=", "is_rotated", ",", "\n", "angle_bound_on", "=", "True", ",", "\n", "angle_bound_lo", "=", "-", "180", ",", "\n", "angle_bound_hi", "=", "180", ",", "\n", "clip_angle_thresh", "=", "1.0", ",", "\n", "legacy_plus_one", "=", "False", ",", "\n", ")", "\n", "roi_pred_bbox", "=", "to_device", "(", "roi_pred_bbox", ",", "device", ")", "\n", "roi_batch_splits", "=", "to_device", "(", "roi_batch_splits", ",", "device", ")", "\n", "\n", "nms_outputs", "=", "torch", ".", "ops", ".", "_caffe2", ".", "BoxWithNMSLimit", "(", "\n", "to_device", "(", "class_prob", ",", "\"cpu\"", ")", ",", "\n", "to_device", "(", "roi_pred_bbox", ",", "\"cpu\"", ")", ",", "\n", "to_device", "(", "roi_batch_splits", ",", "\"cpu\"", ")", ",", "\n", "score_thresh", "=", "float", "(", "score_thresh", ")", ",", "\n", "nms", "=", "float", "(", "nms_thresh", ")", ",", "\n", "detections_per_im", "=", "int", "(", "topk_per_image", ")", ",", "\n", "soft_nms_enabled", "=", "False", ",", "\n", "soft_nms_method", "=", "\"linear\"", ",", "\n", "soft_nms_sigma", "=", "0.5", ",", "\n", "soft_nms_min_score_thres", "=", "0.001", ",", "\n", "rotated", "=", "is_rotated", ",", "\n", "cls_agnostic_bbox_reg", "=", "cls_agnostic_bbox_reg", ",", "\n", "input_boxes_include_bg_cls", "=", "False", ",", "\n", "output_classes_include_bg_cls", "=", "False", ",", "\n", "legacy_plus_one", "=", "False", ",", "\n", ")", "\n", "roi_score_nms", "=", "to_device", "(", "nms_outputs", "[", "0", "]", ",", "device", ")", "\n", "roi_bbox_nms", "=", "to_device", "(", "nms_outputs", "[", "1", "]", ",", "device", ")", "\n", "roi_class_nms", "=", "to_device", "(", "nms_outputs", "[", "2", "]", ",", "device", ")", "\n", "roi_batch_splits_nms", "=", "to_device", "(", "nms_outputs", "[", "3", "]", ",", "device", ")", "\n", "roi_keeps_nms", "=", "to_device", "(", "nms_outputs", "[", "4", "]", ",", "device", ")", "\n", "roi_keeps_size_nms", "=", "to_device", "(", "nms_outputs", "[", "5", "]", ",", "device", ")", "\n", "if", "not", "self", ".", "tensor_mode", ":", "\n", "            ", "roi_class_nms", "=", "roi_class_nms", ".", "to", "(", "torch", ".", "int64", ")", "\n", "\n", "", "roi_batch_ids", "=", "cat", "(", "\n", "[", "\n", "torch", ".", "full", "(", "(", "b", ",", "1", ")", ",", "i", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "for", "i", ",", "b", "in", "enumerate", "(", "int", "(", "x", ".", "item", "(", ")", ")", "for", "x", "in", "roi_batch_splits_nms", ")", "\n", "]", ",", "\n", "dim", "=", "0", ",", "\n", ")", "\n", "\n", "roi_class_nms", "=", "alias", "(", "roi_class_nms", ",", "\"class_nms\"", ")", "\n", "roi_score_nms", "=", "alias", "(", "roi_score_nms", ",", "\"score_nms\"", ")", "\n", "roi_bbox_nms", "=", "alias", "(", "roi_bbox_nms", ",", "\"bbox_nms\"", ")", "\n", "roi_batch_splits_nms", "=", "alias", "(", "roi_batch_splits_nms", ",", "\"batch_splits_nms\"", ")", "\n", "roi_keeps_nms", "=", "alias", "(", "roi_keeps_nms", ",", "\"keeps_nms\"", ")", "\n", "roi_keeps_size_nms", "=", "alias", "(", "roi_keeps_size_nms", ",", "\"keeps_size_nms\"", ")", "\n", "\n", "results", "=", "InstancesList", "(", "\n", "im_info", "=", "im_info", ",", "\n", "indices", "=", "roi_batch_ids", "[", ":", ",", "0", "]", ",", "\n", "extra_fields", "=", "{", "\n", "\"pred_boxes\"", ":", "Caffe2Boxes", "(", "roi_bbox_nms", ")", ",", "\n", "\"scores\"", ":", "roi_score_nms", ",", "\n", "\"pred_classes\"", ":", "roi_class_nms", ",", "\n", "}", ",", "\n", ")", "\n", "\n", "if", "not", "self", ".", "tensor_mode", ":", "\n", "            ", "results", "=", "InstancesList", ".", "to_d2_instances_list", "(", "results", ")", "\n", "batch_splits", "=", "roi_batch_splits_nms", ".", "int", "(", ")", ".", "tolist", "(", ")", "\n", "kept_indices", "=", "list", "(", "roi_keeps_nms", ".", "to", "(", "torch", ".", "int64", ")", ".", "split", "(", "batch_splits", ")", ")", "\n", "", "else", ":", "\n", "            ", "results", "=", "[", "results", "]", "\n", "kept_indices", "=", "[", "roi_keeps_nms", "]", "\n", "\n", "", "return", "results", ",", "kept_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2MaskRCNNInference.__call__": [[472, 481], ["all", "pred_mask_logits.sigmoid", "shared.alias", "detectron2.modeling.roi_heads.mask_head.mask_rcnn_inference", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.mask_rcnn_inference"], ["    ", "def", "__call__", "(", "self", ",", "pred_mask_logits", ",", "pred_instances", ")", ":", "\n", "        ", "\"\"\" equivalent to mask_head.mask_rcnn_inference \"\"\"", "\n", "if", "all", "(", "isinstance", "(", "x", ",", "InstancesList", ")", "for", "x", "in", "pred_instances", ")", ":", "\n", "            ", "assert", "len", "(", "pred_instances", ")", "==", "1", "\n", "mask_probs_pred", "=", "pred_mask_logits", ".", "sigmoid", "(", ")", "\n", "mask_probs_pred", "=", "alias", "(", "mask_probs_pred", ",", "\"mask_fcn_probs\"", ")", "\n", "pred_instances", "[", "0", "]", ".", "pred_masks", "=", "mask_probs_pred", "\n", "", "else", ":", "\n", "            ", "mask_rcnn_inference", "(", "pred_mask_logits", ",", "pred_instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2KeypointRCNNInference.__init__": [[484, 486], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "use_heatmap_max_keypoint", ")", ":", "\n", "        ", "self", ".", "use_heatmap_max_keypoint", "=", "use_heatmap_max_keypoint", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.Caffe2KeypointRCNNInference.__call__": [[487, 504], ["shared.alias", "all", "isinstance", "len", "torch.ops._caffe2.HeatmapMaxKeypoint", "torch.ops._caffe2.HeatmapMaxKeypoint", "torch.ops._caffe2.HeatmapMaxKeypoint", "torch.ops._caffe2.HeatmapMaxKeypoint", "shared.to_device", "shared.alias", "shared.to_device"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.alias", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.to_device"], ["", "def", "__call__", "(", "self", ",", "pred_keypoint_logits", ",", "pred_instances", ")", ":", "\n", "# just return the keypoint heatmap for now,", "\n", "# there will be option to call HeatmapMaxKeypointOp", "\n", "        ", "output", "=", "alias", "(", "pred_keypoint_logits", ",", "\"kps_score\"", ")", "\n", "if", "all", "(", "isinstance", "(", "x", ",", "InstancesList", ")", "for", "x", "in", "pred_instances", ")", ":", "\n", "            ", "assert", "len", "(", "pred_instances", ")", "==", "1", "\n", "if", "self", ".", "use_heatmap_max_keypoint", ":", "\n", "                ", "device", "=", "output", ".", "device", "\n", "output", "=", "torch", ".", "ops", ".", "_caffe2", ".", "HeatmapMaxKeypoint", "(", "\n", "to_device", "(", "output", ",", "\"cpu\"", ")", ",", "\n", "pred_instances", "[", "0", "]", ".", "pred_boxes", ".", "tensor", ",", "\n", "should_output_softmax", "=", "True", ",", "# worth make it configerable?", "\n", ")", "\n", "output", "=", "to_device", "(", "output", ",", "device", ")", "\n", "output", "=", "alias", "(", "output", ",", "\"keypoints_out\"", ")", "\n", "", "pred_instances", "[", "0", "]", ".", "pred_keypoints", "=", "output", "\n", "", "return", "pred_keypoint_logits", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer.__init__": [[71, 91], ["isinstance", "isinstance", "type", "api.add_export_config"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.add_export_config"], ["def", "__init__", "(", "self", ",", "cfg", ",", "model", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode): a detectron2 config, with extra export-related options\n                added by :func:`add_export_config`.\n            model (nn.Module): a model built by\n                :func:`detectron2.modeling.build_model`. Weights have to be already\n                loaded to this model.\n            inputs: sample inputs that the given model takes for inference.\n                Will be used to trace the model. Random input with no detected objects\n                will not work if the model has data-dependent control flow (e.g., R-CNN).\n        \"\"\"", "\n", "assert", "isinstance", "(", "cfg", ",", "CN", ")", ",", "cfg", "\n", "assert", "isinstance", "(", "model", ",", "torch", ".", "nn", ".", "Module", ")", ",", "type", "(", "model", ")", "\n", "if", "\"EXPORT_CAFFE2\"", "not", "in", "cfg", ":", "\n", "            ", "cfg", "=", "add_export_config", "(", "cfg", ")", "# will just the defaults", "\n", "\n", "", "self", ".", "cfg", "=", "cfg", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "inputs", "=", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer._get_traceable": [[92, 98], ["C2MetaArch", "C2MetaArch.get_caffe2_inputs", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2MetaArch.get_caffe2_inputs"], ["", "def", "_get_traceable", "(", "self", ")", ":", "\n", "# TODO how to make it extensible to support custom models", "\n", "        ", "C2MetaArch", "=", "META_ARCH_CAFFE2_EXPORT_TYPE_MAP", "[", "self", ".", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "]", "\n", "traceable_model", "=", "C2MetaArch", "(", "self", ".", "cfg", ",", "copy", ".", "deepcopy", "(", "self", ".", "model", ")", ")", "\n", "traceable_inputs", "=", "traceable_model", ".", "get_caffe2_inputs", "(", "self", ".", "inputs", ")", "\n", "return", "traceable_model", ",", "traceable_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer.export_caffe2": [[99, 113], ["api.Caffe2Tracer._get_traceable", "export_caffe2_detection_model", "api.Caffe2Model"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer._get_traceable", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export.export_caffe2_detection_model"], ["", "def", "export_caffe2", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Export the model to Caffe2's protobuf format.\n        The returned object can be saved with ``.save_protobuf()`` method.\n        The result can be loaded and executed using Caffe2 runtime.\n\n        Returns:\n            Caffe2Model\n        \"\"\"", "\n", "from", ".", "caffe2_export", "import", "export_caffe2_detection_model", "\n", "\n", "model", ",", "inputs", "=", "self", ".", "_get_traceable", "(", ")", "\n", "predict_net", ",", "init_net", "=", "export_caffe2_detection_model", "(", "model", ",", "inputs", ")", "\n", "return", "Caffe2Model", "(", "predict_net", ",", "init_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer.export_onnx": [[114, 129], ["api.Caffe2Tracer._get_traceable", "export_onnx_model_impl"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer._get_traceable"], ["", "def", "export_onnx", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Export the model to ONNX format.\n        Note that the exported model contains custom ops only available in caffe2, therefore it\n        cannot be directly executed by other runtime. Post-processing or transformation passes\n        may be applied on the model to accommodate different runtimes, but we currently do not\n        provide support for them.\n\n        Returns:\n            onnx.ModelProto: an onnx model.\n        \"\"\"", "\n", "from", ".", "caffe2_export", "import", "export_onnx_model", "as", "export_onnx_model_impl", "\n", "\n", "model", ",", "inputs", "=", "self", ".", "_get_traceable", "(", ")", "\n", "return", "export_onnx_model_impl", "(", "model", ",", "(", "inputs", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer.export_torchscript": [[130, 143], ["api.Caffe2Tracer._get_traceable", "logging.getLogger", "logging.getLogger.info", "torch.no_grad", "torch.jit.trace"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer._get_traceable"], ["", "def", "export_torchscript", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Export the model to a ``torch.jit.TracedModule`` by tracing.\n        The returned object can be saved to a file by ``.save()``.\n\n        Returns:\n            torch.jit.TracedModule: a torch TracedModule\n        \"\"\"", "\n", "model", ",", "inputs", "=", "self", ".", "_get_traceable", "(", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Tracing the model with torch.jit.trace ...\"", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "return", "torch", ".", "jit", ".", "trace", "(", "model", ",", "(", "inputs", ",", ")", ",", "optimize", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.__init__": [[191, 197], ["torch.nn.Module.__init__", "api.Caffe2Model.eval"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eval", "(", ")", "# always in eval mode", "\n", "self", ".", "_predict_net", "=", "predict_net", "\n", "self", ".", "_init_net", "=", "init_net", "\n", "self", ".", "_predictor", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.predict_net": [[198, 205], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "predict_net", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            core.Net: the underlying caffe2 predict net\n        \"\"\"", "\n", "return", "self", ".", "_predict_net", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.init_net": [[206, 213], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "init_net", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            core.Net: the underlying caffe2 init net\n        \"\"\"", "\n", "return", "self", ".", "_init_net", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.save_protobuf": [[216, 233], ["logging.getLogger", "logging.getLogger.info", "os.makedirs", "open", "f.write", "open", "f.write", "open", "f.write", "os.path.join", "api.Caffe2Model._predict_net.SerializeToString", "os.path.join", "str", "os.path.join", "api.Caffe2Model._init_net.SerializeToString"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write"], ["def", "save_protobuf", "(", "self", ",", "output_dir", ")", ":", "\n", "        ", "\"\"\"\n        Save the model as caffe2's protobuf format.\n\n        Args:\n            output_dir (str): the output directory to save protobuf files.\n        \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Saving model to {} ...\"", ".", "format", "(", "output_dir", ")", ")", "\n", "os", ".", "makedirs", "(", "output_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"model.pb\"", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "self", ".", "_predict_net", ".", "SerializeToString", "(", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"model.pbtxt\"", ")", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "str", "(", "self", ".", "_predict_net", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"model_init.pb\"", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "self", ".", "_init_net", ".", "SerializeToString", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.save_graph": [[234, 255], ["shared.save_graph", "shared.get_pb_arg_vali", "shared.get_pb_arg_vals().decode", "caffe2_modeling.convert_batched_inputs_to_c2_format", "run_and_save_graph", "x.cpu().numpy", "shared.get_pb_arg_vals", "x.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.save_graph", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.convert_batched_inputs_to_c2_format", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_export.run_and_save_graph", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vals"], ["", "", "def", "save_graph", "(", "self", ",", "output_file", ",", "inputs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Save the graph as SVG format.\n\n        Args:\n            output_file (str): a SVG file\n            inputs: optional inputs given to the model.\n                If given, the inputs will be used to run the graph to record\n                shape of every tensor. The shape information will be\n                saved together with the graph.\n        \"\"\"", "\n", "from", ".", "caffe2_export", "import", "run_and_save_graph", "\n", "\n", "if", "inputs", "is", "None", ":", "\n", "            ", "save_graph", "(", "self", ".", "_predict_net", ",", "output_file", ",", "op_only", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "size_divisibility", "=", "get_pb_arg_vali", "(", "self", ".", "_predict_net", ",", "\"size_divisibility\"", ",", "0", ")", "\n", "device", "=", "get_pb_arg_vals", "(", "self", ".", "_predict_net", ",", "\"device\"", ",", "b\"cpu\"", ")", ".", "decode", "(", "\"ascii\"", ")", "\n", "inputs", "=", "convert_batched_inputs_to_c2_format", "(", "inputs", ",", "size_divisibility", ",", "device", ")", "\n", "inputs", "=", "[", "x", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "x", "in", "inputs", "]", "\n", "run_and_save_graph", "(", "self", ".", "_predict_net", ",", "self", ".", "_init_net", ",", "inputs", ",", "output_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.load_protobuf": [[256, 276], ["caffe2.proto.caffe2_pb2.NetDef", "caffe2.proto.caffe2_pb2.NetDef", "api.Caffe2Model", "open", "caffe2.proto.caffe2_pb2.NetDef.ParseFromString", "open", "caffe2.proto.caffe2_pb2.NetDef.ParseFromString", "os.path.join", "f.read", "os.path.join", "f.read"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "load_protobuf", "(", "dir", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dir (str): a directory used to save Caffe2Model with\n                :meth:`save_protobuf`.\n                The files \"model.pb\" and \"model_init.pb\" are needed.\n\n        Returns:\n            Caffe2Model: the caffe2 model loaded from this directory.\n        \"\"\"", "\n", "predict_net", "=", "caffe2_pb2", ".", "NetDef", "(", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dir", ",", "\"model.pb\"", ")", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "predict_net", ".", "ParseFromString", "(", "f", ".", "read", "(", ")", ")", "\n", "\n", "", "init_net", "=", "caffe2_pb2", ".", "NetDef", "(", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "dir", ",", "\"model_init.pb\"", ")", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "init_net", ".", "ParseFromString", "(", "f", ".", "read", "(", ")", ")", "\n", "\n", "", "return", "Caffe2Model", "(", "predict_net", ",", "init_net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.__call__": [[277, 289], ["api.Caffe2Model._predictor", "caffe2_inference.ProtobufDetectionModel"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        An interface that wraps around a caffe2 model and mimics detectron2's models'\n        input & output format. This is used to compare the outputs of caffe2 model\n        with its original torch model.\n\n        Due to the extra conversion between torch/caffe2,\n        this method is not meant for benchmark.\n        \"\"\"", "\n", "if", "self", ".", "_predictor", "is", "None", ":", "\n", "            ", "self", ".", "_predictor", "=", "ProtobufDetectionModel", "(", "self", ".", "_predict_net", ",", "self", ".", "_init_net", ")", "\n", "", "return", "self", ".", "_predictor", "(", "inputs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.add_export_config": [[24, 40], ["cfg.is_frozen", "cfg.defrost", "detectron2.config.CfgNode", "cfg.freeze"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze"], ["def", "add_export_config", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg (CfgNode): a detectron2 config\n\n    Returns:\n        CfgNode: an updated config with new options that will be used\n            by :class:`Caffe2Tracer`.\n    \"\"\"", "\n", "is_frozen", "=", "cfg", ".", "is_frozen", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "EXPORT_CAFFE2", "=", "CN", "(", ")", "\n", "cfg", ".", "EXPORT_CAFFE2", ".", "USE_HEATMAP_MAX_KEYPOINT", "=", "False", "\n", "if", "is_frozen", ":", "\n", "        ", "cfg", ".", "freeze", "(", ")", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.export_caffe2_model": [[145, 162], ["api.Caffe2Tracer.export_caffe2", "api.Caffe2Tracer"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer.export_caffe2"], ["", "", "", "def", "export_caffe2_model", "(", "cfg", ",", "model", ",", "inputs", ")", ":", "\n", "    ", "\"\"\"\n    Export a detectron2 model to caffe2 format.\n\n    Args:\n        cfg (CfgNode): a detectron2 config, with extra export-related options\n            added by :func:`add_export_config`.\n        model (nn.Module): a model built by\n            :func:`detectron2.modeling.build_model`.\n            It will be modified by this function.\n        inputs: sample inputs that the given model takes for inference.\n            Will be used to trace the model.\n\n    Returns:\n        Caffe2Model\n    \"\"\"", "\n", "return", "Caffe2Tracer", "(", "cfg", ",", "model", ",", "inputs", ")", ".", "export_caffe2", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.export_onnx_model": [[164, 184], ["api.Caffe2Tracer.export_onnx", "api.Caffe2Tracer"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Tracer.export_onnx"], ["", "def", "export_onnx_model", "(", "cfg", ",", "model", ",", "inputs", ")", ":", "\n", "    ", "\"\"\"\n    Export a detectron2 model to ONNX format.\n    Note that the exported model contains custom ops only available in caffe2, therefore it\n    cannot be directly executed by other runtime. Post-processing or transformation passes\n    may be applied on the model to accommodate different runtimes, but we currently do not\n    provide support for them.\n\n    Args:\n        cfg (CfgNode): a detectron2 config, with extra export-related options\n            added by :func:`add_export_config`.\n        model (nn.Module): a model built by\n            :func:`detectron2.modeling.build_model`.\n            It will be modified by this function.\n        inputs: sample inputs that the given model takes for inference.\n            Will be used to trace the model.\n    Returns:\n        onnx.ModelProto: an onnx model.\n    \"\"\"", "\n", "return", "Caffe2Tracer", "(", "cfg", ",", "model", ",", "inputs", ")", ".", "export_onnx", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_inference.ProtobufModel.__init__": [[23, 39], ["logger.info", "super().__init__", "isinstance", "isinstance", "caffe2.python.core.Net", "set", "shared.ScopedWS", "ws.RunNetOnce", "ws.CreateNet", "caffe2_inference.ProtobufModel.net.Proto", "ws.Blobs", "ws.CreateBlob"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["def", "__init__", "(", "self", ",", "predict_net", ",", "init_net", ")", ":", "\n", "        ", "logger", ".", "info", "(", "\"Initializing ProtobufModel ...\"", ")", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "predict_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "assert", "isinstance", "(", "init_net", ",", "caffe2_pb2", ".", "NetDef", ")", "\n", "self", ".", "ws_name", "=", "\"__ws_tmp__\"", "\n", "self", ".", "net", "=", "core", ".", "Net", "(", "predict_net", ")", "\n", "\n", "with", "ScopedWS", "(", "self", ".", "ws_name", ",", "is_reset", "=", "True", ",", "is_cleanup", "=", "False", ")", "as", "ws", ":", "\n", "            ", "ws", ".", "RunNetOnce", "(", "init_net", ")", "\n", "for", "blob", "in", "self", ".", "net", ".", "Proto", "(", ")", ".", "external_input", ":", "\n", "                ", "if", "blob", "not", "in", "ws", ".", "Blobs", "(", ")", ":", "\n", "                    ", "ws", ".", "CreateBlob", "(", "blob", ")", "\n", "", "", "ws", ".", "CreateNet", "(", "self", ".", "net", ")", "\n", "\n", "", "self", ".", "_error_msgs", "=", "set", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_inference.ProtobufModel.forward": [[40, 66], ["all", "shared.ScopedWS", "inputs_dict.items", "collections.OrderedDict", "ws.FeedBlob", "ws.RunNet", "caffe2_inference.ProtobufModel.net.Proto", "ws.FeedBlob", "logger.warning", "caffe2_inference.ProtobufModel.net.Proto", "caffe2_inference.ProtobufModel.net.Proto", "caffe2_inference.ProtobufModel._error_msgs.add", "logger.warning", "ws.FetchBlob", "str", "str", "caffe2_inference.ProtobufModel.net.Proto", "str"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.add"], ["", "def", "forward", "(", "self", ",", "inputs_dict", ")", ":", "\n", "        ", "assert", "all", "(", "inp", "in", "self", ".", "net", ".", "Proto", "(", ")", ".", "external_input", "for", "inp", "in", "inputs_dict", ")", "\n", "with", "ScopedWS", "(", "self", ".", "ws_name", ",", "is_reset", "=", "False", ",", "is_cleanup", "=", "False", ")", "as", "ws", ":", "\n", "            ", "for", "b", ",", "tensor", "in", "inputs_dict", ".", "items", "(", ")", ":", "\n", "                ", "ws", ".", "FeedBlob", "(", "b", ",", "tensor", ")", "\n", "", "try", ":", "\n", "                ", "ws", ".", "RunNet", "(", "self", ".", "net", ".", "Proto", "(", ")", ".", "name", ")", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "                ", "if", "not", "str", "(", "e", ")", "in", "self", ".", "_error_msgs", ":", "\n", "                    ", "self", ".", "_error_msgs", ".", "add", "(", "str", "(", "e", ")", ")", "\n", "logger", ".", "warning", "(", "\"Encountered new RuntimeError: \\n{}\"", ".", "format", "(", "str", "(", "e", ")", ")", ")", "\n", "", "logger", ".", "warning", "(", "\"Catch the error and use partial results.\"", ")", "\n", "\n", "", "outputs_dict", "=", "collections", ".", "OrderedDict", "(", "\n", "[", "(", "b", ",", "ws", ".", "FetchBlob", "(", "b", ")", ")", "for", "b", "in", "self", ".", "net", ".", "Proto", "(", ")", ".", "external_output", "]", "\n", ")", "\n", "# Remove outputs of current run, this is necessary in order to", "\n", "# prevent fetching the result from previous run if the model fails", "\n", "# in the middle.", "\n", "for", "b", "in", "self", ".", "net", ".", "Proto", "(", ")", ".", "external_output", ":", "\n", "# Needs to create uninitialized blob to make the net runable.", "\n", "# This is \"equivalent\" to: ws.RemoveBlob(b) then ws.CreateBlob(b),", "\n", "# but there'no such API.", "\n", "                ", "ws", ".", "FeedBlob", "(", "b", ",", "\"{}, a C++ native class of type nullptr (uninitialized).\"", ".", "format", "(", "b", ")", ")", "\n", "\n", "", "", "return", "outputs_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_inference.ProtobufDetectionModel.__init__": [[74, 93], ["super().__init__", "caffe2_inference.ProtobufModel", "shared.get_pb_arg_vali", "shared.get_pb_arg_vals().decode", "shared.get_pb_arg_vals", "shared.get_pb_arg_vals.get_outputs_converter", "shared.get_pb_arg_vals", "shared.get_pb_arg_vals.decode"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vali", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.Caffe2RetinaNet.get_outputs_converter", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.get_pb_arg_vals"], ["def", "__init__", "(", "self", ",", "predict_net", ",", "init_net", ",", "*", ",", "convert_outputs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            predict_net, init_net (core.Net): caffe2 nets\n            convert_outptus (callable): a function that converts caffe2\n                outputs to the same format of the original pytorch model.\n                By default, use the one defined in the caffe2 meta_arch.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "protobuf_model", "=", "ProtobufModel", "(", "predict_net", ",", "init_net", ")", "\n", "self", ".", "size_divisibility", "=", "get_pb_arg_vali", "(", "predict_net", ",", "\"size_divisibility\"", ",", "0", ")", "\n", "self", ".", "device", "=", "get_pb_arg_vals", "(", "predict_net", ",", "\"device\"", ",", "b\"cpu\"", ")", ".", "decode", "(", "\"ascii\"", ")", "\n", "\n", "if", "convert_outputs", "is", "None", ":", "\n", "            ", "meta_arch", "=", "get_pb_arg_vals", "(", "predict_net", ",", "\"meta_architecture\"", ",", "b\"GeneralizedRCNN\"", ")", "\n", "meta_arch", "=", "META_ARCH_CAFFE2_EXPORT_TYPE_MAP", "[", "meta_arch", ".", "decode", "(", "\"ascii\"", ")", "]", "\n", "self", ".", "_convert_outputs", "=", "meta_arch", ".", "get_outputs_converter", "(", "predict_net", ",", "init_net", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_convert_outputs", "=", "convert_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_inference.ProtobufDetectionModel._infer_output_devices": [[94, 111], ["caffe2_inference.ProtobufDetectionModel.protobuf_model.net.Proto", "shared.infer_device_type", "caffe2.python.core.get_ssa", "caffe2_inference.ProtobufDetectionModel._infer_output_devices._get_device_type"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.infer_device_type"], ["", "", "def", "_infer_output_devices", "(", "self", ",", "inputs_dict", ")", ":", "\n", "        ", "def", "_get_device_type", "(", "torch_tensor", ")", ":", "\n", "            ", "assert", "torch_tensor", ".", "device", ".", "type", "in", "[", "\"cpu\"", ",", "\"cuda\"", "]", "\n", "assert", "torch_tensor", ".", "device", ".", "index", "==", "0", "\n", "return", "torch_tensor", ".", "device", ".", "type", "\n", "\n", "", "predict_net", "=", "self", ".", "protobuf_model", ".", "net", ".", "Proto", "(", ")", "\n", "input_device_types", "=", "{", "\n", "(", "name", ",", "0", ")", ":", "_get_device_type", "(", "tensor", ")", "for", "name", ",", "tensor", "in", "inputs_dict", ".", "items", "(", ")", "\n", "}", "\n", "device_type_map", "=", "infer_device_type", "(", "\n", "predict_net", ",", "known_status", "=", "input_device_types", ",", "device_name_style", "=", "\"pytorch\"", "\n", ")", "\n", "ssa", ",", "versions", "=", "core", ".", "get_ssa", "(", "predict_net", ")", "\n", "versioned_outputs", "=", "[", "(", "name", ",", "versions", "[", "name", "]", ")", "for", "name", "in", "predict_net", ".", "external_output", "]", "\n", "output_devices", "=", "[", "device_type_map", "[", "outp", "]", "for", "outp", "in", "versioned_outputs", "]", "\n", "return", "output_devices", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_inference.ProtobufDetectionModel._convert_inputs": [[112, 118], ["caffe2_modeling.convert_batched_inputs_to_c2_format"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_modeling.convert_batched_inputs_to_c2_format"], ["", "def", "_convert_inputs", "(", "self", ",", "batched_inputs", ")", ":", "\n", "# currently all models convert inputs in the same way", "\n", "        ", "data", ",", "im_info", "=", "convert_batched_inputs_to_c2_format", "(", "\n", "batched_inputs", ",", "self", ".", "size_divisibility", ",", "self", ".", "device", "\n", ")", "\n", "return", "{", "\"data\"", ":", "data", ",", "\"im_info\"", ":", "im_info", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_inference.ProtobufDetectionModel.forward": [[119, 137], ["caffe2_inference.ProtobufDetectionModel._convert_inputs", "caffe2_inference.ProtobufDetectionModel.protobuf_model", "any", "caffe2_inference.ProtobufDetectionModel._convert_outputs", "caffe2_inference.ProtobufDetectionModel._infer_output_devices", "caffe2_inference.ProtobufDetectionModel.forward._cast_caffe2_blob_to_torch_tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_inference.ProtobufDetectionModel._convert_inputs", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.caffe2_inference.ProtobufDetectionModel._infer_output_devices"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "c2_inputs", "=", "self", ".", "_convert_inputs", "(", "batched_inputs", ")", "\n", "c2_results", "=", "self", ".", "protobuf_model", "(", "c2_inputs", ")", "\n", "\n", "if", "any", "(", "t", ".", "device", ".", "type", "!=", "\"cpu\"", "for", "_", ",", "t", "in", "c2_inputs", ".", "items", "(", ")", ")", ":", "\n", "            ", "output_devices", "=", "self", ".", "_infer_output_devices", "(", "c2_inputs", ")", "\n", "", "else", ":", "\n", "            ", "output_devices", "=", "[", "\"cpu\"", "for", "_", "in", "self", ".", "protobuf_model", ".", "net", ".", "Proto", "(", ")", ".", "external_output", "]", "\n", "\n", "", "def", "_cast_caffe2_blob_to_torch_tensor", "(", "blob", ",", "device", ")", ":", "\n", "            ", "return", "torch", ".", "Tensor", "(", "blob", ")", ".", "to", "(", "device", ")", "if", "isinstance", "(", "blob", ",", "np", ".", "ndarray", ")", "else", "None", "\n", "\n", "", "c2_results", "=", "{", "\n", "name", ":", "_cast_caffe2_blob_to_torch_tensor", "(", "c2_results", "[", "name", "]", ",", "device", ")", "\n", "for", "name", ",", "device", "in", "zip", "(", "self", ".", "protobuf_model", ".", "net", ".", "Proto", "(", ")", ".", "external_output", ",", "output_devices", ")", "\n", "}", "\n", "\n", "return", "self", ".", "_convert_outputs", "(", "batched_inputs", ",", "c2_inputs", ",", "c2_results", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultPredictor.__init__": [[186, 202], ["cfg.clone", "detectron2.modeling.build_model", "defaults.DefaultPredictor.model.eval", "len", "detectron2.checkpoint.DetectionCheckpointer", "detectron2.checkpoint.DetectionCheckpointer.load", "detectron2.ResizeShortestEdge", "detectron2.data.MetadataCatalog.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["# Anchor angles.", "\n", "# list[list[float]], the angle in degrees, for each input feature map.", "\n", "# ANGLES[i] specifies the list of angles for IN_FEATURES[i].", "\n", "_C", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "ANGLES", "=", "[", "[", "-", "90", ",", "0", ",", "90", "]", "]", "\n", "# Relative offset between the center of the first anchor and the top-left corner of the image", "\n", "# Value has to be in [0, 1). Recommend to use 0.5, which means half stride.", "\n", "# The value is not expected to affect model accuracy.", "\n", "_C", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "OFFSET", "=", "0.0", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# RPN options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "RPN", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", "=", "\"StandardRPNHead\"", "# used by RPN_HEAD_REGISTRY", "\n", "\n", "# Names of the input feature maps to be used by RPN", "\n", "# e.g., [\"p2\", \"p3\", \"p4\", \"p5\", \"p6\"] for FPN", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultPredictor.__call__": [[203, 225], ["torch.no_grad", "defaults.DefaultPredictor.aug.get_transform().apply_image", "torch.as_tensor", "torch.as_tensor.astype().transpose", "defaults.DefaultPredictor.model", "defaults.DefaultPredictor.aug.get_transform", "torch.as_tensor.astype"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.get_transform"], ["_C", ".", "MODEL", ".", "RPN", ".", "IN_FEATURES", "=", "[", "\"res4\"", "]", "\n", "# Remove RPN anchors that go outside the image by BOUNDARY_THRESH pixels", "\n", "# Set to -1 or a large value, e.g. 100000, to disable pruning anchors", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "BOUNDARY_THRESH", "=", "-", "1", "\n", "# IOU overlap ratios [BG_IOU_THRESHOLD, FG_IOU_THRESHOLD]", "\n", "# Minimum overlap required between an anchor and ground-truth box for the", "\n", "# (anchor, gt box) pair to be a positive example (IoU >= FG_IOU_THRESHOLD", "\n", "# ==> positive RPN example: 1)", "\n", "# Maximum overlap allowed between an anchor and ground-truth box for the", "\n", "# (anchor, gt box) pair to be a negative examples (IoU < BG_IOU_THRESHOLD", "\n", "# ==> negative RPN example: 0)", "\n", "# Anchors with overlap in between (BG_IOU_THRESHOLD <= IoU < FG_IOU_THRESHOLD)", "\n", "# are ignored (-1)", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "IOU_THRESHOLDS", "=", "[", "0.3", ",", "0.7", "]", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "IOU_LABELS", "=", "[", "0", ",", "-", "1", ",", "1", "]", "\n", "# Number of regions per image used to train RPN", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "BATCH_SIZE_PER_IMAGE", "=", "256", "\n", "# Target fraction of foreground (positive) examples per RPN minibatch", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "POSITIVE_FRACTION", "=", "0.5", "\n", "# Options are: \"smooth_l1\", \"giou\"", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_LOSS_TYPE", "=", "\"smooth_l1\"", "\n", "_C", ".", "MODEL", ".", "RPN", ".", "BBOX_REG_LOSS_WEIGHT", "=", "1.0", "\n", "# Weights on (dx, dy, dw, dh) for normalizing RPN anchor regression targets", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.__init__": [[271, 307], ["logging.getLogger", "defaults.DefaultTrainer.auto_scale_workers", "defaults.DefaultTrainer.build_model", "defaults.DefaultTrainer.build_optimizer", "defaults.DefaultTrainer.build_train_loader", "train_loop.SimpleTrainer.__init__", "defaults.DefaultTrainer.build_lr_scheduler", "detectron2.checkpoint.DetectionCheckpointer", "defaults.DefaultTrainer.register_hooks", "logging.getLogger.isEnabledFor", "detectron2.utils.logger.setup_logger", "detectron2.utils.comm.get_world_size", "detectron2.utils.comm.get_world_size", "torch.nn.parallel.DistributedDataParallel", "defaults.DefaultTrainer.build_hooks", "detectron2.utils.comm.get_local_rank"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.auto_scale_workers", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.Trainer.build_optimizer", "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.Trainer.build_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.build_solver.build_lr_scheduler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_hooks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_local_rank"], ["# Minimum score threshold (assuming scores in a [0, 1] range); a value chosen to", "\n", "# balance obtaining high recall with not having too many low precision", "\n", "# detections that will slow down inference post processing steps (like NMS)", "\n", "# A default threshold of 0.0 increases AP by ~0.2-0.3 but significantly slows down", "\n", "# inference.", "\n", "_C", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", "=", "0.05", "\n", "# Overlap threshold used for non-maximum suppression (suppress boxes with", "\n", "# IoU >= this threshold)", "\n", "_C", ".", "MODEL", ".", "ROI_HEADS", ".", "NMS_THRESH_TEST", "=", "0.5", "\n", "# If True, augment proposals with ground-truth boxes before sampling proposals to", "\n", "# train ROI heads.", "\n", "_C", ".", "MODEL", ".", "ROI_HEADS", ".", "PROPOSAL_APPEND_GT", "=", "True", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Box Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", "=", "CN", "(", ")", "\n", "# C4 don't use head name option", "\n", "# Options for non-C4 models: FastRCNNConvFCHead,", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NAME", "=", "\"\"", "\n", "# Options are: \"smooth_l1\", \"giou\"", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_LOSS_TYPE", "=", "\"smooth_l1\"", "\n", "# The final scaling coefficient on the box regression loss, used to balance the magnitude of its", "\n", "# gradients with other losses in the model. See also `MODEL.ROI_KEYPOINT_HEAD.LOSS_WEIGHT`.", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_LOSS_WEIGHT", "=", "1.0", "\n", "# Default weights on (dx, dy, dw, dh) for normalizing bbox regression targets", "\n", "# These are empirically chosen to approximately lead to unit variance targets", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "BBOX_REG_WEIGHTS", "=", "(", "10.0", ",", "10.0", ",", "5.0", ",", "5.0", ")", "\n", "# The transition point from L1 to L2 loss. Set to 0.0 to make the loss simply L1.", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "SMOOTH_L1_BETA", "=", "0.0", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "=", "14", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "=", "0", "\n", "# Type of pooling operation applied to the incoming feature map for each RoI", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignV2\"", "\n", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_FC", "=", "0", "\n", "# Hidden layer dimension for FC layers in the RoI box head", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load": [[308, 323], ["defaults.DefaultTrainer.checkpointer.resume_or_load", "defaults.DefaultTrainer.checkpointer.has_checkpoint", "defaults.DefaultTrainer.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "FC_DIM", "=", "1024", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NUM_CONV", "=", "0", "\n", "# Channel dimension for Conv layers in the RoI box head", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CONV_DIM", "=", "256", "\n", "# Normalization method for the convolution layers.", "\n", "# Options: \"\" (no norm), \"GN\", \"SyncBN\".", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "NORM", "=", "\"\"", "\n", "# Whether to use class agnostic for bbox regression", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "CLS_AGNOSTIC_BBOX_REG", "=", "False", "\n", "# If true, RoI heads use bounding boxes predicted by the box head rather than proposal boxes.", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "TRAIN_ON_PRED_BOXES", "=", "False", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Cascaded Box Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_CASCADE_HEAD", "=", "CN", "(", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_hooks": [[326, 372], ["defaults.DefaultTrainer.cfg.clone", "defaults.DefaultTrainer.defrost", "detectron2.utils.comm.is_main_process", "ret.append", "detectron2.utils.comm.is_main_process", "hooks.IterationTimer", "hooks.LRScheduler", "ret.append", "defaults.DefaultTrainer.test", "hooks.EvalHook", "ret.append", "hooks.PreciseBN", "hooks.PeriodicCheckpointer", "hooks.PeriodicWriter", "fvcore.nn.precise_bn.get_bn_modules", "defaults.DefaultTrainer.build_train_loader", "defaults.DefaultTrainer.build_writers"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.Trainer.build_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.build_writers"], ["(", "10.0", ",", "10.0", ",", "5.0", ",", "5.0", ")", ",", "\n", "(", "20.0", ",", "20.0", ",", "10.0", ",", "10.0", ")", ",", "\n", "(", "30.0", ",", "30.0", ",", "15.0", ",", "15.0", ")", ",", "\n", ")", "\n", "_C", ".", "MODEL", ".", "ROI_BOX_CASCADE_HEAD", ".", "IOUS", "=", "(", "0.5", ",", "0.6", ",", "0.7", ")", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Mask Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NAME", "=", "\"MaskRCNNConvUpsampleHead\"", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "=", "14", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_SAMPLING_RATIO", "=", "0", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NUM_CONV", "=", "0", "# The number of convs in the mask head", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", "=", "256", "\n", "# Normalization method for the convolution layers.", "\n", "# Options: \"\" (no norm), \"GN\", \"SyncBN\".", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NORM", "=", "\"\"", "\n", "# Whether to use class agnostic for mask prediction", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CLS_AGNOSTIC_MASK", "=", "False", "\n", "# Type of pooling operation applied to the incoming feature map for each RoI", "\n", "_C", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignV2\"", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Keypoint Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NAME", "=", "\"KRCNNConvDeconvUpsampleHead\"", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_RESOLUTION", "=", "14", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_SAMPLING_RATIO", "=", "0", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "CONV_DIMS", "=", "tuple", "(", "512", "for", "_", "in", "range", "(", "8", ")", ")", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NUM_KEYPOINTS", "=", "17", "# 17 is the number of keypoints in COCO.", "\n", "\n", "# Images with too few (or no) keypoints are excluded from training.", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "MIN_KEYPOINTS_PER_IMAGE", "=", "1", "\n", "# Normalize by the total number of visible keypoints in the minibatch if True.", "\n", "# Otherwise, normalize by the total number of keypoints that could ever exist", "\n", "# in the minibatch.", "\n", "# The keypoint softmax loss is only calculated on visible keypoints.", "\n", "# Since the number of visible keypoints can vary significantly between", "\n", "# minibatches, this has the effect of up-weighting the importance of", "\n", "# minibatches with few visible keypoints. (Imagine the extreme case of", "\n", "# only one visible keypoint versus N: in the case of N, each one", "\n", "# contributes 1/N to the gradient compared to the single keypoint", "\n", "# determining the gradient direction). Instead, we can normalize the", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_writers": [[373, 399], ["detectron2.utils.events.CommonMetricPrinter", "detectron2.utils.events.JSONWriter", "detectron2.utils.events.TensorboardXWriter", "os.path.join"], "methods", ["None"], ["# loss by the total number of keypoints, if it were the case that all", "\n", "# keypoints were visible in a full minibatch. (Returning to the example,", "\n", "# this means that the one visible keypoint contributes as much as each", "\n", "# of the N keypoints.)", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NORMALIZE_LOSS_BY_VISIBLE_KEYPOINTS", "=", "True", "\n", "# Multi-task loss weight to use for keypoints", "\n", "# Recommended values:", "\n", "#   - use 1.0 if NORMALIZE_LOSS_BY_VISIBLE_KEYPOINTS is True", "\n", "#   - use 4.0 if NORMALIZE_LOSS_BY_VISIBLE_KEYPOINTS is False", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "LOSS_WEIGHT", "=", "1.0", "\n", "# Type of pooling operation applied to the incoming feature map for each RoI", "\n", "_C", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_TYPE", "=", "\"ROIAlignV2\"", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Semantic Segmentation Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", "=", "CN", "(", ")", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NAME", "=", "\"SemSegFPNHead\"", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IN_FEATURES", "=", "[", "\"p2\"", ",", "\"p3\"", ",", "\"p4\"", ",", "\"p5\"", "]", "\n", "# Label in the semantic segmentation ground truth that is ignored, i.e., no loss is calculated for", "\n", "# the correposnding pixel.", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", "=", "255", "\n", "# Number of classes in the semantic segmentation head", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "=", "54", "\n", "# Number of channels in the 3x3 convs inside semantic-FPN heads.", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "CONVS_DIM", "=", "128", "\n", "# Outputs from semantic-FPN heads are up-scaled to the COMMON_STRIDE stride.", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.train": [[401, 415], ["super().train", "len", "detectron2.utils.comm.is_main_process", "hasattr", "detectron2.evaluation.verify_results"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.verify_results"], ["# Normalization method for the convolution layers. Options: \"\" (no norm), \"GN\".", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NORM", "=", "\"GN\"", "\n", "_C", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_WEIGHT", "=", "1.0", "\n", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", "=", "CN", "(", ")", "\n", "# Scaling of all losses from instance detection / segmentation head.", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "INSTANCE_LOSS_WEIGHT", "=", "1.0", "\n", "\n", "# options when combining instance & semantic segmentation outputs", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", "=", "CN", "(", "{", "\"ENABLED\"", ":", "True", "}", ")", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "OVERLAP_THRESH", "=", "0.5", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "STUFF_AREA_LIMIT", "=", "4096", "\n", "_C", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "=", "0.5", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model": [[416, 429], ["detectron2.modeling.build_model", "logging.getLogger", "logging.getLogger.info"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model"], ["# ---------------------------------------------------------------------------- #", "\n", "# RetinaNet Head", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "RETINANET", "=", "CN", "(", ")", "\n", "\n", "# This is the number of foreground classes.", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "NUM_CLASSES", "=", "80", "\n", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "IN_FEATURES", "=", "[", "\"p3\"", ",", "\"p4\"", ",", "\"p5\"", ",", "\"p6\"", ",", "\"p7\"", "]", "\n", "\n", "# Convolutions to use in the cls and bbox tower", "\n", "# NOTE: this doesn't include the last conv for logits", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "NUM_CONVS", "=", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_optimizer": [[430, 440], ["detectron2.solver.build_optimizer"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.Trainer.build_optimizer"], ["# IoU overlap ratio [bg, fg] for labeling anchors.", "\n", "# Anchors with < bg are labeled negative (0)", "\n", "# Anchors  with >= bg and < fg are ignored (-1)", "\n", "# Anchors with >= fg are labeled positive (1)", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "IOU_THRESHOLDS", "=", "[", "0.4", ",", "0.5", "]", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "IOU_LABELS", "=", "[", "0", ",", "-", "1", ",", "1", "]", "\n", "\n", "# Prior prob for rare case (i.e. foreground) at the beginning of training.", "\n", "# This is used to set the bias for the logits layer of the classifier subnet.", "\n", "# This improves training stability in the case of heavy class imbalance.", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "PRIOR_PROB", "=", "0.01", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_lr_scheduler": [[441, 448], ["detectron2.solver.build_lr_scheduler"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.build_solver.build_lr_scheduler"], ["\n", "# Inference cls score threshold, only anchors with score > INFERENCE_TH are", "\n", "# considered for inference (to improve speed)", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "=", "0.05", "\n", "# Select topk candidates before NMS", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "TOPK_CANDIDATES_TEST", "=", "1000", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "NMS_THRESH_TEST", "=", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_train_loader": [[449, 459], ["detectron2.data.build_detection_train_loader"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader"], ["# Weights on (dx, dy, dw, dh) for normalizing Retinanet anchor regression targets", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "BBOX_REG_WEIGHTS", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", "\n", "\n", "# Loss parameters", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "FOCAL_LOSS_GAMMA", "=", "2.0", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "FOCAL_LOSS_ALPHA", "=", "0.25", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "SMOOTH_L1_LOSS_BETA", "=", "0.1", "\n", "# Options are: \"smooth_l1\", \"giou\"", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "BBOX_REG_LOSS_TYPE", "=", "\"smooth_l1\"", "\n", "\n", "# One of BN, SyncBN, FrozenBN, GN", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_test_loader": [[460, 470], ["detectron2.data.build_detection_test_loader"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_test_loader"], ["# Only supports GN until unshared norm is implemented", "\n", "_C", ".", "MODEL", ".", "RETINANET", ".", "NORM", "=", "\"\"", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# ResNe[X]t options (ResNets = {ResNet, ResNeXt}", "\n", "# Note that parts of a resnet may be used for both the backbone and the head", "\n", "# These options apply to both", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "RESNETS", "=", "CN", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_evaluator": [[471, 485], ["NotImplementedError"], "methods", ["None"], ["_C", ".", "MODEL", ".", "RESNETS", ".", "DEPTH", "=", "50", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "OUT_FEATURES", "=", "[", "\"res4\"", "]", "# res4 for C4 backbone, res2..5 for FPN backbone", "\n", "\n", "# Number of groups to use; 1 ==> ResNet; > 1 ==> ResNeXt", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", "=", "1", "\n", "\n", "# Options: FrozenBN, GN, \"SyncBN\", \"BN\"", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "NORM", "=", "\"FrozenBN\"", "\n", "\n", "# Baseline width of each group.", "\n", "# Scaling this parameters will scale the width of all bottleneck layers.", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", "=", "64", "\n", "\n", "# Place the stride 2 conv on the 1x1 filter", "\n", "# Use True only for the original MSRA ResNet; use False for C2 and Torch models", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.test": [[487, 539], ["logging.getLogger", "isinstance", "collections.OrderedDict", "enumerate", "cls.build_test_loader", "detectron2.evaluation.inference_on_dataset", "detectron2.utils.comm.is_main_process", "len", "len", "len", "len", "len", "isinstance", "logging.getLogger.info", "detectron2.evaluation.print_csv_format", "list", "cls.build_evaluator", "collections.OrderedDict.values", "logging.getLogger.warn"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.build_test_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.inference_on_dataset", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.print_csv_format", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.Trainer.build_evaluator"], ["\n", "# Apply dilation in stage \"res5\"", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "RES5_DILATION", "=", "1", "\n", "\n", "# Output width of res2. Scaling this parameters will scale the width of all 1x1 convs in ResNet", "\n", "# For R18 and R34, this needs to be set to 64", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "=", "256", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", "=", "64", "\n", "\n", "# Apply Deformable Convolution in stages", "\n", "# Specify if apply deform_conv on Res2, Res3, Res4, Res5", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_ON_PER_STAGE", "=", "[", "False", ",", "False", ",", "False", ",", "False", "]", "\n", "# Use True to use modulated deform_conv (DeformableV2, https://arxiv.org/abs/1811.11168);", "\n", "# Use False for DeformableV1.", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_MODULATED", "=", "False", "\n", "# Number of groups in deformable conv.", "\n", "_C", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_NUM_GROUPS", "=", "1", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Solver", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "SOLVER", "=", "CN", "(", ")", "\n", "\n", "# See detectron2/solver/build.py for LR scheduler options", "\n", "_C", ".", "SOLVER", ".", "LR_SCHEDULER_NAME", "=", "\"WarmupMultiStepLR\"", "\n", "\n", "_C", ".", "SOLVER", ".", "MAX_ITER", "=", "40000", "\n", "\n", "_C", ".", "SOLVER", ".", "BASE_LR", "=", "0.001", "\n", "\n", "_C", ".", "SOLVER", ".", "MOMENTUM", "=", "0.9", "\n", "\n", "_C", ".", "SOLVER", ".", "NESTEROV", "=", "False", "\n", "\n", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY", "=", "0.0001", "\n", "# The weight decay that's applied to parameters of normalization layers", "\n", "# (typically the affine transformation)", "\n", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY_NORM", "=", "0.0", "\n", "\n", "_C", ".", "SOLVER", ".", "GAMMA", "=", "0.1", "\n", "# The iteration number to decrease learning rate by GAMMA.", "\n", "_C", ".", "SOLVER", ".", "STEPS", "=", "(", "30000", ",", ")", "\n", "\n", "_C", ".", "SOLVER", ".", "WARMUP_FACTOR", "=", "1.0", "/", "1000", "\n", "_C", ".", "SOLVER", ".", "WARMUP_ITERS", "=", "1000", "\n", "_C", ".", "SOLVER", ".", "WARMUP_METHOD", "=", "\"linear\"", "\n", "\n", "# Save a checkpoint after every this number of iterations", "\n", "_C", ".", "SOLVER", ".", "CHECKPOINT_PERIOD", "=", "5000", "\n", "\n", "# Number of images per batch across all machines.", "\n", "# If we have 16 GPUs and IMS_PER_BATCH = 32,", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.auto_scale_workers": [[540, 585], ["cfg.clone.clone.clone", "cfg.clone.clone.is_frozen", "cfg.clone.clone.defrost", "int", "int", "int", "tuple", "int", "logging.getLogger", "logging.getLogger.info", "round", "round", "round", "round", "cfg.clone.clone.freeze", "int", "round"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze"], ["# each GPU will see 2 images per batch.", "\n", "# May be adjusted automatically if REFERENCE_WORLD_SIZE is set.", "\n", "_C", ".", "SOLVER", ".", "IMS_PER_BATCH", "=", "16", "\n", "\n", "# The reference number of workers (GPUs) this config is meant to train with.", "\n", "# With a non-zero value, it will be used by DefaultTrainer to compute a desired", "\n", "# per-worker batch size, and then scale the other related configs (total batch size,", "\n", "# learning rate, etc) to match the per-worker batch size if the actual number", "\n", "# of workers during training is different from this reference.", "\n", "_C", ".", "SOLVER", ".", "REFERENCE_WORLD_SIZE", "=", "0", "\n", "\n", "# Detectron v1 (and previous detection code) used a 2x higher LR and 0 WD for", "\n", "# biases. This is not useful (at least for recent models). You should avoid", "\n", "# changing these and they exist only to reproduce Detectron v1 training if", "\n", "# desired.", "\n", "_C", ".", "SOLVER", ".", "BIAS_LR_FACTOR", "=", "1.0", "\n", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY_BIAS", "=", "_C", ".", "SOLVER", ".", "WEIGHT_DECAY", "\n", "\n", "# Gradient clipping", "\n", "_C", ".", "SOLVER", ".", "CLIP_GRADIENTS", "=", "CN", "(", "{", "\"ENABLED\"", ":", "False", "}", ")", "\n", "# Type of gradient clipping, currently 2 values are supported:", "\n", "# - \"value\": the absolute values of elements of each gradients are clipped", "\n", "# - \"norm\": the norm of the gradient for each parameter is clipped thus", "\n", "#   affecting all elements in the parameter", "\n", "_C", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "CLIP_TYPE", "=", "\"value\"", "\n", "# Maximum absolute value used for clipping gradients", "\n", "_C", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "CLIP_VALUE", "=", "1.0", "\n", "# Floating point number p for L-p norm to be used with the \"norm\"", "\n", "# gradient clipping type; for L-inf, please specify .inf", "\n", "_C", ".", "SOLVER", ".", "CLIP_GRADIENTS", ".", "NORM_TYPE", "=", "2.0", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Specific test options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "TEST", "=", "CN", "(", ")", "\n", "# For end-to-end tests to verify the expected accuracy.", "\n", "# Each item is [task, metric, value, tolerance]", "\n", "# e.g.: [['bbox', 'AP', 38.5, 0.2]]", "\n", "_C", ".", "TEST", ".", "EXPECTED_RESULTS", "=", "[", "]", "\n", "# The period (in terms of steps) to evaluate the model during training.", "\n", "# Set to 0 to disable.", "\n", "_C", ".", "TEST", ".", "EVAL_PERIOD", "=", "0", "\n", "# The sigmas used to calculate keypoint OKS. See http://cocodataset.org/#keypoints-eval", "\n", "# When empty, it will use the defaults in COCO.", "\n", "# Otherwise it should be a list[float] with the same length as ROI_KEYPOINT_HEAD.NUM_KEYPOINTS.", "\n", "_C", ".", "TEST", ".", "KEYPOINT_OKS_SIGMAS", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_argument_parser": [[49, 103], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "hash", "os.getuid"], "function", ["None"], ["# Size of the smallest side of the image during training", "\n", "_C", ".", "INPUT", ".", "MIN_SIZE_TRAIN", "=", "(", "800", ",", ")", "\n", "# Sample size of smallest side by choice or random selection from range give by", "\n", "# INPUT.MIN_SIZE_TRAIN", "\n", "_C", ".", "INPUT", ".", "MIN_SIZE_TRAIN_SAMPLING", "=", "\"choice\"", "\n", "# Maximum size of the side of the image during training", "\n", "_C", ".", "INPUT", ".", "MAX_SIZE_TRAIN", "=", "1333", "\n", "# Size of the smallest side of the image during testing. Set to zero to disable resize in testing.", "\n", "_C", ".", "INPUT", ".", "MIN_SIZE_TEST", "=", "800", "\n", "# Maximum size of the side of the image during testing", "\n", "_C", ".", "INPUT", ".", "MAX_SIZE_TEST", "=", "1333", "\n", "# Mode for flipping images used in data augmentation during training", "\n", "# choose one of [\"horizontal, \"vertical\", \"none\"]", "\n", "_C", ".", "INPUT", ".", "RANDOM_FLIP", "=", "\"horizontal\"", "\n", "\n", "# `True` if cropping is used for data augmentation during training", "\n", "_C", ".", "INPUT", ".", "CROP", "=", "CN", "(", "{", "\"ENABLED\"", ":", "False", "}", ")", "\n", "# Cropping type:", "\n", "# - \"relative\" crop (H * CROP.SIZE[0], W * CROP.SIZE[1]) part of an input of size (H, W)", "\n", "# - \"relative_range\" uniformly sample relative crop size from between [CROP.SIZE[0], [CROP.SIZE[1]].", "\n", "#   and  [1, 1] and use it as in \"relative\" scenario.", "\n", "# - \"absolute\" crop part of an input with absolute size: (CROP.SIZE[0], CROP.SIZE[1]).", "\n", "# - \"absolute_range\", for an input of size (H, W), uniformly sample H_crop in", "\n", "#   [CROP.SIZE[0], min(H, CROP.SIZE[1])] and W_crop in [CROP.SIZE[0], min(W, CROP.SIZE[1])]", "\n", "_C", ".", "INPUT", ".", "CROP", ".", "TYPE", "=", "\"relative_range\"", "\n", "# Size of crop in range (0, 1] if CROP.TYPE is \"relative\" or \"relative_range\" and in number of", "\n", "# pixels if CROP.TYPE is \"absolute\"", "\n", "_C", ".", "INPUT", ".", "CROP", ".", "SIZE", "=", "[", "0.9", ",", "0.9", "]", "\n", "\n", "\n", "# Whether the model needs RGB, YUV, HSV etc.", "\n", "# Should be one of the modes defined here, as we use PIL to read the image:", "\n", "# https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes", "\n", "# with BGR being the one exception. One can set image format to BGR, we will", "\n", "# internally use RGB for conversion and flip the channels over", "\n", "_C", ".", "INPUT", ".", "FORMAT", "=", "\"BGR\"", "\n", "# The ground truth mask format that the model will use.", "\n", "# Mask R-CNN supports either \"polygon\" or \"bitmask\" as ground truth.", "\n", "_C", ".", "INPUT", ".", "MASK_FORMAT", "=", "\"polygon\"", "# alternative: \"bitmask\"", "\n", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# Dataset", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "DATASETS", "=", "CN", "(", ")", "\n", "# List of the dataset names for training. Must be registered in DatasetCatalog", "\n", "_C", ".", "DATASETS", ".", "TRAIN", "=", "(", ")", "\n", "# List of the pre-computed proposal files for training, which must be consistent", "\n", "# with datasets listed in DATASETS.TRAIN.", "\n", "_C", ".", "DATASETS", ".", "PROPOSAL_FILES_TRAIN", "=", "(", ")", "\n", "# Number of top scoring precomputed proposals to keep for training", "\n", "_C", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TRAIN", "=", "2000", "\n", "# List of the dataset names for testing. Must be registered in DatasetCatalog", "\n", "_C", ".", "DATASETS", ".", "TEST", "=", "(", ")", "\n", "# List of the pre-computed proposal files for test, which must be consistent", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup": [[105, 158], ["detectron2.utils.comm.get_rank", "detectron2.utils.logger.setup_logger", "detectron2.utils.logger.setup_logger", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.env.seed_all_rng", "detectron2.utils.comm.is_main_process", "fvcore.common.file_io.PathManager.mkdirs", "hasattr", "detectron2.utils.logger.setup_logger.info", "detectron2.utils.comm.is_main_process", "os.path.join", "detectron2.utils.logger.setup_logger.info", "fvcore.common.file_io.PathManager.mkdirs", "fvcore.common.file_io.PathManager.mkdirs", "detectron2.utils.comm.get_world_size", "detectron2.utils.collect_env.collect_env_info", "str", "fvcore.common.file_io.PathManager.open", "f.write", "hasattr", "os.path.join", "os.path.join", "fvcore.common.file_io.PathManager.open().read", "cfg.dump", "fvcore.common.file_io.PathManager.open"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env.seed_all_rng", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.collect_env_info", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump"], ["_C", ".", "DATASETS", ".", "PROPOSAL_FILES_TEST", "=", "(", ")", "\n", "# Number of top scoring precomputed proposals to keep for test", "\n", "_C", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TEST", "=", "1000", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "# DataLoader", "\n", "# -----------------------------------------------------------------------------", "\n", "_C", ".", "DATALOADER", "=", "CN", "(", ")", "\n", "# Number of data loading threads", "\n", "_C", ".", "DATALOADER", ".", "NUM_WORKERS", "=", "4", "\n", "# If True, each batch should contain only images for which the aspect ratio", "\n", "# is compatible. This groups portrait images together, and landscape images", "\n", "# are not batched with portrait images.", "\n", "_C", ".", "DATALOADER", ".", "ASPECT_RATIO_GROUPING", "=", "True", "\n", "# Options: TrainingSampler, RepeatFactorTrainingSampler", "\n", "_C", ".", "DATALOADER", ".", "SAMPLER_TRAIN", "=", "\"TrainingSampler\"", "\n", "# Repeat threshold for RepeatFactorTrainingSampler", "\n", "_C", ".", "DATALOADER", ".", "REPEAT_THRESHOLD", "=", "0.0", "\n", "# Tf True, when working on datasets that have instance annotations, the", "\n", "# training dataloader will filter out images without associated annotations", "\n", "_C", ".", "DATALOADER", ".", "FILTER_EMPTY_ANNOTATIONS", "=", "True", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Backbone options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "BACKBONE", "=", "CN", "(", ")", "\n", "\n", "_C", ".", "MODEL", ".", "BACKBONE", ".", "NAME", "=", "\"build_resnet_backbone\"", "\n", "# Freeze the first several stages so they are not trained.", "\n", "# There are 5 stages in ResNet. The first is a convolution, and the following", "\n", "# stages are each group of residual blocks.", "\n", "_C", ".", "MODEL", ".", "BACKBONE", ".", "FREEZE_AT", "=", "2", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# FPN options", "\n", "# ---------------------------------------------------------------------------- #", "\n", "_C", ".", "MODEL", ".", "FPN", "=", "CN", "(", ")", "\n", "# Names of the input feature maps to be used by FPN", "\n", "# They must have contiguous power of 2 strides", "\n", "# e.g., [\"res2\", \"res3\", \"res4\", \"res5\"]", "\n", "_C", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "=", "[", "]", "\n", "_C", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "=", "256", "\n", "\n", "# Options: \"\" (no norm), \"GN\"", "\n", "_C", ".", "MODEL", ".", "FPN", ".", "NORM", "=", "\"\"", "\n", "\n", "# Types for fusing the FPN top-down and lateral features. Can be either \"sum\" or \"avg\"", "\n", "_C", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", "=", "\"sum\"", "\n", "\n", "\n", "# ---------------------------------------------------------------------------- #", "\n", "# Proposal generator options", "\n", "# ---------------------------------------------------------------------------- #", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.launch._find_free_port": [[12, 22], ["socket.socket", "socket.socket.bind", "socket.socket.close", "socket.socket.getsockname"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close"], ["def", "_find_free_port", "(", ")", ":", "\n", "    ", "import", "socket", "\n", "\n", "sock", "=", "socket", ".", "socket", "(", "socket", ".", "AF_INET", ",", "socket", ".", "SOCK_STREAM", ")", "\n", "# Binding to port 0 will cause the OS to find an available port for us", "\n", "sock", ".", "bind", "(", "(", "\"\"", ",", "0", ")", ")", "\n", "port", "=", "sock", ".", "getsockname", "(", ")", "[", "1", "]", "\n", "sock", ".", "close", "(", ")", "\n", "# NOTE: there is still a chance the port could be taken by other processes.", "\n", "return", "port", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.launch.launch": [[24, 63], ["torch.spawn", "main_func", "launch._find_free_port", "dist_url.startswith", "logging.getLogger", "logging.getLogger.warning"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.launch._find_free_port"], ["", "def", "launch", "(", "main_func", ",", "num_gpus_per_machine", ",", "num_machines", "=", "1", ",", "machine_rank", "=", "0", ",", "dist_url", "=", "None", ",", "args", "=", "(", ")", ")", ":", "\n", "    ", "\"\"\"\n    Launch multi-gpu or distributed training.\n    This function must be called on all machines involved in the training.\n    It will spawn child processes (defined by ``num_gpus_per_machine``) on each machine.\n\n    Args:\n        main_func: a function that will be called by `main_func(*args)`\n        num_gpus_per_machine (int): number of GPUs per machine\n        num_machines (int): the total number of machines\n        machine_rank (int): the rank of this machine\n        dist_url (str): url to connect to for distributed jobs, including protocol\n                       e.g. \"tcp://127.0.0.1:8686\".\n                       Can be set to \"auto\" to automatically select a free port on localhost\n        args (tuple): arguments passed to main_func\n    \"\"\"", "\n", "world_size", "=", "num_machines", "*", "num_gpus_per_machine", "\n", "if", "world_size", ">", "1", ":", "\n", "# https://github.com/pytorch/pytorch/pull/14391", "\n", "# TODO prctl in spawned processes", "\n", "\n", "        ", "if", "dist_url", "==", "\"auto\"", ":", "\n", "            ", "assert", "num_machines", "==", "1", ",", "\"dist_url=auto not supported in multi-machine jobs.\"", "\n", "port", "=", "_find_free_port", "(", ")", "\n", "dist_url", "=", "f\"tcp://127.0.0.1:{port}\"", "\n", "", "if", "num_machines", ">", "1", "and", "dist_url", ".", "startswith", "(", "\"file://\"", ")", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"file:// is not a reliable init_method in multi-machine jobs. Prefer tcp://\"", "\n", ")", "\n", "\n", "", "mp", ".", "spawn", "(", "\n", "_distributed_worker", ",", "\n", "nprocs", "=", "num_gpus_per_machine", ",", "\n", "args", "=", "(", "main_func", ",", "world_size", ",", "num_gpus_per_machine", ",", "machine_rank", ",", "dist_url", ",", "args", ")", ",", "\n", "daemon", "=", "False", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "main_func", "(", "*", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.launch._distributed_worker": [[65, 95], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "detectron2.utils.comm.synchronize", "torch.cuda.set_device", "torch.cuda.set_device", "torch.cuda.set_device", "range", "main_func", "torch.init_process_group", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "list", "torch.new_group", "logging.getLogger", "logging.getLogger.error", "range"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "", "def", "_distributed_worker", "(", "\n", "local_rank", ",", "main_func", ",", "world_size", ",", "num_gpus_per_machine", ",", "machine_rank", ",", "dist_url", ",", "args", "\n", ")", ":", "\n", "    ", "assert", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"cuda is not available. Please check your installation.\"", "\n", "global_rank", "=", "machine_rank", "*", "num_gpus_per_machine", "+", "local_rank", "\n", "try", ":", "\n", "        ", "dist", ".", "init_process_group", "(", "\n", "backend", "=", "\"NCCL\"", ",", "init_method", "=", "dist_url", ",", "world_size", "=", "world_size", ",", "rank", "=", "global_rank", "\n", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "error", "(", "\"Process group URL: {}\"", ".", "format", "(", "dist_url", ")", ")", "\n", "raise", "e", "\n", "# synchronize is needed here to prevent a possible timeout after calling init_process_group", "\n", "# See: https://github.com/facebookresearch/maskrcnn-benchmark/issues/172", "\n", "", "comm", ".", "synchronize", "(", ")", "\n", "\n", "assert", "num_gpus_per_machine", "<=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "local_rank", ")", "\n", "\n", "# Setup the local process group (which contains ranks within the same machine)", "\n", "assert", "comm", ".", "_LOCAL_PROCESS_GROUP", "is", "None", "\n", "num_machines", "=", "world_size", "//", "num_gpus_per_machine", "\n", "for", "i", "in", "range", "(", "num_machines", ")", ":", "\n", "        ", "ranks_on_i", "=", "list", "(", "range", "(", "i", "*", "num_gpus_per_machine", ",", "(", "i", "+", "1", ")", "*", "num_gpus_per_machine", ")", ")", "\n", "pg", "=", "dist", ".", "new_group", "(", "ranks_on_i", ")", "\n", "if", "i", "==", "machine_rank", ":", "\n", "            ", "comm", ".", "_LOCAL_PROCESS_GROUP", "=", "pg", "\n", "\n", "", "", "main_func", "(", "*", "args", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.CallbackHook.__init__": [[45, 53], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "*", ",", "before_train", "=", "None", ",", "after_train", "=", "None", ",", "before_step", "=", "None", ",", "after_step", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Each argument is a function that takes one argument: the trainer.\n        \"\"\"", "\n", "self", ".", "_before_train", "=", "before_train", "\n", "self", ".", "_before_step", "=", "before_step", "\n", "self", ".", "_after_step", "=", "after_step", "\n", "self", ".", "_after_train", "=", "after_train", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.CallbackHook.before_train": [[54, 57], ["hooks.CallbackHook._before_train"], "methods", ["None"], ["", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_before_train", ":", "\n", "            ", "self", ".", "_before_train", "(", "self", ".", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.CallbackHook.after_train": [[58, 65], ["hooks.CallbackHook._after_train"], "methods", ["None"], ["", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_after_train", ":", "\n", "            ", "self", ".", "_after_train", "(", "self", ".", "trainer", ")", "\n", "# The functions may be closures that hold reference to the trainer", "\n", "# Therefore, delete them to avoid circular reference.", "\n", "", "del", "self", ".", "_before_train", ",", "self", ".", "_after_train", "\n", "del", "self", ".", "_before_step", ",", "self", ".", "_after_step", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.CallbackHook.before_step": [[66, 69], ["hooks.CallbackHook._before_step"], "methods", ["None"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_before_step", ":", "\n", "            ", "self", ".", "_before_step", "(", "self", ".", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.CallbackHook.after_step": [[70, 73], ["hooks.CallbackHook._after_step"], "methods", ["None"], ["", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_after_step", ":", "\n", "            ", "self", ".", "_after_step", "(", "self", ".", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.IterationTimer.__init__": [[87, 97], ["fvcore.common.timer.Timer", "time.perf_counter", "fvcore.common.timer.Timer"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "warmup_iter", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            warmup_iter (int): the number of iterations at the beginning to exclude\n                from timing.\n        \"\"\"", "\n", "self", ".", "_warmup_iter", "=", "warmup_iter", "\n", "self", ".", "_step_timer", "=", "Timer", "(", ")", "\n", "self", ".", "_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "self", ".", "_total_timer", "=", "Timer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.IterationTimer.before_train": [[98, 102], ["time.perf_counter", "hooks.IterationTimer._total_timer.reset", "hooks.IterationTimer._total_timer.pause"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.reset"], ["", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "self", ".", "_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "self", ".", "_total_timer", ".", "reset", "(", ")", "\n", "self", ".", "_total_timer", ".", "pause", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.IterationTimer.after_train": [[103, 126], ["logging.getLogger", "hooks.IterationTimer._total_timer.seconds", "logging.getLogger.info", "time.perf_counter", "logging.getLogger.info", "str", "str", "str", "datetime.timedelta", "datetime.timedelta", "datetime.timedelta", "int", "int", "int"], "methods", ["None"], ["", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "total_time", "=", "time", ".", "perf_counter", "(", ")", "-", "self", ".", "_start_time", "\n", "total_time_minus_hooks", "=", "self", ".", "_total_timer", ".", "seconds", "(", ")", "\n", "hook_time", "=", "total_time", "-", "total_time_minus_hooks", "\n", "\n", "num_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "-", "self", ".", "trainer", ".", "start_iter", "-", "self", ".", "_warmup_iter", "\n", "\n", "if", "num_iter", ">", "0", "and", "total_time_minus_hooks", ">", "0", ":", "\n", "# Speed is meaningful only after warmup", "\n", "# NOTE this format is parsed by grep in some scripts", "\n", "            ", "logger", ".", "info", "(", "\n", "\"Overall training speed: {} iterations in {} ({:.4f} s / it)\"", ".", "format", "(", "\n", "num_iter", ",", "\n", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_time_minus_hooks", ")", ")", ")", ",", "\n", "total_time_minus_hooks", "/", "num_iter", ",", "\n", ")", "\n", ")", "\n", "\n", "", "logger", ".", "info", "(", "\n", "\"Total training time: {} ({} on hooks)\"", ".", "format", "(", "\n", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_time", ")", ")", ")", ",", "\n", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "hook_time", ")", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.IterationTimer.before_step": [[129, 132], ["hooks.IterationTimer._step_timer.reset", "hooks.IterationTimer._total_timer.resume"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.reset"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "self", ".", "_step_timer", ".", "reset", "(", ")", "\n", "self", ".", "_total_timer", ".", "resume", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.IterationTimer.after_step": [[133, 145], ["hooks.IterationTimer._total_timer.pause", "hooks.IterationTimer._step_timer.seconds", "hooks.IterationTimer.trainer.storage.put_scalars", "time.perf_counter", "hooks.IterationTimer._total_timer.reset"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalars", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.reset"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "# +1 because we're in after_step, the current step is done", "\n", "# but not yet counted", "\n", "        ", "iter_done", "=", "self", ".", "trainer", ".", "iter", "-", "self", ".", "trainer", ".", "start_iter", "+", "1", "\n", "if", "iter_done", ">=", "self", ".", "_warmup_iter", ":", "\n", "            ", "sec", "=", "self", ".", "_step_timer", ".", "seconds", "(", ")", "\n", "self", ".", "trainer", ".", "storage", ".", "put_scalars", "(", "time", "=", "sec", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "self", ".", "_total_timer", ".", "reset", "(", ")", "\n", "\n", "", "self", ".", "_total_timer", ".", "pause", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.PeriodicWriter.__init__": [[155, 165], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "writers", ",", "period", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            writers (list[EventWriter]): a list of EventWriter objects\n            period (int):\n        \"\"\"", "\n", "self", ".", "_writers", "=", "writers", "\n", "for", "w", "in", "writers", ":", "\n", "            ", "assert", "isinstance", "(", "w", ",", "EventWriter", ")", ",", "w", "\n", "", "self", ".", "_period", "=", "period", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.PeriodicWriter.after_step": [[166, 172], ["writer.write"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "if", "(", "self", ".", "trainer", ".", "iter", "+", "1", ")", "%", "self", ".", "_period", "==", "0", "or", "(", "\n", "self", ".", "trainer", ".", "iter", "==", "self", ".", "trainer", ".", "max_iter", "-", "1", "\n", ")", ":", "\n", "            ", "for", "writer", "in", "self", ".", "_writers", ":", "\n", "                ", "writer", ".", "write", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.PeriodicWriter.after_train": [[173, 179], ["writer.write", "writer.close"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close"], ["", "", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "for", "writer", "in", "self", ".", "_writers", ":", "\n", "# If any new data is found (e.g. produced by other after_train),", "\n", "# write them before closing", "\n", "            ", "writer", ".", "write", "(", ")", "\n", "writer", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.PeriodicCheckpointer.before_train": [[192, 194], ["None"], "methods", ["None"], ["def", "before_train", "(", "self", ")", ":", "\n", "        ", "self", ".", "max_iter", "=", "self", ".", "trainer", ".", "max_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.PeriodicCheckpointer.after_step": [[195, 198], ["hooks.PeriodicCheckpointer.step"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "# No way to use **kwargs", "\n", "        ", "self", ".", "step", "(", "self", ".", "trainer", ".", "iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.LRScheduler.__init__": [[206, 233], ["max", "collections.Counter", "enumerate", "enumerate", "len", "collections.Counter.most_common", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "optimizer", ",", "scheduler", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            optimizer (torch.optim.Optimizer):\n            scheduler (torch.optim._LRScheduler)\n        \"\"\"", "\n", "self", ".", "_optimizer", "=", "optimizer", "\n", "self", ".", "_scheduler", "=", "scheduler", "\n", "\n", "# NOTE: some heuristics on what LR to summarize", "\n", "# summarize the param group with most parameters", "\n", "largest_group", "=", "max", "(", "len", "(", "g", "[", "\"params\"", "]", ")", "for", "g", "in", "optimizer", ".", "param_groups", ")", "\n", "\n", "if", "largest_group", "==", "1", ":", "\n", "# If all groups have one parameter,", "\n", "# then find the most common initial LR, and use it for summary", "\n", "            ", "lr_count", "=", "Counter", "(", "[", "g", "[", "\"lr\"", "]", "for", "g", "in", "optimizer", ".", "param_groups", "]", ")", "\n", "lr", "=", "lr_count", ".", "most_common", "(", ")", "[", "0", "]", "[", "0", "]", "\n", "for", "i", ",", "g", "in", "enumerate", "(", "optimizer", ".", "param_groups", ")", ":", "\n", "                ", "if", "g", "[", "\"lr\"", "]", "==", "lr", ":", "\n", "                    ", "self", ".", "_best_param_group_id", "=", "i", "\n", "break", "\n", "", "", "", "else", ":", "\n", "            ", "for", "i", ",", "g", "in", "enumerate", "(", "optimizer", ".", "param_groups", ")", ":", "\n", "                ", "if", "len", "(", "g", "[", "\"params\"", "]", ")", "==", "largest_group", ":", "\n", "                    ", "self", ".", "_best_param_group_id", "=", "i", "\n", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.LRScheduler.after_step": [[234, 238], ["hooks.LRScheduler.trainer.storage.put_scalar", "hooks.LRScheduler._scheduler.step"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step"], ["", "", "", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "lr", "=", "self", ".", "_optimizer", ".", "param_groups", "[", "self", ".", "_best_param_group_id", "]", "[", "\"lr\"", "]", "\n", "self", ".", "trainer", ".", "storage", ".", "put_scalar", "(", "\"lr\"", ",", "lr", ",", "smoothing_hint", "=", "False", ")", "\n", "self", ".", "_scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.AutogradProfiler.__init__": [[263, 275], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "enable_predicate", ",", "output_dir", ",", "*", ",", "use_cuda", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            enable_predicate (callable[trainer -> bool]): a function which takes a trainer,\n                and returns whether to enable the profiler.\n                It will be called once every step, and can be used to select which steps to profile.\n            output_dir (str): the output directory to dump tracing files.\n            use_cuda (bool): same as in `torch.autograd.profiler.profile`.\n        \"\"\"", "\n", "self", ".", "_enable_predicate", "=", "enable_predicate", "\n", "self", ".", "_use_cuda", "=", "use_cuda", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.AutogradProfiler.before_step": [[276, 282], ["hooks.AutogradProfiler._enable_predicate", "torch.autograd.profiler.profile", "hooks.AutogradProfiler._profiler.__enter__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.ScopedWS.__enter__"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_enable_predicate", "(", "self", ".", "trainer", ")", ":", "\n", "            ", "self", ".", "_profiler", "=", "torch", ".", "autograd", ".", "profiler", ".", "profile", "(", "use_cuda", "=", "self", ".", "_use_cuda", ")", "\n", "self", ".", "_profiler", ".", "__enter__", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_profiler", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.AutogradProfiler.after_step": [[283, 302], ["hooks.AutogradProfiler._profiler.__exit__", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "hooks.AutogradProfiler._profiler.export_chrome_trace", "tempfile.TemporaryDirectory", "os.path.join", "hooks.AutogradProfiler._profiler.export_chrome_trace", "fvcore.common.file_io.PathManager.open", "f.write", "open", "f.read"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.shared.ScopedWS.__exit__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write"], ["", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_profiler", "is", "None", ":", "\n", "            ", "return", "\n", "", "self", ".", "_profiler", ".", "__exit__", "(", "None", ",", "None", ",", "None", ")", "\n", "PathManager", ".", "mkdirs", "(", "self", ".", "_output_dir", ")", "\n", "out_file", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "_output_dir", ",", "\"profiler-trace-iter{}.json\"", ".", "format", "(", "self", ".", "trainer", ".", "iter", ")", "\n", ")", "\n", "if", "\"://\"", "not", "in", "out_file", ":", "\n", "            ", "self", ".", "_profiler", ".", "export_chrome_trace", "(", "out_file", ")", "\n", "", "else", ":", "\n", "# Support non-posix filesystems", "\n", "            ", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_profiler\"", ")", "as", "d", ":", "\n", "                ", "tmp_file", "=", "os", ".", "path", ".", "join", "(", "d", ",", "\"tmp.json\"", ")", "\n", "self", ".", "_profiler", ".", "export_chrome_trace", "(", "tmp_file", ")", "\n", "with", "open", "(", "tmp_file", ")", "as", "f", ":", "\n", "                    ", "content", "=", "f", ".", "read", "(", ")", "\n", "", "", "with", "PathManager", ".", "open", "(", "out_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "content", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.EvalHook.__init__": [[311, 326], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "eval_period", ",", "eval_function", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            eval_period (int): the period to run `eval_function`. Set to 0 to\n                not evaluate periodically (but still after the last iteration).\n            eval_function (callable): a function which takes no arguments, and\n                returns a nested dict of evaluation metrics.\n\n        Note:\n            This hook must be enabled in all or none workers.\n            If you would like only certain workers to perform evaluation,\n            give other workers a no-op function (`eval_function=lambda: None`).\n        \"\"\"", "\n", "self", ".", "_period", "=", "eval_period", "\n", "self", ".", "_func", "=", "eval_function", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.EvalHook._do_eval": [[327, 349], ["hooks.EvalHook._func", "detectron2.synchronize", "isinstance", "detectron2.evaluation.testing.flatten_results_dict", "detectron2.evaluation.testing.flatten_results_dict.items", "hooks.EvalHook.trainer.storage.put_scalars", "float", "ValueError"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.flatten_results_dict", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalars"], ["", "def", "_do_eval", "(", "self", ")", ":", "\n", "        ", "results", "=", "self", ".", "_func", "(", ")", "\n", "\n", "if", "results", ":", "\n", "            ", "assert", "isinstance", "(", "\n", "results", ",", "dict", "\n", ")", ",", "\"Eval function must return a dict. Got {} instead.\"", ".", "format", "(", "results", ")", "\n", "\n", "flattened_results", "=", "flatten_results_dict", "(", "results", ")", "\n", "for", "k", ",", "v", "in", "flattened_results", ".", "items", "(", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "v", "=", "float", "(", "v", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"[EvalHook] eval_function should return a nested dict of float. \"", "\n", "\"Got '{}: {}' instead.\"", ".", "format", "(", "k", ",", "v", ")", "\n", ")", "from", "e", "\n", "", "", "self", ".", "trainer", ".", "storage", ".", "put_scalars", "(", "**", "flattened_results", ",", "smoothing_hint", "=", "False", ")", "\n", "\n", "# Evaluation may take different time among workers.", "\n", "# A barrier make them start the next iteration together.", "\n", "", "comm", ".", "synchronize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.EvalHook.after_step": [[350, 354], ["hooks.EvalHook._do_eval"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.EvalHook._do_eval"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "next_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "\n", "if", "self", ".", "_period", ">", "0", "and", "next_iter", "%", "self", ".", "_period", "==", "0", ":", "\n", "            ", "self", ".", "_do_eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.EvalHook.after_train": [[355, 362], ["hooks.EvalHook._do_eval"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.EvalHook._do_eval"], ["", "", "def", "after_train", "(", "self", ")", ":", "\n", "# This condition is to prevent the eval from running after a failed training", "\n", "        ", "if", "self", ".", "trainer", ".", "iter", "+", "1", ">=", "self", ".", "trainer", ".", "max_iter", ":", "\n", "            ", "self", ".", "_do_eval", "(", ")", "\n", "# func is likely a closure that holds reference to the trainer", "\n", "# therefore we clean it to avoid circular reference in the end", "\n", "", "del", "self", ".", "_func", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.PreciseBN.__init__": [[374, 402], ["logging.getLogger", "len", "hooks.PreciseBN._logger.info", "fvcore.nn.precise_bn.get_bn_modules"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "period", ",", "model", ",", "data_loader", ",", "num_iter", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            period (int): the period this hook is run, or 0 to not run during training.\n                The hook will always run in the end of training.\n            model (nn.Module): a module whose all BN layers in training mode will be\n                updated by precise BN.\n                Note that user is responsible for ensuring the BN layers to be\n                updated are in training mode when this hook is triggered.\n            data_loader (iterable): it will produce data to be run by `model(data)`.\n            num_iter (int): number of iterations used to compute the precise\n                statistics.\n        \"\"\"", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "if", "len", "(", "get_bn_modules", "(", "model", ")", ")", "==", "0", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\n", "\"PreciseBN is disabled because model does not contain BN layers in training mode.\"", "\n", ")", "\n", "self", ".", "_disabled", "=", "True", "\n", "return", "\n", "\n", "", "self", ".", "_model", "=", "model", "\n", "self", ".", "_data_loader", "=", "data_loader", "\n", "self", ".", "_num_iter", "=", "num_iter", "\n", "self", ".", "_period", "=", "period", "\n", "self", ".", "_disabled", "=", "False", "\n", "\n", "self", ".", "_data_iter", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.PreciseBN.after_step": [[403, 408], ["hooks.PreciseBN.update_stats"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.PreciseBN.update_stats"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "next_iter", "=", "self", ".", "trainer", ".", "iter", "+", "1", "\n", "is_final", "=", "next_iter", "==", "self", ".", "trainer", ".", "max_iter", "\n", "if", "is_final", "or", "(", "self", ".", "_period", ">", "0", "and", "next_iter", "%", "self", ".", "_period", "==", "0", ")", ":", "\n", "            ", "self", ".", "update_stats", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.hooks.PreciseBN.update_stats": [[409, 434], ["iter", "itertools.count", "detectron2.utils.events.EventStorage", "hooks.PreciseBN._logger.info", "fvcore.nn.precise_bn.update_bn_stats", "hooks.PreciseBN.update_stats.data_loader"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter"], ["", "", "def", "update_stats", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Update the model with precise statistics. Users can manually call this method.\n        \"\"\"", "\n", "if", "self", ".", "_disabled", ":", "\n", "            ", "return", "\n", "\n", "", "if", "self", ".", "_data_iter", "is", "None", ":", "\n", "            ", "self", ".", "_data_iter", "=", "iter", "(", "self", ".", "_data_loader", ")", "\n", "\n", "", "def", "data_loader", "(", ")", ":", "\n", "            ", "for", "num_iter", "in", "itertools", ".", "count", "(", "1", ")", ":", "\n", "                ", "if", "num_iter", "%", "100", "==", "0", ":", "\n", "                    ", "self", ".", "_logger", ".", "info", "(", "\n", "\"Running precise-BN ... {}/{} iterations.\"", ".", "format", "(", "num_iter", ",", "self", ".", "_num_iter", ")", "\n", ")", "\n", "# This way we can reuse the same iterator", "\n", "", "yield", "next", "(", "self", ".", "_data_iter", ")", "\n", "\n", "", "", "with", "EventStorage", "(", ")", ":", "# capture events in a new storage to discard them", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\n", "\"Running precise-BN for {} iterations...  \"", ".", "format", "(", "self", ".", "_num_iter", ")", "\n", "+", "\"Note that this could produce different statistics every time.\"", "\n", ")", "\n", "update_bn_stats", "(", "self", ".", "_model", ",", "data_loader", "(", ")", ",", "self", ".", "_num_iter", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.HookBase.before_train": [[64, 69], ["None"], "methods", ["None"], ["def", "before_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called before the first iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.HookBase.after_train": [[70, 75], ["None"], "methods", ["None"], ["", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called after the last iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.HookBase.before_step": [[76, 81], ["None"], "methods", ["None"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called before each iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.HookBase.after_step": [[82, 87], ["None"], "methods", ["None"], ["", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Called after each iteration.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.__init__": [[108, 110], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_hooks", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.register_hooks": [[111, 128], ["train_loop.TrainerBase._hooks.extend", "isinstance", "weakref.proxy"], "methods", ["None"], ["", "def", "register_hooks", "(", "self", ",", "hooks", ")", ":", "\n", "        ", "\"\"\"\n        Register hooks to the trainer. The hooks are executed in the order\n        they are registered.\n\n        Args:\n            hooks (list[Optional[HookBase]]): list of hooks\n        \"\"\"", "\n", "hooks", "=", "[", "h", "for", "h", "in", "hooks", "if", "h", "is", "not", "None", "]", "\n", "for", "h", "in", "hooks", ":", "\n", "            ", "assert", "isinstance", "(", "h", ",", "HookBase", ")", "\n", "# To avoid circular reference, hooks and trainer cannot own each other.", "\n", "# This normally does not matter, but will cause memory leak if the", "\n", "# involved objects contain __del__:", "\n", "# See http://engineering.hearsaysocial.com/2013/06/16/circular-references-in-python/", "\n", "h", ".", "trainer", "=", "weakref", ".", "proxy", "(", "self", ")", "\n", "", "self", ".", "_hooks", ".", "extend", "(", "hooks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train": [[129, 158], ["logging.getLogger", "logging.getLogger.info", "detectron2.utils.events.EventStorage", "train_loop.TrainerBase.before_train", "range", "train_loop.TrainerBase.after_train", "train_loop.TrainerBase.before_step", "train_loop.TrainerBase.run_step", "train_loop.TrainerBase.after_step", "logging.getLogger.exception"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.before_train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.after_train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.before_step", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.SimpleTrainer.run_step", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.after_step"], ["", "def", "train", "(", "self", ",", "start_iter", ":", "int", ",", "max_iter", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            start_iter, max_iter (int): See docs above\n        \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Starting training from iteration {}\"", ".", "format", "(", "start_iter", ")", ")", "\n", "\n", "self", ".", "iter", "=", "self", ".", "start_iter", "=", "start_iter", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "\n", "with", "EventStorage", "(", "start_iter", ")", "as", "self", ".", "storage", ":", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "before_train", "(", ")", "\n", "for", "self", ".", "iter", "in", "range", "(", "start_iter", ",", "max_iter", ")", ":", "\n", "                    ", "if", "self", ".", "cfg", ".", "OWOD", ".", "SKIP_TRAINING_WHILE_EVAL", ":", "\n", "                        ", "continue", "\n", "", "self", ".", "before_step", "(", ")", "\n", "self", ".", "run_step", "(", ")", "\n", "self", ".", "after_step", "(", ")", "\n", "# self.iter == max_iter can be used by `after_train` to", "\n", "# tell whether the training successfully finished or failed", "\n", "# due to exceptions.", "\n", "", "self", ".", "iter", "+=", "1", "\n", "", "except", "Exception", ":", "\n", "                ", "logger", ".", "exception", "(", "\"Exception during training:\"", ")", "\n", "raise", "\n", "", "finally", ":", "\n", "                ", "self", ".", "after_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.before_train": [[159, 165], ["logging.getLogger", "logging.getLogger.info", "h.before_train"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.before_train"], ["", "", "", "def", "before_train", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "cfg", ".", "OWOD", ".", "SKIP_TRAINING_WHILE_EVAL", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "'Skipping training as cfg.OWOD.SKIP_TRAINING_WHILE_EVAL flag is set.'", ")", "\n", "", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "before_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.after_train": [[166, 180], ["logging.getLogger", "logging.getLogger.info", "train_loop.TrainerBase.analyse_energy", "h.after_train", "str", "h.after_train", "type"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.analyse_energy", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.after_train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.after_train"], ["", "", "def", "after_train", "(", "self", ")", ":", "\n", "        ", "self", ".", "storage", ".", "iter", "=", "self", ".", "iter", "\n", "if", "self", ".", "cfg", ".", "OWOD", ".", "COMPUTE_ENERGY", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Going to analyse the energy files...\"", ")", "\n", "\n", "self", ".", "analyse_energy", "(", ")", "\n", "\n", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "                ", "if", "'EvalHook'", "not", "in", "str", "(", "type", "(", "h", ")", ")", ":", "\n", "                    ", "h", ".", "after_train", "(", ")", "\n", "", "", "", "else", ":", "\n", "            ", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "                ", "h", ".", "after_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.analyse_energy": [[181, 244], ["os.listdir", "logging.getLogger", "logging.getLogger.info", "enumerate", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "time.time", "reliability.Fitters.Fit_Weibull_3P", "logging.getLogger.info", "wb_dist_param.append", "time.time", "reliability.Fitters.Fit_Weibull_3P", "logging.getLogger.info", "wb_dist_param.append", "os.path.join", "logging.getLogger.info", "torch.save", "logging.getLogger.info", "numpy.linspace", "matplotlib.pyplot.hist", "matplotlib.pyplot.hist", "matplotlib.pyplot.legend", "matplotlib.pyplot.savefig", "os.path.join", "os.path.join", "enumerate", "os.path.join", "str", "torch.load", "torch.logsumexp", "logging.getLogger.info", "str", "str", "logging.getLogger.info", "unk.append", "known.append", "len", "len", "time.time", "time.time", "str", "lse[].detach().cpu().tolist", "lse[].detach().cpu().tolist", "str", "len", "lse[].detach().cpu", "lse[].detach().cpu", "str", "lse[].detach", "lse[].detach"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load"], ["", "", "", "def", "analyse_energy", "(", "self", ",", "temp", "=", "1.5", ")", ":", "\n", "        ", "files", "=", "os", ".", "listdir", "(", "os", ".", "path", ".", "join", "(", "self", ".", "cfg", ".", "OUTPUT_DIR", ",", "self", ".", "cfg", ".", "OWOD", ".", "ENERGY_SAVE_PATH", ")", ")", "\n", "temp", "=", "self", ".", "cfg", ".", "OWOD", ".", "TEMPERATURE", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "'Temperature value: '", "+", "str", "(", "temp", ")", ")", "\n", "unk", "=", "[", "]", "\n", "known", "=", "[", "]", "\n", "\n", "for", "id", ",", "file", "in", "enumerate", "(", "files", ")", ":", "\n", "            ", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "cfg", ".", "OUTPUT_DIR", ",", "self", ".", "cfg", ".", "OWOD", ".", "ENERGY_SAVE_PATH", ",", "file", ")", "\n", "try", ":", "\n", "                ", "logits", ",", "classes", "=", "torch", ".", "load", "(", "path", ")", "\n", "", "except", ":", "\n", "                ", "logger", ".", "info", "(", "'Not able to load '", "+", "path", "+", "\". Continuing...\"", ")", "\n", "continue", "\n", "", "num_seen_classes", "=", "self", ".", "cfg", ".", "OWOD", ".", "PREV_INTRODUCED_CLS", "+", "self", ".", "cfg", ".", "OWOD", ".", "CUR_INTRODUCED_CLS", "\n", "lse", "=", "temp", "*", "torch", ".", "logsumexp", "(", "logits", "[", ":", ",", ":", "num_seen_classes", "]", "/", "temp", ",", "dim", "=", "1", ")", "\n", "# lse = torch.logsumexp(logits[:, :-2], dim=1)", "\n", "\n", "for", "i", ",", "cls", "in", "enumerate", "(", "classes", ")", ":", "\n", "                ", "if", "cls", "==", "self", ".", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", ":", "\n", "                    ", "continue", "\n", "", "if", "cls", "==", "self", ".", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "-", "1", ":", "\n", "                    ", "unk", ".", "append", "(", "lse", "[", "i", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", "\n", "", "else", ":", "\n", "                    ", "known", ".", "append", "(", "lse", "[", "i", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "", "", "if", "id", "%", "100", "==", "0", ":", "\n", "                ", "logger", ".", "info", "(", "\"Analysing \"", "+", "str", "(", "id", ")", "+", "\" / \"", "+", "str", "(", "len", "(", "files", ")", ")", ")", "\n", "# if id == 10:", "\n", "#     break", "\n", "\n", "", "", "logger", ".", "info", "(", "'len(unk): '", "+", "str", "(", "len", "(", "unk", ")", ")", ")", "\n", "logger", ".", "info", "(", "'len(known): '", "+", "str", "(", "len", "(", "known", ")", ")", ")", "\n", "\n", "logger", ".", "info", "(", "'Fitting Weibull distribution...'", ")", "\n", "wb_dist_param", "=", "[", "]", "\n", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "wb_unk", "=", "Fit_Weibull_3P", "(", "failures", "=", "unk", ",", "show_probability_plot", "=", "False", ",", "print_results", "=", "False", ")", "\n", "logger", ".", "info", "(", "\"--- %s seconds ---\"", "%", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ")", "\n", "\n", "wb_dist_param", ".", "append", "(", "{", "\"scale_unk\"", ":", "wb_unk", ".", "alpha", ",", "\"shape_unk\"", ":", "wb_unk", ".", "beta", ",", "\"shift_unk\"", ":", "wb_unk", ".", "gamma", "}", ")", "\n", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "wb_known", "=", "Fit_Weibull_3P", "(", "failures", "=", "known", ",", "show_probability_plot", "=", "False", ",", "print_results", "=", "False", ")", "\n", "logger", ".", "info", "(", "\"--- %s seconds ---\"", "%", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ")", "\n", "\n", "wb_dist_param", ".", "append", "(", "\n", "{", "\"scale_known\"", ":", "wb_known", ".", "alpha", ",", "\"shape_known\"", ":", "wb_known", ".", "beta", ",", "\"shift_known\"", ":", "wb_known", ".", "gamma", "}", ")", "\n", "\n", "param_save_location", "=", "os", ".", "path", ".", "join", "(", "self", ".", "cfg", ".", "OUTPUT_DIR", ",", "\n", "'energy_dist_'", "+", "str", "(", "self", ".", "cfg", ".", "OWOD", ".", "PREV_INTRODUCED_CLS", "\n", "+", "self", ".", "cfg", ".", "OWOD", ".", "CUR_INTRODUCED_CLS", ")", "+", "'.pkl'", ")", "\n", "logger", ".", "info", "(", "'Pickling the parameters to '", "+", "param_save_location", ")", "\n", "torch", ".", "save", "(", "wb_dist_param", ",", "param_save_location", ")", "\n", "\n", "logger", ".", "info", "(", "'Plotting the computed energy values...'", ")", "\n", "bins", "=", "np", ".", "linspace", "(", "2", ",", "15", ",", "500", ")", "\n", "pyplot", ".", "hist", "(", "known", ",", "bins", ",", "alpha", "=", "0.5", ",", "label", "=", "'known'", ")", "\n", "pyplot", ".", "hist", "(", "unk", ",", "bins", ",", "alpha", "=", "0.5", ",", "label", "=", "'unk'", ")", "\n", "pyplot", ".", "legend", "(", "loc", "=", "'upper right'", ")", "\n", "pyplot", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "self", ".", "cfg", ".", "OUTPUT_DIR", ",", "'energy.png'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.before_step": [[245, 252], ["h.before_step"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.before_step"], ["", "def", "before_step", "(", "self", ")", ":", "\n", "# Maintain the invariant that storage.iter == trainer.iter", "\n", "# for the entire execution of each step", "\n", "        ", "self", ".", "storage", ".", "iter", "=", "self", ".", "iter", "\n", "\n", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "before_step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.after_step": [[253, 256], ["h.after_step"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.after_step"], ["", "", "def", "after_step", "(", "self", ")", ":", "\n", "        ", "for", "h", "in", "self", ".", "_hooks", ":", "\n", "            ", "h", ".", "after_step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.run_step": [[257, 259], ["None"], "methods", ["None"], ["", "", "def", "run_step", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.SimpleTrainer.__init__": [[279, 301], ["train_loop.TrainerBase.__init__", "model.train", "iter"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter"], ["def", "__init__", "(", "self", ",", "model", ",", "data_loader", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            model: a torch Module. Takes a data from data_loader and returns a\n                dict of losses.\n            data_loader: an iterable. Contains data to be used to call model.\n            optimizer: a torch optimizer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "\"\"\"\n        We set the model to training mode in the trainer.\n        However it's valid to train a model that's in eval mode.\n        If you want your model (or a submodule of it) to behave\n        like evaluation during training, you can overwrite its train() method.\n        \"\"\"", "\n", "model", ".", "train", "(", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "data_loader", "=", "data_loader", "\n", "self", ".", "_data_loader_iter", "=", "iter", "(", "data_loader", ")", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.SimpleTrainer.run_step": [[302, 342], ["time.perf_counter", "next", "train_loop.SimpleTrainer.model", "sum", "train_loop.SimpleTrainer.optimizer.zero_grad", "sum.backward", "train_loop.SimpleTrainer.optimizer.step", "time.perf_counter", "train_loop.SimpleTrainer.values", "train_loop.SimpleTrainer._write_metrics", "train_loop.SimpleTrainer._detect_anomaly", "torch.cuda.stream", "_nullcontext", "torch.cuda.Stream"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.swap_align2nat._SwapAlign2Nat.backward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.SimpleTrainer._write_metrics", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.SimpleTrainer._detect_anomaly"], ["", "def", "run_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Implement the standard training logic described above.\n        \"\"\"", "\n", "assert", "self", ".", "model", ".", "training", ",", "\"[SimpleTrainer] model was changed to eval mode!\"", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "\"\"\"\n        If you want to do something with the data, you can wrap the dataloader.\n        \"\"\"", "\n", "data", "=", "next", "(", "self", ".", "_data_loader_iter", ")", "\n", "data_time", "=", "time", ".", "perf_counter", "(", ")", "-", "start", "\n", "\n", "\"\"\"\n        If you want to do something with the losses, you can wrap the model.\n        \"\"\"", "\n", "loss_dict", "=", "self", ".", "model", "(", "data", ")", "\n", "losses", "=", "sum", "(", "loss_dict", ".", "values", "(", ")", ")", "\n", "\n", "\"\"\"\n        If you need to accumulate gradients or do something similar, you can\n        wrap the optimizer with your custom `zero_grad()` method.\n        \"\"\"", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "\n", "# use a new stream so the ops don't wait for DDP", "\n", "with", "torch", ".", "cuda", ".", "stream", "(", "\n", "torch", ".", "cuda", ".", "Stream", "(", ")", "\n", ")", "if", "losses", ".", "device", ".", "type", "==", "\"cuda\"", "else", "_nullcontext", "(", ")", ":", "\n", "            ", "metrics_dict", "=", "loss_dict", "\n", "metrics_dict", "[", "\"data_time\"", "]", "=", "data_time", "\n", "self", ".", "_write_metrics", "(", "metrics_dict", ")", "\n", "self", ".", "_detect_anomaly", "(", "losses", ",", "loss_dict", ")", "\n", "\n", "", "\"\"\"\n        If you need gradient clipping/scaling or other processing, you can\n        wrap the optimizer with your custom `step()` method. But it is\n        suboptimal as explained in https://arxiv.org/abs/2006.15704 Sec 3.2.4\n        \"\"\"", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.SimpleTrainer._detect_anomaly": [[343, 348], ["torch.isfinite().all", "FloatingPointError", "torch.isfinite"], "methods", ["None"], ["", "def", "_detect_anomaly", "(", "self", ",", "losses", ",", "loss_dict", ")", ":", "\n", "        ", "if", "not", "torch", ".", "isfinite", "(", "losses", ")", ".", "all", "(", ")", ":", "\n", "            ", "raise", "FloatingPointError", "(", "\n", "\"Loss became infinite or NaN at iteration={}!\\nloss_dict = {}\"", ".", "format", "(", "\n", "self", ".", "iter", ",", "loss_dict", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.SimpleTrainer._write_metrics": [[351, 381], ["detectron2.gather", "detectron2.is_main_process", "sum", "train_loop.SimpleTrainer.storage.put_scalar", "isinstance", "v.detach().cpu().item", "float", "metrics_dict.items", "numpy.max", "train_loop.SimpleTrainer.storage.put_scalar", "numpy.mean", "len", "train_loop.SimpleTrainer.storage.put_scalars", "all_metrics_dict[].keys", "v.detach().cpu", "x.pop", "metrics_dict.values", "v.detach"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalars"], ["", "", "def", "_write_metrics", "(", "self", ",", "metrics_dict", ":", "dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            metrics_dict (dict): dict of scalar metrics\n        \"\"\"", "\n", "metrics_dict", "=", "{", "\n", "k", ":", "v", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", "else", "float", "(", "v", ")", "\n", "for", "k", ",", "v", "in", "metrics_dict", ".", "items", "(", ")", "\n", "}", "\n", "# gather metrics among all workers for logging", "\n", "# This assumes we do DDP-style training, which is currently the only", "\n", "# supported method in detectron2.", "\n", "all_metrics_dict", "=", "comm", ".", "gather", "(", "metrics_dict", ")", "\n", "\n", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "if", "\"data_time\"", "in", "all_metrics_dict", "[", "0", "]", ":", "\n", "# data_time among workers can have high variance. The actual latency", "\n", "# caused by data_time is the maximum among workers.", "\n", "                ", "data_time", "=", "np", ".", "max", "(", "[", "x", ".", "pop", "(", "\"data_time\"", ")", "for", "x", "in", "all_metrics_dict", "]", ")", "\n", "self", ".", "storage", ".", "put_scalar", "(", "\"data_time\"", ",", "data_time", ")", "\n", "\n", "# average the rest metrics", "\n", "", "metrics_dict", "=", "{", "\n", "k", ":", "np", ".", "mean", "(", "[", "x", "[", "k", "]", "for", "x", "in", "all_metrics_dict", "]", ")", "for", "k", "in", "all_metrics_dict", "[", "0", "]", ".", "keys", "(", ")", "\n", "}", "\n", "total_losses_reduced", "=", "sum", "(", "loss", "for", "loss", "in", "metrics_dict", ".", "values", "(", ")", ")", "\n", "\n", "self", ".", "storage", ".", "put_scalar", "(", "\"total_loss\"", ",", "total_losses_reduced", ")", "\n", "if", "len", "(", "metrics_dict", ")", ">", "1", ":", "\n", "                ", "self", ".", "storage", ".", "put_scalars", "(", "**", "metrics_dict", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountingLoader.__init__": [[30, 32], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "loader", ")", ":", "\n", "        ", "self", ".", "loader", "=", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountingLoader.__iter__": [[33, 51], ["iter", "detectron2.utils.events.get_event_storage", "next", "len", "detectron2.utils.events.get_event_storage.put_scalar"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "it", "=", "iter", "(", "self", ".", "loader", ")", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "while", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "batch", "=", "next", "(", "it", ")", "\n", "num_inst_per_dataset", "=", "{", "}", "\n", "for", "data", "in", "batch", ":", "\n", "                    ", "dataset_name", "=", "data", "[", "\"dataset\"", "]", "\n", "if", "dataset_name", "not", "in", "num_inst_per_dataset", ":", "\n", "                        ", "num_inst_per_dataset", "[", "dataset_name", "]", "=", "0", "\n", "", "num_inst", "=", "len", "(", "data", "[", "\"instances\"", "]", ")", "\n", "num_inst_per_dataset", "[", "dataset_name", "]", "+=", "num_inst", "\n", "", "for", "dataset_name", "in", "num_inst_per_dataset", ":", "\n", "                    ", "storage", ".", "put_scalar", "(", "f\"batch/{dataset_name}\"", ",", "num_inst_per_dataset", "[", "dataset_name", "]", ")", "\n", "", "yield", "batch", "\n", "", "except", "StopIteration", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.__init__": [[54, 56], ["logging.getLogger"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write": [[57, 64], ["detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.histories().items", "trainer.SampleCountMetricPrinter.logger.info", "key.startswith", "detectron2.utils.events.get_event_storage.histories", "batch_stats_strs.append", "buf.avg"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.histories"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "batch_stats_strs", "=", "[", "]", "\n", "for", "key", ",", "buf", "in", "storage", ".", "histories", "(", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "key", ".", "startswith", "(", "\"batch/\"", ")", ":", "\n", "                ", "batch_stats_strs", ".", "append", "(", "f\"{key} {buf.avg(20)}\"", ")", "\n", "", "", "self", ".", "logger", ".", "info", "(", "\", \"", ".", "join", "(", "batch_stats_strs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.build_evaluator": [[67, 75], ["detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.evaluation.COCOEvaluator", "evaluators.append", "densepose.DensePoseCOCOEvaluator"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ":", "CfgNode", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluators", "=", "[", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "]", "\n", "if", "cfg", ".", "MODEL", ".", "DENSEPOSE_ON", ":", "\n", "            ", "evaluators", ".", "append", "(", "DensePoseCOCOEvaluator", "(", "dataset_name", ",", "True", ",", "output_folder", ")", ")", "\n", "", "return", "DatasetEvaluators", "(", "evaluators", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.build_test_loader": [[76, 79], ["densepose.data.build_detection_test_loader", "densepose.data.DatasetMapper"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_test_loader"], ["", "@", "classmethod", "\n", "def", "build_test_loader", "(", "cls", ",", "cfg", ":", "CfgNode", ",", "dataset_name", ")", ":", "\n", "        ", "return", "build_detection_test_loader", "(", "cfg", ",", "dataset_name", ",", "mapper", "=", "DatasetMapper", "(", "cfg", ",", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.build_train_loader": [[80, 94], ["densepose.data.build_detection_train_loader", "cls.build_model", "cls.build_model.to", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "densepose.data.build_inference_based_loaders", "densepose.data.build_combined_loader", "trainer.SampleCountingLoader", "densepose.data.has_inference_based_loaders", "densepose.data.DatasetMapper", "detectron2.checkpoint.DetectionCheckpointer"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_inference_based_loaders", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_combined_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.has_inference_based_loaders"], ["", "@", "classmethod", "\n", "def", "build_train_loader", "(", "cls", ",", "cfg", ":", "CfgNode", ")", ":", "\n", "        ", "data_loader", "=", "build_detection_train_loader", "(", "cfg", ",", "mapper", "=", "DatasetMapper", "(", "cfg", ",", "True", ")", ")", "\n", "if", "not", "has_inference_based_loaders", "(", "cfg", ")", ":", "\n", "            ", "return", "data_loader", "\n", "", "model", "=", "cls", ".", "build_model", "(", "cfg", ")", "\n", "model", ".", "to", "(", "cfg", ".", "BOOTSTRAP_MODEL", ".", "DEVICE", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "resume_or_load", "(", "cfg", ".", "BOOTSTRAP_MODEL", ".", "WEIGHTS", ",", "resume", "=", "False", ")", "\n", "inference_based_loaders", ",", "ratios", "=", "build_inference_based_loaders", "(", "cfg", ",", "model", ")", "\n", "loaders", "=", "[", "data_loader", "]", "+", "inference_based_loaders", "\n", "ratios", "=", "[", "1.0", "]", "+", "ratios", "\n", "combined_data_loader", "=", "build_combined_loader", "(", "cfg", ",", "loaders", ",", "ratios", ")", "\n", "sample_counting_loader", "=", "SampleCountingLoader", "(", "combined_data_loader", ")", "\n", "return", "sample_counting_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.build_writers": [[95, 99], ["super().build_writers", "super().build_writers.append", "trainer.SampleCountMetricPrinter"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.build_writers"], ["", "def", "build_writers", "(", "self", ")", ":", "\n", "        ", "writers", "=", "super", "(", ")", ".", "build_writers", "(", ")", "\n", "writers", ".", "append", "(", "SampleCountMetricPrinter", "(", ")", ")", "\n", "return", "writers", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.test_with_TTA": [[100, 119], ["logging.getLogger", "logging.getLogger.info", "densepose.load_from_cfg", "densepose.DensePoseGeneralizedRCNNWithTTA", "cls.test", "collections.OrderedDict", "densepose.DensePoseDatasetMapperTTA", "cls.build_evaluator", "os.path.join", "collections.OrderedDict.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.transform.load_from_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.Trainer.build_evaluator"], ["", "@", "classmethod", "\n", "def", "test_with_TTA", "(", "cls", ",", "cfg", ":", "CfgNode", ",", "model", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "\"detectron2.trainer\"", ")", "\n", "# In the end of training, run an evaluation with TTA", "\n", "# Only support some R-CNN models.", "\n", "logger", ".", "info", "(", "\"Running inference with test-time augmentation ...\"", ")", "\n", "transform_data", "=", "load_from_cfg", "(", "cfg", ")", "\n", "model", "=", "DensePoseGeneralizedRCNNWithTTA", "(", "\n", "cfg", ",", "model", ",", "transform_data", ",", "DensePoseDatasetMapperTTA", "(", "cfg", ")", "\n", ")", "\n", "evaluators", "=", "[", "\n", "cls", ".", "build_evaluator", "(", "\n", "cfg", ",", "name", ",", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference_TTA\"", ")", "\n", ")", "\n", "for", "name", "in", "cfg", ".", "DATASETS", ".", "TEST", "\n", "]", "\n", "res", "=", "cls", ".", "test", "(", "cfg", ",", "model", ",", "evaluators", ")", "\n", "res", "=", "OrderedDict", "(", "{", "k", "+", "\"_TTA\"", ":", "v", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "}", ")", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.common.MapDataset.__init__": [[26, 32], ["detectron2.utils.serialize.PicklableWrapper", "random.Random", "set", "range", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["def", "__init__", "(", "self", ",", "dataset", ",", "map_func", ")", ":", "\n", "        ", "self", ".", "_dataset", "=", "dataset", "\n", "self", ".", "_map_func", "=", "PicklableWrapper", "(", "map_func", ")", "# wrap so that a lambda will work", "\n", "\n", "self", ".", "_rng", "=", "random", ".", "Random", "(", "42", ")", "\n", "self", ".", "_fallback_candidates", "=", "set", "(", "range", "(", "len", "(", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.common.MapDataset.__len__": [[33, 35], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.common.MapDataset.__getitem__": [[36, 56], ["int", "common.MapDataset._map_func", "common.MapDataset._fallback_candidates.discard", "common.MapDataset._fallback_candidates.add", "common.MapDataset._rng.sample", "logging.getLogger", "logging.getLogger.warning"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.add"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "retry_count", "=", "0", "\n", "cur_idx", "=", "int", "(", "idx", ")", "\n", "\n", "while", "True", ":", "\n", "            ", "data", "=", "self", ".", "_map_func", "(", "self", ".", "_dataset", "[", "cur_idx", "]", ")", "\n", "if", "data", "is", "not", "None", ":", "\n", "                ", "self", ".", "_fallback_candidates", ".", "add", "(", "cur_idx", ")", "\n", "return", "data", "\n", "\n", "# _map_func fails for this idx, use a random new index from the pool", "\n", "", "retry_count", "+=", "1", "\n", "self", ".", "_fallback_candidates", ".", "discard", "(", "cur_idx", ")", "\n", "cur_idx", "=", "self", ".", "_rng", ".", "sample", "(", "self", ".", "_fallback_candidates", ",", "k", "=", "1", ")", "[", "0", "]", "\n", "\n", "if", "retry_count", ">=", "3", ":", "\n", "                ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"Failed to apply `_map_func` for idx: {}, retry count: {}\"", ".", "format", "(", "\n", "idx", ",", "retry_count", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.common.DatasetFromList.__init__": [[65, 96], ["pickle.dumps", "numpy.frombuffer", "logging.getLogger", "logging.getLogger.info", "numpy.asarray", "numpy.cumsum", "numpy.concatenate", "logging.getLogger.info", "common.DatasetFromList.__init__._serialize"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lst", ":", "list", ",", "copy", ":", "bool", "=", "True", ",", "serialize", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            lst (list): a list which contains elements to produce.\n            copy (bool): whether to deepcopy the element when producing it,\n                so that the result can be modified in place without affecting the\n                source in the list.\n            serialize (bool): whether to hold memory using serialized objects, when\n                enabled, data loader workers can use shared RAM from master\n                process instead of making a copy.\n        \"\"\"", "\n", "self", ".", "_lst", "=", "lst", "\n", "self", ".", "_copy", "=", "copy", "\n", "self", ".", "_serialize", "=", "serialize", "\n", "\n", "def", "_serialize", "(", "data", ")", ":", "\n", "            ", "buffer", "=", "pickle", ".", "dumps", "(", "data", ",", "protocol", "=", "-", "1", ")", "\n", "return", "np", ".", "frombuffer", "(", "buffer", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "", "if", "self", ".", "_serialize", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\n", "\"Serializing {} elements to byte tensors and concatenating them all ...\"", ".", "format", "(", "\n", "len", "(", "self", ".", "_lst", ")", "\n", ")", "\n", ")", "\n", "self", ".", "_lst", "=", "[", "_serialize", "(", "x", ")", "for", "x", "in", "self", ".", "_lst", "]", "\n", "self", ".", "_addr", "=", "np", ".", "asarray", "(", "[", "len", "(", "x", ")", "for", "x", "in", "self", ".", "_lst", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "_addr", "=", "np", ".", "cumsum", "(", "self", ".", "_addr", ")", "\n", "self", ".", "_lst", "=", "np", ".", "concatenate", "(", "self", ".", "_lst", ")", "\n", "logger", ".", "info", "(", "\"Serialized dataset takes {:.2f} MiB\"", ".", "format", "(", "len", "(", "self", ".", "_lst", ")", "/", "1024", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.common.DatasetFromList.__len__": [[97, 102], ["len", "len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_serialize", ":", "\n", "            ", "return", "len", "(", "self", ".", "_addr", ")", "\n", "", "else", ":", "\n", "            ", "return", "len", "(", "self", ".", "_lst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.common.DatasetFromList.__getitem__": [[103, 113], ["common.DatasetFromList._addr[].item", "memoryview", "pickle.loads", "common.DatasetFromList._addr[].item", "copy.deepcopy"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "_serialize", ":", "\n", "            ", "start_addr", "=", "0", "if", "idx", "==", "0", "else", "self", ".", "_addr", "[", "idx", "-", "1", "]", ".", "item", "(", ")", "\n", "end_addr", "=", "self", ".", "_addr", "[", "idx", "]", ".", "item", "(", ")", "\n", "bytes", "=", "memoryview", "(", "self", ".", "_lst", "[", "start_addr", ":", "end_addr", "]", ")", "\n", "return", "pickle", ".", "loads", "(", "bytes", ")", "\n", "", "elif", "self", ".", "_copy", ":", "\n", "            ", "return", "copy", ".", "deepcopy", "(", "self", ".", "_lst", "[", "idx", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_lst", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.common.AspectRatioGroupedDataset.__init__": [[128, 138], ["range"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dataset", ",", "batch_size", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset: an iterable. Each element must be a dict with keys\n                \"width\" and \"height\", which will be used to batch data.\n            batch_size (int):\n        \"\"\"", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "_buckets", "=", "[", "[", "]", "for", "_", "in", "range", "(", "2", ")", "]", "\n", "# Hard-coded two aspect ratio groups: w > h and w < h.", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.common.AspectRatioGroupedDataset.__iter__": [[141, 150], ["bucket.append", "len"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "d", "in", "self", ".", "dataset", ":", "\n", "            ", "w", ",", "h", "=", "d", "[", "\"width\"", "]", ",", "d", "[", "\"height\"", "]", "\n", "bucket_id", "=", "0", "if", "w", ">", "h", "else", "1", "\n", "bucket", "=", "self", ".", "_buckets", "[", "bucket_id", "]", "\n", "bucket", ".", "append", "(", "d", ")", "\n", "if", "len", "(", "bucket", ")", "==", "self", ".", "batch_size", ":", "\n", "                ", "yield", "bucket", "[", ":", "]", "\n", "del", "bucket", "[", ":", "]", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.convert_PIL_to_numpy": [[59, 90], ["numpy.asarray", "np.dot.convert", "numpy.expand_dims", "numpy.dot", "numpy.array"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["def", "convert_PIL_to_numpy", "(", "image", ",", "format", ")", ":", "\n", "    ", "\"\"\"\n    Convert PIL image to numpy array of target format.\n\n    Args:\n        image (PIL.Image): a PIL image\n        format (str): the format of output image\n\n    Returns:\n        (np.ndarray): also see `read_image`\n    \"\"\"", "\n", "if", "format", "is", "not", "None", ":", "\n", "# PIL only supports RGB, so convert to RGB and flip channels over below", "\n", "        ", "conversion_format", "=", "format", "\n", "if", "format", "in", "[", "\"BGR\"", ",", "\"YUV-BT.601\"", "]", ":", "\n", "            ", "conversion_format", "=", "\"RGB\"", "\n", "", "image", "=", "image", ".", "convert", "(", "conversion_format", ")", "\n", "", "image", "=", "np", ".", "asarray", "(", "image", ")", "\n", "# PIL squeezes out the channel dimension for \"L\", so make it HWC", "\n", "if", "format", "==", "\"L\"", ":", "\n", "        ", "image", "=", "np", ".", "expand_dims", "(", "image", ",", "-", "1", ")", "\n", "\n", "# handle formats not supported by PIL", "\n", "", "elif", "format", "==", "\"BGR\"", ":", "\n", "# flip channels if needed", "\n", "        ", "image", "=", "image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "", "elif", "format", "==", "\"YUV-BT.601\"", ":", "\n", "        ", "image", "=", "image", "/", "255.0", "\n", "image", "=", "np", ".", "dot", "(", "image", ",", "np", ".", "array", "(", "_M_RGB2YUV", ")", ".", "T", ")", "\n", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.convert_image_to_rgb": [[92, 116], ["isinstance", "np.asarray.cpu().numpy", "numpy.dot", "np.asarray.astype", "numpy.asarray", "np.asarray.cpu", "PIL.Image.fromarray().convert", "numpy.array", "PIL.Image.fromarray"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "convert_image_to_rgb", "(", "image", ",", "format", ")", ":", "\n", "    ", "\"\"\"\n    Convert an image from given format to RGB.\n\n    Args:\n        image (np.ndarray or Tensor): an HWC image\n        format (str): the format of input image, also see `read_image`\n\n    Returns:\n        (np.ndarray): (H,W,3) RGB image in 0-255 range, can be either float or uint8\n    \"\"\"", "\n", "if", "isinstance", "(", "image", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "image", "=", "image", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "if", "format", "==", "\"BGR\"", ":", "\n", "        ", "image", "=", "image", "[", ":", ",", ":", ",", "[", "2", ",", "1", ",", "0", "]", "]", "\n", "", "elif", "format", "==", "\"YUV-BT.601\"", ":", "\n", "        ", "image", "=", "np", ".", "dot", "(", "image", ",", "np", ".", "array", "(", "_M_YUV2RGB", ")", ".", "T", ")", "\n", "image", "=", "image", "*", "255.0", "\n", "", "else", ":", "\n", "        ", "if", "format", "==", "\"L\"", ":", "\n", "            ", "image", "=", "image", "[", ":", ",", ":", ",", "0", "]", "\n", "", "image", "=", "image", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "image", "=", "np", ".", "asarray", "(", "Image", ".", "fromarray", "(", "image", ",", "mode", "=", "format", ")", ".", "convert", "(", "\"RGB\"", ")", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils._apply_exif_orientation": [[118, 163], ["image.getexif.get", "hasattr", "image.getexif", "image.transpose"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "_apply_exif_orientation", "(", "image", ")", ":", "\n", "    ", "\"\"\"\n    Applies the exif orientation correctly.\n\n    This code exists per the bug:\n      https://github.com/python-pillow/Pillow/issues/3973\n    with the function `ImageOps.exif_transpose`. The Pillow source raises errors with\n    various methods, especially `tobytes`\n\n    Function based on:\n      https://github.com/wkentaro/labelme/blob/v4.5.4/labelme/utils/image.py#L59\n      https://github.com/python-pillow/Pillow/blob/7.1.2/src/PIL/ImageOps.py#L527\n\n    Args:\n        image (PIL.Image): a PIL image\n\n    Returns:\n        (PIL.Image): the PIL image with exif orientation applied, if applicable\n    \"\"\"", "\n", "if", "not", "hasattr", "(", "image", ",", "\"getexif\"", ")", ":", "\n", "        ", "return", "image", "\n", "\n", "", "try", ":", "\n", "        ", "exif", "=", "image", ".", "getexif", "(", ")", "\n", "", "except", "Exception", ":", "# https://github.com/facebookresearch/detectron2/issues/1885", "\n", "        ", "exif", "=", "None", "\n", "\n", "", "if", "exif", "is", "None", ":", "\n", "        ", "return", "image", "\n", "\n", "", "orientation", "=", "exif", ".", "get", "(", "_EXIF_ORIENT", ")", "\n", "\n", "method", "=", "{", "\n", "2", ":", "Image", ".", "FLIP_LEFT_RIGHT", ",", "\n", "3", ":", "Image", ".", "ROTATE_180", ",", "\n", "4", ":", "Image", ".", "FLIP_TOP_BOTTOM", ",", "\n", "5", ":", "Image", ".", "TRANSPOSE", ",", "\n", "6", ":", "Image", ".", "ROTATE_270", ",", "\n", "7", ":", "Image", ".", "TRANSVERSE", ",", "\n", "8", ":", "Image", ".", "ROTATE_90", ",", "\n", "}", ".", "get", "(", "orientation", ")", "\n", "\n", "if", "method", "is", "not", "None", ":", "\n", "        ", "return", "image", ".", "transpose", "(", "method", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.read_image": [[165, 184], ["fvcore.common.file_io.PathManager.open", "PIL.Image.open", "detection_utils._apply_exif_orientation", "detection_utils.convert_PIL_to_numpy"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils._apply_exif_orientation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.convert_PIL_to_numpy"], ["", "def", "read_image", "(", "file_name", ",", "format", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Read an image into the given format.\n    Will apply rotation and flipping if the image has such exif information.\n\n    Args:\n        file_name (str): image file path\n        format (str): one of the supported image modes in PIL, or \"BGR\" or \"YUV-BT.601\".\n\n    Returns:\n        image (np.ndarray): an HWC image in the given format, which is 0-255, uint8 for\n            supported image modes in PIL or \"BGR\"; float (0-1 for Y) for YUV-BT.601.\n    \"\"\"", "\n", "with", "PathManager", ".", "open", "(", "file_name", ",", "\"rb\"", ")", "as", "f", ":", "\n", "        ", "image", "=", "Image", ".", "open", "(", "f", ")", "\n", "\n", "# work around this bug: https://github.com/python-pillow/Pillow/issues/3973", "\n", "image", "=", "_apply_exif_orientation", "(", "image", ")", "\n", "return", "convert_PIL_to_numpy", "(", "image", ",", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.check_image_size": [[186, 209], ["detection_utils.SizeMismatchError"], "function", ["None"], ["", "", "def", "check_image_size", "(", "dataset_dict", ",", "image", ")", ":", "\n", "    ", "\"\"\"\n    Raise an error if the image does not match the size specified in the dict.\n    \"\"\"", "\n", "if", "\"width\"", "in", "dataset_dict", "or", "\"height\"", "in", "dataset_dict", ":", "\n", "        ", "image_wh", "=", "(", "image", ".", "shape", "[", "1", "]", ",", "image", ".", "shape", "[", "0", "]", ")", "\n", "expected_wh", "=", "(", "dataset_dict", "[", "\"width\"", "]", ",", "dataset_dict", "[", "\"height\"", "]", ")", "\n", "if", "not", "image_wh", "==", "expected_wh", ":", "\n", "            ", "raise", "SizeMismatchError", "(", "\n", "\"Mismatched (W,H){}, got {}, expect {}\"", ".", "format", "(", "\n", "\" for image \"", "+", "dataset_dict", "[", "\"file_name\"", "]", "\n", "if", "\"file_name\"", "in", "dataset_dict", "\n", "else", "\"\"", ",", "\n", "image_wh", ",", "\n", "expected_wh", ",", "\n", ")", "\n", ")", "\n", "\n", "# To ensure bbox always remap to original image size", "\n", "", "", "if", "\"width\"", "not", "in", "dataset_dict", ":", "\n", "        ", "dataset_dict", "[", "\"width\"", "]", "=", "image", ".", "shape", "[", "1", "]", "\n", "", "if", "\"height\"", "not", "in", "dataset_dict", ":", "\n", "        ", "dataset_dict", "[", "\"height\"", "]", "=", "image", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_proposals": [[211, 252], ["transforms.apply_box", "detectron2.structures.Boxes", "torch.as_tensor", "detectron2.structures.Boxes.clip", "detectron2.structures.Boxes.nonempty", "detectron2.structures.Instances", "detectron2.structures.BoxMode.convert", "dataset_dict.pop().astype", "dataset_dict.pop", "dataset_dict.pop", "dataset_dict.pop"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "", "def", "transform_proposals", "(", "dataset_dict", ",", "image_shape", ",", "transforms", ",", "*", ",", "proposal_topk", ",", "min_box_size", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Apply transformations to the proposals in dataset_dict, if any.\n\n    Args:\n        dataset_dict (dict): a dict read from the dataset, possibly\n            contains fields \"proposal_boxes\", \"proposal_objectness_logits\", \"proposal_bbox_mode\"\n        image_shape (tuple): height, width\n        transforms (TransformList):\n        proposal_topk (int): only keep top-K scoring proposals\n        min_box_size (int): proposals with either side smaller than this\n            threshold are removed\n\n    The input dict is modified in-place, with abovementioned keys removed. A new\n    key \"proposals\" will be added. Its value is an `Instances`\n    object which contains the transformed proposals in its field\n    \"proposal_boxes\" and \"objectness_logits\".\n    \"\"\"", "\n", "if", "\"proposal_boxes\"", "in", "dataset_dict", ":", "\n", "# Transform proposal boxes", "\n", "        ", "boxes", "=", "transforms", ".", "apply_box", "(", "\n", "BoxMode", ".", "convert", "(", "\n", "dataset_dict", ".", "pop", "(", "\"proposal_boxes\"", ")", ",", "\n", "dataset_dict", ".", "pop", "(", "\"proposal_bbox_mode\"", ")", ",", "\n", "BoxMode", ".", "XYXY_ABS", ",", "\n", ")", "\n", ")", "\n", "boxes", "=", "Boxes", "(", "boxes", ")", "\n", "objectness_logits", "=", "torch", ".", "as_tensor", "(", "\n", "dataset_dict", ".", "pop", "(", "\"proposal_objectness_logits\"", ")", ".", "astype", "(", "\"float32\"", ")", "\n", ")", "\n", "\n", "boxes", ".", "clip", "(", "image_shape", ")", "\n", "keep", "=", "boxes", ".", "nonempty", "(", "threshold", "=", "min_box_size", ")", "\n", "boxes", "=", "boxes", "[", "keep", "]", "\n", "objectness_logits", "=", "objectness_logits", "[", "keep", "]", "\n", "\n", "proposals", "=", "Instances", "(", "image_shape", ")", "\n", "proposals", ".", "proposal_boxes", "=", "boxes", "[", ":", "proposal_topk", "]", "\n", "proposals", ".", "objectness_logits", "=", "objectness_logits", "[", ":", "proposal_topk", "]", "\n", "dataset_dict", "[", "\"proposals\"", "]", "=", "proposals", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_instance_annotations": [[254, 316], ["isinstance", "detectron2.structures.BoxMode.convert", "[].clip", "numpy.minimum", "transforms.TransformList", "isinstance", "detection_utils.transform_keypoint_annotations", "list", "isinstance", "T.TransformList.apply_box", "numpy.asarray().reshape", "p.reshape", "pycocotools.decode", "T.TransformList.apply_segmentation", "ValueError", "numpy.array", "T.TransformList.apply_polygons", "tuple", "numpy.asarray", "type"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_keypoint_annotations", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_segmentation"], ["", "", "def", "transform_instance_annotations", "(", "\n", "annotation", ",", "transforms", ",", "image_size", ",", "*", ",", "keypoint_hflip_indices", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Apply transforms to box, segmentation and keypoints annotations of a single instance.\n\n    It will use `transforms.apply_box` for the box, and\n    `transforms.apply_coords` for segmentation polygons & keypoints.\n    If you need anything more specially designed for each data structure,\n    you'll need to implement your own version of this function or the transforms.\n\n    Args:\n        annotation (dict): dict of instance annotations for a single instance.\n            It will be modified in-place.\n        transforms (TransformList or list[Transform]):\n        image_size (tuple): the height, width of the transformed image\n        keypoint_hflip_indices (ndarray[int]): see `create_keypoint_hflip_indices`.\n\n    Returns:\n        dict:\n            the same input dict with fields \"bbox\", \"segmentation\", \"keypoints\"\n            transformed according to `transforms`.\n            The \"bbox_mode\" field will be set to XYXY_ABS.\n    \"\"\"", "\n", "if", "isinstance", "(", "transforms", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "        ", "transforms", "=", "T", ".", "TransformList", "(", "transforms", ")", "\n", "# bbox is 1d (per-instance bounding box)", "\n", "", "bbox", "=", "BoxMode", ".", "convert", "(", "annotation", "[", "\"bbox\"", "]", ",", "annotation", "[", "\"bbox_mode\"", "]", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "# clip transformed bbox to image size", "\n", "bbox", "=", "transforms", ".", "apply_box", "(", "np", ".", "array", "(", "[", "bbox", "]", ")", ")", "[", "0", "]", ".", "clip", "(", "min", "=", "0", ")", "\n", "annotation", "[", "\"bbox\"", "]", "=", "np", ".", "minimum", "(", "bbox", ",", "list", "(", "image_size", "+", "image_size", ")", "[", ":", ":", "-", "1", "]", ")", "\n", "annotation", "[", "\"bbox_mode\"", "]", "=", "BoxMode", ".", "XYXY_ABS", "\n", "\n", "if", "\"segmentation\"", "in", "annotation", ":", "\n", "# each instance contains 1 or more polygons", "\n", "        ", "segm", "=", "annotation", "[", "\"segmentation\"", "]", "\n", "if", "isinstance", "(", "segm", ",", "list", ")", ":", "\n", "# polygons", "\n", "            ", "polygons", "=", "[", "np", ".", "asarray", "(", "p", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "for", "p", "in", "segm", "]", "\n", "annotation", "[", "\"segmentation\"", "]", "=", "[", "\n", "p", ".", "reshape", "(", "-", "1", ")", "for", "p", "in", "transforms", ".", "apply_polygons", "(", "polygons", ")", "\n", "]", "\n", "", "elif", "isinstance", "(", "segm", ",", "dict", ")", ":", "\n", "# RLE", "\n", "            ", "mask", "=", "mask_util", ".", "decode", "(", "segm", ")", "\n", "mask", "=", "transforms", ".", "apply_segmentation", "(", "mask", ")", "\n", "assert", "tuple", "(", "mask", ".", "shape", "[", ":", "2", "]", ")", "==", "image_size", "\n", "annotation", "[", "\"segmentation\"", "]", "=", "mask", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Cannot transform segmentation of type '{}'!\"", "\n", "\"Supported types are: polygons as list[list[float] or ndarray],\"", "\n", "\" COCO-style RLE as a dict.\"", ".", "format", "(", "type", "(", "segm", ")", ")", "\n", ")", "\n", "\n", "", "", "if", "\"keypoints\"", "in", "annotation", ":", "\n", "        ", "keypoints", "=", "transform_keypoint_annotations", "(", "\n", "annotation", "[", "\"keypoints\"", "]", ",", "transforms", ",", "image_size", ",", "keypoint_hflip_indices", "\n", ")", "\n", "annotation", "[", "\"keypoints\"", "]", "=", "keypoints", "\n", "\n", "", "return", "annotation", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_keypoint_annotations": [[318, 358], ["numpy.asarray().reshape", "transforms.apply_coords", "inside.all.all", "numpy.asarray", "numpy.array", "numpy.array", "sum", "isinstance"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords"], ["", "def", "transform_keypoint_annotations", "(", "keypoints", ",", "transforms", ",", "image_size", ",", "keypoint_hflip_indices", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Transform keypoint annotations of an image.\n    If a keypoint is transformed out of image boundary, it will be marked \"unlabeled\" (visibility=0)\n\n    Args:\n        keypoints (list[float]): Nx3 float in Detectron2's Dataset format.\n            Each point is represented by (x, y, visibility).\n        transforms (TransformList):\n        image_size (tuple): the height, width of the transformed image\n        keypoint_hflip_indices (ndarray[int]): see `create_keypoint_hflip_indices`.\n            When `transforms` includes horizontal flip, will use the index\n            mapping to flip keypoints.\n    \"\"\"", "\n", "# (N*3,) -> (N, 3)", "\n", "keypoints", "=", "np", ".", "asarray", "(", "keypoints", ",", "dtype", "=", "\"float64\"", ")", ".", "reshape", "(", "-", "1", ",", "3", ")", "\n", "keypoints_xy", "=", "transforms", ".", "apply_coords", "(", "keypoints", "[", ":", ",", ":", "2", "]", ")", "\n", "\n", "# Set all out-of-boundary points to \"unlabeled\"", "\n", "inside", "=", "(", "keypoints_xy", ">=", "np", ".", "array", "(", "[", "0", ",", "0", "]", ")", ")", "&", "(", "keypoints_xy", "<=", "np", ".", "array", "(", "image_size", "[", ":", ":", "-", "1", "]", ")", ")", "\n", "inside", "=", "inside", ".", "all", "(", "axis", "=", "1", ")", "\n", "keypoints", "[", ":", ",", ":", "2", "]", "=", "keypoints_xy", "\n", "keypoints", "[", ":", ",", "2", "]", "[", "~", "inside", "]", "=", "0", "\n", "\n", "# This assumes that HorizFlipTransform is the only one that does flip", "\n", "do_hflip", "=", "sum", "(", "isinstance", "(", "t", ",", "T", ".", "HFlipTransform", ")", "for", "t", "in", "transforms", ".", "transforms", ")", "%", "2", "==", "1", "\n", "\n", "# Alternative way: check if probe points was horizontally flipped.", "\n", "# probe = np.asarray([[0.0, 0.0], [image_width, 0.0]])", "\n", "# probe_aug = transforms.apply_coords(probe.copy())", "\n", "# do_hflip = np.sign(probe[1][0] - probe[0][0]) != np.sign(probe_aug[1][0] - probe_aug[0][0])  # noqa", "\n", "\n", "# If flipped, swap each keypoint with its opposite-handed equivalent", "\n", "if", "do_hflip", ":", "\n", "        ", "assert", "keypoint_hflip_indices", "is", "not", "None", "\n", "keypoints", "=", "keypoints", "[", "keypoint_hflip_indices", ",", ":", "]", "\n", "\n", "# Maintain COCO convention that if visibility == 0 (unlabeled), then x, y = 0", "\n", "", "keypoints", "[", "keypoints", "[", ":", ",", "2", "]", "==", "0", "]", "=", "0", "\n", "return", "keypoints", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.annotations_to_instances": [[360, 423], ["detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor", "detectron2.structures.BoxMode.convert", "int", "len", "len", "detectron2.structures.Keypoints", "detectron2.structures.PolygonMasks", "detectron2.structures.BitMasks", "obj.get", "isinstance", "torch.stack", "detectron2.structures.BitMasks.append", "isinstance", "detectron2.structures.polygons_to_bitmask", "detectron2.structures.BitMasks.append", "isinstance", "torch.from_numpy", "pycocotools.decode", "detectron2.structures.BitMasks.append", "ValueError", "numpy.ascontiguousarray", "type"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.polygons_to_bitmask"], ["", "def", "annotations_to_instances", "(", "annos", ",", "image_size", ",", "mask_format", "=", "\"polygon\"", ")", ":", "\n", "    ", "\"\"\"\n    Create an :class:`Instances` object used by the models,\n    from instance annotations in the dataset dict.\n\n    Args:\n        annos (list[dict]): a list of instance annotations in one image, each\n            element for one instance.\n        image_size (tuple): height, width\n\n    Returns:\n        Instances:\n            It will contain fields \"gt_boxes\", \"gt_classes\",\n            \"gt_masks\", \"gt_keypoints\", if they can be obtained from `annos`.\n            This is the format that builtin models expect.\n    \"\"\"", "\n", "boxes", "=", "[", "BoxMode", ".", "convert", "(", "obj", "[", "\"bbox\"", "]", ",", "obj", "[", "\"bbox_mode\"", "]", ",", "BoxMode", ".", "XYXY_ABS", ")", "for", "obj", "in", "annos", "]", "\n", "target", "=", "Instances", "(", "image_size", ")", "\n", "target", ".", "gt_boxes", "=", "Boxes", "(", "boxes", ")", "\n", "\n", "classes", "=", "[", "int", "(", "obj", "[", "\"category_id\"", "]", ")", "for", "obj", "in", "annos", "]", "\n", "classes", "=", "torch", ".", "tensor", "(", "classes", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "target", ".", "gt_classes", "=", "classes", "\n", "\n", "if", "len", "(", "annos", ")", "and", "\"segmentation\"", "in", "annos", "[", "0", "]", ":", "\n", "        ", "segms", "=", "[", "obj", "[", "\"segmentation\"", "]", "for", "obj", "in", "annos", "]", "\n", "if", "mask_format", "==", "\"polygon\"", ":", "\n", "# TODO check type and provide better error", "\n", "            ", "masks", "=", "PolygonMasks", "(", "segms", ")", "\n", "", "else", ":", "\n", "            ", "assert", "mask_format", "==", "\"bitmask\"", ",", "mask_format", "\n", "masks", "=", "[", "]", "\n", "for", "segm", "in", "segms", ":", "\n", "                ", "if", "isinstance", "(", "segm", ",", "list", ")", ":", "\n", "# polygon", "\n", "                    ", "masks", ".", "append", "(", "polygons_to_bitmask", "(", "segm", ",", "*", "image_size", ")", ")", "\n", "", "elif", "isinstance", "(", "segm", ",", "dict", ")", ":", "\n", "# COCO RLE", "\n", "                    ", "masks", ".", "append", "(", "mask_util", ".", "decode", "(", "segm", ")", ")", "\n", "", "elif", "isinstance", "(", "segm", ",", "np", ".", "ndarray", ")", ":", "\n", "                    ", "assert", "segm", ".", "ndim", "==", "2", ",", "\"Expect segmentation of 2 dimensions, got {}.\"", ".", "format", "(", "\n", "segm", ".", "ndim", "\n", ")", "\n", "# mask array", "\n", "masks", ".", "append", "(", "segm", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"Cannot convert segmentation of type '{}' to BitMasks!\"", "\n", "\"Supported types are: polygons as list[list[float] or ndarray],\"", "\n", "\" COCO-style RLE as a dict, or a full-image segmentation mask \"", "\n", "\"as a 2D ndarray.\"", ".", "format", "(", "type", "(", "segm", ")", ")", "\n", ")", "\n", "# torch.from_numpy does not support array with negative stride.", "\n", "", "", "masks", "=", "BitMasks", "(", "\n", "torch", ".", "stack", "(", "[", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "x", ")", ")", "for", "x", "in", "masks", "]", ")", "\n", ")", "\n", "", "target", ".", "gt_masks", "=", "masks", "\n", "\n", "", "if", "len", "(", "annos", ")", "and", "\"keypoints\"", "in", "annos", "[", "0", "]", ":", "\n", "        ", "kpts", "=", "[", "obj", ".", "get", "(", "\"keypoints\"", ",", "[", "]", ")", "for", "obj", "in", "annos", "]", "\n", "target", ".", "gt_keypoints", "=", "Keypoints", "(", "kpts", ")", "\n", "\n", "", "return", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.annotations_to_instances_rotated": [[425, 452], ["detectron2.structures.Instances", "detectron2.structures.RotatedBoxes", "detectron2.structures.RotatedBoxes.clip", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "def", "annotations_to_instances_rotated", "(", "annos", ",", "image_size", ")", ":", "\n", "    ", "\"\"\"\n    Create an :class:`Instances` object used by the models,\n    from instance annotations in the dataset dict.\n    Compared to `annotations_to_instances`, this function is for rotated boxes only\n\n    Args:\n        annos (list[dict]): a list of instance annotations in one image, each\n            element for one instance.\n        image_size (tuple): height, width\n\n    Returns:\n        Instances:\n            Containing fields \"gt_boxes\", \"gt_classes\",\n            if they can be obtained from `annos`.\n            This is the format that builtin models expect.\n    \"\"\"", "\n", "boxes", "=", "[", "obj", "[", "\"bbox\"", "]", "for", "obj", "in", "annos", "]", "\n", "target", "=", "Instances", "(", "image_size", ")", "\n", "boxes", "=", "target", ".", "gt_boxes", "=", "RotatedBoxes", "(", "boxes", ")", "\n", "boxes", ".", "clip", "(", "image_size", ")", "\n", "\n", "classes", "=", "[", "obj", "[", "\"category_id\"", "]", "for", "obj", "in", "annos", "]", "\n", "classes", "=", "torch", ".", "tensor", "(", "classes", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "target", ".", "gt_classes", "=", "classes", "\n", "\n", "return", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.filter_empty_instances": [[454, 482], ["r.append", "instances.has", "r.append", "instances.gt_boxes.nonempty", "instances.gt_masks.nonempty"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty"], ["", "def", "filter_empty_instances", "(", "instances", ",", "by_box", "=", "True", ",", "by_mask", "=", "True", ",", "box_threshold", "=", "1e-5", ")", ":", "\n", "    ", "\"\"\"\n    Filter out empty instances in an `Instances` object.\n\n    Args:\n        instances (Instances):\n        by_box (bool): whether to filter out instances with empty boxes\n        by_mask (bool): whether to filter out instances with empty masks\n        box_threshold (float): minimum width and height to be considered non-empty\n\n    Returns:\n        Instances: the filtered instances.\n    \"\"\"", "\n", "assert", "by_box", "or", "by_mask", "\n", "r", "=", "[", "]", "\n", "if", "by_box", ":", "\n", "        ", "r", ".", "append", "(", "instances", ".", "gt_boxes", ".", "nonempty", "(", "threshold", "=", "box_threshold", ")", ")", "\n", "", "if", "instances", ".", "has", "(", "\"gt_masks\"", ")", "and", "by_mask", ":", "\n", "        ", "r", ".", "append", "(", "instances", ".", "gt_masks", ".", "nonempty", "(", ")", ")", "\n", "\n", "# TODO: can also filter visible keypoints", "\n", "\n", "", "if", "not", "r", ":", "\n", "        ", "return", "instances", "\n", "", "m", "=", "r", "[", "0", "]", "\n", "for", "x", "in", "r", "[", "1", ":", "]", ":", "\n", "        ", "m", "=", "m", "&", "x", "\n", "", "return", "instances", "[", "m", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.create_keypoint_hflip_indices": [[484, 504], ["detection_utils.check_metadata_consistency", "detection_utils.check_metadata_consistency", "catalog.MetadataCatalog.get", "dict", "dict.update", "numpy.asarray", "names.index", "dict.items"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.check_metadata_consistency", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.check_metadata_consistency", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "create_keypoint_hflip_indices", "(", "dataset_names", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        dataset_names (list[str]): list of dataset names\n    Returns:\n        ndarray[int]: a vector of size=#keypoints, storing the\n        horizontally-flipped keypoint indices.\n    \"\"\"", "\n", "\n", "check_metadata_consistency", "(", "\"keypoint_names\"", ",", "dataset_names", ")", "\n", "check_metadata_consistency", "(", "\"keypoint_flip_map\"", ",", "dataset_names", ")", "\n", "\n", "meta", "=", "MetadataCatalog", ".", "get", "(", "dataset_names", "[", "0", "]", ")", "\n", "names", "=", "meta", ".", "keypoint_names", "\n", "# TODO flip -> hflip", "\n", "flip_map", "=", "dict", "(", "meta", ".", "keypoint_flip_map", ")", "\n", "flip_map", ".", "update", "(", "{", "v", ":", "k", "for", "k", ",", "v", "in", "flip_map", ".", "items", "(", ")", "}", ")", "\n", "flipped_names", "=", "[", "i", "if", "i", "not", "in", "flip_map", "else", "flip_map", "[", "i", "]", "for", "i", "in", "names", "]", "\n", "flip_indices", "=", "[", "names", ".", "index", "(", "i", ")", "for", "i", "in", "flipped_names", "]", "\n", "return", "np", ".", "asarray", "(", "flip_indices", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.gen_crop_transform_with_instance": [[506, 534], ["numpy.asarray", "detectron2.structures.BoxMode.convert", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.random.randint", "numpy.random.randint", "transforms.CropTransform", "numpy.ceil().astype", "numpy.floor().astype", "numpy.asarray", "numpy.ceil", "numpy.floor"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "gen_crop_transform_with_instance", "(", "crop_size", ",", "image_size", ",", "instance", ")", ":", "\n", "    ", "\"\"\"\n    Generate a CropTransform so that the cropping region contains\n    the center of the given instance.\n\n    Args:\n        crop_size (tuple): h, w in pixels\n        image_size (tuple): h, w\n        instance (dict): an annotation dict of one instance, in Detectron2's\n            dataset format.\n    \"\"\"", "\n", "crop_size", "=", "np", ".", "asarray", "(", "crop_size", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "bbox", "=", "BoxMode", ".", "convert", "(", "instance", "[", "\"bbox\"", "]", ",", "instance", "[", "\"bbox_mode\"", "]", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "center_yx", "=", "(", "bbox", "[", "1", "]", "+", "bbox", "[", "3", "]", ")", "*", "0.5", ",", "(", "bbox", "[", "0", "]", "+", "bbox", "[", "2", "]", ")", "*", "0.5", "\n", "assert", "(", "\n", "image_size", "[", "0", "]", ">=", "center_yx", "[", "0", "]", "and", "image_size", "[", "1", "]", ">=", "center_yx", "[", "1", "]", "\n", ")", ",", "\"The annotation bounding box is outside of the image!\"", "\n", "assert", "(", "\n", "image_size", "[", "0", "]", ">=", "crop_size", "[", "0", "]", "and", "image_size", "[", "1", "]", ">=", "crop_size", "[", "1", "]", "\n", ")", ",", "\"Crop size is larger than image size!\"", "\n", "\n", "min_yx", "=", "np", ".", "maximum", "(", "np", ".", "floor", "(", "center_yx", ")", ".", "astype", "(", "np", ".", "int32", ")", "-", "crop_size", ",", "0", ")", "\n", "max_yx", "=", "np", ".", "maximum", "(", "np", ".", "asarray", "(", "image_size", ",", "dtype", "=", "np", ".", "int32", ")", "-", "crop_size", ",", "0", ")", "\n", "max_yx", "=", "np", ".", "minimum", "(", "max_yx", ",", "np", ".", "ceil", "(", "center_yx", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "\n", "y0", "=", "np", ".", "random", ".", "randint", "(", "min_yx", "[", "0", "]", ",", "max_yx", "[", "0", "]", "+", "1", ")", "\n", "x0", "=", "np", ".", "random", ".", "randint", "(", "min_yx", "[", "1", "]", ",", "max_yx", "[", "1", "]", "+", "1", ")", "\n", "return", "T", ".", "CropTransform", "(", "x0", ",", "y0", ",", "crop_size", "[", "1", "]", ",", "crop_size", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.check_metadata_consistency": [[536, 563], ["logging.getLogger", "enumerate", "len", "getattr", "catalog.MetadataCatalog.get", "logging.getLogger.error", "logging.getLogger.error", "ValueError", "str", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "check_metadata_consistency", "(", "key", ",", "dataset_names", ")", ":", "\n", "    ", "\"\"\"\n    Check that the datasets have consistent metadata.\n\n    Args:\n        key (str): a metadata key\n        dataset_names (list[str]): a list of dataset names\n\n    Raises:\n        AttributeError: if the key does not exist in the metadata\n        ValueError: if the given datasets do not have the same metadata values defined by key\n    \"\"\"", "\n", "if", "len", "(", "dataset_names", ")", "==", "0", ":", "\n", "        ", "return", "\n", "", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "entries_per_dataset", "=", "[", "getattr", "(", "MetadataCatalog", ".", "get", "(", "d", ")", ",", "key", ")", "for", "d", "in", "dataset_names", "]", "\n", "for", "idx", ",", "entry", "in", "enumerate", "(", "entries_per_dataset", ")", ":", "\n", "        ", "if", "entry", "!=", "entries_per_dataset", "[", "0", "]", ":", "\n", "            ", "logger", ".", "error", "(", "\n", "\"Metadata '{}' for dataset '{}' is '{}'\"", ".", "format", "(", "key", ",", "dataset_names", "[", "idx", "]", ",", "str", "(", "entry", ")", ")", "\n", ")", "\n", "logger", ".", "error", "(", "\n", "\"Metadata '{}' for dataset '{}' is '{}'\"", ".", "format", "(", "\n", "key", ",", "dataset_names", "[", "0", "]", ",", "str", "(", "entries_per_dataset", "[", "0", "]", ")", "\n", ")", "\n", ")", "\n", "raise", "ValueError", "(", "\"Datasets have different metadata '{}'!\"", ".", "format", "(", "key", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.build_augmentation": [[565, 590], ["transforms.ResizeShortestEdge", "augmentation.append", "transforms.RandomFlip"], "function", ["None"], ["", "", "", "def", "build_augmentation", "(", "cfg", ",", "is_train", ")", ":", "\n", "    ", "\"\"\"\n    Create a list of default :class:`Augmentation` from config.\n    Now it includes resizing and flipping.\n\n    Returns:\n        list[Augmentation]\n    \"\"\"", "\n", "if", "is_train", ":", "\n", "        ", "min_size", "=", "cfg", ".", "INPUT", ".", "MIN_SIZE_TRAIN", "\n", "max_size", "=", "cfg", ".", "INPUT", ".", "MAX_SIZE_TRAIN", "\n", "sample_style", "=", "cfg", ".", "INPUT", ".", "MIN_SIZE_TRAIN_SAMPLING", "\n", "", "else", ":", "\n", "        ", "min_size", "=", "cfg", ".", "INPUT", ".", "MIN_SIZE_TEST", "\n", "max_size", "=", "cfg", ".", "INPUT", ".", "MAX_SIZE_TEST", "\n", "sample_style", "=", "\"choice\"", "\n", "", "augmentation", "=", "[", "T", ".", "ResizeShortestEdge", "(", "min_size", ",", "max_size", ",", "sample_style", ")", "]", "\n", "if", "is_train", "and", "cfg", ".", "INPUT", ".", "RANDOM_FLIP", "!=", "\"none\"", ":", "\n", "        ", "augmentation", ".", "append", "(", "\n", "T", ".", "RandomFlip", "(", "\n", "horizontal", "=", "cfg", ".", "INPUT", ".", "RANDOM_FLIP", "==", "\"horizontal\"", ",", "\n", "vertical", "=", "cfg", ".", "INPUT", ".", "RANDOM_FLIP", "==", "\"vertical\"", ",", "\n", ")", "\n", ")", "\n", "", "return", "augmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._DatasetCatalog.register": [[29, 39], ["callable"], "methods", ["None"], ["\"FAIR/X-152-32x8d-IN5k\"", ":", "\"ImageNetPretrained/25093814/X-152-32x8d-IN5k.pkl\"", ",", "\n", "}", "\n", "\n", "C2_DETECTRON_PATH_FORMAT", "=", "(", "\n", "\"{prefix}/{url}/output/train/{dataset}/{type}/model_final.pkl\"", "# noqa B950", "\n", ")", "\n", "\n", "C2_DATASET_COCO", "=", "\"coco_2014_train%3Acoco_2014_valminusminival\"", "\n", "C2_DATASET_COCO_KEYPOINTS", "=", "\"keypoints_coco_2014_train%3Akeypoints_coco_2014_valminusminival\"", "\n", "\n", "# format: {model_name} -> part of the url", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._DatasetCatalog.get": [[40, 59], ["f", "KeyError", "catalog._DatasetCatalog.list"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["C2_DETECTRON_MODELS", "=", "{", "\n", "\"35857197/e2e_faster_rcnn_R-50-C4_1x\"", ":", "\"35857197/12_2017_baselines/e2e_faster_rcnn_R-50-C4_1x.yaml.01_33_49.iAX0mXvW\"", ",", "# noqa B950", "\n", "\"35857345/e2e_faster_rcnn_R-50-FPN_1x\"", ":", "\"35857345/12_2017_baselines/e2e_faster_rcnn_R-50-FPN_1x.yaml.01_36_30.cUF7QR7I\"", ",", "# noqa B950", "\n", "\"35857890/e2e_faster_rcnn_R-101-FPN_1x\"", ":", "\"35857890/12_2017_baselines/e2e_faster_rcnn_R-101-FPN_1x.yaml.01_38_50.sNxI7sX7\"", ",", "# noqa B950", "\n", "\"36761737/e2e_faster_rcnn_X-101-32x8d-FPN_1x\"", ":", "\"36761737/12_2017_baselines/e2e_faster_rcnn_X-101-32x8d-FPN_1x.yaml.06_31_39.5MIHi1fZ\"", ",", "# noqa B950", "\n", "\"35858791/e2e_mask_rcnn_R-50-C4_1x\"", ":", "\"35858791/12_2017_baselines/e2e_mask_rcnn_R-50-C4_1x.yaml.01_45_57.ZgkA7hPB\"", ",", "# noqa B950", "\n", "\"35858933/e2e_mask_rcnn_R-50-FPN_1x\"", ":", "\"35858933/12_2017_baselines/e2e_mask_rcnn_R-50-FPN_1x.yaml.01_48_14.DzEQe4wC\"", ",", "# noqa B950", "\n", "\"35861795/e2e_mask_rcnn_R-101-FPN_1x\"", ":", "\"35861795/12_2017_baselines/e2e_mask_rcnn_R-101-FPN_1x.yaml.02_31_37.KqyEK4tT\"", ",", "# noqa B950", "\n", "\"36761843/e2e_mask_rcnn_X-101-32x8d-FPN_1x\"", ":", "\"36761843/12_2017_baselines/e2e_mask_rcnn_X-101-32x8d-FPN_1x.yaml.06_35_59.RZotkLKI\"", ",", "# noqa B950", "\n", "\"48616381/e2e_mask_rcnn_R-50-FPN_2x_gn\"", ":", "\"GN/48616381/04_2018_gn_baselines/e2e_mask_rcnn_R-50-FPN_2x_gn_0416.13_23_38.bTlTI97Q\"", ",", "# noqa B950", "\n", "\"37697547/e2e_keypoint_rcnn_R-50-FPN_1x\"", ":", "\"37697547/12_2017_baselines/e2e_keypoint_rcnn_R-50-FPN_1x.yaml.08_42_54.kdzV35ao\"", ",", "# noqa B950", "\n", "\"35998355/rpn_R-50-C4_1x\"", ":", "\"35998355/12_2017_baselines/rpn_R-50-C4_1x.yaml.08_00_43.njH5oD9L\"", ",", "# noqa B950", "\n", "\"35998814/rpn_R-50-FPN_1x\"", ":", "\"35998814/12_2017_baselines/rpn_R-50-FPN_1x.yaml.08_06_03.Axg0r179\"", ",", "# noqa B950", "\n", "\"36225147/fast_R-50-FPN_1x\"", ":", "\"36225147/12_2017_baselines/fast_rcnn_R-50-FPN_1x.yaml.08_39_09.L3obSdQ2\"", ",", "# noqa B950", "\n", "}", "\n", "\n", "@", "staticmethod", "\n", "def", "get", "(", "name", ")", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "\"Caffe2Detectron/COCO\"", ")", ":", "\n", "            ", "return", "ModelCatalog", ".", "_get_c2_detectron_baseline", "(", "name", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._DatasetCatalog.list": [[60, 68], ["catalog._DatasetCatalog.list"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "if", "name", ".", "startswith", "(", "\"ImageNetPretrained/\"", ")", ":", "\n", "            ", "return", "ModelCatalog", ".", "_get_c2_imagenet_pretrained", "(", "name", ")", "\n", "", "raise", "RuntimeError", "(", "\"model not present in the catalog: {}\"", ".", "format", "(", "name", ")", ")", "\n", "\n", "", "@", "staticmethod", "\n", "def", "_get_c2_imagenet_pretrained", "(", "name", ")", ":", "\n", "        ", "prefix", "=", "ModelCatalog", ".", "S3_C2_DETECTRON_PREFIX", "\n", "name", "=", "name", "[", "len", "(", "\"ImageNetPretrained/\"", ")", ":", "]", "\n", "name", "=", "ModelCatalog", ".", "C2_IMAGENET_MODELS", "[", "name", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._DatasetCatalog.remove": [[69, 74], ["catalog._DatasetCatalog.pop"], "methods", ["None"], ["url", "=", "\"/\"", ".", "join", "(", "[", "prefix", ",", "name", "]", ")", "\n", "return", "url", "\n", "\n", "", "@", "staticmethod", "\n", "def", "_get_c2_detectron_baseline", "(", "name", ")", ":", "\n", "        ", "name", "=", "name", "[", "len", "(", "\"Caffe2Detectron/COCO/\"", ")", ":", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._DatasetCatalog.__str__": [[75, 77], ["catalog._DatasetCatalog.keys"], "methods", ["None"], ["url", "=", "ModelCatalog", ".", "C2_DETECTRON_MODELS", "[", "name", "]", "\n", "if", "\"keypoint_rcnn\"", "in", "name", ":", "\n", "            ", "dataset", "=", "ModelCatalog", ".", "C2_DATASET_COCO_KEYPOINTS", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.__getattr__": [[115, 133], ["detectron2.utils.logger.log_first_n", "getattr", "len", "AttributeError", "AttributeError", "str", "catalog.Metadata.__dict__.keys"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.log_first_n"], ["    ", "\"\"\"\n    Resolve anything that's in Detectron2 model zoo.\n    \"\"\"", "\n", "\n", "PREFIX", "=", "\"detectron2://\"", "\n", "S3_DETECTRON2_PREFIX", "=", "\"https://dl.fbaipublicfiles.com/detectron2/\"", "\n", "\n", "def", "_get_supported_prefixes", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "PREFIX", "]", "\n", "\n", "", "def", "_get_local_path", "(", "self", ",", "path", ")", ":", "\n", "        ", "name", "=", "path", "[", "len", "(", "self", ".", "PREFIX", ")", ":", "]", "\n", "return", "PathManager", ".", "get_local_path", "(", "self", ".", "S3_DETECTRON2_PREFIX", "+", "name", ")", "\n", "\n", "", "def", "_open", "(", "self", ",", "path", ",", "mode", "=", "\"r\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "PathManager", ".", "open", "(", "self", ".", "_get_local_path", "(", "path", ")", ",", "mode", ",", "**", "kwargs", ")", "\n", "\n", "\n", "", "", "PathManager", ".", "register_handler", "(", "ModelCatalogHandler", "(", ")", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.__setattr__": [[136, 154], ["detectron2.utils.logger.log_first_n", "setattr", "getattr", "types.SimpleNamespace.__setattr__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.log_first_n", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.__setattr__"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.as_dict": [[155, 161], ["copy.copy"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set": [[162, 169], ["kwargs.items", "setattr"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.get": [[170, 179], ["getattr"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get": [[194, 208], ["len", "super().get", "catalog.Metadata"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list": [[209, 217], ["catalog._MetadataCatalog.list"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove": [[218, 223], ["catalog._MetadataCatalog.pop"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.__str__": [[224, 226], ["catalog._MetadataCatalog.keys"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.filter_images_with_only_crowd_annotations": [[38, 67], ["len", "len", "logging.getLogger", "logging.getLogger.info", "build.filter_images_with_only_crowd_annotations.valid"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.filter_images_with_few_keypoints": [[69, 101], ["len", "len", "logging.getLogger", "logging.getLogger.info", "sum", "build.filter_images_with_few_keypoints.visible_keypoints_in_image"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.load_proposals_into_dataset": [[103, 155], ["logging.getLogger", "logging.getLogger.info", "set", "fvcore.common.file_io.PathManager.open", "pickle.load", "str", "detectron2.structures.BoxMode", "pickle.load.pop", "str", "enumerate", "objectness_logits.argsort", "str", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.print_instances_class_histogram": [[157, 202], ["len", "numpy.arange", "numpy.zeros", "min", "list", "sum", "itertools.zip_longest.extend", "itertools.zip_longest", "tabulate.tabulate", "detectron2.utils.logger.log_first_n", "logging.getLogger", "logging.getLogger.info", "itertools.chain", "itertools.zip_longest.extend", "numpy.histogram", "len", "len", "termcolor.colored", "str", "len", "x.get", "len", "range", "build.print_instances_class_histogram.short_name"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.log_first_n", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.get_detection_dataset_dicts": [[204, 263], ["len", "zip", "list", "len", "catalog.DatasetCatalog.get", "len", "itertools.chain.from_iterable", "build.filter_images_with_only_crowd_annotations", "build.filter_images_with_few_keypoints", "build.remove_prev_class_and_unk_instances", "len", "len", "build.load_proposals_into_dataset", "build.label_known_class_and_unknown", "detection_utils.check_metadata_consistency", "build.print_instances_class_histogram", "zip", "build.label_known_class_and_unknown", "catalog.MetadataCatalog.get", "build.remove_unknown_instances"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.filter_images_with_only_crowd_annotations", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.filter_images_with_few_keypoints", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.remove_prev_class_and_unk_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.load_proposals_into_dataset", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.label_known_class_and_unknown", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.check_metadata_consistency", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.print_instances_class_histogram", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.label_known_class_and_unknown", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.remove_unknown_instances"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.remove_prev_class_and_unk_instances": [[264, 283], ["range", "logging.getLogger", "logging.getLogger.info", "logging.getLogger.info", "copy.copy", "copy.copy", "str", "len", "dataset_dicts.remove", "annos.remove"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.remove_unknown_instances": [[284, 303], ["range", "logging.getLogger", "logging.getLogger.info", "logging.getLogger.info", "copy.copy", "copy.copy", "str", "len", "dataset_dicts.remove", "annos.remove"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.label_known_class_and_unknown": [[304, 324], ["range", "logging.getLogger", "logging.getLogger.info", "logging.getLogger.info", "str"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_batch_data_loader": [[325, 372], ["detectron2.utils.comm.get_world_size", "torch.utils.data.DataLoader", "common.AspectRatioGroupedDataset", "torch.utils.data.sampler.BatchSampler", "torch.utils.data.DataLoader", "operator.itemgetter"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader": [[310, 365], ["build._add_category_whitelists_to_metadata", "build._add_category_maps_to_metadata", "build.combine_detection_dataset_dicts", "detectron2.data.common.DatasetFromList", "detectron2.data.common.MapDataset", "logging.getLogger", "logging.getLogger.info", "detectron2.data.build.build_batch_data_loader", "dataset_mapper.DatasetMapper", "detectron2.data.samplers.TrainingSampler", "build._get_train_keep_instance_predicate", "len", "detectron2.data.samplers.RepeatFactorTrainingSampler.repeat_factors_from_category_frequency", "detectron2.data.samplers.RepeatFactorTrainingSampler", "ValueError"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._add_category_whitelists_to_metadata", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._add_category_maps_to_metadata", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.combine_detection_dataset_dicts", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_batch_data_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._get_train_keep_instance_predicate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.RepeatFactorTrainingSampler.repeat_factors_from_category_frequency"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_test_loader": [[368, 414], ["build._add_category_whitelists_to_metadata", "build._add_category_maps_to_metadata", "build.combine_detection_dataset_dicts", "detectron2.data.common.DatasetFromList", "detectron2.data.common.MapDataset", "detectron2.data.samplers.InferenceSampler", "torch.utils.data.sampler.BatchSampler", "torch.utils.data.DataLoader", "dataset_mapper.DatasetMapper", "len", "build._get_test_keep_instance_predicate", "list().index", "list"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._add_category_whitelists_to_metadata", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._add_category_maps_to_metadata", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.combine_detection_dataset_dicts", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._get_test_keep_instance_predicate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.trivial_batch_collator": [[480, 485], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.worker_init_reset_seed": [[487, 489], ["detectron2.utils.env.seed_all_rng", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.env.seed_all_rng"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.DatasetMapper.__init__": [[36, 73], ["dataset_mapper.build_augmentation", "detectron2.data.detection_utils.create_keypoint_hflip_indices", "fvcore.common.file_io.PathManager.get_local_path", "structures.DensePoseTransformData.load", "len", "detectron2.data.MetadataCatalog.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.build_augmentation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.create_keypoint_hflip_indices", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["\n", "@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "is_train", ":", "bool", ",", "\n", "*", ",", "\n", "augmentations", ":", "List", "[", "Union", "[", "T", ".", "Augmentation", ",", "T", ".", "Transform", "]", "]", ",", "\n", "image_format", ":", "str", ",", "\n", "use_instance_mask", ":", "bool", "=", "False", ",", "\n", "use_keypoint", ":", "bool", "=", "False", ",", "\n", "instance_mask_format", ":", "str", "=", "\"polygon\"", ",", "\n", "keypoint_hflip_indices", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "precomputed_proposal_topk", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "recompute_boxes", ":", "bool", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            is_train: whether it's used in training or inference\n            augmentations: a list of augmentations or deterministic transforms to apply\n            image_format: an image format supported by :func:`detection_utils.read_image`.\n            use_instance_mask: whether to process instance segmentation annotations, if available\n            use_keypoint: whether to process keypoint annotations if available\n            instance_mask_format: one of \"polygon\" or \"bitmask\". Process instance segmentation\n                masks into this format.\n            keypoint_hflip_indices: see :func:`detection_utils.create_keypoint_hflip_indices`\n            precomputed_proposal_topk: if given, will load pre-computed\n                proposals from dataset_dict and keep the top k proposals for each image.\n            recompute_boxes: whether to overwrite bounding box annotations\n                by computing tight bounding boxes from instance mask annotations.\n        \"\"\"", "\n", "if", "recompute_boxes", ":", "\n", "            ", "assert", "use_instance_mask", ",", "\"recompute_boxes requires instance masks\"", "\n", "# fmt: off", "\n", "", "self", ".", "is_train", "=", "is_train", "\n", "self", ".", "augmentations", "=", "T", ".", "AugmentationList", "(", "augmentations", ")", "\n", "self", ".", "image_format", "=", "image_format", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.DatasetMapper.from_config": [[84, 112], ["detection_utils.build_augmentation", "detection_utils.build_augmentation.insert", "detection_utils.create_keypoint_hflip_indices", "transforms.RandomCrop"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.build_augmentation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.create_keypoint_hflip_indices"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "is_train", ":", "bool", "=", "True", ")", ":", "\n", "        ", "augs", "=", "utils", ".", "build_augmentation", "(", "cfg", ",", "is_train", ")", "\n", "if", "cfg", ".", "INPUT", ".", "CROP", ".", "ENABLED", "and", "is_train", ":", "\n", "            ", "augs", ".", "insert", "(", "0", ",", "T", ".", "RandomCrop", "(", "cfg", ".", "INPUT", ".", "CROP", ".", "TYPE", ",", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", ")", ")", "\n", "recompute_boxes", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "", "else", ":", "\n", "            ", "recompute_boxes", "=", "False", "\n", "\n", "", "ret", "=", "{", "\n", "\"is_train\"", ":", "is_train", ",", "\n", "\"augmentations\"", ":", "augs", ",", "\n", "\"image_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "\"use_instance_mask\"", ":", "cfg", ".", "MODEL", ".", "MASK_ON", ",", "\n", "\"instance_mask_format\"", ":", "cfg", ".", "INPUT", ".", "MASK_FORMAT", ",", "\n", "\"use_keypoint\"", ":", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ",", "\n", "\"recompute_boxes\"", ":", "recompute_boxes", ",", "\n", "}", "\n", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "ret", "[", "\"keypoint_hflip_indices\"", "]", "=", "utils", ".", "create_keypoint_hflip_indices", "(", "cfg", ".", "DATASETS", ".", "TRAIN", ")", "\n", "\n", "", "if", "cfg", ".", "MODEL", ".", "LOAD_PROPOSALS", ":", "\n", "            ", "ret", "[", "\"precomputed_proposal_topk\"", "]", "=", "(", "\n", "cfg", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TRAIN", "\n", "if", "is_train", "\n", "else", "cfg", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TEST", "\n", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.DatasetMapper.__call__": [[74, 125], ["copy.deepcopy", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.check_image_size", "detectron2.data.transforms.apply_transform_gens", "torch.as_tensor", "detectron2.data.detection_utils.annotations_to_instances", "detectron2.data.detection_utils.read_image.transpose().astype", "copy.deepcopy.pop", "dataset_mapper.DatasetMapper._transform_densepose", "dataset_mapper.DatasetMapper._add_densepose_masks_as_segmentation", "obj.get", "structures.DensePoseList", "anno.pop", "anno.pop", "detectron2.data.detection_utils.transform_instance_annotations", "copy.deepcopy.pop", "all", "detectron2.data.detection_utils.annotations_to_instances.gt_boxes.nonempty", "detectron2.data.detection_utils.read_image.transpose", "obj.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.read_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.check_image_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.annotations_to_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.DatasetMapper._transform_densepose", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.DatasetMapper._add_densepose_masks_as_segmentation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_instance_annotations", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["self", ".", "use_instance_mask", "=", "use_instance_mask", "\n", "self", ".", "instance_mask_format", "=", "instance_mask_format", "\n", "self", ".", "use_keypoint", "=", "use_keypoint", "\n", "self", ".", "keypoint_hflip_indices", "=", "keypoint_hflip_indices", "\n", "self", ".", "proposal_topk", "=", "precomputed_proposal_topk", "\n", "self", ".", "recompute_boxes", "=", "recompute_boxes", "\n", "# fmt: on", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Augmentations used in training: \"", "+", "str", "(", "augmentations", ")", ")", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "is_train", ":", "bool", "=", "True", ")", ":", "\n", "        ", "augs", "=", "utils", ".", "build_augmentation", "(", "cfg", ",", "is_train", ")", "\n", "if", "cfg", ".", "INPUT", ".", "CROP", ".", "ENABLED", "and", "is_train", ":", "\n", "            ", "augs", ".", "insert", "(", "0", ",", "T", ".", "RandomCrop", "(", "cfg", ".", "INPUT", ".", "CROP", ".", "TYPE", ",", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", ")", ")", "\n", "recompute_boxes", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "", "else", ":", "\n", "            ", "recompute_boxes", "=", "False", "\n", "\n", "", "ret", "=", "{", "\n", "\"is_train\"", ":", "is_train", ",", "\n", "\"augmentations\"", ":", "augs", ",", "\n", "\"image_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "\"use_instance_mask\"", ":", "cfg", ".", "MODEL", ".", "MASK_ON", ",", "\n", "\"instance_mask_format\"", ":", "cfg", ".", "INPUT", ".", "MASK_FORMAT", ",", "\n", "\"use_keypoint\"", ":", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ",", "\n", "\"recompute_boxes\"", ":", "recompute_boxes", ",", "\n", "}", "\n", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "ret", "[", "\"keypoint_hflip_indices\"", "]", "=", "utils", ".", "create_keypoint_hflip_indices", "(", "cfg", ".", "DATASETS", ".", "TRAIN", ")", "\n", "\n", "", "if", "cfg", ".", "MODEL", ".", "LOAD_PROPOSALS", ":", "\n", "            ", "ret", "[", "\"precomputed_proposal_topk\"", "]", "=", "(", "\n", "cfg", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TRAIN", "\n", "if", "is_train", "\n", "else", "cfg", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TEST", "\n", ")", "\n", "", "return", "ret", "\n", "\n", "", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_dict (dict): Metadata of one image, in Detectron2 Dataset format.\n\n        Returns:\n            dict: a format that builtin models in detectron2 accept\n        \"\"\"", "\n", "dataset_dict", "=", "copy", ".", "deepcopy", "(", "dataset_dict", ")", "# it will be modified by code below", "\n", "# USER: Write your own image loading if it's not from a file", "\n", "image", "=", "utils", ".", "read_image", "(", "dataset_dict", "[", "\"file_name\"", "]", ",", "format", "=", "self", ".", "image_format", ")", "\n", "utils", ".", "check_image_size", "(", "dataset_dict", ",", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.combined_loader.CombinedDataLoader.__init__": [[23, 27], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "loaders", ":", "Collection", "[", "Loader", "]", ",", "batch_size", ":", "int", ",", "ratios", ":", "Sequence", "[", "float", "]", ")", ":", "\n", "        ", "self", ".", "loaders", "=", "loaders", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "ratios", "=", "ratios", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.combined_loader.CombinedDataLoader.__iter__": [[28, 45], ["iter", "len", "collections.deque", "random.choices", "range", "combined_loader._pooled_next", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.combined_loader._pooled_next"], ["", "def", "__iter__", "(", "self", ")", "->", "Iterator", "[", "List", "[", "Any", "]", "]", ":", "\n", "        ", "iters", "=", "[", "iter", "(", "loader", ")", "for", "loader", "in", "self", ".", "loaders", "]", "\n", "indices", "=", "[", "]", "\n", "pool", "=", "[", "deque", "(", ")", "]", "*", "len", "(", "iters", ")", "\n", "# infinite iterator, as in D2", "\n", "while", "True", ":", "\n", "            ", "if", "not", "indices", ":", "\n", "# just a buffer of indices, its size doesn't matter", "\n", "# as long as it's a multiple of batch_size", "\n", "                ", "k", "=", "self", ".", "batch_size", "*", "self", ".", "BATCH_COUNT", "\n", "indices", "=", "random", ".", "choices", "(", "range", "(", "len", "(", "self", ".", "loaders", ")", ")", ",", "self", ".", "ratios", ",", "k", "=", "k", ")", "\n", "", "try", ":", "\n", "                ", "batch", "=", "[", "_pooled_next", "(", "iters", "[", "i", "]", ",", "pool", "[", "i", "]", ")", "for", "i", "in", "indices", "[", ":", "self", ".", "batch_size", "]", "]", "\n", "", "except", "StopIteration", ":", "\n", "                ", "break", "\n", "", "indices", "=", "indices", "[", "self", ".", "batch_size", ":", "]", "\n", "yield", "batch", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.combined_loader._pooled_next": [[10, 14], ["pool.popleft", "pool.extend", "next"], "function", ["None"], ["def", "_pooled_next", "(", "iterator", ":", "Iterator", "[", "Any", "]", ",", "pool", ":", "Deque", "[", "Any", "]", ")", ":", "\n", "    ", "if", "not", "pool", ":", "\n", "        ", "pool", ".", "extend", "(", "next", "(", "iterator", ")", ")", "\n", "", "return", "pool", ".", "popleft", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.image_list_dataset.ImageListDataset.__init__": [[22, 29], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "image_list", ":", "List", "[", "str", "]", ",", "transform", ":", "Optional", "[", "ImageTransform", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image_list (List[str]): list of paths to image files\n        \"\"\"", "\n", "self", ".", "image_list", "=", "image_list", "\n", "self", ".", "transform", "=", "transform", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.image_list_dataset.ImageListDataset.__getitem__": [[30, 51], ["torch.from_numpy", "numpy.ascontiguousarray", "logging.getLogger", "logging.getLogger.warning", "detectron2.data.detection_utils.read_image", "image_list_dataset.ImageListDataset.transform", "torch.from_numpy.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.read_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugInput.transform"], ["", "def", "__getitem__", "(", "self", ",", "idx", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Gets selected images from the list\n\n        Args:\n            idx (int): video index in the video list file\n        Returns:\n            image (torch.Tensor): tensor of size [H, W, 3]\n        \"\"\"", "\n", "fpath", "=", "self", ".", "image_list", "[", "idx", "]", "\n", "\n", "try", ":", "\n", "            ", "image", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "read_image", "(", "fpath", ",", "format", "=", "\"BGR\"", ")", ")", ")", "\n", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "                ", "image", "=", "self", ".", "transform", "(", "image", ".", "unsqueeze", "(", "0", ")", ")", "[", "0", "]", "# Transforms are done on batches", "\n", "", "return", "image", "\n", "", "except", "(", "OSError", ",", "RuntimeError", ")", "as", "e", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "f\"Error opening image file container {fpath}: {e}\"", ")", "\n", "\n", "", "return", "self", ".", "_EMPTY_IMAGE", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.image_list_dataset.ImageListDataset.__len__": [[52, 54], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "image_list", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register": [[592, 601], ["datasets.dataset_type.DatasetType.VIDEO_LIST", "build.build_video_list_dataset"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_video_list_dataset"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._compute_num_images_per_worker": [[54, 69], ["detectron2.utils.comm.get_world_size"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._map_category_id_to_contiguous_id": [[71, 76], ["detectron2.data.catalog.MetadataCatalog.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._add_category_id_to_contiguous_id_maps_to_metadata": [[78, 109], ["enumerate", "detectron2.data.catalog.MetadataCatalog.get", "MetadataCatalog.get.categories.items", "sorted", "detectron2.data.catalog.MetadataCatalog.get", "MetadataCatalog.get.get", "merged_categories.keys", "ValueError", "sorted", "sorted", "sorted", "meta.get.keys", "meta.get.keys", "meta.get.keys"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_create_general_keep_instance_predicate": [[112, 128], ["build._maybe_create_general_keep_instance_predicate.has_annotations"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_create_keypoints_keep_instance_predicate": [[130, 145], ["sum", "numpy.array"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_create_mask_keep_instance_predicate": [[147, 155], ["any"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_create_densepose_keep_instance_predicate": [[157, 174], ["all"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_create_specific_keep_instance_predicate": [[176, 191], ["creator", "any", "p"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._get_train_keep_instance_predicate": [[193, 207], ["build._maybe_create_general_keep_instance_predicate", "build._maybe_create_specific_keep_instance_predicate", "_maybe_create_general_keep_instance_predicate.", "_maybe_create_specific_keep_instance_predicate."], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_create_general_keep_instance_predicate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_create_specific_keep_instance_predicate"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._get_test_keep_instance_predicate": [[209, 212], ["build._maybe_create_general_keep_instance_predicate"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_create_general_keep_instance_predicate"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_filter_and_map_categories": [[214, 234], ["detectron2.data.catalog.MetadataCatalog.get", "MetadataCatalog.get.get", "MetadataCatalog.get.get", "filtered_dataset_dicts.append", "meta.get.get", "anns.append"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._add_category_whitelists_to_metadata": [[236, 244], ["cfg.DATASETS.WHITELISTED_CATEGORIES.items", "detectron2.data.catalog.MetadataCatalog.get", "logging.getLogger", "logging.getLogger.info"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._add_category_maps_to_metadata": [[248, 257], ["cfg.DATASETS.CATEGORY_MAPS.items", "detectron2.data.catalog.MetadataCatalog.get", "logging.getLogger", "logging.getLogger.info", "int", "int", "category_map.items"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.combine_detection_dataset_dicts": [[259, 308], ["len", "build._add_category_id_to_contiguous_id_maps_to_metadata", "zip", "len", "len", "detectron2.data.catalog.DatasetCatalog.get", "len", "build._maybe_filter_and_map_categories", "build._map_category_id_to_contiguous_id", "detectron2.data.build.print_instances_class_histogram", "all_datasets_dicts.append", "list", "len", "detectron2.data.build.load_proposals_into_dataset", "itertools.chain.from_iterable", "detectron2.data.catalog.MetadataCatalog.get", "itertools.chain.from_iterable", "keep_instance_predicate"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._add_category_id_to_contiguous_id_maps_to_metadata", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._maybe_filter_and_map_categories", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._map_category_id_to_contiguous_id", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.print_instances_class_histogram", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.load_proposals_into_dataset", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_frame_selector": [[416, 427], ["video.FrameSelectionStrategy", "video.RandomKFramesSelector", "video.FirstKFramesSelector", "video.LastKFramesSelector"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_transform": [[429, 434], ["ValueError", "transform.ImageResizeTransform"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_combined_loader": [[436, 439], ["build._compute_num_images_per_worker", "combined_loader.CombinedDataLoader"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._compute_num_images_per_worker"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_bootstrap_dataset": [[441, 462], ["logging.getLogger", "detectron2.data.catalog.MetadataCatalog.get", "BootstrapDatasetFactoryCatalog.get", "BootstrapDatasetFactoryCatalog.get.", "logging.getLogger.warning"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_data_sampler": [[464, 519], ["ValueError", "samplers.PredictionToGroundTruthSampler", "samplers.PredictionToGroundTruthSampler.register_sampler", "samplers.PredictionToGroundTruthSampler.register_sampler", "samplers.DensePoseUniformSampler", "samplers.MaskFromDensePoseSampler", "samplers.PredictionToGroundTruthSampler", "samplers.PredictionToGroundTruthSampler.register_sampler", "samplers.PredictionToGroundTruthSampler.register_sampler", "samplers.DensePoseConfidenceBasedSampler", "samplers.MaskFromDensePoseSampler", "samplers.PredictionToGroundTruthSampler", "samplers.PredictionToGroundTruthSampler.register_sampler", "samplers.PredictionToGroundTruthSampler.register_sampler", "samplers.DensePoseConfidenceBasedSampler", "samplers.MaskFromDensePoseSampler", "samplers.PredictionToGroundTruthSampler", "samplers.PredictionToGroundTruthSampler.register_sampler", "samplers.PredictionToGroundTruthSampler.register_sampler", "samplers.DensePoseConfidenceBasedSampler", "samplers.MaskFromDensePoseSampler"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_data_filter": [[521, 526], ["ValueError", "inference_based_loader.ScoreBasedFilter"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_inference_based_loader": [[528, 551], ["build.build_bootstrap_dataset", "detectron2.data.samplers.TrainingSampler", "torch.utils.data.DataLoader", "inference_based_loader.InferenceBasedLoader", "len", "build.build_data_sampler", "build.build_data_filter"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_bootstrap_dataset", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_data_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_data_filter"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.has_inference_based_loaders": [[554, 560], ["len"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_inference_based_loaders": [[562, 574], ["densepose.config.get_bootstrap_dataset_config().clone", "get_bootstrap_dataset_config().clone.merge_from_other_cfg", "build.build_inference_based_loader", "loaders.append", "ratios.append", "detectron2.config.CfgNode", "densepose.config.get_bootstrap_dataset_config"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_inference_based_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.get_bootstrap_dataset_config"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_video_list_dataset": [[576, 584], ["build.build_frame_selector", "build.build_transform", "video.video_list_from_file", "video.VideoKeyframeDataset"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_frame_selector", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_transform", "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.video_keyframe_dataset.video_list_from_file"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.DatasetMapper._transform_densepose": [[126, 144], ["structures.DensePoseDataRelative.validate_annotation", "structures.DensePoseDataRelative", "structures.DensePoseDataRelative.apply_transform", "structures.DensePoseDataRelative.cleanup_annotation"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.validate_annotation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.apply_transform", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.cleanup_annotation"], ["# USER: Remove if you don't do semantic/panoptic segmentation.", "\n", "if", "\"sem_seg_file_name\"", "in", "dataset_dict", ":", "\n", "            ", "sem_seg_gt", "=", "utils", ".", "read_image", "(", "dataset_dict", ".", "pop", "(", "\"sem_seg_file_name\"", ")", ",", "\"L\"", ")", ".", "squeeze", "(", "2", ")", "\n", "", "else", ":", "\n", "            ", "sem_seg_gt", "=", "None", "\n", "\n", "", "aug_input", "=", "T", ".", "AugInput", "(", "image", ",", "sem_seg", "=", "sem_seg_gt", ")", "\n", "transforms", "=", "self", ".", "augmentations", "(", "aug_input", ")", "\n", "image", ",", "sem_seg_gt", "=", "aug_input", ".", "image", ",", "aug_input", ".", "sem_seg", "\n", "\n", "image_shape", "=", "image", ".", "shape", "[", ":", "2", "]", "# h, w", "\n", "# Pytorch's dataloader is efficient on torch.Tensor due to shared-memory,", "\n", "# but not efficient on large generic data structures due to the use of pickle & mp.Queue.", "\n", "# Therefore it's important to use torch.Tensor.", "\n", "dataset_dict", "[", "\"image\"", "]", "=", "torch", ".", "as_tensor", "(", "np", ".", "ascontiguousarray", "(", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "            ", "dataset_dict", "[", "\"sem_seg\"", "]", "=", "torch", ".", "as_tensor", "(", "sem_seg_gt", ".", "astype", "(", "\"long\"", ")", ")", "\n", "\n", "# USER: Remove if you don't use pre-computed proposals.", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.DatasetMapper._add_densepose_masks_as_segmentation": [[145, 169], ["torch.zeros_like", "torch.tensor", "detectron2.layers.ROIAlign().forward().squeeze", "torch.zeros", "v.item", "detectron2.structures.BoxMode.convert", "detectron2.layers.ROIAlign().forward", "torch.zeros_like.view", "detectron2.layers.ROIAlign"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward"], ["# Most users would not need this feature.", "\n", "", "if", "self", ".", "proposal_topk", "is", "not", "None", ":", "\n", "            ", "utils", ".", "transform_proposals", "(", "\n", "dataset_dict", ",", "image_shape", ",", "transforms", ",", "proposal_topk", "=", "self", ".", "proposal_topk", "\n", ")", "\n", "\n", "", "if", "not", "self", ".", "is_train", ":", "\n", "# USER: Modify this if you want to keep them for some reason.", "\n", "            ", "dataset_dict", ".", "pop", "(", "\"annotations\"", ",", "None", ")", "\n", "dataset_dict", ".", "pop", "(", "\"sem_seg_file_name\"", ",", "None", ")", "\n", "return", "dataset_dict", "\n", "\n", "", "if", "\"annotations\"", "in", "dataset_dict", ":", "\n", "# USER: Modify this if you want to keep them for some reason.", "\n", "            ", "for", "anno", "in", "dataset_dict", "[", "\"annotations\"", "]", ":", "\n", "                ", "if", "not", "self", ".", "use_instance_mask", ":", "\n", "                    ", "anno", ".", "pop", "(", "\"segmentation\"", ",", "None", ")", "\n", "", "if", "not", "self", ".", "use_keypoint", ":", "\n", "                    ", "anno", ".", "pop", "(", "\"keypoints\"", ",", "None", ")", "\n", "\n", "# USER: Implement additional transformations if you have other types of data", "\n", "", "", "annos", "=", "[", "\n", "utils", ".", "transform_instance_annotations", "(", "\n", "obj", ",", "transforms", ",", "image_shape", ",", "keypoint_hflip_indices", "=", "self", ".", "keypoint_hflip_indices", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.build_augmentation": [[19, 29], ["logging.getLogger", "detectron2.data.detection_utils.build_augmentation", "detectron2.data.transforms.RandomRotation", "utils.build_augmentation.append", "logging.getLogger.info", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.build_augmentation"], ["\n", "class", "DatasetMapper", ":", "\n", "    "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.inference_based_loader.ScoreBasedFilter.__init__": [[39, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "min_score", ":", "float", "=", "0.8", ")", ":", "\n", "        ", "self", ".", "min_score", "=", "min_score", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.inference_based_loader.ScoreBasedFilter.__call__": [[42, 50], ["instances.has"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has"], ["", "def", "__call__", "(", "self", ",", "model_output", ":", "ModelOutput", ")", "->", "ModelOutput", ":", "\n", "        ", "for", "model_output_i", "in", "model_output", ":", "\n", "            ", "instances", "=", "model_output_i", "[", "\"instances\"", "]", "\n", "if", "not", "instances", ".", "has", "(", "\"scores\"", ")", ":", "\n", "                ", "continue", "\n", "", "instances_filtered", "=", "instances", "[", "instances", ".", "scores", ">=", "self", ".", "min_score", "]", "\n", "model_output_i", "[", "\"instances\"", "]", "=", "instances_filtered", "\n", "", "return", "model_output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.inference_based_loader.InferenceBasedLoader.__init__": [[60, 98], ["inference_based_loader.InferenceBasedLoader.model.eval"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "nn", ".", "Module", ",", "\n", "data_loader", ":", "Iterable", "[", "List", "[", "torch", ".", "Tensor", "]", "]", ",", "\n", "data_sampler", ":", "Optional", "[", "Callable", "[", "[", "ModelOutput", "]", ",", "List", "[", "SampledData", "]", "]", "]", "=", "None", ",", "\n", "data_filter", ":", "Optional", "[", "Callable", "[", "[", "ModelOutput", "]", ",", "ModelOutput", "]", "]", "=", "None", ",", "\n", "shuffle", ":", "bool", "=", "True", ",", "\n", "batch_size", ":", "int", "=", "4", ",", "\n", "inference_batch_size", ":", "int", "=", "4", ",", "\n", "drop_last", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Constructor\n\n        Args:\n          model (torch.nn.Module): model used to produce data\n          data_loader (Iterable[Tensor]): iterable that provides images\n              to perform inference on\n          data_sampler (Callable: ModelOutput -> SampledData): functor\n              that produces annotation data from inference results;\n              (optional, default: None)\n          data_filter (Callable: ModelOutput -> ModelOutput): filter\n              that selects model outputs for for further processing\n              (optional, default: None)\n          shuffle (bool): if True, the input images get shuffled\n          batch_size (int): batch size for the produced annotation data\n          inference_batch_size (int): batch size for input images\n          drop_last (bool): if True, drop the last batch if it is undersized\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "data_loader", "=", "data_loader", "\n", "self", ".", "data_sampler", "=", "data_sampler", "\n", "self", ".", "data_filter", "=", "data_filter", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "inference_batch_size", "=", "inference_batch_size", "\n", "self", ".", "drop_last", "=", "drop_last", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.inference_based_loader.InferenceBasedLoader.__iter__": [[99, 110], ["random.shuffle", "inference_based_loader.InferenceBasedLoader._produce_data"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.inference_based_loader.InferenceBasedLoader._produce_data"], ["", "def", "__iter__", "(", "self", ")", "->", "Iterator", "[", "List", "[", "SampledData", "]", "]", ":", "\n", "        ", "for", "batch", "in", "self", ".", "data_loader", ":", "\n", "# batch : List[Tensor[N, C, H, W]]", "\n", "# images_batch : Tensor[N, C, H, W]", "\n", "# image : Tensor[C, H, W]", "\n", "            ", "images", "=", "[", "image", "for", "images_batch", "in", "batch", "for", "image", "in", "images_batch", "]", "\n", "if", "not", "images", ":", "\n", "                ", "continue", "\n", "", "if", "self", ".", "shuffle", ":", "\n", "                ", "random", ".", "shuffle", "(", "images", ")", "\n", "", "yield", "from", "self", ".", "_produce_data", "(", "images", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.inference_based_loader.InferenceBasedLoader._produce_data": [[111, 147], ["inference_based_loader._grouper", "zip", "torch.no_grad", "inference_based_loader.InferenceBasedLoader.model", "inference_based_loader.InferenceBasedLoader.data_filter", "inference_based_loader.InferenceBasedLoader.data_sampler", "len", "len", "img.to", "data_batches.append"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_combine_data_loader._grouper", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "", "def", "_produce_data", "(", "self", ",", "images", ":", "List", "[", "torch", ".", "Tensor", "]", ")", "->", "Iterator", "[", "List", "[", "SampledData", "]", "]", ":", "\n", "        ", "\"\"\"\n        Produce batches of data from images\n\n        Args:\n          images (List[Tensor]): list of images to process\n\n        Returns:\n          Iterator over batches of data sampled from model outputs\n        \"\"\"", "\n", "data_batches", ":", "List", "[", "SampledData", "]", "=", "[", "]", "\n", "batched_images", "=", "_grouper", "(", "images", ",", "self", ".", "inference_batch_size", ")", "\n", "for", "batch", "in", "batched_images", ":", "\n", "            ", "batch", "=", "[", "{", "\"image\"", ":", "img", ".", "to", "(", "self", ".", "model", ".", "device", ")", "}", "for", "img", "in", "batch", "if", "img", "is", "not", "None", "]", "\n", "if", "not", "batch", ":", "\n", "                ", "continue", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "model_output", "=", "self", ".", "model", "(", "batch", ")", "\n", "", "for", "model_output_i", ",", "batch_i", "in", "zip", "(", "model_output", ",", "batch", ")", ":", "\n", "                ", "model_output_i", "[", "\"image\"", "]", "=", "batch_i", "[", "\"image\"", "]", "\n", "", "model_output_filtered", "=", "(", "\n", "model_output", "if", "self", ".", "data_filter", "is", "None", "else", "self", ".", "data_filter", "(", "model_output", ")", "\n", ")", "\n", "data", "=", "(", "\n", "model_output_filtered", "\n", "if", "self", ".", "data_sampler", "is", "None", "\n", "else", "self", ".", "data_sampler", "(", "model_output_filtered", ")", "\n", ")", "\n", "for", "data_i", "in", "data", ":", "\n", "                ", "if", "len", "(", "data_i", "[", "\"instances\"", "]", ")", ":", "\n", "                    ", "data_batches", ".", "append", "(", "data_i", ")", "\n", "", "", "if", "len", "(", "data_batches", ")", ">=", "self", ".", "batch_size", ":", "\n", "                ", "yield", "data_batches", "[", ":", "self", ".", "batch_size", "]", "\n", "data_batches", "=", "data_batches", "[", "self", ".", "batch_size", ":", "]", "\n", "", "", "if", "not", "self", ".", "drop_last", "and", "data_batches", ":", "\n", "            ", "yield", "data_batches", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.inference_based_loader._grouper": [[12, 31], ["iter", "range", "values.append", "tuple", "next", "values.extend", "tuple", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter"], ["def", "_grouper", "(", "iterable", ":", "Iterable", "[", "Any", "]", ",", "n", ":", "int", ",", "fillvalue", "=", "None", ")", "->", "Iterator", "[", "Tuple", "[", "Any", "]", "]", ":", "\n", "    ", "\"\"\"\n    Group elements of an iterable by chunks of size `n`, e.g.\n    grouper(range(9), 4) ->\n        (0, 1, 2, 3), (4, 5, 6, 7), (8, None, None, None)\n    \"\"\"", "\n", "it", "=", "iter", "(", "iterable", ")", "\n", "while", "True", ":", "\n", "        ", "values", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "value", "=", "next", "(", "it", ")", "\n", "", "except", "StopIteration", ":", "\n", "                ", "if", "values", ":", "\n", "                    ", "values", ".", "extend", "(", "[", "fillvalue", "]", "*", "(", "n", "-", "len", "(", "values", ")", ")", ")", "\n", "yield", "tuple", "(", "values", ")", "\n", "", "return", "\n", "", "values", ".", "append", "(", "value", ")", "\n", "", "yield", "tuple", "(", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.__init__": [[19, 24], ["torch.device"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["def", "__init__", "(", "self", ",", "uv_symmetries", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "device", ":", "torch", ".", "device", ")", ":", "\n", "        ", "self", ".", "mask_label_symmetries", "=", "DensePoseTransformData", ".", "MASK_LABEL_SYMMETRIES", "\n", "self", ".", "point_label_symmetries", "=", "DensePoseTransformData", ".", "POINT_LABEL_SYMMETRIES", "\n", "self", ".", "uv_symmetries", "=", "uv_symmetries", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.to": [[25, 42], ["structures.DensePoseTransformData", "structures.DensePoseTransformData.uv_symmetries[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "to", "(", "self", ",", "device", ":", "torch", ".", "device", ",", "copy", ":", "bool", "=", "False", ")", "->", "\"DensePoseTransformData\"", ":", "\n", "        ", "\"\"\"\n        Convert transform data to the specified device\n\n        Args:\n            device (torch.device): device to convert the data to\n            copy (bool): flag that specifies whether to copy or to reference the data\n                in case the device is the same\n        Return:\n            An instance of `DensePoseTransformData` with data stored on the specified device\n        \"\"\"", "\n", "if", "self", ".", "device", "==", "device", "and", "not", "copy", ":", "\n", "            ", "return", "self", "\n", "", "uv_symmetry_map", "=", "{", "}", "\n", "for", "key", "in", "self", ".", "uv_symmetries", ":", "\n", "            ", "uv_symmetry_map", "[", "key", "]", "=", "self", ".", "uv_symmetries", "[", "key", "]", ".", "to", "(", "device", "=", "device", ",", "copy", "=", "copy", ")", "\n", "", "return", "DensePoseTransformData", "(", "uv_symmetry_map", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load": [[43, 64], ["scipy.io.loadmat", "structures.DensePoseTransformData", "range", "torch.stack", "map_dst.append", "torch.device", "torch.from_numpy().to", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "@", "staticmethod", "\n", "def", "load", "(", "io", ":", "Union", "[", "str", ",", "BinaryIO", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            io: (str or binary file-like object): input file to load data from\n        Returns:\n            An instance of `DensePoseTransformData` with transforms loaded from the file\n        \"\"\"", "\n", "import", "scipy", ".", "io", "\n", "\n", "uv_symmetry_map", "=", "scipy", ".", "io", ".", "loadmat", "(", "io", ")", "\n", "uv_symmetry_map_torch", "=", "{", "}", "\n", "for", "key", "in", "[", "\"U_transforms\"", ",", "\"V_transforms\"", "]", ":", "\n", "            ", "uv_symmetry_map_torch", "[", "key", "]", "=", "[", "]", "\n", "map_src", "=", "uv_symmetry_map", "[", "key", "]", "\n", "map_dst", "=", "uv_symmetry_map_torch", "[", "key", "]", "\n", "for", "i", "in", "range", "(", "map_src", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "map_dst", ".", "append", "(", "torch", ".", "from_numpy", "(", "map_src", "[", "0", ",", "i", "]", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", ")", "\n", "", "uv_symmetry_map_torch", "[", "key", "]", "=", "torch", ".", "stack", "(", "map_dst", ",", "dim", "=", "0", ")", "\n", "", "transform_data", "=", "DensePoseTransformData", "(", "uv_symmetry_map_torch", ",", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "return", "transform_data", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.__init__": [[101, 113], ["structures.DensePoseDataRelative.validate_annotation", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "structures.DensePoseDataRelative.extract_segmentation_mask", "torch.device", "structures.DensePoseDataRelative.cleanup_annotation"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.validate_annotation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.extract_segmentation_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.cleanup_annotation"], ["def", "__init__", "(", "self", ",", "annotation", ",", "cleanup", "=", "False", ")", ":", "\n", "        ", "is_valid", ",", "reason_not_valid", "=", "DensePoseDataRelative", ".", "validate_annotation", "(", "annotation", ")", "\n", "assert", "is_valid", ",", "\"Invalid DensePose annotations: {}\"", ".", "format", "(", "reason_not_valid", ")", "\n", "self", ".", "x", "=", "torch", ".", "as_tensor", "(", "annotation", "[", "DensePoseDataRelative", ".", "X_KEY", "]", ")", "\n", "self", ".", "y", "=", "torch", ".", "as_tensor", "(", "annotation", "[", "DensePoseDataRelative", ".", "Y_KEY", "]", ")", "\n", "self", ".", "i", "=", "torch", ".", "as_tensor", "(", "annotation", "[", "DensePoseDataRelative", ".", "I_KEY", "]", ")", "\n", "self", ".", "u", "=", "torch", ".", "as_tensor", "(", "annotation", "[", "DensePoseDataRelative", ".", "U_KEY", "]", ")", "\n", "self", ".", "v", "=", "torch", ".", "as_tensor", "(", "annotation", "[", "DensePoseDataRelative", ".", "V_KEY", "]", ")", "\n", "self", ".", "segm", "=", "DensePoseDataRelative", ".", "extract_segmentation_mask", "(", "annotation", ")", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "if", "cleanup", ":", "\n", "            ", "DensePoseDataRelative", ".", "cleanup_annotation", "(", "annotation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.to": [[114, 127], ["object.__new__", "structures.DensePoseDataRelative.x.to", "structures.DensePoseDataRelative.y.to", "structures.DensePoseDataRelative.i.to", "structures.DensePoseDataRelative.u.to", "structures.DensePoseDataRelative.v.to", "structures.DensePoseDataRelative.segm.to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.shape_spec.ShapeSpec.__new__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "if", "self", ".", "device", "==", "device", ":", "\n", "            ", "return", "self", "\n", "", "new_data", "=", "DensePoseDataRelative", ".", "__new__", "(", "DensePoseDataRelative", ")", "\n", "new_data", ".", "x", "=", "self", ".", "x", "\n", "new_data", ".", "x", "=", "self", ".", "x", ".", "to", "(", "device", ")", "\n", "new_data", ".", "y", "=", "self", ".", "y", ".", "to", "(", "device", ")", "\n", "new_data", ".", "i", "=", "self", ".", "i", ".", "to", "(", "device", ")", "\n", "new_data", ".", "u", "=", "self", ".", "u", ".", "to", "(", "device", ")", "\n", "new_data", ".", "v", "=", "self", ".", "v", ".", "to", "(", "device", ")", "\n", "new_data", ".", "segm", "=", "self", ".", "segm", ".", "to", "(", "device", ")", "\n", "new_data", ".", "device", "=", "device", "\n", "return", "new_data", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.extract_segmentation_mask": [[128, 144], ["isinstance", "torch.zeros", "range", "mask_utils.decode"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "extract_segmentation_mask", "(", "annotation", ")", ":", "\n", "        ", "poly_specs", "=", "annotation", "[", "DensePoseDataRelative", ".", "S_KEY", "]", "\n", "if", "isinstance", "(", "poly_specs", ",", "torch", ".", "Tensor", ")", ":", "\n", "# data is already given as mask tensors, no need to decode", "\n", "            ", "return", "poly_specs", "\n", "\n", "", "import", "pycocotools", ".", "mask", "as", "mask_utils", "\n", "\n", "segm", "=", "torch", ".", "zeros", "(", "(", "DensePoseDataRelative", ".", "MASK_SIZE", ",", ")", "*", "2", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "DensePoseDataRelative", ".", "N_BODY_PARTS", ")", ":", "\n", "            ", "poly_i", "=", "poly_specs", "[", "i", "]", "\n", "if", "poly_i", ":", "\n", "                ", "mask_i", "=", "mask_utils", ".", "decode", "(", "poly_i", ")", "\n", "segm", "[", "mask_i", ">", "0", "]", "=", "i", "+", "1", "\n", "", "", "return", "segm", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.validate_annotation": [[145, 158], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "validate_annotation", "(", "annotation", ")", ":", "\n", "        ", "for", "key", "in", "[", "\n", "DensePoseDataRelative", ".", "X_KEY", ",", "\n", "DensePoseDataRelative", ".", "Y_KEY", ",", "\n", "DensePoseDataRelative", ".", "I_KEY", ",", "\n", "DensePoseDataRelative", ".", "U_KEY", ",", "\n", "DensePoseDataRelative", ".", "V_KEY", ",", "\n", "DensePoseDataRelative", ".", "S_KEY", ",", "\n", "]", ":", "\n", "            ", "if", "key", "not", "in", "annotation", ":", "\n", "                ", "return", "False", ",", "\"no {key} data in the annotation\"", ".", "format", "(", "key", "=", "key", ")", "\n", "", "", "return", "True", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.cleanup_annotation": [[159, 171], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "cleanup_annotation", "(", "annotation", ")", ":", "\n", "        ", "for", "key", "in", "[", "\n", "DensePoseDataRelative", ".", "X_KEY", ",", "\n", "DensePoseDataRelative", ".", "Y_KEY", ",", "\n", "DensePoseDataRelative", ".", "I_KEY", ",", "\n", "DensePoseDataRelative", ".", "U_KEY", ",", "\n", "DensePoseDataRelative", ".", "V_KEY", ",", "\n", "DensePoseDataRelative", ".", "S_KEY", ",", "\n", "]", ":", "\n", "            ", "if", "key", "in", "annotation", ":", "\n", "                ", "del", "annotation", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.apply_transform": [[172, 175], ["structures.DensePoseDataRelative._transform_pts", "structures.DensePoseDataRelative._transform_segm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._transform_pts", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._transform_segm"], ["", "", "", "def", "apply_transform", "(", "self", ",", "transforms", ",", "densepose_transform_data", ")", ":", "\n", "        ", "self", ".", "_transform_pts", "(", "transforms", ",", "densepose_transform_data", ")", "\n", "self", ".", "_transform_segm", "(", "transforms", ",", "densepose_transform_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._transform_pts": [[176, 190], ["structures.DensePoseDataRelative._flip_iuv_semantics", "isinstance", "sum", "structures.DensePoseDataRelative.segm.size", "t.apply_coords", "numpy.array", "torch.tensor", "isinstance", "numpy.stack"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._flip_iuv_semantics", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords"], ["", "def", "_transform_pts", "(", "self", ",", "transforms", ",", "dp_transform_data", ")", ":", "\n", "        ", "import", "detectron2", ".", "data", ".", "transforms", "as", "T", "\n", "\n", "# NOTE: This assumes that HorizFlipTransform is the only one that does flip", "\n", "do_hflip", "=", "sum", "(", "isinstance", "(", "t", ",", "T", ".", "HFlipTransform", ")", "for", "t", "in", "transforms", ".", "transforms", ")", "%", "2", "==", "1", "\n", "if", "do_hflip", ":", "\n", "            ", "self", ".", "x", "=", "self", ".", "segm", ".", "size", "(", "1", ")", "-", "self", ".", "x", "\n", "self", ".", "_flip_iuv_semantics", "(", "dp_transform_data", ")", "\n", "\n", "", "for", "t", "in", "transforms", ".", "transforms", ":", "\n", "            ", "if", "isinstance", "(", "t", ",", "T", ".", "RotationTransform", ")", ":", "\n", "                ", "xy_scale", "=", "np", ".", "array", "(", "(", "t", ".", "w", ",", "t", ".", "h", ")", ")", "/", "DensePoseDataRelative", ".", "MASK_SIZE", "\n", "xy", "=", "t", ".", "apply_coords", "(", "np", ".", "stack", "(", "(", "self", ".", "x", ",", "self", ".", "y", ")", ",", "axis", "=", "1", ")", "*", "xy_scale", ")", "\n", "self", ".", "x", ",", "self", ".", "y", "=", "torch", ".", "tensor", "(", "xy", "/", "xy_scale", ",", "dtype", "=", "self", ".", "x", ".", "dtype", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._flip_iuv_semantics": [[191, 207], ["structures.DensePoseDataRelative.i.clone", "range", "[].to", "[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "", "", "def", "_flip_iuv_semantics", "(", "self", ",", "dp_transform_data", ":", "DensePoseTransformData", ")", "->", "None", ":", "\n", "        ", "i_old", "=", "self", ".", "i", ".", "clone", "(", ")", "\n", "uv_symmetries", "=", "dp_transform_data", ".", "uv_symmetries", "\n", "pt_label_symmetries", "=", "dp_transform_data", ".", "point_label_symmetries", "\n", "for", "i", "in", "range", "(", "self", ".", "N_PART_LABELS", ")", ":", "\n", "            ", "if", "i", "+", "1", "in", "i_old", ":", "\n", "                ", "annot_indices_i", "=", "i_old", "==", "i", "+", "1", "\n", "if", "pt_label_symmetries", "[", "i", "+", "1", "]", "!=", "i", "+", "1", ":", "\n", "                    ", "self", ".", "i", "[", "annot_indices_i", "]", "=", "pt_label_symmetries", "[", "i", "+", "1", "]", "\n", "", "u_loc", "=", "(", "self", ".", "u", "[", "annot_indices_i", "]", "*", "255", ")", ".", "long", "(", ")", "\n", "v_loc", "=", "(", "self", ".", "v", "[", "annot_indices_i", "]", "*", "255", ")", ".", "long", "(", ")", "\n", "self", ".", "u", "[", "annot_indices_i", "]", "=", "uv_symmetries", "[", "\"U_transforms\"", "]", "[", "i", "]", "[", "v_loc", ",", "u_loc", "]", ".", "to", "(", "\n", "device", "=", "self", ".", "u", ".", "device", "\n", ")", "\n", "self", ".", "v", "[", "annot_indices_i", "]", "=", "uv_symmetries", "[", "\"V_transforms\"", "]", "[", "i", "]", "[", "v_loc", ",", "u_loc", "]", ".", "to", "(", "\n", "device", "=", "self", ".", "v", ".", "device", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._transform_segm": [[209, 221], ["torch.flip", "structures.DensePoseDataRelative._flip_segm_semantics", "isinstance", "sum", "structures.DensePoseDataRelative._transform_segm_rotation", "isinstance"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._flip_segm_semantics", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._transform_segm_rotation"], ["", "", "", "def", "_transform_segm", "(", "self", ",", "transforms", ",", "dp_transform_data", ")", ":", "\n", "        ", "import", "detectron2", ".", "data", ".", "transforms", "as", "T", "\n", "\n", "# NOTE: This assumes that HorizFlipTransform is the only one that does flip", "\n", "do_hflip", "=", "sum", "(", "isinstance", "(", "t", ",", "T", ".", "HFlipTransform", ")", "for", "t", "in", "transforms", ".", "transforms", ")", "%", "2", "==", "1", "\n", "if", "do_hflip", ":", "\n", "            ", "self", ".", "segm", "=", "torch", ".", "flip", "(", "self", ".", "segm", ",", "[", "1", "]", ")", "\n", "self", ".", "_flip_segm_semantics", "(", "dp_transform_data", ")", "\n", "\n", "", "for", "t", "in", "transforms", ".", "transforms", ":", "\n", "            ", "if", "isinstance", "(", "t", ",", "T", ".", "RotationTransform", ")", ":", "\n", "                ", "self", ".", "_transform_segm_rotation", "(", "t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._flip_segm_semantics": [[222, 228], ["structures.DensePoseDataRelative.segm.clone", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "", "", "def", "_flip_segm_semantics", "(", "self", ",", "dp_transform_data", ")", ":", "\n", "        ", "old_segm", "=", "self", ".", "segm", ".", "clone", "(", ")", "\n", "mask_label_symmetries", "=", "dp_transform_data", ".", "mask_label_symmetries", "\n", "for", "i", "in", "range", "(", "self", ".", "N_BODY_PARTS", ")", ":", "\n", "            ", "if", "mask_label_symmetries", "[", "i", "+", "1", "]", "!=", "i", "+", "1", ":", "\n", "                ", "self", ".", "segm", "[", "old_segm", "==", "i", "+", "1", "]", "=", "mask_label_symmetries", "[", "i", "+", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative._transform_segm_rotation": [[229, 233], ["torch.nn.functional.interpolate().numpy", "torch.tensor", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "rotation.apply_segmentation"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_segmentation"], ["", "", "", "def", "_transform_segm_rotation", "(", "self", ",", "rotation", ")", ":", "\n", "        ", "self", ".", "segm", "=", "F", ".", "interpolate", "(", "self", ".", "segm", "[", "None", ",", "None", ",", ":", "]", ",", "(", "rotation", ".", "h", ",", "rotation", ".", "w", ")", ")", ".", "numpy", "(", ")", "\n", "self", ".", "segm", "=", "torch", ".", "tensor", "(", "rotation", ".", "apply_segmentation", "(", "self", ".", "segm", "[", "0", ",", "0", "]", ")", ")", "[", "None", ",", "None", ",", ":", "]", "\n", "self", ".", "segm", "=", "F", ".", "interpolate", "(", "self", ".", "segm", ",", "[", "DensePoseDataRelative", ".", "MASK_SIZE", "]", "*", "2", ")", "[", "0", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.__init__": [[249, 264], ["structures.DensePoseOutput._check_output_dims"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput._check_output_dims"], ["    ", "def", "__init__", "(", "self", ",", "S", ",", "I", ",", "U", ",", "V", ",", "confidences", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            S (`torch.Tensor`): coarse segmentation tensor of size (N, A, H, W)\n            I (`torch.Tensor`): fine segmentation tensor of size (N, C, H, W)\n            U (`torch.Tensor`): U coordinates for each fine segmentation label of size (N, C, H, W)\n            V (`torch.Tensor`): V coordinates for each fine segmentation label of size (N, C, H, W)\n            confidences (dict of str -> `torch.Tensor`) estimated confidence model parameters\n        \"\"\"", "\n", "self", ".", "S", "=", "S", "\n", "self", ".", "I", "=", "I", "# noqa: E741", "\n", "self", ".", "U", "=", "U", "\n", "self", ".", "V", "=", "V", "\n", "self", ".", "confidences", "=", "confidences", "\n", "self", ".", "_check_output_dims", "(", "S", ",", "I", ",", "U", ",", "V", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput._check_output_dims": [[265, 303], ["len", "S.size", "len", "S.size", "len", "S.size", "len", "S.size", "len", "len", "len", "len", "I.size", "U.size", "I.size", "U.size", "I.size", "V.size", "I.size", "V.size", "S.size", "I.size", "U.size", "V.size", "S.size", "I.size", "S.size", "I.size"], "methods", ["None"], ["", "def", "_check_output_dims", "(", "self", ",", "S", ",", "I", ",", "U", ",", "V", ")", ":", "\n", "        ", "assert", "(", "\n", "len", "(", "S", ".", "size", "(", ")", ")", "==", "4", "\n", ")", ",", "\"Segmentation output should have 4 \"", "\"dimensions (NCHW), but has size {}\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", "\n", ")", "\n", "assert", "(", "\n", "len", "(", "I", ".", "size", "(", ")", ")", "==", "4", "\n", ")", ",", "\"Segmentation output should have 4 \"", "\"dimensions (NCHW), but has size {}\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", "\n", ")", "\n", "assert", "(", "\n", "len", "(", "U", ".", "size", "(", ")", ")", "==", "4", "\n", ")", ",", "\"Segmentation output should have 4 \"", "\"dimensions (NCHW), but has size {}\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", "\n", ")", "\n", "assert", "(", "\n", "len", "(", "V", ".", "size", "(", ")", ")", "==", "4", "\n", ")", ",", "\"Segmentation output should have 4 \"", "\"dimensions (NCHW), but has size {}\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", "\n", ")", "\n", "assert", "len", "(", "S", ")", "==", "len", "(", "I", ")", ",", "(", "\n", "\"Number of output segmentation planes {} \"", "\n", "\"should be equal to the number of output part index \"", "\n", "\"planes {}\"", ".", "format", "(", "len", "(", "S", ")", ",", "len", "(", "I", ")", ")", "\n", ")", "\n", "assert", "S", ".", "size", "(", ")", "[", "2", ":", "]", "==", "I", ".", "size", "(", ")", "[", "2", ":", "]", ",", "(", "\n", "\"Output segmentation plane size {} \"", "\n", "\"should be equal to the output part index \"", "\n", "\"plane size {}\"", ".", "format", "(", "S", ".", "size", "(", ")", "[", "2", ":", "]", ",", "I", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", ")", "\n", "assert", "I", ".", "size", "(", ")", "==", "U", ".", "size", "(", ")", ",", "(", "\n", "\"Part index output shape {} \"", "\n", "\"should be the same as U coordinates output shape {}\"", ".", "format", "(", "I", ".", "size", "(", ")", ",", "U", ".", "size", "(", ")", ")", "\n", ")", "\n", "assert", "I", ".", "size", "(", ")", "==", "V", ".", "size", "(", ")", ",", "(", "\n", "\"Part index output shape {} \"", "\n", "\"should be the same as V coordinates output shape {}\"", ".", "format", "(", "I", ".", "size", "(", ")", ",", "V", ".", "size", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.resize": [[305, 308], ["None"], "methods", ["None"], ["", "def", "resize", "(", "self", ",", "image_size_hw", ")", ":", "\n", "# do nothing - outputs are invariant to resize", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput._crop": [[309, 370], ["structures.normalized_coords_transform", "normalized_coords_transform.", "normalized_coords_transform.", "S.size", "S.size", "torch.meshgrid", "torch.stack().to", "torch.nn.functional.grid_sample().squeeze", "torch.nn.functional.grid_sample().squeeze", "torch.nn.functional.grid_sample().squeeze", "torch.nn.functional.grid_sample().squeeze", "torch.stack().to.size", "torch.stack().to.size", "torch.stack().to.size", "torch.stack().to.size", "torch.arange", "torch.arange", "torch.stack", "torch.nn.functional.grid_sample", "torch.nn.functional.grid_sample", "torch.nn.functional.grid_sample", "torch.nn.functional.grid_sample", "S.unsqueeze", "torch.unsqueeze", "I.unsqueeze", "torch.unsqueeze", "U.unsqueeze", "torch.unsqueeze", "V.unsqueeze", "torch.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.normalized_coords_transform", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "_crop", "(", "self", ",", "S", ",", "I", ",", "U", ",", "V", ",", "bbox_old_xywh", ",", "bbox_new_xywh", ")", ":", "\n", "        ", "\"\"\"\n        Resample S, I, U, V from bbox_old to the cropped bbox_new\n        \"\"\"", "\n", "x0old", ",", "y0old", ",", "wold", ",", "hold", "=", "bbox_old_xywh", "\n", "x0new", ",", "y0new", ",", "wnew", ",", "hnew", "=", "bbox_new_xywh", "\n", "tr_coords", "=", "normalized_coords_transform", "(", "x0old", ",", "y0old", ",", "wold", ",", "hold", ")", "\n", "topleft", "=", "(", "x0new", ",", "y0new", ")", "\n", "bottomright", "=", "(", "x0new", "+", "wnew", ",", "y0new", "+", "hnew", ")", "\n", "topleft_norm", "=", "tr_coords", "(", "topleft", ")", "\n", "bottomright_norm", "=", "tr_coords", "(", "bottomright", ")", "\n", "hsize", "=", "S", ".", "size", "(", "1", ")", "\n", "wsize", "=", "S", ".", "size", "(", "2", ")", "\n", "grid", "=", "torch", ".", "meshgrid", "(", "\n", "torch", ".", "arange", "(", "\n", "topleft_norm", "[", "1", "]", ",", "\n", "bottomright_norm", "[", "1", "]", ",", "\n", "(", "bottomright_norm", "[", "1", "]", "-", "topleft_norm", "[", "1", "]", ")", "/", "hsize", ",", "\n", ")", "[", ":", "hsize", "]", ",", "\n", "torch", ".", "arange", "(", "\n", "topleft_norm", "[", "0", "]", ",", "\n", "bottomright_norm", "[", "0", "]", ",", "\n", "(", "bottomright_norm", "[", "0", "]", "-", "topleft_norm", "[", "0", "]", ")", "/", "wsize", ",", "\n", ")", "[", ":", "wsize", "]", ",", "\n", ")", "\n", "grid", "=", "torch", ".", "stack", "(", "grid", ",", "dim", "=", "2", ")", ".", "to", "(", "S", ".", "device", ")", "\n", "assert", "(", "\n", "grid", ".", "size", "(", "0", ")", "==", "hsize", "\n", ")", ",", "\"Resampled grid expected \"", "\"height={}, actual height={}\"", ".", "format", "(", "hsize", ",", "grid", ".", "size", "(", "0", ")", ")", "\n", "assert", "grid", ".", "size", "(", "1", ")", "==", "wsize", ",", "\"Resampled grid expected \"", "\"width={}, actual width={}\"", ".", "format", "(", "\n", "wsize", ",", "grid", ".", "size", "(", "1", ")", "\n", ")", "\n", "S_new", "=", "F", ".", "grid_sample", "(", "\n", "S", ".", "unsqueeze", "(", "0", ")", ",", "\n", "torch", ".", "unsqueeze", "(", "grid", ",", "0", ")", ",", "\n", "mode", "=", "\"bilinear\"", ",", "\n", "padding_mode", "=", "\"border\"", ",", "\n", "align_corners", "=", "True", ",", "\n", ")", ".", "squeeze", "(", "0", ")", "\n", "I_new", "=", "F", ".", "grid_sample", "(", "\n", "I", ".", "unsqueeze", "(", "0", ")", ",", "\n", "torch", ".", "unsqueeze", "(", "grid", ",", "0", ")", ",", "\n", "mode", "=", "\"bilinear\"", ",", "\n", "padding_mode", "=", "\"border\"", ",", "\n", "align_corners", "=", "True", ",", "\n", ")", ".", "squeeze", "(", "0", ")", "\n", "U_new", "=", "F", ".", "grid_sample", "(", "\n", "U", ".", "unsqueeze", "(", "0", ")", ",", "\n", "torch", ".", "unsqueeze", "(", "grid", ",", "0", ")", ",", "\n", "mode", "=", "\"bilinear\"", ",", "\n", "padding_mode", "=", "\"border\"", ",", "\n", "align_corners", "=", "True", ",", "\n", ")", ".", "squeeze", "(", "0", ")", "\n", "V_new", "=", "F", ".", "grid_sample", "(", "\n", "V", ".", "unsqueeze", "(", "0", ")", ",", "\n", "torch", ".", "unsqueeze", "(", "grid", ",", "0", ")", ",", "\n", "mode", "=", "\"bilinear\"", ",", "\n", "padding_mode", "=", "\"border\"", ",", "\n", "align_corners", "=", "True", ",", "\n", ")", ".", "squeeze", "(", "0", ")", "\n", "return", "S_new", ",", "I_new", ",", "U_new", ",", "V_new", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.crop": [[371, 381], ["None"], "methods", ["None"], ["", "def", "crop", "(", "self", ",", "indices_cropped", ",", "bboxes_old", ",", "bboxes_new", ")", ":", "\n", "        ", "\"\"\"\n        Crop outputs for selected bounding boxes to the new bounding boxes.\n        \"\"\"", "\n", "# VK: cropping is ignored for now", "\n", "# for i, ic in enumerate(indices_cropped):", "\n", "#    self.S[ic], self.I[ic], self.U[ic], self.V[ic] = \\", "\n", "#        self._crop(self.S[ic], self.I[ic], self.U[ic], self.V[ic],", "\n", "#        bboxes_old[i], bboxes_new[i])", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.hflip": [[382, 393], ["structures.DensePoseOutput._flip_iuv_semantics_tensor", "structures.DensePoseOutput._flip_segm_semantics_tensor", "torch.flip", "torch.flip"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput._flip_iuv_semantics_tensor", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput._flip_segm_semantics_tensor"], ["", "def", "hflip", "(", "self", ",", "transform_data", ":", "DensePoseTransformData", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Change S, I, U and V to take into account a Horizontal flip.\n        \"\"\"", "\n", "if", "self", ".", "I", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "            ", "for", "el", "in", "\"SIUV\"", ":", "\n", "                ", "self", ".", "__dict__", "[", "el", "]", "=", "torch", ".", "flip", "(", "self", ".", "__dict__", "[", "el", "]", ",", "[", "3", "]", ")", "\n", "", "for", "key", "in", "self", ".", "confidences", ":", "\n", "                ", "self", ".", "confidences", "[", "key", "]", "=", "torch", ".", "flip", "(", "self", ".", "confidences", "[", "key", "]", ",", "[", "3", "]", ")", "\n", "", "self", ".", "_flip_iuv_semantics_tensor", "(", "transform_data", ")", "\n", "self", ".", "_flip_segm_semantics_tensor", "(", "transform_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput._flip_iuv_semantics_tensor": [[394, 409], ["[].expand", "structures.DensePoseOutput.U[].clamp", "structures.DensePoseOutput.V[].clamp", "torch.arange"], "methods", ["None"], ["", "", "def", "_flip_iuv_semantics_tensor", "(", "self", ",", "dp_transform_data", ":", "DensePoseTransformData", ")", "->", "None", ":", "\n", "        ", "point_label_symmetries", "=", "dp_transform_data", ".", "point_label_symmetries", "\n", "uv_symmetries", "=", "dp_transform_data", ".", "uv_symmetries", "\n", "\n", "N", ",", "C", ",", "H", ",", "W", "=", "self", ".", "U", ".", "shape", "\n", "u_loc", "=", "(", "self", ".", "U", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", ".", "clamp", "(", "0", ",", "1", ")", "*", "255", ")", ".", "long", "(", ")", "\n", "v_loc", "=", "(", "self", ".", "V", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", ".", "clamp", "(", "0", ",", "1", ")", "*", "255", ")", ".", "long", "(", ")", "\n", "Iindex", "=", "torch", ".", "arange", "(", "C", "-", "1", ",", "device", "=", "self", ".", "U", ".", "device", ")", "[", "None", ",", ":", ",", "None", ",", "None", "]", ".", "expand", "(", "\n", "N", ",", "C", "-", "1", ",", "H", ",", "W", "\n", ")", "\n", "self", ".", "U", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", "=", "uv_symmetries", "[", "\"U_transforms\"", "]", "[", "Iindex", ",", "v_loc", ",", "u_loc", "]", "\n", "self", ".", "V", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", "=", "uv_symmetries", "[", "\"V_transforms\"", "]", "[", "Iindex", ",", "v_loc", ",", "u_loc", "]", "\n", "\n", "for", "el", "in", "\"IUV\"", ":", "\n", "            ", "self", ".", "__dict__", "[", "el", "]", "=", "self", ".", "__dict__", "[", "el", "]", "[", ":", ",", "point_label_symmetries", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput._flip_segm_semantics_tensor": [[410, 413], ["None"], "methods", ["None"], ["", "", "def", "_flip_segm_semantics_tensor", "(", "self", ",", "dp_transform_data", ")", ":", "\n", "        ", "if", "self", ".", "S", ".", "shape", "[", "1", "]", "==", "DensePoseDataRelative", ".", "N_BODY_PARTS", "+", "1", ":", "\n", "            ", "self", ".", "S", "=", "self", ".", "S", "[", ":", ",", "dp_transform_data", ".", "mask_label_symmetries", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.to_result": [[414, 421], ["structures.DensePoseResult"], "methods", ["None"], ["", "", "def", "to_result", "(", "self", ",", "boxes_xywh", ")", ":", "\n", "        ", "\"\"\"\n        Convert DensePose outputs to results format. Results are more compact,\n        but cannot be resampled any more\n        \"\"\"", "\n", "result", "=", "DensePoseResult", "(", "boxes_xywh", ",", "self", ".", "S", ",", "self", ".", "I", ",", "self", ".", "U", ",", "self", ".", "V", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.__getitem__": [[422, 440], ["isinstance", "structures.DensePoseOutput", "structures.DensePoseOutput.S[].unsqueeze", "structures.DensePoseOutput.I[].unsqueeze", "structures.DensePoseOutput.U[].unsqueeze", "structures.DensePoseOutput.V[].unsqueeze", "[].unsqueeze"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "S_selected", "=", "self", ".", "S", "[", "item", "]", ".", "unsqueeze", "(", "0", ")", "\n", "I_selected", "=", "self", ".", "I", "[", "item", "]", ".", "unsqueeze", "(", "0", ")", "\n", "U_selected", "=", "self", ".", "U", "[", "item", "]", ".", "unsqueeze", "(", "0", ")", "\n", "V_selected", "=", "self", ".", "V", "[", "item", "]", ".", "unsqueeze", "(", "0", ")", "\n", "conf_selected", "=", "{", "}", "\n", "for", "key", "in", "self", ".", "confidences", ":", "\n", "                ", "conf_selected", "[", "key", "]", "=", "self", ".", "confidences", "[", "key", "]", "[", "item", "]", ".", "unsqueeze", "(", "0", ")", "\n", "", "", "else", ":", "\n", "            ", "S_selected", "=", "self", ".", "S", "[", "item", "]", "\n", "I_selected", "=", "self", ".", "I", "[", "item", "]", "\n", "U_selected", "=", "self", ".", "U", "[", "item", "]", "\n", "V_selected", "=", "self", ".", "V", "[", "item", "]", "\n", "conf_selected", "=", "{", "}", "\n", "for", "key", "in", "self", ".", "confidences", ":", "\n", "                ", "conf_selected", "[", "key", "]", "=", "self", ".", "confidences", "[", "key", "]", "[", "item", "]", "\n", "", "", "return", "DensePoseOutput", "(", "S_selected", ",", "I_selected", ",", "U_selected", ",", "V_selected", ",", "conf_selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.__str__": [[441, 449], ["list", "list", "list", "list", "structures.DensePoseOutput.S.size", "structures.DensePoseOutput.I.size", "structures.DensePoseOutput.U.size", "structures.DensePoseOutput.V.size", "list", "structures.DensePoseOutput.confidences[].size"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "\"DensePoseOutput S {}, I {}, U {}, V {}\"", ".", "format", "(", "\n", "list", "(", "self", ".", "S", ".", "size", "(", ")", ")", ",", "list", "(", "self", ".", "I", ".", "size", "(", ")", ")", ",", "list", "(", "self", ".", "U", ".", "size", "(", ")", ")", ",", "list", "(", "self", ".", "V", ".", "size", "(", ")", ")", "\n", ")", "\n", "s_conf", "=", "\"confidences: [{}]\"", ".", "format", "(", "\n", "\", \"", ".", "join", "(", "[", "f\"{key} {list(self.confidences[key].size())}\"", "for", "key", "in", "self", ".", "confidences", "]", ")", "\n", ")", "\n", "return", "\", \"", ".", "join", "(", "[", "s", ",", "s_conf", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.__len__": [[450, 452], ["structures.DensePoseOutput.S.size"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "S", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.__init__": [[537, 548], ["boxes_xywh.cpu().tolist", "enumerate", "len", "boxes_xywh.size", "structures.DensePoseResult._output_to_result", "structures.DensePoseResult.cpu().numpy", "structures.DensePoseResult.encode_png_data", "structures.DensePoseResult.results.append", "boxes_xywh.cpu", "boxes_xywh.size", "structures.DensePoseResult.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult._output_to_result", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.encode_png_data"], ["    ", "def", "__init__", "(", "self", ",", "boxes_xywh", ",", "S", ",", "I", ",", "U", ",", "V", ")", ":", "\n", "        ", "self", ".", "results", "=", "[", "]", "\n", "self", ".", "boxes_xywh", "=", "boxes_xywh", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "assert", "len", "(", "boxes_xywh", ".", "size", "(", ")", ")", "==", "2", "\n", "assert", "boxes_xywh", ".", "size", "(", "1", ")", "==", "4", "\n", "for", "i", ",", "box_xywh", "in", "enumerate", "(", "boxes_xywh", ")", ":", "\n", "            ", "result_i", "=", "self", ".", "_output_to_result", "(", "box_xywh", ",", "S", "[", "[", "i", "]", "]", ",", "I", "[", "[", "i", "]", "]", ",", "U", "[", "[", "i", "]", "]", ",", "V", "[", "[", "i", "]", "]", ")", "\n", "result_numpy_i", "=", "result_i", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "result_encoded_i", "=", "DensePoseResult", ".", "encode_png_data", "(", "result_numpy_i", ")", "\n", "result_encoded_with_shape_i", "=", "(", "result_numpy_i", ".", "shape", ",", "result_encoded_i", ")", "\n", "self", ".", "results", ".", "append", "(", "result_encoded_with_shape_i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.__str__": [[549, 554], ["len", "str", "list"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "\"DensePoseResult: N={} [{}]\"", ".", "format", "(", "\n", "len", "(", "self", ".", "results", ")", ",", "\", \"", ".", "join", "(", "[", "str", "(", "list", "(", "r", "[", "0", "]", ")", ")", "for", "r", "in", "self", ".", "results", "]", ")", "\n", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult._output_to_result": [[555, 595], ["max", "max", "torch.zeros", "torch.nn.functional.interpolate().argmax", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "range", "int", "int", "len", "len", "len", "len", "len", "len", "len", "len", "torch.nn.functional.interpolate.size", "torch.zeros.size", "torch.zeros.size", "torch.zeros.size", "torch.zeros.size", "S.size", "S.size", "torch.nn.functional.interpolate", "I.size", "S.size", "U.size", "U.size", "V.size", "V.size", "torch.nn.functional.interpolate().argmax", "torch.nn.functional.interpolate"], "methods", ["None"], ["", "def", "_output_to_result", "(", "self", ",", "box_xywh", ",", "S", ",", "I", ",", "U", ",", "V", ")", ":", "\n", "# TODO: reuse resample_output_to_bbox", "\n", "        ", "x", ",", "y", ",", "w", ",", "h", "=", "box_xywh", "\n", "w", "=", "max", "(", "int", "(", "w", ")", ",", "1", ")", "\n", "h", "=", "max", "(", "int", "(", "h", ")", ",", "1", ")", "\n", "result", "=", "torch", ".", "zeros", "(", "[", "3", ",", "h", ",", "w", "]", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "U", ".", "device", ")", "\n", "assert", "(", "\n", "len", "(", "S", ".", "size", "(", ")", ")", "==", "4", "\n", ")", ",", "\"AnnIndex tensor size should have {} \"", "\"dimensions but has {}\"", ".", "format", "(", "4", ",", "len", "(", "S", ".", "size", "(", ")", ")", ")", "\n", "s_bbox", "=", "F", ".", "interpolate", "(", "S", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "assert", "(", "\n", "len", "(", "I", ".", "size", "(", ")", ")", "==", "4", "\n", ")", ",", "\"IndexUV tensor size should have {} \"", "\"dimensions but has {}\"", ".", "format", "(", "4", ",", "len", "(", "S", ".", "size", "(", ")", ")", ")", "\n", "i_bbox", "=", "(", "\n", "F", ".", "interpolate", "(", "I", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "*", "(", "s_bbox", ">", "0", ")", ".", "long", "(", ")", "\n", ")", ".", "squeeze", "(", "0", ")", "\n", "assert", "len", "(", "U", ".", "size", "(", ")", ")", "==", "4", ",", "\"U tensor size should have {} \"", "\"dimensions but has {}\"", ".", "format", "(", "\n", "4", ",", "len", "(", "U", ".", "size", "(", ")", ")", "\n", ")", "\n", "u_bbox", "=", "F", ".", "interpolate", "(", "U", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "assert", "len", "(", "V", ".", "size", "(", ")", ")", "==", "4", ",", "\"V tensor size should have {} \"", "\"dimensions but has {}\"", ".", "format", "(", "\n", "4", ",", "len", "(", "V", ".", "size", "(", ")", ")", "\n", ")", "\n", "v_bbox", "=", "F", ".", "interpolate", "(", "V", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "result", "[", "0", "]", "=", "i_bbox", "\n", "for", "part_id", "in", "range", "(", "1", ",", "u_bbox", ".", "size", "(", "1", ")", ")", ":", "\n", "            ", "result", "[", "1", "]", "[", "i_bbox", "==", "part_id", "]", "=", "(", "\n", "(", "u_bbox", "[", "0", ",", "part_id", "]", "[", "i_bbox", "==", "part_id", "]", "*", "255", ")", ".", "clamp", "(", "0", ",", "255", ")", ".", "to", "(", "torch", ".", "uint8", ")", "\n", ")", "\n", "result", "[", "2", "]", "[", "i_bbox", "==", "part_id", "]", "=", "(", "\n", "(", "v_bbox", "[", "0", ",", "part_id", "]", "[", "i_bbox", "==", "part_id", "]", "*", "255", ")", ".", "clamp", "(", "0", ",", "255", ")", ".", "to", "(", "torch", ".", "uint8", ")", "\n", ")", "\n", "", "assert", "(", "\n", "result", ".", "size", "(", "1", ")", "==", "h", "\n", ")", ",", "\"Results height {} should be equal\"", "\"to bounding box height {}\"", ".", "format", "(", "result", ".", "size", "(", "1", ")", ",", "h", ")", "\n", "assert", "(", "\n", "result", ".", "size", "(", "2", ")", "==", "w", "\n", ")", ",", "\"Results width {} should be equal\"", "\"to bounding box width {}\"", ".", "format", "(", "result", ".", "size", "(", "2", ")", ",", "w", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.encode_png_data": [[596, 618], ["numpy.moveaxis", "PIL.Image.fromarray", "io.BytesIO", "PIL.Image.fromarray.save", "base64.encodebytes().decode", "len", "len", "base64.encodebytes", "io.BytesIO.getvalue"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save"], ["", "@", "staticmethod", "\n", "def", "encode_png_data", "(", "arr", ")", ":", "\n", "        ", "\"\"\"\n        Encode array data as a PNG image using the highest compression rate\n        @param arr [in] Data stored in an array of size (3, M, N) of type uint8\n        @return Base64-encoded string containing PNG-compressed data\n        \"\"\"", "\n", "assert", "len", "(", "arr", ".", "shape", ")", "==", "3", ",", "\"Expected a 3D array as an input,\"", "\" got a {0}D array\"", ".", "format", "(", "\n", "len", "(", "arr", ".", "shape", ")", "\n", ")", "\n", "assert", "arr", ".", "shape", "[", "0", "]", "==", "3", ",", "\"Expected first array dimension of size 3,\"", "\" got {0}\"", ".", "format", "(", "\n", "arr", ".", "shape", "[", "0", "]", "\n", ")", "\n", "assert", "arr", ".", "dtype", "==", "np", ".", "uint8", ",", "\"Expected an array of type np.uint8, \"", "\" got {0}\"", ".", "format", "(", "\n", "arr", ".", "dtype", "\n", ")", "\n", "data", "=", "np", ".", "moveaxis", "(", "arr", ",", "0", ",", "-", "1", ")", "\n", "im", "=", "Image", ".", "fromarray", "(", "data", ")", "\n", "fstream", "=", "BytesIO", "(", ")", "\n", "im", ".", "save", "(", "fstream", ",", "format", "=", "\"png\"", ",", "optimize", "=", "True", ")", "\n", "s", "=", "base64", ".", "encodebytes", "(", "fstream", ".", "getvalue", "(", ")", ")", ".", "decode", "(", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.decode_png_data": [[619, 630], ["io.BytesIO", "PIL.Image.open", "numpy.moveaxis", "numpy.moveaxis.reshape", "base64.decodebytes", "numpy.array", "s.encode", "PIL.Image.open.getdata"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "decode_png_data", "(", "shape", ",", "s", ")", ":", "\n", "        ", "\"\"\"\n        Decode array data from a string that contains PNG-compressed data\n        @param Base64-encoded string containing PNG-compressed data\n        @return Data stored in an array of size (3, M, N) of type uint8\n        \"\"\"", "\n", "fstream", "=", "BytesIO", "(", "base64", ".", "decodebytes", "(", "s", ".", "encode", "(", ")", ")", ")", "\n", "im", "=", "Image", ".", "open", "(", "fstream", ")", "\n", "data", "=", "np", ".", "moveaxis", "(", "np", ".", "array", "(", "im", ".", "getdata", "(", ")", ",", "dtype", "=", "np", ".", "uint8", ")", ",", "-", "1", ",", "0", ")", "\n", "return", "data", ".", "reshape", "(", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.__len__": [[631, 633], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.__getitem__": [[634, 638], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "result_encoded", "=", "self", ".", "results", "[", "item", "]", "\n", "bbox_xywh", "=", "self", ".", "boxes_xywh", "[", "item", "]", "\n", "return", "result_encoded", ",", "bbox_xywh", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.__init__": [[644, 663], ["boxes_xyxy_abs.to", "len", "len", "len", "len", "structures.DensePoseList.densepose_datas.append", "isinstance", "type", "densepose_data.to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["def", "__init__", "(", "self", ",", "densepose_datas", ",", "boxes_xyxy_abs", ",", "image_size_hw", ",", "device", "=", "_TORCH_DEVICE_CPU", ")", ":", "\n", "        ", "assert", "len", "(", "densepose_datas", ")", "==", "len", "(", "\n", "boxes_xyxy_abs", "\n", ")", ",", "\"Attempt to initialize DensePoseList with {} DensePose datas \"", "\"and {} boxes\"", ".", "format", "(", "\n", "len", "(", "densepose_datas", ")", ",", "len", "(", "boxes_xyxy_abs", ")", "\n", ")", "\n", "self", ".", "densepose_datas", "=", "[", "]", "\n", "for", "densepose_data", "in", "densepose_datas", ":", "\n", "            ", "assert", "isinstance", "(", "densepose_data", ",", "DensePoseDataRelative", ")", "or", "densepose_data", "is", "None", ",", "(", "\n", "\"Attempt to initialize DensePoseList with DensePose datas \"", "\n", "\"of type {}, expected DensePoseDataRelative\"", ".", "format", "(", "type", "(", "densepose_data", ")", ")", "\n", ")", "\n", "densepose_data_ondevice", "=", "(", "\n", "densepose_data", ".", "to", "(", "device", ")", "if", "densepose_data", "is", "not", "None", "else", "None", "\n", ")", "\n", "self", ".", "densepose_datas", ".", "append", "(", "densepose_data_ondevice", ")", "\n", "", "self", ".", "boxes_xyxy_abs", "=", "boxes_xyxy_abs", ".", "to", "(", "device", ")", "\n", "self", ".", "image_size_hw", "=", "image_size_hw", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to": [[664, 668], ["structures.DensePoseList"], "methods", ["None"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "if", "self", ".", "device", "==", "device", ":", "\n", "            ", "return", "self", "\n", "", "return", "DensePoseList", "(", "self", ".", "densepose_datas", ",", "self", ".", "boxes_xyxy_abs", ",", "self", ".", "image_size_hw", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.__iter__": [[669, 671], ["iter"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "densepose_datas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.__len__": [[672, 674], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "densepose_datas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.__repr__": [[675, 681], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "\n", "s", "+=", "\"num_instances={}, \"", ".", "format", "(", "len", "(", "self", ".", "densepose_datas", ")", ")", "\n", "s", "+=", "\"image_width={}, \"", ".", "format", "(", "self", ".", "image_size_hw", "[", "1", "]", ")", "\n", "s", "+=", "\"image_height={})\"", ".", "format", "(", "self", ".", "image_size_hw", "[", "0", "]", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.__getitem__": [[682, 703], ["isinstance", "isinstance", "structures.DensePoseList", "isinstance", "structures.DensePoseList", "structures.DensePoseList", "enumerate"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "densepose_data_rel", "=", "self", ".", "densepose_datas", "[", "item", "]", "\n", "return", "densepose_data_rel", "\n", "", "elif", "isinstance", "(", "item", ",", "slice", ")", ":", "\n", "            ", "densepose_datas_rel", "=", "self", ".", "densepose_datas", "[", "item", "]", "\n", "boxes_xyxy_abs", "=", "self", ".", "boxes_xyxy_abs", "[", "item", "]", "\n", "return", "DensePoseList", "(", "\n", "densepose_datas_rel", ",", "boxes_xyxy_abs", ",", "self", ".", "image_size_hw", ",", "self", ".", "device", "\n", ")", "\n", "", "elif", "isinstance", "(", "item", ",", "torch", ".", "Tensor", ")", "and", "(", "item", ".", "dtype", "==", "torch", ".", "bool", ")", ":", "\n", "            ", "densepose_datas_rel", "=", "[", "self", ".", "densepose_datas", "[", "i", "]", "for", "i", ",", "x", "in", "enumerate", "(", "item", ")", "if", "x", ">", "0", "]", "\n", "boxes_xyxy_abs", "=", "self", ".", "boxes_xyxy_abs", "[", "item", "]", "\n", "return", "DensePoseList", "(", "\n", "densepose_datas_rel", ",", "boxes_xyxy_abs", ",", "self", ".", "image_size_hw", ",", "self", ".", "device", "\n", ")", "\n", "", "else", ":", "\n", "            ", "densepose_datas_rel", "=", "[", "self", ".", "densepose_datas", "[", "i", "]", "for", "i", "in", "item", "]", "\n", "boxes_xyxy_abs", "=", "self", ".", "boxes_xyxy_abs", "[", "item", "]", "\n", "return", "DensePoseList", "(", "\n", "densepose_datas_rel", ",", "boxes_xyxy_abs", ",", "self", ".", "image_size_hw", ",", "self", ".", "device", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.normalized_coords_transform": [[235, 246], ["None"], "function", ["None"], ["", "", "def", "normalized_coords_transform", "(", "x0", ",", "y0", ",", "w", ",", "h", ")", ":", "\n", "    ", "\"\"\"\n    Coordinates transform that maps top left corner to (-1, -1) and bottom\n    right corner to (1, 1). Used for torch.grid_sample to initialize the\n    grid\n    \"\"\"", "\n", "\n", "def", "f", "(", "p", ")", ":", "\n", "        ", "return", "(", "2", "*", "(", "p", "[", "0", "]", "-", "x0", ")", "/", "w", "-", "1", ",", "2", "*", "(", "p", "[", "1", "]", "-", "y0", ")", "/", "h", "-", "1", ")", "\n", "\n", "", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.resample_output_to_bbox": [[454, 534], ["max", "max", "torch.zeros", "torch.nn.functional.interpolate().argmax", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "range", "int", "int", "len", "len", "len", "len", "len", "len", "len", "len", "F.interpolate.size", "enumerate", "enumerate", "labels.unsqueeze", "len", "output.S.size", "output.S.size", "torch.nn.functional.interpolate", "output.I.size", "output.S.size", "output.U.size", "output.U.size", "output.V.size", "output.V.size", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate().argmax", "resampled_confidence[].size", "F.interpolate.size", "resampled_confidence[].size", "F.interpolate.size", "torch.nn.functional.interpolate"], "function", ["None"], ["", "", "def", "resample_output_to_bbox", "(", "\n", "output", ":", "DensePoseOutput", ",", "bbox_xywh_abs", ":", "List", "[", "int", "]", ",", "confidences", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "    ", "\"\"\"\n    Convert DensePose output of size [1, C, S, S] into DensePose results [D, H_i, W_i],\n    where `i` is detection index and `D == 2 + len(confidences)`. This conversion:\n     - resamples data to the detection bounding box size (H_i, W_i),\n     - sets label for each pixel of the bounding box as the `argmax` of scores,\n     - assigns values (U, V, confidences) based on label and resampled data\n\n    Args:\n      output (DensePoseOutput): outputs of the DensePose model\n      bbox_xywh_abs (List[int]): bounding box, a list of 4 integer values XYWH\n      confidences (List[str]): optional list of `str` that specifies confidence\n        channels to be resampled and added to the results\n\n    Results:\n        labels (torch.Tensor): tensor [1, H_i, W_i] of `torch.uint8` containing fine\n            segmentation labels of each pixel\n        data (torch.Tensor): tensor [D, H_i, W_i] of `torch.float32` containing\n            for each pixel the estimated U, V coordinates and the requested\n            confidence values in the order that corresponds to `confidences`\n    \"\"\"", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "bbox_xywh_abs", "\n", "w", "=", "max", "(", "int", "(", "w", ")", ",", "1", ")", "\n", "h", "=", "max", "(", "int", "(", "h", ")", ",", "1", ")", "\n", "N_out", "=", "2", "if", "confidences", "is", "None", "else", "2", "+", "len", "(", "confidences", ")", "\n", "device", "=", "output", ".", "U", ".", "device", "\n", "data", "=", "torch", ".", "zeros", "(", "[", "N_out", ",", "h", ",", "w", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "# coarse segmentation", "\n", "assert", "(", "\n", "len", "(", "output", ".", "S", ".", "size", "(", ")", ")", "==", "4", "\n", ")", ",", "\"AnnIndex tensor size should have {} dimensions but has {}\"", ".", "format", "(", "4", ",", "len", "(", "output", ".", "S", ".", "size", "(", ")", ")", ")", "\n", "s_bbox", "=", "F", ".", "interpolate", "(", "output", ".", "S", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "# fine segmentation", "\n", "assert", "(", "\n", "len", "(", "output", ".", "I", ".", "size", "(", ")", ")", "==", "4", "\n", ")", ",", "\"IndexUV tensor size should have {} dimensions but has {}\"", ".", "format", "(", "4", ",", "len", "(", "output", ".", "S", ".", "size", "(", ")", ")", ")", "\n", "labels", "=", "(", "\n", "F", ".", "interpolate", "(", "output", ".", "I", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "*", "(", "s_bbox", ">", "0", ")", ".", "long", "(", ")", "\n", ")", ".", "squeeze", "(", "0", ")", "\n", "# U", "\n", "assert", "len", "(", "output", ".", "U", ".", "size", "(", ")", ")", "==", "4", ",", "\"U tensor size should have {} dimensions but has {}\"", ".", "format", "(", "\n", "4", ",", "len", "(", "output", ".", "U", ".", "size", "(", ")", ")", "\n", ")", "\n", "u_bbox", "=", "F", ".", "interpolate", "(", "output", ".", "U", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "# V", "\n", "assert", "len", "(", "output", ".", "V", ".", "size", "(", ")", ")", "==", "4", ",", "\"V tensor size should have {} dimensions but has {}\"", ".", "format", "(", "\n", "4", ",", "len", "(", "output", ".", "V", ".", "size", "(", ")", ")", "\n", ")", "\n", "v_bbox", "=", "F", ".", "interpolate", "(", "output", ".", "V", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "# confidences", "\n", "if", "confidences", "is", "not", "None", ":", "\n", "        ", "resampled_confidence", "=", "{", "}", "\n", "for", "key", "in", "output", ".", "confidences", ":", "\n", "            ", "resampled_confidence", "[", "key", "]", "=", "F", ".", "interpolate", "(", "\n", "output", ".", "confidences", "[", "key", "]", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "\n", "# assign data from channels that correspond to the labels", "\n", "", "", "for", "part_id", "in", "range", "(", "1", ",", "u_bbox", ".", "size", "(", "1", ")", ")", ":", "\n", "        ", "data", "[", "0", "]", "[", "labels", "==", "part_id", "]", "=", "u_bbox", "[", "0", ",", "part_id", "]", "[", "labels", "==", "part_id", "]", "\n", "data", "[", "1", "]", "[", "labels", "==", "part_id", "]", "=", "v_bbox", "[", "0", ",", "part_id", "]", "[", "labels", "==", "part_id", "]", "\n", "if", "confidences", "is", "None", ":", "\n", "            ", "continue", "\n", "", "for", "i", ",", "key", "in", "enumerate", "(", "confidences", ")", ":", "\n", "            ", "if", "resampled_confidence", "[", "key", "]", ".", "size", "(", "1", ")", "!=", "u_bbox", ".", "size", "(", "1", ")", ":", "\n", "# confidence is not part-based, don't try to fill it part by part", "\n", "                ", "continue", "\n", "", "data", "[", "2", "+", "i", "]", "[", "labels", "==", "part_id", "]", "=", "resampled_confidence", "[", "key", "]", "[", "0", ",", "part_id", "]", "[", "\n", "labels", "==", "part_id", "\n", "]", "\n", "", "", "if", "confidences", "is", "not", "None", ":", "\n", "        ", "for", "i", ",", "key", "in", "enumerate", "(", "confidences", ")", ":", "\n", "            ", "if", "resampled_confidence", "[", "key", "]", ".", "size", "(", "1", ")", "!=", "u_bbox", ".", "size", "(", "1", ")", ":", "\n", "# confidence is not part-based, fill the data with the first channel", "\n", "# (targeted for segmentation confidences that have only 1 channel)", "\n", "                ", "data", "[", "2", "+", "i", "]", "=", "resampled_confidence", "[", "key", "]", "[", "0", ",", "0", "]", "\n", "", "", "", "return", "labels", ".", "unsqueeze", "(", "0", ")", ",", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.is_relative_local_path": [[7, 10], ["os.fsdecode", "os.path.isabs"], "function", ["None"], ["    ", "for", "name", ",", "param", "in", "module", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "\"bias\"", "in", "name", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.maybe_prepend_base_path": [[12, 23], ["utils.is_relative_local_path", "os.path.join"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.is_relative_local_path"], ["", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.setUp": [[19, 21], ["detectron2.utils.logger.setup_logger"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "setup_logger", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_apply_rotated_boxes": [[22, 39], ["numpy.random.seed", "detectron2.config.get_cfg", "detectron2.data.detection_utils.build_augmentation", "numpy.random.rand", "detectron2.data.transforms.apply_augmentations", "numpy.array", "numpy.array", "numpy.allclose", "detectron2.data.transforms.apply_rotated_box"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.dataset_mapper.build_augmentation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.apply_augmentations"], ["", "def", "test_apply_rotated_boxes", "(", "self", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "125", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "is_train", "=", "True", "\n", "augs", "=", "detection_utils", ".", "build_augmentation", "(", "cfg", ",", "is_train", ")", "\n", "image", "=", "np", ".", "random", ".", "rand", "(", "200", ",", "300", ")", "\n", "image", ",", "transforms", "=", "T", ".", "apply_augmentations", "(", "augs", ",", "image", ")", "\n", "image_shape", "=", "image", ".", "shape", "[", ":", "2", "]", "# h, w", "\n", "assert", "image_shape", "==", "(", "800", ",", "1200", ")", "\n", "annotation", "=", "{", "\"bbox\"", ":", "[", "179", ",", "97", ",", "62", ",", "40", ",", "-", "56", "]", "}", "\n", "\n", "boxes", "=", "np", ".", "array", "(", "[", "annotation", "[", "\"bbox\"", "]", "]", ",", "dtype", "=", "np", ".", "float64", ")", "# boxes.shape = (1, 5)", "\n", "transformed_bbox", "=", "transforms", ".", "apply_rotated_box", "(", "boxes", ")", "[", "0", "]", "\n", "\n", "expected_bbox", "=", "np", ".", "array", "(", "[", "484", ",", "388", ",", "248", ",", "160", ",", "56", "]", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "err_msg", "=", "\"transformed_bbox = {}, expected {}\"", ".", "format", "(", "transformed_bbox", ",", "expected_bbox", ")", "\n", "assert", "np", ".", "allclose", "(", "transformed_bbox", ",", "expected_bbox", ")", ",", "err_msg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_apply_rotated_boxes_unequal_scaling_factor": [[40, 73], ["numpy.random.seed", "numpy.random.rand", "augs.append", "detectron2.data.transforms.apply_augmentations", "numpy.array", "detectron2.data.transforms.apply_rotated_box", "numpy.array", "numpy.allclose", "detectron2.data.transforms.Resize"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.apply_augmentations"], ["", "def", "test_apply_rotated_boxes_unequal_scaling_factor", "(", "self", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "125", ")", "\n", "h", ",", "w", "=", "400", ",", "200", "\n", "newh", ",", "neww", "=", "800", ",", "800", "\n", "image", "=", "np", ".", "random", ".", "rand", "(", "h", ",", "w", ")", "\n", "augs", "=", "[", "]", "\n", "augs", ".", "append", "(", "T", ".", "Resize", "(", "shape", "=", "(", "newh", ",", "neww", ")", ")", ")", "\n", "image", ",", "transforms", "=", "T", ".", "apply_augmentations", "(", "augs", ",", "image", ")", "\n", "image_shape", "=", "image", ".", "shape", "[", ":", "2", "]", "# h, w", "\n", "assert", "image_shape", "==", "(", "newh", ",", "neww", ")", "\n", "\n", "boxes", "=", "np", ".", "array", "(", "\n", "[", "\n", "[", "150", ",", "100", ",", "40", ",", "20", ",", "0", "]", ",", "\n", "[", "150", ",", "100", ",", "40", ",", "20", ",", "30", "]", ",", "\n", "[", "150", ",", "100", ",", "40", ",", "20", ",", "90", "]", ",", "\n", "[", "150", ",", "100", ",", "40", ",", "20", ",", "-", "90", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "np", ".", "float64", ",", "\n", ")", "\n", "transformed_boxes", "=", "transforms", ".", "apply_rotated_box", "(", "boxes", ")", "\n", "\n", "expected_bboxes", "=", "np", ".", "array", "(", "\n", "[", "\n", "[", "600", ",", "200", ",", "160", ",", "40", ",", "0", "]", ",", "\n", "[", "600", ",", "200", ",", "144.22205102", ",", "52.91502622", ",", "49.10660535", "]", ",", "\n", "[", "600", ",", "200", ",", "80", ",", "80", ",", "90", "]", ",", "\n", "[", "600", ",", "200", ",", "80", ",", "80", ",", "-", "90", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "np", ".", "float64", ",", "\n", ")", "\n", "err_msg", "=", "\"transformed_boxes = {}, expected {}\"", ".", "format", "(", "transformed_boxes", ",", "expected_bboxes", ")", "\n", "assert", "np", ".", "allclose", "(", "transformed_boxes", ",", "expected_bboxes", ")", ",", "err_msg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_print_augmentation": [[74, 86], ["detectron2.data.transforms.RandomCrop", "test_transforms.TestTransforms.assertEqual", "detectron2.data.transforms.RandomFlip", "test_transforms.TestTransforms.assertEqual", "detectron2.data.transforms.RandomFlip", "test_transforms.TestTransforms.assertEqual", "detectron2.data.transforms.AugmentationList", "test_transforms.TestTransforms.assertEqual", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "test_print_augmentation", "(", "self", ")", ":", "\n", "        ", "t", "=", "T", ".", "RandomCrop", "(", "\"relative\"", ",", "(", "100", ",", "100", ")", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "t", ")", ",", "\"RandomCrop(crop_type='relative', crop_size=(100, 100))\"", ")", "\n", "\n", "t0", "=", "T", ".", "RandomFlip", "(", "prob", "=", "0.5", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "t0", ")", ",", "\"RandomFlip(prob=0.5)\"", ")", "\n", "\n", "t1", "=", "T", ".", "RandomFlip", "(", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "t1", ")", ",", "\"RandomFlip()\"", ")", "\n", "\n", "t", "=", "T", ".", "AugmentationList", "(", "[", "t0", ",", "t1", "]", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "t", ")", ",", "f\"AugmentationList[{t0}, {t1}]\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_random_apply_prob_out_of_range_check": [[87, 95], ["test_probabilities.items", "test_transforms.TestTransforms.assertRaises", "detectron2.data.transforms.RandomApply", "detectron2.data.transforms.NoOpTransform"], "methods", ["None"], ["", "def", "test_random_apply_prob_out_of_range_check", "(", "self", ")", ":", "\n", "        ", "test_probabilities", "=", "{", "0.0", ":", "True", ",", "0.5", ":", "True", ",", "1.0", ":", "True", ",", "-", "0.01", ":", "False", ",", "1.01", ":", "False", "}", "\n", "\n", "for", "given_probability", ",", "is_valid", "in", "test_probabilities", ".", "items", "(", ")", ":", "\n", "            ", "if", "not", "is_valid", ":", "\n", "                ", "self", ".", "assertRaises", "(", "AssertionError", ",", "T", ".", "RandomApply", ",", "None", ",", "prob", "=", "given_probability", ")", "\n", "", "else", ":", "\n", "                ", "T", ".", "RandomApply", "(", "T", ".", "NoOpTransform", "(", ")", ",", "prob", "=", "given_probability", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_random_apply_wrapping_aug_probability_occured_evaluation": [[96, 105], ["unittest.mock.MagicMock", "unittest.mock.MagicMock", "detectron2.data.transforms.RandomApply", "unittest.mock.MagicMock.get_transform.assert_called_once_with", "test_transforms.TestTransforms.assertIsNot", "unittest.mock.patch.object", "detectron2.data.transforms.RandomApply.get_transform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.get_transform"], ["", "", "", "def", "test_random_apply_wrapping_aug_probability_occured_evaluation", "(", "self", ")", ":", "\n", "        ", "transform_mock", "=", "mock", ".", "MagicMock", "(", "name", "=", "\"MockTransform\"", ",", "spec", "=", "T", ".", "Augmentation", ")", "\n", "image_mock", "=", "mock", ".", "MagicMock", "(", "name", "=", "\"MockImage\"", ")", "\n", "random_apply", "=", "T", ".", "RandomApply", "(", "transform_mock", ",", "prob", "=", "0.001", ")", "\n", "\n", "with", "mock", ".", "patch", ".", "object", "(", "random_apply", ",", "\"_rand_range\"", ",", "return_value", "=", "0.0001", ")", ":", "\n", "            ", "transform", "=", "random_apply", ".", "get_transform", "(", "image_mock", ")", "\n", "", "transform_mock", ".", "get_transform", ".", "assert_called_once_with", "(", "image_mock", ")", "\n", "self", ".", "assertIsNot", "(", "transform", ",", "transform_mock", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_random_apply_wrapping_std_transform_probability_occured_evaluation": [[106, 114], ["unittest.mock.MagicMock", "unittest.mock.MagicMock", "detectron2.data.transforms.RandomApply", "test_transforms.TestTransforms.assertIs", "unittest.mock.patch.object", "detectron2.data.transforms.RandomApply.get_transform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.get_transform"], ["", "def", "test_random_apply_wrapping_std_transform_probability_occured_evaluation", "(", "self", ")", ":", "\n", "        ", "transform_mock", "=", "mock", ".", "MagicMock", "(", "name", "=", "\"MockTransform\"", ",", "spec", "=", "T", ".", "Transform", ")", "\n", "image_mock", "=", "mock", ".", "MagicMock", "(", "name", "=", "\"MockImage\"", ")", "\n", "random_apply", "=", "T", ".", "RandomApply", "(", "transform_mock", ",", "prob", "=", "0.001", ")", "\n", "\n", "with", "mock", ".", "patch", ".", "object", "(", "random_apply", ",", "\"_rand_range\"", ",", "return_value", "=", "0.0001", ")", ":", "\n", "            ", "transform", "=", "random_apply", ".", "get_transform", "(", "image_mock", ")", "\n", "", "self", ".", "assertIs", "(", "transform", ",", "transform_mock", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_random_apply_probability_not_occured_evaluation": [[115, 124], ["unittest.mock.MagicMock", "unittest.mock.MagicMock", "detectron2.data.transforms.RandomApply", "unittest.mock.MagicMock.get_transform.assert_not_called", "test_transforms.TestTransforms.assertIsInstance", "unittest.mock.patch.object", "detectron2.data.transforms.RandomApply.get_transform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.get_transform"], ["", "def", "test_random_apply_probability_not_occured_evaluation", "(", "self", ")", ":", "\n", "        ", "transform_mock", "=", "mock", ".", "MagicMock", "(", "name", "=", "\"MockTransform\"", ",", "spec", "=", "T", ".", "Augmentation", ")", "\n", "image_mock", "=", "mock", ".", "MagicMock", "(", "name", "=", "\"MockImage\"", ")", "\n", "random_apply", "=", "T", ".", "RandomApply", "(", "transform_mock", ",", "prob", "=", "0.001", ")", "\n", "\n", "with", "mock", ".", "patch", ".", "object", "(", "random_apply", ",", "\"_rand_range\"", ",", "return_value", "=", "0.9", ")", ":", "\n", "            ", "transform", "=", "random_apply", ".", "get_transform", "(", "image_mock", ")", "\n", "", "transform_mock", ".", "get_transform", ".", "assert_not_called", "(", ")", "\n", "self", ".", "assertIsInstance", "(", "transform", ",", "T", ".", "NoOpTransform", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_augmentation_input_args": [[125, 156], ["numpy.random.rand().astype", "detectron2.data.transforms.AugInput", "detectron2.data.transforms.AugInput.apply_augmentations", "test_transforms.TestTransforms.assertIsInstance", "test_transforms.TestTransforms.assertIsInstance", "test_transforms.TestTransforms.assertTrue", "test_transforms.TestTransforms.assertTrue", "test_transforms.TestTransforms.assertRaises", "detectron2.data.transforms.AugInput.apply_augmentations", "detectron2.data.transforms.ResizeTransform", "detectron2.data.transforms.HFlipTransform", "numpy.random.rand", "TG1", "TG2", "numpy.random.rand", "TG3"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.apply_augmentations", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.apply_augmentations"], ["", "def", "test_augmentation_input_args", "(", "self", ")", ":", "\n", "        ", "input_shape", "=", "(", "100", ",", "100", ")", "\n", "output_shape", "=", "(", "50", ",", "50", ")", "\n", "\n", "# define two augmentations with different args", "\n", "class", "TG1", "(", "T", ".", "Augmentation", ")", ":", "\n", "            ", "def", "get_transform", "(", "self", ",", "image", ",", "sem_seg", ")", ":", "\n", "                ", "return", "T", ".", "ResizeTransform", "(", "\n", "input_shape", "[", "0", "]", ",", "input_shape", "[", "1", "]", ",", "output_shape", "[", "0", "]", ",", "output_shape", "[", "1", "]", "\n", ")", "\n", "\n", "", "", "class", "TG2", "(", "T", ".", "Augmentation", ")", ":", "\n", "            ", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "                ", "assert", "image", ".", "shape", "[", ":", "2", "]", "==", "output_shape", "# check that TG1 is applied", "\n", "return", "T", ".", "HFlipTransform", "(", "output_shape", "[", "1", "]", ")", "\n", "\n", "", "", "image", "=", "np", ".", "random", ".", "rand", "(", "*", "input_shape", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "sem_seg", "=", "(", "np", ".", "random", ".", "rand", "(", "*", "input_shape", ")", "<", "0.5", ")", ".", "astype", "(", "\"uint8\"", ")", "\n", "inputs", "=", "T", ".", "AugInput", "(", "image", ",", "sem_seg", "=", "sem_seg", ")", "# provide two args", "\n", "tfms", "=", "inputs", ".", "apply_augmentations", "(", "[", "TG1", "(", ")", ",", "TG2", "(", ")", "]", ")", "\n", "self", ".", "assertIsInstance", "(", "tfms", "[", "0", "]", ",", "T", ".", "ResizeTransform", ")", "\n", "self", ".", "assertIsInstance", "(", "tfms", "[", "1", "]", ",", "T", ".", "HFlipTransform", ")", "\n", "self", ".", "assertTrue", "(", "inputs", ".", "image", ".", "shape", "[", ":", "2", "]", "==", "output_shape", ")", "\n", "self", ".", "assertTrue", "(", "inputs", ".", "sem_seg", ".", "shape", "[", ":", "2", "]", "==", "output_shape", ")", "\n", "\n", "class", "TG3", "(", "T", ".", "Augmentation", ")", ":", "\n", "            ", "def", "get_transform", "(", "self", ",", "image", ",", "nonexist", ")", ":", "\n", "                ", "pass", "\n", "\n", "", "", "with", "self", ".", "assertRaises", "(", "AttributeError", ")", ":", "\n", "            ", "inputs", ".", "apply_augmentations", "(", "[", "TG3", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_augmentation_list": [[157, 165], ["numpy.random.rand().astype", "detectron2.data.transforms.AugInput", "detectron2.data.transforms.AugmentationList", "detectron2.data.transforms.AugmentationList", "numpy.random.rand", "detectron2.data.transforms.RandomFlip", "detectron2.data.transforms.Resize", "numpy.random.rand", "detectron2.data.transforms.Resize"], "methods", ["None"], ["", "", "def", "test_augmentation_list", "(", "self", ")", ":", "\n", "        ", "input_shape", "=", "(", "100", ",", "100", ")", "\n", "image", "=", "np", ".", "random", ".", "rand", "(", "*", "input_shape", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "sem_seg", "=", "(", "np", ".", "random", ".", "rand", "(", "*", "input_shape", ")", "<", "0.5", ")", ".", "astype", "(", "\"uint8\"", ")", "\n", "inputs", "=", "T", ".", "AugInput", "(", "image", ",", "sem_seg", "=", "sem_seg", ")", "# provide two args", "\n", "\n", "augs", "=", "T", ".", "AugmentationList", "(", "[", "T", ".", "RandomFlip", "(", ")", ",", "T", ".", "Resize", "(", "20", ")", "]", ")", "\n", "_", "=", "T", ".", "AugmentationList", "(", "[", "augs", ",", "T", ".", "Resize", "(", "30", ")", "]", ")", "(", "inputs", ")", "\n", "# 3 in latest fvcore (flattened transformlist), 2 in older", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_transforms.TestTransforms.test_color_transforms": [[168, 181], ["rand_img.astype.astype.astype", "detectron2.data.transforms.ColorTransform", "test_transforms.TestTransforms.assertTrue", "numpy.random.randint", "detectron2.data.transforms.PILColorTransform", "PIL.ImageOps.solarize", "test_transforms.TestTransforms.assertTrue", "numpy.random.random", "numpy.array_equal", "PIL.Image.fromarray", "numpy.array_equal", "detectron2.data.transforms.ColorTransform.apply_image", "PIL.ImageOps.solarize", "detectron2.data.transforms.PILColorTransform.apply_image"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image"], ["", "def", "test_color_transforms", "(", "self", ")", ":", "\n", "        ", "rand_img", "=", "np", ".", "random", ".", "random", "(", "(", "100", ",", "100", ",", "3", ")", ")", "*", "255", "\n", "rand_img", "=", "rand_img", ".", "astype", "(", "\"uint8\"", ")", "\n", "\n", "# Test no-op", "\n", "noop_transform", "=", "T", ".", "ColorTransform", "(", "lambda", "img", ":", "img", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "array_equal", "(", "rand_img", ",", "noop_transform", ".", "apply_image", "(", "rand_img", ")", ")", ")", "\n", "\n", "# Test a ImageOps operation", "\n", "magnitude", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "256", ")", "\n", "solarize_transform", "=", "T", ".", "PILColorTransform", "(", "lambda", "img", ":", "ImageOps", ".", "solarize", "(", "img", ",", "magnitude", ")", ")", "\n", "expected_img", "=", "ImageOps", ".", "solarize", "(", "Image", ".", "fromarray", "(", "rand_img", ")", ",", "magnitude", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "array_equal", "(", "expected_img", ",", "solarize_transform", ".", "apply_image", "(", "rand_img", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays": [[9, 11], ["test_rotation_transform.TestRotationTransform.assertTrue", "numpy.allclose"], "methods", ["None"], ["    ", "def", "assertEqualsArrays", "(", "self", ",", "a1", ",", "a2", ")", ":", "\n", "        ", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "a1", ",", "a2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.randomData": [[12, 16], ["numpy.random.rand", "numpy.array", "range", "range"], "methods", ["None"], ["", "def", "randomData", "(", "self", ",", "h", "=", "5", ",", "w", "=", "5", ")", ":", "\n", "        ", "image", "=", "np", ".", "random", ".", "rand", "(", "h", ",", "w", ")", "\n", "coords", "=", "np", ".", "array", "(", "[", "[", "i", ",", "j", "]", "for", "j", "in", "range", "(", "h", "+", "1", ")", "for", "i", "in", "range", "(", "w", "+", "1", ")", "]", ",", "dtype", "=", "float", ")", "\n", "return", "image", ",", "coords", ",", "h", ",", "w", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.test180": [[17, 23], ["test_rotation_transform.TestRotationTransform.randomData", "detectron2.data.transforms.transform.RotationTransform", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "detectron2.data.transforms.transform.RotationTransform.apply_image", "detectron2.data.transforms.transform.RotationTransform.apply_coords"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.randomData", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords"], ["", "def", "test180", "(", "self", ")", ":", "\n", "        ", "image", ",", "coords", ",", "h", ",", "w", "=", "self", ".", "randomData", "(", "6", ",", "6", ")", "\n", "rot", "=", "RotationTransform", "(", "h", ",", "w", ",", "180", ",", "expand", "=", "False", ",", "center", "=", "None", ")", "\n", "self", ".", "assertEqualsArrays", "(", "rot", ".", "apply_image", "(", "image", ")", ",", "image", "[", ":", ":", "-", "1", ",", ":", ":", "-", "1", "]", ")", "\n", "rotated_coords", "=", "[", "[", "w", "-", "c", "[", "0", "]", ",", "h", "-", "c", "[", "1", "]", "]", "for", "c", "in", "coords", "]", "\n", "self", ".", "assertEqualsArrays", "(", "rot", ".", "apply_coords", "(", "coords", ")", ",", "rotated_coords", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.test45_coords": [[24, 32], ["test_rotation_transform.TestRotationTransform.randomData", "detectron2.data.transforms.transform.RotationTransform", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "detectron2.data.transforms.transform.RotationTransform.apply_coords", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.randomData", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords"], ["", "def", "test45_coords", "(", "self", ")", ":", "\n", "        ", "_", ",", "coords", ",", "h", ",", "w", "=", "self", ".", "randomData", "(", "4", ",", "6", ")", "\n", "rot", "=", "RotationTransform", "(", "h", ",", "w", ",", "45", ",", "expand", "=", "False", ",", "center", "=", "None", ")", "\n", "rotated_coords", "=", "[", "\n", "[", "(", "x", "+", "y", "-", "(", "h", "+", "w", ")", "/", "2", ")", "/", "np", ".", "sqrt", "(", "2", ")", "+", "w", "/", "2", ",", "h", "/", "2", "+", "(", "y", "+", "(", "w", "-", "h", ")", "/", "2", "-", "x", ")", "/", "np", ".", "sqrt", "(", "2", ")", "]", "\n", "for", "(", "x", ",", "y", ")", "in", "coords", "\n", "]", "\n", "self", ".", "assertEqualsArrays", "(", "rot", ".", "apply_coords", "(", "coords", ")", ",", "rotated_coords", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.test90": [[33, 39], ["test_rotation_transform.TestRotationTransform.randomData", "detectron2.data.transforms.transform.RotationTransform", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "detectron2.data.transforms.transform.RotationTransform.apply_image", "detectron2.data.transforms.transform.RotationTransform.apply_coords"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.randomData", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords"], ["", "def", "test90", "(", "self", ")", ":", "\n", "        ", "image", ",", "coords", ",", "h", ",", "w", "=", "self", ".", "randomData", "(", ")", "\n", "rot", "=", "RotationTransform", "(", "h", ",", "w", ",", "90", ",", "expand", "=", "False", ",", "center", "=", "None", ")", "\n", "self", ".", "assertEqualsArrays", "(", "rot", ".", "apply_image", "(", "image", ")", ",", "image", ".", "T", "[", ":", ":", "-", "1", "]", ")", "\n", "rotated_coords", "=", "[", "[", "c", "[", "1", "]", ",", "w", "-", "c", "[", "0", "]", "]", "for", "c", "in", "coords", "]", "\n", "self", ".", "assertEqualsArrays", "(", "rot", ".", "apply_coords", "(", "coords", ")", ",", "rotated_coords", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.test90_expand": [[40, 46], ["test_rotation_transform.TestRotationTransform.randomData", "detectron2.data.transforms.transform.RotationTransform", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "detectron2.data.transforms.transform.RotationTransform.apply_image", "detectron2.data.transforms.transform.RotationTransform.apply_coords"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.randomData", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords"], ["", "def", "test90_expand", "(", "self", ")", ":", "# non-square image", "\n", "        ", "image", ",", "coords", ",", "h", ",", "w", "=", "self", ".", "randomData", "(", "h", "=", "5", ",", "w", "=", "8", ")", "\n", "rot", "=", "RotationTransform", "(", "h", ",", "w", ",", "90", ",", "expand", "=", "True", ",", "center", "=", "None", ")", "\n", "self", ".", "assertEqualsArrays", "(", "rot", ".", "apply_image", "(", "image", ")", ",", "image", ".", "T", "[", ":", ":", "-", "1", "]", ")", "\n", "rotated_coords", "=", "[", "[", "c", "[", "1", "]", ",", "w", "-", "c", "[", "0", "]", "]", "for", "c", "in", "coords", "]", "\n", "self", ".", "assertEqualsArrays", "(", "rot", ".", "apply_coords", "(", "coords", ")", ",", "rotated_coords", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.test_center_expand": [[47, 59], ["test_rotation_transform.TestRotationTransform.randomData", "numpy.random.randint", "detectron2.data.transforms.transform.RotationTransform", "detectron2.data.transforms.transform.RotationTransform", "detectron2.data.transforms.transform.RotationTransform", "detectron2.data.transforms.transform.RotationTransform", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "r1.apply_image", "r2.apply_image", "r1.apply_coords", "r2.apply_coords"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.randomData", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords"], ["", "def", "test_center_expand", "(", "self", ")", ":", "\n", "# center has no effect if expand=True because it only affects shifting", "\n", "        ", "image", ",", "coords", ",", "h", ",", "w", "=", "self", ".", "randomData", "(", "h", "=", "5", ",", "w", "=", "8", ")", "\n", "angle", "=", "np", ".", "random", ".", "randint", "(", "360", ")", "\n", "rot1", "=", "RotationTransform", "(", "h", ",", "w", ",", "angle", ",", "expand", "=", "True", ",", "center", "=", "None", ")", "\n", "rot2", "=", "RotationTransform", "(", "h", ",", "w", ",", "angle", ",", "expand", "=", "True", ",", "center", "=", "(", "0", ",", "0", ")", ")", "\n", "rot3", "=", "RotationTransform", "(", "h", ",", "w", ",", "angle", ",", "expand", "=", "True", ",", "center", "=", "(", "h", ",", "w", ")", ")", "\n", "rot4", "=", "RotationTransform", "(", "h", ",", "w", ",", "angle", ",", "expand", "=", "True", ",", "center", "=", "(", "2", ",", "5", ")", ")", "\n", "for", "r1", "in", "[", "rot1", ",", "rot2", ",", "rot3", ",", "rot4", "]", ":", "\n", "            ", "for", "r2", "in", "[", "rot1", ",", "rot2", ",", "rot3", ",", "rot4", "]", ":", "\n", "                ", "self", ".", "assertEqualsArrays", "(", "r1", ".", "apply_image", "(", "image", ")", ",", "r2", ".", "apply_image", "(", "image", ")", ")", "\n", "self", ".", "assertEqualsArrays", "(", "r1", ".", "apply_coords", "(", "coords", ")", ",", "r2", ".", "apply_coords", "(", "coords", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.test_inverse_transform": [[60, 68], ["test_rotation_transform.TestRotationTransform.randomData", "detectron2.data.transforms.transform.RotationTransform", "detectron2.data.transforms.transform.RotationTransform.apply_image", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "detectron2.data.transforms.transform.RotationTransform", "detectron2.data.transforms.transform.RotationTransform.apply_coords", "test_rotation_transform.TestRotationTransform.assertEqualsArrays", "detectron2.data.transforms.transform.RotationTransform.inverse().apply_image", "detectron2.data.transforms.transform.RotationTransform.inverse().apply_coords", "detectron2.data.transforms.transform.RotationTransform.inverse", "detectron2.data.transforms.transform.RotationTransform.inverse"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.randomData", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_rotation_transform.TestRotationTransform.assertEqualsArrays", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.inverse", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.inverse"], ["", "", "", "def", "test_inverse_transform", "(", "self", ")", ":", "\n", "        ", "image", ",", "coords", ",", "h", ",", "w", "=", "self", ".", "randomData", "(", "h", "=", "5", ",", "w", "=", "8", ")", "\n", "rot", "=", "RotationTransform", "(", "h", ",", "w", ",", "90", ",", "expand", "=", "True", ",", "center", "=", "None", ")", "\n", "rot_image", "=", "rot", ".", "apply_image", "(", "image", ")", "\n", "self", ".", "assertEqualsArrays", "(", "rot", ".", "inverse", "(", ")", ".", "apply_image", "(", "rot_image", ")", ",", "image", ")", "\n", "rot", "=", "RotationTransform", "(", "h", ",", "w", ",", "65", ",", "expand", "=", "True", ",", "center", "=", "None", ")", "\n", "rotated_coords", "=", "rot", ".", "apply_coords", "(", "coords", ")", "\n", "self", ".", "assertEqualsArrays", "(", "rot", ".", "inverse", "(", ")", ".", "apply_coords", "(", "rotated_coords", ")", ",", "coords", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_detection_utils.TestTransformAnnotations.test_transform_simple_annotation": [[16, 31], ["detectron2.data.transforms.TransformList", "detectron2.data.detection_utils.transform_instance_annotations", "test_detection_utils.TestTransformAnnotations.assertTrue", "test_detection_utils.TestTransformAnnotations.assertEqual", "test_detection_utils.TestTransformAnnotations.assertTrue", "detectron2.data.detection_utils.annotations_to_instances", "numpy.asarray", "numpy.allclose", "len", "len", "numpy.allclose", "detectron2.data.transforms.HFlipTransform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_instance_annotations", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.annotations_to_instances"], ["    ", "def", "test_transform_simple_annotation", "(", "self", ")", ":", "\n", "        ", "transforms", "=", "T", ".", "TransformList", "(", "[", "T", ".", "HFlipTransform", "(", "400", ")", "]", ")", "\n", "anno", "=", "{", "\n", "\"bbox\"", ":", "np", ".", "asarray", "(", "[", "10", ",", "10", ",", "200", ",", "300", "]", ")", ",", "\n", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", ",", "\n", "\"category_id\"", ":", "3", ",", "\n", "\"segmentation\"", ":", "[", "[", "10", ",", "10", ",", "100", ",", "100", ",", "100", ",", "10", "]", ",", "[", "150", ",", "150", ",", "200", ",", "150", ",", "200", ",", "200", "]", "]", ",", "\n", "}", "\n", "\n", "output", "=", "detection_utils", ".", "transform_instance_annotations", "(", "anno", ",", "transforms", ",", "(", "400", ",", "400", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "output", "[", "\"bbox\"", "]", ",", "[", "200", ",", "10", ",", "390", ",", "300", "]", ")", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "output", "[", "\"segmentation\"", "]", ")", ",", "len", "(", "anno", "[", "\"segmentation\"", "]", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "output", "[", "\"segmentation\"", "]", "[", "0", "]", ",", "[", "390", ",", "10", ",", "300", ",", "100", ",", "300", ",", "10", "]", ")", ")", "\n", "\n", "detection_utils", ".", "annotations_to_instances", "(", "[", "output", ",", "output", "]", ",", "(", "400", ",", "400", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_detection_utils.TestTransformAnnotations.test_flip_keypoints": [[32, 61], ["detectron2.data.transforms.TransformList", "detectron2.data.detection_utils.transform_instance_annotations", "test_detection_utils.TestTransformAnnotations.assertTrue", "test_detection_utils.TestTransformAnnotations.assertTrue", "test_detection_utils.TestTransformAnnotations.assertTrue", "numpy.asarray", "copy.deepcopy", "numpy.allclose", "numpy.allclose", "numpy.allclose", "detectron2.data.transforms.HFlipTransform", "detectron2.data.detection_utils.create_keypoint_hflip_indices", "[].reshape", "numpy.random.rand", "[].reshape", "[].reshape", "[].reshape"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_instance_annotations", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.create_keypoint_hflip_indices"], ["", "def", "test_flip_keypoints", "(", "self", ")", ":", "\n", "        ", "transforms", "=", "T", ".", "TransformList", "(", "[", "T", ".", "HFlipTransform", "(", "400", ")", "]", ")", "\n", "anno", "=", "{", "\n", "\"bbox\"", ":", "np", ".", "asarray", "(", "[", "10", ",", "10", ",", "200", ",", "300", "]", ")", ",", "\n", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", ",", "\n", "\"keypoints\"", ":", "np", ".", "random", ".", "rand", "(", "17", ",", "3", ")", "*", "50", "+", "15", ",", "\n", "}", "\n", "\n", "output", "=", "detection_utils", ".", "transform_instance_annotations", "(", "\n", "copy", ".", "deepcopy", "(", "anno", ")", ",", "\n", "transforms", ",", "\n", "(", "400", ",", "400", ")", ",", "\n", "keypoint_hflip_indices", "=", "detection_utils", ".", "create_keypoint_hflip_indices", "(", "\n", "[", "\"keypoints_coco_2017_train\"", "]", "\n", ")", ",", "\n", ")", "\n", "# The first keypoint is nose", "\n", "self", ".", "assertTrue", "(", "np", ".", "allclose", "(", "output", "[", "\"keypoints\"", "]", "[", "0", ",", "0", "]", ",", "400", "-", "anno", "[", "\"keypoints\"", "]", "[", "0", ",", "0", "]", ")", ")", "\n", "# The last 16 keypoints are 8 left-right pairs", "\n", "self", ".", "assertTrue", "(", "\n", "np", ".", "allclose", "(", "\n", "output", "[", "\"keypoints\"", "]", "[", "1", ":", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", "[", ":", ",", ":", ":", "-", "1", "]", ",", "\n", "400", "-", "anno", "[", "\"keypoints\"", "]", "[", "1", ":", ",", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", ",", "\n", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "np", ".", "allclose", "(", "\n", "output", "[", "\"keypoints\"", "]", "[", "1", ":", ",", "1", ":", "]", ".", "reshape", "(", "-", "1", ",", "2", ",", "2", ")", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", ",", "\n", "anno", "[", "\"keypoints\"", "]", "[", "1", ":", ",", "1", ":", "]", ".", "reshape", "(", "-", "1", ",", "2", ",", "2", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_detection_utils.TestTransformAnnotations.test_crop": [[64, 81], ["detectron2.data.transforms.TransformList", "detectron2.data.detection_utils.transform_instance_annotations", "test_detection_utils.TestTransformAnnotations.assertTrue", "test_detection_utils.TestTransformAnnotations.assertTrue", "numpy.asarray", "copy.deepcopy", "detectron2.data.transforms.CropTransform", "numpy.random.rand", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_instance_annotations"], ["", "def", "test_crop", "(", "self", ")", ":", "\n", "        ", "transforms", "=", "T", ".", "TransformList", "(", "[", "T", ".", "CropTransform", "(", "300", ",", "300", ",", "10", ",", "10", ")", "]", ")", "\n", "keypoints", "=", "np", ".", "random", ".", "rand", "(", "17", ",", "3", ")", "*", "50", "+", "15", "\n", "keypoints", "[", ":", ",", "2", "]", "=", "2", "\n", "anno", "=", "{", "\n", "\"bbox\"", ":", "np", ".", "asarray", "(", "[", "10", ",", "10", ",", "200", ",", "400", "]", ")", ",", "\n", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", ",", "\n", "\"keypoints\"", ":", "keypoints", ",", "\n", "}", "\n", "\n", "output", "=", "detection_utils", ".", "transform_instance_annotations", "(", "\n", "copy", ".", "deepcopy", "(", "anno", ")", ",", "transforms", ",", "(", "10", ",", "10", ")", "\n", ")", "\n", "# box is shifted and cropped", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "\"bbox\"", "]", "==", "np", ".", "asarray", "(", "[", "0", ",", "0", ",", "0", ",", "10", "]", ")", ")", ".", "all", "(", ")", ")", "\n", "# keypoints are no longer visible", "\n", "self", ".", "assertTrue", "(", "(", "output", "[", "\"keypoints\"", "]", "[", ":", ",", "2", "]", "==", "0", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_detection_utils.TestTransformAnnotations.test_transform_RLE": [[82, 104], ["detectron2.data.transforms.TransformList", "numpy.zeros().astype", "detectron2.data.detection_utils.transform_instance_annotations", "test_detection_utils.TestTransformAnnotations.assertTrue", "test_detection_utils.TestTransformAnnotations.assertTrue", "detectron2.data.detection_utils.annotations_to_instances", "test_detection_utils.TestTransformAnnotations.assertTrue", "numpy.asarray", "copy.deepcopy", "isinstance", "detectron2.data.transforms.HFlipTransform", "numpy.zeros", "pycocotools.encode"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_instance_annotations", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.annotations_to_instances"], ["", "def", "test_transform_RLE", "(", "self", ")", ":", "\n", "        ", "transforms", "=", "T", ".", "TransformList", "(", "[", "T", ".", "HFlipTransform", "(", "400", ")", "]", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "300", ",", "400", ")", ",", "order", "=", "\"F\"", ")", ".", "astype", "(", "\"uint8\"", ")", "\n", "mask", "[", ":", ",", ":", "200", "]", "=", "1", "\n", "\n", "anno", "=", "{", "\n", "\"bbox\"", ":", "np", ".", "asarray", "(", "[", "10", ",", "10", ",", "200", ",", "300", "]", ")", ",", "\n", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", ",", "\n", "\"segmentation\"", ":", "mask_util", ".", "encode", "(", "mask", "[", ":", ",", ":", ",", "None", "]", ")", "[", "0", "]", ",", "\n", "\"category_id\"", ":", "3", ",", "\n", "}", "\n", "output", "=", "detection_utils", ".", "transform_instance_annotations", "(", "\n", "copy", ".", "deepcopy", "(", "anno", ")", ",", "transforms", ",", "(", "300", ",", "400", ")", "\n", ")", "\n", "mask", "=", "output", "[", "\"segmentation\"", "]", "\n", "self", ".", "assertTrue", "(", "(", "mask", "[", ":", ",", "200", ":", "]", "==", "1", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "mask", "[", ":", ",", ":", "200", "]", "==", "0", ")", ".", "all", "(", ")", ")", "\n", "\n", "inst", "=", "detection_utils", ".", "annotations_to_instances", "(", "\n", "[", "output", ",", "output", "]", ",", "(", "400", ",", "400", ")", ",", "mask_format", "=", "\"bitmask\"", "\n", ")", "\n", "self", ".", "assertTrue", "(", "isinstance", "(", "inst", ".", "gt_masks", ",", "BitMasks", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_detection_utils.TestTransformAnnotations.test_transform_RLE_resize": [[105, 126], ["detectron2.data.transforms.TransformList", "numpy.zeros().astype", "detectron2.data.detection_utils.transform_instance_annotations", "detectron2.data.detection_utils.annotations_to_instances", "test_detection_utils.TestTransformAnnotations.assertTrue", "numpy.asarray", "copy.deepcopy", "isinstance", "detectron2.data.transforms.HFlipTransform", "detectron2.data.transforms.ScaleTransform", "numpy.zeros", "pycocotools.encode"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.transform_instance_annotations", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.annotations_to_instances"], ["", "def", "test_transform_RLE_resize", "(", "self", ")", ":", "\n", "        ", "transforms", "=", "T", ".", "TransformList", "(", "\n", "[", "T", ".", "HFlipTransform", "(", "400", ")", ",", "T", ".", "ScaleTransform", "(", "300", ",", "400", ",", "400", ",", "400", ",", "\"bilinear\"", ")", "]", "\n", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "300", ",", "400", ")", ",", "order", "=", "\"F\"", ")", ".", "astype", "(", "\"uint8\"", ")", "\n", "mask", "[", ":", ",", ":", "200", "]", "=", "1", "\n", "\n", "anno", "=", "{", "\n", "\"bbox\"", ":", "np", ".", "asarray", "(", "[", "10", ",", "10", ",", "200", ",", "300", "]", ")", ",", "\n", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", ",", "\n", "\"segmentation\"", ":", "mask_util", ".", "encode", "(", "mask", "[", ":", ",", ":", ",", "None", "]", ")", "[", "0", "]", ",", "\n", "\"category_id\"", ":", "3", ",", "\n", "}", "\n", "output", "=", "detection_utils", ".", "transform_instance_annotations", "(", "\n", "copy", ".", "deepcopy", "(", "anno", ")", ",", "transforms", ",", "(", "400", ",", "400", ")", "\n", ")", "\n", "\n", "inst", "=", "detection_utils", ".", "annotations_to_instances", "(", "\n", "[", "output", ",", "output", "]", ",", "(", "400", ",", "400", ")", ",", "mask_format", "=", "\"bitmask\"", "\n", ")", "\n", "self", ".", "assertTrue", "(", "isinstance", "(", "inst", ".", "gt_masks", ",", "BitMasks", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_detection_utils.TestTransformAnnotations.test_gen_crop": [[127, 132], ["detectron2.data.detection_utils.gen_crop_transform_with_instance", "test_detection_utils.TestTransformAnnotations.assertTrue"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.gen_crop_transform_with_instance"], ["", "def", "test_gen_crop", "(", "self", ")", ":", "\n", "        ", "instance", "=", "{", "\"bbox\"", ":", "[", "10", ",", "10", ",", "100", ",", "100", "]", ",", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", "}", "\n", "t", "=", "detection_utils", ".", "gen_crop_transform_with_instance", "(", "(", "10", ",", "10", ")", ",", "(", "150", ",", "150", ")", ",", "instance", ")", "\n", "# the box center must fall into the cropped region", "\n", "self", ".", "assertTrue", "(", "t", ".", "x0", "<=", "55", "<=", "t", ".", "x0", "+", "t", ".", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_detection_utils.TestTransformAnnotations.test_gen_crop_outside_boxes": [[133, 137], ["test_detection_utils.TestTransformAnnotations.assertRaises", "detectron2.data.detection_utils.gen_crop_transform_with_instance"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.gen_crop_transform_with_instance"], ["", "def", "test_gen_crop_outside_boxes", "(", "self", ")", ":", "\n", "        ", "instance", "=", "{", "\"bbox\"", ":", "[", "10", ",", "10", ",", "100", ",", "100", "]", ",", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", "}", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "detection_utils", ".", "gen_crop_transform_with_instance", "(", "(", "10", ",", "10", ")", ",", "(", "15", ",", "15", ")", ",", "instance", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_detection_utils.TestTransformAnnotations.test_read_sem_seg": [[138, 153], ["os.path.join", "detectron2.data.detection_utils.read_image", "test_detection_utils.TestTransformAnnotations.assertEqual", "test_detection_utils.TestTransformAnnotations.assertEqual", "test_detection_utils.TestTransformAnnotations.assertEqual", "test_detection_utils.TestTransformAnnotations.assertEqual", "test_detection_utils.TestTransformAnnotations.assertEqual", "detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.exists", "unittest.SkipTest", "detectron2.data.detection_utils.read_image.max", "detectron2.data.detection_utils.read_image.min"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.read_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "test_read_sem_seg", "(", "self", ")", ":", "\n", "        ", "cityscapes_dir", "=", "MetadataCatalog", ".", "get", "(", "\"cityscapes_fine_sem_seg_val\"", ")", ".", "gt_dir", "\n", "sem_seg_gt_path", "=", "os", ".", "path", ".", "join", "(", "\n", "cityscapes_dir", ",", "\"frankfurt\"", ",", "\"frankfurt_000001_083852_gtFine_labelIds.png\"", "\n", ")", "\n", "if", "not", "PathManager", ".", "exists", "(", "sem_seg_gt_path", ")", ":", "\n", "            ", "raise", "unittest", ".", "SkipTest", "(", "\n", "\"Semantic segmentation ground truth {} not found.\"", ".", "format", "(", "sem_seg_gt_path", ")", "\n", ")", "\n", "", "sem_seg", "=", "detection_utils", ".", "read_image", "(", "sem_seg_gt_path", ",", "\"L\"", ")", "\n", "self", ".", "assertEqual", "(", "sem_seg", ".", "ndim", ",", "3", ")", "\n", "self", ".", "assertEqual", "(", "sem_seg", ".", "shape", "[", "2", "]", ",", "1", ")", "\n", "self", ".", "assertEqual", "(", "sem_seg", ".", "dtype", ",", "np", ".", "uint8", ")", "\n", "self", ".", "assertEqual", "(", "sem_seg", ".", "max", "(", ")", ",", "32", ")", "\n", "self", ".", "assertEqual", "(", "sem_seg", ".", "min", "(", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_sampler.TestGroupedBatchSampler.test_missing_group_id": [[9, 16], ["torch.utils.data.sampler.SequentialSampler", "detectron2.data.samplers.GroupedBatchSampler", "list", "test_sampler.TestGroupedBatchSampler.assertEqual", "range", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["    ", "def", "test_missing_group_id", "(", "self", ")", ":", "\n", "        ", "sampler", "=", "SequentialSampler", "(", "list", "(", "range", "(", "100", ")", ")", ")", "\n", "group_ids", "=", "[", "1", "]", "*", "100", "\n", "samples", "=", "GroupedBatchSampler", "(", "sampler", ",", "group_ids", ",", "2", ")", "\n", "\n", "for", "mini_batch", "in", "samples", ":", "\n", "            ", "self", ".", "assertEqual", "(", "len", "(", "mini_batch", ")", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_sampler.TestGroupedBatchSampler.test_groups": [[17, 24], ["torch.utils.data.sampler.SequentialSampler", "detectron2.data.samplers.GroupedBatchSampler", "list", "test_sampler.TestGroupedBatchSampler.assertEqual", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "", "def", "test_groups", "(", "self", ")", ":", "\n", "        ", "sampler", "=", "SequentialSampler", "(", "list", "(", "range", "(", "100", ")", ")", ")", "\n", "group_ids", "=", "[", "1", ",", "0", "]", "*", "50", "\n", "samples", "=", "GroupedBatchSampler", "(", "sampler", ",", "group_ids", ",", "2", ")", "\n", "\n", "for", "mini_batch", "in", "samples", ":", "\n", "            ", "self", ".", "assertEqual", "(", "(", "mini_batch", "[", "0", "]", "+", "mini_batch", "[", "1", "]", ")", "%", "2", ",", "0", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco_evaluation.TestCOCOeval.test": [[17, 121], ["copy.deepcopy", "experiments.items", "copy.deepcopy", "copy.deepcopy", "tempfile.TemporaryDirectory", "os.path.join", "test_coco_evaluation.TestCOCOeval.assertTrue", "open", "json.dump", "contextlib.redirect_stdout", "pycocotools.coco.COCO", "contextlib.redirect_stdout", "pycocotools.coco.COCO.loadRes", "pycocotools.cocoeval.COCOeval", "params.items", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "pycocotools.cocoeval.COCOeval.summarize", "contextlib.redirect_stdout", "pycocotools.coco.COCO.loadRes", "detectron2.evaluation.fast_eval_api.COCOeval_opt", "params.items", "detectron2.evaluation.fast_eval_api.COCOeval_opt.evaluate", "detectron2.evaluation.fast_eval_api.COCOeval_opt.accumulate", "detectron2.evaluation.fast_eval_api.COCOeval_opt.summarize", "numpy.abs", "test_coco_evaluation.TestCOCOeval.assertTrue", "io.StringIO", "io.StringIO", "setattr", "io.StringIO", "setattr", "type", "type", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], ["    ", "def", "test", "(", "self", ")", ":", "\n", "# A small set of images/categories from COCO val", "\n", "# fmt: off", "\n", "        ", "detections", "=", "[", "{", "\"image_id\"", ":", "139", ",", "\"category_id\"", ":", "1", ",", "\"bbox\"", ":", "[", "417.3332824707031", ",", "159.27003479003906", ",", "47.66064453125", ",", "143.00193786621094", "]", ",", "\"score\"", ":", "0.9949821829795837", ",", "\"segmentation\"", ":", "{", "\"size\"", ":", "[", "426", ",", "640", "]", ",", "\"counts\"", ":", "\"Tc`52W=3N0N4aNN^E7]:4XE1g:8kDMT;U100000001O1gE[Nk8h1dFiNY9Z1aFkN]9g2J3NdN`FlN`9S1cFRN07]9g1bFoM6;X9c1cFoM=8R9g1bFQN>3U9Y30O01OO1O001N2O1N1O4L4L5UNoE3V:CVF6Q:@YF9l9@ZF<k9[O`F=];HYnX2\"", "}", "}", ",", "{", "\"image_id\"", ":", "139", ",", "\"category_id\"", ":", "1", ",", "\"bbox\"", ":", "[", "383.5909118652344", ",", "172.0777587890625", ",", "17.959075927734375", ",", "36.94813537597656", "]", ",", "\"score\"", ":", "0.7685421705245972", ",", "\"segmentation\"", ":", "{", "\"size\"", ":", "[", "426", ",", "640", "]", ",", "\"counts\"", ":", "\"lZP5m0Z<300O100O100000001O00]OlC0T<OnCOT<OnCNX<JnC2bQT3\"", "}", "}", ",", "{", "\"image_id\"", ":", "139", ",", "\"category_id\"", ":", "1", ",", "\"bbox\"", ":", "[", "457.8359069824219", ",", "158.88027954101562", ",", "9.89764404296875", ",", "8.771820068359375", "]", ",", "\"score\"", ":", "0.07092753797769547", ",", "\"segmentation\"", ":", "{", "\"size\"", ":", "[", "426", ",", "640", "]", ",", "\"counts\"", ":", "\"bSo54T=2N2O1001O006ImiW2\"", "}", "}", "]", "# noqa", "\n", "gt_annotations", "=", "{", "\"categories\"", ":", "[", "{", "\"supercategory\"", ":", "\"person\"", ",", "\"id\"", ":", "1", ",", "\"name\"", ":", "\"person\"", "}", ",", "{", "\"supercategory\"", ":", "\"furniture\"", ",", "\"id\"", ":", "65", ",", "\"name\"", ":", "\"bed\"", "}", "]", ",", "\"images\"", ":", "[", "{", "\"license\"", ":", "4", ",", "\"file_name\"", ":", "\"000000000285.jpg\"", ",", "\"coco_url\"", ":", "\"http://images.cocodataset.org/val2017/000000000285.jpg\"", ",", "\"height\"", ":", "640", ",", "\"width\"", ":", "586", ",", "\"date_captured\"", ":", "\"2013-11-18 13:09:47\"", ",", "\"flickr_url\"", ":", "\"http://farm8.staticflickr.com/7434/9138147604_c6225224b8_z.jpg\"", ",", "\"id\"", ":", "285", "}", ",", "{", "\"license\"", ":", "2", ",", "\"file_name\"", ":", "\"000000000139.jpg\"", ",", "\"coco_url\"", ":", "\"http://images.cocodataset.org/val2017/000000000139.jpg\"", ",", "\"height\"", ":", "426", ",", "\"width\"", ":", "640", ",", "\"date_captured\"", ":", "\"2013-11-21 01:34:01\"", ",", "\"flickr_url\"", ":", "\"http://farm9.staticflickr.com/8035/8024364858_9c41dc1666_z.jpg\"", ",", "\"id\"", ":", "139", "}", "]", ",", "\"annotations\"", ":", "[", "{", "\"segmentation\"", ":", "[", "[", "428.19", ",", "219.47", ",", "430.94", ",", "209.57", ",", "430.39", ",", "210.12", ",", "421.32", ",", "216.17", ",", "412.8", ",", "217.27", ",", "413.9", ",", "214.24", ",", "422.42", ",", "211.22", ",", "429.29", ",", "201.6", ",", "430.67", ",", "181.8", ",", "430.12", ",", "175.2", ",", "427.09", ",", "168.06", ",", "426.27", ",", "164.21", ",", "430.94", ",", "159.26", ",", "440.29", ",", "157.61", ",", "446.06", ",", "163.93", ",", "448.53", ",", "168.06", ",", "448.53", ",", "173.01", ",", "449.08", ",", "174.93", ",", "454.03", ",", "185.1", ",", "455.41", ",", "188.4", ",", "458.43", ",", "195.0", ",", "460.08", ",", "210.94", ",", "462.28", ",", "226.61", ",", "460.91", ",", "233.76", ",", "454.31", ",", "234.04", ",", "460.08", ",", "256.85", ",", "462.56", ",", "268.13", ",", "465.58", ",", "290.67", ",", "465.85", ",", "293.14", ",", "463.38", ",", "295.62", ",", "452.66", ",", "295.34", ",", "448.26", ",", "294.52", ",", "443.59", ",", "282.7", ",", "446.06", ",", "235.14", ",", "446.34", ",", "230.19", ",", "438.09", ",", "232.39", ",", "438.09", ",", "221.67", ",", "434.24", ",", "221.12", ",", "427.09", ",", "219.74", "]", "]", ",", "\"area\"", ":", "2913.1103999999987", ",", "\"iscrowd\"", ":", "0", ",", "\"image_id\"", ":", "139", ",", "\"bbox\"", ":", "[", "412.8", ",", "157.61", ",", "53.05", ",", "138.01", "]", ",", "\"category_id\"", ":", "1", ",", "\"id\"", ":", "230831", "}", ",", "{", "\"segmentation\"", ":", "[", "[", "384.98", ",", "206.58", ",", "384.43", ",", "199.98", ",", "385.25", ",", "193.66", ",", "385.25", ",", "190.08", ",", "387.18", ",", "185.13", ",", "387.18", ",", "182.93", ",", "386.08", ",", "181.01", ",", "385.25", ",", "178.81", ",", "385.25", ",", "175.79", ",", "388.0", ",", "172.76", ",", "394.88", ",", "172.21", ",", "398.72", ",", "173.31", ",", "399.27", ",", "176.06", ",", "399.55", ",", "183.48", ",", "397.9", ",", "185.68", ",", "395.15", ",", "188.98", ",", "396.8", ",", "193.38", ",", "398.45", ",", "194.48", ",", "399.0", ",", "205.75", ",", "395.43", ",", "207.95", ",", "388.83", ",", "206.03", "]", "]", ",", "\"area\"", ":", "435.1449499999997", ",", "\"iscrowd\"", ":", "0", ",", "\"image_id\"", ":", "139", ",", "\"bbox\"", ":", "[", "384.43", ",", "172.21", ",", "15.12", ",", "35.74", "]", ",", "\"category_id\"", ":", "1", ",", "\"id\"", ":", "233201", "}", "]", "}", "# noqa", "\n", "# fmt: on", "\n", "\n", "# Test a small dataset for typical COCO format", "\n", "experiments", "=", "{", "\"full\"", ":", "(", "detections", ",", "gt_annotations", ",", "{", "}", ")", "}", "\n", "\n", "# Test what happens if the list of detections or ground truth annotations is empty", "\n", "experiments", "[", "\"empty_dt\"", "]", "=", "(", "[", "]", ",", "gt_annotations", ",", "{", "}", ")", "\n", "gt", "=", "copy", ".", "deepcopy", "(", "gt_annotations", ")", "\n", "gt", "[", "\"annotations\"", "]", "=", "[", "]", "\n", "experiments", "[", "\"empty_gt\"", "]", "=", "(", "detections", ",", "gt", ",", "{", "}", ")", "\n", "\n", "# Test changing parameter settings", "\n", "experiments", "[", "\"no_categories\"", "]", "=", "(", "detections", ",", "gt_annotations", ",", "{", "\"useCats\"", ":", "0", "}", ")", "\n", "experiments", "[", "\"no_ious\"", "]", "=", "(", "detections", ",", "gt_annotations", ",", "{", "\"iouThrs\"", ":", "[", "]", "}", ")", "\n", "experiments", "[", "\"no_rec_thrs\"", "]", "=", "(", "detections", ",", "gt_annotations", ",", "{", "\"recThrs\"", ":", "[", "]", "}", ")", "\n", "experiments", "[", "\"no_max_dets\"", "]", "=", "(", "detections", ",", "gt_annotations", ",", "{", "\"maxDets\"", ":", "[", "]", "}", ")", "\n", "experiments", "[", "\"one_max_det\"", "]", "=", "(", "detections", ",", "gt_annotations", ",", "{", "\"maxDets\"", ":", "[", "1", "]", "}", ")", "\n", "experiments", "[", "\"no_area\"", "]", "=", "(", "detections", ",", "gt_annotations", ",", "{", "\"areaRng\"", ":", "[", "]", ",", "\"areaRngLbl\"", ":", "[", "]", "}", ")", "\n", "\n", "# Test what happens if one omits different fields from the annotation structure", "\n", "annotation_fields", "=", "[", "\n", "\"id\"", ",", "\n", "\"image_id\"", ",", "\n", "\"category_id\"", ",", "\n", "\"score\"", ",", "\n", "\"area\"", ",", "\n", "\"iscrowd\"", ",", "\n", "\"ignore\"", ",", "\n", "\"bbox\"", ",", "\n", "\"segmentation\"", ",", "\n", "]", "\n", "for", "a", "in", "annotation_fields", ":", "\n", "            ", "gt", "=", "copy", ".", "deepcopy", "(", "gt_annotations", ")", "\n", "for", "g", "in", "gt", "[", "\"annotations\"", "]", ":", "\n", "                ", "if", "a", "in", "g", ":", "\n", "                    ", "del", "g", "[", "a", "]", "\n", "", "", "dt", "=", "copy", ".", "deepcopy", "(", "detections", ")", "\n", "for", "d", "in", "dt", ":", "\n", "                ", "if", "a", "in", "d", ":", "\n", "                    ", "del", "d", "[", "a", "]", "\n", "", "", "experiments", "[", "\"omit_gt_\"", "+", "a", "]", "=", "(", "detections", ",", "gt", ",", "{", "}", ")", "\n", "experiments", "[", "\"omit_dt_\"", "+", "a", "]", "=", "(", "dt", ",", "gt_annotations", ",", "{", "}", ")", "\n", "\n", "# Compare precision/recall for original COCO PythonAPI to custom optimized one", "\n", "", "for", "name", ",", "(", "dt", ",", "gt", ",", "params", ")", "in", "experiments", ".", "items", "(", ")", ":", "\n", "# Dump to json.", "\n", "            ", "try", ":", "\n", "                ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdir", ":", "\n", "                    ", "json_file_name", "=", "os", ".", "path", ".", "join", "(", "tmpdir", ",", "\"gt_\"", "+", "name", "+", "\".json\"", ")", "\n", "with", "open", "(", "json_file_name", ",", "\"w\"", ")", "as", "f", ":", "\n", "                        ", "json", ".", "dump", "(", "gt", ",", "f", ")", "\n", "", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "                        ", "coco_api", "=", "COCO", "(", "json_file_name", ")", "\n", "", "", "", "except", "Exception", ":", "\n", "                ", "pass", "\n", "\n", "", "for", "iou_type", "in", "[", "\"bbox\"", ",", "\"segm\"", ",", "\"keypoints\"", "]", ":", "\n", "# Run original COCOeval PythonAPI", "\n", "                ", "api_exception", "=", "None", "\n", "try", ":", "\n", "                    ", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "                        ", "coco_dt", "=", "coco_api", ".", "loadRes", "(", "dt", ")", "\n", "coco_eval", "=", "COCOeval", "(", "coco_api", ",", "coco_dt", ",", "iou_type", ")", "\n", "for", "p", ",", "v", "in", "params", ".", "items", "(", ")", ":", "\n", "                            ", "setattr", "(", "coco_eval", ".", "params", ",", "p", ",", "v", ")", "\n", "", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "coco_eval", ".", "summarize", "(", ")", "\n", "", "", "except", "Exception", "as", "ex", ":", "\n", "                    ", "api_exception", "=", "ex", "\n", "\n", "# Run optimized COCOeval_opt API", "\n", "", "opt_exception", "=", "None", "\n", "try", ":", "\n", "                    ", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "                        ", "coco_dt", "=", "coco_api", ".", "loadRes", "(", "dt", ")", "\n", "coco_eval_opt", "=", "COCOeval_opt", "(", "coco_api", ",", "coco_dt", ",", "iou_type", ")", "\n", "for", "p", ",", "v", "in", "params", ".", "items", "(", ")", ":", "\n", "                            ", "setattr", "(", "coco_eval_opt", ".", "params", ",", "p", ",", "v", ")", "\n", "", "coco_eval_opt", ".", "evaluate", "(", ")", "\n", "coco_eval_opt", ".", "accumulate", "(", ")", "\n", "coco_eval_opt", ".", "summarize", "(", ")", "\n", "", "", "except", "Exception", "as", "ex", ":", "\n", "                    ", "opt_exception", "=", "ex", "\n", "\n", "", "if", "api_exception", "is", "not", "None", "and", "opt_exception", "is", "not", "None", ":", "\n", "# Original API and optimized API should throw the same exception if annotation", "\n", "# format is bad", "\n", "                    ", "api_error", "=", "\"\"", "if", "api_exception", "is", "None", "else", "type", "(", "api_exception", ")", ".", "__name__", "\n", "opt_error", "=", "\"\"", "if", "opt_exception", "is", "None", "else", "type", "(", "opt_exception", ")", ".", "__name__", "\n", "msg", "=", "\"%s: comparing COCO APIs, '%s' != '%s'\"", "%", "(", "name", ",", "api_error", ",", "opt_error", ")", "\n", "self", ".", "assertTrue", "(", "api_error", "==", "opt_error", ",", "msg", "=", "msg", ")", "\n", "", "else", ":", "\n", "# Original API and optimized API should produce the same precision/recalls", "\n", "                    ", "for", "k", "in", "[", "\"precision\"", ",", "\"recall\"", "]", ":", "\n", "                        ", "diff", "=", "np", ".", "abs", "(", "coco_eval", ".", "eval", "[", "k", "]", "-", "coco_eval_opt", ".", "eval", "[", "k", "]", ")", "\n", "abs_diff", "=", "np", ".", "max", "(", "diff", ")", "if", "diff", ".", "size", ">", "0", "else", "0.0", "\n", "msg", "=", "\"%s: comparing COCO APIs, %s differs by %f\"", "%", "(", "name", ",", "k", ",", "abs_diff", ")", "\n", "self", ".", "assertTrue", "(", "abs_diff", "<", "1e-4", ",", "msg", "=", "msg", ")", "\n", "", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.TestRLEToJson.test": [[78, 97], ["test_coco.make_mask", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "detectron2.data.datasets.coco.convert_to_coco_dict", "pycocotools.decode", "test_coco.TestRLEToJson.assertTrue", "tempfile.TemporaryDirectory", "os.path.join", "detectron2.data.datasets.coco.load_coco_json", "numpy.array_equal", "test_coco.make_dataset_dicts", "detectron2.data.MetadataCatalog.get", "open", "json.dump"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.make_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.convert_to_coco_dict", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.load_coco_json", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.make_dataset_dicts", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump"], ["    ", "def", "test", "(", "self", ")", ":", "\n", "# Make a dummy dataset.", "\n", "        ", "mask", "=", "make_mask", "(", ")", "\n", "DatasetCatalog", ".", "register", "(", "\"test_dataset\"", ",", "lambda", ":", "make_dataset_dicts", "(", "mask", ")", ")", "\n", "MetadataCatalog", ".", "get", "(", "\"test_dataset\"", ")", ".", "set", "(", "thing_classes", "=", "[", "\"test_label\"", "]", ")", "\n", "\n", "# Dump to json.", "\n", "json_dict", "=", "convert_to_coco_dict", "(", "\"test_dataset\"", ")", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdir", ":", "\n", "            ", "json_file_name", "=", "os", ".", "path", ".", "join", "(", "tmpdir", ",", "\"test.json\"", ")", "\n", "with", "open", "(", "json_file_name", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "json", ".", "dump", "(", "json_dict", ",", "f", ")", "\n", "# Load from json.", "\n", "", "dicts", "=", "load_coco_json", "(", "json_file_name", ",", "\"\"", ")", "\n", "\n", "# Check the loaded mask matches the original.", "\n", "", "anno", "=", "dicts", "[", "0", "]", "[", "\"annotations\"", "]", "[", "0", "]", "\n", "loaded_mask", "=", "mask_util", ".", "decode", "(", "anno", "[", "\"segmentation\"", "]", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "array_equal", "(", "loaded_mask", ",", "mask", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.TestRLEToJson.test_uncompressed_RLE": [[98, 104], ["test_coco.make_mask", "pycocotools.encode", "test_coco.uncompressed_rle", "pycocotools.frPyObjects", "test_coco.TestRLEToJson.assertEqual", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.make_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.uncompressed_rle"], ["", "def", "test_uncompressed_RLE", "(", "self", ")", ":", "\n", "        ", "mask", "=", "make_mask", "(", ")", "\n", "rle", "=", "mask_util", ".", "encode", "(", "np", ".", "asarray", "(", "mask", ",", "order", "=", "\"F\"", ")", ")", "\n", "uncompressed", "=", "uncompressed_rle", "(", "mask", ")", "\n", "compressed", "=", "mask_util", ".", "frPyObjects", "(", "uncompressed", ",", "*", "rle", "[", "\"size\"", "]", ")", "\n", "self", ".", "assertEqual", "(", "rle", ",", "compressed", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.make_mask": [[14, 27], ["numpy.zeros", "range", "range", "numpy.linalg.norm", "numpy.array", "numpy.array"], "function", ["None"], ["def", "make_mask", "(", ")", ":", "\n", "    ", "\"\"\"\n    Makes a donut shaped binary mask.\n    \"\"\"", "\n", "H", "=", "100", "\n", "W", "=", "100", "\n", "mask", "=", "np", ".", "zeros", "(", "[", "H", ",", "W", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "x", "in", "range", "(", "W", ")", ":", "\n", "        ", "for", "y", "in", "range", "(", "H", ")", ":", "\n", "            ", "d", "=", "np", ".", "linalg", ".", "norm", "(", "np", ".", "array", "(", "[", "W", ",", "H", "]", ")", "/", "2", "-", "np", ".", "array", "(", "[", "x", ",", "y", "]", ")", ")", "\n", "if", "d", ">", "10", "and", "d", "<", "20", ":", "\n", "                ", "mask", "[", "y", ",", "x", "]", "=", "1", "\n", "", "", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.uncompressed_rle": [[29, 43], ["mask.flatten().tolist", "counts.append", "mask.flatten", "counts.append"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "def", "uncompressed_rle", "(", "mask", ")", ":", "\n", "    ", "l", "=", "mask", ".", "flatten", "(", "order", "=", "\"F\"", ")", ".", "tolist", "(", ")", "\n", "counts", "=", "[", "]", "\n", "p", "=", "False", "\n", "cnt", "=", "0", "\n", "for", "i", "in", "l", ":", "\n", "        ", "if", "i", "==", "p", ":", "\n", "            ", "cnt", "+=", "1", "\n", "", "else", ":", "\n", "            ", "counts", ".", "append", "(", "cnt", ")", "\n", "p", "=", "i", "\n", "cnt", "=", "1", "\n", "", "", "counts", ".", "append", "(", "cnt", ")", "\n", "return", "{", "\"counts\"", ":", "counts", ",", "\"size\"", ":", "[", "mask", ".", "shape", "[", "0", "]", ",", "mask", ".", "shape", "[", "1", "]", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.make_dataset_dicts": [[45, 75], ["numpy.nonzero", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "pycocotools.encode", "test_coco.uncompressed_rle", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.test_coco.uncompressed_rle"], ["", "def", "make_dataset_dicts", "(", "mask", ",", "compressed", ":", "bool", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Returns a list of dicts that represents a single COCO data point for\n    object detection. The single instance given by `mask` is represented by\n    RLE, either compressed or uncompressed.\n    \"\"\"", "\n", "record", "=", "{", "}", "\n", "record", "[", "\"file_name\"", "]", "=", "\"test\"", "\n", "record", "[", "\"image_id\"", "]", "=", "0", "\n", "record", "[", "\"height\"", "]", "=", "mask", ".", "shape", "[", "0", "]", "\n", "record", "[", "\"width\"", "]", "=", "mask", ".", "shape", "[", "1", "]", "\n", "\n", "y", ",", "x", "=", "np", ".", "nonzero", "(", "mask", ")", "\n", "if", "compressed", ":", "\n", "        ", "segmentation", "=", "mask_util", ".", "encode", "(", "np", ".", "asarray", "(", "mask", ",", "order", "=", "\"F\"", ")", ")", "\n", "", "else", ":", "\n", "        ", "segmentation", "=", "uncompressed_rle", "(", "mask", ")", "\n", "", "min_x", "=", "np", ".", "min", "(", "x", ")", "\n", "max_x", "=", "np", ".", "max", "(", "x", ")", "\n", "min_y", "=", "np", ".", "min", "(", "y", ")", "\n", "max_y", "=", "np", ".", "max", "(", "y", ")", "\n", "obj", "=", "{", "\n", "\"bbox\"", ":", "[", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "]", ",", "\n", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", ",", "\n", "\"category_id\"", ":", "0", ",", "\n", "\"iscrowd\"", ":", "0", ",", "\n", "\"segmentation\"", ":", "segmentation", ",", "\n", "}", "\n", "record", "[", "\"annotations\"", "]", "=", "[", "obj", "]", "\n", "return", "[", "record", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.grouped_batch_sampler.GroupedBatchSampler.__init__": [[14, 36], ["numpy.asarray", "numpy.unique().tolist", "isinstance", "ValueError", "numpy.unique"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sampler", ",", "group_ids", ",", "batch_size", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            sampler (Sampler): Base sampler.\n            group_ids (list[int]): If the sampler produces indices in range [0, N),\n                `group_ids` must be a list of `N` ints which contains the group id of each sample.\n                The group ids must be a set of integers in the range [0, num_groups).\n            batch_size (int): Size of mini-batch.\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "sampler", ",", "Sampler", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"sampler should be an instance of \"", "\n", "\"torch.utils.data.Sampler, but got sampler={}\"", ".", "format", "(", "sampler", ")", "\n", ")", "\n", "", "self", ".", "sampler", "=", "sampler", "\n", "self", ".", "group_ids", "=", "np", ".", "asarray", "(", "group_ids", ")", "\n", "assert", "self", ".", "group_ids", ".", "ndim", "==", "1", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "groups", "=", "np", ".", "unique", "(", "self", ".", "group_ids", ")", ".", "tolist", "(", ")", "\n", "\n", "# buffer the indices of each group until batch size is reached", "\n", "self", ".", "buffer_per_group", "=", "{", "k", ":", "[", "]", "for", "k", "in", "groups", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.grouped_batch_sampler.GroupedBatchSampler.__iter__": [[37, 45], ["group_buffer.append", "len"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "idx", "in", "self", ".", "sampler", ":", "\n", "            ", "group_id", "=", "self", ".", "group_ids", "[", "idx", "]", "\n", "group_buffer", "=", "self", ".", "buffer_per_group", "[", "group_id", "]", "\n", "group_buffer", ".", "append", "(", "idx", ")", "\n", "if", "len", "(", "group_buffer", ")", "==", "self", ".", "batch_size", ":", "\n", "                ", "yield", "group_buffer", "[", ":", "]", "# yield a copy of the list", "\n", "del", "group_buffer", "[", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.grouped_batch_sampler.GroupedBatchSampler.__len__": [[46, 48], ["NotImplementedError"], "methods", ["None"], ["", "", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"len() of GroupedBatchSampler is not well-defined.\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.TrainingSampler.__init__": [[24, 42], ["int", "detectron2.utils.comm.get_rank", "detectron2.utils.comm.get_world_size", "detectron2.utils.comm.shared_random_seed"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.shared_random_seed"], ["def", "__init__", "(", "self", ",", "size", ":", "int", ",", "shuffle", ":", "bool", "=", "True", ",", "seed", ":", "Optional", "[", "int", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            size (int): the total number of data of the underlying dataset to sample from\n            shuffle (bool): whether to shuffle the indices or not\n            seed (int): the initial seed of the shuffle. Must be the same\n                across all workers. If None, will use a random seed shared\n                among workers (require synchronization among all workers).\n        \"\"\"", "\n", "self", ".", "_size", "=", "size", "\n", "assert", "size", ">", "0", "\n", "self", ".", "_shuffle", "=", "shuffle", "\n", "if", "seed", "is", "None", ":", "\n", "            ", "seed", "=", "comm", ".", "shared_random_seed", "(", ")", "\n", "", "self", ".", "_seed", "=", "int", "(", "seed", ")", "\n", "\n", "self", ".", "_rank", "=", "comm", ".", "get_rank", "(", ")", "\n", "self", ".", "_world_size", "=", "comm", ".", "get_world_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.TrainingSampler.__iter__": [[43, 46], ["itertools.islice", "distributed_sampler.TrainingSampler._infinite_indices"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.RepeatFactorTrainingSampler._infinite_indices"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "start", "=", "self", ".", "_rank", "\n", "yield", "from", "itertools", ".", "islice", "(", "self", ".", "_infinite_indices", "(", ")", ",", "start", ",", "None", ",", "self", ".", "_world_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.TrainingSampler._infinite_indices": [[47, 55], ["torch.Generator", "torch.Generator.manual_seed", "torch.randperm", "torch.arange"], "methods", ["None"], ["", "def", "_infinite_indices", "(", "self", ")", ":", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "_seed", ")", "\n", "while", "True", ":", "\n", "            ", "if", "self", ".", "_shuffle", ":", "\n", "                ", "yield", "from", "torch", ".", "randperm", "(", "self", ".", "_size", ",", "generator", "=", "g", ")", "\n", "", "else", ":", "\n", "                ", "yield", "from", "torch", ".", "arange", "(", "self", ".", "_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.RepeatFactorTrainingSampler.__init__": [[63, 84], ["int", "detectron2.utils.comm.get_rank", "detectron2.utils.comm.get_world_size", "torch.trunc", "detectron2.utils.comm.shared_random_seed"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.shared_random_seed"], ["def", "__init__", "(", "self", ",", "repeat_factors", ",", "*", ",", "shuffle", "=", "True", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            repeat_factors (Tensor): a float vector, the repeat factor for each indice. When it's\n                full of ones, it is equivalent to ``TrainingSampler(len(repeat_factors), ...)``.\n            shuffle (bool): whether to shuffle the indices or not\n            seed (int): the initial seed of the shuffle. Must be the same\n                across all workers. If None, will use a random seed shared\n                among workers (require synchronization among all workers).\n        \"\"\"", "\n", "self", ".", "_shuffle", "=", "shuffle", "\n", "if", "seed", "is", "None", ":", "\n", "            ", "seed", "=", "comm", ".", "shared_random_seed", "(", ")", "\n", "", "self", ".", "_seed", "=", "int", "(", "seed", ")", "\n", "\n", "self", ".", "_rank", "=", "comm", ".", "get_rank", "(", ")", "\n", "self", ".", "_world_size", "=", "comm", ".", "get_world_size", "(", ")", "\n", "\n", "# Split into whole number (_int_part) and fractional (_frac_part) parts.", "\n", "self", ".", "_int_part", "=", "torch", ".", "trunc", "(", "repeat_factors", ")", "\n", "self", ".", "_frac_part", "=", "repeat_factors", "-", "self", ".", "_int_part", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.RepeatFactorTrainingSampler.repeat_factors_from_category_frequency": [[85, 131], ["collections.defaultdict", "len", "collections.defaultdict.items", "torch.tensor", "max", "max", "rep_factors.append", "math.sqrt", "collections.defaultdict.items"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "repeat_factors_from_category_frequency", "(", "dataset_dicts", ",", "repeat_thresh", ")", ":", "\n", "        ", "\"\"\"\n        Compute (fractional) per-image repeat factors based on category frequency.\n        The repeat factor for an image is a function of the frequency of the rarest\n        category labeled in that image. The \"frequency of category c\" in [0, 1] is defined\n        as the fraction of images in the training set (without repeats) in which category c\n        appears.\n        See :paper:`lvis` (>= v2) Appendix B.2.\n\n        Args:\n            dataset_dicts (list[dict]): annotations in Detectron2 dataset format.\n            repeat_thresh (float): frequency threshold below which data is repeated.\n                If the frequency is half of `repeat_thresh`, the image will be\n                repeated twice.\n\n        Returns:\n            torch.Tensor: the i-th element is the repeat factor for the dataset image\n                at index i.\n        \"\"\"", "\n", "# 1. For each category c, compute the fraction of images that contain it: f(c)", "\n", "category_freq", "=", "defaultdict", "(", "int", ")", "\n", "for", "dataset_dict", "in", "dataset_dicts", ":", "# For each image (without repeats)", "\n", "            ", "cat_ids", "=", "{", "ann", "[", "\"category_id\"", "]", "for", "ann", "in", "dataset_dict", "[", "\"annotations\"", "]", "}", "\n", "for", "cat_id", "in", "cat_ids", ":", "\n", "                ", "category_freq", "[", "cat_id", "]", "+=", "1", "\n", "", "", "num_images", "=", "len", "(", "dataset_dicts", ")", "\n", "for", "k", ",", "v", "in", "category_freq", ".", "items", "(", ")", ":", "\n", "            ", "category_freq", "[", "k", "]", "=", "v", "/", "num_images", "\n", "\n", "# 2. For each category c, compute the category-level repeat factor:", "\n", "#    r(c) = max(1, sqrt(t / f(c)))", "\n", "", "category_rep", "=", "{", "\n", "cat_id", ":", "max", "(", "1.0", ",", "math", ".", "sqrt", "(", "repeat_thresh", "/", "cat_freq", ")", ")", "\n", "for", "cat_id", ",", "cat_freq", "in", "category_freq", ".", "items", "(", ")", "\n", "}", "\n", "\n", "# 3. For each image I, compute the image-level repeat factor:", "\n", "#    r(I) = max_{c in I} r(c)", "\n", "rep_factors", "=", "[", "]", "\n", "for", "dataset_dict", "in", "dataset_dicts", ":", "\n", "            ", "cat_ids", "=", "{", "ann", "[", "\"category_id\"", "]", "for", "ann", "in", "dataset_dict", "[", "\"annotations\"", "]", "}", "\n", "rep_factor", "=", "max", "(", "{", "category_rep", "[", "cat_id", "]", "for", "cat_id", "in", "cat_ids", "}", ")", "\n", "rep_factors", ".", "append", "(", "rep_factor", ")", "\n", "\n", "", "return", "torch", ".", "tensor", "(", "rep_factors", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.RepeatFactorTrainingSampler._get_epoch_indices": [[132, 154], ["torch.rand", "enumerate", "torch.tensor", "len", "indices.extend", "int", "rep_factor.item"], "methods", ["None"], ["", "def", "_get_epoch_indices", "(", "self", ",", "generator", ")", ":", "\n", "        ", "\"\"\"\n        Create a list of dataset indices (with repeats) to use for one epoch.\n\n        Args:\n            generator (torch.Generator): pseudo random number generator used for\n                stochastic rounding.\n\n        Returns:\n            torch.Tensor: list of dataset indices to use in one epoch. Each index\n                is repeated based on its calculated repeat factor.\n        \"\"\"", "\n", "# Since repeat factors are fractional, we use stochastic rounding so", "\n", "# that the target repeat factor is achieved in expectation over the", "\n", "# course of training", "\n", "rands", "=", "torch", ".", "rand", "(", "len", "(", "self", ".", "_frac_part", ")", ",", "generator", "=", "generator", ")", "\n", "rep_factors", "=", "self", ".", "_int_part", "+", "(", "rands", "<", "self", ".", "_frac_part", ")", ".", "float", "(", ")", "\n", "# Construct a list of indices in which we repeat images as specified", "\n", "indices", "=", "[", "]", "\n", "for", "dataset_index", ",", "rep_factor", "in", "enumerate", "(", "rep_factors", ")", ":", "\n", "            ", "indices", ".", "extend", "(", "[", "dataset_index", "]", "*", "int", "(", "rep_factor", ".", "item", "(", ")", ")", ")", "\n", "", "return", "torch", ".", "tensor", "(", "indices", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.RepeatFactorTrainingSampler.__iter__": [[155, 158], ["itertools.islice", "distributed_sampler.RepeatFactorTrainingSampler._infinite_indices"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.RepeatFactorTrainingSampler._infinite_indices"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "start", "=", "self", ".", "_rank", "\n", "yield", "from", "itertools", ".", "islice", "(", "self", ".", "_infinite_indices", "(", ")", ",", "start", ",", "None", ",", "self", ".", "_world_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.RepeatFactorTrainingSampler._infinite_indices": [[159, 171], ["torch.Generator", "torch.Generator.manual_seed", "distributed_sampler.RepeatFactorTrainingSampler._get_epoch_indices", "torch.randperm", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.RepeatFactorTrainingSampler._get_epoch_indices"], ["", "def", "_infinite_indices", "(", "self", ")", ":", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "_seed", ")", "\n", "while", "True", ":", "\n", "# Sample indices with repeats determined by stochastic rounding; each", "\n", "# \"epoch\" may have a slightly different size due to the rounding.", "\n", "            ", "indices", "=", "self", ".", "_get_epoch_indices", "(", "g", ")", "\n", "if", "self", ".", "_shuffle", ":", "\n", "                ", "randperm", "=", "torch", ".", "randperm", "(", "len", "(", "indices", ")", ",", "generator", "=", "g", ")", "\n", "yield", "from", "indices", "[", "randperm", "]", "\n", "", "else", ":", "\n", "                ", "yield", "from", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.InferenceSampler.__init__": [[181, 195], ["detectron2.utils.comm.get_rank", "detectron2.utils.comm.get_world_size", "min", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size"], ["def", "__init__", "(", "self", ",", "size", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            size (int): the total number of data of the underlying dataset to sample from\n        \"\"\"", "\n", "self", ".", "_size", "=", "size", "\n", "assert", "size", ">", "0", "\n", "self", ".", "_rank", "=", "comm", ".", "get_rank", "(", ")", "\n", "self", ".", "_world_size", "=", "comm", ".", "get_world_size", "(", ")", "\n", "\n", "shard_size", "=", "(", "self", ".", "_size", "-", "1", ")", "//", "self", ".", "_world_size", "+", "1", "\n", "begin", "=", "shard_size", "*", "self", ".", "_rank", "\n", "end", "=", "min", "(", "shard_size", "*", "(", "self", ".", "_rank", "+", "1", ")", ",", "self", ".", "_size", ")", "\n", "self", ".", "_local_indices", "=", "range", "(", "begin", ",", "end", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.InferenceSampler.__iter__": [[196, 198], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "yield", "from", "self", ".", "_local_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.distributed_sampler.InferenceSampler.__len__": [[199, 201], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_local_indices", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_confidence_based.DensePoseConfidenceBasedSampler.__init__": [[16, 52], ["densepose_base.DensePoseBaseSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "confidence_channel", ":", "str", ",", "\n", "count_per_class", ":", "int", "=", "8", ",", "\n", "search_count_multiplier", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "search_proportion", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Constructor\n\n        Args:\n          confidence_channel (str): confidence channel to use for sampling;\n            possible values:\n              \"sigma_2\": confidences for UV values\n              \"fine_segm_confidence\": confidences for fine segmentation\n              \"coarse_segm_confidence\": confidences for coarse segmentation\n            (default: \"sigma_2\")\n          count_per_class (int): the sampler produces at most `count_per_class`\n              samples for each category (default: 8)\n          search_count_multiplier (float or None): if not None, the total number\n              of the most confident estimates of a given class to consider is\n              defined as `min(search_count_multiplier * count_per_class, N)`,\n              where `N` is the total number of estimates of the class; cannot be\n              specified together with `search_proportion` (default: None)\n          search_proportion (float or None): if not None, the total number of the\n              of the most confident estimates of a given class to consider is\n              defined as `min(max(search_proportion * N, count_per_class), N)`,\n              where `N` is the total number of estimates of the class; cannot be\n              specified together with `search_count_multiplier` (default: None)\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "count_per_class", ")", "\n", "self", ".", "confidence_channel", "=", "confidence_channel", "\n", "self", ".", "search_count_multiplier", "=", "search_count_multiplier", "\n", "self", ".", "search_proportion", "=", "search_proportion", "\n", "assert", "(", "search_count_multiplier", "is", "None", ")", "or", "(", "search_proportion", "is", "None", ")", ",", "(", "\n", "f\"Cannot specify both search_count_multiplier (={search_count_multiplier})\"", "\n", "f\"and search_proportion (={search_proportion})\"", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_confidence_based.DensePoseConfidenceBasedSampler._confidence_channels": [[55, 60], ["None"], "methods", ["None"], ["", "def", "_confidence_channels", "(", "self", ")", "->", "Optional", "[", "List", "[", "str", "]", "]", ":", "\n", "        ", "\"\"\"\n        Confedence channels to be used for sampling (to be overridden in children)\n        \"\"\"", "\n", "return", "[", "self", ".", "confidence_channel", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_confidence_based.DensePoseConfidenceBasedSampler._produce_index_sample": [[61, 92], ["list", "torch.sort", "random.sample", "range", "min", "range", "int", "min", "min", "max", "int"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "_produce_index_sample", "(", "self", ",", "values", ":", "torch", ".", "Tensor", ",", "count", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Produce a sample of indices to select data based on confidences\n\n        Args:\n            values (torch.Tensor): an array of size [n, k] that contains\n                estimated values (U, V, confidences);\n                n: number of channels (U, V, confidences)\n                k: number of points labeled with part_id\n            count (int): number of samples to produce, should be positive and <= k\n\n        Return:\n            list(int): indices of values (along axis 1) selected as a sample\n        \"\"\"", "\n", "k", "=", "values", ".", "shape", "[", "1", "]", "\n", "if", "k", "==", "count", ":", "\n", "            ", "index_sample", "=", "list", "(", "range", "(", "k", ")", ")", "\n", "", "else", ":", "\n", "# take the best count * search_count_multiplier pixels,", "\n", "# sample from them uniformly", "\n", "# (here best = smallest variance)", "\n", "            ", "_", ",", "sorted_confidence_indices", "=", "torch", ".", "sort", "(", "values", "[", "2", "]", ")", "\n", "if", "self", ".", "search_count_multiplier", "is", "not", "None", ":", "\n", "                ", "search_count", "=", "min", "(", "int", "(", "count", "*", "self", ".", "search_count_multiplier", ")", ",", "k", ")", "\n", "", "elif", "self", ".", "search_proportion", "is", "not", "None", ":", "\n", "                ", "search_count", "=", "min", "(", "max", "(", "int", "(", "k", "*", "self", ".", "search_proportion", ")", ",", "count", ")", ",", "k", ")", "\n", "", "else", ":", "\n", "                ", "search_count", "=", "min", "(", "count", ",", "k", ")", "\n", "", "sample_from_top", "=", "random", ".", "sample", "(", "range", "(", "search_count", ")", ",", "count", ")", "\n", "index_sample", "=", "sorted_confidence_indices", "[", ":", "search_count", "]", "[", "sample_from_top", "]", "\n", "", "return", "index_sample", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.mask_from_densepose.MaskFromDensePoseSampler.__call__": [[48, 60], ["mask_from_densepose.densepose_to_mask"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.mask_from_densepose.densepose_to_mask"], ["def", "__call__", "(", "self", ",", "instances", ":", "Instances", ")", "->", "BitMasks", ":", "\n", "        ", "\"\"\"\n        Converts predicted data from `instances` into the GT mask data\n\n        Args:\n            instances (Instances): predicted results, expected to have `pred_densepose` field\n\n        Returns:\n            Boolean Tensor of the size of the input image that has non-zero\n            values at pixels that are estimated to belong to the detected object\n        \"\"\"", "\n", "return", "densepose_to_mask", "(", "instances", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.mask_from_densepose.densepose_to_mask": [[10, 37], ["instances.pred_boxes.tensor.clone().cpu", "detectron2.structures.BoxMode.convert", "len", "torch.zeros", "enumerate", "detectron2.structures.BitMasks", "structures.resample_output_to_bbox", "box_xywh.long().tolist", "instances.pred_boxes.tensor.clone", "torch.device", "labels_i.cpu", "box_xywh.long"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.resample_output_to_bbox", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["def", "densepose_to_mask", "(", "instances", ":", "Instances", ")", "->", "BitMasks", ":", "\n", "    ", "\"\"\"\n    Produce masks from DensePose predictions\n    DensePose predictions for a given image, stored in `pred_densepose` field,\n    are instances of DensePoseOutput. This sampler takes\n    `S` and `I` output tensors (coarse and fine segmentation) and converts\n    then to a mask tensor, which is a bool tensor of the size of the input\n    image\n\n    Args:\n        instances (Instances): predicted results, expected to have `pred_densepose` field\n            that contains `DensePoseOutput` objects\n\n    Returns:\n        `BitMasks` instance with boolean tensors of the size of the input image that have non-zero\n            values at pixels that are estimated to belong to the detected objects\n    \"\"\"", "\n", "H", ",", "W", "=", "instances", ".", "image_size", "\n", "boxes_xyxy_abs", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "clone", "(", ")", ".", "cpu", "(", ")", "\n", "boxes_xywh_abs", "=", "BoxMode", ".", "convert", "(", "boxes_xyxy_abs", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "N", "=", "len", "(", "boxes_xywh_abs", ")", "\n", "gt_masks", "=", "torch", ".", "zeros", "(", "(", "N", ",", "H", ",", "W", ")", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "for", "i", ",", "box_xywh", "in", "enumerate", "(", "boxes_xywh_abs", ")", ":", "\n", "        ", "labels_i", ",", "_", "=", "resample_output_to_bbox", "(", "instances", ".", "pred_densepose", "[", "i", "]", ",", "box_xywh", ")", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "box_xywh", ".", "long", "(", ")", ".", "tolist", "(", ")", "\n", "gt_masks", "[", "i", ",", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "=", "labels_i", ".", "cpu", "(", ")", ">", "0", "\n", "", "return", "BitMasks", "(", "gt_masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_base.DensePoseBaseSampler.__init__": [[24, 33], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "count_per_class", ":", "int", "=", "8", ")", ":", "\n", "        ", "\"\"\"\n        Constructor\n\n        Args:\n          count_per_class (int): the sampler produces at most `count_per_class`\n              samples for each category\n        \"\"\"", "\n", "self", ".", "count_per_class", "=", "count_per_class", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_base.DensePoseBaseSampler.__call__": [[34, 55], ["instances.pred_boxes.tensor.clone().cpu", "detectron2.structures.BoxMode.convert", "enumerate", "structures.DensePoseList", "structures.resample_output_to_bbox", "densepose_base.DensePoseBaseSampler._sample", "densepose_base.DensePoseBaseSampler._resample_mask", "dp_datas.append", "instances.pred_boxes.tensor.clone", "densepose_base.DensePoseBaseSampler._confidence_channels", "labels_i.cpu", "result_i.cpu", "structures.DensePoseDataRelative"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.resample_output_to_bbox", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_base.DensePoseBaseSampler._sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_base.DensePoseBaseSampler._resample_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_base.DensePoseBaseSampler._confidence_channels"], ["", "def", "__call__", "(", "self", ",", "instances", ":", "Instances", ")", "->", "DensePoseList", ":", "\n", "        ", "\"\"\"\n        Convert DensePose predictions (an instance of `DensePoseOutput`)\n        into DensePose annotations data (an instance of `DensePoseList`)\n        \"\"\"", "\n", "boxes_xyxy_abs", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "clone", "(", ")", ".", "cpu", "(", ")", "\n", "boxes_xywh_abs", "=", "BoxMode", ".", "convert", "(", "boxes_xyxy_abs", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "dp_datas", "=", "[", "]", "\n", "for", "i", ",", "box_xywh", "in", "enumerate", "(", "boxes_xywh_abs", ")", ":", "\n", "            ", "labels_i", ",", "result_i", "=", "resample_output_to_bbox", "(", "\n", "instances", ".", "pred_densepose", "[", "i", "]", ",", "box_xywh", ",", "self", ".", "_confidence_channels", "(", ")", "\n", ")", "\n", "annotation_i", "=", "self", ".", "_sample", "(", "labels_i", ".", "cpu", "(", ")", ",", "result_i", ".", "cpu", "(", ")", ",", "box_xywh", ")", "\n", "annotation_i", "[", "DensePoseDataRelative", ".", "S_KEY", "]", "=", "self", ".", "_resample_mask", "(", "\n", "instances", ".", "pred_densepose", "[", "i", "]", "\n", ")", "\n", "\n", "dp_datas", ".", "append", "(", "DensePoseDataRelative", "(", "annotation_i", ")", ")", "\n", "# create densepose annotations on CPU", "\n", "", "dp_list", "=", "DensePoseList", "(", "dp_datas", ",", "boxes_xyxy_abs", ",", "instances", ".", "image_size", ")", "\n", "return", "dp_list", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_base.DensePoseBaseSampler._sample": [[56, 102], ["range", "torch.nonzero", "dp_result[].view", "min", "densepose_base.DensePoseBaseSampler._produce_index_sample", "sampled_values[].clamp().cpu().tolist", "sampled_values[].clamp().cpu().tolist", "annotation[].extend", "annotation[].extend", "annotation[].extend", "annotation[].extend", "annotation[].extend", "labels.expand", "sampled_values[].clamp().cpu", "sampled_values[].clamp().cpu", "sampled_values[].clamp", "sampled_values[].clamp"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_uniform.DensePoseUniformSampler._produce_index_sample"], ["", "def", "_sample", "(", "\n", "self", ",", "labels", ":", "torch", ".", "Tensor", ",", "dp_result", ":", "torch", ".", "Tensor", ",", "bbox_xywh", ":", "List", "[", "int", "]", "\n", ")", "->", "DensePoseDataRelative", ":", "\n", "        ", "\"\"\"\n        Sample DensPoseDataRelative from estimation results\n        \"\"\"", "\n", "annotation", "=", "{", "\n", "DensePoseDataRelative", ".", "X_KEY", ":", "[", "]", ",", "\n", "DensePoseDataRelative", ".", "Y_KEY", ":", "[", "]", ",", "\n", "DensePoseDataRelative", ".", "U_KEY", ":", "[", "]", ",", "\n", "DensePoseDataRelative", ".", "V_KEY", ":", "[", "]", ",", "\n", "DensePoseDataRelative", ".", "I_KEY", ":", "[", "]", ",", "\n", "}", "\n", "x0", ",", "y0", ",", "_", ",", "_", "=", "bbox_xywh", "\n", "n", ",", "h", ",", "w", "=", "dp_result", ".", "shape", "\n", "for", "part_id", "in", "range", "(", "1", ",", "DensePoseDataRelative", ".", "N_PART_LABELS", "+", "1", ")", ":", "\n", "# indices - tuple of 3 1D tensors of size k", "\n", "# 0: index along the first dimension N", "\n", "# 1: index along H dimension", "\n", "# 2: index along W dimension", "\n", "            ", "indices", "=", "torch", ".", "nonzero", "(", "labels", ".", "expand", "(", "n", ",", "h", ",", "w", ")", "==", "part_id", ",", "as_tuple", "=", "True", ")", "\n", "# values - an array of size [n, k]", "\n", "# n: number of channels (U, V, confidences)", "\n", "# k: number of points labeled with part_id", "\n", "values", "=", "dp_result", "[", "indices", "]", ".", "view", "(", "n", ",", "-", "1", ")", "\n", "k", "=", "values", ".", "shape", "[", "1", "]", "\n", "count", "=", "min", "(", "self", ".", "count_per_class", ",", "k", ")", "\n", "if", "count", "<=", "0", ":", "\n", "                ", "continue", "\n", "", "index_sample", "=", "self", ".", "_produce_index_sample", "(", "values", ",", "count", ")", "\n", "sampled_values", "=", "values", "[", ":", ",", "index_sample", "]", "\n", "sampled_y", "=", "indices", "[", "1", "]", "[", "index_sample", "]", "+", "0.5", "\n", "sampled_x", "=", "indices", "[", "2", "]", "[", "index_sample", "]", "+", "0.5", "\n", "# prepare / normalize data", "\n", "x", "=", "(", "sampled_x", "/", "w", "*", "256.0", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "y", "=", "(", "sampled_y", "/", "h", "*", "256.0", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "u", "=", "sampled_values", "[", "0", "]", ".", "clamp", "(", "0", ",", "1", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "v", "=", "sampled_values", "[", "1", "]", ".", "clamp", "(", "0", ",", "1", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "fine_segm_labels", "=", "[", "part_id", "]", "*", "count", "\n", "# extend annotations", "\n", "annotation", "[", "DensePoseDataRelative", ".", "X_KEY", "]", ".", "extend", "(", "x", ")", "\n", "annotation", "[", "DensePoseDataRelative", ".", "Y_KEY", "]", ".", "extend", "(", "y", ")", "\n", "annotation", "[", "DensePoseDataRelative", ".", "U_KEY", "]", ".", "extend", "(", "u", ")", "\n", "annotation", "[", "DensePoseDataRelative", ".", "V_KEY", "]", ".", "extend", "(", "v", ")", "\n", "annotation", "[", "DensePoseDataRelative", ".", "I_KEY", "]", ".", "extend", "(", "fine_segm_labels", ")", "\n", "", "return", "annotation", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_base.DensePoseBaseSampler._confidence_channels": [[103, 108], ["None"], "methods", ["None"], ["", "def", "_confidence_channels", "(", "self", ")", "->", "Optional", "[", "List", "[", "str", "]", "]", ":", "\n", "        ", "\"\"\"\n        Confedence channels to be used for sampling (to be overridden in children)\n        \"\"\"", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_base.DensePoseBaseSampler._produce_index_sample": [[109, 126], ["None"], "methods", ["None"], ["", "def", "_produce_index_sample", "(", "self", ",", "values", ":", "torch", ".", "Tensor", ",", "count", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Abstract method to produce a sample of indices to select data\n        To be implemented in descendants\n\n        Args:\n            values (torch.Tensor): an array of size [n, k] that contains\n                estimated values (U, V, confidences);\n                n: number of channels (U, V, confidences)\n                k: number of points labeled with part_id\n            count (int): number of samples to produce, should be positive and <= k\n:w\n\n        Return:\n            list(int): indices of values (along axis 1) selected as a sample\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_base.DensePoseBaseSampler._resample_mask": [[127, 191], ["torch.nn.functional.interpolate().argmax().long", "torch.zeros", "range", "torch.nn.functional.interpolate().argmax", "torch.device", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate().argmax", "torch.nn.functional.interpolate"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["", "def", "_resample_mask", "(", "self", ",", "output", ":", "DensePoseOutput", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Convert output mask tensors into the annotation mask tensor of size\n        (256, 256)\n        \"\"\"", "\n", "sz", "=", "DensePoseDataRelative", ".", "MASK_SIZE", "\n", "S", "=", "(", "\n", "F", ".", "interpolate", "(", "output", ".", "S", ",", "(", "sz", ",", "sz", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", ".", "argmax", "(", "dim", "=", "1", ")", "\n", ".", "long", "(", ")", "\n", ")", "\n", "I", "=", "(", "\n", "(", "\n", "F", ".", "interpolate", "(", "output", ".", "I", ",", "(", "sz", ",", "sz", ")", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", ".", "argmax", "(", "\n", "dim", "=", "1", "\n", ")", "\n", "*", "(", "S", ">", "0", ")", ".", "long", "(", ")", "\n", ")", "\n", ".", "squeeze", "(", ")", "\n", ".", "cpu", "(", ")", "\n", ")", "\n", "# Map fine segmentation results to coarse segmentation ground truth", "\n", "# TODO: extract this into separate classes", "\n", "# coarse segmentation: 1 = Torso, 2 = Right Hand, 3 = Left Hand,", "\n", "# 4 = Left Foot, 5 = Right Foot, 6 = Upper Leg Right, 7 = Upper Leg Left,", "\n", "# 8 = Lower Leg Right, 9 = Lower Leg Left, 10 = Upper Arm Left,", "\n", "# 11 = Upper Arm Right, 12 = Lower Arm Left, 13 = Lower Arm Right,", "\n", "# 14 = Head", "\n", "# fine segmentation: 1, 2 = Torso, 3 = Right Hand, 4 = Left Hand,", "\n", "# 5 = Left Foot, 6 = Right Foot, 7, 9 = Upper Leg Right,", "\n", "# 8, 10 = Upper Leg Left, 11, 13 = Lower Leg Right,", "\n", "# 12, 14 = Lower Leg Left, 15, 17 = Upper Arm Left,", "\n", "# 16, 18 = Upper Arm Right, 19, 21 = Lower Arm Left,", "\n", "# 20, 22 = Lower Arm Right, 23, 24 = Head", "\n", "FINE_TO_COARSE_SEGMENTATION", "=", "{", "\n", "1", ":", "1", ",", "\n", "2", ":", "1", ",", "\n", "3", ":", "2", ",", "\n", "4", ":", "3", ",", "\n", "5", ":", "4", ",", "\n", "6", ":", "5", ",", "\n", "7", ":", "6", ",", "\n", "8", ":", "7", ",", "\n", "9", ":", "6", ",", "\n", "10", ":", "7", ",", "\n", "11", ":", "8", ",", "\n", "12", ":", "9", ",", "\n", "13", ":", "8", ",", "\n", "14", ":", "9", ",", "\n", "15", ":", "10", ",", "\n", "16", ":", "11", ",", "\n", "17", ":", "10", ",", "\n", "18", ":", "11", ",", "\n", "19", ":", "12", ",", "\n", "20", ":", "13", ",", "\n", "21", ":", "12", ",", "\n", "22", ":", "13", ",", "\n", "23", ":", "14", ",", "\n", "24", ":", "14", ",", "\n", "}", "\n", "mask", "=", "torch", ".", "zeros", "(", "(", "sz", ",", "sz", ")", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "for", "i", "in", "range", "(", "DensePoseDataRelative", ".", "N_PART_LABELS", ")", ":", "\n", "            ", "mask", "[", "I", "==", "i", "+", "1", "]", "=", "FINE_TO_COARSE_SEGMENTATION", "[", "i", "+", "1", "]", "\n", "", "return", "mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.__init__": [[33, 39], ["prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "prediction_to_gt.PredictionToGroundTruthSampler.register_sampler"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler"], ["def", "__init__", "(", "self", ",", "dataset_name", ":", "str", "=", "\"\"", ")", ":", "\n", "        ", "self", ".", "dataset_name", "=", "dataset_name", "\n", "self", ".", "_samplers", "=", "{", "}", "\n", "self", ".", "register_sampler", "(", "\"pred_boxes\"", ",", "\"gt_boxes\"", ",", "None", ")", "\n", "self", ".", "register_sampler", "(", "\"pred_classes\"", ",", "\"gt_classes\"", ",", "None", ")", "\n", "self", ".", "register_sampler", "(", "\"scores\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.__call__": [[40, 65], ["prediction_to_gt.PredictionToGroundTruthSampler._samplers.items", "prediction_to_gt.PredictionToGroundTruthSampler._samplers.items", "instances.set", "instances.set", "instances.has", "instances.remove", "instances.has", "instances.get", "sampler.func"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "__call__", "(", "self", ",", "model_output", ":", "ModelOutput", ")", "->", "SampledData", ":", "\n", "        ", "\"\"\"\n        Transform model output into ground truth data through sampling\n\n        Args:\n          model_output (Dict[str, Any]): model output\n        Returns:\n          Dict[str, Any]: sampled data\n        \"\"\"", "\n", "for", "model_output_i", "in", "model_output", ":", "\n", "            ", "instances", ":", "Instances", "=", "model_output_i", "[", "\"instances\"", "]", "\n", "# transform data in each field", "\n", "for", "_", ",", "sampler", "in", "self", ".", "_samplers", ".", "items", "(", ")", ":", "\n", "                ", "if", "not", "instances", ".", "has", "(", "sampler", ".", "src", ")", "or", "sampler", ".", "dst", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "if", "sampler", ".", "func", "is", "None", ":", "\n", "                    ", "instances", ".", "set", "(", "sampler", ".", "dst", ",", "instances", ".", "get", "(", "sampler", ".", "src", ")", ")", "\n", "", "else", ":", "\n", "                    ", "instances", ".", "set", "(", "sampler", ".", "dst", ",", "sampler", ".", "func", "(", "instances", ")", ")", "\n", "# delete model output data that was transformed", "\n", "", "", "for", "_", ",", "sampler", "in", "self", ".", "_samplers", ".", "items", "(", ")", ":", "\n", "                ", "if", "sampler", ".", "src", "!=", "sampler", ".", "dst", "and", "instances", ".", "has", "(", "sampler", ".", "src", ")", ":", "\n", "                    ", "instances", ".", "remove", "(", "sampler", ".", "src", ")", "\n", "", "", "model_output_i", "[", "\"dataset\"", "]", "=", "self", ".", "dataset_name", "\n", "", "return", "model_output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.prediction_to_gt.PredictionToGroundTruthSampler.register_sampler": [[66, 81], ["prediction_to_gt._Sampler"], "methods", ["None"], ["", "def", "register_sampler", "(", "\n", "self", ",", "\n", "prediction_attr", ":", "str", ",", "\n", "gt_attr", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "func", ":", "Optional", "[", "Callable", "[", "[", "Any", "]", ",", "Any", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Register sampler for a field\n\n        Args:\n          prediction_attr (str): field to replace with a sampled value\n          gt_attr (Optional[str]): field to store the sampled value to, if not None\n          func (Optional[Callable: Any -> Any]): sampler function\n        \"\"\"", "\n", "self", ".", "_samplers", "[", "prediction_attr", "]", "=", "_Sampler", "(", "src", "=", "prediction_attr", ",", "dst", "=", "gt_attr", ",", "func", "=", "func", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_uniform.DensePoseUniformSampler.__init__": [[16, 25], ["densepose_base.DensePoseBaseSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "count_per_class", ":", "int", "=", "8", ")", ":", "\n", "        ", "\"\"\"\n        Constructor\n\n        Args:\n          count_per_class (int): the sampler produces at most `count_per_class`\n              samples for each category\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "count_per_class", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.densepose_uniform.DensePoseUniformSampler._produce_index_sample": [[26, 42], ["random.sample", "range"], "methods", ["None"], ["", "def", "_produce_index_sample", "(", "self", ",", "values", ":", "torch", ".", "Tensor", ",", "count", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Produce a uniform sample of indices to select data\n\n        Args:\n            values (torch.Tensor): an array of size [n, k] that contains\n                estimated values (U, V, confidences);\n                n: number of channels (U, V, confidences)\n                k: number of points labeled with part_id\n            count (int): number of samples to produce, should be positive and <= k\n\n        Return:\n            list(int): indices of values (along axis 1) selected as a sample\n        \"\"\"", "\n", "k", "=", "values", ".", "shape", "[", "1", "]", "\n", "return", "random", ".", "sample", "(", "range", "(", "k", ")", ",", "count", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomApply.__init__": [[41, 54], ["augmentation.Augmentation.__init__", "augmentation._transform_to_aug"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation._transform_to_aug"], ["def", "__init__", "(", "self", ",", "tfm_or_aug", ",", "prob", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tfm_or_aug (Transform, Augmentation): the transform or augmentation\n                to be applied. It can either be a `Transform` or `Augmentation`\n                instance.\n            prob (float): probability between 0.0 and 1.0 that\n                the wrapper transformation is applied\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "aug", "=", "_transform_to_aug", "(", "tfm_or_aug", ")", "\n", "assert", "0.0", "<=", "prob", "<=", "1.0", ",", "f\"Probablity must be between 0.0 and 1.0 (given: {prob})\"", "\n", "self", ".", "prob", "=", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomApply.get_transform": [[55, 61], ["augmentation_impl.RandomApply._rand_range", "augmentation_impl.RandomApply.aug.get_transform", "fvcore.transforms.transform.NoOpTransform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._rand_range", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.get_transform"], ["", "def", "get_transform", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "do", "=", "self", ".", "_rand_range", "(", ")", "<", "self", ".", "prob", "\n", "if", "do", ":", "\n", "            ", "return", "self", ".", "aug", ".", "get_transform", "(", "*", "args", ")", "\n", "", "else", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomApply.__call__": [[62, 68], ["augmentation_impl.RandomApply._rand_range", "augmentation_impl.RandomApply.aug", "fvcore.transforms.transform.NoOpTransform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._rand_range"], ["", "", "def", "__call__", "(", "self", ",", "aug_input", ")", ":", "\n", "        ", "do", "=", "self", ".", "_rand_range", "(", ")", "<", "self", ".", "prob", "\n", "if", "do", ":", "\n", "            ", "return", "self", ".", "aug", "(", "aug_input", ")", "\n", "", "else", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomFlip.__init__": [[75, 89], ["augmentation.Augmentation.__init__", "augmentation_impl.RandomFlip._init", "ValueError", "ValueError", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "self", ",", "prob", "=", "0.5", ",", "*", ",", "horizontal", "=", "True", ",", "vertical", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            prob (float): probability of flip.\n            horizontal (boolean): whether to apply horizontal flipping\n            vertical (boolean): whether to apply vertical flipping\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "horizontal", "and", "vertical", ":", "\n", "            ", "raise", "ValueError", "(", "\"Cannot do both horiz and vert. Please use two Flip instead.\"", ")", "\n", "", "if", "not", "horizontal", "and", "not", "vertical", ":", "\n", "            ", "raise", "ValueError", "(", "\"At least one of horiz or vert has to be True!\"", ")", "\n", "", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomFlip.get_transform": [[90, 100], ["augmentation_impl.RandomFlip._rand_range", "fvcore.transforms.transform.NoOpTransform", "fvcore.transforms.transform.HFlipTransform", "fvcore.transforms.transform.VFlipTransform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._rand_range"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "h", ",", "w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "do", "=", "self", ".", "_rand_range", "(", ")", "<", "self", ".", "prob", "\n", "if", "do", ":", "\n", "            ", "if", "self", ".", "horizontal", ":", "\n", "                ", "return", "HFlipTransform", "(", "w", ")", "\n", "", "elif", "self", ".", "vertical", ":", "\n", "                ", "return", "VFlipTransform", "(", "h", ")", "\n", "", "", "else", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.Resize.__init__": [[105, 115], ["isinstance", "tuple", "augmentation_impl.Resize._init", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "self", ",", "shape", ",", "interp", "=", "Image", ".", "BILINEAR", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            shape: (h, w) tuple or a int\n            interp: PIL interpolation method\n        \"\"\"", "\n", "if", "isinstance", "(", "shape", ",", "int", ")", ":", "\n", "            ", "shape", "=", "(", "shape", ",", "shape", ")", "\n", "", "shape", "=", "tuple", "(", "shape", ")", "\n", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.Resize.get_transform": [[116, 119], ["transform.ResizeTransform"], "methods", ["None"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "return", "ResizeTransform", "(", "\n", "image", ".", "shape", "[", "0", "]", ",", "image", ".", "shape", "[", "1", "]", ",", "self", ".", "shape", "[", "0", "]", ",", "self", ".", "shape", "[", "1", "]", ",", "self", ".", "interp", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.ResizeShortestEdge.__init__": [[128, 151], ["augmentation.Augmentation.__init__", "isinstance", "augmentation_impl.ResizeShortestEdge._init", "locals", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "\n", "self", ",", "short_edge_length", ",", "max_size", "=", "sys", ".", "maxsize", ",", "sample_style", "=", "\"range\"", ",", "interp", "=", "Image", ".", "BILINEAR", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            short_edge_length (list[int]): If ``sample_style==\"range\"``,\n                a [min, max] interval from which to sample the shortest edge length.\n                If ``sample_style==\"choice\"``, a list of shortest edge lengths to sample from.\n            max_size (int): maximum allowed longest edge length.\n            sample_style (str): either \"range\" or \"choice\".\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "sample_style", "in", "[", "\"range\"", ",", "\"choice\"", "]", ",", "sample_style", "\n", "\n", "self", ".", "is_range", "=", "sample_style", "==", "\"range\"", "\n", "if", "isinstance", "(", "short_edge_length", ",", "int", ")", ":", "\n", "            ", "short_edge_length", "=", "(", "short_edge_length", ",", "short_edge_length", ")", "\n", "", "if", "self", ".", "is_range", ":", "\n", "            ", "assert", "len", "(", "short_edge_length", ")", "==", "2", ",", "(", "\n", "\"short_edge_length must be two values using 'range' sample style.\"", "\n", "f\" Got {short_edge_length}!\"", "\n", ")", "\n", "", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.ResizeShortestEdge.get_transform": [[152, 173], ["int", "int", "transform.ResizeTransform", "numpy.random.randint", "numpy.random.choice", "fvcore.transforms.transform.NoOpTransform", "min", "max", "max"], "methods", ["None"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "h", ",", "w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "if", "self", ".", "is_range", ":", "\n", "            ", "size", "=", "np", ".", "random", ".", "randint", "(", "self", ".", "short_edge_length", "[", "0", "]", ",", "self", ".", "short_edge_length", "[", "1", "]", "+", "1", ")", "\n", "", "else", ":", "\n", "            ", "size", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "short_edge_length", ")", "\n", "", "if", "size", "==", "0", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "scale", "=", "size", "*", "1.0", "/", "min", "(", "h", ",", "w", ")", "\n", "if", "h", "<", "w", ":", "\n", "            ", "newh", ",", "neww", "=", "size", ",", "scale", "*", "w", "\n", "", "else", ":", "\n", "            ", "newh", ",", "neww", "=", "scale", "*", "h", ",", "size", "\n", "", "if", "max", "(", "newh", ",", "neww", ")", ">", "self", ".", "max_size", ":", "\n", "            ", "scale", "=", "self", ".", "max_size", "*", "1.0", "/", "max", "(", "newh", ",", "neww", ")", "\n", "newh", "=", "newh", "*", "scale", "\n", "neww", "=", "neww", "*", "scale", "\n", "", "neww", "=", "int", "(", "neww", "+", "0.5", ")", "\n", "newh", "=", "int", "(", "newh", "+", "0.5", ")", "\n", "return", "ResizeTransform", "(", "h", ",", "w", ",", "newh", ",", "neww", ",", "self", ".", "interp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomRotation.__init__": [[181, 204], ["augmentation.Augmentation.__init__", "isinstance", "augmentation_impl.RandomRotation._init", "isinstance", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "self", ",", "angle", ",", "expand", "=", "True", ",", "center", "=", "None", ",", "sample_style", "=", "\"range\"", ",", "interp", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            angle (list[float]): If ``sample_style==\"range\"``,\n                a [min, max] interval from which to sample the angle (in degrees).\n                If ``sample_style==\"choice\"``, a list of angles to sample from\n            expand (bool): choose if the image should be resized to fit the whole\n                rotated image (default), or simply cropped\n            center (list[[float, float]]):  If ``sample_style==\"range\"``,\n                a [[minx, miny], [maxx, maxy]] relative interval from which to sample the center,\n                [0, 0] being the top left of the image and [1, 1] the bottom right.\n                If ``sample_style==\"choice\"``, a list of centers to sample from\n                Default: None, which means that the center of rotation is the center of the image\n                center has no effect if expand=True because it only affects shifting\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "sample_style", "in", "[", "\"range\"", ",", "\"choice\"", "]", ",", "sample_style", "\n", "self", ".", "is_range", "=", "sample_style", "==", "\"range\"", "\n", "if", "isinstance", "(", "angle", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "            ", "angle", "=", "(", "angle", ",", "angle", ")", "\n", "", "if", "center", "is", "not", "None", "and", "isinstance", "(", "center", "[", "0", "]", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "            ", "center", "=", "(", "center", ",", "center", ")", "\n", "", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomRotation.get_transform": [[205, 227], ["transform.RotationTransform", "numpy.random.uniform", "numpy.random.choice", "fvcore.transforms.transform.NoOpTransform", "numpy.random.choice", "numpy.random.uniform", "numpy.random.uniform"], "methods", ["None"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "h", ",", "w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "center", "=", "None", "\n", "if", "self", ".", "is_range", ":", "\n", "            ", "angle", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "angle", "[", "0", "]", ",", "self", ".", "angle", "[", "1", "]", ")", "\n", "if", "self", ".", "center", "is", "not", "None", ":", "\n", "                ", "center", "=", "(", "\n", "np", ".", "random", ".", "uniform", "(", "self", ".", "center", "[", "0", "]", "[", "0", "]", ",", "self", ".", "center", "[", "1", "]", "[", "0", "]", ")", ",", "\n", "np", ".", "random", ".", "uniform", "(", "self", ".", "center", "[", "0", "]", "[", "1", "]", ",", "self", ".", "center", "[", "1", "]", "[", "1", "]", ")", ",", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "angle", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "angle", ")", "\n", "if", "self", ".", "center", "is", "not", "None", ":", "\n", "                ", "center", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "center", ")", "\n", "\n", "", "", "if", "center", "is", "not", "None", ":", "\n", "            ", "center", "=", "(", "w", "*", "center", "[", "0", "]", ",", "h", "*", "center", "[", "1", "]", ")", "# Convert to absolute coordinates", "\n", "\n", "", "if", "angle", "%", "360", "==", "0", ":", "\n", "            ", "return", "NoOpTransform", "(", ")", "\n", "\n", "", "return", "RotationTransform", "(", "h", ",", "w", ",", "angle", ",", "expand", "=", "self", ".", "expand", ",", "center", "=", "center", ",", "interp", "=", "self", ".", "interp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomCrop.__init__": [[234, 245], ["augmentation.Augmentation.__init__", "augmentation_impl.RandomCrop._init", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "self", ",", "crop_type", ":", "str", ",", "crop_size", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            crop_type (str): one of \"relative_range\", \"relative\", \"absolute\", \"absolute_range\".\n                See `config/defaults.py` for explanation.\n            crop_size (tuple[float]): the relative ratio or absolute pixels of\n                height and width\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "crop_type", "in", "[", "\"relative_range\"", ",", "\"relative\"", ",", "\"absolute\"", ",", "\"absolute_range\"", "]", "\n", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomCrop.get_transform": [[246, 253], ["augmentation_impl.RandomCrop.get_crop_size", "numpy.random.randint", "numpy.random.randint", "fvcore.transforms.transform.CropTransform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomCrop.get_crop_size"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "h", ",", "w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "croph", ",", "cropw", "=", "self", ".", "get_crop_size", "(", "(", "h", ",", "w", ")", ")", "\n", "assert", "h", ">=", "croph", "and", "w", ">=", "cropw", ",", "\"Shape computation in {} has bugs.\"", ".", "format", "(", "self", ")", "\n", "h0", "=", "np", ".", "random", ".", "randint", "(", "h", "-", "croph", "+", "1", ")", "\n", "w0", "=", "np", ".", "random", ".", "randint", "(", "w", "-", "cropw", "+", "1", ")", "\n", "return", "CropTransform", "(", "w0", ",", "h0", ",", "cropw", ",", "croph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomCrop.get_crop_size": [[254, 279], ["int", "int", "numpy.asarray", "int", "int", "numpy.random.rand", "min", "min", "numpy.random.randint", "numpy.random.randint", "NotImplementedError", "min", "min", "min", "min"], "methods", ["None"], ["", "def", "get_crop_size", "(", "self", ",", "image_size", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image_size (tuple): height, width\n\n        Returns:\n            crop_size (tuple): height, width in absolute pixels\n        \"\"\"", "\n", "h", ",", "w", "=", "image_size", "\n", "if", "self", ".", "crop_type", "==", "\"relative\"", ":", "\n", "            ", "ch", ",", "cw", "=", "self", ".", "crop_size", "\n", "return", "int", "(", "h", "*", "ch", "+", "0.5", ")", ",", "int", "(", "w", "*", "cw", "+", "0.5", ")", "\n", "", "elif", "self", ".", "crop_type", "==", "\"relative_range\"", ":", "\n", "            ", "crop_size", "=", "np", ".", "asarray", "(", "self", ".", "crop_size", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "ch", ",", "cw", "=", "crop_size", "+", "np", ".", "random", ".", "rand", "(", "2", ")", "*", "(", "1", "-", "crop_size", ")", "\n", "return", "int", "(", "h", "*", "ch", "+", "0.5", ")", ",", "int", "(", "w", "*", "cw", "+", "0.5", ")", "\n", "", "elif", "self", ".", "crop_type", "==", "\"absolute\"", ":", "\n", "            ", "return", "(", "min", "(", "self", ".", "crop_size", "[", "0", "]", ",", "h", ")", ",", "min", "(", "self", ".", "crop_size", "[", "1", "]", ",", "w", ")", ")", "\n", "", "elif", "self", ".", "crop_type", "==", "\"absolute_range\"", ":", "\n", "            ", "assert", "self", ".", "crop_size", "[", "0", "]", "<=", "self", ".", "crop_size", "[", "1", "]", "\n", "ch", "=", "np", ".", "random", ".", "randint", "(", "min", "(", "h", ",", "self", ".", "crop_size", "[", "0", "]", ")", ",", "min", "(", "h", ",", "self", ".", "crop_size", "[", "1", "]", ")", "+", "1", ")", "\n", "cw", "=", "np", ".", "random", ".", "randint", "(", "min", "(", "w", ",", "self", ".", "crop_size", "[", "0", "]", ")", ",", "min", "(", "w", ",", "self", ".", "crop_size", "[", "1", "]", ")", "+", "1", ")", "\n", "return", "ch", ",", "cw", "\n", "", "else", ":", "\n", "            ", "NotImplementedError", "(", "\"Unknown crop type {}\"", ".", "format", "(", "self", ".", "crop_type", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomCrop_CategoryAreaConstraint.__init__": [[289, 307], ["augmentation_impl.RandomCrop", "augmentation_impl.RandomCrop_CategoryAreaConstraint._init", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "\n", "self", ",", "\n", "crop_type", ":", "str", ",", "\n", "crop_size", ",", "\n", "single_category_max_area", ":", "float", "=", "1.0", ",", "\n", "ignored_category", ":", "int", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            crop_type, crop_size: same as in :class:`RandomCrop`\n            single_category_max_area: the maximum allowed area ratio of a\n                category. Set to 1.0 to disable\n            ignored_category: allow this category in the semantic segmentation\n                ground truth to exceed the area ratio. Usually set to the category\n                that's ignored in training.\n        \"\"\"", "\n", "self", ".", "crop_aug", "=", "RandomCrop", "(", "crop_type", ",", "crop_size", ")", "\n", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomCrop_CategoryAreaConstraint.get_transform": [[308, 325], ["augmentation_impl.RandomCrop_CategoryAreaConstraint.crop_aug.get_transform", "range", "fvcore.transforms.transform.CropTransform", "augmentation_impl.RandomCrop_CategoryAreaConstraint.crop_aug.get_crop_size", "numpy.random.randint", "numpy.random.randint", "numpy.unique", "len", "numpy.max", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.get_transform", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomCrop.get_crop_size"], ["", "def", "get_transform", "(", "self", ",", "image", ",", "sem_seg", ")", ":", "\n", "        ", "if", "self", ".", "single_category_max_area", ">=", "1.0", ":", "\n", "            ", "return", "self", ".", "crop_aug", ".", "get_transform", "(", "image", ")", "\n", "", "else", ":", "\n", "            ", "h", ",", "w", "=", "sem_seg", ".", "shape", "\n", "for", "_", "in", "range", "(", "10", ")", ":", "\n", "                ", "crop_size", "=", "self", ".", "crop_aug", ".", "get_crop_size", "(", "(", "h", ",", "w", ")", ")", "\n", "y0", "=", "np", ".", "random", ".", "randint", "(", "h", "-", "crop_size", "[", "0", "]", "+", "1", ")", "\n", "x0", "=", "np", ".", "random", ".", "randint", "(", "w", "-", "crop_size", "[", "1", "]", "+", "1", ")", "\n", "sem_seg_temp", "=", "sem_seg", "[", "y0", ":", "y0", "+", "crop_size", "[", "0", "]", ",", "x0", ":", "x0", "+", "crop_size", "[", "1", "]", "]", "\n", "labels", ",", "cnt", "=", "np", ".", "unique", "(", "sem_seg_temp", ",", "return_counts", "=", "True", ")", "\n", "if", "self", ".", "ignored_category", "is", "not", "None", ":", "\n", "                    ", "cnt", "=", "cnt", "[", "labels", "!=", "self", ".", "ignored_category", "]", "\n", "", "if", "len", "(", "cnt", ")", ">", "1", "and", "np", ".", "max", "(", "cnt", ")", "<", "np", ".", "sum", "(", "cnt", ")", "*", "self", ".", "single_category_max_area", ":", "\n", "                    ", "break", "\n", "", "", "crop_tfm", "=", "CropTransform", "(", "x0", ",", "y0", ",", "crop_size", "[", "1", "]", ",", "crop_size", "[", "0", "]", ")", "\n", "return", "crop_tfm", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomExtent.__init__": [[336, 348], ["augmentation.Augmentation.__init__", "augmentation_impl.RandomExtent._init", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "self", ",", "scale_range", ",", "shift_range", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            output_size (h, w): Dimensions of output image\n            scale_range (l, h): Range of input-to-output size scaling factor\n            shift_range (x, y): Range of shifts of the cropped subrect. The rect\n                is shifted by [w / 2 * Uniform(-x, x), h / 2 * Uniform(-y, y)],\n                where (w, h) is the (width, height) of the input image. Set each\n                component to zero to crop at the image's center.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomExtent.get_transform": [[349, 369], ["numpy.array", "numpy.random.uniform", "transform.ExtentTransform", "numpy.random.rand", "numpy.random.rand", "int", "int"], "methods", ["None"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "img_h", ",", "img_w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "\n", "# Initialize src_rect to fit the input image.", "\n", "src_rect", "=", "np", ".", "array", "(", "[", "-", "0.5", "*", "img_w", ",", "-", "0.5", "*", "img_h", ",", "0.5", "*", "img_w", ",", "0.5", "*", "img_h", "]", ")", "\n", "\n", "# Apply a random scaling to the src_rect.", "\n", "src_rect", "*=", "np", ".", "random", ".", "uniform", "(", "self", ".", "scale_range", "[", "0", "]", ",", "self", ".", "scale_range", "[", "1", "]", ")", "\n", "\n", "# Apply a random shift to the coordinates origin.", "\n", "src_rect", "[", "0", ":", ":", "2", "]", "+=", "self", ".", "shift_range", "[", "0", "]", "*", "img_w", "*", "(", "np", ".", "random", ".", "rand", "(", ")", "-", "0.5", ")", "\n", "src_rect", "[", "1", ":", ":", "2", "]", "+=", "self", ".", "shift_range", "[", "1", "]", "*", "img_h", "*", "(", "np", ".", "random", ".", "rand", "(", ")", "-", "0.5", ")", "\n", "\n", "# Map src_rect coordinates into image coordinates (center at corner).", "\n", "src_rect", "[", "0", ":", ":", "2", "]", "+=", "0.5", "*", "img_w", "\n", "src_rect", "[", "1", ":", ":", "2", "]", "+=", "0.5", "*", "img_h", "\n", "\n", "return", "ExtentTransform", "(", "\n", "src_rect", "=", "(", "src_rect", "[", "0", "]", ",", "src_rect", "[", "1", "]", ",", "src_rect", "[", "2", "]", ",", "src_rect", "[", "3", "]", ")", ",", "\n", "output_size", "=", "(", "int", "(", "src_rect", "[", "3", "]", "-", "src_rect", "[", "1", "]", ")", ",", "int", "(", "src_rect", "[", "2", "]", "-", "src_rect", "[", "0", "]", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomContrast.__init__": [[384, 392], ["augmentation.Augmentation.__init__", "augmentation_impl.RandomContrast._init", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "self", ",", "intensity_min", ",", "intensity_max", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            intensity_min (float): Minimum augmentation\n            intensity_max (float): Maximum augmentation\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomContrast.get_transform": [[393, 396], ["numpy.random.uniform", "fvcore.transforms.transform.BlendTransform", "image.mean"], "methods", ["None"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "w", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "intensity_min", ",", "self", ".", "intensity_max", ")", "\n", "return", "BlendTransform", "(", "src_image", "=", "image", ".", "mean", "(", ")", ",", "src_weight", "=", "1", "-", "w", ",", "dst_weight", "=", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomBrightness.__init__": [[410, 418], ["augmentation.Augmentation.__init__", "augmentation_impl.RandomBrightness._init", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "self", ",", "intensity_min", ",", "intensity_max", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            intensity_min (float): Minimum augmentation\n            intensity_max (float): Maximum augmentation\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomBrightness.get_transform": [[419, 422], ["numpy.random.uniform", "fvcore.transforms.transform.BlendTransform"], "methods", ["None"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "w", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "intensity_min", ",", "self", ".", "intensity_max", ")", "\n", "return", "BlendTransform", "(", "src_image", "=", "0", ",", "src_weight", "=", "1", "-", "w", ",", "dst_weight", "=", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomSaturation.__init__": [[437, 445], ["augmentation.Augmentation.__init__", "augmentation_impl.RandomSaturation._init", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "self", ",", "intensity_min", ",", "intensity_max", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            intensity_min (float): Minimum augmentation (1 preserves input).\n            intensity_max (float): Maximum augmentation (1 preserves input).\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomSaturation.get_transform": [[446, 451], ["numpy.random.uniform", "fvcore.transforms.transform.BlendTransform", "image.dot"], "methods", ["None"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "assert", "image", ".", "shape", "[", "-", "1", "]", "==", "3", ",", "\"RandomSaturation only works on RGB images\"", "\n", "w", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "intensity_min", ",", "self", ".", "intensity_max", ")", "\n", "grayscale", "=", "image", ".", "dot", "(", "[", "0.299", ",", "0.587", ",", "0.114", "]", ")", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "return", "BlendTransform", "(", "src_image", "=", "grayscale", ",", "src_weight", "=", "1", "-", "w", ",", "dst_weight", "=", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomLighting.__init__": [[462, 473], ["augmentation.Augmentation.__init__", "augmentation_impl.RandomLighting._init", "numpy.array", "numpy.array", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init"], ["def", "__init__", "(", "self", ",", "scale", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            scale (float): Standard deviation of principal component weighting.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_init", "(", "locals", "(", ")", ")", "\n", "self", ".", "eigen_vecs", "=", "np", ".", "array", "(", "\n", "[", "[", "-", "0.5675", ",", "0.7192", ",", "0.4009", "]", ",", "[", "-", "0.5808", ",", "-", "0.0045", ",", "-", "0.8140", "]", ",", "[", "-", "0.5836", ",", "-", "0.6948", ",", "0.4203", "]", "]", "\n", ")", "\n", "self", ".", "eigen_vals", "=", "np", ".", "array", "(", "[", "0.2175", ",", "0.0188", ",", "0.0045", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation_impl.RandomLighting.get_transform": [[474, 479], ["numpy.random.normal", "fvcore.transforms.transform.BlendTransform", "augmentation_impl.RandomLighting.eigen_vecs.dot"], "methods", ["None"], ["", "def", "get_transform", "(", "self", ",", "image", ")", ":", "\n", "        ", "assert", "image", ".", "shape", "[", "-", "1", "]", "==", "3", ",", "\"RandomLighting only works on RGB images\"", "\n", "weights", "=", "np", ".", "random", ".", "normal", "(", "scale", "=", "self", ".", "scale", ",", "size", "=", "3", ")", "\n", "return", "BlendTransform", "(", "\n", "src_image", "=", "self", ".", "eigen_vecs", ".", "dot", "(", "weights", "*", "self", ".", "eigen_vals", ")", ",", "src_weight", "=", "1.0", ",", "dst_weight", "=", "1.0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ExtentTransform.__init__": [[42, 52], ["fvcore.transforms.transform.Transform.__init__", "transform.ExtentTransform._set_attributes", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "src_rect", ",", "output_size", ",", "interp", "=", "Image", ".", "LINEAR", ",", "fill", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            src_rect (x0, y0, x1, y1): src coordinates\n            output_size (h, w): dst image size\n            interp: PIL interpolation methods\n            fill: Fill color used when src_rect extends outside image\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_set_attributes", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ExtentTransform.apply_image": [[53, 63], ["PIL.Image.fromarray().transform", "numpy.asarray", "PIL.Image.fromarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugInput.transform"], ["", "def", "apply_image", "(", "self", ",", "img", ",", "interp", "=", "None", ")", ":", "\n", "        ", "h", ",", "w", "=", "self", ".", "output_size", "\n", "ret", "=", "Image", ".", "fromarray", "(", "img", ")", ".", "transform", "(", "\n", "size", "=", "(", "w", ",", "h", ")", ",", "\n", "method", "=", "Image", ".", "EXTENT", ",", "\n", "data", "=", "self", ".", "src_rect", ",", "\n", "resample", "=", "interp", "if", "interp", "else", "self", ".", "interp", ",", "\n", "fill", "=", "self", ".", "fill", ",", "\n", ")", "\n", "return", "np", ".", "asarray", "(", "ret", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ExtentTransform.apply_coords": [[64, 77], ["coords.astype"], "methods", ["None"], ["", "def", "apply_coords", "(", "self", ",", "coords", ")", ":", "\n", "# Transform image center from source coordinates into output coordinates", "\n", "# and then map the new origin to the corner of the output image.", "\n", "        ", "h", ",", "w", "=", "self", ".", "output_size", "\n", "x0", ",", "y0", ",", "x1", ",", "y1", "=", "self", ".", "src_rect", "\n", "new_coords", "=", "coords", ".", "astype", "(", "np", ".", "float32", ")", "\n", "new_coords", "[", ":", ",", "0", "]", "-=", "0.5", "*", "(", "x0", "+", "x1", ")", "\n", "new_coords", "[", ":", ",", "1", "]", "-=", "0.5", "*", "(", "y0", "+", "y1", ")", "\n", "new_coords", "[", ":", ",", "0", "]", "*=", "w", "/", "(", "x1", "-", "x0", ")", "\n", "new_coords", "[", ":", ",", "1", "]", "*=", "h", "/", "(", "y1", "-", "y0", ")", "\n", "new_coords", "[", ":", ",", "0", "]", "+=", "0.5", "*", "w", "\n", "new_coords", "[", ":", ",", "1", "]", "+=", "0.5", "*", "h", "\n", "return", "new_coords", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ExtentTransform.apply_segmentation": [[78, 81], ["transform.ExtentTransform.apply_image"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image"], ["", "def", "apply_segmentation", "(", "self", ",", "segmentation", ")", ":", "\n", "        ", "segmentation", "=", "self", ".", "apply_image", "(", "segmentation", ",", "interp", "=", "Image", ".", "NEAREST", ")", "\n", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ResizeTransform.__init__": [[88, 100], ["fvcore.transforms.transform.Transform.__init__", "transform.ResizeTransform._set_attributes", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "h", ",", "w", ",", "new_h", ",", "new_w", ",", "interp", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            h, w (int): original image size\n            new_h, new_w (int): new image size\n            interp: PIL interpolation methods, defaults to bilinear.\n        \"\"\"", "\n", "# TODO decide on PIL vs opencv", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "interp", "is", "None", ":", "\n", "            ", "interp", "=", "Image", ".", "BILINEAR", "\n", "", "self", ".", "_set_attributes", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ResizeTransform.apply_image": [[101, 125], ["len", "PIL.Image.fromarray", "pil_image.resize.resize.resize", "numpy.asarray", "any", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "list", "numpy.ascontiguousarray.view().permute", "torch.interpolate", "torch.interpolate", "numpy.ascontiguousarray.permute().view().numpy", "numpy.ascontiguousarray", "numpy.ascontiguousarray.view", "numpy.ascontiguousarray.permute().view", "len", "numpy.ascontiguousarray.permute"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.resize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "apply_image", "(", "self", ",", "img", ",", "interp", "=", "None", ")", ":", "\n", "        ", "assert", "img", ".", "shape", "[", ":", "2", "]", "==", "(", "self", ".", "h", ",", "self", ".", "w", ")", "\n", "assert", "len", "(", "img", ".", "shape", ")", "<=", "4", "\n", "\n", "if", "img", ".", "dtype", "==", "np", ".", "uint8", ":", "\n", "            ", "pil_image", "=", "Image", ".", "fromarray", "(", "img", ")", "\n", "interp_method", "=", "interp", "if", "interp", "is", "not", "None", "else", "self", ".", "interp", "\n", "pil_image", "=", "pil_image", ".", "resize", "(", "(", "self", ".", "new_w", ",", "self", ".", "new_h", ")", ",", "interp_method", ")", "\n", "ret", "=", "np", ".", "asarray", "(", "pil_image", ")", "\n", "", "else", ":", "\n", "# PIL only supports uint8", "\n", "            ", "if", "any", "(", "x", "<", "0", "for", "x", "in", "img", ".", "strides", ")", ":", "\n", "                ", "img", "=", "np", ".", "ascontiguousarray", "(", "img", ")", "\n", "", "img", "=", "torch", ".", "from_numpy", "(", "img", ")", "\n", "shape", "=", "list", "(", "img", ".", "shape", ")", "\n", "shape_4d", "=", "shape", "[", ":", "2", "]", "+", "[", "1", "]", "*", "(", "4", "-", "len", "(", "shape", ")", ")", "+", "shape", "[", "2", ":", "]", "\n", "img", "=", "img", ".", "view", "(", "shape_4d", ")", ".", "permute", "(", "2", ",", "3", ",", "0", ",", "1", ")", "# hw(c) -> nchw", "\n", "_PIL_RESIZE_TO_INTERPOLATE_MODE", "=", "{", "Image", ".", "BILINEAR", ":", "\"bilinear\"", ",", "Image", ".", "BICUBIC", ":", "\"bicubic\"", "}", "\n", "mode", "=", "_PIL_RESIZE_TO_INTERPOLATE_MODE", "[", "self", ".", "interp", "]", "\n", "img", "=", "F", ".", "interpolate", "(", "img", ",", "(", "self", ".", "new_h", ",", "self", ".", "new_w", ")", ",", "mode", "=", "mode", ",", "align_corners", "=", "False", ")", "\n", "shape", "[", ":", "2", "]", "=", "(", "self", ".", "new_h", ",", "self", ".", "new_w", ")", "\n", "ret", "=", "img", ".", "permute", "(", "2", ",", "3", ",", "0", ",", "1", ")", ".", "view", "(", "shape", ")", ".", "numpy", "(", ")", "# nchw -> hw(c)", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ResizeTransform.apply_coords": [[126, 130], ["None"], "methods", ["None"], ["", "def", "apply_coords", "(", "self", ",", "coords", ")", ":", "\n", "        ", "coords", "[", ":", ",", "0", "]", "=", "coords", "[", ":", ",", "0", "]", "*", "(", "self", ".", "new_w", "*", "1.0", "/", "self", ".", "w", ")", "\n", "coords", "[", ":", ",", "1", "]", "=", "coords", "[", ":", ",", "1", "]", "*", "(", "self", ".", "new_h", "*", "1.0", "/", "self", ".", "h", ")", "\n", "return", "coords", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ResizeTransform.apply_segmentation": [[131, 134], ["transform.ResizeTransform.apply_image"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image"], ["", "def", "apply_segmentation", "(", "self", ",", "segmentation", ")", ":", "\n", "        ", "segmentation", "=", "self", ".", "apply_image", "(", "segmentation", ",", "interp", "=", "Image", ".", "NEAREST", ")", "\n", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ResizeTransform.inverse": [[135, 137], ["transform.ResizeTransform"], "methods", ["None"], ["", "def", "inverse", "(", "self", ")", ":", "\n", "        ", "return", "ResizeTransform", "(", "self", ".", "new_h", ",", "self", ".", "new_w", ",", "self", ".", "h", ",", "self", ".", "w", ",", "self", ".", "interp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.RotationTransform.__init__": [[145, 176], ["fvcore.transforms.transform.Transform.__init__", "numpy.array", "transform.RotationTransform._set_attributes", "transform.RotationTransform.create_rotation_matrix", "transform.RotationTransform.create_rotation_matrix", "abs", "abs", "numpy.rint().astype", "locals", "numpy.cos", "numpy.sin", "numpy.deg2rad", "numpy.deg2rad", "numpy.rint"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.RotationTransform.create_rotation_matrix", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.RotationTransform.create_rotation_matrix"], ["def", "__init__", "(", "self", ",", "h", ",", "w", ",", "angle", ",", "expand", "=", "True", ",", "center", "=", "None", ",", "interp", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            h, w (int): original image size\n            angle (float): degrees for rotation\n            expand (bool): choose if the image should be resized to fit the whole\n                rotated image (default), or simply cropped\n            center (tuple (width, height)): coordinates of the rotation center\n                if left to None, the center will be fit to the center of each image\n                center has no effect if expand=True because it only affects shifting\n            interp: cv2 interpolation method, default cv2.INTER_LINEAR\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "image_center", "=", "np", ".", "array", "(", "(", "w", "/", "2", ",", "h", "/", "2", ")", ")", "\n", "if", "center", "is", "None", ":", "\n", "            ", "center", "=", "image_center", "\n", "", "if", "interp", "is", "None", ":", "\n", "            ", "interp", "=", "cv2", ".", "INTER_LINEAR", "\n", "", "abs_cos", ",", "abs_sin", "=", "(", "abs", "(", "np", ".", "cos", "(", "np", ".", "deg2rad", "(", "angle", ")", ")", ")", ",", "abs", "(", "np", ".", "sin", "(", "np", ".", "deg2rad", "(", "angle", ")", ")", ")", ")", "\n", "if", "expand", ":", "\n", "# find the new width and height bounds", "\n", "            ", "bound_w", ",", "bound_h", "=", "np", ".", "rint", "(", "\n", "[", "h", "*", "abs_sin", "+", "w", "*", "abs_cos", ",", "h", "*", "abs_cos", "+", "w", "*", "abs_sin", "]", "\n", ")", ".", "astype", "(", "int", ")", "\n", "", "else", ":", "\n", "            ", "bound_w", ",", "bound_h", "=", "w", ",", "h", "\n", "\n", "", "self", ".", "_set_attributes", "(", "locals", "(", ")", ")", "\n", "self", ".", "rm_coords", "=", "self", ".", "create_rotation_matrix", "(", ")", "\n", "# Needed because of this problem https://github.com/opencv/opencv/issues/11784", "\n", "self", ".", "rm_image", "=", "self", ".", "create_rotation_matrix", "(", "offset", "=", "-", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.RotationTransform.apply_image": [[177, 186], ["cv2.warpAffine", "len"], "methods", ["None"], ["", "def", "apply_image", "(", "self", ",", "img", ",", "interp", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        img should be a numpy array, formatted as Height * Width * Nchannels\n        \"\"\"", "\n", "if", "len", "(", "img", ")", "==", "0", "or", "self", ".", "angle", "%", "360", "==", "0", ":", "\n", "            ", "return", "img", "\n", "", "assert", "img", ".", "shape", "[", ":", "2", "]", "==", "(", "self", ".", "h", ",", "self", ".", "w", ")", "\n", "interp", "=", "interp", "if", "interp", "is", "not", "None", "else", "self", ".", "interp", "\n", "return", "cv2", ".", "warpAffine", "(", "img", ",", "self", ".", "rm_image", ",", "(", "self", ".", "bound_w", ",", "self", ".", "bound_h", ")", ",", "flags", "=", "interp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.RotationTransform.apply_coords": [[187, 195], ["numpy.asarray", "cv2.transform", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugInput.transform"], ["", "def", "apply_coords", "(", "self", ",", "coords", ")", ":", "\n", "        ", "\"\"\"\n        coords should be a N * 2 array-like, containing N couples of (x, y) points\n        \"\"\"", "\n", "coords", "=", "np", ".", "asarray", "(", "coords", ",", "dtype", "=", "float", ")", "\n", "if", "len", "(", "coords", ")", "==", "0", "or", "self", ".", "angle", "%", "360", "==", "0", ":", "\n", "            ", "return", "coords", "\n", "", "return", "cv2", ".", "transform", "(", "coords", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", ",", "self", ".", "rm_coords", ")", "[", ":", ",", "0", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.RotationTransform.apply_segmentation": [[196, 199], ["transform.RotationTransform.apply_image"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image"], ["", "def", "apply_segmentation", "(", "self", ",", "segmentation", ")", ":", "\n", "        ", "segmentation", "=", "self", ".", "apply_image", "(", "segmentation", ",", "interp", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.RotationTransform.create_rotation_matrix": [[200, 211], ["cv2.getRotationMatrix2D", "tuple", "cv2.transform", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugInput.transform"], ["", "def", "create_rotation_matrix", "(", "self", ",", "offset", "=", "0", ")", ":", "\n", "        ", "center", "=", "(", "self", ".", "center", "[", "0", "]", "+", "offset", ",", "self", ".", "center", "[", "1", "]", "+", "offset", ")", "\n", "rm", "=", "cv2", ".", "getRotationMatrix2D", "(", "tuple", "(", "center", ")", ",", "self", ".", "angle", ",", "1", ")", "\n", "if", "self", ".", "expand", ":", "\n", "# Find the coordinates of the center of rotation in the new image", "\n", "# The only point for which we know the future coordinates is the center of the image", "\n", "            ", "rot_im_center", "=", "cv2", ".", "transform", "(", "self", ".", "image_center", "[", "None", ",", "None", ",", ":", "]", "+", "offset", ",", "rm", ")", "[", "0", ",", "0", ",", ":", "]", "\n", "new_center", "=", "np", ".", "array", "(", "[", "self", ".", "bound_w", "/", "2", ",", "self", ".", "bound_h", "/", "2", "]", ")", "+", "offset", "-", "rot_im_center", "\n", "# shift the rotation center to the new coordinates", "\n", "rm", "[", ":", ",", "2", "]", "+=", "new_center", "\n", "", "return", "rm", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.RotationTransform.inverse": [[212, 225], ["transform.RotationTransform", "fvcore.transforms.transform.CropTransform", "fvcore.transforms.transform.TransformList", "NotImplementedError"], "methods", ["None"], ["", "def", "inverse", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        The inverse is to rotate it back with expand, and crop to get the original shape.\n        \"\"\"", "\n", "if", "not", "self", ".", "expand", ":", "# Not possible to inverse if a part of the image is lost", "\n", "            ", "raise", "NotImplementedError", "(", ")", "\n", "", "rotation", "=", "RotationTransform", "(", "\n", "self", ".", "bound_h", ",", "self", ".", "bound_w", ",", "-", "self", ".", "angle", ",", "True", ",", "None", ",", "self", ".", "interp", "\n", ")", "\n", "crop", "=", "CropTransform", "(", "\n", "(", "rotation", ".", "bound_w", "-", "self", ".", "w", ")", "//", "2", ",", "(", "rotation", ".", "bound_h", "-", "self", ".", "h", ")", "//", "2", ",", "self", ".", "w", ",", "self", ".", "h", "\n", ")", "\n", "return", "TransformList", "(", "[", "rotation", ",", "crop", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.__init__": [[235, 245], ["fvcore.transforms.transform.Transform.__init__", "transform.ColorTransform._set_attributes", "callable", "ValueError", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "op", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            op (Callable): operation to be applied to the image,\n                which takes in an ndarray and returns an ndarray.\n        \"\"\"", "\n", "if", "not", "callable", "(", "op", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"op parameter should be callable\"", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_set_attributes", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.apply_image": [[246, 248], ["transform.ColorTransform.op"], "methods", ["None"], ["", "def", "apply_image", "(", "self", ",", "img", ")", ":", "\n", "        ", "return", "self", ".", "op", "(", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.apply_coords": [[249, 251], ["None"], "methods", ["None"], ["", "def", "apply_coords", "(", "self", ",", "coords", ")", ":", "\n", "        ", "return", "coords", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.inverse": [[252, 254], ["fvcore.transforms.transform.NoOpTransform"], "methods", ["None"], ["", "def", "inverse", "(", "self", ")", ":", "\n", "        ", "return", "NoOpTransform", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.ColorTransform.apply_segmentation": [[255, 257], ["None"], "methods", ["None"], ["", "def", "apply_segmentation", "(", "self", ",", "segmentation", ")", ":", "\n", "        ", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.PILColorTransform.__init__": [[266, 278], ["transform.ColorTransform.__init__", "callable", "ValueError"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "op", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            op (Callable): operation to be applied to the image,\n                which takes in a PIL Image and returns a transformed\n                PIL Image.\n                For reference on possible operations see:\n                - https://pillow.readthedocs.io/en/stable/\n        \"\"\"", "\n", "if", "not", "callable", "(", "op", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"op parameter should be callable\"", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "op", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.PILColorTransform.apply_image": [[279, 282], ["PIL.Image.fromarray", "numpy.asarray", "transform.ColorTransform.apply_image"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image"], ["", "def", "apply_image", "(", "self", ",", "img", ")", ":", "\n", "        ", "img", "=", "Image", ".", "fromarray", "(", "img", ")", "\n", "return", "np", ".", "asarray", "(", "super", "(", ")", ".", "apply_image", "(", "img", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.HFlip_rotated_box": [[284, 298], ["None"], "function", ["None"], ["", "", "def", "HFlip_rotated_box", "(", "transform", ",", "rotated_boxes", ")", ":", "\n", "    ", "\"\"\"\n    Apply the horizontal flip transform on rotated boxes.\n\n    Args:\n        rotated_boxes (ndarray): Nx5 floating point array of\n            (x_center, y_center, width, height, angle_degrees) format\n            in absolute coordinates.\n    \"\"\"", "\n", "# Transform x_center", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "=", "transform", ".", "width", "-", "rotated_boxes", "[", ":", ",", "0", "]", "\n", "# Transform angle", "\n", "rotated_boxes", "[", ":", ",", "4", "]", "=", "-", "rotated_boxes", "[", ":", ",", "4", "]", "\n", "return", "rotated_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.transform.Resize_rotated_box": [[300, 322], ["numpy.cos", "numpy.sin", "numpy.sqrt", "numpy.sqrt", "numpy.square", "numpy.square", "numpy.square", "numpy.square", "numpy.arctan2"], "function", ["None"], ["", "def", "Resize_rotated_box", "(", "transform", ",", "rotated_boxes", ")", ":", "\n", "    ", "\"\"\"\n    Apply the resizing transform on rotated boxes. For details of how these (approximation)\n    formulas are derived, please refer to :meth:`RotatedBoxes.scale`.\n\n    Args:\n        rotated_boxes (ndarray): Nx5 floating point array of\n            (x_center, y_center, width, height, angle_degrees) format\n            in absolute coordinates.\n    \"\"\"", "\n", "scale_factor_x", "=", "transform", ".", "new_w", "*", "1.0", "/", "transform", ".", "w", "\n", "scale_factor_y", "=", "transform", ".", "new_h", "*", "1.0", "/", "transform", ".", "h", "\n", "rotated_boxes", "[", ":", ",", "0", "]", "*=", "scale_factor_x", "\n", "rotated_boxes", "[", ":", ",", "1", "]", "*=", "scale_factor_y", "\n", "theta", "=", "rotated_boxes", "[", ":", ",", "4", "]", "*", "np", ".", "pi", "/", "180.0", "\n", "c", "=", "np", ".", "cos", "(", "theta", ")", "\n", "s", "=", "np", ".", "sin", "(", "theta", ")", "\n", "rotated_boxes", "[", ":", ",", "2", "]", "*=", "np", ".", "sqrt", "(", "np", ".", "square", "(", "scale_factor_x", "*", "c", ")", "+", "np", ".", "square", "(", "scale_factor_y", "*", "s", ")", ")", "\n", "rotated_boxes", "[", ":", ",", "3", "]", "*=", "np", ".", "sqrt", "(", "np", ".", "square", "(", "scale_factor_x", "*", "s", ")", "+", "np", ".", "square", "(", "scale_factor_y", "*", "c", ")", ")", "\n", "rotated_boxes", "[", ":", ",", "4", "]", "=", "np", ".", "arctan2", "(", "scale_factor_x", "*", "s", ",", "scale_factor_y", "*", "c", ")", "*", "180", "/", "np", ".", "pi", "\n", "\n", "return", "rotated_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._init": [[105, 110], ["params.items", "setattr", "k.startswith"], "methods", ["None"], ["def", "_init", "(", "self", ",", "params", "=", "None", ")", ":", "\n", "        ", "if", "params", ":", "\n", "            ", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", ":", "\n", "                ", "if", "k", "!=", "\"self\"", "and", "not", "k", ".", "startswith", "(", "\"_\"", ")", ":", "\n", "                    ", "setattr", "(", "self", ",", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.get_transform": [[111, 146], ["None"], "methods", ["None"], ["", "", "", "", "def", "get_transform", "(", "self", ",", "*", "args", ")", "->", "Transform", ":", "\n", "        ", "\"\"\"\n        Execute the policy based on input data, and decide what transform to apply to inputs.\n\n        Args:\n            args: Any fixed-length positional arguments. By default, the name of the arguments\n                should exist in the :class:`AugInput` to be used.\n\n        Returns:\n            Transform: Returns the deterministic transform to apply to the input.\n\n        Examples:\n        ::\n            class MyAug:\n                # if a policy needs to know both image and semantic segmentation\n                def get_transform(image, sem_seg) -> T.Transform:\n                    pass\n            tfm: Transform = MyAug().get_transform(image, sem_seg)\n            new_image = tfm.apply_image(image)\n\n        Notes:\n            Users can freely use arbitrary new argument names in custom\n            :meth:`get_transform` method, as long as they are available in the\n            input data. In detectron2 we use the following convention:\n\n            * image: (H,W) or (H,W,C) ndarray of type uint8 in range [0, 255], or\n              floating point in range [0, 1] or [0, 255].\n            * boxes: (N,4) ndarray of float32. It represents the instance bounding boxes\n              of N instances. Each is in XYXY format in unit of absolute coordinates.\n            * sem_seg: (H,W) ndarray of type uint8. Each element is an integer label of pixel.\n\n            We do not specify convention for other types and do not include builtin\n            :class:`Augmentation` that uses other types in detectron2.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.__call__": [[147, 171], ["augmentation._get_aug_input_args", "augmentation.Augmentation.get_transform", "isinstance", "aug_input.transform", "type"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation._get_aug_input_args", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.get_transform", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugInput.transform"], ["", "def", "__call__", "(", "self", ",", "aug_input", ")", "->", "Transform", ":", "\n", "        ", "\"\"\"\n        Augment the given `aug_input` **in-place**, and return the transform that's used.\n\n        This method will be called to apply the augmentation. In most augmentation, it\n        is enough to use the default implementation, which calls :meth:`get_transform`\n        using the inputs. But a subclass can overwrite it to have more complicated logic.\n\n        Args:\n            aug_input (AugInput): an object that has attributes needed by this augmentation\n                (defined by ``self.get_transform``). Its ``transform`` method will be called\n                to in-place transform it.\n\n        Returns:\n            Transform: the transform that is applied on the input.\n        \"\"\"", "\n", "args", "=", "_get_aug_input_args", "(", "self", ",", "aug_input", ")", "\n", "tfm", "=", "self", ".", "get_transform", "(", "*", "args", ")", "\n", "assert", "isinstance", "(", "tfm", ",", "(", "Transform", ",", "TransformList", ")", ")", ",", "(", "\n", "f\"{type(self)}.get_transform must return an instance of Transform! \"", "\n", "\"Got {type(tfm)} instead.\"", "\n", ")", "\n", "aug_input", ".", "transform", "(", "tfm", ")", "\n", "return", "tfm", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation._rand_range": [[172, 181], ["numpy.random.uniform"], "methods", ["None"], ["", "def", "_rand_range", "(", "self", ",", "low", "=", "1.0", ",", "high", "=", "None", ",", "size", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Uniform float random number between low and high.\n        \"\"\"", "\n", "if", "high", "is", "None", ":", "\n", "            ", "low", ",", "high", "=", "0", ",", "low", "\n", "", "if", "size", "is", "None", ":", "\n", "            ", "size", "=", "[", "]", "\n", "", "return", "np", ".", "random", ".", "uniform", "(", "low", ",", "high", ",", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.Augmentation.__repr__": [[182, 211], ["inspect.signature", "inspect.signature.parameters.items", "type", "hasattr", "getattr", "pprint.pformat", "argstr.append", "super().__repr__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugmentationList.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Produce something like:\n        \"MyAugmentation(field1={self.field1}, field2={self.field2})\"\n        \"\"\"", "\n", "try", ":", "\n", "            ", "sig", "=", "inspect", ".", "signature", "(", "self", ".", "__init__", ")", "\n", "classname", "=", "type", "(", "self", ")", ".", "__name__", "\n", "argstr", "=", "[", "]", "\n", "for", "name", ",", "param", "in", "sig", ".", "parameters", ".", "items", "(", ")", ":", "\n", "                ", "assert", "(", "\n", "param", ".", "kind", "!=", "param", ".", "VAR_POSITIONAL", "and", "param", ".", "kind", "!=", "param", ".", "VAR_KEYWORD", "\n", ")", ",", "\"The default __repr__ doesn't support *args or **kwargs\"", "\n", "assert", "hasattr", "(", "self", ",", "name", ")", ",", "(", "\n", "\"Attribute {} not found! \"", "\n", "\"Default __repr__ only works if attributes match the constructor.\"", ".", "format", "(", "name", ")", "\n", ")", "\n", "attr", "=", "getattr", "(", "self", ",", "name", ")", "\n", "default", "=", "param", ".", "default", "\n", "if", "default", "is", "attr", ":", "\n", "                    ", "continue", "\n", "", "attr_str", "=", "pprint", ".", "pformat", "(", "attr", ")", "\n", "if", "\"\\n\"", "in", "attr_str", ":", "\n", "# don't show it if pformat decides to use >1 lines", "\n", "                    ", "attr_str", "=", "\"...\"", "\n", "", "argstr", ".", "append", "(", "\"{}={}\"", ".", "format", "(", "name", ",", "attr_str", ")", ")", "\n", "", "return", "\"{}({})\"", ".", "format", "(", "classname", ",", "\", \"", ".", "join", "(", "argstr", ")", ")", "\n", "", "except", "AssertionError", ":", "\n", "            ", "return", "super", "(", ")", ".", "__repr__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugmentationList.__init__": [[252, 259], ["super().__init__", "augmentation._transform_to_aug"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation._transform_to_aug"], ["def", "__init__", "(", "self", ",", "augs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            augs (list[Augmentation or Transform]):\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "augs", "=", "[", "_transform_to_aug", "(", "x", ")", "for", "x", "in", "augs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugmentationList.__call__": [[260, 266], ["fvcore.transforms.transform.TransformList", "x", "tfms.append"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "aug_input", ")", "->", "Transform", ":", "\n", "        ", "tfms", "=", "[", "]", "\n", "for", "x", "in", "self", ".", "augs", ":", "\n", "            ", "tfm", "=", "x", "(", "aug_input", ")", "\n", "tfms", ".", "append", "(", "tfm", ")", "\n", "", "return", "TransformList", "(", "tfms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugmentationList.__repr__": [[267, 270], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "msgs", "=", "[", "str", "(", "x", ")", "for", "x", "in", "self", ".", "augs", "]", "\n", "return", "\"AugmentationList[{}]\"", ".", "format", "(", "\", \"", ".", "join", "(", "msgs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugInput.__init__": [[306, 326], ["augmentation._check_img_dtype"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation._check_img_dtype"], ["def", "__init__", "(", "\n", "self", ",", "\n", "image", ":", "np", ".", "ndarray", ",", "\n", "*", ",", "\n", "boxes", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "sem_seg", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image (ndarray): (H,W) or (H,W,C) ndarray of type uint8 in range [0, 255], or\n                floating point in range [0, 1] or [0, 255]. The meaning of C is up\n                to users.\n            boxes (ndarray or None): Nx4 float32 boxes in XYXY_ABS mode\n            sem_seg (ndarray or None): HxW uint8 semantic segmentation mask. Each element\n                is an integer label of pixel.\n        \"\"\"", "\n", "_check_img_dtype", "(", "image", ")", "\n", "self", ".", "image", "=", "image", "\n", "self", ".", "boxes", "=", "boxes", "\n", "self", ".", "sem_seg", "=", "sem_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugInput.transform": [[327, 339], ["tfm.apply_image", "tfm.apply_box", "tfm.apply_segmentation"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_segmentation"], ["", "def", "transform", "(", "self", ",", "tfm", ":", "Transform", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        In-place transform all attributes of this class.\n\n        By \"in-place\", it means after calling this method, accessing an attribute such\n        as ``self.image`` will return transformed data.\n        \"\"\"", "\n", "self", ".", "image", "=", "tfm", ".", "apply_image", "(", "self", ".", "image", ")", "\n", "if", "self", ".", "boxes", "is", "not", "None", ":", "\n", "            ", "self", ".", "boxes", "=", "tfm", ".", "apply_box", "(", "self", ".", "boxes", ")", "\n", "", "if", "self", ".", "sem_seg", "is", "not", "None", ":", "\n", "            ", "self", ".", "sem_seg", "=", "tfm", ".", "apply_segmentation", "(", "self", ".", "sem_seg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugInput.apply_augmentations": [[340, 347], ["augmentation.AugmentationList"], "methods", ["None"], ["", "", "def", "apply_augmentations", "(", "\n", "self", ",", "augmentations", ":", "List", "[", "Union", "[", "Augmentation", ",", "Transform", "]", "]", "\n", ")", "->", "TransformList", ":", "\n", "        ", "\"\"\"\n        Equivalent of ``AugmentationList(augmentations)(self)``\n        \"\"\"", "\n", "return", "AugmentationList", "(", "augmentations", ")", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation._check_img_dtype": [[26, 36], ["isinstance", "type", "isinstance"], "function", ["None"], ["def", "_check_img_dtype", "(", "img", ")", ":", "\n", "    ", "assert", "isinstance", "(", "img", ",", "np", ".", "ndarray", ")", ",", "\"[Augmentation] Needs an numpy array, but got a {}!\"", ".", "format", "(", "\n", "type", "(", "img", ")", "\n", ")", "\n", "assert", "not", "isinstance", "(", "img", ".", "dtype", ",", "np", ".", "integer", ")", "or", "(", "\n", "img", ".", "dtype", "==", "np", ".", "uint8", "\n", ")", ",", "\"[Augmentation] Got image of type {}, use uint8 or floating points instead!\"", ".", "format", "(", "\n", "img", ".", "dtype", "\n", ")", "\n", "assert", "img", ".", "ndim", "in", "[", "2", ",", "3", "]", ",", "img", ".", "ndim", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation._get_aug_input_args": [[38, 74], ["list", "tuple", "inspect.signature().parameters.items", "len", "args.append", "names.append", "getattr", "AttributeError", "TypeError", "inspect.signature", "type", "type", "type", "type"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "_get_aug_input_args", "(", "aug", ",", "aug_input", ")", "->", "List", "[", "Any", "]", ":", "\n", "    ", "\"\"\"\n    Get the arguments to be passed to ``aug.get_transform`` from the input ``aug_input``.\n    \"\"\"", "\n", "if", "aug", ".", "input_args", "is", "None", ":", "\n", "# Decide what attributes are needed automatically", "\n", "        ", "prms", "=", "list", "(", "inspect", ".", "signature", "(", "aug", ".", "get_transform", ")", ".", "parameters", ".", "items", "(", ")", ")", "\n", "# The default behavior is: if there is one parameter, then its \"image\"", "\n", "# (work automatically for majority of use cases, and also avoid BC breaking),", "\n", "# Otherwise, use the argument names.", "\n", "if", "len", "(", "prms", ")", "==", "1", ":", "\n", "            ", "names", "=", "(", "\"image\"", ",", ")", "\n", "", "else", ":", "\n", "            ", "names", "=", "[", "]", "\n", "for", "name", ",", "prm", "in", "prms", ":", "\n", "                ", "if", "prm", ".", "kind", "in", "(", "inspect", ".", "Parameter", ".", "VAR_POSITIONAL", ",", "inspect", ".", "Parameter", ".", "VAR_KEYWORD", ")", ":", "\n", "                    ", "raise", "TypeError", "(", "\n", "f\"\"\" \\\nThe default implementation of `{type(aug)}.__call__` does not allow \\\n`{type(aug)}.get_transform` to use variable-length arguments (*args, **kwargs)! \\\nIf arguments are unknown, reimplement `__call__` instead. \\\n\"\"\"", "\n", ")", "\n", "", "names", ".", "append", "(", "name", ")", "\n", "", "", "aug", ".", "input_args", "=", "tuple", "(", "names", ")", "\n", "\n", "", "args", "=", "[", "]", "\n", "for", "f", "in", "aug", ".", "input_args", ":", "\n", "        ", "try", ":", "\n", "            ", "args", ".", "append", "(", "getattr", "(", "aug_input", ",", "f", ")", ")", "\n", "", "except", "AttributeError", "as", "e", ":", "\n", "            ", "raise", "AttributeError", "(", "\n", "f\"{type(aug)}.get_transform needs input attribute '{f}', \"", "\n", "f\"but it is not an attribute of {type(aug_input)}!\"", "\n", ")", "from", "e", "\n", "", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation._transform_to_aug": [[215, 238], ["isinstance", "isinstance", "_TransformToAug", "repr"], "function", ["None"], ["", "def", "_transform_to_aug", "(", "tfm_or_aug", ")", ":", "\n", "    ", "\"\"\"\n    Wrap Transform into Augmentation.\n    Private, used internally to implement augmentations.\n    \"\"\"", "\n", "assert", "isinstance", "(", "tfm_or_aug", ",", "(", "Transform", ",", "Augmentation", ")", ")", ",", "tfm_or_aug", "\n", "if", "isinstance", "(", "tfm_or_aug", ",", "Augmentation", ")", ":", "\n", "        ", "return", "tfm_or_aug", "\n", "", "else", ":", "\n", "\n", "        ", "class", "_TransformToAug", "(", "Augmentation", ")", ":", "\n", "            ", "def", "__init__", "(", "self", ",", "tfm", ":", "Transform", ")", ":", "\n", "                ", "self", ".", "tfm", "=", "tfm", "\n", "\n", "", "def", "get_transform", "(", "self", ",", "*", "args", ")", ":", "\n", "                ", "return", "self", ".", "tfm", "\n", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n", "                ", "return", "repr", "(", "self", ".", "tfm", ")", "\n", "\n", "", "__str__", "=", "__repr__", "\n", "\n", "", "return", "_TransformToAug", "(", "tfm_or_aug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.apply_augmentations": [[349, 361], ["isinstance", "AugInput.apply_augmentations", "augmentation.AugInput"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.apply_augmentations"], ["", "", "def", "apply_augmentations", "(", "augmentations", ":", "List", "[", "Union", "[", "Transform", ",", "Augmentation", "]", "]", ",", "inputs", ")", ":", "\n", "    ", "\"\"\"\n    Use ``T.AugmentationList(augmentations)(inputs)`` instead.\n    \"\"\"", "\n", "if", "isinstance", "(", "inputs", ",", "np", ".", "ndarray", ")", ":", "\n", "# handle the common case of image-only Augmentation, also for backward compatibility", "\n", "        ", "image_only", "=", "True", "\n", "inputs", "=", "AugInput", "(", "inputs", ")", "\n", "", "else", ":", "\n", "        ", "image_only", "=", "False", "\n", "", "tfms", "=", "inputs", ".", "apply_augmentations", "(", "augmentations", ")", "\n", "return", "inputs", ".", "image", "if", "image_only", "else", "inputs", ",", "tfms", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.fast_eval_api.COCOeval_opt.evaluate": [[16, 95], ["time.time", "print", "print", "list", "sorted", "fast_eval_api.COCOeval_opt._prepare", "detectron2._C.COCOevalEvaluateImages", "copy.deepcopy", "time.time", "print", "print", "numpy.unique", "list", "computeIoU", "numpy.unique", "detectron2._C.InstanceAnnotation", "instances_cpp.append", "fast_eval_api.COCOeval_opt.evaluate.convert_instances_to_cpp"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._prepare", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeIoU"], ["def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Run per image evaluation on given images and store results in self.evalImgs_cpp, a\n        datastructure that isn't readable from Python but is used by a c++ implementation of\n        accumulate().  Unlike the original COCO PythonAPI, we don't populate the datastructure\n        self.evalImgs because this datastructure is a computational bottleneck.\n        :return: None\n        \"\"\"", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "\n", "print", "(", "\"Running per image evaluation...\"", ")", "\n", "p", "=", "self", ".", "params", "\n", "# add backward compatibility if useSegm is specified in params", "\n", "if", "p", ".", "useSegm", "is", "not", "None", ":", "\n", "            ", "p", ".", "iouType", "=", "\"segm\"", "if", "p", ".", "useSegm", "==", "1", "else", "\"bbox\"", "\n", "print", "(", "\"useSegm (deprecated) is not None. Running {} evaluation\"", ".", "format", "(", "p", ".", "iouType", ")", ")", "\n", "", "print", "(", "\"Evaluate annotation type *{}*\"", ".", "format", "(", "p", ".", "iouType", ")", ")", "\n", "p", ".", "imgIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "imgIds", ")", ")", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "p", ".", "catIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "catIds", ")", ")", "\n", "", "p", ".", "maxDets", "=", "sorted", "(", "p", ".", "maxDets", ")", "\n", "self", ".", "params", "=", "p", "\n", "\n", "self", ".", "_prepare", "(", ")", "\n", "\n", "# loop through images, area range, max detection number", "\n", "catIds", "=", "p", ".", "catIds", "if", "p", ".", "useCats", "else", "[", "-", "1", "]", "\n", "\n", "if", "p", ".", "iouType", "==", "\"segm\"", "or", "p", ".", "iouType", "==", "\"bbox\"", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeIoU", "\n", "", "elif", "p", ".", "iouType", "==", "\"keypoints\"", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeOks", "\n", "", "self", ".", "ious", "=", "{", "\n", "(", "imgId", ",", "catId", ")", ":", "computeIoU", "(", "imgId", ",", "catId", ")", "for", "imgId", "in", "p", ".", "imgIds", "for", "catId", "in", "catIds", "\n", "}", "\n", "\n", "maxDet", "=", "p", ".", "maxDets", "[", "-", "1", "]", "\n", "\n", "# <<<< Beginning of code differences with original COCO API", "\n", "def", "convert_instances_to_cpp", "(", "instances", ",", "is_det", "=", "False", ")", ":", "\n", "# Convert annotations for a list of instances in an image to a format that's fast", "\n", "# to access in C++", "\n", "            ", "instances_cpp", "=", "[", "]", "\n", "for", "instance", "in", "instances", ":", "\n", "                ", "instance_cpp", "=", "_C", ".", "InstanceAnnotation", "(", "\n", "int", "(", "instance", "[", "\"id\"", "]", ")", ",", "\n", "instance", "[", "\"score\"", "]", "if", "is_det", "else", "instance", ".", "get", "(", "\"score\"", ",", "0.0", ")", ",", "\n", "instance", "[", "\"area\"", "]", ",", "\n", "bool", "(", "instance", ".", "get", "(", "\"iscrowd\"", ",", "0", ")", ")", ",", "\n", "bool", "(", "instance", ".", "get", "(", "\"ignore\"", ",", "0", ")", ")", ",", "\n", ")", "\n", "instances_cpp", ".", "append", "(", "instance_cpp", ")", "\n", "", "return", "instances_cpp", "\n", "\n", "# Convert GT annotations, detections, and IOUs to a format that's fast to access in C++", "\n", "", "ground_truth_instances", "=", "[", "\n", "[", "convert_instances_to_cpp", "(", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", ")", "for", "catId", "in", "p", ".", "catIds", "]", "\n", "for", "imgId", "in", "p", ".", "imgIds", "\n", "]", "\n", "detected_instances", "=", "[", "\n", "[", "convert_instances_to_cpp", "(", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", ",", "is_det", "=", "True", ")", "for", "catId", "in", "p", ".", "catIds", "]", "\n", "for", "imgId", "in", "p", ".", "imgIds", "\n", "]", "\n", "ious", "=", "[", "[", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "for", "catId", "in", "catIds", "]", "for", "imgId", "in", "p", ".", "imgIds", "]", "\n", "\n", "if", "not", "p", ".", "useCats", ":", "\n", "# For each image, flatten per-category lists into a single list", "\n", "            ", "ground_truth_instances", "=", "[", "[", "[", "o", "for", "c", "in", "i", "for", "o", "in", "c", "]", "]", "for", "i", "in", "ground_truth_instances", "]", "\n", "detected_instances", "=", "[", "[", "[", "o", "for", "c", "in", "i", "for", "o", "in", "c", "]", "]", "for", "i", "in", "detected_instances", "]", "\n", "\n", "# Call C++ implementation of self.evaluateImgs()", "\n", "", "self", ".", "_evalImgs_cpp", "=", "_C", ".", "COCOevalEvaluateImages", "(", "\n", "p", ".", "areaRng", ",", "maxDet", ",", "p", ".", "iouThrs", ",", "ious", ",", "ground_truth_instances", ",", "detected_instances", "\n", ")", "\n", "self", ".", "_evalImgs", "=", "None", "\n", "\n", "self", ".", "_paramsEval", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ")", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"COCOeval_opt.evaluate() finished in {:0.2f} seconds.\"", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "# >>>> End of code differences with original COCO API", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.fast_eval_api.COCOeval_opt.accumulate": [[97, 120], ["print", "time.time", "detectron2._C.COCOevalAccumulate", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "time.time", "print", "hasattr", "print", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "accumulate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Accumulate per image evaluation results and store the result in self.eval.  Does not\n        support changing parameter settings from those used by self.evaluate()\n        \"\"\"", "\n", "print", "(", "\"Accumulating evaluation results...\"", ")", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "hasattr", "(", "self", ",", "\"_evalImgs_cpp\"", ")", ":", "\n", "            ", "print", "(", "\"Please run evaluate() first\"", ")", "\n", "\n", "", "self", ".", "eval", "=", "_C", ".", "COCOevalAccumulate", "(", "self", ".", "_paramsEval", ",", "self", ".", "_evalImgs_cpp", ")", "\n", "\n", "# recall is num_iou_thresholds X num_categories X num_area_ranges X num_max_detections", "\n", "self", ".", "eval", "[", "\"recall\"", "]", "=", "np", ".", "array", "(", "self", ".", "eval", "[", "\"recall\"", "]", ")", ".", "reshape", "(", "\n", "self", ".", "eval", "[", "\"counts\"", "]", "[", ":", "1", "]", "+", "self", ".", "eval", "[", "\"counts\"", "]", "[", "2", ":", "]", "\n", ")", "\n", "\n", "# precision and scores are num_iou_thresholds X num_recall_thresholds X num_categories X", "\n", "# num_area_ranges X num_max_detections", "\n", "self", ".", "eval", "[", "\"precision\"", "]", "=", "np", ".", "array", "(", "self", ".", "eval", "[", "\"precision\"", "]", ")", ".", "reshape", "(", "self", ".", "eval", "[", "\"counts\"", "]", ")", "\n", "self", ".", "eval", "[", "\"scores\"", "]", "=", "np", ".", "array", "(", "self", ".", "eval", "[", "\"scores\"", "]", ")", ".", "reshape", "(", "self", ".", "eval", "[", "\"counts\"", "]", ")", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"COCOeval_opt.accumulate() finished in {:0.2f} seconds.\"", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.sem_seg_evaluation.SemSegEvaluator.__init__": [[24, 58], ["torch.device", "logging.getLogger", "detectron2.data.MetadataCatalog.get", "detectron2.data.DatasetCatalog.get", "c2d.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "distributed", ",", "num_classes", ",", "ignore_label", "=", "255", ",", "output_dir", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset to be evaluated.\n            distributed (True): if True, will collect results from all ranks for evaluation.\n                Otherwise, will evaluate the results in the current process.\n            num_classes (int): number of classes\n            ignore_label (int): value in semantic segmentation ground truth. Predictions for the\n            corresponding pixels should be ignored.\n            output_dir (str): an output directory to dump results.\n        \"\"\"", "\n", "self", ".", "_dataset_name", "=", "dataset_name", "\n", "self", ".", "_distributed", "=", "distributed", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "self", ".", "_num_classes", "=", "num_classes", "\n", "self", ".", "_ignore_label", "=", "ignore_label", "\n", "self", ".", "_N", "=", "num_classes", "+", "1", "\n", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "self", ".", "input_file_to_gt_file", "=", "{", "\n", "dataset_record", "[", "\"file_name\"", "]", ":", "dataset_record", "[", "\"sem_seg_file_name\"", "]", "\n", "for", "dataset_record", "in", "DatasetCatalog", ".", "get", "(", "dataset_name", ")", "\n", "}", "\n", "\n", "meta", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "# Dict that maps contiguous training ids to COCO category ids", "\n", "try", ":", "\n", "            ", "c2d", "=", "meta", ".", "stuff_dataset_id_to_contiguous_id", "\n", "self", ".", "_contiguous_id_to_dataset_id", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "c2d", ".", "items", "(", ")", "}", "\n", "", "except", "AttributeError", ":", "\n", "            ", "self", ".", "_contiguous_id_to_dataset_id", "=", "None", "\n", "", "self", ".", "_class_names", "=", "meta", ".", "stuff_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.sem_seg_evaluation.SemSegEvaluator.reset": [[59, 62], ["numpy.zeros"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_conf_matrix", "=", "np", ".", "zeros", "(", "(", "self", ".", "_N", ",", "self", ".", "_N", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.sem_seg_evaluation.SemSegEvaluator.process": [[63, 86], ["zip", "output[].argmax().to", "numpy.array", "numpy.bincount().reshape", "sem_seg_evaluation.SemSegEvaluator._predictions.extend", "fvcore.common.file_io.PathManager.open", "numpy.array", "sem_seg_evaluation.SemSegEvaluator.encode_json_sem_seg", "output[].argmax", "PIL.open", "numpy.bincount", "numpy.array.reshape", "numpy.array.reshape"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.sem_seg_evaluation.SemSegEvaluator.encode_json_sem_seg"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a model.\n                It is a list of dicts. Each dict corresponds to an image and\n                contains keys like \"height\", \"width\", \"file_name\".\n            outputs: the outputs of a model. It is either list of semantic segmentation predictions\n                (Tensor [H, W]) or list of dicts with key \"sem_seg\" that contains semantic\n                segmentation prediction in the same format.\n        \"\"\"", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "output", "=", "output", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "pred", "=", "np", ".", "array", "(", "output", ",", "dtype", "=", "np", ".", "int", ")", "\n", "with", "PathManager", ".", "open", "(", "self", ".", "input_file_to_gt_file", "[", "input", "[", "\"file_name\"", "]", "]", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "f", ")", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n", "", "gt", "[", "gt", "==", "self", ".", "_ignore_label", "]", "=", "self", ".", "_num_classes", "\n", "\n", "self", ".", "_conf_matrix", "+=", "np", ".", "bincount", "(", "\n", "self", ".", "_N", "*", "pred", ".", "reshape", "(", "-", "1", ")", "+", "gt", ".", "reshape", "(", "-", "1", ")", ",", "minlength", "=", "self", ".", "_N", "**", "2", "\n", ")", ".", "reshape", "(", "self", ".", "_N", ",", "self", ".", "_N", ")", "\n", "\n", "self", ".", "_predictions", ".", "extend", "(", "self", ".", "encode_json_sem_seg", "(", "pred", ",", "input", "[", "\"file_name\"", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.sem_seg_evaluation.SemSegEvaluator.evaluate": [[87, 147], ["numpy.full", "numpy.full", "[].astype", "numpy.sum().astype", "numpy.sum().astype", "numpy.sum", "enumerate", "enumerate", "collections.OrderedDict", "sem_seg_evaluation.SemSegEvaluator._logger.info", "detectron2.utils.comm.synchronize", "detectron2.utils.comm.all_gather", "detectron2.utils.comm.all_gather", "list", "numpy.zeros_like", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "os.path.join", "itertools.chain", "detectron2.utils.comm.is_main_process", "fvcore.common.file_io.PathManager.open", "f.write", "numpy.sum", "numpy.sum", "fvcore.common.file_io.PathManager.open", "torch.save", "json.dumps", "sem_seg_evaluation.SemSegEvaluator._conf_matrix.diagonal"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Evaluates standard semantic segmentation metrics (http://cocodataset.org/#stuff-eval):\n\n        * Mean intersection-over-union averaged across classes (mIoU)\n        * Frequency Weighted IoU (fwIoU)\n        * Mean pixel accuracy averaged across classes (mACC)\n        * Pixel Accuracy (pACC)\n        \"\"\"", "\n", "if", "self", ".", "_distributed", ":", "\n", "            ", "synchronize", "(", ")", "\n", "conf_matrix_list", "=", "all_gather", "(", "self", ".", "_conf_matrix", ")", "\n", "self", ".", "_predictions", "=", "all_gather", "(", "self", ".", "_predictions", ")", "\n", "self", ".", "_predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "self", ".", "_predictions", ")", ")", "\n", "if", "not", "is_main_process", "(", ")", ":", "\n", "                ", "return", "\n", "\n", "", "self", ".", "_conf_matrix", "=", "np", ".", "zeros_like", "(", "self", ".", "_conf_matrix", ")", "\n", "for", "conf_matrix", "in", "conf_matrix_list", ":", "\n", "                ", "self", ".", "_conf_matrix", "+=", "conf_matrix", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "PathManager", ".", "mkdirs", "(", "self", ".", "_output_dir", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"sem_seg_predictions.json\"", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "self", ".", "_predictions", ")", ")", "\n", "\n", "", "", "acc", "=", "np", ".", "full", "(", "self", ".", "_num_classes", ",", "np", ".", "nan", ",", "dtype", "=", "np", ".", "float", ")", "\n", "iou", "=", "np", ".", "full", "(", "self", ".", "_num_classes", ",", "np", ".", "nan", ",", "dtype", "=", "np", ".", "float", ")", "\n", "tp", "=", "self", ".", "_conf_matrix", ".", "diagonal", "(", ")", "[", ":", "-", "1", "]", ".", "astype", "(", "np", ".", "float", ")", "\n", "pos_gt", "=", "np", ".", "sum", "(", "self", ".", "_conf_matrix", "[", ":", "-", "1", ",", ":", "-", "1", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "class_weights", "=", "pos_gt", "/", "np", ".", "sum", "(", "pos_gt", ")", "\n", "pos_pred", "=", "np", ".", "sum", "(", "self", ".", "_conf_matrix", "[", ":", "-", "1", ",", ":", "-", "1", "]", ",", "axis", "=", "1", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "acc_valid", "=", "pos_gt", ">", "0", "\n", "acc", "[", "acc_valid", "]", "=", "tp", "[", "acc_valid", "]", "/", "pos_gt", "[", "acc_valid", "]", "\n", "iou_valid", "=", "(", "pos_gt", "+", "pos_pred", ")", ">", "0", "\n", "union", "=", "pos_gt", "+", "pos_pred", "-", "tp", "\n", "iou", "[", "acc_valid", "]", "=", "tp", "[", "acc_valid", "]", "/", "union", "[", "acc_valid", "]", "\n", "macc", "=", "np", ".", "sum", "(", "acc", "[", "acc_valid", "]", ")", "/", "np", ".", "sum", "(", "acc_valid", ")", "\n", "miou", "=", "np", ".", "sum", "(", "iou", "[", "acc_valid", "]", ")", "/", "np", ".", "sum", "(", "iou_valid", ")", "\n", "fiou", "=", "np", ".", "sum", "(", "iou", "[", "acc_valid", "]", "*", "class_weights", "[", "acc_valid", "]", ")", "\n", "pacc", "=", "np", ".", "sum", "(", "tp", ")", "/", "np", ".", "sum", "(", "pos_gt", ")", "\n", "\n", "res", "=", "{", "}", "\n", "res", "[", "\"mIoU\"", "]", "=", "100", "*", "miou", "\n", "res", "[", "\"fwIoU\"", "]", "=", "100", "*", "fiou", "\n", "for", "i", ",", "name", "in", "enumerate", "(", "self", ".", "_class_names", ")", ":", "\n", "            ", "res", "[", "\"IoU-{}\"", ".", "format", "(", "name", ")", "]", "=", "100", "*", "iou", "[", "i", "]", "\n", "", "res", "[", "\"mACC\"", "]", "=", "100", "*", "macc", "\n", "res", "[", "\"pACC\"", "]", "=", "100", "*", "pacc", "\n", "for", "i", ",", "name", "in", "enumerate", "(", "self", ".", "_class_names", ")", ":", "\n", "            ", "res", "[", "\"ACC-{}\"", ".", "format", "(", "name", ")", "]", "=", "100", "*", "acc", "[", "i", "]", "\n", "\n", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"sem_seg_evaluation.pth\"", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "torch", ".", "save", "(", "res", ",", "f", ")", "\n", "", "", "results", "=", "OrderedDict", "(", "{", "\"sem_seg\"", ":", "res", "}", ")", "\n", "self", ".", "_logger", ".", "info", "(", "results", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.sem_seg_evaluation.SemSegEvaluator.encode_json_sem_seg": [[148, 169], ["numpy.unique", "mask_rle[].decode", "json_list.append", "int", "pycocotools.encode", "numpy.array"], "methods", ["None"], ["", "def", "encode_json_sem_seg", "(", "self", ",", "sem_seg", ",", "input_file_name", ")", ":", "\n", "        ", "\"\"\"\n        Convert semantic segmentation to COCO stuff format with segments encoded as RLEs.\n        See http://cocodataset.org/#format-results\n        \"\"\"", "\n", "json_list", "=", "[", "]", "\n", "for", "label", "in", "np", ".", "unique", "(", "sem_seg", ")", ":", "\n", "            ", "if", "self", ".", "_contiguous_id_to_dataset_id", "is", "not", "None", ":", "\n", "                ", "assert", "(", "\n", "label", "in", "self", ".", "_contiguous_id_to_dataset_id", "\n", ")", ",", "\"Label {} is not in the metadata info for {}\"", ".", "format", "(", "label", ",", "self", ".", "_dataset_name", ")", "\n", "dataset_id", "=", "self", ".", "_contiguous_id_to_dataset_id", "[", "label", "]", "\n", "", "else", ":", "\n", "                ", "dataset_id", "=", "int", "(", "label", ")", "\n", "", "mask", "=", "(", "sem_seg", "==", "label", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "mask_rle", "=", "mask_util", ".", "encode", "(", "np", ".", "array", "(", "mask", "[", ":", ",", ":", ",", "None", "]", ",", "order", "=", "\"F\"", ")", ")", "[", "0", "]", "\n", "mask_rle", "[", "\"counts\"", "]", "=", "mask_rle", "[", "\"counts\"", "]", ".", "decode", "(", "\"utf-8\"", ")", "\n", "json_list", ".", "append", "(", "\n", "{", "\"file_name\"", ":", "input_file_name", ",", "\"category_id\"", ":", "dataset_id", ",", "\"segmentation\"", ":", "mask_rle", "}", "\n", ")", "\n", "", "return", "json_list", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation.LVISEvaluator.__init__": [[27, 53], ["lvis_evaluation.LVISEvaluator._tasks_from_config", "torch.device", "logging.getLogger", "detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.get_local_path", "LVIS", "len", "lvis_evaluation.LVISEvaluator._lvis_api.get_ann_ids"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._tasks_from_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "cfg", ",", "distributed", ",", "output_dir", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset to be evaluated.\n                It must have the following corresponding metadata:\n                \"json_file\": the path to the LVIS format annotation\n            cfg (CfgNode): config instance\n            distributed (True): if True, will collect results from all ranks for evaluation.\n                Otherwise, will evaluate the results in the current process.\n            output_dir (str): optional, an output directory to dump results.\n        \"\"\"", "\n", "from", "lvis", "import", "LVIS", "\n", "\n", "self", ".", "_tasks", "=", "self", ".", "_tasks_from_config", "(", "cfg", ")", "\n", "self", ".", "_distributed", "=", "distributed", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "self", ".", "_metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "json_file", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "json_file", ")", "\n", "self", ".", "_lvis_api", "=", "LVIS", "(", "json_file", ")", "\n", "# Test set json files do not contain annotations (evaluation must be", "\n", "# performed using the LVIS evaluation server).", "\n", "self", ".", "_do_evaluation", "=", "len", "(", "self", ".", "_lvis_api", ".", "get_ann_ids", "(", ")", ")", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation.LVISEvaluator.reset": [[54, 56], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation.LVISEvaluator._tasks_from_config": [[57, 66], ["None"], "methods", ["None"], ["", "def", "_tasks_from_config", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            tuple[str]: tasks that can be evaluated under the given configuration.\n        \"\"\"", "\n", "tasks", "=", "(", "\"bbox\"", ",", ")", "\n", "if", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "            ", "tasks", "=", "tasks", "+", "(", "\"segm\"", ",", ")", "\n", "", "return", "tasks", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation.LVISEvaluator.process": [[67, 85], ["zip", "lvis_evaluation.LVISEvaluator._predictions.append", "output[].to", "coco_evaluation.instances_to_coco_json", "output[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.instances_to_coco_json", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a LVIS model (e.g., GeneralizedRCNN).\n                It is a list of dict. Each dict corresponds to an image and\n                contains keys like \"height\", \"width\", \"file_name\", \"image_id\".\n            outputs: the outputs of a LVIS model. It is a list of dicts with key\n                \"instances\" that contains :class:`Instances`.\n        \"\"\"", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "prediction", "=", "{", "\"image_id\"", ":", "input", "[", "\"image_id\"", "]", "}", "\n", "\n", "if", "\"instances\"", "in", "output", ":", "\n", "                ", "instances", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "prediction", "[", "\"instances\"", "]", "=", "instances_to_coco_json", "(", "instances", ",", "input", "[", "\"image_id\"", "]", ")", "\n", "", "if", "\"proposals\"", "in", "output", ":", "\n", "                ", "prediction", "[", "\"proposals\"", "]", "=", "output", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "", "self", ".", "_predictions", ".", "append", "(", "prediction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation.LVISEvaluator.evaluate": [[86, 114], ["collections.OrderedDict", "copy.deepcopy", "detectron2.synchronize", "detectron2.gather", "list", "len", "lvis_evaluation.LVISEvaluator._logger.warning", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "lvis_evaluation.LVISEvaluator._eval_box_proposals", "lvis_evaluation.LVISEvaluator._eval_predictions", "itertools.chain", "detectron2.is_main_process", "fvcore.common.file_io.PathManager.open", "torch.save", "set"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._eval_box_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator._eval_predictions", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_distributed", ":", "\n", "            ", "comm", ".", "synchronize", "(", ")", "\n", "predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ",", "dst", "=", "0", ")", "\n", "predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "predictions", ")", ")", "\n", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "                ", "return", "\n", "", "", "else", ":", "\n", "            ", "predictions", "=", "self", ".", "_predictions", "\n", "\n", "", "if", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "self", ".", "_logger", ".", "warning", "(", "\"[LVISEvaluator] Did not receive valid predictions.\"", ")", "\n", "return", "{", "}", "\n", "\n", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "PathManager", ".", "mkdirs", "(", "self", ".", "_output_dir", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"instances_predictions.pth\"", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "torch", ".", "save", "(", "predictions", ",", "f", ")", "\n", "\n", "", "", "self", ".", "_results", "=", "OrderedDict", "(", ")", "\n", "if", "\"proposals\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_box_proposals", "(", "predictions", ")", "\n", "", "if", "\"instances\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_predictions", "(", "set", "(", "self", ".", "_tasks", ")", ",", "predictions", ")", "\n", "# Copy so the caller can do whatever with results", "\n", "", "return", "copy", ".", "deepcopy", "(", "self", ".", "_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation.LVISEvaluator._eval_predictions": [[115, 156], ["lvis_evaluation.LVISEvaluator._logger.info", "list", "hasattr", "lvis_evaluation.LVISEvaluator._logger.info", "sorted", "itertools.chain", "os.path.join", "lvis_evaluation.LVISEvaluator._logger.info", "lvis_evaluation.LVISEvaluator._logger.info", "lvis_evaluation._evaluate_predictions_on_lvis", "fvcore.common.file_io.PathManager.open", "f.write", "f.flush", "lvis_evaluation.LVISEvaluator._metadata.thing_dataset_id_to_contiguous_id.items", "json.dumps", "lvis_evaluation.LVISEvaluator._metadata.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation._evaluate_predictions_on_lvis", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "_eval_predictions", "(", "self", ",", "tasks", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate predictions on the given tasks.\n        Fill self._results with the metrics of the tasks.\n\n        Args:\n            predictions (list[dict]): list of outputs from the model\n        \"\"\"", "\n", "self", ".", "_logger", ".", "info", "(", "\"Preparing results in the LVIS format ...\"", ")", "\n", "lvis_results", "=", "list", "(", "itertools", ".", "chain", "(", "*", "[", "x", "[", "\"instances\"", "]", "for", "x", "in", "predictions", "]", ")", ")", "\n", "\n", "# LVIS evaluator can be used to evaluate results for COCO dataset categories.", "\n", "# In this case `_metadata` variable will have a field with COCO-specific category mapping.", "\n", "if", "hasattr", "(", "self", ".", "_metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n", "            ", "reverse_id_mapping", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "for", "result", "in", "lvis_results", ":", "\n", "                ", "result", "[", "\"category_id\"", "]", "=", "reverse_id_mapping", "[", "result", "[", "\"category_id\"", "]", "]", "\n", "", "", "else", ":", "\n", "# unmap the category ids for LVIS (from 0-indexed to 1-indexed)", "\n", "            ", "for", "result", "in", "lvis_results", ":", "\n", "                ", "result", "[", "\"category_id\"", "]", "+=", "1", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"lvis_instances_results.json\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Saving results to {}\"", ".", "format", "(", "file_path", ")", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "lvis_results", ")", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating predictions ...\"", ")", "\n", "for", "task", "in", "sorted", "(", "tasks", ")", ":", "\n", "            ", "res", "=", "_evaluate_predictions_on_lvis", "(", "\n", "self", ".", "_lvis_api", ",", "lvis_results", ",", "task", ",", "class_names", "=", "self", ".", "_metadata", ".", "get", "(", "\"thing_classes\"", ")", "\n", ")", "\n", "self", ".", "_results", "[", "task", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation.LVISEvaluator._eval_box_proposals": [[157, 195], ["lvis_evaluation.LVISEvaluator._logger.info", "lvis_evaluation.LVISEvaluator._logger.info", "lvis_evaluation.LVISEvaluator._logger.info", "areas.items", "ids.append", "boxes.append", "objectness_logits.append", "fvcore.common.file_io.PathManager.open", "pickle.dump", "lvis_evaluation._evaluate_box_proposals", "float", "detectron2.utils.logger.create_small_table", "prediction[].proposal_boxes.tensor.numpy", "prediction[].objectness_logits.numpy", "os.path.join", "stats[].item"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation._evaluate_box_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.create_small_table"], ["", "", "def", "_eval_box_proposals", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate the box proposals in predictions.\n        Fill self._results with the metrics for \"box_proposals\" task.\n        \"\"\"", "\n", "if", "self", ".", "_output_dir", ":", "\n", "# Saving generated box proposals to file.", "\n", "# Predicted box_proposals are in XYXY_ABS mode.", "\n", "            ", "bbox_mode", "=", "BoxMode", ".", "XYXY_ABS", ".", "value", "\n", "ids", ",", "boxes", ",", "objectness_logits", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "prediction", "in", "predictions", ":", "\n", "                ", "ids", ".", "append", "(", "prediction", "[", "\"image_id\"", "]", ")", "\n", "boxes", ".", "append", "(", "prediction", "[", "\"proposals\"", "]", ".", "proposal_boxes", ".", "tensor", ".", "numpy", "(", ")", ")", "\n", "objectness_logits", ".", "append", "(", "prediction", "[", "\"proposals\"", "]", ".", "objectness_logits", ".", "numpy", "(", ")", ")", "\n", "\n", "", "proposal_data", "=", "{", "\n", "\"boxes\"", ":", "boxes", ",", "\n", "\"objectness_logits\"", ":", "objectness_logits", ",", "\n", "\"ids\"", ":", "ids", ",", "\n", "\"bbox_mode\"", ":", "bbox_mode", ",", "\n", "}", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"box_proposals.pkl\"", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "pickle", ".", "dump", "(", "proposal_data", ",", "f", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating bbox proposals ...\"", ")", "\n", "res", "=", "{", "}", "\n", "areas", "=", "{", "\"all\"", ":", "\"\"", ",", "\"small\"", ":", "\"s\"", ",", "\"medium\"", ":", "\"m\"", ",", "\"large\"", ":", "\"l\"", "}", "\n", "for", "limit", "in", "[", "100", ",", "1000", "]", ":", "\n", "            ", "for", "area", ",", "suffix", "in", "areas", ".", "items", "(", ")", ":", "\n", "                ", "stats", "=", "_evaluate_box_proposals", "(", "predictions", ",", "self", ".", "_lvis_api", ",", "area", "=", "area", ",", "limit", "=", "limit", ")", "\n", "key", "=", "\"AR{}@{:d}\"", ".", "format", "(", "suffix", ",", "limit", ")", "\n", "res", "[", "key", "]", "=", "float", "(", "stats", "[", "\"ar\"", "]", ".", "item", "(", ")", "*", "100", ")", "\n", "", "", "self", ".", "_logger", ".", "info", "(", "\"Proposal metrics: \\n\"", "+", "create_small_table", "(", "res", ")", ")", "\n", "self", ".", "_results", "[", "\"box_proposals\"", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation._evaluate_box_proposals": [[199, 305], ["torch.sort", "torch.zeros_like", "enumerate", "torch.zeros_like.mean", "lvis_api.get_ann_ids", "lvis_api.load_anns", "torch.as_tensor().reshape", "detectron2.structures.Boxes", "torch.as_tensor", "len", "detectron2.structures.pairwise_iou", "torch.zeros", "range", "gt_overlaps.append", "len", "torch.cat", "torch.zeros", "torch.arange", "predictions.objectness_logits.sort", "detectron2.structures.BoxMode.convert", "len", "len", "min", "detectron2.structures.pairwise_iou.max", "max_overlaps.max", "float", "torch.as_tensor", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "", "def", "_evaluate_box_proposals", "(", "dataset_predictions", ",", "lvis_api", ",", "thresholds", "=", "None", ",", "area", "=", "\"all\"", ",", "limit", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Evaluate detection proposal recall metrics. This function is a much\n    faster alternative to the official LVIS API recall evaluation code. However,\n    it produces slightly different results.\n    \"\"\"", "\n", "# Record max overlap value for each gt box", "\n", "# Return vector of overlap values", "\n", "areas", "=", "{", "\n", "\"all\"", ":", "0", ",", "\n", "\"small\"", ":", "1", ",", "\n", "\"medium\"", ":", "2", ",", "\n", "\"large\"", ":", "3", ",", "\n", "\"96-128\"", ":", "4", ",", "\n", "\"128-256\"", ":", "5", ",", "\n", "\"256-512\"", ":", "6", ",", "\n", "\"512-inf\"", ":", "7", ",", "\n", "}", "\n", "area_ranges", "=", "[", "\n", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "# all", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "# small", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "# medium", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "# large", "\n", "[", "96", "**", "2", ",", "128", "**", "2", "]", ",", "# 96-128", "\n", "[", "128", "**", "2", ",", "256", "**", "2", "]", ",", "# 128-256", "\n", "[", "256", "**", "2", ",", "512", "**", "2", "]", ",", "# 256-512", "\n", "[", "512", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "]", "# 512-inf", "\n", "assert", "area", "in", "areas", ",", "\"Unknown area range: {}\"", ".", "format", "(", "area", ")", "\n", "area_range", "=", "area_ranges", "[", "areas", "[", "area", "]", "]", "\n", "gt_overlaps", "=", "[", "]", "\n", "num_pos", "=", "0", "\n", "\n", "for", "prediction_dict", "in", "dataset_predictions", ":", "\n", "        ", "predictions", "=", "prediction_dict", "[", "\"proposals\"", "]", "\n", "\n", "# sort predictions in descending order", "\n", "# TODO maybe remove this and make it explicit in the documentation", "\n", "inds", "=", "predictions", ".", "objectness_logits", ".", "sort", "(", "descending", "=", "True", ")", "[", "1", "]", "\n", "predictions", "=", "predictions", "[", "inds", "]", "\n", "\n", "ann_ids", "=", "lvis_api", ".", "get_ann_ids", "(", "img_ids", "=", "[", "prediction_dict", "[", "\"image_id\"", "]", "]", ")", "\n", "anno", "=", "lvis_api", ".", "load_anns", "(", "ann_ids", ")", "\n", "gt_boxes", "=", "[", "\n", "BoxMode", ".", "convert", "(", "obj", "[", "\"bbox\"", "]", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "for", "obj", "in", "anno", "\n", "]", "\n", "gt_boxes", "=", "torch", ".", "as_tensor", "(", "gt_boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "# guard against no boxes", "\n", "gt_boxes", "=", "Boxes", "(", "gt_boxes", ")", "\n", "gt_areas", "=", "torch", ".", "as_tensor", "(", "[", "obj", "[", "\"area\"", "]", "for", "obj", "in", "anno", "]", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", "or", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "valid_gt_inds", "=", "(", "gt_areas", ">=", "area_range", "[", "0", "]", ")", "&", "(", "gt_areas", "<=", "area_range", "[", "1", "]", ")", "\n", "gt_boxes", "=", "gt_boxes", "[", "valid_gt_inds", "]", "\n", "\n", "num_pos", "+=", "len", "(", "gt_boxes", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "limit", "is", "not", "None", "and", "len", "(", "predictions", ")", ">", "limit", ":", "\n", "            ", "predictions", "=", "predictions", "[", ":", "limit", "]", "\n", "\n", "", "overlaps", "=", "pairwise_iou", "(", "predictions", ".", "proposal_boxes", ",", "gt_boxes", ")", "\n", "\n", "_gt_overlaps", "=", "torch", ".", "zeros", "(", "len", "(", "gt_boxes", ")", ")", "\n", "for", "j", "in", "range", "(", "min", "(", "len", "(", "predictions", ")", ",", "len", "(", "gt_boxes", ")", ")", ")", ":", "\n", "# find which proposal box maximally covers each gt box", "\n", "# and get the iou amount of coverage for each gt box", "\n", "            ", "max_overlaps", ",", "argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "# find which gt box is 'best' covered (i.e. 'best' = most iou)", "\n", "gt_ovr", ",", "gt_ind", "=", "max_overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "assert", "gt_ovr", ">=", "0", "\n", "# find the proposal box that covers the best covered gt box", "\n", "box_ind", "=", "argmax_overlaps", "[", "gt_ind", "]", "\n", "# record the iou coverage of this gt box", "\n", "_gt_overlaps", "[", "j", "]", "=", "overlaps", "[", "box_ind", ",", "gt_ind", "]", "\n", "assert", "_gt_overlaps", "[", "j", "]", "==", "gt_ovr", "\n", "# mark the proposal box and the gt box as used", "\n", "overlaps", "[", "box_ind", ",", ":", "]", "=", "-", "1", "\n", "overlaps", "[", ":", ",", "gt_ind", "]", "=", "-", "1", "\n", "\n", "# append recorded iou coverage level", "\n", "", "gt_overlaps", ".", "append", "(", "_gt_overlaps", ")", "\n", "", "gt_overlaps", "=", "(", "\n", "torch", ".", "cat", "(", "gt_overlaps", ",", "dim", "=", "0", ")", "if", "len", "(", "gt_overlaps", ")", "else", "torch", ".", "zeros", "(", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", ")", "\n", "gt_overlaps", ",", "_", "=", "torch", ".", "sort", "(", "gt_overlaps", ")", "\n", "\n", "if", "thresholds", "is", "None", ":", "\n", "        ", "step", "=", "0.05", "\n", "thresholds", "=", "torch", ".", "arange", "(", "0.5", ",", "0.95", "+", "1e-5", ",", "step", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "recalls", "=", "torch", ".", "zeros_like", "(", "thresholds", ")", "\n", "# compute recall for each iou threshold", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "        ", "recalls", "[", "i", "]", "=", "(", "gt_overlaps", ">=", "t", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "/", "float", "(", "num_pos", ")", "\n", "# ar = 2 * np.trapz(recalls, thresholds)", "\n", "", "ar", "=", "recalls", ".", "mean", "(", ")", "\n", "return", "{", "\n", "\"ar\"", ":", "ar", ",", "\n", "\"recalls\"", ":", "recalls", ",", "\n", "\"thresholds\"", ":", "thresholds", ",", "\n", "\"gt_overlaps\"", ":", "gt_overlaps", ",", "\n", "\"num_pos\"", ":", "num_pos", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.lvis_evaluation._evaluate_predictions_on_lvis": [[308, 351], ["logging.getLogger", "LVISResults", "LVISEval", "LVISEval.run", "LVISEval.print_results", "LVISEval.get_results", "logging.getLogger.info", "len", "logging.getLogger.warn", "copy.deepcopy", "float", "float", "c.pop", "detectron2.utils.logger.create_small_table"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.create_small_table"], ["", "def", "_evaluate_predictions_on_lvis", "(", "lvis_gt", ",", "lvis_results", ",", "iou_type", ",", "class_names", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        iou_type (str):\n        kpt_oks_sigmas (list[float]):\n        class_names (None or list[str]): if provided, will use it to predict\n            per-category AP.\n\n    Returns:\n        a dict of {metric name: score}\n    \"\"\"", "\n", "metrics", "=", "{", "\n", "\"bbox\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", ",", "\"APr\"", ",", "\"APc\"", ",", "\"APf\"", "]", ",", "\n", "\"segm\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", ",", "\"APr\"", ",", "\"APc\"", ",", "\"APf\"", "]", ",", "\n", "}", "[", "iou_type", "]", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "if", "len", "(", "lvis_results", ")", "==", "0", ":", "# TODO: check if needed", "\n", "        ", "logger", ".", "warn", "(", "\"No predictions from the model!\"", ")", "\n", "return", "{", "metric", ":", "float", "(", "\"nan\"", ")", "for", "metric", "in", "metrics", "}", "\n", "\n", "", "if", "iou_type", "==", "\"segm\"", ":", "\n", "        ", "lvis_results", "=", "copy", ".", "deepcopy", "(", "lvis_results", ")", "\n", "# When evaluating mask AP, if the results contain bbox, LVIS API will", "\n", "# use the box area as the area of the instance, instead of the mask area.", "\n", "# This leads to a different definition of small/medium/large.", "\n", "# We remove the bbox field to let mask AP use mask area.", "\n", "for", "c", "in", "lvis_results", ":", "\n", "            ", "c", ".", "pop", "(", "\"bbox\"", ",", "None", ")", "\n", "\n", "", "", "from", "lvis", "import", "LVISEval", ",", "LVISResults", "\n", "\n", "lvis_results", "=", "LVISResults", "(", "lvis_gt", ",", "lvis_results", ")", "\n", "lvis_eval", "=", "LVISEval", "(", "lvis_gt", ",", "lvis_results", ",", "iou_type", ")", "\n", "lvis_eval", ".", "run", "(", ")", "\n", "lvis_eval", ".", "print_results", "(", ")", "\n", "\n", "# Pull the standard metrics from the LVIS results", "\n", "results", "=", "lvis_eval", ".", "get_results", "(", ")", "\n", "results", "=", "{", "metric", ":", "float", "(", "results", "[", "metric", "]", "*", "100", ")", "for", "metric", "in", "metrics", "}", "\n", "logger", ".", "info", "(", "\"Evaluation results for {}: \\n\"", ".", "format", "(", "iou_type", ")", "+", "create_small_table", "(", "results", ")", ")", "\n", "return", "results", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator.__init__": [[40, 93], ["coco_evaluation.COCOEvaluator._tasks_from_config", "torch.device", "logging.getLogger", "detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.get_local_path", "hasattr", "coco_evaluation.COCOEvaluator._logger.info", "os.path.join", "detectron2.data.datasets.coco.convert_to_coco_json", "contextlib.redirect_stdout", "pycocotools.coco.COCO", "io.StringIO"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._tasks_from_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.datasets.coco.convert_to_coco_json"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "cfg", ",", "distributed", ",", "output_dir", "=", "None", ",", "*", ",", "use_fast_impl", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset to be evaluated.\n                It must have either the following corresponding metadata:\n\n                    \"json_file\": the path to the COCO format annotation\n\n                Or it must be in detectron2's standard dataset format\n                so it can be converted to COCO format automatically.\n            cfg (CfgNode): config instance\n            distributed (True): if True, will collect results from all ranks and run evaluation\n                in the main process.\n                Otherwise, will only evaluate the results in the current process.\n            output_dir (str): optional, an output directory to dump all\n                results predicted on the dataset. The dump contains two files:\n\n                1. \"instance_predictions.pth\" a file in torch serialization\n                   format that contains all the raw original predictions.\n                2. \"coco_instances_results.json\" a json file in COCO's result\n                   format.\n            use_fast_impl (bool): use a fast but **unofficial** implementation to compute AP.\n                Although the results should be very close to the official implementation in COCO\n                API, it is still recommended to compute results with the official API for use in\n                papers.\n        \"\"\"", "\n", "self", ".", "_tasks", "=", "self", ".", "_tasks_from_config", "(", "cfg", ")", "\n", "self", ".", "_distributed", "=", "distributed", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "self", ".", "_use_fast_impl", "=", "use_fast_impl", "\n", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "self", ".", "_metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "if", "not", "hasattr", "(", "self", ".", "_metadata", ",", "\"json_file\"", ")", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\n", "f\"'{dataset_name}' is not registered by `register_coco_instances`.\"", "\n", "\" Therefore trying to convert it to COCO format ...\"", "\n", ")", "\n", "\n", "cache_path", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "f\"{dataset_name}_coco_format.json\"", ")", "\n", "self", ".", "_metadata", ".", "json_file", "=", "cache_path", "\n", "convert_to_coco_json", "(", "dataset_name", ",", "cache_path", ")", "\n", "\n", "", "json_file", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "json_file", ")", "\n", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "            ", "self", ".", "_coco_api", "=", "COCO", "(", "json_file", ")", "\n", "\n", "", "self", ".", "_kpt_oks_sigmas", "=", "cfg", ".", "TEST", ".", "KEYPOINT_OKS_SIGMAS", "\n", "# Test set json files do not contain annotations (evaluation must be", "\n", "# performed using the COCO evaluation server).", "\n", "self", ".", "_do_evaluation", "=", "\"annotations\"", "in", "self", ".", "_coco_api", ".", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator.reset": [[94, 96], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._tasks_from_config": [[97, 108], ["None"], "methods", ["None"], ["", "def", "_tasks_from_config", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            tuple[str]: tasks that can be evaluated under the given configuration.\n        \"\"\"", "\n", "tasks", "=", "(", "\"bbox\"", ",", ")", "\n", "if", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "            ", "tasks", "=", "tasks", "+", "(", "\"segm\"", ",", ")", "\n", "", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "tasks", "=", "tasks", "+", "(", "\"keypoints\"", ",", ")", "\n", "", "return", "tasks", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator.process": [[109, 127], ["zip", "coco_evaluation.COCOEvaluator._predictions.append", "output[].to", "coco_evaluation.instances_to_coco_json", "output[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.instances_to_coco_json", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a COCO model (e.g., GeneralizedRCNN).\n                It is a list of dict. Each dict corresponds to an image and\n                contains keys like \"height\", \"width\", \"file_name\", \"image_id\".\n            outputs: the outputs of a COCO model. It is a list of dicts with key\n                \"instances\" that contains :class:`Instances`.\n        \"\"\"", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "prediction", "=", "{", "\"image_id\"", ":", "input", "[", "\"image_id\"", "]", "}", "\n", "\n", "if", "\"instances\"", "in", "output", ":", "\n", "                ", "instances", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "prediction", "[", "\"instances\"", "]", "=", "instances_to_coco_json", "(", "instances", ",", "input", "[", "\"image_id\"", "]", ")", "\n", "", "if", "\"proposals\"", "in", "output", ":", "\n", "                ", "prediction", "[", "\"proposals\"", "]", "=", "output", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "", "self", ".", "_predictions", ".", "append", "(", "prediction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator.evaluate": [[128, 156], ["collections.OrderedDict", "copy.deepcopy", "detectron2.synchronize", "detectron2.gather", "list", "len", "coco_evaluation.COCOEvaluator._logger.warning", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "coco_evaluation.COCOEvaluator._eval_box_proposals", "coco_evaluation.COCOEvaluator._eval_predictions", "itertools.chain", "detectron2.is_main_process", "fvcore.common.file_io.PathManager.open", "torch.save", "set"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._eval_box_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator._eval_predictions", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_distributed", ":", "\n", "            ", "comm", ".", "synchronize", "(", ")", "\n", "predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ",", "dst", "=", "0", ")", "\n", "predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "predictions", ")", ")", "\n", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "                ", "return", "{", "}", "\n", "", "", "else", ":", "\n", "            ", "predictions", "=", "self", ".", "_predictions", "\n", "\n", "", "if", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "self", ".", "_logger", ".", "warning", "(", "\"[COCOEvaluator] Did not receive valid predictions.\"", ")", "\n", "return", "{", "}", "\n", "\n", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "PathManager", ".", "mkdirs", "(", "self", ".", "_output_dir", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"instances_predictions.pth\"", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "torch", ".", "save", "(", "predictions", ",", "f", ")", "\n", "\n", "", "", "self", ".", "_results", "=", "OrderedDict", "(", ")", "\n", "if", "\"proposals\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_box_proposals", "(", "predictions", ")", "\n", "", "if", "\"instances\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_predictions", "(", "set", "(", "self", ".", "_tasks", ")", ",", "predictions", ")", "\n", "# Copy so the caller can do whatever with results", "\n", "", "return", "copy", ".", "deepcopy", "(", "self", ".", "_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._eval_predictions": [[157, 212], ["coco_evaluation.COCOEvaluator._logger.info", "list", "hasattr", "coco_evaluation.COCOEvaluator._logger.info", "sorted", "itertools.chain", "os.path.join", "coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._derive_coco_results", "fvcore.common.file_io.PathManager.open", "f.write", "f.flush", "coco_evaluation._evaluate_predictions_on_coco", "coco_evaluation.COCOEvaluator._metadata.thing_dataset_id_to_contiguous_id.items", "json.dumps", "len", "coco_evaluation.COCOEvaluator._metadata.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._derive_coco_results", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "_eval_predictions", "(", "self", ",", "tasks", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate predictions on the given tasks.\n        Fill self._results with the metrics of the tasks.\n        \"\"\"", "\n", "self", ".", "_logger", ".", "info", "(", "\"Preparing results for COCO format ...\"", ")", "\n", "coco_results", "=", "list", "(", "itertools", ".", "chain", "(", "*", "[", "x", "[", "\"instances\"", "]", "for", "x", "in", "predictions", "]", ")", ")", "\n", "\n", "# unmap the category ids for COCO", "\n", "if", "hasattr", "(", "self", ".", "_metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n", "            ", "reverse_id_mapping", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "for", "result", "in", "coco_results", ":", "\n", "                ", "category_id", "=", "result", "[", "\"category_id\"", "]", "\n", "assert", "(", "\n", "category_id", "in", "reverse_id_mapping", "\n", ")", ",", "\"A prediction has category_id={}, which is not available in the dataset.\"", ".", "format", "(", "\n", "category_id", "\n", ")", "\n", "result", "[", "\"category_id\"", "]", "=", "reverse_id_mapping", "[", "category_id", "]", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"coco_instances_results.json\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Saving results to {}\"", ".", "format", "(", "file_path", ")", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "coco_results", ")", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\n", "\"Evaluating predictions with {} COCO API...\"", ".", "format", "(", "\n", "\"unofficial\"", "if", "self", ".", "_use_fast_impl", "else", "\"official\"", "\n", ")", "\n", ")", "\n", "for", "task", "in", "sorted", "(", "tasks", ")", ":", "\n", "            ", "coco_eval", "=", "(", "\n", "_evaluate_predictions_on_coco", "(", "\n", "self", ".", "_coco_api", ",", "\n", "coco_results", ",", "\n", "task", ",", "\n", "kpt_oks_sigmas", "=", "self", ".", "_kpt_oks_sigmas", ",", "\n", "use_fast_impl", "=", "self", ".", "_use_fast_impl", ",", "\n", ")", "\n", "if", "len", "(", "coco_results", ")", ">", "0", "\n", "else", "None", "# cocoapi does not handle empty results very well", "\n", ")", "\n", "\n", "res", "=", "self", ".", "_derive_coco_results", "(", "\n", "coco_eval", ",", "task", ",", "class_names", "=", "self", ".", "_metadata", ".", "get", "(", "\"thing_classes\"", ")", "\n", ")", "\n", "self", ".", "_results", "[", "task", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._eval_box_proposals": [[213, 251], ["coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._logger.info", "areas.items", "ids.append", "boxes.append", "objectness_logits.append", "fvcore.common.file_io.PathManager.open", "pickle.dump", "coco_evaluation._evaluate_box_proposals", "float", "detectron2.utils.logger.create_small_table", "prediction[].proposal_boxes.tensor.numpy", "prediction[].objectness_logits.numpy", "os.path.join", "stats[].item"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation._evaluate_box_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.create_small_table"], ["", "", "def", "_eval_box_proposals", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate the box proposals in predictions.\n        Fill self._results with the metrics for \"box_proposals\" task.\n        \"\"\"", "\n", "if", "self", ".", "_output_dir", ":", "\n", "# Saving generated box proposals to file.", "\n", "# Predicted box_proposals are in XYXY_ABS mode.", "\n", "            ", "bbox_mode", "=", "BoxMode", ".", "XYXY_ABS", ".", "value", "\n", "ids", ",", "boxes", ",", "objectness_logits", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "prediction", "in", "predictions", ":", "\n", "                ", "ids", ".", "append", "(", "prediction", "[", "\"image_id\"", "]", ")", "\n", "boxes", ".", "append", "(", "prediction", "[", "\"proposals\"", "]", ".", "proposal_boxes", ".", "tensor", ".", "numpy", "(", ")", ")", "\n", "objectness_logits", ".", "append", "(", "prediction", "[", "\"proposals\"", "]", ".", "objectness_logits", ".", "numpy", "(", ")", ")", "\n", "\n", "", "proposal_data", "=", "{", "\n", "\"boxes\"", ":", "boxes", ",", "\n", "\"objectness_logits\"", ":", "objectness_logits", ",", "\n", "\"ids\"", ":", "ids", ",", "\n", "\"bbox_mode\"", ":", "bbox_mode", ",", "\n", "}", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"box_proposals.pkl\"", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "pickle", ".", "dump", "(", "proposal_data", ",", "f", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating bbox proposals ...\"", ")", "\n", "res", "=", "{", "}", "\n", "areas", "=", "{", "\"all\"", ":", "\"\"", ",", "\"small\"", ":", "\"s\"", ",", "\"medium\"", ":", "\"m\"", ",", "\"large\"", ":", "\"l\"", "}", "\n", "for", "limit", "in", "[", "100", ",", "1000", "]", ":", "\n", "            ", "for", "area", ",", "suffix", "in", "areas", ".", "items", "(", ")", ":", "\n", "                ", "stats", "=", "_evaluate_box_proposals", "(", "predictions", ",", "self", ".", "_coco_api", ",", "area", "=", "area", ",", "limit", "=", "limit", ")", "\n", "key", "=", "\"AR{}@{:d}\"", ".", "format", "(", "suffix", ",", "limit", ")", "\n", "res", "[", "key", "]", "=", "float", "(", "stats", "[", "\"ar\"", "]", ".", "item", "(", ")", "*", "100", ")", "\n", "", "", "self", ".", "_logger", ".", "info", "(", "\"Proposal metrics: \\n\"", "+", "create_small_table", "(", "res", ")", ")", "\n", "self", ".", "_results", "[", "\"box_proposals\"", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._derive_coco_results": [[252, 319], ["coco_evaluation.COCOEvaluator._logger.info", "enumerate", "min", "list", "itertools.zip_longest", "tabulate.tabulate.tabulate", "coco_evaluation.COCOEvaluator._logger.info", "results.update", "coco_evaluation.COCOEvaluator._logger.warn", "float", "numpy.isfinite", "coco_evaluation.COCOEvaluator._logger.info", "len", "results_per_category.append", "itertools.chain", "float", "enumerate", "detectron2.utils.logger.create_small_table", "sum", "len", "numpy.mean", "float", "len", "results.values", "float", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.create_small_table"], ["", "def", "_derive_coco_results", "(", "self", ",", "coco_eval", ",", "iou_type", ",", "class_names", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Derive the desired score numbers from summarized COCOeval.\n\n        Args:\n            coco_eval (None or COCOEval): None represents no predictions from model.\n            iou_type (str):\n            class_names (None or list[str]): if provided, will use it to predict\n                per-category AP.\n\n        Returns:\n            a dict of {metric name: score}\n        \"\"\"", "\n", "\n", "metrics", "=", "{", "\n", "\"bbox\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", "]", ",", "\n", "\"segm\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", "]", ",", "\n", "\"keypoints\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APm\"", ",", "\"APl\"", "]", ",", "\n", "}", "[", "iou_type", "]", "\n", "\n", "if", "coco_eval", "is", "None", ":", "\n", "            ", "self", ".", "_logger", ".", "warn", "(", "\"No predictions from the model!\"", ")", "\n", "return", "{", "metric", ":", "float", "(", "\"nan\"", ")", "for", "metric", "in", "metrics", "}", "\n", "\n", "# the standard metrics", "\n", "", "results", "=", "{", "\n", "metric", ":", "float", "(", "coco_eval", ".", "stats", "[", "idx", "]", "*", "100", "if", "coco_eval", ".", "stats", "[", "idx", "]", ">=", "0", "else", "\"nan\"", ")", "\n", "for", "idx", ",", "metric", "in", "enumerate", "(", "metrics", ")", "\n", "}", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "\"Evaluation results for {}: \\n\"", ".", "format", "(", "iou_type", ")", "+", "create_small_table", "(", "results", ")", "\n", ")", "\n", "if", "not", "np", ".", "isfinite", "(", "sum", "(", "results", ".", "values", "(", ")", ")", ")", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Some metrics cannot be computed and is shown as NaN.\"", ")", "\n", "\n", "", "if", "class_names", "is", "None", "or", "len", "(", "class_names", ")", "<=", "1", ":", "\n", "            ", "return", "results", "\n", "# Compute per-category AP", "\n", "# from https://github.com/facebookresearch/Detectron/blob/a6a835f5b8208c45d0dce217ce9bbda915f44df7/detectron/datasets/json_dataset_evaluator.py#L222-L252 # noqa", "\n", "", "precisions", "=", "coco_eval", ".", "eval", "[", "\"precision\"", "]", "\n", "# precision has dims (iou, recall, cls, area range, max dets)", "\n", "assert", "len", "(", "class_names", ")", "==", "precisions", ".", "shape", "[", "2", "]", "\n", "\n", "results_per_category", "=", "[", "]", "\n", "for", "idx", ",", "name", "in", "enumerate", "(", "class_names", ")", ":", "\n", "# area range index 0: all area ranges", "\n", "# max dets index -1: typically 100 per image", "\n", "            ", "precision", "=", "precisions", "[", ":", ",", ":", ",", "idx", ",", "0", ",", "-", "1", "]", "\n", "precision", "=", "precision", "[", "precision", ">", "-", "1", "]", "\n", "ap", "=", "np", ".", "mean", "(", "precision", ")", "if", "precision", ".", "size", "else", "float", "(", "\"nan\"", ")", "\n", "results_per_category", ".", "append", "(", "(", "\"{}\"", ".", "format", "(", "name", ")", ",", "float", "(", "ap", "*", "100", ")", ")", ")", "\n", "\n", "# tabulate it", "\n", "", "N_COLS", "=", "min", "(", "6", ",", "len", "(", "results_per_category", ")", "*", "2", ")", "\n", "results_flatten", "=", "list", "(", "itertools", ".", "chain", "(", "*", "results_per_category", ")", ")", "\n", "results_2d", "=", "itertools", ".", "zip_longest", "(", "*", "[", "results_flatten", "[", "i", ":", ":", "N_COLS", "]", "for", "i", "in", "range", "(", "N_COLS", ")", "]", ")", "\n", "table", "=", "tabulate", "(", "\n", "results_2d", ",", "\n", "tablefmt", "=", "\"pipe\"", ",", "\n", "floatfmt", "=", "\".3f\"", ",", "\n", "headers", "=", "[", "\"category\"", ",", "\"AP\"", "]", "*", "(", "N_COLS", "//", "2", ")", ",", "\n", "numalign", "=", "\"left\"", ",", "\n", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Per-category {} AP: \\n\"", ".", "format", "(", "iou_type", ")", "+", "table", ")", "\n", "\n", "results", ".", "update", "(", "{", "\"AP-\"", "+", "name", ":", "ap", "for", "name", ",", "ap", "in", "results_per_category", "}", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.instances_to_coco_json": [[321, 381], ["len", "instances.pred_boxes.tensor.numpy", "detectron2.structures.BoxMode.convert", "boxes.tolist.tolist", "instances.scores.tolist", "instances.pred_classes.tolist", "instances.has", "instances.has", "range", "results.append", "rle[].decode", "keypoints[].flatten().tolist", "pycocotools.encode", "numpy.array", "keypoints[].flatten"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "", "def", "instances_to_coco_json", "(", "instances", ",", "img_id", ")", ":", "\n", "    ", "\"\"\"\n    Dump an \"Instances\" object to a COCO-format json that's used for evaluation.\n\n    Args:\n        instances (Instances):\n        img_id (int): the image id\n\n    Returns:\n        list[dict]: list of json annotations in COCO format.\n    \"\"\"", "\n", "num_instance", "=", "len", "(", "instances", ")", "\n", "if", "num_instance", "==", "0", ":", "\n", "        ", "return", "[", "]", "\n", "\n", "", "boxes", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "\n", "boxes", "=", "BoxMode", ".", "convert", "(", "boxes", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "boxes", "=", "boxes", ".", "tolist", "(", ")", "\n", "scores", "=", "instances", ".", "scores", ".", "tolist", "(", ")", "\n", "classes", "=", "instances", ".", "pred_classes", ".", "tolist", "(", ")", "\n", "\n", "has_mask", "=", "instances", ".", "has", "(", "\"pred_masks\"", ")", "\n", "if", "has_mask", ":", "\n", "# use RLE to encode the masks, because they are too large and takes memory", "\n", "# since this evaluator stores outputs of the entire dataset", "\n", "        ", "rles", "=", "[", "\n", "mask_util", ".", "encode", "(", "np", ".", "array", "(", "mask", "[", ":", ",", ":", ",", "None", "]", ",", "order", "=", "\"F\"", ",", "dtype", "=", "\"uint8\"", ")", ")", "[", "0", "]", "\n", "for", "mask", "in", "instances", ".", "pred_masks", "\n", "]", "\n", "for", "rle", "in", "rles", ":", "\n", "# \"counts\" is an array encoded by mask_util as a byte-stream. Python3's", "\n", "# json writer which always produces strings cannot serialize a bytestream", "\n", "# unless you decode it. Thankfully, utf-8 works out (which is also what", "\n", "# the pycocotools/_mask.pyx does).", "\n", "            ", "rle", "[", "\"counts\"", "]", "=", "rle", "[", "\"counts\"", "]", ".", "decode", "(", "\"utf-8\"", ")", "\n", "\n", "", "", "has_keypoints", "=", "instances", ".", "has", "(", "\"pred_keypoints\"", ")", "\n", "if", "has_keypoints", ":", "\n", "        ", "keypoints", "=", "instances", ".", "pred_keypoints", "\n", "\n", "", "results", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "num_instance", ")", ":", "\n", "        ", "result", "=", "{", "\n", "\"image_id\"", ":", "img_id", ",", "\n", "\"category_id\"", ":", "classes", "[", "k", "]", ",", "\n", "\"bbox\"", ":", "boxes", "[", "k", "]", ",", "\n", "\"score\"", ":", "scores", "[", "k", "]", ",", "\n", "}", "\n", "if", "has_mask", ":", "\n", "            ", "result", "[", "\"segmentation\"", "]", "=", "rles", "[", "k", "]", "\n", "", "if", "has_keypoints", ":", "\n", "# In COCO annotations,", "\n", "# keypoints coordinates are pixel indices.", "\n", "# However our predictions are floating point coordinates.", "\n", "# Therefore we subtract 0.5 to be consistent with the annotation format.", "\n", "# This is the inverse of data loading logic in `datasets/coco.py`.", "\n", "            ", "keypoints", "[", "k", "]", "[", ":", ",", ":", "2", "]", "-=", "0.5", "\n", "result", "[", "\"keypoints\"", "]", "=", "keypoints", "[", "k", "]", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "", "results", ".", "append", "(", "result", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation._evaluate_box_proposals": [[385, 493], ["torch.sort", "torch.zeros_like", "enumerate", "torch.zeros_like.mean", "coco_api.getAnnIds", "coco_api.loadAnns", "torch.as_tensor().reshape", "detectron2.structures.Boxes", "torch.as_tensor", "len", "detectron2.structures.pairwise_iou", "torch.zeros", "range", "gt_overlaps.append", "len", "torch.cat", "torch.zeros", "torch.arange", "predictions.objectness_logits.sort", "detectron2.structures.BoxMode.convert", "len", "len", "min", "detectron2.structures.pairwise_iou.max", "max_overlaps.max", "float", "torch.as_tensor", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.pairwise_iou", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "_evaluate_box_proposals", "(", "dataset_predictions", ",", "coco_api", ",", "thresholds", "=", "None", ",", "area", "=", "\"all\"", ",", "limit", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Evaluate detection proposal recall metrics. This function is a much\n    faster alternative to the official COCO API recall evaluation code. However,\n    it produces slightly different results.\n    \"\"\"", "\n", "# Record max overlap value for each gt box", "\n", "# Return vector of overlap values", "\n", "areas", "=", "{", "\n", "\"all\"", ":", "0", ",", "\n", "\"small\"", ":", "1", ",", "\n", "\"medium\"", ":", "2", ",", "\n", "\"large\"", ":", "3", ",", "\n", "\"96-128\"", ":", "4", ",", "\n", "\"128-256\"", ":", "5", ",", "\n", "\"256-512\"", ":", "6", ",", "\n", "\"512-inf\"", ":", "7", ",", "\n", "}", "\n", "area_ranges", "=", "[", "\n", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "# all", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "# small", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "# medium", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "# large", "\n", "[", "96", "**", "2", ",", "128", "**", "2", "]", ",", "# 96-128", "\n", "[", "128", "**", "2", ",", "256", "**", "2", "]", ",", "# 128-256", "\n", "[", "256", "**", "2", ",", "512", "**", "2", "]", ",", "# 256-512", "\n", "[", "512", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "]", "# 512-inf", "\n", "assert", "area", "in", "areas", ",", "\"Unknown area range: {}\"", ".", "format", "(", "area", ")", "\n", "area_range", "=", "area_ranges", "[", "areas", "[", "area", "]", "]", "\n", "gt_overlaps", "=", "[", "]", "\n", "num_pos", "=", "0", "\n", "\n", "for", "prediction_dict", "in", "dataset_predictions", ":", "\n", "        ", "predictions", "=", "prediction_dict", "[", "\"proposals\"", "]", "\n", "\n", "# sort predictions in descending order", "\n", "# TODO maybe remove this and make it explicit in the documentation", "\n", "inds", "=", "predictions", ".", "objectness_logits", ".", "sort", "(", "descending", "=", "True", ")", "[", "1", "]", "\n", "predictions", "=", "predictions", "[", "inds", "]", "\n", "\n", "ann_ids", "=", "coco_api", ".", "getAnnIds", "(", "imgIds", "=", "prediction_dict", "[", "\"image_id\"", "]", ")", "\n", "anno", "=", "coco_api", ".", "loadAnns", "(", "ann_ids", ")", "\n", "gt_boxes", "=", "[", "\n", "BoxMode", ".", "convert", "(", "obj", "[", "\"bbox\"", "]", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "for", "obj", "in", "anno", "\n", "if", "obj", "[", "\"iscrowd\"", "]", "==", "0", "\n", "]", "\n", "gt_boxes", "=", "torch", ".", "as_tensor", "(", "gt_boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "# guard against no boxes", "\n", "gt_boxes", "=", "Boxes", "(", "gt_boxes", ")", "\n", "gt_areas", "=", "torch", ".", "as_tensor", "(", "[", "obj", "[", "\"area\"", "]", "for", "obj", "in", "anno", "if", "obj", "[", "\"iscrowd\"", "]", "==", "0", "]", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", "or", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "valid_gt_inds", "=", "(", "gt_areas", ">=", "area_range", "[", "0", "]", ")", "&", "(", "gt_areas", "<=", "area_range", "[", "1", "]", ")", "\n", "gt_boxes", "=", "gt_boxes", "[", "valid_gt_inds", "]", "\n", "\n", "num_pos", "+=", "len", "(", "gt_boxes", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "limit", "is", "not", "None", "and", "len", "(", "predictions", ")", ">", "limit", ":", "\n", "            ", "predictions", "=", "predictions", "[", ":", "limit", "]", "\n", "\n", "", "overlaps", "=", "pairwise_iou", "(", "predictions", ".", "proposal_boxes", ",", "gt_boxes", ")", "\n", "\n", "_gt_overlaps", "=", "torch", ".", "zeros", "(", "len", "(", "gt_boxes", ")", ")", "\n", "for", "j", "in", "range", "(", "min", "(", "len", "(", "predictions", ")", ",", "len", "(", "gt_boxes", ")", ")", ")", ":", "\n", "# find which proposal box maximally covers each gt box", "\n", "# and get the iou amount of coverage for each gt box", "\n", "            ", "max_overlaps", ",", "argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "# find which gt box is 'best' covered (i.e. 'best' = most iou)", "\n", "gt_ovr", ",", "gt_ind", "=", "max_overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "assert", "gt_ovr", ">=", "0", "\n", "# find the proposal box that covers the best covered gt box", "\n", "box_ind", "=", "argmax_overlaps", "[", "gt_ind", "]", "\n", "# record the iou coverage of this gt box", "\n", "_gt_overlaps", "[", "j", "]", "=", "overlaps", "[", "box_ind", ",", "gt_ind", "]", "\n", "assert", "_gt_overlaps", "[", "j", "]", "==", "gt_ovr", "\n", "# mark the proposal box and the gt box as used", "\n", "overlaps", "[", "box_ind", ",", ":", "]", "=", "-", "1", "\n", "overlaps", "[", ":", ",", "gt_ind", "]", "=", "-", "1", "\n", "\n", "# append recorded iou coverage level", "\n", "", "gt_overlaps", ".", "append", "(", "_gt_overlaps", ")", "\n", "", "gt_overlaps", "=", "(", "\n", "torch", ".", "cat", "(", "gt_overlaps", ",", "dim", "=", "0", ")", "if", "len", "(", "gt_overlaps", ")", "else", "torch", ".", "zeros", "(", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", ")", "\n", "gt_overlaps", ",", "_", "=", "torch", ".", "sort", "(", "gt_overlaps", ")", "\n", "\n", "if", "thresholds", "is", "None", ":", "\n", "        ", "step", "=", "0.05", "\n", "thresholds", "=", "torch", ".", "arange", "(", "0.5", ",", "0.95", "+", "1e-5", ",", "step", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "recalls", "=", "torch", ".", "zeros_like", "(", "thresholds", ")", "\n", "# compute recall for each iou threshold", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "        ", "recalls", "[", "i", "]", "=", "(", "gt_overlaps", ">=", "t", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "/", "float", "(", "num_pos", ")", "\n", "# ar = 2 * np.trapz(recalls, thresholds)", "\n", "", "ar", "=", "recalls", ".", "mean", "(", ")", "\n", "return", "{", "\n", "\"ar\"", ":", "ar", ",", "\n", "\"recalls\"", ":", "recalls", ",", "\n", "\"thresholds\"", ":", "thresholds", ",", "\n", "\"gt_overlaps\"", ":", "gt_overlaps", ",", "\n", "\"num_pos\"", ":", "num_pos", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation._evaluate_predictions_on_coco": [[496, 539], ["coco_gt.loadRes", "coco_eval.evaluate", "coco_eval.accumulate", "coco_eval.summarize", "len", "copy.deepcopy", "len", "c.pop", "hasattr", "numpy.array", "len", "len", "next", "iter", "coco_gt.anns.values"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter"], ["", "def", "_evaluate_predictions_on_coco", "(", "\n", "coco_gt", ",", "coco_results", ",", "iou_type", ",", "kpt_oks_sigmas", "=", "None", ",", "use_fast_impl", "=", "True", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Evaluate the coco results using COCOEval API.\n    \"\"\"", "\n", "assert", "len", "(", "coco_results", ")", ">", "0", "\n", "\n", "if", "iou_type", "==", "\"segm\"", ":", "\n", "        ", "coco_results", "=", "copy", ".", "deepcopy", "(", "coco_results", ")", "\n", "# When evaluating mask AP, if the results contain bbox, cocoapi will", "\n", "# use the box area as the area of the instance, instead of the mask area.", "\n", "# This leads to a different definition of small/medium/large.", "\n", "# We remove the bbox field to let mask AP use mask area.", "\n", "for", "c", "in", "coco_results", ":", "\n", "            ", "c", ".", "pop", "(", "\"bbox\"", ",", "None", ")", "\n", "\n", "", "", "coco_dt", "=", "coco_gt", ".", "loadRes", "(", "coco_results", ")", "\n", "coco_eval", "=", "(", "COCOeval_opt", "if", "use_fast_impl", "else", "COCOeval", ")", "(", "coco_gt", ",", "coco_dt", ",", "iou_type", ")", "\n", "\n", "if", "iou_type", "==", "\"keypoints\"", ":", "\n", "# Use the COCO default keypoint OKS sigmas unless overrides are specified", "\n", "        ", "if", "kpt_oks_sigmas", ":", "\n", "            ", "assert", "hasattr", "(", "coco_eval", ".", "params", ",", "\"kpt_oks_sigmas\"", ")", ",", "\"pycocotools is too old!\"", "\n", "coco_eval", ".", "params", ".", "kpt_oks_sigmas", "=", "np", ".", "array", "(", "kpt_oks_sigmas", ")", "\n", "# COCOAPI requires every detection and every gt to have keypoints, so", "\n", "# we just take the first entry from both", "\n", "", "num_keypoints_dt", "=", "len", "(", "coco_results", "[", "0", "]", "[", "\"keypoints\"", "]", ")", "//", "3", "\n", "num_keypoints_gt", "=", "len", "(", "next", "(", "iter", "(", "coco_gt", ".", "anns", ".", "values", "(", ")", ")", ")", "[", "\"keypoints\"", "]", ")", "//", "3", "\n", "num_keypoints_oks", "=", "len", "(", "coco_eval", ".", "params", ".", "kpt_oks_sigmas", ")", "\n", "assert", "num_keypoints_oks", "==", "num_keypoints_dt", "==", "num_keypoints_gt", ",", "(", "\n", "f\"[COCOEvaluator] Prediction contain {num_keypoints_dt} keypoints. \"", "\n", "f\"Ground truth contains {num_keypoints_gt} keypoints. \"", "\n", "f\"The length of cfg.TEST.KEYPOINT_OKS_SIGMAS is {num_keypoints_oks}. \"", "\n", "\"They have to agree with each other. For meaning of OKS, please refer to \"", "\n", "\"http://cocodataset.org/#keypoints-eval.\"", "\n", ")", "\n", "\n", "", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "coco_eval", ".", "summarize", "(", ")", "\n", "\n", "return", "coco_eval", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.panoptic_evaluation.COCOPanopticEvaluator.__init__": [[31, 47], ["detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "panoptic_evaluation.COCOPanopticEvaluator._metadata.thing_dataset_id_to_contiguous_id.items", "panoptic_evaluation.COCOPanopticEvaluator._metadata.stuff_dataset_id_to_contiguous_id.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "output_dir", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset\n            output_dir (str): output directory to save results for evaluation\n        \"\"\"", "\n", "self", ".", "_metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "self", ".", "_thing_contiguous_id_to_dataset_id", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "self", ".", "_stuff_contiguous_id_to_dataset_id", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "stuff_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "\n", "PathManager", ".", "mkdirs", "(", "output_dir", ")", "\n", "self", ".", "_predictions_json", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"predictions.json\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.panoptic_evaluation.COCOPanopticEvaluator.reset": [[48, 50], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.panoptic_evaluation.COCOPanopticEvaluator._convert_category_id": [[51, 65], ["segment_info.pop"], "methods", ["None"], ["", "def", "_convert_category_id", "(", "self", ",", "segment_info", ")", ":", "\n", "        ", "isthing", "=", "segment_info", ".", "pop", "(", "\"isthing\"", ",", "None", ")", "\n", "if", "isthing", "is", "None", ":", "\n", "# the model produces panoptic category id directly. No more conversion needed", "\n", "            ", "return", "segment_info", "\n", "", "if", "isthing", "is", "True", ":", "\n", "            ", "segment_info", "[", "\"category_id\"", "]", "=", "self", ".", "_thing_contiguous_id_to_dataset_id", "[", "\n", "segment_info", "[", "\"category_id\"", "]", "\n", "]", "\n", "", "else", ":", "\n", "            ", "segment_info", "[", "\"category_id\"", "]", "=", "self", ".", "_stuff_contiguous_id_to_dataset_id", "[", "\n", "segment_info", "[", "\"category_id\"", "]", "\n", "]", "\n", "", "return", "segment_info", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.panoptic_evaluation.COCOPanopticEvaluator.process": [[66, 109], ["zip", "panoptic_img.cpu().numpy.cpu().numpy.cpu().numpy", "os.path.basename", "numpy.unique", "io.BytesIO", "PIL.Image.fromarray().save", "panoptic_evaluation.COCOPanopticEvaluator._predictions.append", "panoptic_img.cpu().numpy.cpu().numpy.cpu", "segments_info.append", "os.path.splitext", "panoptic_evaluation.COCOPanopticEvaluator._convert_category_id", "panoptic_evaluation.COCOPanopticEvaluator._metadata.thing_dataset_id_to_contiguous_id.values", "PIL.Image.fromarray", "out.getvalue", "int", "bool", "id2rgb", "int"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.panoptic_evaluation.COCOPanopticEvaluator._convert_category_id"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "from", "panopticapi", ".", "utils", "import", "id2rgb", "\n", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "panoptic_img", ",", "segments_info", "=", "output", "[", "\"panoptic_seg\"", "]", "\n", "panoptic_img", "=", "panoptic_img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "segments_info", "is", "None", ":", "\n", "# If \"segments_info\" is None, we assume \"panoptic_img\" is a", "\n", "# H*W int32 image storing the panoptic_id in the format of", "\n", "# category_id * label_divisor + instance_id. We reserve -1 for", "\n", "# VOID label, and add 1 to panoptic_img since the official", "\n", "# evaluation script uses 0 for VOID label.", "\n", "                ", "label_divisor", "=", "self", ".", "_metadata", ".", "label_divisor", "\n", "segments_info", "=", "[", "]", "\n", "for", "panoptic_label", "in", "np", ".", "unique", "(", "panoptic_img", ")", ":", "\n", "                    ", "if", "panoptic_label", "==", "-", "1", ":", "\n", "# VOID region.", "\n", "                        ", "continue", "\n", "", "pred_class", "=", "panoptic_label", "//", "label_divisor", "\n", "isthing", "=", "(", "\n", "pred_class", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", "\n", ")", "\n", "segments_info", ".", "append", "(", "\n", "{", "\n", "\"id\"", ":", "int", "(", "panoptic_label", ")", "+", "1", ",", "\n", "\"category_id\"", ":", "int", "(", "pred_class", ")", ",", "\n", "\"isthing\"", ":", "bool", "(", "isthing", ")", ",", "\n", "}", "\n", ")", "\n", "# Official evaluation script uses 0 for VOID label.", "\n", "", "panoptic_img", "+=", "1", "\n", "\n", "", "file_name", "=", "os", ".", "path", ".", "basename", "(", "input", "[", "\"file_name\"", "]", ")", "\n", "file_name_png", "=", "os", ".", "path", ".", "splitext", "(", "file_name", ")", "[", "0", "]", "+", "\".png\"", "\n", "with", "io", ".", "BytesIO", "(", ")", "as", "out", ":", "\n", "                ", "Image", ".", "fromarray", "(", "id2rgb", "(", "panoptic_img", ")", ")", ".", "save", "(", "out", ",", "format", "=", "\"PNG\"", ")", "\n", "segments_info", "=", "[", "self", ".", "_convert_category_id", "(", "x", ")", "for", "x", "in", "segments_info", "]", "\n", "self", ".", "_predictions", ".", "append", "(", "\n", "{", "\n", "\"image_id\"", ":", "input", "[", "\"image_id\"", "]", ",", "\n", "\"file_name\"", ":", "file_name_png", ",", "\n", "\"png_string\"", ":", "out", ".", "getvalue", "(", ")", ",", "\n", "\"segments_info\"", ":", "segments_info", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.panoptic_evaluation.COCOPanopticEvaluator.evaluate": [[112, 161], ["detectron2.utils.comm.synchronize", "detectron2.utils.comm.gather", "list", "fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.file_io.PathManager.get_local_path", "collections.OrderedDict", "panoptic_evaluation._print_panoptic_results", "itertools.chain", "detectron2.utils.comm.is_main_process", "tempfile.TemporaryDirectory", "logger.info", "open", "json.load", "fvcore.common.file_io.PathManager.open", "f.write", "contextlib.redirect_stdout", "pq_compute", "open", "f.write", "json.dumps", "io.StringIO", "fvcore.common.file_io.PathManager.get_local_path", "os.path.join", "p.pop"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.panoptic_evaluation._print_panoptic_results", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write"], ["", "", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "comm", ".", "synchronize", "(", ")", "\n", "\n", "self", ".", "_predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ")", "\n", "self", ".", "_predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "self", ".", "_predictions", ")", ")", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "return", "\n", "\n", "# PanopticApi requires local files", "\n", "", "gt_json", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "panoptic_json", ")", "\n", "gt_folder", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "panoptic_root", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"panoptic_eval\"", ")", "as", "pred_dir", ":", "\n", "            ", "logger", ".", "info", "(", "\"Writing all panoptic predictions to {} ...\"", ".", "format", "(", "pred_dir", ")", ")", "\n", "for", "p", "in", "self", ".", "_predictions", ":", "\n", "                ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "pred_dir", ",", "p", "[", "\"file_name\"", "]", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "p", ".", "pop", "(", "\"png_string\"", ")", ")", "\n", "\n", "", "", "with", "open", "(", "gt_json", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "json_data", "=", "json", ".", "load", "(", "f", ")", "\n", "", "json_data", "[", "\"annotations\"", "]", "=", "self", ".", "_predictions", "\n", "with", "PathManager", ".", "open", "(", "self", ".", "_predictions_json", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "json_data", ")", ")", "\n", "\n", "", "from", "panopticapi", ".", "evaluation", "import", "pq_compute", "\n", "\n", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "                ", "pq_res", "=", "pq_compute", "(", "\n", "gt_json", ",", "\n", "PathManager", ".", "get_local_path", "(", "self", ".", "_predictions_json", ")", ",", "\n", "gt_folder", "=", "gt_folder", ",", "\n", "pred_folder", "=", "pred_dir", ",", "\n", ")", "\n", "\n", "", "", "res", "=", "{", "}", "\n", "res", "[", "\"PQ\"", "]", "=", "100", "*", "pq_res", "[", "\"All\"", "]", "[", "\"pq\"", "]", "\n", "res", "[", "\"SQ\"", "]", "=", "100", "*", "pq_res", "[", "\"All\"", "]", "[", "\"sq\"", "]", "\n", "res", "[", "\"RQ\"", "]", "=", "100", "*", "pq_res", "[", "\"All\"", "]", "[", "\"rq\"", "]", "\n", "res", "[", "\"PQ_th\"", "]", "=", "100", "*", "pq_res", "[", "\"Things\"", "]", "[", "\"pq\"", "]", "\n", "res", "[", "\"SQ_th\"", "]", "=", "100", "*", "pq_res", "[", "\"Things\"", "]", "[", "\"sq\"", "]", "\n", "res", "[", "\"RQ_th\"", "]", "=", "100", "*", "pq_res", "[", "\"Things\"", "]", "[", "\"rq\"", "]", "\n", "res", "[", "\"PQ_st\"", "]", "=", "100", "*", "pq_res", "[", "\"Stuff\"", "]", "[", "\"pq\"", "]", "\n", "res", "[", "\"SQ_st\"", "]", "=", "100", "*", "pq_res", "[", "\"Stuff\"", "]", "[", "\"sq\"", "]", "\n", "res", "[", "\"RQ_st\"", "]", "=", "100", "*", "pq_res", "[", "\"Stuff\"", "]", "[", "\"rq\"", "]", "\n", "\n", "results", "=", "OrderedDict", "(", "{", "\"panoptic_seg\"", ":", "res", "}", ")", "\n", "_print_panoptic_results", "(", "pq_res", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.panoptic_evaluation._print_panoptic_results": [[163, 173], ["tabulate.tabulate", "logger.info", "data.append"], "function", ["None"], ["", "", "def", "_print_panoptic_results", "(", "pq_res", ")", ":", "\n", "    ", "headers", "=", "[", "\"\"", ",", "\"PQ\"", ",", "\"SQ\"", ",", "\"RQ\"", ",", "\"#categories\"", "]", "\n", "data", "=", "[", "]", "\n", "for", "name", "in", "[", "\"All\"", ",", "\"Things\"", ",", "\"Stuff\"", "]", ":", "\n", "        ", "row", "=", "[", "name", "]", "+", "[", "pq_res", "[", "name", "]", "[", "k", "]", "*", "100", "for", "k", "in", "[", "\"pq\"", ",", "\"sq\"", ",", "\"rq\"", "]", "]", "+", "[", "pq_res", "[", "name", "]", "[", "\"n\"", "]", "]", "\n", "data", ".", "append", "(", "row", ")", "\n", "", "table", "=", "tabulate", "(", "\n", "data", ",", "headers", "=", "headers", ",", "tablefmt", "=", "\"pipe\"", ",", "floatfmt", "=", "\".3f\"", ",", "stralign", "=", "\"center\"", ",", "numalign", "=", "\"center\"", "\n", ")", "\n", "logger", ".", "info", "(", "\"Panoptic Evaluation Results:\\n\"", "+", "table", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.__init__": [[37, 72], ["detectron2.data.MetadataCatalog.get", "os.path.join", "os.path.join", "torch.device", "logging.getLogger", "os.path.join", "os.path.isfile", "os.access", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "torch.load", "pascal_voc_evaluation.PascalVOCDetectionEvaluator.create_distribution", "pascal_voc_evaluation.PascalVOCDetectionEvaluator.create_distribution", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "str"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.create_distribution", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.create_distribution"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "cfg", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset, e.g., \"voc_2007_test\"\n        \"\"\"", "\n", "self", ".", "_dataset_name", "=", "dataset_name", "\n", "meta", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "self", ".", "_anno_file_template", "=", "os", ".", "path", ".", "join", "(", "meta", ".", "dirname", ",", "\"Annotations\"", ",", "\"{}.xml\"", ")", "\n", "self", ".", "_image_set_path", "=", "os", ".", "path", ".", "join", "(", "meta", ".", "dirname", ",", "\"ImageSets\"", ",", "\"Main\"", ",", "meta", ".", "split", "+", "\".txt\"", ")", "\n", "self", ".", "_class_names", "=", "meta", ".", "thing_classes", "\n", "assert", "meta", ".", "year", "in", "[", "2007", ",", "2012", "]", ",", "meta", ".", "year", "\n", "self", ".", "_is_2007", "=", "False", "\n", "# self._is_2007 = meta.year == 2007", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "if", "cfg", "is", "not", "None", ":", "\n", "            ", "self", ".", "prev_intro_cls", "=", "cfg", ".", "OWOD", ".", "PREV_INTRODUCED_CLS", "\n", "self", ".", "curr_intro_cls", "=", "cfg", ".", "OWOD", ".", "CUR_INTRODUCED_CLS", "\n", "self", ".", "total_num_class", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "self", ".", "unknown_class_index", "=", "self", ".", "total_num_class", "-", "1", "\n", "self", ".", "num_seen_classes", "=", "self", ".", "prev_intro_cls", "+", "self", ".", "curr_intro_cls", "\n", "self", ".", "known_classes", "=", "self", ".", "_class_names", "[", ":", "self", ".", "num_seen_classes", "]", "\n", "\n", "param_save_location", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "'energy_dist_'", "+", "str", "(", "self", ".", "num_seen_classes", ")", "+", "'.pkl'", ")", "\n", "self", ".", "energy_distribution_loaded", "=", "False", "\n", "if", "os", ".", "path", ".", "isfile", "(", "param_save_location", ")", "and", "os", ".", "access", "(", "param_save_location", ",", "os", ".", "R_OK", ")", ":", "\n", "                ", "self", ".", "_logger", ".", "info", "(", "'Loading energy distribution from '", "+", "param_save_location", ")", "\n", "params", "=", "torch", ".", "load", "(", "param_save_location", ")", "\n", "unknown", "=", "params", "[", "0", "]", "\n", "known", "=", "params", "[", "1", "]", "\n", "self", ".", "unk_dist", "=", "self", ".", "create_distribution", "(", "unknown", "[", "'scale_unk'", "]", ",", "unknown", "[", "'shape_unk'", "]", ",", "unknown", "[", "'shift_unk'", "]", ")", "\n", "self", ".", "known_dist", "=", "self", ".", "create_distribution", "(", "known", "[", "'scale_known'", "]", ",", "known", "[", "'shape_known'", "]", ",", "known", "[", "'shift_known'", "]", ")", "\n", "self", ".", "energy_distribution_loaded", "=", "True", "\n", "", "else", ":", "\n", "                ", "self", ".", "_logger", ".", "info", "(", "'Energy distribution is not found at '", "+", "param_save_location", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.create_distribution": [[74, 79], ["torch.distributions.weibull.Weibull", "torch.distributions.transforms.AffineTransform", "torch.distributions.transformed_distribution.TransformedDistribution"], "methods", ["None"], ["", "", "", "def", "create_distribution", "(", "self", ",", "scale", ",", "shape", ",", "shift", ")", ":", "\n", "        ", "wd", "=", "Weibull", "(", "scale", "=", "scale", ",", "concentration", "=", "shape", ")", "\n", "transforms", "=", "AffineTransform", "(", "loc", "=", "shift", ",", "scale", "=", "1.", ")", "\n", "weibull", "=", "TransformedDistribution", "(", "wd", ",", "transforms", ")", "\n", "return", "weibull", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_prob": [[80, 90], ["torch.linspace", "distribution.log_prob().exp", "torch.sum", "distribution.log_prob"], "methods", ["None"], ["", "def", "compute_prob", "(", "self", ",", "x", ",", "distribution", ")", ":", "\n", "        ", "eps_radius", "=", "0.5", "\n", "num_eval_points", "=", "100", "\n", "start_x", "=", "x", "-", "eps_radius", "\n", "end_x", "=", "x", "+", "eps_radius", "\n", "step", "=", "(", "end_x", "-", "start_x", ")", "/", "num_eval_points", "\n", "dx", "=", "torch", ".", "linspace", "(", "x", "-", "eps_radius", ",", "x", "+", "eps_radius", ",", "num_eval_points", ")", "\n", "pdf", "=", "distribution", ".", "log_prob", "(", "dx", ")", ".", "exp", "(", ")", "\n", "prob", "=", "torch", ".", "sum", "(", "pdf", "*", "step", ")", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.reset": [[91, 93], ["collections.defaultdict"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "defaultdict", "(", "list", ")", "# class name -> list of prediction strings", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.update_label_based_on_energy": [[94, 112], ["torch.logsumexp", "enumerate", "pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_prob", "pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_prob", "torch.isnan", "torch.isnan"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_prob", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_prob"], ["", "def", "update_label_based_on_energy", "(", "self", ",", "logits", ",", "classes", ")", ":", "\n", "        ", "if", "not", "self", ".", "energy_distribution_loaded", ":", "\n", "            ", "return", "classes", "\n", "", "else", ":", "\n", "            ", "cls", "=", "classes", "\n", "lse", "=", "torch", ".", "logsumexp", "(", "logits", "[", ":", ",", ":", "self", ".", "num_seen_classes", "]", ",", "dim", "=", "1", ")", "\n", "for", "i", ",", "energy", "in", "enumerate", "(", "lse", ")", ":", "\n", "                ", "p_unk", "=", "self", ".", "compute_prob", "(", "energy", ",", "self", ".", "unk_dist", ")", "\n", "p_known", "=", "self", ".", "compute_prob", "(", "energy", ",", "self", ".", "known_dist", ")", "\n", "if", "torch", ".", "isnan", "(", "p_unk", ")", "or", "torch", ".", "isnan", "(", "p_known", ")", ":", "\n", "                    ", "continue", "\n", "", "if", "p_unk", "<=", "p_known", ":", "\n", "                    ", "if", "cls", "[", "i", "]", "==", "self", ".", "unknown_class_index", ":", "\n", "                        ", "cls", "[", "i", "]", "=", "-", "100", "\n", "", "", "else", ":", "\n", "                    ", "if", "cls", "[", "i", "]", "!=", "self", ".", "unknown_class_index", ":", "\n", "                        ", "cls", "[", "i", "]", "=", "self", ".", "unknown_class_index", "\n", "", "", "", "return", "cls", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.process": [[114, 132], ["zip", "output[].to", "output[].to.pred_boxes.tensor.numpy", "output[].to.scores.tolist", "output[].to.pred_classes.tolist", "pascal_voc_evaluation.PascalVOCDetectionEvaluator.update_label_based_on_energy", "zip", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._predictions[].append"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.update_label_based_on_energy"], ["", "", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "image_id", "=", "input", "[", "\"image_id\"", "]", "\n", "instances", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "boxes", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "\n", "scores", "=", "instances", ".", "scores", ".", "tolist", "(", ")", "\n", "classes", "=", "instances", ".", "pred_classes", ".", "tolist", "(", ")", "\n", "logits", "=", "instances", ".", "logits", "\n", "classes", "=", "self", ".", "update_label_based_on_energy", "(", "logits", ",", "classes", ")", "\n", "for", "box", ",", "score", ",", "cls", "in", "zip", "(", "boxes", ",", "scores", ",", "classes", ")", ":", "\n", "                ", "if", "cls", "==", "-", "100", ":", "\n", "                    ", "continue", "\n", "", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "box", "\n", "# The inverse of data loading logic in `datasets/pascal_voc.py`", "\n", "xmin", "+=", "1", "\n", "ymin", "+=", "1", "\n", "self", ".", "_predictions", "[", "cls", "]", ".", "append", "(", "\n", "f\"{image_id} {score:.3f} {xmin:.1f} {ymin:.1f} {xmax:.1f} {ymax:.1f}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_avg_precision_at_many_recall_level_for_unk": [[134, 141], ["range", "pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_avg_precision_at_a_recall_level_for_unk"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_avg_precision_at_a_recall_level_for_unk"], ["", "", "", "def", "compute_avg_precision_at_many_recall_level_for_unk", "(", "self", ",", "precisions", ",", "recalls", ")", ":", "\n", "        ", "precs", "=", "{", "}", "\n", "for", "r", "in", "range", "(", "1", ",", "10", ")", ":", "\n", "            ", "r", "=", "r", "/", "10", "\n", "p", "=", "self", ".", "compute_avg_precision_at_a_recall_level_for_unk", "(", "precisions", ",", "recalls", ",", "recall_level", "=", "r", ")", "\n", "precs", "[", "r", "]", "=", "p", "\n", "", "return", "precs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_avg_precision_at_a_recall_level_for_unk": [[142, 155], ["recalls.items", "enumerate", "len", "numpy.mean", "prec.append", "len", "min", "range", "len", "abs"], "methods", ["None"], ["", "def", "compute_avg_precision_at_a_recall_level_for_unk", "(", "self", ",", "precisions", ",", "recalls", ",", "recall_level", "=", "0.5", ")", ":", "\n", "        ", "precs", "=", "{", "}", "\n", "for", "iou", ",", "recall", "in", "recalls", ".", "items", "(", ")", ":", "\n", "            ", "prec", "=", "[", "]", "\n", "for", "cls_id", ",", "rec", "in", "enumerate", "(", "recall", ")", ":", "\n", "                ", "if", "cls_id", "==", "self", ".", "unknown_class_index", "and", "len", "(", "rec", ")", ">", "0", ":", "\n", "                    ", "p", "=", "precisions", "[", "iou", "]", "[", "cls_id", "]", "[", "min", "(", "range", "(", "len", "(", "rec", ")", ")", ",", "key", "=", "lambda", "i", ":", "abs", "(", "rec", "[", "i", "]", "-", "recall_level", ")", ")", "]", "\n", "prec", ".", "append", "(", "p", ")", "\n", "", "", "if", "len", "(", "prec", ")", ">", "0", ":", "\n", "                ", "precs", "[", "iou", "]", "=", "np", ".", "mean", "(", "prec", ")", "\n", "", "else", ":", "\n", "                ", "precs", "[", "iou", "]", "=", "0", "\n", "", "", "return", "precs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_WI_at_many_recall_level": [[156, 163], ["range", "pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_WI_at_a_recall_level"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_WI_at_a_recall_level"], ["", "def", "compute_WI_at_many_recall_level", "(", "self", ",", "recalls", ",", "tp_plus_fp_cs", ",", "fp_os", ")", ":", "\n", "        ", "wi_at_recall", "=", "{", "}", "\n", "for", "r", "in", "range", "(", "1", ",", "10", ")", ":", "\n", "            ", "r", "=", "r", "/", "10", "\n", "wi", "=", "self", ".", "compute_WI_at_a_recall_level", "(", "recalls", ",", "tp_plus_fp_cs", ",", "fp_os", ",", "recall_level", "=", "r", ")", "\n", "wi_at_recall", "[", "r", "]", "=", "wi", "\n", "", "return", "wi_at_recall", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_WI_at_a_recall_level": [[164, 181], ["recalls.items", "enumerate", "len", "min", "tp_plus_fps.append", "fps.append", "numpy.mean", "numpy.mean", "range", "len", "range", "len", "abs"], "methods", ["None"], ["", "def", "compute_WI_at_a_recall_level", "(", "self", ",", "recalls", ",", "tp_plus_fp_cs", ",", "fp_os", ",", "recall_level", "=", "0.5", ")", ":", "\n", "        ", "wi_at_iou", "=", "{", "}", "\n", "for", "iou", ",", "recall", "in", "recalls", ".", "items", "(", ")", ":", "\n", "            ", "tp_plus_fps", "=", "[", "]", "\n", "fps", "=", "[", "]", "\n", "for", "cls_id", ",", "rec", "in", "enumerate", "(", "recall", ")", ":", "\n", "                ", "if", "cls_id", "in", "range", "(", "self", ".", "num_seen_classes", ")", "and", "len", "(", "rec", ")", ">", "0", ":", "\n", "                    ", "index", "=", "min", "(", "range", "(", "len", "(", "rec", ")", ")", ",", "key", "=", "lambda", "i", ":", "abs", "(", "rec", "[", "i", "]", "-", "recall_level", ")", ")", "\n", "tp_plus_fp", "=", "tp_plus_fp_cs", "[", "iou", "]", "[", "cls_id", "]", "[", "index", "]", "\n", "tp_plus_fps", ".", "append", "(", "tp_plus_fp", ")", "\n", "fp", "=", "fp_os", "[", "iou", "]", "[", "cls_id", "]", "[", "index", "]", "\n", "fps", ".", "append", "(", "fp", ")", "\n", "", "", "if", "len", "(", "tp_plus_fps", ")", ">", "0", ":", "\n", "                ", "wi_at_iou", "[", "iou", "]", "=", "np", ".", "mean", "(", "fps", ")", "/", "np", ".", "mean", "(", "tp_plus_fps", ")", "\n", "", "else", ":", "\n", "                ", "wi_at_iou", "[", "iou", "]", "=", "0", "\n", "", "", "return", "wi_at_iou", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.evaluate": [[182, 306], ["detectron2.utils.comm.gather", "collections.defaultdict", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_WI_at_many_recall_level", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_avg_precision_at_many_recall_level_for_unk", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "collections.OrderedDict", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "list", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "detectron2.utils.comm.is_main_process", "predictions_per_rank.items", "tempfile.TemporaryDirectory", "os.path.join", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "enumerate", "numpy.mean", "numpy.mean", "numpy.sum", "numpy.mean", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "predictions[].extend", "collections.defaultdict.get", "pascal_voc_evaluation.PascalVOCDetectionEvaluator._logger.info", "pascal_voc_evaluation.voc_eval", "aps[].append", "unk_det_as_knowns[].append", "num_unks[].append", "all_precs[].append", "all_recs[].append", "tp_plus_fp_cs[].append", "fp_os[].append", "str", "str", "collections.defaultdict.items", "list", "collections.defaultdict.items", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "open", "f.write", "recs[].append", "precs[].append", "mAP.values", "str", "str", "str", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "os.path.join.format", "recs[].append", "precs[].append", "collections.defaultdict.items", "numpy.mean", "numpy.mean", "numpy.mean", "str", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_WI_at_many_recall_level", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.PascalVOCDetectionEvaluator.compute_avg_precision_at_many_recall_level_for_unk", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.voc_eval", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict: has a key \"segm\", whose value is a dict of \"AP\", \"AP50\", and \"AP75\".\n        \"\"\"", "\n", "all_predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ",", "dst", "=", "0", ")", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "return", "\n", "", "predictions", "=", "defaultdict", "(", "list", ")", "\n", "for", "predictions_per_rank", "in", "all_predictions", ":", "\n", "            ", "for", "clsid", ",", "lines", "in", "predictions_per_rank", ".", "items", "(", ")", ":", "\n", "                ", "predictions", "[", "clsid", "]", ".", "extend", "(", "lines", ")", "\n", "", "", "del", "all_predictions", "\n", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "\"Evaluating {} using {} metric. \"", "\n", "\"Note that results do not use the official Matlab API.\"", ".", "format", "(", "\n", "self", ".", "_dataset_name", ",", "2007", "if", "self", ".", "_is_2007", "else", "2012", "\n", ")", "\n", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"pascal_voc_eval_\"", ")", "as", "dirname", ":", "\n", "            ", "res_file_template", "=", "os", ".", "path", ".", "join", "(", "dirname", ",", "\"{}.txt\"", ")", "\n", "\n", "aps", "=", "defaultdict", "(", "list", ")", "# iou -> ap per class", "\n", "recs", "=", "defaultdict", "(", "list", ")", "\n", "precs", "=", "defaultdict", "(", "list", ")", "\n", "all_recs", "=", "defaultdict", "(", "list", ")", "\n", "all_precs", "=", "defaultdict", "(", "list", ")", "\n", "unk_det_as_knowns", "=", "defaultdict", "(", "list", ")", "\n", "num_unks", "=", "defaultdict", "(", "list", ")", "\n", "tp_plus_fp_cs", "=", "defaultdict", "(", "list", ")", "\n", "fp_os", "=", "defaultdict", "(", "list", ")", "\n", "\n", "for", "cls_id", ",", "cls_name", "in", "enumerate", "(", "self", ".", "_class_names", ")", ":", "\n", "                ", "lines", "=", "predictions", ".", "get", "(", "cls_id", ",", "[", "\"\"", "]", ")", "\n", "self", ".", "_logger", ".", "info", "(", "cls_name", "+", "\" has \"", "+", "str", "(", "len", "(", "lines", ")", ")", "+", "\" predictions.\"", ")", "\n", "with", "open", "(", "res_file_template", ".", "format", "(", "cls_name", ")", ",", "\"w\"", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "\"\\n\"", ".", "join", "(", "lines", ")", ")", "\n", "\n", "# for thresh in range(50, 100, 5):", "\n", "", "thresh", "=", "50", "\n", "rec", ",", "prec", ",", "ap", ",", "unk_det_as_known", ",", "num_unk", ",", "tp_plus_fp_closed_set", ",", "fp_open_set", "=", "voc_eval", "(", "\n", "res_file_template", ",", "\n", "self", ".", "_anno_file_template", ",", "\n", "self", ".", "_image_set_path", ",", "\n", "cls_name", ",", "\n", "ovthresh", "=", "thresh", "/", "100.0", ",", "\n", "use_07_metric", "=", "self", ".", "_is_2007", ",", "\n", "known_classes", "=", "self", ".", "known_classes", "\n", ")", "\n", "aps", "[", "thresh", "]", ".", "append", "(", "ap", "*", "100", ")", "\n", "unk_det_as_knowns", "[", "thresh", "]", ".", "append", "(", "unk_det_as_known", ")", "\n", "num_unks", "[", "thresh", "]", ".", "append", "(", "num_unk", ")", "\n", "all_precs", "[", "thresh", "]", ".", "append", "(", "prec", ")", "\n", "all_recs", "[", "thresh", "]", ".", "append", "(", "rec", ")", "\n", "tp_plus_fp_cs", "[", "thresh", "]", ".", "append", "(", "tp_plus_fp_closed_set", ")", "\n", "fp_os", "[", "thresh", "]", ".", "append", "(", "fp_open_set", ")", "\n", "try", ":", "\n", "                    ", "recs", "[", "thresh", "]", ".", "append", "(", "rec", "[", "-", "1", "]", "*", "100", ")", "\n", "precs", "[", "thresh", "]", ".", "append", "(", "prec", "[", "-", "1", "]", "*", "100", ")", "\n", "", "except", ":", "\n", "                    ", "recs", "[", "thresh", "]", ".", "append", "(", "0", ")", "\n", "precs", "[", "thresh", "]", ".", "append", "(", "0", ")", "\n", "\n", "", "", "", "wi", "=", "self", ".", "compute_WI_at_many_recall_level", "(", "all_recs", ",", "tp_plus_fp_cs", ",", "fp_os", ")", "\n", "self", ".", "_logger", ".", "info", "(", "'Wilderness Impact: '", "+", "str", "(", "wi", ")", ")", "\n", "\n", "avg_precision_unk", "=", "self", ".", "compute_avg_precision_at_many_recall_level_for_unk", "(", "all_precs", ",", "all_recs", ")", "\n", "self", ".", "_logger", ".", "info", "(", "'avg_precision: '", "+", "str", "(", "avg_precision_unk", ")", ")", "\n", "\n", "ret", "=", "OrderedDict", "(", ")", "\n", "mAP", "=", "{", "iou", ":", "np", ".", "mean", "(", "x", ")", "for", "iou", ",", "x", "in", "aps", ".", "items", "(", ")", "}", "\n", "ret", "[", "\"bbox\"", "]", "=", "{", "\"AP\"", ":", "np", ".", "mean", "(", "list", "(", "mAP", ".", "values", "(", ")", ")", ")", ",", "\"AP50\"", ":", "mAP", "[", "50", "]", "}", "\n", "\n", "total_num_unk_det_as_known", "=", "{", "iou", ":", "np", ".", "sum", "(", "x", ")", "for", "iou", ",", "x", "in", "unk_det_as_knowns", ".", "items", "(", ")", "}", "\n", "total_num_unk", "=", "num_unks", "[", "50", "]", "[", "0", "]", "\n", "self", ".", "_logger", ".", "info", "(", "'Absolute OSE (total_num_unk_det_as_known): '", "+", "str", "(", "total_num_unk_det_as_known", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "'total_num_unk '", "+", "str", "(", "total_num_unk", ")", ")", "\n", "\n", "# Extra logging of class-wise APs", "\n", "avg_precs", "=", "list", "(", "np", ".", "mean", "(", "[", "x", "for", "_", ",", "x", "in", "aps", ".", "items", "(", ")", "]", ",", "axis", "=", "0", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "self", ".", "_class_names", ")", "\n", "# self._logger.info(\"AP__: \" + str(['%.1f' % x for x in avg_precs]))", "\n", "self", ".", "_logger", ".", "info", "(", "\"AP50: \"", "+", "str", "(", "[", "'%.1f'", "%", "x", "for", "x", "in", "aps", "[", "50", "]", "]", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Precisions50: \"", "+", "str", "(", "[", "'%.1f'", "%", "x", "for", "x", "in", "precs", "[", "50", "]", "]", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Recall50: \"", "+", "str", "(", "[", "'%.1f'", "%", "x", "for", "x", "in", "recs", "[", "50", "]", "]", ")", ")", "\n", "# self._logger.info(\"AP75: \" + str(['%.1f' % x for x in aps[75]]))", "\n", "\n", "if", "self", ".", "prev_intro_cls", ">", "0", ":", "\n", "# self._logger.info(\"\\nPrev class AP__: \" + str(np.mean(avg_precs[:self.prev_intro_cls])))", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Prev class AP50: \"", "+", "str", "(", "np", ".", "mean", "(", "aps", "[", "50", "]", "[", ":", "self", ".", "prev_intro_cls", "]", ")", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Prev class Precisions50: \"", "+", "str", "(", "np", ".", "mean", "(", "precs", "[", "50", "]", "[", ":", "self", ".", "prev_intro_cls", "]", ")", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Prev class Recall50: \"", "+", "str", "(", "np", ".", "mean", "(", "recs", "[", "50", "]", "[", ":", "self", ".", "prev_intro_cls", "]", ")", ")", ")", "\n", "\n", "# self._logger.info(\"Prev class AP75: \" + str(np.mean(aps[75][:self.prev_intro_cls])))", "\n", "\n", "# self._logger.info(\"\\nCurrent class AP__: \" + str(np.mean(avg_precs[self.prev_intro_cls:self.curr_intro_cls])))", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Current class AP50: \"", "+", "str", "(", "np", ".", "mean", "(", "aps", "[", "50", "]", "[", "self", ".", "prev_intro_cls", ":", "self", ".", "prev_intro_cls", "+", "self", ".", "curr_intro_cls", "]", ")", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Current class Precisions50: \"", "+", "str", "(", "np", ".", "mean", "(", "precs", "[", "50", "]", "[", "self", ".", "prev_intro_cls", ":", "self", ".", "prev_intro_cls", "+", "self", ".", "curr_intro_cls", "]", ")", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Current class Recall50: \"", "+", "str", "(", "np", ".", "mean", "(", "recs", "[", "50", "]", "[", "self", ".", "prev_intro_cls", ":", "self", ".", "prev_intro_cls", "+", "self", ".", "curr_intro_cls", "]", ")", ")", ")", "\n", "# self._logger.info(\"Current class AP75: \" + str(np.mean(aps[75][self.prev_intro_cls:self.curr_intro_cls])))", "\n", "\n", "# self._logger.info(\"\\nKnown AP__: \" + str(np.mean(avg_precs[:self.prev_intro_cls + self.curr_intro_cls])))", "\n", "self", ".", "_logger", ".", "info", "(", "\"Known AP50: \"", "+", "str", "(", "np", ".", "mean", "(", "aps", "[", "50", "]", "[", ":", "self", ".", "prev_intro_cls", "+", "self", ".", "curr_intro_cls", "]", ")", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Known Precisions50: \"", "+", "str", "(", "np", ".", "mean", "(", "precs", "[", "50", "]", "[", ":", "self", ".", "prev_intro_cls", "+", "self", ".", "curr_intro_cls", "]", ")", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Known Recall50: \"", "+", "str", "(", "np", ".", "mean", "(", "recs", "[", "50", "]", "[", ":", "self", ".", "prev_intro_cls", "+", "self", ".", "curr_intro_cls", "]", ")", ")", ")", "\n", "# self._logger.info(\"Known AP75: \" + str(np.mean(aps[75][:self.prev_intro_cls + self.curr_intro_cls])))", "\n", "\n", "# self._logger.info(\"\\nUnknown AP__: \" + str(avg_precs[-1]))", "\n", "self", ".", "_logger", ".", "info", "(", "\"Unknown AP50: \"", "+", "str", "(", "aps", "[", "50", "]", "[", "-", "1", "]", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Unknown Precisions50: \"", "+", "str", "(", "precs", "[", "50", "]", "[", "-", "1", "]", ")", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Unknown Recall50: \"", "+", "str", "(", "recs", "[", "50", "]", "[", "-", "1", "]", ")", ")", "\n", "# self._logger.info(\"Unknown AP75: \" + str(aps[75][-1]))", "\n", "\n", "# self._logger.info(\"R__: \" + str(['%.1f' % x for x in list(np.mean([x for _, x in recs.items()], axis=0))]))", "\n", "# self._logger.info(\"R50: \" + str(['%.1f' % x for x in recs[50]]))", "\n", "# self._logger.info(\"R75: \" + str(['%.1f' % x for x in recs[75]]))", "\n", "#", "\n", "# self._logger.info(\"P__: \" + str(['%.1f' % x for x in list(np.mean([x for _, x in precs.items()], axis=0))]))", "\n", "# self._logger.info(\"P50: \" + str(['%.1f' % x for x in precs[50]]))", "\n", "# self._logger.info(\"P75: \" + str(['%.1f' % x for x in precs[75]]))", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.parse_rec": [[321, 362], ["functools.lru_cache", "ET.parse.findall", "int", "obj.find", "objects.append", "fvcore.common.file_io.PathManager.open", "xml.parse", "logging.getLogger", "logging.getLogger.info", "obj.find", "int", "int", "int", "int", "obj.find", "VOC_CLASS_NAMES_COCOFIED.index", "obj.find.find", "obj.find.find", "obj.find.find", "obj.find.find"], "function", ["None"], ["@", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "parse_rec", "(", "filename", ",", "known_classes", ")", ":", "\n", "    ", "\"\"\"Parse a PASCAL VOC xml file.\"\"\"", "\n", "VOC_CLASS_NAMES_COCOFIED", "=", "[", "\n", "\"airplane\"", ",", "\"dining table\"", ",", "\"motorcycle\"", ",", "\n", "\"potted plant\"", ",", "\"couch\"", ",", "\"tv\"", "\n", "]", "\n", "BASE_VOC_CLASS_NAMES", "=", "[", "\n", "\"aeroplane\"", ",", "\"diningtable\"", ",", "\"motorbike\"", ",", "\n", "\"pottedplant\"", ",", "\"sofa\"", ",", "\"tvmonitor\"", "\n", "]", "\n", "try", ":", "\n", "        ", "with", "PathManager", ".", "open", "(", "filename", ")", "as", "f", ":", "\n", "            ", "tree", "=", "ET", ".", "parse", "(", "f", ")", "\n", "", "", "except", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "'Not able to load: '", "+", "filename", "+", "'. Continuing without aboarting...'", ")", "\n", "return", "None", "\n", "\n", "", "objects", "=", "[", "]", "\n", "for", "obj", "in", "tree", ".", "findall", "(", "\"object\"", ")", ":", "\n", "        ", "obj_struct", "=", "{", "}", "\n", "cls_name", "=", "obj", ".", "find", "(", "\"name\"", ")", ".", "text", "\n", "if", "cls_name", "in", "VOC_CLASS_NAMES_COCOFIED", ":", "\n", "            ", "cls_name", "=", "BASE_VOC_CLASS_NAMES", "[", "VOC_CLASS_NAMES_COCOFIED", ".", "index", "(", "cls_name", ")", "]", "\n", "", "if", "cls_name", "not", "in", "known_classes", ":", "\n", "            ", "cls_name", "=", "'unknown'", "\n", "", "obj_struct", "[", "\"name\"", "]", "=", "cls_name", "\n", "# obj_struct[\"pose\"] = obj.find(\"pose\").text", "\n", "# obj_struct[\"truncated\"] = int(obj.find(\"truncated\").text)", "\n", "obj_struct", "[", "\"difficult\"", "]", "=", "int", "(", "obj", ".", "find", "(", "\"difficult\"", ")", ".", "text", ")", "\n", "bbox", "=", "obj", ".", "find", "(", "\"bndbox\"", ")", "\n", "obj_struct", "[", "\"bbox\"", "]", "=", "[", "\n", "int", "(", "bbox", ".", "find", "(", "\"xmin\"", ")", ".", "text", ")", ",", "\n", "int", "(", "bbox", ".", "find", "(", "\"ymin\"", ")", ".", "text", ")", ",", "\n", "int", "(", "bbox", ".", "find", "(", "\"xmax\"", ")", ".", "text", ")", ",", "\n", "int", "(", "bbox", ".", "find", "(", "\"ymax\"", ")", ".", "text", ")", ",", "\n", "]", "\n", "objects", ".", "append", "(", "obj_struct", ")", "\n", "\n", "", "return", "objects", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.voc_ap": [[364, 394], ["numpy.arange", "numpy.concatenate", "numpy.concatenate", "range", "numpy.sum", "numpy.maximum", "numpy.where", "numpy.sum", "numpy.max"], "function", ["None"], ["", "def", "voc_ap", "(", "rec", ",", "prec", ",", "use_07_metric", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute VOC AP given precision and recall. If use_07_metric is true, uses\n    the VOC 07 11-point method (default:False).\n    \"\"\"", "\n", "if", "use_07_metric", ":", "\n", "# 11 point metric", "\n", "        ", "ap", "=", "0.0", "\n", "for", "t", "in", "np", ".", "arange", "(", "0.0", ",", "1.1", ",", "0.1", ")", ":", "\n", "            ", "if", "np", ".", "sum", "(", "rec", ">=", "t", ")", "==", "0", ":", "\n", "                ", "p", "=", "0", "\n", "", "else", ":", "\n", "                ", "p", "=", "np", ".", "max", "(", "prec", "[", "rec", ">=", "t", "]", ")", "\n", "", "ap", "=", "ap", "+", "p", "/", "11.0", "\n", "", "", "else", ":", "\n", "# correct AP calculation", "\n", "# first append sentinel values at the end", "\n", "        ", "mrec", "=", "np", ".", "concatenate", "(", "(", "[", "0.0", "]", ",", "rec", ",", "[", "1.0", "]", ")", ")", "\n", "mpre", "=", "np", ".", "concatenate", "(", "(", "[", "0.0", "]", ",", "prec", ",", "[", "0.0", "]", ")", ")", "\n", "\n", "# compute the precision envelope", "\n", "for", "i", "in", "range", "(", "mpre", ".", "size", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "mpre", "[", "i", "-", "1", "]", "=", "np", ".", "maximum", "(", "mpre", "[", "i", "-", "1", "]", ",", "mpre", "[", "i", "]", ")", "\n", "\n", "# to calculate area under PR curve, look for points", "\n", "# where X axis (recall) changes value", "\n", "", "i", "=", "np", ".", "where", "(", "mrec", "[", "1", ":", "]", "!=", "mrec", "[", ":", "-", "1", "]", ")", "[", "0", "]", "\n", "\n", "# and sum (\\Delta recall) * prec", "\n", "ap", "=", "np", ".", "sum", "(", "(", "mrec", "[", "i", "+", "1", "]", "-", "mrec", "[", "i", "]", ")", "*", "mpre", "[", "i", "+", "1", "]", ")", "\n", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.voc_eval": [[396, 593], ["detpath.format", "numpy.array", "numpy.array().reshape", "numpy.argsort", "len", "numpy.zeros", "numpy.zeros", "range", "numpy.cumsum", "numpy.cumsum", "pascal_voc_evaluation.voc_ap", "logging.getLogger", "numpy.zeros", "range", "numpy.sum", "numpy.cumsum", "fvcore.common.file_io.PathManager.open", "f.readlines", "x.strip", "pascal_voc_evaluation.parse_rec", "numpy.array", "numpy.array().astype", "open", "f.readlines", "x.strip().split", "BB[].astype", "R[].astype", "float", "numpy.maximum", "numpy.array", "numpy.array().astype", "BB[].astype", "R[].astype", "annopath.format", "tuple", "imagenames_filtered.append", "len", "sum", "float", "numpy.array", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.max", "numpy.argmax", "len", "sum", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.max", "numpy.argmax", "numpy.array", "x.strip", "numpy.finfo", "numpy.array", "float"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.voc_ap", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.parse_rec"], ["", "def", "voc_eval", "(", "detpath", ",", "annopath", ",", "imagesetfile", ",", "classname", ",", "ovthresh", "=", "0.5", ",", "use_07_metric", "=", "False", ",", "known_classes", "=", "None", ")", ":", "\n", "    ", "\"\"\"rec, prec, ap = voc_eval(detpath,\n                                annopath,\n                                imagesetfile,\n                                classname,\n                                [ovthresh],\n                                [use_07_metric])\n\n    Top level function that does the PASCAL VOC evaluation.\n\n    detpath: Path to detections\n        detpath.format(classname) should produce the detection results file.\n    annopath: Path to annotations\n        annopath.format(imagename) should be the xml annotations file.\n    imagesetfile: Text file containing the list of images, one image per line.\n    classname: Category name (duh)\n    [ovthresh]: Overlap threshold (default = 0.5)\n    [use_07_metric]: Whether to use VOC07's 11 point AP computation\n        (default False)\n    \"\"\"", "\n", "# assumes detections are in detpath.format(classname)", "\n", "# assumes annotations are in annopath.format(imagename)", "\n", "# assumes imagesetfile is a text file with each line an image name", "\n", "\n", "# first load gt", "\n", "# read list of images", "\n", "with", "PathManager", ".", "open", "(", "imagesetfile", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "imagenames", "=", "[", "x", ".", "strip", "(", ")", "for", "x", "in", "lines", "]", "\n", "\n", "imagenames_filtered", "=", "[", "]", "\n", "# load annots", "\n", "recs", "=", "{", "}", "\n", "for", "imagename", "in", "imagenames", ":", "\n", "        ", "rec", "=", "parse_rec", "(", "annopath", ".", "format", "(", "imagename", ")", ",", "tuple", "(", "known_classes", ")", ")", "\n", "if", "rec", "is", "not", "None", ":", "\n", "            ", "recs", "[", "imagename", "]", "=", "rec", "\n", "imagenames_filtered", ".", "append", "(", "imagename", ")", "\n", "\n", "", "", "imagenames", "=", "imagenames_filtered", "\n", "\n", "# extract gt objects for this class", "\n", "class_recs", "=", "{", "}", "\n", "npos", "=", "0", "\n", "for", "imagename", "in", "imagenames", ":", "\n", "        ", "R", "=", "[", "obj", "for", "obj", "in", "recs", "[", "imagename", "]", "if", "obj", "[", "\"name\"", "]", "==", "classname", "]", "\n", "bbox", "=", "np", ".", "array", "(", "[", "x", "[", "\"bbox\"", "]", "for", "x", "in", "R", "]", ")", "\n", "difficult", "=", "np", ".", "array", "(", "[", "x", "[", "\"difficult\"", "]", "for", "x", "in", "R", "]", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "# difficult = np.array([False for x in R]).astype(np.bool)  # treat all \"difficult\" as GT", "\n", "det", "=", "[", "False", "]", "*", "len", "(", "R", ")", "\n", "npos", "=", "npos", "+", "sum", "(", "~", "difficult", ")", "\n", "class_recs", "[", "imagename", "]", "=", "{", "\"bbox\"", ":", "bbox", ",", "\"difficult\"", ":", "difficult", ",", "\"det\"", ":", "det", "}", "\n", "\n", "# read dets", "\n", "", "detfile", "=", "detpath", ".", "format", "(", "classname", ")", "\n", "with", "open", "(", "detfile", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "", "splitlines", "=", "[", "x", ".", "strip", "(", ")", ".", "split", "(", "\" \"", ")", "for", "x", "in", "lines", "]", "\n", "image_ids", "=", "[", "x", "[", "0", "]", "for", "x", "in", "splitlines", "]", "\n", "confidence", "=", "np", ".", "array", "(", "[", "float", "(", "x", "[", "1", "]", ")", "for", "x", "in", "splitlines", "]", ")", "\n", "BB", "=", "np", ".", "array", "(", "[", "[", "float", "(", "z", ")", "for", "z", "in", "x", "[", "2", ":", "]", "]", "for", "x", "in", "splitlines", "]", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "\n", "# sort by confidence", "\n", "sorted_ind", "=", "np", ".", "argsort", "(", "-", "confidence", ")", "\n", "BB", "=", "BB", "[", "sorted_ind", ",", ":", "]", "\n", "image_ids", "=", "[", "image_ids", "[", "x", "]", "for", "x", "in", "sorted_ind", "]", "\n", "\n", "# go down dets and mark TPs and FPs", "\n", "nd", "=", "len", "(", "image_ids", ")", "\n", "tp", "=", "np", ".", "zeros", "(", "nd", ")", "\n", "fp", "=", "np", ".", "zeros", "(", "nd", ")", "\n", "\n", "# if 'unknown' not in classname:", "\n", "#     return tp, fp, 0", "\n", "\n", "for", "d", "in", "range", "(", "nd", ")", ":", "\n", "        ", "R", "=", "class_recs", "[", "image_ids", "[", "d", "]", "]", "\n", "bb", "=", "BB", "[", "d", ",", ":", "]", ".", "astype", "(", "float", ")", "\n", "ovmax", "=", "-", "np", ".", "inf", "\n", "BBGT", "=", "R", "[", "\"bbox\"", "]", ".", "astype", "(", "float", ")", "\n", "\n", "if", "BBGT", ".", "size", ">", "0", ":", "\n", "# compute overlaps", "\n", "# intersection", "\n", "            ", "ixmin", "=", "np", ".", "maximum", "(", "BBGT", "[", ":", ",", "0", "]", ",", "bb", "[", "0", "]", ")", "\n", "iymin", "=", "np", ".", "maximum", "(", "BBGT", "[", ":", ",", "1", "]", ",", "bb", "[", "1", "]", ")", "\n", "ixmax", "=", "np", ".", "minimum", "(", "BBGT", "[", ":", ",", "2", "]", ",", "bb", "[", "2", "]", ")", "\n", "iymax", "=", "np", ".", "minimum", "(", "BBGT", "[", ":", ",", "3", "]", ",", "bb", "[", "3", "]", ")", "\n", "iw", "=", "np", ".", "maximum", "(", "ixmax", "-", "ixmin", "+", "1.0", ",", "0.0", ")", "\n", "ih", "=", "np", ".", "maximum", "(", "iymax", "-", "iymin", "+", "1.0", ",", "0.0", ")", "\n", "inters", "=", "iw", "*", "ih", "\n", "\n", "# union", "\n", "uni", "=", "(", "\n", "(", "bb", "[", "2", "]", "-", "bb", "[", "0", "]", "+", "1.0", ")", "*", "(", "bb", "[", "3", "]", "-", "bb", "[", "1", "]", "+", "1.0", ")", "\n", "+", "(", "BBGT", "[", ":", ",", "2", "]", "-", "BBGT", "[", ":", ",", "0", "]", "+", "1.0", ")", "*", "(", "BBGT", "[", ":", ",", "3", "]", "-", "BBGT", "[", ":", ",", "1", "]", "+", "1.0", ")", "\n", "-", "inters", "\n", ")", "\n", "\n", "overlaps", "=", "inters", "/", "uni", "\n", "ovmax", "=", "np", ".", "max", "(", "overlaps", ")", "\n", "jmax", "=", "np", ".", "argmax", "(", "overlaps", ")", "\n", "\n", "", "if", "ovmax", ">", "ovthresh", ":", "\n", "            ", "if", "not", "R", "[", "\"difficult\"", "]", "[", "jmax", "]", ":", "\n", "                ", "if", "not", "R", "[", "\"det\"", "]", "[", "jmax", "]", ":", "\n", "                    ", "tp", "[", "d", "]", "=", "1.0", "\n", "R", "[", "\"det\"", "]", "[", "jmax", "]", "=", "1", "\n", "", "else", ":", "\n", "                    ", "fp", "[", "d", "]", "=", "1.0", "\n", "", "", "", "else", ":", "\n", "            ", "fp", "[", "d", "]", "=", "1.0", "\n", "\n", "# compute precision recall", "\n", "", "", "fp", "=", "np", ".", "cumsum", "(", "fp", ")", "\n", "tp", "=", "np", ".", "cumsum", "(", "tp", ")", "\n", "rec", "=", "tp", "/", "float", "(", "npos", ")", "\n", "# avoid divide by zero in case the first detection matches a difficult", "\n", "# ground truth", "\n", "prec", "=", "tp", "/", "np", ".", "maximum", "(", "tp", "+", "fp", ",", "np", ".", "finfo", "(", "np", ".", "float64", ")", ".", "eps", ")", "\n", "# plot_pr_curve(prec, rec, classname+'.png')", "\n", "ap", "=", "voc_ap", "(", "rec", ",", "prec", ",", "use_07_metric", ")", "\n", "\n", "# print('tp: ' + str(tp[-1]))", "\n", "# print('fp: ' + str(fp[-1]))", "\n", "# print('tp: ')", "\n", "# print(tp)", "\n", "# print('fp: ')", "\n", "# print(fp)", "\n", "\n", "'''\n    Computing Absolute Open-Set Error (A-OSE) and Wilderness Impact (WI)\n                                    ===========    \n    Absolute OSE = # of unknown objects classified as known objects of class 'classname'\n    WI = FP_openset / (TP_closed_set + FP_closed_set)\n    '''", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "# Finding GT of unknown objects", "\n", "unknown_class_recs", "=", "{", "}", "\n", "n_unk", "=", "0", "\n", "for", "imagename", "in", "imagenames", ":", "\n", "        ", "R", "=", "[", "obj", "for", "obj", "in", "recs", "[", "imagename", "]", "if", "obj", "[", "\"name\"", "]", "==", "'unknown'", "]", "\n", "bbox", "=", "np", ".", "array", "(", "[", "x", "[", "\"bbox\"", "]", "for", "x", "in", "R", "]", ")", "\n", "difficult", "=", "np", ".", "array", "(", "[", "x", "[", "\"difficult\"", "]", "for", "x", "in", "R", "]", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "det", "=", "[", "False", "]", "*", "len", "(", "R", ")", "\n", "n_unk", "=", "n_unk", "+", "sum", "(", "~", "difficult", ")", "\n", "unknown_class_recs", "[", "imagename", "]", "=", "{", "\"bbox\"", ":", "bbox", ",", "\"difficult\"", ":", "difficult", ",", "\"det\"", ":", "det", "}", "\n", "\n", "", "if", "classname", "==", "'unknown'", ":", "\n", "        ", "return", "rec", ",", "prec", ",", "ap", ",", "0", ",", "n_unk", ",", "None", ",", "None", "\n", "\n", "# Go down each detection and see if it has an overlap with an unknown object.", "\n", "# If so, it is an unknown object that was classified as known.", "\n", "", "is_unk", "=", "np", ".", "zeros", "(", "nd", ")", "\n", "for", "d", "in", "range", "(", "nd", ")", ":", "\n", "        ", "R", "=", "unknown_class_recs", "[", "image_ids", "[", "d", "]", "]", "\n", "bb", "=", "BB", "[", "d", ",", ":", "]", ".", "astype", "(", "float", ")", "\n", "ovmax", "=", "-", "np", ".", "inf", "\n", "BBGT", "=", "R", "[", "\"bbox\"", "]", ".", "astype", "(", "float", ")", "\n", "\n", "if", "BBGT", ".", "size", ">", "0", ":", "\n", "# compute overlaps", "\n", "# intersection", "\n", "            ", "ixmin", "=", "np", ".", "maximum", "(", "BBGT", "[", ":", ",", "0", "]", ",", "bb", "[", "0", "]", ")", "\n", "iymin", "=", "np", ".", "maximum", "(", "BBGT", "[", ":", ",", "1", "]", ",", "bb", "[", "1", "]", ")", "\n", "ixmax", "=", "np", ".", "minimum", "(", "BBGT", "[", ":", ",", "2", "]", ",", "bb", "[", "2", "]", ")", "\n", "iymax", "=", "np", ".", "minimum", "(", "BBGT", "[", ":", ",", "3", "]", ",", "bb", "[", "3", "]", ")", "\n", "iw", "=", "np", ".", "maximum", "(", "ixmax", "-", "ixmin", "+", "1.0", ",", "0.0", ")", "\n", "ih", "=", "np", ".", "maximum", "(", "iymax", "-", "iymin", "+", "1.0", ",", "0.0", ")", "\n", "inters", "=", "iw", "*", "ih", "\n", "\n", "# union", "\n", "uni", "=", "(", "\n", "(", "bb", "[", "2", "]", "-", "bb", "[", "0", "]", "+", "1.0", ")", "*", "(", "bb", "[", "3", "]", "-", "bb", "[", "1", "]", "+", "1.0", ")", "\n", "+", "(", "BBGT", "[", ":", ",", "2", "]", "-", "BBGT", "[", ":", ",", "0", "]", "+", "1.0", ")", "*", "(", "BBGT", "[", ":", ",", "3", "]", "-", "BBGT", "[", ":", ",", "1", "]", "+", "1.0", ")", "\n", "-", "inters", "\n", ")", "\n", "\n", "overlaps", "=", "inters", "/", "uni", "\n", "ovmax", "=", "np", ".", "max", "(", "overlaps", ")", "\n", "jmax", "=", "np", ".", "argmax", "(", "overlaps", ")", "\n", "\n", "", "if", "ovmax", ">", "ovthresh", ":", "\n", "            ", "is_unk", "[", "d", "]", "=", "1.0", "\n", "\n", "", "", "is_unk_sum", "=", "np", ".", "sum", "(", "is_unk", ")", "\n", "# OSE = is_unk / n_unk", "\n", "# logger.info('Number of unknowns detected knowns (for class '+ classname + ') is ' + str(is_unk))", "\n", "# logger.info(\"Num of unknown instances: \" + str(n_unk))", "\n", "# logger.info('OSE: ' + str(OSE))", "\n", "\n", "tp_plus_fp_closed_set", "=", "tp", "+", "fp", "\n", "fp_open_set", "=", "np", ".", "cumsum", "(", "is_unk", ")", "\n", "\n", "return", "rec", ",", "prec", ",", "ap", ",", "is_unk_sum", ",", "n_unk", ",", "tp_plus_fp_closed_set", ",", "fp_open_set", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.pascal_voc_evaluation.plot_pr_curve": [[595, 604], ["matplotlib.subplots", "ax.step", "ax.fill_between", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.xlim", "matplotlib.savefig"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step"], ["", "def", "plot_pr_curve", "(", "precision", ",", "recall", ",", "filename", ",", "base_path", "=", "'/home/fk1/workspace/OWOD/output/plots/'", ")", ":", "\n", "    ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "step", "(", "recall", ",", "precision", ",", "color", "=", "'r'", ",", "alpha", "=", "0.99", ",", "where", "=", "'post'", ")", "\n", "ax", ".", "fill_between", "(", "recall", ",", "precision", ",", "alpha", "=", "0.2", ",", "color", "=", "'b'", ",", "step", "=", "'post'", ")", "\n", "plt", ".", "xlabel", "(", "'Recall'", ")", "\n", "plt", ".", "ylabel", "(", "'Precision'", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "savefig", "(", "base_path", "+", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.print_csv_format": [[10, 26], ["isinstance", "logging.getLogger", "results.items", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "res.items"], "function", ["None"], ["def", "print_csv_format", "(", "results", ")", ":", "\n", "    ", "\"\"\"\n    Print main metrics in a format similar to Detectron,\n    so that they are easy to copypaste into a spreadsheet.\n\n    Args:\n        results (OrderedDict[dict]): task_name -> {metric -> score}\n    \"\"\"", "\n", "assert", "isinstance", "(", "results", ",", "OrderedDict", ")", ",", "results", "# unordered results cannot be properly printed", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "for", "task", ",", "res", "in", "results", ".", "items", "(", ")", ":", "\n", "# Don't print \"AP-category\" metrics since they are usually not tracked.", "\n", "        ", "important_res", "=", "[", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "if", "\"-\"", "not", "in", "k", "]", "\n", "logger", ".", "info", "(", "\"copypaste: Task: {}\"", ".", "format", "(", "task", ")", ")", "\n", "logger", ".", "info", "(", "\"copypaste: \"", "+", "\",\"", ".", "join", "(", "[", "k", "[", "0", "]", "for", "k", "in", "important_res", "]", ")", ")", "\n", "logger", ".", "info", "(", "\"copypaste: \"", "+", "\",\"", ".", "join", "(", "[", "\"{0:.4f}\"", ".", "format", "(", "k", "[", "1", "]", ")", "for", "k", "in", "important_res", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.verify_results": [[28, 59], ["logging.getLogger", "len", "abs", "logging.getLogger.error", "logging.getLogger.error", "logging.getLogger.error", "sys.exit", "logging.getLogger.info", "numpy.isfinite", "str", "pprint.pformat"], "function", ["None"], ["", "", "def", "verify_results", "(", "cfg", ",", "results", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        results (OrderedDict[dict]): task_name -> {metric -> score}\n\n    Returns:\n        bool: whether the verification succeeds or not\n    \"\"\"", "\n", "expected_results", "=", "cfg", ".", "TEST", ".", "EXPECTED_RESULTS", "\n", "if", "not", "len", "(", "expected_results", ")", ":", "\n", "        ", "return", "True", "\n", "\n", "", "ok", "=", "True", "\n", "for", "task", ",", "metric", ",", "expected", ",", "tolerance", "in", "expected_results", ":", "\n", "        ", "actual", "=", "results", "[", "task", "]", "[", "metric", "]", "\n", "if", "not", "np", ".", "isfinite", "(", "actual", ")", ":", "\n", "            ", "ok", "=", "False", "\n", "", "diff", "=", "abs", "(", "actual", "-", "expected", ")", "\n", "if", "diff", ">", "tolerance", ":", "\n", "            ", "ok", "=", "False", "\n", "\n", "", "", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "if", "not", "ok", ":", "\n", "        ", "logger", ".", "error", "(", "\"Result verification failed!\"", ")", "\n", "logger", ".", "error", "(", "\"Expected Results: \"", "+", "str", "(", "expected_results", ")", ")", "\n", "logger", ".", "error", "(", "\"Actual Results: \"", "+", "pprint", ".", "pformat", "(", "results", ")", ")", "\n", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\"Results verification passed.\"", ")", "\n", "", "return", "ok", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.flatten_results_dict": [[61, 79], ["results.items", "isinstance", "testing.flatten_results_dict", "flatten_results_dict.items"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.flatten_results_dict"], ["", "def", "flatten_results_dict", "(", "results", ")", ":", "\n", "    ", "\"\"\"\n    Expand a hierarchical dict of scalars into a flat dict of scalars.\n    If results[k1][k2][k3] = v, the returned dict will have the entry\n    {\"k1/k2/k3\": v}.\n\n    Args:\n        results (dict):\n    \"\"\"", "\n", "r", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "results", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "v", ",", "Mapping", ")", ":", "\n", "            ", "v", "=", "flatten_results_dict", "(", "v", ")", "\n", "for", "kk", ",", "vv", "in", "v", ".", "items", "(", ")", ":", "\n", "                ", "r", "[", "k", "+", "\"/\"", "+", "kk", "]", "=", "vv", "\n", "", "", "else", ":", "\n", "            ", "r", "[", "k", "]", "=", "v", "\n", "", "", "return", "r", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.DatasetEvaluator.reset": [[24, 30], ["None"], "methods", ["None"], ["def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Preparation for a new round of evaluation.\n        Should be called before starting a round of evaluation.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.DatasetEvaluator.process": [[31, 47], ["None"], "methods", ["None"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Process the pair of inputs and outputs.\n        If they contain batches, the pairs can be consumed one-by-one using `zip`:\n\n        .. code-block:: python\n\n            for input_, output in zip(inputs, outputs):\n                # do evaluation on single input/output pair\n                ...\n\n        Args:\n            inputs (list): the inputs that's used to call the model.\n            outputs (list): the return value of `model(inputs)`\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.DatasetEvaluator.evaluate": [[48, 62], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate/summarize the performance, after processing all input/output pairs.\n\n        Returns:\n            dict:\n                A new evaluator class can return a dict of arbitrary format\n                as long as the user can process the results.\n                In our train_net.py, we expect the following format:\n\n                * key: the name of the task (e.g., bbox)\n                * value: a dict of {metric name: score}, e.g.: {\"AP50\": 80}\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.DatasetEvaluators.__init__": [[72, 79], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "evaluators", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            evaluators (list): the evaluators to combine.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_evaluators", "=", "evaluators", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.DatasetEvaluators.reset": [[80, 83], ["evaluator.reset"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.reset"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "evaluator", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.DatasetEvaluators.process": [[84, 87], ["evaluator.process"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.process"], ["", "", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.DatasetEvaluators.evaluate": [[88, 99], ["collections.OrderedDict", "evaluator.evaluate", "detectron2.utils.comm.is_main_process", "evaluator.evaluate.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "results", "=", "OrderedDict", "(", ")", "\n", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "result", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "if", "is_main_process", "(", ")", "and", "result", "is", "not", "None", ":", "\n", "                ", "for", "k", ",", "v", "in", "result", ".", "items", "(", ")", ":", "\n", "                    ", "assert", "(", "\n", "k", "not", "in", "results", "\n", ")", ",", "\"Different evaluators produce results with the same key {}\"", ".", "format", "(", "k", ")", "\n", "results", "[", "k", "]", "=", "v", "\n", "", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.inference_on_dataset": [[101, 182], ["detectron2.utils.comm.get_world_size", "logging.getLogger", "logging.getLogger.info", "len", "evaluator.DatasetEvaluators.reset", "min", "time.perf_counter", "str", "logging.getLogger.info", "str", "logging.getLogger.info", "evaluator.DatasetEvaluators.evaluate", "evaluator.DatasetEvaluators", "evaluator.inference_context", "torch.no_grad", "enumerate", "time.perf_counter", "datetime.timedelta", "datetime.timedelta", "len", "time.perf_counter", "model", "torch.cuda.is_available", "evaluator.DatasetEvaluators.process", "time.perf_counter", "torch.cuda.synchronize", "time.perf_counter", "datetime.timedelta", "detectron2.utils.logger.log_every_n_seconds", "int", "int", "time.perf_counter", "int", "str"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_world_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.reset", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.inference_context", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.log_every_n_seconds"], ["", "", "def", "inference_on_dataset", "(", "model", ",", "data_loader", ",", "evaluator", ")", ":", "\n", "    ", "\"\"\"\n    Run model on the data_loader and evaluate the metrics with evaluator.\n    Also benchmark the inference speed of `model.forward` accurately.\n    The model will be used in eval mode.\n\n    Args:\n        model (nn.Module): a module which accepts an object from\n            `data_loader` and returns some outputs. It will be temporarily set to `eval` mode.\n\n            If you wish to evaluate a model in `training` mode instead, you can\n            wrap the given model and override its behavior of `.eval()` and `.train()`.\n        data_loader: an iterable object with a length.\n            The elements it generates will be the inputs to the model.\n        evaluator (DatasetEvaluator): the evaluator to run. Use `None` if you only want\n            to benchmark, but don't want to do any evaluation.\n\n    Returns:\n        The return value of `evaluator.evaluate()`\n    \"\"\"", "\n", "num_devices", "=", "get_world_size", "(", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Start inference on {} images\"", ".", "format", "(", "len", "(", "data_loader", ")", ")", ")", "\n", "\n", "total", "=", "len", "(", "data_loader", ")", "# inference data loader must have a fixed length", "\n", "if", "evaluator", "is", "None", ":", "\n", "# create a no-op evaluator", "\n", "        ", "evaluator", "=", "DatasetEvaluators", "(", "[", "]", ")", "\n", "", "evaluator", ".", "reset", "(", ")", "\n", "\n", "num_warmup", "=", "min", "(", "5", ",", "total", "-", "1", ")", "\n", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "total_compute_time", "=", "0", "\n", "with", "inference_context", "(", "model", ")", ",", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "idx", ",", "inputs", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "            ", "if", "idx", "==", "num_warmup", ":", "\n", "                ", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "total_compute_time", "=", "0", "\n", "\n", "", "start_compute_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "total_compute_time", "+=", "time", ".", "perf_counter", "(", ")", "-", "start_compute_time", "\n", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n", "iters_after_start", "=", "idx", "+", "1", "-", "num_warmup", "*", "int", "(", "idx", ">=", "num_warmup", ")", "\n", "seconds_per_img", "=", "total_compute_time", "/", "iters_after_start", "\n", "if", "idx", ">=", "num_warmup", "*", "2", "or", "seconds_per_img", ">", "5", ":", "\n", "                ", "total_seconds_per_img", "=", "(", "time", ".", "perf_counter", "(", ")", "-", "start_time", ")", "/", "iters_after_start", "\n", "eta", "=", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_seconds_per_img", "*", "(", "total", "-", "idx", "-", "1", ")", ")", ")", "\n", "log_every_n_seconds", "(", "\n", "logging", ".", "INFO", ",", "\n", "\"Inference done {}/{}. {:.4f} s / img. ETA={}\"", ".", "format", "(", "\n", "idx", "+", "1", ",", "total", ",", "seconds_per_img", ",", "str", "(", "eta", ")", "\n", ")", ",", "\n", "n", "=", "5", ",", "\n", ")", "\n", "\n", "# Measure the time only for this worker (before the synchronization barrier)", "\n", "", "", "", "total_time", "=", "time", ".", "perf_counter", "(", ")", "-", "start_time", "\n", "total_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "total_time", ")", ")", "\n", "# NOTE this format is parsed by grep", "\n", "logger", ".", "info", "(", "\n", "\"Total inference time: {} ({:.6f} s / img per device, on {} devices)\"", ".", "format", "(", "\n", "total_time_str", ",", "total_time", "/", "(", "total", "-", "num_warmup", ")", ",", "num_devices", "\n", ")", "\n", ")", "\n", "total_compute_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_compute_time", ")", ")", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total inference pure compute time: {} ({:.6f} s / img per device, on {} devices)\"", ".", "format", "(", "\n", "total_compute_time_str", ",", "total_compute_time", "/", "(", "total", "-", "num_warmup", ")", ",", "num_devices", "\n", ")", "\n", ")", "\n", "\n", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "# An evaluator may return None when not in main process.", "\n", "# Replace it by an empty dict instead to make it easier for downstream code to handle", "\n", "if", "results", "is", "None", ":", "\n", "        ", "results", "=", "{", "}", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.evaluator.inference_context": [[184, 197], ["model.eval", "model.train"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train"], ["", "@", "contextmanager", "\n", "def", "inference_context", "(", "model", ")", ":", "\n", "    ", "\"\"\"\n    A context where the model is temporarily changed to eval mode,\n    and restored to previous mode afterwards.\n\n    Args:\n        model: a torch Module\n    \"\"\"", "\n", "training_mode", "=", "model", ".", "training", "\n", "model", ".", "eval", "(", ")", "\n", "yield", "\n", "model", ".", "train", "(", "training_mode", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOeval.is_rotated": [[16, 32], ["type", "type", "numpy.all", "numpy.array", "len", "type", "type"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "is_rotated", "(", "box_list", ")", ":", "\n", "        ", "if", "type", "(", "box_list", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "return", "box_list", ".", "shape", "[", "1", "]", "==", "5", "\n", "", "elif", "type", "(", "box_list", ")", "==", "list", ":", "\n", "            ", "if", "box_list", "==", "[", "]", ":", "# cannot decide the box_dim", "\n", "                ", "return", "False", "\n", "", "return", "np", ".", "all", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "(", "len", "(", "obj", ")", "==", "5", ")", "and", "(", "(", "type", "(", "obj", ")", "==", "list", ")", "or", "(", "type", "(", "obj", ")", "==", "np", ".", "ndarray", ")", ")", "\n", "for", "obj", "in", "box_list", "\n", "]", "\n", ")", "\n", ")", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor": [[33, 56], ["type", "torch.from_numpy", "type", "Exception", "detectron2.structures.BoxMode.convert", "Exception", "torch.zeros", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "@", "staticmethod", "\n", "def", "boxlist_to_tensor", "(", "boxlist", ",", "output_box_dim", ")", ":", "\n", "        ", "if", "type", "(", "boxlist", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "box_tensor", "=", "torch", ".", "from_numpy", "(", "boxlist", ")", "\n", "", "elif", "type", "(", "boxlist", ")", "==", "list", ":", "\n", "            ", "if", "boxlist", "==", "[", "]", ":", "\n", "                ", "return", "torch", ".", "zeros", "(", "(", "0", ",", "output_box_dim", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "else", ":", "\n", "                ", "box_tensor", "=", "torch", ".", "FloatTensor", "(", "boxlist", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Unrecognized boxlist type\"", ")", "\n", "\n", "", "input_box_dim", "=", "box_tensor", ".", "shape", "[", "1", "]", "\n", "if", "input_box_dim", "!=", "output_box_dim", ":", "\n", "            ", "if", "input_box_dim", "==", "4", "and", "output_box_dim", "==", "5", ":", "\n", "                ", "box_tensor", "=", "BoxMode", ".", "convert", "(", "box_tensor", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYWHA_ABS", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"Unable to convert from {}-dim box to {}-dim box\"", ".", "format", "(", "\n", "input_box_dim", ",", "output_box_dim", "\n", ")", "\n", ")", "\n", "", "", "return", "box_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOeval.compute_iou_dt_gt": [[57, 67], ["rotated_coco_evaluation.RotatedCOCOeval.is_rotated", "rotated_coco_evaluation.RotatedCOCOeval.is_rotated", "all", "detectron2.structures.RotatedBoxes", "detectron2.structures.RotatedBoxes", "detectron2.structures.pairwise_iou_rotated", "pycocotools.cocoeval.maskUtils.iou", "rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor", "rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOeval.is_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOeval.is_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.rotated_boxes.pairwise_iou_rotated", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOeval.boxlist_to_tensor"], ["", "def", "compute_iou_dt_gt", "(", "self", ",", "dt", ",", "gt", ",", "is_crowd", ")", ":", "\n", "        ", "if", "self", ".", "is_rotated", "(", "dt", ")", "or", "self", ".", "is_rotated", "(", "gt", ")", ":", "\n", "# TODO: take is_crowd into consideration", "\n", "            ", "assert", "all", "(", "c", "==", "0", "for", "c", "in", "is_crowd", ")", "\n", "dt", "=", "RotatedBoxes", "(", "self", ".", "boxlist_to_tensor", "(", "dt", ",", "output_box_dim", "=", "5", ")", ")", "\n", "gt", "=", "RotatedBoxes", "(", "self", ".", "boxlist_to_tensor", "(", "gt", ",", "output_box_dim", "=", "5", ")", ")", "\n", "return", "pairwise_iou_rotated", "(", "dt", ",", "gt", ")", "\n", "", "else", ":", "\n", "# This is the same as the classical COCO evaluation", "\n", "            ", "return", "maskUtils", ".", "iou", "(", "dt", ",", "gt", ",", "is_crowd", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOeval.computeIoU": [[68, 95], ["numpy.argsort", "rotated_coco_evaluation.RotatedCOCOeval.compute_iou_dt_gt", "len", "int", "len", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOeval.compute_iou_dt_gt"], ["", "", "def", "computeIoU", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dt", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dt", "=", "dt", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "\n", "", "assert", "p", ".", "iouType", "==", "\"bbox\"", ",", "\"unsupported iouType for iou computation\"", "\n", "\n", "g", "=", "[", "g", "[", "\"bbox\"", "]", "for", "g", "in", "gt", "]", "\n", "d", "=", "[", "d", "[", "\"bbox\"", "]", "for", "d", "in", "dt", "]", "\n", "\n", "# compute iou between each dt and gt region", "\n", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "gt", "]", "\n", "\n", "# Note: this function is copied from cocoeval.py in cocoapi", "\n", "# and the major difference is here.", "\n", "ious", "=", "self", ".", "compute_iou_dt_gt", "(", "d", ",", "g", ",", "iscrowd", ")", "\n", "return", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator.process": [[104, 123], ["zip", "rotated_coco_evaluation.RotatedCOCOEvaluator._predictions.append", "output[].to", "rotated_coco_evaluation.RotatedCOCOEvaluator.instances_to_json", "output[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator.instances_to_json", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a COCO model (e.g., GeneralizedRCNN).\n                It is a list of dict. Each dict corresponds to an image and\n                contains keys like \"height\", \"width\", \"file_name\", \"image_id\".\n            outputs: the outputs of a COCO model. It is a list of dicts with key\n                \"instances\" that contains :class:`Instances`.\n        \"\"\"", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "prediction", "=", "{", "\"image_id\"", ":", "input", "[", "\"image_id\"", "]", "}", "\n", "\n", "if", "\"instances\"", "in", "output", ":", "\n", "                ", "instances", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "\n", "prediction", "[", "\"instances\"", "]", "=", "self", ".", "instances_to_json", "(", "instances", ",", "input", "[", "\"image_id\"", "]", ")", "\n", "", "if", "\"proposals\"", "in", "output", ":", "\n", "                ", "prediction", "[", "\"proposals\"", "]", "=", "output", "[", "\"proposals\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "", "self", ".", "_predictions", ".", "append", "(", "prediction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator.instances_to_json": [[124, 147], ["len", "instances.pred_boxes.tensor.numpy", "detectron2.structures.BoxMode.convert.tolist", "instances.scores.tolist", "instances.pred_classes.tolist", "range", "detectron2.structures.BoxMode.convert", "results.append"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "", "def", "instances_to_json", "(", "self", ",", "instances", ",", "img_id", ")", ":", "\n", "        ", "num_instance", "=", "len", "(", "instances", ")", "\n", "if", "num_instance", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "boxes", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "\n", "if", "boxes", ".", "shape", "[", "1", "]", "==", "4", ":", "\n", "            ", "boxes", "=", "BoxMode", ".", "convert", "(", "boxes", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "", "boxes", "=", "boxes", ".", "tolist", "(", ")", "\n", "scores", "=", "instances", ".", "scores", ".", "tolist", "(", ")", "\n", "classes", "=", "instances", ".", "pred_classes", ".", "tolist", "(", ")", "\n", "\n", "results", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "num_instance", ")", ":", "\n", "            ", "result", "=", "{", "\n", "\"image_id\"", ":", "img_id", ",", "\n", "\"category_id\"", ":", "classes", "[", "k", "]", ",", "\n", "\"bbox\"", ":", "boxes", "[", "k", "]", ",", "\n", "\"score\"", ":", "scores", "[", "k", "]", ",", "\n", "}", "\n", "\n", "results", ".", "append", "(", "result", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator._eval_predictions": [[148, 188], ["rotated_coco_evaluation.RotatedCOCOEvaluator._logger.info", "list", "hasattr", "rotated_coco_evaluation.RotatedCOCOEvaluator._logger.info", "sorted", "itertools.chain", "os.path.join", "rotated_coco_evaluation.RotatedCOCOEvaluator._logger.info", "rotated_coco_evaluation.RotatedCOCOEvaluator._logger.info", "rotated_coco_evaluation.RotatedCOCOEvaluator._derive_coco_results", "fvcore.common.file_io.PathManager.open", "f.write", "f.flush", "rotated_coco_evaluation.RotatedCOCOEvaluator._evaluate_predictions_on_coco", "rotated_coco_evaluation.RotatedCOCOEvaluator._metadata.thing_dataset_id_to_contiguous_id.items", "json.dumps", "len", "rotated_coco_evaluation.RotatedCOCOEvaluator._metadata.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.coco_evaluation.COCOEvaluator._derive_coco_results", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "_eval_predictions", "(", "self", ",", "tasks", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate predictions on the given tasks.\n        Fill self._results with the metrics of the tasks.\n        \"\"\"", "\n", "self", ".", "_logger", ".", "info", "(", "\"Preparing results for COCO format ...\"", ")", "\n", "coco_results", "=", "list", "(", "itertools", ".", "chain", "(", "*", "[", "x", "[", "\"instances\"", "]", "for", "x", "in", "predictions", "]", ")", ")", "\n", "\n", "# unmap the category ids for COCO", "\n", "if", "hasattr", "(", "self", ".", "_metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n", "            ", "reverse_id_mapping", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "for", "result", "in", "coco_results", ":", "\n", "                ", "result", "[", "\"category_id\"", "]", "=", "reverse_id_mapping", "[", "result", "[", "\"category_id\"", "]", "]", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"coco_instances_results.json\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Saving results to {}\"", ".", "format", "(", "file_path", ")", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "coco_results", ")", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating predictions ...\"", ")", "\n", "for", "task", "in", "sorted", "(", "tasks", ")", ":", "\n", "            ", "assert", "task", "==", "\"bbox\"", ",", "\"Task {} is not supported\"", ".", "format", "(", "task", ")", "\n", "coco_eval", "=", "(", "\n", "self", ".", "_evaluate_predictions_on_coco", "(", "self", ".", "_coco_api", ",", "coco_results", ")", "\n", "if", "len", "(", "coco_results", ")", ">", "0", "\n", "else", "None", "# cocoapi does not handle empty results very well", "\n", ")", "\n", "\n", "res", "=", "self", ".", "_derive_coco_results", "(", "\n", "coco_eval", ",", "task", ",", "class_names", "=", "self", ".", "_metadata", ".", "get", "(", "\"thing_classes\"", ")", "\n", ")", "\n", "self", ".", "_results", "[", "task", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.rotated_coco_evaluation.RotatedCOCOEvaluator._evaluate_predictions_on_coco": [[189, 205], ["coco_gt.loadRes", "rotated_coco_evaluation.RotatedCOCOeval", "RotatedCOCOeval.evaluate", "RotatedCOCOeval.accumulate", "RotatedCOCOeval.summarize", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], ["", "", "def", "_evaluate_predictions_on_coco", "(", "self", ",", "coco_gt", ",", "coco_results", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate the coco results using COCOEval API.\n        \"\"\"", "\n", "assert", "len", "(", "coco_results", ")", ">", "0", "\n", "\n", "coco_dt", "=", "coco_gt", ".", "loadRes", "(", "coco_results", ")", "\n", "\n", "# Only bbox is supported for now", "\n", "coco_eval", "=", "RotatedCOCOeval", "(", "coco_gt", ",", "coco_dt", ",", "iouType", "=", "\"bbox\"", ")", "\n", "\n", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "coco_eval", ".", "summarize", "(", ")", "\n", "\n", "return", "coco_eval", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.cityscapes_evaluation.CityscapesEvaluator.__init__": [[23, 33], ["detectron2.data.MetadataCatalog.get", "torch.device", "logging.getLogger"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["def", "__init__", "(", "self", ",", "dataset_name", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): the name of the dataset.\n                It must have the following metadata associated with it:\n                \"thing_classes\", \"gt_dir\".\n        \"\"\"", "\n", "self", ".", "_metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.cityscapes_evaluation.CityscapesEvaluator.reset": [[34, 44], ["tempfile.TemporaryDirectory", "cityscapes_evaluation.CityscapesEvaluator._logger.info", "detectron2.utils.comm.all_gather", "cityscapes_evaluation.CityscapesEvaluator._working_dir.cleanup"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_working_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"cityscapes_eval_\"", ")", "\n", "self", ".", "_temp_dir", "=", "self", ".", "_working_dir", ".", "name", "\n", "# All workers will write to the same results directory", "\n", "# TODO this does not work in distributed training", "\n", "self", ".", "_temp_dir", "=", "comm", ".", "all_gather", "(", "self", ".", "_temp_dir", ")", "[", "0", "]", "\n", "if", "self", ".", "_temp_dir", "!=", "self", ".", "_working_dir", ".", "name", ":", "\n", "            ", "self", ".", "_working_dir", ".", "cleanup", "(", ")", "\n", "", "self", ".", "_logger", ".", "info", "(", "\n", "\"Writing cityscapes results to temporary directory {} ...\"", ".", "format", "(", "self", ".", "_temp_dir", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.cityscapes_evaluation.CityscapesInstanceEvaluator.process": [[57, 87], ["zip", "os.path.join", "os.path.splitext", "output[].to", "len", "os.path.basename", "open", "range", "open", "output[].to.pred_masks[].numpy().astype", "os.path.join", "PIL.Image.fromarray().save", "fout.write", "output[].to.pred_masks[].numpy", "PIL.Image.fromarray", "os.path.basename"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write"], ["def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "from", "cityscapesscripts", ".", "helpers", ".", "labels", "import", "name2label", "\n", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "file_name", "=", "input", "[", "\"file_name\"", "]", "\n", "basename", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "file_name", ")", ")", "[", "0", "]", "\n", "pred_txt", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_temp_dir", ",", "basename", "+", "\"_pred.txt\"", ")", "\n", "\n", "if", "\"instances\"", "in", "output", ":", "\n", "                ", "output", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "num_instances", "=", "len", "(", "output", ")", "\n", "with", "open", "(", "pred_txt", ",", "\"w\"", ")", "as", "fout", ":", "\n", "                    ", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "                        ", "pred_class", "=", "output", ".", "pred_classes", "[", "i", "]", "\n", "classes", "=", "self", ".", "_metadata", ".", "thing_classes", "[", "pred_class", "]", "\n", "class_id", "=", "name2label", "[", "classes", "]", ".", "id", "\n", "score", "=", "output", ".", "scores", "[", "i", "]", "\n", "mask", "=", "output", ".", "pred_masks", "[", "i", "]", ".", "numpy", "(", ")", ".", "astype", "(", "\"uint8\"", ")", "\n", "png_filename", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "_temp_dir", ",", "basename", "+", "\"_{}_{}.png\"", ".", "format", "(", "i", ",", "classes", ")", "\n", ")", "\n", "\n", "Image", ".", "fromarray", "(", "mask", "*", "255", ")", ".", "save", "(", "png_filename", ")", "\n", "fout", ".", "write", "(", "\n", "\"{} {} {}\\n\"", ".", "format", "(", "os", ".", "path", ".", "basename", "(", "png_filename", ")", ",", "class_id", ",", "score", ")", "\n", ")", "\n", "", "", "", "else", ":", "\n", "# Cityscapes requires a prediction file for every ground truth image.", "\n", "                ", "with", "open", "(", "pred_txt", ",", "\"w\"", ")", "as", "fout", ":", "\n", "                    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.cityscapes_evaluation.CityscapesInstanceEvaluator.evaluate": [[88, 127], ["detectron2.utils.comm.synchronize", "cityscapes_evaluation.CityscapesInstanceEvaluator._logger.info", "os.path.abspath", "os.path.join", "fvcore.common.file_io.PathManager.get_local_path", "glob.glob", "len", "collections.OrderedDict", "cityscapes_evaluation.CityscapesInstanceEvaluator._working_dir.cleanup", "detectron2.utils.comm.get_rank", "os.path.join", "predictionImgList.append", "cityscapes_eval.evaluateImgLists", "cityscapes_eval.getPrediction"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["", "", "", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict: has a key \"segm\", whose value is a dict of \"AP\" and \"AP50\".\n        \"\"\"", "\n", "comm", ".", "synchronize", "(", ")", "\n", "if", "comm", ".", "get_rank", "(", ")", ">", "0", ":", "\n", "            ", "return", "\n", "", "import", "cityscapesscripts", ".", "evaluation", ".", "evalInstanceLevelSemanticLabeling", "as", "cityscapes_eval", "\n", "\n", "self", ".", "_logger", ".", "info", "(", "\"Evaluating results under {} ...\"", ".", "format", "(", "self", ".", "_temp_dir", ")", ")", "\n", "\n", "# set some global states in cityscapes evaluation API, before evaluating", "\n", "cityscapes_eval", ".", "args", ".", "predictionPath", "=", "os", ".", "path", ".", "abspath", "(", "self", ".", "_temp_dir", ")", "\n", "cityscapes_eval", ".", "args", ".", "predictionWalk", "=", "None", "\n", "cityscapes_eval", ".", "args", ".", "JSONOutput", "=", "False", "\n", "cityscapes_eval", ".", "args", ".", "colorized", "=", "False", "\n", "cityscapes_eval", ".", "args", ".", "gtInstancesFile", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_temp_dir", ",", "\"gtInstances.json\"", ")", "\n", "\n", "# These lines are adopted from", "\n", "# https://github.com/mcordts/cityscapesScripts/blob/master/cityscapesscripts/evaluation/evalInstanceLevelSemanticLabeling.py # noqa", "\n", "gt_dir", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "gt_dir", ")", "\n", "groundTruthImgList", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "\"*\"", ",", "\"*_gtFine_instanceIds.png\"", ")", ")", "\n", "assert", "len", "(", "\n", "groundTruthImgList", "\n", ")", ",", "\"Cannot find any ground truth images to use for evaluation. Searched for: {}\"", ".", "format", "(", "\n", "cityscapes_eval", ".", "args", ".", "groundTruthSearch", "\n", ")", "\n", "predictionImgList", "=", "[", "]", "\n", "for", "gt", "in", "groundTruthImgList", ":", "\n", "            ", "predictionImgList", ".", "append", "(", "cityscapes_eval", ".", "getPrediction", "(", "gt", ",", "cityscapes_eval", ".", "args", ")", ")", "\n", "", "results", "=", "cityscapes_eval", ".", "evaluateImgLists", "(", "\n", "predictionImgList", ",", "groundTruthImgList", ",", "cityscapes_eval", ".", "args", "\n", ")", "[", "\"averages\"", "]", "\n", "\n", "ret", "=", "OrderedDict", "(", ")", "\n", "ret", "[", "\"segm\"", "]", "=", "{", "\"AP\"", ":", "results", "[", "\"allAp\"", "]", "*", "100", ",", "\"AP50\"", ":", "results", "[", "\"allAp50%\"", "]", "*", "100", "}", "\n", "self", ".", "_working_dir", ".", "cleanup", "(", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.cityscapes_evaluation.CityscapesSemSegEvaluator.process": [[139, 154], ["zip", "os.path.join", "output[].argmax().to().numpy", "trainId2label.items", "PIL.Image.fromarray().save", "os.path.splitext", "numpy.ones", "os.path.basename", "output[].argmax().to", "PIL.Image.fromarray", "output[].argmax"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "from", "cityscapesscripts", ".", "helpers", ".", "labels", "import", "trainId2label", "\n", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "file_name", "=", "input", "[", "\"file_name\"", "]", "\n", "basename", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "file_name", ")", ")", "[", "0", "]", "\n", "pred_filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_temp_dir", ",", "basename", "+", "\"_pred.png\"", ")", "\n", "\n", "output", "=", "output", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "_cpu_device", ")", ".", "numpy", "(", ")", "\n", "pred", "=", "255", "*", "np", ".", "ones", "(", "output", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "train_id", ",", "label", "in", "trainId2label", ".", "items", "(", ")", ":", "\n", "                ", "if", "label", ".", "ignoreInEval", ":", "\n", "                    ", "continue", "\n", "", "pred", "[", "output", "==", "train_id", "]", "=", "label", ".", "id", "\n", "", "Image", ".", "fromarray", "(", "pred", ")", ".", "save", "(", "pred_filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.cityscapes_evaluation.CityscapesSemSegEvaluator.evaluate": [[155, 195], ["detectron2.utils.comm.synchronize", "cityscapes_evaluation.CityscapesSemSegEvaluator._logger.info", "os.path.abspath", "fvcore.common.file_io.PathManager.get_local_path", "glob.glob", "len", "cityscapes_eval.evaluateImgLists", "collections.OrderedDict", "cityscapes_evaluation.CityscapesSemSegEvaluator._working_dir.cleanup", "detectron2.utils.comm.get_rank", "os.path.join", "predictionImgList.append", "cityscapes_eval.getPrediction"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "comm", ".", "synchronize", "(", ")", "\n", "if", "comm", ".", "get_rank", "(", ")", ">", "0", ":", "\n", "            ", "return", "\n", "# Load the Cityscapes eval script *after* setting the required env var,", "\n", "# since the script reads CITYSCAPES_DATASET into global variables at load time.", "\n", "", "import", "cityscapesscripts", ".", "evaluation", ".", "evalPixelLevelSemanticLabeling", "as", "cityscapes_eval", "\n", "\n", "self", ".", "_logger", ".", "info", "(", "\"Evaluating results under {} ...\"", ".", "format", "(", "self", ".", "_temp_dir", ")", ")", "\n", "\n", "# set some global states in cityscapes evaluation API, before evaluating", "\n", "cityscapes_eval", ".", "args", ".", "predictionPath", "=", "os", ".", "path", ".", "abspath", "(", "self", ".", "_temp_dir", ")", "\n", "cityscapes_eval", ".", "args", ".", "predictionWalk", "=", "None", "\n", "cityscapes_eval", ".", "args", ".", "JSONOutput", "=", "False", "\n", "cityscapes_eval", ".", "args", ".", "colorized", "=", "False", "\n", "\n", "# These lines are adopted from", "\n", "# https://github.com/mcordts/cityscapesScripts/blob/master/cityscapesscripts/evaluation/evalPixelLevelSemanticLabeling.py # noqa", "\n", "gt_dir", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "gt_dir", ")", "\n", "groundTruthImgList", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "gt_dir", ",", "\"*\"", ",", "\"*_gtFine_labelIds.png\"", ")", ")", "\n", "assert", "len", "(", "\n", "groundTruthImgList", "\n", ")", ",", "\"Cannot find any ground truth images to use for evaluation. Searched for: {}\"", ".", "format", "(", "\n", "cityscapes_eval", ".", "args", ".", "groundTruthSearch", "\n", ")", "\n", "predictionImgList", "=", "[", "]", "\n", "for", "gt", "in", "groundTruthImgList", ":", "\n", "            ", "predictionImgList", ".", "append", "(", "cityscapes_eval", ".", "getPrediction", "(", "cityscapes_eval", ".", "args", ",", "gt", ")", ")", "\n", "", "results", "=", "cityscapes_eval", ".", "evaluateImgLists", "(", "\n", "predictionImgList", ",", "groundTruthImgList", ",", "cityscapes_eval", ".", "args", "\n", ")", "\n", "ret", "=", "OrderedDict", "(", ")", "\n", "ret", "[", "\"sem_seg\"", "]", "=", "{", "\n", "\"IoU\"", ":", "100.0", "*", "results", "[", "\"averageScoreClasses\"", "]", ",", "\n", "\"iIoU\"", ":", "100.0", "*", "results", "[", "\"averageScoreInstClasses\"", "]", ",", "\n", "\"IoU_sup\"", ":", "100.0", "*", "results", "[", "\"averageScoreCategories\"", "]", ",", "\n", "\"iIoU_sup\"", ":", "100.0", "*", "results", "[", "\"averageScoreInstCategories\"", "]", ",", "\n", "}", "\n", "self", ".", "_working_dir", ".", "cleanup", "(", ")", "\n", "return", "ret", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build._create_gradient_clipper": [[19, 37], ["cfg.clone.clone", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_value_", "build.GradientClipType"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["\n", "meta_arch", "=", "cfg", ".", "MODEL", ".", "META_ARCHITECTURE", "\n", "model", "=", "META_ARCH_REGISTRY", ".", "get", "(", "meta_arch", ")", "(", "cfg", ")", "\n", "model", ".", "to", "(", "torch", ".", "device", "(", "cfg", ".", "MODEL", ".", "DEVICE", ")", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build._generate_optimizer_class_with_gradient_clipping": [[39, 59], ["type", "super().step", "gradient_clipper", "type"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build.maybe_add_gradient_clipping": [[61, 91], ["build._create_gradient_clipper", "build._generate_optimizer_class_with_gradient_clipping", "type"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build._create_gradient_clipper", "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build._generate_optimizer_class_with_gradient_clipping"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build.build_optimizer": [[93, 138], ["set", "model.modules", "torch.optim.SGD", "build.maybe_add_gradient_clipping", "module.named_parameters", "memo.add", "isinstance"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build.maybe_add_gradient_clipping", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.add"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build.build_lr_scheduler": [[140, 166], ["lr_scheduler.WarmupMultiStepLR", "lr_scheduler.WarmupCosineLR", "ValueError"], "function", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler.WarmupMultiStepLR.__init__": [[17, 37], ["super().__init__", "ValueError", "list", "sorted"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", ",", "\n", "milestones", ":", "List", "[", "int", "]", ",", "\n", "gamma", ":", "float", "=", "0.1", ",", "\n", "warmup_factor", ":", "float", "=", "0.001", ",", "\n", "warmup_iters", ":", "int", "=", "1000", ",", "\n", "warmup_method", ":", "str", "=", "\"linear\"", ",", "\n", "last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "if", "not", "list", "(", "milestones", ")", "==", "sorted", "(", "milestones", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Milestones should be a list of\"", "\" increasing integers. Got {}\"", ",", "milestones", "\n", ")", "\n", "", "self", ".", "milestones", "=", "milestones", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler.WarmupMultiStepLR.get_lr": [[38, 45], ["lr_scheduler._get_warmup_factor_at_iter", "bisect.bisect_right"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler._get_warmup_factor_at_iter"], ["", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "warmup_factor", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "self", ".", "last_epoch", ",", "self", ".", "warmup_iters", ",", "self", ".", "warmup_factor", "\n", ")", "\n", "return", "[", "\n", "base_lr", "*", "warmup_factor", "*", "self", ".", "gamma", "**", "bisect_right", "(", "self", ".", "milestones", ",", "self", ".", "last_epoch", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler.WarmupMultiStepLR._compute_values": [[47, 50], ["lr_scheduler.WarmupMultiStepLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.lr_scheduler.WarmupPolyLR.get_lr"], ["", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler.WarmupCosineLR.__init__": [[53, 67], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", ",", "\n", "max_iters", ":", "int", ",", "\n", "warmup_factor", ":", "float", "=", "0.001", ",", "\n", "warmup_iters", ":", "int", "=", "1000", ",", "\n", "warmup_method", ":", "str", "=", "\"linear\"", ",", "\n", "last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler.WarmupCosineLR.get_lr": [[68, 83], ["lr_scheduler._get_warmup_factor_at_iter", "math.cos"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler._get_warmup_factor_at_iter"], ["", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "warmup_factor", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "self", ".", "last_epoch", ",", "self", ".", "warmup_iters", ",", "self", ".", "warmup_factor", "\n", ")", "\n", "# Different definitions of half-cosine with warmup are possible. For", "\n", "# simplicity we multiply the standard half-cosine schedule by the warmup", "\n", "# factor. An alternative is to start the period of the cosine at warmup_iters", "\n", "# instead of at 0. In the case that warmup_iters << max_iters the two are", "\n", "# very close to each other.", "\n", "return", "[", "\n", "base_lr", "\n", "*", "warmup_factor", "\n", "*", "0.5", "\n", "*", "(", "1.0", "+", "math", ".", "cos", "(", "math", ".", "pi", "*", "self", ".", "last_epoch", "/", "self", ".", "max_iters", ")", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler.WarmupCosineLR._compute_values": [[85, 88], ["lr_scheduler.WarmupCosineLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.lr_scheduler.WarmupPolyLR.get_lr"], ["", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler._get_warmup_factor_at_iter": [[90, 117], ["ValueError"], "function", ["None"], ["", "", "def", "_get_warmup_factor_at_iter", "(", "\n", "method", ":", "str", ",", "iter", ":", "int", ",", "warmup_iters", ":", "int", ",", "warmup_factor", ":", "float", "\n", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Return the learning rate warmup factor at a specific iteration.\n    See :paper:`ImageNet in 1h` for more details.\n\n    Args:\n        method (str): warmup method; either \"constant\" or \"linear\".\n        iter (int): iteration at which to calculate the warmup factor.\n        warmup_iters (int): the number of warmup iterations.\n        warmup_factor (float): the base warmup factor (the meaning changes according\n            to the method used).\n\n    Returns:\n        float: the effective warmup factor at the given iteration.\n    \"\"\"", "\n", "if", "iter", ">=", "warmup_iters", ":", "\n", "        ", "return", "1.0", "\n", "\n", "", "if", "method", "==", "\"constant\"", ":", "\n", "        ", "return", "warmup_factor", "\n", "", "elif", "method", "==", "\"linear\"", ":", "\n", "        ", "alpha", "=", "iter", "/", "warmup_iters", "\n", "return", "warmup_factor", "*", "(", "1", "-", "alpha", ")", "+", "alpha", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown warmup method: {}\"", ".", "format", "(", "method", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.Trainer.build_evaluator": [[54, 90], ["detectron2.evaluation.DatasetEvaluators", "detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "detectron2.data.MetadataCatalog.get", "evaluator_list.append", "evaluator_list.append", "evaluator_list.append", "cfg.defrost", "cfg.freeze", "evaluator_list.append", "len", "NotImplementedError", "detectron2.evaluation.COCOPanopticEvaluator", "detectron2.evaluation.COCOPanopticEvaluator", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.get_rank", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.COCOEvaluator", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["\n", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluator_list", "=", "[", "]", "\n", "evaluator_type", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "evaluator_type", "\n", "if", "evaluator_type", "in", "[", "\"sem_seg\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "\n", "SemSegEvaluator", "(", "\n", "dataset_name", ",", "\n", "distributed", "=", "True", ",", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", ",", "\n", "ignore_label", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", ",", "\n", "output_dir", "=", "output_folder", ",", "\n", ")", "\n", ")", "\n", "", "if", "evaluator_type", "in", "[", "\"coco\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"coco_panoptic_seg\"", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOPanopticEvaluator", "(", "dataset_name", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_instance\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesInstanceEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_sem_seg\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesSemSegEvaluator", "(", "dataset_name", ")", "\n", "", "elif", "evaluator_type", "==", "\"pascal_voc\"", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ",", "cfg", ")", "\n", "", "elif", "evaluator_type", "==", "\"lvis\"", ":", "\n", "            ", "return", "LVISEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.Trainer.build_train_loader": [[91, 95], ["detectron2.projects.panoptic_deeplab.PanopticDeeplabDatasetMapper", "detectron2.projects.panoptic_deeplab.PanopticDeeplabDatasetMapper", "detectron2.data.build_detection_train_loader", "detectron2.data.build_detection_train_loader", "train_net.build_sem_seg_train_aug"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.build_sem_seg_train_aug"], ["", "if", "len", "(", "evaluator_list", ")", "==", "0", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"no Evaluator for the dataset {} with the type {}\"", ".", "format", "(", "\n", "dataset_name", ",", "evaluator_type", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.Trainer.build_lr_scheduler": [[96, 103], ["detectron2.projects.deeplab.build_lr_scheduler", "detectron2.projects.deeplab.build_lr_scheduler"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.build_solver.build_lr_scheduler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.build_solver.build_lr_scheduler"], [")", "\n", "", "elif", "len", "(", "evaluator_list", ")", "==", "1", ":", "\n", "            ", "return", "evaluator_list", "[", "0", "]", "\n", "", "return", "DatasetEvaluators", "(", "evaluator_list", ")", "\n", "\n", "", "@", "classmethod", "\n", "def", "test_with_TTA", "(", "cls", ",", "cfg", ",", "model", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "\"detectron2.trainer\"", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.Trainer.build_optimizer": [[104, 155], ["set", "model.modules", "detectron2.solver.build.maybe_add_gradient_clipping", "detectron2.solver.build.maybe_add_gradient_clipping", "module.named_parameters", "torch.optim.SGD", "memo.add", "isinstance", "torch.optim.Adam", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build.maybe_add_gradient_clipping", "home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.build.maybe_add_gradient_clipping", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.store.Store.add"], ["# In the end of training, run an evaluation with TTA", "\n", "# Only support some R-CNN models.", "\n", "logger", ".", "info", "(", "\"Running inference with test-time augmentation ...\"", ")", "\n", "model", "=", "GeneralizedRCNNWithTTA", "(", "cfg", ",", "model", ")", "\n", "evaluators", "=", "[", "\n", "cls", ".", "build_evaluator", "(", "\n", "cfg", ",", "name", ",", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference_TTA\"", ")", "\n", ")", "\n", "for", "name", "in", "cfg", ".", "DATASETS", ".", "TEST", "\n", "]", "\n", "res", "=", "cls", ".", "test", "(", "cfg", ",", "model", ",", "evaluators", ")", "\n", "res", "=", "OrderedDict", "(", "{", "k", "+", "\"_TTA\"", ":", "v", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "}", ")", "\n", "return", "res", "\n", "\n", "\n", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n", "\n", "", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", "\n", ")", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ")", "\n", "if", "cfg", ".", "TEST", ".", "AUG", ".", "ENABLED", ":", "\n", "            ", "res", ".", "update", "(", "Trainer", ".", "test_with_TTA", "(", "cfg", ",", "model", ")", ")", "\n", "", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "verify_results", "(", "cfg", ",", "res", ")", "\n", "", "return", "res", "\n", "\n", "", "\"\"\"\n    If you'd like to do anything fancier than the standard training logic,\n    consider writing your own training loop (see plain_train_net.py) or\n    subclassing the trainer.\n    \"\"\"", "\n", "trainer", "=", "Trainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ")", "\n", "if", "cfg", ".", "TEST", ".", "AUG", ".", "ENABLED", ":", "\n", "        ", "trainer", ".", "register_hooks", "(", "\n", "[", "hooks", ".", "EvalHook", "(", "0", ",", "lambda", ":", "trainer", ".", "test_with_TTA", "(", "cfg", ",", "trainer", ".", "model", ")", ")", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.build_sem_seg_train_aug": [[34, 44], ["augs.append", "detectron2.ResizeShortestEdge", "augs.append", "detectron2.RandomFlip", "detectron2.RandomCrop"], "function", ["None"], ["DatasetEvaluators", ",", "\n", "LVISEvaluator", ",", "\n", "PascalVOCDetectionEvaluator", ",", "\n", "SemSegEvaluator", ",", "\n", "verify_results", ",", "\n", ")", "\n", "from", "detectron2", ".", "modeling", "import", "GeneralizedRCNNWithTTA", "\n", "\n", "\n", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.setup": [[157, 168], ["detectron2.config.get_cfg", "detectron2.projects.panoptic_deeplab.add_panoptic_deeplab_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.config.add_panoptic_deeplab_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup"], ["", "return", "trainer", ".", "train", "(", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "args", "=", "default_argument_parser", "(", ")", ".", "parse_args", "(", ")", "\n", "print", "(", "\"Command Line Args:\"", ",", "args", ")", "\n", "launch", "(", "\n", "main", ",", "\n", "args", ".", "num_gpus", ",", "\n", "num_machines", "=", "args", ".", "num_machines", ",", "\n", "machine_rank", "=", "args", ".", "machine_rank", ",", "\n", "dist_url", "=", "args", ".", "dist_url", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.Panoptic-DeepLab.train_net.main": [[170, 184], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test"], [")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.config.add_panoptic_deeplab_config": [[8, 51], ["detectron2.projects.deeplab.add_deeplab_config", "detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.config.add_deeplab_config"], ["from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "", "else", ":", "\n", "# compat.py needs to import CfgNode", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLab.__init__": [[42, 55], ["torch.nn.Module.__init__", "detectron2.modeling.build_backbone", "detectron2.modeling.build_sem_seg_head", "panoptic_seg.build_ins_embed_branch", "panoptic_seg.PanopticDeepLab.register_buffer", "panoptic_seg.PanopticDeepLab.register_buffer", "detectron2.data.MetadataCatalog.get", "panoptic_seg.PanopticDeepLab.backbone.output_shape", "panoptic_seg.PanopticDeepLab.backbone.output_shape", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.semantic_seg.build_sem_seg_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.build_ins_embed_branch", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "sem_seg_head", "=", "build_sem_seg_head", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "ins_embed_head", "=", "build_ins_embed_branch", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "meta", "=", "MetadataCatalog", ".", "get", "(", "cfg", ".", "DATASETS", ".", "TRAIN", "[", "0", "]", ")", "\n", "self", ".", "stuff_area", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "STUFF_AREA", "\n", "self", ".", "threshold", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "CENTER_THRESHOLD", "\n", "self", ".", "nms_kernel", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "NMS_KERNEL", "\n", "self", ".", "top_k", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "TOP_K_INSTANCE", "\n", "self", ".", "predict_instances", "=", "cfg", ".", "MODEL", ".", "PANOPTIC_DEEPLAB", ".", "PREDICT_INSTANCES", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLab.device": [[56, 59], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLab.forward": [[60, 204], ["detectron2.structures.ImageList.from_tensors", "panoptic_seg.PanopticDeepLab.backbone", "panoptic_seg.PanopticDeepLab.sem_seg_head", "losses.update", "panoptic_seg.PanopticDeepLab.ins_embed_head", "losses.update", "losses.update", "zip", "x[].to", "detectron2.structures.ImageList.from_tensors().tensor.unsqueeze", "input_per_image.get", "input_per_image.get", "detectron2.modeling.postprocessing.sem_seg_postprocess", "detectron2.modeling.postprocessing.sem_seg_postprocess", "detectron2.modeling.postprocessing.sem_seg_postprocess", "post_processing.get_panoptic_segmentation", "processed_results.append", "panoptic_image.squeeze.squeeze.squeeze", "torch.nn.functional.softmax", "x[].to", "detectron2.structures.ImageList.from_tensors", "x[].to", "x[].to", "detectron2.structures.ImageList.from_tensors", "x[].to", "detectron2.structures.ImageList.from_tensors", "x[].to", "detectron2.structures.ImageList.from_tensors", "detectron2.modeling.postprocessing.sem_seg_postprocess.argmax", "panoptic_image.squeeze.squeeze.cpu().numpy", "numpy.unique", "x[].to", "detectron2.structures.ImageList.from_tensors", "panoptic_seg.PanopticDeepLab.meta.thing_dataset_id_to_contiguous_id.values", "len", "detectron2.structures.Instances.cat", "detectron2.structures.ImageList.from_tensors", "panoptic_image.squeeze.squeeze.cpu", "list", "detectron2.structures.Instances", "torch.tensor", "mask.unsqueeze", "torch.mean", "torch.nonzero().float", "torch.tensor", "detectron2.structures.BitMasks().get_bounding_boxes", "instances.append", "panoptic_seg.PanopticDeepLab.meta.thing_dataset_id_to_contiguous_id.values", "torch.mean", "torch.mean", "torch.nonzero", "detectron2.structures.BitMasks", "int", "int", "center_y.item", "center_x.item"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.postprocessing.sem_seg_postprocess", "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.get_panoptic_segmentation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.get_bounding_boxes"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.\n                Each item in the list contains the inputs for one image.\n                For now, each item in the list is a dict that contains:\n                   * \"image\": Tensor, image in (C, H, W) format.\n                   * \"sem_seg\": semantic segmentation ground truth\n                   * \"center\": center points heatmap ground truth\n                   * \"offset\": pixel offsets to center points ground truth\n                   * Other information that's included in the original dicts, such as:\n                     \"height\", \"width\" (int): the output resolution of the model (may be different\n                     from input resolution), used in inference.\n        Returns:\n            list[dict]:\n              each dict is the results for one image. The dict contains the following keys:\n\n                * \"instances\": see :meth:`GeneralizedRCNN.forward` for its format.\n                * \"sem_seg\": see :meth:`SemanticSegmentor.forward` for its format.\n                * \"panoptic_seg\": see :func:`combine_semantic_and_instance_outputs` for its format.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "size_divisibility", "=", "self", ".", "backbone", ".", "size_divisibility", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "size_divisibility", ")", "\n", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "losses", "=", "{", "}", "\n", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "targets", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "targets", ",", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "if", "\"sem_seg_weights\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "# The default D2 DatasetMapper may not contain \"sem_seg_weights\"", "\n", "# Avoid error in testing when default DatasetMapper is used.", "\n", "                ", "weights", "=", "[", "x", "[", "\"sem_seg_weights\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "weights", "=", "ImageList", ".", "from_tensors", "(", "weights", ",", "size_divisibility", ")", ".", "tensor", "\n", "", "else", ":", "\n", "                ", "weights", "=", "None", "\n", "", "", "else", ":", "\n", "            ", "targets", "=", "None", "\n", "weights", "=", "None", "\n", "", "sem_seg_results", ",", "sem_seg_losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "targets", ",", "weights", ")", "\n", "losses", ".", "update", "(", "sem_seg_losses", ")", "\n", "\n", "if", "\"center\"", "in", "batched_inputs", "[", "0", "]", "and", "\"offset\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "center_targets", "=", "[", "x", "[", "\"center\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "center_targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "center_targets", ",", "size_divisibility", "\n", ")", ".", "tensor", ".", "unsqueeze", "(", "1", ")", "\n", "center_weights", "=", "[", "x", "[", "\"center_weights\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "center_weights", "=", "ImageList", ".", "from_tensors", "(", "center_weights", ",", "size_divisibility", ")", ".", "tensor", "\n", "\n", "offset_targets", "=", "[", "x", "[", "\"offset\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "offset_targets", "=", "ImageList", ".", "from_tensors", "(", "offset_targets", ",", "size_divisibility", ")", ".", "tensor", "\n", "offset_weights", "=", "[", "x", "[", "\"offset_weights\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "offset_weights", "=", "ImageList", ".", "from_tensors", "(", "offset_weights", ",", "size_divisibility", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "center_targets", "=", "None", "\n", "center_weights", "=", "None", "\n", "\n", "offset_targets", "=", "None", "\n", "offset_weights", "=", "None", "\n", "\n", "", "center_results", ",", "offset_results", ",", "center_losses", ",", "offset_losses", "=", "self", ".", "ins_embed_head", "(", "\n", "features", ",", "center_targets", ",", "center_weights", ",", "offset_targets", ",", "offset_weights", "\n", ")", "\n", "losses", ".", "update", "(", "center_losses", ")", "\n", "losses", ".", "update", "(", "offset_losses", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "sem_seg_result", ",", "center_result", ",", "offset_result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "\n", "sem_seg_results", ",", "center_results", ",", "offset_results", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ")", "\n", "r", "=", "sem_seg_postprocess", "(", "sem_seg_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "c", "=", "sem_seg_postprocess", "(", "center_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "o", "=", "sem_seg_postprocess", "(", "offset_result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "# Post-processing to get panoptic segmentation.", "\n", "panoptic_image", ",", "_", "=", "get_panoptic_segmentation", "(", "\n", "r", ".", "argmax", "(", "dim", "=", "0", ",", "keepdim", "=", "True", ")", ",", "\n", "c", ",", "\n", "o", ",", "\n", "thing_ids", "=", "self", ".", "meta", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", ",", "\n", "label_divisor", "=", "self", ".", "meta", ".", "label_divisor", ",", "\n", "stuff_area", "=", "self", ".", "stuff_area", ",", "\n", "void_label", "=", "-", "1", ",", "\n", "threshold", "=", "self", ".", "threshold", ",", "\n", "nms_kernel", "=", "self", ".", "nms_kernel", ",", "\n", "top_k", "=", "self", ".", "top_k", ",", "\n", ")", "\n", "# For semantic segmentation evaluation.", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "r", "}", ")", "\n", "panoptic_image", "=", "panoptic_image", ".", "squeeze", "(", "0", ")", "\n", "semantic_prob", "=", "F", ".", "softmax", "(", "r", ",", "dim", "=", "0", ")", "\n", "# For panoptic segmentation evaluation.", "\n", "processed_results", "[", "-", "1", "]", "[", "\"panoptic_seg\"", "]", "=", "(", "panoptic_image", ",", "None", ")", "\n", "# For instance segmentation evaluation.", "\n", "if", "self", ".", "predict_instances", ":", "\n", "                ", "instances", "=", "[", "]", "\n", "panoptic_image_cpu", "=", "panoptic_image", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "panoptic_label", "in", "np", ".", "unique", "(", "panoptic_image_cpu", ")", ":", "\n", "                    ", "if", "panoptic_label", "==", "-", "1", ":", "\n", "                        ", "continue", "\n", "", "pred_class", "=", "panoptic_label", "//", "self", ".", "meta", ".", "label_divisor", "\n", "isthing", "=", "pred_class", "in", "list", "(", "\n", "self", ".", "meta", ".", "thing_dataset_id_to_contiguous_id", ".", "values", "(", ")", "\n", ")", "\n", "# Get instance segmentation results.", "\n", "if", "isthing", ":", "\n", "                        ", "instance", "=", "Instances", "(", "(", "height", ",", "width", ")", ")", "\n", "# Evaluation code takes continuous id starting from 0", "\n", "instance", ".", "pred_classes", "=", "torch", ".", "tensor", "(", "\n", "[", "pred_class", "]", ",", "device", "=", "panoptic_image", ".", "device", "\n", ")", "\n", "mask", "=", "panoptic_image", "==", "panoptic_label", "\n", "instance", ".", "pred_masks", "=", "mask", ".", "unsqueeze", "(", "0", ")", "\n", "# Average semantic probability", "\n", "sem_scores", "=", "semantic_prob", "[", "pred_class", ",", "...", "]", "\n", "sem_scores", "=", "torch", ".", "mean", "(", "sem_scores", "[", "mask", "]", ")", "\n", "# Center point probability", "\n", "mask_indices", "=", "torch", ".", "nonzero", "(", "mask", ")", ".", "float", "(", ")", "\n", "center_y", ",", "center_x", "=", "(", "\n", "torch", ".", "mean", "(", "mask_indices", "[", ":", ",", "0", "]", ")", ",", "\n", "torch", ".", "mean", "(", "mask_indices", "[", ":", ",", "1", "]", ")", ",", "\n", ")", "\n", "center_scores", "=", "c", "[", "0", ",", "int", "(", "center_y", ".", "item", "(", ")", ")", ",", "int", "(", "center_x", ".", "item", "(", ")", ")", "]", "\n", "# Confidence score is semantic prob * center prob.", "\n", "instance", ".", "scores", "=", "torch", ".", "tensor", "(", "\n", "[", "sem_scores", "*", "center_scores", "]", ",", "device", "=", "panoptic_image", ".", "device", "\n", ")", "\n", "# Get bounding boxes", "\n", "instance", ".", "pred_boxes", "=", "BitMasks", "(", "instance", ".", "pred_masks", ")", ".", "get_bounding_boxes", "(", ")", "\n", "instances", ".", "append", "(", "instance", ")", "\n", "", "", "if", "len", "(", "instances", ")", ">", "0", ":", "\n", "                    ", "processed_results", "[", "-", "1", "]", "[", "\"instances\"", "]", "=", "Instances", ".", "cat", "(", "instances", ")", "\n", "\n", "", "", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.__init__": [[212, 287], ["detectron2.projects.deeplab.DeepLabV3PlusHead.__init__", "torch.nn.Sequential", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "torch.nn.CrossEntropyLoss", "detectron2.projects.deeplab.loss.DeepLabCE", "ValueError", "detectron2.layers.get_norm", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ",", "\n", "*", ",", "\n", "decoder_channels", ":", "List", "[", "int", "]", ",", "\n", "norm", ":", "Union", "[", "str", ",", "Callable", "]", ",", "\n", "head_channels", ":", "int", ",", "\n", "loss_weight", ":", "float", ",", "\n", "loss_type", ":", "str", ",", "\n", "loss_top_k", ":", "float", ",", "\n", "ignore_value", ":", "int", ",", "\n", "num_classes", ":", "int", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature\n            decoder_channels (list[int]): a list of output channels of each\n                decoder stage. It should have the same length as \"in_features\"\n                (each element in \"in_features\" corresponds to one decoder stage).\n            norm (str or callable): normalization for all conv layers.\n            head_channels (int): the output channels of extra convolutions\n                between decoder and predictor.\n            loss_weight (float): loss weight.\n            loss_top_k: (float): setting the top k% hardest pixels for\n                \"hard_pixel_mining\" loss.\n            loss_type, ignore_value, num_classes: the same as the base class.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "input_shape", ",", "\n", "decoder_channels", "=", "decoder_channels", ",", "\n", "norm", "=", "norm", ",", "\n", "ignore_value", "=", "ignore_value", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "assert", "self", ".", "decoder_only", "\n", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "use_bias", "=", "norm", "==", "\"\"", "\n", "# `head` is additional transform before predictor", "\n", "self", ".", "head", "=", "nn", ".", "Sequential", "(", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "decoder_channels", "[", "0", "]", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "head_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "head_channels", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "head", "[", "0", "]", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "head", "[", "1", "]", ")", "\n", "self", ".", "predictor", "=", "Conv2d", "(", "head_channels", ",", "num_classes", ",", "kernel_size", "=", "1", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "predictor", ".", "weight", ",", "0", ",", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "predictor", ".", "bias", ",", "0", ")", "\n", "\n", "if", "loss_type", "==", "\"cross_entropy\"", ":", "\n", "            ", "self", ".", "loss", "=", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "\"mean\"", ",", "ignore_index", "=", "ignore_value", ")", "\n", "", "elif", "loss_type", "==", "\"hard_pixel_mining\"", ":", "\n", "            ", "self", ".", "loss", "=", "DeepLabCE", "(", "ignore_label", "=", "ignore_value", ",", "top_k_percent_pixels", "=", "loss_top_k", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unexpected loss type: %s\"", "%", "loss_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.from_config": [[288, 294], ["super().from_config"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.from_config"], ["", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ",", "input_shape", ")", "\n", "ret", "[", "\"head_channels\"", "]", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "HEAD_CHANNELS", "\n", "ret", "[", "\"loss_top_k\"", "]", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_TOP_K", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.forward": [[295, 309], ["panoptic_seg.PanopticDeepLabSemSegHead.layers", "torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabSemSegHead.losses"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses"], ["", "def", "forward", "(", "self", ",", "features", ",", "targets", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            In training, returns (None, dict of losses)\n            In inference, returns (CxHxW logits, {})\n        \"\"\"", "\n", "y", "=", "self", ".", "layers", "(", "features", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "None", ",", "self", ".", "losses", "(", "y", ",", "targets", ",", "weights", ")", "\n", "", "else", ":", "\n", "            ", "y", "=", "F", ".", "interpolate", "(", "\n", "y", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "return", "y", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.layers": [[310, 316], ["super().layers", "panoptic_seg.PanopticDeepLabSemSegHead.head", "panoptic_seg.PanopticDeepLabSemSegHead.predictor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers"], ["", "", "def", "layers", "(", "self", ",", "features", ")", ":", "\n", "        ", "assert", "self", ".", "decoder_only", "\n", "y", "=", "super", "(", ")", ".", "layers", "(", "features", ")", "\n", "y", "=", "self", ".", "head", "(", "y", ")", "\n", "y", "=", "self", ".", "predictor", "(", "y", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabSemSegHead.losses": [[317, 324], ["torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabSemSegHead.loss"], "methods", ["None"], ["", "def", "losses", "(", "self", ",", "predictions", ",", "targets", ",", "weights", "=", "None", ")", ":", "\n", "        ", "predictions", "=", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "loss", "=", "self", ".", "loss", "(", "predictions", ",", "targets", ",", "weights", ")", "\n", "losses", "=", "{", "\"loss_sem_seg\"", ":", "loss", "*", "self", ".", "loss_weight", "}", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.__init__": [[340, 430], ["detectron2.projects.deeplab.DeepLabV3PlusHead.__init__", "torch.nn.Sequential", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.Sequential", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.MSELoss", "torch.nn.L1Loss", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ",", "\n", "*", ",", "\n", "decoder_channels", ":", "List", "[", "int", "]", ",", "\n", "norm", ":", "Union", "[", "str", ",", "Callable", "]", ",", "\n", "head_channels", ":", "int", ",", "\n", "center_loss_weight", ":", "float", ",", "\n", "offset_loss_weight", ":", "float", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            input_shape (ShapeSpec): shape of the input feature\n            decoder_channels (list[int]): a list of output channels of each\n                decoder stage. It should have the same length as \"in_features\"\n                (each element in \"in_features\" corresponds to one decoder stage).\n            norm (str or callable): normalization for all conv layers.\n            head_channels (int): the output channels of extra convolutions\n                between decoder and predictor.\n            center_loss_weight (float): loss weight for center point prediction.\n            offset_loss_weight (float): loss weight for center offset prediction.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "input_shape", ",", "decoder_channels", "=", "decoder_channels", ",", "norm", "=", "norm", ",", "**", "kwargs", ")", "\n", "assert", "self", ".", "decoder_only", "\n", "\n", "self", ".", "center_loss_weight", "=", "center_loss_weight", "\n", "self", ".", "offset_loss_weight", "=", "offset_loss_weight", "\n", "use_bias", "=", "norm", "==", "\"\"", "\n", "# center prediction", "\n", "# `head` is additional transform before predictor", "\n", "self", ".", "center_head", "=", "nn", ".", "Sequential", "(", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "decoder_channels", "[", "0", "]", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "head_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "head_channels", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "center_head", "[", "0", "]", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "center_head", "[", "1", "]", ")", "\n", "self", ".", "center_predictor", "=", "Conv2d", "(", "head_channels", ",", "1", ",", "kernel_size", "=", "1", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "center_predictor", ".", "weight", ",", "0", ",", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "center_predictor", ".", "bias", ",", "0", ")", "\n", "\n", "# offset prediction", "\n", "# `head` is additional transform before predictor", "\n", "self", ".", "offset_head", "=", "nn", ".", "Sequential", "(", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "decoder_channels", "[", "0", "]", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", "Conv2d", "(", "\n", "decoder_channels", "[", "0", "]", ",", "\n", "head_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "head_channels", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", ",", "\n", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "offset_head", "[", "0", "]", ")", "\n", "weight_init", ".", "c2_xavier_fill", "(", "self", ".", "offset_head", "[", "1", "]", ")", "\n", "self", ".", "offset_predictor", "=", "Conv2d", "(", "head_channels", ",", "2", ",", "kernel_size", "=", "1", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "offset_predictor", ".", "weight", ",", "0", ",", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "offset_predictor", ".", "bias", ",", "0", ")", "\n", "\n", "self", ".", "center_loss", "=", "nn", ".", "MSELoss", "(", "reduction", "=", "\"none\"", ")", "\n", "self", ".", "offset_loss", "=", "nn", ".", "L1Loss", "(", "reduction", "=", "\"none\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.from_config": [[431, 456], ["dict", "len"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "if", "cfg", ".", "INPUT", ".", "CROP", ".", "ENABLED", ":", "\n", "            ", "assert", "cfg", ".", "INPUT", ".", "CROP", ".", "TYPE", "==", "\"absolute\"", "\n", "train_size", "=", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", "\n", "", "else", ":", "\n", "            ", "train_size", "=", "None", "\n", "", "decoder_channels", "=", "[", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "CONVS_DIM", "]", "*", "(", "\n", "len", "(", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "IN_FEATURES", ")", "-", "1", "\n", ")", "+", "[", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "ASPP_CHANNELS", "]", "\n", "ret", "=", "dict", "(", "\n", "input_shape", "=", "input_shape", ",", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "IN_FEATURES", ",", "\n", "project_channels", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "PROJECT_CHANNELS", ",", "\n", "aspp_dilations", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "ASPP_DILATIONS", ",", "\n", "aspp_dropout", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "ASPP_DROPOUT", ",", "\n", "decoder_channels", "=", "decoder_channels", ",", "\n", "common_stride", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "COMMON_STRIDE", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "NORM", ",", "\n", "train_size", "=", "train_size", ",", "\n", "head_channels", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "HEAD_CHANNELS", ",", "\n", "center_loss_weight", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "CENTER_LOSS_WEIGHT", ",", "\n", "offset_loss_weight", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "OFFSET_LOSS_WEIGHT", ",", "\n", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.forward": [[457, 489], ["panoptic_seg.PanopticDeepLabInsEmbedHead.layers", "torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabInsEmbedHead.center_losses", "panoptic_seg.PanopticDeepLabInsEmbedHead.offset_losses", "torch.nn.functional.interpolate"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.center_losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.offset_losses"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "features", ",", "\n", "center_targets", "=", "None", ",", "\n", "center_weights", "=", "None", ",", "\n", "offset_targets", "=", "None", ",", "\n", "offset_weights", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            In training, returns (None, dict of losses)\n            In inference, returns (CxHxW logits, {})\n        \"\"\"", "\n", "center", ",", "offset", "=", "self", ".", "layers", "(", "features", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "(", "\n", "None", ",", "\n", "None", ",", "\n", "self", ".", "center_losses", "(", "center", ",", "center_targets", ",", "center_weights", ")", ",", "\n", "self", ".", "offset_losses", "(", "offset", ",", "offset_targets", ",", "offset_weights", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "center", "=", "F", ".", "interpolate", "(", "\n", "center", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "offset", "=", "(", "\n", "F", ".", "interpolate", "(", "\n", "offset", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "*", "self", ".", "common_stride", "\n", ")", "\n", "return", "center", ",", "offset", ",", "{", "}", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.layers": [[490, 500], ["super().layers", "panoptic_seg.PanopticDeepLabInsEmbedHead.center_head", "panoptic_seg.PanopticDeepLabInsEmbedHead.center_predictor", "panoptic_seg.PanopticDeepLabInsEmbedHead.offset_head", "panoptic_seg.PanopticDeepLabInsEmbedHead.offset_predictor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers"], ["", "", "def", "layers", "(", "self", ",", "features", ")", ":", "\n", "        ", "assert", "self", ".", "decoder_only", "\n", "y", "=", "super", "(", ")", ".", "layers", "(", "features", ")", "\n", "# center", "\n", "center", "=", "self", ".", "center_head", "(", "y", ")", "\n", "center", "=", "self", ".", "center_predictor", "(", "center", ")", "\n", "# offset", "\n", "offset", "=", "self", ".", "offset_head", "(", "y", ")", "\n", "offset", "=", "self", ".", "offset_predictor", "(", "offset", ")", "\n", "return", "center", ",", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.center_losses": [[501, 512], ["torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabInsEmbedHead.center_loss", "weights.sum", "loss.sum", "weights.sum", "loss.sum"], "methods", ["None"], ["", "def", "center_losses", "(", "self", ",", "predictions", ",", "targets", ",", "weights", ")", ":", "\n", "        ", "predictions", "=", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "loss", "=", "self", ".", "center_loss", "(", "predictions", ",", "targets", ")", "*", "weights", "\n", "if", "weights", ".", "sum", "(", ")", ">", "0", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "/", "weights", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "*", "0", "\n", "", "losses", "=", "{", "\"loss_center\"", ":", "loss", "*", "self", ".", "center_loss_weight", "}", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.PanopticDeepLabInsEmbedHead.offset_losses": [[513, 527], ["torch.nn.functional.interpolate", "panoptic_seg.PanopticDeepLabInsEmbedHead.offset_loss", "weights.sum", "loss.sum", "weights.sum", "loss.sum"], "methods", ["None"], ["", "def", "offset_losses", "(", "self", ",", "predictions", ",", "targets", ",", "weights", ")", ":", "\n", "        ", "predictions", "=", "(", "\n", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "*", "self", ".", "common_stride", "\n", ")", "\n", "loss", "=", "self", ".", "offset_loss", "(", "predictions", ",", "targets", ")", "*", "weights", "\n", "if", "weights", ".", "sum", "(", ")", ">", "0", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "/", "weights", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "loss", ".", "sum", "(", ")", "*", "0", "\n", "", "losses", "=", "{", "\"loss_offset\"", ":", "loss", "*", "self", ".", "offset_loss_weight", "}", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.panoptic_seg.build_ins_embed_branch": [[326, 332], ["INS_EMBED_BRANCHES_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "build_ins_embed_branch", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a instance embedding branch from `cfg.MODEL.INS_EMBED_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "INS_EMBED_HEAD", ".", "NAME", "\n", "return", "INS_EMBED_BRANCHES_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.target_generator.PanopticDeepLabTargetGenerator.__init__": [[12, 51], ["set", "numpy.arange", "numpy.exp"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["def", "__init__", "(", "\n", "self", ",", "\n", "ignore_label", ",", "\n", "thing_ids", ",", "\n", "sigma", "=", "8", ",", "\n", "ignore_stuff_in_offset", "=", "False", ",", "\n", "small_instance_area", "=", "0", ",", "\n", "small_instance_weight", "=", "1", ",", "\n", "ignore_crowd_in_semantic", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            ignore_label: Integer, the ignore label for semantic segmentation.\n            thing_ids: Set, a set of ids from contiguous category ids belonging\n                to thing categories.\n            sigma: the sigma for Gaussian kernel.\n            ignore_stuff_in_offset: Boolean, whether to ignore stuff region when\n                training the offset branch.\n            small_instance_area: Integer, indicates largest area for small instances.\n            small_instance_weight: Integer, indicates semantic loss weights for\n                small instances.\n            ignore_crowd_in_semantic: Boolean, whether to ignore crowd region in\n                semantic segmentation branch, crowd region is ignored in the original\n                TensorFlow implementation.\n        \"\"\"", "\n", "self", ".", "ignore_label", "=", "ignore_label", "\n", "self", ".", "thing_ids", "=", "set", "(", "thing_ids", ")", "\n", "self", ".", "ignore_stuff_in_offset", "=", "ignore_stuff_in_offset", "\n", "self", ".", "small_instance_area", "=", "small_instance_area", "\n", "self", ".", "small_instance_weight", "=", "small_instance_weight", "\n", "self", ".", "ignore_crowd_in_semantic", "=", "ignore_crowd_in_semantic", "\n", "\n", "# Generate the default Gaussian image for each center", "\n", "self", ".", "sigma", "=", "sigma", "\n", "size", "=", "6", "*", "sigma", "+", "3", "\n", "x", "=", "np", ".", "arange", "(", "0", ",", "size", ",", "1", ",", "float", ")", "\n", "y", "=", "x", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "x0", ",", "y0", "=", "3", "*", "sigma", "+", "1", ",", "3", "*", "sigma", "+", "1", "\n", "self", ".", "g", "=", "np", ".", "exp", "(", "-", "(", "(", "x", "-", "x0", ")", "**", "2", "+", "(", "y", "-", "y0", ")", "**", "2", ")", "/", "(", "2", "*", "sigma", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.target_generator.PanopticDeepLabTargetGenerator.__call__": [[52, 161], ["numpy.zeros", "numpy.zeros", "numpy.meshgrid", "numpy.ones_like", "numpy.zeros_like", "numpy.zeros_like", "dict", "numpy.zeros_like", "numpy.arange", "numpy.arange", "numpy.where", "len", "center_pts.append", "numpy.maximum", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "len", "numpy.mean", "numpy.mean", "int", "int", "int", "int", "int", "int", "max", "max", "max", "min", "max", "min", "semantic.astype", "numpy.zeros.astype", "numpy.zeros.astype", "numpy.ones_like.astype", "numpy.zeros_like.astype", "numpy.zeros_like.astype", "round", "round", "numpy.round", "numpy.round", "numpy.round", "numpy.round", "min", "min"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "panoptic", ",", "segments_info", ")", ":", "\n", "        ", "\"\"\"Generates the training target.\n        reference: https://github.com/mcordts/cityscapesScripts/blob/master/cityscapesscripts/preparation/createPanopticImgs.py  # noqa\n        reference: https://github.com/facebookresearch/detectron2/blob/master/datasets/prepare_panoptic_fpn.py#L18  # noqa\n        Args:\n            panoptic: numpy.array, panoptic label, we assume it is already\n                converted from rgb image by panopticapi.utils.rgb2id.\n            segments_info: List, a list of dictionary containing information of\n                every segment, it has fields:\n                - id: panoptic id, this is the compact id that encode both\n                    category and instance id by:\n                    category_id * label_divisor + instance_id.\n                - category_id: category id, like semantic segmentation, it is\n                    the class id for each pixel. It is expected to by contiguous\n                    category id, conveted when registering panoptic datasets.\n                - iscrowd: crowd region.\n        Returns:\n            A dictionary with fields:\n                - sem_seg: Tensor, semantic label, shape=(H, W).\n                - center: Tensor, center heatmap, shape=(H, W).\n                - center_points: List, center coordinates, with tuple\n                    (y-coord, x-coord).\n                - offset: Tensor, offset, shape=(2, H, W), first dim is\n                    (offset_y, offset_x).\n                - sem_seg_weights: Tensor, loss weight for semantic prediction,\n                    shape=(H, W).\n                - center_weights: Tensor, ignore region of center prediction,\n                    shape=(H, W), used as weights for center regression 0 is\n                    ignore, 1 is has instance. Multiply this mask to loss.\n                - offset_weights: Tensor, ignore region of offset prediction,\n                    shape=(H, W), used as weights for offset regression 0 is\n                    ignore, 1 is has instance. Multiply this mask to loss.\n        \"\"\"", "\n", "height", ",", "width", "=", "panoptic", ".", "shape", "[", "0", "]", ",", "panoptic", ".", "shape", "[", "1", "]", "\n", "semantic", "=", "np", ".", "zeros_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "+", "self", ".", "ignore_label", "\n", "center", "=", "np", ".", "zeros", "(", "(", "height", ",", "width", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "center_pts", "=", "[", "]", "\n", "offset", "=", "np", ".", "zeros", "(", "(", "2", ",", "height", ",", "width", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "y_coord", ",", "x_coord", "=", "np", ".", "meshgrid", "(", "\n", "np", ".", "arange", "(", "height", ",", "dtype", "=", "np", ".", "float32", ")", ",", "np", ".", "arange", "(", "width", ",", "dtype", "=", "np", ".", "float32", ")", ",", "indexing", "=", "\"ij\"", "\n", ")", "\n", "# Generate pixel-wise loss weights", "\n", "semantic_weights", "=", "np", ".", "ones_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "# 0: ignore, 1: has instance", "\n", "# three conditions for a region to be ignored for instance branches:", "\n", "# (1) It is labeled as `ignore_label`", "\n", "# (2) It is crowd region (iscrowd=1)", "\n", "# (3) (Optional) It is stuff region (for offset branch)", "\n", "center_weights", "=", "np", ".", "zeros_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "offset_weights", "=", "np", ".", "zeros_like", "(", "panoptic", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "seg", "in", "segments_info", ":", "\n", "            ", "cat_id", "=", "seg", "[", "\"category_id\"", "]", "\n", "if", "not", "(", "self", ".", "ignore_crowd_in_semantic", "and", "seg", "[", "\"iscrowd\"", "]", ")", ":", "\n", "                ", "semantic", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "cat_id", "\n", "", "if", "not", "seg", "[", "\"iscrowd\"", "]", ":", "\n", "# Ignored regions are not in `segments_info`.", "\n", "# Handle crowd region.", "\n", "                ", "center_weights", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "1", "\n", "if", "not", "self", ".", "ignore_stuff_in_offset", "or", "cat_id", "in", "self", ".", "thing_ids", ":", "\n", "                    ", "offset_weights", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "1", "\n", "", "", "if", "cat_id", "in", "self", ".", "thing_ids", ":", "\n", "# find instance center", "\n", "                ", "mask_index", "=", "np", ".", "where", "(", "panoptic", "==", "seg", "[", "\"id\"", "]", ")", "\n", "if", "len", "(", "mask_index", "[", "0", "]", ")", "==", "0", ":", "\n", "# the instance is completely cropped", "\n", "                    ", "continue", "\n", "\n", "# Find instance area", "\n", "", "ins_area", "=", "len", "(", "mask_index", "[", "0", "]", ")", "\n", "if", "ins_area", "<", "self", ".", "small_instance_area", ":", "\n", "                    ", "semantic_weights", "[", "panoptic", "==", "seg", "[", "\"id\"", "]", "]", "=", "self", ".", "small_instance_weight", "\n", "\n", "", "center_y", ",", "center_x", "=", "np", ".", "mean", "(", "mask_index", "[", "0", "]", ")", ",", "np", ".", "mean", "(", "mask_index", "[", "1", "]", ")", "\n", "center_pts", ".", "append", "(", "[", "center_y", ",", "center_x", "]", ")", "\n", "\n", "# generate center heatmap", "\n", "y", ",", "x", "=", "int", "(", "round", "(", "center_y", ")", ")", ",", "int", "(", "round", "(", "center_x", ")", ")", "\n", "sigma", "=", "self", ".", "sigma", "\n", "# upper left", "\n", "ul", "=", "int", "(", "np", ".", "round", "(", "x", "-", "3", "*", "sigma", "-", "1", ")", ")", ",", "int", "(", "np", ".", "round", "(", "y", "-", "3", "*", "sigma", "-", "1", ")", ")", "\n", "# bottom right", "\n", "br", "=", "int", "(", "np", ".", "round", "(", "x", "+", "3", "*", "sigma", "+", "2", ")", ")", ",", "int", "(", "np", ".", "round", "(", "y", "+", "3", "*", "sigma", "+", "2", ")", ")", "\n", "\n", "# start and end indices in default Gaussian image", "\n", "gaussian_x0", ",", "gaussian_x1", "=", "max", "(", "0", ",", "-", "ul", "[", "0", "]", ")", ",", "min", "(", "br", "[", "0", "]", ",", "width", ")", "-", "ul", "[", "0", "]", "\n", "gaussian_y0", ",", "gaussian_y1", "=", "max", "(", "0", ",", "-", "ul", "[", "1", "]", ")", ",", "min", "(", "br", "[", "1", "]", ",", "height", ")", "-", "ul", "[", "1", "]", "\n", "\n", "# start and end indices in center heatmap image", "\n", "center_x0", ",", "center_x1", "=", "max", "(", "0", ",", "ul", "[", "0", "]", ")", ",", "min", "(", "br", "[", "0", "]", ",", "width", ")", "\n", "center_y0", ",", "center_y1", "=", "max", "(", "0", ",", "ul", "[", "1", "]", ")", ",", "min", "(", "br", "[", "1", "]", ",", "height", ")", "\n", "center", "[", "center_y0", ":", "center_y1", ",", "center_x0", ":", "center_x1", "]", "=", "np", ".", "maximum", "(", "\n", "center", "[", "center_y0", ":", "center_y1", ",", "center_x0", ":", "center_x1", "]", ",", "\n", "self", ".", "g", "[", "gaussian_y0", ":", "gaussian_y1", ",", "gaussian_x0", ":", "gaussian_x1", "]", ",", "\n", ")", "\n", "\n", "# generate offset (2, h, w) -> (y-dir, x-dir)", "\n", "offset", "[", "0", "]", "[", "mask_index", "]", "=", "center_y", "-", "y_coord", "[", "mask_index", "]", "\n", "offset", "[", "1", "]", "[", "mask_index", "]", "=", "center_x", "-", "x_coord", "[", "mask_index", "]", "\n", "\n", "", "", "center_weights", "=", "center_weights", "[", "None", "]", "\n", "offset_weights", "=", "offset_weights", "[", "None", "]", "\n", "return", "dict", "(", "\n", "sem_seg", "=", "torch", ".", "as_tensor", "(", "semantic", ".", "astype", "(", "\"long\"", ")", ")", ",", "\n", "center", "=", "torch", ".", "as_tensor", "(", "center", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "center_points", "=", "center_pts", ",", "\n", "offset", "=", "torch", ".", "as_tensor", "(", "offset", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "sem_seg_weights", "=", "torch", ".", "as_tensor", "(", "semantic_weights", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "center_weights", "=", "torch", ".", "as_tensor", "(", "center_weights", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "offset_weights", "=", "torch", ".", "as_tensor", "(", "offset_weights", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.find_instance_center": [[9, 42], ["torch.threshold", "torch.max_pool2d", "center_heatmap.squeeze.squeeze", "len", "torch.nonzero", "torch.nonzero", "torch.topk", "torch.topk", "torch.nonzero", "torch.nonzero", "center_heatmap.squeeze.size", "torch.flatten", "torch.flatten", "top_k_scores[].clamp_"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["def", "find_instance_center", "(", "center_heatmap", ",", "threshold", "=", "0.1", ",", "nms_kernel", "=", "3", ",", "top_k", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Find the center points from the center heatmap.\n    Args:\n        center_heatmap: A Tensor of shape [1, H, W] of raw center heatmap output.\n        threshold: A float, threshold applied to center heatmap score.\n        nms_kernel: An integer, NMS max pooling kernel size.\n        top_k: An integer, top k centers to keep.\n    Returns:\n        A Tensor of shape [K, 2] where K is the number of center points. The\n            order of second dim is (y, x).\n    \"\"\"", "\n", "# Thresholding, setting values below threshold to -1.", "\n", "center_heatmap", "=", "F", ".", "threshold", "(", "center_heatmap", ",", "threshold", ",", "-", "1", ")", "\n", "\n", "# NMS", "\n", "nms_padding", "=", "(", "nms_kernel", "-", "1", ")", "//", "2", "\n", "center_heatmap_max_pooled", "=", "F", ".", "max_pool2d", "(", "\n", "center_heatmap", ",", "kernel_size", "=", "nms_kernel", ",", "stride", "=", "1", ",", "padding", "=", "nms_padding", "\n", ")", "\n", "center_heatmap", "[", "center_heatmap", "!=", "center_heatmap_max_pooled", "]", "=", "-", "1", "\n", "\n", "# Squeeze first two dimensions.", "\n", "center_heatmap", "=", "center_heatmap", ".", "squeeze", "(", ")", "\n", "assert", "len", "(", "center_heatmap", ".", "size", "(", ")", ")", "==", "2", ",", "\"Something is wrong with center heatmap dimension.\"", "\n", "\n", "# Find non-zero elements.", "\n", "if", "top_k", "is", "None", ":", "\n", "        ", "return", "torch", ".", "nonzero", "(", "center_heatmap", ">", "0", ")", "\n", "", "else", ":", "\n", "# find top k centers.", "\n", "        ", "top_k_scores", ",", "_", "=", "torch", ".", "topk", "(", "torch", ".", "flatten", "(", "center_heatmap", ")", ",", "top_k", ")", "\n", "return", "torch", ".", "nonzero", "(", "center_heatmap", ">", "top_k_scores", "[", "-", "1", "]", ".", "clamp_", "(", "min", "=", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.group_pixels": [[44, 77], ["torch.meshgrid", "torch.meshgrid", "torch.cat", "torch.cat", "center_loc.flatten().T.unsqueeze_.flatten().T.unsqueeze_", "center_points.unsqueeze.unsqueeze", "torch.norm", "torch.norm", "offsets.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.argmin().reshape", "torch.argmin().reshape", "y_coord.unsqueeze", "x_coord.unsqueeze", "center_loc.flatten().T.unsqueeze_.flatten", "torch.argmin", "torch.argmin"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "", "def", "group_pixels", "(", "center_points", ",", "offsets", ")", ":", "\n", "    ", "\"\"\"\n    Gives each pixel in the image an instance id.\n    Args:\n        center_points: A Tensor of shape [K, 2] where K is the number of center points.\n            The order of second dim is (y, x).\n        offsets: A Tensor of shape [2, H, W] of raw offset output. The order of\n            second dim is (offset_y, offset_x).\n    Returns:\n        A Tensor of shape [1, H, W] with values in range [1, K], which represents\n            the center this pixel belongs to.\n    \"\"\"", "\n", "height", ",", "width", "=", "offsets", ".", "size", "(", ")", "[", "1", ":", "]", "\n", "\n", "# Generates a coordinate map, where each location is the coordinate of", "\n", "# that location.", "\n", "y_coord", ",", "x_coord", "=", "torch", ".", "meshgrid", "(", "\n", "torch", ".", "arange", "(", "height", ",", "dtype", "=", "offsets", ".", "dtype", ",", "device", "=", "offsets", ".", "device", ")", ",", "\n", "torch", ".", "arange", "(", "width", ",", "dtype", "=", "offsets", ".", "dtype", ",", "device", "=", "offsets", ".", "device", ")", ",", "\n", ")", "\n", "coord", "=", "torch", ".", "cat", "(", "(", "y_coord", ".", "unsqueeze", "(", "0", ")", ",", "x_coord", ".", "unsqueeze", "(", "0", ")", ")", ",", "dim", "=", "0", ")", "\n", "\n", "center_loc", "=", "coord", "+", "offsets", "\n", "center_loc", "=", "center_loc", ".", "flatten", "(", "1", ")", ".", "T", ".", "unsqueeze_", "(", "0", ")", "# [1, H*W, 2]", "\n", "center_points", "=", "center_points", ".", "unsqueeze", "(", "1", ")", "# [K, 1, 2]", "\n", "\n", "# Distance: [K, H*W].", "\n", "distance", "=", "torch", ".", "norm", "(", "center_points", "-", "center_loc", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Finds center with minimum distance at each location, offset by 1, to", "\n", "# reserve id=0 for stuff.", "\n", "instance_id", "=", "torch", ".", "argmin", "(", "distance", ",", "dim", "=", "0", ")", ".", "reshape", "(", "(", "1", ",", "height", ",", "width", ")", ")", "+", "1", "\n", "return", "instance_id", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.get_instance_segmentation": [[79, 109], ["post_processing.find_instance_center", "post_processing.group_pixels", "find_instance_center.size", "find_instance_center.unsqueeze", "torch.zeros_like", "torch.zeros_like", "find_instance_center.unsqueeze"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.find_instance_center", "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.group_pixels"], ["", "def", "get_instance_segmentation", "(", "\n", "sem_seg", ",", "center_heatmap", ",", "offsets", ",", "thing_seg", ",", "thing_ids", ",", "threshold", "=", "0.1", ",", "nms_kernel", "=", "3", ",", "top_k", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Post-processing for instance segmentation, gets class agnostic instance id.\n    Args:\n        sem_seg: A Tensor of shape [1, H, W], predicted semantic label.\n        center_heatmap: A Tensor of shape [1, H, W] of raw center heatmap output.\n        offsets: A Tensor of shape [2, H, W] of raw offset output. The order of\n            second dim is (offset_y, offset_x).\n        thing_seg: A Tensor of shape [1, H, W], predicted foreground mask,\n            if not provided, inference from semantic prediction.\n        thing_ids: A set of ids from contiguous category ids belonging\n            to thing categories.\n        threshold: A float, threshold applied to center heatmap score.\n        nms_kernel: An integer, NMS max pooling kernel size.\n        top_k: An integer, top k centers to keep.\n    Returns:\n        A Tensor of shape [1, H, W] with value 0 represent stuff (not instance)\n            and other positive values represent different instances.\n        A Tensor of shape [1, K, 2] where K is the number of center points.\n            The order of second dim is (y, x).\n    \"\"\"", "\n", "center_points", "=", "find_instance_center", "(", "\n", "center_heatmap", ",", "threshold", "=", "threshold", ",", "nms_kernel", "=", "nms_kernel", ",", "top_k", "=", "top_k", "\n", ")", "\n", "if", "center_points", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "        ", "return", "torch", ".", "zeros_like", "(", "sem_seg", ")", ",", "center_points", ".", "unsqueeze", "(", "0", ")", "\n", "", "ins_seg", "=", "group_pixels", "(", "center_points", ",", "offsets", ")", "\n", "return", "thing_seg", "*", "ins_seg", ",", "center_points", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.merge_semantic_and_instance": [[111, 163], ["collections.Counter", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.zeros_like", "torch.zeros_like", "torch.mode", "torch.mode", "torch.nonzero().size", "torch.nonzero().size", "sem_seg[].view", "class_id.item", "stuff_mask.sum().item", "class_id.item", "class_id.item", "torch.nonzero", "torch.nonzero", "stuff_mask.sum"], "function", ["None"], ["", "def", "merge_semantic_and_instance", "(", "\n", "sem_seg", ",", "ins_seg", ",", "semantic_thing_seg", ",", "label_divisor", ",", "thing_ids", ",", "stuff_area", ",", "void_label", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Post-processing for panoptic segmentation, by merging semantic segmentation\n        label and class agnostic instance segmentation label.\n    Args:\n        sem_seg: A Tensor of shape [1, H, W], predicted category id for each pixel.\n        ins_seg: A Tensor of shape [1, H, W], predicted instance id for each pixel.\n        semantic_thing_seg: A Tensor of shape [1, H, W], predicted foreground mask.\n        label_divisor: An integer, used to convert panoptic id =\n            semantic id * label_divisor + instance_id.\n        thing_ids: Set, a set of ids from contiguous category ids belonging\n            to thing categories.\n        stuff_area: An integer, remove stuff whose area is less tan stuff_area.\n        void_label: An integer, indicates the region has no confident prediction.\n    Returns:\n        A Tensor of shape [1, H, W].\n    \"\"\"", "\n", "# In case thing mask does not align with semantic prediction.", "\n", "pan_seg", "=", "torch", ".", "zeros_like", "(", "sem_seg", ")", "+", "void_label", "\n", "is_thing", "=", "(", "ins_seg", ">", "0", ")", "&", "(", "semantic_thing_seg", ">", "0", ")", "\n", "\n", "# Keep track of instance id for each class.", "\n", "class_id_tracker", "=", "Counter", "(", ")", "\n", "\n", "# Paste thing by majority voting.", "\n", "instance_ids", "=", "torch", ".", "unique", "(", "ins_seg", ")", "\n", "for", "ins_id", "in", "instance_ids", ":", "\n", "        ", "if", "ins_id", "==", "0", ":", "\n", "            ", "continue", "\n", "# Make sure only do majority voting within `semantic_thing_seg`.", "\n", "", "thing_mask", "=", "(", "ins_seg", "==", "ins_id", ")", "&", "is_thing", "\n", "if", "torch", ".", "nonzero", "(", "thing_mask", ")", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "class_id", ",", "_", "=", "torch", ".", "mode", "(", "sem_seg", "[", "thing_mask", "]", ".", "view", "(", "-", "1", ")", ")", "\n", "class_id_tracker", "[", "class_id", ".", "item", "(", ")", "]", "+=", "1", "\n", "new_ins_id", "=", "class_id_tracker", "[", "class_id", ".", "item", "(", ")", "]", "\n", "pan_seg", "[", "thing_mask", "]", "=", "class_id", "*", "label_divisor", "+", "new_ins_id", "\n", "\n", "# Paste stuff to unoccupied area.", "\n", "", "class_ids", "=", "torch", ".", "unique", "(", "sem_seg", ")", "\n", "for", "class_id", "in", "class_ids", ":", "\n", "        ", "if", "class_id", ".", "item", "(", ")", "in", "thing_ids", ":", "\n", "# thing class", "\n", "            ", "continue", "\n", "# Calculate stuff area.", "\n", "", "stuff_mask", "=", "(", "sem_seg", "==", "class_id", ")", "&", "(", "ins_seg", "==", "0", ")", "\n", "if", "stuff_mask", ".", "sum", "(", ")", ".", "item", "(", ")", ">=", "stuff_area", ":", "\n", "            ", "pan_seg", "[", "stuff_mask", "]", "=", "class_id", "*", "label_divisor", "\n", "\n", "", "", "return", "pan_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.get_panoptic_segmentation": [[165, 235], ["post_processing.get_instance_segmentation", "post_processing.merge_semantic_and_instance", "ValueError", "center_heatmap.dim", "ValueError", "offsets.dim", "ValueError", "torch.zeros_like", "torch.zeros_like", "list", "sem_seg.dim", "sem_seg.size", "ValueError", "sem_seg.size", "center_heatmap.dim", "offsets.dim", "foreground_mask.dim", "foreground_mask.size", "sem_seg.size"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.get_instance_segmentation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.post_processing.merge_semantic_and_instance", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "get_panoptic_segmentation", "(", "\n", "sem_seg", ",", "\n", "center_heatmap", ",", "\n", "offsets", ",", "\n", "thing_ids", ",", "\n", "label_divisor", ",", "\n", "stuff_area", ",", "\n", "void_label", ",", "\n", "threshold", "=", "0.1", ",", "\n", "nms_kernel", "=", "7", ",", "\n", "top_k", "=", "200", ",", "\n", "foreground_mask", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Post-processing for panoptic segmentation.\n    Args:\n        sem_seg: A Tensor of shape [1, H, W] of predicted semantic label.\n        center_heatmap: A Tensor of shape [1, H, W] of raw center heatmap output.\n        offsets: A Tensor of shape [2, H, W] of raw offset output. The order of\n            second dim is (offset_y, offset_x).\n        thing_ids: A set of ids from contiguous category ids belonging\n            to thing categories.\n        label_divisor: An integer, used to convert panoptic id =\n            semantic id * label_divisor + instance_id.\n        stuff_area: An integer, remove stuff whose area is less tan stuff_area.\n        void_label: An integer, indicates the region has no confident prediction.\n        threshold: A float, threshold applied to center heatmap score.\n        nms_kernel: An integer, NMS max pooling kernel size.\n        top_k: An integer, top k centers to keep.\n        foreground_mask: Optional, A Tensor of shape [1, H, W] of predicted\n            binary foreground mask. If not provided, it will be generated from\n            sem_seg.\n    Returns:\n        A Tensor of shape [1, H, W], int64.\n    \"\"\"", "\n", "if", "sem_seg", ".", "dim", "(", ")", "!=", "3", "and", "sem_seg", ".", "size", "(", "0", ")", "!=", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"Semantic prediction with un-supported shape: {}.\"", ".", "format", "(", "sem_seg", ".", "size", "(", ")", ")", ")", "\n", "", "if", "center_heatmap", ".", "dim", "(", ")", "!=", "3", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Center prediction with un-supported dimension: {}.\"", ".", "format", "(", "center_heatmap", ".", "dim", "(", ")", ")", "\n", ")", "\n", "", "if", "offsets", ".", "dim", "(", ")", "!=", "3", ":", "\n", "        ", "raise", "ValueError", "(", "\"Offset prediction with un-supported dimension: {}.\"", ".", "format", "(", "offsets", ".", "dim", "(", ")", ")", ")", "\n", "", "if", "foreground_mask", "is", "not", "None", ":", "\n", "        ", "if", "foreground_mask", ".", "dim", "(", ")", "!=", "3", "and", "foreground_mask", ".", "size", "(", "0", ")", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Foreground prediction with un-supported shape: {}.\"", ".", "format", "(", "sem_seg", ".", "size", "(", ")", ")", "\n", ")", "\n", "", "thing_seg", "=", "foreground_mask", "\n", "", "else", ":", "\n", "# inference from semantic segmentation", "\n", "        ", "thing_seg", "=", "torch", ".", "zeros_like", "(", "sem_seg", ")", "\n", "for", "thing_class", "in", "list", "(", "thing_ids", ")", ":", "\n", "            ", "thing_seg", "[", "sem_seg", "==", "thing_class", "]", "=", "1", "\n", "\n", "", "", "instance", ",", "center", "=", "get_instance_segmentation", "(", "\n", "sem_seg", ",", "\n", "center_heatmap", ",", "\n", "offsets", ",", "\n", "thing_seg", ",", "\n", "thing_ids", ",", "\n", "threshold", "=", "threshold", ",", "\n", "nms_kernel", "=", "nms_kernel", ",", "\n", "top_k", "=", "top_k", ",", "\n", ")", "\n", "panoptic", "=", "merge_semantic_and_instance", "(", "\n", "sem_seg", ",", "instance", ",", "thing_seg", ",", "label_divisor", ",", "thing_ids", ",", "stuff_area", ",", "void_label", "\n", ")", "\n", "\n", "return", "panoptic", ",", "center", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.dataset_mapper.PanopticDeeplabDatasetMapper.__init__": [[28, 53], ["detectron2.data.transforms.AugmentationList", "logging.getLogger", "logging.getLogger.info", "str"], "methods", ["None"], ["\n", "\n", "@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "is_train", ":", "bool", ",", "\n", "*", ",", "\n", "augmentations", ":", "List", "[", "Union", "[", "T", ".", "Augmentation", ",", "T", ".", "Transform", "]", "]", ",", "\n", "image_format", ":", "str", ",", "\n", "use_instance_mask", ":", "bool", "=", "False", ",", "\n", "use_keypoint", ":", "bool", "=", "False", ",", "\n", "instance_mask_format", ":", "str", "=", "\"polygon\"", ",", "\n", "keypoint_hflip_indices", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "precomputed_proposal_topk", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "recompute_boxes", ":", "bool", "=", "False", "\n", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.dataset_mapper.PanopticDeeplabDatasetMapper.from_config": [[54, 86], ["augs.append", "detectron2.data.MetadataCatalog.get", "target_generator.PanopticDeepLabTargetGenerator", "detectron2.data.transforms.ResizeShortestEdge", "augs.append", "detectron2.data.transforms.RandomFlip", "detectron2.data.transforms.RandomCrop", "list", "detectron2.data.MetadataCatalog.get.thing_dataset_id_to_contiguous_id.values"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["\n", "if", "recompute_boxes", ":", "\n", "            ", "assert", "use_instance_mask", ",", "\"recompute_boxes requires instance masks\"", "\n", "# fmt: off", "\n", "", "self", ".", "is_train", "=", "is_train", "\n", "self", ".", "augmentations", "=", "T", ".", "AugmentationList", "(", "augmentations", ")", "\n", "self", ".", "image_format", "=", "image_format", "\n", "self", ".", "use_instance_mask", "=", "use_instance_mask", "\n", "self", ".", "instance_mask_format", "=", "instance_mask_format", "\n", "self", ".", "use_keypoint", "=", "use_keypoint", "\n", "self", ".", "keypoint_hflip_indices", "=", "keypoint_hflip_indices", "\n", "self", ".", "proposal_topk", "=", "precomputed_proposal_topk", "\n", "self", ".", "recompute_boxes", "=", "recompute_boxes", "\n", "# fmt: on", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Augmentations used in training: \"", "+", "str", "(", "augmentations", ")", ")", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "is_train", ":", "bool", "=", "True", ")", ":", "\n", "        ", "augs", "=", "utils", ".", "build_augmentation", "(", "cfg", ",", "is_train", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.panoptic_deeplab.dataset_mapper.PanopticDeeplabDatasetMapper.__call__": [[87, 117], ["copy.deepcopy", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.check_image_size", "detectron2.data.detection_utils.read_image", "detectron2.data.transforms.AugInput", "dataset_mapper.PanopticDeeplabDatasetMapper.augmentations", "torch.as_tensor", "dataset_mapper.PanopticDeeplabDatasetMapper.panoptic_target_generator", "copy.deepcopy.update", "copy.deepcopy.pop", "numpy.ascontiguousarray", "panopticapi.utils.rgb2id", "detectron2.data.detection_utils.read_image.transpose"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.read_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.check_image_size", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.read_image"], ["if", "cfg", ".", "INPUT", ".", "CROP", ".", "ENABLED", "and", "is_train", ":", "\n", "            ", "augs", ".", "insert", "(", "0", ",", "T", ".", "RandomCrop", "(", "cfg", ".", "INPUT", ".", "CROP", ".", "TYPE", ",", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", ")", ")", "\n", "recompute_boxes", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "", "else", ":", "\n", "            ", "recompute_boxes", "=", "False", "\n", "\n", "", "ret", "=", "{", "\n", "\"is_train\"", ":", "is_train", ",", "\n", "\"augmentations\"", ":", "augs", ",", "\n", "\"image_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "\"use_instance_mask\"", ":", "cfg", ".", "MODEL", ".", "MASK_ON", ",", "\n", "\"instance_mask_format\"", ":", "cfg", ".", "INPUT", ".", "MASK_FORMAT", ",", "\n", "\"use_keypoint\"", ":", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ",", "\n", "\"recompute_boxes\"", ":", "recompute_boxes", ",", "\n", "}", "\n", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "ret", "[", "\"keypoint_hflip_indices\"", "]", "=", "utils", ".", "create_keypoint_hflip_indices", "(", "cfg", ".", "DATASETS", ".", "TRAIN", ")", "\n", "\n", "", "if", "cfg", ".", "MODEL", ".", "LOAD_PROPOSALS", ":", "\n", "            ", "ret", "[", "\"precomputed_proposal_topk\"", "]", "=", "(", "\n", "cfg", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TRAIN", "\n", "if", "is_train", "\n", "else", "cfg", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TEST", "\n", ")", "\n", "", "return", "ret", "\n", "\n", "", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.TensorMask.setup.get_extensions": [[11, 59], ["os.path.dirname", "os.path.join", "os.path.join", "glob.glob", "os.path.abspath", "os.path.join", "glob.glob", "glob.glob", "os.environ.get", "os.path.join", "extension", "os.path.join", "os.path.join", "torch.cuda.is_available", "os.getenv", "extra_compile_args[].append"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["from", "torch", ".", "utils", ".", "cpp_extension", "import", "CUDA_HOME", ",", "CppExtension", ",", "CUDAExtension", "\n", "from", "torch", ".", "utils", ".", "hipify", "import", "hipify_python", "\n", "\n", "torch_ver", "=", "[", "int", "(", "x", ")", "for", "x", "in", "torch", ".", "__version__", ".", "split", "(", "\".\"", ")", "[", ":", "2", "]", "]", "\n", "assert", "torch_ver", ">=", "[", "1", ",", "4", "]", ",", "\"Requires PyTorch >= 1.4\"", "\n", "\n", "\n", "def", "get_version", "(", ")", ":", "\n", "    ", "init_py_path", "=", "path", ".", "join", "(", "path", ".", "abspath", "(", "path", ".", "dirname", "(", "__file__", ")", ")", ",", "\"detectron2\"", ",", "\"__init__.py\"", ")", "\n", "init_py", "=", "open", "(", "init_py_path", ",", "\"r\"", ")", ".", "readlines", "(", ")", "\n", "version_line", "=", "[", "l", ".", "strip", "(", ")", "for", "l", "in", "init_py", "if", "l", ".", "startswith", "(", "\"__version__\"", ")", "]", "[", "0", "]", "\n", "version", "=", "version_line", ".", "split", "(", "\"=\"", ")", "[", "-", "1", "]", ".", "strip", "(", ")", ".", "strip", "(", "\"'\\\"\"", ")", "\n", "\n", "# The following is used to build release packages.", "\n", "# Users should never use it.", "\n", "suffix", "=", "os", ".", "getenv", "(", "\"D2_VERSION_SUFFIX\"", ",", "\"\"", ")", "\n", "version", "=", "version", "+", "suffix", "\n", "if", "os", ".", "getenv", "(", "\"BUILD_NIGHTLY\"", ",", "\"0\"", ")", "==", "\"1\"", ":", "\n", "        ", "from", "datetime", "import", "datetime", "\n", "\n", "date_str", "=", "datetime", ".", "today", "(", ")", ".", "strftime", "(", "\"%y%m%d\"", ")", "\n", "version", "=", "version", "+", "\".dev\"", "+", "date_str", "\n", "\n", "new_init_py", "=", "[", "l", "for", "l", "in", "init_py", "if", "not", "l", ".", "startswith", "(", "\"__version__\"", ")", "]", "\n", "new_init_py", ".", "append", "(", "'__version__ = \"{}\"\\n'", ".", "format", "(", "version", ")", ")", "\n", "with", "open", "(", "init_py_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "\"\"", ".", "join", "(", "new_init_py", ")", ")", "\n", "", "", "return", "version", "\n", "\n", "\n", "", "def", "get_extensions", "(", ")", ":", "\n", "    ", "this_dir", "=", "path", ".", "dirname", "(", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "extensions_dir", "=", "path", ".", "join", "(", "this_dir", ",", "\"detectron2\"", ",", "\"layers\"", ",", "\"csrc\"", ")", "\n", "\n", "main_source", "=", "path", ".", "join", "(", "extensions_dir", ",", "\"vision.cpp\"", ")", "\n", "sources", "=", "glob", ".", "glob", "(", "path", ".", "join", "(", "extensions_dir", ",", "\"**\"", ",", "\"*.cpp\"", ")", ")", "\n", "\n", "is_rocm_pytorch", "=", "False", "\n", "if", "torch_ver", ">=", "[", "1", ",", "5", "]", ":", "\n", "        ", "from", "torch", ".", "utils", ".", "cpp_extension", "import", "ROCM_HOME", "\n", "\n", "is_rocm_pytorch", "=", "(", "\n", "True", "if", "(", "(", "torch", ".", "version", ".", "hip", "is", "not", "None", ")", "and", "(", "ROCM_HOME", "is", "not", "None", ")", ")", "else", "False", "\n", ")", "\n", "\n", "", "if", "is_rocm_pytorch", ":", "\n", "        ", "hipify_python", ".", "hipify", "(", "\n", "project_directory", "=", "this_dir", ",", "\n", "output_directory", "=", "this_dir", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.TensorMask.train_net.Trainer.build_evaluator": [[22, 27], ["detectron2.evaluation.COCOEvaluator", "os.path.join"], "methods", ["None"], ["import", "torch", "\n", "\n", "import", "detectron2", ".", "utils", ".", "comm", "as", "comm", "\n", "from", "detectron2", ".", "checkpoint", "import", "DetectionCheckpointer", "\n", "from", "detectron2", ".", "config", "import", "get_cfg", "\n", "from", "detectron2", ".", "data", "import", "MetadataCatalog", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.TensorMask.train_net.setup": [[29, 40], ["detectron2.config.get_cfg", "tensormask.add_tensormask_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.config.add_tensormask_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup"], ["from", "detectron2", ".", "evaluation", "import", "(", "\n", "CityscapesInstanceEvaluator", ",", "\n", "CityscapesSemSegEvaluator", ",", "\n", "COCOEvaluator", ",", "\n", "COCOPanopticEvaluator", ",", "\n", "DatasetEvaluators", ",", "\n", "LVISEvaluator", ",", "\n", "PascalVOCDetectionEvaluator", ",", "\n", "SemSegEvaluator", ",", "\n", "verify_results", ",", "\n", ")", "\n", "from", "detectron2", ".", "modeling", "import", "GeneralizedRCNNWithTTA", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.TensorMask.train_net.main": [[42, 58], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.is_main_process", "detectron2.evaluation.verify_results", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.verify_results"], ["\n", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "    ", "\"\"\"\n    We use the \"DefaultTrainer\" which contains pre-defined default logic for\n    standard training workflow. They may not work for you, especially if you\n    are working on a new research project. In that case you can write your\n    own training loop. You can use \"tools/plain_train_net.py\" as an example.\n    \"\"\"", "\n", "\n", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Create evaluator(s) for a given dataset.\n        This uses the special metadata \"evaluator_type\" associated with each builtin dataset.\n        For your own dataset, you can simply create an evaluator manually in your\n        script and do not have to worry about the hacky if-else logic here.\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.config.add_tensormask_config": [[7, 51], ["detectron2.config.CfgNode"], "function", ["None"], ["from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "", "else", ":", "\n", "# compat.py needs to import CfgNode", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMaskAnchorGenerator.grid_anchors_with_unit_lengths_and_indexes": [[235, 269], ["enumerate", "zip", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "anchors.append", "unit_lengths.append", "torch.full", "torch.full", "torch.full", "torch.full", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "indexes.append", "torch.full", "torch.full", "torch.full", "torch.full", "torch.stack().view", "torch.stack().view", "torch.stack().view", "torch.stack().view", "base_anchors.view", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["None"], ["def", "grid_anchors_with_unit_lengths_and_indexes", "(", "self", ",", "grid_sizes", ")", ":", "\n", "        ", "anchors", "=", "[", "]", "\n", "unit_lengths", "=", "[", "]", "\n", "indexes", "=", "[", "]", "\n", "for", "lvl", ",", "(", "size", ",", "stride", ",", "base_anchors", ")", "in", "enumerate", "(", "\n", "zip", "(", "grid_sizes", ",", "self", ".", "strides", ",", "self", ".", "cell_anchors", ")", "\n", ")", ":", "\n", "            ", "grid_height", ",", "grid_width", "=", "size", "\n", "device", "=", "base_anchors", ".", "device", "\n", "shifts_x", "=", "torch", ".", "arange", "(", "\n", "0", ",", "grid_width", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shifts_y", "=", "torch", ".", "arange", "(", "\n", "0", ",", "grid_height", "*", "stride", ",", "step", "=", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shift_y", ",", "shift_x", "=", "torch", ".", "meshgrid", "(", "shifts_y", ",", "shifts_x", ")", "\n", "shifts", "=", "torch", ".", "stack", "(", "(", "shift_x", ",", "shift_y", ",", "shift_x", ",", "shift_y", ")", ",", "dim", "=", "2", ")", "\n", "# Stack anchors in shapes of (HWA, 4)", "\n", "cur_anchor", "=", "(", "shifts", "[", ":", ",", ":", ",", "None", ",", ":", "]", "+", "base_anchors", ".", "view", "(", "1", ",", "1", ",", "-", "1", ",", "4", ")", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "anchors", ".", "append", "(", "cur_anchor", ")", "\n", "unit_lengths", ".", "append", "(", "\n", "torch", ".", "full", "(", "(", "cur_anchor", ".", "shape", "[", "0", "]", ",", ")", ",", "stride", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", ")", "\n", "# create mask indexes using mesh grid", "\n", "shifts_l", "=", "torch", ".", "full", "(", "(", "1", ",", ")", ",", "lvl", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "shifts_i", "=", "torch", ".", "zeros", "(", "(", "1", ",", ")", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "shifts_h", "=", "torch", ".", "arange", "(", "0", ",", "grid_height", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "shifts_w", "=", "torch", ".", "arange", "(", "0", ",", "grid_width", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "shifts_a", "=", "torch", ".", "arange", "(", "0", ",", "base_anchors", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "grids", "=", "torch", ".", "meshgrid", "(", "shifts_l", ",", "shifts_i", ",", "shifts_h", ",", "shifts_w", ",", "shifts_a", ")", "\n", "\n", "indexes", ".", "append", "(", "torch", ".", "stack", "(", "grids", ",", "dim", "=", "5", ")", ".", "view", "(", "-", "1", ",", "5", ")", ")", "\n", "\n", "", "return", "anchors", ",", "unit_lengths", ",", "indexes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMaskAnchorGenerator.forward": [[270, 298], ["len", "arch.TensorMaskAnchorGenerator.grid_anchors_with_unit_lengths_and_indexes", "detectron2.structures.Boxes", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMaskAnchorGenerator.grid_anchors_with_unit_lengths_and_indexes"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[list[Boxes]]: a list of #image elements. Each is a list of #feature level Boxes.\n                The Boxes contains anchors of this image on the specific feature level.\n            list[list[Tensor]]: a list of #image elements. Each is a list of #feature level tensors.\n                The tensor contains strides, or unit lengths for the anchors.\n            list[list[Tensor]]: a list of #image elements. Each is a list of #feature level tensors.\n                The Tensor contains indexes for the anchors, with the last dimension meaning\n                (L, N, H, W, A), where L is level, I is image (not set yet), H is height,\n                W is width, and A is anchor.\n        \"\"\"", "\n", "num_images", "=", "len", "(", "features", "[", "0", "]", ")", "\n", "grid_sizes", "=", "[", "feature_map", ".", "shape", "[", "-", "2", ":", "]", "for", "feature_map", "in", "features", "]", "\n", "anchors_list", ",", "lengths_list", ",", "indexes_list", "=", "self", ".", "grid_anchors_with_unit_lengths_and_indexes", "(", "\n", "grid_sizes", "\n", ")", "\n", "\n", "# Convert anchors from Tensor to Boxes", "\n", "anchors_per_im", "=", "[", "Boxes", "(", "x", ")", "for", "x", "in", "anchors_list", "]", "\n", "\n", "# TODO it can be simplified to not return duplicated information for", "\n", "# each image, just like detectron2's own AnchorGenerator", "\n", "anchors", "=", "[", "copy", ".", "deepcopy", "(", "anchors_per_im", ")", "for", "_", "in", "range", "(", "num_images", ")", "]", "\n", "unit_lengths", "=", "[", "copy", ".", "deepcopy", "(", "lengths_list", ")", "for", "_", "in", "range", "(", "num_images", ")", "]", "\n", "indexes", "=", "[", "copy", ".", "deepcopy", "(", "indexes_list", ")", "for", "_", "in", "range", "(", "num_images", ")", "]", "\n", "\n", "return", "anchors", ",", "unit_lengths", ",", "indexes", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.__init__": [[308, 353], ["torch.nn.Module.__init__", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "detectron2.modeling.backbone.build_backbone", "arch.TensorMask.backbone.output_shape", "arch.TensorMaskAnchorGenerator", "arch.TensorMaskHead", "detectron2.modeling.box_regression.Box2BoxTransform", "arch.TensorMask.register_buffer", "arch.TensorMask.register_buffer", "min", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.build.build_backbone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.backbone.Backbone.output_shape"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "num_classes", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "NUM_CLASSES", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "IN_FEATURES", "\n", "self", ".", "anchor_sizes", "=", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "\n", "self", ".", "num_levels", "=", "len", "(", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", ")", "\n", "# Loss parameters:", "\n", "self", ".", "focal_loss_alpha", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "FOCAL_LOSS_ALPHA", "\n", "self", ".", "focal_loss_gamma", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "FOCAL_LOSS_GAMMA", "\n", "# Inference parameters:", "\n", "self", ".", "score_threshold", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "SCORE_THRESH_TEST", "\n", "self", ".", "topk_candidates", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "TOPK_CANDIDATES_TEST", "\n", "self", ".", "nms_threshold", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "NMS_THRESH_TEST", "\n", "self", ".", "detections_im", "=", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", "\n", "# Mask parameters:", "\n", "self", ".", "mask_on", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "self", ".", "mask_loss_weight", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "MASK_LOSS_WEIGHT", "\n", "self", ".", "mask_pos_weight", "=", "torch", ".", "tensor", "(", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "POSITIVE_WEIGHT", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "self", ".", "bipyramid_on", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "BIPYRAMID_ON", "\n", "# fmt: on", "\n", "\n", "# build the backbone", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "\n", "backbone_shape", "=", "self", ".", "backbone", ".", "output_shape", "(", ")", "\n", "feature_shapes", "=", "[", "backbone_shape", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "feature_strides", "=", "[", "x", ".", "stride", "for", "x", "in", "feature_shapes", "]", "\n", "# build anchors", "\n", "self", ".", "anchor_generator", "=", "TensorMaskAnchorGenerator", "(", "cfg", ",", "feature_shapes", ")", "\n", "self", ".", "num_anchors", "=", "self", ".", "anchor_generator", ".", "num_cell_anchors", "[", "0", "]", "\n", "anchors_min_level", "=", "cfg", ".", "MODEL", ".", "ANCHOR_GENERATOR", ".", "SIZES", "[", "0", "]", "\n", "self", ".", "mask_sizes", "=", "[", "size", "//", "feature_strides", "[", "0", "]", "for", "size", "in", "anchors_min_level", "]", "\n", "self", ".", "min_anchor_size", "=", "min", "(", "anchors_min_level", ")", "-", "feature_strides", "[", "0", "]", "\n", "\n", "# head of the TensorMask", "\n", "self", ".", "head", "=", "TensorMaskHead", "(", "\n", "cfg", ",", "self", ".", "num_levels", ",", "self", ".", "num_anchors", ",", "self", ".", "mask_sizes", ",", "feature_shapes", "\n", ")", "\n", "# box transform", "\n", "self", ".", "box2box_transform", "=", "Box2BoxTransform", "(", "weights", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "BBOX_REG_WEIGHTS", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device": [[354, 357], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.forward": [[358, 415], ["arch.TensorMask.preprocess_image", "arch.TensorMask.backbone", "arch.TensorMask.head", "arch.TensorMask.anchor_generator", "arch.TensorMask.get_ground_truth", "arch.TensorMask.losses", "arch.TensorMask.inference", "zip", "x[].to", "input_im.get", "input_im.get", "arch._postprocess", "processed_results.append"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.preprocess_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.get_ground_truth", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch._postprocess"], ["", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DetectionTransform` .\n                Each item in the list contains the inputs for one image.\n            For now, each item in the list is a dict that contains:\n                image: Tensor, image in (C, H, W) format.\n                instances: Instances\n                Other information that's included in the original dicts, such as:\n                    \"height\", \"width\" (int): the output resolution of the model, used in inference.\n                        See :meth:`postprocess` for details.\n         Returns:\n            losses (dict[str: Tensor]): mapping from a named loss to a tensor\n                storing the loss. Used during training only.\n        \"\"\"", "\n", "images", "=", "self", ".", "preprocess_image", "(", "batched_inputs", ")", "\n", "if", "\"instances\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "gt_instances", "=", "[", "x", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "", "else", ":", "\n", "            ", "gt_instances", "=", "None", "\n", "\n", "", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "# apply the TensorMask head", "\n", "pred_logits", ",", "pred_deltas", ",", "pred_masks", "=", "self", ".", "head", "(", "features", ")", "\n", "# generate anchors based on features, is it image specific?", "\n", "anchors", ",", "unit_lengths", ",", "indexes", "=", "self", ".", "anchor_generator", "(", "features", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "# get ground truths for class labels and box targets, it will label each anchor", "\n", "            ", "gt_class_info", ",", "gt_delta_info", ",", "gt_mask_info", ",", "num_fg", "=", "self", ".", "get_ground_truth", "(", "\n", "anchors", ",", "unit_lengths", ",", "indexes", ",", "gt_instances", "\n", ")", "\n", "# compute the loss", "\n", "return", "self", ".", "losses", "(", "\n", "gt_class_info", ",", "\n", "gt_delta_info", ",", "\n", "gt_mask_info", ",", "\n", "num_fg", ",", "\n", "pred_logits", ",", "\n", "pred_deltas", ",", "\n", "pred_masks", ",", "\n", ")", "\n", "", "else", ":", "\n", "# do inference to get the output", "\n", "            ", "results", "=", "self", ".", "inference", "(", "pred_logits", ",", "pred_deltas", ",", "pred_masks", ",", "anchors", ",", "indexes", ",", "images", ")", "\n", "processed_results", "=", "[", "]", "\n", "for", "results_im", ",", "input_im", ",", "image_size", "in", "zip", "(", "\n", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", "\n", ")", ":", "\n", "                ", "height", "=", "input_im", ".", "get", "(", "\"height\"", ",", "image_size", "[", "0", "]", ")", "\n", "width", "=", "input_im", ".", "get", "(", "\"width\"", ",", "image_size", "[", "1", "]", ")", "\n", "# this is to do post-processing with the image size", "\n", "result_box", ",", "result_mask", "=", "results_im", "\n", "r", "=", "_postprocess", "(", "result_box", ",", "result_mask", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"instances\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.losses": [[416, 501], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "arch.permute_all_cls_and_box_to_N_HWA_K_and_concat", "max", "fvcore.nn.sigmoid_focal_loss_star_jit", "range", "pred_deltas.sum", "fvcore.nn.smooth_l1_loss", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "cur_pred_masks.view", "[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.permute_all_cls_and_box_to_N_HWA_K_and_concat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "", "def", "losses", "(", "\n", "self", ",", "\n", "gt_class_info", ",", "\n", "gt_delta_info", ",", "\n", "gt_mask_info", ",", "\n", "num_fg", ",", "\n", "pred_logits", ",", "\n", "pred_deltas", ",", "\n", "pred_masks", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            For `gt_class_info`, `gt_delta_info`, `gt_mask_info` and `num_fg` parameters, see\n                :meth:`TensorMask.get_ground_truth`.\n            For `pred_logits`, `pred_deltas` and `pred_masks`, see\n                :meth:`TensorMaskHead.forward`.\n\n        Returns:\n            losses (dict[str: Tensor]): mapping from a named loss to a scalar tensor\n                storing the loss. Used during training only. The potential dict keys are:\n                \"loss_cls\", \"loss_box_reg\" and \"loss_mask\".\n        \"\"\"", "\n", "gt_classes_target", ",", "gt_valid_inds", "=", "gt_class_info", "\n", "gt_deltas", ",", "gt_fg_inds", "=", "gt_delta_info", "\n", "gt_masks", ",", "gt_mask_inds", "=", "gt_mask_info", "\n", "loss_normalizer", "=", "torch", ".", "tensor", "(", "max", "(", "1", ",", "num_fg", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# classification and regression", "\n", "pred_logits", ",", "pred_deltas", "=", "permute_all_cls_and_box_to_N_HWA_K_and_concat", "(", "\n", "pred_logits", ",", "pred_deltas", ",", "self", ".", "num_classes", "\n", ")", "\n", "loss_cls", "=", "(", "\n", "sigmoid_focal_loss_star_jit", "(", "\n", "pred_logits", "[", "gt_valid_inds", "]", ",", "\n", "gt_classes_target", "[", "gt_valid_inds", "]", ",", "\n", "alpha", "=", "self", ".", "focal_loss_alpha", ",", "\n", "gamma", "=", "self", ".", "focal_loss_gamma", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "\n", "/", "loss_normalizer", "\n", ")", "\n", "\n", "if", "num_fg", "==", "0", ":", "\n", "            ", "loss_box_reg", "=", "pred_deltas", ".", "sum", "(", ")", "*", "0", "\n", "", "else", ":", "\n", "            ", "loss_box_reg", "=", "(", "\n", "smooth_l1_loss", "(", "pred_deltas", "[", "gt_fg_inds", "]", ",", "gt_deltas", ",", "beta", "=", "0.0", ",", "reduction", "=", "\"sum\"", ")", "\n", "/", "loss_normalizer", "\n", ")", "\n", "", "losses", "=", "{", "\"loss_cls\"", ":", "loss_cls", ",", "\"loss_box_reg\"", ":", "loss_box_reg", "}", "\n", "\n", "# mask prediction", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "loss_mask", "=", "0", "\n", "for", "lvl", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "                ", "cur_level_factor", "=", "2", "**", "lvl", "if", "self", ".", "bipyramid_on", "else", "1", "\n", "for", "anc", "in", "range", "(", "self", ".", "num_anchors", ")", ":", "\n", "                    ", "cur_gt_mask_inds", "=", "gt_mask_inds", "[", "lvl", "]", "[", "anc", "]", "\n", "if", "cur_gt_mask_inds", "is", "None", ":", "\n", "                        ", "loss_mask", "+=", "pred_masks", "[", "lvl", "]", "[", "anc", "]", "[", "0", ",", "0", ",", "0", ",", "0", "]", "*", "0", "\n", "", "else", ":", "\n", "                        ", "cur_mask_size", "=", "self", ".", "mask_sizes", "[", "anc", "]", "*", "cur_level_factor", "\n", "# TODO maybe there are numerical issues when mask sizes are large", "\n", "cur_size_divider", "=", "torch", ".", "tensor", "(", "\n", "self", ".", "mask_loss_weight", "/", "(", "cur_mask_size", "**", "2", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "self", ".", "device", ",", "\n", ")", "\n", "\n", "cur_pred_masks", "=", "pred_masks", "[", "lvl", "]", "[", "anc", "]", "[", "\n", "cur_gt_mask_inds", "[", ":", ",", "0", "]", ",", "# N", "\n", ":", ",", "# V x U", "\n", "cur_gt_mask_inds", "[", ":", ",", "1", "]", ",", "# H", "\n", "cur_gt_mask_inds", "[", ":", ",", "2", "]", ",", "# W", "\n", "]", "\n", "\n", "loss_mask", "+=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "cur_pred_masks", ".", "view", "(", "-", "1", ",", "cur_mask_size", ",", "cur_mask_size", ")", ",", "# V, U", "\n", "gt_masks", "[", "lvl", "]", "[", "anc", "]", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", "weight", "=", "cur_size_divider", ",", "\n", "pos_weight", "=", "self", ".", "mask_pos_weight", ",", "\n", ")", "\n", "", "", "", "losses", "[", "\"loss_mask\"", "]", "=", "loss_mask", "/", "loss_normalizer", "\n", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.get_ground_truth": [[502, 631], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "enumerate", "detectron2.layers.cat", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "detectron2.structures.Boxes.cat", "detectron2.layers.cat", "detectron2.layers.cat", "zip", "torch.full_like", "torch.full_like", "torch.full_like", "torch.full_like", "detectron2.layers.cat.append", "detectron2.layers.cat", "range", "range", "len", "arch._assignment_rule", "len", "arch.TensorMask.box2box_transform.get_deltas", "gt_deltas.append", "range", "range", "range", "detectron2.layers.cat", "detectron2.layers.cat", "torch.any", "torch.any", "torch.any", "torch.any", "range", "torch.any", "torch.any", "torch.any", "torch.any", "[].append", "[].append", "targets_im[].gt_masks.crop_and_resize"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch._assignment_rule", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.get_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.crop_and_resize"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_ground_truth", "(", "self", ",", "anchors", ",", "unit_lengths", ",", "indexes", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            anchors (list[list[Boxes]]): a list of N=#image elements. Each is a\n                list of #feature level Boxes. The Boxes contains anchors of\n                this image on the specific feature level.\n            unit_lengths (list[list[Tensor]]): a list of N=#image elements. Each is a\n                list of #feature level Tensor. The tensor contains unit lengths for anchors of\n                this image on the specific feature level.\n            indexes (list[list[Tensor]]): a list of N=#image elements. Each is a\n                list of #feature level Tensor. The tensor contains the 5D index of\n                each anchor, the second dimension means (L, N, H, W, A), where L\n                is level, I is image, H is height, W is width, and A is anchor.\n            targets (list[Instances]): a list of N `Instances`s. The i-th\n                `Instances` contains the ground-truth per-instance annotations\n                for the i-th input image.  Specify `targets` during training only.\n\n        Returns:\n            gt_class_info (Tensor, Tensor): A pair of two tensors for classification.\n                The first one is an integer tensor of shape (R, #classes) storing ground-truth\n                labels for each anchor. R is the total number of anchors in the batch.\n                The second one is an integer tensor of shape (R,), to indicate which\n                anchors are valid for loss computation, which anchors are not.\n            gt_delta_info (Tensor, Tensor): A pair of two tensors for boxes.\n                The first one, of shape (F, 4). F=#foreground anchors.\n                The last dimension represents ground-truth box2box transform\n                targets (dx, dy, dw, dh) that map each anchor to its matched ground-truth box.\n                Only foreground anchors have values in this tensor. Could be `None` if F=0.\n                The second one, of shape (R,), is an integer tensor indicating which anchors\n                are foreground ones used for box regression. Could be `None` if F=0.\n            gt_mask_info (list[list[Tensor]], list[list[Tensor]]): A pair of two lists for masks.\n                The first one is a list of P=#feature level elements. Each is a\n                list of A=#anchor tensors. Each tensor contains the ground truth\n                masks of the same size and for the same feature level. Could be `None`.\n                The second one is a list of P=#feature level elements. Each is a\n                list of A=#anchor tensors. Each tensor contains the location of the ground truth\n                masks of the same size and for the same feature level. The second dimension means\n                (N, H, W), where N is image, H is height, and W is width. Could be `None`.\n            num_fg (int): F=#foreground anchors, used later for loss normalization.\n        \"\"\"", "\n", "gt_classes", "=", "[", "]", "\n", "gt_deltas", "=", "[", "]", "\n", "gt_masks", "=", "[", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "num_anchors", ")", "]", "for", "_", "in", "range", "(", "self", ".", "num_levels", ")", "]", "\n", "gt_mask_inds", "=", "[", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "num_anchors", ")", "]", "for", "_", "in", "range", "(", "self", ".", "num_levels", ")", "]", "\n", "\n", "anchors", "=", "[", "Boxes", ".", "cat", "(", "anchors_i", ")", "for", "anchors_i", "in", "anchors", "]", "\n", "unit_lengths", "=", "[", "cat", "(", "unit_lengths_i", ")", "for", "unit_lengths_i", "in", "unit_lengths", "]", "\n", "indexes", "=", "[", "cat", "(", "indexes_i", ")", "for", "indexes_i", "in", "indexes", "]", "\n", "\n", "num_fg", "=", "0", "\n", "for", "i", ",", "(", "anchors_im", ",", "unit_lengths_im", ",", "indexes_im", ",", "targets_im", ")", "in", "enumerate", "(", "\n", "zip", "(", "anchors", ",", "unit_lengths", ",", "indexes", ",", "targets", ")", "\n", ")", ":", "\n", "# Initialize all", "\n", "            ", "gt_classes_i", "=", "torch", ".", "full_like", "(", "\n", "unit_lengths_im", ",", "self", ".", "num_classes", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "self", ".", "device", "\n", ")", "\n", "# Ground truth classes", "\n", "has_gt", "=", "len", "(", "targets_im", ")", ">", "0", "\n", "if", "has_gt", ":", "\n", "# Compute the pairwise matrix", "\n", "                ", "gt_matched_inds", ",", "anchor_labels", "=", "_assignment_rule", "(", "\n", "targets_im", ".", "gt_boxes", ",", "anchors_im", ",", "unit_lengths_im", ",", "self", ".", "min_anchor_size", "\n", ")", "\n", "# Find the foreground instances", "\n", "fg_inds", "=", "anchor_labels", "==", "1", "\n", "fg_anchors", "=", "anchors_im", "[", "fg_inds", "]", "\n", "num_fg", "+=", "len", "(", "fg_anchors", ")", "\n", "# Find the ground truths for foreground instances", "\n", "gt_fg_matched_inds", "=", "gt_matched_inds", "[", "fg_inds", "]", "\n", "# Assign labels for foreground instances", "\n", "gt_classes_i", "[", "fg_inds", "]", "=", "targets_im", ".", "gt_classes", "[", "gt_fg_matched_inds", "]", "\n", "# Anchors with label -1 are ignored, others are left as negative", "\n", "gt_classes_i", "[", "anchor_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "\n", "# Boxes", "\n", "# Ground truth box regression, only for foregrounds", "\n", "matched_gt_boxes", "=", "targets_im", "[", "gt_fg_matched_inds", "]", ".", "gt_boxes", "\n", "# Compute box regression offsets for foregrounds only", "\n", "gt_deltas_i", "=", "self", ".", "box2box_transform", ".", "get_deltas", "(", "\n", "fg_anchors", ".", "tensor", ",", "matched_gt_boxes", ".", "tensor", "\n", ")", "\n", "gt_deltas", ".", "append", "(", "gt_deltas_i", ")", "\n", "\n", "# Masks", "\n", "if", "self", ".", "mask_on", ":", "\n", "# Compute masks for each level and each anchor", "\n", "                    ", "matched_indexes", "=", "indexes_im", "[", "fg_inds", ",", ":", "]", "\n", "for", "lvl", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "                        ", "ids_lvl", "=", "matched_indexes", "[", ":", ",", "0", "]", "==", "lvl", "\n", "if", "torch", ".", "any", "(", "ids_lvl", ")", ":", "\n", "                            ", "cur_level_factor", "=", "2", "**", "lvl", "if", "self", ".", "bipyramid_on", "else", "1", "\n", "for", "anc", "in", "range", "(", "self", ".", "num_anchors", ")", ":", "\n", "                                ", "ids_lvl_anchor", "=", "ids_lvl", "&", "(", "matched_indexes", "[", ":", ",", "4", "]", "==", "anc", ")", "\n", "if", "torch", ".", "any", "(", "ids_lvl_anchor", ")", ":", "\n", "                                    ", "gt_masks", "[", "lvl", "]", "[", "anc", "]", ".", "append", "(", "\n", "targets_im", "[", "\n", "gt_fg_matched_inds", "[", "ids_lvl_anchor", "]", "\n", "]", ".", "gt_masks", ".", "crop_and_resize", "(", "\n", "fg_anchors", "[", "ids_lvl_anchor", "]", ".", "tensor", ",", "\n", "self", ".", "mask_sizes", "[", "anc", "]", "*", "cur_level_factor", ",", "\n", ")", "\n", ")", "\n", "# Select (N, H, W) dimensions", "\n", "gt_mask_inds_lvl_anc", "=", "matched_indexes", "[", "ids_lvl_anchor", ",", "1", ":", "4", "]", "\n", "# Set the image index to the current image", "\n", "gt_mask_inds_lvl_anc", "[", ":", ",", "0", "]", "=", "i", "\n", "gt_mask_inds", "[", "lvl", "]", "[", "anc", "]", ".", "append", "(", "gt_mask_inds_lvl_anc", ")", "\n", "", "", "", "", "", "", "gt_classes", ".", "append", "(", "gt_classes_i", ")", "\n", "\n", "# Classes and boxes", "\n", "", "gt_classes", "=", "cat", "(", "gt_classes", ")", "\n", "gt_valid_inds", "=", "gt_classes", ">=", "0", "\n", "gt_fg_inds", "=", "gt_valid_inds", "&", "(", "gt_classes", "<", "self", ".", "num_classes", ")", "\n", "gt_classes_target", "=", "torch", ".", "zeros", "(", "\n", "(", "gt_classes", ".", "shape", "[", "0", "]", ",", "self", ".", "num_classes", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", "\n", ")", "\n", "gt_classes_target", "[", "gt_fg_inds", ",", "gt_classes", "[", "gt_fg_inds", "]", "]", "=", "1", "\n", "gt_deltas", "=", "cat", "(", "gt_deltas", ")", "if", "gt_deltas", "else", "None", "\n", "\n", "# Masks", "\n", "gt_masks", "=", "[", "[", "cat", "(", "mla", ")", "if", "mla", "else", "None", "for", "mla", "in", "ml", "]", "for", "ml", "in", "gt_masks", "]", "\n", "gt_mask_inds", "=", "[", "[", "cat", "(", "ila", ")", "if", "ila", "else", "None", "for", "ila", "in", "il", "]", "for", "il", "in", "gt_mask_inds", "]", "\n", "return", "(", "\n", "(", "gt_classes_target", ",", "gt_valid_inds", ")", ",", "\n", "(", "gt_deltas", ",", "gt_fg_inds", ")", ",", "\n", "(", "gt_masks", ",", "gt_mask_inds", ")", ",", "\n", "num_fg", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference": [[633, 674], ["detectron2.layers.cat", "detectron2.layers.cat", "enumerate", "len", "len", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "zip", "arch.TensorMask.inference_single_image", "results.append", "detectron2.structures.Boxes.cat", "detectron2.layers.cat", "tuple"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference_single_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "inference", "(", "self", ",", "pred_logits", ",", "pred_deltas", ",", "pred_masks", ",", "anchors", ",", "indexes", ",", "images", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            pred_logits, pred_deltas, pred_masks: Same as the output of:\n                meth:`TensorMaskHead.forward`\n            anchors, indexes: Same as the input of meth:`TensorMask.get_ground_truth`\n            images (ImageList): the input images\n\n        Returns:\n            results (List[Instances]): a list of #images elements.\n        \"\"\"", "\n", "assert", "len", "(", "anchors", ")", "==", "len", "(", "images", ")", "\n", "results", "=", "[", "]", "\n", "\n", "pred_logits", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "self", ".", "num_classes", ")", "for", "x", "in", "pred_logits", "]", "\n", "pred_deltas", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "4", ")", "for", "x", "in", "pred_deltas", "]", "\n", "\n", "pred_logits", "=", "cat", "(", "pred_logits", ",", "dim", "=", "1", ")", "\n", "pred_deltas", "=", "cat", "(", "pred_deltas", ",", "dim", "=", "1", ")", "\n", "\n", "for", "img_idx", ",", "(", "anchors_im", ",", "indexes_im", ")", "in", "enumerate", "(", "zip", "(", "anchors", ",", "indexes", ")", ")", ":", "\n", "# Get the size of the current image", "\n", "            ", "image_size", "=", "images", ".", "image_sizes", "[", "img_idx", "]", "\n", "\n", "logits_im", "=", "pred_logits", "[", "img_idx", "]", "\n", "deltas_im", "=", "pred_deltas", "[", "img_idx", "]", "\n", "\n", "if", "self", ".", "mask_on", ":", "\n", "                ", "masks_im", "=", "[", "[", "mla", "[", "img_idx", "]", "for", "mla", "in", "ml", "]", "for", "ml", "in", "pred_masks", "]", "\n", "", "else", ":", "\n", "                ", "masks_im", "=", "[", "None", "]", "*", "self", ".", "num_levels", "\n", "", "results_im", "=", "self", ".", "inference_single_image", "(", "\n", "logits_im", ",", "\n", "deltas_im", ",", "\n", "masks_im", ",", "\n", "Boxes", ".", "cat", "(", "anchors_im", ")", ",", "\n", "cat", "(", "indexes_im", ")", ",", "\n", "tuple", "(", "image_size", ")", ",", "\n", ")", "\n", "results", ".", "append", "(", "results_im", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.inference_single_image": [[675, 743], ["pred_logits.flatten().sigmoid_.flatten().sigmoid_.flatten().sigmoid_", "min", "pred_logits[].sort", "arch.TensorMask.box2box_transform.apply_deltas", "detectron2.layers.batched_nms", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.where", "torch.where", "torch.where", "torch.where", "result_indexes.tolist", "pred_logits.flatten().sigmoid_.flatten().sigmoid_.flatten", "result_masks.append", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "[].view"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.box_regression.Box2BoxTransformRotated.apply_deltas", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "def", "inference_single_image", "(", "\n", "self", ",", "pred_logits", ",", "pred_deltas", ",", "pred_masks", ",", "anchors", ",", "indexes", ",", "image_size", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Single-image inference. Return bounding-box detection results by thresholding\n        on scores and applying non-maximum suppression (NMS).\n\n        Arguments:\n            pred_logits (list[Tensor]): list of #feature levels. Each entry contains\n                tensor of size (AxHxW, K)\n            pred_deltas (list[Tensor]): Same shape as 'pred_logits' except that K becomes 4.\n            pred_masks (list[list[Tensor]]): List of #feature levels, each is a list of #anchors.\n                Each entry contains tensor of size (M_i*M_i, H, W). `None` if mask_on=False.\n            anchors (list[Boxes]): list of #feature levels. Each entry contains\n                a Boxes object, which contains all the anchors for that\n                image in that feature level.\n            image_size (tuple(H, W)): a tuple of the image height and width.\n\n        Returns:\n            Same as `inference`, but for only one image.\n        \"\"\"", "\n", "pred_logits", "=", "pred_logits", ".", "flatten", "(", ")", ".", "sigmoid_", "(", ")", "\n", "# We get top locations across all levels to accelerate the inference speed,", "\n", "# which does not seem to affect the accuracy.", "\n", "# First select values above the threshold", "\n", "logits_top_idxs", "=", "torch", ".", "where", "(", "pred_logits", ">", "self", ".", "score_threshold", ")", "[", "0", "]", "\n", "# Then get the top values", "\n", "num_topk", "=", "min", "(", "self", ".", "topk_candidates", ",", "logits_top_idxs", ".", "shape", "[", "0", "]", ")", "\n", "pred_prob", ",", "topk_idxs", "=", "pred_logits", "[", "logits_top_idxs", "]", ".", "sort", "(", "descending", "=", "True", ")", "\n", "# Keep top k scoring values", "\n", "pred_prob", "=", "pred_prob", "[", ":", "num_topk", "]", "\n", "# Keep top k values", "\n", "top_idxs", "=", "logits_top_idxs", "[", "topk_idxs", "[", ":", "num_topk", "]", "]", "\n", "\n", "# class index", "\n", "cls_idxs", "=", "top_idxs", "%", "self", ".", "num_classes", "\n", "# HWA index", "\n", "top_idxs", "//=", "self", ".", "num_classes", "\n", "# predict boxes", "\n", "pred_boxes", "=", "self", ".", "box2box_transform", ".", "apply_deltas", "(", "\n", "pred_deltas", "[", "top_idxs", "]", ",", "anchors", "[", "top_idxs", "]", ".", "tensor", "\n", ")", "\n", "# apply nms", "\n", "keep", "=", "batched_nms", "(", "pred_boxes", ",", "pred_prob", ",", "cls_idxs", ",", "self", ".", "nms_threshold", ")", "\n", "# pick the top ones", "\n", "keep", "=", "keep", "[", ":", "self", ".", "detections_im", "]", "\n", "\n", "results", "=", "Instances", "(", "image_size", ")", "\n", "results", ".", "pred_boxes", "=", "Boxes", "(", "pred_boxes", "[", "keep", "]", ")", "\n", "results", ".", "scores", "=", "pred_prob", "[", "keep", "]", "\n", "results", ".", "pred_classes", "=", "cls_idxs", "[", "keep", "]", "\n", "\n", "# deal with masks", "\n", "result_masks", ",", "result_anchors", "=", "[", "]", ",", "None", "\n", "if", "self", ".", "mask_on", ":", "\n", "# index and anchors, useful for masks", "\n", "            ", "top_indexes", "=", "indexes", "[", "top_idxs", "]", "\n", "top_anchors", "=", "anchors", "[", "top_idxs", "]", "\n", "result_indexes", "=", "top_indexes", "[", "keep", "]", "\n", "result_anchors", "=", "top_anchors", "[", "keep", "]", "\n", "# Get masks and do sigmoid", "\n", "for", "lvl", ",", "_", ",", "h", ",", "w", ",", "anc", "in", "result_indexes", ".", "tolist", "(", ")", ":", "\n", "                ", "cur_size", "=", "self", ".", "mask_sizes", "[", "anc", "]", "*", "(", "2", "**", "lvl", "if", "self", ".", "bipyramid_on", "else", "1", ")", "\n", "result_masks", ".", "append", "(", "\n", "torch", ".", "sigmoid", "(", "pred_masks", "[", "lvl", "]", "[", "anc", "]", "[", ":", ",", "h", ",", "w", "]", ".", "view", "(", "1", ",", "cur_size", ",", "cur_size", ")", ")", "\n", ")", "\n", "\n", "", "", "return", "results", ",", "(", "result_masks", ",", "result_anchors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.preprocess_image": [[744, 752], ["detectron2.structures.ImageList.from_tensors", "x[].to"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.image_list.ImageList.from_tensors", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "preprocess_image", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Normalize, pad and batch the input images.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMaskHead.__init__": [[755, 856], ["torch.nn.Module.__init__", "range", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "range", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "modules_list.extend", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "cls_subnet.append", "cls_subnet.append", "bbox_subnet.append", "bbox_subnet.append", "range", "torch.nn.Sequential", "torch.nn.Sequential", "modules_list.append", "modules.modules", "math.log", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "mask_subnet.append", "mask_subnet.append", "arch.TensorMaskHead.add_module", "modules_list.append", "isinstance", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "getattr", "range", "torch.nn.Sequential", "torch.nn.Sequential", "modules_list.append", "tensormask.layers.SwapAlign2Nat", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "setattr", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "tensormask.layers.SwapAlign2Nat"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "num_levels", ",", "num_anchors", ",", "mask_sizes", ",", "input_shape", ":", "List", "[", "ShapeSpec", "]", ")", ":", "\n", "        ", "\"\"\"\n        TensorMask head.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "IN_FEATURES", "\n", "in_channels", "=", "input_shape", "[", "0", "]", ".", "channels", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "NUM_CLASSES", "\n", "cls_channels", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "CLS_CHANNELS", "\n", "num_convs", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "NUM_CONVS", "\n", "# box parameters", "\n", "bbox_channels", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "BBOX_CHANNELS", "\n", "# mask parameters", "\n", "self", ".", "mask_on", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "self", ".", "mask_sizes", "=", "mask_sizes", "\n", "mask_channels", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "MASK_CHANNELS", "\n", "self", ".", "align_on", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "ALIGNED_ON", "\n", "self", ".", "bipyramid_on", "=", "cfg", ".", "MODEL", ".", "TENSOR_MASK", ".", "BIPYRAMID_ON", "\n", "# fmt: on", "\n", "\n", "# class subnet", "\n", "cls_subnet", "=", "[", "]", "\n", "cur_channels", "=", "in_channels", "\n", "for", "_", "in", "range", "(", "num_convs", ")", ":", "\n", "            ", "cls_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "cur_channels", ",", "cls_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "cur_channels", "=", "cls_channels", "\n", "cls_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "self", ".", "cls_subnet", "=", "nn", ".", "Sequential", "(", "*", "cls_subnet", ")", "\n", "self", ".", "cls_score", "=", "nn", ".", "Conv2d", "(", "\n", "cur_channels", ",", "num_anchors", "*", "num_classes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "modules_list", "=", "[", "self", ".", "cls_subnet", ",", "self", ".", "cls_score", "]", "\n", "\n", "# box subnet", "\n", "bbox_subnet", "=", "[", "]", "\n", "cur_channels", "=", "in_channels", "\n", "for", "_", "in", "range", "(", "num_convs", ")", ":", "\n", "            ", "bbox_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "cur_channels", ",", "bbox_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "cur_channels", "=", "bbox_channels", "\n", "bbox_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "self", ".", "bbox_subnet", "=", "nn", ".", "Sequential", "(", "*", "bbox_subnet", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Conv2d", "(", "\n", "cur_channels", ",", "num_anchors", "*", "4", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "modules_list", ".", "extend", "(", "[", "self", ".", "bbox_subnet", ",", "self", ".", "bbox_pred", "]", ")", "\n", "\n", "# mask subnet", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "mask_subnet", "=", "[", "]", "\n", "cur_channels", "=", "in_channels", "\n", "for", "_", "in", "range", "(", "num_convs", ")", ":", "\n", "                ", "mask_subnet", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "cur_channels", ",", "mask_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", ")", "\n", "cur_channels", "=", "mask_channels", "\n", "mask_subnet", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "self", ".", "mask_subnet", "=", "nn", ".", "Sequential", "(", "*", "mask_subnet", ")", "\n", "modules_list", ".", "append", "(", "self", ".", "mask_subnet", ")", "\n", "for", "mask_size", "in", "self", ".", "mask_sizes", ":", "\n", "                ", "cur_mask_module", "=", "\"mask_pred_%02d\"", "%", "mask_size", "\n", "self", ".", "add_module", "(", "\n", "cur_mask_module", ",", "\n", "nn", ".", "Conv2d", "(", "\n", "cur_channels", ",", "mask_size", "*", "mask_size", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", "\n", ")", ",", "\n", ")", "\n", "modules_list", ".", "append", "(", "getattr", "(", "self", ",", "cur_mask_module", ")", ")", "\n", "", "if", "self", ".", "align_on", ":", "\n", "                ", "if", "self", ".", "bipyramid_on", ":", "\n", "                    ", "for", "lvl", "in", "range", "(", "num_levels", ")", ":", "\n", "                        ", "cur_mask_module", "=", "\"align2nat_%02d\"", "%", "lvl", "\n", "lambda_val", "=", "2", "**", "lvl", "\n", "setattr", "(", "self", ",", "cur_mask_module", ",", "SwapAlign2Nat", "(", "lambda_val", ")", ")", "\n", "# Also the fusing layer, stay at the same channel size", "\n", "", "mask_fuse", "=", "[", "\n", "nn", ".", "Conv2d", "(", "cur_channels", ",", "cur_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "]", "\n", "self", ".", "mask_fuse", "=", "nn", ".", "Sequential", "(", "*", "mask_fuse", ")", "\n", "modules_list", ".", "append", "(", "self", ".", "mask_fuse", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "align2nat", "=", "SwapAlign2Nat", "(", "1", ")", "\n", "\n", "# Initialization", "\n", "", "", "", "for", "modules", "in", "modules_list", ":", "\n", "            ", "for", "layer", "in", "modules", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "layer", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "layer", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "layer", ".", "bias", ",", "0", ")", "\n", "\n", "# Use prior in model initialization to improve stability", "\n", "", "", "", "bias_value", "=", "-", "(", "math", ".", "log", "(", "(", "1", "-", "0.01", ")", "/", "0.01", ")", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "self", ".", "cls_score", ".", "bias", ",", "bias_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMaskHead.forward": [[857, 914], ["arch.TensorMaskHead.cls_score", "arch.TensorMaskHead.bbox_pred", "enumerate", "arch.TensorMaskHead.cls_subnet", "arch.TensorMaskHead.bbox_subnet", "arch.TensorMaskHead.mask_subnet", "enumerate", "pred_masks.append", "mask_feats_up.append", "getattr", "getattr.", "cur_masks.append", "torch.interpolate", "torch.interpolate", "arch.TensorMaskHead.mask_fuse", "getattr", "getattr.", "arch.TensorMaskHead.align2nat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            features (list[Tensor]): FPN feature map tensors in high to low resolution.\n                Each tensor in the list correspond to different feature levels.\n\n        Returns:\n            pred_logits (list[Tensor]): #lvl tensors, each has shape (N, AxK, Hi, Wi).\n                The tensor predicts the classification probability\n                at each spatial position for each of the A anchors and K object\n                classes.\n            pred_deltas (list[Tensor]): #lvl tensors, each has shape (N, Ax4, Hi, Wi).\n                The tensor predicts 4-vector (dx,dy,dw,dh) box\n                regression values for every anchor. These values are the\n                relative offset between the anchor and the ground truth box.\n            pred_masks (list(list[Tensor])): #lvl list of tensors, each is a list of\n                A tensors of shape (N, M_{i,a}, Hi, Wi).\n                The tensor predicts a dense set of M_ixM_i masks at every location.\n        \"\"\"", "\n", "pred_logits", "=", "[", "self", ".", "cls_score", "(", "self", ".", "cls_subnet", "(", "x", ")", ")", "for", "x", "in", "features", "]", "\n", "pred_deltas", "=", "[", "self", ".", "bbox_pred", "(", "self", ".", "bbox_subnet", "(", "x", ")", ")", "for", "x", "in", "features", "]", "\n", "\n", "pred_masks", "=", "None", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "mask_feats", "=", "[", "self", ".", "mask_subnet", "(", "x", ")", "for", "x", "in", "features", "]", "\n", "\n", "if", "self", ".", "bipyramid_on", ":", "\n", "                ", "mask_feat_high_res", "=", "mask_feats", "[", "0", "]", "\n", "H", ",", "W", "=", "mask_feat_high_res", ".", "shape", "[", "-", "2", ":", "]", "\n", "mask_feats_up", "=", "[", "]", "\n", "for", "lvl", ",", "mask_feat", "in", "enumerate", "(", "mask_feats", ")", ":", "\n", "                    ", "lambda_val", "=", "2.0", "**", "lvl", "\n", "mask_feat_up", "=", "mask_feat", "\n", "if", "lvl", ">", "0", ":", "\n", "                        ", "mask_feat_up", "=", "F", ".", "interpolate", "(", "\n", "mask_feat", ",", "scale_factor", "=", "lambda_val", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "", "mask_feats_up", ".", "append", "(", "\n", "self", ".", "mask_fuse", "(", "mask_feat_up", "[", ":", ",", ":", ",", ":", "H", ",", ":", "W", "]", "+", "mask_feat_high_res", ")", "\n", ")", "\n", "", "mask_feats", "=", "mask_feats_up", "\n", "\n", "", "pred_masks", "=", "[", "]", "\n", "for", "lvl", ",", "mask_feat", "in", "enumerate", "(", "mask_feats", ")", ":", "\n", "                ", "cur_masks", "=", "[", "]", "\n", "for", "mask_size", "in", "self", ".", "mask_sizes", ":", "\n", "                    ", "cur_mask_module", "=", "getattr", "(", "self", ",", "\"mask_pred_%02d\"", "%", "mask_size", ")", "\n", "cur_mask", "=", "cur_mask_module", "(", "mask_feat", ")", "\n", "if", "self", ".", "align_on", ":", "\n", "                        ", "if", "self", ".", "bipyramid_on", ":", "\n", "                            ", "cur_mask_module", "=", "getattr", "(", "self", ",", "\"align2nat_%02d\"", "%", "lvl", ")", "\n", "cur_mask", "=", "cur_mask_module", "(", "cur_mask", ")", "\n", "", "else", ":", "\n", "                            ", "cur_mask", "=", "self", ".", "align2nat", "(", "cur_mask", ")", "\n", "", "", "cur_masks", ".", "append", "(", "cur_mask", ")", "\n", "", "pred_masks", ".", "append", "(", "cur_masks", ")", "\n", "", "", "return", "pred_logits", ",", "pred_deltas", ",", "pred_masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.permute_all_cls_and_box_to_N_HWA_K_and_concat": [[23, 40], ["detectron2.layers.cat().view", "detectron2.layers.cat().view", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "detectron2.modeling.meta_arch.retinanet.permute_to_N_HWA_K", "detectron2.layers.cat", "detectron2.layers.cat"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.JosephKJ_OWOD.meta_arch.retinanet.permute_to_N_HWA_K", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["def", "permute_all_cls_and_box_to_N_HWA_K_and_concat", "(", "pred_logits", ",", "pred_anchor_deltas", ",", "num_classes", "=", "80", ")", ":", "\n", "    ", "\"\"\"\n    Rearrange the tensor layout from the network output, i.e.:\n    list[Tensor]: #lvl tensors of shape (N, A x K, Hi, Wi)\n    to per-image predictions, i.e.:\n    Tensor: of shape (N x sum(Hi x Wi x A), K)\n    \"\"\"", "\n", "# for each feature level, permute the outputs to make them be in the", "\n", "# same format as the labels.", "\n", "pred_logits_flattened", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "num_classes", ")", "for", "x", "in", "pred_logits", "]", "\n", "pred_anchor_deltas_flattened", "=", "[", "permute_to_N_HWA_K", "(", "x", ",", "4", ")", "for", "x", "in", "pred_anchor_deltas", "]", "\n", "# concatenate on the first dimension (representing the feature levels), to", "\n", "# take into account the way the labels were generated (with all feature maps", "\n", "# being concatenated as well)", "\n", "pred_logits", "=", "cat", "(", "pred_logits_flattened", ",", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "num_classes", ")", "\n", "pred_anchor_deltas", "=", "cat", "(", "pred_anchor_deltas_flattened", ",", "dim", "=", "1", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "return", "pred_logits", ",", "pred_anchor_deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch._assignment_rule": [[42, 133], ["torch.min", "torch.min", "torch.max", "torch.max", "detectron2.layers.cat", "torch.zeros_like", "torch.zeros_like", "torch.all", "torch.all", "assign_matrix.max", "matches.new_full", "torch.max", "torch.max", "torch.sum", "torch.sum", "matches.size", "assign_matrix.sum", "gt_boxes.new_full", "gt_boxes.new_full", "torch.max", "torch.max"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "_assignment_rule", "(", "\n", "gt_boxes", ",", "\n", "anchor_boxes", ",", "\n", "unit_lengths", ",", "\n", "min_anchor_size", ",", "\n", "scale_thresh", "=", "2.0", ",", "\n", "spatial_thresh", "=", "1.0", ",", "\n", "uniqueness_on", "=", "True", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Given two lists of boxes of N ground truth boxes and M anchor boxes,\n    compute the assignment between the two, following the assignment rules in\n    https://arxiv.org/abs/1903.12174.\n    The box order must be (xmin, ymin, xmax, ymax), so please make sure to convert\n    to BoxMode.XYXY_ABS before calling this function.\n\n    Args:\n        gt_boxes, anchor_boxes (Boxes): two Boxes. Contains N & M boxes/anchors, respectively.\n        unit_lengths (Tensor): Contains the unit lengths of M anchor boxes.\n        min_anchor_size (float): Minimum size of the anchor, in pixels\n        scale_thresh (float): The `scale` threshold: the maximum size of the anchor\n                              should not be greater than scale_thresh x max(h, w) of\n                              the ground truth box.\n        spatial_thresh (float): The `spatial` threshold: the l2 distance between the\n                              center of the anchor and the ground truth box should not\n                              be greater than spatial_thresh x u where u is the unit length.\n\n    Returns:\n        matches (Tensor[int64]): a vector of length M, where matches[i] is a matched\n                ground-truth index in [0, N)\n        match_labels (Tensor[int8]): a vector of length M, where pred_labels[i] indicates\n            whether a prediction is a true or false positive or ignored\n    \"\"\"", "\n", "gt_boxes", ",", "anchor_boxes", "=", "gt_boxes", ".", "tensor", ",", "anchor_boxes", ".", "tensor", "\n", "N", "=", "gt_boxes", ".", "shape", "[", "0", "]", "\n", "M", "=", "anchor_boxes", ".", "shape", "[", "0", "]", "\n", "if", "N", "==", "0", "or", "M", "==", "0", ":", "\n", "        ", "return", "(", "\n", "gt_boxes", ".", "new_full", "(", "(", "N", ",", ")", ",", "0", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "\n", "gt_boxes", ".", "new_full", "(", "(", "N", ",", ")", ",", "-", "1", ",", "dtype", "=", "torch", ".", "int8", ")", ",", "\n", ")", "\n", "\n", "# Containment rule", "\n", "", "lt", "=", "torch", ".", "min", "(", "gt_boxes", "[", ":", ",", "None", ",", ":", "2", "]", ",", "anchor_boxes", "[", ":", ",", ":", "2", "]", ")", "# [N,M,2]", "\n", "rb", "=", "torch", ".", "max", "(", "gt_boxes", "[", ":", ",", "None", ",", "2", ":", "]", ",", "anchor_boxes", "[", ":", ",", "2", ":", "]", ")", "# [N,M,2]", "\n", "union", "=", "cat", "(", "[", "lt", ",", "rb", "]", ",", "dim", "=", "2", ")", "# [N,M,4]", "\n", "\n", "dummy_gt_boxes", "=", "torch", ".", "zeros_like", "(", "gt_boxes", ")", "\n", "anchor", "=", "dummy_gt_boxes", "[", ":", ",", "None", ",", ":", "]", "+", "anchor_boxes", "[", ":", ",", ":", "]", "# [N,M,4]", "\n", "\n", "contain_matrix", "=", "torch", ".", "all", "(", "union", "==", "anchor", ",", "dim", "=", "2", ")", "# [N,M]", "\n", "\n", "# Centrality rule, scale", "\n", "gt_size_lower", "=", "torch", ".", "max", "(", "gt_boxes", "[", ":", ",", "2", ":", "]", "-", "gt_boxes", "[", ":", ",", ":", "2", "]", ",", "dim", "=", "1", ")", "[", "0", "]", "# [N]", "\n", "gt_size_upper", "=", "gt_size_lower", "*", "scale_thresh", "# [N]", "\n", "# Fall back for small objects", "\n", "gt_size_upper", "[", "gt_size_upper", "<", "min_anchor_size", "]", "=", "min_anchor_size", "\n", "# Due to sampling of locations, the anchor sizes are deducted with sampling strides", "\n", "anchor_size", "=", "(", "\n", "torch", ".", "max", "(", "anchor_boxes", "[", ":", ",", "2", ":", "]", "-", "anchor_boxes", "[", ":", ",", ":", "2", "]", ",", "dim", "=", "1", ")", "[", "0", "]", "-", "unit_lengths", "\n", ")", "# [M]", "\n", "\n", "size_diff_upper", "=", "gt_size_upper", "[", ":", ",", "None", "]", "-", "anchor_size", "# [N,M]", "\n", "scale_matrix", "=", "size_diff_upper", ">=", "0", "# [N,M]", "\n", "\n", "# Centrality rule, spatial", "\n", "gt_center", "=", "(", "gt_boxes", "[", ":", ",", "2", ":", "]", "+", "gt_boxes", "[", ":", ",", ":", "2", "]", ")", "/", "2", "# [N,2]", "\n", "anchor_center", "=", "(", "anchor_boxes", "[", ":", ",", "2", ":", "]", "+", "anchor_boxes", "[", ":", ",", ":", "2", "]", ")", "/", "2", "# [M,2]", "\n", "offset_center", "=", "gt_center", "[", ":", ",", "None", ",", ":", "]", "-", "anchor_center", "[", ":", ",", ":", "]", "# [N,M,2]", "\n", "offset_center", "/=", "unit_lengths", "[", ":", ",", "None", "]", "# [N,M,2]", "\n", "spatial_square", "=", "spatial_thresh", "*", "spatial_thresh", "\n", "spatial_matrix", "=", "torch", ".", "sum", "(", "offset_center", "*", "offset_center", ",", "dim", "=", "2", ")", "<=", "spatial_square", "\n", "\n", "assign_matrix", "=", "(", "contain_matrix", "&", "scale_matrix", "&", "spatial_matrix", ")", ".", "int", "(", ")", "\n", "\n", "# assign_matrix is N (gt) x M (predicted)", "\n", "# Max over gt elements (dim 0) to find best gt candidate for each prediction", "\n", "matched_vals", ",", "matches", "=", "assign_matrix", ".", "max", "(", "dim", "=", "0", ")", "\n", "match_labels", "=", "matches", ".", "new_full", "(", "matches", ".", "size", "(", ")", ",", "1", ",", "dtype", "=", "torch", ".", "int8", ")", "\n", "\n", "match_labels", "[", "matched_vals", "==", "0", "]", "=", "0", "\n", "match_labels", "[", "matched_vals", "==", "1", "]", "=", "1", "\n", "\n", "# find all the elements that match to ground truths multiple times", "\n", "not_unique_idxs", "=", "assign_matrix", ".", "sum", "(", "dim", "=", "0", ")", ">", "1", "\n", "if", "uniqueness_on", ":", "\n", "        ", "match_labels", "[", "not_unique_idxs", "]", "=", "0", "\n", "", "else", ":", "\n", "        ", "match_labels", "[", "not_unique_idxs", "]", "=", "-", "1", "\n", "\n", "", "return", "matches", ",", "match_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch._paste_mask_lists_in_image": [[136, 180], ["torch.tensor", "torch.tensor", "torch.unique", "torch.unique", "torch.unique.tolist", "detectron2.layers.cat", "detectron2.layers.cat", "torch.empty_like", "torch.empty_like", "len", "torch.empty", "torch.empty", "detectron2.layers.cat.append", "detectron2.layers.cat", "detectron2.layers.cat.append", "torch.where", "torch.where", "detectron2.layers.paste_masks_in_image"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.mask_ops.paste_masks_in_image"], ["", "def", "_paste_mask_lists_in_image", "(", "masks", ",", "boxes", ",", "image_shape", ",", "threshold", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"\n    Paste a list of masks that are of various resolutions (e.g., 28 x 28) into an image.\n    The location, height, and width for pasting each mask is determined by their\n    corresponding bounding boxes in boxes.\n\n    Args:\n        masks (list(Tensor)): A list of Tensor of shape (1, Hmask_i, Wmask_i).\n                            Values are in [0, 1]. The list length, Bimg, is the\n                            number of detected object instances in the image.\n        boxes (Boxes): A Boxes of length Bimg. boxes.tensor[i] and masks[i] correspond\n                            to the same object instance.\n        image_shape (tuple): height, width\n        threshold (float): A threshold in [0, 1] for converting the (soft) masks to\n            binary masks.\n\n    Returns:\n        img_masks (Tensor): A tensor of shape (Bimg, Himage, Wimage), where Bimg is the\n        number of detected object instances and Himage, Wimage are the image width\n        and height. img_masks[i] is a binary mask for object instance i.\n    \"\"\"", "\n", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "        ", "return", "torch", ".", "empty", "(", "(", "0", ",", "1", ")", "+", "image_shape", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "\n", "# Loop over masks groups. Each group has the same mask prediction size.", "\n", "", "img_masks", "=", "[", "]", "\n", "ind_masks", "=", "[", "]", "\n", "mask_sizes", "=", "torch", ".", "tensor", "(", "[", "m", ".", "shape", "[", "-", "1", "]", "for", "m", "in", "masks", "]", ")", "\n", "unique_sizes", "=", "torch", ".", "unique", "(", "mask_sizes", ")", "\n", "for", "msize", "in", "unique_sizes", ".", "tolist", "(", ")", ":", "\n", "        ", "cur_ind", "=", "torch", ".", "where", "(", "mask_sizes", "==", "msize", ")", "[", "0", "]", "\n", "ind_masks", ".", "append", "(", "cur_ind", ")", "\n", "\n", "cur_masks", "=", "cat", "(", "[", "masks", "[", "i", "]", "for", "i", "in", "cur_ind", "]", ")", "\n", "cur_boxes", "=", "boxes", "[", "cur_ind", "]", "\n", "img_masks", ".", "append", "(", "paste_masks_in_image", "(", "cur_masks", ",", "cur_boxes", ",", "image_shape", ",", "threshold", ")", ")", "\n", "\n", "", "img_masks", "=", "cat", "(", "img_masks", ")", "\n", "ind_masks", "=", "cat", "(", "ind_masks", ")", "\n", "\n", "img_masks_out", "=", "torch", ".", "empty_like", "(", "img_masks", ")", "\n", "img_masks_out", "[", "ind_masks", ",", ":", ",", ":", "]", "=", "img_masks", "\n", "\n", "return", "img_masks_out", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch._postprocess": [[182, 227], ["detectron2.structures.Instances", "output_boxes.clip", "output_boxes.nonempty", "arch._paste_mask_lists_in_image", "detectron2.structures.Instances.get_fields", "zip", "output_boxes.nonempty.tolist"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.nonempty", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch._paste_mask_lists_in_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.get_fields"], ["", "def", "_postprocess", "(", "results", ",", "result_mask_info", ",", "output_height", ",", "output_width", ",", "mask_threshold", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"\n    Post-process the output boxes for TensorMask.\n    The input images are often resized when entering an object detector.\n    As a result, we often need the outputs of the detector in a different\n    resolution from its inputs.\n\n    This function will postprocess the raw outputs of TensorMask\n    to produce outputs according to the desired output resolution.\n\n    Args:\n        results (Instances): the raw outputs from the detector.\n            `results.image_size` contains the input image resolution the detector sees.\n            This object might be modified in-place. Note that it does not contain the field\n            `pred_masks`, which is provided by another input `result_masks`.\n        result_mask_info (list[Tensor], Boxes): a pair of two items for mask related results.\n                The first item is a list of #detection tensors, each is the predicted masks.\n                The second item is the anchors corresponding to the predicted masks.\n        output_height, output_width: the desired output resolution.\n\n    Returns:\n        Instances: the postprocessed output from the model, based on the output resolution\n    \"\"\"", "\n", "scale_x", ",", "scale_y", "=", "(", "output_width", "/", "results", ".", "image_size", "[", "1", "]", ",", "output_height", "/", "results", ".", "image_size", "[", "0", "]", ")", "\n", "results", "=", "Instances", "(", "(", "output_height", ",", "output_width", ")", ",", "**", "results", ".", "get_fields", "(", ")", ")", "\n", "\n", "output_boxes", "=", "results", ".", "pred_boxes", "\n", "output_boxes", ".", "tensor", "[", ":", ",", "0", ":", ":", "2", "]", "*=", "scale_x", "\n", "output_boxes", ".", "tensor", "[", ":", ",", "1", ":", ":", "2", "]", "*=", "scale_y", "\n", "output_boxes", ".", "clip", "(", "results", ".", "image_size", ")", "\n", "\n", "inds_nonempty", "=", "output_boxes", ".", "nonempty", "(", ")", "\n", "results", "=", "results", "[", "inds_nonempty", "]", "\n", "result_masks", ",", "result_anchors", "=", "result_mask_info", "\n", "if", "result_masks", ":", "\n", "        ", "result_anchors", ".", "tensor", "[", ":", ",", "0", ":", ":", "2", "]", "*=", "scale_x", "\n", "result_anchors", ".", "tensor", "[", ":", ",", "1", ":", ":", "2", "]", "*=", "scale_y", "\n", "result_masks", "=", "[", "x", "for", "(", "i", ",", "x", ")", "in", "zip", "(", "inds_nonempty", ".", "tolist", "(", ")", ",", "result_masks", ")", "if", "i", "]", "\n", "results", ".", "pred_masks", "=", "_paste_mask_lists_in_image", "(", "\n", "result_masks", ",", "\n", "result_anchors", "[", "inds_nonempty", "]", ",", "\n", "results", ".", "image_size", ",", "\n", "threshold", "=", "mask_threshold", ",", "\n", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_swap_align2nat.SwapAlign2NatTest.test_swap_align2nat_gradcheck_cuda": [[12, 20], ["unittest.skipIf", "torch.device", "tensormask.layers.swap_align2nat.SwapAlign2Nat().to", "torch.rand", "test_swap_align2nat.SwapAlign2NatTest.assertTrue", "torch.autograd.gradcheck", "torch.cuda.is_available", "tensormask.layers.swap_align2nat.SwapAlign2Nat"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["    ", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_swap_align2nat_gradcheck_cuda", "(", "self", ")", ":", "\n", "        ", "dtype", "=", "torch", ".", "float64", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ")", "\n", "m", "=", "SwapAlign2Nat", "(", "2", ")", ".", "to", "(", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "x", "=", "torch", ".", "rand", "(", "2", ",", "4", ",", "10", ",", "10", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ",", "requires_grad", "=", "True", ")", "\n", "\n", "self", ".", "assertTrue", "(", "gradcheck", "(", "m", ",", "x", ")", ",", "\"gradcheck failed for SwapAlign2Nat CUDA\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_swap_align2nat.SwapAlign2NatTest._swap_align2nat": [[21, 29], ["tensormask.layers.swap_align2nat.SwapAlign2Nat", "torch.from_numpy", "tensormask.layers.swap_align2nat.SwapAlign2Nat.forward().cpu().numpy", "tensor[].astype", "tensormask.layers.swap_align2nat.SwapAlign2Nat.forward().cpu", "tensormask.layers.swap_align2nat.SwapAlign2Nat.forward", "torch.from_numpy.cuda"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward"], ["", "def", "_swap_align2nat", "(", "self", ",", "tensor", ",", "lambda_val", ")", ":", "\n", "        ", "\"\"\"\n        The basic setup for testing Swap_Align\n        \"\"\"", "\n", "op", "=", "SwapAlign2Nat", "(", "lambda_val", ",", "pad_val", "=", "0.0", ")", "\n", "input", "=", "torch", ".", "from_numpy", "(", "tensor", "[", "None", ",", ":", ",", ":", ",", ":", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "output", "=", "op", ".", "forward", "(", "input", ".", "cuda", "(", ")", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "return", "output", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_image_resize_transform.TestImageResizeTransform.test_image_resize_1": [[10, 17], ["densepose.data.transform.ImageResizeTransform", "densepose.data.transform.ImageResizeTransform.", "test_image_resize_transform.TestImageResizeTransform.assertEqual", "test_image_resize_transform.TestImageResizeTransform.assertAlmostEqual", "torch.ones", "torch.ones", "densepose.data.transform.ImageResizeTransform.size", "IMAGES_GT.size", "torch.abs().max().item", "torch.abs().max", "torch.abs"], "methods", ["None"], ["    ", "def", "test_image_resize_1", "(", "self", ")", ":", "\n", "        ", "images_batch", "=", "torch", ".", "ones", "(", "(", "3", ",", "100", ",", "100", ",", "3", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "*", "100", "\n", "transform", "=", "ImageResizeTransform", "(", ")", "\n", "images_transformed", "=", "transform", "(", "images_batch", ")", "\n", "IMAGES_GT", "=", "torch", ".", "ones", "(", "(", "3", ",", "3", ",", "800", ",", "800", ")", ",", "dtype", "=", "torch", ".", "float", ")", "*", "100", "\n", "self", ".", "assertEqual", "(", "images_transformed", ".", "size", "(", ")", ",", "IMAGES_GT", ".", "size", "(", ")", ")", "\n", "self", ".", "assertAlmostEqual", "(", "torch", ".", "abs", "(", "IMAGES_GT", "-", "images_transformed", ")", ".", "max", "(", ")", ".", "item", "(", ")", ",", "0.0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_combine_data_loader.TestCombinedDataLoader.test_combine_loaders_1": [[31, 47], ["test_combine_data_loader._grouper", "test_combine_data_loader._grouper", "random.seed", "densepose.data.CombinedDataLoader", "enumerate", "test_combine_data_loader.TestCombinedDataLoader.assertEqual", "test_combine_data_loader.TestCombinedDataLoader.assertEqual", "len", "range", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_combine_data_loader._grouper", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_combine_data_loader._grouper"], ["    ", "def", "test_combine_loaders_1", "(", "self", ")", ":", "\n", "        ", "loader1", "=", "_grouper", "(", "[", "f\"1_{i}\"", "for", "i", "in", "range", "(", "10", ")", "]", ",", "2", ")", "\n", "loader2", "=", "_grouper", "(", "[", "f\"2_{i}\"", "for", "i", "in", "range", "(", "11", ")", "]", ",", "3", ")", "\n", "batch_size", "=", "4", "\n", "ratios", "=", "(", "0.1", ",", "0.9", ")", "\n", "random", ".", "seed", "(", "43", ")", "\n", "combined", "=", "CombinedDataLoader", "(", "(", "loader1", ",", "loader2", ")", ",", "batch_size", ",", "ratios", ")", "\n", "BATCHES_GT", "=", "[", "\n", "[", "\"1_0\"", ",", "\"1_1\"", ",", "\"2_0\"", ",", "\"2_1\"", "]", ",", "\n", "[", "\"2_2\"", ",", "\"2_3\"", ",", "\"2_4\"", ",", "\"2_5\"", "]", ",", "\n", "[", "\"1_2\"", ",", "\"1_3\"", ",", "\"2_6\"", ",", "\"2_7\"", "]", ",", "\n", "[", "\"2_8\"", ",", "\"2_9\"", ",", "\"2_10\"", ",", "None", "]", ",", "\n", "]", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "combined", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "len", "(", "batch", ")", ",", "batch_size", ")", "\n", "self", ".", "assertEqual", "(", "batch", ",", "BATCHES_GT", "[", "i", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_combine_data_loader._grouper": [[10, 28], ["iter", "range", "values.append", "tuple", "next", "values.extend", "tuple", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.iter"], ["def", "_grouper", "(", "iterable", ":", "Iterable", "[", "Any", "]", ",", "n", ":", "int", ",", "fillvalue", "=", "None", ")", "->", "Iterator", "[", "Tuple", "[", "Any", "]", "]", ":", "\n", "    ", "\"\"\"\n    Group elements of an iterable by chunks of size `n`, e.g.\n    grouper(range(9), 4) ->\n        (0, 1, 2, 3), (4, 5, 6, 7), (8, None, None, None)\n    \"\"\"", "\n", "it", "=", "iter", "(", "iterable", ")", "\n", "while", "True", ":", "\n", "        ", "values", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "value", "=", "next", "(", "it", ")", "\n", "", "except", "StopIteration", ":", "\n", "                ", "values", ".", "extend", "(", "[", "fillvalue", "]", "*", "(", "n", "-", "len", "(", "values", ")", ")", ")", "\n", "yield", "tuple", "(", "values", ")", "\n", "return", "\n", "", "values", ".", "append", "(", "value", ")", "\n", "", "yield", "tuple", "(", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_base_config_dir": [[20, 25], ["os.path.join", "os.path.dirname", "os.path.realpath"], "function", ["None"], ["\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_evolution_config_dir": [[27, 32], ["os.path.join", "common._get_base_config_dir"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_base_config_dir"], ["        ", "self", ".", "_dataset", "=", "dataset", "\n", "self", ".", "_map_func", "=", "PicklableWrapper", "(", "map_func", ")", "# wrap so that a lambda will work", "\n", "\n", "self", ".", "_rng", "=", "random", ".", "Random", "(", "42", ")", "\n", "self", ".", "_fallback_candidates", "=", "set", "(", "range", "(", "len", "(", "dataset", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_hrnet_config_dir": [[34, 39], ["os.path.join", "common._get_base_config_dir"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_base_config_dir"], ["        ", "return", "len", "(", "self", ".", "_dataset", ")", "\n", "\n", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "retry_count", "=", "0", "\n", "cur_idx", "=", "int", "(", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_quick_schedules_config_dir": [[41, 46], ["os.path.join", "common._get_base_config_dir"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_base_config_dir"], ["            ", "data", "=", "self", ".", "_map_func", "(", "self", ".", "_dataset", "[", "cur_idx", "]", ")", "\n", "if", "data", "is", "not", "None", ":", "\n", "                ", "self", ".", "_fallback_candidates", ".", "add", "(", "cur_idx", ")", "\n", "return", "data", "\n", "\n", "# _map_func fails for this idx, use a random new index from the pool", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._collect_config_files": [[48, 66], ["common._get_base_config_dir", "os.listdir", "os.path.join", "os.path.splitext", "entry.startswith", "os.path.relpath", "results.append", "os.path.isfile"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_base_config_dir"], ["self", ".", "_fallback_candidates", ".", "discard", "(", "cur_idx", ")", "\n", "cur_idx", "=", "self", ".", "_rng", ".", "sample", "(", "self", ".", "_fallback_candidates", ",", "k", "=", "1", ")", "[", "0", "]", "\n", "\n", "if", "retry_count", ">=", "3", ":", "\n", "                ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "\"Failed to apply `_map_func` for idx: {}, retry count: {}\"", ".", "format", "(", "\n", "idx", ",", "retry_count", "\n", ")", "\n", ")", "\n", "\n", "\n", "", "", "", "", "class", "DatasetFromList", "(", "data", ".", "Dataset", ")", ":", "\n", "    ", "\"\"\"\n    Wrap a list to a torch Dataset. It produces elements of the list as data.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "lst", ":", "list", ",", "copy", ":", "bool", "=", "True", ",", "serialize", ":", "bool", "=", "True", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_config_files": [[68, 73], ["common._collect_config_files", "common._get_base_config_dir"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._collect_config_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_base_config_dir"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_evolution_config_files": [[75, 80], ["common._collect_config_files", "common._get_evolution_config_dir"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._collect_config_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_evolution_config_dir"], ["\n", "self", ".", "_lst", "=", "lst", "\n", "self", ".", "_copy", "=", "copy", "\n", "self", ".", "_serialize", "=", "serialize", "\n", "\n", "def", "_serialize", "(", "data", ")", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_hrnet_config_files": [[82, 87], ["common._collect_config_files", "common._get_hrnet_config_dir"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._collect_config_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_hrnet_config_dir"], ["return", "np", ".", "frombuffer", "(", "buffer", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "", "if", "self", ".", "_serialize", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\n", "\"Serializing {} elements to byte tensors and concatenating them all ...\"", ".", "format", "(", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_quick_schedules_config_files": [[89, 94], ["common._collect_config_files", "common._get_quick_schedules_config_dir"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._collect_config_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_quick_schedules_config_dir"], [")", "\n", ")", "\n", "self", ".", "_lst", "=", "[", "_serialize", "(", "x", ")", "for", "x", "in", "self", ".", "_lst", "]", "\n", "self", ".", "_addr", "=", "np", ".", "asarray", "(", "[", "len", "(", "x", ")", "for", "x", "in", "self", ".", "_lst", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "_addr", "=", "np", ".", "cumsum", "(", "self", ".", "_addr", ")", "\n", "self", ".", "_lst", "=", "np", ".", "concatenate", "(", "self", ".", "_lst", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_model_config": [[96, 108], ["detectron2.config.get_cfg", "densepose.add_densepose_config", "os.path.join", "detectron2.config.get_cfg.merge_from_file", "common._get_base_config_dir", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_densepose_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_base_config_dir"], ["\n", "", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_serialize", ":", "\n", "            ", "return", "len", "(", "self", ".", "_addr", ")", "\n", "", "else", ":", "\n", "            ", "return", "len", "(", "self", ".", "_lst", ")", "\n", "\n", "", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "_serialize", ":", "\n", "            ", "start_addr", "=", "0", "if", "idx", "==", "0", "else", "self", ".", "_addr", "[", "idx", "-", "1", "]", ".", "item", "(", ")", "\n", "end_addr", "=", "self", ".", "_addr", "[", "idx", "]", ".", "item", "(", ")", "\n", "bytes", "=", "memoryview", "(", "self", ".", "_lst", "[", "start_addr", ":", "end_addr", "]", ")", "\n", "return", "pickle", ".", "loads", "(", "bytes", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_model": [[110, 116], ["common._get_model_config", "detectron2.modeling.build_model"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_model_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model"], ["            ", "return", "copy", ".", "deepcopy", "(", "self", ".", "_lst", "[", "idx", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_lst", "[", "idx", "]", "\n", "\n", "\n", "", "", "", "class", "AspectRatioGroupedDataset", "(", "data", ".", "IterableDataset", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.setup": [[118, 125], ["common._get_model_config", "_get_model_config.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common._get_model_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_frame_selector.TestFrameSelector.test_frame_selector_random_k_1": [[10, 19], ["random.seed", "densepose.data.video.RandomKFramesSelector", "list", "densepose.data.video.RandomKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["    ", "def", "test_frame_selector_random_k_1", "(", "self", ")", ":", "\n", "        ", "_SEED", "=", "43", "\n", "_K", "=", "4", "\n", "random", ".", "seed", "(", "_SEED", ")", "\n", "selector", "=", "RandomKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "20", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "[", "0", ",", "8", ",", "4", ",", "6", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_frame_selector.TestFrameSelector.test_frame_selector_random_k_2": [[20, 29], ["random.seed", "densepose.data.video.RandomKFramesSelector", "list", "densepose.data.video.RandomKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "test_frame_selector_random_k_2", "(", "self", ")", ":", "\n", "        ", "_SEED", "=", "43", "\n", "_K", "=", "10", "\n", "random", ".", "seed", "(", "_SEED", ")", "\n", "selector", "=", "RandomKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "6", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "[", "0", ",", "2", ",", "4", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_frame_selector.TestFrameSelector.test_frame_selector_first_k_1": [[30, 37], ["densepose.data.video.FirstKFramesSelector", "list", "densepose.data.video.FirstKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "test_frame_selector_first_k_1", "(", "self", ")", ":", "\n", "        ", "_K", "=", "4", "\n", "selector", "=", "FirstKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "20", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "frame_tss", "[", ":", "_K", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_frame_selector.TestFrameSelector.test_frame_selector_first_k_2": [[38, 45], ["densepose.data.video.FirstKFramesSelector", "list", "densepose.data.video.FirstKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "test_frame_selector_first_k_2", "(", "self", ")", ":", "\n", "        ", "_K", "=", "10", "\n", "selector", "=", "FirstKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "6", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "frame_tss", "[", ":", "_K", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_frame_selector.TestFrameSelector.test_frame_selector_last_k_1": [[46, 53], ["densepose.data.video.LastKFramesSelector", "list", "densepose.data.video.LastKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "test_frame_selector_last_k_1", "(", "self", ")", ":", "\n", "        ", "_K", "=", "4", "\n", "selector", "=", "LastKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "20", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "frame_tss", "[", "-", "_K", ":", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_frame_selector.TestFrameSelector.test_frame_selector_last_k_2": [[54, 61], ["densepose.data.video.LastKFramesSelector", "list", "densepose.data.video.LastKFramesSelector.", "test_frame_selector.TestFrameSelector.assertEqual", "range"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list"], ["", "def", "test_frame_selector_last_k_2", "(", "self", ")", ":", "\n", "        ", "_K", "=", "10", "\n", "selector", "=", "LastKFramesSelector", "(", "_K", ")", "\n", "frame_tss", "=", "list", "(", "range", "(", "0", ",", "6", ",", "2", ")", ")", "\n", "_SELECTED_GT", "=", "frame_tss", "[", "-", "_K", ":", "]", "\n", "selected", "=", "selector", "(", "frame_tss", ")", "\n", "self", ".", "assertEqual", "(", "_SELECTED_GT", ",", "selected", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_e2e.ModelE2ETest.setUp": [[30, 32], ["common.get_model"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_model"], ["def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", "=", "get_model", "(", "self", ".", "CONFIG_PATH", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_e2e.ModelE2ETest._test_eval": [[33, 37], ["test_model_e2e.ModelE2ETest.model.eval", "test_model_e2e.ModelE2ETest.model", "test_model_e2e.make_model_inputs", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_e2e.make_model_inputs"], ["", "def", "_test_eval", "(", "self", ",", "sizes", ")", ":", "\n", "        ", "inputs", "=", "[", "make_model_inputs", "(", "torch", ".", "rand", "(", "3", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ")", ")", "for", "size", "in", "sizes", "]", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "model", "(", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_e2e.DensePoseRCNNE2ETest.test_empty_data": [[42, 44], ["test_model_e2e.DensePoseRCNNE2ETest._test_eval"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_e2e.ModelE2ETest._test_eval"], ["def", "test_empty_data", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_eval", "(", "[", "(", "200", ",", "250", ")", ",", "(", "200", ",", "249", ")", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_e2e.make_model_inputs": [[12, 17], ["None"], "function", ["None"], ["def", "make_model_inputs", "(", "image", ",", "instances", "=", "None", ")", ":", "\n", "    ", "if", "instances", "is", "None", ":", "\n", "        ", "return", "{", "\"image\"", ":", "image", "}", "\n", "\n", "", "return", "{", "\"image\"", ":", "image", ",", "\"instances\"", ":", "instances", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_e2e.make_empty_instances": [[19, 25], ["detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.tensor().to", "detectron2.structures.BitMasks", "torch.rand", "torch.rand", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["", "def", "make_empty_instances", "(", "h", ",", "w", ")", ":", "\n", "    ", "instances", "=", "Instances", "(", "(", "h", ",", "w", ")", ")", "\n", "instances", ".", "gt_boxes", "=", "Boxes", "(", "torch", ".", "rand", "(", "0", ",", "4", ")", ")", "\n", "instances", ".", "gt_classes", "=", "torch", ".", "tensor", "(", "[", "]", ")", ".", "to", "(", "dtype", "=", "torch", ".", "int64", ")", "\n", "instances", ".", "gt_masks", "=", "BitMasks", "(", "torch", ".", "rand", "(", "0", ",", "h", ",", "w", ")", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_setup.TestSetup._test_setup": [[15, 17], ["common.setup"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup"], ["    ", "def", "_test_setup", "(", "self", ",", "config_file", ")", ":", "\n", "        ", "setup", "(", "config_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_setup.TestSetup.test_setup_configs": [[18, 22], ["common.get_config_files", "test_setup.TestSetup._test_setup"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_config_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_setup.TestSetup._test_setup"], ["", "def", "test_setup_configs", "(", "self", ")", ":", "\n", "        ", "config_files", "=", "get_config_files", "(", ")", "\n", "for", "config_file", "in", "config_files", ":", "\n", "            ", "self", ".", "_test_setup", "(", "config_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_setup.TestSetup.test_setup_evolution_configs": [[23, 27], ["common.get_evolution_config_files", "test_setup.TestSetup._test_setup"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_evolution_config_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_setup.TestSetup._test_setup"], ["", "", "def", "test_setup_evolution_configs", "(", "self", ")", ":", "\n", "        ", "config_files", "=", "get_evolution_config_files", "(", ")", "\n", "for", "config_file", "in", "config_files", ":", "\n", "            ", "self", ".", "_test_setup", "(", "config_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_setup.TestSetup.test_setup_hrnet_configs": [[28, 32], ["common.get_hrnet_config_files", "test_setup.TestSetup._test_setup"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_hrnet_config_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_setup.TestSetup._test_setup"], ["", "", "def", "test_setup_hrnet_configs", "(", "self", ")", ":", "\n", "        ", "config_files", "=", "get_hrnet_config_files", "(", ")", "\n", "for", "config_file", "in", "config_files", ":", "\n", "            ", "self", ".", "_test_setup", "(", "config_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_setup.TestSetup.test_setup_quick_schedules_configs": [[33, 37], ["common.get_quick_schedules_config_files", "test_setup.TestSetup._test_setup"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.common.get_quick_schedules_config_files", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_setup.TestSetup._test_setup"], ["", "", "def", "test_setup_quick_schedules_configs", "(", "self", ")", ":", "\n", "        ", "config_files", "=", "get_quick_schedules_config_files", "(", ")", "\n", "for", "config_file", "in", "config_files", ":", "\n", "            ", "self", ".", "_test_setup", "(", "config_file", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_structures.TestStructures.test_normalized_coords_transform": [[9, 26], ["densepose.data.structures.normalized_coords_transform", "test_structures.TestStructures.assertEqual", "test_structures.TestStructures.assertEqual", "test_structures.TestStructures.assertEqual", "test_structures.TestStructures.assertEqual", "densepose.data.structures.normalized_coords_transform.", "densepose.data.structures.normalized_coords_transform.", "densepose.data.structures.normalized_coords_transform.", "densepose.data.structures.normalized_coords_transform."], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.normalized_coords_transform"], ["    ", "def", "test_normalized_coords_transform", "(", "self", ")", ":", "\n", "        ", "bbox", "=", "(", "32", ",", "24", ",", "288", ",", "216", ")", "\n", "x0", ",", "y0", ",", "w", ",", "h", "=", "bbox", "\n", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "x0", ",", "y0", ",", "x0", "+", "w", ",", "y0", "+", "h", "\n", "f", "=", "normalized_coords_transform", "(", "*", "bbox", ")", "\n", "# Top-left", "\n", "expected_p", ",", "actual_p", "=", "(", "-", "1", ",", "-", "1", ")", ",", "f", "(", "(", "xmin", ",", "ymin", ")", ")", "\n", "self", ".", "assertEqual", "(", "expected_p", ",", "actual_p", ")", "\n", "# Top-right", "\n", "expected_p", ",", "actual_p", "=", "(", "1", ",", "-", "1", ")", ",", "f", "(", "(", "xmax", ",", "ymin", ")", ")", "\n", "self", ".", "assertEqual", "(", "expected_p", ",", "actual_p", ")", "\n", "# Bottom-left", "\n", "expected_p", ",", "actual_p", "=", "(", "-", "1", ",", "1", ")", ",", "f", "(", "(", "xmin", ",", "ymax", ")", ")", "\n", "self", ".", "assertEqual", "(", "expected_p", ",", "actual_p", ")", "\n", "# Bottom-right", "\n", "expected_p", ",", "actual_p", "=", "(", "1", ",", "1", ")", ",", "f", "(", "(", "xmax", ",", "ymax", ")", ")", "\n", "self", ".", "assertEqual", "(", "expected_p", ",", "actual_p", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_video_keyframe_dataset.TestVideoKeyframeDataset.test_read_keyframes_all": [[56, 66], ["test_video_keyframe_dataset.TestVideoKeyframeDataset.assertTrue", "test_video_keyframe_dataset.temp_video", "densepose.data.video.VideoKeyframeDataset", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "len", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_video_keyframe_dataset.temp_video"], ["    ", "def", "test_read_keyframes_all", "(", "self", ")", ":", "\n", "        ", "with", "temp_video", "(", "60", ",", "300", ",", "300", ",", "5", ",", "video_codec", "=", "\"mpeg4\"", ")", "as", "(", "fname", ",", "data", ")", ":", "\n", "            ", "video_list", "=", "[", "fname", "]", "\n", "dataset", "=", "VideoKeyframeDataset", "(", "video_list", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "dataset", ")", ",", "1", ")", "\n", "data1", "=", "dataset", "[", "0", "]", "\n", "self", ".", "assertEqual", "(", "data1", ".", "shape", ",", "torch", ".", "Size", "(", "(", "5", ",", "300", ",", "300", ",", "3", ")", ")", ")", "\n", "self", ".", "assertEqual", "(", "data1", ".", "dtype", ",", "torch", ".", "uint8", ")", "\n", "return", "\n", "", "self", ".", "assertTrue", "(", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_video_keyframe_dataset.TestVideoKeyframeDataset.test_read_keyframes_with_selector": [[67, 79], ["test_video_keyframe_dataset.TestVideoKeyframeDataset.assertTrue", "test_video_keyframe_dataset.temp_video", "random.seed", "densepose.data.video.RandomKFramesSelector", "densepose.data.video.VideoKeyframeDataset", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "len", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_video_keyframe_dataset.temp_video"], ["", "def", "test_read_keyframes_with_selector", "(", "self", ")", ":", "\n", "        ", "with", "temp_video", "(", "60", ",", "300", ",", "300", ",", "5", ",", "video_codec", "=", "\"mpeg4\"", ")", "as", "(", "fname", ",", "data", ")", ":", "\n", "            ", "video_list", "=", "[", "fname", "]", "\n", "random", ".", "seed", "(", "0", ")", "\n", "frame_selector", "=", "RandomKFramesSelector", "(", "3", ")", "\n", "dataset", "=", "VideoKeyframeDataset", "(", "video_list", ",", "frame_selector", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "dataset", ")", ",", "1", ")", "\n", "data1", "=", "dataset", "[", "0", "]", "\n", "self", ".", "assertEqual", "(", "data1", ".", "shape", ",", "torch", ".", "Size", "(", "(", "3", ",", "300", ",", "300", ",", "3", ")", ")", ")", "\n", "self", ".", "assertEqual", "(", "data1", ".", "dtype", ",", "torch", ".", "uint8", ")", "\n", "return", "\n", "", "self", ".", "assertTrue", "(", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_video_keyframe_dataset.TestVideoKeyframeDataset.test_read_keyframes_with_selector_with_transform": [[80, 93], ["test_video_keyframe_dataset.TestVideoKeyframeDataset.assertTrue", "test_video_keyframe_dataset.temp_video", "random.seed", "densepose.data.video.RandomKFramesSelector", "densepose.data.transform.ImageResizeTransform", "densepose.data.video.VideoKeyframeDataset", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "test_video_keyframe_dataset.TestVideoKeyframeDataset.assertEqual", "len", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_video_keyframe_dataset.temp_video"], ["", "def", "test_read_keyframes_with_selector_with_transform", "(", "self", ")", ":", "\n", "        ", "with", "temp_video", "(", "60", ",", "300", ",", "300", ",", "5", ",", "video_codec", "=", "\"mpeg4\"", ")", "as", "(", "fname", ",", "data", ")", ":", "\n", "            ", "video_list", "=", "[", "fname", "]", "\n", "random", ".", "seed", "(", "0", ")", "\n", "frame_selector", "=", "RandomKFramesSelector", "(", "1", ")", "\n", "transform", "=", "ImageResizeTransform", "(", ")", "\n", "dataset", "=", "VideoKeyframeDataset", "(", "video_list", ",", "frame_selector", ",", "transform", ")", "\n", "data1", "=", "dataset", "[", "0", "]", "\n", "self", ".", "assertEqual", "(", "len", "(", "dataset", ")", ",", "1", ")", "\n", "self", ".", "assertEqual", "(", "data1", ".", "shape", ",", "torch", ".", "Size", "(", "(", "1", ",", "3", ",", "800", ",", "800", ")", ")", ")", "\n", "self", ".", "assertEqual", "(", "data1", ".", "dtype", ",", "torch", ".", "float32", ")", "\n", "return", "\n", "", "self", ".", "assertTrue", "(", "False", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_video_keyframe_dataset._create_video_frames": [[21, 30], ["torch.meshgrid", "range", "torch.stack", "torch.linspace", "torch.linspace", "data.append", "float", "torch.exp", "d.unsqueeze().repeat().byte", "float", "d.unsqueeze().repeat", "d.unsqueeze"], "function", ["None"], ["", "def", "_create_video_frames", "(", "num_frames", ",", "height", ",", "width", ")", ":", "\n", "    ", "y", ",", "x", "=", "torch", ".", "meshgrid", "(", "torch", ".", "linspace", "(", "-", "2", ",", "2", ",", "height", ")", ",", "torch", ".", "linspace", "(", "-", "2", ",", "2", ",", "width", ")", ")", "\n", "data", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_frames", ")", ":", "\n", "        ", "xc", "=", "float", "(", "i", ")", "/", "num_frames", "\n", "yc", "=", "1", "-", "float", "(", "i", ")", "/", "(", "2", "*", "num_frames", ")", "\n", "d", "=", "torch", ".", "exp", "(", "-", "(", "(", "x", "-", "xc", ")", "**", "2", "+", "(", "y", "-", "yc", ")", "**", "2", ")", "/", "2", ")", "*", "255", "\n", "data", ".", "append", "(", "d", ".", "unsqueeze", "(", "2", ")", ".", "repeat", "(", "1", ",", "1", ",", "3", ")", ".", "byte", "(", ")", ")", "\n", "", "return", "torch", ".", "stack", "(", "data", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_video_keyframe_dataset.temp_video": [[33, 52], ["test_video_keyframe_dataset._create_video_frames", "os.unlink", "tempfile.NamedTemporaryFile", "f.close", "torchvision.write_video", "ValueError", "ValueError"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_video_keyframe_dataset._create_video_frames", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close"], ["", "@", "contextlib", ".", "contextmanager", "\n", "def", "temp_video", "(", "num_frames", ",", "height", ",", "width", ",", "fps", ",", "lossless", "=", "False", ",", "video_codec", "=", "None", ",", "options", "=", "None", ")", ":", "\n", "    ", "if", "lossless", ":", "\n", "        ", "if", "video_codec", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"video_codec can't be specified together with lossless\"", ")", "\n", "", "if", "options", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"options can't be specified together with lossless\"", ")", "\n", "", "video_codec", "=", "\"libx264rgb\"", "\n", "options", "=", "{", "\"crf\"", ":", "\"0\"", "}", "\n", "", "if", "video_codec", "is", "None", ":", "\n", "        ", "video_codec", "=", "\"libx264\"", "\n", "", "if", "options", "is", "None", ":", "\n", "        ", "options", "=", "{", "}", "\n", "", "data", "=", "_create_video_frames", "(", "num_frames", ",", "height", ",", "width", ")", "\n", "with", "tempfile", ".", "NamedTemporaryFile", "(", "suffix", "=", "\".mp4\"", ")", "as", "f", ":", "\n", "        ", "f", ".", "close", "(", ")", "\n", "io", ".", "write_video", "(", "f", ".", "name", ",", "data", ",", "fps", "=", "fps", ",", "video_codec", "=", "video_codec", ",", "options", "=", "options", ")", "\n", "yield", "f", ".", "name", ",", "data", "\n", "", "os", ".", "unlink", "(", "f", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestProjects.test_import": [[8, 16], ["None"], "methods", ["None"], ["    ", "def", "test_import", "(", "self", ")", ":", "\n", "        ", "from", "detectron2", ".", "projects", "import", "point_rend", "\n", "\n", "_", "=", "point_rend", ".", "add_pointrend_config", "\n", "\n", "import", "detectron2", ".", "projects", ".", "deeplab", "as", "deeplab", "\n", "\n", "_", "=", "deeplab", ".", "add_deeplab_config", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test": [[23, 25], ["detectron2.utils.collect_env.collect_env_info"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.collect_env.collect_env_info"], ["    ", "def", "test", "(", "self", ")", ":", "\n", "        ", "_", "=", "collect_env_info", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_zoo.TestModelZoo.test_get_returns_model": [[12, 16], ["detectron2.model_zoo.get", "test_model_zoo.TestModelZoo.assertIsInstance", "test_model_zoo.TestModelZoo.assertIsInstance"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["    ", "def", "test_get_returns_model", "(", "self", ")", ":", "\n", "        ", "model", "=", "model_zoo", ".", "get", "(", "\"Misc/scratch_mask_rcnn_R_50_FPN_3x_gn.yaml\"", ",", "trained", "=", "False", ")", "\n", "self", ".", "assertIsInstance", "(", "model", ",", "GeneralizedRCNN", ")", "\n", "self", ".", "assertIsInstance", "(", "model", ".", "backbone", ",", "FPN", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_zoo.TestModelZoo.test_get_invalid_model": [[17, 19], ["test_model_zoo.TestModelZoo.assertRaises"], "methods", ["None"], ["", "def", "test_get_invalid_model", "(", "self", ")", ":", "\n", "        ", "self", ".", "assertRaises", "(", "RuntimeError", ",", "model_zoo", ".", "get", ",", "\"Invalid/config.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_zoo.TestModelZoo.test_get_url": [[20, 25], ["detectron2.model_zoo.get_checkpoint_url", "test_model_zoo.TestModelZoo.assertEqual"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get_checkpoint_url"], ["", "def", "test_get_url", "(", "self", ")", ":", "\n", "        ", "url", "=", "model_zoo", ".", "get_checkpoint_url", "(", "\"Misc/scratch_mask_rcnn_R_50_FPN_3x_gn.yaml\"", ")", "\n", "self", ".", "assertEqual", "(", "\n", "url", ",", "\n", "\"https://dl.fbaipublicfiles.com/detectron2/Misc/scratch_mask_rcnn_R_50_FPN_3x_gn/138602908/model_final_01ca85.pkl\"", ",", "# noqa", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.RetinaNetTest.setUp": [[26, 28], ["test_model_analysis.get_model_zoo"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.get_model_zoo"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", "=", "get_model_zoo", "(", "\"COCO-Detection/retinanet_R_50_FPN_1x.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.RetinaNetTest.test_flop": [[29, 34], ["detectron2.utils.analysis.flop_count_operators", "test_model_analysis.RetinaNetTest.assertTrue", "int", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis.flop_count_operators"], ["", "def", "test_flop", "(", "self", ")", ":", "\n", "# RetinaNet supports flop-counting with random inputs", "\n", "        ", "inputs", "=", "[", "{", "\"image\"", ":", "torch", ".", "rand", "(", "3", ",", "800", ",", "800", ")", "}", "]", "\n", "res", "=", "flop_count_operators", "(", "self", ".", "model", ",", "inputs", ")", "\n", "self", ".", "assertTrue", "(", "int", "(", "res", "[", "\"conv\"", "]", ")", ",", "146", ")", "# 146B flops", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.RetinaNetTest.test_param_count": [[35, 39], ["detectron2.utils.analysis.parameter_count", "test_model_analysis.RetinaNetTest.assertTrue", "test_model_analysis.RetinaNetTest.assertTrue"], "methods", ["None"], ["", "def", "test_param_count", "(", "self", ")", ":", "\n", "        ", "res", "=", "parameter_count", "(", "self", ".", "model", ")", "\n", "self", ".", "assertTrue", "(", "res", "[", "\"\"", "]", ",", "37915572", ")", "\n", "self", ".", "assertTrue", "(", "res", "[", "\"backbone\"", "]", ",", "31452352", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.FasterRCNNTest.setUp": [[42, 44], ["test_model_analysis.get_model_zoo"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.get_model_zoo"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", "=", "get_model_zoo", "(", "\"COCO-Detection/faster_rcnn_R_50_FPN_1x.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.FasterRCNNTest.test_flop": [[45, 54], ["detectron2.utils.analysis.flop_count_operators", "test_model_analysis.FasterRCNNTest.assertTrue", "int", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.analysis.flop_count_operators"], ["", "def", "test_flop", "(", "self", ")", ":", "\n", "# Faster R-CNN supports flop-counting with random inputs", "\n", "        ", "inputs", "=", "[", "{", "\"image\"", ":", "torch", ".", "rand", "(", "3", ",", "800", ",", "800", ")", "}", "]", "\n", "res", "=", "flop_count_operators", "(", "self", ".", "model", ",", "inputs", ")", "\n", "\n", "# This only checks flops for backbone & proposal generator", "\n", "# Flops for box head is not conv, and depends on #proposals, which is", "\n", "# almost 0 for random inputs.", "\n", "self", ".", "assertTrue", "(", "int", "(", "res", "[", "\"conv\"", "]", ")", ",", "117", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.FasterRCNNTest.test_param_count": [[55, 59], ["detectron2.utils.analysis.parameter_count", "test_model_analysis.FasterRCNNTest.assertTrue", "test_model_analysis.FasterRCNNTest.assertTrue"], "methods", ["None"], ["", "def", "test_param_count", "(", "self", ")", ":", "\n", "        ", "res", "=", "parameter_count", "(", "self", ".", "model", ")", "\n", "self", ".", "assertTrue", "(", "res", "[", "\"\"", "]", ",", "41699936", ")", "\n", "self", ".", "assertTrue", "(", "res", "[", "\"backbone\"", "]", ",", "26799296", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_model_analysis.get_model_zoo": [[13, 23], ["detectron2.get_config_file", "detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.modeling.build_model", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get_config_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model"], ["def", "get_model_zoo", "(", "config_path", ")", ":", "\n", "    ", "\"\"\"\n    Like model_zoo.get, but do not load any weights (even pretrained)\n    \"\"\"", "\n", "cfg_file", "=", "model_zoo", ".", "get_config_file", "(", "config_path", ")", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "cfg_file", ")", "\n", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "cfg", ".", "MODEL", ".", "DEVICE", "=", "\"cpu\"", "\n", "", "return", "build_model", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigVersioning.test_upgrade_downgrade_consistency": [[27, 35], ["detectron2.config.get_cfg", "detectron2.config.downgrade_config", "detectron2.config.upgrade_config", "test_config.TestConfigVersioning.assertTrue"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.downgrade_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.compat.upgrade_config"], ["    ", "def", "test_upgrade_downgrade_consistency", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "# check that custom is preserved", "\n", "cfg", ".", "USER_CUSTOM", "=", "1", "\n", "\n", "down", "=", "downgrade_config", "(", "cfg", ",", "to_version", "=", "0", ")", "\n", "up", "=", "upgrade_config", "(", "down", ")", "\n", "self", ".", "assertTrue", "(", "up", "==", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigVersioning._merge_cfg_str": [[36, 45], ["tempfile.NamedTemporaryFile", "tempfile.NamedTemporaryFile.write", "tempfile.NamedTemporaryFile.close", "cfg.merge_from_file", "os.remove"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.remove"], ["", "def", "_merge_cfg_str", "(", "self", ",", "cfg", ",", "merge_str", ")", ":", "\n", "        ", "f", "=", "tempfile", ".", "NamedTemporaryFile", "(", "mode", "=", "\"w\"", ",", "suffix", "=", "\".yaml\"", ",", "delete", "=", "False", ")", "\n", "try", ":", "\n", "            ", "f", ".", "write", "(", "merge_str", ")", "\n", "f", ".", "close", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "f", ".", "name", ")", "\n", "", "finally", ":", "\n", "            ", "os", ".", "remove", "(", "f", ".", "name", ")", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigVersioning.test_auto_upgrade": [[46, 55], ["detectron2.config.get_cfg", "test_config.TestConfigVersioning._merge_cfg_str", "test_config.TestConfigVersioning.assertEqual", "test_config.TestConfigVersioning.assertEqual"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigVersioning._merge_cfg_str"], ["", "def", "test_auto_upgrade", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "latest_ver", "=", "cfg", ".", "VERSION", "\n", "cfg", ".", "USER_CUSTOM", "=", "1", "\n", "\n", "self", ".", "_merge_cfg_str", "(", "cfg", ",", "_V0_CFG", ")", "\n", "\n", "self", ".", "assertEqual", "(", "cfg", ".", "MODEL", ".", "RPN", ".", "HEAD_NAME", ",", "\"TEST\"", ")", "\n", "self", ".", "assertEqual", "(", "cfg", ".", "VERSION", ",", "latest_ver", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigVersioning.test_guess_v1": [[56, 61], ["detectron2.config.get_cfg", "test_config.TestConfigVersioning._merge_cfg_str", "test_config.TestConfigVersioning.assertEqual"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigVersioning._merge_cfg_str"], ["", "def", "test_guess_v1", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "latest_ver", "=", "cfg", ".", "VERSION", "\n", "self", ".", "_merge_cfg_str", "(", "cfg", ",", "_V1_CFG", ")", "\n", "self", ".", "assertEqual", "(", "cfg", ".", "VERSION", ",", "latest_ver", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config._TestClassA.__init__": [[64, 73], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "arg1", ",", "arg2", ",", "arg3", "=", "3", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "arg1", "=", "arg1", "\n", "self", ".", "arg2", "=", "arg2", "\n", "self", ".", "arg3", "=", "arg3", "\n", "assert", "arg1", "==", "1", "\n", "assert", "arg2", "==", "2", "\n", "assert", "arg3", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config._TestClassA.from_config": [[74, 78], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "args", "=", "{", "\"arg1\"", ":", "cfg", ".", "ARG1", ",", "\"arg2\"", ":", "cfg", ".", "ARG2", "}", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config._TestClassB.__init__": [[81, 88], ["test_config._TestClassA.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ",", "arg1", ",", "arg2", ",", "arg3", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Doc of _TestClassB\n        \"\"\"", "\n", "assert", "input_shape", "==", "\"shape\"", "\n", "super", "(", ")", ".", "__init__", "(", "arg1", ",", "arg2", ",", "arg3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config._TestClassB.from_config": [[89, 94], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "# test extra positional arg in from_config", "\n", "        ", "args", "=", "{", "\"arg1\"", ":", "cfg", ".", "ARG1", ",", "\"arg2\"", ":", "cfg", ".", "ARG2", "}", "\n", "args", "[", "\"input_shape\"", "]", "=", "input_shape", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config._LegacySubClass.__init__": [[98, 103], ["test_config._TestClassB.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ",", "arg4", "=", "4", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "assert", "self", ".", "arg1", "==", "1", "\n", "assert", "self", ".", "arg2", "==", "2", "\n", "assert", "self", ".", "arg3", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config._NewSubClassNewInit.__init__": [[107, 113], ["test_config._TestClassB.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ",", "arg4", "=", "4", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "input_shape", ",", "**", "kwargs", ")", "\n", "assert", "self", ".", "arg1", "==", "1", "\n", "assert", "self", ".", "arg2", "==", "2", "\n", "assert", "self", ".", "arg3", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config._LegacySubClassNotCfg.__init__": [[117, 122], ["test_config._TestClassB.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "config", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "config", ",", "input_shape", ")", "\n", "assert", "self", ".", "arg1", "==", "1", "\n", "assert", "self", ".", "arg2", "==", "2", "\n", "assert", "self", ".", "arg3", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config._TestClassC.from_config": [[125, 131], ["args.update"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ",", "**", "kwargs", ")", ":", "# test extra kwarg overwrite", "\n", "        ", "args", "=", "{", "\"arg1\"", ":", "cfg", ".", "ARG1", ",", "\"arg2\"", ":", "cfg", ".", "ARG2", "}", "\n", "args", "[", "\"input_shape\"", "]", "=", "input_shape", "\n", "args", ".", "update", "(", "kwargs", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config._TestClassD.__init__": [[134, 138], ["test_config._TestClassA.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "input_shape", ":", "ShapeSpec", ",", "arg1", ":", "int", ",", "arg2", ",", "arg3", "=", "3", ")", ":", "\n", "        ", "assert", "input_shape", "==", "\"shape\"", "\n", "super", "(", ")", ".", "__init__", "(", "arg1", ",", "arg2", ",", "arg3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigurable.testInitWithArgs": [[144, 149], ["test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD"], "methods", ["None"], ["    ", "def", "testInitWithArgs", "(", "self", ")", ":", "\n", "        ", "_", "=", "_TestClassA", "(", "arg1", "=", "1", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassB", "(", "\"shape\"", ",", "arg1", "=", "1", ",", "arg2", "=", "2", ")", "\n", "_", "=", "_TestClassC", "(", "\"shape\"", ",", "arg1", "=", "1", ",", "arg2", "=", "2", ")", "\n", "_", "=", "_TestClassD", "(", "\"shape\"", ",", "arg1", "=", "1", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigurable.testPatchedAttr": [[150, 153], ["test_config.TestConfigurable.assertTrue", "test_config.TestConfigurable.assertEqual"], "methods", ["None"], ["", "def", "testPatchedAttr", "(", "self", ")", ":", "\n", "        ", "self", ".", "assertTrue", "(", "\"Doc\"", "in", "_TestClassB", ".", "__init__", ".", "__doc__", ")", "\n", "self", ".", "assertEqual", "(", "_TestClassD", ".", "__init__", ".", "__annotations__", "[", "\"arg1\"", "]", ",", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigurable.testInitWithCfg": [[154, 178], ["detectron2.config.get_cfg", "test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD", "test_config._LegacySubClass", "test_config._NewSubClassNewInit", "test_config._LegacySubClassNotCfg", "test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD", "test_config._LegacySubClass", "test_config._NewSubClassNewInit", "test_config._LegacySubClassNotCfg", "test_config.TestConfigurable.assertRaises", "test_config._TestClassD"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg"], ["", "def", "testInitWithCfg", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "ARG1", "=", "1", "\n", "cfg", ".", "ARG2", "=", "2", "\n", "cfg", ".", "ARG3", "=", "3", "\n", "_", "=", "_TestClassA", "(", "cfg", ")", "\n", "_", "=", "_TestClassB", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_TestClassC", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_TestClassD", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_LegacySubClass", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_NewSubClassNewInit", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_LegacySubClassNotCfg", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "# disallow forwarding positional args to __init__ since it's prone to errors", "\n", "            ", "_", "=", "_TestClassD", "(", "cfg", ",", "\"shape\"", ")", "\n", "\n", "# call with kwargs instead", "\n", "", "_", "=", "_TestClassA", "(", "cfg", "=", "cfg", ")", "\n", "_", "=", "_TestClassB", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_TestClassC", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_TestClassD", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_LegacySubClass", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_NewSubClassNewInit", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "_", "=", "_LegacySubClassNotCfg", "(", "config", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigurable.testInitWithCfgOverwrite": [[179, 197], ["detectron2.config.get_cfg", "test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD", "test_config._TestClassA", "test_config._TestClassB", "test_config._TestClassC", "test_config._TestClassD", "test_config.TestConfigurable.assertRaises", "test_config._TestClassA"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg"], ["", "def", "testInitWithCfgOverwrite", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "ARG1", "=", "1", "\n", "cfg", ".", "ARG2", "=", "999", "# wrong config", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "_TestClassA", "(", "cfg", ",", "arg3", "=", "3", ")", "\n", "\n", "# overwrite arg2 with correct config later:", "\n", "", "_", "=", "_TestClassA", "(", "cfg", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassB", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassC", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassD", "(", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "\n", "# call with kwargs cfg=cfg instead", "\n", "_", "=", "_TestClassA", "(", "cfg", "=", "cfg", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassB", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassC", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "_", "=", "_TestClassD", "(", "cfg", "=", "cfg", ",", "input_shape", "=", "\"shape\"", ",", "arg2", "=", "2", ",", "arg3", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigurable.testInitWithCfgWrongArgs": [[198, 208], ["detectron2.config.get_cfg", "test_config.TestConfigurable.assertRaises", "test_config._TestClassB", "test_config.TestConfigurable.assertRaises", "test_config._TestClassC", "test_config.TestConfigurable.assertRaises", "test_config._TestClassD"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg"], ["", "def", "testInitWithCfgWrongArgs", "(", "self", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "ARG1", "=", "1", "\n", "cfg", ".", "ARG2", "=", "2", "\n", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_TestClassB", "(", "cfg", ",", "\"shape\"", ",", "not_exist", "=", "1", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_TestClassC", "(", "cfg", ",", "\"shape\"", ",", "not_exist", "=", "1", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_TestClassD", "(", "cfg", ",", "\"shape\"", ",", "not_exist", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_config.TestConfigurable.testBadClass": [[209, 241], ["test_config.TestConfigurable.assertRaises", "_BadClass1", "test_config.TestConfigurable.assertRaises", "_BadClass2", "test_config.TestConfigurable.assertRaises", "_BadClass3", "detectron2.config.get_cfg"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg"], ["", "", "def", "testBadClass", "(", "self", ")", ":", "\n", "        ", "class", "_BadClass1", ":", "\n", "            ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "a", "=", "1", ",", "b", "=", "2", ")", ":", "\n", "                ", "pass", "\n", "\n", "", "", "class", "_BadClass2", ":", "\n", "            ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "a", "=", "1", ",", "b", "=", "2", ")", ":", "\n", "                ", "pass", "\n", "\n", "", "def", "from_config", "(", "self", ",", "cfg", ")", ":", "# noqa", "\n", "                ", "pass", "\n", "\n", "", "", "class", "_BadClass3", ":", "\n", "            ", "@", "configurable", "\n", "def", "__init__", "(", "self", ",", "a", "=", "1", ",", "b", "=", "2", ")", ":", "\n", "                ", "pass", "\n", "\n", "# bad name: must be cfg", "\n", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "config", ")", ":", "# noqa", "\n", "                ", "pass", "\n", "\n", "", "", "with", "self", ".", "assertRaises", "(", "AttributeError", ")", ":", "\n", "            ", "_", "=", "_BadClass1", "(", "a", "=", "1", ")", "\n", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_BadClass2", "(", "a", "=", "1", ")", "\n", "\n", "", "with", "self", ".", "assertRaises", "(", "TypeError", ")", ":", "\n", "            ", "_", "=", "_BadClass3", "(", "get_cfg", "(", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export.setUp": [[23, 25], ["detectron2.utils.logger.setup_logger"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "setup_logger", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export._test_model": [[26, 45], ["detectron2.config.get_cfg", "add_export_config.merge_from_file", "add_export_config", "detectron2.modeling.build_model", "detectron2.checkpoint.DetectionCheckpointer().load", "export_caffe2_model", "detectron2.model_zoo.get_config_file", "detectron2.model_zoo.get_checkpoint_url", "copy.deepcopy", "tempfile.TemporaryDirectory", "Caffe2Model.load_protobuf.save_protobuf", "Caffe2Model.load_protobuf.save_graph", "Caffe2Model.load_protobuf", "test_export_caffe2.TestCaffe2Export._get_test_image", "detectron2.checkpoint.DetectionCheckpointer", "os.path.join", "Caffe2Model.load_protobuf.", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.add_export_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.export_caffe2_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get_config_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.model_zoo.model_zoo.get_checkpoint_url", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.save_protobuf", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.save_graph", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.api.Caffe2Model.load_protobuf", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export._get_test_image"], ["", "def", "_test_model", "(", "self", ",", "config_path", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "# requires extra dependencies", "\n", "        ", "from", "detectron2", ".", "export", "import", "Caffe2Model", ",", "add_export_config", ",", "export_caffe2_model", "\n", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "model_zoo", ".", "get_config_file", "(", "config_path", ")", ")", "\n", "cfg", "=", "add_export_config", "(", "cfg", ")", "\n", "cfg", ".", "MODEL", ".", "DEVICE", "=", "device", "\n", "\n", "inputs", "=", "[", "{", "\"image\"", ":", "self", ".", "_get_test_image", "(", ")", "}", "]", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ")", ".", "load", "(", "model_zoo", ".", "get_checkpoint_url", "(", "config_path", ")", ")", "\n", "c2_model", "=", "export_caffe2_model", "(", "cfg", ",", "model", ",", "copy", ".", "deepcopy", "(", "inputs", ")", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_unittest\"", ")", "as", "d", ":", "\n", "            ", "c2_model", ".", "save_protobuf", "(", "d", ")", "\n", "c2_model", ".", "save_graph", "(", "os", ".", "path", ".", "join", "(", "d", ",", "\"test.svg\"", ")", ",", "inputs", "=", "copy", ".", "deepcopy", "(", "inputs", ")", ")", "\n", "c2_model", "=", "Caffe2Model", ".", "load_protobuf", "(", "d", ")", "\n", "", "c2_model", "(", "inputs", ")", "[", "0", "]", "[", "\"instances\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export._get_test_image": [[46, 58], ["cv2.imdecode", "torch.from_numpy", "fvcore.common.file_io.PathManager.exists", "fvcore.common.file_io.PathManager.open", "f.read", "numpy.frombuffer", "cv2.imdecode.transpose", "test_export_caffe2.TestCaffe2Export.skipTest", "detectron2.data.DatasetCatalog.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "_get_test_image", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "file_name", "=", "DatasetCatalog", ".", "get", "(", "\"coco_2017_train\"", ")", "[", "0", "]", "[", "\"file_name\"", "]", "\n", "assert", "PathManager", ".", "exists", "(", "file_name", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "self", ".", "skipTest", "(", "\"COCO dataset not available.\"", ")", "\n", "\n", "", "with", "PathManager", ".", "open", "(", "file_name", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "buf", "=", "f", ".", "read", "(", ")", "\n", "", "img", "=", "cv2", ".", "imdecode", "(", "np", ".", "frombuffer", "(", "buf", ",", "dtype", "=", "np", ".", "uint8", ")", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "assert", "img", "is", "not", "None", ",", "file_name", "\n", "return", "torch", ".", "from_numpy", "(", "img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export.testMaskRCNN": [[59, 61], ["test_export_caffe2.TestCaffe2Export._test_model"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export._test_model"], ["", "def", "testMaskRCNN", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_model", "(", "\"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export.testMaskRCNNGPU": [[62, 65], ["unittest.skipIf", "test_export_caffe2.TestCaffe2Export._test_model", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export._test_model"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "testMaskRCNNGPU", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_model", "(", "\"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml\"", ",", "device", "=", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export.testRetinaNet": [[66, 68], ["test_export_caffe2.TestCaffe2Export._test_model"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export._test_model"], ["", "def", "testRetinaNet", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_model", "(", "\"COCO-Detection/retinanet_R_50_FPN_3x.yaml\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export.testPanopticFPN": [[69, 71], ["test_export_caffe2.TestCaffe2Export._test_model"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_export_caffe2.TestCaffe2Export._test_model"], ["", "def", "testPanopticFPN", "(", "self", ")", ":", "\n", "        ", "self", ".", "_test_model", "(", "\"COCO-PanopticSegmentation/panoptic_fpn_R_50_3x.yaml\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_checkpoint.TestCheckpointer.setUp": [[12, 14], ["detectron2.utils.logger.setup_logger"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "setup_logger", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_checkpoint.TestCheckpointer.create_complex_model": [[15, 31], ["torch.nn.Module", "torch.nn.Module", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Module", "torch.nn.Linear", "collections.OrderedDict", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand"], "methods", ["None"], ["", "def", "create_complex_model", "(", "self", ")", ":", "\n", "        ", "m", "=", "nn", ".", "Module", "(", ")", "\n", "m", ".", "block1", "=", "nn", ".", "Module", "(", ")", "\n", "m", ".", "block1", ".", "layer1", "=", "nn", ".", "Linear", "(", "2", ",", "3", ")", "\n", "m", ".", "layer2", "=", "nn", ".", "Linear", "(", "3", ",", "2", ")", "\n", "m", ".", "res", "=", "nn", ".", "Module", "(", ")", "\n", "m", ".", "res", ".", "layer2", "=", "nn", ".", "Linear", "(", "3", ",", "2", ")", "\n", "\n", "state_dict", "=", "OrderedDict", "(", ")", "\n", "state_dict", "[", "\"layer1.weight\"", "]", "=", "torch", ".", "rand", "(", "3", ",", "2", ")", "\n", "state_dict", "[", "\"layer1.bias\"", "]", "=", "torch", ".", "rand", "(", "3", ")", "\n", "state_dict", "[", "\"layer2.weight\"", "]", "=", "torch", ".", "rand", "(", "2", ",", "3", ")", "\n", "state_dict", "[", "\"layer2.bias\"", "]", "=", "torch", ".", "rand", "(", "2", ")", "\n", "state_dict", "[", "\"res.layer2.weight\"", "]", "=", "torch", ".", "rand", "(", "2", ",", "3", ")", "\n", "state_dict", "[", "\"res.layer2.bias\"", "]", "=", "torch", ".", "rand", "(", "2", ")", "\n", "return", "m", ",", "state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_checkpoint.TestCheckpointer.test_complex_model_loaded": [[32, 45], ["test_checkpoint.TestCheckpointer.create_complex_model", "torch.nn.DataParallel.state_dict", "detectron2.checkpoint.c2_model_loading.align_and_update_state_dicts", "zip", "torch.nn.DataParallel", "nn.DataParallel.state_dict.values", "state_dict.values", "test_checkpoint.TestCheckpointer.assertFalse", "test_checkpoint.TestCheckpointer.assertTrue", "loaded.equal", "id", "id"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_checkpoint.TestCheckpointer.create_complex_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.checkpoint.c2_model_loading.align_and_update_state_dicts"], ["", "def", "test_complex_model_loaded", "(", "self", ")", ":", "\n", "        ", "for", "add_data_parallel", "in", "[", "False", ",", "True", "]", ":", "\n", "            ", "model", ",", "state_dict", "=", "self", ".", "create_complex_model", "(", ")", "\n", "if", "add_data_parallel", ":", "\n", "                ", "model", "=", "nn", ".", "DataParallel", "(", "model", ")", "\n", "", "model_sd", "=", "model", ".", "state_dict", "(", ")", "\n", "\n", "align_and_update_state_dicts", "(", "model_sd", ",", "state_dict", ")", "\n", "for", "loaded", ",", "stored", "in", "zip", "(", "model_sd", ".", "values", "(", ")", ",", "state_dict", ".", "values", "(", ")", ")", ":", "\n", "# different tensor references", "\n", "                ", "self", ".", "assertFalse", "(", "id", "(", "loaded", ")", "==", "id", "(", "stored", ")", ")", "\n", "# same content", "\n", "self", ".", "assertTrue", "(", "loaded", ".", "equal", "(", "stored", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_engine.SimpleModel.__init__": [[17, 21], ["torch.nn.Module.__init__", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "sleep_sec", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mod", "=", "nn", ".", "Linear", "(", "10", ",", "20", ")", "\n", "self", ".", "sleep_sec", "=", "sleep_sec", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_engine.SimpleModel.forward": [[22, 26], ["time.sleep", "x.sum", "sum", "x.mean", "test_engine.SimpleModel.parameters"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "sleep_sec", ">", "0", ":", "\n", "            ", "time", ".", "sleep", "(", "self", ".", "sleep_sec", ")", "\n", "", "return", "{", "\"loss\"", ":", "x", ".", "sum", "(", ")", "+", "sum", "(", "[", "x", ".", "mean", "(", ")", "for", "x", "in", "self", ".", "parameters", "(", ")", "]", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_engine.TestTrainer._data_loader": [[29, 33], ["torch.device", "torch.rand().to", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["    ", "def", "_data_loader", "(", "self", ",", "device", ")", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "device", ")", "\n", "while", "True", ":", "\n", "            ", "yield", "torch", ".", "rand", "(", "3", ",", "3", ")", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_engine.TestTrainer.test_simple_trainer": [[34, 40], ["SimpleModel().to", "detectron2.engine.SimpleTrainer", "detectron2.engine.SimpleTrainer.train", "test_engine.TestTrainer._data_loader", "torch.optim.SGD", "test_engine.SimpleModel", "SimpleModel().to.parameters"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_engine.TestTrainer._data_loader"], ["", "", "def", "test_simple_trainer", "(", "self", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "        ", "model", "=", "SimpleModel", "(", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "trainer", "=", "SimpleTrainer", "(", "\n", "model", ",", "self", ".", "_data_loader", "(", "device", ")", ",", "torch", ".", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "0.1", ")", "\n", ")", "\n", "trainer", ".", "train", "(", "0", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_engine.TestTrainer.test_simple_trainer_cuda": [[41, 44], ["unittest.skipIf", "test_engine.TestTrainer.test_simple_trainer", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_engine.TestTrainer.test_simple_trainer"], ["", "@", "unittest", ".", "skipIf", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\"CUDA not available\"", ")", "\n", "def", "test_simple_trainer_cuda", "(", "self", ")", ":", "\n", "        ", "self", ".", "test_simple_trainer", "(", "device", "=", "\"cuda\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_engine.TestTrainer.test_writer_hooks": [[45, 76], ["test_engine.SimpleModel", "detectron2.engine.SimpleTrainer", "test_engine.TestTrainer._data_loader", "torch.optim.SGD", "tempfile.TemporaryDirectory", "os.path.join", "mock.MagicMock", "detectron2.engine.SimpleTrainer.register_hooks", "detectron2.engine.SimpleTrainer.train", "test_engine.TestTrainer.assertEqual", "zip", "test_engine.TestTrainer.assertIn", "SimpleModel.parameters", "detectron2.utils.events.CommonMetricPrinter", "detectron2.utils.events.JSONWriter", "open", "test_engine.TestTrainer.assertEqual", "test_engine.TestTrainer.assertIn", "str", "len", "test_engine.TestTrainer.assertIn", "detectron2.engine.hooks.EvalHook", "detectron2.engine.hooks.PeriodicWriter", "json.loads", "line.strip"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_engine.TestTrainer._data_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train"], ["", "def", "test_writer_hooks", "(", "self", ")", ":", "\n", "        ", "model", "=", "SimpleModel", "(", "sleep_sec", "=", "0.1", ")", "\n", "trainer", "=", "SimpleTrainer", "(", "\n", "model", ",", "self", ".", "_data_loader", "(", "\"cpu\"", ")", ",", "torch", ".", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "0.1", ")", "\n", ")", "\n", "\n", "max_iter", "=", "50", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_test\"", ")", "as", "d", ":", "\n", "            ", "json_file", "=", "os", ".", "path", ".", "join", "(", "d", ",", "\"metrics.json\"", ")", "\n", "writers", "=", "[", "CommonMetricPrinter", "(", "max_iter", ")", ",", "JSONWriter", "(", "json_file", ")", "]", "\n", "logger_info", "=", "writers", "[", "0", "]", ".", "logger", ".", "info", "=", "MagicMock", "(", ")", "\n", "\n", "trainer", ".", "register_hooks", "(", "\n", "[", "hooks", ".", "EvalHook", "(", "0", ",", "lambda", ":", "{", "\"metric\"", ":", "100", "}", ")", ",", "hooks", ".", "PeriodicWriter", "(", "writers", ")", "]", "\n", ")", "\n", "trainer", ".", "train", "(", "0", ",", "max_iter", ")", "\n", "\n", "with", "open", "(", "json_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "data", "=", "[", "json", ".", "loads", "(", "line", ".", "strip", "(", ")", ")", "for", "line", "in", "f", "]", "\n", "self", ".", "assertEqual", "(", "[", "x", "[", "\"iteration\"", "]", "for", "x", "in", "data", "]", ",", "[", "19", ",", "39", ",", "49", ",", "50", "]", ")", "\n", "# the eval metric is in the last line with iter 50", "\n", "self", ".", "assertIn", "(", "\"metric\"", ",", "data", "[", "-", "1", "]", ",", "\"Eval metric must be in last line of JSON!\"", ")", "\n", "\n", "# test logged messages from CommonMetricPrinter", "\n", "", "all_logs", "=", "[", "str", "(", "x", ")", "for", "x", "in", "logger_info", ".", "call_args_list", "]", "\n", "self", ".", "assertEqual", "(", "len", "(", "all_logs", ")", ",", "3", ")", "\n", "for", "log", ",", "iter", "in", "zip", "(", "all_logs", ",", "[", "19", ",", "39", ",", "49", "]", ")", ":", "\n", "                ", "self", ".", "assertIn", "(", "f\"iter: {iter}\"", ",", "log", ")", "\n", "\n", "", "self", ".", "assertIn", "(", "\"eta: 0:00:00\"", ",", "all_logs", "[", "-", "1", "]", ",", "\"Last ETA must be 0!\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_events.TestEventWriter.testScalar": [[11, 26], ["tempfile.TemporaryDirectory", "detectron2.utils.events.EventStorage", "os.path.join", "detectron2.utils.events.JSONWriter", "range", "detectron2.utils.events.JSONWriter.close", "storage.put_scalar", "storage.step", "open", "test_events.TestEventWriter.assertTrue", "detectron2.utils.events.JSONWriter.write", "json.loads", "int"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write"], ["    ", "def", "testScalar", "(", "self", ")", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", "\n", "prefix", "=", "\"detectron2_tests\"", "\n", ")", "as", "dir", ",", "EventStorage", "(", ")", "as", "storage", ":", "\n", "            ", "json_file", "=", "os", ".", "path", ".", "join", "(", "dir", ",", "\"test.json\"", ")", "\n", "writer", "=", "JSONWriter", "(", "json_file", ")", "\n", "for", "k", "in", "range", "(", "60", ")", ":", "\n", "                ", "storage", ".", "put_scalar", "(", "\"key\"", ",", "k", ",", "smoothing_hint", "=", "False", ")", "\n", "if", "(", "k", "+", "1", ")", "%", "20", "==", "0", ":", "\n", "                    ", "writer", ".", "write", "(", ")", "\n", "", "storage", ".", "step", "(", ")", "\n", "", "writer", ".", "close", "(", ")", "\n", "with", "open", "(", "json_file", ")", "as", "f", ":", "\n", "                ", "data", "=", "[", "json", ".", "loads", "(", "l", ")", "for", "l", "in", "f", "]", "\n", "self", ".", "assertTrue", "(", "[", "int", "(", "k", "[", "\"key\"", "]", ")", "for", "k", "in", "data", "]", "==", "[", "19", ",", "39", ",", "59", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_events.TestEventWriter.testScalarMismatchedPeriod": [[27, 47], ["tempfile.TemporaryDirectory", "detectron2.utils.events.EventStorage", "os.path.join", "detectron2.utils.events.JSONWriter", "range", "detectron2.utils.events.JSONWriter.close", "storage.put_scalar", "storage.step", "open", "test_events.TestEventWriter.assertTrue", "test_events.TestEventWriter.assertTrue", "test_events.TestEventWriter.assertTrue", "storage.put_scalar", "detectron2.utils.events.JSONWriter.write", "json.loads", "int", "int", "int", "k.get", "k.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.step", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.SampleCountMetricPrinter.write", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "", "def", "testScalarMismatchedPeriod", "(", "self", ")", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", "\n", "prefix", "=", "\"detectron2_tests\"", "\n", ")", "as", "dir", ",", "EventStorage", "(", ")", "as", "storage", ":", "\n", "            ", "json_file", "=", "os", ".", "path", ".", "join", "(", "dir", ",", "\"test.json\"", ")", "\n", "\n", "writer", "=", "JSONWriter", "(", "json_file", ")", "\n", "for", "k", "in", "range", "(", "60", ")", ":", "\n", "                ", "if", "k", "%", "17", "==", "0", ":", "# write in a differnt period", "\n", "                    ", "storage", ".", "put_scalar", "(", "\"key2\"", ",", "k", ",", "smoothing_hint", "=", "False", ")", "\n", "", "storage", ".", "put_scalar", "(", "\"key\"", ",", "k", ",", "smoothing_hint", "=", "False", ")", "\n", "if", "(", "k", "+", "1", ")", "%", "20", "==", "0", ":", "\n", "                    ", "writer", ".", "write", "(", ")", "\n", "", "storage", ".", "step", "(", ")", "\n", "", "writer", ".", "close", "(", ")", "\n", "with", "open", "(", "json_file", ")", "as", "f", ":", "\n", "                ", "data", "=", "[", "json", ".", "loads", "(", "l", ")", "for", "l", "in", "f", "]", "\n", "self", ".", "assertTrue", "(", "[", "int", "(", "k", ".", "get", "(", "\"key2\"", ",", "0", ")", ")", "for", "k", "in", "data", "]", "==", "[", "17", ",", "0", ",", "34", ",", "0", ",", "51", ",", "0", "]", ")", "\n", "self", ".", "assertTrue", "(", "[", "int", "(", "k", ".", "get", "(", "\"key\"", ",", "0", ")", ")", "for", "k", "in", "data", "]", "==", "[", "0", ",", "19", ",", "0", ",", "39", ",", "0", ",", "59", "]", ")", "\n", "self", ".", "assertTrue", "(", "[", "int", "(", "k", "[", "\"iteration\"", "]", ")", "for", "k", "in", "data", "]", "==", "[", "17", ",", "19", ",", "34", ",", "39", ",", "51", ",", "59", "]", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer._random_data": [[17, 34], ["numpy.concatenate", "numpy.zeros_like", "numpy.random.rand", "numpy.random.rand", "str", "numpy.random.rand().flatten", "test_visualizer.TestVisualizer._random_data._rand_poly"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["    ", "def", "_random_data", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "100", ",", "100", "\n", "N", "=", "10", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "H", ",", "W", ",", "3", ")", "*", "255", "\n", "boxxy", "=", "np", ".", "random", ".", "rand", "(", "N", ",", "2", ")", "*", "(", "H", "//", "2", ")", "\n", "boxes", "=", "np", ".", "concatenate", "(", "(", "boxxy", ",", "boxxy", "+", "H", "//", "2", ")", ",", "axis", "=", "1", ")", "\n", "\n", "def", "_rand_poly", "(", ")", ":", "\n", "            ", "return", "np", ".", "random", ".", "rand", "(", "3", ",", "2", ")", ".", "flatten", "(", ")", "*", "H", "\n", "\n", "", "polygons", "=", "[", "[", "_rand_poly", "(", ")", "for", "_", "in", "range", "(", "np", ".", "random", ".", "randint", "(", "1", ",", "5", ")", ")", "]", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "\n", "mask", "=", "np", ".", "zeros_like", "(", "img", "[", ":", ",", ":", ",", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "mask", "[", ":", "40", ",", "10", ":", "20", "]", "=", "1", "\n", "\n", "labels", "=", "[", "str", "(", "i", ")", "for", "i", "in", "range", "(", "N", ")", "]", "\n", "return", "img", ",", "boxes", ",", "labels", ",", "polygons", ",", "[", "mask", "]", "*", "N", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.metadata": [[35, 38], ["detectron2.data.MetadataCatalog.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "@", "property", "\n", "def", "metadata", "(", "self", ")", ":", "\n", "        ", "return", "MetadataCatalog", ".", "get", "(", "\"coco_2017_train\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_draw_dataset_dict": [[39, 65], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_dataset_dict", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_dataset_dict"], ["", "def", "test_draw_dataset_dict", "(", "self", ")", ":", "\n", "        ", "img", "=", "np", ".", "random", ".", "rand", "(", "512", ",", "512", ",", "3", ")", "*", "255", "\n", "dic", "=", "{", "\n", "\"annotations\"", ":", "[", "\n", "{", "\n", "\"bbox\"", ":", "[", "\n", "368.9946492271106", ",", "\n", "330.891438763377", ",", "\n", "13.148537455410235", ",", "\n", "13.644708680142685", ",", "\n", "]", ",", "\n", "\"bbox_mode\"", ":", "BoxMode", ".", "XYWH_ABS", ",", "\n", "\"category_id\"", ":", "0", ",", "\n", "\"iscrowd\"", ":", "1", ",", "\n", "\"segmentation\"", ":", "{", "\n", "\"counts\"", ":", "\"_jh52m?2N2N2N2O100O10O001N1O2MceP2\"", ",", "\n", "\"size\"", ":", "[", "512", ",", "512", "]", ",", "\n", "}", ",", "\n", "}", "\n", "]", ",", "\n", "\"height\"", ":", "512", ",", "\n", "\"image_id\"", ":", "1", ",", "\n", "\"width\"", ":", "512", ",", "\n", "}", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "v", ".", "draw_dataset_dict", "(", "dic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_overlay_instances": [[66, 82], ["test_visualizer.TestVisualizer._random_data", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "test_visualizer.TestVisualizer.assertEqual", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "test_visualizer.TestVisualizer.assertEqual", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "test_visualizer.TestVisualizer.assertEqual", "detectron2.utils.visualizer.Visualizer.overlay_instances", "detectron2.utils.visualizer.Visualizer.overlay_instances", "detectron2.utils.visualizer.Visualizer.overlay_instances"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances"], ["", "def", "test_overlay_instances", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "labels", ",", "polygons", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "output", "=", "v", ".", "overlay_instances", "(", "masks", "=", "polygons", ",", "boxes", "=", "boxes", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "img", ".", "shape", ")", "\n", "\n", "# Test 2x scaling", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ",", "scale", "=", "2.0", ")", "\n", "output", "=", "v", ".", "overlay_instances", "(", "masks", "=", "polygons", ",", "boxes", "=", "boxes", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "0", "]", "*", "2", ")", "\n", "\n", "# Test overlay masks", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "output", "=", "v", ".", "overlay_instances", "(", "masks", "=", "masks", ",", "boxes", "=", "boxes", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "img", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_overlay_instances_no_boxes": [[83, 87], ["test_visualizer.TestVisualizer._random_data", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "detectron2.utils.visualizer.Visualizer.overlay_instances"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances"], ["", "def", "test_overlay_instances_no_boxes", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "labels", ",", "polygons", ",", "_", "=", "self", ".", "_random_data", "(", ")", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "v", ".", "overlay_instances", "(", "masks", "=", "polygons", ",", "boxes", "=", "None", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_draw_instance_predictions": [[88, 99], ["test_visualizer.TestVisualizer._random_data", "len", "detectron2.structures.Instances", "torch.randint", "torch.rand", "torch.from_numpy", "torch.from_numpy", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_instance_predictions"], ["", "def", "test_draw_instance_predictions", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "num_inst", "=", "len", "(", "boxes", ")", "\n", "inst", "=", "Instances", "(", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", ")", "\n", "inst", ".", "pred_classes", "=", "torch", ".", "randint", "(", "0", ",", "80", ",", "size", "=", "(", "num_inst", ",", ")", ")", "\n", "inst", ".", "scores", "=", "torch", ".", "rand", "(", "num_inst", ")", "\n", "inst", ".", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "boxes", ")", "\n", "inst", ".", "pred_masks", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "masks", ")", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "v", ".", "draw_instance_predictions", "(", "inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_BWmode_nomask": [[100, 110], ["test_visualizer.TestVisualizer._random_data", "len", "detectron2.structures.Instances", "torch.randint", "torch.rand", "torch.from_numpy", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_instance_predictions"], ["", "def", "test_BWmode_nomask", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "num_inst", "=", "len", "(", "boxes", ")", "\n", "inst", "=", "Instances", "(", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", ")", "\n", "inst", ".", "pred_classes", "=", "torch", ".", "randint", "(", "0", ",", "80", ",", "size", "=", "(", "num_inst", ",", ")", ")", "\n", "inst", ".", "scores", "=", "torch", ".", "rand", "(", "num_inst", ")", "\n", "inst", ".", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "boxes", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE_BW", ")", "\n", "v", ".", "draw_instance_predictions", "(", "inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_draw_empty_mask_predictions": [[111, 122], ["test_visualizer.TestVisualizer._random_data", "len", "detectron2.structures.Instances", "torch.randint", "torch.rand", "torch.from_numpy", "torch.from_numpy", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "numpy.zeros_like", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_instance_predictions"], ["", "def", "test_draw_empty_mask_predictions", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "num_inst", "=", "len", "(", "boxes", ")", "\n", "inst", "=", "Instances", "(", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", ")", "\n", "inst", ".", "pred_classes", "=", "torch", ".", "randint", "(", "0", ",", "80", ",", "size", "=", "(", "num_inst", ",", ")", ")", "\n", "inst", ".", "scores", "=", "torch", ".", "rand", "(", "num_inst", ")", "\n", "inst", ".", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "boxes", ")", "\n", "inst", ".", "pred_masks", "=", "torch", ".", "from_numpy", "(", "np", ".", "zeros_like", "(", "np", ".", "asarray", "(", "masks", ")", ")", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "v", ".", "draw_instance_predictions", "(", "inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_correct_output_shape": [[123, 128], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.output.get_image", "test_visualizer.TestVisualizer.assertEqual", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image"], ["", "def", "test_correct_output_shape", "(", "self", ")", ":", "\n", "        ", "img", "=", "np", ".", "random", ".", "rand", "(", "928", ",", "928", ",", "3", ")", "*", "255", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "out", "=", "v", ".", "output", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "out", ".", "shape", ",", "img", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_overlay_rotated_instances": [[129, 145], ["torch.zeros", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "detectron2.structures.RotatedBoxes", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.overlay_instances().get_image", "test_visualizer.TestVisualizer.assertEqual", "numpy.random.rand", "max", "max", "str", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "range", "detectron2.utils.visualizer.Visualizer.overlay_instances"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.overlay_instances"], ["", "def", "test_overlay_rotated_instances", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "100", ",", "150", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "H", ",", "W", ",", "3", ")", "*", "255", "\n", "num_boxes", "=", "50", "\n", "boxes_5d", "=", "torch", ".", "zeros", "(", "num_boxes", ",", "5", ")", "\n", "boxes_5d", "[", ":", ",", "0", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "0.1", "*", "W", ",", "1.1", "*", "W", ")", "\n", "boxes_5d", "[", ":", ",", "1", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "0.1", "*", "H", ",", "1.1", "*", "H", ")", "\n", "boxes_5d", "[", ":", ",", "2", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "max", "(", "W", ",", "H", ")", ")", "\n", "boxes_5d", "[", ":", ",", "3", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "0", ",", "max", "(", "W", ",", "H", ")", ")", "\n", "boxes_5d", "[", ":", ",", "4", "]", "=", "torch", ".", "FloatTensor", "(", "num_boxes", ")", ".", "uniform_", "(", "-", "1800", ",", "1800", ")", "\n", "rotated_boxes", "=", "RotatedBoxes", "(", "boxes_5d", ")", "\n", "labels", "=", "[", "str", "(", "i", ")", "for", "i", "in", "range", "(", "num_boxes", ")", "]", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "self", ".", "metadata", ")", "\n", "output", "=", "v", ".", "overlay_instances", "(", "boxes", "=", "rotated_boxes", ",", "labels", "=", "labels", ")", ".", "get_image", "(", ")", "\n", "self", ".", "assertEqual", "(", "output", ".", "shape", ",", "img", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_draw_no_metadata": [[146, 157], ["test_visualizer.TestVisualizer._random_data", "len", "detectron2.structures.Instances", "torch.randint", "torch.rand", "torch.from_numpy", "torch.from_numpy", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "numpy.asarray", "detectron2.data.MetadataCatalog.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "def", "test_draw_no_metadata", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "num_inst", "=", "len", "(", "boxes", ")", "\n", "inst", "=", "Instances", "(", "(", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", ")", ")", "\n", "inst", ".", "pred_classes", "=", "torch", ".", "randint", "(", "0", ",", "80", ",", "size", "=", "(", "num_inst", ",", ")", ")", "\n", "inst", ".", "scores", "=", "torch", ".", "rand", "(", "num_inst", ")", "\n", "inst", ".", "pred_boxes", "=", "torch", ".", "from_numpy", "(", "boxes", ")", "\n", "inst", ".", "pred_masks", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "masks", ")", ")", "\n", "\n", "v", "=", "Visualizer", "(", "img", ",", "MetadataCatalog", ".", "get", "(", "\"asdfasdf\"", ")", ")", "\n", "v", ".", "draw_instance_predictions", "(", "inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_draw_binary_mask": [[158, 178], ["test_visualizer.TestVisualizer._random_data", "numpy.zeros_like().astype", "cv2.rectangle", "numpy.zeros_like", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_binary_mask", "test_visualizer.TestVisualizer.assertTrue", "o.get_image().astype.get_image().astype.get_image().astype", "tempfile.TemporaryDirectory", "os.path.join", "o.get_image().astype.get_image().astype.save", "o[].sum", "cv2.imread", "o.get_image().astype.get_image().astype.get_image"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer._random_data", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_binary_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image"], ["", "def", "test_draw_binary_mask", "(", "self", ")", ":", "\n", "        ", "img", ",", "boxes", ",", "_", ",", "_", ",", "masks", "=", "self", ".", "_random_data", "(", ")", "\n", "img", "[", ":", ",", ":", ",", "0", "]", "=", "0", "# remove red color", "\n", "mask", "=", "masks", "[", "0", "]", "\n", "mask_with_hole", "=", "np", ".", "zeros_like", "(", "mask", ")", ".", "astype", "(", "\"uint8\"", ")", "\n", "mask_with_hole", "=", "cv2", ".", "rectangle", "(", "mask_with_hole", ",", "(", "10", ",", "10", ")", ",", "(", "50", ",", "50", ")", ",", "1", ",", "5", ")", "\n", "\n", "for", "m", "in", "[", "mask", ",", "mask_with_hole", "]", ":", "\n", "            ", "for", "save", "in", "[", "True", ",", "False", "]", ":", "\n", "                ", "v", "=", "Visualizer", "(", "img", ")", "\n", "o", "=", "v", ".", "draw_binary_mask", "(", "m", ",", "color", "=", "\"red\"", ",", "text", "=", "\"test\"", ")", "\n", "if", "save", ":", "\n", "                    ", "with", "tempfile", ".", "TemporaryDirectory", "(", "prefix", "=", "\"detectron2_viz\"", ")", "as", "d", ":", "\n", "                        ", "path", "=", "os", ".", "path", ".", "join", "(", "d", ",", "\"output.png\"", ")", "\n", "o", ".", "save", "(", "path", ")", "\n", "o", "=", "cv2", ".", "imread", "(", "path", ")", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "", "", "else", ":", "\n", "                    ", "o", "=", "o", ".", "get_image", "(", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "# red color is drawn on the image", "\n", "", "self", ".", "assertTrue", "(", "o", "[", ":", ",", ":", ",", "0", "]", ".", "sum", "(", ")", ">", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_visualizer.TestVisualizer.test_border": [[179, 199], ["numpy.zeros", "detectron2.utils.visualizer.Visualizer", "numpy.zeros", "cv2.rectangle", "detectron2.utils.visualizer.Visualizer.draw_binary_mask", "test_visualizer.TestVisualizer.assertEqual", "test_visualizer.TestVisualizer.assertEqual", "test_visualizer.TestVisualizer.assertIn", "test_visualizer.TestVisualizer.assertIn", "detectron2.utils.visualizer.Visualizer.draw_binary_mask.get_image", "tuple", "tuple", "len", "len", "x.tolist", "x.tolist"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.Visualizer.draw_binary_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.get_image"], ["", "", "", "def", "test_border", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "200", ",", "200", "\n", "img", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "3", ")", ")", "\n", "img", "[", ":", ",", ":", ",", "0", "]", "=", "255.0", "\n", "v", "=", "Visualizer", "(", "img", ",", "scale", "=", "3", ")", "\n", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ")", ")", "\n", "mask", "[", ":", ",", "100", ":", "150", "]", "=", "1", "\n", "# create a hole, to trigger imshow", "\n", "mask", "=", "cv2", ".", "rectangle", "(", "mask", ",", "(", "110", ",", "110", ")", ",", "(", "130", ",", "130", ")", ",", "0", ",", "thickness", "=", "-", "1", ")", "\n", "output", "=", "v", ".", "draw_binary_mask", "(", "mask", ",", "color", "=", "\"blue\"", ")", "\n", "output", "=", "output", ".", "get_image", "(", ")", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "\n", "first_row", "=", "{", "tuple", "(", "x", ".", "tolist", "(", ")", ")", "for", "x", "in", "output", "[", "0", "]", "}", "\n", "last_row", "=", "{", "tuple", "(", "x", ".", "tolist", "(", ")", ")", "for", "x", "in", "output", "[", "-", "1", "]", "}", "\n", "# check quantization / off-by-1 error: the first and last row must have two colors", "\n", "self", ".", "assertEqual", "(", "len", "(", "last_row", ")", ",", "2", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "first_row", ")", ",", "2", ")", "\n", "self", ".", "assertIn", "(", "(", "0", ",", "0", ",", "255", ")", ",", "last_row", ")", "\n", "self", ".", "assertIn", "(", "(", "0", ",", "0", ",", "255", ")", ",", "first_row", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DeepLab.train_net.Trainer.build_evaluator": [[50, 84], ["detectron2.evaluation.DatasetEvaluators", "detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "detectron2.data.MetadataCatalog.get", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "len", "NotImplementedError", "len", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.get_rank"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["\n", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Create evaluator(s) for a given dataset.\n        This uses the special metadata \"evaluator_type\" associated with each builtin dataset.\n        For your own dataset, you can simply create an evaluator manually in your\n        script and do not have to worry about the hacky if-else logic here.\n        \"\"\"", "\n", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluator_list", "=", "[", "]", "\n", "evaluator_type", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "evaluator_type", "\n", "if", "evaluator_type", "in", "[", "\"sem_seg\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "\n", "SemSegEvaluator", "(", "\n", "dataset_name", ",", "\n", "distributed", "=", "True", ",", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", ",", "\n", "ignore_label", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", ",", "\n", "output_dir", "=", "output_folder", ",", "\n", ")", "\n", ")", "\n", "", "if", "evaluator_type", "in", "[", "\"coco\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"coco_panoptic_seg\"", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOPanopticEvaluator", "(", "dataset_name", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_instance\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesInstanceEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_sem_seg\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DeepLab.train_net.Trainer.build_train_loader": [[85, 92], ["detectron2.data.build_detection_train_loader", "detectron2.data.build_detection_train_loader", "detectron2.data.DatasetMapper", "detectron2.data.DatasetMapper", "train_net.build_sem_seg_train_aug"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.build_sem_seg_train_aug"], [")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesSemSegEvaluator", "(", "dataset_name", ")", "\n", "", "elif", "evaluator_type", "==", "\"pascal_voc\"", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ",", "cfg", ")", "\n", "", "elif", "evaluator_type", "==", "\"lvis\"", ":", "\n", "            ", "return", "LVISEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "", "if", "len", "(", "evaluator_list", ")", "==", "0", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DeepLab.train_net.Trainer.build_lr_scheduler": [[93, 100], ["detectron2.projects.deeplab.build_lr_scheduler", "detectron2.projects.deeplab.build_lr_scheduler"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.build_solver.build_lr_scheduler", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.build_solver.build_lr_scheduler"], ["\"no Evaluator for the dataset {} with the type {}\"", ".", "format", "(", "\n", "dataset_name", ",", "evaluator_type", "\n", ")", "\n", ")", "\n", "", "elif", "len", "(", "evaluator_list", ")", "==", "1", ":", "\n", "            ", "return", "evaluator_list", "[", "0", "]", "\n", "", "return", "DatasetEvaluators", "(", "evaluator_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DeepLab.train_net.build_sem_seg_train_aug": [[23, 40], ["augs.append", "detectron2.ResizeShortestEdge", "augs.append", "detectron2.RandomFlip", "detectron2.RandomCrop_CategoryAreaConstraint"], "function", ["None"], ["\n", "import", "detectron2", ".", "utils", ".", "comm", "as", "comm", "\n", "from", "detectron2", ".", "checkpoint", "import", "DetectionCheckpointer", "\n", "from", "detectron2", ".", "config", "import", "get_cfg", "\n", "from", "detectron2", ".", "data", "import", "MetadataCatalog", "\n", "from", "detectron2", ".", "engine", "import", "DefaultTrainer", ",", "default_argument_parser", ",", "default_setup", ",", "hooks", ",", "launch", "\n", "from", "detectron2", ".", "evaluation", "import", "(", "\n", "CityscapesInstanceEvaluator", ",", "\n", "CityscapesSemSegEvaluator", ",", "\n", "COCOEvaluator", ",", "\n", "COCOPanopticEvaluator", ",", "\n", "DatasetEvaluators", ",", "\n", "LVISEvaluator", ",", "\n", "PascalVOCDetectionEvaluator", ",", "\n", "SemSegEvaluator", ",", "\n", "verify_results", ",", "\n", ")", "\n", "from", "detectron2", ".", "modeling", "import", "GeneralizedRCNNWithTTA", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DeepLab.train_net.setup": [[102, 113], ["detectron2.config.get_cfg", "detectron2.projects.deeplab.add_deeplab_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.config.add_deeplab_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup"], ["def", "test_with_TTA", "(", "cls", ",", "cfg", ",", "model", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "\"detectron2.trainer\"", ")", "\n", "# In the end of training, run an evaluation with TTA", "\n", "# Only support some R-CNN models.", "\n", "logger", ".", "info", "(", "\"Running inference with test-time augmentation ...\"", ")", "\n", "model", "=", "GeneralizedRCNNWithTTA", "(", "cfg", ",", "model", ")", "\n", "evaluators", "=", "[", "\n", "cls", ".", "build_evaluator", "(", "\n", "cfg", ",", "name", ",", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference_TTA\"", ")", "\n", ")", "\n", "for", "name", "in", "cfg", ".", "DATASETS", ".", "TEST", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DeepLab.train_net.main": [[115, 129], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test"], ["res", "=", "OrderedDict", "(", "{", "k", "+", "\"_TTA\"", ":", "v", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "}", ")", "\n", "return", "res", "\n", "\n", "\n", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.config.add_deeplab_config": [[5, 28], ["None"], "function", ["None"], ["import", "inspect", "\n", "import", "logging", "\n", "from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.loss.DeepLabCE.__init__": [[20, 26], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "ignore_label", "=", "-", "1", ",", "top_k_percent_pixels", "=", "1.0", ",", "weight", "=", "None", ")", ":", "\n", "        ", "super", "(", "DeepLabCE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "top_k_percent_pixels", "=", "top_k_percent_pixels", "\n", "self", ".", "ignore_label", "=", "ignore_label", "\n", "self", ".", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", "\n", "weight", "=", "weight", ",", "ignore_index", "=", "ignore_label", ",", "reduction", "=", "\"none\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.loss.DeepLabCE.forward": [[28, 41], ["int", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "pixel_losses.contiguous().view.contiguous().view.mean", "loss.DeepLabCE.criterion().contiguous().view", "pixel_losses.contiguous().view.contiguous().view.contiguous().view", "pixel_losses.contiguous().view.contiguous().view.mean", "loss.DeepLabCE.criterion", "pixel_losses.contiguous().view.contiguous().view.numel", "loss.DeepLabCE.criterion().contiguous", "pixel_losses.contiguous().view.contiguous().view.contiguous", "loss.DeepLabCE.criterion"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "logits", ",", "labels", ",", "weights", "=", "None", ")", ":", "\n", "        ", "if", "weights", "is", "None", ":", "\n", "            ", "pixel_losses", "=", "self", ".", "criterion", "(", "logits", ",", "labels", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "# Apply per-pixel loss weights.", "\n", "            ", "pixel_losses", "=", "self", ".", "criterion", "(", "logits", ",", "labels", ")", "*", "weights", "\n", "pixel_losses", "=", "pixel_losses", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "", "if", "self", ".", "top_k_percent_pixels", "==", "1.0", ":", "\n", "            ", "return", "pixel_losses", ".", "mean", "(", ")", "\n", "\n", "", "top_k_pixels", "=", "int", "(", "self", ".", "top_k_percent_pixels", "*", "pixel_losses", ".", "numel", "(", ")", ")", "\n", "pixel_losses", ",", "_", "=", "torch", ".", "topk", "(", "pixel_losses", ",", "top_k_pixels", ")", "\n", "return", "pixel_losses", ".", "mean", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.resnet.DeepLabStem.__init__": [[19, 57], ["detectron2.layers.CNNBlockBase.__init__", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "fvcore.c2_msra_fill", "fvcore.c2_msra_fill", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["from", ".", "build", "import", "BACKBONE_REGISTRY", "\n", "\n", "__all__", "=", "[", "\n", "\"ResNetBlockBase\"", ",", "\n", "\"BasicBlock\"", ",", "\n", "\"BottleneckBlock\"", ",", "\n", "\"DeformBottleneckBlock\"", ",", "\n", "\"BasicStem\"", ",", "\n", "\"ResNet\"", ",", "\n", "\"make_stage\"", ",", "\n", "\"build_resnet_backbone\"", ",", "\n", "]", "\n", "\n", "\n", "class", "BasicBlock", "(", "CNNBlockBase", ")", ":", "\n", "    ", "\"\"\"\n    The basic residual block for ResNet-18 and ResNet-34 defined in :paper:`ResNet`,\n    with two 3x3 conv layers and a projection shortcut if needed.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "*", ",", "stride", "=", "1", ",", "norm", "=", "\"BN\"", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            in_channels (int): Number of input channels.\n            out_channels (int): Number of output channels.\n            stride (int): Stride for the first conv.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.resnet.DeepLabStem.forward": [[58, 67], ["resnet.DeepLabStem.conv1", "torch.relu_", "resnet.DeepLabStem.conv2", "torch.relu_", "resnet.DeepLabStem.conv3", "torch.relu_", "torch.max_pool2d"], "methods", ["None"], [")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.resnet.build_resnet_deeplab_backbone": [[69, 158], ["detectron2.modeling.BACKBONE_REGISTRY.register", "max", "enumerate", "detectron2.modeling.backbone.resnet.ResNet().freeze", "detectron2.modeling.backbone.resnet.BasicStem", "range", "detectron2.modeling.backbone.resnet.ResNet.make_stage", "stages.append", "resnet.DeepLabStem", "ValueError", "stage_kargs.pop", "detectron2.modeling.backbone.resnet.ResNet"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.make_stage"], ["norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv2", "=", "Conv2d", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "+=", "shortcut", "\n", "out", "=", "F", ".", "relu_", "(", "out", ")", "\n", "return", "out", "\n", "\n", "\n", "", "", "class", "BottleneckBlock", "(", "CNNBlockBase", ")", ":", "\n", "    ", "\"\"\"\n    The standard bottleneck residual block used by ResNet-50, 101 and 152\n    defined in :paper:`ResNet`.  It contains 3 conv layers with kernels\n    1x1, 3x3, 1x1, and a projection shortcut if needed.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "dilation", "=", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            bottleneck_channels (int): number of output channels for the 3x3\n                \"bottleneck\" conv layers.\n            num_groups (int): number of groups for the 3x3 conv layer.\n            norm (str or callable): normalization for all conv layers.\n                See :func:`layers.get_norm` for supported format.\n            stride_in_1x1 (bool): when stride>1, whether to put stride in the\n                first 1x1 convolution or the bottleneck 3x3 convolution.\n            dilation (int): the dilation rate of the 3x3 conv layer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "# The original MSRA ResNet models have stride in the first 1x1 conv", "\n", "# The subsequent fb.torch.resnet and Caffe2 ResNe[X]t implementations have", "\n", "# stride in the 3x3 conv", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.build_solver.build_lr_scheduler": [[10, 29], ["lr_scheduler.WarmupPolyLR", "detectron2.solver.build_lr_scheduler"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.build_solver.build_lr_scheduler"], ["def", "build_lr_scheduler", "(", "\n", "cfg", ":", "CfgNode", ",", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", "\n", ")", "->", "torch", ".", "optim", ".", "lr_scheduler", ".", "_LRScheduler", ":", "\n", "    ", "\"\"\"\n    Build a LR scheduler from config.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "SOLVER", ".", "LR_SCHEDULER_NAME", "\n", "if", "name", "==", "\"WarmupPolyLR\"", ":", "\n", "        ", "return", "WarmupPolyLR", "(", "\n", "optimizer", ",", "\n", "cfg", ".", "SOLVER", ".", "MAX_ITER", ",", "\n", "warmup_factor", "=", "cfg", ".", "SOLVER", ".", "WARMUP_FACTOR", ",", "\n", "warmup_iters", "=", "cfg", ".", "SOLVER", ".", "WARMUP_ITERS", ",", "\n", "warmup_method", "=", "cfg", ".", "SOLVER", ".", "WARMUP_METHOD", ",", "\n", "power", "=", "cfg", ".", "SOLVER", ".", "POLY_LR_POWER", ",", "\n", "constant_ending", "=", "cfg", ".", "SOLVER", ".", "POLY_LR_CONSTANT_ENDING", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "return", "build_d2_lr_scheduler", "(", "cfg", ",", "optimizer", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.lr_scheduler.WarmupPolyLR.__init__": [[25, 43], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "if", "not", "list", "(", "milestones", ")", "==", "sorted", "(", "milestones", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Milestones should be a list of\"", "\" increasing integers. Got {}\"", ",", "milestones", "\n", ")", "\n", "", "self", ".", "milestones", "=", "milestones", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n", "", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "warmup_factor", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "self", ".", "last_epoch", ",", "self", ".", "warmup_iters", ",", "self", ".", "warmup_factor", "\n", ")", "\n", "return", "[", "\n", "base_lr", "*", "warmup_factor", "*", "self", ".", "gamma", "**", "bisect_right", "(", "self", ".", "milestones", ",", "self", ".", "last_epoch", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.lr_scheduler.WarmupPolyLR.get_lr": [[44, 58], ["detectron2.solver.lr_scheduler._get_warmup_factor_at_iter", "math.pow", "math.pow"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.solver.lr_scheduler._get_warmup_factor_at_iter"], ["for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n", "\n", "", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n", "\n", "", "", "class", "WarmupCosineLR", "(", "torch", ".", "optim", ".", "lr_scheduler", ".", "_LRScheduler", ")", ":", "\n", "    ", "def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", ",", "\n", "max_iters", ":", "int", ",", "\n", "warmup_factor", ":", "float", "=", "0.001", ",", "\n", "warmup_iters", ":", "int", "=", "1000", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.lr_scheduler.WarmupPolyLR._compute_values": [[60, 63], ["lr_scheduler.WarmupPolyLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.lr_scheduler.WarmupPolyLR.get_lr"], ["last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.__init__": [[21, 171], ["torch.nn.Module.__init__", "torch.nn.ModuleDict", "enumerate", "len", "len", "len", "len", "len", "len", "torch.nn.ModuleDict", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "len", "len", "detectron2.layers.ASPP", "detectron2.layers.Conv2d", "torch.nn.Sequential", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "fvcore.c2_xavier_fill", "torch.nn.CrossEntropyLoss", "len", "detectron2.layers.Conv2d", "detectron2.layers.Conv2d", "loss.DeepLabCE", "ValueError", "ValueError", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["SEM_SEG_HEADS_REGISTRY", ".", "__doc__", "=", "\"\"\"\nRegistry for semantic segmentation heads, which make semantic segmentation predictions\nfrom feature maps.\n\"\"\"", "\n", "\n", "\n", "@", "META_ARCH_REGISTRY", ".", "register", "(", ")", "\n", "class", "SemanticSegmentor", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    Main class for semantic segmentation architectures.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "cfg", ")", "\n", "self", ".", "sem_seg_head", "=", "build_sem_seg_head", "(", "cfg", ",", "self", ".", "backbone", ".", "output_shape", "(", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_mean\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_MEAN", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"pixel_std\"", ",", "torch", ".", "Tensor", "(", "cfg", ".", "MODEL", ".", "PIXEL_STD", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "pixel_mean", ".", "device", "\n", "\n", "", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.\n                Each item in the list contains the inputs for one image.\n\n                For now, each item in the list is a dict that contains:\n\n                   * \"image\": Tensor, image in (C, H, W) format.\n                   * \"sem_seg\": semantic segmentation ground truth\n                   * Other information that's included in the original dicts, such as:\n                     \"height\", \"width\" (int): the output resolution of the model (may be different\n                     from input resolution), used in inference.\n\n\n        Returns:\n            list[dict]:\n              Each dict is the output for one input image.\n              The dict contains one key \"sem_seg\" whose value is a\n              Tensor that represents the\n              per-pixel segmentation prediced by the head.\n              The prediction has shape KxHxW that represents the logits of\n              each class for each pixel.\n        \"\"\"", "\n", "images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "targets", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "targets", ",", "self", ".", "backbone", ".", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "targets", "=", "None", "\n", "", "results", ",", "losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "targets", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ")", "\n", "r", "=", "sem_seg_postprocess", "(", "result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n", "\n", "", "", "def", "build_sem_seg_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a semantic segmentation head from `cfg.MODEL.SEM_SEG_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NAME", "\n", "return", "SEM_SEG_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "\n", "", "@", "SEM_SEG_HEADS_REGISTRY", ".", "register", "(", ")", "\n", "class", "SemSegFPNHead", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    A semantic segmentation head described in :paper:`PanopticFPN`.\n    It takes FPN features as input and merges information from all\n    levels of the FPN into single output.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IN_FEATURES", "\n", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "feature_channels", "=", "{", "k", ":", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "self", ".", "ignore_value", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "CONVS_DIM", "\n", "self", ".", "common_stride", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "COMMON_STRIDE", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NORM", "\n", "self", ".", "loss_weight", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_WEIGHT", "\n", "# fmt: on", "\n", "\n", "self", ".", "scale_heads", "=", "[", "]", "\n", "for", "in_feature", "in", "self", ".", "in_features", ":", "\n", "            ", "head_ops", "=", "[", "]", "\n", "head_length", "=", "max", "(", "\n", "1", ",", "int", "(", "np", ".", "log2", "(", "feature_strides", "[", "in_feature", "]", ")", "-", "np", ".", "log2", "(", "self", ".", "common_stride", ")", ")", "\n", ")", "\n", "for", "k", "in", "range", "(", "head_length", ")", ":", "\n", "                ", "norm_module", "=", "nn", ".", "GroupNorm", "(", "32", ",", "conv_dims", ")", "if", "norm", "==", "\"GN\"", "else", "None", "\n", "conv", "=", "Conv2d", "(", "\n", "feature_channels", "[", "in_feature", "]", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "norm", ",", "\n", "norm", "=", "norm_module", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "conv", ")", "\n", "head_ops", ".", "append", "(", "conv", ")", "\n", "if", "feature_strides", "[", "in_feature", "]", "!=", "self", ".", "common_stride", ":", "\n", "                    ", "head_ops", ".", "append", "(", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", ")", "\n", "", "", "self", ".", "scale_heads", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "head_ops", ")", ")", "\n", "self", ".", "add_module", "(", "in_feature", ",", "self", ".", "scale_heads", "[", "-", "1", "]", ")", "\n", "", "self", ".", "predictor", "=", "Conv2d", "(", "conv_dims", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "predictor", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "features", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            In training, returns (None, dict of losses)\n            In inference, returns (CxHxW logits, {})\n        \"\"\"", "\n", "x", "=", "self", ".", "layers", "(", "features", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "None", ",", "self", ".", "losses", "(", "x", ",", "targets", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "\n", "x", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "return", "x", ",", "{", "}", "\n", "\n", "", "", "def", "layers", "(", "self", ",", "features", ")", ":", "\n", "        ", "for", "i", ",", "f", "in", "enumerate", "(", "self", ".", "in_features", ")", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.from_config": [[172, 198], ["dict", "len"], "methods", ["None"], ["            ", "if", "i", "==", "0", ":", "\n", "                ", "x", "=", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "f", "]", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "x", "+", "self", ".", "scale_heads", "[", "i", "]", "(", "features", "[", "f", "]", ")", "\n", "", "", "x", "=", "self", ".", "predictor", "(", "x", ")", "\n", "return", "x", "\n", "\n", "", "def", "losses", "(", "self", ",", "predictions", ",", "targets", ")", ":", "\n", "        ", "predictions", "=", "F", ".", "interpolate", "(", "\n", "predictions", ",", "scale_factor", "=", "self", ".", "common_stride", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "\n", "predictions", ",", "targets", ",", "reduction", "=", "\"mean\"", ",", "ignore_index", "=", "self", ".", "ignore_value", "\n", ")", "\n", "losses", "=", "{", "\"loss_sem_seg\"", ":", "loss", "*", "self", ".", "loss_weight", "}", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.forward": [[199, 216], ["semantic_seg.DeepLabV3PlusHead.layers", "torch.nn.functional.interpolate", "semantic_seg.DeepLabV3PlusHead.losses"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers": [[217, 233], ["semantic_seg.DeepLabV3PlusHead.predictor", "torch.nn.functional.interpolate", "torch.cat", "proj_x.size"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.losses": [[234, 241], ["torch.nn.functional.interpolate", "semantic_seg.DeepLabV3PlusHead.loss"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.__init__": [[249, 302], ["torch.nn.Module.__init__", "detectron2.layers.ASPP", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "len", "len", "torch.nn.CrossEntropyLoss", "ValueError", "loss.DeepLabCE", "ValueError"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.forward": [[303, 319], ["semantic_seg.DeepLabV3Head.aspp", "semantic_seg.DeepLabV3Head.predictor", "torch.nn.functional.interpolate", "semantic_seg.DeepLabV3Head.losses"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses": [[320, 327], ["torch.nn.functional.interpolate", "semantic_seg.DeepLabV3Head.loss"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.Action.add_arguments": [[40, 47], ["parser.add_argument"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "parser", ".", "add_argument", "(", "\n", "\"-v\"", ",", "\n", "\"--verbosity\"", ",", "\n", "action", "=", "\"count\"", ",", "\n", "help", "=", "\"Verbose mode. Multiple -v options increase the verbosity.\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.EntrywiseAction.add_arguments": [[60, 75], ["query_db.Action.add_arguments", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["    ", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "EntrywiseAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"dataset\"", ",", "metavar", "=", "\"<dataset>\"", ",", "help", "=", "\"Dataset name (e.g. densepose_coco_2014_train)\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"selector\"", ",", "\n", "metavar", "=", "\"<selector>\"", ",", "\n", "help", "=", "\"Dataset entry selector in the form field1[:type]=value1[,\"", "\n", "\"field2[:type]=value_min-value_max...] which selects all \"", "\n", "\"entries from the dataset that satisfy the constraints\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--max-entries\"", ",", "metavar", "=", "\"N\"", ",", "help", "=", "\"Maximum number of entries to process\"", ",", "type", "=", "int", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.EntrywiseAction.execute": [[77, 90], ["query_db.setup_dataset", "densepose.utils.dbhelper.EntrySelector.from_string", "cls.create_context", "zip", "range", "densepose.utils.dbhelper.EntrySelector.from_string.", "densepose.utils.dbhelper.EntrySelector.from_string.", "cls.execute_on_entry", "cls.execute_on_entry"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.setup_dataset", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.dbhelper.EntrySelector.from_string", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.create_context", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.ShowAction.execute_on_entry", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.ShowAction.execute_on_entry"], ["", "@", "classmethod", "\n", "def", "execute", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", ":", "\n", "        ", "dataset", "=", "setup_dataset", "(", "args", ".", "dataset", ")", "\n", "entry_selector", "=", "EntrySelector", ".", "from_string", "(", "args", ".", "selector", ")", "\n", "context", "=", "cls", ".", "create_context", "(", "args", ")", "\n", "if", "args", ".", "max_entries", "is", "not", "None", ":", "\n", "            ", "for", "_", ",", "entry", "in", "zip", "(", "range", "(", "args", ".", "max_entries", ")", ",", "dataset", ")", ":", "\n", "                ", "if", "entry_selector", "(", "entry", ")", ":", "\n", "                    ", "cls", ".", "execute_on_entry", "(", "entry", ",", "context", ")", "\n", "", "", "", "else", ":", "\n", "            ", "for", "entry", "in", "dataset", ":", "\n", "                ", "if", "entry_selector", "(", "entry", ")", ":", "\n", "                    ", "cls", ".", "execute_on_entry", "(", "entry", ",", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.EntrywiseAction.create_context": [[91, 95], ["None"], "methods", ["None"], ["", "", "", "", "@", "classmethod", "\n", "def", "create_context", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "context", "=", "{", "}", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.PrintAction.add_parser": [[105, 110], ["subparsers.add_parser", "cls.add_arguments", "subparsers.add_parser.set_defaults"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_parser", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["@", "classmethod", "\n", "def", "add_parser", "(", "cls", ":", "type", ",", "subparsers", ":", "argparse", ".", "_SubParsersAction", ")", ":", "\n", "        ", "parser", "=", "subparsers", ".", "add_parser", "(", "cls", ".", "COMMAND", ",", "help", "=", "\"Output selected entries to stdout. \"", ")", "\n", "cls", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "cls", ".", "execute", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.PrintAction.add_arguments": [[111, 114], ["query_db.EntrywiseAction.add_arguments"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "PrintAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.PrintAction.execute_on_entry": [[115, 121], ["pprint.PrettyPrinter", "pprint.PrettyPrinter.pprint"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "execute_on_entry", "(", "cls", ":", "type", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "import", "pprint", "\n", "\n", "printer", "=", "pprint", ".", "PrettyPrinter", "(", "indent", "=", "2", ",", "width", "=", "200", ",", "compact", "=", "True", ")", "\n", "printer", ".", "pprint", "(", "entry", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.ShowAction.add_parser": [[139, 144], ["subparsers.add_parser", "cls.add_arguments", "subparsers.add_parser.set_defaults"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_parser", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["@", "classmethod", "\n", "def", "add_parser", "(", "cls", ":", "type", ",", "subparsers", ":", "argparse", ".", "_SubParsersAction", ")", ":", "\n", "        ", "parser", "=", "subparsers", ".", "add_parser", "(", "cls", ".", "COMMAND", ",", "help", "=", "\"Visualize selected entries\"", ")", "\n", "cls", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "cls", ".", "execute", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.ShowAction.add_arguments": [[145, 159], ["query_db.EntrywiseAction.add_arguments", "parser.add_argument", "parser.add_argument", "sorted", "cls.VISUALIZERS.keys"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "ShowAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"visualizations\"", ",", "\n", "metavar", "=", "\"<visualizations>\"", ",", "\n", "help", "=", "\"Comma separated list of visualizations, possible values: \"", "\n", "\"[{}]\"", ".", "format", "(", "\",\"", ".", "join", "(", "sorted", "(", "cls", ".", "VISUALIZERS", ".", "keys", "(", ")", ")", ")", ")", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "metavar", "=", "\"<image_file>\"", ",", "\n", "default", "=", "\"output.png\"", ",", "\n", "help", "=", "\"File name to save output to\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.ShowAction.execute_on_entry": [[161, 177], ["fvcore.common.file_io.PathManager.get_local_path", "cv2.imread", "np.tile", "cls._extract_data_for_visualizers_from_entry", "visualizer.visualize", "cls._get_out_fname", "cv2.imwrite", "logger.info"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.ShowAction._extract_data_for_visualizers_from_entry", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction._get_out_fname"], ["", "@", "classmethod", "\n", "def", "execute_on_entry", "(", "cls", ":", "type", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "import", "cv2", "\n", "import", "numpy", "as", "np", "\n", "\n", "image_fpath", "=", "PathManager", ".", "get_local_path", "(", "entry", "[", "\"file_name\"", "]", ")", "\n", "image", "=", "cv2", ".", "imread", "(", "image_fpath", ",", "cv2", ".", "IMREAD_GRAYSCALE", ")", "\n", "image", "=", "np", ".", "tile", "(", "image", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "[", "1", ",", "1", ",", "3", "]", ")", "\n", "datas", "=", "cls", ".", "_extract_data_for_visualizers_from_entry", "(", "context", "[", "\"vis_specs\"", "]", ",", "entry", ")", "\n", "visualizer", "=", "context", "[", "\"visualizer\"", "]", "\n", "image_vis", "=", "visualizer", ".", "visualize", "(", "image", ",", "datas", ")", "\n", "entry_idx", "=", "context", "[", "\"entry_idx\"", "]", "+", "1", "\n", "out_fname", "=", "cls", ".", "_get_out_fname", "(", "entry_idx", ",", "context", "[", "\"out_fname\"", "]", ")", "\n", "cv2", ".", "imwrite", "(", "out_fname", ",", "image_vis", ")", "\n", "logger", ".", "info", "(", "f\"Output saved to {out_fname}\"", ")", "\n", "context", "[", "\"entry_idx\"", "]", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.ShowAction._get_out_fname": [[178, 182], ["os.path.splitext"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_get_out_fname", "(", "cls", ":", "type", ",", "entry_idx", ":", "int", ",", "fname_base", ":", "str", ")", ":", "\n", "        ", "base", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "fname_base", ")", "\n", "return", "base", "+", "\".{0:04d}\"", ".", "format", "(", "entry_idx", ")", "+", "ext", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.ShowAction.create_context": [[183, 197], ["args.visualizations.split", "visualizers.append", "densepose.vis.base.CompoundVisualizer"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "create_context", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "vis_specs", "=", "args", ".", "visualizations", ".", "split", "(", "\",\"", ")", "\n", "visualizers", "=", "[", "]", "\n", "for", "vis_spec", "in", "vis_specs", ":", "\n", "            ", "vis", "=", "cls", ".", "VISUALIZERS", "[", "vis_spec", "]", "\n", "visualizers", ".", "append", "(", "vis", ")", "\n", "", "context", "=", "{", "\n", "\"vis_specs\"", ":", "vis_specs", ",", "\n", "\"visualizer\"", ":", "CompoundVisualizer", "(", "visualizers", ")", ",", "\n", "\"out_fname\"", ":", "args", ".", "output", ",", "\n", "\"entry_idx\"", ":", "0", ",", "\n", "}", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.ShowAction._extract_data_for_visualizers_from_entry": [[198, 216], ["densepose.data.structures.DensePoseDataRelative.validate_annotation", "torch.as_tensor", "bbox_list.append", "densepose.data.structures.DensePoseDataRelative", "dp_list.append", "datas.append"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseDataRelative.validate_annotation"], ["", "@", "classmethod", "\n", "def", "_extract_data_for_visualizers_from_entry", "(", "\n", "cls", ":", "type", ",", "vis_specs", ":", "List", "[", "str", "]", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", "\n", ")", ":", "\n", "        ", "dp_list", "=", "[", "]", "\n", "bbox_list", "=", "[", "]", "\n", "for", "annotation", "in", "entry", "[", "\"annotations\"", "]", ":", "\n", "            ", "is_valid", ",", "_", "=", "DensePoseDataRelative", ".", "validate_annotation", "(", "annotation", ")", "\n", "if", "not", "is_valid", ":", "\n", "                ", "continue", "\n", "", "bbox", "=", "torch", ".", "as_tensor", "(", "annotation", "[", "\"bbox\"", "]", ")", "\n", "bbox_list", ".", "append", "(", "bbox", ")", "\n", "dp_data", "=", "DensePoseDataRelative", "(", "annotation", ")", "\n", "dp_list", ".", "append", "(", "dp_data", ")", "\n", "", "datas", "=", "[", "]", "\n", "for", "vis_spec", "in", "vis_specs", ":", "\n", "            ", "datas", ".", "append", "(", "bbox_list", "if", "\"bbox\"", "==", "vis_spec", "else", "(", "bbox_list", ",", "dp_list", ")", ")", "\n", "", "return", "datas", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.register_action": [[50, 57], ["None"], "function", ["None"], ["", "", "def", "register_action", "(", "cls", ":", "type", ")", ":", "\n", "    ", "\"\"\"\n    Decorator for action classes to automate action registration\n    \"\"\"", "\n", "global", "_ACTION_REGISTRY", "\n", "_ACTION_REGISTRY", "[", "cls", ".", "COMMAND", "]", "=", "cls", "\n", "return", "cls", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.setup_dataset": [[218, 225], ["logger.info", "timeit.default_timer", "detectron2.data.catalog.DatasetCatalog.get", "timeit.default_timer", "logger.info"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "setup_dataset", "(", "dataset_name", ")", ":", "\n", "    ", "logger", ".", "info", "(", "\"Loading dataset {}\"", ".", "format", "(", "dataset_name", ")", ")", "\n", "start", "=", "timer", "(", ")", "\n", "dataset", "=", "DatasetCatalog", ".", "get", "(", "dataset_name", ")", "\n", "stop", "=", "timer", "(", ")", "\n", "logger", ".", "info", "(", "\"Loaded dataset {} in {:.3f}s\"", ".", "format", "(", "dataset_name", ",", "stop", "-", "start", ")", ")", "\n", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.create_argument_parser": [[227, 237], ["argparse.ArgumentParser", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.add_subparsers", "_ACTION_REGISTRY.items", "action.add_parser", "argparse.HelpFormatter", "argparse.ArgumentParser.print_help"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_parser"], ["", "def", "create_argument_parser", "(", ")", "->", "argparse", ".", "ArgumentParser", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "DOC", ",", "\n", "formatter_class", "=", "lambda", "prog", ":", "argparse", ".", "HelpFormatter", "(", "prog", ",", "max_help_position", "=", "120", ")", ",", "\n", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "lambda", "_", ":", "parser", ".", "print_help", "(", "sys", ".", "stdout", ")", ")", "\n", "subparsers", "=", "parser", ".", "add_subparsers", "(", "title", "=", "\"Actions\"", ")", "\n", "for", "_", ",", "action", "in", "_ACTION_REGISTRY", ".", "items", "(", ")", ":", "\n", "        ", "action", ".", "add_parser", "(", "subparsers", ")", "\n", "", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.query_db.main": [[239, 247], ["query_db.create_argument_parser", "create_argument_parser.parse_args", "detectron2.utils.logger.setup_logger", "detectron2.utils.logger.setup_logger.setLevel", "parser.parse_args.func", "hasattr", "densepose.utils.logger.verbosity_to_level"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.create_argument_parser", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.visualize_data.parse_args", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.verbosity_to_level"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "create_argument_parser", "(", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "verbosity", "=", "args", ".", "verbosity", "if", "hasattr", "(", "args", ",", "\"verbosity\"", ")", "else", "None", "\n", "global", "logger", "\n", "logger", "=", "setup_logger", "(", "name", "=", "LOGGER_NAME", ")", "\n", "logger", ".", "setLevel", "(", "verbosity_to_level", "(", "verbosity", ")", ")", "\n", "args", ".", "func", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.Action.add_arguments": [[42, 49], ["parser.add_argument"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "parser", ".", "add_argument", "(", "\n", "\"-v\"", ",", "\n", "\"--verbosity\"", ",", "\n", "action", "=", "\"count\"", ",", "\n", "help", "=", "\"Verbose mode. Multiple -v options increase the verbosity.\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.InferenceAction.add_arguments": [[62, 73], ["apply_net.Action.add_arguments", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["    ", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "InferenceAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\"cfg\"", ",", "metavar", "=", "\"<config>\"", ",", "help", "=", "\"Config file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"model\"", ",", "metavar", "=", "\"<model>\"", ",", "help", "=", "\"Model file\"", ")", "\n", "parser", ".", "add_argument", "(", "\"input\"", ",", "metavar", "=", "\"<input>\"", ",", "help", "=", "\"Input data\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line 'KEY VALUE' pairs\"", ",", "\n", "default", "=", "[", "]", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.InferenceAction.execute": [[75, 94], ["logger.info", "cls.setup_config", "logger.info", "detectron2.engine.defaults.DefaultPredictor", "logger.info", "cls._get_input_file_list", "cls.create_context", "cls.postexecute", "len", "logger.warning", "detectron2.data.detection_utils.read_image", "torch.no_grad", "cls.execute_on_outputs", "detectron2.engine.defaults.DefaultPredictor."], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.setup_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.InferenceAction._get_input_file_list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.create_context", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.postexecute", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.detection_utils.read_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.execute_on_outputs"], ["", "@", "classmethod", "\n", "def", "execute", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Loading config from {args.cfg}\"", ")", "\n", "opts", "=", "[", "]", "\n", "cfg", "=", "cls", ".", "setup_config", "(", "args", ".", "cfg", ",", "args", ".", "model", ",", "args", ",", "opts", ")", "\n", "logger", ".", "info", "(", "f\"Loading model from {args.model}\"", ")", "\n", "predictor", "=", "DefaultPredictor", "(", "cfg", ")", "\n", "logger", ".", "info", "(", "f\"Loading data from {args.input}\"", ")", "\n", "file_list", "=", "cls", ".", "_get_input_file_list", "(", "args", ".", "input", ")", "\n", "if", "len", "(", "file_list", ")", "==", "0", ":", "\n", "            ", "logger", ".", "warning", "(", "f\"No input images for {args.input}\"", ")", "\n", "return", "\n", "", "context", "=", "cls", ".", "create_context", "(", "args", ")", "\n", "for", "file_name", "in", "file_list", ":", "\n", "            ", "img", "=", "read_image", "(", "file_name", ",", "format", "=", "\"BGR\"", ")", "# predictor expects BGR image.", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "outputs", "=", "predictor", "(", "img", ")", "[", "\"instances\"", "]", "\n", "cls", ".", "execute_on_outputs", "(", "context", ",", "{", "\"file_name\"", ":", "file_name", ",", "\"image\"", ":", "img", "}", ",", "outputs", ")", "\n", "", "", "cls", ".", "postexecute", "(", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.InferenceAction.setup_config": [[95, 109], ["detectron2.config.get_cfg", "densepose.add_densepose_config", "densepose.add_hrnet_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.config.get_cfg.merge_from_list"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_densepose_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_hrnet_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze"], ["", "@", "classmethod", "\n", "def", "setup_config", "(", "\n", "cls", ":", "type", ",", "config_fpath", ":", "str", ",", "model_fpath", ":", "str", ",", "args", ":", "argparse", ".", "Namespace", ",", "opts", ":", "List", "[", "str", "]", "\n", ")", ":", "\n", "        ", "cfg", "=", "get_cfg", "(", ")", "\n", "add_densepose_config", "(", "cfg", ")", "\n", "add_hrnet_config", "(", "cfg", ")", "\n", "cfg", ".", "merge_from_file", "(", "config_fpath", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "if", "opts", ":", "\n", "            ", "cfg", ".", "merge_from_list", "(", "opts", ")", "\n", "", "cfg", ".", "MODEL", ".", "WEIGHTS", "=", "model_fpath", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.InferenceAction._get_input_file_list": [[110, 123], ["os.path.isdir", "os.path.isfile", "os.path.join", "glob.glob", "os.listdir", "os.path.isfile", "os.path.join"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_get_input_file_list", "(", "cls", ":", "type", ",", "input_spec", ":", "str", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "isdir", "(", "input_spec", ")", ":", "\n", "            ", "file_list", "=", "[", "\n", "os", ".", "path", ".", "join", "(", "input_spec", ",", "fname", ")", "\n", "for", "fname", "in", "os", ".", "listdir", "(", "input_spec", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "input_spec", ",", "fname", ")", ")", "\n", "]", "\n", "", "elif", "os", ".", "path", ".", "isfile", "(", "input_spec", ")", ":", "\n", "            ", "file_list", "=", "[", "input_spec", "]", "\n", "", "else", ":", "\n", "            ", "file_list", "=", "glob", ".", "glob", "(", "input_spec", ")", "\n", "", "return", "file_list", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.DumpAction.add_parser": [[133, 138], ["subparsers.add_parser", "cls.add_arguments", "subparsers.add_parser.set_defaults"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_parser", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["@", "classmethod", "\n", "def", "add_parser", "(", "cls", ":", "type", ",", "subparsers", ":", "argparse", ".", "_SubParsersAction", ")", ":", "\n", "        ", "parser", "=", "subparsers", ".", "add_parser", "(", "cls", ".", "COMMAND", ",", "help", "=", "\"Dump model outputs to a file.\"", ")", "\n", "cls", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "cls", ".", "execute", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.DumpAction.add_arguments": [[139, 147], ["apply_net.InferenceAction.add_arguments", "parser.add_argument"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "DumpAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "metavar", "=", "\"<dump_file>\"", ",", "\n", "default", "=", "\"results.pkl\"", ",", "\n", "help", "=", "\"File name to save dump to\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.DumpAction.execute_on_outputs": [[149, 166], ["logger.info", "outputs.has", "outputs.has", "context[].append", "outputs.get().cpu", "outputs.get().tensor.cpu", "outputs.has", "detectron2.structures.boxes.BoxMode.convert", "outputs.get().to_result", "outputs.get", "outputs.get", "outputs.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.to_result", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "@", "classmethod", "\n", "def", "execute_on_outputs", "(", "\n", "cls", ":", "type", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ",", "outputs", ":", "Instances", "\n", ")", ":", "\n", "        ", "image_fpath", "=", "entry", "[", "\"file_name\"", "]", "\n", "logger", ".", "info", "(", "f\"Processing {image_fpath}\"", ")", "\n", "result", "=", "{", "\"file_name\"", ":", "image_fpath", "}", "\n", "if", "outputs", ".", "has", "(", "\"scores\"", ")", ":", "\n", "            ", "result", "[", "\"scores\"", "]", "=", "outputs", ".", "get", "(", "\"scores\"", ")", ".", "cpu", "(", ")", "\n", "", "if", "outputs", ".", "has", "(", "\"pred_boxes\"", ")", ":", "\n", "            ", "result", "[", "\"pred_boxes_XYXY\"", "]", "=", "outputs", ".", "get", "(", "\"pred_boxes\"", ")", ".", "tensor", ".", "cpu", "(", ")", "\n", "if", "outputs", ".", "has", "(", "\"pred_densepose\"", ")", ":", "\n", "                ", "boxes_XYWH", "=", "BoxMode", ".", "convert", "(", "\n", "result", "[", "\"pred_boxes_XYXY\"", "]", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", "\n", ")", "\n", "result", "[", "\"pred_densepose\"", "]", "=", "outputs", ".", "get", "(", "\"pred_densepose\"", ")", ".", "to_result", "(", "boxes_XYWH", ")", "\n", "", "", "context", "[", "\"results\"", "]", ".", "append", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.DumpAction.create_context": [[167, 171], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "create_context", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", ":", "\n", "        ", "context", "=", "{", "\"results\"", ":", "[", "]", ",", "\"out_fname\"", ":", "args", ".", "output", "}", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.DumpAction.postexecute": [[172, 181], ["os.path.dirname", "os.makedirs", "open", "pickle.dump", "logger.info", "len", "os.path.exists"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.dump"], ["", "@", "classmethod", "\n", "def", "postexecute", "(", "cls", ":", "type", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "out_fname", "=", "context", "[", "\"out_fname\"", "]", "\n", "out_dir", "=", "os", ".", "path", ".", "dirname", "(", "out_fname", ")", "\n", "if", "len", "(", "out_dir", ")", ">", "0", "and", "not", "os", ".", "path", ".", "exists", "(", "out_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "", "with", "open", "(", "out_fname", ",", "\"wb\"", ")", "as", "hFile", ":", "\n", "            ", "pickle", ".", "dump", "(", "context", "[", "\"results\"", "]", ",", "hFile", ")", "\n", "logger", ".", "info", "(", "f\"Output saved to {out_fname}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_parser": [[198, 203], ["subparsers.add_parser", "cls.add_arguments", "subparsers.add_parser.set_defaults"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_parser", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["@", "classmethod", "\n", "def", "add_parser", "(", "cls", ":", "type", ",", "subparsers", ":", "argparse", ".", "_SubParsersAction", ")", ":", "\n", "        ", "parser", "=", "subparsers", ".", "add_parser", "(", "cls", ".", "COMMAND", ",", "help", "=", "\"Visualize selected entries\"", ")", "\n", "cls", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "cls", ".", "execute", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments": [[204, 228], ["apply_net.InferenceAction.add_arguments", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "sorted", "cls.VISUALIZERS.keys"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_arguments"], ["", "@", "classmethod", "\n", "def", "add_arguments", "(", "cls", ":", "type", ",", "parser", ":", "argparse", ".", "ArgumentParser", ")", ":", "\n", "        ", "super", "(", "ShowAction", ",", "cls", ")", ".", "add_arguments", "(", "parser", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"visualizations\"", ",", "\n", "metavar", "=", "\"<visualizations>\"", ",", "\n", "help", "=", "\"Comma separated list of visualizations, possible values: \"", "\n", "\"[{}]\"", ".", "format", "(", "\",\"", ".", "join", "(", "sorted", "(", "cls", ".", "VISUALIZERS", ".", "keys", "(", ")", ")", ")", ")", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--min_score\"", ",", "\n", "metavar", "=", "\"<score>\"", ",", "\n", "default", "=", "0.8", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "\"Minimum detection score to visualize\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--nms_thresh\"", ",", "metavar", "=", "\"<threshold>\"", ",", "default", "=", "None", ",", "type", "=", "float", ",", "help", "=", "\"NMS threshold\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "metavar", "=", "\"<image_file>\"", ",", "\n", "default", "=", "\"outputres.png\"", ",", "\n", "help", "=", "\"File name to save output to\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.setup_config": [[230, 241], ["opts.append", "opts.append", "apply_net.InferenceAction.setup_config", "str", "opts.append", "opts.append", "str"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.setup_config"], ["", "@", "classmethod", "\n", "def", "setup_config", "(", "\n", "cls", ":", "type", ",", "config_fpath", ":", "str", ",", "model_fpath", ":", "str", ",", "args", ":", "argparse", ".", "Namespace", ",", "opts", ":", "List", "[", "str", "]", "\n", ")", ":", "\n", "        ", "opts", ".", "append", "(", "\"MODEL.ROI_HEADS.SCORE_THRESH_TEST\"", ")", "\n", "opts", ".", "append", "(", "str", "(", "args", ".", "min_score", ")", ")", "\n", "if", "args", ".", "nms_thresh", "is", "not", "None", ":", "\n", "            ", "opts", ".", "append", "(", "\"MODEL.ROI_HEADS.NMS_THRESH_TEST\"", ")", "\n", "opts", ".", "append", "(", "str", "(", "args", ".", "nms_thresh", ")", ")", "\n", "", "cfg", "=", "super", "(", "ShowAction", ",", "cls", ")", ".", "setup_config", "(", "config_fpath", ",", "model_fpath", ",", "args", ",", "opts", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.execute_on_outputs": [[242, 265], ["logger.info", "cv2.cvtColor", "np.tile", "extractor", "visualizer.visualize", "cls._get_out_fname", "os.path.dirname", "cv2.imwrite", "logger.info", "os.makedirs", "len", "os.path.exists"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction._get_out_fname"], ["", "@", "classmethod", "\n", "def", "execute_on_outputs", "(", "\n", "cls", ":", "type", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ",", "entry", ":", "Dict", "[", "str", ",", "Any", "]", ",", "outputs", ":", "Instances", "\n", ")", ":", "\n", "        ", "import", "cv2", "\n", "import", "numpy", "as", "np", "\n", "\n", "visualizer", "=", "context", "[", "\"visualizer\"", "]", "\n", "extractor", "=", "context", "[", "\"extractor\"", "]", "\n", "image_fpath", "=", "entry", "[", "\"file_name\"", "]", "\n", "logger", ".", "info", "(", "f\"Processing {image_fpath}\"", ")", "\n", "image", "=", "cv2", ".", "cvtColor", "(", "entry", "[", "\"image\"", "]", ",", "cv2", ".", "COLOR_BGR2GRAY", ")", "\n", "image", "=", "np", ".", "tile", "(", "image", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "[", "1", ",", "1", ",", "3", "]", ")", "\n", "data", "=", "extractor", "(", "outputs", ")", "\n", "image_vis", "=", "visualizer", ".", "visualize", "(", "image", ",", "data", ")", "\n", "entry_idx", "=", "context", "[", "\"entry_idx\"", "]", "+", "1", "\n", "out_fname", "=", "cls", ".", "_get_out_fname", "(", "entry_idx", ",", "context", "[", "\"out_fname\"", "]", ")", "\n", "out_dir", "=", "os", ".", "path", ".", "dirname", "(", "out_fname", ")", "\n", "if", "len", "(", "out_dir", ")", ">", "0", "and", "not", "os", ".", "path", ".", "exists", "(", "out_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "", "cv2", ".", "imwrite", "(", "out_fname", ",", "image_vis", ")", "\n", "logger", ".", "info", "(", "f\"Output saved to {out_fname}\"", ")", "\n", "context", "[", "\"entry_idx\"", "]", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.postexecute": [[266, 269], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "postexecute", "(", "cls", ":", "type", ",", "context", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction._get_out_fname": [[270, 274], ["os.path.splitext"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_get_out_fname", "(", "cls", ":", "type", ",", "entry_idx", ":", "int", ",", "fname_base", ":", "str", ")", ":", "\n", "        ", "base", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "fname_base", ")", "\n", "return", "base", "+", "\".{0:04d}\"", ".", "format", "(", "entry_idx", ")", "+", "ext", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.create_context": [[275, 294], ["args.visualizations.split", "densepose.vis.base.CompoundVisualizer", "densepose.vis.extractor.CompoundExtractor", "visualizers.append", "densepose.vis.extractor.create_extractor", "extractors.append"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.create_extractor"], ["", "@", "classmethod", "\n", "def", "create_context", "(", "cls", ":", "type", ",", "args", ":", "argparse", ".", "Namespace", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "vis_specs", "=", "args", ".", "visualizations", ".", "split", "(", "\",\"", ")", "\n", "visualizers", "=", "[", "]", "\n", "extractors", "=", "[", "]", "\n", "for", "vis_spec", "in", "vis_specs", ":", "\n", "            ", "vis", "=", "cls", ".", "VISUALIZERS", "[", "vis_spec", "]", "(", ")", "\n", "visualizers", ".", "append", "(", "vis", ")", "\n", "extractor", "=", "create_extractor", "(", "vis", ")", "\n", "extractors", ".", "append", "(", "extractor", ")", "\n", "", "visualizer", "=", "CompoundVisualizer", "(", "visualizers", ")", "\n", "extractor", "=", "CompoundExtractor", "(", "extractors", ")", "\n", "context", "=", "{", "\n", "\"extractor\"", ":", "extractor", ",", "\n", "\"visualizer\"", ":", "visualizer", ",", "\n", "\"out_fname\"", ":", "args", ".", "output", ",", "\n", "\"entry_idx\"", ":", "0", ",", "\n", "}", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.register_action": [[52, 59], ["None"], "function", ["None"], ["", "", "def", "register_action", "(", "cls", ":", "type", ")", ":", "\n", "    ", "\"\"\"\n    Decorator for action classes to automate action registration\n    \"\"\"", "\n", "global", "_ACTION_REGISTRY", "\n", "_ACTION_REGISTRY", "[", "cls", ".", "COMMAND", "]", "=", "cls", "\n", "return", "cls", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.create_argument_parser": [[296, 306], ["argparse.ArgumentParser", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.add_subparsers", "_ACTION_REGISTRY.items", "action.add_parser", "argparse.HelpFormatter", "argparse.ArgumentParser.print_help"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.ShowAction.add_parser"], ["", "", "def", "create_argument_parser", "(", ")", "->", "argparse", ".", "ArgumentParser", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "DOC", ",", "\n", "formatter_class", "=", "lambda", "prog", ":", "argparse", ".", "HelpFormatter", "(", "prog", ",", "max_help_position", "=", "120", ")", ",", "\n", ")", "\n", "parser", ".", "set_defaults", "(", "func", "=", "lambda", "_", ":", "parser", ".", "print_help", "(", "sys", ".", "stdout", ")", ")", "\n", "subparsers", "=", "parser", ".", "add_subparsers", "(", "title", "=", "\"Actions\"", ")", "\n", "for", "_", ",", "action", "in", "_ACTION_REGISTRY", ".", "items", "(", ")", ":", "\n", "        ", "action", ".", "add_parser", "(", "subparsers", ")", "\n", "", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.main": [[308, 316], ["apply_net.create_argument_parser", "create_argument_parser.parse_args", "detectron2.utils.logger.setup_logger", "detectron2.utils.logger.setup_logger.setLevel", "parser.parse_args.func", "hasattr", "densepose.utils.logger.verbosity_to_level"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.apply_net.create_argument_parser", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tools.visualize_data.parse_args", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.verbosity_to_level"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "create_argument_parser", "(", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "verbosity", "=", "args", ".", "verbosity", "if", "hasattr", "(", "args", ",", "\"verbosity\"", ")", "else", "None", "\n", "global", "logger", "\n", "logger", "=", "setup_logger", "(", "name", "=", "LOGGER_NAME", ")", "\n", "logger", ".", "setLevel", "(", "verbosity_to_level", "(", "verbosity", ")", ")", "\n", "args", ".", "func", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.train_net.setup": [[25, 35], ["detectron2.config.get_cfg", "densepose.add_densepose_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup", "detectron2.utils.logger.setup_logger", "detectron2.get_rank"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_densepose_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.setup_logger", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["from", "detectron2", ".", "checkpoint", "import", "DetectionCheckpointer", "\n", "from", "detectron2", ".", "config", "import", "get_cfg", "\n", "from", "detectron2", ".", "data", "import", "MetadataCatalog", "\n", "from", "detectron2", ".", "engine", "import", "DefaultTrainer", ",", "default_argument_parser", ",", "default_setup", ",", "hooks", ",", "launch", "\n", "from", "detectron2", ".", "evaluation", "import", "(", "\n", "CityscapesInstanceEvaluator", ",", "\n", "CityscapesSemSegEvaluator", ",", "\n", "COCOEvaluator", ",", "\n", "COCOPanopticEvaluator", ",", "\n", "DatasetEvaluators", ",", "\n", "LVISEvaluator", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.DensePose.train_net.main": [[37, 62], ["train_net.setup", "fvcore.common.file_io.PathManager.set_strict_kwargs_checking", "densepose.engine.Trainer", "densepose.engine.Trainer.resume_or_load", "densepose.engine.Trainer.train", "densepose.engine.Trainer.build_model", "densepose.modeling.densepose_checkpoint.DensePoseCheckpointer().resume_or_load", "densepose.engine.Trainer.test", "detectron2.is_main_process", "densepose.engine.Trainer.register_hooks", "Trainer.test.update", "detectron2.evaluation.verify_results", "densepose.modeling.densepose_checkpoint.DensePoseCheckpointer", "densepose.engine.Trainer.test_with_TTA", "detectron2.engine.hooks.EvalHook", "densepose.engine.Trainer.test_with_TTA"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.register_hooks", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.verify_results", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.test_with_TTA", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.trainer.Trainer.test_with_TTA"], ["SemSegEvaluator", ",", "\n", "verify_results", ",", "\n", ")", "\n", "from", "detectron2", ".", "modeling", "import", "GeneralizedRCNNWithTTA", "\n", "\n", "\n", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "    ", "\"\"\"\n    We use the \"DefaultTrainer\" which contains pre-defined default logic for\n    standard training workflow. They may not work for you, especially if you\n    are working on a new research project. In that case you can write your\n    own training loop. You can use \"tools/plain_train_net.py\" as an example.\n    \"\"\"", "\n", "\n", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Create evaluator(s) for a given dataset.\n        This uses the special metadata \"evaluator_type\" associated with each builtin dataset.\n        For your own dataset, you can simply create an evaluator manually in your\n        script and do not have to worry about the hacky if-else logic here.\n        \"\"\"", "\n", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluator_list", "=", "[", "]", "\n", "evaluator_type", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "evaluator_type", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_dataset_category_config": [[7, 16], ["detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["None"], ["from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_bootstrap_config": [[18, 26], ["detectron2.config.CfgNode"], "function", ["None"], ["\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.get_bootstrap_dataset_config": [[28, 51], ["detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["None"], ["\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "", "else", ":", "\n", "# compat.py needs to import CfgNode", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.load_bootstrap_config": [[53, 68], ["get_bootstrap_dataset_config().clone", "get_bootstrap_dataset_config().clone.merge_from_other_cfg", "bootstrap_datasets_cfgnodes.append", "detectron2.config.CfgNode", "config.get_bootstrap_dataset_config"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.get_bootstrap_dataset_config"], ["\n", "logger", ".", "warning", "(", "\n", "\"Loading an old v{} config file '{}' by automatically upgrading to v{}. \"", "\n", "\"See docs/CHANGELOG.md for instructions to update your files.\"", ".", "format", "(", "\n", "loaded_ver", ",", "cfg_filename", ",", "self", ".", "VERSION", "\n", ")", "\n", ")", "\n", "# To convert, first obtain a full config at an old version", "\n", "old_self", "=", "downgrade_config", "(", "self", ",", "to_version", "=", "loaded_ver", ")", "\n", "old_self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n", "new_config", "=", "upgrade_config", "(", "old_self", ")", "\n", "self", ".", "clear", "(", ")", "\n", "self", ".", "update", "(", "new_config", ")", "\n", "\n", "", "", "def", "dump", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_densepose_head_config": [[70, 130], ["detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["None"], ["\n", "# to make it show up in docs", "\n", "return", "super", "(", ")", ".", "dump", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "\n", "", "", "global_cfg", "=", "CfgNode", "(", ")", "\n", "\n", "\n", "def", "get_cfg", "(", ")", "->", "CfgNode", ":", "\n", "    ", "\"\"\"\n    Get a copy of the default config.\n\n    Returns:\n        a detectron2 CfgNode instance.\n    \"\"\"", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "return", "_C", ".", "clone", "(", ")", "\n", "\n", "\n", "", "def", "set_global_cfg", "(", "cfg", ":", "CfgNode", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Let the global config point to the given cfg.\n\n    Assume that the given \"cfg\" has the key \"KEY\", after calling\n    `set_global_cfg(cfg)`, the key can be accessed by:\n    ::\n        from detectron2.config import global_cfg\n        print(global_cfg.KEY)\n\n    By using a hacky global config, you can access these configs anywhere,\n    without having to pass the config object or the values deep into the code.\n    This is a hacky feature introduced for quick prototyping / research exploration.\n    \"\"\"", "\n", "global", "global_cfg", "\n", "global_cfg", ".", "clear", "(", ")", "\n", "global_cfg", ".", "update", "(", "cfg", ")", "\n", "\n", "\n", "", "def", "configurable", "(", "init_func", ")", ":", "\n", "    ", "\"\"\"\n    Decorate a class's __init__ method so that it can be called with a CfgNode\n    object using the class's from_config classmethod.\n\n    Examples:\n    ::\n        class A:\n            @configurable\n            def __init__(self, a, b=2, c=3):\n                pass\n\n            @classmethod\n            def from_config(cls, cfg):\n                # Returns kwargs to be passed to __init__\n                return {\"a\": cfg.A, \"b\": cfg.B}\n\n        a1 = A(a=1, b=2)  # regular construction\n        a2 = A(cfg)       # construct with a cfg\n        a3 = A(cfg, b=3, c=4)  # construct with extra overwrite\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_hrnet_config": [[132, 165], ["detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode", "detectron2.config.CfgNode"], "function", ["None"], ["if", "init_func", ".", "__module__", ".", "startswith", "(", "\"detectron2.\"", ")", ":", "\n", "        ", "assert", "(", "\n", "init_func", ".", "__doc__", "is", "not", "None", "and", "\"experimental\"", "in", "init_func", ".", "__doc__", "\n", ")", ",", "f\"configurable {init_func} should be marked experimental\"", "\n", "\n", "", "@", "functools", ".", "wraps", "(", "init_func", ")", "\n", "def", "wrapped", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from_config_func", "=", "type", "(", "self", ")", ".", "from_config", "\n", "", "except", "AttributeError", "as", "e", ":", "\n", "            ", "raise", "AttributeError", "(", "\n", "\"Class with @configurable must have a 'from_config' classmethod.\"", "\n", ")", "from", "e", "\n", "", "if", "not", "inspect", ".", "ismethod", "(", "from_config_func", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"Class with @configurable must have a 'from_config' classmethod.\"", ")", "\n", "\n", "", "if", "_called_with_cfg", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "explicit_args", "=", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "init_func", "(", "self", ",", "**", "explicit_args", ")", "\n", "", "else", ":", "\n", "            ", "init_func", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapped", "\n", "\n", "\n", "", "def", "_get_args_from_config", "(", "from_config_func", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Use `from_config` to obtain explicit arguments.\n\n    Returns:\n        dict: arguments to be used for cls.__init__\n    \"\"\"", "\n", "signature", "=", "inspect", ".", "signature", "(", "from_config_func", ")", "\n", "if", "list", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "[", "0", "]", "!=", "\"cfg\"", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_densepose_config": [[167, 172], ["config.add_densepose_head_config", "config.add_hrnet_config", "config.add_bootstrap_config", "config.add_dataset_category_config"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_densepose_head_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_hrnet_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_bootstrap_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.config.add_dataset_category_config"], ["f\"{from_config_func.__self__}.from_config must take 'cfg' as the first argument!\"", "\n", ")", "\n", "", "support_var_arg", "=", "any", "(", "\n", "param", ".", "kind", "in", "[", "param", ".", "VAR_POSITIONAL", ",", "param", ".", "VAR_KEYWORD", "]", "\n", "for", "param", "in", "signature", ".", "parameters", ".", "values", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.__init__": [[28, 40], ["torch.device", "logging.getLogger", "detectron2.data.MetadataCatalog.get", "fvcore.common.file_io.PathManager.get_local_path", "contextlib.redirect_stdout", "pycocotools.coco.COCO", "io.StringIO"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["\n", "pass", "\n", "\n", "", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.reset": [[41, 43], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.process": [[44, 59], ["zip", "output[].to", "evaluator.prediction_to_json", "evaluator.DensePoseCOCOEvaluator._predictions.extend"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.prediction_to_json"], ["\n", "pass", "\n", "\n", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator.evaluate": [[60, 71], ["copy.deepcopy", "detectron2.utils.comm.synchronize", "detectron2.utils.comm.all_gather", "list", "evaluator.DensePoseCOCOEvaluator._eval_predictions", "itertools.chain", "detectron2.utils.comm.is_main_process"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.synchronize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.all_gather", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator._eval_predictions", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process"], ["\n", "pass", "\n", "\n", "\n", "", "", "class", "DatasetEvaluators", "(", "DatasetEvaluator", ")", ":", "\n", "    ", "\"\"\"\n    Wrapper class to combine multiple :class:`DatasetEvaluator` instances.\n\n    This class dispatches every evaluation call to\n    all of its :class:`DatasetEvaluator`.\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.DensePoseCOCOEvaluator._eval_predictions": [[72, 94], ["evaluator.DensePoseCOCOEvaluator._logger.info", "evaluator.DensePoseCOCOEvaluator._logger.info", "collections.OrderedDict", "evaluator._evaluate_predictions_on_coco", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "fvcore.common.file_io.PathManager.open", "torch.save"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.visualizer.VisImage.save"], ["def", "__init__", "(", "self", ",", "evaluators", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            evaluators (list): the evaluators to combine.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_evaluators", "=", "evaluators", "\n", "\n", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "evaluator", ".", "reset", "(", ")", "\n", "\n", "", "", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n", "", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "results", "=", "OrderedDict", "(", ")", "\n", "for", "evaluator", "in", "self", ".", "_evaluators", ":", "\n", "            ", "result", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "if", "is_main_process", "(", ")", "and", "result", "is", "not", "None", ":", "\n", "                ", "for", "k", ",", "v", "in", "result", ".", "items", "(", ")", ":", "\n", "                    ", "assert", "(", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator.prediction_to_json": [[96, 130], ["instances.scores.tolist", "data.samplers.densepose_to_mask", "instances.pred_boxes.tensor.clone", "detectron2.structures.BoxMode.convert", "instances.pred_densepose.to_result", "range", "len", "pycocotools.encode", "segmentation_encoded[].decode", "results.append", "numpy.require", "segmentation.numpy"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.samplers.mask_from_densepose.densepose_to_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.to_result"], [")", ",", "\"Different evaluators produce results with the same key {}\"", ".", "format", "(", "k", ")", "\n", "results", "[", "k", "]", "=", "v", "\n", "", "", "", "return", "results", "\n", "\n", "\n", "", "", "def", "inference_on_dataset", "(", "model", ",", "data_loader", ",", "evaluator", ")", ":", "\n", "    ", "\"\"\"\n    Run model on the data_loader and evaluate the metrics with evaluator.\n    Also benchmark the inference speed of `model.forward` accurately.\n    The model will be used in eval mode.\n\n    Args:\n        model (nn.Module): a module which accepts an object from\n            `data_loader` and returns some outputs. It will be temporarily set to `eval` mode.\n\n            If you wish to evaluate a model in `training` mode instead, you can\n            wrap the given model and override its behavior of `.eval()` and `.train()`.\n        data_loader: an iterable object with a length.\n            The elements it generates will be the inputs to the model.\n        evaluator (DatasetEvaluator): the evaluator to run. Use `None` if you only want\n            to benchmark, but don't want to do any evaluation.\n\n    Returns:\n        The return value of `evaluator.evaluate()`\n    \"\"\"", "\n", "num_devices", "=", "get_world_size", "(", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Start inference on {} images\"", ".", "format", "(", "len", "(", "data_loader", ")", ")", ")", "\n", "\n", "total", "=", "len", "(", "data_loader", ")", "# inference data loader must have a fixed length", "\n", "if", "evaluator", "is", "None", ":", "\n", "# create a no-op evaluator", "\n", "        ", "evaluator", "=", "DatasetEvaluators", "(", "[", "]", ")", "\n", "", "evaluator", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco": [[132, 160], ["logging.getLogger", "evaluator._get_segmentation_metrics", "evaluator._get_densepose_metrics", "coco_gt.loadRes", "evaluator._evaluate_predictions_on_coco_segm", "logging.getLogger.info", "evaluator._evaluate_predictions_on_coco_gps", "logging.getLogger.info", "evaluator._evaluate_predictions_on_coco_gpsm", "logging.getLogger.info", "len", "logging.getLogger.warn", "detectron2.utils.logger.create_small_table", "detectron2.utils.logger.create_small_table", "detectron2.utils.logger.create_small_table"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._get_segmentation_metrics", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._get_densepose_metrics", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco_segm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco_gps", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco_gpsm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.create_small_table", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.create_small_table", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.logger.create_small_table"], ["start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "total_compute_time", "=", "0", "\n", "with", "inference_context", "(", "model", ")", ",", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "idx", ",", "inputs", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "            ", "if", "idx", "==", "num_warmup", ":", "\n", "                ", "start_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "total_compute_time", "=", "0", "\n", "\n", "", "start_compute_time", "=", "time", ".", "perf_counter", "(", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "", "total_compute_time", "+=", "time", ".", "perf_counter", "(", ")", "-", "start_compute_time", "\n", "evaluator", ".", "process", "(", "inputs", ",", "outputs", ")", "\n", "\n", "iters_after_start", "=", "idx", "+", "1", "-", "num_warmup", "*", "int", "(", "idx", ">=", "num_warmup", ")", "\n", "seconds_per_img", "=", "total_compute_time", "/", "iters_after_start", "\n", "if", "idx", ">=", "num_warmup", "*", "2", "or", "seconds_per_img", ">", "5", ":", "\n", "                ", "total_seconds_per_img", "=", "(", "time", ".", "perf_counter", "(", ")", "-", "start_time", ")", "/", "iters_after_start", "\n", "eta", "=", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_seconds_per_img", "*", "(", "total", "-", "idx", "-", "1", ")", ")", ")", "\n", "log_every_n_seconds", "(", "\n", "logging", ".", "INFO", ",", "\n", "\"Inference done {}/{}. {:.4f} s / img. ETA={}\"", ".", "format", "(", "\n", "idx", "+", "1", ",", "total", ",", "seconds_per_img", ",", "str", "(", "eta", ")", "\n", ")", ",", "\n", "n", "=", "5", ",", "\n", ")", "\n", "\n", "# Measure the time only for this worker (before the synchronization barrier)", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._get_densepose_metrics": [[162, 172], ["metrics.extend"], "function", ["None"], ["total_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "total_time", ")", ")", "\n", "# NOTE this format is parsed by grep", "\n", "logger", ".", "info", "(", "\n", "\"Total inference time: {} ({:.6f} s / img per device, on {} devices)\"", ".", "format", "(", "\n", "total_time_str", ",", "total_time", "/", "(", "total", "-", "num_warmup", ")", ",", "num_devices", "\n", ")", "\n", ")", "\n", "total_compute_time_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "total_compute_time", ")", ")", ")", "\n", "logger", ".", "info", "(", "\n", "\"Total inference pure compute time: {} ({:.6f} s / img per device, on {} devices)\"", ".", "format", "(", "\n", "total_compute_time_str", ",", "total_compute_time", "/", "(", "total", "-", "num_warmup", ")", ",", "num_devices", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._get_segmentation_metrics": [[174, 188], ["None"], "function", ["None"], [")", "\n", "\n", "results", "=", "evaluator", ".", "evaluate", "(", ")", "\n", "# An evaluator may return None when not in main process.", "\n", "# Replace it by an empty dict instead to make it easier for downstream code to handle", "\n", "if", "results", "is", "None", ":", "\n", "        ", "results", "=", "{", "}", "\n", "", "return", "results", "\n", "\n", "\n", "", "@", "contextmanager", "\n", "def", "inference_context", "(", "model", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco_gps": [[191, 201], ["densepose_coco_evaluation.DensePoseCocoEval", "numpy.linspace", "densepose_coco_evaluation.DensePoseCocoEval.evaluate", "densepose_coco_evaluation.DensePoseCocoEval.accumulate", "densepose_coco_evaluation.DensePoseCocoEval.summarize", "float", "int", "enumerate", "numpy.round"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], ["\n", "training_mode", "=", "model", ".", "training", "\n", "model", ".", "eval", "(", ")", "\n", "yield", "\n", "model", ".", "train", "(", "training_mode", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco_gpsm": [[203, 213], ["densepose_coco_evaluation.DensePoseCocoEval", "numpy.linspace", "densepose_coco_evaluation.DensePoseCocoEval.evaluate", "densepose_coco_evaluation.DensePoseCocoEval.accumulate", "densepose_coco_evaluation.DensePoseCocoEval.summarize", "float", "int", "enumerate", "numpy.round"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.evaluator._evaluate_predictions_on_coco_segm": [[215, 225], ["densepose_coco_evaluation.DensePoseCocoEval", "numpy.linspace", "densepose_coco_evaluation.DensePoseCocoEval.evaluate", "densepose_coco_evaluation.DensePoseCocoEval.accumulate", "densepose_coco_evaluation.DensePoseCocoEval.summarize", "float", "int", "enumerate", "numpy.round"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.__init__": [[102, 134], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "densepose_coco_evaluation.Params", "sorted", "sorted", "cocoGt.getImgIds", "cocoGt.getCatIds"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "cocoGt", "=", "None", ",", "\n", "cocoDt", "=", "None", ",", "\n", "iouType", ":", "str", "=", "\"densepose\"", ",", "\n", "dpEvalMode", ":", "DensePoseEvalMode", "=", "DensePoseEvalMode", ".", "GPS", ",", "\n", "dpDataMode", ":", "DensePoseDataMode", "=", "DensePoseDataMode", ".", "IUV_DT", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize CocoEval using coco APIs for gt and dt\n        :param cocoGt: coco object with ground truth annotations\n        :param cocoDt: coco object with detection results\n        :return: None\n        \"\"\"", "\n", "self", ".", "cocoGt", "=", "cocoGt", "# ground truth COCO API", "\n", "self", ".", "cocoDt", "=", "cocoDt", "# detections COCO API", "\n", "self", ".", "_dpEvalMode", "=", "dpEvalMode", "\n", "self", ".", "_dpDataMode", "=", "dpDataMode", "\n", "self", ".", "params", "=", "{", "}", "# evaluation parameters", "\n", "self", ".", "evalImgs", "=", "defaultdict", "(", "list", ")", "# per-image per-category eval results [KxAxI]", "\n", "self", ".", "eval", "=", "{", "}", "# accumulated evaluation results", "\n", "self", ".", "_gts", "=", "defaultdict", "(", "list", ")", "# gt for evaluation", "\n", "self", ".", "_dts", "=", "defaultdict", "(", "list", ")", "# dt for evaluation", "\n", "self", ".", "params", "=", "Params", "(", "iouType", "=", "iouType", ")", "# parameters", "\n", "self", ".", "_paramsEval", "=", "{", "}", "# parameters for evaluation", "\n", "self", ".", "stats", "=", "[", "]", "# result summarization", "\n", "self", ".", "ious", "=", "{", "}", "# ious between all gts and dts", "\n", "if", "cocoGt", "is", "not", "None", ":", "\n", "            ", "self", ".", "params", ".", "imgIds", "=", "sorted", "(", "cocoGt", ".", "getImgIds", "(", ")", ")", "\n", "self", ".", "params", ".", "catIds", "=", "sorted", "(", "cocoGt", ".", "getCatIds", "(", ")", ")", "\n", "", "self", ".", "ignoreThrBB", "=", "0.7", "\n", "self", ".", "ignoreThrUV", "=", "0.9", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._loadGEval": [[135, 167], ["fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.file_io.PathManager.get_local_path", "fvcore.common.file_io.PathManager.get_local_path", "scipy.io.loadmat", "scipy.io.loadmat", "densepose_coco_evaluation.DensePoseCocoEval.PDIST_transform[].squeeze", "numpy.array().squeeze", "numpy.arange", "numpy.array", "numpy.array", "numpy.array", "numpy.arange", "densepose_coco_evaluation.DensePoseCocoEval.Part_UVs.append", "densepose_coco_evaluation.DensePoseCocoEval.Part_ClosestVertInds.append", "open", "pickle.load", "SMPL_subdiv[].squeeze", "numpy.array", "SMPL_subdiv[].squeeze", "SMPL_subdiv[].squeeze"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseTransformData.load"], ["", "def", "_loadGEval", "(", "self", ")", ":", "\n", "        ", "smpl_subdiv_fpath", "=", "PathManager", ".", "get_local_path", "(", "\n", "\"https://dl.fbaipublicfiles.com/densepose/data/SMPL_subdiv.mat\"", "\n", ")", "\n", "pdist_transform_fpath", "=", "PathManager", ".", "get_local_path", "(", "\n", "\"https://dl.fbaipublicfiles.com/densepose/data/SMPL_SUBDIV_TRANSFORM.mat\"", "\n", ")", "\n", "pdist_matrix_fpath", "=", "PathManager", ".", "get_local_path", "(", "\n", "\"https://dl.fbaipublicfiles.com/densepose/data/Pdist_matrix.pkl\"", ",", "timeout_sec", "=", "120", "\n", ")", "\n", "SMPL_subdiv", "=", "loadmat", "(", "smpl_subdiv_fpath", ")", "\n", "self", ".", "PDIST_transform", "=", "loadmat", "(", "pdist_transform_fpath", ")", "\n", "self", ".", "PDIST_transform", "=", "self", ".", "PDIST_transform", "[", "\"index\"", "]", ".", "squeeze", "(", ")", "\n", "UV", "=", "np", ".", "array", "(", "[", "SMPL_subdiv", "[", "\"U_subdiv\"", "]", ",", "SMPL_subdiv", "[", "\"V_subdiv\"", "]", "]", ")", ".", "squeeze", "(", ")", "\n", "ClosestVertInds", "=", "np", ".", "arange", "(", "UV", ".", "shape", "[", "1", "]", ")", "+", "1", "\n", "self", ".", "Part_UVs", "=", "[", "]", "\n", "self", ".", "Part_ClosestVertInds", "=", "[", "]", "\n", "for", "i", "in", "np", ".", "arange", "(", "24", ")", ":", "\n", "            ", "self", ".", "Part_UVs", ".", "append", "(", "UV", "[", ":", ",", "SMPL_subdiv", "[", "\"Part_ID_subdiv\"", "]", ".", "squeeze", "(", ")", "==", "(", "i", "+", "1", ")", "]", ")", "\n", "self", ".", "Part_ClosestVertInds", ".", "append", "(", "\n", "ClosestVertInds", "[", "SMPL_subdiv", "[", "\"Part_ID_subdiv\"", "]", ".", "squeeze", "(", ")", "==", "(", "i", "+", "1", ")", "]", "\n", ")", "\n", "\n", "", "with", "open", "(", "pdist_matrix_fpath", ",", "\"rb\"", ")", "as", "hFile", ":", "\n", "            ", "arrays", "=", "pickle", ".", "load", "(", "hFile", ",", "encoding", "=", "\"latin1\"", ")", "\n", "", "self", ".", "Pdist_matrix", "=", "arrays", "[", "\"Pdist_matrix\"", "]", "\n", "self", ".", "Part_ids", "=", "np", ".", "array", "(", "SMPL_subdiv", "[", "\"Part_ID_subdiv\"", "]", ".", "squeeze", "(", ")", ")", "\n", "# Mean geodesic distances for parts.", "\n", "self", ".", "Mean_Distances", "=", "np", ".", "array", "(", "[", "0", ",", "0.351", ",", "0.107", ",", "0.126", ",", "0.237", ",", "0.173", ",", "0.142", ",", "0.128", ",", "0.150", "]", ")", "\n", "# Coarse Part labels.", "\n", "self", ".", "CoarseParts", "=", "np", ".", "array", "(", "\n", "[", "0", ",", "1", ",", "1", ",", "2", ",", "2", ",", "3", ",", "3", ",", "4", ",", "4", ",", "4", ",", "4", ",", "5", ",", "5", ",", "5", ",", "5", ",", "6", ",", "6", ",", "6", ",", "6", ",", "7", ",", "7", ",", "7", ",", "7", ",", "8", ",", "8", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._prepare": [[169, 286], ["densepose_coco_evaluation.DensePoseCocoEval.cocoGt.loadImgs", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "pycocotools.mask.frPyObjects", "pycocotools.mask.merge", "pycocotools.mask.decode", "numpy.array().astype", "min", "min", "numpy.require", "densepose_coco_evaluation.DensePoseCocoEval._extract_mask", "numpy.require", "pycocotools.mask.encode", "pycocotools.mask.encode", "densepose_coco_evaluation.DensePoseCocoEval.cocoGt.loadAnns", "densepose_coco_evaluation.DensePoseCocoEval.cocoDt.loadAnns", "densepose_coco_evaluation.DensePoseCocoEval.cocoGt.loadAnns", "densepose_coco_evaluation.DensePoseCocoEval.cocoDt.loadAnns", "densepose_coco_evaluation.DensePoseCocoEval._loadGEval", "densepose_coco_evaluation.DensePoseCocoEval._prepare._toMask"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._loadGEval"], ["", "def", "_prepare", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Prepare ._gts and ._dts for evaluation based on params\n        :return: None\n        \"\"\"", "\n", "\n", "def", "_toMask", "(", "anns", ",", "coco", ")", ":", "\n", "# modify ann['segmentation'] by reference", "\n", "            ", "for", "ann", "in", "anns", ":", "\n", "# safeguard for invalid segmentation annotation;", "\n", "# annotations containing empty lists exist in the posetrack", "\n", "# dataset. This is not a correct segmentation annotation", "\n", "# in terms of COCO format; we need to deal with it somehow", "\n", "                ", "segm", "=", "ann", "[", "\"segmentation\"", "]", "\n", "if", "type", "(", "segm", ")", "==", "list", "and", "len", "(", "segm", ")", "==", "0", ":", "\n", "                    ", "ann", "[", "\"segmentation\"", "]", "=", "None", "\n", "continue", "\n", "", "rle", "=", "coco", ".", "annToRLE", "(", "ann", ")", "\n", "ann", "[", "\"segmentation\"", "]", "=", "rle", "\n", "\n", "", "", "def", "_getIgnoreRegion", "(", "iid", ",", "coco", ")", ":", "\n", "            ", "img", "=", "coco", ".", "imgs", "[", "iid", "]", "\n", "\n", "if", "\"ignore_regions_x\"", "not", "in", "img", ".", "keys", "(", ")", ":", "\n", "                ", "return", "None", "\n", "\n", "", "if", "len", "(", "img", "[", "\"ignore_regions_x\"", "]", ")", "==", "0", ":", "\n", "                ", "return", "None", "\n", "\n", "", "rgns_merged", "=", "[", "\n", "[", "v", "for", "xy", "in", "zip", "(", "region_x", ",", "region_y", ")", "for", "v", "in", "xy", "]", "\n", "for", "region_x", ",", "region_y", "in", "zip", "(", "img", "[", "\"ignore_regions_x\"", "]", ",", "img", "[", "\"ignore_regions_y\"", "]", ")", "\n", "]", "\n", "rles", "=", "maskUtils", ".", "frPyObjects", "(", "rgns_merged", ",", "img", "[", "\"height\"", "]", ",", "img", "[", "\"width\"", "]", ")", "\n", "rle", "=", "maskUtils", ".", "merge", "(", "rles", ")", "\n", "return", "maskUtils", ".", "decode", "(", "rle", ")", "\n", "\n", "", "def", "_checkIgnore", "(", "dt", ",", "iregion", ")", ":", "\n", "            ", "if", "iregion", "is", "None", ":", "\n", "                ", "return", "True", "\n", "\n", "", "bb", "=", "np", ".", "array", "(", "dt", "[", "\"bbox\"", "]", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "bb", "[", "0", "]", ",", "bb", "[", "1", "]", ",", "bb", "[", "0", "]", "+", "bb", "[", "2", "]", ",", "bb", "[", "1", "]", "+", "bb", "[", "3", "]", "\n", "x2", "=", "min", "(", "[", "x2", ",", "iregion", ".", "shape", "[", "1", "]", "]", ")", "\n", "y2", "=", "min", "(", "[", "y2", ",", "iregion", ".", "shape", "[", "0", "]", "]", ")", "\n", "\n", "if", "bb", "[", "2", "]", "*", "bb", "[", "3", "]", "==", "0", ":", "\n", "                ", "return", "False", "\n", "\n", "", "crop_iregion", "=", "iregion", "[", "y1", ":", "y2", ",", "x1", ":", "x2", "]", "\n", "\n", "if", "crop_iregion", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "return", "True", "\n", "\n", "", "if", "\"densepose\"", "not", "in", "dt", ".", "keys", "(", ")", ":", "# filtering boxes", "\n", "                ", "return", "crop_iregion", ".", "sum", "(", ")", "/", "bb", "[", "2", "]", "/", "bb", "[", "3", "]", "<", "self", ".", "ignoreThrBB", "\n", "\n", "# filtering UVs", "\n", "", "ignoremask", "=", "np", ".", "require", "(", "crop_iregion", ",", "requirements", "=", "[", "\"F\"", "]", ")", "\n", "mask", "=", "self", ".", "_extract_mask", "(", "dt", ")", "\n", "uvmask", "=", "np", ".", "require", "(", "np", ".", "asarray", "(", "mask", ">", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "requirements", "=", "[", "\"F\"", "]", ")", "\n", "uvmask_", "=", "maskUtils", ".", "encode", "(", "uvmask", ")", "\n", "ignoremask_", "=", "maskUtils", ".", "encode", "(", "ignoremask", ")", "\n", "uviou", "=", "maskUtils", ".", "iou", "(", "[", "uvmask_", "]", ",", "[", "ignoremask_", "]", ",", "[", "1", "]", ")", "[", "0", "]", "\n", "return", "uviou", "<", "self", ".", "ignoreThrUV", "\n", "\n", "", "p", "=", "self", ".", "params", "\n", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gts", "=", "self", ".", "cocoGt", ".", "loadAnns", "(", "self", ".", "cocoGt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ",", "catIds", "=", "p", ".", "catIds", ")", ")", "\n", "dts", "=", "self", ".", "cocoDt", ".", "loadAnns", "(", "self", ".", "cocoDt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ",", "catIds", "=", "p", ".", "catIds", ")", ")", "\n", "", "else", ":", "\n", "            ", "gts", "=", "self", ".", "cocoGt", ".", "loadAnns", "(", "self", ".", "cocoGt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ")", ")", "\n", "dts", "=", "self", ".", "cocoDt", ".", "loadAnns", "(", "self", ".", "cocoDt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ")", ")", "\n", "\n", "", "imns", "=", "self", ".", "cocoGt", ".", "loadImgs", "(", "p", ".", "imgIds", ")", "\n", "self", ".", "size_mapping", "=", "{", "}", "\n", "for", "im", "in", "imns", ":", "\n", "            ", "self", ".", "size_mapping", "[", "im", "[", "\"id\"", "]", "]", "=", "[", "im", "[", "\"height\"", "]", ",", "im", "[", "\"width\"", "]", "]", "\n", "\n", "# if iouType == 'uv', add point gt annotations", "\n", "", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "self", ".", "_loadGEval", "(", ")", "\n", "\n", "# convert ground truth to mask if iouType == 'segm'", "\n", "", "if", "p", ".", "iouType", "==", "\"segm\"", ":", "\n", "            ", "_toMask", "(", "gts", ",", "self", ".", "cocoGt", ")", "\n", "_toMask", "(", "dts", ",", "self", ".", "cocoDt", ")", "\n", "\n", "# set ignore flag", "\n", "", "for", "gt", "in", "gts", ":", "\n", "            ", "gt", "[", "\"ignore\"", "]", "=", "gt", "[", "\"ignore\"", "]", "if", "\"ignore\"", "in", "gt", "else", "0", "\n", "gt", "[", "\"ignore\"", "]", "=", "\"iscrowd\"", "in", "gt", "and", "gt", "[", "\"iscrowd\"", "]", "\n", "if", "p", ".", "iouType", "==", "\"keypoints\"", ":", "\n", "                ", "gt", "[", "\"ignore\"", "]", "=", "(", "gt", "[", "\"num_keypoints\"", "]", "==", "0", ")", "or", "gt", "[", "\"ignore\"", "]", "\n", "", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "                ", "gt", "[", "\"ignore\"", "]", "=", "(", "\"dp_x\"", "in", "gt", ")", "==", "0", "\n", "", "if", "p", ".", "iouType", "==", "\"segm\"", ":", "\n", "                ", "gt", "[", "\"ignore\"", "]", "=", "gt", "[", "\"segmentation\"", "]", "is", "None", "\n", "\n", "", "", "self", ".", "_gts", "=", "defaultdict", "(", "list", ")", "# gt for evaluation", "\n", "self", ".", "_dts", "=", "defaultdict", "(", "list", ")", "# dt for evaluation", "\n", "self", ".", "_igrgns", "=", "defaultdict", "(", "list", ")", "\n", "\n", "for", "gt", "in", "gts", ":", "\n", "            ", "iid", "=", "gt", "[", "\"image_id\"", "]", "\n", "if", "iid", "not", "in", "self", ".", "_igrgns", ".", "keys", "(", ")", ":", "\n", "                ", "self", ".", "_igrgns", "[", "iid", "]", "=", "_getIgnoreRegion", "(", "iid", ",", "self", ".", "cocoGt", ")", "\n", "", "if", "_checkIgnore", "(", "gt", ",", "self", ".", "_igrgns", "[", "iid", "]", ")", ":", "\n", "                ", "self", ".", "_gts", "[", "iid", ",", "gt", "[", "\"category_id\"", "]", "]", ".", "append", "(", "gt", ")", "\n", "", "", "for", "dt", "in", "dts", ":", "\n", "            ", "iid", "=", "dt", "[", "\"image_id\"", "]", "\n", "if", "(", "iid", "not", "in", "self", ".", "_igrgns", ")", "or", "_checkIgnore", "(", "dt", ",", "self", ".", "_igrgns", "[", "iid", "]", ")", ":", "\n", "                ", "self", ".", "_dts", "[", "iid", ",", "dt", "[", "\"category_id\"", "]", "]", ".", "append", "(", "dt", ")", "\n", "\n", "", "", "self", ".", "evalImgs", "=", "defaultdict", "(", "list", ")", "# per-image per-category evaluation results", "\n", "self", ".", "eval", "=", "{", "}", "# accumulated evaluation results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluate": [[287, 337], ["time.time", "logger.info", "list", "sorted", "densepose_coco_evaluation.DensePoseCocoEval._prepare", "copy.deepcopy", "time.time", "logger.info", "logger.info", "numpy.unique", "list", "densepose_coco_evaluation.DensePoseCocoEval.computeIoU"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._prepare", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.list", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeIoU"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Run per image evaluation on given images and store results (a list of dict) in self.evalImgs\n        :return: None\n        \"\"\"", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "logger", ".", "info", "(", "\"Running per image DensePose evaluation... {}\"", ".", "format", "(", "self", ".", "params", ".", "iouType", ")", ")", "\n", "p", "=", "self", ".", "params", "\n", "# add backward compatibility if useSegm is specified in params", "\n", "if", "p", ".", "useSegm", "is", "not", "None", ":", "\n", "            ", "p", ".", "iouType", "=", "\"segm\"", "if", "p", ".", "useSegm", "==", "1", "else", "\"bbox\"", "\n", "logger", ".", "info", "(", "\"useSegm (deprecated) is not None. Running DensePose evaluation\"", ")", "\n", "", "p", ".", "imgIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "imgIds", ")", ")", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "p", ".", "catIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "catIds", ")", ")", "\n", "", "p", ".", "maxDets", "=", "sorted", "(", "p", ".", "maxDets", ")", "\n", "self", ".", "params", "=", "p", "\n", "\n", "self", ".", "_prepare", "(", ")", "\n", "# loop through images, area range, max detection number", "\n", "catIds", "=", "p", ".", "catIds", "if", "p", ".", "useCats", "else", "[", "-", "1", "]", "\n", "\n", "if", "p", ".", "iouType", "in", "[", "\"segm\"", ",", "\"bbox\"", "]", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeIoU", "\n", "", "elif", "p", ".", "iouType", "==", "\"keypoints\"", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeOks", "\n", "", "elif", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeOgps", "\n", "if", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "GPSM", ":", "\n", "                ", "self", ".", "real_ious", "=", "{", "\n", "(", "imgId", ",", "catId", ")", ":", "self", ".", "computeDPIoU", "(", "imgId", ",", "catId", ")", "\n", "for", "imgId", "in", "p", ".", "imgIds", "\n", "for", "catId", "in", "catIds", "\n", "}", "\n", "\n", "", "", "self", ".", "ious", "=", "{", "\n", "(", "imgId", ",", "catId", ")", ":", "computeIoU", "(", "imgId", ",", "catId", ")", "for", "imgId", "in", "p", ".", "imgIds", "for", "catId", "in", "catIds", "\n", "}", "\n", "\n", "evaluateImg", "=", "self", ".", "evaluateImg", "\n", "maxDet", "=", "p", ".", "maxDets", "[", "-", "1", "]", "\n", "self", ".", "evalImgs", "=", "[", "\n", "evaluateImg", "(", "imgId", ",", "catId", ",", "areaRng", ",", "maxDet", ")", "\n", "for", "catId", "in", "catIds", "\n", "for", "areaRng", "in", "p", ".", "areaRng", "\n", "for", "imgId", "in", "p", ".", "imgIds", "\n", "]", "\n", "self", ".", "_paramsEval", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ")", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "logger", ".", "info", "(", "\"DensePose evaluation DONE (t={:0.2f}s).\"", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.getDensePoseMask": [[338, 346], ["numpy.zeros", "min", "range", "len", "pycocotools.mask.decode"], "methods", ["None"], ["", "def", "getDensePoseMask", "(", "self", ",", "polys", ")", ":", "\n", "        ", "maskGen", "=", "np", ".", "zeros", "(", "[", "256", ",", "256", "]", ")", "\n", "stop", "=", "min", "(", "len", "(", "polys", ")", "+", "1", ",", "15", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "stop", ")", ":", "\n", "            ", "if", "polys", "[", "i", "-", "1", "]", ":", "\n", "                ", "currentMask", "=", "maskUtils", ".", "decode", "(", "polys", "[", "i", "-", "1", "]", ")", "\n", "maskGen", "[", "currentMask", ">", "0", "]", "=", "i", "\n", "", "", "return", "maskGen", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image": [[347, 363], ["numpy.array", "numpy.zeros", "numpy.require", "max", "min", "max", "min", "int", "int", "numpy.asarray", "pycocotools.mask.encode", "int", "int", "int", "int", "numpy.array", "int", "int"], "methods", ["None"], ["", "def", "_generate_rlemask_on_image", "(", "self", ",", "mask", ",", "imgId", ",", "data", ")", ":", "\n", "        ", "bbox_xywh", "=", "np", ".", "array", "(", "data", "[", "\"bbox\"", "]", ")", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "bbox_xywh", "\n", "im_h", ",", "im_w", "=", "self", ".", "size_mapping", "[", "imgId", "]", "\n", "im_mask", "=", "np", ".", "zeros", "(", "(", "im_h", ",", "im_w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "x0", "=", "max", "(", "int", "(", "x", ")", ",", "0", ")", "\n", "x1", "=", "min", "(", "int", "(", "x", "+", "w", ")", ",", "im_w", ",", "int", "(", "x", ")", "+", "mask", ".", "shape", "[", "1", "]", ")", "\n", "y0", "=", "max", "(", "int", "(", "y", ")", ",", "0", ")", "\n", "y1", "=", "min", "(", "int", "(", "y", "+", "h", ")", ",", "im_h", ",", "int", "(", "y", ")", "+", "mask", ".", "shape", "[", "0", "]", ")", "\n", "y", "=", "int", "(", "y", ")", "\n", "x", "=", "int", "(", "x", ")", "\n", "im_mask", "[", "y0", ":", "y1", ",", "x0", ":", "x1", "]", "=", "mask", "[", "y0", "-", "y", ":", "y1", "-", "y", ",", "x0", "-", "x", ":", "x1", "-", "x", "]", "\n", "", "im_mask", "=", "np", ".", "require", "(", "np", ".", "asarray", "(", "im_mask", ">", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "requirements", "=", "[", "\"F\"", "]", ")", "\n", "rle_mask", "=", "maskUtils", ".", "encode", "(", "np", ".", "array", "(", "im_mask", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "order", "=", "\"F\"", ")", ")", "[", "0", "]", "\n", "return", "rle_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeDPIoU": [[364, 422], ["numpy.argsort", "pycocotools.mask.iou", "len", "gtmasks.append", "densepose_coco_evaluation.DensePoseCocoEval._extract_mask", "numpy.require", "densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "dtmasks.append", "int", "len", "len", "numpy.minimum", "scipy.ndimage.zoom", "numpy.array", "densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "numpy.asarray", "densepose_coco_evaluation.DensePoseCocoEval.getDensePoseMask", "float", "float", "densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "max", "max", "isinstance", "pycocotools.mask.frPyObjects", "pycocotools.mask.merge", "isinstance", "isinstance", "densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "pycocotools.mask.frPyObjects"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_mask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.getDensePoseMask", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._generate_rlemask_on_image"], ["", "def", "computeDPIoU", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dt", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dt", "=", "dt", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "\n", "", "gtmasks", "=", "[", "]", "\n", "for", "g", "in", "gt", ":", "\n", "            ", "if", "DensePoseDataRelative", ".", "S_KEY", "in", "g", ":", "\n", "# convert DensePose mask to a binary mask", "\n", "                ", "mask", "=", "np", ".", "minimum", "(", "self", ".", "getDensePoseMask", "(", "g", "[", "DensePoseDataRelative", ".", "S_KEY", "]", ")", ",", "1.0", ")", "\n", "_", ",", "_", ",", "w", ",", "h", "=", "g", "[", "\"bbox\"", "]", "\n", "scale_x", "=", "float", "(", "max", "(", "w", ",", "1", ")", ")", "/", "mask", ".", "shape", "[", "1", "]", "\n", "scale_y", "=", "float", "(", "max", "(", "h", ",", "1", ")", ")", "/", "mask", ".", "shape", "[", "0", "]", "\n", "mask", "=", "spzoom", "(", "mask", ",", "(", "scale_y", ",", "scale_x", ")", ",", "order", "=", "1", ",", "prefilter", "=", "False", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask", ">", "0.5", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "rle_mask", "=", "self", ".", "_generate_rlemask_on_image", "(", "mask", ",", "imgId", ",", "g", ")", "\n", "", "elif", "\"segmentation\"", "in", "g", ":", "\n", "                ", "segmentation", "=", "g", "[", "\"segmentation\"", "]", "\n", "if", "isinstance", "(", "segmentation", ",", "list", ")", "and", "segmentation", ":", "\n", "# polygons", "\n", "                    ", "im_h", ",", "im_w", "=", "self", ".", "size_mapping", "[", "imgId", "]", "\n", "rles", "=", "maskUtils", ".", "frPyObjects", "(", "segmentation", ",", "im_h", ",", "im_w", ")", "\n", "rle_mask", "=", "maskUtils", ".", "merge", "(", "rles", ")", "\n", "", "elif", "isinstance", "(", "segmentation", ",", "dict", ")", ":", "\n", "                    ", "if", "isinstance", "(", "segmentation", "[", "\"counts\"", "]", ",", "list", ")", ":", "\n", "# uncompressed RLE", "\n", "                        ", "im_h", ",", "im_w", "=", "self", ".", "size_mapping", "[", "imgId", "]", "\n", "rle_mask", "=", "maskUtils", ".", "frPyObjects", "(", "segmentation", ",", "im_h", ",", "im_w", ")", "\n", "", "else", ":", "\n", "# compressed RLE", "\n", "                        ", "rle_mask", "=", "segmentation", "\n", "", "", "else", ":", "\n", "                    ", "rle_mask", "=", "self", ".", "_generate_rlemask_on_image", "(", "None", ",", "imgId", ",", "g", ")", "\n", "", "", "else", ":", "\n", "                ", "rle_mask", "=", "self", ".", "_generate_rlemask_on_image", "(", "None", ",", "imgId", ",", "g", ")", "\n", "", "gtmasks", ".", "append", "(", "rle_mask", ")", "\n", "\n", "", "dtmasks", "=", "[", "]", "\n", "for", "d", "in", "dt", ":", "\n", "            ", "mask", "=", "self", ".", "_extract_mask", "(", "d", ")", "\n", "mask", "=", "np", ".", "require", "(", "np", ".", "asarray", "(", "mask", ">", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "requirements", "=", "[", "\"F\"", "]", ")", "\n", "rle_mask", "=", "self", ".", "_generate_rlemask_on_image", "(", "mask", ",", "imgId", ",", "d", ")", "\n", "dtmasks", ".", "append", "(", "rle_mask", ")", "\n", "\n", "# compute iou between each dt and gt region", "\n", "", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "gt", "]", "\n", "iousDP", "=", "maskUtils", ".", "iou", "(", "dtmasks", ",", "gtmasks", ",", "iscrowd", ")", "\n", "return", "iousDP", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeIoU": [[423, 451], ["numpy.argsort", "pycocotools.mask.iou", "len", "int", "len", "len", "Exception"], "methods", ["None"], ["", "def", "computeIoU", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dt", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dt", "=", "dt", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "\n", "", "if", "p", ".", "iouType", "==", "\"segm\"", ":", "\n", "            ", "g", "=", "[", "g", "[", "\"segmentation\"", "]", "for", "g", "in", "gt", "if", "g", "[", "\"segmentation\"", "]", "is", "not", "None", "]", "\n", "d", "=", "[", "d", "[", "\"segmentation\"", "]", "for", "d", "in", "dt", "if", "d", "[", "\"segmentation\"", "]", "is", "not", "None", "]", "\n", "", "elif", "p", ".", "iouType", "==", "\"bbox\"", ":", "\n", "            ", "g", "=", "[", "g", "[", "\"bbox\"", "]", "for", "g", "in", "gt", "]", "\n", "d", "=", "[", "d", "[", "\"bbox\"", "]", "for", "d", "in", "dt", "]", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"unknown iouType for iou computation\"", ")", "\n", "\n", "# compute iou between each dt and gt region", "\n", "", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "gt", "]", "\n", "ious", "=", "maskUtils", ".", "iou", "(", "d", ",", "g", ",", "iscrowd", ")", "\n", "return", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeOks": [[452, 522], ["numpy.argsort", "numpy.zeros", "len", "enumerate", "len", "numpy.array", "numpy.array", "numpy.count_nonzero", "enumerate", "len", "len", "len", "len", "numpy.array", "numpy.zeros", "numpy.sum", "numpy.max", "numpy.max", "numpy.max", "numpy.max", "numpy.exp", "numpy.spacing"], "methods", ["None"], ["", "def", "computeOks", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "# dimension here should be Nxm", "\n", "gts", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dts", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dts", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dts", "=", "[", "dts", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dts", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dts", "=", "dts", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "# if len(gts) == 0 and len(dts) == 0:", "\n", "", "if", "len", "(", "gts", ")", "==", "0", "or", "len", "(", "dts", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "ious", "=", "np", ".", "zeros", "(", "(", "len", "(", "dts", ")", ",", "len", "(", "gts", ")", ")", ")", "\n", "sigmas", "=", "(", "\n", "np", ".", "array", "(", "\n", "[", "\n", "0.26", ",", "\n", "0.25", ",", "\n", "0.25", ",", "\n", "0.35", ",", "\n", "0.35", ",", "\n", "0.79", ",", "\n", "0.79", ",", "\n", "0.72", ",", "\n", "0.72", ",", "\n", "0.62", ",", "\n", "0.62", ",", "\n", "1.07", ",", "\n", "1.07", ",", "\n", "0.87", ",", "\n", "0.87", ",", "\n", "0.89", ",", "\n", "0.89", ",", "\n", "]", "\n", ")", "\n", "/", "10.0", "\n", ")", "\n", "vars", "=", "(", "sigmas", "*", "2", ")", "**", "2", "\n", "k", "=", "len", "(", "sigmas", ")", "\n", "# compute oks between each detection and ground truth object", "\n", "for", "j", ",", "gt", "in", "enumerate", "(", "gts", ")", ":", "\n", "# create bounds for ignore regions(double the gt bbox)", "\n", "            ", "g", "=", "np", ".", "array", "(", "gt", "[", "\"keypoints\"", "]", ")", "\n", "xg", "=", "g", "[", "0", ":", ":", "3", "]", "\n", "yg", "=", "g", "[", "1", ":", ":", "3", "]", "\n", "vg", "=", "g", "[", "2", ":", ":", "3", "]", "\n", "k1", "=", "np", ".", "count_nonzero", "(", "vg", ">", "0", ")", "\n", "bb", "=", "gt", "[", "\"bbox\"", "]", "\n", "x0", "=", "bb", "[", "0", "]", "-", "bb", "[", "2", "]", "\n", "x1", "=", "bb", "[", "0", "]", "+", "bb", "[", "2", "]", "*", "2", "\n", "y0", "=", "bb", "[", "1", "]", "-", "bb", "[", "3", "]", "\n", "y1", "=", "bb", "[", "1", "]", "+", "bb", "[", "3", "]", "*", "2", "\n", "for", "i", ",", "dt", "in", "enumerate", "(", "dts", ")", ":", "\n", "                ", "d", "=", "np", ".", "array", "(", "dt", "[", "\"keypoints\"", "]", ")", "\n", "xd", "=", "d", "[", "0", ":", ":", "3", "]", "\n", "yd", "=", "d", "[", "1", ":", ":", "3", "]", "\n", "if", "k1", ">", "0", ":", "\n", "# measure the per-keypoint distance if keypoints visible", "\n", "                    ", "dx", "=", "xd", "-", "xg", "\n", "dy", "=", "yd", "-", "yg", "\n", "", "else", ":", "\n", "# measure minimum distance to keypoints in (x0,y0) & (x1,y1)", "\n", "                    ", "z", "=", "np", ".", "zeros", "(", "k", ")", "\n", "dx", "=", "np", ".", "max", "(", "(", "z", ",", "x0", "-", "xd", ")", ",", "axis", "=", "0", ")", "+", "np", ".", "max", "(", "(", "z", ",", "xd", "-", "x1", ")", ",", "axis", "=", "0", ")", "\n", "dy", "=", "np", ".", "max", "(", "(", "z", ",", "y0", "-", "yd", ")", ",", "axis", "=", "0", ")", "+", "np", ".", "max", "(", "(", "z", ",", "yd", "-", "y1", ")", ",", "axis", "=", "0", ")", "\n", "", "e", "=", "(", "dx", "**", "2", "+", "dy", "**", "2", ")", "/", "vars", "/", "(", "gt", "[", "\"area\"", "]", "+", "np", ".", "spacing", "(", "1", ")", ")", "/", "2", "\n", "if", "k1", ">", "0", ":", "\n", "                    ", "e", "=", "e", "[", "vg", ">", "0", "]", "\n", "", "ious", "[", "i", ",", "j", "]", "=", "np", ".", "sum", "(", "np", ".", "exp", "(", "-", "e", ")", ")", "/", "e", ".", "shape", "[", "0", "]", "\n", "", "", "return", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_mask": [[523, 527], ["data.structures.DensePoseResult.decode_png_data"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.decode_png_data"], ["", "def", "_extract_mask", "(", "self", ",", "dt", ":", "Dict", "[", "str", ",", "Any", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "(", "densepose_shape", ",", "densepose_data_encoded", ")", ",", "densepose_bbox_xywh", "=", "dt", "[", "\"densepose\"", "]", "\n", "densepose_data", "=", "DensePoseResult", ".", "decode_png_data", "(", "densepose_shape", ",", "densepose_data_encoded", ")", "\n", "return", "densepose_data", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_iuv": [[528, 563], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "ValueError"], "methods", ["None"], ["", "def", "_extract_iuv", "(", "\n", "self", ",", "densepose_data", ":", "np", ".", "ndarray", ",", "py", ":", "np", ".", "ndarray", ",", "px", ":", "np", ".", "ndarray", ",", "gt", ":", "Dict", "[", "str", ",", "Any", "]", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Extract arrays of I, U and V values at given points as numpy arrays\n        given the data mode stored in self._dpDataMode\n        \"\"\"", "\n", "if", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "IUV_DT", ":", "\n", "# estimated labels and UV (default)", "\n", "            ", "ipoints", "=", "densepose_data", "[", "0", ",", "py", ",", "px", "]", "\n", "upoints", "=", "densepose_data", "[", "1", ",", "py", ",", "px", "]", "/", "255.0", "# convert from uint8 by /255.", "\n", "vpoints", "=", "densepose_data", "[", "2", ",", "py", ",", "px", "]", "/", "255.0", "\n", "", "elif", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "IUV_GT", ":", "\n", "# ground truth", "\n", "            ", "ipoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_I\"", "]", ")", "\n", "upoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_U\"", "]", ")", "\n", "vpoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_V\"", "]", ")", "\n", "", "elif", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "I_GT_UV_0", ":", "\n", "# ground truth labels, UV = 0", "\n", "            ", "ipoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_I\"", "]", ")", "\n", "upoints", "=", "upoints", "*", "0.0", "\n", "vpoints", "=", "vpoints", "*", "0.0", "\n", "", "elif", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "I_GT_UV_DT", ":", "\n", "# ground truth labels, estimated UV", "\n", "            ", "ipoints", "=", "np", ".", "array", "(", "gt", "[", "\"dp_I\"", "]", ")", "\n", "upoints", "=", "densepose_data", "[", "1", ",", "py", ",", "px", "]", "/", "255.0", "# convert from uint8 by /255.", "\n", "vpoints", "=", "densepose_data", "[", "2", ",", "py", ",", "px", "]", "/", "255.0", "\n", "", "elif", "self", ".", "_dpDataMode", "==", "DensePoseDataMode", ".", "I_DT_UV_0", ":", "\n", "# estimated labels, UV = 0", "\n", "            ", "ipoints", "=", "densepose_data", "[", "0", ",", "py", ",", "px", "]", "\n", "upoints", "=", "upoints", "*", "0.0", "\n", "vpoints", "=", "vpoints", "*", "0.0", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Unknown data mode: {self._dpDataMode}\"", ")", "\n", "", "return", "ipoints", ",", "upoints", ",", "vpoints", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.computeOgps": [[564, 645], ["numpy.argsort", "numpy.zeros", "enumerate", "pycocotools.mask.iou", "len", "int", "len", "len", "len", "len", "enumerate", "int", "int", "numpy.zeros", "len", "len", "numpy.array", "numpy.array", "numpy.max", "data.structures.DensePoseResult.decode_png_data", "densepose_coco_evaluation.DensePoseCocoEval._extract_iuv", "densepose_coco_evaluation.DensePoseCocoEval.findAllClosestVerts", "densepose_coco_evaluation.DensePoseCocoEval.getDistances", "numpy.exp", "len", "numpy.sum", "len", "cVertsGT[].astype"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.decode_png_data", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval._extract_iuv", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.findAllClosestVerts", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.getDistances"], ["", "def", "computeOgps", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "# dimension here should be Nxm", "\n", "g", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "d", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d_", "[", "\"score\"", "]", "for", "d_", "in", "d", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "d", "=", "[", "d", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "d", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "d", "=", "d", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "# if len(gts) == 0 and len(dts) == 0:", "\n", "", "if", "len", "(", "g", ")", "==", "0", "or", "len", "(", "d", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "ious", "=", "np", ".", "zeros", "(", "(", "len", "(", "d", ")", ",", "len", "(", "g", ")", ")", ")", "\n", "# compute opgs between each detection and ground truth object", "\n", "# sigma = self.sigma #0.255 # dist = 0.3m corresponds to ogps = 0.5", "\n", "# 1 # dist = 0.3m corresponds to ogps = 0.96", "\n", "# 1.45 # dist = 1.7m (person height) corresponds to ogps = 0.5)", "\n", "for", "j", ",", "gt", "in", "enumerate", "(", "g", ")", ":", "\n", "            ", "if", "not", "gt", "[", "\"ignore\"", "]", ":", "\n", "                ", "g_", "=", "gt", "[", "\"bbox\"", "]", "\n", "for", "i", ",", "dt", "in", "enumerate", "(", "d", ")", ":", "\n", "#", "\n", "                    ", "dy", "=", "int", "(", "dt", "[", "\"bbox\"", "]", "[", "3", "]", ")", "\n", "dx", "=", "int", "(", "dt", "[", "\"bbox\"", "]", "[", "2", "]", ")", "\n", "dp_x", "=", "np", ".", "array", "(", "gt", "[", "\"dp_x\"", "]", ")", "*", "g_", "[", "2", "]", "/", "255.0", "\n", "dp_y", "=", "np", ".", "array", "(", "gt", "[", "\"dp_y\"", "]", ")", "*", "g_", "[", "3", "]", "/", "255.0", "\n", "py", "=", "(", "dp_y", "+", "g_", "[", "1", "]", "-", "dt", "[", "\"bbox\"", "]", "[", "1", "]", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "px", "=", "(", "dp_x", "+", "g_", "[", "0", "]", "-", "dt", "[", "\"bbox\"", "]", "[", "0", "]", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "#", "\n", "pts", "=", "np", ".", "zeros", "(", "len", "(", "px", ")", ")", "\n", "pts", "[", "px", ">=", "dx", "]", "=", "-", "1", "\n", "pts", "[", "py", ">=", "dy", "]", "=", "-", "1", "\n", "pts", "[", "px", "<", "0", "]", "=", "-", "1", "\n", "pts", "[", "py", "<", "0", "]", "=", "-", "1", "\n", "if", "len", "(", "pts", ")", "<", "1", ":", "\n", "                        ", "ogps", "=", "0.0", "\n", "", "elif", "np", ".", "max", "(", "pts", ")", "==", "-", "1", ":", "\n", "                        ", "ogps", "=", "0.0", "\n", "", "else", ":", "\n", "                        ", "px", "[", "pts", "==", "-", "1", "]", "=", "0", "\n", "py", "[", "pts", "==", "-", "1", "]", "=", "0", "\n", "(", "densepose_shape", ",", "densepose_data_encoded", ")", ",", "densepose_bbox_xywh", "=", "dt", "[", "\n", "\"densepose\"", "\n", "]", "\n", "densepose_data", "=", "DensePoseResult", ".", "decode_png_data", "(", "\n", "densepose_shape", ",", "densepose_data_encoded", "\n", ")", "\n", "assert", "densepose_data", ".", "shape", "[", "2", "]", "==", "dx", ",", "(", "\n", "\"DensePoseData width {} should be equal to \"", "\n", "\"detection bounding box width {}\"", ".", "format", "(", "densepose_data", ".", "shape", "[", "2", "]", ",", "dx", ")", "\n", ")", "\n", "assert", "densepose_data", ".", "shape", "[", "1", "]", "==", "dy", ",", "(", "\n", "\"DensePoseData height {} should be equal to \"", "\n", "\"detection bounding box height {}\"", ".", "format", "(", "densepose_data", ".", "shape", "[", "1", "]", ",", "dy", ")", "\n", ")", "\n", "ipoints", ",", "upoints", ",", "vpoints", "=", "self", ".", "_extract_iuv", "(", "densepose_data", ",", "py", ",", "px", ",", "gt", ")", "\n", "ipoints", "[", "pts", "==", "-", "1", "]", "=", "0", "\n", "# Find closest vertices in subsampled mesh.", "\n", "cVerts", ",", "cVertsGT", "=", "self", ".", "findAllClosestVerts", "(", "gt", ",", "upoints", ",", "vpoints", ",", "ipoints", ")", "\n", "# Get pairwise geodesic distances between gt and estimated mesh points.", "\n", "dist", "=", "self", ".", "getDistances", "(", "cVertsGT", ",", "cVerts", ")", "\n", "# Compute the Ogps measure.", "\n", "# Find the mean geodesic normalization distance for", "\n", "# each GT point, based on which part it is on.", "\n", "Current_Mean_Distances", "=", "self", ".", "Mean_Distances", "[", "\n", "self", ".", "CoarseParts", "[", "self", ".", "Part_ids", "[", "cVertsGT", "[", "cVertsGT", ">", "0", "]", ".", "astype", "(", "int", ")", "-", "1", "]", "]", "\n", "]", "\n", "# Compute gps", "\n", "ogps_values", "=", "np", ".", "exp", "(", "-", "(", "dist", "**", "2", ")", "/", "(", "2", "*", "(", "Current_Mean_Distances", "**", "2", ")", ")", ")", "\n", "#", "\n", "if", "len", "(", "dist", ")", ">", "0", ":", "\n", "                            ", "ogps", "=", "np", ".", "sum", "(", "ogps_values", ")", "/", "len", "(", "dist", ")", "\n", "", "", "ious", "[", "i", ",", "j", "]", "=", "ogps", "\n", "\n", "", "", "", "gbb", "=", "[", "gt", "[", "\"bbox\"", "]", "for", "gt", "in", "g", "]", "\n", "dbb", "=", "[", "dt", "[", "\"bbox\"", "]", "for", "dt", "in", "d", "]", "\n", "\n", "# compute iou between each dt and gt region", "\n", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "g", "]", "\n", "ious_bb", "=", "maskUtils", ".", "iou", "(", "dbb", ",", "gbb", ",", "iscrowd", ")", "\n", "return", "ious", ",", "ious_bb", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.evaluateImg": [[646, 789], ["numpy.argsort", "numpy.argsort", "len", "len", "len", "numpy.zeros", "numpy.zeros", "numpy.array", "numpy.zeros", "numpy.array().reshape", "numpy.logical_or", "int", "numpy.all", "numpy.logical_or", "len", "enumerate", "numpy.logical_and", "len", "len", "enumerate", "enumerate", "numpy.array", "len", "numpy.repeat", "len", "len", "len", "min", "enumerate", "len", "len", "enumerate", "numpy.sqrt"], "methods", ["None"], ["", "def", "evaluateImg", "(", "self", ",", "imgId", ",", "catId", ",", "aRng", ",", "maxDet", ")", ":", "\n", "        ", "\"\"\"\n        perform evaluation for single category and image\n        :return: dict (single image results)\n        \"\"\"", "\n", "\n", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "", "for", "g", "in", "gt", ":", "\n", "# g['_ignore'] = g['ignore']", "\n", "            ", "if", "g", "[", "\"ignore\"", "]", "or", "(", "g", "[", "\"area\"", "]", "<", "aRng", "[", "0", "]", "or", "g", "[", "\"area\"", "]", ">", "aRng", "[", "1", "]", ")", ":", "\n", "                ", "g", "[", "\"_ignore\"", "]", "=", "True", "\n", "", "else", ":", "\n", "                ", "g", "[", "\"_ignore\"", "]", "=", "False", "\n", "\n", "# sort dt highest score first, sort gt ignore last", "\n", "", "", "gtind", "=", "np", ".", "argsort", "(", "[", "g", "[", "\"_ignore\"", "]", "for", "g", "in", "gt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "gt", "=", "[", "gt", "[", "i", "]", "for", "i", "in", "gtind", "]", "\n", "dtind", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "\"mergesort\"", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "dtind", "[", "0", ":", "maxDet", "]", "]", "\n", "iscrowd", "=", "[", "int", "(", "o", "[", "\"iscrowd\"", "]", ")", "for", "o", "in", "gt", "]", "\n", "# load computed ious", "\n", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "# print('Checking the length', len(self.ious[imgId, catId]))", "\n", "# if len(self.ious[imgId, catId]) == 0:", "\n", "#    print(self.ious[imgId, catId])", "\n", "            ", "ious", "=", "(", "\n", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "[", "0", "]", "[", ":", ",", "gtind", "]", "\n", "if", "len", "(", "self", ".", "ious", "[", "imgId", ",", "catId", "]", ")", ">", "0", "\n", "else", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "\n", ")", "\n", "ioubs", "=", "(", "\n", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "[", "1", "]", "[", ":", ",", "gtind", "]", "\n", "if", "len", "(", "self", ".", "ious", "[", "imgId", ",", "catId", "]", ")", ">", "0", "\n", "else", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "\n", ")", "\n", "if", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "GPSM", ":", "\n", "                ", "iousM", "=", "(", "\n", "self", ".", "real_ious", "[", "imgId", ",", "catId", "]", "[", ":", ",", "gtind", "]", "\n", "if", "len", "(", "self", ".", "real_ious", "[", "imgId", ",", "catId", "]", ")", ">", "0", "\n", "else", "self", ".", "real_ious", "[", "imgId", ",", "catId", "]", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "ious", "=", "(", "\n", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "[", ":", ",", "gtind", "]", "\n", "if", "len", "(", "self", ".", "ious", "[", "imgId", ",", "catId", "]", ")", ">", "0", "\n", "else", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "\n", ")", "\n", "\n", "", "T", "=", "len", "(", "p", ".", "iouThrs", ")", "\n", "G", "=", "len", "(", "gt", ")", "\n", "D", "=", "len", "(", "dt", ")", "\n", "gtm", "=", "np", ".", "zeros", "(", "(", "T", ",", "G", ")", ")", "\n", "dtm", "=", "np", ".", "zeros", "(", "(", "T", ",", "D", ")", ")", "\n", "gtIg", "=", "np", ".", "array", "(", "[", "g", "[", "\"_ignore\"", "]", "for", "g", "in", "gt", "]", ")", "\n", "dtIg", "=", "np", ".", "zeros", "(", "(", "T", ",", "D", ")", ")", "\n", "if", "np", ".", "all", "(", "gtIg", ")", "and", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "dtIg", "=", "np", ".", "logical_or", "(", "dtIg", ",", "True", ")", "\n", "\n", "", "if", "len", "(", "ious", ")", ">", "0", ":", "# and not p.iouType == 'densepose':", "\n", "            ", "for", "tind", ",", "t", "in", "enumerate", "(", "p", ".", "iouThrs", ")", ":", "\n", "                ", "for", "dind", ",", "d", "in", "enumerate", "(", "dt", ")", ":", "\n", "# information about best match so far (m=-1 -> unmatched)", "\n", "                    ", "iou", "=", "min", "(", "[", "t", ",", "1", "-", "1e-10", "]", ")", "\n", "m", "=", "-", "1", "\n", "for", "gind", ",", "_g", "in", "enumerate", "(", "gt", ")", ":", "\n", "# if this gt already matched, and not a crowd, continue", "\n", "                        ", "if", "gtm", "[", "tind", ",", "gind", "]", ">", "0", "and", "not", "iscrowd", "[", "gind", "]", ":", "\n", "                            ", "continue", "\n", "# if dt matched to reg gt, and on ignore gt, stop", "\n", "", "if", "m", ">", "-", "1", "and", "gtIg", "[", "m", "]", "==", "0", "and", "gtIg", "[", "gind", "]", "==", "1", ":", "\n", "                            ", "break", "\n", "", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "                            ", "if", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "GPSM", ":", "\n", "                                ", "new_iou", "=", "np", ".", "sqrt", "(", "iousM", "[", "dind", ",", "gind", "]", "*", "ious", "[", "dind", ",", "gind", "]", ")", "\n", "", "elif", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "IOU", ":", "\n", "                                ", "new_iou", "=", "iousM", "[", "dind", ",", "gind", "]", "\n", "", "elif", "self", ".", "_dpEvalMode", "==", "DensePoseEvalMode", ".", "GPS", ":", "\n", "                                ", "new_iou", "=", "ious", "[", "dind", ",", "gind", "]", "\n", "", "", "else", ":", "\n", "                            ", "new_iou", "=", "ious", "[", "dind", ",", "gind", "]", "\n", "", "if", "new_iou", "<", "iou", ":", "\n", "                            ", "continue", "\n", "", "if", "new_iou", "==", "0.0", ":", "\n", "                            ", "continue", "\n", "# if match successful and best so far, store appropriately", "\n", "", "iou", "=", "new_iou", "\n", "m", "=", "gind", "\n", "# if match made store id of match for both dt and gt", "\n", "", "if", "m", "==", "-", "1", ":", "\n", "                        ", "continue", "\n", "", "dtIg", "[", "tind", ",", "dind", "]", "=", "gtIg", "[", "m", "]", "\n", "dtm", "[", "tind", ",", "dind", "]", "=", "gt", "[", "m", "]", "[", "\"id\"", "]", "\n", "gtm", "[", "tind", ",", "m", "]", "=", "d", "[", "\"id\"", "]", "\n", "\n", "", "", "", "if", "p", ".", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "if", "not", "len", "(", "ioubs", ")", "==", "0", ":", "\n", "                ", "for", "dind", ",", "d", "in", "enumerate", "(", "dt", ")", ":", "\n", "# information about best match so far (m=-1 -> unmatched)", "\n", "                    ", "if", "dtm", "[", "tind", ",", "dind", "]", "==", "0", ":", "\n", "                        ", "ioub", "=", "0.8", "\n", "m", "=", "-", "1", "\n", "for", "gind", ",", "_g", "in", "enumerate", "(", "gt", ")", ":", "\n", "# if this gt already matched, and not a crowd, continue", "\n", "                            ", "if", "gtm", "[", "tind", ",", "gind", "]", ">", "0", "and", "not", "iscrowd", "[", "gind", "]", ":", "\n", "                                ", "continue", "\n", "# continue to next gt unless better match made", "\n", "", "if", "ioubs", "[", "dind", ",", "gind", "]", "<", "ioub", ":", "\n", "                                ", "continue", "\n", "# if match successful and best so far, store appropriately", "\n", "", "ioub", "=", "ioubs", "[", "dind", ",", "gind", "]", "\n", "m", "=", "gind", "\n", "# if match made store id of match for both dt and gt", "\n", "", "if", "m", ">", "-", "1", ":", "\n", "                            ", "dtIg", "[", ":", ",", "dind", "]", "=", "gtIg", "[", "m", "]", "\n", "if", "gtIg", "[", "m", "]", ":", "\n", "                                ", "dtm", "[", "tind", ",", "dind", "]", "=", "gt", "[", "m", "]", "[", "\"id\"", "]", "\n", "gtm", "[", "tind", ",", "m", "]", "=", "d", "[", "\"id\"", "]", "\n", "# set unmatched detections outside of area range to ignore", "\n", "", "", "", "", "", "", "a", "=", "np", ".", "array", "(", "[", "d", "[", "\"area\"", "]", "<", "aRng", "[", "0", "]", "or", "d", "[", "\"area\"", "]", ">", "aRng", "[", "1", "]", "for", "d", "in", "dt", "]", ")", ".", "reshape", "(", "(", "1", ",", "len", "(", "dt", ")", ")", ")", "\n", "dtIg", "=", "np", ".", "logical_or", "(", "dtIg", ",", "np", ".", "logical_and", "(", "dtm", "==", "0", ",", "np", ".", "repeat", "(", "a", ",", "T", ",", "0", ")", ")", ")", "\n", "# store results for given image and category", "\n", "# print('Done with the function', len(self.ious[imgId, catId]))", "\n", "return", "{", "\n", "\"image_id\"", ":", "imgId", ",", "\n", "\"category_id\"", ":", "catId", ",", "\n", "\"aRng\"", ":", "aRng", ",", "\n", "\"maxDet\"", ":", "maxDet", ",", "\n", "\"dtIds\"", ":", "[", "d", "[", "\"id\"", "]", "for", "d", "in", "dt", "]", ",", "\n", "\"gtIds\"", ":", "[", "g", "[", "\"id\"", "]", "for", "g", "in", "gt", "]", ",", "\n", "\"dtMatches\"", ":", "dtm", ",", "\n", "\"gtMatches\"", ":", "gtm", ",", "\n", "\"dtScores\"", ":", "[", "d", "[", "\"score\"", "]", "for", "d", "in", "dt", "]", ",", "\n", "\"gtIgnore\"", ":", "gtIg", ",", "\n", "\"dtIgnore\"", ":", "dtIg", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.accumulate": [[791, 895], ["logger.info", "time.time", "len", "len", "len", "len", "logger.info", "set", "set", "set", "set", "len", "len", "enumerate", "logger.info", "time.time", "logger.info", "logger.info", "len", "numpy.ones", "numpy.ones", "map", "enumerate", "datetime.datetime.now().strftime", "enumerate", "enumerate", "enumerate", "enumerate", "enumerate", "numpy.max", "numpy.min", "map", "numpy.concatenate", "numpy.argsort", "numpy.concatenate", "numpy.count_nonzero", "numpy.logical_and", "numpy.logical_and", "numpy.cumsum().astype", "numpy.cumsum().astype", "enumerate", "datetime.datetime.now", "len", "numpy.concatenate", "numpy.concatenate", "numpy.logical_not", "numpy.logical_not", "numpy.logical_not", "zip", "numpy.array", "numpy.array", "len", "numpy.zeros", "pr.tolist.tolist.tolist", "q.tolist.tolist.tolist", "range", "numpy.searchsorted", "numpy.array", "tuple", "numpy.cumsum", "numpy.cumsum", "enumerate", "numpy.spacing"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog.Metadata.set"], ["", "def", "accumulate", "(", "self", ",", "p", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Accumulate per image evaluation results and store the result in self.eval\n        :param p: input params for evaluation\n        :return: None\n        \"\"\"", "\n", "logger", ".", "info", "(", "\"Accumulating evaluation results...\"", ")", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "self", ".", "evalImgs", ":", "\n", "            ", "logger", ".", "info", "(", "\"Please run evaluate() first\"", ")", "\n", "# allows input customized parameters", "\n", "", "if", "p", "is", "None", ":", "\n", "            ", "p", "=", "self", ".", "params", "\n", "", "p", ".", "catIds", "=", "p", ".", "catIds", "if", "p", ".", "useCats", "==", "1", "else", "[", "-", "1", "]", "\n", "T", "=", "len", "(", "p", ".", "iouThrs", ")", "\n", "R", "=", "len", "(", "p", ".", "recThrs", ")", "\n", "K", "=", "len", "(", "p", ".", "catIds", ")", "if", "p", ".", "useCats", "else", "1", "\n", "A", "=", "len", "(", "p", ".", "areaRng", ")", "\n", "M", "=", "len", "(", "p", ".", "maxDets", ")", "\n", "precision", "=", "-", "(", "np", ".", "ones", "(", "(", "T", ",", "R", ",", "K", ",", "A", ",", "M", ")", ")", ")", "# -1 for the precision of absent categories", "\n", "recall", "=", "-", "(", "np", ".", "ones", "(", "(", "T", ",", "K", ",", "A", ",", "M", ")", ")", ")", "\n", "\n", "# create dictionary for future indexing", "\n", "logger", ".", "info", "(", "\"Categories: {}\"", ".", "format", "(", "p", ".", "catIds", ")", ")", "\n", "_pe", "=", "self", ".", "_paramsEval", "\n", "catIds", "=", "_pe", ".", "catIds", "if", "_pe", ".", "useCats", "else", "[", "-", "1", "]", "\n", "setK", "=", "set", "(", "catIds", ")", "\n", "setA", "=", "set", "(", "map", "(", "tuple", ",", "_pe", ".", "areaRng", ")", ")", "\n", "setM", "=", "set", "(", "_pe", ".", "maxDets", ")", "\n", "setI", "=", "set", "(", "_pe", ".", "imgIds", ")", "\n", "# get inds to evaluate", "\n", "k_list", "=", "[", "n", "for", "n", ",", "k", "in", "enumerate", "(", "p", ".", "catIds", ")", "if", "k", "in", "setK", "]", "\n", "m_list", "=", "[", "m", "for", "n", ",", "m", "in", "enumerate", "(", "p", ".", "maxDets", ")", "if", "m", "in", "setM", "]", "\n", "a_list", "=", "[", "n", "for", "n", ",", "a", "in", "enumerate", "(", "map", "(", "lambda", "x", ":", "tuple", "(", "x", ")", ",", "p", ".", "areaRng", ")", ")", "if", "a", "in", "setA", "]", "\n", "i_list", "=", "[", "n", "for", "n", ",", "i", "in", "enumerate", "(", "p", ".", "imgIds", ")", "if", "i", "in", "setI", "]", "\n", "I0", "=", "len", "(", "_pe", ".", "imgIds", ")", "\n", "A0", "=", "len", "(", "_pe", ".", "areaRng", ")", "\n", "# retrieve E at each category, area range, and max number of detections", "\n", "for", "k", ",", "k0", "in", "enumerate", "(", "k_list", ")", ":", "\n", "            ", "Nk", "=", "k0", "*", "A0", "*", "I0", "\n", "for", "a", ",", "a0", "in", "enumerate", "(", "a_list", ")", ":", "\n", "                ", "Na", "=", "a0", "*", "I0", "\n", "for", "m", ",", "maxDet", "in", "enumerate", "(", "m_list", ")", ":", "\n", "                    ", "E", "=", "[", "self", ".", "evalImgs", "[", "Nk", "+", "Na", "+", "i", "]", "for", "i", "in", "i_list", "]", "\n", "E", "=", "[", "e", "for", "e", "in", "E", "if", "e", "is", "not", "None", "]", "\n", "if", "len", "(", "E", ")", "==", "0", ":", "\n", "                        ", "continue", "\n", "", "dtScores", "=", "np", ".", "concatenate", "(", "[", "e", "[", "\"dtScores\"", "]", "[", "0", ":", "maxDet", "]", "for", "e", "in", "E", "]", ")", "\n", "\n", "# different sorting method generates slightly different results.", "\n", "# mergesort is used to be consistent as Matlab implementation.", "\n", "inds", "=", "np", ".", "argsort", "(", "-", "dtScores", ",", "kind", "=", "\"mergesort\"", ")", "\n", "\n", "dtm", "=", "np", ".", "concatenate", "(", "[", "e", "[", "\"dtMatches\"", "]", "[", ":", ",", "0", ":", "maxDet", "]", "for", "e", "in", "E", "]", ",", "axis", "=", "1", ")", "[", ":", ",", "inds", "]", "\n", "dtIg", "=", "np", ".", "concatenate", "(", "[", "e", "[", "\"dtIgnore\"", "]", "[", ":", ",", "0", ":", "maxDet", "]", "for", "e", "in", "E", "]", ",", "axis", "=", "1", ")", "[", ":", ",", "inds", "]", "\n", "gtIg", "=", "np", ".", "concatenate", "(", "[", "e", "[", "\"gtIgnore\"", "]", "for", "e", "in", "E", "]", ")", "\n", "npig", "=", "np", ".", "count_nonzero", "(", "gtIg", "==", "0", ")", "\n", "if", "npig", "==", "0", ":", "\n", "                        ", "continue", "\n", "", "tps", "=", "np", ".", "logical_and", "(", "dtm", ",", "np", ".", "logical_not", "(", "dtIg", ")", ")", "\n", "fps", "=", "np", ".", "logical_and", "(", "np", ".", "logical_not", "(", "dtm", ")", ",", "np", ".", "logical_not", "(", "dtIg", ")", ")", "\n", "tp_sum", "=", "np", ".", "cumsum", "(", "tps", ",", "axis", "=", "1", ")", ".", "astype", "(", "dtype", "=", "np", ".", "float", ")", "\n", "fp_sum", "=", "np", ".", "cumsum", "(", "fps", ",", "axis", "=", "1", ")", ".", "astype", "(", "dtype", "=", "np", ".", "float", ")", "\n", "for", "t", ",", "(", "tp", ",", "fp", ")", "in", "enumerate", "(", "zip", "(", "tp_sum", ",", "fp_sum", ")", ")", ":", "\n", "                        ", "tp", "=", "np", ".", "array", "(", "tp", ")", "\n", "fp", "=", "np", ".", "array", "(", "fp", ")", "\n", "nd", "=", "len", "(", "tp", ")", "\n", "rc", "=", "tp", "/", "npig", "\n", "pr", "=", "tp", "/", "(", "fp", "+", "tp", "+", "np", ".", "spacing", "(", "1", ")", ")", "\n", "q", "=", "np", ".", "zeros", "(", "(", "R", ",", ")", ")", "\n", "\n", "if", "nd", ":", "\n", "                            ", "recall", "[", "t", ",", "k", ",", "a", ",", "m", "]", "=", "rc", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "                            ", "recall", "[", "t", ",", "k", ",", "a", ",", "m", "]", "=", "0", "\n", "\n", "# numpy is slow without cython optimization for accessing elements", "\n", "# use python array gets significant speed improvement", "\n", "", "pr", "=", "pr", ".", "tolist", "(", ")", "\n", "q", "=", "q", ".", "tolist", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "nd", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "                            ", "if", "pr", "[", "i", "]", ">", "pr", "[", "i", "-", "1", "]", ":", "\n", "                                ", "pr", "[", "i", "-", "1", "]", "=", "pr", "[", "i", "]", "\n", "\n", "", "", "inds", "=", "np", ".", "searchsorted", "(", "rc", ",", "p", ".", "recThrs", ",", "side", "=", "\"left\"", ")", "\n", "try", ":", "\n", "                            ", "for", "ri", ",", "pi", "in", "enumerate", "(", "inds", ")", ":", "\n", "                                ", "q", "[", "ri", "]", "=", "pr", "[", "pi", "]", "\n", "", "", "except", "Exception", ":", "\n", "                            ", "pass", "\n", "", "precision", "[", "t", ",", ":", ",", "k", ",", "a", ",", "m", "]", "=", "np", ".", "array", "(", "q", ")", "\n", "", "", "", "", "logger", ".", "info", "(", "\n", "\"Final: max precision {}, min precision {}\"", ".", "format", "(", "np", ".", "max", "(", "precision", ")", ",", "np", ".", "min", "(", "precision", ")", ")", "\n", ")", "\n", "self", ".", "eval", "=", "{", "\n", "\"params\"", ":", "p", ",", "\n", "\"counts\"", ":", "[", "T", ",", "R", ",", "K", ",", "A", ",", "M", "]", ",", "\n", "\"date\"", ":", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%Y-%m-%d %H:%M:%S\"", ")", ",", "\n", "\"precision\"", ":", "precision", ",", "\n", "\"recall\"", ":", "recall", ",", "\n", "}", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "logger", ".", "info", "(", "\"DONE (t={:0.2f}s).\"", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize": [[896, 1026], ["densepose_coco_evaluation.DensePoseCocoEval.summarize"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], ["", "def", "summarize", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute and display summary metrics for evaluation results.\n        Note this function can *only* be applied on the default parameter setting\n        \"\"\"", "\n", "\n", "def", "_summarize", "(", "ap", "=", "1", ",", "iouThr", "=", "None", ",", "areaRng", "=", "\"all\"", ",", "maxDets", "=", "100", ")", ":", "\n", "            ", "p", "=", "self", ".", "params", "\n", "iStr", "=", "\" {:<18} {} @[ {}={:<9} | area={:>6s} | maxDets={:>3d} ] = {:0.3f}\"", "\n", "titleStr", "=", "\"Average Precision\"", "if", "ap", "==", "1", "else", "\"Average Recall\"", "\n", "typeStr", "=", "\"(AP)\"", "if", "ap", "==", "1", "else", "\"(AR)\"", "\n", "measure", "=", "\"IoU\"", "\n", "if", "self", ".", "params", ".", "iouType", "==", "\"keypoints\"", ":", "\n", "                ", "measure", "=", "\"OKS\"", "\n", "", "elif", "self", ".", "params", ".", "iouType", "==", "\"densepose\"", ":", "\n", "                ", "measure", "=", "\"OGPS\"", "\n", "", "iouStr", "=", "(", "\n", "\"{:0.2f}:{:0.2f}\"", ".", "format", "(", "p", ".", "iouThrs", "[", "0", "]", ",", "p", ".", "iouThrs", "[", "-", "1", "]", ")", "\n", "if", "iouThr", "is", "None", "\n", "else", "\"{:0.2f}\"", ".", "format", "(", "iouThr", ")", "\n", ")", "\n", "\n", "aind", "=", "[", "i", "for", "i", ",", "aRng", "in", "enumerate", "(", "p", ".", "areaRngLbl", ")", "if", "aRng", "==", "areaRng", "]", "\n", "mind", "=", "[", "i", "for", "i", ",", "mDet", "in", "enumerate", "(", "p", ".", "maxDets", ")", "if", "mDet", "==", "maxDets", "]", "\n", "if", "ap", "==", "1", ":", "\n", "# dimension of precision: [TxRxKxAxM]", "\n", "                ", "s", "=", "self", ".", "eval", "[", "\"precision\"", "]", "\n", "# IoU", "\n", "if", "iouThr", "is", "not", "None", ":", "\n", "                    ", "t", "=", "np", ".", "where", "(", "np", ".", "abs", "(", "iouThr", "-", "p", ".", "iouThrs", ")", "<", "0.001", ")", "[", "0", "]", "\n", "s", "=", "s", "[", "t", "]", "\n", "", "s", "=", "s", "[", ":", ",", ":", ",", ":", ",", "aind", ",", "mind", "]", "\n", "", "else", ":", "\n", "# dimension of recall: [TxKxAxM]", "\n", "                ", "s", "=", "self", ".", "eval", "[", "\"recall\"", "]", "\n", "if", "iouThr", "is", "not", "None", ":", "\n", "                    ", "t", "=", "np", ".", "where", "(", "np", ".", "abs", "(", "iouThr", "-", "p", ".", "iouThrs", ")", "<", "0.001", ")", "[", "0", "]", "\n", "s", "=", "s", "[", "t", "]", "\n", "", "s", "=", "s", "[", ":", ",", ":", ",", "aind", ",", "mind", "]", "\n", "", "if", "len", "(", "s", "[", "s", ">", "-", "1", "]", ")", "==", "0", ":", "\n", "                ", "mean_s", "=", "-", "1", "\n", "", "else", ":", "\n", "                ", "mean_s", "=", "np", ".", "mean", "(", "s", "[", "s", ">", "-", "1", "]", ")", "\n", "", "logger", ".", "info", "(", "iStr", ".", "format", "(", "titleStr", ",", "typeStr", ",", "measure", ",", "iouStr", ",", "areaRng", ",", "maxDets", ",", "mean_s", ")", ")", "\n", "return", "mean_s", "\n", "\n", "", "def", "_summarizeDets", "(", ")", ":", "\n", "            ", "stats", "=", "np", ".", "zeros", "(", "(", "12", ",", ")", ")", "\n", "stats", "[", "0", "]", "=", "_summarize", "(", "1", ")", "\n", "stats", "[", "1", "]", "=", "_summarize", "(", "1", ",", "iouThr", "=", "0.5", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "2", "]", "=", "_summarize", "(", "1", ",", "iouThr", "=", "0.75", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "3", "]", "=", "_summarize", "(", "1", ",", "areaRng", "=", "\"small\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "4", "]", "=", "_summarize", "(", "1", ",", "areaRng", "=", "\"medium\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "5", "]", "=", "_summarize", "(", "1", ",", "areaRng", "=", "\"large\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "6", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", "\n", "stats", "[", "7", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "1", "]", ")", "\n", "stats", "[", "8", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "9", "]", "=", "_summarize", "(", "0", ",", "areaRng", "=", "\"small\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "10", "]", "=", "_summarize", "(", "0", ",", "areaRng", "=", "\"medium\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "11", "]", "=", "_summarize", "(", "0", ",", "areaRng", "=", "\"large\"", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "return", "stats", "\n", "\n", "", "def", "_summarizeKps", "(", ")", ":", "\n", "            ", "stats", "=", "np", ".", "zeros", "(", "(", "10", ",", ")", ")", "\n", "stats", "[", "0", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ")", "\n", "stats", "[", "1", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "iouThr", "=", "0.5", ")", "\n", "stats", "[", "2", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "iouThr", "=", "0.75", ")", "\n", "stats", "[", "3", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "areaRng", "=", "\"medium\"", ")", "\n", "stats", "[", "4", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "areaRng", "=", "\"large\"", ")", "\n", "stats", "[", "5", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ")", "\n", "stats", "[", "6", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "iouThr", "=", "0.5", ")", "\n", "stats", "[", "7", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "iouThr", "=", "0.75", ")", "\n", "stats", "[", "8", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "areaRng", "=", "\"medium\"", ")", "\n", "stats", "[", "9", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "areaRng", "=", "\"large\"", ")", "\n", "return", "stats", "\n", "\n", "", "def", "_summarizeUvs", "(", ")", ":", "\n", "            ", "stats", "=", "[", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", "]", "\n", "min_threshold", "=", "self", ".", "params", ".", "iouThrs", ".", "min", "(", ")", "\n", "if", "min_threshold", "<=", "0.201", ":", "\n", "                ", "stats", "+=", "[", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.2", ")", "]", "\n", "", "if", "min_threshold", "<=", "0.301", ":", "\n", "                ", "stats", "+=", "[", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.3", ")", "]", "\n", "", "if", "min_threshold", "<=", "0.401", ":", "\n", "                ", "stats", "+=", "[", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.4", ")", "]", "\n", "", "stats", "+=", "[", "\n", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.5", ")", ",", "\n", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.75", ")", ",", "\n", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"medium\"", ")", ",", "\n", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"large\"", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.5", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.75", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"medium\"", ")", ",", "\n", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"large\"", ")", ",", "\n", "]", "\n", "return", "np", ".", "array", "(", "stats", ")", "\n", "\n", "", "def", "_summarizeUvsOld", "(", ")", ":", "\n", "            ", "stats", "=", "np", ".", "zeros", "(", "(", "18", ",", ")", ")", "\n", "stats", "[", "0", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", "\n", "stats", "[", "1", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.5", ")", "\n", "stats", "[", "2", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.55", ")", "\n", "stats", "[", "3", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.60", ")", "\n", "stats", "[", "4", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.65", ")", "\n", "stats", "[", "5", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.70", ")", "\n", "stats", "[", "6", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.75", ")", "\n", "stats", "[", "7", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.80", ")", "\n", "stats", "[", "8", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.85", ")", "\n", "stats", "[", "9", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.90", ")", "\n", "stats", "[", "10", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.95", ")", "\n", "stats", "[", "11", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"medium\"", ")", "\n", "stats", "[", "12", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"large\"", ")", "\n", "stats", "[", "13", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", "\n", "stats", "[", "14", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.5", ")", "\n", "stats", "[", "15", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "iouThr", "=", "0.75", ")", "\n", "stats", "[", "16", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"medium\"", ")", "\n", "stats", "[", "17", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ",", "areaRng", "=", "\"large\"", ")", "\n", "return", "stats", "\n", "\n", "", "if", "not", "self", ".", "eval", ":", "\n", "            ", "raise", "Exception", "(", "\"Please run accumulate() first\"", ")", "\n", "", "iouType", "=", "self", ".", "params", ".", "iouType", "\n", "if", "iouType", "in", "[", "\"segm\"", ",", "\"bbox\"", "]", ":", "\n", "            ", "summarize", "=", "_summarizeDets", "\n", "", "elif", "iouType", "in", "[", "\"keypoints\"", "]", ":", "\n", "            ", "summarize", "=", "_summarizeKps", "\n", "", "elif", "iouType", "in", "[", "\"densepose\"", "]", ":", "\n", "            ", "summarize", "=", "_summarizeUvs", "\n", "", "self", ".", "stats", "=", "summarize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.__str__": [[1027, 1029], ["densepose_coco_evaluation.DensePoseCocoEval.summarize"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.summarize"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "self", ".", "summarize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.findAllClosestVerts": [[1031, 1063], ["numpy.array", "numpy.array", "numpy.array", "numpy.arange", "numpy.arange", "numpy.ones", "numpy.ones", "sum", "numpy.array", "scipy.cdist().squeeze", "sum", "numpy.array", "scipy.cdist().squeeze", "scipy.cdist", "numpy.argmin", "scipy.cdist", "numpy.argmin", "Current_Part_UVs.transpose", "numpy.array.transpose", "Current_Part_UVs.transpose", "numpy.array.transpose"], "methods", ["None"], ["", "def", "findAllClosestVerts", "(", "self", ",", "gt", ",", "U_points", ",", "V_points", ",", "Index_points", ")", ":", "\n", "#", "\n", "        ", "I_gt", "=", "np", ".", "array", "(", "gt", "[", "\"dp_I\"", "]", ")", "\n", "U_gt", "=", "np", ".", "array", "(", "gt", "[", "\"dp_U\"", "]", ")", "\n", "V_gt", "=", "np", ".", "array", "(", "gt", "[", "\"dp_V\"", "]", ")", "\n", "#", "\n", "# print(I_gt)", "\n", "#", "\n", "ClosestVerts", "=", "np", ".", "ones", "(", "Index_points", ".", "shape", ")", "*", "-", "1", "\n", "for", "i", "in", "np", ".", "arange", "(", "24", ")", ":", "\n", "#", "\n", "            ", "if", "sum", "(", "Index_points", "==", "(", "i", "+", "1", ")", ")", ">", "0", ":", "\n", "                ", "UVs", "=", "np", ".", "array", "(", "\n", "[", "U_points", "[", "Index_points", "==", "(", "i", "+", "1", ")", "]", ",", "V_points", "[", "Index_points", "==", "(", "i", "+", "1", ")", "]", "]", "\n", ")", "\n", "Current_Part_UVs", "=", "self", ".", "Part_UVs", "[", "i", "]", "\n", "Current_Part_ClosestVertInds", "=", "self", ".", "Part_ClosestVertInds", "[", "i", "]", "\n", "D", "=", "ssd", ".", "cdist", "(", "Current_Part_UVs", ".", "transpose", "(", ")", ",", "UVs", ".", "transpose", "(", ")", ")", ".", "squeeze", "(", ")", "\n", "ClosestVerts", "[", "Index_points", "==", "(", "i", "+", "1", ")", "]", "=", "Current_Part_ClosestVertInds", "[", "\n", "np", ".", "argmin", "(", "D", ",", "axis", "=", "0", ")", "\n", "]", "\n", "#", "\n", "", "", "ClosestVertsGT", "=", "np", ".", "ones", "(", "Index_points", ".", "shape", ")", "*", "-", "1", "\n", "for", "i", "in", "np", ".", "arange", "(", "24", ")", ":", "\n", "            ", "if", "sum", "(", "I_gt", "==", "(", "i", "+", "1", ")", ")", ">", "0", ":", "\n", "                ", "UVs", "=", "np", ".", "array", "(", "[", "U_gt", "[", "I_gt", "==", "(", "i", "+", "1", ")", "]", ",", "V_gt", "[", "I_gt", "==", "(", "i", "+", "1", ")", "]", "]", ")", "\n", "Current_Part_UVs", "=", "self", ".", "Part_UVs", "[", "i", "]", "\n", "Current_Part_ClosestVertInds", "=", "self", ".", "Part_ClosestVertInds", "[", "i", "]", "\n", "D", "=", "ssd", ".", "cdist", "(", "Current_Part_UVs", ".", "transpose", "(", ")", ",", "UVs", ".", "transpose", "(", ")", ")", ".", "squeeze", "(", ")", "\n", "ClosestVertsGT", "[", "I_gt", "==", "(", "i", "+", "1", ")", "]", "=", "Current_Part_ClosestVertInds", "[", "np", ".", "argmin", "(", "D", ",", "axis", "=", "0", ")", "]", "\n", "#", "\n", "", "", "return", "ClosestVerts", ",", "ClosestVertsGT", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.DensePoseCocoEval.getDistances": [[1064, 1102], ["range", "numpy.atleast_1d", "len", "numpy.array().squeeze", "cVerts.astype", "cVertsGT.astype", "dists.append", "numpy.array", "dists.append", "dists.append", "dists.append", "int", "int"], "methods", ["None"], ["", "def", "getDistances", "(", "self", ",", "cVertsGT", ",", "cVerts", ")", ":", "\n", "\n", "        ", "ClosestVertsTransformed", "=", "self", ".", "PDIST_transform", "[", "cVerts", ".", "astype", "(", "int", ")", "-", "1", "]", "\n", "ClosestVertsGTTransformed", "=", "self", ".", "PDIST_transform", "[", "cVertsGT", ".", "astype", "(", "int", ")", "-", "1", "]", "\n", "#", "\n", "ClosestVertsTransformed", "[", "cVerts", "<", "0", "]", "=", "0", "\n", "ClosestVertsGTTransformed", "[", "cVertsGT", "<", "0", "]", "=", "0", "\n", "#", "\n", "cVertsGT", "=", "ClosestVertsGTTransformed", "\n", "cVerts", "=", "ClosestVertsTransformed", "\n", "#", "\n", "n", "=", "27554", "\n", "dists", "=", "[", "]", "\n", "for", "d", "in", "range", "(", "len", "(", "cVertsGT", ")", ")", ":", "\n", "            ", "if", "cVertsGT", "[", "d", "]", ">", "0", ":", "\n", "                ", "if", "cVerts", "[", "d", "]", ">", "0", ":", "\n", "                    ", "i", "=", "cVertsGT", "[", "d", "]", "-", "1", "\n", "j", "=", "cVerts", "[", "d", "]", "-", "1", "\n", "if", "j", "==", "i", ":", "\n", "                        ", "dists", ".", "append", "(", "0", ")", "\n", "", "elif", "j", ">", "i", ":", "\n", "                        ", "ccc", "=", "i", "\n", "i", "=", "j", "\n", "j", "=", "ccc", "\n", "i", "=", "n", "-", "i", "-", "1", "\n", "j", "=", "n", "-", "j", "-", "1", "\n", "k", "=", "(", "n", "*", "(", "n", "-", "1", ")", "/", "2", ")", "-", "(", "n", "-", "i", ")", "*", "(", "(", "n", "-", "i", ")", "-", "1", ")", "/", "2", "+", "j", "-", "i", "-", "1", "\n", "k", "=", "(", "n", "*", "n", "-", "n", ")", "/", "2", "-", "k", "-", "1", "\n", "dists", ".", "append", "(", "self", ".", "Pdist_matrix", "[", "int", "(", "k", ")", "]", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                        ", "i", "=", "n", "-", "i", "-", "1", "\n", "j", "=", "n", "-", "j", "-", "1", "\n", "k", "=", "(", "n", "*", "(", "n", "-", "1", ")", "/", "2", ")", "-", "(", "n", "-", "i", ")", "*", "(", "(", "n", "-", "i", ")", "-", "1", ")", "/", "2", "+", "j", "-", "i", "-", "1", "\n", "k", "=", "(", "n", "*", "n", "-", "n", ")", "/", "2", "-", "k", "-", "1", "\n", "dists", ".", "append", "(", "self", ".", "Pdist_matrix", "[", "int", "(", "k", ")", "]", "[", "0", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "dists", ".", "append", "(", "np", ".", "inf", ")", "\n", "", "", "", "return", "np", ".", "atleast_1d", "(", "np", ".", "array", "(", "dists", ")", ".", "squeeze", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.Params.setDetParams": [[1109, 1124], ["numpy.linspace", "numpy.linspace", "int", "int", "numpy.round", "numpy.round"], "methods", ["None"], ["def", "setDetParams", "(", "self", ")", ":", "\n", "        ", "self", ".", "imgIds", "=", "[", "]", "\n", "self", ".", "catIds", "=", "[", "]", "\n", "# np.arange causes trouble.  the data point on arange is slightly larger than the true value", "\n", "self", ".", "iouThrs", "=", "np", ".", "linspace", "(", "0.5", ",", "0.95", ",", "int", "(", "np", ".", "round", "(", "(", "0.95", "-", "0.5", ")", "/", "0.05", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "recThrs", "=", "np", ".", "linspace", "(", "0.0", ",", "1.00", ",", "int", "(", "np", ".", "round", "(", "(", "1.00", "-", "0.0", ")", "/", "0.01", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "maxDets", "=", "[", "1", ",", "10", ",", "100", "]", "\n", "self", ".", "areaRng", "=", "[", "\n", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "]", "\n", "self", ".", "areaRngLbl", "=", "[", "\"all\"", ",", "\"small\"", ",", "\"medium\"", ",", "\"large\"", "]", "\n", "self", ".", "useCats", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.Params.setKpParams": [[1125, 1135], ["numpy.linspace", "numpy.linspace", "numpy.round", "numpy.round"], "methods", ["None"], ["", "def", "setKpParams", "(", "self", ")", ":", "\n", "        ", "self", ".", "imgIds", "=", "[", "]", "\n", "self", ".", "catIds", "=", "[", "]", "\n", "# np.arange causes trouble.  the data point on arange is slightly larger than the true value", "\n", "self", ".", "iouThrs", "=", "np", ".", "linspace", "(", "0.5", ",", "0.95", ",", "np", ".", "round", "(", "(", "0.95", "-", "0.5", ")", "/", "0.05", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "recThrs", "=", "np", ".", "linspace", "(", "0.0", ",", "1.00", ",", "np", ".", "round", "(", "(", "1.00", "-", "0.0", ")", "/", "0.01", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "maxDets", "=", "[", "20", "]", "\n", "self", ".", "areaRng", "=", "[", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", "]", "\n", "self", ".", "areaRngLbl", "=", "[", "\"all\"", ",", "\"medium\"", ",", "\"large\"", "]", "\n", "self", ".", "useCats", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.Params.setUvParams": [[1136, 1145], ["numpy.linspace", "numpy.linspace", "int", "int", "numpy.round", "numpy.round"], "methods", ["None"], ["", "def", "setUvParams", "(", "self", ")", ":", "\n", "        ", "self", ".", "imgIds", "=", "[", "]", "\n", "self", ".", "catIds", "=", "[", "]", "\n", "self", ".", "iouThrs", "=", "np", ".", "linspace", "(", "0.5", ",", "0.95", ",", "int", "(", "np", ".", "round", "(", "(", "0.95", "-", "0.5", ")", "/", "0.05", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "recThrs", "=", "np", ".", "linspace", "(", "0.0", ",", "1.00", ",", "int", "(", "np", ".", "round", "(", "(", "1.00", "-", "0.0", ")", "/", "0.01", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "maxDets", "=", "[", "20", "]", "\n", "self", ".", "areaRng", "=", "[", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", "]", "\n", "self", ".", "areaRngLbl", "=", "[", "\"all\"", ",", "\"medium\"", ",", "\"large\"", "]", "\n", "self", ".", "useCats", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.Params.__init__": [[1146, 1158], ["densepose_coco_evaluation.Params.setDetParams", "densepose_coco_evaluation.Params.setKpParams", "densepose_coco_evaluation.Params.setUvParams", "Exception"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.Params.setDetParams", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.Params.setKpParams", "home.repos.pwc.inspect_result.JosephKJ_OWOD.densepose.densepose_coco_evaluation.Params.setUvParams"], ["", "def", "__init__", "(", "self", ",", "iouType", "=", "\"segm\"", ")", ":", "\n", "        ", "if", "iouType", "==", "\"segm\"", "or", "iouType", "==", "\"bbox\"", ":", "\n", "            ", "self", ".", "setDetParams", "(", ")", "\n", "", "elif", "iouType", "==", "\"keypoints\"", ":", "\n", "            ", "self", ".", "setKpParams", "(", ")", "\n", "", "elif", "iouType", "==", "\"densepose\"", ":", "\n", "            ", "self", ".", "setUvParams", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"iouType not supported\"", ")", "\n", "", "self", ".", "iouType", "=", "iouType", "\n", "# useSegm is deprecated", "\n", "self", ".", "useSegm", "=", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin.__init__": [[29, 42], ["super().__init__", "confidence.DensePoseConfidenceModelConfig.from_cfg", "chart_confidence.DensePoseChartConfidencePredictorMixin._initialize_confidence_estimation_layers", "utils.initialize_module_params"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.confidence.DensePoseConfidenceModelConfig.from_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin._initialize_confidence_estimation_layers", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.utils.initialize_module_params"], ["def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize confidence predictor using configuration options.\n\n        Args:\n            cfg (CfgNode): configuration options\n            input_channels (int): number of input channels\n        \"\"\"", "\n", "# we rely on base predictor to call nn.Module.__init__", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_channels", ")", "\n", "self", ".", "confidence_model_cfg", "=", "DensePoseConfidenceModelConfig", ".", "from_cfg", "(", "cfg", ")", "\n", "self", ".", "_initialize_confidence_estimation_layers", "(", "cfg", ",", "input_channels", ")", "\n", "initialize_module_params", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin._initialize_confidence_estimation_layers": [[43, 82], ["detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "ValueError", "int", "int", "int", "int", "int", "int"], "methods", ["None"], ["", "def", "_initialize_confidence_estimation_layers", "(", "self", ",", "cfg", ":", "CfgNode", ",", "dim_in", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize confidence estimation layers based on configuration options\n\n        Args:\n            cfg (CfgNode): configuration options\n            dim_in (int): number of input channels\n        \"\"\"", "\n", "dim_out_patches", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_PATCHES", "+", "1", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECONV_KERNEL", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "                ", "self", ".", "sigma_2_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "", "elif", "(", "\n", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "\n", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", "\n", ")", ":", "\n", "                ", "self", ".", "sigma_2_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "kappa_u_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "kappa_v_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Unknown confidence model type: \"", "\n", "f\"{self.confidence_model_cfg.confidence_model_type}\"", "\n", ")", "\n", "", "", "if", "self", ".", "confidence_model_cfg", ".", "segm_confidence", ".", "enabled", ":", "\n", "            ", "self", ".", "fine_segm_confidence_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "1", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "coarse_segm_confidence_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "1", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart_confidence.DensePoseChartConfidencePredictorMixin.forward": [[84, 177], ["super().forward", "results.append", "isinstance", "results.append", "results.append", "tuple", "isinstance", "chart_confidence.DensePoseChartConfidencePredictorMixin.fine_segm_confidence_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "chart_confidence.DensePoseChartConfidencePredictorMixin.coarse_segm_confidence_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "results.extend", "chart_confidence.DensePoseChartConfidencePredictorMixin.sigma_2_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "torch.nn.functional.softplus", "torch.repeat_interleave", "torch.nn.functional.softplus", "torch.repeat_interleave", "chart_confidence.DensePoseChartConfidencePredictorMixin.sigma_2_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.kappa_u_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.kappa_v_lowres", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "chart_confidence.DensePoseChartConfidencePredictorMixin.interp2d", "ValueError"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d"], ["", "", "def", "forward", "(", "self", ",", "head_outputs", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Perform forward operation on head outputs used as inputs for the predictor.\n        Calls forward method from the base predictor and uses its outputs to compute\n        confidences.\n\n        Args:\n            head_outputs (Tensor): head outputs used as predictor inputs\n        Return:\n            A tuple containing the following entries:\n            - SIUV tuple with possibly modified segmentation tensors\n            - various other outputs from the base predictor\n            - 6 tensors with estimated confidence model parameters at full resolution\n            (sigma_1, sigma_2, kappa_u, kappa_v, fine_segm_confidence, coarse_segm_confidence)\n            - 6 tensors with estimated confidence model parameters at half resolution\n            (sigma_1, sigma_2, kappa_u, kappa_v, fine_segm_confidence, coarse_segm_confidence)\n        \"\"\"", "\n", "# assuming base class returns SIUV estimates in its first result", "\n", "base_predictor_outputs", "=", "super", "(", ")", ".", "forward", "(", "head_outputs", ")", "\n", "siuv", "=", "(", "\n", "base_predictor_outputs", "[", "0", "]", "\n", "if", "isinstance", "(", "base_predictor_outputs", ",", "tuple", ")", "\n", "else", "base_predictor_outputs", "\n", ")", "\n", "coarse_segm", ",", "fine_segm", ",", "u", ",", "v", "=", "siuv", "\n", "\n", "sigma_1", ",", "sigma_2", ",", "kappa_u", ",", "kappa_v", "=", "None", ",", "None", ",", "None", ",", "None", "\n", "sigma_1_lowres", ",", "sigma_2_lowres", ",", "kappa_u_lowres", ",", "kappa_v_lowres", "=", "None", ",", "None", ",", "None", ",", "None", "\n", "fine_segm_confidence_lowres", ",", "fine_segm_confidence", "=", "None", ",", "None", "\n", "coarse_segm_confidence_lowres", ",", "coarse_segm_confidence", "=", "None", ",", "None", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "                ", "sigma_2_lowres", "=", "self", ".", "sigma_2_lowres", "(", "head_outputs", ")", "\n", "# assuming base class defines interp2d method for bilinear interpolation", "\n", "sigma_2", "=", "self", ".", "interp2d", "(", "sigma_2_lowres", ")", "\n", "", "elif", "(", "\n", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "\n", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", "\n", ")", ":", "\n", "                ", "sigma_2_lowres", "=", "self", ".", "sigma_2_lowres", "(", "head_outputs", ")", "\n", "kappa_u_lowres", "=", "self", ".", "kappa_u_lowres", "(", "head_outputs", ")", "\n", "kappa_v_lowres", "=", "self", ".", "kappa_v_lowres", "(", "head_outputs", ")", "\n", "# assuming base class defines interp2d method for bilinear interpolation", "\n", "sigma_2", "=", "self", ".", "interp2d", "(", "sigma_2_lowres", ")", "\n", "kappa_u", "=", "self", ".", "interp2d", "(", "kappa_u_lowres", ")", "\n", "kappa_v", "=", "self", ".", "interp2d", "(", "kappa_v_lowres", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Unknown confidence model type: \"", "\n", "f\"{self.confidence_model_cfg.confidence_model_type}\"", "\n", ")", "\n", "", "", "if", "self", ".", "confidence_model_cfg", ".", "segm_confidence", ".", "enabled", ":", "\n", "            ", "fine_segm_confidence_lowres", "=", "self", ".", "fine_segm_confidence_lowres", "(", "head_outputs", ")", "\n", "# assuming base class defines interp2d method for bilinear interpolation", "\n", "fine_segm_confidence", "=", "self", ".", "interp2d", "(", "fine_segm_confidence_lowres", ")", "\n", "fine_segm_confidence", "=", "(", "\n", "F", ".", "softplus", "(", "fine_segm_confidence", ")", "+", "self", ".", "confidence_model_cfg", ".", "segm_confidence", ".", "epsilon", "\n", ")", "\n", "fine_segm", "=", "fine_segm", "*", "torch", ".", "repeat_interleave", "(", "\n", "fine_segm_confidence", ",", "fine_segm", ".", "shape", "[", "1", "]", ",", "dim", "=", "1", "\n", ")", "\n", "coarse_segm_confidence_lowres", "=", "self", ".", "coarse_segm_confidence_lowres", "(", "head_outputs", ")", "\n", "# assuming base class defines interp2d method for bilinear interpolation", "\n", "coarse_segm_confidence", "=", "self", ".", "interp2d", "(", "coarse_segm_confidence_lowres", ")", "\n", "coarse_segm_confidence", "=", "(", "\n", "F", ".", "softplus", "(", "coarse_segm_confidence", ")", "\n", "+", "self", ".", "confidence_model_cfg", ".", "segm_confidence", ".", "epsilon", "\n", ")", "\n", "coarse_segm", "=", "coarse_segm", "*", "torch", ".", "repeat_interleave", "(", "\n", "coarse_segm_confidence", ",", "coarse_segm", ".", "shape", "[", "1", "]", ",", "dim", "=", "1", "\n", ")", "\n", "", "results", "=", "[", "]", "\n", "# append SIUV with possibly modified segmentation tensors", "\n", "results", ".", "append", "(", "(", "coarse_segm", ",", "fine_segm", ",", "u", ",", "v", ")", ")", "\n", "# append the rest of base predictor outputs", "\n", "if", "isinstance", "(", "base_predictor_outputs", ",", "tuple", ")", ":", "\n", "            ", "results", ".", "extend", "(", "base_predictor_outputs", "[", "1", ":", "]", ")", "\n", "# append hi-res confidence estimates", "\n", "", "results", ".", "append", "(", "\n", "(", "sigma_1", ",", "sigma_2", ",", "kappa_u", ",", "kappa_v", ",", "fine_segm_confidence", ",", "coarse_segm_confidence", ")", "\n", ")", "\n", "# append lo-res confidence estimates", "\n", "results", ".", "append", "(", "\n", "(", "\n", "sigma_1_lowres", ",", "\n", "sigma_2_lowres", ",", "\n", "kappa_u_lowres", ",", "\n", "kappa_v_lowres", ",", "\n", "fine_segm_confidence_lowres", ",", "\n", "coarse_segm_confidence_lowres", ",", "\n", ")", "\n", ")", "\n", "return", "tuple", "(", "results", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.__init__": [[31, 58], ["torch.nn.Module.__init__", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "detectron2.layers.ConvTranspose2d", "utils.initialize_module_params", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.utils.initialize_module_params"], ["def", "__init__", "(", "self", ",", "cfg", ":", "CfgNode", ",", "input_channels", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize predictor using configuration options\n\n        Args:\n            cfg (CfgNode): configuration options\n            input_channels (int): input tensor size along the channel dimension\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "dim_in", "=", "input_channels", "\n", "n_segm_chan", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_COARSE_SEGM_CHANNELS", "\n", "dim_out_patches", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_PATCHES", "+", "1", "\n", "kernel_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "DECONV_KERNEL", "\n", "self", ".", "ann_index_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "n_segm_chan", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "index_uv_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "u_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "v_lowres", "=", "ConvTranspose2d", "(", "\n", "dim_in", ",", "dim_out_patches", ",", "kernel_size", ",", "stride", "=", "2", ",", "padding", "=", "int", "(", "kernel_size", "/", "2", "-", "1", ")", "\n", ")", "\n", "self", ".", "scale_factor", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "UP_SCALE", "\n", "initialize_module_params", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d": [[59, 71], ["detectron2.layers.interpolate"], "methods", ["None"], ["", "def", "interp2d", "(", "self", ",", "tensor_nchw", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Bilinear interpolation method to be used for upscaling\n\n        Args:\n            tensor_nchw (tensor): tensor of shape (N, C, H, W)\n        Return:\n            tensor of shape (N, C, Hout, Wout), where Hout and Wout are computed\n                by applying the scale factor to H and W\n        \"\"\"", "\n", "return", "interpolate", "(", "\n", "tensor_nchw", ",", "scale_factor", "=", "self", ".", "scale_factor", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.forward": [[73, 103], ["chart.DensePoseChartPredictor.ann_index_lowres", "chart.DensePoseChartPredictor.index_uv_lowres", "chart.DensePoseChartPredictor.u_lowres", "chart.DensePoseChartPredictor.v_lowres", "chart.DensePoseChartPredictor.interp2d", "chart.DensePoseChartPredictor.interp2d", "chart.DensePoseChartPredictor.interp2d", "chart.DensePoseChartPredictor.interp2d"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d", "home.repos.pwc.inspect_result.JosephKJ_OWOD.predictors.chart.DensePoseChartPredictor.interp2d"], ["", "def", "forward", "(", "self", ",", "head_outputs", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Perform forward step on DensePose head outputs\n\n        Args:\n            head_outputs (tensor): DensePose head outputs, tensor of shape [N, D, H, W]\n        Return:\n           - a tuple of 4 tensors containing DensePose predictions for charts:\n               * coarse segmentation estimate, a tensor of shape [N, K, Hout, Wout]\n               * fine segmentation estimate, a tensor of shape [N, C, Hout, Wout]\n               * U coordinates, a tensor of shape [N, C, Hout, Wout]\n               * V coordinates, a tensor of shape [N, C, Hout, Wout]\n           - a tuple of 4 tensors containing DensePose predictions for charts at reduced resolution:\n               * coarse segmentation estimate, a tensor of shape [N, K, Hout / 2, Wout / 2]\n               * fine segmentation estimate, a tensor of shape [N, C, Hout / 2, Wout / 2]\n               * U coordinates, a tensor of shape [N, C, Hout / 2, Wout / 2]\n               * V coordinates, a tensor of shape [N, C, Hout / 2, Wout / 2]\n        \"\"\"", "\n", "coarse_segm_lowres", "=", "self", ".", "ann_index_lowres", "(", "head_outputs", ")", "\n", "fine_segm_lowres", "=", "self", ".", "index_uv_lowres", "(", "head_outputs", ")", "\n", "u_lowres", "=", "self", ".", "u_lowres", "(", "head_outputs", ")", "\n", "v_lowres", "=", "self", ".", "v_lowres", "(", "head_outputs", ")", "\n", "\n", "coarse_segm", "=", "self", ".", "interp2d", "(", "coarse_segm_lowres", ")", "\n", "fine_segm", "=", "self", ".", "interp2d", "(", "fine_segm_lowres", ")", "\n", "u", "=", "self", ".", "interp2d", "(", "u_lowres", ")", "\n", "v", "=", "self", ".", "interp2d", "(", "v_lowres", ")", "\n", "siuv", "=", "(", "coarse_segm", ",", "fine_segm", ",", "u", ",", "v", ")", "\n", "siuv_lowres", "=", "(", "coarse_segm_lowres", ",", "fine_segm_lowres", ",", "u_lowres", ",", "v_lowres", ")", "\n", "return", "siuv", ",", "siuv_lowres", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.SingleTensorsHelper.__init__": [[61, 81], ["locals().items", "torch.no_grad", "densepose_losses._extract_single_tensors_from_matches", "locals", "setattr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._extract_single_tensors_from_matches"], ["    ", "def", "__init__", "(", "self", ",", "proposals_with_gt", ")", ":", "\n", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "(", "\n", "index_uv_img", ",", "\n", "i_with_dp", ",", "\n", "bbox_xywh_est", ",", "\n", "bbox_xywh_gt", ",", "\n", "index_gt_all", ",", "\n", "x_norm", ",", "\n", "y_norm", ",", "\n", "u_gt_all", ",", "\n", "v_gt_all", ",", "\n", "s_gt", ",", "\n", "index_bbox", ",", "\n", ")", "=", "_extract_single_tensors_from_matches", "(", "proposals_with_gt", ")", "\n", "\n", "", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "not", "in", "[", "\"self\"", ",", "\"proposals_with_gt\"", "]", ":", "\n", "                ", "setattr", "(", "self", ",", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.__init__": [[107, 123], ["locals().items", "locals", "setattr"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "tensors_helper", ",", "\n", "j_valid", ",", "\n", "y_lo", ",", "\n", "y_hi", ",", "\n", "x_lo", ",", "\n", "x_hi", ",", "\n", "w_ylo_xlo", ",", "\n", "w_ylo_xhi", ",", "\n", "w_yhi_xlo", ",", "\n", "w_yhi_xhi", ",", "\n", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "locals", "(", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "!=", "\"self\"", ":", "\n", "                ", "setattr", "(", "self", ",", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.from_matches": [[124, 157], ["tensors_helper.bbox_xywh_gt[].unbind", "tensors_helper.bbox_xywh_est[].unbind", "densepose_losses._linear_interpolation_utilities", "densepose_losses._linear_interpolation_utilities", "densepose_losses.BilinearInterpolationHelper"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._linear_interpolation_utilities", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._linear_interpolation_utilities"], ["", "", "", "@", "staticmethod", "\n", "def", "from_matches", "(", "tensors_helper", ",", "densepose_outputs_size", ")", ":", "\n", "\n", "        ", "zh", ",", "zw", "=", "densepose_outputs_size", "[", "2", "]", ",", "densepose_outputs_size", "[", "3", "]", "\n", "\n", "x0_gt", ",", "y0_gt", ",", "w_gt", ",", "h_gt", "=", "tensors_helper", ".", "bbox_xywh_gt", "[", "tensors_helper", ".", "index_bbox", "]", ".", "unbind", "(", "1", ")", "\n", "x0_est", ",", "y0_est", ",", "w_est", ",", "h_est", "=", "tensors_helper", ".", "bbox_xywh_est", "[", "\n", "tensors_helper", ".", "index_bbox", "\n", "]", ".", "unbind", "(", "dim", "=", "1", ")", "\n", "x_lo", ",", "x_hi", ",", "x_w", ",", "jx_valid", "=", "_linear_interpolation_utilities", "(", "\n", "tensors_helper", ".", "x_norm", ",", "x0_gt", ",", "w_gt", ",", "x0_est", ",", "w_est", ",", "zw", "\n", ")", "\n", "y_lo", ",", "y_hi", ",", "y_w", ",", "jy_valid", "=", "_linear_interpolation_utilities", "(", "\n", "tensors_helper", ".", "y_norm", ",", "y0_gt", ",", "h_gt", ",", "y0_est", ",", "h_est", ",", "zh", "\n", ")", "\n", "j_valid", "=", "jx_valid", "*", "jy_valid", "\n", "\n", "w_ylo_xlo", "=", "(", "1.0", "-", "x_w", ")", "*", "(", "1.0", "-", "y_w", ")", "\n", "w_ylo_xhi", "=", "x_w", "*", "(", "1.0", "-", "y_w", ")", "\n", "w_yhi_xlo", "=", "(", "1.0", "-", "x_w", ")", "*", "y_w", "\n", "w_yhi_xhi", "=", "x_w", "*", "y_w", "\n", "\n", "return", "BilinearInterpolationHelper", "(", "\n", "tensors_helper", ",", "\n", "j_valid", ",", "\n", "y_lo", ",", "\n", "y_hi", ",", "\n", "x_lo", ",", "\n", "x_hi", ",", "\n", "w_ylo_xlo", ",", "\n", "w_ylo_xhi", ",", "\n", "w_yhi_xlo", ",", "\n", "w_yhi_xhi", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.extract_at_points": [[159, 191], ["None"], "methods", ["None"], ["", "def", "extract_at_points", "(", "\n", "self", ",", "\n", "z_est", ",", "\n", "slice_index_uv", "=", "None", ",", "\n", "w_ylo_xlo", "=", "None", ",", "\n", "w_ylo_xhi", "=", "None", ",", "\n", "w_yhi_xlo", "=", "None", ",", "\n", "w_yhi_xhi", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Extract ground truth values z_gt for valid point indices and estimated\n        values z_est using bilinear interpolation over top-left (y_lo, x_lo),\n        top-right (y_lo, x_hi), bottom-left (y_hi, x_lo) and bottom-right\n        (y_hi, x_hi) values in z_est with corresponding weights:\n        w_ylo_xlo, w_ylo_xhi, w_yhi_xlo and w_yhi_xhi.\n        Use slice_index_uv to slice dim=1 in z_est\n        \"\"\"", "\n", "index_gt_all", "=", "self", ".", "tensors_helper", ".", "index_gt_all", "\n", "slice_index_uv", "=", "index_gt_all", "if", "slice_index_uv", "is", "None", "else", "slice_index_uv", "\n", "w_ylo_xlo", "=", "self", ".", "w_ylo_xlo", "if", "w_ylo_xlo", "is", "None", "else", "w_ylo_xlo", "\n", "w_ylo_xhi", "=", "self", ".", "w_ylo_xhi", "if", "w_ylo_xhi", "is", "None", "else", "w_ylo_xhi", "\n", "w_yhi_xlo", "=", "self", ".", "w_yhi_xlo", "if", "w_yhi_xlo", "is", "None", "else", "w_yhi_xlo", "\n", "w_yhi_xhi", "=", "self", ".", "w_yhi_xhi", "if", "w_yhi_xhi", "is", "None", "else", "w_yhi_xhi", "\n", "\n", "index_bbox", "=", "self", ".", "tensors_helper", ".", "index_bbox", "\n", "z_est_sampled", "=", "(", "\n", "z_est", "[", "index_bbox", ",", "slice_index_uv", ",", "self", ".", "y_lo", ",", "self", ".", "x_lo", "]", "*", "w_ylo_xlo", "\n", "+", "z_est", "[", "index_bbox", ",", "slice_index_uv", ",", "self", ".", "y_lo", ",", "self", ".", "x_hi", "]", "*", "w_ylo_xhi", "\n", "+", "z_est", "[", "index_bbox", ",", "slice_index_uv", ",", "self", ".", "y_hi", ",", "self", ".", "x_lo", "]", "*", "w_yhi_xlo", "\n", "+", "z_est", "[", "index_bbox", ",", "slice_index_uv", ",", "self", ".", "y_hi", ",", "self", ".", "x_hi", "]", "*", "w_yhi_xhi", "\n", ")", "\n", "return", "z_est_sampled", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.IIDIsotropicGaussianUVLoss.__init__": [[447, 451], ["torch.nn.Module.__init__", "math.log"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "sigma_lower_bound", ":", "float", ")", ":", "\n", "        ", "super", "(", "IIDIsotropicGaussianUVLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "sigma_lower_bound", "=", "sigma_lower_bound", "\n", "self", ".", "log2pi", "=", "math", ".", "log", "(", "2", "*", "math", ".", "pi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.IIDIsotropicGaussianUVLoss.forward": [[452, 469], ["loss.sum", "torch.nn.functional.softplus", "torch.log"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "u", ":", "torch", ".", "Tensor", ",", "\n", "v", ":", "torch", ".", "Tensor", ",", "\n", "sigma_u", ":", "torch", ".", "Tensor", ",", "\n", "target_u", ":", "torch", ".", "Tensor", ",", "\n", "target_v", ":", "torch", ".", "Tensor", ",", "\n", ")", ":", "\n", "# compute $\\sigma_i^2$", "\n", "# use sigma_lower_bound to avoid degenerate solution for variance", "\n", "# (sigma -> 0)", "\n", "        ", "sigma2", "=", "F", ".", "softplus", "(", "sigma_u", ")", "+", "self", ".", "sigma_lower_bound", "\n", "# compute \\|delta_i\\|^2", "\n", "delta_t_delta", "=", "(", "u", "-", "target_u", ")", "**", "2", "+", "(", "v", "-", "target_v", ")", "**", "2", "\n", "# the total loss from the formula above:", "\n", "loss", "=", "0.5", "*", "(", "self", ".", "log2pi", "+", "2", "*", "torch", ".", "log", "(", "sigma2", ")", "+", "delta_t_delta", "/", "sigma2", ")", "\n", "return", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.IndepAnisotropicGaussianUVLoss.__init__": [[487, 491], ["torch.nn.Module.__init__", "math.log"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "sigma_lower_bound", ":", "float", ")", ":", "\n", "        ", "super", "(", "IndepAnisotropicGaussianUVLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "sigma_lower_bound", "=", "sigma_lower_bound", "\n", "self", ".", "log2pi", "=", "math", ".", "log", "(", "2", "*", "math", ".", "pi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.IndepAnisotropicGaussianUVLoss.forward": [[492, 521], ["loss.sum", "torch.nn.functional.softplus", "torch.log"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "u", ":", "torch", ".", "Tensor", ",", "\n", "v", ":", "torch", ".", "Tensor", ",", "\n", "sigma_u", ":", "torch", ".", "Tensor", ",", "\n", "kappa_u_est", ":", "torch", ".", "Tensor", ",", "\n", "kappa_v_est", ":", "torch", ".", "Tensor", ",", "\n", "target_u", ":", "torch", ".", "Tensor", ",", "\n", "target_v", ":", "torch", ".", "Tensor", ",", "\n", ")", ":", "\n", "# compute $\\sigma_i^2$", "\n", "        ", "sigma2", "=", "F", ".", "softplus", "(", "sigma_u", ")", "+", "self", ".", "sigma_lower_bound", "\n", "# compute \\|r_i\\|^2", "\n", "r_sqnorm2", "=", "kappa_u_est", "**", "2", "+", "kappa_v_est", "**", "2", "\n", "delta_u", "=", "u", "-", "target_u", "\n", "delta_v", "=", "v", "-", "target_v", "\n", "# compute \\|delta_i\\|^2", "\n", "delta_sqnorm", "=", "delta_u", "**", "2", "+", "delta_v", "**", "2", "\n", "delta_u_r_u", "=", "delta_u", "*", "kappa_u_est", "\n", "delta_v_r_v", "=", "delta_v", "*", "kappa_v_est", "\n", "# compute the scalar product <delta_i, r_i>", "\n", "delta_r", "=", "delta_u_r_u", "+", "delta_v_r_v", "\n", "# compute squared scalar product <delta_i, r_i>^2", "\n", "delta_r_sqnorm", "=", "delta_r", "**", "2", "\n", "denom2", "=", "sigma2", "*", "(", "sigma2", "+", "r_sqnorm2", ")", "\n", "loss", "=", "0.5", "*", "(", "\n", "self", ".", "log2pi", "+", "torch", ".", "log", "(", "denom2", ")", "+", "delta_sqnorm", "/", "sigma2", "-", "delta_r_sqnorm", "/", "denom2", "\n", ")", "\n", "return", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.__init__": [[524, 541], ["DensePoseConfidenceModelConfig.from_cfg", "densepose_losses.IIDIsotropicGaussianUVLoss", "densepose_losses.IndepAnisotropicGaussianUVLoss"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.modeling.confidence.DensePoseConfidenceModelConfig.from_cfg"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "# fmt: off", "\n", "        ", "self", ".", "heatmap_size", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "HEATMAP_SIZE", "\n", "self", ".", "w_points", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "POINT_REGRESSION_WEIGHTS", "\n", "self", ".", "w_part", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "PART_WEIGHTS", "\n", "self", ".", "w_segm", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "INDEX_WEIGHTS", "\n", "self", ".", "n_segm_chan", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "NUM_COARSE_SEGM_CHANNELS", "\n", "# fmt: on", "\n", "self", ".", "segm_trained_by_masks", "=", "cfg", ".", "MODEL", ".", "ROI_DENSEPOSE_HEAD", ".", "COARSE_SEGM_TRAINED_BY_MASKS", "\n", "self", ".", "confidence_model_cfg", "=", "DensePoseConfidenceModelConfig", ".", "from_cfg", "(", "cfg", ")", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "            ", "self", ".", "uv_loss_with_confidences", "=", "IIDIsotropicGaussianUVLoss", "(", "\n", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "epsilon", "\n", ")", "\n", "", "elif", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", ":", "\n", "            ", "self", ".", "uv_loss_with_confidences", "=", "IndepAnisotropicGaussianUVLoss", "(", "\n", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "epsilon", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.__call__": [[543, 559], ["densepose_losses.DensePoseLosses.produce_densepose_losses", "densepose_losses.DensePoseLosses.produce_densepose_losses", "losses.update", "densepose_losses.DensePoseLosses.produce_mask_losses", "losses.update"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_densepose_losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_densepose_losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_mask_losses"], ["", "", "def", "__call__", "(", "self", ",", "proposals_with_gt", ",", "densepose_outputs", ",", "densepose_confidences", ")", ":", "\n", "        ", "if", "not", "self", ".", "segm_trained_by_masks", ":", "\n", "            ", "return", "self", ".", "produce_densepose_losses", "(", "\n", "proposals_with_gt", ",", "densepose_outputs", ",", "densepose_confidences", "\n", ")", "\n", "", "else", ":", "\n", "            ", "losses", "=", "{", "}", "\n", "losses_densepose", "=", "self", ".", "produce_densepose_losses", "(", "\n", "proposals_with_gt", ",", "densepose_outputs", ",", "densepose_confidences", "\n", ")", "\n", "losses", ".", "update", "(", "losses_densepose", ")", "\n", "losses_mask", "=", "self", ".", "produce_mask_losses", "(", "\n", "proposals_with_gt", ",", "densepose_outputs", ",", "densepose_confidences", "\n", ")", "\n", "losses", ".", "update", "(", "losses_mask", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_fake_mask_losses": [[560, 565], ["segm_scores.sum"], "methods", ["None"], ["", "", "def", "produce_fake_mask_losses", "(", "self", ",", "densepose_outputs", ")", ":", "\n", "        ", "losses", "=", "{", "}", "\n", "segm_scores", ",", "_", ",", "_", ",", "_", "=", "densepose_outputs", "\n", "losses", "[", "\"loss_densepose_S\"", "]", "=", "segm_scores", ".", "sum", "(", ")", "*", "0", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_mask_losses": [[566, 584], ["len", "densepose_losses.DensePoseLosses.produce_fake_mask_losses", "torch.no_grad", "densepose_losses._extract_data_for_mask_loss_from_matches", "densepose_losses.DensePoseLosses.produce_fake_mask_losses", "torch.nn.functional.cross_entropy", "_extract_data_for_mask_loss_from_matches.masks_gt.long"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_fake_mask_losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._extract_data_for_mask_loss_from_matches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_fake_mask_losses"], ["", "def", "produce_mask_losses", "(", "self", ",", "proposals_with_gt", ",", "densepose_outputs", ",", "densepose_confidences", ")", ":", "\n", "        ", "if", "not", "len", "(", "proposals_with_gt", ")", ":", "\n", "            ", "return", "self", ".", "produce_fake_mask_losses", "(", "densepose_outputs", ")", "\n", "", "losses", "=", "{", "}", "\n", "# densepose outputs are computed for all images and all bounding boxes;", "\n", "# i.e. if a batch has 4 images with (3, 1, 2, 1) proposals respectively,", "\n", "# the outputs will have size(0) == 3+1+2+1 == 7", "\n", "segm_scores", ",", "_", ",", "_", ",", "_", "=", "densepose_outputs", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "mask_loss_data", "=", "_extract_data_for_mask_loss_from_matches", "(", "\n", "proposals_with_gt", ",", "segm_scores", "\n", ")", "\n", "", "if", "(", "mask_loss_data", ".", "masks_gt", "is", "None", ")", "or", "(", "mask_loss_data", ".", "masks_est", "is", "None", ")", ":", "\n", "            ", "return", "self", ".", "produce_fake_mask_losses", "(", "densepose_outputs", ")", "\n", "", "losses", "[", "\"loss_densepose_S\"", "]", "=", "(", "\n", "F", ".", "cross_entropy", "(", "mask_loss_data", ".", "masks_est", ",", "mask_loss_data", ".", "masks_gt", ".", "long", "(", ")", ")", "*", "self", ".", "w_segm", "\n", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_fake_densepose_losses": [[585, 614], ["index_uv.sum", "s.sum", "u.sum", "v.sum", "u.sum", "v.sum", "sigma_2.sum", "kappa_v.sum", "sigma_2.sum", "kappa_u.sum"], "methods", ["None"], ["", "def", "produce_fake_densepose_losses", "(", "self", ",", "densepose_outputs", ",", "densepose_confidences", ")", ":", "\n", "# we need to keep the same computation graph on all the GPUs to", "\n", "# perform reduction properly. Hence even if we have no data on one", "\n", "# of the GPUs, we still need to generate the computation graph.", "\n", "# Add fake (zero) losses in the form Tensor.sum() * 0", "\n", "        ", "s", ",", "index_uv", ",", "u", ",", "v", "=", "densepose_outputs", "\n", "conf_type", "=", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "\n", "(", "\n", "sigma_1", ",", "\n", "sigma_2", ",", "\n", "kappa_u", ",", "\n", "kappa_v", ",", "\n", "fine_segm_confidence", ",", "\n", "coarse_segm_confidence", ",", "\n", ")", "=", "densepose_confidences", "\n", "losses", "=", "{", "}", "\n", "losses", "[", "\"loss_densepose_I\"", "]", "=", "index_uv", ".", "sum", "(", ")", "*", "0", "\n", "if", "not", "self", ".", "segm_trained_by_masks", ":", "\n", "            ", "losses", "[", "\"loss_densepose_S\"", "]", "=", "s", ".", "sum", "(", ")", "*", "0", "\n", "", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "losses", "[", "\"loss_densepose_UV\"", "]", "=", "(", "u", ".", "sum", "(", ")", "+", "v", ".", "sum", "(", ")", ")", "*", "0", "\n", "if", "conf_type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "                ", "losses", "[", "\"loss_densepose_UV\"", "]", "+=", "sigma_2", ".", "sum", "(", ")", "*", "0", "\n", "", "elif", "conf_type", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", ":", "\n", "                ", "losses", "[", "\"loss_densepose_UV\"", "]", "+=", "(", "sigma_2", ".", "sum", "(", ")", "+", "kappa_u", ".", "sum", "(", ")", "+", "kappa_v", ".", "sum", "(", ")", ")", "*", "0", "\n", "", "", "else", ":", "\n", "            ", "losses", "[", "\"loss_densepose_U\"", "]", "=", "u", ".", "sum", "(", ")", "*", "0", "\n", "losses", "[", "\"loss_densepose_V\"", "]", "=", "v", ".", "sum", "(", ")", "*", "0", "\n", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_densepose_losses": [[615, 730], ["u.size", "densepose_losses.SingleTensorsHelper", "len", "densepose_losses.BilinearInterpolationHelper.from_matches", "densepose_losses.BilinearInterpolationHelper.from_matches", "densepose_losses.BilinearInterpolationHelper.from_matches", "densepose_losses.BilinearInterpolationHelper.from_matches", "u.size", "v.size", "u.size", "v.size", "u.size", "index_uv.size", "u.size", "index_uv.size", "len", "densepose_losses.DensePoseLosses.produce_fake_densepose_losses", "densepose_losses.DensePoseLosses.produce_fake_densepose_losses", "densepose_losses.BilinearInterpolationHelper.from_matches", "torch.nn.functional.cross_entropy", "slice", "densepose_losses.BilinearInterpolationHelper.from_matches", "densepose_losses.BilinearInterpolationHelper.from_matches", "torch.no_grad", "_resample_data().squeeze", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss", "index_uv_gt.long", "torch.nn.functional.cross_entropy", "densepose_losses.DensePoseLosses.uv_loss_with_confidences", "ValueError", "_resample_data().squeeze.long", "densepose_losses._resample_data", "densepose_losses.DensePoseLosses.uv_loss_with_confidences", "SingleTensorsHelper.s_gt.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.from_matches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.from_matches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.from_matches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.from_matches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_fake_densepose_losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.DensePoseLosses.produce_fake_densepose_losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.from_matches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.from_matches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses.BilinearInterpolationHelper.from_matches", "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._resample_data"], ["", "def", "produce_densepose_losses", "(", "self", ",", "proposals_with_gt", ",", "densepose_outputs", ",", "densepose_confidences", ")", ":", "\n", "        ", "losses", "=", "{", "}", "\n", "# densepose outputs are computed for all images and all bounding boxes;", "\n", "# i.e. if a batch has 4 images with (3, 1, 2, 1) proposals respectively,", "\n", "# the outputs will have size(0) == 3+1+2+1 == 7", "\n", "s", ",", "index_uv", ",", "u", ",", "v", "=", "densepose_outputs", "\n", "assert", "u", ".", "size", "(", "2", ")", "==", "v", ".", "size", "(", "2", ")", "\n", "assert", "u", ".", "size", "(", "3", ")", "==", "v", ".", "size", "(", "3", ")", "\n", "assert", "u", ".", "size", "(", "2", ")", "==", "index_uv", ".", "size", "(", "2", ")", "\n", "assert", "u", ".", "size", "(", "3", ")", "==", "index_uv", ".", "size", "(", "3", ")", "\n", "densepose_outputs_size", "=", "u", ".", "size", "(", ")", "\n", "\n", "if", "not", "len", "(", "proposals_with_gt", ")", ":", "\n", "            ", "return", "self", ".", "produce_fake_densepose_losses", "(", "densepose_outputs", ",", "densepose_confidences", ")", "\n", "", "(", "\n", "sigma_1", ",", "\n", "sigma_2", ",", "\n", "kappa_u", ",", "\n", "kappa_v", ",", "\n", "fine_segm_confidence", ",", "\n", "coarse_segm_confidence", ",", "\n", ")", "=", "densepose_confidences", "\n", "conf_type", "=", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "type", "\n", "\n", "tensors_helper", "=", "SingleTensorsHelper", "(", "proposals_with_gt", ")", "\n", "n_batch", "=", "len", "(", "tensors_helper", ".", "i_with_dp", ")", "\n", "\n", "# NOTE: we need to keep the same computation graph on all the GPUs to", "\n", "# perform reduction properly. Hence even if we have no data on one", "\n", "# of the GPUs, we still need to generate the computation graph.", "\n", "# Add fake (zero) loss in the form Tensor.sum() * 0", "\n", "if", "not", "n_batch", ":", "\n", "            ", "return", "self", ".", "produce_fake_densepose_losses", "(", "densepose_outputs", ",", "densepose_confidences", ")", "\n", "\n", "", "interpolator", "=", "BilinearInterpolationHelper", ".", "from_matches", "(", "\n", "tensors_helper", ",", "densepose_outputs_size", "\n", ")", "\n", "\n", "j_valid_fg", "=", "interpolator", ".", "j_valid", "*", "(", "tensors_helper", ".", "index_gt_all", ">", "0", ")", "\n", "\n", "u_gt", "=", "tensors_helper", ".", "u_gt_all", "[", "j_valid_fg", "]", "\n", "u_est_all", "=", "interpolator", ".", "extract_at_points", "(", "u", "[", "tensors_helper", ".", "i_with_dp", "]", ")", "\n", "u_est", "=", "u_est_all", "[", "j_valid_fg", "]", "\n", "\n", "v_gt", "=", "tensors_helper", ".", "v_gt_all", "[", "j_valid_fg", "]", "\n", "v_est_all", "=", "interpolator", ".", "extract_at_points", "(", "v", "[", "tensors_helper", ".", "i_with_dp", "]", ")", "\n", "v_est", "=", "v_est_all", "[", "j_valid_fg", "]", "\n", "\n", "index_uv_gt", "=", "tensors_helper", ".", "index_gt_all", "[", "interpolator", ".", "j_valid", "]", "\n", "index_uv_est_all", "=", "interpolator", ".", "extract_at_points", "(", "\n", "index_uv", "[", "tensors_helper", ".", "i_with_dp", "]", ",", "\n", "slice_index_uv", "=", "slice", "(", "None", ")", ",", "\n", "w_ylo_xlo", "=", "interpolator", ".", "w_ylo_xlo", "[", ":", ",", "None", "]", ",", "\n", "w_ylo_xhi", "=", "interpolator", ".", "w_ylo_xhi", "[", ":", ",", "None", "]", ",", "\n", "w_yhi_xlo", "=", "interpolator", ".", "w_yhi_xlo", "[", ":", ",", "None", "]", ",", "\n", "w_yhi_xhi", "=", "interpolator", ".", "w_yhi_xhi", "[", ":", ",", "None", "]", ",", "\n", ")", "\n", "index_uv_est", "=", "index_uv_est_all", "[", "interpolator", ".", "j_valid", ",", ":", "]", "\n", "\n", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "sigma_2_est_all", "=", "interpolator", ".", "extract_at_points", "(", "sigma_2", "[", "tensors_helper", ".", "i_with_dp", "]", ")", "\n", "sigma_2_est", "=", "sigma_2_est_all", "[", "j_valid_fg", "]", "\n", "if", "conf_type", "in", "[", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", "]", ":", "\n", "                ", "kappa_u_est_all", "=", "interpolator", ".", "extract_at_points", "(", "kappa_u", "[", "tensors_helper", ".", "i_with_dp", "]", ")", "\n", "kappa_u_est", "=", "kappa_u_est_all", "[", "j_valid_fg", "]", "\n", "kappa_v_est_all", "=", "interpolator", ".", "extract_at_points", "(", "kappa_v", "[", "tensors_helper", ".", "i_with_dp", "]", ")", "\n", "kappa_v_est", "=", "kappa_v_est_all", "[", "j_valid_fg", "]", "\n", "\n", "# Resample everything to the estimated data size, no need to resample", "\n", "# S_est then:", "\n", "", "", "if", "not", "self", ".", "segm_trained_by_masks", ":", "\n", "            ", "s_est", "=", "s", "[", "tensors_helper", ".", "i_with_dp", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "s_gt", "=", "_resample_data", "(", "\n", "tensors_helper", ".", "s_gt", ".", "unsqueeze", "(", "1", ")", ",", "\n", "tensors_helper", ".", "bbox_xywh_gt", ",", "\n", "tensors_helper", ".", "bbox_xywh_est", ",", "\n", "self", ".", "heatmap_size", ",", "\n", "self", ".", "heatmap_size", ",", "\n", "mode", "=", "\"nearest\"", ",", "\n", "padding_mode", "=", "\"zeros\"", ",", "\n", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "# add point-based losses:", "\n", "", "", "if", "self", ".", "confidence_model_cfg", ".", "uv_confidence", ".", "enabled", ":", "\n", "            ", "if", "conf_type", "==", "DensePoseUVConfidenceType", ".", "IID_ISO", ":", "\n", "                ", "uv_loss", "=", "(", "\n", "self", ".", "uv_loss_with_confidences", "(", "u_est", ",", "v_est", ",", "sigma_2_est", ",", "u_gt", ",", "v_gt", ")", "\n", "*", "self", ".", "w_points", "\n", ")", "\n", "losses", "[", "\"loss_densepose_UV\"", "]", "=", "uv_loss", "\n", "", "elif", "conf_type", "==", "DensePoseUVConfidenceType", ".", "INDEP_ANISO", ":", "\n", "                ", "uv_loss", "=", "(", "\n", "self", ".", "uv_loss_with_confidences", "(", "\n", "u_est", ",", "v_est", ",", "sigma_2_est", ",", "kappa_u_est", ",", "kappa_v_est", ",", "u_gt", ",", "v_gt", "\n", ")", "\n", "*", "self", ".", "w_points", "\n", ")", "\n", "losses", "[", "\"loss_densepose_UV\"", "]", "=", "uv_loss", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Unknown confidence model type: {conf_type}\"", ")", "\n", "", "", "else", ":", "\n", "            ", "u_loss", "=", "F", ".", "smooth_l1_loss", "(", "u_est", ",", "u_gt", ",", "reduction", "=", "\"sum\"", ")", "*", "self", ".", "w_points", "\n", "losses", "[", "\"loss_densepose_U\"", "]", "=", "u_loss", "\n", "v_loss", "=", "F", ".", "smooth_l1_loss", "(", "v_est", ",", "v_gt", ",", "reduction", "=", "\"sum\"", ")", "*", "self", ".", "w_points", "\n", "losses", "[", "\"loss_densepose_V\"", "]", "=", "v_loss", "\n", "", "index_uv_loss", "=", "F", ".", "cross_entropy", "(", "index_uv_est", ",", "index_uv_gt", ".", "long", "(", ")", ")", "*", "self", ".", "w_part", "\n", "losses", "[", "\"loss_densepose_I\"", "]", "=", "index_uv_loss", "\n", "\n", "if", "not", "self", ".", "segm_trained_by_masks", ":", "\n", "            ", "if", "self", ".", "n_segm_chan", "==", "2", ":", "\n", "                ", "s_gt", "=", "s_gt", ">", "0", "\n", "", "s_loss", "=", "F", ".", "cross_entropy", "(", "s_est", ",", "s_gt", ".", "long", "(", ")", ")", "*", "self", ".", "w_segm", "\n", "losses", "[", "\"loss_densepose_S\"", "]", "=", "s_loss", "\n", "", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._linear_interpolation_utilities": [[14, 58], ["torch.min.floor().long().clamp", "torch.min", "v_hi.float", "v_grid.floor().long().clamp.float", "torch.min.floor().long", "torch.min.floor"], "function", ["None"], ["def", "_linear_interpolation_utilities", "(", "v_norm", ",", "v0_src", ",", "size_src", ",", "v0_dst", ",", "size_dst", ",", "size_z", ")", ":", "\n", "    ", "\"\"\"\n    Computes utility values for linear interpolation at points v.\n    The points are given as normalized offsets in the source interval\n    (v0_src, v0_src + size_src), more precisely:\n        v = v0_src + v_norm * size_src / 256.0\n    The computed utilities include lower points v_lo, upper points v_hi,\n    interpolation weights v_w and flags j_valid indicating whether the\n    points falls into the destination interval (v0_dst, v0_dst + size_dst).\n\n    Args:\n        v_norm (:obj: `torch.Tensor`): tensor of size N containing\n            normalized point offsets\n        v0_src (:obj: `torch.Tensor`): tensor of size N containing\n            left bounds of source intervals for normalized points\n        size_src (:obj: `torch.Tensor`): tensor of size N containing\n            source interval sizes for normalized points\n        v0_dst (:obj: `torch.Tensor`): tensor of size N containing\n            left bounds of destination intervals\n        size_dst (:obj: `torch.Tensor`): tensor of size N containing\n            destination interval sizes\n        size_z (int): interval size for data to be interpolated\n\n    Returns:\n        v_lo (:obj: `torch.Tensor`): int tensor of size N containing\n            indices of lower values used for interpolation, all values are\n            integers from [0, size_z - 1]\n        v_hi (:obj: `torch.Tensor`): int tensor of size N containing\n            indices of upper values used for interpolation, all values are\n            integers from [0, size_z - 1]\n        v_w (:obj: `torch.Tensor`): float tensor of size N containing\n            interpolation weights\n        j_valid (:obj: `torch.Tensor`): uint8 tensor of size N containing\n            0 for points outside the estimation interval\n            (v0_est, v0_est + size_est) and 1 otherwise\n    \"\"\"", "\n", "v", "=", "v0_src", "+", "v_norm", "*", "size_src", "/", "256.0", "\n", "j_valid", "=", "(", "v", "-", "v0_dst", ">=", "0", ")", "*", "(", "v", "-", "v0_dst", "<", "size_dst", ")", "\n", "v_grid", "=", "(", "v", "-", "v0_dst", ")", "*", "size_z", "/", "size_dst", "\n", "v_lo", "=", "v_grid", ".", "floor", "(", ")", ".", "long", "(", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "size_z", "-", "1", ")", "\n", "v_hi", "=", "(", "v_lo", "+", "1", ")", ".", "clamp", "(", "max", "=", "size_z", "-", "1", ")", "\n", "v_grid", "=", "torch", ".", "min", "(", "v_hi", ".", "float", "(", ")", ",", "v_grid", ")", "\n", "v_w", "=", "v_grid", "-", "v_lo", ".", "float", "(", ")", "\n", "return", "v_lo", ",", "v_hi", ",", "v_w", ",", "j_valid", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._resample_data": [[193, 234], ["bbox_xywh_src.size", "bbox_xywh_src.unbind", "bbox_xywh_dst.unbind", "grid_w[].expand", "grid_h[].expand", "[].expand", "[].expand", "x0dst_norm[].expand", "y0dst_norm[].expand", "torch.stack", "torch.nn.functional.grid_sample", "bbox_xywh_dst.size", "bbox_xywh_src.size", "bbox_xywh_dst.size", "torch.arange", "torch.arange"], "function", ["None"], ["", "", "def", "_resample_data", "(", "\n", "z", ",", "bbox_xywh_src", ",", "bbox_xywh_dst", ",", "wout", ",", "hout", ",", "mode", "=", "\"nearest\"", ",", "padding_mode", "=", "\"zeros\"", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        z (:obj: `torch.Tensor`): tensor of size (N,C,H,W) with data to be\n            resampled\n        bbox_xywh_src (:obj: `torch.Tensor`): tensor of size (N,4) containing\n            source bounding boxes in format XYWH\n        bbox_xywh_dst (:obj: `torch.Tensor`): tensor of size (N,4) containing\n            destination bounding boxes in format XYWH\n    Return:\n        zresampled (:obj: `torch.Tensor`): tensor of size (N, C, Hout, Wout)\n            with resampled values of z, where D is the discretization size\n    \"\"\"", "\n", "n", "=", "bbox_xywh_src", ".", "size", "(", "0", ")", "\n", "assert", "n", "==", "bbox_xywh_dst", ".", "size", "(", "0", ")", ",", "(", "\n", "\"The number of \"", "\n", "\"source ROIs for resampling ({}) should be equal to the number \"", "\n", "\"of destination ROIs ({})\"", ".", "format", "(", "bbox_xywh_src", ".", "size", "(", "0", ")", ",", "bbox_xywh_dst", ".", "size", "(", "0", ")", ")", "\n", ")", "\n", "x0src", ",", "y0src", ",", "wsrc", ",", "hsrc", "=", "bbox_xywh_src", ".", "unbind", "(", "dim", "=", "1", ")", "\n", "x0dst", ",", "y0dst", ",", "wdst", ",", "hdst", "=", "bbox_xywh_dst", ".", "unbind", "(", "dim", "=", "1", ")", "\n", "x0dst_norm", "=", "2", "*", "(", "x0dst", "-", "x0src", ")", "/", "wsrc", "-", "1", "\n", "y0dst_norm", "=", "2", "*", "(", "y0dst", "-", "y0src", ")", "/", "hsrc", "-", "1", "\n", "x1dst_norm", "=", "2", "*", "(", "x0dst", "+", "wdst", "-", "x0src", ")", "/", "wsrc", "-", "1", "\n", "y1dst_norm", "=", "2", "*", "(", "y0dst", "+", "hdst", "-", "y0src", ")", "/", "hsrc", "-", "1", "\n", "grid_w", "=", "torch", ".", "arange", "(", "wout", ",", "device", "=", "z", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "/", "wout", "\n", "grid_h", "=", "torch", ".", "arange", "(", "hout", ",", "device", "=", "z", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "/", "hout", "\n", "grid_w_expanded", "=", "grid_w", "[", "None", ",", "None", ",", ":", "]", ".", "expand", "(", "n", ",", "hout", ",", "wout", ")", "\n", "grid_h_expanded", "=", "grid_h", "[", "None", ",", ":", ",", "None", "]", ".", "expand", "(", "n", ",", "hout", ",", "wout", ")", "\n", "dx_expanded", "=", "(", "x1dst_norm", "-", "x0dst_norm", ")", "[", ":", ",", "None", ",", "None", "]", ".", "expand", "(", "n", ",", "hout", ",", "wout", ")", "\n", "dy_expanded", "=", "(", "y1dst_norm", "-", "y0dst_norm", ")", "[", ":", ",", "None", ",", "None", "]", ".", "expand", "(", "n", ",", "hout", ",", "wout", ")", "\n", "x0_expanded", "=", "x0dst_norm", "[", ":", ",", "None", ",", "None", "]", ".", "expand", "(", "n", ",", "hout", ",", "wout", ")", "\n", "y0_expanded", "=", "y0dst_norm", "[", ":", ",", "None", ",", "None", "]", ".", "expand", "(", "n", ",", "hout", ",", "wout", ")", "\n", "grid_x", "=", "grid_w_expanded", "*", "dx_expanded", "+", "x0_expanded", "\n", "grid_y", "=", "grid_h_expanded", "*", "dy_expanded", "+", "y0_expanded", "\n", "grid", "=", "torch", ".", "stack", "(", "(", "grid_x", ",", "grid_y", ")", ",", "dim", "=", "3", ")", "\n", "# resample Z from (N, C, H, W) into (N, C, Hout, Wout)", "\n", "zresampled", "=", "F", ".", "grid_sample", "(", "z", ",", "grid", ",", "mode", "=", "mode", ",", "padding_mode", "=", "padding_mode", ",", "align_corners", "=", "True", ")", "\n", "return", "zresampled", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._extract_single_tensors_from_matches_one_image": [[236, 293], ["proposals_targets.proposal_boxes.clone", "proposals_targets.gt_boxes.clone", "len", "len", "hasattr", "zip", "range", "i_gt_all.append", "x_norm_all.append", "y_norm_all.append", "u_gt_all.append", "v_gt_all.append", "s_gt_all.append", "bbox_xywh_gt_all.append", "bbox_xywh_est_all.append", "torch.full_like", "i_bbox_all.append", "i_with_dp.append", "len", "dp_gt.segm.unsqueeze", "box_xywh_gt.view", "box_xywh_est.view", "len"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "def", "_extract_single_tensors_from_matches_one_image", "(", "\n", "proposals_targets", ",", "bbox_with_dp_offset", ",", "bbox_global_offset", "\n", ")", ":", "\n", "    ", "i_gt_all", "=", "[", "]", "\n", "x_norm_all", "=", "[", "]", "\n", "y_norm_all", "=", "[", "]", "\n", "u_gt_all", "=", "[", "]", "\n", "v_gt_all", "=", "[", "]", "\n", "s_gt_all", "=", "[", "]", "\n", "bbox_xywh_gt_all", "=", "[", "]", "\n", "bbox_xywh_est_all", "=", "[", "]", "\n", "# Ibbox_all == k should be true for all data that corresponds", "\n", "# to bbox_xywh_gt[k] and bbox_xywh_est[k]", "\n", "# index k here is global wrt images", "\n", "i_bbox_all", "=", "[", "]", "\n", "# at offset k (k is global) contains index of bounding box data", "\n", "# within densepose output tensor", "\n", "i_with_dp", "=", "[", "]", "\n", "\n", "boxes_xywh_est", "=", "proposals_targets", ".", "proposal_boxes", ".", "clone", "(", ")", "\n", "boxes_xywh_gt", "=", "proposals_targets", ".", "gt_boxes", ".", "clone", "(", ")", "\n", "n_i", "=", "len", "(", "boxes_xywh_est", ")", "\n", "assert", "n_i", "==", "len", "(", "boxes_xywh_gt", ")", "\n", "\n", "if", "n_i", ":", "\n", "        ", "boxes_xywh_est", ".", "tensor", "[", ":", ",", "2", "]", "-=", "boxes_xywh_est", ".", "tensor", "[", ":", ",", "0", "]", "\n", "boxes_xywh_est", ".", "tensor", "[", ":", ",", "3", "]", "-=", "boxes_xywh_est", ".", "tensor", "[", ":", ",", "1", "]", "\n", "boxes_xywh_gt", ".", "tensor", "[", ":", ",", "2", "]", "-=", "boxes_xywh_gt", ".", "tensor", "[", ":", ",", "0", "]", "\n", "boxes_xywh_gt", ".", "tensor", "[", ":", ",", "3", "]", "-=", "boxes_xywh_gt", ".", "tensor", "[", ":", ",", "1", "]", "\n", "if", "hasattr", "(", "proposals_targets", ",", "\"gt_densepose\"", ")", ":", "\n", "            ", "densepose_gt", "=", "proposals_targets", ".", "gt_densepose", "\n", "for", "k", ",", "box_xywh_est", ",", "box_xywh_gt", ",", "dp_gt", "in", "zip", "(", "\n", "range", "(", "n_i", ")", ",", "boxes_xywh_est", ".", "tensor", ",", "boxes_xywh_gt", ".", "tensor", ",", "densepose_gt", "\n", ")", ":", "\n", "                ", "if", "(", "dp_gt", "is", "not", "None", ")", "and", "(", "len", "(", "dp_gt", ".", "x", ")", ">", "0", ")", ":", "\n", "                    ", "i_gt_all", ".", "append", "(", "dp_gt", ".", "i", ")", "\n", "x_norm_all", ".", "append", "(", "dp_gt", ".", "x", ")", "\n", "y_norm_all", ".", "append", "(", "dp_gt", ".", "y", ")", "\n", "u_gt_all", ".", "append", "(", "dp_gt", ".", "u", ")", "\n", "v_gt_all", ".", "append", "(", "dp_gt", ".", "v", ")", "\n", "s_gt_all", ".", "append", "(", "dp_gt", ".", "segm", ".", "unsqueeze", "(", "0", ")", ")", "\n", "bbox_xywh_gt_all", ".", "append", "(", "box_xywh_gt", ".", "view", "(", "-", "1", ",", "4", ")", ")", "\n", "bbox_xywh_est_all", ".", "append", "(", "box_xywh_est", ".", "view", "(", "-", "1", ",", "4", ")", ")", "\n", "i_bbox_k", "=", "torch", ".", "full_like", "(", "dp_gt", ".", "i", ",", "bbox_with_dp_offset", "+", "len", "(", "i_with_dp", ")", ")", "\n", "i_bbox_all", ".", "append", "(", "i_bbox_k", ")", "\n", "i_with_dp", ".", "append", "(", "bbox_global_offset", "+", "k", ")", "\n", "", "", "", "", "return", "(", "\n", "i_gt_all", ",", "\n", "x_norm_all", ",", "\n", "y_norm_all", ",", "\n", "u_gt_all", ",", "\n", "v_gt_all", ",", "\n", "s_gt_all", ",", "\n", "bbox_xywh_gt_all", ",", "\n", "bbox_xywh_est_all", ",", "\n", "i_bbox_all", ",", "\n", "i_with_dp", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._extract_single_tensors_from_matches": [[296, 372], ["enumerate", "proposals_targets_per_image.proposal_boxes.tensor.size", "densepose_losses._extract_single_tensors_from_matches_one_image", "i_gt_all.extend", "x_norm_all.extend", "y_norm_all.extend", "u_gt_all.extend", "v_gt_all.extend", "s_gt_all.extend", "bbox_xywh_gt_all.extend", "bbox_xywh_est_all.extend", "i_bbox_all.extend", "i_with_dp_all.extend", "i_img.extend", "torch.cat().long", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat().long", "len", "len", "len", "torch.cat", "torch.cat"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._extract_single_tensors_from_matches_one_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "_extract_single_tensors_from_matches", "(", "proposals_with_targets", ")", ":", "\n", "    ", "i_img", "=", "[", "]", "\n", "i_gt_all", "=", "[", "]", "\n", "x_norm_all", "=", "[", "]", "\n", "y_norm_all", "=", "[", "]", "\n", "u_gt_all", "=", "[", "]", "\n", "v_gt_all", "=", "[", "]", "\n", "s_gt_all", "=", "[", "]", "\n", "bbox_xywh_gt_all", "=", "[", "]", "\n", "bbox_xywh_est_all", "=", "[", "]", "\n", "i_bbox_all", "=", "[", "]", "\n", "i_with_dp_all", "=", "[", "]", "\n", "n", "=", "0", "\n", "for", "i", ",", "proposals_targets_per_image", "in", "enumerate", "(", "proposals_with_targets", ")", ":", "\n", "        ", "n_i", "=", "proposals_targets_per_image", ".", "proposal_boxes", ".", "tensor", ".", "size", "(", "0", ")", "\n", "if", "not", "n_i", ":", "\n", "            ", "continue", "\n", "", "(", "\n", "i_gt_img", ",", "\n", "x_norm_img", ",", "\n", "y_norm_img", ",", "\n", "u_gt_img", ",", "\n", "v_gt_img", ",", "\n", "s_gt_img", ",", "\n", "bbox_xywh_gt_img", ",", "\n", "bbox_xywh_est_img", ",", "\n", "i_bbox_img", ",", "\n", "i_with_dp_img", ",", "\n", ")", "=", "_extract_single_tensors_from_matches_one_image", "(", "# noqa", "\n", "proposals_targets_per_image", ",", "len", "(", "i_with_dp_all", ")", ",", "n", "\n", ")", "\n", "i_gt_all", ".", "extend", "(", "i_gt_img", ")", "\n", "x_norm_all", ".", "extend", "(", "x_norm_img", ")", "\n", "y_norm_all", ".", "extend", "(", "y_norm_img", ")", "\n", "u_gt_all", ".", "extend", "(", "u_gt_img", ")", "\n", "v_gt_all", ".", "extend", "(", "v_gt_img", ")", "\n", "s_gt_all", ".", "extend", "(", "s_gt_img", ")", "\n", "bbox_xywh_gt_all", ".", "extend", "(", "bbox_xywh_gt_img", ")", "\n", "bbox_xywh_est_all", ".", "extend", "(", "bbox_xywh_est_img", ")", "\n", "i_bbox_all", ".", "extend", "(", "i_bbox_img", ")", "\n", "i_with_dp_all", ".", "extend", "(", "i_with_dp_img", ")", "\n", "i_img", ".", "extend", "(", "[", "i", "]", "*", "len", "(", "i_with_dp_img", ")", ")", "\n", "n", "+=", "n_i", "\n", "# concatenate all data into a single tensor", "\n", "", "if", "(", "n", ">", "0", ")", "and", "(", "len", "(", "i_with_dp_all", ")", ">", "0", ")", ":", "\n", "        ", "i_gt", "=", "torch", ".", "cat", "(", "i_gt_all", ",", "0", ")", ".", "long", "(", ")", "\n", "x_norm", "=", "torch", ".", "cat", "(", "x_norm_all", ",", "0", ")", "\n", "y_norm", "=", "torch", ".", "cat", "(", "y_norm_all", ",", "0", ")", "\n", "u_gt", "=", "torch", ".", "cat", "(", "u_gt_all", ",", "0", ")", "\n", "v_gt", "=", "torch", ".", "cat", "(", "v_gt_all", ",", "0", ")", "\n", "s_gt", "=", "torch", ".", "cat", "(", "s_gt_all", ",", "0", ")", "\n", "bbox_xywh_gt", "=", "torch", ".", "cat", "(", "bbox_xywh_gt_all", ",", "0", ")", "\n", "bbox_xywh_est", "=", "torch", ".", "cat", "(", "bbox_xywh_est_all", ",", "0", ")", "\n", "i_bbox", "=", "torch", ".", "cat", "(", "i_bbox_all", ",", "0", ")", ".", "long", "(", ")", "\n", "", "else", ":", "\n", "        ", "i_gt", "=", "None", "\n", "x_norm", "=", "None", "\n", "y_norm", "=", "None", "\n", "u_gt", "=", "None", "\n", "v_gt", "=", "None", "\n", "s_gt", "=", "None", "\n", "bbox_xywh_gt", "=", "None", "\n", "bbox_xywh_est", "=", "None", "\n", "i_bbox", "=", "None", "\n", "", "return", "(", "\n", "i_img", ",", "\n", "i_with_dp_all", ",", "\n", "bbox_xywh_est", ",", "\n", "bbox_xywh_gt", ",", "\n", "i_gt", ",", "\n", "x_norm", ",", "\n", "y_norm", ",", "\n", "u_gt", ",", "\n", "v_gt", ",", "\n", "s_gt", ",", "\n", "i_bbox", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.losses.densepose_losses._extract_data_for_mask_loss_from_matches": [[387, 432], ["densepose_losses.DataForMaskLoss", "sum", "proposals_targets_per_image.proposal_boxes.tensor.size", "proposals_targets_per_image.gt_masks.crop_and_resize().to", "masks_gt.append", "torch.cat", "inst.proposal_boxes.tensor.size", "proposals_targets_per_image.gt_masks.crop_and_resize"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.masks.PolygonMasks.crop_and_resize"], ["", "def", "_extract_data_for_mask_loss_from_matches", "(", "\n", "proposals_targets", ":", "Iterable", "[", "Instances", "]", ",", "estimated_segm", ":", "torch", ".", "Tensor", "\n", ")", "->", "DataForMaskLoss", ":", "\n", "    ", "\"\"\"\n    Extract data for mask loss from instances that contain matched GT and\n    estimated bounding boxes.\n    Args:\n        proposals_targets: Iterable[Instances]\n            matched GT and estimated results, each item in the iterable\n            corresponds to data in 1 image\n        estimated_segm: torch.Tensor if size\n            size to which GT masks are resized\n    Return:\n        masks_est: tensor(K, C, H, W) of float - class scores\n        masks_gt: tensor(K, H, W) of int64 - labels\n    \"\"\"", "\n", "data", "=", "DataForMaskLoss", "(", ")", "\n", "masks_gt", "=", "[", "]", "\n", "offset", "=", "0", "\n", "assert", "estimated_segm", ".", "shape", "[", "2", "]", "==", "estimated_segm", ".", "shape", "[", "3", "]", ",", "(", "\n", "f\"Expected estimated segmentation to have a square shape, \"", "\n", "f\"but the actual shape is {estimated_segm.shape[2:]}\"", "\n", ")", "\n", "mask_size", "=", "estimated_segm", ".", "shape", "[", "2", "]", "\n", "num_proposals", "=", "sum", "(", "inst", ".", "proposal_boxes", ".", "tensor", ".", "size", "(", "0", ")", "for", "inst", "in", "proposals_targets", ")", "\n", "num_estimated", "=", "estimated_segm", ".", "shape", "[", "0", "]", "\n", "assert", "(", "\n", "num_proposals", "==", "num_estimated", "\n", ")", ",", "\"The number of proposals {} must be equal to the number of estimates {}\"", ".", "format", "(", "\n", "num_proposals", ",", "num_estimated", "\n", ")", "\n", "\n", "for", "proposals_targets_per_image", "in", "proposals_targets", ":", "\n", "        ", "n_i", "=", "proposals_targets_per_image", ".", "proposal_boxes", ".", "tensor", ".", "size", "(", "0", ")", "\n", "if", "not", "n_i", ":", "\n", "            ", "continue", "\n", "", "gt_masks_per_image", "=", "proposals_targets_per_image", ".", "gt_masks", ".", "crop_and_resize", "(", "\n", "proposals_targets_per_image", ".", "proposal_boxes", ".", "tensor", ",", "mask_size", "\n", ")", ".", "to", "(", "device", "=", "estimated_segm", ".", "device", ")", "\n", "masks_gt", ".", "append", "(", "gt_masks_per_image", ")", "\n", "offset", "+=", "n_i", "\n", "", "if", "masks_gt", ":", "\n", "        ", "data", ".", "masks_est", "=", "estimated_segm", "\n", "data", ".", "masks_gt", "=", "torch", ".", "cat", "(", "masks_gt", ",", "dim", "=", "0", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.frame_selector.RandomKFramesSelector.__init__": [[35, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "k", ":", "int", ")", ":", "\n", "        ", "self", ".", "k", "=", "k", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.frame_selector.RandomKFramesSelector.__call__": [[38, 48], ["random.sample", "min", "len"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "frame_tss", ":", "FrameTsList", ")", "->", "FrameTsList", ":", "\n", "        ", "\"\"\"\n        Select `k` random frames\n\n        Args:\n          frames_tss (List[int]): timestamps of input frames\n        Returns:\n          List[int]: timestamps of selected frames\n        \"\"\"", "\n", "return", "random", ".", "sample", "(", "frame_tss", ",", "min", "(", "self", ".", "k", ",", "len", "(", "frame_tss", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.frame_selector.FirstKFramesSelector.__init__": [[55, 57], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "k", ":", "int", ")", ":", "\n", "        ", "self", ".", "k", "=", "k", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.frame_selector.FirstKFramesSelector.__call__": [[58, 68], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "frame_tss", ":", "FrameTsList", ")", "->", "FrameTsList", ":", "\n", "        ", "\"\"\"\n        Select `k` first frames\n\n        Args:\n          frames_tss (List[int]): timestamps of input frames\n        Returns:\n          List[int]: timestamps of selected frames\n        \"\"\"", "\n", "return", "frame_tss", "[", ":", "self", ".", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.frame_selector.LastKFramesSelector.__init__": [[75, 77], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "k", ":", "int", ")", ":", "\n", "        ", "self", ".", "k", "=", "k", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.frame_selector.LastKFramesSelector.__call__": [[78, 88], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "frame_tss", ":", "FrameTsList", ")", "->", "FrameTsList", ":", "\n", "        ", "\"\"\"\n        Select `k` last frames\n\n        Args:\n          frames_tss (List[int]): timestamps of input frames\n        Returns:\n          List[int]: timestamps of selected frames\n        \"\"\"", "\n", "return", "frame_tss", "[", "-", "self", ".", "k", ":", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.video_keyframe_dataset.VideoKeyframeDataset.__init__": [[181, 205], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "video_list", ":", "List", "[", "str", "]", ",", "\n", "frame_selector", ":", "Optional", "[", "FrameSelector", "]", "=", "None", ",", "\n", "transform", ":", "Optional", "[", "FrameTransform", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Dataset constructor\n\n        Args:\n            video_list (List[str]): list of paths to video files\n            frame_selector (Callable: KeyFrameList -> KeyFrameList):\n                selects keyframes to process, keyframes are given by\n                packet timestamps in timebase counts. If None, all keyframes\n                are selected (default: None)\n            transform (Callable: torch.Tensor -> torch.Tensor):\n                transforms a batch of RGB images (tensors of size [B, H, W, 3]),\n                returns a tensor of the same size. If None, no transform is\n                applied (default: None)\n\n        \"\"\"", "\n", "self", ".", "video_list", "=", "video_list", "\n", "self", ".", "frame_selector", "=", "frame_selector", "\n", "self", ".", "transform", "=", "transform", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.video_keyframe_dataset.VideoKeyframeDataset.__getitem__": [[206, 230], ["video_keyframe_dataset.list_keyframes", "video_keyframe_dataset.read_keyframes", "numpy.stack", "torch.as_tensor", "video_keyframe_dataset.VideoKeyframeDataset.frame_selector", "video_keyframe_dataset.VideoKeyframeDataset.transform", "frame.to_rgb().to_ndarray", "torch.device", "frame.to_rgb"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.video.video_keyframe_dataset.list_keyframes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.video_keyframe_dataset.read_keyframes", "home.repos.pwc.inspect_result.JosephKJ_OWOD.transforms.augmentation.AugInput.transform", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tensormask.arch.TensorMask.device"], ["", "def", "__getitem__", "(", "self", ",", "idx", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Gets selected keyframes from a given video\n\n        Args:\n            idx (int): video index in the video list file\n        Returns:\n            frames (torch.Tensor): tensor of size [N, H, W, 3] or of size\n                defined by the transform that contains keyframes data\n        \"\"\"", "\n", "fpath", "=", "self", ".", "video_list", "[", "idx", "]", "\n", "keyframes", "=", "list_keyframes", "(", "fpath", ")", "\n", "if", "not", "keyframes", ":", "\n", "            ", "return", "self", ".", "_EMPTY_FRAMES", "\n", "", "if", "self", ".", "frame_selector", "is", "not", "None", ":", "\n", "            ", "keyframes", "=", "self", ".", "frame_selector", "(", "keyframes", ")", "\n", "", "frames", "=", "read_keyframes", "(", "fpath", ",", "keyframes", ")", "\n", "if", "not", "frames", ":", "\n", "            ", "return", "self", ".", "_EMPTY_FRAMES", "\n", "", "frames", "=", "np", ".", "stack", "(", "[", "frame", ".", "to_rgb", "(", ")", ".", "to_ndarray", "(", ")", "for", "frame", "in", "frames", "]", ")", "\n", "frames", "=", "torch", ".", "as_tensor", "(", "frames", ",", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "            ", "frames", "=", "self", ".", "transform", "(", "frames", ")", "\n", "", "return", "frames", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.video_keyframe_dataset.VideoKeyframeDataset.__len__": [[231, 233], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "video_list", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.video_keyframe_dataset.list_keyframes": [[20, 93], ["fvcore.common.file_io.PathManager.open", "av.open", "logging.getLogger", "logging.getLogger.warning", "logging.getLogger", "logging.getLogger.warning", "next", "av.open.seek", "av.open.demux", "logging.getLogger", "logging.getLogger.warning", "keyframes.append", "logging.getLogger", "logging.getLogger.debug", "logging.getLogger", "logging.getLogger.warning"], "function", ["None"], ["def", "list_keyframes", "(", "video_fpath", ":", "str", ",", "video_stream_idx", ":", "int", "=", "0", ")", "->", "FrameTsList", ":", "\n", "    ", "\"\"\"\n    Traverses all keyframes of a video file. Returns a list of keyframe\n    timestamps. Timestamps are counts in timebase units.\n\n    Args:\n       video_fpath (str): Video file path\n       video_stream_idx (int): Video stream index (default: 0)\n    Returns:\n       List[int]: list of keyframe timestaps (timestamp is a count in timebase\n           units)\n    \"\"\"", "\n", "try", ":", "\n", "        ", "with", "PathManager", ".", "open", "(", "video_fpath", ",", "\"rb\"", ")", "as", "io", ":", "\n", "            ", "container", "=", "av", ".", "open", "(", "io", ",", "mode", "=", "\"r\"", ")", "\n", "stream", "=", "container", ".", "streams", ".", "video", "[", "video_stream_idx", "]", "\n", "keyframes", "=", "[", "]", "\n", "pts", "=", "-", "1", "\n", "# Note: even though we request forward seeks for keyframes, sometimes", "\n", "# a keyframe in backwards direction is returned. We introduce tolerance", "\n", "# as a max count of ignored backward seeks", "\n", "tolerance_backward_seeks", "=", "2", "\n", "while", "True", ":", "\n", "                ", "try", ":", "\n", "                    ", "container", ".", "seek", "(", "pts", "+", "1", ",", "backward", "=", "False", ",", "any_frame", "=", "False", ",", "stream", "=", "stream", ")", "\n", "", "except", "av", ".", "AVError", "as", "e", ":", "\n", "# the exception occurs when the video length is exceeded,", "\n", "# we then return whatever data we've already collected", "\n", "                    ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "debug", "(", "\n", "f\"List keyframes: Error seeking video file {video_fpath}, \"", "\n", "f\"video stream {video_stream_idx}, pts {pts + 1}, AV error: {e}\"", "\n", ")", "\n", "return", "keyframes", "\n", "", "except", "OSError", "as", "e", ":", "\n", "                    ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"List keyframes: Error seeking video file {video_fpath}, \"", "\n", "f\"video stream {video_stream_idx}, pts {pts + 1}, OS error: {e}\"", "\n", ")", "\n", "return", "[", "]", "\n", "", "packet", "=", "next", "(", "container", ".", "demux", "(", "video", "=", "video_stream_idx", ")", ")", "\n", "if", "packet", ".", "pts", "is", "not", "None", "and", "packet", ".", "pts", "<=", "pts", ":", "\n", "                    ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"Video file {video_fpath}, stream {video_stream_idx}: \"", "\n", "f\"bad seek for packet {pts + 1} (got packet {packet.pts}), \"", "\n", "f\"tolerance {tolerance_backward_seeks}.\"", "\n", ")", "\n", "tolerance_backward_seeks", "-=", "1", "\n", "if", "tolerance_backward_seeks", "==", "0", ":", "\n", "                        ", "return", "[", "]", "\n", "", "pts", "+=", "1", "\n", "continue", "\n", "", "tolerance_backward_seeks", "=", "2", "\n", "pts", "=", "packet", ".", "pts", "\n", "if", "pts", "is", "None", ":", "\n", "                    ", "return", "keyframes", "\n", "", "if", "packet", ".", "is_keyframe", ":", "\n", "                    ", "keyframes", ".", "append", "(", "pts", ")", "\n", "", "", "return", "keyframes", "\n", "", "", "except", "OSError", "as", "e", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"List keyframes: Error opening video file container {video_fpath}, \"", "f\"OS error: {e}\"", "\n", ")", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"List keyframes: Error opening video file container {video_fpath}, \"", "\n", "f\"Runtime error: {e}\"", "\n", ")", "\n", "", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.video_keyframe_dataset.read_keyframes": [[95, 157], ["fvcore.common.file_io.PathManager.open", "av.open", "av.open.close", "logging.getLogger", "logging.getLogger.warning", "logging.getLogger", "logging.getLogger.warning", "av.open.seek", "next", "frames.append", "av.open.decode", "logging.getLogger", "logging.getLogger.warning", "av.open.close", "logging.getLogger", "logging.getLogger.warning", "av.open.close", "logging.getLogger", "logging.getLogger.warning", "av.open.close"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.TensorboardXWriter.close"], ["", "def", "read_keyframes", "(", "\n", "video_fpath", ":", "str", ",", "keyframes", ":", "FrameTsList", ",", "video_stream_idx", ":", "int", "=", "0", "\n", ")", "->", "FrameList", ":", "\n", "    ", "\"\"\"\n    Reads keyframe data from a video file.\n\n    Args:\n        video_fpath (str): Video file path\n        keyframes (List[int]): List of keyframe timestamps (as counts in\n            timebase units to be used in container seek operations)\n        video_stream_idx (int): Video stream index (default: 0)\n    Returns:\n        List[Frame]: list of frames that correspond to the specified timestamps\n    \"\"\"", "\n", "try", ":", "\n", "        ", "with", "PathManager", ".", "open", "(", "video_fpath", ",", "\"rb\"", ")", "as", "io", ":", "\n", "            ", "container", "=", "av", ".", "open", "(", "io", ")", "\n", "stream", "=", "container", ".", "streams", ".", "video", "[", "video_stream_idx", "]", "\n", "frames", "=", "[", "]", "\n", "for", "pts", "in", "keyframes", ":", "\n", "                ", "try", ":", "\n", "                    ", "container", ".", "seek", "(", "pts", ",", "any_frame", "=", "False", ",", "stream", "=", "stream", ")", "\n", "frame", "=", "next", "(", "container", ".", "decode", "(", "video", "=", "0", ")", ")", "\n", "frames", ".", "append", "(", "frame", ")", "\n", "", "except", "av", ".", "AVError", "as", "e", ":", "\n", "                    ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"Read keyframes: Error seeking video file {video_fpath}, \"", "\n", "f\"video stream {video_stream_idx}, pts {pts}, AV error: {e}\"", "\n", ")", "\n", "container", ".", "close", "(", ")", "\n", "return", "frames", "\n", "", "except", "OSError", "as", "e", ":", "\n", "                    ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"Read keyframes: Error seeking video file {video_fpath}, \"", "\n", "f\"video stream {video_stream_idx}, pts {pts}, OS error: {e}\"", "\n", ")", "\n", "container", ".", "close", "(", ")", "\n", "return", "frames", "\n", "", "except", "StopIteration", ":", "\n", "                    ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"Read keyframes: Error decoding frame from {video_fpath}, \"", "\n", "f\"video stream {video_stream_idx}, pts {pts}\"", "\n", ")", "\n", "container", ".", "close", "(", ")", "\n", "return", "frames", "\n", "\n", "", "", "container", ".", "close", "(", ")", "\n", "return", "frames", "\n", "", "", "except", "OSError", "as", "e", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"Read keyframes: Error opening video file container {video_fpath}, OS error: {e}\"", "\n", ")", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"Read keyframes: Error opening video file container {video_fpath}, Runtime error: {e}\"", "\n", ")", "\n", "", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.video.video_keyframe_dataset.video_list_from_file": [[159, 172], ["fvcore.common.file_io.PathManager.open", "video_list.append", "utils.maybe_prepend_base_path", "line.strip"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.utils.maybe_prepend_base_path"], ["", "def", "video_list_from_file", "(", "video_list_fpath", ":", "str", ",", "base_path", ":", "Optional", "[", "str", "]", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Create a list of paths to video files from a text file.\n\n    Args:\n        video_list_fpath (str): path to a plain text file with the list of videos\n        base_path (str): base path for entries from the video list (default: None)\n    \"\"\"", "\n", "video_list", "=", "[", "]", "\n", "with", "PathManager", ".", "open", "(", "video_list_fpath", ",", "\"r\"", ")", "as", "io", ":", "\n", "        ", "for", "line", "in", "io", ":", "\n", "            ", "video_list", ".", "append", "(", "maybe_prepend_base_path", "(", "base_path", ",", "line", ".", "strip", "(", ")", ")", ")", "\n", "", "", "return", "video_list", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transform.image.ImageResizeTransform.__init__": [[13, 16], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "min_size", ":", "int", "=", "800", ",", "max_size", ":", "int", "=", "1333", ")", ":", "\n", "        ", "self", ".", "min_size", "=", "min_size", "\n", "self", ".", "max_size", "=", "max_size", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.transform.image.ImageResizeTransform.__call__": [[17, 38], ["torch.nn.functional.interpolate.permute().float", "min", "max", "min", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate.permute"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "frames", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Args:\n            frames (torch.Tensor): tensor of size [N, H, W, 3] that contains\n                RGB data (typically in uint8)\n        Returns:\n            frames (torch.Tensor): tensor of size [N, 3, H1, W1] where\n                H1 and W1 are chosen to respect the specified min and max sizes\n                and preserve the original aspect ratio, the data channels\n                follow BGR order and the data type is `torch.float32`\n        \"\"\"", "\n", "frames", "=", "frames", "[", "...", ",", "[", "2", ",", "1", ",", "0", "]", "]", "# RGB -> BGR", "\n", "frames", "=", "frames", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "float", "(", ")", "# NHWC -> NCHW", "\n", "# resize with min size", "\n", "min_size", "=", "min", "(", "frames", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "max_size", "=", "max", "(", "frames", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "scale", "=", "min", "(", "self", ".", "min_size", "/", "min_size", ",", "self", ".", "max_size", "/", "max_size", ")", "\n", "frames", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "\n", "frames", ",", "scale_factor", "=", "scale", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", "\n", ")", "\n", "return", "frames", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.MatrixVisualizer.__init__": [[16, 31], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "inplace", "=", "True", ",", "\n", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "\n", "val_scale", "=", "1.0", ",", "\n", "alpha", "=", "0.7", ",", "\n", "interp_method_matrix", "=", "cv2", ".", "INTER_LINEAR", ",", "\n", "interp_method_mask", "=", "cv2", ".", "INTER_NEAREST", ",", "\n", ")", ":", "\n", "        ", "self", ".", "inplace", "=", "inplace", "\n", "self", ".", "cmap", "=", "cmap", "\n", "self", ".", "val_scale", "=", "val_scale", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "interp_method_matrix", "=", "interp_method_matrix", "\n", "self", ".", "interp_method_mask", "=", "interp_method_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.MatrixVisualizer.visualize": [[32, 58], ["base.MatrixVisualizer._check_image", "base.MatrixVisualizer._check_mask_matrix", "base.MatrixVisualizer._resize", "numpy.tile", "numpy.any", "matrix_scaled.clip().astype", "cv2.applyColorMap", "image_target_bgr.astype", "int", "matrix.astype", "logging.getLogger", "logging.getLogger.warning", "matrix_scaled.clip"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.MatrixVisualizer._check_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.MatrixVisualizer._check_mask_matrix", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.MatrixVisualizer._resize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "def", "visualize", "(", "self", ",", "image_bgr", ",", "mask", ",", "matrix", ",", "bbox_xywh", ")", ":", "\n", "        ", "self", ".", "_check_image", "(", "image_bgr", ")", "\n", "self", ".", "_check_mask_matrix", "(", "mask", ",", "matrix", ")", "\n", "if", "self", ".", "inplace", ":", "\n", "            ", "image_target_bgr", "=", "image_bgr", "\n", "", "else", ":", "\n", "            ", "image_target_bgr", "=", "image_bgr", "*", "0", "\n", "", "x", ",", "y", ",", "w", ",", "h", "=", "[", "int", "(", "v", ")", "for", "v", "in", "bbox_xywh", "]", "\n", "if", "w", "<=", "0", "or", "h", "<=", "0", ":", "\n", "            ", "return", "image_bgr", "\n", "", "mask", ",", "matrix", "=", "self", ".", "_resize", "(", "mask", ",", "matrix", ",", "w", ",", "h", ")", "\n", "mask_bg", "=", "np", ".", "tile", "(", "(", "mask", "==", "0", ")", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "[", "1", ",", "1", ",", "3", "]", ")", "\n", "matrix_scaled", "=", "matrix", ".", "astype", "(", "np", ".", "float32", ")", "*", "self", ".", "val_scale", "\n", "_EPSILON", "=", "1e-6", "\n", "if", "np", ".", "any", "(", "matrix_scaled", ">", "255", "+", "_EPSILON", ")", ":", "\n", "            ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "warning", "(", "\n", "f\"Matrix has values > {255 + _EPSILON} after \"", "f\"scaling, clipping to [0..255]\"", "\n", ")", "\n", "", "matrix_scaled_8u", "=", "matrix_scaled", ".", "clip", "(", "0", ",", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "matrix_vis", "=", "cv2", ".", "applyColorMap", "(", "matrix_scaled_8u", ",", "self", ".", "cmap", ")", "\n", "matrix_vis", "[", "mask_bg", "]", "=", "image_target_bgr", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", ",", ":", "]", "[", "mask_bg", "]", "\n", "image_target_bgr", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", ",", ":", "]", "=", "(", "\n", "image_target_bgr", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", ",", ":", "]", "*", "(", "1.0", "-", "self", ".", "alpha", ")", "+", "matrix_vis", "*", "self", ".", "alpha", "\n", ")", "\n", "return", "image_target_bgr", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.MatrixVisualizer._resize": [[59, 65], ["cv2.resize", "cv2.resize"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.resize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.resize"], ["", "def", "_resize", "(", "self", ",", "mask", ",", "matrix", ",", "w", ",", "h", ")", ":", "\n", "        ", "if", "(", "w", "!=", "mask", ".", "shape", "[", "1", "]", ")", "or", "(", "h", "!=", "mask", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "mask", "=", "cv2", ".", "resize", "(", "mask", ",", "(", "w", ",", "h", ")", ",", "self", ".", "interp_method_mask", ")", "\n", "", "if", "(", "w", "!=", "matrix", ".", "shape", "[", "1", "]", ")", "or", "(", "h", "!=", "matrix", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "matrix", "=", "cv2", ".", "resize", "(", "matrix", ",", "(", "w", ",", "h", ")", ",", "self", ".", "interp_method_matrix", ")", "\n", "", "return", "mask", ",", "matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.MatrixVisualizer._check_image": [[66, 70], ["len"], "methods", ["None"], ["", "def", "_check_image", "(", "self", ",", "image_rgb", ")", ":", "\n", "        ", "assert", "len", "(", "image_rgb", ".", "shape", ")", "==", "3", "\n", "assert", "image_rgb", ".", "shape", "[", "2", "]", "==", "3", "\n", "assert", "image_rgb", ".", "dtype", "==", "np", ".", "uint8", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.MatrixVisualizer._check_mask_matrix": [[71, 75], ["len", "len"], "methods", ["None"], ["", "def", "_check_mask_matrix", "(", "self", ",", "mask", ",", "matrix", ")", ":", "\n", "        ", "assert", "len", "(", "matrix", ".", "shape", ")", "==", "2", "\n", "assert", "len", "(", "mask", ".", "shape", ")", "==", "2", "\n", "assert", "mask", ".", "dtype", "==", "np", ".", "uint8", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.RectangleVisualizer.__init__": [[81, 84], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "color", "=", "_COLOR_GREEN", ",", "thickness", "=", "1", ")", ":", "\n", "        ", "self", ".", "color", "=", "color", "\n", "self", ".", "thickness", "=", "thickness", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.RectangleVisualizer.visualize": [[85, 91], ["cv2.rectangle", "int", "int", "int", "int"], "methods", ["None"], ["", "def", "visualize", "(", "self", ",", "image_bgr", ",", "bbox_xywh", ",", "color", "=", "None", ",", "thickness", "=", "None", ")", ":", "\n", "        ", "x", ",", "y", ",", "w", ",", "h", "=", "bbox_xywh", "\n", "color", "=", "color", "or", "self", ".", "color", "\n", "thickness", "=", "thickness", "or", "self", ".", "thickness", "\n", "cv2", ".", "rectangle", "(", "image_bgr", ",", "(", "int", "(", "x", ")", ",", "int", "(", "y", ")", ")", ",", "(", "int", "(", "x", "+", "w", ")", ",", "int", "(", "y", "+", "h", ")", ")", ",", "color", ",", "thickness", ")", "\n", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.PointsVisualizer.__init__": [[97, 100], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "color_bgr", "=", "_COLOR_GREEN", ",", "r", "=", "5", ")", ":", "\n", "        ", "self", ".", "color_bgr", "=", "color_bgr", "\n", "self", ".", "r", "=", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.PointsVisualizer.visualize": [[101, 108], ["enumerate", "cv2.circle"], "methods", ["None"], ["", "def", "visualize", "(", "self", ",", "image_bgr", ",", "pts_xy", ",", "colors_bgr", "=", "None", ",", "rs", "=", "None", ")", ":", "\n", "        ", "for", "j", ",", "pt_xy", "in", "enumerate", "(", "pts_xy", ")", ":", "\n", "            ", "x", ",", "y", "=", "pt_xy", "\n", "color_bgr", "=", "colors_bgr", "[", "j", "]", "if", "colors_bgr", "is", "not", "None", "else", "self", ".", "color_bgr", "\n", "r", "=", "rs", "[", "j", "]", "if", "rs", "is", "not", "None", "else", "self", ".", "r", "\n", "cv2", ".", "circle", "(", "image_bgr", ",", "(", "x", ",", "y", ")", ",", "r", ",", "color_bgr", ",", "-", "1", ")", "\n", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.TextVisualizer.__init__": [[115, 138], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "font_face", "=", "cv2", ".", "FONT_HERSHEY_SIMPLEX", ",", "\n", "font_color_bgr", "=", "_COLOR_GRAY", ",", "\n", "font_scale", "=", "0.35", ",", "\n", "font_line_type", "=", "cv2", ".", "LINE_AA", ",", "\n", "font_line_thickness", "=", "1", ",", "\n", "fill_color_bgr", "=", "_COLOR_WHITE", ",", "\n", "fill_color_transparency", "=", "1.0", ",", "\n", "frame_color_bgr", "=", "_COLOR_WHITE", ",", "\n", "frame_color_transparency", "=", "1.0", ",", "\n", "frame_thickness", "=", "1", ",", "\n", ")", ":", "\n", "        ", "self", ".", "font_face", "=", "font_face", "\n", "self", ".", "font_color_bgr", "=", "font_color_bgr", "\n", "self", ".", "font_scale", "=", "font_scale", "\n", "self", ".", "font_line_type", "=", "font_line_type", "\n", "self", ".", "font_line_thickness", "=", "font_line_thickness", "\n", "self", ".", "fill_color_bgr", "=", "fill_color_bgr", "\n", "self", ".", "fill_color_transparency", "=", "fill_color_transparency", "\n", "self", ".", "frame_color_bgr", "=", "frame_color_bgr", "\n", "self", ".", "frame_color_transparency", "=", "frame_color_transparency", "\n", "self", ".", "frame_thickness", "=", "frame_thickness", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.TextVisualizer.visualize": [[139, 166], ["base.TextVisualizer.get_text_size_wh", "tuple", "cv2.putText", "map", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.TextVisualizer.get_text_size_wh"], ["", "def", "visualize", "(", "self", ",", "image_bgr", ",", "txt", ",", "topleft_xy", ")", ":", "\n", "        ", "txt_w", ",", "txt_h", "=", "self", ".", "get_text_size_wh", "(", "txt", ")", "\n", "topleft_xy", "=", "tuple", "(", "map", "(", "int", ",", "topleft_xy", ")", ")", "\n", "x", ",", "y", "=", "topleft_xy", "\n", "if", "self", ".", "frame_color_transparency", "<", "1.0", ":", "\n", "            ", "t", "=", "self", ".", "frame_thickness", "\n", "image_bgr", "[", "y", "-", "t", ":", "y", "+", "txt_h", "+", "t", ",", "x", "-", "t", ":", "x", "+", "txt_w", "+", "t", ",", ":", "]", "=", "(", "\n", "image_bgr", "[", "y", "-", "t", ":", "y", "+", "txt_h", "+", "t", ",", "x", "-", "t", ":", "x", "+", "txt_w", "+", "t", ",", ":", "]", "\n", "*", "self", ".", "frame_color_transparency", "\n", "+", "np", ".", "array", "(", "self", ".", "frame_color_bgr", ")", "*", "(", "1.0", "-", "self", ".", "frame_color_transparency", ")", "\n", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "", "if", "self", ".", "fill_color_transparency", "<", "1.0", ":", "\n", "            ", "image_bgr", "[", "y", ":", "y", "+", "txt_h", ",", "x", ":", "x", "+", "txt_w", ",", ":", "]", "=", "(", "\n", "image_bgr", "[", "y", ":", "y", "+", "txt_h", ",", "x", ":", "x", "+", "txt_w", ",", ":", "]", "*", "self", ".", "fill_color_transparency", "\n", "+", "np", ".", "array", "(", "self", ".", "fill_color_bgr", ")", "*", "(", "1.0", "-", "self", ".", "fill_color_transparency", ")", "\n", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "", "cv2", ".", "putText", "(", "\n", "image_bgr", ",", "\n", "txt", ",", "\n", "topleft_xy", ",", "\n", "self", ".", "font_face", ",", "\n", "self", ".", "font_scale", ",", "\n", "self", ".", "font_color_bgr", ",", "\n", "self", ".", "font_line_thickness", ",", "\n", "self", ".", "font_line_type", ",", "\n", ")", "\n", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.TextVisualizer.get_text_size_wh": [[167, 172], ["cv2.getTextSize"], "methods", ["None"], ["", "def", "get_text_size_wh", "(", "self", ",", "txt", ")", ":", "\n", "        ", "(", "(", "txt_w", ",", "txt_h", ")", ",", "_", ")", "=", "cv2", ".", "getTextSize", "(", "\n", "txt", ",", "self", ".", "font_face", ",", "self", ".", "font_scale", ",", "self", ".", "font_line_thickness", "\n", ")", "\n", "return", "txt_w", ",", "txt_h", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.CompoundVisualizer.__init__": [[175, 177], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "visualizers", ")", ":", "\n", "        ", "self", ".", "visualizers", "=", "visualizers", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.CompoundVisualizer.visualize": [[178, 188], ["enumerate", "len", "len", "len", "len", "visualizer.visualize"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "self", ",", "image_bgr", ",", "data", ")", ":", "\n", "        ", "assert", "len", "(", "data", ")", "==", "len", "(", "\n", "self", ".", "visualizers", "\n", ")", ",", "\"The number of datas {} should match the number of visualizers\"", "\" {}\"", ".", "format", "(", "\n", "len", "(", "data", ")", ",", "len", "(", "self", ".", "visualizers", ")", "\n", ")", "\n", "image", "=", "image_bgr", "\n", "for", "i", ",", "visualizer", "in", "enumerate", "(", "self", ".", "visualizers", ")", ":", "\n", "            ", "image", "=", "visualizer", ".", "visualize", "(", "image", ",", "data", "[", "i", "]", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.base.CompoundVisualizer.__str__": [[189, 192], ["str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "visualizer_str", "=", "\", \"", ".", "join", "(", "[", "str", "(", "v", ")", "for", "v", "in", "self", ".", "visualizers", "]", ")", "\n", "return", "\"Compound Visualizer [{}]\"", ".", "format", "(", "visualizer_str", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.BoundingBoxExtractor.__call__": [[56, 59], ["extractor.extract_boxes_xywh_from_instances"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.extract_boxes_xywh_from_instances"], ["def", "__call__", "(", "self", ",", "instances", ":", "Instances", ")", ":", "\n", "        ", "boxes_xywh", "=", "extract_boxes_xywh_from_instances", "(", "instances", ")", "\n", "return", "boxes_xywh", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.ScoredBoundingBoxExtractor.__call__": [[66, 75], ["extractor.extract_scores_from_instances", "extractor.extract_boxes_xywh_from_instances"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.extract_scores_from_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.extract_boxes_xywh_from_instances"], ["def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "scores", "=", "extract_scores_from_instances", "(", "instances", ")", "\n", "boxes_xywh", "=", "extract_boxes_xywh_from_instances", "(", "instances", ")", "\n", "if", "(", "scores", "is", "None", ")", "or", "(", "boxes_xywh", "is", "None", ")", ":", "\n", "            ", "return", "(", "boxes_xywh", ",", "scores", ")", "\n", "", "if", "select", "is", "not", "None", ":", "\n", "            ", "scores", "=", "scores", "[", "select", "]", "\n", "boxes_xywh", "=", "boxes_xywh", "[", "select", "]", "\n", "", "return", "(", "boxes_xywh", ",", "scores", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.DensePoseResultExtractor.__call__": [[82, 92], ["extractor.extract_boxes_xywh_from_instances", "instances.has", "dpout.to_result"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.extract_boxes_xywh_from_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseOutput.to_result"], ["def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "boxes_xywh", "=", "extract_boxes_xywh_from_instances", "(", "instances", ")", "\n", "if", "instances", ".", "has", "(", "\"pred_densepose\"", ")", "and", "(", "boxes_xywh", "is", "not", "None", ")", ":", "\n", "            ", "dpout", "=", "instances", ".", "pred_densepose", "\n", "if", "select", "is", "not", "None", ":", "\n", "                ", "dpout", "=", "dpout", "[", "select", "]", "\n", "boxes_xywh", "=", "boxes_xywh", "[", "select", "]", "\n", "", "return", "dpout", ".", "to_result", "(", "boxes_xywh", ")", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.CompoundExtractor.__init__": [[99, 101], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "extractors", ")", ":", "\n", "        ", "self", ".", "extractors", "=", "extractors", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.CompoundExtractor.__call__": [[102, 108], ["extractor", "datas.append"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "datas", "=", "[", "]", "\n", "for", "extractor", "in", "self", ".", "extractors", ":", "\n", "            ", "data", "=", "extractor", "(", "instances", ",", "select", ")", "\n", "datas", ".", "append", "(", "data", ")", "\n", "", "return", "datas", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.NmsFilteredExtractor.__init__": [[115, 118], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "extractor", ",", "iou_threshold", ")", ":", "\n", "        ", "self", ".", "extractor", "=", "extractor", "\n", "self", ".", "iou_threshold", "=", "iou_threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.NmsFilteredExtractor.__call__": [[119, 134], ["extractor.extract_scores_from_instances", "extractor.extract_boxes_xywh_from_instances", "detectron2.layers.nms.batched_nms().squeeze", "torch.zeros", "extractor.NmsFilteredExtractor.extractor", "len", "detectron2.layers.nms.batched_nms", "torch.zeros", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.extract_scores_from_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.extract_boxes_xywh_from_instances", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms"], ["", "def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "scores", "=", "extract_scores_from_instances", "(", "instances", ")", "\n", "boxes_xywh", "=", "extract_boxes_xywh_from_instances", "(", "instances", ")", "\n", "if", "boxes_xywh", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "select_local_idx", "=", "batched_nms", "(", "\n", "boxes_xywh", ",", "\n", "scores", ",", "\n", "torch", ".", "zeros", "(", "len", "(", "scores", ")", ",", "dtype", "=", "torch", ".", "int32", ")", ",", "\n", "iou_threshold", "=", "self", ".", "iou_threshold", ",", "\n", ")", ".", "squeeze", "(", ")", "\n", "select_local", "=", "torch", ".", "zeros", "(", "len", "(", "boxes_xywh", ")", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "boxes_xywh", ".", "device", ")", "\n", "select_local", "[", "select_local_idx", "]", "=", "True", "\n", "select", "=", "select_local", "if", "select", "is", "None", "else", "(", "select", "&", "select_local", ")", "\n", "return", "self", ".", "extractor", "(", "instances", ",", "select", "=", "select", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.ScoreThresholdedExtractor.__init__": [[141, 144], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "extractor", ",", "min_score", ")", ":", "\n", "        ", "self", ".", "extractor", "=", "extractor", "\n", "self", ".", "min_score", "=", "min_score", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.ScoreThresholdedExtractor.__call__": [[145, 153], ["extractor.extract_scores_from_instances", "extractor.ScoreThresholdedExtractor.extractor"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.extract_scores_from_instances"], ["", "def", "__call__", "(", "self", ",", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "        ", "scores", "=", "extract_scores_from_instances", "(", "instances", ")", "\n", "if", "scores", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "select_local", "=", "scores", ">", "self", ".", "min_score", "\n", "select", "=", "select_local", "if", "select", "is", "None", "else", "(", "select", "&", "select_local", ")", "\n", "data", "=", "self", ".", "extractor", "(", "instances", ",", "select", "=", "select", ")", "\n", "return", "data", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.extract_scores_from_instances": [[17, 21], ["instances.has"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has"], ["def", "extract_scores_from_instances", "(", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "    ", "if", "instances", ".", "has", "(", "\"scores\"", ")", ":", "\n", "        ", "return", "instances", ".", "scores", "if", "select", "is", "None", "else", "instances", ".", "scores", "[", "select", "]", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.extract_boxes_xywh_from_instances": [[23, 30], ["instances.has", "instances.pred_boxes.tensor.clone"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.has", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "def", "extract_boxes_xywh_from_instances", "(", "instances", ":", "Instances", ",", "select", "=", "None", ")", ":", "\n", "    ", "if", "instances", ".", "has", "(", "\"pred_boxes\"", ")", ":", "\n", "        ", "boxes_xywh", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "clone", "(", ")", "\n", "boxes_xywh", "[", ":", ",", "2", "]", "-=", "boxes_xywh", "[", ":", ",", "0", "]", "\n", "boxes_xywh", "[", ":", ",", "3", "]", "-=", "boxes_xywh", "[", ":", ",", "1", "]", "\n", "return", "boxes_xywh", "if", "select", "is", "None", "else", "boxes_xywh", "[", "select", "]", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.create_extractor": [[32, 49], ["isinstance", "extractor.CompoundExtractor", "isinstance", "extractor.create_extractor", "extractor.DensePoseResultExtractor", "isinstance", "extractor.CompoundExtractor", "isinstance", "logging.getLogger", "logging.getLogger.error"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.extractor.create_extractor"], ["", "def", "create_extractor", "(", "visualizer", ":", "object", ")", ":", "\n", "    ", "\"\"\"\n    Create an extractor for the provided visualizer\n    \"\"\"", "\n", "if", "isinstance", "(", "visualizer", ",", "CompoundVisualizer", ")", ":", "\n", "        ", "extractors", "=", "[", "create_extractor", "(", "v", ")", "for", "v", "in", "visualizer", ".", "visualizers", "]", "\n", "return", "CompoundExtractor", "(", "extractors", ")", "\n", "", "elif", "isinstance", "(", "visualizer", ",", "DensePoseResultsVisualizer", ")", ":", "\n", "        ", "return", "DensePoseResultExtractor", "(", ")", "\n", "", "elif", "isinstance", "(", "visualizer", ",", "ScoredBoundingBoxVisualizer", ")", ":", "\n", "        ", "return", "CompoundExtractor", "(", "[", "extract_boxes_xywh_from_instances", ",", "extract_scores_from_instances", "]", ")", "\n", "", "elif", "isinstance", "(", "visualizer", ",", "BoundingBoxVisualizer", ")", ":", "\n", "        ", "return", "extract_boxes_xywh_from_instances", "\n", "", "else", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "error", "(", "f\"Could not create extractor for {visualizer}\"", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.bounding_box.BoundingBoxVisualizer.__init__": [[6, 8], ["base.RectangleVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "rectangle_visualizer", "=", "RectangleVisualizer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.bounding_box.BoundingBoxVisualizer.visualize": [[9, 13], ["bounding_box.BoundingBoxVisualizer.rectangle_visualizer.visualize"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "self", ",", "image_bgr", ",", "boxes_xywh", ")", ":", "\n", "        ", "for", "bbox_xywh", "in", "boxes_xywh", ":", "\n", "            ", "image_bgr", "=", "self", ".", "rectangle_visualizer", ".", "visualize", "(", "image_bgr", ",", "bbox_xywh", ")", "\n", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.bounding_box.ScoredBoundingBoxVisualizer.__init__": [[16, 23], ["base.RectangleVisualizer", "base.TextVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "bbox_visualizer_params", "=", "None", ",", "score_visualizer_params", "=", "None", ")", ":", "\n", "        ", "if", "bbox_visualizer_params", "is", "None", ":", "\n", "            ", "bbox_visualizer_params", "=", "{", "}", "\n", "", "if", "score_visualizer_params", "is", "None", ":", "\n", "            ", "score_visualizer_params", "=", "{", "}", "\n", "", "self", ".", "visualizer_bbox", "=", "RectangleVisualizer", "(", "**", "bbox_visualizer_params", ")", "\n", "self", ".", "visualizer_score", "=", "TextVisualizer", "(", "**", "score_visualizer_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.bounding_box.ScoredBoundingBoxVisualizer.visualize": [[24, 38], ["enumerate", "len", "len", "len", "len", "bounding_box.ScoredBoundingBoxVisualizer.visualizer_bbox.visualize", "bounding_box.ScoredBoundingBoxVisualizer.visualizer_score.visualize"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "self", ",", "image_bgr", ",", "scored_bboxes", ")", ":", "\n", "        ", "boxes_xywh", ",", "box_scores", "=", "scored_bboxes", "\n", "assert", "len", "(", "boxes_xywh", ")", "==", "len", "(", "\n", "box_scores", "\n", ")", ",", "\"Number of bounding boxes {} should be equal to the number of scores {}\"", ".", "format", "(", "\n", "len", "(", "boxes_xywh", ")", ",", "len", "(", "box_scores", ")", "\n", ")", "\n", "for", "i", ",", "box_xywh", "in", "enumerate", "(", "boxes_xywh", ")", ":", "\n", "            ", "score_i", "=", "box_scores", "[", "i", "]", "\n", "image_bgr", "=", "self", ".", "visualizer_bbox", ".", "visualize", "(", "image_bgr", ",", "box_xywh", ")", "\n", "score_txt", "=", "\"{0:6.4f}\"", ".", "format", "(", "score_i", ")", "\n", "topleft_xy", "=", "box_xywh", "[", "0", "]", ",", "box_xywh", "[", "1", "]", "\n", "image_bgr", "=", "self", ".", "visualizer_score", ".", "visualize", "(", "image_bgr", ",", "score_txt", ",", "topleft_xy", ")", "\n", "", "return", "image_bgr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsVisualizer.visualize": [[12, 22], ["densepose.DensePoseResultsVisualizer.create_visualization_context", "enumerate", "densepose.DensePoseResultsVisualizer.context_to_image_bgr", "data.structures.DensePoseResult.decode_png_data", "densepose.DensePoseResultsVisualizer.visualize_iuv_arr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.create_visualization_context", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.context_to_image_bgr", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseResult.decode_png_data", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.visualize_iuv_arr"], ["    ", "def", "visualize", "(", "self", ",", "image_bgr", ":", "Image", ",", "densepose_result", ":", "Optional", "[", "DensePoseResult", "]", ")", "->", "Image", ":", "\n", "        ", "if", "densepose_result", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "context", "=", "self", ".", "create_visualization_context", "(", "image_bgr", ")", "\n", "for", "i", ",", "result_encoded_w_shape", "in", "enumerate", "(", "densepose_result", ".", "results", ")", ":", "\n", "            ", "iuv_arr", "=", "DensePoseResult", ".", "decode_png_data", "(", "*", "result_encoded_w_shape", ")", "\n", "bbox_xywh", "=", "densepose_result", ".", "boxes_xywh", "[", "i", "]", "\n", "self", ".", "visualize_iuv_arr", "(", "context", ",", "iuv_arr", ",", "bbox_xywh", ")", "\n", "", "image_bgr", "=", "self", ".", "context_to_image_bgr", "(", "context", ")", "\n", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseMaskedColormapResultsVisualizer.__init__": [[25, 39], ["base.MatrixVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "data_extractor", ",", "\n", "segm_extractor", ",", "\n", "inplace", "=", "True", ",", "\n", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "\n", "alpha", "=", "0.7", ",", "\n", "val_scale", "=", "1.0", ",", "\n", ")", ":", "\n", "        ", "self", ".", "mask_visualizer", "=", "MatrixVisualizer", "(", "\n", "inplace", "=", "inplace", ",", "cmap", "=", "cmap", ",", "val_scale", "=", "val_scale", ",", "alpha", "=", "alpha", "\n", ")", "\n", "self", ".", "data_extractor", "=", "data_extractor", "\n", "self", ".", "segm_extractor", "=", "segm_extractor", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseMaskedColormapResultsVisualizer.create_visualization_context": [[40, 42], ["None"], "methods", ["None"], ["", "def", "create_visualization_context", "(", "self", ",", "image_bgr", ":", "Image", ")", ":", "\n", "        ", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseMaskedColormapResultsVisualizer.context_to_image_bgr": [[43, 45], ["None"], "methods", ["None"], ["", "def", "context_to_image_bgr", "(", "self", ",", "context", ")", ":", "\n", "        ", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseMaskedColormapResultsVisualizer.get_image_bgr_from_context": [[46, 48], ["None"], "methods", ["None"], ["", "def", "get_image_bgr_from_context", "(", "self", ",", "context", ")", ":", "\n", "        ", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseMaskedColormapResultsVisualizer.visualize_iuv_arr": [[49, 57], ["densepose.DensePoseMaskedColormapResultsVisualizer.get_image_bgr_from_context", "densepose.DensePoseMaskedColormapResultsVisualizer.data_extractor", "densepose.DensePoseMaskedColormapResultsVisualizer.segm_extractor", "numpy.zeros", "densepose.DensePoseMaskedColormapResultsVisualizer.mask_visualizer.visualize"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.get_image_bgr_from_context", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize_iuv_arr", "(", "self", ",", "context", ",", "iuv_arr", ",", "bbox_xywh", ")", ":", "\n", "        ", "image_bgr", "=", "self", ".", "get_image_bgr_from_context", "(", "context", ")", "\n", "matrix", "=", "self", ".", "data_extractor", "(", "iuv_arr", ")", "\n", "segm", "=", "self", ".", "segm_extractor", "(", "iuv_arr", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "matrix", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "[", "segm", ">", "0", "]", "=", "1", "\n", "image_bgr", "=", "self", ".", "mask_visualizer", ".", "visualize", "(", "image_bgr", ",", "mask", ",", "matrix", ",", "bbox_xywh", ")", "\n", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsMplContourVisualizer.__init__": [[72, 75], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "levels", "=", "10", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "levels", "=", "levels", "\n", "self", ".", "plot_args", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsMplContourVisualizer.create_visualization_context": [[76, 94], ["plt.figure", "plt.axes", "plt.axis", "FigureCanvas", "plt.imshow", "float", "float"], "methods", ["None"], ["", "def", "create_visualization_context", "(", "self", ",", "image_bgr", ":", "Image", ")", ":", "\n", "        ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "from", "matplotlib", ".", "backends", ".", "backend_agg", "import", "FigureCanvasAgg", "as", "FigureCanvas", "\n", "\n", "context", "=", "{", "}", "\n", "context", "[", "\"image_bgr\"", "]", "=", "image_bgr", "\n", "dpi", "=", "100", "\n", "height_inches", "=", "float", "(", "image_bgr", ".", "shape", "[", "0", "]", ")", "/", "dpi", "\n", "width_inches", "=", "float", "(", "image_bgr", ".", "shape", "[", "1", "]", ")", "/", "dpi", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "width_inches", ",", "height_inches", ")", ",", "dpi", "=", "dpi", ")", "\n", "plt", ".", "axes", "(", "[", "0", ",", "0", ",", "1", ",", "1", "]", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "context", "[", "\"fig\"", "]", "=", "fig", "\n", "canvas", "=", "FigureCanvas", "(", "fig", ")", "\n", "context", "[", "\"canvas\"", "]", "=", "canvas", "\n", "extent", "=", "(", "0", ",", "image_bgr", ".", "shape", "[", "1", "]", ",", "image_bgr", ".", "shape", "[", "0", "]", ",", "0", ")", "\n", "plt", ".", "imshow", "(", "image_bgr", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ",", "extent", "=", "extent", ")", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsMplContourVisualizer.context_to_image_bgr": [[95, 104], ["map", "canvas.draw", "numpy.fromstring", "numpy.fromstring.reshape", "image_rgb[].copy", "canvas.tostring_rgb", "fig.get_size_inches", "fig.get_dpi"], "methods", ["None"], ["", "def", "context_to_image_bgr", "(", "self", ",", "context", ")", ":", "\n", "        ", "fig", "=", "context", "[", "\"fig\"", "]", "\n", "w", ",", "h", "=", "map", "(", "int", ",", "fig", ".", "get_size_inches", "(", ")", "*", "fig", ".", "get_dpi", "(", ")", ")", "\n", "canvas", "=", "context", "[", "\"canvas\"", "]", "\n", "canvas", ".", "draw", "(", ")", "\n", "image_1d", "=", "np", ".", "fromstring", "(", "canvas", ".", "tostring_rgb", "(", ")", ",", "dtype", "=", "\"uint8\"", ")", "\n", "image_rgb", "=", "image_1d", ".", "reshape", "(", "h", ",", "w", ",", "3", ")", "\n", "image_bgr", "=", "image_rgb", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ".", "copy", "(", ")", "\n", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsMplContourVisualizer.visualize_iuv_arr": [[105, 118], ["plt.contour", "plt.contour", "_extract_u_from_iuvarr().astype", "_extract_v_from_iuvarr().astype", "densepose._extract_u_from_iuvarr", "densepose._extract_v_from_iuvarr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._extract_u_from_iuvarr", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._extract_v_from_iuvarr"], ["", "def", "visualize_iuv_arr", "(", "self", ",", "context", ",", "iuv_arr", ":", "np", ".", "ndarray", ",", "bbox_xywh", ":", "Boxes", ")", "->", "Image", ":", "\n", "        ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "\n", "u", "=", "_extract_u_from_iuvarr", "(", "iuv_arr", ")", ".", "astype", "(", "float", ")", "/", "255.0", "\n", "v", "=", "_extract_v_from_iuvarr", "(", "iuv_arr", ")", ".", "astype", "(", "float", ")", "/", "255.0", "\n", "extent", "=", "(", "\n", "bbox_xywh", "[", "0", "]", ",", "\n", "bbox_xywh", "[", "0", "]", "+", "bbox_xywh", "[", "2", "]", ",", "\n", "bbox_xywh", "[", "1", "]", ",", "\n", "bbox_xywh", "[", "1", "]", "+", "bbox_xywh", "[", "3", "]", ",", "\n", ")", "\n", "plt", ".", "contour", "(", "u", ",", "self", ".", "levels", ",", "extent", "=", "extent", ",", "**", "self", ".", "plot_args", ")", "\n", "plt", ".", "contour", "(", "v", ",", "self", ".", "levels", ",", "extent", "=", "extent", ",", "**", "self", ".", "plot_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.__init__": [[125, 140], ["isinstance", "cv2.applyColorMap", "numpy.linspace", "len", "int", "img_color_bgr.ravel"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "levels", "=", "10", ",", "**", "kwargs", ")", ":", "\n", "# TODO: colormap is hardcoded", "\n", "        ", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", "\n", "if", "isinstance", "(", "levels", ",", "int", ")", ":", "\n", "            ", "self", ".", "levels", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "levels", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "levels", "=", "levels", "\n", "", "if", "\"linewidths\"", "in", "kwargs", ":", "\n", "            ", "self", ".", "linewidths", "=", "kwargs", "[", "\"linewidths\"", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "linewidths", "=", "[", "1", "]", "*", "len", "(", "self", ".", "levels", ")", "\n", "", "self", ".", "plot_args", "=", "kwargs", "\n", "img_colors_bgr", "=", "cv2", ".", "applyColorMap", "(", "(", "self", ".", "levels", "*", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", ",", "cmap", ")", "\n", "self", ".", "level_colors_bgr", "=", "[", "\n", "[", "int", "(", "v", ")", "for", "v", "in", "img_color_bgr", ".", "ravel", "(", ")", "]", "for", "img_color_bgr", "in", "img_colors_bgr", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.create_visualization_context": [[142, 144], ["None"], "methods", ["None"], ["", "def", "create_visualization_context", "(", "self", ",", "image_bgr", ":", "Image", ")", ":", "\n", "        ", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.context_to_image_bgr": [[145, 147], ["None"], "methods", ["None"], ["", "def", "context_to_image_bgr", "(", "self", ",", "context", ")", ":", "\n", "        ", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.get_image_bgr_from_context": [[148, 150], ["None"], "methods", ["None"], ["", "def", "get_image_bgr_from_context", "(", "self", ",", "context", ")", ":", "\n", "        ", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.visualize_iuv_arr": [[151, 158], ["densepose.DensePoseResultsCustomContourVisualizer.get_image_bgr_from_context", "densepose._extract_i_from_iuvarr", "densepose.DensePoseResultsCustomContourVisualizer._contours", "densepose.DensePoseResultsCustomContourVisualizer._contours", "_extract_u_from_iuvarr().astype", "_extract_v_from_iuvarr().astype", "densepose._extract_u_from_iuvarr", "densepose._extract_v_from_iuvarr"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer.get_image_bgr_from_context", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._extract_i_from_iuvarr", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer._contours", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer._contours", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._extract_u_from_iuvarr", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._extract_v_from_iuvarr"], ["", "def", "visualize_iuv_arr", "(", "self", ",", "context", ",", "iuv_arr", ":", "np", ".", "ndarray", ",", "bbox_xywh", ":", "Boxes", ")", "->", "Image", ":", "\n", "        ", "image_bgr", "=", "self", ".", "get_image_bgr_from_context", "(", "context", ")", "\n", "segm", "=", "_extract_i_from_iuvarr", "(", "iuv_arr", ")", "\n", "u", "=", "_extract_u_from_iuvarr", "(", "iuv_arr", ")", ".", "astype", "(", "float", ")", "/", "255.0", "\n", "v", "=", "_extract_v_from_iuvarr", "(", "iuv_arr", ")", ".", "astype", "(", "float", ")", "/", "255.0", "\n", "self", ".", "_contours", "(", "image_bgr", ",", "u", ",", "segm", ",", "bbox_xywh", ")", "\n", "self", ".", "_contours", "(", "image_bgr", ",", "v", ",", "segm", ",", "bbox_xywh", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer._contours": [[159, 204], ["range", "numpy.amin", "numpy.amax", "numpy.nonzero", "numpy.amin", "numpy.amin", "enumerate", "numpy.any", "numpy.amax", "numpy.amax", "numpy.nditer", "numpy.nditer.iternext", "densepose.DensePoseResultsCustomContourVisualizer._draw_line"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer._draw_line"], ["", "def", "_contours", "(", "self", ",", "image_bgr", ",", "arr", ",", "segm", ",", "bbox_xywh", ")", ":", "\n", "        ", "for", "part_idx", "in", "range", "(", "1", ",", "DensePoseDataRelative", ".", "N_PART_LABELS", "+", "1", ")", ":", "\n", "            ", "mask", "=", "segm", "==", "part_idx", "\n", "if", "not", "np", ".", "any", "(", "mask", ")", ":", "\n", "                ", "continue", "\n", "", "arr_min", "=", "np", ".", "amin", "(", "arr", "[", "mask", "]", ")", "\n", "arr_max", "=", "np", ".", "amax", "(", "arr", "[", "mask", "]", ")", "\n", "I", ",", "J", "=", "np", ".", "nonzero", "(", "mask", ")", "\n", "i0", "=", "np", ".", "amin", "(", "I", ")", "\n", "i1", "=", "np", ".", "amax", "(", "I", ")", "+", "1", "\n", "j0", "=", "np", ".", "amin", "(", "J", ")", "\n", "j1", "=", "np", ".", "amax", "(", "J", ")", "+", "1", "\n", "if", "(", "j1", "==", "j0", "+", "1", ")", "or", "(", "i1", "==", "i0", "+", "1", ")", ":", "\n", "                ", "continue", "\n", "", "Nw", "=", "arr", ".", "shape", "[", "1", "]", "-", "1", "\n", "Nh", "=", "arr", ".", "shape", "[", "0", "]", "-", "1", "\n", "for", "level_idx", ",", "level", "in", "enumerate", "(", "self", ".", "levels", ")", ":", "\n", "                ", "if", "(", "level", "<", "arr_min", ")", "or", "(", "level", ">", "arr_max", ")", ":", "\n", "                    ", "continue", "\n", "", "vp", "=", "arr", "[", "i0", ":", "i1", ",", "j0", ":", "j1", "]", ">=", "level", "\n", "bin_codes", "=", "vp", "[", ":", "-", "1", ",", ":", "-", "1", "]", "+", "vp", "[", "1", ":", ",", ":", "-", "1", "]", "*", "2", "+", "vp", "[", "1", ":", ",", "1", ":", "]", "*", "4", "+", "vp", "[", ":", "-", "1", ",", "1", ":", "]", "*", "8", "\n", "mp", "=", "mask", "[", "i0", ":", "i1", ",", "j0", ":", "j1", "]", "\n", "bin_mask_codes", "=", "mp", "[", ":", "-", "1", ",", ":", "-", "1", "]", "+", "mp", "[", "1", ":", ",", ":", "-", "1", "]", "*", "2", "+", "mp", "[", "1", ":", ",", "1", ":", "]", "*", "4", "+", "mp", "[", ":", "-", "1", ",", "1", ":", "]", "*", "8", "\n", "it", "=", "np", ".", "nditer", "(", "bin_codes", ",", "flags", "=", "[", "\"multi_index\"", "]", ")", "\n", "color_bgr", "=", "self", ".", "level_colors_bgr", "[", "level_idx", "]", "\n", "linewidth", "=", "self", ".", "linewidths", "[", "level_idx", "]", "\n", "while", "not", "it", ".", "finished", ":", "\n", "                    ", "if", "(", "it", "[", "0", "]", "!=", "0", ")", "and", "(", "it", "[", "0", "]", "!=", "15", ")", ":", "\n", "                        ", "i", ",", "j", "=", "it", ".", "multi_index", "\n", "if", "bin_mask_codes", "[", "i", ",", "j", "]", "!=", "0", ":", "\n", "                            ", "self", ".", "_draw_line", "(", "\n", "image_bgr", ",", "\n", "arr", ",", "\n", "mask", ",", "\n", "level", ",", "\n", "color_bgr", ",", "\n", "linewidth", ",", "\n", "it", "[", "0", "]", ",", "\n", "it", ".", "multi_index", ",", "\n", "bbox_xywh", ",", "\n", "Nw", ",", "\n", "Nh", ",", "\n", "(", "i0", ",", "j0", ")", ",", "\n", ")", "\n", "", "", "it", ".", "iternext", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer._draw_line": [[205, 230], ["densepose.DensePoseResultsCustomContourVisualizer._bin_code_2_lines", "cv2.line", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer._bin_code_2_lines"], ["", "", "", "", "def", "_draw_line", "(", "\n", "self", ",", "\n", "image_bgr", ",", "\n", "arr", ",", "\n", "mask", ",", "\n", "v", ",", "\n", "color_bgr", ",", "\n", "linewidth", ",", "\n", "bin_code", ",", "\n", "multi_idx", ",", "\n", "bbox_xywh", ",", "\n", "Nw", ",", "\n", "Nh", ",", "\n", "offset", ",", "\n", ")", ":", "\n", "        ", "lines", "=", "self", ".", "_bin_code_2_lines", "(", "arr", ",", "v", ",", "bin_code", ",", "multi_idx", ",", "Nw", ",", "Nh", ",", "offset", ")", "\n", "x0", ",", "y0", ",", "w", ",", "h", "=", "bbox_xywh", "\n", "x1", "=", "x0", "+", "w", "\n", "y1", "=", "y0", "+", "h", "\n", "for", "line", "in", "lines", ":", "\n", "            ", "x0r", ",", "y0r", "=", "line", "[", "0", "]", "\n", "x1r", ",", "y1r", "=", "line", "[", "1", "]", "\n", "pt0", "=", "(", "int", "(", "x0", "+", "x0r", "*", "(", "x1", "-", "x0", ")", ")", ",", "int", "(", "y0", "+", "y0r", "*", "(", "y1", "-", "y0", ")", ")", ")", "\n", "pt1", "=", "(", "int", "(", "x0", "+", "x1r", "*", "(", "x1", "-", "x0", ")", ")", ",", "int", "(", "y0", "+", "y1r", "*", "(", "y1", "-", "y0", ")", ")", ")", "\n", "cv2", ".", "line", "(", "image_bgr", ",", "pt0", ",", "pt1", ",", "color_bgr", ",", "linewidth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsCustomContourVisualizer._bin_code_2_lines": [[231, 298], ["float", "float"], "methods", ["None"], ["", "", "def", "_bin_code_2_lines", "(", "self", ",", "arr", ",", "v", ",", "bin_code", ",", "multi_idx", ",", "Nw", ",", "Nh", ",", "offset", ")", ":", "\n", "        ", "i0", ",", "j0", "=", "offset", "\n", "i", ",", "j", "=", "multi_idx", "\n", "i", "+=", "i0", "\n", "j", "+=", "j0", "\n", "v0", ",", "v1", ",", "v2", ",", "v3", "=", "arr", "[", "i", ",", "j", "]", ",", "arr", "[", "i", "+", "1", ",", "j", "]", ",", "arr", "[", "i", "+", "1", ",", "j", "+", "1", "]", ",", "arr", "[", "i", ",", "j", "+", "1", "]", "\n", "x0i", "=", "float", "(", "j", ")", "/", "Nw", "\n", "y0j", "=", "float", "(", "i", ")", "/", "Nh", "\n", "He", "=", "1.0", "/", "Nh", "\n", "We", "=", "1.0", "/", "Nw", "\n", "if", "(", "bin_code", "==", "1", ")", "or", "(", "bin_code", "==", "14", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "pt1", "=", "(", "x0i", ",", "y0j", "+", "a", "*", "He", ")", "\n", "pt2", "=", "(", "x0i", "+", "b", "*", "We", ",", "y0j", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "2", ")", "or", "(", "bin_code", "==", "13", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "pt1", "=", "(", "x0i", ",", "y0j", "+", "a", "*", "He", ")", "\n", "pt2", "=", "(", "x0i", "+", "b", "*", "We", ",", "y0j", "+", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "3", ")", "or", "(", "bin_code", "==", "12", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "pt1", "=", "(", "x0i", "+", "a", "*", "We", ",", "y0j", ")", "\n", "pt2", "=", "(", "x0i", "+", "b", "*", "We", ",", "y0j", "+", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "4", ")", "or", "(", "bin_code", "==", "11", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "b", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt1", "=", "(", "x0i", "+", "a", "*", "We", ",", "y0j", "+", "He", ")", "\n", "pt2", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b", "*", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "6", ")", "or", "(", "bin_code", "==", "9", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt1", "=", "(", "x0i", ",", "y0j", "+", "a", "*", "He", ")", "\n", "pt2", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b", "*", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "(", "bin_code", "==", "7", ")", "or", "(", "bin_code", "==", "8", ")", ":", "\n", "            ", "a", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "b", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt1", "=", "(", "x0i", "+", "a", "*", "We", ",", "y0j", ")", "\n", "pt2", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b", "*", "He", ")", "\n", "return", "[", "(", "pt1", ",", "pt2", ")", "]", "\n", "", "elif", "bin_code", "==", "5", ":", "\n", "            ", "a1", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "b1", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "pt11", "=", "(", "x0i", ",", "y0j", "+", "a1", "*", "He", ")", "\n", "pt12", "=", "(", "x0i", "+", "b1", "*", "We", ",", "y0j", "+", "He", ")", "\n", "a2", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "b2", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt21", "=", "(", "x0i", "+", "a2", "*", "We", ",", "y0j", ")", "\n", "pt22", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b2", "*", "He", ")", "\n", "return", "[", "(", "pt11", ",", "pt12", ")", ",", "(", "pt21", ",", "pt22", ")", "]", "\n", "", "elif", "bin_code", "==", "10", ":", "\n", "            ", "a1", "=", "(", "v", "-", "v0", ")", "/", "(", "v3", "-", "v0", ")", "\n", "b1", "=", "(", "v", "-", "v0", ")", "/", "(", "v1", "-", "v0", ")", "\n", "pt11", "=", "(", "x0i", "+", "a1", "*", "We", ",", "y0j", ")", "\n", "pt12", "=", "(", "x0i", ",", "y0j", "+", "b1", "*", "He", ")", "\n", "a2", "=", "(", "v", "-", "v1", ")", "/", "(", "v2", "-", "v1", ")", "\n", "b2", "=", "(", "v", "-", "v3", ")", "/", "(", "v2", "-", "v3", ")", "\n", "pt21", "=", "(", "x0i", "+", "a2", "*", "We", ",", "y0j", "+", "He", ")", "\n", "pt22", "=", "(", "x0i", "+", "We", ",", "y0j", "+", "b2", "*", "He", ")", "\n", "return", "[", "(", "pt11", ",", "pt12", ")", ",", "(", "pt21", ",", "pt22", ")", "]", "\n", "", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsFineSegmentationVisualizer.__init__": [[312, 320], ["densepose.DensePoseMaskedColormapResultsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "super", "(", "DensePoseResultsFineSegmentationVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "_extract_i_from_iuvarr", ",", "\n", "_extract_i_from_iuvarr", ",", "\n", "inplace", ",", "\n", "cmap", ",", "\n", "alpha", ",", "\n", "val_scale", "=", "255.0", "/", "DensePoseDataRelative", ".", "N_PART_LABELS", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsUVisualizer.__init__": [[324, 327], ["densepose.DensePoseMaskedColormapResultsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "super", "(", "DensePoseResultsUVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "_extract_u_from_iuvarr", ",", "_extract_i_from_iuvarr", ",", "inplace", ",", "cmap", ",", "alpha", ",", "val_scale", "=", "1.0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseResultsVVisualizer.__init__": [[331, 334], ["densepose.DensePoseMaskedColormapResultsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "super", "(", "DensePoseResultsVVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "_extract_v_from_iuvarr", ",", "_extract_i_from_iuvarr", ",", "inplace", ",", "cmap", ",", "alpha", ",", "val_scale", "=", "1.0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseOutputsFineSegmentationVisualizer.__init__": [[338, 344], ["base.MatrixVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "self", ".", "mask_visualizer", "=", "MatrixVisualizer", "(", "\n", "inplace", "=", "inplace", ",", "\n", "cmap", "=", "cmap", ",", "\n", "val_scale", "=", "255.0", "/", "DensePoseDataRelative", ".", "N_PART_LABELS", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseOutputsFineSegmentationVisualizer.visualize": [[346, 386], ["S.size", "range", "I.size", "S.size", "I.size", "U.size", "S.size", "U.size", "V.size", "S.size", "V.size", "len", "len", "S[].argmax", "In.cpu().numpy().astype", "numpy.zeros", "densepose.DensePoseOutputsFineSegmentationVisualizer.mask_visualizer.visualize", "I[].argmax", "In.cpu().numpy", "In.cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "\n", "self", ",", "image_bgr", ":", "Image", ",", "dp_output_with_bboxes", ":", "Optional", "[", "Tuple", "[", "DensePoseOutput", ",", "Boxes", "]", "]", "\n", ")", "->", "Image", ":", "\n", "        ", "if", "dp_output_with_bboxes", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "densepose_output", ",", "bboxes_xywh", "=", "dp_output_with_bboxes", "\n", "S", "=", "densepose_output", ".", "S", "\n", "I", "=", "densepose_output", ".", "I", "# noqa", "\n", "U", "=", "densepose_output", ".", "U", "\n", "V", "=", "densepose_output", ".", "V", "\n", "N", "=", "S", ".", "size", "(", "0", ")", "\n", "assert", "N", "==", "I", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and I {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "I", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "U", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and U {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "U", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "V", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and V {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "V", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "len", "(", "\n", "bboxes_xywh", "\n", ")", ",", "\"number of bounding boxes {}\"", "\" should be equal to first dim size of outputs {}\"", ".", "format", "(", "\n", "len", "(", "bboxes_xywh", ")", ",", "N", "\n", ")", "\n", "for", "n", "in", "range", "(", "N", ")", ":", "\n", "            ", "Sn", "=", "S", "[", "n", "]", ".", "argmax", "(", "dim", "=", "0", ")", "\n", "In", "=", "I", "[", "n", "]", ".", "argmax", "(", "dim", "=", "0", ")", "*", "(", "Sn", ">", "0", ")", ".", "long", "(", ")", "\n", "matrix", "=", "In", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "matrix", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "[", "matrix", ">", "0", "]", "=", "1", "\n", "bbox_xywh", "=", "bboxes_xywh", "[", "n", "]", "\n", "image_bgr", "=", "self", ".", "mask_visualizer", ".", "visualize", "(", "image_bgr", ",", "mask", ",", "matrix", ",", "bbox_xywh", ")", "\n", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseOutputsUVisualizer.__init__": [[389, 392], ["base.MatrixVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "self", ".", "mask_visualizer", "=", "MatrixVisualizer", "(", "\n", "inplace", "=", "inplace", ",", "cmap", "=", "cmap", ",", "val_scale", "=", "1.0", ",", "alpha", "=", "alpha", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseOutputsUVisualizer.visualize": [[394, 441], ["isinstance", "S.size", "range", "type", "I.size", "S.size", "I.size", "U.size", "S.size", "U.size", "V.size", "S.size", "V.size", "len", "len", "S[].argmax", "In.cpu().numpy().astype", "numpy.zeros", "U[].cpu().numpy().astype", "numpy.zeros", "range", "densepose.DensePoseOutputsUVisualizer.mask_visualizer.visualize", "I[].argmax", "In.cpu().numpy", "U[].cpu().numpy", "[].clip", "In.cpu", "U[].cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "def", "visualize", "(", "\n", "self", ",", "image_bgr", ":", "Image", ",", "dp_output_with_bboxes", ":", "Optional", "[", "Tuple", "[", "DensePoseOutput", ",", "Boxes", "]", "]", "\n", ")", "->", "Image", ":", "\n", "        ", "if", "dp_output_with_bboxes", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "densepose_output", ",", "bboxes_xywh", "=", "dp_output_with_bboxes", "\n", "assert", "isinstance", "(", "\n", "densepose_output", ",", "DensePoseOutput", "\n", ")", ",", "\"DensePoseOutput expected, {} encountered\"", ".", "format", "(", "type", "(", "densepose_output", ")", ")", "\n", "S", "=", "densepose_output", ".", "S", "\n", "I", "=", "densepose_output", ".", "I", "# noqa", "\n", "U", "=", "densepose_output", ".", "U", "\n", "V", "=", "densepose_output", ".", "V", "\n", "N", "=", "S", ".", "size", "(", "0", ")", "\n", "assert", "N", "==", "I", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and I {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "I", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "U", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and U {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "U", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "V", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and V {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "V", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "len", "(", "\n", "bboxes_xywh", "\n", ")", ",", "\"number of bounding boxes {}\"", "\" should be equal to first dim size of outputs {}\"", ".", "format", "(", "\n", "len", "(", "bboxes_xywh", ")", ",", "N", "\n", ")", "\n", "for", "n", "in", "range", "(", "N", ")", ":", "\n", "            ", "Sn", "=", "S", "[", "n", "]", ".", "argmax", "(", "dim", "=", "0", ")", "\n", "In", "=", "I", "[", "n", "]", ".", "argmax", "(", "dim", "=", "0", ")", "*", "(", "Sn", ">", "0", ")", ".", "long", "(", ")", "\n", "segmentation", "=", "In", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "segmentation", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "[", "segmentation", ">", "0", "]", "=", "1", "\n", "Un", "=", "U", "[", "n", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "Uvis", "=", "np", ".", "zeros", "(", "segmentation", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "partId", "in", "range", "(", "Un", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "Uvis", "[", "segmentation", "==", "partId", "]", "=", "Un", "[", "partId", "]", "[", "segmentation", "==", "partId", "]", ".", "clip", "(", "0", ",", "1", ")", "*", "255", "\n", "bbox_xywh", "=", "bboxes_xywh", "[", "n", "]", "\n", "", "image_bgr", "=", "self", ".", "mask_visualizer", ".", "visualize", "(", "image_bgr", ",", "mask", ",", "Uvis", ",", "bbox_xywh", ")", "\n", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseOutputsVVisualizer.__init__": [[444, 447], ["base.MatrixVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "self", ".", "mask_visualizer", "=", "MatrixVisualizer", "(", "\n", "inplace", "=", "inplace", ",", "cmap", "=", "cmap", ",", "val_scale", "=", "1.0", ",", "alpha", "=", "alpha", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseOutputsVVisualizer.visualize": [[449, 496], ["isinstance", "S.size", "range", "type", "I.size", "S.size", "I.size", "U.size", "S.size", "U.size", "V.size", "S.size", "V.size", "len", "len", "S[].argmax", "In.cpu().numpy().astype", "numpy.zeros", "V[].cpu().numpy().astype", "numpy.zeros", "range", "densepose.DensePoseOutputsVVisualizer.mask_visualizer.visualize", "I[].argmax", "V[].cpu().numpy().astype.size", "In.cpu().numpy", "V[].cpu().numpy", "[].clip", "In.cpu", "V[].cpu"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "def", "visualize", "(", "\n", "self", ",", "image_bgr", ":", "Image", ",", "dp_output_with_bboxes", ":", "Optional", "[", "Tuple", "[", "DensePoseOutput", ",", "Boxes", "]", "]", "\n", ")", "->", "Image", ":", "\n", "        ", "if", "dp_output_with_bboxes", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "densepose_output", ",", "bboxes_xywh", "=", "dp_output_with_bboxes", "\n", "assert", "isinstance", "(", "\n", "densepose_output", ",", "DensePoseOutput", "\n", ")", ",", "\"DensePoseOutput expected, {} encountered\"", ".", "format", "(", "type", "(", "densepose_output", ")", ")", "\n", "S", "=", "densepose_output", ".", "S", "\n", "I", "=", "densepose_output", ".", "I", "# noqa", "\n", "U", "=", "densepose_output", ".", "U", "\n", "V", "=", "densepose_output", ".", "V", "\n", "N", "=", "S", ".", "size", "(", "0", ")", "\n", "assert", "N", "==", "I", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and I {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "I", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "U", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and U {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "U", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "V", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"densepose outputs S {} and V {}\"", "\" should have equal first dim size\"", ".", "format", "(", "\n", "S", ".", "size", "(", ")", ",", "V", ".", "size", "(", ")", "\n", ")", "\n", "assert", "N", "==", "len", "(", "\n", "bboxes_xywh", "\n", ")", ",", "\"number of bounding boxes {}\"", "\" should be equal to first dim size of outputs {}\"", ".", "format", "(", "\n", "len", "(", "bboxes_xywh", ")", ",", "N", "\n", ")", "\n", "for", "n", "in", "range", "(", "N", ")", ":", "\n", "            ", "Sn", "=", "S", "[", "n", "]", ".", "argmax", "(", "dim", "=", "0", ")", "\n", "In", "=", "I", "[", "n", "]", ".", "argmax", "(", "dim", "=", "0", ")", "*", "(", "Sn", ">", "0", ")", ".", "long", "(", ")", "\n", "segmentation", "=", "In", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "segmentation", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "[", "segmentation", ">", "0", "]", "=", "1", "\n", "Vn", "=", "V", "[", "n", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "Vvis", "=", "np", ".", "zeros", "(", "segmentation", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "partId", "in", "range", "(", "Vn", ".", "size", "(", "0", ")", ")", ":", "\n", "                ", "Vvis", "[", "segmentation", "==", "partId", "]", "=", "Vn", "[", "partId", "]", "[", "segmentation", "==", "partId", "]", ".", "clip", "(", "0", ",", "1", ")", "*", "255", "\n", "", "bbox_xywh", "=", "bboxes_xywh", "[", "n", "]", "\n", "image_bgr", "=", "self", ".", "mask_visualizer", ".", "visualize", "(", "image_bgr", ",", "mask", ",", "Vvis", ",", "bbox_xywh", ")", "\n", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataCoarseSegmentationVisualizer.__init__": [[503, 509], ["base.MatrixVisualizer"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "inplace", "=", "True", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ",", "alpha", "=", "0.7", ")", ":", "\n", "        ", "self", ".", "mask_visualizer", "=", "MatrixVisualizer", "(", "\n", "inplace", "=", "inplace", ",", "\n", "cmap", "=", "cmap", ",", "\n", "val_scale", "=", "255.0", "/", "DensePoseDataRelative", ".", "N_BODY_PARTS", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataCoarseSegmentationVisualizer.visualize": [[511, 524], ["zip", "densepose_data.segm.numpy", "numpy.zeros", "densepose.DensePoseDataCoarseSegmentationVisualizer.mask_visualizer.visualize", "bbox_xywh.numpy"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "\n", "self", ",", "\n", "image_bgr", ":", "Image", ",", "\n", "bbox_densepose_datas", ":", "Optional", "[", "Tuple", "[", "Iterable", "[", "Boxes", "]", ",", "Iterable", "[", "DensePoseDataRelative", "]", "]", "]", ",", "\n", ")", "->", "Image", ":", "\n", "        ", "if", "bbox_densepose_datas", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "for", "bbox_xywh", ",", "densepose_data", "in", "zip", "(", "*", "bbox_densepose_datas", ")", ":", "\n", "            ", "matrix", "=", "densepose_data", ".", "segm", ".", "numpy", "(", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "matrix", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "mask", "[", "matrix", ">", "0", "]", "=", "1", "\n", "image_bgr", "=", "self", ".", "mask_visualizer", ".", "visualize", "(", "image_bgr", ",", "mask", ",", "matrix", ",", "bbox_xywh", ".", "numpy", "(", ")", ")", "\n", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.__init__": [[527, 531], ["base.PointsVisualizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "densepose_data_to_value_fn", "=", "None", ",", "cmap", "=", "cv2", ".", "COLORMAP_PARULA", ")", ":", "\n", "        ", "self", ".", "points_visualizer", "=", "PointsVisualizer", "(", ")", "\n", "self", ".", "densepose_data_to_value_fn", "=", "densepose_data_to_value_fn", "\n", "self", ".", "cmap", "=", "cmap", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize": [[532, 554], ["zip", "bbox_xywh.numpy", "zip", "densepose.DensePoseDataPointsVisualizer.points_visualizer.visualize", "densepose.DensePoseDataPointsVisualizer.densepose_data_to_value_fn", "cv2.applyColorMap", "densepose.DensePoseDataPointsVisualizer.points_visualizer.visualize", "densepose_data.x.numpy", "densepose_data.y.numpy", "int", "img_color_bgr.ravel"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize", "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVisualizer.visualize"], ["", "def", "visualize", "(", "\n", "self", ",", "\n", "image_bgr", ":", "Image", ",", "\n", "bbox_densepose_datas", ":", "Optional", "[", "Tuple", "[", "Iterable", "[", "Boxes", "]", ",", "Iterable", "[", "DensePoseDataRelative", "]", "]", "]", ",", "\n", ")", "->", "Image", ":", "\n", "        ", "if", "bbox_densepose_datas", "is", "None", ":", "\n", "            ", "return", "image_bgr", "\n", "", "for", "bbox_xywh", ",", "densepose_data", "in", "zip", "(", "*", "bbox_densepose_datas", ")", ":", "\n", "            ", "x0", ",", "y0", ",", "w", ",", "h", "=", "bbox_xywh", ".", "numpy", "(", ")", "\n", "x", "=", "densepose_data", ".", "x", ".", "numpy", "(", ")", "*", "w", "/", "255.0", "+", "x0", "\n", "y", "=", "densepose_data", ".", "y", ".", "numpy", "(", ")", "*", "h", "/", "255.0", "+", "y0", "\n", "pts_xy", "=", "zip", "(", "x", ",", "y", ")", "\n", "if", "self", ".", "densepose_data_to_value_fn", "is", "None", ":", "\n", "                ", "image_bgr", "=", "self", ".", "points_visualizer", ".", "visualize", "(", "image_bgr", ",", "pts_xy", ")", "\n", "", "else", ":", "\n", "                ", "v", "=", "self", ".", "densepose_data_to_value_fn", "(", "densepose_data", ")", "\n", "img_colors_bgr", "=", "cv2", ".", "applyColorMap", "(", "v", ",", "self", ".", "cmap", ")", "\n", "colors_bgr", "=", "[", "\n", "[", "int", "(", "v", ")", "for", "v", "in", "img_color_bgr", ".", "ravel", "(", ")", "]", "for", "img_color_bgr", "in", "img_colors_bgr", "\n", "]", "\n", "image_bgr", "=", "self", ".", "points_visualizer", ".", "visualize", "(", "image_bgr", ",", "pts_xy", ",", "colors_bgr", ")", "\n", "", "", "return", "image_bgr", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsUVisualizer.__init__": [[576, 579], ["densepose.DensePoseDataPointsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DensePoseDataPointsUVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "densepose_data_to_value_fn", "=", "_densepose_data_u_for_cmap", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsVVisualizer.__init__": [[583, 586], ["densepose.DensePoseDataPointsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DensePoseDataPointsVVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "densepose_data_to_value_fn", "=", "_densepose_data_v_for_cmap", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose.DensePoseDataPointsIVisualizer.__init__": [[590, 593], ["densepose.DensePoseDataPointsVisualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DensePoseDataPointsIVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "densepose_data_to_value_fn", "=", "_densepose_data_i_for_cmap", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._extract_i_from_iuvarr": [[59, 61], ["None"], "function", ["None"], ["", "", "def", "_extract_i_from_iuvarr", "(", "iuv_arr", ")", ":", "\n", "    ", "return", "iuv_arr", "[", "0", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._extract_u_from_iuvarr": [[63, 65], ["None"], "function", ["None"], ["", "def", "_extract_u_from_iuvarr", "(", "iuv_arr", ")", ":", "\n", "    ", "return", "iuv_arr", "[", "1", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._extract_v_from_iuvarr": [[67, 69], ["None"], "function", ["None"], ["", "def", "_extract_v_from_iuvarr", "(", "iuv_arr", ")", ":", "\n", "    ", "return", "iuv_arr", "[", "2", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._densepose_data_u_for_cmap": [[556, 559], ["u.astype", "numpy.clip", "densepose_data.u.numpy"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "", "def", "_densepose_data_u_for_cmap", "(", "densepose_data", ")", ":", "\n", "    ", "u", "=", "np", ".", "clip", "(", "densepose_data", ".", "u", ".", "numpy", "(", ")", ",", "0", ",", "1", ")", "*", "255.0", "\n", "return", "u", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._densepose_data_v_for_cmap": [[561, 564], ["v.astype", "numpy.clip", "densepose_data.v.numpy"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "def", "_densepose_data_v_for_cmap", "(", "densepose_data", ")", ":", "\n", "    ", "v", "=", "np", ".", "clip", "(", "densepose_data", ".", "v", ".", "numpy", "(", ")", ",", "0", ",", "1", ")", "*", "255.0", "\n", "return", "v", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.vis.densepose._densepose_data_i_for_cmap": [[566, 573], ["i.astype", "numpy.clip", "densepose_data.i.numpy"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "def", "_densepose_data_i_for_cmap", "(", "densepose_data", ")", ":", "\n", "    ", "i", "=", "(", "\n", "np", ".", "clip", "(", "densepose_data", ".", "i", ".", "numpy", "(", ")", ",", "0.0", ",", "DensePoseDataRelative", ".", "N_PART_LABELS", ")", "\n", "*", "255.0", "\n", "/", "DensePoseDataRelative", ".", "N_PART_LABELS", "\n", ")", "\n", "return", "i", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.TridentNet.train_net.Trainer.build_evaluator": [[21, 26], ["detectron2.evaluation.COCOEvaluator", "os.path.join"], "methods", ["None"], ["from", "collections", "import", "OrderedDict", "\n", "import", "torch", "\n", "\n", "import", "detectron2", ".", "utils", ".", "comm", "as", "comm", "\n", "from", "detectron2", ".", "checkpoint", "import", "DetectionCheckpointer", "\n", "from", "detectron2", ".", "config", "import", "get_cfg", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.TridentNet.train_net.setup": [[28, 39], ["detectron2.config.get_cfg", "tridentnet.add_tridentnet_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.config.add_tridentnet_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup"], ["from", "detectron2", ".", "engine", "import", "DefaultTrainer", ",", "default_argument_parser", ",", "default_setup", ",", "hooks", ",", "launch", "\n", "from", "detectron2", ".", "evaluation", "import", "(", "\n", "CityscapesInstanceEvaluator", ",", "\n", "CityscapesSemSegEvaluator", ",", "\n", "COCOEvaluator", ",", "\n", "COCOPanopticEvaluator", ",", "\n", "DatasetEvaluators", ",", "\n", "LVISEvaluator", ",", "\n", "PascalVOCDetectionEvaluator", ",", "\n", "SemSegEvaluator", ",", "\n", "verify_results", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.TridentNet.train_net.main": [[41, 55], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test"], ["\n", "\n", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "    ", "\"\"\"\n    We use the \"DefaultTrainer\" which contains pre-defined default logic for\n    standard training workflow. They may not work for you, especially if you\n    are working on a new research project. In that case you can write your\n    own training loop. You can use \"tools/plain_train_net.py\" as an example.\n    \"\"\"", "\n", "\n", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.config.add_tridentnet_config": [[7, 27], ["detectron2.config.CfgNode"], "function", ["None"], ["from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_rpn.TridentRPN.__init__": [[15, 20], ["detectron2.modeling.proposal_generator.rpn.RPN.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "TridentRPN", ",", "self", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "self", ".", "num_branch", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "NUM_BRANCH", "\n", "self", ".", "trident_fast", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TEST_BRANCH_IDX", "!=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_rpn.TridentRPN.forward": [[21, 33], ["detectron2.structures.ImageList", "super().forward", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "gt_instances", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        See :class:`RPN.forward`.\n        \"\"\"", "\n", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "not", "self", ".", "trident_fast", "else", "1", "\n", "# Duplicate images and gt_instances for all branches in TridentNet.", "\n", "all_images", "=", "ImageList", "(", "\n", "torch", ".", "cat", "(", "[", "images", ".", "tensor", "]", "*", "num_branch", ")", ",", "images", ".", "image_sizes", "*", "num_branch", "\n", ")", "\n", "all_gt_instances", "=", "gt_instances", "*", "num_branch", "if", "gt_instances", "is", "not", "None", "else", "None", "\n", "\n", "return", "super", "(", "TridentRPN", ",", "self", ")", ".", "forward", "(", "all_images", ",", "features", ",", "all_gt_instances", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_conv.TridentConv.__init__": [[11, 57], ["torch.nn.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "isinstance", "isinstance", "torch.nn.Parameter", "torch.nn.init.kaiming_uniform_", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "len", "torch.Tensor", "torch.nn.Parameter", "torch.nn.init.constant_", "torch.Tensor", "len", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "paddings", "=", "0", ",", "\n", "dilations", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "num_branch", "=", "1", ",", "\n", "test_branch_idx", "=", "-", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "None", ",", "\n", "activation", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "TridentConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "num_branch", "=", "num_branch", "\n", "self", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "with_bias", "=", "bias", "\n", "if", "isinstance", "(", "paddings", ",", "int", ")", ":", "\n", "            ", "paddings", "=", "[", "paddings", "]", "*", "self", ".", "num_branch", "\n", "", "if", "isinstance", "(", "dilations", ",", "int", ")", ":", "\n", "            ", "dilations", "=", "[", "dilations", "]", "*", "self", ".", "num_branch", "\n", "", "self", ".", "paddings", "=", "[", "_pair", "(", "padding", ")", "for", "padding", "in", "paddings", "]", "\n", "self", ".", "dilations", "=", "[", "_pair", "(", "dilation", ")", "for", "dilation", "in", "dilations", "]", "\n", "self", ".", "test_branch_idx", "=", "test_branch_idx", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "assert", "len", "(", "{", "self", ".", "num_branch", ",", "len", "(", "self", ".", "paddings", ")", ",", "len", "(", "self", ".", "dilations", ")", "}", ")", "==", "1", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "groups", ",", "*", "self", ".", "kernel_size", ")", "\n", ")", "\n", "if", "bias", ":", "\n", "            ", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_channels", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bias", "=", "None", "\n", "\n", "", "nn", ".", "init", ".", "kaiming_uniform_", "(", "self", ".", "weight", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_conv.TridentConv.forward": [[58, 95], ["len", "inputs[].numel", "detectron2.layers.wrappers._NewEmptyTensorOp.apply", "torch.nn.functional.conv2d", "torch.nn.functional.conv2d", "trident_conv.TridentConv.norm", "trident_conv.TridentConv.activation", "zip", "zip"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "self", ".", "test_branch_idx", "==", "-", "1", "else", "1", "\n", "assert", "len", "(", "inputs", ")", "==", "num_branch", "\n", "\n", "if", "inputs", "[", "0", "]", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "s", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "s", "in", "zip", "(", "\n", "inputs", "[", "0", "]", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "input", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "[", "_NewEmptyTensorOp", ".", "apply", "(", "input", ",", "output_shape", ")", "for", "input", "in", "inputs", "]", "\n", "\n", "", "if", "self", ".", "training", "or", "self", ".", "test_branch_idx", "==", "-", "1", ":", "\n", "            ", "outputs", "=", "[", "\n", "F", ".", "conv2d", "(", "input", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "padding", ",", "dilation", ",", "self", ".", "groups", ")", "\n", "for", "input", ",", "dilation", ",", "padding", "in", "zip", "(", "inputs", ",", "self", ".", "dilations", ",", "self", ".", "paddings", ")", "\n", "]", "\n", "", "else", ":", "\n", "            ", "outputs", "=", "[", "\n", "F", ".", "conv2d", "(", "\n", "inputs", "[", "0", "]", ",", "\n", "self", ".", "weight", ",", "\n", "self", ".", "bias", ",", "\n", "self", ".", "stride", ",", "\n", "self", ".", "paddings", "[", "self", ".", "test_branch_idx", "]", ",", "\n", "self", ".", "dilations", "[", "self", ".", "test_branch_idx", "]", ",", "\n", "self", ".", "groups", ",", "\n", ")", "\n", "]", "\n", "\n", "", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "outputs", "=", "[", "self", ".", "norm", "(", "x", ")", "for", "x", "in", "outputs", "]", "\n", "", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "            ", "outputs", "=", "[", "self", ".", "activation", "(", "x", ")", "for", "x", "in", "outputs", "]", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_conv.TridentConv.extra_repr": [[96, 108], ["str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "\"in_channels=\"", "+", "str", "(", "self", ".", "in_channels", ")", "\n", "tmpstr", "+=", "\", out_channels=\"", "+", "str", "(", "self", ".", "out_channels", ")", "\n", "tmpstr", "+=", "\", kernel_size=\"", "+", "str", "(", "self", ".", "kernel_size", ")", "\n", "tmpstr", "+=", "\", num_branch=\"", "+", "str", "(", "self", ".", "num_branch", ")", "\n", "tmpstr", "+=", "\", test_branch_idx=\"", "+", "str", "(", "self", ".", "test_branch_idx", ")", "\n", "tmpstr", "+=", "\", stride=\"", "+", "str", "(", "self", ".", "stride", ")", "\n", "tmpstr", "+=", "\", paddings=\"", "+", "str", "(", "self", ".", "paddings", ")", "\n", "tmpstr", "+=", "\", dilations=\"", "+", "str", "(", "self", ".", "dilations", ")", "\n", "tmpstr", "+=", "\", groups=\"", "+", "str", "(", "self", ".", "groups", ")", "\n", "tmpstr", "+=", "\", bias=\"", "+", "str", "(", "self", ".", "with_bias", ")", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_backbone.TridentBottleneckBlock.__init__": [[16, 94], ["detectron2.modeling.ResNetBlockBase.__init__", "detectron2.layers.Conv2d", "trident_conv.TridentConv", "detectron2.layers.Conv2d", "len", "detectron2.layers.Conv2d", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "detectron2.layers.get_norm", "fvcore.c2_msra_fill", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.get_norm"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "*", ",", "\n", "bottleneck_channels", ",", "\n", "stride", "=", "1", ",", "\n", "num_groups", "=", "1", ",", "\n", "norm", "=", "\"BN\"", ",", "\n", "stride_in_1x1", "=", "False", ",", "\n", "num_branch", "=", "3", ",", "\n", "dilations", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "concat_output", "=", "False", ",", "\n", "test_branch_idx", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            num_branch (int): the number of branches in TridentNet.\n            dilations (tuple): the dilations of multiple branches in TridentNet.\n            concat_output (bool): if concatenate outputs of multiple branches in TridentNet.\n                Use 'True' for the last trident block.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "stride", ")", "\n", "\n", "assert", "num_branch", "==", "len", "(", "dilations", ")", "\n", "\n", "self", ".", "num_branch", "=", "num_branch", "\n", "self", ".", "concat_output", "=", "concat_output", "\n", "self", ".", "test_branch_idx", "=", "test_branch_idx", "\n", "\n", "if", "in_channels", "!=", "out_channels", ":", "\n", "            ", "self", ".", "shortcut", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut", "=", "None", "\n", "\n", "", "stride_1x1", ",", "stride_3x3", "=", "(", "stride", ",", "1", ")", "if", "stride_in_1x1", "else", "(", "1", ",", "stride", ")", "\n", "\n", "self", ".", "conv1", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride_1x1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv2", "=", "TridentConv", "(", "\n", "bottleneck_channels", ",", "\n", "bottleneck_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride_3x3", ",", "\n", "paddings", "=", "dilations", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "num_groups", ",", "\n", "dilations", "=", "dilations", ",", "\n", "num_branch", "=", "num_branch", ",", "\n", "test_branch_idx", "=", "test_branch_idx", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "bottleneck_channels", ")", ",", "\n", ")", "\n", "\n", "self", ".", "conv3", "=", "Conv2d", "(", "\n", "bottleneck_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm", "=", "get_norm", "(", "norm", ",", "out_channels", ")", ",", "\n", ")", "\n", "\n", "for", "layer", "in", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "shortcut", "]", ":", "\n", "            ", "if", "layer", "is", "not", "None", ":", "# shortcut can be None", "\n", "                ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_backbone.TridentBottleneckBlock.forward": [[95, 117], ["trident_backbone.TridentBottleneckBlock.conv2", "isinstance", "trident_backbone.TridentBottleneckBlock.conv1", "torch.relu_", "torch.relu_", "torch.relu_", "torch.relu_", "trident_backbone.TridentBottleneckBlock.conv3", "torch.relu_", "torch.relu_", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "trident_backbone.TridentBottleneckBlock.shortcut", "zip"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "self", ".", "test_branch_idx", "==", "-", "1", "else", "1", "\n", "if", "not", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "            ", "x", "=", "[", "x", "]", "*", "num_branch", "\n", "", "out", "=", "[", "self", ".", "conv1", "(", "b", ")", "for", "b", "in", "x", "]", "\n", "out", "=", "[", "F", ".", "relu_", "(", "b", ")", "for", "b", "in", "out", "]", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "[", "F", ".", "relu_", "(", "b", ")", "for", "b", "in", "out", "]", "\n", "\n", "out", "=", "[", "self", ".", "conv3", "(", "b", ")", "for", "b", "in", "out", "]", "\n", "\n", "if", "self", ".", "shortcut", "is", "not", "None", ":", "\n", "            ", "shortcut", "=", "[", "self", ".", "shortcut", "(", "b", ")", "for", "b", "in", "x", "]", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", "\n", "\n", "", "out", "=", "[", "out_b", "+", "shortcut_b", "for", "out_b", ",", "shortcut_b", "in", "zip", "(", "out", ",", "shortcut", ")", "]", "\n", "out", "=", "[", "F", ".", "relu_", "(", "b", ")", "for", "b", "in", "out", "]", "\n", "if", "self", ".", "concat_output", ":", "\n", "            ", "out", "=", "torch", ".", "cat", "(", "out", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_backbone.make_trident_stage": [[119, 129], ["range", "blocks.append", "blocks.append", "block_class", "block_class"], "function", ["None"], ["", "", "def", "make_trident_stage", "(", "block_class", ",", "num_blocks", ",", "first_stride", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a resnet stage by creating many blocks for TridentNet.\n    \"\"\"", "\n", "blocks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_blocks", "-", "1", ")", ":", "\n", "        ", "blocks", ".", "append", "(", "block_class", "(", "stride", "=", "first_stride", "if", "i", "==", "0", "else", "1", ",", "**", "kwargs", ")", ")", "\n", "kwargs", "[", "\"in_channels\"", "]", "=", "kwargs", "[", "\"out_channels\"", "]", "\n", "", "blocks", ".", "append", "(", "block_class", "(", "stride", "=", "1", ",", "concat_output", "=", "True", ",", "**", "kwargs", ")", ")", "\n", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_backbone.build_trident_resnet_backbone": [[131, 224], ["detectron2.modeling.BACKBONE_REGISTRY.register", "detectron2.modeling.backbone.resnet.BasicStem", "max", "enumerate", "detectron2.modeling.ResNet", "FrozenBatchNorm2d.convert_frozen_batchnorm.parameters", "detectron2.layers.FrozenBatchNorm2d.convert_frozen_batchnorm", "range", "stages.append", "stage_kargs.pop", "trident_backbone.make_trident_stage", "detectron2.modeling.make_stage", "block.freeze"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build._BootstrapDatasetFactoryCatalog.register", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.batch_norm.FrozenBatchNorm2d.convert_frozen_batchnorm", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_backbone.make_trident_stage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.backbone.resnet.make_stage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_trident_resnet_backbone", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Create a ResNet instance from config for TridentNet.\n\n    Returns:\n        ResNet: a :class:`ResNet` instance.\n    \"\"\"", "\n", "# need registration of new blocks/stems?", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NORM", "\n", "stem", "=", "BasicStem", "(", "\n", "in_channels", "=", "input_shape", ".", "channels", ",", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", ",", "\n", "norm", "=", "norm", ",", "\n", ")", "\n", "freeze_at", "=", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "FREEZE_AT", "\n", "\n", "if", "freeze_at", ">=", "1", ":", "\n", "        ", "for", "p", "in", "stem", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "", "stem", "=", "FrozenBatchNorm2d", ".", "convert_frozen_batchnorm", "(", "stem", ")", "\n", "\n", "# fmt: off", "\n", "", "out_features", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "OUT_FEATURES", "\n", "depth", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEPTH", "\n", "num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "NUM_GROUPS", "\n", "width_per_group", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "WIDTH_PER_GROUP", "\n", "bottleneck_channels", "=", "num_groups", "*", "width_per_group", "\n", "in_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STEM_OUT_CHANNELS", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES2_OUT_CHANNELS", "\n", "stride_in_1x1", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "STRIDE_IN_1X1", "\n", "res5_dilation", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "RES5_DILATION", "\n", "deform_on_per_stage", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_ON_PER_STAGE", "\n", "deform_modulated", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_MODULATED", "\n", "deform_num_groups", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "DEFORM_NUM_GROUPS", "\n", "num_branch", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "NUM_BRANCH", "\n", "branch_dilations", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "BRANCH_DILATIONS", "\n", "trident_stage", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TRIDENT_STAGE", "\n", "test_branch_idx", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TEST_BRANCH_IDX", "\n", "# fmt: on", "\n", "assert", "res5_dilation", "in", "{", "1", ",", "2", "}", ",", "\"res5_dilation cannot be {}.\"", ".", "format", "(", "res5_dilation", ")", "\n", "\n", "num_blocks_per_stage", "=", "{", "50", ":", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "101", ":", "[", "3", ",", "4", ",", "23", ",", "3", "]", ",", "152", ":", "[", "3", ",", "8", ",", "36", ",", "3", "]", "}", "[", "depth", "]", "\n", "\n", "stages", "=", "[", "]", "\n", "\n", "res_stage_idx", "=", "{", "\"res2\"", ":", "2", ",", "\"res3\"", ":", "3", ",", "\"res4\"", ":", "4", ",", "\"res5\"", ":", "5", "}", "\n", "out_stage_idx", "=", "[", "res_stage_idx", "[", "f", "]", "for", "f", "in", "out_features", "]", "\n", "trident_stage_idx", "=", "res_stage_idx", "[", "trident_stage", "]", "\n", "max_stage_idx", "=", "max", "(", "out_stage_idx", ")", "\n", "for", "idx", ",", "stage_idx", "in", "enumerate", "(", "range", "(", "2", ",", "max_stage_idx", "+", "1", ")", ")", ":", "\n", "        ", "dilation", "=", "res5_dilation", "if", "stage_idx", "==", "5", "else", "1", "\n", "first_stride", "=", "1", "if", "idx", "==", "0", "or", "(", "stage_idx", "==", "5", "and", "dilation", "==", "2", ")", "else", "2", "\n", "stage_kargs", "=", "{", "\n", "\"num_blocks\"", ":", "num_blocks_per_stage", "[", "idx", "]", ",", "\n", "\"first_stride\"", ":", "first_stride", ",", "\n", "\"in_channels\"", ":", "in_channels", ",", "\n", "\"bottleneck_channels\"", ":", "bottleneck_channels", ",", "\n", "\"out_channels\"", ":", "out_channels", ",", "\n", "\"num_groups\"", ":", "num_groups", ",", "\n", "\"norm\"", ":", "norm", ",", "\n", "\"stride_in_1x1\"", ":", "stride_in_1x1", ",", "\n", "\"dilation\"", ":", "dilation", ",", "\n", "}", "\n", "if", "stage_idx", "==", "trident_stage_idx", ":", "\n", "            ", "assert", "not", "deform_on_per_stage", "[", "\n", "idx", "\n", "]", ",", "\"Not support deformable conv in Trident blocks yet.\"", "\n", "stage_kargs", "[", "\"block_class\"", "]", "=", "TridentBottleneckBlock", "\n", "stage_kargs", "[", "\"num_branch\"", "]", "=", "num_branch", "\n", "stage_kargs", "[", "\"dilations\"", "]", "=", "branch_dilations", "\n", "stage_kargs", "[", "\"test_branch_idx\"", "]", "=", "test_branch_idx", "\n", "stage_kargs", ".", "pop", "(", "\"dilation\"", ")", "\n", "", "elif", "deform_on_per_stage", "[", "idx", "]", ":", "\n", "            ", "stage_kargs", "[", "\"block_class\"", "]", "=", "DeformBottleneckBlock", "\n", "stage_kargs", "[", "\"deform_modulated\"", "]", "=", "deform_modulated", "\n", "stage_kargs", "[", "\"deform_num_groups\"", "]", "=", "deform_num_groups", "\n", "", "else", ":", "\n", "            ", "stage_kargs", "[", "\"block_class\"", "]", "=", "BottleneckBlock", "\n", "", "blocks", "=", "(", "\n", "make_trident_stage", "(", "**", "stage_kargs", ")", "\n", "if", "stage_idx", "==", "trident_stage_idx", "\n", "else", "make_stage", "(", "**", "stage_kargs", ")", "\n", ")", "\n", "in_channels", "=", "out_channels", "\n", "out_channels", "*=", "2", "\n", "bottleneck_channels", "*=", "2", "\n", "\n", "if", "freeze_at", ">=", "stage_idx", ":", "\n", "            ", "for", "block", "in", "blocks", ":", "\n", "                ", "block", ".", "freeze", "(", ")", "\n", "", "", "stages", ".", "append", "(", "blocks", ")", "\n", "", "return", "ResNet", "(", "stem", ",", "stages", ",", "out_features", "=", "out_features", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_rcnn.TridentRes5ROIHeads.__init__": [[54, 59], ["detectron2.modeling.roi_heads.roi_heads.Res5ROIHeads.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "self", ".", "num_branch", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "NUM_BRANCH", "\n", "self", ".", "trident_fast", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TEST_BRANCH_IDX", "!=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_rcnn.TridentRes5ROIHeads.forward": [[60, 80], ["super().forward", "trident_rcnn.merge_branch_instances"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_rcnn.merge_branch_instances"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        See :class:`Res5ROIHeads.forward`.\n        \"\"\"", "\n", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "not", "self", ".", "trident_fast", "else", "1", "\n", "all_targets", "=", "targets", "*", "num_branch", "if", "targets", "is", "not", "None", "else", "None", "\n", "pred_instances", ",", "losses", "=", "super", "(", ")", ".", "forward", "(", "images", ",", "features", ",", "proposals", ",", "all_targets", ")", "\n", "del", "images", ",", "all_targets", ",", "targets", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "pred_instances", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", "=", "merge_branch_instances", "(", "\n", "pred_instances", ",", "\n", "num_branch", ",", "\n", "self", ".", "box_predictor", ".", "test_nms_thresh", ",", "\n", "self", ".", "box_predictor", ".", "test_topk_per_image", ",", "\n", ")", "\n", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_rcnn.TridentStandardROIHeads.__init__": [[89, 94], ["detectron2.modeling.StandardROIHeads.__init__"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "TridentStandardROIHeads", ",", "self", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "self", ".", "num_branch", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "NUM_BRANCH", "\n", "self", ".", "trident_fast", "=", "cfg", ".", "MODEL", ".", "TRIDENT", ".", "TEST_BRANCH_IDX", "!=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_rcnn.TridentStandardROIHeads.forward": [[95, 117], ["super().forward", "trident_rcnn.merge_branch_instances"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_rcnn.merge_branch_instances"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        See :class:`Res5ROIHeads.forward`.\n        \"\"\"", "\n", "# Use 1 branch if using trident_fast during inference.", "\n", "num_branch", "=", "self", ".", "num_branch", "if", "self", ".", "training", "or", "not", "self", ".", "trident_fast", "else", "1", "\n", "# Duplicate targets for all branches in TridentNet.", "\n", "all_targets", "=", "targets", "*", "num_branch", "if", "targets", "is", "not", "None", "else", "None", "\n", "pred_instances", ",", "losses", "=", "super", "(", ")", ".", "forward", "(", "images", ",", "features", ",", "proposals", ",", "all_targets", ")", "\n", "del", "images", ",", "all_targets", ",", "targets", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "pred_instances", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", "=", "merge_branch_instances", "(", "\n", "pred_instances", ",", "\n", "num_branch", ",", "\n", "self", ".", "box_predictor", ".", "test_nms_thresh", ",", "\n", "self", ".", "box_predictor", ".", "test_topk_per_image", ",", "\n", ")", "\n", "\n", "return", "pred_instances", ",", "{", "}", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.tridentnet.trident_rcnn.merge_branch_instances": [[8, 45], ["range", "len", "detectron2.structures.Instances.cat", "detectron2.layers.batched_nms", "results.append", "range"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.nms.batched_nms"], ["def", "merge_branch_instances", "(", "instances", ",", "num_branch", ",", "nms_thresh", ",", "topk_per_image", ")", ":", "\n", "    ", "\"\"\"\n    Merge detection results from different branches of TridentNet.\n    Return detection results by applying non-maximum suppression (NMS) on bounding boxes\n    and keep the unsuppressed boxes and other instances (e.g mask) if any.\n\n    Args:\n        instances (list[Instances]): A list of N * num_branch instances that store detection\n            results. Contain N images and each image has num_branch instances.\n        num_branch (int): Number of branches used for merging detection results for each image.\n        nms_thresh (float):  The threshold to use for box non-maximum suppression. Value in [0, 1].\n        topk_per_image (int): The number of top scoring detections to return. Set < 0 to return\n            all detections.\n\n    Returns:\n        results: (list[Instances]): A list of N instances, one for each image in the batch,\n            that stores the topk most confidence detections after merging results from multiple\n            branches.\n    \"\"\"", "\n", "if", "num_branch", "==", "1", ":", "\n", "        ", "return", "instances", "\n", "\n", "", "batch_size", "=", "len", "(", "instances", ")", "//", "num_branch", "\n", "results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "instance", "=", "Instances", ".", "cat", "(", "[", "instances", "[", "i", "+", "batch_size", "*", "j", "]", "for", "j", "in", "range", "(", "num_branch", ")", "]", ")", "\n", "\n", "# Apply per-class NMS", "\n", "keep", "=", "batched_nms", "(", "\n", "instance", ".", "pred_boxes", ".", "tensor", ",", "instance", ".", "scores", ",", "instance", ".", "pred_classes", ",", "nms_thresh", "\n", ")", "\n", "keep", "=", "keep", "[", ":", "topk_per_image", "]", "\n", "result", "=", "instance", "[", "keep", "]", "\n", "\n", "results", ".", "append", "(", "result", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.Trainer.build_evaluator": [[60, 103], ["detectron2.evaluation.DatasetEvaluators", "detectron2.evaluation.DatasetEvaluators", "os.path.join", "detectron2.data.MetadataCatalog.get", "detectron2.data.MetadataCatalog.get", "detectron2.evaluation.LVISEvaluator", "detectron2.evaluation.LVISEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.COCOEvaluator", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.SemSegEvaluator", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesInstanceEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "detectron2.evaluation.CityscapesSemSegEvaluator", "len", "NotImplementedError", "len", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.get_rank", "torch.cuda.device_count", "detectron2.get_rank", "detectron2.get_rank"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.get_rank"], ["            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "", "evaluator_list", "=", "[", "]", "\n", "evaluator_type", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", ".", "evaluator_type", "\n", "if", "evaluator_type", "in", "[", "\"sem_seg\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "\n", "SemSegEvaluator", "(", "\n", "dataset_name", ",", "\n", "distributed", "=", "True", ",", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", ",", "\n", "ignore_label", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", ",", "\n", "output_dir", "=", "output_folder", ",", "\n", ")", "\n", ")", "\n", "", "if", "evaluator_type", "in", "[", "\"coco\"", ",", "\"coco_panoptic_seg\"", "]", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"coco_panoptic_seg\"", ":", "\n", "            ", "evaluator_list", ".", "append", "(", "COCOPanopticEvaluator", "(", "dataset_name", ",", "output_folder", ")", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_instance\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesInstanceEvaluator", "(", "dataset_name", ")", "\n", "", "if", "evaluator_type", "==", "\"cityscapes_sem_seg\"", ":", "\n", "            ", "assert", "(", "\n", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "comm", ".", "get_rank", "(", ")", "\n", ")", ",", "\"CityscapesEvaluator currently do not work with multiple machines.\"", "\n", "return", "CityscapesSemSegEvaluator", "(", "dataset_name", ")", "\n", "", "elif", "evaluator_type", "==", "\"pascal_voc\"", ":", "\n", "            ", "return", "PascalVOCDetectionEvaluator", "(", "dataset_name", ",", "cfg", ")", "\n", "", "elif", "evaluator_type", "==", "\"lvis\"", ":", "\n", "            ", "return", "LVISEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "", "if", "len", "(", "evaluator_list", ")", "==", "0", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"no Evaluator for the dataset {} with the type {}\"", ".", "format", "(", "\n", "dataset_name", ",", "evaluator_type", "\n", ")", "\n", ")", "\n", "", "elif", "len", "(", "evaluator_list", ")", "==", "1", ":", "\n", "            ", "return", "evaluator_list", "[", "0", "]", "\n", "", "return", "DatasetEvaluators", "(", "evaluator_list", ")", "\n", "\n", "", "@", "classmethod", "\n", "def", "test_with_TTA", "(", "cls", ",", "cfg", ",", "model", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "\"detectron2.trainer\"", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.Trainer.build_train_loader": [[104, 111], ["detectron2.data.build_detection_train_loader", "detectron2.data.build_detection_train_loader", "detectron2.data.DatasetMapper", "detectron2.data.DatasetMapper", "train_net.build_sem_seg_train_aug"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.build.build_detection_train_loader", "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.build_sem_seg_train_aug"], ["# In the end of training, run an evaluation with TTA", "\n", "# Only support some R-CNN models.", "\n", "logger", ".", "info", "(", "\"Running inference with test-time augmentation ...\"", ")", "\n", "model", "=", "GeneralizedRCNNWithTTA", "(", "cfg", ",", "model", ")", "\n", "evaluators", "=", "[", "\n", "cls", ".", "build_evaluator", "(", "\n", "cfg", ",", "name", ",", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference_TTA\"", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.build_sem_seg_train_aug": [[31, 50], ["augs.append", "detectron2.ResizeShortestEdge", "augs.append", "augs.append", "detectron2.RandomFlip", "detectron2.RandomCrop_CategoryAreaConstraint", "detectron2.projects.point_rend.ColorAugSSDTransform"], "function", ["None"], ["CityscapesSemSegEvaluator", ",", "\n", "COCOEvaluator", ",", "\n", "COCOPanopticEvaluator", ",", "\n", "DatasetEvaluators", ",", "\n", "LVISEvaluator", ",", "\n", "PascalVOCDetectionEvaluator", ",", "\n", "SemSegEvaluator", ",", "\n", "verify_results", ",", "\n", ")", "\n", "from", "detectron2", ".", "modeling", "import", "GeneralizedRCNNWithTTA", "\n", "\n", "\n", "class", "Trainer", "(", "DefaultTrainer", ")", ":", "\n", "    ", "\"\"\"\n    We use the \"DefaultTrainer\" which contains pre-defined default logic for\n    standard training workflow. They may not work for you, especially if you\n    are working on a new research project. In that case you can write your\n    own training loop. You can use \"tools/plain_train_net.py\" as an example.\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup": [[113, 124], ["detectron2.config.get_cfg", "detectron2.projects.point_rend.add_pointrend_config", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.get_cfg", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.config.add_pointrend_config", "home.repos.pwc.inspect_result.JosephKJ_OWOD.config.config.CfgNode.merge_from_file", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.blocks.CNNBlockBase.freeze", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.default_setup"], ["]", "\n", "res", "=", "cls", ".", "test", "(", "cfg", ",", "model", ",", "evaluators", ")", "\n", "res", "=", "OrderedDict", "(", "{", "k", "+", "\"_TTA\"", ":", "v", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "}", ")", "\n", "return", "res", "\n", "\n", "\n", "", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.main": [[126, 142], ["train_net.setup", "train_net.Trainer", "Trainer.resume_or_load", "Trainer.train", "Trainer.build_model", "detectron2.checkpoint.DetectionCheckpointer().resume_or_load", "Trainer.test", "detectron2.is_main_process", "detectron2.evaluation.verify_results", "detectron2.checkpoint.DetectionCheckpointer"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.PointRend.train_net.setup", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.train_loop.TrainerBase.train", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.build_model", "home.repos.pwc.inspect_result.JosephKJ_OWOD.engine.defaults.DefaultTrainer.resume_or_load", "home.repos.pwc.inspect_result.JosephKJ_OWOD.tests.test_packaging.TestCollectEnv.test", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.comm.is_main_process", "home.repos.pwc.inspect_result.JosephKJ_OWOD.evaluation.testing.verify_results"], ["cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n", "\n", "", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "\n", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "DetectionCheckpointer", "(", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", "\n", ")", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ")", "\n", "if", "cfg", ".", "TEST", ".", "AUG", ".", "ENABLED", ":", "\n", "            ", "res", ".", "update", "(", "Trainer", ".", "test_with_TTA", "(", "cfg", ",", "model", ")", ")", "\n", "", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.config.add_pointrend_config": [[7, 49], ["detectron2.config.CfgNode"], "function", ["None"], ["from", "fvcore", ".", "common", ".", "config", "import", "CfgNode", "as", "_CfgNode", "\n", "from", "fvcore", ".", "common", ".", "file_io", "import", "PathManager", "\n", "\n", "\n", "class", "CfgNode", "(", "_CfgNode", ")", ":", "\n", "    ", "\"\"\"\n    The same as `fvcore.common.config.CfgNode`, but different in:\n\n    1. Use unsafe yaml loading by default.\n       Note that this may lead to arbitrary code execution: you must not\n       load a config file from untrusted sources before manually inspecting\n       the content of the file.\n    2. Support config versioning.\n       When attempting to merge an old config, it will convert the old config automatically.\n    \"\"\"", "\n", "\n", "# Note that the default value of allow_unsafe is changed to True", "\n", "def", "merge_from_file", "(", "self", ",", "cfg_filename", ":", "str", ",", "allow_unsafe", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "assert", "PathManager", ".", "isfile", "(", "cfg_filename", ")", ",", "f\"Config file '{cfg_filename}' does not exist!\"", "\n", "loaded_cfg", "=", "_CfgNode", ".", "load_yaml_with_base", "(", "cfg_filename", ",", "allow_unsafe", "=", "allow_unsafe", ")", "\n", "loaded_cfg", "=", "type", "(", "self", ")", "(", "loaded_cfg", ")", "\n", "\n", "# defaults.py needs to import CfgNode", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "latest_ver", "=", "_C", ".", "VERSION", "\n", "assert", "(", "\n", "latest_ver", "==", "self", ".", "VERSION", "\n", ")", ",", "\"CfgNode.merge_from_file is only allowed on a config object of latest version!\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "loaded_ver", "=", "loaded_cfg", ".", "get", "(", "\"VERSION\"", ",", "None", ")", "\n", "if", "loaded_ver", "is", "None", ":", "\n", "            ", "from", ".", "compat", "import", "guess_version", "\n", "\n", "loaded_ver", "=", "guess_version", "(", "loaded_cfg", ",", "cfg_filename", ")", "\n", "", "assert", "loaded_ver", "<=", "self", ".", "VERSION", ",", "\"Cannot merge a v{} config into a v{} config.\"", ".", "format", "(", "\n", "loaded_ver", ",", "self", ".", "VERSION", "\n", ")", "\n", "\n", "if", "loaded_ver", "==", "self", ".", "VERSION", ":", "\n", "            ", "self", ".", "merge_from_other_cfg", "(", "loaded_cfg", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads.__init__": [[60, 64], ["detectron2.modeling.StandardROIHeads.__init__", "roi_heads.PointRendROIHeads._init_mask_head"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._init_mask_head"], []], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._init_mask_head": [[65, 85], ["numpy.sum", "detectron2.modeling.roi_heads.mask_head.build_mask_head", "roi_heads.PointRendROIHeads._init_point_head", "detectron2.layers.ShapeSpec", "input_shape.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.build_mask_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead._init_point_head"], ["\n", "assert", "isinstance", "(", "proposals", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "proposals", "[", "0", "]", ",", "Instances", ")", "\n", "assert", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_classes\"", ")", "\n", "fg_proposals", "=", "[", "]", "\n", "fg_selection_masks", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "        ", "gt_classes", "=", "proposals_per_image", ".", "gt_classes", "\n", "fg_selection_mask", "=", "(", "gt_classes", "!=", "-", "1", ")", "&", "(", "gt_classes", "!=", "bg_label", ")", "\n", "fg_idxs", "=", "fg_selection_mask", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "fg_proposals", ".", "append", "(", "proposals_per_image", "[", "fg_idxs", "]", ")", "\n", "fg_selection_masks", ".", "append", "(", "fg_selection_mask", ")", "\n", "", "return", "fg_proposals", ",", "fg_selection_masks", "\n", "\n", "\n", "", "def", "select_proposals_with_visible_keypoints", "(", "proposals", ":", "List", "[", "Instances", "]", ")", "->", "List", "[", "Instances", "]", ":", "\n", "    "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._init_point_head": [[86, 104], ["numpy.sum", "point_head.build_point_head", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_head.build_point_head"], ["\n", "ret", "=", "[", "]", "\n", "all_num_fg", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "# If empty/unannotated image (hard negatives), skip filtering for train", "\n", "        ", "if", "len", "(", "proposals_per_image", ")", "==", "0", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask": [[106, 138], ["detectron2.modeling.roi_heads.roi_heads.select_foreground_proposals", "roi_heads.PointRendROIHeads._forward_mask_coarse", "losses.update", "roi_heads.PointRendROIHeads._forward_mask_coarse", "roi_heads.PointRendROIHeads._forward_mask_point", "detectron2.modeling.roi_heads.mask_head.mask_rcnn_inference", "detectron2.modeling.roi_heads.mask_head.mask_rcnn_loss", "roi_heads.PointRendROIHeads._forward_mask_point"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.roi_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask_coarse", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask_coarse", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask_point", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.mask_rcnn_inference", "home.repos.pwc.inspect_result.JosephKJ_OWOD.roi_heads.mask_head.mask_rcnn_loss", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask_point"], ["continue", "\n", "", "gt_keypoints", "=", "proposals_per_image", ".", "gt_keypoints", ".", "tensor", "\n", "# #fg x K x 3", "\n", "vis_mask", "=", "gt_keypoints", "[", ":", ",", ":", ",", "2", "]", ">=", "1", "\n", "xs", ",", "ys", "=", "gt_keypoints", "[", ":", ",", ":", ",", "0", "]", ",", "gt_keypoints", "[", ":", ",", ":", ",", "1", "]", "\n", "proposal_boxes", "=", "proposals_per_image", ".", "proposal_boxes", ".", "tensor", ".", "unsqueeze", "(", "dim", "=", "1", ")", "# #fg x 1 x 4", "\n", "kp_in_box", "=", "(", "\n", "(", "xs", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "&", "(", "xs", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "2", "]", ")", "\n", "&", "(", "ys", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "1", "]", ")", "\n", "&", "(", "ys", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "3", "]", ")", "\n", ")", "\n", "selection", "=", "(", "kp_in_box", "&", "vis_mask", ")", ".", "any", "(", "dim", "=", "1", ")", "\n", "selection_idxs", "=", "nonzero_tuple", "(", "selection", ")", "[", "0", "]", "\n", "all_num_fg", ".", "append", "(", "selection_idxs", ".", "numel", "(", ")", ")", "\n", "ret", ".", "append", "(", "proposals_per_image", "[", "selection_idxs", "]", ")", "\n", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"keypoint_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "all_num_fg", ")", ")", "\n", "return", "ret", "\n", "\n", "\n", "", "class", "ROIHeads", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask_coarse": [[139, 154], ["point_features.generate_regular_grid_point_coords", "point_features.point_sample_fine_grained_features", "roi_heads.PointRendROIHeads.mask_coarse_head", "numpy.sum", "len"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.generate_regular_grid_point_coords", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample_fine_grained_features"], ["\n", "\n", "@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "num_classes", ",", "\n", "batch_size_per_image", ",", "\n", "positive_fraction", ",", "\n", "proposal_matcher", ",", "\n", "enable_thresold_autolabelling", ",", "\n", "unk_k", ",", "\n", "proposal_append_gt", "=", "True", ",", "\n", ")", ":", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.PointRendROIHeads._forward_mask_point": [[155, 228], ["detectron2.layers.cat", "point_features.point_sample_fine_grained_features", "point_features.point_sample", "roi_heads.PointRendROIHeads.mask_point_head", "detectron2.layers.cat", "mask_coarse_logits.clone", "range", "torch.no_grad", "point_features.get_uncertain_point_coords_with_randomness", "point_head.roi_mask_point_loss", "len", "detectron2.layers.interpolate", "roi_heads.calculate_uncertainty", "point_features.get_uncertain_point_coords_on_grid", "point_features.point_sample_fine_grained_features", "point_features.point_sample", "roi_heads.PointRendROIHeads.mask_point_head", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "mask_logits.reshape().scatter_().view.reshape().scatter_().view.reshape().scatter_().view", "roi_heads.calculate_uncertainty", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze", "mask_logits.reshape().scatter_().view.reshape().scatter_().view.reshape().scatter_", "mask_logits.reshape().scatter_().view.reshape().scatter_().view.reshape"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample_fine_grained_features", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.get_uncertain_point_coords_with_randomness", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_head.roi_mask_point_loss", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.calculate_uncertainty", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.get_uncertain_point_coords_on_grid", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample_fine_grained_features", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.calculate_uncertainty"], ["        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            num_classes (int): number of classes. Used to label background proposals.\n            batch_size_per_image (int): number of proposals to sample for training\n            positive_fraction (float): fraction of positive (foreground) proposals\n                to sample for training.\n            proposal_matcher (Matcher): matcher that matches proposals and ground truth\n            proposal_append_gt (bool): whether to include ground truth as proposals as well\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "batch_size_per_image", "=", "batch_size_per_image", "\n", "self", ".", "positive_fraction", "=", "positive_fraction", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "proposal_append_gt", "=", "proposal_append_gt", "\n", "self", ".", "enable_thresold_autolabelling", "=", "enable_thresold_autolabelling", "\n", "self", ".", "unk_k", "=", "unk_k", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "return", "{", "\n", "\"batch_size_per_image\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "BATCH_SIZE_PER_IMAGE", ",", "\n", "\"positive_fraction\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "POSITIVE_FRACTION", ",", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", ",", "\n", "\"proposal_append_gt\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "PROPOSAL_APPEND_GT", ",", "\n", "# Matcher to assign box proposals to gt boxes", "\n", "\"proposal_matcher\"", ":", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_THRESHOLDS", ",", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_LABELS", ",", "\n", "allow_low_quality_matches", "=", "False", ",", "\n", ")", ",", "\n", "\"enable_thresold_autolabelling\"", ":", "cfg", ".", "OWOD", ".", "ENABLE_THRESHOLD_AUTOLABEL_UNK", ",", "\n", "\"unk_k\"", ":", "cfg", ".", "OWOD", ".", "NUM_UNK_PER_IMAGE", ",", "\n", "}", "\n", "\n", "", "def", "_sample_proposals", "(", "\n", "self", ",", "matched_idxs", ":", "torch", ".", "Tensor", ",", "matched_labels", ":", "torch", ".", "Tensor", ",", "gt_classes", ":", "torch", ".", "Tensor", ",", "\n", "objectness_logits", ":", "torch", ".", "Tensor", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Based on the matching between N proposals and M groundtruth,\n        sample the proposals and set their classification labels.\n\n        Args:\n            matched_idxs (Tensor): a vector of length N, each is the best-matched\n                gt index in [0, M) for each proposal.\n            matched_labels (Tensor): a vector of length N, the matcher's label\n                (one of cfg.MODEL.ROI_HEADS.IOU_LABELS) for each proposal.\n            gt_classes (Tensor): a vector of length M.\n\n        Returns:\n            Tensor: a vector of indices of sampled proposals. Each is in [0, N).\n            Tensor: a vector of the same length, the classification label for\n                each sampled proposal. Each sample is labeled as either a category in\n                [0, num_classes) or the background (num_classes).\n        \"\"\"", "\n", "has_gt", "=", "gt_classes", ".", "numel", "(", ")", ">", "0", "\n", "# Get the corresponding GT for each proposal", "\n", "if", "has_gt", ":", "\n", "            ", "gt_classes", "=", "gt_classes", "[", "matched_idxs", "]", "\n", "# Label unmatched proposals (0 label from matcher) as background (label=num_classes)", "\n", "gt_classes", "[", "matched_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "# Label ignore proposals (-1 label)", "\n", "gt_classes", "[", "matched_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "            ", "gt_classes", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "\n", "", "sampled_fg_idxs", ",", "sampled_bg_idxs", "=", "subsample_labels", "(", "\n", "gt_classes", ",", "self", ".", "batch_size_per_image", ",", "self", ".", "positive_fraction", ",", "self", ".", "num_classes", "\n", ")", "\n", "\n", "sampled_idxs", "=", "torch", ".", "cat", "(", "[", "sampled_fg_idxs", ",", "sampled_bg_idxs", "]", ",", "dim", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.roi_heads.calculate_uncertainty": [[25, 48], ["logits.clone", "logits[].unsqueeze", "torch.abs", "torch.arange"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["from", ".", "box_head", "import", "build_box_head", "\n", "from", ".", "fast_rcnn", "import", "FastRCNNOutputLayers", "\n", "from", ".", "keypoint_head", "import", "build_keypoint_head", "\n", "from", ".", "mask_head", "import", "build_mask_head", "\n", "\n", "ROI_HEADS_REGISTRY", "=", "Registry", "(", "\"ROI_HEADS\"", ")", "\n", "ROI_HEADS_REGISTRY", ".", "__doc__", "=", "\"\"\"\nRegistry for ROI heads in a generalized R-CNN model.\nROIHeads take feature maps and region proposals, and\nperform per-region computation.\n\nThe registered object will be called with `obj(cfg, input_shape)`.\nThe call is expected to return an :class:`ROIHeads`.\n\"\"\"", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "\n", "def", "build_roi_heads", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build ROIHeads defined by `cfg.MODEL.ROI_HEADS.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NAME", "\n", "return", "ROI_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample": [[19, 43], ["torch.nn.functional.grid_sample", "point_coords.unsqueeze.dim", "point_coords.unsqueeze.unsqueeze", "output.squeeze.squeeze"], "function", ["None"], ["def", "point_sample", "(", "input", ",", "point_coords", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    A wrapper around :function:`torch.nn.functional.grid_sample` to support 3D point_coords tensors.\n    Unlike :function:`torch.nn.functional.grid_sample` it assumes `point_coords` to lie inside\n    [0, 1] x [0, 1] square.\n\n    Args:\n        input (Tensor): A tensor of shape (N, C, H, W) that contains features map on a H x W grid.\n        point_coords (Tensor): A tensor of shape (N, P, 2) or (N, Hgrid, Wgrid, 2) that contains\n        [0, 1] x [0, 1] normalized point coordinates.\n\n    Returns:\n        output (Tensor): A tensor of shape (N, C, P) or (N, C, Hgrid, Wgrid) that contains\n            features for points in `point_coords`. The features are obtained via bilinear\n            interplation from `input` the same way as :function:`torch.nn.functional.grid_sample`.\n    \"\"\"", "\n", "add_dim", "=", "False", "\n", "if", "point_coords", ".", "dim", "(", ")", "==", "3", ":", "\n", "        ", "add_dim", "=", "True", "\n", "point_coords", "=", "point_coords", ".", "unsqueeze", "(", "2", ")", "\n", "", "output", "=", "F", ".", "grid_sample", "(", "input", ",", "2.0", "*", "point_coords", "-", "1.0", ",", "**", "kwargs", ")", "\n", "if", "add_dim", ":", "\n", "        ", "output", "=", "output", ".", "squeeze", "(", "3", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.generate_regular_grid_point_coords": [[45, 61], ["torch.tensor", "torch.nn.functional.affine_grid", "F.affine_grid.view().expand", "torch.Size", "F.affine_grid.view"], "function", ["None"], ["", "def", "generate_regular_grid_point_coords", "(", "R", ",", "side_size", ",", "device", ")", ":", "\n", "    ", "\"\"\"\n    Generate regular square grid of points in [0, 1] x [0, 1] coordinate space.\n\n    Args:\n        R (int): The number of grids to sample, one for each region.\n        side_size (int): The side size of the regular grid.\n        device (torch.device): Desired device of returned tensor.\n\n    Returns:\n        (Tensor): A tensor of shape (R, side_size^2, 2) that contains coordinates\n            for the regular grids.\n    \"\"\"", "\n", "aff", "=", "torch", ".", "tensor", "(", "[", "[", "[", "0.5", ",", "0", ",", "0.5", "]", ",", "[", "0", ",", "0.5", ",", "0.5", "]", "]", "]", ",", "device", "=", "device", ")", "\n", "r", "=", "F", ".", "affine_grid", "(", "aff", ",", "torch", ".", "Size", "(", "(", "1", ",", "1", ",", "side_size", ",", "side_size", ")", ")", ",", "align_corners", "=", "False", ")", "\n", "return", "r", ".", "view", "(", "1", ",", "-", "1", ",", "2", ")", ".", "expand", "(", "R", ",", "-", "1", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.get_uncertain_point_coords_with_randomness": [[63, 117], ["int", "torch.rand", "point_features.point_sample", "uncertainty_func", "int", "[].view", "torch.topk", "torch.arange", "detectron2.layers.cat", "detectron2.layers.cat.view", "torch.rand", "idx.view"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "def", "get_uncertain_point_coords_with_randomness", "(", "\n", "coarse_logits", ",", "uncertainty_func", ",", "num_points", ",", "oversample_ratio", ",", "importance_sample_ratio", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Sample points in [0, 1] x [0, 1] coordinate space based on their uncertainty. The unceratinties\n        are calculated for each point using 'uncertainty_func' function that takes point's logit\n        prediction as input.\n    See PointRend paper for details.\n\n    Args:\n        coarse_logits (Tensor): A tensor of shape (N, C, Hmask, Wmask) or (N, 1, Hmask, Wmask) for\n            class-specific or class-agnostic prediction.\n        uncertainty_func: A function that takes a Tensor of shape (N, C, P) or (N, 1, P) that\n            contains logit predictions for P points and returns their uncertainties as a Tensor of\n            shape (N, 1, P).\n        num_points (int): The number of points P to sample.\n        oversample_ratio (int): Oversampling parameter.\n        importance_sample_ratio (float): Ratio of points that are sampled via importnace sampling.\n\n    Returns:\n        point_coords (Tensor): A tensor of shape (N, P, 2) that contains the coordinates of P\n            sampled points.\n    \"\"\"", "\n", "assert", "oversample_ratio", ">=", "1", "\n", "assert", "importance_sample_ratio", "<=", "1", "and", "importance_sample_ratio", ">=", "0", "\n", "num_boxes", "=", "coarse_logits", ".", "shape", "[", "0", "]", "\n", "num_sampled", "=", "int", "(", "num_points", "*", "oversample_ratio", ")", "\n", "point_coords", "=", "torch", ".", "rand", "(", "num_boxes", ",", "num_sampled", ",", "2", ",", "device", "=", "coarse_logits", ".", "device", ")", "\n", "point_logits", "=", "point_sample", "(", "coarse_logits", ",", "point_coords", ",", "align_corners", "=", "False", ")", "\n", "# It is crucial to calculate uncertainty based on the sampled prediction value for the points.", "\n", "# Calculating uncertainties of the coarse predictions first and sampling them for points leads", "\n", "# to incorrect results.", "\n", "# To illustrate this: assume uncertainty_func(logits)=-abs(logits), a sampled point between", "\n", "# two coarse predictions with -1 and 1 logits has 0 logits, and therefore 0 uncertainty value.", "\n", "# However, if we calculate uncertainties for the coarse predictions first,", "\n", "# both will have -1 uncertainty, and the sampled point will get -1 uncertainty.", "\n", "point_uncertainties", "=", "uncertainty_func", "(", "point_logits", ")", "\n", "num_uncertain_points", "=", "int", "(", "importance_sample_ratio", "*", "num_points", ")", "\n", "num_random_points", "=", "num_points", "-", "num_uncertain_points", "\n", "idx", "=", "torch", ".", "topk", "(", "point_uncertainties", "[", ":", ",", "0", ",", ":", "]", ",", "k", "=", "num_uncertain_points", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "shift", "=", "num_sampled", "*", "torch", ".", "arange", "(", "num_boxes", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "coarse_logits", ".", "device", ")", "\n", "idx", "+=", "shift", "[", ":", ",", "None", "]", "\n", "point_coords", "=", "point_coords", ".", "view", "(", "-", "1", ",", "2", ")", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "\n", "num_boxes", ",", "num_uncertain_points", ",", "2", "\n", ")", "\n", "if", "num_random_points", ">", "0", ":", "\n", "        ", "point_coords", "=", "cat", "(", "\n", "[", "\n", "point_coords", ",", "\n", "torch", ".", "rand", "(", "num_boxes", ",", "num_random_points", ",", "2", ",", "device", "=", "coarse_logits", ".", "device", ")", ",", "\n", "]", ",", "\n", "dim", "=", "1", ",", "\n", ")", "\n", "", "return", "point_coords", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.get_uncertain_point_coords_on_grid": [[119, 144], ["min", "torch.zeros", "float", "float", "torch.topk", "uncertainty_map.view"], "function", ["None"], ["", "def", "get_uncertain_point_coords_on_grid", "(", "uncertainty_map", ",", "num_points", ")", ":", "\n", "    ", "\"\"\"\n    Find `num_points` most uncertain points from `uncertainty_map` grid.\n\n    Args:\n        uncertainty_map (Tensor): A tensor of shape (N, 1, H, W) that contains uncertainty\n            values for a set of points on a regular H x W grid.\n        num_points (int): The number of points P to select.\n\n    Returns:\n        point_indices (Tensor): A tensor of shape (N, P) that contains indices from\n            [0, H x W) of the most uncertain points.\n        point_coords (Tensor): A tensor of shape (N, P, 2) that contains [0, 1] x [0, 1] normalized\n            coordinates of the most uncertain points from the H x W grid.\n    \"\"\"", "\n", "R", ",", "_", ",", "H", ",", "W", "=", "uncertainty_map", ".", "shape", "\n", "h_step", "=", "1.0", "/", "float", "(", "H", ")", "\n", "w_step", "=", "1.0", "/", "float", "(", "W", ")", "\n", "\n", "num_points", "=", "min", "(", "H", "*", "W", ",", "num_points", ")", "\n", "point_indices", "=", "torch", ".", "topk", "(", "uncertainty_map", ".", "view", "(", "R", ",", "H", "*", "W", ")", ",", "k", "=", "num_points", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "point_coords", "=", "torch", ".", "zeros", "(", "R", ",", "num_points", ",", "2", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "uncertainty_map", ".", "device", ")", "\n", "point_coords", "[", ":", ",", ":", ",", "0", "]", "=", "w_step", "/", "2.0", "+", "(", "point_indices", "%", "W", ")", ".", "to", "(", "torch", ".", "float", ")", "*", "w_step", "\n", "point_coords", "[", ":", ",", ":", ",", "1", "]", "=", "h_step", "/", "2.0", "+", "(", "point_indices", "//", "W", ")", ".", "to", "(", "torch", ".", "float", ")", "*", "h_step", "\n", "return", "point_indices", ",", "point_coords", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample_fine_grained_features": [[146, 190], ["detectron2.structures.Boxes.cat", "point_features.get_point_coords_wrt_image", "torch.split", "enumerate", "len", "enumerate", "point_features.append", "detectron2.layers.cat", "point_features_per_image.append", "detectron2.layers.cat", "torch.tensor", "point_sample().squeeze().transpose", "point_sample().squeeze", "point_features.point_sample", "feature_map[].unsqueeze", "point_coords_scaled.unsqueeze"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.get_point_coords_wrt_image", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample"], ["", "def", "point_sample_fine_grained_features", "(", "features_list", ",", "feature_scales", ",", "boxes", ",", "point_coords", ")", ":", "\n", "    ", "\"\"\"\n    Get features from feature maps in `features_list` that correspond to specific point coordinates\n        inside each bounding box from `boxes`.\n\n    Args:\n        features_list (list[Tensor]): A list of feature map tensors to get features from.\n        feature_scales (list[float]): A list of scales for tensors in `features_list`.\n        boxes (list[Boxes]): A list of I Boxes  objects that contain R_1 + ... + R_I = R boxes all\n            together.\n        point_coords (Tensor): A tensor of shape (R, P, 2) that contains\n            [0, 1] x [0, 1] box-normalized coordinates of the P sampled points.\n\n    Returns:\n        point_features (Tensor): A tensor of shape (R, C, P) that contains features sampled\n            from all features maps in feature_list for P sampled points for all R boxes in `boxes`.\n        point_coords_wrt_image (Tensor): A tensor of shape (R, P, 2) that contains image-level\n            coordinates of P points.\n    \"\"\"", "\n", "cat_boxes", "=", "Boxes", ".", "cat", "(", "boxes", ")", "\n", "num_boxes", "=", "[", "len", "(", "b", ")", "for", "b", "in", "boxes", "]", "\n", "\n", "point_coords_wrt_image", "=", "get_point_coords_wrt_image", "(", "cat_boxes", ".", "tensor", ",", "point_coords", ")", "\n", "split_point_coords_wrt_image", "=", "torch", ".", "split", "(", "point_coords_wrt_image", ",", "num_boxes", ")", "\n", "\n", "point_features", "=", "[", "]", "\n", "for", "idx_img", ",", "point_coords_wrt_image_per_image", "in", "enumerate", "(", "split_point_coords_wrt_image", ")", ":", "\n", "        ", "point_features_per_image", "=", "[", "]", "\n", "for", "idx_feature", ",", "feature_map", "in", "enumerate", "(", "features_list", ")", ":", "\n", "            ", "h", ",", "w", "=", "feature_map", ".", "shape", "[", "-", "2", ":", "]", "\n", "scale", "=", "torch", ".", "tensor", "(", "[", "w", ",", "h", "]", ",", "device", "=", "feature_map", ".", "device", ")", "/", "feature_scales", "[", "idx_feature", "]", "\n", "point_coords_scaled", "=", "point_coords_wrt_image_per_image", "/", "scale", "\n", "point_features_per_image", ".", "append", "(", "\n", "point_sample", "(", "\n", "feature_map", "[", "idx_img", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "point_coords_scaled", ".", "unsqueeze", "(", "0", ")", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", "\n", ".", "squeeze", "(", "0", ")", "\n", ".", "transpose", "(", "1", ",", "0", ")", "\n", ")", "\n", "", "point_features", ".", "append", "(", "cat", "(", "point_features_per_image", ",", "dim", "=", "1", ")", ")", "\n", "\n", "", "return", "cat", "(", "point_features", ",", "dim", "=", "0", ")", ",", "point_coords_wrt_image", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.get_point_coords_wrt_image": [[192, 217], ["torch.no_grad", "point_coords.clone"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone"], ["", "def", "get_point_coords_wrt_image", "(", "boxes_coords", ",", "point_coords", ")", ":", "\n", "    ", "\"\"\"\n    Convert box-normalized [0, 1] x [0, 1] point cooordinates to image-level coordinates.\n\n    Args:\n        boxes_coords (Tensor): A tensor of shape (R, 4) that contains bounding boxes.\n            coordinates.\n        point_coords (Tensor): A tensor of shape (R, P, 2) that contains\n            [0, 1] x [0, 1] box-normalized coordinates of the P sampled points.\n\n    Returns:\n        point_coords_wrt_image (Tensor): A tensor of shape (R, P, 2) that contains\n            image-normalized coordinates of P sampled points.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "point_coords_wrt_image", "=", "point_coords", ".", "clone", "(", ")", "\n", "point_coords_wrt_image", "[", ":", ",", ":", ",", "0", "]", "=", "point_coords_wrt_image", "[", ":", ",", ":", ",", "0", "]", "*", "(", "\n", "boxes_coords", "[", ":", ",", "None", ",", "2", "]", "-", "boxes_coords", "[", ":", ",", "None", ",", "0", "]", "\n", ")", "\n", "point_coords_wrt_image", "[", ":", ",", ":", ",", "1", "]", "=", "point_coords_wrt_image", "[", ":", ",", ":", ",", "1", "]", "*", "(", "\n", "boxes_coords", "[", ":", ",", "None", ",", "3", "]", "-", "boxes_coords", "[", ":", ",", "None", ",", "1", "]", "\n", ")", "\n", "point_coords_wrt_image", "[", ":", ",", ":", ",", "0", "]", "+=", "boxes_coords", "[", ":", ",", "None", ",", "0", "]", "\n", "point_coords_wrt_image", "[", ":", ",", ":", ",", "1", "]", "+=", "boxes_coords", "[", ":", ",", "None", ",", "1", "]", "\n", "", "return", "point_coords_wrt_image", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_head.StandardPointHead.__init__": [[106, 142], ["torch.nn.Module.__init__", "range", "torch.nn.Conv1d", "torch.nn.init.normal_", "torch.nn.Conv1d", "point_head.StandardPointHead.add_module", "point_head.StandardPointHead.fc_layers.append", "fvcore.c2_msra_fill", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "\"\"\"\n        The following attributes are parsed from config:\n            fc_dim: the output dimension of each FC layers\n            num_fc: the number of FC layers\n            coarse_pred_each_layer: if True, coarse prediction features are concatenated to each\n                layer's input\n        \"\"\"", "\n", "super", "(", "StandardPointHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "NUM_CLASSES", "\n", "fc_dim", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "FC_DIM", "\n", "num_fc", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "NUM_FC", "\n", "cls_agnostic_mask", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "CLS_AGNOSTIC_MASK", "\n", "self", ".", "coarse_pred_each_layer", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "COARSE_PRED_EACH_LAYER", "\n", "input_channels", "=", "input_shape", ".", "channels", "\n", "# fmt: on", "\n", "\n", "fc_dim_in", "=", "input_channels", "+", "num_classes", "\n", "self", ".", "fc_layers", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "num_fc", ")", ":", "\n", "            ", "fc", "=", "nn", ".", "Conv1d", "(", "fc_dim_in", ",", "fc_dim", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ")", "\n", "self", ".", "add_module", "(", "\"fc{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "fc", ")", "\n", "self", ".", "fc_layers", ".", "append", "(", "fc", ")", "\n", "fc_dim_in", "=", "fc_dim", "\n", "fc_dim_in", "+=", "num_classes", "if", "self", ".", "coarse_pred_each_layer", "else", "0", "\n", "\n", "", "num_mask_classes", "=", "1", "if", "cls_agnostic_mask", "else", "num_classes", "\n", "self", ".", "predictor", "=", "nn", ".", "Conv1d", "(", "fc_dim_in", ",", "num_mask_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "for", "layer", "in", "self", ".", "fc_layers", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "# use normal distribution initialization for mask prediction layer", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "predictor", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "if", "self", ".", "predictor", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "predictor", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_head.StandardPointHead.forward": [[143, 150], ["torch.cat", "point_head.StandardPointHead.predictor", "torch.nn.functional.relu", "layer", "detectron2.layers.cat"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat"], ["", "", "def", "forward", "(", "self", ",", "fine_grained_features", ",", "coarse_features", ")", ":", "\n", "        ", "x", "=", "torch", ".", "cat", "(", "(", "fine_grained_features", ",", "coarse_features", ")", ",", "dim", "=", "1", ")", "\n", "for", "layer", "in", "self", ".", "fc_layers", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "layer", "(", "x", ")", ")", "\n", "if", "self", ".", "coarse_pred_each_layer", ":", "\n", "                ", "x", "=", "cat", "(", "(", "x", ",", "coarse_features", ")", ",", "dim", "=", "1", ")", "\n", "", "", "return", "self", ".", "predictor", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_head.roi_mask_point_loss": [[22, 97], ["detectron2.layers.cat", "detectron2.utils.events.get_event_storage().put_scalar", "torch.nn.functional.binary_cross_entropy_with_logits", "torch.no_grad", "mask_logits.size", "len", "detectron2.layers.cat.numel", "torch.arange", "detectron2.layers.cat", "detectron2.layers.cat.to", "mask_accurate.nonzero().size", "mask_accurate.numel", "detectron2.layers.cat.to", "mask_logits.size", "isinstance", "torch.tensor", "len", "detectron2.layers.cat.append", "mask_logits.sum", "detectron2.utils.events.get_event_storage", "len", "instances_per_image.gt_classes.to", "detectron2.layers.cat.append", "point_features.point_sample().squeeze", "mask_accurate.nonzero", "point_features.point_sample", "len", "gt_bit_masks.to().unsqueeze", "gt_bit_masks.to"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.EventStorage.put_scalar", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.utils.events.get_event_storage", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["def", "roi_mask_point_loss", "(", "mask_logits", ",", "instances", ",", "points_coord", ")", ":", "\n", "    ", "\"\"\"\n    Compute the point-based loss for instance segmentation mask predictions.\n\n    Args:\n        mask_logits (Tensor): A tensor of shape (R, C, P) or (R, 1, P) for class-specific or\n            class-agnostic, where R is the total number of predicted masks in all images, C is the\n            number of foreground classes, and P is the number of points sampled for each mask.\n            The values are logits.\n        instances (list[Instances]): A list of N Instances, where N is the number of images\n            in the batch. These instances are in 1:1 correspondence with the `mask_logits`. So, i_th\n            elememt of the list contains R_i objects and R_1 + ... + R_N is equal to R.\n            The ground-truth labels (class, box, mask, ...) associated with each instance are stored\n            in fields.\n        points_coords (Tensor): A tensor of shape (R, P, 2), where R is the total number of\n            predicted masks and P is the number of points for each mask. The coordinates are in\n            the image pixel coordinate space, i.e. [0, H] x [0, W].\n    Returns:\n        point_loss (Tensor): A scalar tensor containing the loss.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "cls_agnostic_mask", "=", "mask_logits", ".", "size", "(", "1", ")", "==", "1", "\n", "total_num_masks", "=", "mask_logits", ".", "size", "(", "0", ")", "\n", "\n", "gt_classes", "=", "[", "]", "\n", "gt_mask_logits", "=", "[", "]", "\n", "idx", "=", "0", "\n", "for", "instances_per_image", "in", "instances", ":", "\n", "            ", "if", "len", "(", "instances_per_image", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "assert", "isinstance", "(", "\n", "instances_per_image", ".", "gt_masks", ",", "BitMasks", "\n", ")", ",", "\"Point head works with GT in 'bitmask' format. Set INPUT.MASK_FORMAT to 'bitmask'.\"", "\n", "\n", "if", "not", "cls_agnostic_mask", ":", "\n", "                ", "gt_classes_per_image", "=", "instances_per_image", ".", "gt_classes", ".", "to", "(", "dtype", "=", "torch", ".", "int64", ")", "\n", "gt_classes", ".", "append", "(", "gt_classes_per_image", ")", "\n", "\n", "", "gt_bit_masks", "=", "instances_per_image", ".", "gt_masks", ".", "tensor", "\n", "h", ",", "w", "=", "instances_per_image", ".", "gt_masks", ".", "image_size", "\n", "scale", "=", "torch", ".", "tensor", "(", "[", "w", ",", "h", "]", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "gt_bit_masks", ".", "device", ")", "\n", "points_coord_grid_sample_format", "=", "(", "\n", "points_coord", "[", "idx", ":", "idx", "+", "len", "(", "instances_per_image", ")", "]", "/", "scale", "\n", ")", "\n", "idx", "+=", "len", "(", "instances_per_image", ")", "\n", "gt_mask_logits", ".", "append", "(", "\n", "point_sample", "(", "\n", "gt_bit_masks", ".", "to", "(", "torch", ".", "float32", ")", ".", "unsqueeze", "(", "1", ")", ",", "\n", "points_coord_grid_sample_format", ",", "\n", "align_corners", "=", "False", ",", "\n", ")", ".", "squeeze", "(", "1", ")", "\n", ")", "\n", "\n", "", "", "if", "len", "(", "gt_mask_logits", ")", "==", "0", ":", "\n", "        ", "return", "mask_logits", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "gt_mask_logits", "=", "cat", "(", "gt_mask_logits", ")", "\n", "assert", "gt_mask_logits", ".", "numel", "(", ")", ">", "0", ",", "gt_mask_logits", ".", "shape", "\n", "\n", "if", "cls_agnostic_mask", ":", "\n", "        ", "mask_logits", "=", "mask_logits", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "        ", "indices", "=", "torch", ".", "arange", "(", "total_num_masks", ")", "\n", "gt_classes", "=", "cat", "(", "gt_classes", ",", "dim", "=", "0", ")", "\n", "mask_logits", "=", "mask_logits", "[", "indices", ",", "gt_classes", "]", "\n", "\n", "# Log the training accuracy (using gt classes and 0.0 threshold for the logits)", "\n", "", "mask_accurate", "=", "(", "mask_logits", ">", "0.0", ")", "==", "gt_mask_logits", ".", "to", "(", "dtype", "=", "torch", ".", "uint8", ")", "\n", "mask_accuracy", "=", "mask_accurate", ".", "nonzero", "(", ")", ".", "size", "(", "0", ")", "/", "mask_accurate", ".", "numel", "(", ")", "\n", "get_event_storage", "(", ")", ".", "put_scalar", "(", "\"point_rend/accuracy\"", ",", "mask_accuracy", ")", "\n", "\n", "point_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "mask_logits", ",", "gt_mask_logits", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "reduction", "=", "\"mean\"", "\n", ")", "\n", "return", "point_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_head.build_point_head": [[152, 158], ["POINT_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["", "", "def", "build_point_head", "(", "cfg", ",", "input_channels", ")", ":", "\n", "    ", "\"\"\"\n    Build a point head defined by `cfg.MODEL.POINT_HEAD.NAME`.\n    \"\"\"", "\n", "head_name", "=", "cfg", ".", "MODEL", ".", "POINT_HEAD", ".", "NAME", "\n", "return", "POINT_HEAD_REGISTRY", ".", "get", "(", "head_name", ")", "(", "cfg", ",", "input_channels", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.coarse_mask_head.CoarseMaskHead.__init__": [[19, 79], ["torch.nn.Module.__init__", "detectron2.layers.Conv2d", "coarse_mask_head.CoarseMaskHead.conv_layers.append", "range", "torch.nn.Linear", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "coarse_mask_head.CoarseMaskHead.conv_layers.append", "torch.nn.Linear", "coarse_mask_head.CoarseMaskHead.add_module", "coarse_mask_head.CoarseMaskHead.fcs.append", "fvcore.c2_msra_fill", "fvcore.c2_xavier_fill"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "\"\"\"\n        The following attributes are parsed from config:\n            conv_dim: the output dimension of the conv layers\n            fc_dim: the feature dimenstion of the FC layers\n            num_fc: the number of FC layers\n            output_side_resolution: side resolution of the output square mask prediction\n        \"\"\"", "\n", "super", "(", "CoarseMaskHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "conv_dim", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", "\n", "self", ".", "fc_dim", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "FC_DIM", "\n", "num_fc", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NUM_FC", "\n", "self", ".", "output_side_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "OUTPUT_SIDE_RESOLUTION", "\n", "self", ".", "input_channels", "=", "input_shape", ".", "channels", "\n", "self", ".", "input_h", "=", "input_shape", ".", "height", "\n", "self", ".", "input_w", "=", "input_shape", ".", "width", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_layers", "=", "[", "]", "\n", "if", "self", ".", "input_channels", ">", "conv_dim", ":", "\n", "            ", "self", ".", "reduce_channel_dim_conv", "=", "Conv2d", "(", "\n", "self", ".", "input_channels", ",", "\n", "conv_dim", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "True", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "self", ".", "conv_layers", ".", "append", "(", "self", ".", "reduce_channel_dim_conv", ")", "\n", "\n", "", "self", ".", "reduce_spatial_dim_conv", "=", "Conv2d", "(", "\n", "conv_dim", ",", "conv_dim", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "True", ",", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "conv_layers", ".", "append", "(", "self", ".", "reduce_spatial_dim_conv", ")", "\n", "\n", "input_dim", "=", "conv_dim", "*", "self", ".", "input_h", "*", "self", ".", "input_w", "\n", "input_dim", "//=", "4", "\n", "\n", "self", ".", "fcs", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "num_fc", ")", ":", "\n", "            ", "fc", "=", "nn", ".", "Linear", "(", "input_dim", ",", "self", ".", "fc_dim", ")", "\n", "self", ".", "add_module", "(", "\"coarse_mask_fc{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "fc", ")", "\n", "self", ".", "fcs", ".", "append", "(", "fc", ")", "\n", "input_dim", "=", "self", ".", "fc_dim", "\n", "\n", "", "output_dim", "=", "self", ".", "num_classes", "*", "self", ".", "output_side_resolution", "*", "self", ".", "output_side_resolution", "\n", "\n", "self", ".", "prediction", "=", "nn", ".", "Linear", "(", "self", ".", "fc_dim", ",", "output_dim", ")", "\n", "# use normal distribution initialization for mask prediction layer", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "prediction", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "prediction", ".", "bias", ",", "0", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_layers", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "", "for", "layer", "in", "self", ".", "fcs", ":", "\n", "            ", "weight_init", ".", "c2_xavier_fill", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.coarse_mask_head.CoarseMaskHead.forward": [[80, 92], ["torch.nn.functional.relu.view", "torch.flatten", "coarse_mask_head.CoarseMaskHead.prediction().view", "layer", "torch.nn.functional.relu", "layer", "coarse_mask_head.CoarseMaskHead.prediction"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.export.c10.InstancesList.flatten"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# unlike BaseMaskRCNNHead, this head only outputs intermediate", "\n", "# features, because the features will be used later by PointHead.", "\n", "        ", "N", "=", "x", ".", "shape", "[", "0", "]", "\n", "x", "=", "x", ".", "view", "(", "N", ",", "self", ".", "input_channels", ",", "self", ".", "input_h", ",", "self", ".", "input_w", ")", "\n", "for", "layer", "in", "self", ".", "conv_layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "start_dim", "=", "1", ")", "\n", "for", "layer", "in", "self", ".", "fcs", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "layer", "(", "x", ")", ")", "\n", "", "return", "self", ".", "prediction", "(", "x", ")", ".", "view", "(", "\n", "N", ",", "self", ".", "num_classes", ",", "self", ".", "output_side_resolution", ",", "self", ".", "output_side_resolution", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.__init__": [[43, 52], ["torch.nn.Module.__init__", "semantic_seg.PointRendSemSegHead._init_point_head", "detectron2.modeling.SEM_SEG_HEADS_REGISTRY.get"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead._init_point_head", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.catalog._MetadataCatalog.get"], ["\n", "", "def", "forward", "(", "self", ",", "batched_inputs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead._init_point_head": [[53, 67], ["numpy.sum", "point_head.build_point_head", "detectron2.layers.ShapeSpec", "input_shape.items"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_head.build_point_head"], ["\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.PointRendSemSegHead.forward": [[68, 136], ["semantic_seg.PointRendSemSegHead.coarse_sem_seg_head.layers", "semantic_seg.PointRendSemSegHead.coarse_sem_seg_head.losses", "point_features.point_sample", "detectron2.layers.cat", "semantic_seg.PointRendSemSegHead.point_head", "point_features.point_sample().squeeze().to", "torch.nn.functional.cross_entropy", "semantic_seg.PointRendSemSegHead.clone", "range", "torch.no_grad", "point_features.get_uncertain_point_coords_with_randomness", "torch.nn.functional.interpolate", "semantic_seg.calculate_uncertainty", "point_features.get_uncertain_point_coords_on_grid", "detectron2.layers.cat", "point_features.point_sample", "semantic_seg.PointRendSemSegHead.point_head", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "sem_seg_logits.reshape().scatter_().view.reshape().scatter_().view.reshape().scatter_().view", "point_features.point_sample", "point_features.point_sample().squeeze", "point_features.point_sample", "point_indices.unsqueeze().expand.unsqueeze().expand.unsqueeze", "sem_seg_logits.reshape().scatter_().view.reshape().scatter_().view.reshape().scatter_", "point_features.point_sample", "targets.unsqueeze().to", "sem_seg_logits.reshape().scatter_().view.reshape().scatter_().view.reshape", "targets.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3PlusHead.layers", "home.repos.pwc.inspect_result.JosephKJ_OWOD.deeplab.semantic_seg.DeepLabV3Head.losses", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to", "home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clone", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.get_uncertain_point_coords_with_randomness", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.calculate_uncertainty", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.get_uncertain_point_coords_on_grid", "home.repos.pwc.inspect_result.JosephKJ_OWOD.layers.wrappers.cat", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.point_features.point_sample", "home.repos.pwc.inspect_result.JosephKJ_OWOD.data.structures.DensePoseList.to"], ["images", "=", "[", "x", "[", "\"image\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "images", "=", "[", "(", "x", "-", "self", ".", "pixel_mean", ")", "/", "self", ".", "pixel_std", "for", "x", "in", "images", "]", "\n", "images", "=", "ImageList", ".", "from_tensors", "(", "images", ",", "self", ".", "backbone", ".", "size_divisibility", ")", "\n", "\n", "features", "=", "self", ".", "backbone", "(", "images", ".", "tensor", ")", "\n", "\n", "if", "\"sem_seg\"", "in", "batched_inputs", "[", "0", "]", ":", "\n", "            ", "targets", "=", "[", "x", "[", "\"sem_seg\"", "]", ".", "to", "(", "self", ".", "device", ")", "for", "x", "in", "batched_inputs", "]", "\n", "targets", "=", "ImageList", ".", "from_tensors", "(", "\n", "targets", ",", "self", ".", "backbone", ".", "size_divisibility", ",", "self", ".", "sem_seg_head", ".", "ignore_value", "\n", ")", ".", "tensor", "\n", "", "else", ":", "\n", "            ", "targets", "=", "None", "\n", "", "results", ",", "losses", "=", "self", ".", "sem_seg_head", "(", "features", ",", "targets", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "losses", "\n", "\n", "", "processed_results", "=", "[", "]", "\n", "for", "result", ",", "input_per_image", ",", "image_size", "in", "zip", "(", "results", ",", "batched_inputs", ",", "images", ".", "image_sizes", ")", ":", "\n", "            ", "height", "=", "input_per_image", ".", "get", "(", "\"height\"", ")", "\n", "width", "=", "input_per_image", ".", "get", "(", "\"width\"", ")", "\n", "r", "=", "sem_seg_postprocess", "(", "result", ",", "image_size", ",", "height", ",", "width", ")", "\n", "processed_results", ".", "append", "(", "{", "\"sem_seg\"", ":", "r", "}", ")", "\n", "", "return", "processed_results", "\n", "\n", "\n", "", "", "def", "build_sem_seg_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a semantic segmentation head from `cfg.MODEL.SEM_SEG_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NAME", "\n", "return", "SEM_SEG_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "\n", "", "@", "SEM_SEG_HEADS_REGISTRY", ".", "register", "(", ")", "\n", "class", "SemSegFPNHead", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    A semantic segmentation head described in :paper:`PanopticFPN`.\n    It takes FPN features as input and merges information from all\n    levels of the FPN into single output.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IN_FEATURES", "\n", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "feature_channels", "=", "{", "k", ":", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "self", ".", "ignore_value", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "IGNORE_VALUE", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "CONVS_DIM", "\n", "self", ".", "common_stride", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "COMMON_STRIDE", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "NORM", "\n", "self", ".", "loss_weight", "=", "cfg", ".", "MODEL", ".", "SEM_SEG_HEAD", ".", "LOSS_WEIGHT", "\n", "# fmt: on", "\n", "\n", "self", ".", "scale_heads", "=", "[", "]", "\n", "for", "in_feature", "in", "self", ".", "in_features", ":", "\n", "            ", "head_ops", "=", "[", "]", "\n", "head_length", "=", "max", "(", "\n", "1", ",", "int", "(", "np", ".", "log2", "(", "feature_strides", "[", "in_feature", "]", ")", "-", "np", ".", "log2", "(", "self", ".", "common_stride", ")", ")", "\n", ")", "\n", "for", "k", "in", "range", "(", "head_length", ")", ":", "\n", "                ", "norm_module", "=", "nn", ".", "GroupNorm", "(", "32", ",", "conv_dims", ")", "if", "norm", "==", "\"GN\"", "else", "None", "\n", "conv", "=", "Conv2d", "(", "\n", "feature_channels", "[", "in_feature", "]", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.semantic_seg.calculate_uncertainty": [[19, 34], ["torch.topk"], "function", ["None"], ["\n", "SEM_SEG_HEADS_REGISTRY", "=", "Registry", "(", "\"SEM_SEG_HEADS\"", ")", "\n", "SEM_SEG_HEADS_REGISTRY", ".", "__doc__", "=", "\"\"\"\nRegistry for semantic segmentation heads, which make semantic segmentation predictions\nfrom feature maps.\n\"\"\"", "\n", "\n", "\n", "@", "META_ARCH_REGISTRY", ".", "register", "(", ")", "\n", "class", "SemanticSegmentor", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\"\n    Main class for semantic segmentation architectures.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__": [[27, 42], ["fvcore.transforms.transform.Transform.__init__", "color_augmentation.ColorAugSSDTransform._set_attributes", "locals"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "img_format", ",", "\n", "brightness_delta", "=", "32", ",", "\n", "contrast_low", "=", "0.5", ",", "\n", "contrast_high", "=", "1.5", ",", "\n", "saturation_low", "=", "0.5", ",", "\n", "saturation_high", "=", "1.5", ",", "\n", "hue_delta", "=", "18", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "img_format", "in", "[", "\"BGR\"", ",", "\"RGB\"", "]", "\n", "self", ".", "is_rgb", "=", "img_format", "==", "\"RGB\"", "\n", "del", "img_format", "\n", "self", ".", "_set_attributes", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_coords": [[43, 45], ["None"], "methods", ["None"], ["", "def", "apply_coords", "(", "self", ",", "coords", ")", ":", "\n", "        ", "return", "coords", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_segmentation": [[46, 48], ["None"], "methods", ["None"], ["", "def", "apply_segmentation", "(", "self", ",", "segmentation", ")", ":", "\n", "        ", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.apply_image": [[49, 64], ["color_augmentation.ColorAugSSDTransform.brightness", "random.randrange", "color_augmentation.ColorAugSSDTransform.contrast", "color_augmentation.ColorAugSSDTransform.saturation", "color_augmentation.ColorAugSSDTransform.hue", "color_augmentation.ColorAugSSDTransform.saturation", "color_augmentation.ColorAugSSDTransform.hue", "color_augmentation.ColorAugSSDTransform.contrast"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.brightness", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.contrast", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.saturation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.hue", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.saturation", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.hue", "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.contrast"], ["", "def", "apply_image", "(", "self", ",", "img", ",", "interp", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "is_rgb", ":", "\n", "            ", "img", "=", "img", "[", ":", ",", ":", ",", "[", "2", ",", "1", ",", "0", "]", "]", "\n", "", "img", "=", "self", ".", "brightness", "(", "img", ")", "\n", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "img", "=", "self", ".", "contrast", "(", "img", ")", "\n", "img", "=", "self", ".", "saturation", "(", "img", ")", "\n", "img", "=", "self", ".", "hue", "(", "img", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "self", ".", "saturation", "(", "img", ")", "\n", "img", "=", "self", ".", "hue", "(", "img", ")", "\n", "img", "=", "self", ".", "contrast", "(", "img", ")", "\n", "", "if", "self", ".", "is_rgb", ":", "\n", "            ", "img", "=", "img", "[", ":", ",", ":", ",", "[", "2", ",", "1", ",", "0", "]", "]", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert": [[65, 69], ["numpy.clip", "numpy.clip.astype", "numpy.clip.astype"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.structures.boxes.Boxes.clip"], ["", "def", "convert", "(", "self", ",", "img", ",", "alpha", "=", "1", ",", "beta", "=", "0", ")", ":", "\n", "        ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "*", "alpha", "+", "beta", "\n", "img", "=", "np", ".", "clip", "(", "img", ",", "0", ",", "255", ")", "\n", "return", "img", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.brightness": [[70, 76], ["random.randrange", "color_augmentation.ColorAugSSDTransform.convert", "random.uniform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "brightness", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "return", "self", ".", "convert", "(", "\n", "img", ",", "beta", "=", "random", ".", "uniform", "(", "-", "self", ".", "brightness_delta", ",", "self", ".", "brightness_delta", ")", "\n", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.contrast": [[77, 81], ["random.randrange", "color_augmentation.ColorAugSSDTransform.convert", "random.uniform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "contrast", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "return", "self", ".", "convert", "(", "img", ",", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "contrast_low", ",", "self", ".", "contrast_high", ")", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.saturation": [[82, 90], ["random.randrange", "cv2.cvtColor", "color_augmentation.ColorAugSSDTransform.convert", "cv2.cvtColor", "random.uniform"], "methods", ["home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.convert"], ["", "def", "saturation", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2HSV", ")", "\n", "img", "[", ":", ",", ":", ",", "1", "]", "=", "self", ".", "convert", "(", "\n", "img", "[", ":", ",", ":", ",", "1", "]", ",", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "saturation_low", ",", "self", ".", "saturation_high", ")", "\n", ")", "\n", "return", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_HSV2BGR", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.JosephKJ_OWOD.point_rend.color_augmentation.ColorAugSSDTransform.hue": [[91, 99], ["random.randrange", "cv2.cvtColor", "cv2.cvtColor", "img[].astype", "random.randint"], "methods", ["None"], ["", "def", "hue", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "            ", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2HSV", ")", "\n", "img", "[", ":", ",", ":", ",", "0", "]", "=", "(", "\n", "img", "[", ":", ",", ":", ",", "0", "]", ".", "astype", "(", "int", ")", "+", "random", ".", "randint", "(", "-", "self", ".", "hue_delta", ",", "self", ".", "hue_delta", ")", "\n", ")", "%", "180", "\n", "return", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_HSV2BGR", ")", "\n", "", "return", "img", "\n", "", "", ""]]}