{"home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.FieldOfView.__init__": [[19, 26], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "min_range", ",", "max_range", ",", "max_range_rate", ",", "min_theta", ",", "max_theta", ")", ":", "\n", "        ", "self", ".", "min_range", "=", "min_range", "\n", "self", ".", "max_range", "=", "max_range", "\n", "self", ".", "min_range_rate", "=", "-", "max_range_rate", "\n", "self", ".", "max_range_rate", "=", "max_range_rate", "\n", "self", ".", "min_theta", "=", "min_theta", "\n", "self", ".", "max_theta", "=", "max_theta", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.FieldOfView.__contains__": [[27, 36], ["None"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "measurement", ")", ":", "\n", "        ", "if", "not", "(", "self", ".", "min_range", "<=", "measurement", "[", "0", "]", "<=", "self", ".", "max_range", ")", ":", "\n", "            ", "return", "False", "\n", "", "elif", "not", "(", "self", ".", "min_range_rate", "<=", "measurement", "[", "1", "]", "<=", "self", ".", "max_range_rate", ")", ":", "\n", "            ", "return", "False", "\n", "", "elif", "not", "(", "self", ".", "min_theta", "<=", "measurement", "[", "2", "]", "<=", "self", ".", "max_theta", ")", ":", "\n", "            ", "return", "False", "\n", "", "else", ":", "\n", "            ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.FieldOfView.area": [[37, 42], ["None"], "methods", ["None"], ["", "", "def", "area", "(", "self", ")", ":", "\n", "        ", "range_length", "=", "self", ".", "max_range", "-", "self", ".", "min_range", "\n", "range_rate_length", "=", "self", ".", "max_range_rate", "-", "self", ".", "min_range_rate", "\n", "theta_length", "=", "self", ".", "max_theta", "-", "self", ".", "min_theta", "\n", "return", "range_length", "*", "range_rate_length", "*", "theta_length", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.Object.__init__": [[46, 56], ["numpy.array", "numpy.array", "numpy.concatenate", "numpy.array"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "pos", ",", "vel", ",", "t", ",", "delta_t", ",", "sigma", ",", "id", ")", ":", "\n", "        ", "self", ".", "pos", "=", "pos", "\n", "self", ".", "vel", "=", "vel", "\n", "self", ".", "delta_t", "=", "delta_t", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "state_history", "=", "np", ".", "array", "(", "[", "np", ".", "concatenate", "(", "[", "pos", ",", "vel", ",", "np", ".", "array", "(", "[", "t", "]", ")", "]", ")", "]", ")", "\n", "self", ".", "process_noise_matrix", "=", "sigma", "*", "np", ".", "array", "(", "[", "[", "delta_t", "**", "3", "/", "3", ",", "delta_t", "**", "2", "/", "2", "]", ",", "[", "delta_t", "**", "2", "/", "2", ",", "delta_t", "]", "]", ")", "\n", "\n", "# Unique identifier for every object", "\n", "self", ".", "id", "=", "id", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.Object.update": [[57, 71], ["rng.multivariate_normal", "numpy.concatenate", "numpy.vstack", "len", "len", "len", "mot_data_generation.Object.pos.copy", "mot_data_generation.Object.vel.copy", "numpy.array"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "t", ",", "rng", ")", ":", "\n", "        ", "\"\"\"\n        Updates this object's state using a discretized constant velocity model.\n        \"\"\"", "\n", "\n", "# Update position and velocity of the object in each dimension separately", "\n", "assert", "len", "(", "self", ".", "pos", ")", "==", "len", "(", "self", ".", "vel", ")", "\n", "process_noise", "=", "rng", ".", "multivariate_normal", "(", "[", "0", ",", "0", "]", ",", "self", ".", "process_noise_matrix", ",", "size", "=", "len", "(", "self", ".", "pos", ")", ")", "\n", "self", ".", "pos", "+=", "self", ".", "delta_t", "*", "self", ".", "vel", "+", "process_noise", "[", ":", ",", "0", "]", "\n", "self", ".", "vel", "+=", "process_noise", "[", ":", ",", "1", "]", "\n", "\n", "# Add current state to previous states", "\n", "current_state", "=", "np", ".", "concatenate", "(", "[", "self", ".", "pos", ".", "copy", "(", ")", ",", "self", ".", "vel", ".", "copy", "(", ")", ",", "np", ".", "array", "(", "[", "t", "]", ")", "]", ")", "\n", "self", ".", "state_history", "=", "np", ".", "vstack", "(", "(", "self", ".", "state_history", ",", "current_state", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.Object.__repr__": [[72, 74], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'id: {}, pos: {}, vel: {}'", ".", "format", "(", "self", ".", "id", ",", "self", ".", "pos", ",", "self", ".", "vel", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.__init__": [[77, 134], ["mot_data_generation.FieldOfView", "mot_data_generation.MotDataGenerator.reset", "ValueError", "globals", "NotImplementedError", "modules.realistic_radar_model.realistic_meas_model.RealisticMeasModel", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.reset"], ["    ", "def", "__init__", "(", "self", ",", "args", ",", "rng", ")", ":", "\n", "        ", "if", "not", "(", "isinstance", "(", "args", ".", "data_generation", ".", "measurement_noise_stds", ",", "list", ")", "and", "\n", "len", "(", "args", ".", "data_generation", ".", "measurement_noise_stds", ")", "==", "3", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Specified measurement noise should be a list with three elements, got \"", "\n", "f\"'{args.data_generation.measurement_noise_stds}' instead\"", ")", "\n", "\n", "", "self", ".", "start_pos_params", "=", "[", "args", ".", "data_generation", ".", "birth_process", ".", "mean_pos", ",", "args", ".", "data_generation", ".", "birth_process", ".", "cov_pos", "]", "\n", "self", ".", "start_vel_params", "=", "[", "args", ".", "data_generation", ".", "birth_process", ".", "mean_vel", ",", "args", ".", "data_generation", ".", "birth_process", ".", "cov_vel", "]", "\n", "self", ".", "prob_add_obj", "=", "args", ".", "data_generation", ".", "p_add", "\n", "self", ".", "prob_remove_obj", "=", "args", ".", "data_generation", ".", "p_remove", "\n", "self", ".", "delta_t", "=", "args", ".", "data_generation", ".", "dt", "\n", "self", ".", "process_noise_variance", "=", "args", ".", "data_generation", ".", "process_noise_variance", "\n", "self", ".", "prob_measure", "=", "args", ".", "data_generation", ".", "p_meas", "\n", "self", ".", "measurement_noise_stds", "=", "args", ".", "data_generation", ".", "measurement_noise_stds", "\n", "self", ".", "n_average_false_measurements", "=", "args", ".", "data_generation", ".", "n_avg_false_measurements", "\n", "self", ".", "n_average_starting_objects", "=", "args", ".", "data_generation", ".", "n_avg_starting_objects", "\n", "field_of_view_min_theta", "=", "args", ".", "data_generation", ".", "field_of_view", ".", "min_theta", "if", "args", ".", "data_generation", ".", "field_of_view", ".", "min_theta", "is", "not", "None", "else", "-", "np", ".", "pi", "\n", "field_of_view_max_theta", "=", "args", ".", "data_generation", ".", "field_of_view", ".", "max_theta", "if", "args", ".", "data_generation", ".", "field_of_view", ".", "max_theta", "is", "not", "None", "else", "np", ".", "pi", "\n", "self", ".", "field_of_view", "=", "FieldOfView", "(", "args", ".", "data_generation", ".", "field_of_view", ".", "min_range", ",", "\n", "args", ".", "data_generation", ".", "field_of_view", ".", "max_range", ",", "\n", "args", ".", "data_generation", ".", "field_of_view", ".", "max_range_rate", ",", "\n", "field_of_view_min_theta", ",", "\n", "field_of_view_max_theta", ")", "\n", "self", ".", "max_objects", "=", "args", ".", "data_generation", ".", "max_objects", "\n", "self", ".", "use_realistic_meas_noise", "=", "args", ".", "data_generation", ".", "use_realistic_meas_noise", "\n", "if", "f'get_{args.data_generation.prediction_target}_from_state'", "in", "globals", "(", ")", ":", "\n", "            ", "self", ".", "prediction_target", "=", "args", ".", "data_generation", ".", "prediction_target", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f'The chosen function for mapping state to ground-truth was no implemented: {args.data_generation.prediction_target}'", ")", "\n", "", "self", ".", "rng", "=", "rng", "\n", "self", ".", "debug", "=", "False", "\n", "\n", "if", "self", ".", "use_realistic_meas_noise", ":", "\n", "            ", "self", ".", "realistic_meas_computer", "=", "RealisticMeasModel", "(", ")", "\n", "\n", "# Make sure we're using hyperparameters compatible to the ones used to precompute the covariance matrices of", "\n", "# the realistic measurement model", "\n", "for", "s_y", "in", "args", ".", "data_generation", ".", "measurement_noise_stds", ":", "\n", "                ", "assert", "s_y", "is", "None", ",", "f\"When using realistic measurement model sigma_y must be [None, None, None], but \"", "f\"got {args.data_generation.measurement_noise_stds} instead.\"", "\n", "", "assert", "args", ".", "data_generation", ".", "field_of_view", ".", "min_range", ">=", "self", ".", "realistic_meas_computer", ".", "min_r", "\n", "assert", "args", ".", "data_generation", ".", "field_of_view", ".", "max_range", "<=", "self", ".", "realistic_meas_computer", ".", "max_r", "\n", "assert", "args", ".", "data_generation", ".", "field_of_view", ".", "min_theta", ">=", "self", ".", "realistic_meas_computer", ".", "min_theta", "\n", "assert", "args", ".", "data_generation", ".", "field_of_view", ".", "max_theta", "<=", "self", ".", "realistic_meas_computer", ".", "max_theta", "\n", "", "else", ":", "\n", "            ", "for", "s_y", "in", "args", ".", "data_generation", ".", "measurement_noise_stds", ":", "\n", "                ", "assert", "s_y", "is", "not", "None", ",", "f\"Measurement noise cannot be None. Got {args.data_generation.measurement_noise_stds}.\"", "\n", "\n", "", "", "assert", "self", ".", "n_average_starting_objects", "!=", "0", ",", "'Datagen does not currently work with n_avg_starting_objects equal to zero.'", "\n", "\n", "self", ".", "t", "=", "None", "\n", "self", ".", "objects", "=", "None", "\n", "self", ".", "trajectories", "=", "None", "\n", "self", ".", "measurements", "=", "None", "\n", "self", ".", "unique_ids", "=", "None", "\n", "self", ".", "unique_id_counter", "=", "None", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.reset": [[135, 154], ["numpy.array", "numpy.array", "itertools.count", "mot_data_generation.MotDataGenerator.add_objects", "mot_data_generation.MotDataGenerator.generate_measurements", "mot_data_generation.MotDataGenerator.rng.poisson", "print"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.add_objects", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.generate_measurements"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "t", "=", "0", "\n", "self", ".", "objects", "=", "[", "]", "\n", "self", ".", "trajectories", "=", "{", "}", "\n", "self", ".", "measurements", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "self", ".", "unique_ids", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "'int64'", ")", "\n", "self", ".", "unique_id_counter", "=", "itertools", ".", "count", "(", ")", "\n", "\n", "# Add initial set of objects (re-sample until we get a nonzero value)", "\n", "n_starting_objects", "=", "0", "\n", "while", "n_starting_objects", "==", "0", ":", "\n", "            ", "n_starting_objects", "=", "self", ".", "rng", ".", "poisson", "(", "self", ".", "n_average_starting_objects", ")", "\n", "", "self", ".", "add_objects", "(", "n_starting_objects", ")", "\n", "\n", "# Measure the initial set of objects", "\n", "self", ".", "generate_measurements", "(", ")", "\n", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "print", "(", "n_starting_objects", ",", "'starting objects'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.create_new_object": [[155, 162], ["mot_data_generation.Object", "next"], "methods", ["None"], ["", "", "def", "create_new_object", "(", "self", ",", "pos", ",", "vel", ")", ":", "\n", "        ", "return", "Object", "(", "pos", "=", "pos", ",", "\n", "vel", "=", "vel", ",", "\n", "t", "=", "self", ".", "t", ",", "\n", "delta_t", "=", "self", ".", "delta_t", ",", "\n", "sigma", "=", "self", ".", "process_noise_variance", ",", "\n", "id", "=", "next", "(", "self", ".", "unique_id_counter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.create_n_objects": [[163, 175], ["mot_data_generation.MotDataGenerator.rng.multivariate_normal", "mot_data_generation.MotDataGenerator.rng.multivariate_normal", "zip", "mot_data_generation.MotDataGenerator.create_new_object", "mot_data_generation.get_radar_measurement", "objects.append"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.create_new_object", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.get_radar_measurement"], ["", "def", "create_n_objects", "(", "self", ",", "n", ")", ":", "\n", "        ", "\"\"\"\n        Create `n` objects according to Gaussian birth model. Objects outside measurement FOV are discarded.\n        \"\"\"", "\n", "positions", "=", "self", ".", "rng", ".", "multivariate_normal", "(", "self", ".", "start_pos_params", "[", "0", "]", ",", "self", ".", "start_pos_params", "[", "1", "]", ",", "size", "=", "(", "n", ",", ")", ")", "\n", "velocities", "=", "self", ".", "rng", ".", "multivariate_normal", "(", "self", ".", "start_vel_params", "[", "0", "]", ",", "self", ".", "start_vel_params", "[", "1", "]", ",", "size", "=", "(", "n", ",", ")", ")", "\n", "objects", "=", "[", "]", "\n", "for", "pos", ",", "vel", "in", "zip", "(", "positions", ",", "velocities", ")", ":", "\n", "            ", "obj", "=", "self", ".", "create_new_object", "(", "pos", ",", "vel", ")", "\n", "if", "get_radar_measurement", "(", "obj", ")", "in", "self", ".", "field_of_view", ":", "\n", "                ", "objects", ".", "append", "(", "obj", ")", "\n", "", "", "return", "objects", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.add_objects": [[176, 188], ["min", "mot_data_generation.MotDataGenerator.create_n_objects", "len"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.create_n_objects"], ["", "def", "add_objects", "(", "self", ",", "n", ")", ":", "\n", "        ", "\"\"\"\n        Adds `n` new objects to `objects` list.\n        \"\"\"", "\n", "# Never add more objects than the maximum number of allowed objects", "\n", "n", "=", "min", "(", "n", ",", "self", ".", "max_objects", "-", "len", "(", "self", ".", "objects", ")", ")", "\n", "if", "n", "==", "0", ":", "\n", "            ", "return", "\n", "\n", "# Create new objects and save them in the datagen", "\n", "", "new_objects", "=", "self", ".", "create_n_objects", "(", "n", ")", "\n", "self", ".", "objects", "+=", "new_objects", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.remove_far_away_objects": [[189, 205], ["numpy.array", "zip", "len", "mot_data_generation.get_radar_measurement", "zip"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.get_radar_measurement"], ["", "def", "remove_far_away_objects", "(", "self", ")", ":", "\n", "\n", "        ", "if", "len", "(", "self", ".", "objects", ")", "==", "0", ":", "\n", "            ", "return", "\n", "\n", "# Check which objects left the FOV", "\n", "", "meas_coordinates_of_objects", "=", "np", ".", "array", "(", "[", "get_radar_measurement", "(", "obj", ")", "for", "obj", "in", "self", ".", "objects", "]", ")", "\n", "deaths", "=", "[", "meas_obj", "not", "in", "self", ".", "field_of_view", "for", "meas_obj", "in", "meas_coordinates_of_objects", "]", "\n", "\n", "# Save state history of objects that will be removed in self.trajectories", "\n", "for", "obj", ",", "death", "in", "zip", "(", "self", ".", "objects", ",", "deaths", ")", ":", "\n", "            ", "if", "death", ":", "\n", "                ", "self", ".", "trajectories", "[", "obj", ".", "id", "]", "=", "obj", ".", "state_history", "[", ":", "-", "1", "]", "\n", "\n", "# Remove objects that left the measurement FOV", "\n", "", "", "self", ".", "objects", "=", "[", "o", "for", "o", ",", "r", "in", "zip", "(", "self", ".", "objects", ",", "deaths", ")", "if", "not", "r", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.remove_objects": [[206, 225], ["mot_data_generation.MotDataGenerator.rng.binomial", "sum", "zip", "print", "len", "zip"], "methods", ["None"], ["", "def", "remove_objects", "(", "self", ",", "p", ")", ":", "\n", "        ", "\"\"\"\n        Removes each of the objects with probability `p`.\n        \"\"\"", "\n", "\n", "# Compute which objects are removed in this time-step", "\n", "deaths", "=", "self", ".", "rng", ".", "binomial", "(", "n", "=", "1", ",", "p", "=", "p", ",", "size", "=", "len", "(", "self", ".", "objects", ")", ")", "\n", "\n", "n_deaths", "=", "sum", "(", "deaths", ")", "\n", "if", "self", ".", "debug", "and", "(", "n_deaths", ">", "0", ")", ":", "\n", "            ", "print", "(", "n_deaths", ",", "'objects were removed'", ")", "\n", "\n", "# Save the trajectories of the removed objects", "\n", "", "for", "obj", ",", "death", "in", "zip", "(", "self", ".", "objects", ",", "deaths", ")", ":", "\n", "            ", "if", "death", ":", "\n", "                ", "self", ".", "trajectories", "[", "obj", ".", "id", "]", "=", "obj", ".", "state_history", "\n", "\n", "# Remove them from the object list", "\n", "", "", "self", ".", "objects", "=", "[", "o", "for", "o", ",", "d", "in", "zip", "(", "self", ".", "objects", ",", "deaths", ")", "if", "not", "d", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.get_prob_death": [[226, 228], ["None"], "methods", ["None"], ["", "def", "get_prob_death", "(", "self", ",", "obj", ")", ":", "\n", "        ", "return", "self", ".", "prob_remove_obj", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.remove_object": [[229, 242], ["mot_data_generation.MotDataGenerator.rng.rand", "mot_data_generation.MotDataGenerator.get_prob_death"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.get_prob_death"], ["", "def", "remove_object", "(", "self", ",", "obj", ",", "p", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Removes an object based on its state\n        \"\"\"", "\n", "if", "p", "is", "None", ":", "\n", "            ", "p", "=", "self", ".", "get_prob_death", "(", "obj", ")", "\n", "\n", "", "r", "=", "self", ".", "rng", ".", "rand", "(", ")", "\n", "\n", "if", "r", "<", "p", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.generate_measurements": [[243, 305], ["mot_data_generation.MotDataGenerator.rng.binomial", "enumerate", "numpy.array", "mot_data_generation.MotDataGenerator.rng.poisson", "mot_data_generation.MotDataGenerator.rng.uniform", "numpy.repeat", "numpy.concatenate", "numpy.array", "mot_data_generation.MotDataGenerator.rng.permutation", "numpy.hstack", "numpy.array", "mot_data_generation.MotDataGenerator.realistic_meas_computer.compute_covariance", "len", "numpy.array", "mot_data_generation.MotDataGenerator.rng.normal", "mot_data_generation.get_radar_measurement", "numpy.append", "len", "numpy.vstack", "len", "numpy.vstack", "len", "zip", "numpy.array.append", "mot_data_generation.get_radar_measurement", "mot_data_generation.MotDataGenerator.rng.multivariate_normal", "numpy.zeros", "len"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.realistic_radar_model.realistic_meas_model.RealisticMeasModel.compute_covariance", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.get_radar_measurement", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.get_radar_measurement"], ["", "", "def", "generate_measurements", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Generates all measurements (true and false) for the current time-step.\n        \"\"\"", "\n", "\n", "# Decide which of the objects will be measured", "\n", "is_measured", "=", "self", ".", "rng", ".", "binomial", "(", "n", "=", "1", ",", "p", "=", "self", ".", "prob_measure", ",", "size", "=", "len", "(", "self", ".", "objects", ")", ")", "\n", "measured_objects", "=", "[", "obj", "for", "obj", ",", "is_measured", "in", "zip", "(", "self", ".", "objects", ",", "is_measured", ")", "if", "is_measured", "]", "\n", "\n", "# Generate the true measurements' noise", "\n", "true_measurements", "=", "[", "]", "\n", "if", "self", ".", "use_realistic_meas_noise", ":", "\n", "            ", "positions", "=", "np", ".", "array", "(", "[", "get_radar_measurement", "(", "obj", ")", "for", "obj", "in", "measured_objects", "]", ")", "\n", "measurement_covs", "=", "self", ".", "realistic_meas_computer", ".", "compute_covariance", "(", "positions", ")", "\n", "dim_measurements", "=", "len", "(", "self", ".", "measurement_noise_stds", ")", "\n", "measurement_noises", "=", "np", ".", "array", "(", "[", "self", ".", "rng", ".", "multivariate_normal", "(", "np", ".", "zeros", "(", "dim_measurements", ")", ",", "cov", ")", "for", "cov", "in", "measurement_covs", "]", ")", "\n", "", "else", ":", "\n", "            ", "measurement_noises", "=", "self", ".", "rng", ".", "normal", "(", "0", ",", "self", ".", "measurement_noise_stds", ",", "size", "=", "(", "len", "(", "measured_objects", ")", ",", "3", ")", ")", "\n", "\n", "# Generate true measurements (making sure they're inside the FOV)", "\n", "", "for", "i", ",", "obj", "in", "enumerate", "(", "measured_objects", ")", ":", "\n", "            ", "m", "=", "get_radar_measurement", "(", "obj", ")", "\n", "measurement_with_time", "=", "np", ".", "append", "(", "m", "+", "measurement_noises", "[", "i", ",", ":", "]", ",", "self", ".", "t", ")", "\n", "if", "measurement_with_time", "[", ":", "-", "1", "]", "in", "self", ".", "field_of_view", ":", "\n", "                ", "true_measurements", ".", "append", "(", "measurement_with_time", ")", "\n", "", "", "true_measurements", "=", "np", ".", "array", "(", "true_measurements", ")", "\n", "\n", "unique_obj_ids_true", "=", "[", "obj", ".", "id", "for", "obj", "in", "measured_objects", "]", "\n", "\n", "# Generate false measurements (uniformly distributed over measurement FOV)", "\n", "n_false_measurements", "=", "self", ".", "rng", ".", "poisson", "(", "self", ".", "n_average_false_measurements", ")", "\n", "false_measurements", "=", "self", ".", "rng", ".", "uniform", "(", "low", "=", "[", "self", ".", "field_of_view", ".", "min_range", ",", "-", "self", ".", "field_of_view", ".", "max_range_rate", ",", "self", ".", "field_of_view", ".", "min_theta", "]", ",", "\n", "high", "=", "[", "self", ".", "field_of_view", ".", "max_range", ",", "self", ".", "field_of_view", ".", "max_range_rate", ",", "self", ".", "field_of_view", ".", "max_theta", "]", ",", "\n", "size", "=", "(", "n_false_measurements", ",", "3", ")", ")", "\n", "\n", "# Add time to false measurements", "\n", "times", "=", "np", ".", "repeat", "(", "[", "[", "self", ".", "t", "]", "]", ",", "n_false_measurements", ",", "axis", "=", "0", ")", "\n", "false_measurements", "=", "np", ".", "concatenate", "(", "[", "false_measurements", ",", "times", "]", ",", "1", ")", "\n", "\n", "# Also save from which object each measurement came from (for contrastive learning later); -1 is for false meas.", "\n", "unique_obj_ids_false", "=", "[", "-", "1", "]", "*", "len", "(", "false_measurements", ")", "\n", "unique_obj_ids", "=", "np", ".", "array", "(", "unique_obj_ids_true", "+", "unique_obj_ids_false", ")", "\n", "\n", "# Concatenate true and false measurements in a single array", "\n", "if", "true_measurements", ".", "shape", "[", "0", "]", "and", "false_measurements", ".", "shape", "[", "0", "]", ":", "\n", "            ", "new_measurements", "=", "np", ".", "vstack", "(", "[", "true_measurements", ",", "false_measurements", "]", ")", "\n", "", "elif", "true_measurements", ".", "shape", "[", "0", "]", ":", "\n", "            ", "new_measurements", "=", "true_measurements", "\n", "", "elif", "false_measurements", ".", "shape", "[", "0", "]", ":", "\n", "            ", "new_measurements", "=", "false_measurements", "\n", "", "else", ":", "\n", "            ", "return", "\n", "\n", "# Shuffle all generated measurements and corresponding unique ids in unison", "\n", "", "random_idxs", "=", "self", ".", "rng", ".", "permutation", "(", "len", "(", "new_measurements", ")", ")", "\n", "new_measurements", "=", "new_measurements", "[", "random_idxs", "]", "\n", "unique_obj_ids", "=", "unique_obj_ids", "[", "random_idxs", "]", "\n", "\n", "# Save measurements and unique ids", "\n", "self", ".", "measurements", "=", "np", ".", "vstack", "(", "[", "self", ".", "measurements", ",", "new_measurements", "]", ")", "if", "self", ".", "measurements", ".", "shape", "[", "0", "]", "else", "new_measurements", "\n", "self", ".", "unique_ids", "=", "np", ".", "hstack", "(", "[", "self", ".", "unique_ids", ",", "unique_obj_ids", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.step": [[306, 334], ["mot_data_generation.MotDataGenerator.remove_far_away_objects", "mot_data_generation.MotDataGenerator.remove_objects", "mot_data_generation.MotDataGenerator.generate_measurements", "obj.update", "mot_data_generation.MotDataGenerator.rng.poisson", "mot_data_generation.MotDataGenerator.add_objects", "print", "print", "len"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.remove_far_away_objects", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.remove_objects", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.generate_measurements", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.Object.update", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.add_objects"], ["", "def", "step", "(", "self", ",", "add_new_objects", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Performs one step of the simulation.\n        \"\"\"", "\n", "self", ".", "t", "+=", "self", ".", "delta_t", "\n", "\n", "# Update the remaining ones", "\n", "for", "obj", "in", "self", ".", "objects", ":", "\n", "            ", "obj", ".", "update", "(", "self", ".", "t", ",", "self", ".", "rng", ")", "\n", "\n", "# Remove objects that left the field-of-view", "\n", "", "self", ".", "remove_far_away_objects", "(", ")", "\n", "\n", "# Add new objects", "\n", "if", "add_new_objects", ":", "\n", "            ", "n_new_objs", "=", "self", ".", "rng", ".", "poisson", "(", "self", ".", "prob_add_obj", ")", "\n", "self", ".", "add_objects", "(", "n_new_objs", ")", "\n", "\n", "# Remove some of the objects", "\n", "", "self", ".", "remove_objects", "(", "self", ".", "prob_remove_obj", ")", "\n", "\n", "# Generate measurements", "\n", "self", ".", "generate_measurements", "(", ")", "\n", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "if", "n_new_objs", ">", "0", ":", "\n", "                ", "print", "(", "n_new_objs", ",", "'objects were added'", ")", "\n", "", "print", "(", "len", "(", "self", ".", "objects", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.finish": [[335, 359], ["mot_data_generation.MotDataGenerator.remove_objects", "round", "numpy.array", "mot_data_generation.MotDataGenerator.unique_ids.copy", "mot_data_generation.MotDataGenerator.measurements.copy", "round", "label_data.append", "unique_label_ids.append", "globals"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.remove_objects"], ["", "", "def", "finish", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Should be called after the last call to `self.step()`. Removes the remaining objects, consequently adding the\n        remaining parts of their trajectories to `self.trajectories`.\n        \"\"\"", "\n", "self", ".", "remove_objects", "(", "1.0", ")", "\n", "\n", "label_data", "=", "[", "]", "\n", "unique_label_ids", "=", "[", "]", "\n", "\n", "# -1 is applied because we count t=0 as one time-step", "\n", "last_timestep", "=", "round", "(", "self", ".", "t", "/", "self", ".", "delta_t", ")", "\n", "for", "traj_id", "in", "self", ".", "trajectories", ":", "\n", "            ", "traj", "=", "self", ".", "trajectories", "[", "traj_id", "]", "\n", "last_state", "=", "traj", "[", "-", "1", "]", "\n", "if", "round", "(", "last_state", "[", "4", "]", "/", "self", ".", "delta_t", ")", "==", "last_timestep", ":", "# last state of trajectory, time", "\n", "                ", "pos", "=", "globals", "(", ")", "[", "f'get_{self.prediction_target}_from_state'", "]", "(", "last_state", ")", "\n", "label_data", ".", "append", "(", "pos", ")", "\n", "unique_label_ids", ".", "append", "(", "traj_id", ")", "\n", "\n", "", "", "training_data", "=", "np", ".", "array", "(", "self", ".", "measurements", ".", "copy", "(", ")", ")", "\n", "unique_measurements_ids", "=", "self", ".", "unique_ids", ".", "copy", "(", ")", "\n", "\n", "return", "training_data", ",", "label_data", ",", "unique_measurements_ids", ",", "unique_label_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.get_radar_measurement": [[6, 16], ["numpy.linalg.norm", "numpy.dot", "numpy.arctan2", "numpy.array", "numpy.linalg.norm"], "function", ["None"], ["def", "get_radar_measurement", "(", "obj", ")", ":", "\n", "    ", "\"\"\"\n    Creates a measurement of (range, range_rate, azimuth angle) from an object, without any measurement noise.\n    @param obj:\n    @return:\n    \"\"\"", "\n", "range", "=", "np", ".", "linalg", ".", "norm", "(", "obj", ".", "pos", ")", "\n", "range_rate", "=", "np", ".", "dot", "(", "obj", ".", "pos", "/", "np", ".", "linalg", ".", "norm", "(", "obj", ".", "pos", ")", ",", "obj", ".", "vel", ")", "\n", "azimuth", "=", "np", ".", "arctan2", "(", "obj", ".", "pos", "[", "1", "]", ",", "obj", ".", "pos", "[", "0", "]", ")", "\n", "return", "np", ".", "array", "(", "[", "range", ",", "range_rate", ",", "azimuth", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.get_position_and_velocity_from_state": [[361, 363], ["state[].copy"], "function", ["None"], ["", "", "def", "get_position_and_velocity_from_state", "(", "state", ")", ":", "\n", "    ", "return", "state", "[", ":", "4", "]", ".", "copy", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.data_generator.DataGenerator.__init__": [[13, 28], ["multiprocessing.Pool", "numpy.random.SeedSequence", "data_generation.mot_data_generation.MotDataGenerator", "numpy.random.default_rng", "len", "numpy.random.SeedSequence.spawn"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "params", ",", "rngs", "=", "None", ")", ":", "\n", "        ", "self", ".", "params", "=", "params", "\n", "assert", "0", "<=", "params", ".", "data_generation", ".", "n_prediction_lag", "<=", "params", ".", "data_generation", ".", "n_timesteps", ",", "\"Prediction lag has to be smaller than the total number of time-steps.\"", "\n", "self", ".", "device", "=", "params", ".", "training", ".", "device", "\n", "self", ".", "n_timesteps", "=", "params", ".", "data_generation", ".", "n_timesteps", "\n", "\n", "self", ".", "pool", "=", "multiprocessing", ".", "Pool", "(", ")", "\n", "\n", "# Create `batch_size` data generators, each with its own independent (to a high probability) RNG", "\n", "ss", "=", "SeedSequence", "(", "params", ".", "data_generation", ".", "seed", ")", "\n", "if", "rngs", "is", "None", ":", "\n", "            ", "rngs", "=", "[", "default_rng", "(", "s", ")", "for", "s", "in", "ss", ".", "spawn", "(", "params", ".", "training", ".", "batch_size", ")", "]", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "rngs", ")", "==", "params", ".", "training", ".", "batch_size", ",", "'The number of provided RNGs must match the desired batch size'", "\n", "", "self", ".", "datagens", "=", "[", "MotDataGenerator", "(", "params", ",", "rng", "=", "rng", ")", "for", "rng", "in", "rngs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.data_generator.DataGenerator.get_batch": [[29, 62], ["tuple", "list", "list", "zip", "max", "data_generator.pad_to_batch_max", "range", "numpy.concatenate", "util.misc.NestedTensor", "torch.Tensor().to", "len", "data_generator.DataGenerator.pool.starmap", "zip", "torch.Tensor().to", "list", "list", "len", "torch.Tensor().to", "torch.Tensor().bool().to", "zip", "data_generator.get_single_training_example", "torch.device", "map", "len", "numpy.concatenate", "torch.device", "torch.device", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor().bool", "len", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.pad_to_batch_max", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.data_generator.get_single_training_example"], ["", "def", "get_batch", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "datagens", ")", "!=", "1", ":", "\n", "            ", "results", "=", "self", ".", "pool", ".", "starmap", "(", "get_single_training_example", ",", "zip", "(", "self", ".", "datagens", ",", "[", "self", ".", "n_timesteps", "]", "*", "len", "(", "self", ".", "datagens", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "results", "=", "[", "get_single_training_example", "(", "self", ".", "datagens", "[", "0", "]", ",", "self", ".", "n_timesteps", ")", "]", "\n", "\n", "# Unpack results", "\n", "", "training_data", ",", "labels", ",", "unique_measurement_ids", ",", "unique_label_ids", ",", "trajectories", ",", "new_rngs", "=", "tuple", "(", "zip", "(", "*", "results", ")", ")", "\n", "labels", "=", "[", "Tensor", "(", "l", ")", ".", "to", "(", "torch", ".", "device", "(", "self", ".", "device", ")", ")", "for", "l", "in", "labels", "]", "\n", "trajectories", "=", "list", "(", "trajectories", ")", "\n", "unique_measurement_ids", "=", "[", "list", "(", "u", ")", "for", "u", "in", "unique_measurement_ids", "]", "\n", "unique_label_ids", "=", "list", "(", "unique_label_ids", ")", "\n", "\n", "# Update the RNGs of all the datagens for next call", "\n", "for", "datagen", ",", "new_rng", "in", "zip", "(", "self", ".", "datagens", ",", "new_rngs", ")", ":", "\n", "            ", "datagen", ".", "rng", "=", "new_rng", "\n", "\n", "# Pad training data", "\n", "", "max_len", "=", "max", "(", "list", "(", "map", "(", "len", ",", "training_data", ")", ")", ")", "\n", "training_data", ",", "mask", "=", "pad_to_batch_max", "(", "training_data", ",", "max_len", ")", "\n", "\n", "# Pad unique ids", "\n", "for", "i", "in", "range", "(", "len", "(", "unique_measurement_ids", ")", ")", ":", "\n", "            ", "unique_id", "=", "unique_measurement_ids", "[", "i", "]", "\n", "n_items_to_add", "=", "max_len", "-", "len", "(", "unique_id", ")", "\n", "unique_measurement_ids", "[", "i", "]", "=", "np", ".", "concatenate", "(", "[", "unique_id", ",", "[", "-", "2", "]", "*", "n_items_to_add", "]", ")", "[", "None", ",", ":", "]", "\n", "", "unique_measurement_ids", "=", "np", ".", "concatenate", "(", "unique_measurement_ids", ")", "\n", "\n", "training_nested_tensor", "=", "NestedTensor", "(", "Tensor", "(", "training_data", ")", ".", "to", "(", "torch", ".", "device", "(", "self", ".", "device", ")", ")", ",", "\n", "Tensor", "(", "mask", ")", ".", "bool", "(", ")", ".", "to", "(", "torch", ".", "device", "(", "self", ".", "device", ")", ")", ")", "\n", "unique_measurement_ids", "=", "Tensor", "(", "unique_measurement_ids", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "return", "training_nested_tensor", ",", "labels", ",", "unique_measurement_ids", ",", "unique_label_ids", ",", "trajectories", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.data_generator.DataGenerator.__del__": [[63, 65], ["data_generator.DataGenerator.pool.close"], "methods", ["None"], ["", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "self", ".", "pool", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.data_generator.pad_to_batch_max": [[67, 77], ["len", "numpy.zeros", "numpy.ones", "enumerate", "len", "len"], "function", ["None"], ["", "", "def", "pad_to_batch_max", "(", "training_data", ",", "max_len", ")", ":", "\n", "    ", "batch_size", "=", "len", "(", "training_data", ")", "\n", "d_meas", "=", "training_data", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "training_data_padded", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "max_len", ",", "d_meas", ")", ")", "\n", "mask", "=", "np", ".", "ones", "(", "(", "batch_size", ",", "max_len", ")", ")", "\n", "for", "i", ",", "ex", "in", "enumerate", "(", "training_data", ")", ":", "\n", "        ", "training_data_padded", "[", "i", ",", ":", "len", "(", "ex", ")", ",", ":", "]", "=", "ex", "\n", "mask", "[", "i", ",", ":", "len", "(", "ex", ")", "]", "=", "0", "\n", "\n", "", "return", "training_data_padded", ",", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.data_generator.get_single_training_example": [[79, 100], ["data_generator.reset", "data_generator.reset", "range", "data_generator.finish", "numpy.array().reshape", "data_generator.trajectories.copy", "len", "len", "data_generator.step", "len", "numpy.array"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.reset", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.reset", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.finish", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.MotDataGenerator.step"], ["", "def", "get_single_training_example", "(", "data_generator", ",", "n_timesteps", ")", ":", "\n", "    ", "\"\"\"Generates a single training example\n\n    Returns:\n        training_data   : A single training example\n        true_data       : Ground truth for example\n    \"\"\"", "\n", "\n", "data_generator", ".", "reset", "(", ")", "\n", "label_data", "=", "[", "]", "\n", "\n", "while", "len", "(", "label_data", ")", "==", "0", "or", "len", "(", "data_generator", ".", "measurements", ")", "==", "0", ":", "\n", "# Generate n_timesteps of data, from scratch", "\n", "        ", "data_generator", ".", "reset", "(", ")", "\n", "for", "i", "in", "range", "(", "n_timesteps", "-", "1", ")", ":", "\n", "            ", "data_generator", ".", "step", "(", ")", "\n", "", "training_data", ",", "label_data", ",", "unique_measurement_ids", ",", "unique_label_ids", "=", "data_generator", ".", "finish", "(", ")", "\n", "\n", "", "new_rng", "=", "data_generator", ".", "rng", "\n", "return", "training_data", ",", "np", ".", "array", "(", "label_data", ")", ".", "reshape", "(", "len", "(", "label_data", ")", ",", "-", "1", ")", ",", "unique_measurement_ids", ",", "unique_label_ids", ",", "data_generator", ".", "trajectories", ".", "copy", "(", ")", ",", "new_rng", "\n", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.matcher.HungarianMatcher.__init__": [[13, 18], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__"], ["def", "__init__", "(", "self", ",", "order", ",", "cutoff_distance", ",", "alpha", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "order", "=", "order", "\n", "self", ".", "cutoff_distance", "=", "cutoff_distance", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.matcher.HungarianMatcher.forward": [[19, 61], ["torch.no_grad", "outputs.flatten", "torch.cat", "cost.view().cpu.view().cpu.clamp_max", "cost.view().cpu.view().cpu.view().cpu", "torch.cdist", "len", "scipy.optimize.linear_sum_assignment", "cost.view().cpu.view().cpu.view", "enumerate", "torch.as_tensor", "torch.as_tensor", "cost.view().cpu.view().cpu.split"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "forward", "(", "self", ",", "outputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\" Performs the matching\n\n        Params:\n            outputs: Tensor of dim [batch_size, num_queries, d_label] \n\n            targets: This is a list of targets (len(targets) = batch_size), where each target is a \n                    tensor of dim [num_objects, d_label] (where num_objects is the number of ground-truth\n                    objects in the target) \n\n        Returns:\n            A list of size batch_size, containing tuples of (index_i, index_j) where:\n                - index_i is the indices of the selected predictions (in order)\n                - index_j is the indices of the corresponding selected targets (in order)\n            For each batch element, it holds:\n                len(index_i) = len(index_j) = min(num_queries, num_target_boxes)\n        \"\"\"", "\n", "bs", ",", "num_queries", "=", "outputs", ".", "shape", "[", ":", "2", "]", "\n", "\n", "# We flatten to compute the cost matrices in a batch", "\n", "out", "=", "outputs", ".", "flatten", "(", "0", ",", "1", ")", "# [batch_size * num_queries, d_label]", "\n", "\n", "# Also concat the target labels ", "\n", "tgt", "=", "torch", ".", "cat", "(", "targets", ")", "# [sum(num_objects), d_labels]", "\n", "\n", "# Compute the L2 cost ", "\n", "cost", "=", "torch", ".", "cdist", "(", "out", ",", "tgt", ",", "p", "=", "2", ")", "**", "self", ".", "p", "# [batch_size * num_queries, sum(num_objects)]", "\n", "\n", "# Clamp according to Gospa", "\n", "cost", "=", "cost", ".", "clamp_max", "(", "self", ".", "cutoff_distance", "**", "self", ".", "order", ")", "\n", "\n", "# Reshape", "\n", "cost", "=", "cost", ".", "view", "(", "bs", ",", "num_queries", ",", "-", "1", ")", ".", "cpu", "(", ")", "# [batch_size, num_queries, sum(num_objects)]", "\n", "\n", "# List with num_objects for each training-example", "\n", "sizes", "=", "[", "len", "(", "v", ")", "for", "v", "in", "targets", "]", "\n", "\n", "# Perform hungarian matching using scipy linear_sum_assignment", "\n", "indices", "=", "[", "linear_sum_assignment", "(", "c", "[", "i", "]", ")", "for", "i", ",", "c", "in", "enumerate", "(", "cost", ".", "split", "(", "sizes", ",", "-", "1", ")", ")", "]", "\n", "\n", "return", "[", "(", "torch", ".", "as_tensor", "(", "i", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "torch", ".", "as_tensor", "(", "j", ",", "dtype", "=", "torch", ".", "int64", ")", ")", "for", "i", ",", "j", "in", "indices", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.position_encoder.LearnedPositionEncoder.__init__": [[10, 14], ["torch.nn.Module.__init__", "torch.nn.Embedding", "torch.nn.init.uniform_"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__"], ["def", "__init__", "(", "self", ",", "n_timesteps", ",", "d_model", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "embeddor", "=", "nn", ".", "Embedding", "(", "n_timesteps", ",", "d_model", ")", "# lookup table, each with vector of size d_model    ", "\n", "nn", ".", "init", ".", "uniform_", "(", "self", ".", "embeddor", ".", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.position_encoder.LearnedPositionEncoder.forward": [[15, 18], ["pos_indicies.long.long.long", "position_encoder.LearnedPositionEncoder.embeddor"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pos_indicies", ")", ":", "\n", "        ", "pos_indicies", "=", "pos_indicies", ".", "long", "(", ")", "\n", "return", "self", ".", "embeddor", "(", "pos_indicies", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.position_encoder.PositionEmbeddingSine.__init__": [[25, 32], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__"], ["def", "__init__", "(", "self", ",", "params", ",", "temperature", "=", "10000", ",", "scale", "=", "2", "*", "math", ".", "pi", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "params", "=", "params", "\n", "self", ".", "num_pos_feats", "=", "params", ".", "arch", ".", "d_model", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "max_time", "=", "params", ".", "data_generation", ".", "n_timesteps", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.position_encoder.PositionEmbeddingSine.forward": [[33, 45], ["torch.arange", "torch.stack().flatten", "torch.stack", "pos[].sin", "pos[].cos"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "proposals", ")", ":", "\n", "        ", "proposals", "=", "proposals", "+", "1", "\n", "dim_t", "=", "torch", ".", "arange", "(", "self", ".", "num_pos_feats", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "proposals", ".", "device", ")", "\n", "dim_t", "=", "self", ".", "temperature", "**", "(", "2", "*", "(", "dim_t", "//", "2", ")", "/", "self", ".", "num_pos_feats", ")", "\n", "# N, L", "\n", "proposals", "=", "proposals", "/", "self", ".", "max_time", "*", "self", ".", "scale", "\n", "# N, L, num_pos_feats", "\n", "pos", "=", "proposals", "[", ":", ",", ":", ",", "None", "]", "/", "dim_t", "\n", "# N, L, 2, num_pos_feats/2, 2", "\n", "pos", "=", "torch", ".", "stack", "(", "(", "pos", "[", ":", ",", ":", ",", "0", ":", ":", "2", "]", ".", "sin", "(", ")", ",", "pos", "[", ":", ",", ":", ",", "1", ":", ":", "2", "]", ".", "cos", "(", ")", ")", ",", "dim", "=", "3", ")", ".", "flatten", "(", "2", ")", "\n", "# N, L, num_pos_feats*2", "\n", "return", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.__init__": [[24, 35], ["torch.nn.Module.__init__", "torch.device", "torch.device", "torch.device", "torch.device", "loss.MotLoss.to", "loss.check_gospa_parameters"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.check_gospa_parameters"], ["    ", "def", "__init__", "(", "self", ",", "params", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "params", ".", "loss", ".", "type", "==", "'gospa'", ":", "\n", "            ", "check_gospa_parameters", "(", "params", ".", "loss", ".", "cutoff_distance", ",", "params", ".", "loss", ".", "order", ",", "params", ".", "loss", ".", "alpha", ")", "\n", "self", ".", "order", "=", "params", ".", "loss", ".", "order", "\n", "self", ".", "cutoff_distance", "=", "params", ".", "loss", ".", "cutoff_distance", "\n", "self", ".", "alpha", "=", "params", ".", "loss", ".", "alpha", "\n", "self", ".", "miss_cost", "=", "self", ".", "cutoff_distance", "**", "self", ".", "order", "\n", "", "self", ".", "params", "=", "params", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "params", ".", "training", ".", "device", ")", "\n", "self", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss._get_src_permutation_idx": [[36, 42], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.full_like", "torch.full_like", "torch.full_like", "torch.full_like", "enumerate"], "methods", ["None"], ["", "def", "_get_src_permutation_idx", "(", "self", ",", "indices", ")", ":", "\n", "# permute predictions following indices", "\n", "        ", "batch_idx", "=", "torch", ".", "cat", "(", "[", "torch", ".", "full_like", "(", "src", ",", "i", ")", "\n", "for", "i", ",", "(", "src", ",", "_", ")", "in", "enumerate", "(", "indices", ")", "]", ")", "\n", "src_idx", "=", "torch", ".", "cat", "(", "[", "src", "for", "(", "src", ",", "_", ")", "in", "indices", "]", ")", "\n", "return", "batch_idx", ",", "src_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss._get_tgt_permutation_idx": [[43, 49], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.full_like", "torch.full_like", "torch.full_like", "torch.full_like", "enumerate"], "methods", ["None"], ["", "def", "_get_tgt_permutation_idx", "(", "self", ",", "indices", ")", ":", "\n", "# permute targets following indices", "\n", "        ", "batch_idx", "=", "torch", ".", "cat", "(", "[", "torch", ".", "full_like", "(", "tgt", ",", "i", ")", "\n", "for", "i", ",", "(", "_", ",", "tgt", ")", "in", "enumerate", "(", "indices", ")", "]", ")", "\n", "tgt_idx", "=", "torch", ".", "cat", "(", "[", "tgt", "for", "(", "_", ",", "tgt", ")", "in", "indices", "]", ")", "\n", "return", "batch_idx", ",", "tgt_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.compute_hungarian_matching": [[50, 87], ["predicted_logits.sigmoid", "range", "torch.cdist", "torch.cdist", "torch.cdist", "torch.cdist", "predicted_probabilities[].log", "torch.cdist.to", "torch.cdist.to", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "indices.append", "torch.as_tensor().to", "torch.as_tensor().to", "torch.as_tensor().to", "torch.as_tensor().to", "torch.as_tensor().to", "torch.as_tensor().to", "torch.as_tensor().to", "torch.as_tensor().to", "scipy.optimize.linear_sum_assignment", "torch.cdist.cpu", "torch.cdist.cpu", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to"], ["", "def", "compute_hungarian_matching", "(", "self", ",", "predicted_states", ",", "predicted_logits", ",", "targets", ",", "distance", "=", "'detr'", ",", "scaling", "=", "1", ")", ":", "\n", "        ", "\"\"\" Performs the matching\n\n        Params:\n            outputs: dictionary with 'state' and 'logits'\n                state: Tensor of dim [batch_size, num_queries, d_label]\n                logits: Tensor of dim [batch_size, num_queries, number_of_classes]\n\n            targets: This is a list of targets (len(targets) = batch_size), where each target is a\n                    tensor of dim [num_objects, d_label] (where num_objects is the number of ground-truth\n                    objects in the target)\n\n        Returns:\n            A list of size batch_size, containing tuples of (index_i, index_j) where:\n                - index_i is the indices of the selected predictions (in order)\n                - index_j is the indices of the corresponding selected targets (in order)\n            For each batch element, it holds:\n                len(index_i) = len(index_j) = min(num_queries, num_target_boxes)\n        \"\"\"", "\n", "\n", "bs", ",", "num_queries", "=", "predicted_states", ".", "shape", "[", ":", "2", "]", "\n", "predicted_probabilities", "=", "predicted_logits", ".", "sigmoid", "(", ")", "\n", "\n", "indices", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "# Compute cost matrix for this batch position", "\n", "            ", "cost", "=", "torch", ".", "cdist", "(", "predicted_states", "[", "i", "]", ",", "targets", "[", "i", "]", ",", "p", "=", "2", ")", "\n", "cost", "-=", "predicted_probabilities", "[", "i", "]", ".", "log", "(", ")", "\n", "\n", "# Compute minimum cost assignment and save it", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "indices", ".", "append", "(", "linear_sum_assignment", "(", "cost", ".", "cpu", "(", ")", ")", ")", "\n", "\n", "", "", "permutation_idx", "=", "[", "(", "torch", ".", "as_tensor", "(", "i", ",", "dtype", "=", "torch", ".", "int64", ")", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "torch", ".", "as_tensor", "(", "j", ",", "dtype", "=", "torch", ".", "int64", ")", ".", "to", "(", "self", ".", "device", ")", ")", "for", "i", ",", "j", "in", "indices", "]", "\n", "\n", "return", "permutation_idx", ",", "cost", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.compute_orig_gospa_matching": [[88, 166], ["outputs[].detach", "outputs[].sigmoid().detach", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "outputs[].sigmoid", "output_existence_probabilities[].squeeze", "len", "indices.append", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "len", "len", "indices.append", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.cdist", "torch.cdist", "torch.cdist", "torch.cdist", "dist.clamp_max.clamp_max.clamp_max", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "c.cpu.cpu.cpu", "scipy.optimize.linear_sum_assignment", "indices.append", "zip", "abs", "len", "len", "c[].item", "len", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "compute_orig_gospa_matching", "(", "self", ",", "outputs", ",", "targets", ",", "existence_threshold", ")", ":", "\n", "        ", "\"\"\" Performs the matching. Note that this can NOT be used as a loss function\n\n        Params:\n            outputs: dictionary with 'state' and 'logits'\n                state: Tensor of dim [batch_size, num_queries, d_label]\n                logits: Tensor of dim [batch_size, num_queries, number_of_classes]\n\n            targets: This is a list of targets (len(targets) = batch_size), where each target is a\n                    tensor of dim [num_objects, d_label] (where num_objects is the number of ground-truth\n                    objects in the target)\n\n            existence_threshold: Float in range (0,1) that decides which object are considered alive and which are not.\n\n        Returns:\n            A list of size batch_size, containing tuples of (index_i, index_j) where:\n                - index_i is the indices of the selected predictions (in order)\n                - index_j is the indices of the corresponding selected targets (in order)\n            For each batch element, it holds:\n                len(index_i) = len(index_j) = min(num_queries, num_target_boxes)\n        \"\"\"", "\n", "\n", "assert", "'state'", "in", "outputs", ",", "\"'state' should be in dict\"", "\n", "assert", "'logits'", "in", "outputs", ",", "\"'logits' should be in dict\"", "\n", "assert", "self", ".", "order", "==", "1", ",", "'This code does not work for loss.order != 1'", "\n", "assert", "self", ".", "alpha", "==", "2", ",", "'The permutation -> assignment relation used to decompose GOSPA might require that loss.alpha == 2'", "\n", "\n", "output_state", "=", "outputs", "[", "'state'", "]", ".", "detach", "(", ")", "\n", "output_existence_probabilities", "=", "outputs", "[", "'logits'", "]", ".", "sigmoid", "(", ")", ".", "detach", "(", ")", "\n", "\n", "bs", ",", "num_queries", "=", "output_state", ".", "shape", "[", ":", "2", "]", "\n", "dim_predictions", "=", "output_state", ".", "shape", "[", "2", "]", "\n", "dim_targets", "=", "targets", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "assert", "dim_predictions", "==", "dim_targets", "\n", "\n", "loss", "=", "torch", ".", "zeros", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "localization_cost", "=", "0", "\n", "missed_target_cost", "=", "0", "\n", "false_target_cost", "=", "0", "\n", "indices", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "alive_idx", "=", "output_existence_probabilities", "[", "i", ",", ":", "]", ".", "squeeze", "(", "-", "1", ")", ">", "existence_threshold", "\n", "alive_output", "=", "output_state", "[", "i", ",", "alive_idx", ",", ":", "]", "\n", "current_targets", "=", "targets", "[", "i", "]", "\n", "permutation_length", "=", "0", "\n", "\n", "if", "len", "(", "current_targets", ")", "==", "0", ":", "\n", "                ", "indices", ".", "append", "(", "(", "[", "]", ",", "[", "]", ")", ")", "\n", "loss", "+=", "torch", ".", "Tensor", "(", "[", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "len", "(", "alive_output", ")", "]", ")", "\n", "false_target_cost", "=", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "len", "(", "alive_output", ")", "\n", "", "elif", "len", "(", "alive_output", ")", "==", "0", ":", "\n", "                ", "indices", ".", "append", "(", "(", "[", "]", ",", "[", "]", ")", ")", "\n", "loss", "+=", "torch", ".", "Tensor", "(", "[", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "len", "(", "current_targets", ")", "]", ")", "\n", "missed_target_cost", "=", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "len", "(", "current_targets", ")", "\n", "", "else", ":", "\n", "                ", "dist", "=", "torch", ".", "cdist", "(", "alive_output", ",", "current_targets", ",", "p", "=", "2", ")", "\n", "dist", "=", "dist", ".", "clamp_max", "(", "self", ".", "cutoff_distance", ")", "\n", "c", "=", "torch", ".", "pow", "(", "input", "=", "dist", ",", "exponent", "=", "self", ".", "order", ")", "\n", "c", "=", "c", ".", "cpu", "(", ")", "\n", "output_idx", ",", "target_idx", "=", "linear_sum_assignment", "(", "c", ")", "\n", "indices", ".", "append", "(", "(", "output_idx", ",", "target_idx", ")", ")", "\n", "\n", "for", "t", ",", "o", "in", "zip", "(", "output_idx", ",", "target_idx", ")", ":", "\n", "                    ", "loss", "+=", "c", "[", "t", ",", "o", "]", "\n", "if", "c", "[", "t", ",", "o", "]", "<", "self", ".", "cutoff_distance", ":", "\n", "                        ", "localization_cost", "+=", "c", "[", "t", ",", "o", "]", ".", "item", "(", ")", "\n", "permutation_length", "+=", "1", "\n", "\n", "", "", "cardinality_error", "=", "abs", "(", "len", "(", "alive_output", ")", "-", "len", "(", "current_targets", ")", ")", "\n", "loss", "+=", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "cardinality_error", "\n", "\n", "missed_target_cost", "+=", "(", "len", "(", "current_targets", ")", "-", "permutation_length", ")", "*", "(", "self", ".", "miss_cost", "/", "self", ".", "alpha", ")", "\n", "false_target_cost", "+=", "(", "len", "(", "alive_output", ")", "-", "permutation_length", ")", "*", "(", "self", ".", "miss_cost", "/", "self", ".", "alpha", ")", "\n", "\n", "", "", "decomposition", "=", "{", "'localization'", ":", "localization_cost", ",", "'missed'", ":", "missed_target_cost", ",", "'false'", ":", "false_target_cost", ",", "\n", "'n_matched_objs'", ":", "permutation_length", "}", "\n", "return", "loss", ",", "indices", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.compute_orig_gospa_matching_with_uncertainties": [[167, 223], ["[].sigmoid().detach", "len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "[].sigmoid().detach.squeeze", "[].detach", "[].detach", "indices.append", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "[].sigmoid", "indices.append", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "compute_pairwise_crossentropy", "dist.clamp_max.clamp_max.clamp_max", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "c.cpu.cpu.cpu", "scipy.optimize.linear_sum_assignment", "indices.append", "zip", "abs", "c[].item"], "methods", ["None"], ["", "def", "compute_orig_gospa_matching_with_uncertainties", "(", "self", ",", "predictions", ",", "targets", ",", "existence_threshold", ")", ":", "\n", "\n", "        ", "assert", "self", ".", "order", "==", "1", ",", "'This code does not work for loss.order != 1'", "\n", "assert", "self", ".", "alpha", "==", "2", ",", "'The permutation -> assignment relation used to decompose GOSPA might require that loss.alpha == 2'", "\n", "\n", "batch_size", ",", "_", ",", "dim_predictions", "=", "predictions", "[", "'state'", "]", ".", "shape", "\n", "n_targets", ",", "dim_targets", "=", "targets", "[", "0", "]", ".", "shape", "\n", "assert", "dim_predictions", "==", "dim_targets", "\n", "assert", "batch_size", "==", "1", ",", "'GOSPA matching with uncertainties currently only works with batch size = 1'", "\n", "\n", "existence_probabilities", "=", "predictions", "[", "'logits'", "]", "[", "0", "]", ".", "sigmoid", "(", ")", ".", "detach", "(", ")", "\n", "alive_idx", "=", "existence_probabilities", ".", "squeeze", "(", "-", "1", ")", ">", "existence_threshold", "\n", "\n", "predicted_distributions", "=", "{", "'states'", ":", "predictions", "[", "'state'", "]", "[", "0", ",", "alive_idx", "]", ".", "detach", "(", ")", ",", "\n", "'state_covariances'", ":", "predictions", "[", "'state_covariances'", "]", "[", "0", ",", "alive_idx", "]", ".", "detach", "(", ")", "}", "\n", "targets", "=", "targets", "[", "0", "]", "\n", "n_predictions", "=", "len", "(", "predicted_distributions", "[", "'states'", "]", ")", "\n", "\n", "loss", "=", "torch", ".", "zeros", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "localization_cost", "=", "0", "\n", "missed_target_cost", "=", "0", "\n", "false_target_cost", "=", "0", "\n", "indices", "=", "[", "]", "\n", "permutation_length", "=", "0", "\n", "\n", "if", "n_targets", "==", "0", ":", "\n", "            ", "indices", ".", "append", "(", "(", "[", "]", ",", "[", "]", ")", ")", "\n", "loss", "+=", "torch", ".", "Tensor", "(", "[", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "n_predictions", "]", ")", "\n", "false_target_cost", "=", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "n_predictions", "\n", "", "elif", "n_predictions", "==", "0", ":", "\n", "            ", "indices", ".", "append", "(", "(", "[", "]", ",", "[", "]", ")", ")", "\n", "loss", "+=", "torch", ".", "Tensor", "(", "[", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "n_targets", "]", ")", "\n", "missed_target_cost", "=", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "n_targets", "\n", "", "else", ":", "\n", "            ", "dist", "=", "compute_pairwise_crossentropy", "(", "predicted_distributions", ",", "targets", ")", "\n", "dist", "=", "dist", ".", "clamp_max", "(", "self", ".", "cutoff_distance", ")", "\n", "c", "=", "torch", ".", "pow", "(", "input", "=", "dist", ",", "exponent", "=", "self", ".", "order", ")", "\n", "c", "=", "c", ".", "cpu", "(", ")", "\n", "target_idx", ",", "output_idx", "=", "linear_sum_assignment", "(", "c", ")", "\n", "indices", ".", "append", "(", "(", "target_idx", ",", "output_idx", ")", ")", "\n", "\n", "for", "t", ",", "o", "in", "zip", "(", "target_idx", ",", "output_idx", ")", ":", "\n", "                ", "loss", "+=", "c", "[", "t", ",", "o", "]", "\n", "if", "c", "[", "t", ",", "o", "]", "<", "self", ".", "cutoff_distance", ":", "\n", "                    ", "localization_cost", "+=", "c", "[", "t", ",", "o", "]", ".", "item", "(", ")", "\n", "permutation_length", "+=", "1", "\n", "\n", "", "", "cardinality_error", "=", "abs", "(", "n_predictions", "-", "n_targets", ")", "\n", "loss", "+=", "self", ".", "miss_cost", "/", "self", ".", "alpha", "*", "cardinality_error", "\n", "\n", "missed_target_cost", "+=", "(", "n_targets", "-", "permutation_length", ")", "*", "(", "self", ".", "miss_cost", "/", "self", ".", "alpha", ")", "\n", "false_target_cost", "+=", "(", "n_predictions", "-", "permutation_length", ")", "*", "(", "self", ".", "miss_cost", "/", "self", ".", "alpha", ")", "\n", "\n", "", "decomposition", "=", "{", "'localization'", ":", "localization_cost", ",", "'missed'", ":", "missed_target_cost", ",", "'false'", ":", "false_target_cost", ",", "\n", "'n_matched_objs'", ":", "permutation_length", "}", "\n", "return", "loss", ",", "indices", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.gospa_forward": [[224, 251], ["outputs[].sigmoid", "len", "loss.MotLoss.compute_prob_gospa_matching", "cost_matrix.split.split.split", "range", "loss.MotLoss.compute_orig_gospa_matching", "[].sum", "sum", "[].sum"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.compute_orig_gospa_matching"], ["", "def", "gospa_forward", "(", "self", ",", "outputs", ",", "targets", ",", "probabilistic", "=", "True", ",", "existence_threshold", "=", "0.75", ")", ":", "\n", "\n", "        ", "assert", "'state'", "in", "outputs", ",", "\"'state' should be in dict\"", "\n", "assert", "'logits'", "in", "outputs", ",", "\"'logits' should be in dict\"", "\n", "\n", "output_state", "=", "outputs", "[", "'state'", "]", "\n", "output_logits", "=", "outputs", "[", "'logits'", "]", ".", "sigmoid", "(", ")", "\n", "# List with num_objects for each training-example", "\n", "sizes", "=", "[", "len", "(", "v", ")", "for", "v", "in", "targets", "]", "\n", "\n", "bs", "=", "output_state", ".", "shape", "[", "0", "]", "\n", "if", "probabilistic", ":", "\n", "            ", "indices", ",", "cost_matrix", ",", "unmatched_x", "=", "self", ".", "compute_prob_gospa_matching", "(", "outputs", ",", "targets", ")", "\n", "cost_matrix", "=", "cost_matrix", ".", "split", "(", "sizes", ",", "-", "1", ")", "\n", "loss", "=", "0", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "                ", "batch_idx", "=", "indices", "[", "i", "]", "\n", "batch_cost", "=", "cost_matrix", "[", "i", "]", "[", "i", "]", "[", "batch_idx", "]", ".", "sum", "(", ")", "\n", "batch_cost", "=", "batch_cost", "+", "output_logits", "[", "i", "]", "[", "unmatched_x", "[", "i", "]", "]", ".", "sum", "(", ")", "*", "self", ".", "miss_cost", "/", "2.0", "\n", "loss", "=", "loss", "+", "batch_cost", "\n", "", "loss", "=", "loss", "/", "sum", "(", "sizes", ")", "\n", "return", "loss", ",", "indices", "\n", "", "else", ":", "\n", "            ", "assert", "0", "<=", "existence_threshold", "<", "1", ",", "\"'existence_threshold' should be in range (0,1)\"", "\n", "loss", ",", "indices", ",", "decomposition", "=", "self", ".", "compute_orig_gospa_matching", "(", "outputs", ",", "targets", ",", "existence_threshold", ")", "\n", "loss", "=", "loss", "/", "bs", "\n", "return", "loss", ",", "indices", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.state_loss": [[252, 264], ["F.l1_loss().sum().mean.MotLoss._get_src_permutation_idx", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.l1_loss().sum().mean", "torch.l1_loss().sum().mean", "torch.distributions.normal.Normal.log_prob().mean", "torch.distributions.normal.Normal.log_prob().mean", "zip", "torch.l1_loss().sum", "torch.l1_loss().sum", "torch.distributions.normal.Normal.log_prob", "torch.distributions.normal.Normal.log_prob", "torch.l1_loss", "torch.l1_loss"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting._get_src_permutation_idx", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.pmb_utils.UnnormalizedGaussianMixture.log_prob", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.pmb_utils.UnnormalizedGaussianMixture.log_prob"], ["", "", "def", "state_loss", "(", "self", ",", "predicted_states", ",", "targets", ",", "indices", ",", "uncertainties", "=", "None", ")", ":", "\n", "        ", "idx", "=", "self", ".", "_get_src_permutation_idx", "(", "indices", ")", "\n", "matched_predicted_states", "=", "predicted_states", "[", "idx", "]", "\n", "target", "=", "torch", ".", "cat", "(", "[", "t", "[", "i", "]", "for", "t", ",", "(", "_", ",", "i", ")", "in", "zip", "(", "targets", ",", "indices", ")", "]", ",", "dim", "=", "0", ")", "\n", "if", "uncertainties", "is", "not", "None", ":", "\n", "            ", "matched_uncertainties", "=", "uncertainties", "[", "idx", "]", "\n", "prediction_distribution", "=", "torch", ".", "distributions", ".", "normal", ".", "Normal", "(", "matched_predicted_states", ",", "matched_uncertainties", ")", "\n", "loss", "=", "-", "prediction_distribution", ".", "log_prob", "(", "target", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "F", ".", "l1_loss", "(", "matched_predicted_states", ",", "target", ",", "reduction", "=", "'none'", ")", ".", "sum", "(", "-", "1", ")", ".", "mean", "(", ")", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.logits_loss": [[265, 273], ["F.binary_cross_entropy_with_logits.MotLoss._get_src_permutation_idx", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "predicted_logits.squeeze().permute", "torch.zeros_like.squeeze().permute", "torch.zeros_like.squeeze().permute", "predicted_logits.squeeze", "torch.zeros_like.squeeze", "torch.zeros_like.squeeze"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting._get_src_permutation_idx"], ["", "def", "logits_loss", "(", "self", ",", "predicted_logits", ",", "targets", ",", "indices", ")", ":", "\n", "        ", "idx", "=", "self", ".", "_get_src_permutation_idx", "(", "indices", ")", "\n", "\n", "target_classes", "=", "torch", ".", "zeros_like", "(", "predicted_logits", ",", "device", "=", "predicted_logits", ".", "device", ")", "\n", "target_classes", "[", "idx", "]", "=", "1.0", "# this is representation of an object", "\n", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "predicted_logits", ".", "squeeze", "(", "-", "1", ")", ".", "permute", "(", "1", ",", "0", ")", ",", "target_classes", ".", "squeeze", "(", "-", "1", ")", ".", "permute", "(", "1", ",", "0", ")", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.get_loss": [[274, 301], ["loss.MotLoss.gospa_forward", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "NotImplementedError", "loss.MotLoss.gospa_forward", "loss.MotLoss.compute_hungarian_matching", "loss.MotLoss.logits_loss", "hasattr", "loss.MotLoss.state_loss", "loss.MotLoss.state_loss"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.gospa_forward", "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.gospa_forward", "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.compute_hungarian_matching", "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.logits_loss", "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.state_loss", "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.state_loss"], ["", "def", "get_loss", "(", "self", ",", "prediction", ",", "targets", ",", "loss_type", ",", "existence_threshold", "=", "None", ")", ":", "\n", "# Create state vectors for the predictions, based on prediction target specified by user", "\n", "        ", "if", "self", ".", "params", ".", "data_generation", ".", "prediction_target", "==", "'position'", ":", "\n", "            ", "predicted_states", "=", "prediction", ".", "positions", "\n", "", "elif", "self", ".", "params", ".", "data_generation", ".", "prediction_target", "==", "'position_and_velocity'", ":", "\n", "            ", "predicted_states", "=", "torch", ".", "cat", "(", "(", "prediction", ".", "positions", ",", "prediction", ".", "velocities", ")", ",", "dim", "=", "2", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f'Hungarian matching not implemented for prediction target '", "\n", "f'{self.params.data_generation.prediction_target}'", ")", "\n", "\n", "", "if", "loss_type", "==", "'gospa'", ":", "\n", "            ", "loss", ",", "indices", "=", "self", ".", "gospa_forward", "(", "prediction", ",", "targets", ",", "probabilistic", "=", "True", ")", "\n", "loss", "=", "{", "f'{loss_type}_state'", ":", "loss", ",", "f'{loss_type}_logits'", ":", "0", "}", "\n", "", "elif", "loss_type", "==", "'gospa_eval'", ":", "\n", "            ", "loss", ",", "_", "=", "self", ".", "gospa_forward", "(", "prediction", ",", "targets", ",", "probabilistic", "=", "False", ",", "existence_threshold", "=", "existence_threshold", ")", "\n", "indices", "=", "None", "\n", "loss", "=", "{", "f'{loss_type}_state'", ":", "loss", ",", "f'{loss_type}_logits'", ":", "0", "}", "\n", "", "elif", "loss_type", "==", "'detr'", ":", "\n", "            ", "indices", ",", "_", "=", "self", ".", "compute_hungarian_matching", "(", "predicted_states", ",", "prediction", ".", "logits", ",", "targets", ")", "\n", "log_loss", "=", "self", ".", "logits_loss", "(", "prediction", ".", "logits", ",", "targets", ",", "indices", ")", "\n", "if", "hasattr", "(", "prediction", ",", "'uncertainties'", ")", ":", "\n", "                ", "state_loss", "=", "self", ".", "state_loss", "(", "predicted_states", ",", "targets", ",", "indices", ",", "uncertainties", "=", "prediction", ".", "uncertainties", ")", "\n", "", "else", ":", "\n", "                ", "state_loss", "=", "self", ".", "state_loss", "(", "predicted_states", ",", "targets", ",", "indices", ")", "\n", "", "loss", "=", "{", "f'{loss_type}_state'", ":", "state_loss", ",", "f'{loss_type}_logits'", ":", "log_loss", "}", "\n", "\n", "", "return", "loss", ",", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.forward": [[302, 323], ["loss.MotLoss.get_loss", "losses.update", "NotImplementedError", "enumerate", "loss.MotLoss.get_loss", "losses.update", "loss.MotLoss.get_loss", "losses.update", "enc_loss.items", "aux_loss.items"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.get_loss", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.Object.update", "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.get_loss", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.Object.update", "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.get_loss", "home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.mot_data_generation.Object.update"], ["", "def", "forward", "(", "self", ",", "targets", ",", "prediction", ",", "intermediate_predictions", "=", "None", ",", "encoder_prediction", "=", "None", ",", "loss_type", "=", "'detr'", ",", "\n", "existence_threshold", "=", "0.75", ")", ":", "\n", "        ", "if", "loss_type", "not", "in", "[", "'gospa'", ",", "'gospa_eval'", ",", "'detr'", "]", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f\"The loss type '{loss_type}' was not implemented.'\"", ")", "\n", "\n", "", "losses", "=", "{", "}", "\n", "loss", ",", "indices", "=", "self", ".", "get_loss", "(", "prediction", ",", "targets", ",", "loss_type", ",", "existence_threshold", ")", "\n", "losses", ".", "update", "(", "loss", ")", "\n", "\n", "if", "intermediate_predictions", "is", "not", "None", ":", "\n", "            ", "for", "i", ",", "intermediate_prediction", "in", "enumerate", "(", "intermediate_predictions", ")", ":", "\n", "                ", "aux_loss", ",", "_", "=", "self", ".", "get_loss", "(", "intermediate_prediction", ",", "targets", ",", "loss_type", ",", "existence_threshold", ")", "\n", "aux_loss", "=", "{", "f'{k}_{i}'", ":", "v", "for", "k", ",", "v", "in", "aux_loss", ".", "items", "(", ")", "}", "\n", "losses", ".", "update", "(", "aux_loss", ")", "\n", "\n", "", "", "if", "encoder_prediction", "is", "not", "None", ":", "\n", "            ", "enc_loss", ",", "_", "=", "self", ".", "get_loss", "(", "encoder_prediction", ",", "targets", ",", "loss_type", ",", "existence_threshold", ")", "\n", "enc_loss", "=", "{", "f'{k}_enc'", ":", "v", "for", "k", ",", "v", "in", "enc_loss", ".", "items", "(", ")", "}", "\n", "losses", ".", "update", "(", "enc_loss", ")", "\n", "\n", "", "return", "losses", ",", "indices", "\n", "", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.check_gospa_parameters": [[9, 21], ["ValueError", "ValueError", "ValueError"], "function", ["None"], ["def", "check_gospa_parameters", "(", "c", ",", "p", ",", "alpha", ")", ":", "\n", "    ", "\"\"\" Check parameter bounds.\n\n    If the parameter values are outside the allowable range specified in the\n    definition of GOSPA, a ValueError is raised.\n    \"\"\"", "\n", "if", "alpha", "<=", "0", "or", "alpha", ">", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"The value of alpha is outside the range (0, 2]\"", ")", "\n", "", "if", "c", "<=", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\"The cutoff distance c is outside the range (0, inf)\"", ")", "\n", "", "if", "p", "<", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"The order p is outside the range [1, inf)\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.mlp.MLP.__init__": [[9, 15], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "torch.nn.Linear", "zip"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "hidden_dim", ",", "output_dim", ",", "num_layers", ",", "softplus_at_end", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "softplus_at_end", "=", "softplus_at_end", "\n", "h", "=", "[", "hidden_dim", "]", "*", "(", "num_layers", "-", "1", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", "nn", ".", "Linear", "(", "n", ",", "k", ")", "for", "n", ",", "k", "in", "zip", "(", "[", "input_dim", "]", "+", "h", ",", "h", "+", "[", "output_dim", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.mlp.MLP.forward": [[16, 24], ["enumerate", "torch.nn.functional.softplus", "torch.nn.functional.relu", "layer", "layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "layer", "(", "x", ")", ")", "if", "i", "<", "self", ".", "num_layers", "-", "1", "else", "layer", "(", "x", ")", "\n", "\n", "", "if", "self", ".", "softplus_at_end", ":", "\n", "            ", "x", "=", "F", ".", "softplus", "(", "x", ")", "\n", "\n", "", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.contrastive_loss.ContrastiveLoss.__init__": [[7, 10], ["torch.nn.Module.__init__", "torch.device"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__"], ["    ", "def", "__init__", "(", "self", ",", "params", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "params", ".", "training", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.contrastive_loss.ContrastiveLoss.forward": [[11, 34], ["unique_ids.unsqueeze().repeat", "torch.eye().bool().repeat", "torch.nn.functional.normalize.masked_fill", "torch.nn.functional.normalize", "torch.isnan", "per_measurement_losses.flatten.flatten.masked_fill", "per_measurement_losses.flatten.flatten.flatten", "per_measurement_losses.flatten.flatten.sum", "per_measurement_losses.flatten.sum.sum", "unique_ids.unsqueeze", "torch.eye().bool", "unique_ids.unsqueeze().repeat.permute", "torch.eye"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "log_classifications", ",", "unique_ids", ")", "->", "Tensor", ":", "\n", "        ", "batch_size", ",", "n_measurements", "=", "unique_ids", ".", "shape", "\n", "\n", "temp", "=", "unique_ids", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "n_measurements", ",", "1", ")", "\n", "id_matrix", "=", "(", "temp", "==", "temp", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", ".", "float", "(", ")", "\n", "\n", "# Mask diagonal and then perform row-wise normalization", "\n", "mask", "=", "(", "torch", ".", "eye", "(", "n_measurements", ",", "device", "=", "self", ".", "device", ")", ".", "bool", "(", ")", ")", ".", "repeat", "(", "batch_size", ",", "1", ",", "1", ")", "\n", "id_matrix", "=", "id_matrix", ".", "masked_fill", "(", "mask", ",", "0.0", ")", "\n", "id_matrix", "=", "F", ".", "normalize", "(", "id_matrix", ",", "p", "=", "1", ",", "dim", "=", "2", ")", "\n", "\n", "# Compute element-wise multiplication between log_classifications and id_matrix (NaNs -> 0.0)", "\n", "per_measurement_losses", "=", "-", "log_classifications", "*", "id_matrix", "\n", "mask", "=", "torch", ".", "isnan", "(", "per_measurement_losses", ")", "\n", "per_measurement_losses", "=", "per_measurement_losses", ".", "masked_fill", "(", "mask", ",", "0.0", ")", "\n", "per_measurement_losses", "=", "per_measurement_losses", ".", "flatten", "(", "0", ",", "1", ")", "# get rid of batch dimension, all measurements are born equal", "\n", "\n", "# Compute loss", "\n", "per_measurement_loss", "=", "per_measurement_losses", ".", "sum", "(", "dim", "=", "1", ")", "\n", "n_eligible_measurements", "=", "(", "per_measurement_loss", "!=", "0.0", ")", ".", "sum", "(", ")", "# number of measurements with non-zero losses,", "\n", "# i.e. no. of measurements for which at least one other measurement is from the same object.", "\n", "loss", "=", "per_measurement_loss", ".", "sum", "(", ")", "/", "n_eligible_measurements", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.contrastive_classifier.ContrastiveClassifier.__init__": [[10, 15], ["torch.nn.Module.__init__", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__"], ["    ", "def", "__init__", "(", "self", ",", "measurement_dim", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "measurement_dim", "=", "measurement_dim", "\n", "self", ".", "device", "=", "'cpu'", "\n", "self", ".", "f", "=", "nn", ".", "Linear", "(", "measurement_dim", ",", "measurement_dim", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.contrastive_classifier.ContrastiveClassifier.forward": [[16, 48], ["contrastive_classifier.ContrastiveClassifier.f", "torch.nn.functional.normalize", "torch.eye().bool().repeat", "dot_products.masked_fill", "dot_products.masked_fill.log_softmax", "len", "torch.nn.functional.normalize.permute", "torch.zeros.unsqueeze", "torch.zeros.repeat", "torch.zeros", "torch.eye().bool", "torch.zeros.repeat.transpose", "torch.eye"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ":", "Tensor", ",", "padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", "->", "Tensor", ":", "\n", "        ", "\"\"\"\n        Expects a batch with dimensions (BATCH_SIZE x N_MEASUREMENTS x MEASUREMENT_DIM)\n        \"\"\"", "\n", "assert", "len", "(", "x", ".", "shape", ")", "==", "3", "\n", "\n", "batch_size", "=", "x", ".", "shape", "[", "0", "]", "\n", "n_meas", "=", "x", ".", "shape", "[", "1", "]", "\n", "\n", "# Compute projection for each measurement and normalize them to unit hypersphere", "\n", "z", "=", "self", ".", "f", "(", "x", ")", "\n", "z", "=", "F", ".", "normalize", "(", "z", ",", "dim", "=", "2", ")", "\n", "\n", "# Compute dot-product between all pairs (batch-wise)", "\n", "dot_products", "=", "z", "@", "z", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n", "# Create mask to ignore diagonal elements (dot-products between vector and itself)", "\n", "mask", "=", "(", "torch", ".", "eye", "(", "n_meas", ",", "device", "=", "self", ".", "device", ")", ".", "bool", "(", ")", ")", ".", "repeat", "(", "batch_size", ",", "1", ",", "1", ")", "\n", "\n", "# Create mask to ignore dot-products between vectors and any padding elements", "\n", "if", "padding_mask", "is", "not", "None", ":", "\n", "            ", "padding_mask", "=", "padding_mask", ".", "unsqueeze", "(", "1", ")", "\n", "temp", "=", "padding_mask", ".", "repeat", "(", "1", ",", "n_meas", ",", "1", ")", "\n", "padding_mask", "=", "temp", "|", "temp", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "else", ":", "\n", "            ", "padding_mask", "=", "torch", ".", "zeros", "(", "batch_size", ",", "n_meas", ",", "n_meas", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# All elements which are masked are set to -inf, corresponding to zero probability in the predictions", "\n", "", "masked_dots", "=", "dot_products", ".", "masked_fill", "(", "mask", "|", "padding_mask", ",", "-", "100_000_000", ")", "\n", "\n", "probs", "=", "masked_dots", ".", "log_softmax", "(", "2", ")", "\n", "return", "probs", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.contrastive_classifier.ContrastiveClassifier.to": [[49, 52], ["super().to"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "super", "(", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "device", "=", "device", "\n", "", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.PreProccessor.__init__": [[21, 35], ["torch.nn.Module.__init__", "torch.empty().normal_", "torch.empty().normal_", "torch.empty().normal_", "torch.empty().normal_", "transformer.PreProccessor.register_buffer", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.empty", "torch.empty", "torch.empty", "torch.empty"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "d_detections", ",", "normalization_constant", ",", "use_fourier_feat", "=", "False", ",", "gauss_scale", "=", "1.0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "normalization_constant", "=", "normalization_constant", "\n", "self", ".", "use_fourier_feat", "=", "use_fourier_feat", "\n", "if", "use_fourier_feat", ":", "\n", "            ", "B", "=", "torch", ".", "empty", "(", "(", "d_detections", ",", "d_model", "//", "2", ")", ")", ".", "normal_", "(", ")", "\n", "B", "=", "B", "*", "gauss_scale", "\n", "self", ".", "register_buffer", "(", "\"gauss_B\"", ",", "B", ")", "\n", "self", ".", "d_detections", "=", "d_detections", "\n", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "use_fourier_feat", "=", "use_fourier_feat", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "d_model", ",", "bias", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_detections", ",", "d_model", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.PreProccessor.forward": [[36, 49], ["transformer.PreProccessor.linear1", "torch.mm().view", "torch.mm().view", "torch.mm().view", "torch.mm().view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.sin", "torch.cat.sin", "torch.cat.cos", "torch.cat.cos", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.cat.view", "torch.cat.view"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "src", ")", ":", "\n", "        ", "out", "=", "src", "/", "self", ".", "normalization_constant", "\n", "if", "self", ".", "use_fourier_feat", ":", "\n", "            ", "bs", ",", "num_batch_max_meas", ",", "d_detections", "=", "src", ".", "shape", "\n", "d_in", "=", "self", ".", "gauss_B", ".", "shape", "[", "0", "]", "\n", "d_out", "=", "self", ".", "d_model", "//", "2", "\n", "out", "=", "src", "*", "2", "*", "np", ".", "pi", "\n", "out", "=", "torch", ".", "mm", "(", "out", ".", "view", "(", "-", "1", ",", "d_in", ")", ",", "self", ".", "gauss_B", "[", ":", ",", ":", "d_out", "]", ")", ".", "view", "(", "\n", "bs", ",", "num_batch_max_meas", ",", "d_out", "\n", ")", "\n", "final_embeds", "=", "[", "out", ".", "sin", "(", ")", ",", "out", ".", "cos", "(", ")", "]", "\n", "out", "=", "torch", ".", "cat", "(", "final_embeds", ",", "dim", "=", "2", ")", "\n", "", "return", "self", ".", "linear1", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerEncoderLayer.__init__": [[53, 70], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "transformer._get_activation_fn"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_activation_fn"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "dim_feedforward", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "dim_feedforward", ",", "d_model", ")", "\n", "\n", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerEncoderLayer.with_pos_embed": [[71, 73], ["None"], "methods", ["None"], ["", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerEncoderLayer.forward_post": [[74, 88], ["transformer.TransformerEncoderLayer.with_pos_embed", "transformer.TransformerEncoderLayer.norm1", "transformer.TransformerEncoderLayer.linear2", "transformer.TransformerEncoderLayer.norm2", "transformer.TransformerEncoderLayer.self_attn", "transformer.TransformerEncoderLayer.dropout1", "transformer.TransformerEncoderLayer.dropout", "transformer.TransformerEncoderLayer.dropout2", "transformer.TransformerEncoderLayer.activation", "transformer.TransformerEncoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed"], ["", "def", "forward_post", "(", "self", ",", "\n", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src", ",", "pos", ")", "\n", "src2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "src", ",", "attn_mask", "=", "src_mask", ",", "\n", "key_padding_mask", "=", "src_key_padding_mask", ")", "[", "0", "]", "\n", "src", "=", "src", "+", "self", ".", "dropout1", "(", "src2", ")", "\n", "src", "=", "self", ".", "norm1", "(", "src", ")", "\n", "src2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "src", ")", ")", ")", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout2", "(", "src2", ")", "\n", "src", "=", "self", ".", "norm2", "(", "src", ")", "\n", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerEncoderLayer.forward_pre": [[89, 102], ["transformer.TransformerEncoderLayer.norm1", "transformer.TransformerEncoderLayer.with_pos_embed", "transformer.TransformerEncoderLayer.norm2", "transformer.TransformerEncoderLayer.linear2", "transformer.TransformerEncoderLayer.self_attn", "transformer.TransformerEncoderLayer.dropout1", "transformer.TransformerEncoderLayer.dropout", "transformer.TransformerEncoderLayer.dropout2", "transformer.TransformerEncoderLayer.activation", "transformer.TransformerEncoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed"], ["", "def", "forward_pre", "(", "self", ",", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "src2", "=", "self", ".", "norm1", "(", "src", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src2", ",", "pos", ")", "\n", "src2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "src2", ",", "attn_mask", "=", "src_mask", ",", "\n", "key_padding_mask", "=", "src_key_padding_mask", ")", "[", "0", "]", "\n", "src", "=", "src", "+", "self", ".", "dropout1", "(", "src2", ")", "\n", "src2", "=", "self", ".", "norm2", "(", "src", ")", "\n", "src2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "src2", ")", ")", ")", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout2", "(", "src2", ")", "\n", "return", "src", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerEncoderLayer.forward": [[103, 110], ["transformer.TransformerEncoderLayer.forward_post", "transformer.TransformerEncoderLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.forward_post", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.forward_pre"], ["", "def", "forward", "(", "self", ",", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerEncoder.__init__": [[113, 118], ["torch.nn.Module.__init__", "transformer._get_clones"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_clones"], ["    ", "def", "__init__", "(", "self", ",", "encoder_layer", ",", "num_layers", ",", "norm", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "_get_clones", "(", "encoder_layer", ",", "num_layers", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "norm", "=", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerEncoder.forward": [[119, 133], ["layer", "transformer.TransformerEncoder.norm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "src", ",", "\n", "mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "output", "=", "src", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "output", "=", "layer", "(", "output", ",", "src_mask", "=", "mask", ",", "\n", "src_key_padding_mask", "=", "src_key_padding_mask", ",", "pos", "=", "pos", ")", "\n", "\n", "", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "output", "=", "self", ".", "norm", "(", "output", ")", "\n", "\n", "", "return", "output", "\n", "# --------------------------------------------- #", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerDecoderLayer.__init__": [[138, 157], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "transformer._get_activation_fn"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_activation_fn"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "multihead_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "dim_feedforward", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "dim_feedforward", ",", "d_model", ")", "\n", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm3", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout3", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerDecoderLayer.with_pos_embed": [[158, 160], ["None"], "methods", ["None"], ["", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerDecoderLayer.forward_post": [[161, 183], ["transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.norm1", "transformer.TransformerDecoderLayer.multihead_attn", "transformer.TransformerDecoderLayer.norm2", "transformer.TransformerDecoderLayer.linear2", "transformer.TransformerDecoderLayer.norm3", "transformer.TransformerDecoderLayer.self_attn", "transformer.TransformerDecoderLayer.dropout1", "transformer.TransformerDecoderLayer.dropout2", "transformer.TransformerDecoderLayer.dropout", "transformer.TransformerDecoderLayer.dropout3", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.activation", "transformer.TransformerDecoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed"], ["", "def", "forward_post", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "tgt2", ",", "attn_maps", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout3", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm3", "(", "tgt", ")", "\n", "return", "tgt", ",", "attn_maps", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerDecoderLayer.forward_pre": [[184, 206], ["transformer.TransformerDecoderLayer.norm1", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.norm2", "transformer.TransformerDecoderLayer.multihead_attn", "transformer.TransformerDecoderLayer.norm3", "transformer.TransformerDecoderLayer.linear2", "transformer.TransformerDecoderLayer.self_attn", "transformer.TransformerDecoderLayer.dropout1", "transformer.TransformerDecoderLayer.dropout2", "transformer.TransformerDecoderLayer.dropout", "transformer.TransformerDecoderLayer.dropout3", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.with_pos_embed", "transformer.TransformerDecoderLayer.activation", "transformer.TransformerDecoderLayer.linear1"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed"], ["", "def", "forward_pre", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt2", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "tgt2", ",", "attn_maps", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm3", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt2", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout3", "(", "tgt2", ")", "\n", "return", "tgt", ",", "attn_maps", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerDecoderLayer.forward": [[207, 219], ["transformer.TransformerDecoderLayer.forward_post", "transformer.TransformerDecoderLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.forward_post", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.forward_pre"], ["", "def", "forward", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "tgt", ",", "memory", ",", "tgt_mask", ",", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "tgt", ",", "memory", ",", "tgt_mask", ",", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerDecoder.__init__": [[222, 228], ["torch.nn.Module.__init__", "transformer._get_clones"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_clones"], ["    ", "def", "__init__", "(", "self", ",", "decoder_layer", ",", "num_layers", ",", "norm", "=", "None", ",", "return_intermediate", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "_get_clones", "(", "decoder_layer", ",", "num_layers", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "norm", "=", "norm", "\n", "self", ".", "return_intermediate", "=", "return_intermediate", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer.TransformerDecoder.forward": [[229, 261], ["layer", "intermediate_attn.append", "transformer.TransformerDecoder.norm", "transformer.TransformerDecoder.unsqueeze", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "intermediate.append", "intermediate.pop", "intermediate.append", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "transformer.TransformerDecoder.norm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "output", "=", "tgt", "\n", "\n", "intermediate", "=", "[", "]", "\n", "intermediate_attn", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "output", ",", "attn_maps", "=", "layer", "(", "output", ",", "memory", ",", "tgt_mask", "=", "tgt_mask", ",", "\n", "memory_mask", "=", "memory_mask", ",", "\n", "tgt_key_padding_mask", "=", "tgt_key_padding_mask", ",", "\n", "memory_key_padding_mask", "=", "memory_key_padding_mask", ",", "\n", "pos", "=", "pos", ",", "query_pos", "=", "query_pos", ")", "\n", "if", "self", ".", "return_intermediate", ":", "\n", "                ", "intermediate", ".", "append", "(", "self", ".", "norm", "(", "output", ")", ")", "\n", "\n", "", "intermediate_attn", ".", "append", "(", "attn_maps", ")", "\n", "\n", "", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "output", "=", "self", ".", "norm", "(", "output", ")", "\n", "if", "self", ".", "return_intermediate", ":", "\n", "                ", "intermediate", ".", "pop", "(", ")", "\n", "intermediate", ".", "append", "(", "output", ")", "\n", "\n", "", "", "if", "self", ".", "return_intermediate", ":", "\n", "            ", "return", "torch", ".", "stack", "(", "intermediate", ")", ",", "torch", ".", "stack", "(", "intermediate_attn", ")", "\n", "\n", "", "return", "output", ".", "unsqueeze", "(", "0", ")", ",", "torch", ".", "stack", "(", "intermediate_attn", ")", "\n", "# --------------------------------------------- #", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer._get_clones": [[265, 267], ["torch.nn.modules.ModuleList", "copy.deepcopy", "range"], "function", ["None"], ["", "", "def", "_get_clones", "(", "module", ",", "N", ")", ":", "\n", "    ", "return", "ModuleList", "(", "[", "copy", ".", "deepcopy", "(", "module", ")", "for", "i", "in", "range", "(", "N", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.transformer._get_activation_fn": [[268, 276], ["RuntimeError"], "function", ["None"], ["", "def", "_get_activation_fn", "(", "activation", ")", ":", "\n", "\n", "    ", "if", "activation", "==", "\"relu\"", ":", "\n", "        ", "return", "F", ".", "relu", "\n", "", "elif", "activation", "==", "\"gelu\"", ":", "\n", "        ", "return", "F", ".", "gelu", "\n", "\n", "", "raise", "RuntimeError", "(", "\"activation should be relu/gelu, not {}\"", ".", "format", "(", "activation", ")", ")", "\n", "# --------------------------------------------- #", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.evaluator.evaluate_gospa": [[5, 40], ["torch.no_grad", "model.eval", "modules.loss.MotLoss", "range", "model.train", "data_generator.get_batch", "model.forward", "modules.loss.MotLoss.compute_orig_gospa_matching", "loss.item", "torch.cat"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.data_generation.data_generator.DataGenerator.get_batch", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerDecoder.forward", "home.repos.pwc.inspect_result.julianolagana_mt3v2.modules.loss.MotLoss.compute_orig_gospa_matching"], ["def", "evaluate_gospa", "(", "data_generator", ",", "model", ",", "eval_params", ")", ":", "\n", "    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "model", ".", "eval", "(", ")", "\n", "mot_loss", "=", "MotLoss", "(", "eval_params", ")", "\n", "gospa_total", "=", "0", "\n", "gospa_loc", "=", "0", "\n", "gospa_norm_loc", "=", "0", "\n", "gospa_miss", "=", "0", "\n", "gospa_false", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "eval_params", ".", "n_samples", ")", ":", "\n", "# Get batch from data generator and feed it to trained model", "\n", "            ", "batch", ",", "labels", ",", "unique_ids", ",", "_", ",", "trajectories", "=", "data_generator", ".", "get_batch", "(", ")", "\n", "prediction", ",", "_", ",", "_", ",", "_", ",", "_", "=", "model", ".", "forward", "(", "batch", ")", "\n", "\n", "# Compute GOSPA score", "\n", "prediction_in_format_for_loss", "=", "{", "'state'", ":", "torch", ".", "cat", "(", "(", "prediction", ".", "positions", ",", "prediction", ".", "velocities", ")", ",", "dim", "=", "2", ")", ",", "\n", "'logits'", ":", "prediction", ".", "logits", ",", "\n", "'state_covariances'", ":", "prediction", ".", "uncertainties", "**", "2", "}", "\n", "loss", ",", "_", ",", "decomposition", "=", "mot_loss", ".", "compute_orig_gospa_matching", "(", "prediction_in_format_for_loss", ",", "labels", ",", "\n", "eval_params", ".", "loss", ".", "existence_prob_cutoff", ")", "\n", "gospa_total", "+=", "loss", ".", "item", "(", ")", "\n", "gospa_loc", "+=", "decomposition", "[", "'localization'", "]", "\n", "gospa_norm_loc", "+=", "decomposition", "[", "'localization'", "]", "/", "decomposition", "[", "'n_matched_objs'", "]", "if", "decomposition", "[", "'n_matched_objs'", "]", "!=", "0", "else", "0.0", "\n", "gospa_miss", "+=", "decomposition", "[", "'missed'", "]", "\n", "gospa_false", "+=", "decomposition", "[", "'false'", "]", "\n", "\n", "", "model", ".", "train", "(", ")", "\n", "gospa_total", "/=", "eval_params", ".", "n_samples", "\n", "gospa_loc", "/=", "eval_params", ".", "n_samples", "\n", "gospa_norm_loc", "/=", "eval_params", ".", "n_samples", "\n", "gospa_miss", "/=", "eval_params", ".", "n_samples", "\n", "gospa_false", "/=", "eval_params", ".", "n_samples", "\n", "", "return", "gospa_total", ",", "gospa_loc", ",", "gospa_norm_loc", ",", "gospa_miss", ",", "gospa_false", "\n", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2.__init__": [[17, 117], ["torch.nn.Module.__init__", "modules.position_encoder.LearnedPositionEncoder", "torch.tensor", "modules.models.mt3v2.transformer.PreProccessor", "modules.models.mt3v2.transformer.TransformerEncoderLayer", "modules.models.mt3v2.transformer.TransformerEncoder", "modules.models.mt3v2.transformer.TransformerDecoderLayer", "torch.nn.LayerNorm", "modules.models.mt3v2.transformer.TransformerDecoder", "torch.nn.Embedding", "modules.mlp.MLP", "modules.mlp.MLP", "torch.nn.Linear", "mt3v2.MT3V2._reset_parameters", "torch.nn.init.constant_", "torch.nn.init.constant_", "mt3v2._get_clones", "mt3v2._get_clones", "mt3v2._get_clones", "torch.nn.Embedding", "modules.contrastive_classifier.ContrastiveClassifier", "modules.mlp.MLP", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.Linear", "torch.nn.init.xavier_uniform_", "torch.nn.init.constant_", "torch.device"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2._reset_parameters", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_clones", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_clones", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_clones"], ["    ", "def", "__init__", "(", "self", ",", "params", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "params", "=", "params", "\n", "self", ".", "d_detections", "=", "params", ".", "arch", ".", "d_detections", "\n", "self", ".", "temporal_encoder", "=", "LearnedPositionEncoder", "(", "params", ".", "data_generation", ".", "n_timesteps", ",", "params", ".", "arch", ".", "d_model", ")", "\n", "\n", "# Normalization factor to make all measurement dimensions have similar standard deviations", "\n", "self", ".", "measurement_normalization_factor", "=", "torch", ".", "tensor", "(", "\n", "[", "params", ".", "data_generation", ".", "field_of_view", ".", "max_range", "-", "params", ".", "data_generation", ".", "field_of_view", ".", "min_range", ",", "\n", "params", ".", "data_generation", ".", "field_of_view", ".", "max_range_rate", ",", "\n", "params", ".", "data_generation", ".", "field_of_view", ".", "max_theta", "-", "params", ".", "data_generation", ".", "field_of_view", ".", "min_theta", "]", ",", "device", "=", "torch", ".", "device", "(", "params", ".", "training", ".", "device", ")", ")", "\n", "\n", "# Rescaling factor to map xy position of measurements to (0.25, 0.75) when creating the proposals for two-stage", "\n", "# decoder", "\n", "self", ".", "fov_rescaling_factor", "=", "params", ".", "data_generation", ".", "field_of_view", ".", "max_range", "*", "4", "\n", "\n", "# Rescaling factor used to scale predictions made by the net (from -0.5 to 0.5) to the correct range in", "\n", "# state-space.", "\n", "self", ".", "output_scaling_factor", "=", "[", "params", ".", "data_generation", ".", "field_of_view", ".", "max_range", "*", "4", ",", "\n", "params", ".", "data_generation", ".", "field_of_view", ".", "max_range_rate", "*", "4", "]", "\n", "\n", "self", ".", "preprocessor", "=", "PreProccessor", "(", "params", ".", "arch", ".", "d_model", ",", "\n", "params", ".", "arch", ".", "d_detections", ",", "\n", "normalization_constant", "=", "self", ".", "measurement_normalization_factor", ")", "\n", "self", ".", "false_detect_embedding", "=", "nn", ".", "Embedding", "(", "1", ",", "params", ".", "arch", ".", "d_model", ")", "if", "params", ".", "arch", ".", "false_detect_embedding", "else", "None", "\n", "encoder_layer", "=", "TransformerEncoderLayer", "(", "params", ".", "arch", ".", "d_model", ",", "\n", "nhead", "=", "params", ".", "arch", ".", "encoder", ".", "n_heads", ",", "\n", "dim_feedforward", "=", "params", ".", "arch", ".", "encoder", ".", "dim_feedforward", ",", "\n", "dropout", "=", "params", ".", "arch", ".", "encoder", ".", "dropout", ",", "\n", "activation", "=", "\"relu\"", ",", "\n", "normalize_before", "=", "False", ",", "\n", "false_detect_embedding", "=", "self", ".", "false_detect_embedding", ")", "\n", "self", ".", "encoder", "=", "TransformerEncoder", "(", "encoder_layer", ",", "num_layers", "=", "params", ".", "arch", ".", "encoder", ".", "n_layers", ",", "norm", "=", "None", ")", "\n", "decoder_layer", "=", "TransformerDecoderLayer", "(", "params", ".", "arch", ".", "d_model", ",", "\n", "nhead", "=", "params", ".", "arch", ".", "decoder", ".", "n_heads", ",", "\n", "dim_feedforward", "=", "params", ".", "arch", ".", "decoder", ".", "dim_feedforward", ",", "\n", "dropout", "=", "params", ".", "arch", ".", "decoder", ".", "dropout", ",", "\n", "activation", "=", "\"relu\"", ",", "\n", "normalize_before", "=", "False", ")", "\n", "decoder_norm", "=", "nn", ".", "LayerNorm", "(", "params", ".", "arch", ".", "d_model", ")", "\n", "self", ".", "decoder", "=", "TransformerDecoder", "(", "decoder_layer", ",", "\n", "num_layers", "=", "params", ".", "arch", ".", "decoder", ".", "n_layers", ",", "\n", "norm", "=", "decoder_norm", ",", "\n", "with_state_refine", "=", "params", ".", "arch", ".", "with_state_refine", ")", "\n", "\n", "self", ".", "query_embed", "=", "nn", ".", "Embedding", "(", "params", ".", "arch", ".", "num_queries", ",", "params", ".", "arch", ".", "d_model", ")", "\n", "\n", "# Create pos/vel delta predictor and existence probability predictor", "\n", "self", ".", "prediction_space_dimensions", "=", "2", "# (x, y) position and velocity", "\n", "self", ".", "pos_vel_predictor", "=", "MLP", "(", "params", ".", "arch", ".", "d_model", ",", "\n", "hidden_dim", "=", "params", ".", "arch", ".", "d_prediction_hidden", ",", "\n", "output_dim", "=", "self", ".", "prediction_space_dimensions", "*", "2", ",", "\n", "num_layers", "=", "params", ".", "arch", ".", "n_prediction_layers", ")", "\n", "self", ".", "uncertainty_predictor", "=", "MLP", "(", "params", ".", "arch", ".", "d_model", ",", "\n", "hidden_dim", "=", "params", ".", "arch", ".", "d_prediction_hidden", ",", "\n", "output_dim", "=", "self", ".", "prediction_space_dimensions", "*", "2", ",", "\n", "num_layers", "=", "params", ".", "arch", ".", "n_prediction_layers", ",", "\n", "softplus_at_end", "=", "True", ")", "\n", "self", ".", "obj_classifier", "=", "nn", ".", "Linear", "(", "params", ".", "arch", ".", "d_model", ",", "1", ")", "\n", "\n", "self", ".", "return_intermediate", "=", "params", ".", "loss", ".", "return_intermediate", "\n", "if", "self", ".", "params", ".", "loss", ".", "contrastive_classifier", ":", "\n", "            ", "self", ".", "contrastive_classifier", "=", "ContrastiveClassifier", "(", "params", ".", "arch", ".", "d_model", ")", "\n", "", "if", "self", ".", "params", ".", "loss", ".", "false_classifier", ":", "\n", "            ", "self", ".", "false_classifier", "=", "MLP", "(", "params", ".", "arch", ".", "d_model", ",", "\n", "hidden_dim", "=", "params", ".", "arch", ".", "d_prediction_hidden", ",", "\n", "output_dim", "=", "1", ",", "\n", "num_layers", "=", "1", ")", "\n", "", "self", ".", "two_stage", "=", "params", ".", "arch", ".", "two_stage", "\n", "self", ".", "d_model", "=", "params", ".", "arch", ".", "d_model", "\n", "\n", "self", ".", "_reset_parameters", "(", ")", "\n", "\n", "# Initialize delta predictions to zero", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "pos_vel_predictor", ".", "layers", "[", "-", "1", "]", ".", "weight", ".", "data", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "pos_vel_predictor", ".", "layers", "[", "-", "1", "]", ".", "bias", ".", "data", ",", "0", ")", "\n", "\n", "# Clone prediction heads for all layers of the decoder (+1 for encoder if two-stage)", "\n", "num_pred", "=", "(", "self", ".", "decoder", ".", "num_layers", "+", "1", ")", "if", "self", ".", "two_stage", "else", "self", ".", "decoder", ".", "num_layers", "\n", "self", ".", "obj_classifier", "=", "_get_clones", "(", "self", ".", "obj_classifier", ",", "num_pred", ")", "\n", "self", ".", "pos_vel_predictor", "=", "_get_clones", "(", "self", ".", "pos_vel_predictor", ",", "num_pred", ")", "\n", "self", ".", "uncertainty_predictor", "=", "_get_clones", "(", "self", ".", "uncertainty_predictor", ",", "num_pred", ")", "\n", "self", ".", "decoder", ".", "pos_vel_predictor", "=", "self", ".", "pos_vel_predictor", "\n", "self", ".", "decoder", ".", "uncertainty_predictor", "=", "self", ".", "uncertainty_predictor", "\n", "self", ".", "decoder", ".", "obj_classifier", "=", "self", ".", "obj_classifier", "\n", "\n", "if", "self", ".", "two_stage", ":", "\n", "# hack implementation for two-stage", "\n", "            ", "self", ".", "enc_output", "=", "nn", ".", "Linear", "(", "params", ".", "arch", ".", "d_model", ",", "params", ".", "arch", ".", "d_model", ")", "\n", "self", ".", "enc_output_norm", "=", "nn", ".", "LayerNorm", "(", "params", ".", "arch", ".", "d_model", ")", "\n", "\n", "self", ".", "pos_trans", "=", "nn", ".", "Linear", "(", "self", ".", "d_model", ",", "self", ".", "d_model", "*", "2", ")", "\n", "self", ".", "pos_trans_norm", "=", "nn", ".", "LayerNorm", "(", "self", ".", "d_model", "*", "2", ")", "\n", "\n", "self", ".", "num_queries", "=", "params", ".", "arch", ".", "num_queries", "\n", "", "else", ":", "\n", "            ", "self", ".", "reference_points_linear", "=", "nn", ".", "Linear", "(", "params", ".", "arch", ".", "d_model", ",", "self", ".", "prediction_space_dimensions", "*", "2", ")", "\n", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "reference_points_linear", ".", "weight", ".", "data", ",", "gain", "=", "1.0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "reference_points_linear", ".", "bias", ".", "data", ",", "0.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2._reset_parameters": [[118, 122], ["mt3v2.MT3V2.parameters", "p.dim", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "", "def", "_reset_parameters", "(", "self", ")", ":", "\n", "        ", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "dim", "(", ")", ">", "1", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2.gen_encoder_output_proposals": [[123, 140], ["torch.log", "normalized_measurements_presigmoid.masked_fill.masked_fill.masked_fill", "normalized_measurements_presigmoid.masked_fill.masked_fill.masked_fill", "masked_embeddings.masked_fill.masked_fill.masked_fill", "masked_embeddings.masked_fill.masked_fill.masked_fill", "mt3v2.MT3V2.enc_output_norm", "memory_padding_mask.unsqueeze", "float", "float", "memory_padding_mask.unsqueeze", "float", "float", "mt3v2.MT3V2.enc_output"], "methods", ["None"], ["", "", "", "def", "gen_encoder_output_proposals", "(", "self", ",", "embeddings", ",", "memory_padding_mask", ",", "normalized_measurements", ")", ":", "\n", "# Compute presigmoid version of normalized measurements", "\n", "        ", "normalized_measurements_presigmoid", "=", "torch", ".", "log", "(", "normalized_measurements", "/", "(", "1", "-", "normalized_measurements", ")", ")", "\n", "\n", "# Set to inf invalid measurements (masked or outside the FOV)", "\n", "output_proposals_valid", "=", "(", "(", "normalized_measurements", ">", "0.01", ")", "&", "(", "normalized_measurements", "<", "0.99", ")", ")", ".", "all", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "normalized_measurements_presigmoid", "=", "normalized_measurements_presigmoid", ".", "masked_fill", "(", "memory_padding_mask", ".", "unsqueeze", "(", "-", "1", ")", ",", "float", "(", "'inf'", ")", ")", "\n", "normalized_measurements_presigmoid", "=", "normalized_measurements_presigmoid", ".", "masked_fill", "(", "~", "output_proposals_valid", ",", "float", "(", "'inf'", ")", ")", "\n", "\n", "# Mask embeddings of measurements that are actually just padding", "\n", "masked_embeddings", "=", "embeddings", "\n", "masked_embeddings", "=", "masked_embeddings", ".", "masked_fill", "(", "memory_padding_mask", ".", "unsqueeze", "(", "-", "1", ")", ",", "float", "(", "0", ")", ")", "\n", "masked_embeddings", "=", "masked_embeddings", ".", "masked_fill", "(", "~", "output_proposals_valid", ",", "float", "(", "0", ")", ")", "\n", "\n", "# Project embeddings", "\n", "projected_embeddings", "=", "self", ".", "enc_output_norm", "(", "self", ".", "enc_output", "(", "masked_embeddings", ")", ")", "\n", "return", "projected_embeddings", ",", "normalized_measurements_presigmoid", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2.get_proposal_pos_embed": [[141, 156], ["torch.arange", "torch.stack().flatten", "proposals.sigmoid", "torch.stack", "pos[].sin", "pos[].cos"], "methods", ["None"], ["", "def", "get_proposal_pos_embed", "(", "self", ",", "proposals", ")", ":", "\n", "        ", "num_pos_feats", "=", "self", ".", "d_model", "\n", "temperature", "=", "10000", "\n", "scale", "=", "2", "*", "math", ".", "pi", "\n", "\n", "dim_t", "=", "torch", ".", "arange", "(", "num_pos_feats", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "proposals", ".", "device", ")", "\n", "dim_t", "=", "temperature", "**", "(", "2", "*", "(", "dim_t", "//", "2", ")", "/", "num_pos_feats", ")", "\n", "# N, L, 2", "\n", "proposals", "=", "proposals", ".", "sigmoid", "(", ")", "*", "scale", "\n", "# N, L, 2, num_pos_feats", "\n", "pos", "=", "proposals", "[", ":", ",", ":", ",", ":", ",", "None", "]", "/", "dim_t", "\n", "# N, L, 2, num_pos_feats/2, 2", "\n", "pos", "=", "torch", ".", "stack", "(", "(", "pos", "[", ":", ",", ":", ",", ":", ",", "0", ":", ":", "2", "]", ".", "sin", "(", ")", ",", "pos", "[", ":", ",", ":", ",", ":", ",", "1", ":", ":", "2", "]", ".", "cos", "(", ")", ")", ",", "dim", "=", "4", ")", ".", "flatten", "(", "2", ")", "\n", "# N, L, num_pos_feats*2", "\n", "return", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2.get_two_stage_proposals": [[157, 218], ["torch.stack", "mt3v2.MT3V2.gen_encoder_output_proposals", "scores.masked_fill.masked_fill.masked_fill", "torch.zeros_like", "torch.cat", "adjusted_normalized_meas_presigmoid.sigmoid", "topk_scores_indices.unsqueeze().repeat", "torch.gather().detach", "torch.gather().detach.sigmoid().permute", "torch.gather", "mt3v2.MT3V2.pos_trans_norm", "torch.split", "query_positional_encodings.permute.permute.permute", "object_queries.permute.permute.permute", "measurements[].cos", "measurements[].sin", "embeddings.permute", "measurement_batch.mask.unsqueeze", "torch.topk", "projected_embeddings.detach", "topk_scores_indices.unsqueeze().repeat", "mt3v2.MT3V2.pos_trans", "topk_scores_indices.unsqueeze", "torch.gather", "torch.gather().detach.sigmoid", "topk_scores_indices.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2.gen_encoder_output_proposals"], ["", "def", "get_two_stage_proposals", "(", "self", ",", "measurement_batch", ",", "embeddings", ")", ":", "\n", "        ", "\"\"\"\n        Given a batch of measurements and their corresponding embeddings (computed by the encoder), this generates the\n        object queries to be fed by the decoder, using the selection mechanism as explained in https://arxiv.org/abs/2104.00734\n\n        @param measurement_batch: Batch of measurements, including their masks.\n        @param embeddings: Embeddings computed by the encoder for each of the measurements.\n        @return:\n            object_queries: queries to be fed to the decoder.\n            query_positional_encodings: positional encodings to be added to the object queries.\n            reference_points: 2D position estimates to be used as starting points for iterative refinement in the\n                decoder.\n            enc_outputs_class: predicted existence probability for each measurement.\n            enc_outputs_state: predicted adjustment delta for each measurement (measurements are adjusted by summing\n                their corresponding deltas before using them as starting points for iterative refinement.\n            enc_outputs_coord_unact: adjusted measurements using their corresponding predicted deltas.\n        \"\"\"", "\n", "n_measurements", ",", "_", ",", "c", "=", "embeddings", ".", "shape", "\n", "measurements", "=", "measurement_batch", ".", "tensors", "[", ":", ",", ":", ",", ":", "self", ".", "d_detections", "]", "\n", "\n", "# Compute xy position of the measurements using range and azimuth", "\n", "xs", "=", "measurements", "[", ":", ",", ":", ",", "0", "]", "*", "(", "measurements", "[", ":", ",", ":", ",", "2", "]", ".", "cos", "(", ")", ")", "\n", "ys", "=", "measurements", "[", ":", ",", ":", ",", "0", "]", "*", "(", "measurements", "[", ":", ",", ":", ",", "2", "]", ".", "sin", "(", ")", ")", "\n", "xy_measurements", "=", "torch", ".", "stack", "(", "[", "xs", ",", "ys", "]", ",", "2", ")", "\n", "\n", "# Normalize measurements to 0.25 - 0.75 (to avoid extreme regions of the sigmoid)", "\n", "normalized_xy_meas", "=", "xy_measurements", "/", "self", ".", "fov_rescaling_factor", "+", "0.5", "\n", "\n", "# Compute projected encoder memory + presigmoid normalized measurements (filtered using the masks)", "\n", "result", "=", "self", ".", "gen_encoder_output_proposals", "(", "embeddings", ".", "permute", "(", "1", ",", "0", ",", "2", ")", ",", "measurement_batch", ".", "mask", ",", "normalized_xy_meas", ")", "\n", "projected_embeddings", ",", "normalized_meas_presigmoid", "=", "result", "\n", "\n", "# Compute scores and adjustments", "\n", "scores", "=", "self", ".", "decoder", ".", "obj_classifier", "[", "self", ".", "decoder", ".", "num_layers", "]", "(", "projected_embeddings", ")", "\n", "scores", "=", "scores", ".", "masked_fill", "(", "measurement_batch", ".", "mask", ".", "unsqueeze", "(", "-", "1", ")", ",", "-", "100_000_000", ")", "# Set masked predictions to \"0\" probability", "\n", "adjustments", "=", "self", ".", "pos_vel_predictor", "[", "self", ".", "decoder", ".", "num_layers", "]", "(", "projected_embeddings", ")", "\n", "\n", "# Concatenate initial velocity estimates to the measurements", "\n", "init_vel_estimates_presigmoid", "=", "torch", ".", "zeros_like", "(", "normalized_meas_presigmoid", ")", "\n", "normalized_meas_presigmoid", "=", "torch", ".", "cat", "(", "(", "normalized_meas_presigmoid", ",", "init_vel_estimates_presigmoid", ",", ")", ",", "dim", "=", "2", ")", "\n", "\n", "# Adjust measurements", "\n", "adjusted_normalized_meas_presigmoid", "=", "normalized_meas_presigmoid", "+", "adjustments", "\n", "adjusted_normalized_meas", "=", "adjusted_normalized_meas_presigmoid", ".", "sigmoid", "(", ")", "\n", "\n", "# Select top-k scoring measurements and their corresponding embeddings", "\n", "topk_scores_indices", "=", "torch", ".", "topk", "(", "scores", "[", "...", ",", "0", "]", ",", "self", ".", "num_queries", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "repeated_indices", "=", "topk_scores_indices", ".", "unsqueeze", "(", "-", "1", ")", ".", "repeat", "(", "(", "1", ",", "1", ",", "adjusted_normalized_meas_presigmoid", ".", "shape", "[", "2", "]", ")", ")", "\n", "topk_adjusted_normalized_meas_presigmoid", "=", "torch", ".", "gather", "(", "adjusted_normalized_meas_presigmoid", ",", "\n", "1", ",", "\n", "repeated_indices", ")", ".", "detach", "(", ")", "\n", "topk_adjusted_normalized_meas", "=", "topk_adjusted_normalized_meas_presigmoid", ".", "sigmoid", "(", ")", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "topk_memory", "=", "torch", ".", "gather", "(", "projected_embeddings", ".", "detach", "(", ")", ",", "1", ",", "topk_scores_indices", ".", "unsqueeze", "(", "-", "1", ")", ".", "repeat", "(", "1", ",", "1", ",", "self", ".", "params", ".", "arch", ".", "d_model", ")", ")", "\n", "\n", "# Compute object queries and their positional encodings by feeding the top-k memory through FFN+LayerNorm", "\n", "pos_trans_out", "=", "self", ".", "pos_trans_norm", "(", "self", ".", "pos_trans", "(", "topk_memory", ")", ")", "\n", "query_positional_encodings", ",", "object_queries", "=", "torch", ".", "split", "(", "pos_trans_out", ",", "c", ",", "dim", "=", "2", ")", "\n", "query_positional_encodings", "=", "query_positional_encodings", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "object_queries", "=", "object_queries", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "\n", "return", "object_queries", ",", "query_positional_encodings", ",", "topk_adjusted_normalized_meas", ",", "scores", ",", "adjustments", ",", "adjusted_normalized_meas", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2.forward": [[219, 290], ["torch.round", "mt3v2.MT3V2.temporal_encoder", "mt3v2.MT3V2.preprocessor", "preprocessed_measurements.permute.permute.permute", "time_encoding.permute.permute.permute", "mt3v2.MT3V2.encoder", "mt3v2.MT3V2.decoder", "util.misc.Prediction", "torch.round.long", "mt3v2.MT3V2.contrastive_classifier", "mt3v2.MT3V2.false_classifier", "mt3v2.MT3V2.get_two_stage_proposals", "mt3v2.MT3V2.query_embed.weight.unsqueeze().repeat", "torch.zeros_like", "mt3v2.MT3V2.reference_points_linear().sigmoid", "adjusted_meas.masked_fill.masked_fill.masked_fill", "util.misc.Prediction", "mt3v2.MT3V2.permute", "mask.unsqueeze().repeat", "util.misc.Prediction", "mt3v2.MT3V2.query_embed.weight.unsqueeze", "mt3v2.MT3V2.reference_points_linear", "zip", "mask.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2.get_two_stage_proposals"], ["", "def", "forward", "(", "self", ",", "measurements", ":", "NestedTensor", ")", ":", "\n", "        ", "mapped_time_idx", "=", "torch", ".", "round", "(", "measurements", ".", "tensors", "[", ":", ",", ":", ",", "-", "1", "]", "/", "self", ".", "params", ".", "data_generation", ".", "dt", ")", "\n", "time_encoding", "=", "self", ".", "temporal_encoder", "(", "mapped_time_idx", ".", "long", "(", ")", ")", "\n", "preprocessed_measurements", "=", "self", ".", "preprocessor", "(", "measurements", ".", "tensors", "[", ":", ",", ":", ",", ":", "self", ".", "d_detections", "]", ")", "\n", "mask", "=", "measurements", ".", "mask", "\n", "\n", "batch_size", ",", "num_batch_max_meas", ",", "d_detections", "=", "preprocessed_measurements", ".", "shape", "\n", "preprocessed_measurements", "=", "preprocessed_measurements", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "time_encoding", "=", "time_encoding", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "\n", "# Feed measurements through encoder", "\n", "embeddings", "=", "self", ".", "encoder", "(", "preprocessed_measurements", ",", "src_key_padding_mask", "=", "mask", ",", "pos", "=", "time_encoding", ")", "\n", "\n", "# Compute optional classifications", "\n", "aux_classifications", "=", "{", "}", "\n", "if", "self", ".", "params", ".", "loss", ".", "contrastive_classifier", ":", "\n", "            ", "contrastive_classifications", "=", "self", ".", "contrastive_classifier", "(", "embeddings", ".", "permute", "(", "1", ",", "0", ",", "2", ")", ",", "padding_mask", "=", "mask", ")", "\n", "aux_classifications", "[", "'contrastive_classifications'", "]", "=", "contrastive_classifications", "\n", "", "if", "self", ".", "params", ".", "loss", ".", "false_classifier", ":", "\n", "            ", "false_classifications", "=", "self", ".", "false_classifier", "(", "embeddings", ")", "\n", "aux_classifications", "[", "'false_classifications'", "]", "=", "false_classifications", "\n", "\n", "# Compute object queries for the decoder", "\n", "", "if", "self", ".", "two_stage", ":", "\n", "            ", "(", "object_queries", ",", "\n", "query_positional_encodings", ",", "\n", "topk_adjusted_normalized_meas", ",", "\n", "scores", ",", "\n", "adjustments", ",", "\n", "adjusted_normalized_meas", ")", "=", "self", ".", "get_two_stage_proposals", "(", "measurements", ",", "embeddings", ")", "\n", "", "else", ":", "\n", "            ", "query_positional_encodings", "=", "self", ".", "query_embed", ".", "weight", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "batch_size", ",", "1", ")", "\n", "object_queries", "=", "torch", ".", "zeros_like", "(", "query_positional_encodings", ")", "\n", "topk_adjusted_normalized_meas", "=", "self", ".", "reference_points_linear", "(", "query_positional_encodings", ")", ".", "sigmoid", "(", ")", "\n", "\n", "# Feed embeddings and object queries to decoder", "\n", "", "result", "=", "self", ".", "decoder", "(", "object_queries", ",", "embeddings", ",", "\n", "encoder_embeddings_padding_mask", "=", "mask", ",", "\n", "encoder_embeddings_positional_encoding", "=", "time_encoding", ",", "\n", "object_queries_positional_encoding", "=", "query_positional_encodings", ",", "\n", "reference_points", "=", "topk_adjusted_normalized_meas", ")", "\n", "intermediate_state_predictions_normalized", ",", "intermediate_uncertainties", ",", "intermediate_logits", ",", "debug_dict", "=", "result", "\n", "\n", "# Un-normalize state predictions", "\n", "intermediate_state_predictions", "=", "intermediate_state_predictions_normalized", "-", "0.5", "\n", "intermediate_state_predictions", "[", ":", ",", ":", ",", ":", ",", ":", "2", "]", "*=", "self", ".", "output_scaling_factor", "[", "0", "]", "\n", "intermediate_state_predictions", "[", ":", ",", ":", ",", ":", ",", "2", ":", "]", "*=", "self", ".", "output_scaling_factor", "[", "1", "]", "\n", "\n", "# Un-normalize encoder state predictions and make sure padded measurements cannot be matched / are far away", "\n", "if", "self", ".", "two_stage", ":", "\n", "            ", "adjusted_meas", "=", "adjusted_normalized_meas", "-", "0.5", "\n", "adjusted_meas", "[", ":", ",", ":", ",", ":", "2", "]", "*=", "self", ".", "output_scaling_factor", "[", "0", "]", "\n", "adjusted_meas", "[", ":", ",", ":", ",", "2", ":", "]", "*=", "self", ".", "output_scaling_factor", "[", "1", "]", "\n", "# Hack to make padded measurements never be matched", "\n", "adjusted_meas", "=", "adjusted_meas", ".", "masked_fill", "(", "mask", ".", "unsqueeze", "(", "-", "1", ")", ".", "repeat", "(", "1", ",", "1", ",", "adjusted_meas", ".", "shape", "[", "-", "1", "]", ")", ",", "self", ".", "output_scaling_factor", "[", "0", "]", "*", "5", ")", "\n", "\n", "# Pack output using standardized Prediction class", "\n", "", "prediction", "=", "Prediction", "(", "positions", "=", "intermediate_state_predictions", "[", "-", "1", "]", "[", ":", ",", ":", ",", ":", "self", ".", "prediction_space_dimensions", "]", ",", "\n", "velocities", "=", "intermediate_state_predictions", "[", "-", "1", "]", "[", ":", ",", ":", ",", "self", ".", "prediction_space_dimensions", ":", "]", ",", "\n", "uncertainties", "=", "intermediate_uncertainties", "[", "-", "1", "]", ",", "\n", "logits", "=", "intermediate_logits", "[", "-", "1", "]", ")", "\n", "intermediate_predictions", "=", "[", "Prediction", "(", "positions", "=", "p", "[", ":", ",", ":", ",", ":", "self", ".", "prediction_space_dimensions", "]", ",", "\n", "velocities", "=", "p", "[", ":", ",", ":", ",", "self", ".", "prediction_space_dimensions", ":", "]", ",", "\n", "uncertainties", "=", "u", ",", "\n", "logits", "=", "l", ")", "for", "p", ",", "l", ",", "u", "in", "zip", "(", "intermediate_state_predictions", "[", ":", "-", "1", "]", ",", "\n", "intermediate_logits", "[", ":", "-", "1", "]", ",", "\n", "intermediate_uncertainties", "[", ":", "-", "1", "]", ")", "]", "if", "self", ".", "return_intermediate", "else", "None", "\n", "encoder_prediction", "=", "Prediction", "(", "positions", "=", "adjusted_meas", "[", ":", ",", ":", ",", ":", "self", ".", "prediction_space_dimensions", "]", ",", "\n", "velocities", "=", "adjusted_meas", "[", ":", ",", ":", ",", "self", ".", "prediction_space_dimensions", ":", "]", ",", "\n", "logits", "=", "scores", ")", "if", "self", ".", "two_stage", "else", "None", "\n", "return", "prediction", ",", "intermediate_predictions", ",", "encoder_prediction", ",", "aux_classifications", ",", "debug_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2.MT3V2.to": [[291, 295], ["super().to", "mt3v2.MT3V2.contrastive_classifier.to"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "super", "(", ")", ".", "to", "(", "device", ")", "\n", "if", "self", ".", "params", ".", "loss", ".", "contrastive_classifier", ":", "\n", "            ", "self", ".", "contrastive_classifier", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.mt3v2._get_clones": [[12, 14], ["torch.nn.ModuleList", "copy.deepcopy", "range"], "function", ["None"], ["def", "_get_clones", "(", "module", ",", "N", ")", ":", "\n", "    ", "return", "nn", ".", "ModuleList", "(", "[", "copy", ".", "deepcopy", "(", "module", ")", "for", "i", "in", "range", "(", "N", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.__init__": [[14, 32], ["torch.nn.Module.__init__", "torch.nn.MultiheadAttention", "torch.nn.MultiheadAttention", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "transformer._get_activation_fn"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_activation_fn"], ["\n", "\n", "\n", "class", "PreProccessor", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "d_model", ",", "d_detections", ",", "normalization_constant", ",", "use_fourier_feat", "=", "False", ",", "gauss_scale", "=", "1.0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "normalization_constant", "=", "normalization_constant", "\n", "self", ".", "use_fourier_feat", "=", "use_fourier_feat", "\n", "if", "use_fourier_feat", ":", "\n", "            ", "B", "=", "torch", ".", "empty", "(", "(", "d_detections", ",", "d_model", "//", "2", ")", ")", ".", "normal_", "(", ")", "\n", "B", "=", "B", "*", "gauss_scale", "\n", "self", ".", "register_buffer", "(", "\"gauss_B\"", ",", "B", ")", "\n", "self", ".", "d_detections", "=", "d_detections", "\n", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "use_fourier_feat", "=", "use_fourier_feat", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "d_model", ",", "bias", "=", "False", ")", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed": [[33, 35], ["None"], "methods", ["None"], ["", "else", ":", "\n", "            ", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_detections", ",", "d_model", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.forward_post": [[36, 61], ["transformer.TransformerEncoderLayer.with_pos_embed", "transformer.TransformerEncoderLayer.norm1", "transformer.TransformerEncoderLayer.linear2", "transformer.TransformerEncoderLayer.norm2", "transformer.TransformerEncoderLayer.false_detect_embedding.weight.unsqueeze().permute().repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros().bool().to", "torch.zeros().bool().to", "torch.zeros().bool().to", "torch.zeros().bool().to", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "transformer.TransformerEncoderLayer.self_attn", "transformer.TransformerEncoderLayer.dropout1", "transformer.TransformerEncoderLayer.dropout", "transformer.TransformerEncoderLayer.dropout2", "transformer.TransformerEncoderLayer.activation", "transformer.TransformerEncoderLayer.false_detect_embedding.weight.unsqueeze().permute", "torch.zeros().bool", "torch.zeros().bool", "torch.zeros().bool", "torch.zeros().bool", "transformer.TransformerEncoderLayer.linear1", "transformer.TransformerEncoderLayer.false_detect_embedding.weight.unsqueeze", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to"], ["", "", "def", "forward", "(", "self", ",", "src", ")", ":", "\n", "        ", "out", "=", "src", "/", "self", ".", "normalization_constant", "\n", "if", "self", ".", "use_fourier_feat", ":", "\n", "            ", "bs", ",", "num_batch_max_meas", ",", "d_detections", "=", "src", ".", "shape", "\n", "d_in", "=", "self", ".", "gauss_B", ".", "shape", "[", "0", "]", "\n", "d_out", "=", "self", ".", "d_model", "//", "2", "\n", "out", "=", "src", "*", "2", "*", "np", ".", "pi", "\n", "out", "=", "torch", ".", "mm", "(", "out", ".", "view", "(", "-", "1", ",", "d_in", ")", ",", "self", ".", "gauss_B", "[", ":", ",", ":", "d_out", "]", ")", ".", "view", "(", "\n", "bs", ",", "num_batch_max_meas", ",", "d_out", "\n", ")", "\n", "final_embeds", "=", "[", "out", ".", "sin", "(", ")", ",", "out", ".", "cos", "(", ")", "]", "\n", "out", "=", "torch", ".", "cat", "(", "final_embeds", ",", "dim", "=", "2", ")", "\n", "", "return", "self", ".", "linear1", "(", "out", ")", "\n", "\n", "# ------------ TRANSFORMER ENCODER ------------ #", "\n", "", "", "class", "TransformerEncoderLayer", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "    ", "def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "dim_feedforward", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "dim_feedforward", ",", "d_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.forward_pre": [[62, 86], ["transformer.TransformerEncoderLayer.norm1", "transformer.TransformerEncoderLayer.with_pos_embed", "transformer.TransformerEncoderLayer.norm2", "transformer.TransformerEncoderLayer.linear2", "transformer.TransformerEncoderLayer.false_detect_embedding.weight.unsqueeze().permute().repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros().bool().to", "torch.zeros().bool().to", "torch.zeros().bool().to", "torch.zeros().bool().to", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "transformer.TransformerEncoderLayer.self_attn", "transformer.TransformerEncoderLayer.dropout1", "transformer.TransformerEncoderLayer.dropout", "transformer.TransformerEncoderLayer.dropout2", "transformer.TransformerEncoderLayer.activation", "transformer.TransformerEncoderLayer.false_detect_embedding.weight.unsqueeze().permute", "torch.zeros().bool", "torch.zeros().bool", "torch.zeros().bool", "torch.zeros().bool", "transformer.TransformerEncoderLayer.linear1", "transformer.TransformerEncoderLayer.false_detect_embedding.weight.unsqueeze", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.with_pos_embed", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to"], ["\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n", "", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n", "", "def", "forward_post", "(", "self", ",", "\n", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src", ",", "pos", ")", "\n", "src2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "src", ",", "attn_mask", "=", "src_mask", ",", "\n", "key_padding_mask", "=", "src_key_padding_mask", ")", "[", "0", "]", "\n", "src", "=", "src", "+", "self", ".", "dropout1", "(", "src2", ")", "\n", "src", "=", "self", ".", "norm1", "(", "src", ")", "\n", "src2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "src", ")", ")", ")", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout2", "(", "src2", ")", "\n", "src", "=", "self", ".", "norm2", "(", "src", ")", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.forward": [[87, 94], ["transformer.TransformerEncoderLayer.forward_post", "transformer.TransformerEncoderLayer.forward_pre"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.forward_post", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoderLayer.forward_pre"], ["return", "src", "\n", "\n", "", "def", "forward_pre", "(", "self", ",", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "src2", "=", "self", ".", "norm1", "(", "src", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "src2", ",", "pos", ")", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoder.__init__": [[98, 106], ["torch.nn.Module.__init__", "transformer._get_clones"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_clones"], ["src2", "=", "self", ".", "norm2", "(", "src", ")", "\n", "src2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "src2", ")", ")", ")", ")", "\n", "src", "=", "src", "+", "self", ".", "dropout2", "(", "src2", ")", "\n", "return", "src", "\n", "\n", "", "def", "forward", "(", "self", ",", "src", ",", "\n", "src_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerEncoder.forward": [[107, 121], ["layer", "transformer.TransformerEncoder.norm"], "methods", ["None"], ["        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "src", ",", "src_mask", ",", "src_key_padding_mask", ",", "pos", ")", "\n", "\n", "", "", "class", "TransformerEncoder", "(", "nn", ".", "Module", ")", ":", "\n", "\n", "    ", "def", "__init__", "(", "self", ",", "encoder_layer", ",", "num_layers", ",", "norm", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "_get_clones", "(", "encoder_layer", ",", "num_layers", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "norm", "=", "norm", "\n", "\n", "", "def", "forward", "(", "self", ",", "src", ",", "\n", "mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "src_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerDecoder.__init__": [[125, 137], ["torch.nn.Module.__init__", "transformer._get_clones"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__", "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_clones"], ["for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "output", "=", "layer", "(", "output", ",", "src_mask", "=", "mask", ",", "\n", "src_key_padding_mask", "=", "src_key_padding_mask", ",", "pos", "=", "pos", ")", "\n", "\n", "", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "output", "=", "self", ".", "norm", "(", "output", ")", "\n", "\n", "", "return", "output", "\n", "# --------------------------------------------- #", "\n", "\n", "# ------------ TRANSFORMER DECODER ------------ #", "\n", "", "", "class", "TransformerDecoderLayer", "(", "nn", ".", "Module", ")", ":", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer.TransformerDecoder.forward": [[138, 206], ["enumerate", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "layer", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "transformer.TransformerDecoder.norm().permute", "transformer.TransformerDecoder.norm", "transformer.TransformerDecoder.norm", "normalized_predicted_state_at_current_layer.detach", "normalized_predicted_state_at_current_layer.permute", "uncertainties.permute", "debug_dict[].append", "transformer.TransformerDecoder.norm", "util.misc.inverse_sigmoid"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.inverse_sigmoid"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "nhead", ",", "dim_feedforward", "=", "2048", ",", "dropout", "=", "0.1", ",", "\n", "activation", "=", "\"relu\"", ",", "normalize_before", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "multihead_attn", "=", "nn", ".", "MultiheadAttention", "(", "d_model", ",", "nhead", ",", "dropout", "=", "dropout", ")", "\n", "# Implementation of Feedforward model", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "d_model", ",", "dim_feedforward", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "dim_feedforward", ",", "d_model", ")", "\n", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm3", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "dropout3", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "activation", "=", "_get_activation_fn", "(", "activation", ")", "\n", "self", ".", "normalize_before", "=", "normalize_before", "\n", "\n", "", "def", "with_pos_embed", "(", "self", ",", "tensor", ",", "pos", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "return", "tensor", "if", "pos", "is", "None", "else", "tensor", "+", "pos", "\n", "\n", "", "def", "forward_post", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "tgt2", ",", "attn_maps", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout3", "(", "tgt2", ")", "\n", "tgt", "=", "self", ".", "norm3", "(", "tgt", ")", "\n", "return", "tgt", ",", "attn_maps", "\n", "\n", "", "def", "forward_pre", "(", "self", ",", "tgt", ",", "memory", ",", "\n", "tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "tgt2", "=", "self", ".", "norm1", "(", "tgt", ")", "\n", "q", "=", "k", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", "\n", "tgt2", "=", "self", ".", "self_attn", "(", "q", ",", "k", ",", "value", "=", "tgt2", ",", "attn_mask", "=", "tgt_mask", ",", "\n", "key_padding_mask", "=", "tgt_key_padding_mask", ")", "[", "0", "]", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout1", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm2", "(", "tgt", ")", "\n", "tgt2", ",", "attn_maps", "=", "self", ".", "multihead_attn", "(", "query", "=", "self", ".", "with_pos_embed", "(", "tgt2", ",", "query_pos", ")", ",", "\n", "key", "=", "self", ".", "with_pos_embed", "(", "memory", ",", "pos", ")", ",", "\n", "value", "=", "memory", ",", "attn_mask", "=", "memory_mask", ",", "\n", "key_padding_mask", "=", "memory_key_padding_mask", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout2", "(", "tgt2", ")", "\n", "tgt2", "=", "self", ".", "norm3", "(", "tgt", ")", "\n", "tgt2", "=", "self", ".", "linear2", "(", "self", ".", "dropout", "(", "self", ".", "activation", "(", "self", ".", "linear1", "(", "tgt2", ")", ")", ")", ")", "\n", "tgt", "=", "tgt", "+", "self", ".", "dropout3", "(", "tgt2", ")", "\n", "return", "tgt", ",", "attn_maps", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_clones": [[208, 210], ["torch.nn.modules.ModuleList", "copy.deepcopy", "range"], "function", ["None"], ["tgt_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "memory_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "tgt_key_padding_mask", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.mt3v2.transformer._get_activation_fn": [[212, 220], ["RuntimeError"], "function", ["None"], ["pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "query_pos", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_before", ":", "\n", "            ", "return", "self", ".", "forward_pre", "(", "tgt", ",", "memory", ",", "tgt_mask", ",", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "", "return", "self", ".", "forward_post", "(", "tgt", ",", "memory", ",", "tgt_mask", ",", "memory_mask", ",", "\n", "tgt_key_padding_mask", ",", "memory_key_padding_mask", ",", "pos", ",", "query_pos", ")", "\n", "\n", "", "", "class", "TransformerDecoder", "(", "nn", ".", "Module", ")", ":", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.realistic_radar_model.realistic_meas_model.RealisticMeasModel.__init__": [[7, 22], ["scipy.io.loadmat", "torch.tensor", "min", "max", "min", "max", "data[].item", "data[].item", "data[].item", "data[].item"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "data", "=", "loadmat", "(", "'src/results/precomputed_covs/precomputed_covs.mat'", ")", "\n", "self", ".", "y", "=", "torch", ".", "tensor", "(", "data", "[", "'Y'", "]", ")", "\n", "self", ".", "min_r", "=", "min", "(", "data", "[", "'X'", "]", "[", ":", ",", "0", "]", ")", "\n", "self", ".", "max_r", "=", "max", "(", "data", "[", "'X'", "]", "[", ":", ",", "0", "]", ")", "\n", "self", ".", "min_theta", "=", "min", "(", "data", "[", "'X'", "]", "[", ":", ",", "1", "]", ")", "\n", "self", ".", "max_theta", "=", "max", "(", "data", "[", "'X'", "]", "[", ":", ",", "1", "]", ")", "\n", "\n", "self", ".", "r_delta", "=", "data", "[", "'range_delta'", "]", ".", "item", "(", ")", "\n", "self", ".", "theta_delta", "=", "data", "[", "'theta_delta'", "]", ".", "item", "(", ")", "\n", "self", ".", "n_r", "=", "data", "[", "'Nrange'", "]", ".", "item", "(", ")", "\n", "self", ".", "n_theta", "=", "data", "[", "'Ntheta'", "]", ".", "item", "(", ")", "\n", "\n", "# Permute column and rows so that covariances are for [r, doppler, theta] (instead of [r, theta, doppler]", "\n", "self", ".", "y", "=", "self", ".", "y", "[", ":", ",", "[", "0", ",", "2", ",", "1", "]", "]", "[", ":", ",", ":", ",", "[", "0", ",", "2", ",", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.realistic_radar_model.realistic_meas_model.RealisticMeasModel.compute_covariance": [[23, 38], ["numpy.clip", "numpy.clip", "numpy.zeros", "numpy.round", "numpy.round"], "methods", ["None"], ["", "def", "compute_covariance", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Looks up the closest covariance matrix to the point `x` given.\n        @param x: `ndarray` of shape [N, 2], specifying (range, doppler, theta) of the N points where we want to compute\n            the covariance matrices (note that the doppler part does not influence the covariances).\n        @return: `ndarray` of shape [N, 3, 3] with the covariance matrices computed for each of the N points in `x`. The\n            covariances are specified for (range, doppler, theta), in this order.\n        \"\"\"", "\n", "n_points", "=", "x", ".", "shape", "[", "0", "]", "\n", "if", "n_points", "==", "0", ":", "\n", "            ", "return", "np", ".", "zeros", "(", "(", "0", ",", "3", ",", "3", ")", ")", "\n", "", "i_r", "=", "np", ".", "clip", "(", "np", ".", "round", "(", "(", "x", "[", ":", ",", "0", "]", "-", "self", ".", "min_r", ")", "/", "self", ".", "r_delta", ")", ",", "0", ",", "self", ".", "n_r", "-", "1", ")", "\n", "i_theta", "=", "np", ".", "clip", "(", "np", ".", "round", "(", "(", "x", "[", ":", ",", "2", "]", "-", "self", ".", "min_theta", ")", "/", "self", ".", "theta_delta", ")", ",", "0", ",", "self", ".", "n_theta", "-", "1", ")", "\n", "idx", "=", "(", "i_r", "*", "self", ".", "n_theta", "+", "i_theta", ")", ".", "astype", "(", "int", ")", "\n", "return", "self", ".", "y", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.output_truth_plot_extended_objects": [[11, 74], ["torch.no_grad", "labels[].cpu().numpy", "tuple", "output_state[].cpu().detach().numpy", "output_logits[].cpu().sigmoid().detach().numpy().flatten", "numpy.zeros", "numpy.array", "ax.scatter", "range", "sorted", "numpy.abs().argmin", "plotting.output_truth_plot_extended_objects.f"], "function", ["None"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "output_truth_plot_extended_objects", "(", "ax", ",", "output", ",", "labels", ",", "matched_idx", ",", "batch", ",", "training_example_to_plot", "=", "0", ")", ":", "\n", "    ", "output_state", "=", "output", "[", "'state'", "]", "\n", "output_logits", "=", "output", "[", "'logits'", "]", "\n", "bs", ",", "num_queries", "=", "output_state", ".", "shape", "[", ":", "2", "]", "\n", "\n", "truth", "=", "labels", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "indicies", "=", "tuple", "(", "[", "t", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "for", "t", "in", "matched_idx", "[", "training_example_to_plot", "]", "]", ")", "\n", "out", "=", "output_state", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "out_prob", "=", "output_logits", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "sigmoid", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "\n", "# Plot measurements, alpha-coded by time", "\n", "# TODO: take into account possible non-zero params.general.n_prediction_lag", "\n", "measurements", "=", "batch", ".", "tensors", "[", "training_example_to_plot", "]", "[", "~", "batch", ".", "mask", "[", "training_example_to_plot", "]", "]", "\n", "colors", "=", "np", ".", "zeros", "(", "(", "measurements", ".", "shape", "[", "0", "]", ",", "4", ")", ")", "\n", "unique_time_values", "=", "np", ".", "array", "(", "sorted", "(", "list", "(", "set", "(", "measurements", "[", ":", ",", "2", "]", ".", "tolist", "(", ")", ")", ")", ")", ")", "\n", "def", "f", "(", "t", ")", ":", "\n", "        ", "\"\"\"Exponential decay for alpha in time\"\"\"", "\n", "idx", "=", "(", "np", ".", "abs", "(", "unique_time_values", "-", "t", ")", ")", ".", "argmin", "(", ")", "\n", "return", "1", "/", "1.5", "**", "(", "len", "(", "unique_time_values", ")", "-", "idx", ")", "\n", "", "colors", "[", ":", ",", "3", "]", "=", "[", "f", "(", "t", ")", "for", "t", "in", "measurements", "[", ":", ",", "2", "]", ".", "tolist", "(", ")", "]", "\n", "ax", ".", "scatter", "(", "measurements", "[", ":", ",", "0", "]", ".", "cpu", "(", ")", ",", "measurements", "[", ":", ",", "1", "]", ".", "cpu", "(", ")", ",", "marker", "=", "'x'", ",", "c", "=", "colors", ",", "zorder", "=", "np", ".", "inf", ",", "s", "=", "2", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "out", ")", ")", ":", "\n", "# Rotation matrix", "\n", "        ", "P", "=", "np", ".", "zeros", "(", "(", "2", ",", "2", ")", ")", "\n", "P", "[", "0", ",", "0", "]", "=", "np", ".", "cos", "(", "out", "[", "i", ",", "-", "1", "]", ")", "\n", "P", "[", "0", ",", "1", "]", "=", "-", "np", ".", "sin", "(", "out", "[", "i", ",", "-", "1", "]", ")", "\n", "P", "[", "1", ",", "0", "]", "=", "np", ".", "sin", "(", "out", "[", "i", ",", "-", "1", "]", ")", "\n", "P", "[", "1", ",", "1", "]", "=", "np", ".", "cos", "(", "out", "[", "i", ",", "-", "1", "]", ")", "\n", "# Ellipse axes", "\n", "L", "=", "np", ".", "zeros", "(", "(", "2", ",", "2", ")", ")", "\n", "L", "[", "0", ",", "0", "]", "=", "out", "[", "i", ",", "2", "]", "\n", "L", "[", "1", ",", "1", "]", "=", "out", "[", "i", ",", "3", "]", "\n", "# Predicted ellipse", "\n", "out_cov", "=", "P", "@", "L", "@", "P", ".", "T", "\n", "\n", "a", "=", "np", ".", "linspace", "(", "0", ",", "2", "*", "np", ".", "pi", ")", "\n", "alpha", "=", "np", ".", "array", "(", "[", "np", ".", "cos", "(", "a", ")", ",", "np", ".", "sin", "(", "a", ")", "]", ")", "\n", "rotated", "=", "out_cov", "@", "alpha", "\n", "out_ellipse", "=", "rotated", "+", "out", "[", "i", ",", ":", "2", "]", ".", "reshape", "(", "2", ",", "1", ")", "\n", "\n", "\n", "if", "i", "in", "indicies", "[", "0", "]", ":", "\n", "            ", "tmp_idx", "=", "np", ".", "where", "(", "indicies", "[", "training_example_to_plot", "]", "==", "i", ")", "[", "0", "]", "[", "0", "]", "\n", "truth_idx", "=", "indicies", "[", "1", "]", "[", "tmp_idx", "]", "\n", "\n", "p", "=", "ax", ".", "plot", "(", "out_ellipse", "[", "0", ",", ":", "]", ",", "out_ellipse", "[", "1", ",", ":", "]", ",", "label", "=", "'Matched Predicted Object'", ")", "\n", "truth_pos", "=", "truth", "[", "truth_idx", ",", ":", "2", "]", ".", "reshape", "(", "2", ",", "1", ")", "\n", "truth_cov", "=", "truth", "[", "truth_idx", ",", "2", ":", "]", ".", "reshape", "(", "2", ",", "2", ")", "\n", "rotated", "=", "truth_cov", "@", "alpha", "\n", "truth_ellipse", "=", "rotated", "+", "truth_pos", "\n", "ax", ".", "plot", "(", "truth_ellipse", "[", "0", ",", ":", "]", ",", "truth_ellipse", "[", "1", ",", ":", "]", ",", "color", "=", "p", "[", "0", "]", ".", "get_color", "(", ")", ",", "label", "=", "'Matched Predicted Object'", ")", "\n", "", "else", ":", "\n", "            ", "p", "=", "ax", ".", "plot", "(", "out_ellipse", "[", "0", ",", ":", "]", ",", "out_ellipse", "[", "1", ",", ":", "]", ",", "color", "=", "'k'", ",", "label", "=", "'Unmatched Predicted Object'", ")", "\n", "\n", "", "label", "=", "\"{:.2f}\"", ".", "format", "(", "out_prob", "[", "i", "]", ")", "\n", "ax", ".", "annotate", "(", "label", ",", "# this is the text", "\n", "(", "out", "[", "i", ",", "0", "]", ",", "out", "[", "i", ",", "1", "]", ")", ",", "# this is the point to label", "\n", "textcoords", "=", "\"offset points\"", ",", "# how to position the text", "\n", "xytext", "=", "(", "0", ",", "10", ")", ",", "# distance from text to points (x,y)", "\n", "ha", "=", "'center'", ",", "\n", "color", "=", "p", "[", "0", "]", ".", "get_color", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.output_truth_plot": [[76, 163], ["torch.no_grad", "hasattr", "hasattr", "labels[].cpu().numpy", "tuple", "prediction.logits[].cpu().sigmoid().detach().numpy().flatten", "hasattr", "numpy.zeros", "numpy.array", "measurements.cpu", "ax.scatter", "range", "hasattr", "NotImplementedError", "prediction.positions[].cpu().detach().numpy", "prediction.uncertainties[].cpu().detach().numpy", "sorted", "numpy.abs().argmin", "plotting.output_truth_plot_extended_objects.f"], "function", ["None"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "output_truth_plot", "(", "ax", ",", "prediction", ",", "labels", ",", "matched_idx", ",", "batch", ",", "params", ",", "training_example_to_plot", "=", "0", ")", ":", "\n", "\n", "    ", "assert", "hasattr", "(", "prediction", ",", "'positions'", ")", ",", "'Positions should have been predicted for plotting.'", "\n", "assert", "hasattr", "(", "prediction", ",", "'logits'", ")", ",", "'Logits should have been predicted for plotting.'", "\n", "if", "params", ".", "data_generation", ".", "prediction_target", "==", "'position_and_velocity'", ":", "\n", "        ", "assert", "hasattr", "(", "prediction", ",", "'velocities'", ")", ",", "'Velocities should have been predicted for plotting.'", "\n", "\n", "", "bs", ",", "num_queries", "=", "prediction", ".", "positions", ".", "shape", "[", ":", "2", "]", "\n", "assert", "training_example_to_plot", "<=", "bs", ",", "\"'training_example_to_plot' should be less than batch_size\"", "\n", "\n", "if", "params", ".", "data_generation", ".", "prediction_target", "==", "'position_and_shape'", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Plotting not working yet for shape predictions.'", ")", "\n", "\n", "# Get ground-truth, predicted state, and logits for chosen training example", "\n", "", "truth", "=", "labels", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "indices", "=", "tuple", "(", "[", "t", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "for", "t", "in", "matched_idx", "[", "training_example_to_plot", "]", "]", ")", "\n", "if", "params", ".", "data_generation", ".", "prediction_target", "==", "'position'", ":", "\n", "        ", "out", "=", "prediction", ".", "positions", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "", "elif", "params", ".", "data_generation", ".", "prediction_target", "==", "'position_and_velocity'", ":", "\n", "        ", "pos", "=", "prediction", ".", "positions", "[", "training_example_to_plot", "]", "\n", "vel", "=", "prediction", ".", "velocities", "[", "training_example_to_plot", "]", "\n", "out", "=", "torch", ".", "cat", "(", "(", "pos", ",", "vel", ")", ",", "dim", "=", "1", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "", "out_prob", "=", "prediction", ".", "logits", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "sigmoid", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "\n", "# Optionally get uncertainties for chosen training example", "\n", "if", "hasattr", "(", "prediction", ",", "'uncertainties'", ")", ":", "\n", "        ", "uncertainties", "=", "prediction", ".", "uncertainties", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "        ", "uncertainties", "=", "None", "\n", "\n", "# Plot xy position of measurements, alpha-coded by time", "\n", "", "measurements", "=", "batch", ".", "tensors", "[", "training_example_to_plot", "]", "[", "~", "batch", ".", "mask", "[", "training_example_to_plot", "]", "]", "\n", "colors", "=", "np", ".", "zeros", "(", "(", "measurements", ".", "shape", "[", "0", "]", ",", "4", ")", ")", "\n", "unique_time_values", "=", "np", ".", "array", "(", "sorted", "(", "list", "(", "set", "(", "measurements", "[", ":", ",", "3", "]", ".", "tolist", "(", ")", ")", ")", ")", ")", "\n", "def", "f", "(", "t", ")", ":", "\n", "        ", "\"\"\"Exponential decay for alpha in time\"\"\"", "\n", "idx", "=", "(", "np", ".", "abs", "(", "unique_time_values", "-", "t", ")", ")", ".", "argmin", "(", ")", "\n", "return", "1", "/", "1.2", "**", "(", "len", "(", "unique_time_values", ")", "-", "idx", ")", "\n", "", "colors", "[", ":", ",", "3", "]", "=", "[", "f", "(", "t", ")", "for", "t", "in", "measurements", "[", ":", ",", "3", "]", ".", "tolist", "(", ")", "]", "\n", "measurements_cpu", "=", "measurements", ".", "cpu", "(", ")", "\n", "ax", ".", "scatter", "(", "measurements_cpu", "[", ":", ",", "0", "]", "*", "np", ".", "cos", "(", "measurements_cpu", "[", ":", ",", "2", "]", ")", ",", "\n", "measurements_cpu", "[", ":", ",", "0", "]", "*", "np", ".", "sin", "(", "measurements_cpu", "[", ":", ",", "2", "]", ")", ",", "\n", "marker", "=", "'x'", ",", "c", "=", "colors", ",", "zorder", "=", "np", ".", "inf", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "out", ")", ")", ":", "\n", "        ", "if", "i", "in", "indices", "[", "0", "]", ":", "\n", "            ", "tmp_idx", "=", "np", ".", "where", "(", "indices", "[", "training_example_to_plot", "]", "==", "i", ")", "[", "0", "]", "[", "0", "]", "\n", "truth_idx", "=", "indices", "[", "1", "]", "[", "tmp_idx", "]", "\n", "\n", "# Plot predicted positions", "\n", "p", "=", "ax", ".", "plot", "(", "out", "[", "i", ",", "0", "]", ",", "out", "[", "i", ",", "1", "]", ",", "marker", "=", "'o'", ",", "label", "=", "'Matched Predicted Object'", ",", "markersize", "=", "5", ")", "\n", "color", "=", "p", "[", "0", "]", ".", "get_color", "(", ")", "\n", "\n", "# Plot ground-truth", "\n", "truth_to_plot", "=", "truth", "[", "truth_idx", "]", "\n", "ax", ".", "plot", "(", "truth_to_plot", "[", "0", "]", ",", "truth_to_plot", "[", "1", "]", ",", "marker", "=", "'D'", ",", "color", "=", "color", ",", "label", "=", "'Matched Predicted Object'", ",", "markersize", "=", "5", ")", "\n", "\n", "# Plot velocity", "\n", "if", "params", ".", "data_generation", ".", "prediction_target", "==", "'position_and_velocity'", ":", "\n", "                ", "ax", ".", "arrow", "(", "out", "[", "i", ",", "0", "]", ",", "out", "[", "i", ",", "1", "]", ",", "out", "[", "i", ",", "2", "]", ",", "out", "[", "i", ",", "3", "]", ",", "color", "=", "color", ",", "head_width", "=", "0.2", ",", "linestyle", "=", "'--'", ",", "\n", "length_includes_head", "=", "True", ")", "\n", "ax", ".", "arrow", "(", "truth_to_plot", "[", "0", "]", ",", "truth_to_plot", "[", "1", "]", ",", "truth_to_plot", "[", "2", "]", ",", "truth_to_plot", "[", "3", "]", ",", "color", "=", "p", "[", "0", "]", ".", "get_color", "(", ")", ",", "\n", "head_width", "=", "0.2", ",", "length_includes_head", "=", "True", ")", "\n", "\n", "# Plot uncertainties (2-sigma ellipse)", "\n", "", "if", "uncertainties", "is", "not", "None", ":", "\n", "                ", "ell_position", "=", "Ellipse", "(", "xy", "=", "(", "out", "[", "i", ",", "0", "]", ",", "out", "[", "i", ",", "1", "]", ")", ",", "width", "=", "uncertainties", "[", "i", ",", "0", "]", "*", "4", ",", "height", "=", "uncertainties", "[", "i", ",", "1", "]", "*", "4", ",", "\n", "color", "=", "color", ",", "alpha", "=", "0.4", ")", "\n", "ell_velocity", "=", "Ellipse", "(", "xy", "=", "(", "out", "[", "i", ",", "0", "]", "+", "out", "[", "i", ",", "2", "]", ",", "out", "[", "i", ",", "1", "]", "+", "out", "[", "i", ",", "3", "]", ")", ",", "width", "=", "uncertainties", "[", "i", ",", "2", "]", "*", "4", ",", "\n", "height", "=", "uncertainties", "[", "i", ",", "3", "]", "*", "4", ",", "edgecolor", "=", "color", ",", "linestyle", "=", "'--'", ",", "facecolor", "=", "'none'", ")", "\n", "ax", ".", "add_patch", "(", "ell_position", ")", "\n", "ax", ".", "add_patch", "(", "ell_velocity", ")", "\n", "", "", "else", ":", "\n", "# Plot missed predictions", "\n", "            ", "p", "=", "ax", ".", "plot", "(", "out", "[", "i", ",", "0", "]", ",", "out", "[", "i", ",", "1", "]", ",", "marker", "=", "'*'", ",", "color", "=", "'k'", ",", "label", "=", "'Unmatched Predicted Object'", ",", "markersize", "=", "5", ")", "\n", "if", "params", ".", "data_generation", ".", "prediction_target", "==", "'position_and_velocity'", ":", "\n", "                ", "ax", ".", "arrow", "(", "out", "[", "i", ",", "0", "]", ",", "out", "[", "i", ",", "1", "]", ",", "out", "[", "i", ",", "2", "]", ",", "out", "[", "i", ",", "3", "]", ",", "color", "=", "'k'", ",", "head_width", "=", "0.2", ",", "linestyle", "=", "'--'", ",", "\n", "length_includes_head", "=", "True", ")", "\n", "\n", "", "", "label", "=", "\"{:.2f}\"", ".", "format", "(", "out_prob", "[", "i", "]", ")", "\n", "ax", ".", "annotate", "(", "label", ",", "# this is the text", "\n", "(", "out", "[", "i", ",", "0", "]", ",", "out", "[", "i", ",", "1", "]", ")", ",", "# this is the point to label", "\n", "textcoords", "=", "\"offset points\"", ",", "# how to position the text", "\n", "xytext", "=", "(", "0", ",", "10", ")", ",", "# distance from text to points (x,y)", "\n", "ha", "=", "'center'", ",", "\n", "color", "=", "p", "[", "0", "]", ".", "get_color", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.output_truth_plot_for_fusion_paper": [[165, 204], ["torch.no_grad", "labels[].cpu().numpy", "output_state[].cpu().detach().numpy", "output_logits[].cpu().sigmoid().detach().numpy().flatten", "range", "ax.scatter", "numpy.zeros", "numpy.array", "ax.scatter", "numpy.zeros", "numpy.array", "ax.scatter", "len", "sorted", "numpy.abs().argmin", "plotting.output_truth_plot_extended_objects.f"], "function", ["None"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "output_truth_plot_for_fusion_paper", "(", "ax", ",", "output", ",", "labels", ",", "batch", ",", "unique_idxs", ",", "params", ",", "training_example_to_plot", "=", "0", ")", ":", "\n", "    ", "assert", "'state'", "in", "output", ",", "\"'state' should be in dict\"", "\n", "assert", "'logits'", "in", "output", ",", "\"'logits' should be in dict\"", "\n", "\n", "output_state", "=", "output", "[", "'state'", "]", "\n", "output_logits", "=", "output", "[", "'logits'", "]", "\n", "bs", ",", "num_queries", "=", "output_state", ".", "shape", "[", ":", "2", "]", "\n", "assert", "training_example_to_plot", "<=", "bs", ",", "\"'training_example_to_plot' should be less than batch_size\"", "\n", "\n", "truth", "=", "labels", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "out", "=", "output_state", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "out_prob", "=", "output_logits", "[", "training_example_to_plot", "]", ".", "cpu", "(", ")", ".", "sigmoid", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "\n", "# Plot MT3 predictions", "\n", "for", "i", "in", "range", "(", "len", "(", "out", ")", ")", ":", "\n", "        ", "if", "out_prob", "[", "i", "]", ">=", "params", ".", "loss", ".", "existence_prob_cutoff", ":", "\n", "            ", "p", "=", "ax", ".", "scatter", "(", "out", "[", "i", ",", "0", "]", ",", "out", "[", "i", ",", "1", "]", ",", "marker", "=", "'+'", ",", "s", "=", "200", ",", "c", "=", "'b'", ")", "\n", "\n", "# Plot ground-truth", "\n", "", "", "ax", ".", "scatter", "(", "truth", "[", ":", ",", "0", "]", ",", "truth", "[", ":", ",", "1", "]", ",", "marker", "=", "'o'", ",", "s", "=", "25", ",", "c", "=", "'r'", ",", "zorder", "=", "np", ".", "inf", ")", "\n", "\n", "# Plot measurements, alpha-coded by time", "\n", "measurements", "=", "batch", ".", "tensors", "[", "training_example_to_plot", "]", "[", "unique_idxs", "[", "training_example_to_plot", "]", "!=", "-", "1", "]", "\n", "colors", "=", "np", ".", "zeros", "(", "(", "measurements", ".", "shape", "[", "0", "]", ",", "4", ")", ")", "\n", "unique_time_values", "=", "np", ".", "array", "(", "sorted", "(", "list", "(", "set", "(", "measurements", "[", ":", ",", "2", "]", ".", "tolist", "(", ")", ")", ")", ")", ")", "\n", "def", "f", "(", "t", ")", ":", "\n", "        ", "\"\"\"Exponential decay for alpha in time\"\"\"", "\n", "idx", "=", "(", "np", ".", "abs", "(", "unique_time_values", "-", "t", ")", ")", ".", "argmin", "(", ")", "\n", "return", "1", "/", "1.1", "**", "(", "len", "(", "unique_time_values", ")", "-", "idx", ")", "\n", "", "colors", "[", ":", ",", "3", "]", "=", "[", "f", "(", "t", ")", "for", "t", "in", "measurements", "[", ":", ",", "2", "]", ".", "tolist", "(", ")", "]", "\n", "ax", ".", "scatter", "(", "measurements", "[", ":", ",", "0", "]", ".", "cpu", "(", ")", ",", "measurements", "[", ":", ",", "1", "]", ".", "cpu", "(", ")", ",", "marker", "=", "'x'", ",", "c", "=", "colors", ",", "zorder", "=", "-", "np", ".", "inf", ")", "\n", "\n", "# Plot false measurements, alpha-coded by time", "\n", "measurements", "=", "batch", ".", "tensors", "[", "training_example_to_plot", "]", "[", "unique_idxs", "[", "training_example_to_plot", "]", "==", "-", "1", "]", "\n", "colors", "=", "np", ".", "zeros", "(", "(", "measurements", ".", "shape", "[", "0", "]", ",", "4", ")", ")", "\n", "unique_time_values", "=", "np", ".", "array", "(", "sorted", "(", "list", "(", "set", "(", "measurements", "[", ":", ",", "2", "]", ".", "tolist", "(", ")", ")", ")", ")", ")", "\n", "colors", "[", ":", ",", "3", "]", "=", "[", "f", "(", "t", ")", "for", "t", "in", "measurements", "[", ":", ",", "2", "]", ".", "tolist", "(", ")", "]", "\n", "ax", ".", "scatter", "(", "measurements", "[", ":", ",", "0", "]", ".", "cpu", "(", ")", ",", "measurements", "[", ":", ",", "1", "]", ".", "cpu", "(", ")", ",", "marker", "=", "'.'", ",", "c", "=", "colors", ",", "zorder", "=", "-", "np", ".", "inf", ",", "s", "=", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.contrastive_classifications_plot": [[206, 236], ["torch.no_grad", "[].int().tolist", "numpy.random.choice", "int", "set", "list", "classifications[].exp().detach", "ax.bar", "numpy.min", "numpy.argmin().item", "map", "range", "object_ids[].numpy", "[].int", "classifications[].exp", "classifications[].exp().detach.numpy", "numpy.argmin", "len"], "function", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "contrastive_classifications_plot", "(", "ax", ",", "batch", ",", "object_ids", ",", "contrastive_classifications", ")", ":", "\n", "\n", "    ", "measurements", "=", "batch", ".", "tensors", "[", "0", "]", "\n", "n_measurements", "=", "measurements", ".", "shape", "[", "0", "]", "\n", "classifications", "=", "contrastive_classifications", "[", "0", "]", "\n", "is_there_pads", "=", "np", ".", "min", "(", "object_ids", "[", "0", "]", ".", "numpy", "(", ")", ")", "==", "-", "2", "\n", "if", "is_there_pads", ":", "\n", "        ", "n_measurements_to_use", "=", "np", ".", "argmin", "(", "object_ids", "[", "0", "]", ")", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "        ", "n_measurements_to_use", "=", "n_measurements", "\n", "", "object_ids", "=", "object_ids", "[", "0", "]", "[", ":", "n_measurements_to_use", "]", ".", "int", "(", ")", ".", "tolist", "(", ")", "\n", "\n", "# Choose random measurement (not including padding measurements)", "\n", "chosen_measurement_idx", "=", "np", ".", "random", ".", "choice", "(", "n_measurements_to_use", ")", "\n", "chosen_object_id", "=", "int", "(", "object_ids", "[", "chosen_measurement_idx", "]", ")", "\n", "\n", "# Assign a different color (if possible) to each of the objects in the scene, but the chosen object is always blue", "\n", "# and false measurements always red", "\n", "available_colors", "=", "[", "'tab:orange'", ",", "'tab:green'", ",", "'tab:purple'", ",", "'tab:brown'", ",", "'tab:pink'", ",", "'tab:gray'", ",", "'tab:olive'", ",", "\n", "'tab:cyan'", ",", "'sandybrown'", ",", "'goldenrod'", ",", "'lime'", ",", "'cyan'", "]", "\n", "unique_ids", "=", "set", "(", "object_ids", ")", "\n", "color_dict", "=", "{", "i", ":", "available_colors", "[", "i", "%", "len", "(", "available_colors", ")", "]", "for", "i", "in", "unique_ids", "if", "i", "not", "in", "[", "chosen_object_id", ",", "-", "1", "]", "}", "\n", "color_dict", "[", "chosen_object_id", "]", "=", "'tab:blue'", "\n", "color_dict", "[", "-", "1", "]", "=", "'tab:red'", "\n", "bar_colors", "=", "list", "(", "map", "(", "color_dict", ".", "get", ",", "object_ids", ")", ")", "\n", "\n", "# Plot color-coded predicted pmf for the chosen measurement", "\n", "chosen_classifications", "=", "classifications", "[", "chosen_measurement_idx", "]", ".", "exp", "(", ")", ".", "detach", "(", ")", "\n", "ax", ".", "bar", "(", "range", "(", "n_measurements_to_use", ")", ",", "chosen_classifications", ".", "numpy", "(", ")", "[", ":", "n_measurements_to_use", "]", ",", "color", "=", "bar_colors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.compute_avg_certainty": [[238, 262], ["torch.no_grad", "zip", "plotting._get_src_permutation_idx", "torch.zeros_like().bool", "matched_certainties.extend", "unmatched_certainties.extend", "len", "numpy.quantile", "len", "numpy.quantile", "tuple", "tuple", "output_logits[].sigmoid().cpu().tolist", "output_logits[].sigmoid().cpu().tolist", "torch.zeros_like", "output_logits[].sigmoid().cpu", "output_logits[].sigmoid().cpu", "output_logits[].sigmoid", "output_logits[].sigmoid"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting._get_src_permutation_idx", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.extend", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.extend"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "compute_avg_certainty", "(", "outputs_history", ",", "matched_idx_history", ")", ":", "\n", "    ", "matched_certainties", "=", "[", "]", "\n", "unmatched_certainties", "=", "[", "]", "\n", "for", "outputs", ",", "matched_idx", "in", "zip", "(", "outputs_history", ",", "matched_idx_history", ")", ":", "\n", "        ", "idx", "=", "_get_src_permutation_idx", "(", "matched_idx", ")", "\n", "output_logits", "=", "outputs", "[", "'logits'", "]", "\n", "\n", "mask", "=", "torch", ".", "zeros_like", "(", "output_logits", ")", ".", "bool", "(", ")", "\n", "mask", "[", "idx", "]", "=", "True", "\n", "matched_certainties", ".", "extend", "(", "output_logits", "[", "mask", "]", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", "\n", "unmatched_certainties", ".", "extend", "(", "output_logits", "[", "~", "mask", "]", ".", "sigmoid", "(", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "", "if", "len", "(", "matched_certainties", ")", ">", "0", ":", "\n", "        ", "matched_quants", "=", "np", ".", "quantile", "(", "matched_certainties", ",", "[", "0.0", ",", "0.25", ",", "0.5", ",", "0.75", ",", "1.0", "]", ")", "\n", "", "else", ":", "\n", "        ", "matched_quants", "=", "[", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", "]", "\n", "\n", "", "if", "len", "(", "unmatched_certainties", ")", ">", "0", ":", "\n", "        ", "unmatched_quants", "=", "np", ".", "quantile", "(", "unmatched_certainties", ",", "[", "0.0", ",", "0.25", ",", "0.5", ",", "0.75", ",", "1.0", "]", ")", "\n", "", "else", ":", "\n", "        ", "unmatched_quants", "=", "[", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", "]", "\n", "\n", "", "return", "tuple", "(", "matched_quants", ")", ",", "tuple", "(", "unmatched_quants", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting._get_src_permutation_idx": [[264, 270], ["torch.cat", "torch.cat", "torch.full_like", "enumerate"], "function", ["None"], ["", "def", "_get_src_permutation_idx", "(", "indices", ")", ":", "\n", "# permute predictions following indices", "\n", "    ", "batch_idx", "=", "torch", ".", "cat", "(", "[", "torch", ".", "full_like", "(", "src", ",", "i", ")", "\n", "for", "i", ",", "(", "src", ",", "_", ")", "in", "enumerate", "(", "indices", ")", "]", ")", "\n", "src_idx", "=", "torch", ".", "cat", "(", "[", "src", "for", "(", "src", ",", "_", ")", "in", "indices", "]", ")", "\n", "return", "batch_idx", ",", "src_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.get_constrastive_ax": [[272, 279], ["matplotlib.subplots", "ax.grid", "ax.plot", "ax.set_ylabel"], "function", ["None"], ["", "def", "get_constrastive_ax", "(", ")", ":", "\n", "    ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "grid", "(", "'on'", ")", "\n", "line", ",", "=", "ax", ".", "plot", "(", "[", "1", "]", ",", "'r'", ",", "label", "=", "'Contrastive loss'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Contrastive loss'", ")", "\n", "\n", "return", "fig", ",", "ax", ",", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.get_state_uncertainties_ax": [[280, 290], ["matplotlib.subplots", "ax.grid", "ax.plot", "ax.plot", "ax.plot", "ax.plot", "ax.set_ylabel"], "function", ["None"], ["", "def", "get_state_uncertainties_ax", "(", ")", ":", "\n", "    ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "grid", "(", "'on'", ")", "\n", "line_x", ",", "=", "ax", ".", "plot", "(", "[", "1", "]", ",", "'r'", ",", "label", "=", "'x'", ",", "c", "=", "'C0'", ")", "\n", "line_y", ",", "=", "ax", ".", "plot", "(", "[", "1", "]", ",", "'r'", ",", "label", "=", "'y'", ",", "c", "=", "'C1'", ")", "\n", "line_vx", ",", "=", "ax", ".", "plot", "(", "[", "1", "]", ",", "'r'", ",", "label", "=", "'v_x'", ",", "c", "=", "'C2'", ")", "\n", "line_vy", ",", "=", "ax", ".", "plot", "(", "[", "1", "]", ",", "'r'", ",", "label", "=", "'v_y'", ",", "c", "=", "'C3'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Average standard deviation of predictions'", ")", "\n", "\n", "return", "fig", ",", "ax", ",", "(", "line_x", ",", "line_y", ",", "line_vx", ",", "line_vy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.get_false_ax": [[291, 298], ["matplotlib.subplots", "ax.grid", "ax.plot", "ax.set_ylabel"], "function", ["None"], ["", "def", "get_false_ax", "(", ")", ":", "\n", "    ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "grid", "(", "'on'", ")", "\n", "line", ",", "=", "ax", ".", "plot", "(", "[", "1", "]", ",", "'r'", ",", "label", "=", "'False loss'", ")", "\n", "ax", ".", "set_ylabel", "(", "'False loss'", ")", "\n", "\n", "return", "fig", ",", "ax", ",", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.get_total_loss_ax": [[299, 307], ["matplotlib.subplots", "ax.grid", "ax.plot", "ax.set_ylabel", "ax.set_yscale"], "function", ["None"], ["", "def", "get_total_loss_ax", "(", ")", ":", "\n", "    ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "grid", "(", "'on'", ")", "\n", "line", ",", "=", "ax", ".", "plot", "(", "[", "1", "]", ",", "'r'", ",", "label", "=", "'Total loss'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Total loss'", ")", "\n", "ax", ".", "set_yscale", "(", "'log'", ")", "\n", "\n", "return", "fig", ",", "ax", ",", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.get_new_ax": [[309, 318], ["matplotlib.subplots", "ax.grid", "ax.plot", "ax.set_ylabel", "ax.set_yscale"], "function", ["None"], ["", "def", "get_new_ax", "(", "log", "=", "False", ",", "ylabel", "=", "'Loss'", ")", ":", "\n", "    ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "grid", "(", "'on'", ")", "\n", "line", ",", "=", "ax", ".", "plot", "(", "[", "1", "]", ",", "'r'", ",", "label", "=", "'Loss'", ")", "\n", "ax", ".", "set_ylabel", "(", "ylabel", ")", "\n", "if", "log", ":", "\n", "        ", "ax", ".", "set_yscale", "(", "'log'", ")", "\n", "\n", "", "return", "fig", ",", "ax", ",", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.draw_error_ellipse": [[320, 334], ["numpy.linalg.eig", "scipy.stats.chi2.ppf", "numpy.rad2deg", "matplotlib.patches.Ellipse", "ax.add_artist", "numpy.argmax", "numpy.argmin", "numpy.arctan2", "numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["", "def", "draw_error_ellipse", "(", "ax", ",", "mu", ",", "cov", ",", "p", "=", "0.9", ",", "facecolor", "=", "'C0'", ",", "edgecolor", "=", "None", ",", "linestyle", "=", "'-'", ",", "alpha", "=", "0.5", ")", ":", "\n", "    ", "assert", "cov", ".", "shape", "==", "(", "2", ",", "2", ")", ",", "'This code only works for 2D covariance matrices'", "\n", "\n", "w", ",", "v", "=", "np", ".", "linalg", ".", "eig", "(", "cov", ")", "\n", "idx_max_eig", ",", "idx_min_eig", "=", "np", ".", "argmax", "(", "w", ")", ",", "np", ".", "argmin", "(", "w", ")", "\n", "max_eig_vec", "=", "v", "[", ":", ",", "idx_max_eig", "]", "\n", "confidence_level_multiplier", "=", "chi2", ".", "ppf", "(", "p", ",", "2", ")", "\n", "\n", "theta", "=", "np", ".", "rad2deg", "(", "np", ".", "arctan2", "(", "max_eig_vec", "[", "1", "]", ",", "max_eig_vec", "[", "0", "]", ")", ")", "\n", "width", "=", "2", "*", "np", ".", "sqrt", "(", "confidence_level_multiplier", "*", "w", "[", "idx_max_eig", "]", ")", "\n", "height", "=", "2", "*", "np", ".", "sqrt", "(", "confidence_level_multiplier", "*", "w", "[", "idx_min_eig", "]", ")", "\n", "\n", "ellipse", "=", "Ellipse", "(", "mu", ",", "width", ",", "height", ",", "theta", ",", "facecolor", "=", "facecolor", ",", "edgecolor", "=", "edgecolor", ",", "linestyle", "=", "linestyle", ",", "alpha", "=", "alpha", ")", "\n", "ax", ".", "add_artist", "(", "ellipse", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plotting.plot_polar_sectors_with_values": [[336, 367], ["matplotlib.get_cmap", "matplotlib.Normalize", "matplotlib.ScalarMappable", "range", "ax.autoscale_view", "ax.set_thetamin", "ax.set_thetamax", "ax.bar().remove", "ax.set_xticks", "ax.set_yticks", "ax.set_theta_zero_location", "matplotlib.subplots", "values.min", "values.max", "range", "len", "matplotlib.Rectangle", "ax.add_patch", "ax.bar", "len", "ax.text", "cmx.ScalarMappable.to_rgba"], "function", ["None"], ["", "def", "plot_polar_sectors_with_values", "(", "grid_r", ",", "grid_theta", ",", "values", ",", "ax", "=", "None", ",", "vmin", "=", "None", ",", "vmax", "=", "None", ")", ":", "\n", "    ", "if", "ax", "is", "None", ":", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "nrows", "=", "1", ",", "figsize", "=", "(", "14", ",", "10", ")", ",", "subplot_kw", "=", "{", "'projection'", ":", "'polar'", "}", ")", "\n", "\n", "", "vmin", "=", "values", ".", "min", "(", ")", "if", "vmin", "is", "None", "else", "vmin", "\n", "vmax", "=", "values", ".", "max", "(", ")", "if", "vmax", "is", "None", "else", "vmax", "\n", "plasma", "=", "plt", ".", "get_cmap", "(", "'plasma'", ")", "\n", "cNorm", "=", "colors", ".", "Normalize", "(", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ")", "\n", "scalarMap", "=", "cmx", ".", "ScalarMappable", "(", "norm", "=", "cNorm", ",", "cmap", "=", "plasma", ")", "\n", "delta_r", "=", "grid_r", "[", "1", "]", "-", "grid_r", "[", "0", "]", "\n", "delta_theta", "=", "grid_theta", "[", "1", "]", "-", "grid_theta", "[", "0", "]", "\n", "\n", "for", "i_r", "in", "range", "(", "len", "(", "grid_r", ")", "-", "1", ")", ":", "\n", "        ", "for", "i_theta", "in", "range", "(", "len", "(", "grid_theta", ")", "-", "1", ")", ":", "\n", "            ", "sector", "=", "[", "grid_r", "[", "i_r", "]", ",", "grid_r", "[", "i_r", "+", "1", "]", ",", "grid_theta", "[", "i_theta", "]", ",", "grid_theta", "[", "i_theta", "+", "1", "]", "]", "\n", "rect", "=", "patches", ".", "Rectangle", "(", "(", "sector", "[", "2", "]", ",", "sector", "[", "0", "]", ")", ",", "\n", "grid_theta", "[", "1", "]", "-", "grid_theta", "[", "0", "]", ",", "\n", "grid_r", "[", "1", "]", "-", "grid_r", "[", "0", "]", ",", "\n", "linewidth", "=", "1", ",", "\n", "facecolor", "=", "scalarMap", ".", "to_rgba", "(", "values", "[", "i_r", ",", "i_theta", "]", ")", ",", "\n", "edgecolor", "=", "'none'", ")", "\n", "ax", ".", "add_patch", "(", "rect", ")", "\n", "if", "i_r", "!=", "0", ":", "\n", "                ", "ax", ".", "text", "(", "sector", "[", "2", "]", "+", "delta_theta", "/", "2", ",", "sector", "[", "0", "]", "+", "delta_r", "/", "2", ",", "f\"{values[i_r, i_theta]:.2f}\"", ",", "horizontalalignment", "=", "'center'", ",", "verticalalignment", "=", "'center'", ")", "\n", "", "", "", "ax", ".", "autoscale_view", "(", ")", "\n", "ax", ".", "set_thetamin", "(", "-", "90", ")", "\n", "ax", ".", "set_thetamax", "(", "90", ")", "\n", "ax", ".", "bar", "(", "0", ",", "1", ")", ".", "remove", "(", ")", "\n", "ax", ".", "set_xticks", "(", "grid_theta", ")", "\n", "ax", ".", "set_yticks", "(", "grid_r", ")", "\n", "ax", ".", "set_theta_zero_location", "(", "'N'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.pmb_utils.UnnormalizedGaussianMixture.__init__": [[81, 84], ["torch.distributions.multivariate_normal.MultivariateNormal"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "weights", ",", "means", ",", "covs", ")", ":", "\n", "        ", "self", ".", "weights", "=", "weights", "\n", "self", ".", "components", "=", "MultivariateNormal", "(", "means", ",", "covs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.pmb_utils.UnnormalizedGaussianMixture.log_prob": [[85, 88], ["pmb_utils.UnnormalizedGaussianMixture.components.log_prob", "torch.logsumexp().item", "torch.logsumexp", "pmb_utils.UnnormalizedGaussianMixture.weights.log"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.pmb_utils.UnnormalizedGaussianMixture.log_prob"], ["", "def", "log_prob", "(", "self", ",", "x", ")", ":", "\n", "        ", "log_probs_for_each_component", "=", "self", ".", "components", ".", "log_prob", "(", "x", ")", "\n", "return", "torch", ".", "logsumexp", "(", "log_probs_for_each_component", "+", "self", ".", "weights", ".", "log", "(", ")", ",", "0", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.pmb_utils.UnnormalizedGaussianMixture.get_lambda": [[89, 91], ["pmb_utils.UnnormalizedGaussianMixture.weights.sum().item", "pmb_utils.UnnormalizedGaussianMixture.weights.sum"], "methods", ["None"], ["", "def", "get_lambda", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "weights", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.pmb_utils.compute_nll_for_pmb": [[9, 78], ["len", "len", "range", "range", "scipy.optimize.linear_sum_assignment", "util.misc.AnnotatedValueSum", "util.misc.AnnotatedValueSum.add", "zip", "range", "util.misc.AnnotatedValueSum.get_total_value", "sum", "sum", "sum", "sum", "len", "predictions[].sqrt", "numpy.ones", "[].item", "distribution_type", "range", "util.misc.AnnotatedValue", "util.misc.AnnotatedValueSum.get_filtered_values", "util.misc.AnnotatedValueSum.get_filtered_values", "util.misc.AnnotatedValueSum.get_filtered_values", "util.misc.AnnotatedValueSum.get_filtered_values", "[].item", "util.misc.AnnotatedValueSum.add", "util.misc.AnnotatedValueSum.add", "util.misc.AnnotatedValueSum.add", "[].item", "util.misc.AnnotatedValueSum.add", "range", "numpy.log", "util.misc.AnnotatedValue", "util.misc.AnnotatedValue", "util.misc.AnnotatedValue", "util.misc.AnnotatedValue", "len", "numpy.log", "numpy.log", "x.get", "x.get", "x.get", "x.get", "numpy.log", "distribution_type.log_prob().sum", "numpy.log", "numpy.log", "distribution_type.log_prob"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.add", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.get_total_value", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.get_filtered_values", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.get_filtered_values", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.get_filtered_values", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.get_filtered_values", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.add", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.add", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.add", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.add", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.pmb_utils.UnnormalizedGaussianMixture.log_prob"], ["def", "compute_nll_for_pmb", "(", "predictions", ",", "targets", ",", "target_infos", "=", "None", ")", ":", "\n", "    ", "if", "target_infos", "is", "None", ":", "\n", "        ", "dummy_ids", "=", "[", "0", "for", "_", "in", "range", "(", "len", "(", "targets", ")", ")", "]", "\n", "dummy_trajectories", "=", "[", "[", "[", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", "]", "]", "]", "\n", "target_infos", "=", "[", "dummy_ids", ",", "dummy_trajectories", "]", "\n", "", "target_ids", ",", "all_trajectories", "=", "target_infos", "\n", "\n", "n_predictions", "=", "len", "(", "predictions", "[", "'means'", "]", ")", "\n", "n_targets", "=", "len", "(", "targets", ")", "\n", "\n", "if", "len", "(", "predictions", "[", "'covs'", "]", ".", "shape", ")", "==", "3", ":", "\n", "        ", "distribution_type", "=", "MultivariateNormal", "\n", "scale_params", "=", "predictions", "[", "'covs'", "]", "\n", "", "else", ":", "\n", "        ", "distribution_type", "=", "Normal", "\n", "scale_params", "=", "predictions", "[", "'covs'", "]", ".", "sqrt", "(", ")", "\n", "\n", "", "cost_matrix", "=", "np", ".", "ones", "(", "(", "n_predictions", "+", "n_targets", ",", "n_targets", ")", ")", "*", "np", ".", "inf", "\n", "for", "i_prediction", "in", "range", "(", "n_predictions", ")", ":", "\n", "        ", "p_existence", "=", "predictions", "[", "'p_exs'", "]", "[", "i_prediction", "]", ".", "item", "(", ")", "\n", "dist", "=", "distribution_type", "(", "predictions", "[", "'means'", "]", "[", "i_prediction", "]", ",", "scale_params", "[", "i_prediction", "]", ")", "\n", "for", "i_target", "in", "range", "(", "n_targets", ")", ":", "\n", "            ", "cost_matrix", "[", "i_prediction", ",", "i_target", "]", "=", "-", "(", "np", ".", "log", "(", "p_existence", ")", "+", "dist", ".", "log_prob", "(", "targets", "[", "i_target", "]", ")", ".", "sum", "(", ")", "-", "np", ".", "log", "(", "1", "-", "p_existence", ")", ")", "\n", "\n", "# Fill in diagonal of sub-matrix corresponding to PPP matches", "\n", "", "", "for", "i_target", "in", "range", "(", "n_targets", ")", ":", "\n", "        ", "cost_matrix", "[", "n_predictions", "+", "i_target", ",", "i_target", "]", "=", "-", "predictions", "[", "'ppp_log_prob_func'", "]", "(", "targets", "[", "i_target", "]", ")", "\n", "\n", "# Find optimal match using Hungarian algorithm", "\n", "", "optimal_match", "=", "linear_sum_assignment", "(", "cost_matrix", ")", "\n", "\n", "# Compute likelihood and decompositions", "\n", "annotated_cost", "=", "AnnotatedValueSum", "(", ")", "\n", "annotated_cost", ".", "add", "(", "AnnotatedValue", "(", "predictions", "[", "'ppp_lambda'", "]", ",", "{", "'type'", ":", "'miss'", "}", ")", ")", "\n", "for", "i_prediction", ",", "i_target", "in", "zip", "(", "optimal_match", "[", "0", "]", ",", "optimal_match", "[", "1", "]", ")", ":", "\n", "        ", "birth_time_annotation", "=", "all_trajectories", "[", "target_ids", "[", "i_target", "]", "]", "[", "0", "]", "[", "4", "]", "\n", "# For targets matched with predictions, add cost for localization and existence probability", "\n", "if", "i_prediction", "<", "n_predictions", ":", "\n", "            ", "p_existence", "=", "predictions", "[", "'p_exs'", "]", "[", "i_prediction", "]", ".", "item", "(", ")", "\n", "temp", "=", "-", "np", ".", "log", "(", "p_existence", ")", "+", "np", ".", "log", "(", "1", "-", "p_existence", ")", "\n", "annotated_cost", ".", "add", "(", "AnnotatedValue", "(", "cost_matrix", "[", "i_prediction", ",", "i_target", "]", "-", "temp", ",", "\n", "{", "'type'", ":", "'loc'", ",", "\n", "'target_state'", ":", "targets", "[", "i_target", "]", ",", "\n", "'target_birth_time'", ":", "birth_time_annotation", "}", ")", ")", "\n", "annotated_cost", ".", "add", "(", "AnnotatedValue", "(", "-", "np", ".", "log", "(", "p_existence", ")", ",", "\n", "{", "'type'", ":", "'p_true'", ",", "\n", "'target_state'", ":", "targets", "[", "i_target", "]", ",", "\n", "'target_birth_time'", ":", "birth_time_annotation", "}", ")", ")", "\n", "\n", "# For targets matched with PPP, just add cost for explaining missed targets", "\n", "", "else", ":", "\n", "            ", "annotated_cost", ".", "add", "(", "AnnotatedValue", "(", "cost_matrix", "[", "i_prediction", ",", "i_target", "]", ",", "\n", "{", "'type'", ":", "'miss'", ",", "\n", "'target_state'", ":", "targets", "[", "i_target", "]", ",", "\n", "'target_birth_time'", ":", "birth_time_annotation", "}", ")", ")", "\n", "# Afterwards, add -log(1-p) for all predictions false predictions.", "\n", "", "", "for", "i_prediction", "in", "range", "(", "n_predictions", ")", ":", "\n", "        ", "if", "i_prediction", "not", "in", "optimal_match", "[", "0", "]", ":", "\n", "            ", "p_existence", "=", "predictions", "[", "'p_exs'", "]", "[", "i_prediction", "]", ".", "item", "(", ")", "\n", "annotated_cost", ".", "add", "(", "AnnotatedValue", "(", "-", "np", ".", "log", "(", "1", "-", "p_existence", ")", ",", "\n", "{", "'type'", ":", "'p_false'", ",", "'pred_state'", ":", "predictions", "[", "'means'", "]", "[", "i_prediction", "]", "}", ")", ")", "\n", "\n", "", "", "negative_log_likelihood", "=", "annotated_cost", ".", "get_total_value", "(", ")", "\n", "loc_cost", "=", "sum", "(", "annotated_cost", ".", "get_filtered_values", "(", "lambda", "x", ":", "x", ".", "get", "(", "'type'", ")", "==", "'loc'", ")", ")", "\n", "p_true_cost", "=", "sum", "(", "annotated_cost", ".", "get_filtered_values", "(", "lambda", "x", ":", "x", ".", "get", "(", "'type'", ")", "==", "'p_true'", ")", ")", "\n", "p_false_cost", "=", "sum", "(", "annotated_cost", ".", "get_filtered_values", "(", "lambda", "x", ":", "x", ".", "get", "(", "'type'", ")", "==", "'p_false'", ")", ")", "\n", "p_miss_cost", "=", "sum", "(", "annotated_cost", ".", "get_filtered_values", "(", "lambda", "x", ":", "x", ".", "get", "(", "'type'", ")", "==", "'miss'", ")", ")", "\n", "\n", "return", "negative_log_likelihood", ",", "(", "loc_cost", ",", "p_true_cost", ",", "p_false_cost", ",", "p_miss_cost", ")", ",", "optimal_match", ",", "annotated_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.plot_results.load": [[10, 12], ["util.logger.load_data"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.load_data"], ["def", "load", "(", "path", ")", ":", "\n", "    ", "return", "load_data", "(", "f'{path}'", ",", "'metrics/last_layer_losses'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.FileAndStream.__init__": [[8, 11], ["open"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "filename", ",", "stream", ")", ":", "\n", "        ", "self", ".", "terminal", "=", "stream", "\n", "self", ".", "logfile", "=", "open", "(", "filename", ",", "'w'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.FileAndStream.write": [[12, 15], ["logger.FileAndStream.terminal.write", "logger.FileAndStream.logfile.write"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.FileAndStream.write", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.FileAndStream.write"], ["", "def", "write", "(", "self", ",", "message", ")", ":", "\n", "        ", "self", ".", "terminal", ".", "write", "(", "message", ")", "\n", "self", ".", "logfile", ".", "write", "(", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.FileAndStream.flush": [[16, 20], ["logger.FileAndStream.logfile.flush", "logger.FileAndStream.terminal.flush"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.FileAndStream.flush", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.FileAndStream.flush"], ["", "def", "flush", "(", "self", ")", ":", "\n", "# Needed for Python 3 compatibility", "\n", "        ", "self", ".", "logfile", ".", "flush", "(", ")", "\n", "self", ".", "terminal", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.Logger.__init__": [[24, 51], ["os.path.isdir", "os.makedirs", "logger.FileAndStream", "logger.FileAndStream"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "log_path", ",", "save_output", "=", "True", ",", "buffer_size", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Constructor for the Logger class.\n\n        Args:\n            log_path:    Desired location for saving the experiment. If this location already exists, Logger will\n                         append an ' (i)' to the end of this path, where i is the first integer greater than 1 that\n                         makes this path be new.\n            save_output: If True everything printed to the console will be saved in the files out.log and out_err.log.\n        \"\"\"", "\n", "# Append a number to the end of the desired path if that path already exists", "\n", "new_log_path", "=", "log_path", "\n", "i", "=", "2", "\n", "while", "os", ".", "path", ".", "isdir", "(", "new_log_path", ")", ":", "\n", "            ", "new_log_path", "=", "log_path", "+", "' ({})'", ".", "format", "(", "i", ")", "\n", "i", "+=", "1", "\n", "\n", "", "self", ".", "log_path", "=", "new_log_path", "\n", "os", ".", "makedirs", "(", "new_log_path", ")", "\n", "\n", "# If desired, save all output to log files", "\n", "if", "save_output", ":", "\n", "            ", "sys", ".", "stdout", "=", "FileAndStream", "(", "self", ".", "log_path", "+", "'/out.log'", ",", "sys", ".", "stdout", ")", "\n", "sys", ".", "stderr", "=", "FileAndStream", "(", "self", ".", "log_path", "+", "'/out_err.log'", ",", "sys", ".", "stderr", ")", "\n", "\n", "", "self", ".", "buffer_size", "=", "buffer_size", "\n", "self", ".", "buffer", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.Logger.log_scalar": [[52, 80], ["os.makedirs", "os.path.dirname", "open", "f.write"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.FileAndStream.write"], ["", "def", "log_scalar", "(", "self", ",", "name", ",", "value", ",", "t", ",", "flush_now", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Logs the given value into the file self.log_path/name.txt\n\n        Args:\n            name:  Name that will be logged.\n            value: Value to be logged.\n            t:     Time (or batch number, or optimization step) when this value was obtained. Usually used as the x-axis\n                   when later plotting the logged value.\n        \"\"\"", "\n", "# If variable already in buffer, append to it", "\n", "if", "name", "in", "self", ".", "buffer", ":", "\n", "            ", "self", ".", "buffer", "[", "name", "]", "[", "'n'", "]", "+=", "1", "\n", "self", ".", "buffer", "[", "name", "]", "[", "'data'", "]", "+=", "f'{t}: {value}\\n'", "\n", "\n", "# If not, create it", "\n", "", "else", ":", "\n", "            ", "self", ".", "buffer", "[", "name", "]", "=", "{", "'n'", ":", "1", ",", "'data'", ":", "f'{t}: {value}\\n'", "}", "\n", "\n", "# If buffer full, write all the data at once", "\n", "", "if", "(", "self", ".", "buffer", "[", "name", "]", "[", "'n'", "]", ">=", "self", ".", "buffer_size", ")", "or", "flush_now", ":", "\n", "            ", "filename", "=", "self", ".", "log_path", "+", "'/'", "+", "name", "+", "'.txt'", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "filename", ")", ",", "exist_ok", "=", "True", ")", "\n", "with", "open", "(", "filename", ",", "'a'", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "self", ".", "buffer", "[", "name", "]", "[", "'data'", "]", ")", "\n", "\n", "# Empty the buffer for that variable", "\n", "", "del", "self", ".", "buffer", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.Logger.save_code_dependencies": [[81, 121], ["sys.modules.values", "os.path.realpath", "hasattr", "shutil.copyfile", "filename.replace", "os.path.exists", "os.makedirs", "destination.rfind"], "methods", ["None"], ["", "", "def", "save_code_dependencies", "(", "self", ",", "project_root_path", "=", "None", ",", "additional_paths", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Copies the files of all imported modules present inside the folder `project_root_path` to the log directory, in\n        order to guarantee reproducibility of the experiment.\n\n        For most use cases, this method should be called when you're sure that all the modules you care about have\n        already been imported by your script, so that all of them are copied to the log directory.\n\n        Args:\n            project_root_path: Folder that contains the modules that should be copied if imported.\n            additional_paths: List of additional folders from which imported files should be copied.\n        \"\"\"", "\n", "\n", "# If project_root_path is not specified, assume it to be the path of the script being run", "\n", "if", "project_root_path", "is", "None", ":", "\n", "            ", "project_root_path", "=", "os", ".", "path", ".", "realpath", "(", "sys", ".", "path", "[", "0", "]", ")", "\n", "\n", "", "if", "additional_paths", "is", "None", ":", "\n", "            ", "additional_paths", "=", "[", "]", "\n", "\n", "# Iterate over all imported modules", "\n", "", "modules", "=", "sys", ".", "modules", ".", "values", "(", ")", "\n", "for", "module", "in", "modules", ":", "\n", "            ", "if", "hasattr", "(", "module", ",", "'__file__'", ")", ":", "\n", "                ", "filename", "=", "module", ".", "__file__", "\n", "if", "filename", "is", "not", "None", ":", "\n", "# Check if imported module is inside any of the additional_paths", "\n", "                    ", "file_in_additional_paths", "=", "False", "\n", "for", "p", "in", "additional_paths", ":", "\n", "                        ", "if", "p", "in", "filename", ":", "\n", "                            ", "file_in_additional_paths", "=", "True", "\n", "\n", "# Save the current file if it is inside the project root folder, if it is the name of the script", "\n", "# being run, or if it is inside any of the folders specified in additional_paths", "\n", "", "", "if", "project_root_path", "in", "filename", "or", "filename", "==", "sys", ".", "argv", "[", "0", "]", "or", "file_in_additional_paths", ":", "\n", "                        ", "destination", "=", "self", ".", "log_path", "+", "'/code_used/'", "+", "filename", ".", "replace", "(", "project_root_path", ",", "''", ")", "\n", "destination_folder", "=", "destination", "[", ":", "destination", ".", "rfind", "(", "'/'", ")", "]", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "destination_folder", ")", ":", "\n", "                            ", "os", ".", "makedirs", "(", "destination_folder", ")", "\n", "", "shutil", ".", "copyfile", "(", "filename", ",", "destination", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.Logger.__del__": [[122, 129], ["logger.Logger.buffer.items", "os.makedirs", "os.path.dirname", "open", "f.write"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.FileAndStream.write"], ["", "", "", "", "", "def", "__del__", "(", "self", ")", ":", "\n", "# Write all the remaining data in the buffer", "\n", "        ", "for", "name", ",", "data", "in", "self", ".", "buffer", ".", "items", "(", ")", ":", "\n", "            ", "filename", "=", "self", ".", "log_path", "+", "'/'", "+", "name", "+", "'.txt'", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "filename", ")", ",", "exist_ok", "=", "True", ")", "\n", "with", "open", "(", "filename", ",", "'a'", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "self", ".", "buffer", "[", "name", "]", "[", "'data'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.logger.load_data": [[131, 163], ["open", "line.split", "xs.append", "ys.append", "float", "float", "os.path.isdir", "NotADirectoryError", "os.path.isfile", "FileNotFoundError"], "function", ["None"], ["", "", "", "", "def", "load_data", "(", "log_folder", ",", "var_name", ")", ":", "\n", "    ", "\"\"\"\n    Function used to load data saved by Logger.log_scalar\n\n    Args:\n        log_folder: Name of the log folder where Logger saved the variable.\n        var_name: Name of the variable that should be loaded.\n\n    Returns:\n        xs: list of all the x-values loaded.\n        ys: list of all the y-values loaded.\n    \"\"\"", "\n", "log_folder", "=", "f'{log_folder}'", "\n", "filename", "=", "f'{var_name}.txt'", "\n", "\n", "# Safe open, with helpful error messages", "\n", "try", ":", "\n", "        ", "f", "=", "open", "(", "f'{log_folder}/{filename}'", ",", "'r'", ")", "\n", "", "except", "FileNotFoundError", "as", "fne", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isdir", "(", "log_folder", ")", ":", "\n", "            ", "raise", "NotADirectoryError", "(", "f'Could not find directory {log_folder}'", ")", "\n", "", "elif", "not", "os", ".", "path", ".", "isfile", "(", "filename", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "f'Could not find file {filename} inside {log_folder}'", ")", "\n", "", "else", ":", "\n", "            ", "raise", "fne", "\n", "\n", "", "", "xs", ",", "ys", "=", "[", "]", ",", "[", "]", "\n", "for", "line", "in", "f", ":", "\n", "        ", "l", "=", "line", ".", "split", "(", "':'", ")", "\n", "xs", ".", "append", "(", "float", "(", "l", "[", "0", "]", ")", ")", "\n", "ys", ".", "append", "(", "float", "(", "l", "[", "1", "]", ")", ")", "\n", "", "return", "[", "xs", ",", "ys", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.load_config_files.dotdict.recursive_update": [[26, 58], ["load_config_files.dotdict._recursive_update"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.load_config_files.dotdict._recursive_update"], ["def", "recursive_update", "(", "self", ",", "u", ")", ":", "\n", "        ", "\"\"\"\n        Recursive version of update() for dicts. If u has entries in common with self, overwrite. If an entry is a dict,\n        go inside each key and call update() again.\n\n        Example:\n            v:   {\n                  'a': 2,\n                  'b': {\n                          'x': 1,\n                          'y': 2\n                       }\n                 }\n            u: {\n                  'c': 10,\n                  'b': {\n                          'x': 30,\n                          'z': 40\n                       }\n                }\n            after calling v.recursive_update(u):\n            v:  {\n                    'a': 2,\n                    'c': 10,\n                    'b': {\n                            'x': 30,\n                            'y': 2,\n                            'z': 40\n                         }\n                }\n        \"\"\"", "\n", "return", "dotdict", ".", "_recursive_update", "(", "self", ",", "u", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.load_config_files.dotdict._recursive_update": [[59, 70], ["u.items", "isinstance", "isinstance", "load_config_files.dotdict", "load_config_files.dotdict._recursive_update", "d.get"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.load_config_files.dotdict._recursive_update"], ["", "@", "staticmethod", "\n", "def", "_recursive_update", "(", "d", ",", "u", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "u", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "collections", ".", "abc", ".", "Mapping", ")", ":", "\n", "                ", "d", "[", "k", "]", "=", "dotdict", ".", "_recursive_update", "(", "d", ".", "get", "(", "k", ",", "{", "}", ")", ",", "v", ")", "\n", "", "else", ":", "\n", "                ", "d", "[", "k", "]", "=", "v", "\n", "", "", "if", "isinstance", "(", "d", ",", "dict", ")", ":", "\n", "            ", "return", "dotdict", "(", "d", ")", "\n", "", "else", ":", "\n", "            ", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.load_config_files.load_yaml_into_dotdict": [[6, 18], ["os.path.exists", "print", "exit", "open", "yaml.safe_load", "load_config_files.convert_to_dot_dict", "print", "exit"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.load_config_files.convert_to_dot_dict"], ["def", "load_yaml_into_dotdict", "(", "filepath", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "exists", "(", "filepath", ")", ":", "\n", "        ", "with", "open", "(", "filepath", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "try", ":", "\n", "                ", "params", "=", "yaml", ".", "safe_load", "(", "f", ")", "\n", "return", "convert_to_dot_dict", "(", "params", ")", "\n", "", "except", "yaml", ".", "YAMLError", "as", "exc", ":", "\n", "                ", "print", "(", "f\"Error loading yaml file. Error: {exc}\"", ")", "\n", "exit", "(", ")", "\n", "", "", "", "else", ":", "\n", "        ", "print", "(", "f\"Filepath specified does not exist. Make sure '{filepath}' is correct.\"", ")", "\n", "exit", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.load_config_files.convert_to_dot_dict": [[72, 77], ["load_config_files.dotdict", "isinstance", "load_config_files.convert_to_dot_dict"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.load_config_files.convert_to_dot_dict"], ["", "", "", "def", "convert_to_dot_dict", "(", "regular_dict", ")", ":", "\n", "    ", "for", "key", "in", "regular_dict", ":", "\n", "        ", "if", "isinstance", "(", "regular_dict", "[", "key", "]", ",", "dict", ")", ":", "\n", "            ", "regular_dict", "[", "key", "]", "=", "convert_to_dot_dict", "(", "regular_dict", "[", "key", "]", ")", "\n", "", "", "return", "dotdict", "(", "regular_dict", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.__init__": [[13, 16], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "tensors", ",", "mask", ":", "Optional", "[", "Tensor", "]", ")", ":", "\n", "        ", "self", ".", "tensors", "=", "tensors", "\n", "self", ".", "mask", "=", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to": [[17, 27], ["misc.NestedTensor.tensors.to", "misc.NestedTensor", "mask.to"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "# type: (Device) -> NestedTensor # noqa", "\n", "        ", "cast_tensor", "=", "self", ".", "tensors", ".", "to", "(", "device", ")", "\n", "mask", "=", "self", ".", "mask", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "assert", "mask", "is", "not", "None", "\n", "cast_mask", "=", "mask", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "            ", "cast_mask", "=", "None", "\n", "", "return", "NestedTensor", "(", "cast_tensor", ",", "cast_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.decompose": [[28, 30], ["None"], "methods", ["None"], ["", "def", "decompose", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tensors", ",", "self", ".", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.NestedTensor.__repr__": [[31, 33], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "tensors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.Prediction.__init__": [[196, 209], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "positions", "=", "None", ",", "velocities", "=", "None", ",", "shapes", "=", "None", ",", "logits", "=", "None", ",", "uncertainties", "=", "None", ")", ":", "\n", "        ", "if", "positions", "is", "not", "None", ":", "\n", "            ", "self", ".", "positions", "=", "positions", "\n", "", "if", "velocities", "is", "not", "None", ":", "\n", "            ", "self", ".", "velocities", "=", "velocities", "\n", "", "if", "shapes", "is", "not", "None", ":", "\n", "            ", "self", ".", "shapes", "=", "shapes", "\n", "", "if", "logits", "is", "not", "None", ":", "\n", "            ", "self", ".", "logits", "=", "logits", "\n", "", "if", "uncertainties", "is", "not", "None", ":", "\n", "            ", "self", ".", "uncertainties", "=", "uncertainties", "\n", "\n", "", "self", ".", "_states", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.Prediction.states": [[210, 218], ["torch.cat", "NotImplementedError"], "methods", ["None"], ["", "@", "property", "\n", "def", "states", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "positions", "is", "not", "None", "and", "self", ".", "velocities", "is", "not", "None", ":", "\n", "            ", "return", "torch", ".", "cat", "(", "(", "self", ".", "positions", ",", "self", ".", "velocities", ")", ",", "dim", "=", "2", ")", "\n", "", "elif", "self", ".", "positions", "is", "not", "None", "and", "self", ".", "velocities", "is", "None", ":", "\n", "            ", "return", "self", ".", "positions", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f'`states` attribute not implemented for positions {self.positions} and '", "\n", "f'velocities {self.velocities}.'", ")", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValue.__init__": [[222, 225], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "value", ",", "annotation", ")", ":", "\n", "        ", "self", ".", "value", "=", "value", "\n", "self", ".", "annotation", "=", "annotation", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.__init__": [[228, 234], ["misc.AnnotatedValueSum.values.append", "misc.AnnotatedValueSum.annotations.append"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "*", "annotated_values", ")", ":", "\n", "        ", "self", ".", "values", "=", "[", "]", "\n", "self", ".", "annotations", "=", "[", "]", "\n", "for", "annotated_value", "in", "annotated_values", ":", "\n", "            ", "self", ".", "values", ".", "append", "(", "annotated_value", ".", "value", ")", "\n", "self", ".", "annotations", ".", "append", "(", "annotated_value", ".", "annotation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.get_total_value": [[235, 237], ["sum"], "methods", ["None"], ["", "", "def", "get_total_value", "(", "self", ")", ":", "\n", "        ", "return", "sum", "(", "self", ".", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.get_filtered_values": [[238, 244], ["zip", "filter_condition", "values.append"], "methods", ["None"], ["", "def", "get_filtered_values", "(", "self", ",", "filter_condition", ")", ":", "\n", "        ", "values", "=", "[", "]", "\n", "for", "value", ",", "annotation", "in", "zip", "(", "self", ".", "values", ",", "self", ".", "annotations", ")", ":", "\n", "            ", "if", "filter_condition", "(", "annotation", ")", ":", "\n", "                ", "values", ".", "append", "(", "value", ")", "\n", "", "", "return", "values", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.add": [[245, 248], ["misc.AnnotatedValueSum.values.append", "misc.AnnotatedValueSum.annotations.append"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "annotated_value", ":", "AnnotatedValue", ")", ":", "\n", "        ", "self", ".", "values", ".", "append", "(", "annotated_value", ".", "value", ")", "\n", "self", ".", "annotations", ".", "append", "(", "annotated_value", ".", "annotation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.extend": [[249, 252], ["misc.AnnotatedValueSum.values.extend", "misc.AnnotatedValueSum.annotations.extend"], "methods", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.extend", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.AnnotatedValueSum.extend"], ["", "def", "extend", "(", "self", ",", "other", ")", ":", "\n", "        ", "self", ".", "values", ".", "extend", "(", "other", ".", "values", ")", "\n", "self", ".", "annotations", ".", "extend", "(", "other", ".", "annotations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc._max_by_axis": [[35, 42], ["enumerate", "max"], "function", ["None"], ["", "", "def", "_max_by_axis", "(", "the_list", ")", ":", "\n", "# type: (List[List[int]]) -> List[int]", "\n", "    ", "maxes", "=", "the_list", "[", "0", "]", "\n", "for", "sublist", "in", "the_list", "[", "1", ":", "]", ":", "\n", "        ", "for", "index", ",", "item", "in", "enumerate", "(", "sublist", ")", ":", "\n", "            ", "maxes", "[", "index", "]", "=", "max", "(", "maxes", "[", "index", "]", ",", "item", ")", "\n", "", "", "return", "maxes", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.nested_tensor_from_tensor_list": [[44, 63], ["misc.NestedTensor", "misc._max_by_axis", "torch.zeros", "torch.ones", "zip", "ValueError", "pad_meas[].copy_", "list", "len"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc._max_by_axis"], ["", "def", "nested_tensor_from_tensor_list", "(", "tensor_list", ":", "List", "[", "Tensor", "]", ")", ":", "\n", "# TODO make this more general", "\n", "    ", "if", "tensor_list", "[", "0", "]", ".", "ndim", "==", "3", ":", "\n", "# TODO make it support different-sized images", "\n", "        ", "max_size", "=", "_max_by_axis", "(", "[", "list", "(", "meas", ".", "shape", ")", "for", "meas", "in", "tensor_list", "]", ")", "\n", "# min_size = tuple(min(s) for s in zip(*[img.shape for img in tensor_list]))", "\n", "batch_shape", "=", "[", "len", "(", "tensor_list", ")", "]", "+", "max_size", "\n", "b", ",", "c", ",", "h", ",", "w", "=", "batch_shape", "\n", "dtype", "=", "tensor_list", "[", "0", "]", ".", "dtype", "\n", "device", "=", "tensor_list", "[", "0", "]", ".", "device", "\n", "tensor", "=", "torch", ".", "zeros", "(", "batch_shape", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "mask", "=", "torch", ".", "ones", "(", "(", "b", ",", "h", ",", "w", ")", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "for", "meas", ",", "pad_meas", ",", "m", "in", "zip", "(", "tensor_list", ",", "tensor", ",", "mask", ")", ":", "\n", "            ", "pad_meas", "[", ":", "meas", ".", "shape", "[", "0", "]", ",", ":", "meas", ".", "shape", "[", "1", "]", ",", "\n", ":", "meas", ".", "shape", "[", "2", "]", "]", ".", "copy_", "(", "meas", ")", "\n", "m", "[", ":", "meas", ".", "shape", "[", "1", "]", ",", ":", "meas", ".", "shape", "[", "2", "]", "]", "=", "False", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'not supported'", ")", "\n", "", "return", "NestedTensor", "(", "tensor", ",", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.save_checkpoint": [[65, 74], ["print", "torch.save", "os.path.isdir", "os.makedirs", "os.path.join", "model.state_dict", "optimizer.state_dict", "scheduler.state_dict"], "function", ["None"], ["", "def", "save_checkpoint", "(", "folder", ",", "filename", ",", "model", ",", "optimizer", ",", "scheduler", ")", ":", "\n", "    ", "print", "(", "f\"[INFO] Saving checkpoint in {folder}/{filename}\"", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "folder", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "folder", ")", "\n", "", "torch", ".", "save", "(", "{", "\n", "'model_state_dict'", ":", "model", ".", "state_dict", "(", ")", ",", "\n", "'optimizer_state_dict'", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'scheduler_state_dict'", ":", "scheduler", ".", "state_dict", "(", ")", "\n", "}", ",", "os", ".", "path", ".", "join", "(", "folder", ",", "filename", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.update_logs": [[75, 81], ["logs[].append"], "function", ["None"], ["", "def", "update_logs", "(", "logs", ",", "key", ",", "value", ")", ":", "\n", "    ", "if", "not", "key", "in", "logs", ":", "\n", "        ", "logs", "[", "key", "]", "=", "[", "value", "]", "\n", "", "else", ":", "\n", "        ", "logs", "[", "key", "]", ".", "append", "(", "value", ")", "\n", "", "return", "logs", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.factor_int": [[82, 97], ["math.ceil", "math.sqrt", "int", "float"], "function", ["None"], ["", "def", "factor_int", "(", "n", ")", ":", "\n", "    ", "\"\"\"\n    Given an integer n, compute a factorization into two integers such that they're close as possible to each other (like\n    a square root). E.g. factor_int(16)=(4,4), but factor_int(15)=(3,5).\n    \"\"\"", "\n", "nsqrt", "=", "math", ".", "ceil", "(", "math", ".", "sqrt", "(", "n", ")", ")", "\n", "solution", "=", "False", "\n", "val", "=", "nsqrt", "\n", "while", "not", "solution", ":", "\n", "        ", "val2", "=", "int", "(", "n", "/", "val", ")", "\n", "if", "val2", "*", "val", "==", "float", "(", "n", ")", ":", "\n", "            ", "solution", "=", "True", "\n", "", "else", ":", "\n", "            ", "val", "-=", "1", "\n", "", "", "return", "val", ",", "val2", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.inverse_sigmoid": [[99, 104], ["x.clamp.clamp", "x.clamp.clamp", "torch.log"], "function", ["None"], ["", "def", "inverse_sigmoid", "(", "x", ",", "eps", "=", "1e-5", ")", ":", "\n", "    ", "x", "=", "x", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "1", ")", "\n", "x1", "=", "x", ".", "clamp", "(", "min", "=", "eps", ")", "\n", "x2", "=", "(", "1", "-", "x", ")", ".", "clamp", "(", "min", "=", "eps", ")", "\n", "return", "torch", ".", "log", "(", "x1", "/", "x2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.split_batch": [[106, 139], ["torch.no_grad", "range", "misc.pad_and_nest", "misc.pad_and_nest", "torch.logical_and", "torch.logical_and", "first_batch.append", "first_ids.append", "second_batch.append", "second_ids.append"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.pad_and_nest", "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.pad_and_nest"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "split_batch", "(", "batch", ",", "unique_ids", ",", "params", ")", ":", "\n", "    ", "bs", "=", "batch", ".", "tensors", ".", "shape", "[", "0", "]", "\n", "batch", "=", "batch", ".", "tensors", "\n", "first_batch", "=", "[", "]", "\n", "first_ids", "=", "[", "]", "\n", "second_batch", "=", "[", "]", "\n", "second_ids", "=", "[", "]", "\n", "\n", "mapped_time_idx", "=", "batch", "[", ":", ",", ":", ",", "-", "1", "]", "/", "params", ".", "data_generation", ".", "dt", "\n", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "# Take out all measurements that are in the first batch that are not padded", "\n", "        ", "first_batch_idx", "=", "mapped_time_idx", "[", "i", "]", "<", "params", ".", "data_generation", ".", "n_timesteps", "\n", "first_batch_idx", "=", "torch", ".", "logical_and", "(", "first_batch_idx", ",", "unique_ids", "[", "i", "]", "!=", "-", "2", ")", "\n", "\n", "second_batch_idx", "=", "1", "<=", "mapped_time_idx", "[", "i", "]", "\n", "second_batch_idx", "=", "torch", ".", "logical_and", "(", "second_batch_idx", ",", "unique_ids", "[", "i", "]", "!=", "-", "2", ")", "\n", "\n", "first_batch", ".", "append", "(", "batch", "[", "i", "]", "[", "first_batch_idx", "]", ")", "\n", "first_ids", ".", "append", "(", "unique_ids", "[", "i", "]", "[", "first_batch_idx", "]", ")", "\n", "\n", "second_batch", ".", "append", "(", "batch", "[", "i", "]", "[", "second_batch_idx", "]", ")", "\n", "second_ids", ".", "append", "(", "unique_ids", "[", "i", "]", "[", "second_batch_idx", "]", ")", "\n", "\n", "# Shift timestep", "\n", "second_batch", "[", "i", "]", "[", ":", ",", "-", "1", "]", "=", "second_batch", "[", "i", "]", "[", ":", ",", "-", "1", "]", "-", "params", ".", "data_generation", ".", "dt", "\n", "\n", "\n", "", "first", ",", "first_ids", "=", "pad_and_nest", "(", "first_batch", ",", "first_ids", ")", "\n", "second", ",", "second_ids", "=", "pad_and_nest", "(", "second_batch", ",", "second_ids", ")", "\n", "\n", "return", "first", ",", "second", ",", "first_ids", ",", "second_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.pad_and_nest": [[141, 147], ["max", "misc.pad_to_batch_max", "misc.NestedTensor", "list", "mask.bool", "map"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.pad_to_batch_max"], ["", "def", "pad_and_nest", "(", "batch", ",", "ids", ")", ":", "\n", "    ", "max_len", "=", "max", "(", "list", "(", "map", "(", "len", ",", "batch", ")", ")", ")", "\n", "batch", ",", "mask", ",", "ids", "=", "pad_to_batch_max", "(", "batch", ",", "ids", ",", "max_len", ")", "\n", "nested", "=", "NestedTensor", "(", "batch", ",", "mask", ".", "bool", "(", ")", ")", "\n", "\n", "return", "nested", ",", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.pad_to_batch_max": [[149, 162], ["len", "torch.zeros", "torch.ones", "enumerate", "torch.ones", "len", "len", "len"], "function", ["None"], ["", "def", "pad_to_batch_max", "(", "batch", ",", "unique_ids", ",", "max_len", ")", ":", "\n", "    ", "batch_size", "=", "len", "(", "batch", ")", "\n", "dev", "=", "batch", "[", "0", "]", ".", "device", "\n", "d_meas", "=", "batch", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "training_data_padded", "=", "torch", ".", "zeros", "(", "(", "batch_size", ",", "max_len", ",", "d_meas", ")", ",", "device", "=", "dev", ")", "\n", "mask", "=", "torch", ".", "ones", "(", "(", "batch_size", ",", "max_len", ")", ",", "device", "=", "dev", ")", "\n", "ids", "=", "-", "2", "*", "torch", ".", "ones", "(", "(", "batch_size", ",", "max_len", ")", ",", "device", "=", "dev", ")", "\n", "for", "i", ",", "ex", "in", "enumerate", "(", "batch", ")", ":", "\n", "        ", "training_data_padded", "[", "i", ",", ":", "len", "(", "ex", ")", ",", ":", "]", "=", "ex", "\n", "mask", "[", "i", ",", ":", "len", "(", "ex", ")", "]", "=", "0", "\n", "ids", "[", "i", ",", ":", "len", "(", "ex", ")", "]", "=", "unique_ids", "[", "i", "]", "\n", "\n", "", "return", "training_data_padded", ",", "mask", ",", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.extract_batch": [[164, 177], ["batch.tensors.clone().detach", "batch.mask.clone().detach", "unique_ids.clone().detach", "misc.NestedTensor", "torch.round", "torch.logical_and", "NestedTensor.tensors[].unsqueeze", "batch.mask[].unsqueeze", "batch.tensors.clone", "batch.mask.clone", "unique_ids.clone"], "function", ["None"], ["", "def", "extract_batch", "(", "batch", ",", "unique_ids", ",", "lower_time_idx", ",", "upper_time_idx", ",", "dt", ",", "batch_id", "=", "0", ")", ":", "\n", "    ", "bt", "=", "batch", ".", "tensors", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "bm", "=", "batch", ".", "mask", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "u", "=", "unique_ids", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "b", "=", "NestedTensor", "(", "bt", ",", "bm", ")", "\n", "times", "=", "torch", ".", "round", "(", "b", ".", "tensors", "[", "batch_id", ",", ":", ",", "-", "1", "]", "/", "dt", ")", "\n", "idx", "=", "torch", ".", "logical_and", "(", "lower_time_idx", "<=", "times", ",", "times", "<", "upper_time_idx", ")", "\n", "b", ".", "tensors", "=", "b", ".", "tensors", "[", "batch_id", ",", "idx", "]", ".", "unsqueeze", "(", "0", ")", "\n", "b", ".", "tensors", "[", ":", ",", ":", ",", "-", "1", "]", "=", "b", ".", "tensors", "[", ":", ",", ":", ",", "-", "1", "]", "-", "lower_time_idx", "*", "dt", "\n", "b", ".", "mask", "=", "batch", ".", "mask", "[", "batch_id", ",", "idx", "]", ".", "unsqueeze", "(", "0", ")", "\n", "u", "=", "u", "[", ":", ",", "idx", "]", "\n", "\n", "return", "b", ",", "u", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.recursive_loss_sum": [[179, 187], ["type", "loss_dict.items", "misc.recursive_loss_sum"], "function", ["home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.recursive_loss_sum"], ["", "def", "recursive_loss_sum", "(", "loss_dict", ")", ":", "\n", "    ", "loss", "=", "0", "\n", "if", "type", "(", "loss_dict", ")", "is", "not", "dict", ":", "\n", "        ", "return", "loss_dict", "\n", "", "else", ":", "\n", "        ", "for", "k", ",", "v", "in", "loss_dict", ".", "items", "(", ")", ":", "\n", "            ", "loss", "+=", "recursive_loss_sum", "(", "v", ")", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.julianolagana_mt3v2.util.misc.compute_median_absolute_deviation": [[189, 193], ["mad.item", "x.median"], "function", ["None"], ["", "def", "compute_median_absolute_deviation", "(", "x", ")", ":", "\n", "    ", "median", "=", "x", ".", "median", "(", "dim", "=", "0", ")", "[", "0", "]", "\n", "mad", "=", "(", "x", "-", "median", ")", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ")", ".", "median", "(", ")", "\n", "return", "mad", ".", "item", "(", ")", "\n", "\n"]]}