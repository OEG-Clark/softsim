{"home.repos.pwc.inspect_result.Media-Smart_vedatad.None.setup.readme": [[9, 13], ["open", "f.read"], "function", ["None"], ["def", "readme", "(", ")", ":", "\n", "    ", "with", "open", "(", "'README.md'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "        ", "content", "=", "f", ".", "read", "(", ")", "\n", "", "return", "content", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.None.setup.make_cuda_ext": [[15, 38], ["extension", "torch.cuda.is_available", "print", "EnvironmentError", "os.getenv", "os.path.join", "module.split"], "function", ["None"], ["", "def", "make_cuda_ext", "(", "name", ",", "module", ",", "sources", ",", "sources_cuda", "=", "[", "]", ")", ":", "\n", "\n", "    ", "define_macros", "=", "[", "]", "\n", "extra_compile_args", "=", "{", "'cxx'", ":", "[", "]", "}", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "or", "os", ".", "getenv", "(", "'FORCE_CUDA'", ",", "'0'", ")", "==", "'1'", ":", "\n", "        ", "define_macros", "+=", "[", "(", "'WITH_CUDA'", ",", "None", ")", "]", "\n", "extension", "=", "CUDAExtension", "\n", "extra_compile_args", "[", "'nvcc'", "]", "=", "[", "\n", "'-D__CUDA_NO_HALF_OPERATORS__'", ",", "\n", "'-D__CUDA_NO_HALF_CONVERSIONS__'", ",", "\n", "'-D__CUDA_NO_HALF2_OPERATORS__'", ",", "\n", "]", "\n", "sources", "+=", "sources_cuda", "\n", "", "else", ":", "\n", "        ", "print", "(", "f'Compiling {name} without CUDA'", ")", "\n", "raise", "EnvironmentError", "(", "'CUDA is required to compile vedatad'", ")", "\n", "\n", "", "return", "extension", "(", "\n", "name", "=", "f'{module}.{name}'", ",", "\n", "sources", "=", "[", "os", ".", "path", ".", "join", "(", "*", "module", ".", "split", "(", "'.'", ")", ",", "p", ")", "for", "p", "in", "sources", "]", ",", "\n", "define_macros", "=", "define_macros", ",", "\n", "extra_compile_args", "=", "extra_compile_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.None.setup.parse_requirements": [[40, 114], ["list", "line.strip.startswith", "exists", "setup.parse_requirements.gen_packages_items"], "function", ["None"], ["", "def", "parse_requirements", "(", "fname", "=", "'requirements.txt'", ",", "with_version", "=", "True", ")", ":", "\n", "    ", "\"\"\"Parse the package dependencies listed in a requirements file but strips\n    specific versioning information.\n\n    Args:\n        fname (str): path to requirements file\n        with_version (bool, default=False): if True include version specs\n\n    Returns:\n        List[str]: list of requirements items\n\n    CommandLine:\n        python -c \"import setup; print(setup.parse_requirements())\"\n    \"\"\"", "\n", "import", "re", "\n", "import", "sys", "\n", "from", "os", ".", "path", "import", "exists", "\n", "require_fpath", "=", "fname", "\n", "\n", "def", "parse_line", "(", "line", ")", ":", "\n", "        ", "\"\"\"Parse information from a line in a requirements text file.\"\"\"", "\n", "if", "line", ".", "startswith", "(", "'-r '", ")", ":", "\n", "# Allow specifying requirements in other files", "\n", "            ", "target", "=", "line", ".", "split", "(", "' '", ")", "[", "1", "]", "\n", "for", "info", "in", "parse_require_file", "(", "target", ")", ":", "\n", "                ", "yield", "info", "\n", "", "", "else", ":", "\n", "            ", "info", "=", "{", "'line'", ":", "line", "}", "\n", "if", "line", ".", "startswith", "(", "'-e '", ")", ":", "\n", "                ", "info", "[", "'package'", "]", "=", "line", ".", "split", "(", "'#egg='", ")", "[", "1", "]", "\n", "", "else", ":", "\n", "# Remove versioning from the package", "\n", "                ", "pat", "=", "'('", "+", "'|'", ".", "join", "(", "[", "'>='", ",", "'=='", ",", "'>'", "]", ")", "+", "')'", "\n", "parts", "=", "re", ".", "split", "(", "pat", ",", "line", ",", "maxsplit", "=", "1", ")", "\n", "parts", "=", "[", "p", ".", "strip", "(", ")", "for", "p", "in", "parts", "]", "\n", "\n", "info", "[", "'package'", "]", "=", "parts", "[", "0", "]", "\n", "if", "len", "(", "parts", ")", ">", "1", ":", "\n", "                    ", "op", ",", "rest", "=", "parts", "[", "1", ":", "]", "\n", "if", "';'", "in", "rest", ":", "\n", "# Handle platform specific dependencies", "\n", "# http://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-platform-specific-dependencies", "\n", "                        ", "version", ",", "platform_deps", "=", "map", "(", "str", ".", "strip", ",", "\n", "rest", ".", "split", "(", "';'", ")", ")", "\n", "info", "[", "'platform_deps'", "]", "=", "platform_deps", "\n", "", "else", ":", "\n", "                        ", "version", "=", "rest", "# NOQA", "\n", "", "info", "[", "'version'", "]", "=", "(", "op", ",", "version", ")", "\n", "", "", "yield", "info", "\n", "\n", "", "", "def", "parse_require_file", "(", "fpath", ")", ":", "\n", "        ", "with", "open", "(", "fpath", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "and", "not", "line", ".", "startswith", "(", "'#'", ")", ":", "\n", "                    ", "for", "info", "in", "parse_line", "(", "line", ")", ":", "\n", "                        ", "yield", "info", "\n", "\n", "", "", "", "", "", "def", "gen_packages_items", "(", ")", ":", "\n", "        ", "if", "exists", "(", "require_fpath", ")", ":", "\n", "            ", "for", "info", "in", "parse_require_file", "(", "require_fpath", ")", ":", "\n", "                ", "parts", "=", "[", "info", "[", "'package'", "]", "]", "\n", "if", "with_version", "and", "'version'", "in", "info", ":", "\n", "                    ", "parts", ".", "extend", "(", "info", "[", "'version'", "]", ")", "\n", "", "if", "not", "sys", ".", "version", ".", "startswith", "(", "'3.4'", ")", ":", "\n", "# apparently package_deps are broken in 3.4", "\n", "                    ", "platform_deps", "=", "info", ".", "get", "(", "'platform_deps'", ")", "\n", "if", "platform_deps", "is", "not", "None", ":", "\n", "                        ", "parts", ".", "append", "(", "';'", "+", "platform_deps", ")", "\n", "", "", "item", "=", "''", ".", "join", "(", "parts", ")", "\n", "yield", "item", "\n", "\n", "", "", "", "packages", "=", "list", "(", "gen_packages_items", "(", ")", ")", "\n", "return", "packages", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.__init__": [[37, 49], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "data", ",", "\n", "stack", "=", "False", ",", "\n", "padding_value", "=", "0", ",", "\n", "cpu_only", "=", "False", ",", "\n", "pad_dims", "=", "2", ")", ":", "\n", "        ", "self", ".", "_data", "=", "data", "\n", "self", ".", "_cpu_only", "=", "cpu_only", "\n", "self", ".", "_stack", "=", "stack", "\n", "self", ".", "_padding_value", "=", "padding_value", "\n", "assert", "pad_dims", "in", "[", "None", ",", "1", ",", "2", ",", "3", "]", "\n", "self", ".", "_pad_dims", "=", "pad_dims", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.__repr__": [[50, 52], ["repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'{self.__class__.__name__}({repr(self.data)})'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.__len__": [[53, 55], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.data": [[56, 59], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "data", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_data", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.datatype": [[60, 66], ["isinstance", "data_container.DataContainer.data.type", "type"], "methods", ["None"], ["", "@", "property", "\n", "def", "datatype", "(", "self", ")", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "data", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "self", ".", "data", ".", "type", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "type", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.cpu_only": [[67, 70], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "cpu_only", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_cpu_only", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack": [[71, 74], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "stack", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_stack", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.padding_value": [[75, 78], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "padding_value", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_padding_value", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.pad_dims": [[79, 82], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "pad_dims", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_pad_dims", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size": [[83, 86], ["data_container.DataContainer.data.size"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "@", "assert_tensor_type", "\n", "def", "size", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "size", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim": [[87, 90], ["data_container.DataContainer.data.dim"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim"], ["", "@", "assert_tensor_type", "\n", "def", "dim", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data", ".", "dim", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.assert_tensor_type": [[7, 18], ["functools.wraps", "func", "isinstance", "AttributeError"], "function", ["None"], ["def", "assert_tensor_type", "(", "func", ")", ":", "\n", "\n", "    ", "@", "functools", ".", "wraps", "(", "func", ")", "\n", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "args", "[", "0", "]", ".", "data", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "raise", "AttributeError", "(", "\n", "f'{args[0].__class__.__name__} has no attribute '", "\n", "f'{func.__name__} for type {args[0].datatype}'", ")", "\n", "", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.collate.collate": [[11, 85], ["isinstance", "isinstance", "TypeError", "data_container.DataContainer", "isinstance", "range", "data_container.DataContainer", "zip", "isinstance", "len", "stacked.append", "range", "range", "collate.collate", "torch.utils.data.dataloader.default_collate", "len", "isinstance", "len", "stacked.append", "collate.collate", "batch[].dim", "range", "stacked.append", "batch[].size", "range", "range", "range", "padded_samples.append", "torch.utils.data.dataloader.default_collate", "stacked.append", "ValueError", "range", "max", "torch.pad", "torch.utils.data.dataloader.default_collate", "batch[].size", "sample.size", "sample.size", "range", "sample.size"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.collate.collate", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.collate.collate", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["def", "collate", "(", "batch", ",", "samples_per_gpu", "=", "1", ")", ":", "\n", "    ", "\"\"\"Puts each data field into a tensor/DataContainer with outer dimension\n    batch size.\n\n    Extend default_collate to add support for\n    :type:`~parallel.DataContainer`. There are 3 cases.\n\n    1. cpu_only = True, e.g., meta data\n    2. cpu_only = False, stack = True, e.g., images tensors\n    3. cpu_only = False, stack = False, e.g., gt bboxes\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "batch", ",", "Sequence", ")", ":", "\n", "        ", "raise", "TypeError", "(", "f'{batch.dtype} is not supported.'", ")", "\n", "\n", "", "if", "isinstance", "(", "batch", "[", "0", "]", ",", "DataContainer", ")", ":", "\n", "        ", "stacked", "=", "[", "]", "\n", "if", "batch", "[", "0", "]", ".", "cpu_only", ":", "\n", "            ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "batch", ")", ",", "samples_per_gpu", ")", ":", "\n", "                ", "stacked", ".", "append", "(", "\n", "[", "sample", ".", "data", "for", "sample", "in", "batch", "[", "i", ":", "i", "+", "samples_per_gpu", "]", "]", ")", "\n", "", "return", "DataContainer", "(", "\n", "stacked", ",", "batch", "[", "0", "]", ".", "stack", ",", "batch", "[", "0", "]", ".", "padding_value", ",", "cpu_only", "=", "True", ")", "\n", "", "elif", "batch", "[", "0", "]", ".", "stack", ":", "\n", "            ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "batch", ")", ",", "samples_per_gpu", ")", ":", "\n", "                ", "assert", "isinstance", "(", "batch", "[", "i", "]", ".", "data", ",", "torch", ".", "Tensor", ")", "\n", "\n", "if", "batch", "[", "i", "]", ".", "pad_dims", "is", "not", "None", ":", "\n", "                    ", "ndim", "=", "batch", "[", "i", "]", ".", "dim", "(", ")", "\n", "assert", "ndim", ">", "batch", "[", "i", "]", ".", "pad_dims", "\n", "max_shape", "=", "[", "0", "for", "_", "in", "range", "(", "batch", "[", "i", "]", ".", "pad_dims", ")", "]", "\n", "for", "dim", "in", "range", "(", "1", ",", "batch", "[", "i", "]", ".", "pad_dims", "+", "1", ")", ":", "\n", "                        ", "max_shape", "[", "dim", "-", "1", "]", "=", "batch", "[", "i", "]", ".", "size", "(", "-", "dim", ")", "\n", "", "for", "sample", "in", "batch", "[", "i", ":", "i", "+", "samples_per_gpu", "]", ":", "\n", "                        ", "for", "dim", "in", "range", "(", "0", ",", "ndim", "-", "batch", "[", "i", "]", ".", "pad_dims", ")", ":", "\n", "                            ", "assert", "batch", "[", "i", "]", ".", "size", "(", "dim", ")", "==", "sample", ".", "size", "(", "dim", ")", "\n", "", "for", "dim", "in", "range", "(", "1", ",", "batch", "[", "i", "]", ".", "pad_dims", "+", "1", ")", ":", "\n", "                            ", "max_shape", "[", "dim", "-", "1", "]", "=", "max", "(", "max_shape", "[", "dim", "-", "1", "]", ",", "\n", "sample", ".", "size", "(", "-", "dim", ")", ")", "\n", "", "", "padded_samples", "=", "[", "]", "\n", "for", "sample", "in", "batch", "[", "i", ":", "i", "+", "samples_per_gpu", "]", ":", "\n", "                        ", "pad", "=", "[", "0", "for", "_", "in", "range", "(", "batch", "[", "i", "]", ".", "pad_dims", "*", "2", ")", "]", "\n", "for", "dim", "in", "range", "(", "1", ",", "batch", "[", "i", "]", ".", "pad_dims", "+", "1", ")", ":", "\n", "                            ", "pad", "[", "2", "*", "dim", "-", "\n", "1", "]", "=", "max_shape", "[", "dim", "-", "1", "]", "-", "sample", ".", "size", "(", "-", "dim", ")", "\n", "", "padded_samples", ".", "append", "(", "\n", "F", ".", "pad", "(", "\n", "sample", ".", "data", ",", "pad", ",", "value", "=", "sample", ".", "padding_value", ")", ")", "\n", "", "stacked", ".", "append", "(", "default_collate", "(", "padded_samples", ")", ")", "\n", "", "elif", "batch", "[", "i", "]", ".", "pad_dims", "is", "None", ":", "\n", "                    ", "stacked", ".", "append", "(", "\n", "default_collate", "(", "[", "\n", "sample", ".", "data", "\n", "for", "sample", "in", "batch", "[", "i", ":", "i", "+", "samples_per_gpu", "]", "\n", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "'pad_dims should be either None or integers (1-3)'", ")", "\n", "\n", "", "", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "batch", ")", ",", "samples_per_gpu", ")", ":", "\n", "                ", "stacked", ".", "append", "(", "\n", "[", "sample", ".", "data", "for", "sample", "in", "batch", "[", "i", ":", "i", "+", "samples_per_gpu", "]", "]", ")", "\n", "", "", "return", "DataContainer", "(", "stacked", ",", "batch", "[", "0", "]", ".", "stack", ",", "batch", "[", "0", "]", ".", "padding_value", ")", "\n", "", "elif", "isinstance", "(", "batch", "[", "0", "]", ",", "Sequence", ")", ":", "\n", "        ", "transposed", "=", "zip", "(", "*", "batch", ")", "\n", "return", "[", "collate", "(", "samples", ",", "samples_per_gpu", ")", "for", "samples", "in", "transposed", "]", "\n", "", "elif", "isinstance", "(", "batch", "[", "0", "]", ",", "Mapping", ")", ":", "\n", "        ", "return", "{", "\n", "key", ":", "collate", "(", "[", "d", "[", "key", "]", "for", "d", "in", "batch", "]", ",", "samples_per_gpu", ")", "\n", "for", "key", "in", "batch", "[", "0", "]", "\n", "}", "\n", "", "else", ":", "\n", "        ", "return", "default_collate", "(", "batch", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.init_dist": [[10, 17], ["torch.get_start_method", "torch.set_start_method", "dist_utils._init_dist_pytorch", "ValueError"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils._init_dist_pytorch"], ["def", "init_dist", "(", "launcher", ",", "backend", "=", "'nccl'", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "mp", ".", "get_start_method", "(", "allow_none", "=", "True", ")", "is", "None", ":", "\n", "        ", "mp", ".", "set_start_method", "(", "'spawn'", ")", "\n", "", "if", "launcher", "==", "'pytorch'", ":", "\n", "        ", "_init_dist_pytorch", "(", "backend", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'Invalid launcher type: {launcher}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils._init_dist_pytorch": [[19, 25], ["int", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.set_device", "torch.cuda.set_device", "torch.cuda.set_device", "torch.init_process_group"], "function", ["None"], ["", "", "def", "_init_dist_pytorch", "(", "backend", ",", "**", "kwargs", ")", ":", "\n", "# TODO: use local_rank instead of rank % num_gpus", "\n", "    ", "rank", "=", "int", "(", "os", ".", "environ", "[", "'RANK'", "]", ")", "\n", "num_gpus", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "rank", "%", "num_gpus", ")", "\n", "dist", ".", "init_process_group", "(", "backend", "=", "backend", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.get_dist_info": [[27, 39], ["torch.is_available", "torch.is_initialized", "torch.get_rank", "torch.get_world_size"], "function", ["None"], ["", "def", "get_dist_info", "(", ")", ":", "\n", "    ", "if", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "initialized", "=", "dist", ".", "is_initialized", "(", ")", "\n", "", "else", ":", "\n", "        ", "initialized", "=", "False", "\n", "", "if", "initialized", ":", "\n", "        ", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "world_size", "=", "dist", ".", "get_world_size", "(", ")", "\n", "", "else", ":", "\n", "        ", "rank", "=", "0", "\n", "world_size", "=", "1", "\n", "", "return", "rank", ",", "world_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.master_only": [[41, 50], ["functools.wraps", "dist_utils.get_dist_info", "func"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.get_dist_info"], ["", "def", "master_only", "(", "func", ")", ":", "\n", "\n", "    ", "@", "functools", ".", "wraps", "(", "func", ")", "\n", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "if", "rank", "==", "0", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapper", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.distributed.MMDistributedDataParallel.to_kwargs": [[16, 20], ["scatter_gather.scatter_kwargs"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.scatter_gather.scatter_kwargs"], ["def", "to_kwargs", "(", "self", ",", "inputs", ",", "kwargs", ",", "device_id", ")", ":", "\n", "# Use `self.to_kwargs` instead of `self.scatter` in pytorch1.8", "\n", "# to move all tensors to device_id", "\n", "        ", "return", "scatter_kwargs", "(", "inputs", ",", "kwargs", ",", "[", "device_id", "]", ",", "dim", "=", "self", ".", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.distributed.MMDistributedDataParallel.scatter": [[21, 23], ["scatter_gather.scatter_kwargs"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.scatter_gather.scatter_kwargs"], ["", "def", "scatter", "(", "self", ",", "inputs", ",", "kwargs", ",", "device_ids", ")", ":", "\n", "        ", "return", "scatter_kwargs", "(", "inputs", ",", "kwargs", ",", "device_ids", ",", "dim", "=", "self", ".", "dim", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_parallel.MMDataParallel.scatter": [[11, 13], ["scatter_gather.scatter_kwargs"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.scatter_gather.scatter_kwargs"], ["    ", "def", "scatter", "(", "self", ",", "inputs", ",", "kwargs", ",", "device_ids", ")", ":", "\n", "        ", "return", "scatter_kwargs", "(", "inputs", ",", "kwargs", ",", "device_ids", ",", "dim", "=", "self", ".", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_parallel.MMDataParallel.forward": [[14, 32], ["itertools.chain", "data_parallel.MMDataParallel.scatter", "data_parallel.MMDataParallel.module", "data_parallel.MMDataParallel.module", "len", "data_parallel.MMDataParallel.module.parameters", "data_parallel.MMDataParallel.module.buffers", "RuntimeError"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.scatter"], ["", "def", "forward", "(", "self", ",", "*", "inputs", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "not", "self", ".", "device_ids", ":", "\n", "            ", "return", "self", ".", "module", "(", "*", "inputs", ",", "**", "kwargs", ")", "\n", "\n", "", "assert", "len", "(", "self", ".", "device_ids", ")", "==", "1", ",", "(", "'MMDataParallel only supports single GPU training, if you need to'", "\n", "' train with multiple GPUs, please use MMDistributedDataParallel'", "\n", "'instead.'", ")", "\n", "\n", "for", "t", "in", "chain", "(", "self", ".", "module", ".", "parameters", "(", ")", ",", "self", ".", "module", ".", "buffers", "(", ")", ")", ":", "\n", "            ", "if", "t", ".", "device", "!=", "self", ".", "src_device_obj", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "'module must have its parameters and buffers '", "\n", "f'on device {self.src_device_obj} (device_ids[0]) but '", "\n", "f'found one of them on device: {t.device}'", ")", "\n", "\n", "", "", "inputs", ",", "kwargs", "=", "self", ".", "scatter", "(", "inputs", ",", "kwargs", ",", "self", ".", "device_ids", ")", "\n", "return", "self", ".", "module", "(", "*", "inputs", "[", "0", "]", ",", "**", "kwargs", "[", "0", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.scatter_gather.scatter": [[9, 43], ["isinstance", "isinstance", "scatter_gather.scatter.scatter_map"], "function", ["None"], ["def", "scatter", "(", "inputs", ",", "target_gpus", ",", "dim", "=", "0", ")", ":", "\n", "    ", "\"\"\"Scatter inputs to target gpus.\n\n    The only difference from original :func:`scatter` is to add support for\n    :type:`~parallel.DataContainer`.\n    \"\"\"", "\n", "\n", "def", "scatter_map", "(", "obj", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "OrigScatter", ".", "apply", "(", "target_gpus", ",", "None", ",", "dim", ",", "obj", ")", "\n", "", "if", "isinstance", "(", "obj", ",", "DataContainer", ")", ":", "\n", "            ", "if", "obj", ".", "cpu_only", ":", "\n", "                ", "return", "obj", ".", "data", "\n", "", "else", ":", "\n", "                ", "return", "Scatter", ".", "forward", "(", "target_gpus", ",", "obj", ".", "data", ")", "\n", "", "", "if", "isinstance", "(", "obj", ",", "tuple", ")", "and", "len", "(", "obj", ")", ">", "0", ":", "\n", "            ", "return", "list", "(", "zip", "(", "*", "map", "(", "scatter_map", ",", "obj", ")", ")", ")", "\n", "", "if", "isinstance", "(", "obj", ",", "list", ")", "and", "len", "(", "obj", ")", ">", "0", ":", "\n", "            ", "out", "=", "list", "(", "map", "(", "list", ",", "zip", "(", "*", "map", "(", "scatter_map", ",", "obj", ")", ")", ")", ")", "\n", "return", "out", "\n", "", "if", "isinstance", "(", "obj", ",", "dict", ")", "and", "len", "(", "obj", ")", ">", "0", ":", "\n", "            ", "out", "=", "list", "(", "map", "(", "type", "(", "obj", ")", ",", "zip", "(", "*", "map", "(", "scatter_map", ",", "obj", ".", "items", "(", ")", ")", ")", ")", ")", "\n", "return", "out", "\n", "", "return", "[", "obj", "for", "targets", "in", "target_gpus", "]", "\n", "\n", "# After scatter_map is called, a scatter_map cell will exist. This cell", "\n", "# has a reference to the actual function scatter_map, which has references", "\n", "# to a closure that has a reference to the scatter_map cell (because the", "\n", "# fn is recursive). To avoid this reference cycle, we set the function to", "\n", "# None, clearing the cell", "\n", "", "try", ":", "\n", "        ", "return", "scatter_map", "(", "inputs", ")", "\n", "", "finally", ":", "\n", "        ", "scatter_map", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.scatter_gather.scatter_kwargs": [[45, 56], ["tuple", "tuple", "scatter_gather.scatter", "scatter_gather.scatter", "len", "len", "tuple.extend", "len", "len", "tuple.extend", "range", "range", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.scatter", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.scatter"], ["", "", "def", "scatter_kwargs", "(", "inputs", ",", "kwargs", ",", "target_gpus", ",", "dim", "=", "0", ")", ":", "\n", "    ", "\"\"\"Scatter with support for kwargs dictionary.\"\"\"", "\n", "inputs", "=", "scatter", "(", "inputs", ",", "target_gpus", ",", "dim", ")", "if", "inputs", "else", "[", "]", "\n", "kwargs", "=", "scatter", "(", "kwargs", ",", "target_gpus", ",", "dim", ")", "if", "kwargs", "else", "[", "]", "\n", "if", "len", "(", "inputs", ")", "<", "len", "(", "kwargs", ")", ":", "\n", "        ", "inputs", ".", "extend", "(", "[", "(", ")", "for", "_", "in", "range", "(", "len", "(", "kwargs", ")", "-", "len", "(", "inputs", ")", ")", "]", ")", "\n", "", "elif", "len", "(", "kwargs", ")", "<", "len", "(", "inputs", ")", ":", "\n", "        ", "kwargs", ".", "extend", "(", "[", "{", "}", "for", "_", "in", "range", "(", "len", "(", "inputs", ")", "-", "len", "(", "kwargs", ")", ")", "]", ")", "\n", "", "inputs", "=", "tuple", "(", "inputs", ")", "\n", "kwargs", "=", "tuple", "(", "kwargs", ")", "\n", "return", "inputs", ",", "kwargs", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.utils.is_module_wrapper": [[5, 21], ["isinstance"], "function", ["None"], ["def", "is_module_wrapper", "(", "module", ")", ":", "\n", "    ", "\"\"\"Check if a module is a module wrapper.\n\n    The following 3 modules in MMCV (and their subclasses) are regarded as\n    module wrappers: DataParallel, DistributedDataParallel,\n    MMDistributedDataParallel (the deprecated version). You may add you own\n    module wrapper by registering it to parallel.MODULE_WRAPPERS.\n\n    Args:\n        module (nn.Module): The module to be checked.\n\n    Returns:\n        bool: True if the input module is a module wrapper.\n    \"\"\"", "\n", "module_wrappers", "=", "(", "DataParallel", ",", "DistributedDataParallel", ")", "\n", "return", "isinstance", "(", "module", ",", "module_wrappers", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.Scatter.forward": [[61, 75], ["_functions.get_input_device", "_functions.scatter", "tuple", "_functions.synchronize_stream", "torch.nn.parallel._functions._get_stream"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.get_input_device", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.scatter", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.synchronize_stream"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "target_gpus", ",", "input", ")", ":", "\n", "        ", "input_device", "=", "get_input_device", "(", "input", ")", "\n", "streams", "=", "None", "\n", "if", "input_device", "==", "-", "1", ":", "\n", "# Perform CPU to GPU copies in a background stream", "\n", "            ", "streams", "=", "[", "_get_stream", "(", "device", ")", "for", "device", "in", "target_gpus", "]", "\n", "\n", "", "outputs", "=", "scatter", "(", "input", ",", "target_gpus", ",", "streams", ")", "\n", "# Synchronize with the copy stream", "\n", "if", "streams", "is", "not", "None", ":", "\n", "            ", "synchronize_stream", "(", "outputs", ",", "target_gpus", ",", "streams", ")", "\n", "\n", "", "return", "tuple", "(", "outputs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.scatter": [[6, 27], ["isinstance", "isinstance", "len", "_functions.scatter", "input.contiguous", "Exception", "len", "range", "torch.cuda.device", "torch.cuda.stream", "output.cuda.cuda", "len", "len", "output.cuda.numel", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.scatter"], ["def", "scatter", "(", "input", ",", "devices", ",", "streams", "=", "None", ")", ":", "\n", "    ", "\"\"\"Scatters tensor across multiple GPUs.\"\"\"", "\n", "if", "streams", "is", "None", ":", "\n", "        ", "streams", "=", "[", "None", "]", "*", "len", "(", "devices", ")", "\n", "\n", "", "if", "isinstance", "(", "input", ",", "list", ")", ":", "\n", "        ", "chunk_size", "=", "(", "len", "(", "input", ")", "-", "1", ")", "//", "len", "(", "devices", ")", "+", "1", "\n", "outputs", "=", "[", "\n", "scatter", "(", "input", "[", "i", "]", ",", "[", "devices", "[", "i", "//", "chunk_size", "]", "]", ",", "\n", "[", "streams", "[", "i", "//", "chunk_size", "]", "]", ")", "for", "i", "in", "range", "(", "len", "(", "input", ")", ")", "\n", "]", "\n", "return", "outputs", "\n", "", "elif", "isinstance", "(", "input", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "output", "=", "input", ".", "contiguous", "(", ")", "\n", "# TODO: copy to a pinned buffer first (if copying from CPU)", "\n", "stream", "=", "streams", "[", "0", "]", "if", "output", ".", "numel", "(", ")", ">", "0", "else", "None", "\n", "with", "torch", ".", "cuda", ".", "device", "(", "devices", "[", "0", "]", ")", ",", "torch", ".", "cuda", ".", "stream", "(", "stream", ")", ":", "\n", "            ", "output", "=", "output", ".", "cuda", "(", "devices", "[", "0", "]", ",", "non_blocking", "=", "True", ")", "\n", "", "return", "output", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "f'Unknown type {type(input)}.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.synchronize_stream": [[29, 44], ["isinstance", "range", "isinstance", "len", "len", "len", "range", "Exception", "_functions.synchronize_stream", "output.numel", "torch.cuda.device", "torch.cuda.current_stream", "torch.cuda.current_stream.wait_stream", "output.record_stream", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.synchronize_stream"], ["", "", "def", "synchronize_stream", "(", "output", ",", "devices", ",", "streams", ")", ":", "\n", "    ", "if", "isinstance", "(", "output", ",", "list", ")", ":", "\n", "        ", "chunk_size", "=", "len", "(", "output", ")", "//", "len", "(", "devices", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "devices", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "chunk_size", ")", ":", "\n", "                ", "synchronize_stream", "(", "output", "[", "i", "*", "chunk_size", "+", "j", "]", ",", "[", "devices", "[", "i", "]", "]", ",", "\n", "[", "streams", "[", "i", "]", "]", ")", "\n", "", "", "", "elif", "isinstance", "(", "output", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "if", "output", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "with", "torch", ".", "cuda", ".", "device", "(", "devices", "[", "0", "]", ")", ":", "\n", "                ", "main_stream", "=", "torch", ".", "cuda", ".", "current_stream", "(", ")", "\n", "main_stream", ".", "wait_stream", "(", "streams", "[", "0", "]", ")", "\n", "output", ".", "record_stream", "(", "main_stream", ")", "\n", "", "", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "f'Unknown type {type(output)}.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.get_input_device": [[46, 57], ["isinstance", "isinstance", "_functions.get_input_device", "Exception", "input.get_device", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel._functions.get_input_device"], ["", "", "def", "get_input_device", "(", "input", ")", ":", "\n", "    ", "if", "isinstance", "(", "input", ",", "list", ")", ":", "\n", "        ", "for", "item", "in", "input", ":", "\n", "            ", "input_device", "=", "get_input_device", "(", "item", ")", "\n", "if", "input_device", "!=", "-", "1", ":", "\n", "                ", "return", "input_device", "\n", "", "", "return", "-", "1", "\n", "", "elif", "isinstance", "(", "input", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "input", ".", "get_device", "(", ")", "if", "input", ".", "is_cuda", "else", "-", "1", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "f'Unknown type {type(input)}.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.default_constructor.DefaultOptimizerConstructor.__init__": [[77, 86], ["optimizer_cfg.get", "optimizer_cfg.get", "default_constructor.DefaultOptimizerConstructor._validate_cfg", "isinstance", "TypeError", "type"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.default_constructor.DefaultOptimizerConstructor._validate_cfg"], ["def", "__init__", "(", "self", ",", "optimizer_cfg", ",", "paramwise_cfg", "=", "None", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "optimizer_cfg", ",", "dict", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'optimizer_cfg should be a dict'", ",", "\n", "f'but got {type(optimizer_cfg)}'", ")", "\n", "", "self", ".", "optimizer_cfg", "=", "optimizer_cfg", "\n", "self", ".", "paramwise_cfg", "=", "{", "}", "if", "paramwise_cfg", "is", "None", "else", "paramwise_cfg", "\n", "self", ".", "base_lr", "=", "optimizer_cfg", ".", "get", "(", "'lr'", ",", "None", ")", "\n", "self", ".", "base_wd", "=", "optimizer_cfg", ".", "get", "(", "'weight_decay'", ",", "None", ")", "\n", "self", ".", "_validate_cfg", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.default_constructor.DefaultOptimizerConstructor._validate_cfg": [[87, 109], ["isinstance", "TypeError", "isinstance", "TypeError", "ValueError", "type", "ValueError", "type"], "methods", ["None"], ["", "def", "_validate_cfg", "(", "self", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "self", ".", "paramwise_cfg", ",", "dict", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'paramwise_cfg should be None or a dict, '", "\n", "f'but got {type(self.paramwise_cfg)}'", ")", "\n", "\n", "", "if", "'custom_keys'", "in", "self", ".", "paramwise_cfg", ":", "\n", "            ", "if", "not", "isinstance", "(", "self", ".", "paramwise_cfg", "[", "'custom_keys'", "]", ",", "dict", ")", ":", "\n", "                ", "raise", "TypeError", "(", "\n", "'If specified, custom_keys must be a dict, '", "\n", "f'but got {type(self.paramwise_cfg[\"custom_keys\"])}'", ")", "\n", "", "if", "self", ".", "base_wd", "is", "None", ":", "\n", "                ", "for", "key", "in", "self", ".", "paramwise_cfg", "[", "'custom_keys'", "]", ":", "\n", "                    ", "if", "'decay_mult'", "in", "self", ".", "paramwise_cfg", "[", "'custom_keys'", "]", "[", "key", "]", ":", "\n", "                        ", "raise", "ValueError", "(", "'base_wd should not be None'", ")", "\n", "\n", "# get base lr and weight decay", "\n", "# weight_decay must be explicitly specified if mult is specified", "\n", "", "", "", "", "if", "(", "'bias_decay_mult'", "in", "self", ".", "paramwise_cfg", "\n", "or", "'norm_decay_mult'", "in", "self", ".", "paramwise_cfg", "\n", "or", "'dwconv_decay_mult'", "in", "self", ".", "paramwise_cfg", ")", ":", "\n", "            ", "if", "self", ".", "base_wd", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "'base_wd should not be None'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.default_constructor.DefaultOptimizerConstructor._is_in": [[110, 118], ["vedacore.misc.is_list_of", "set", "set", "set.update", "set.isdisjoint", "set"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_list_of", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update"], ["", "", "", "def", "_is_in", "(", "self", ",", "param_group", ",", "param_group_list", ")", ":", "\n", "        ", "assert", "is_list_of", "(", "param_group_list", ",", "dict", ")", "\n", "param", "=", "set", "(", "param_group", "[", "'params'", "]", ")", "\n", "param_set", "=", "set", "(", ")", "\n", "for", "group", "in", "param_group_list", ":", "\n", "            ", "param_set", ".", "update", "(", "set", "(", "group", "[", "'params'", "]", ")", ")", "\n", "\n", "", "return", "not", "param", ".", "isdisjoint", "(", "param_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.default_constructor.DefaultOptimizerConstructor.add_params": [[119, 192], ["default_constructor.DefaultOptimizerConstructor.paramwise_cfg.get", "sorted", "default_constructor.DefaultOptimizerConstructor.paramwise_cfg.get", "default_constructor.DefaultOptimizerConstructor.paramwise_cfg.get", "default_constructor.DefaultOptimizerConstructor.paramwise_cfg.get", "default_constructor.DefaultOptimizerConstructor.paramwise_cfg.get", "default_constructor.DefaultOptimizerConstructor.paramwise_cfg.get", "isinstance", "module.named_parameters", "module.named_children", "sorted", "isinstance", "params.append", "default_constructor.DefaultOptimizerConstructor.add_params", "default_constructor.DefaultOptimizerConstructor.keys", "params.append", "default_constructor.DefaultOptimizerConstructor._is_in", "warnings.warn", "custom_keys[].get", "custom_keys[].get"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.default_constructor.DefaultOptimizerConstructor.add_params", "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.default_constructor.DefaultOptimizerConstructor._is_in", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "add_params", "(", "self", ",", "params", ",", "module", ",", "prefix", "=", "''", ")", ":", "\n", "        ", "\"\"\"Add all parameters of module to the params list.\n\n        The parameters of the given module will be added to the list of param\n        groups, with specific rules defined by paramwise_cfg.\n\n        Args:\n            params (list[dict]): A list of param groups, it will be modified\n                in place.\n            module (nn.Module): The module to be added.\n            prefix (str): The prefix of the module\n        \"\"\"", "\n", "# get param-wise options", "\n", "custom_keys", "=", "self", ".", "paramwise_cfg", ".", "get", "(", "'custom_keys'", ",", "{", "}", ")", "\n", "# first sort with alphabet order and then sort with reversed len of str", "\n", "sorted_keys", "=", "sorted", "(", "sorted", "(", "custom_keys", ".", "keys", "(", ")", ")", ",", "key", "=", "len", ",", "reverse", "=", "True", ")", "\n", "\n", "bias_lr_mult", "=", "self", ".", "paramwise_cfg", ".", "get", "(", "'bias_lr_mult'", ",", "1.", ")", "\n", "bias_decay_mult", "=", "self", ".", "paramwise_cfg", ".", "get", "(", "'bias_decay_mult'", ",", "1.", ")", "\n", "norm_decay_mult", "=", "self", ".", "paramwise_cfg", ".", "get", "(", "'norm_decay_mult'", ",", "1.", ")", "\n", "dwconv_decay_mult", "=", "self", ".", "paramwise_cfg", ".", "get", "(", "'dwconv_decay_mult'", ",", "1.", ")", "\n", "bypass_duplicate", "=", "self", ".", "paramwise_cfg", ".", "get", "(", "'bypass_duplicate'", ",", "False", ")", "\n", "\n", "# special rules for norm layers and depth-wise conv layers", "\n", "is_norm", "=", "isinstance", "(", "module", ",", "\n", "(", "_BatchNorm", ",", "_InstanceNorm", ",", "GroupNorm", ",", "LayerNorm", ")", ")", "\n", "is_dwconv", "=", "(", "\n", "isinstance", "(", "module", ",", "torch", ".", "nn", ".", "Conv2d", ")", "\n", "and", "module", ".", "in_channels", "==", "module", ".", "groups", ")", "\n", "\n", "for", "name", ",", "param", "in", "module", ".", "named_parameters", "(", "recurse", "=", "False", ")", ":", "\n", "            ", "param_group", "=", "{", "'params'", ":", "[", "param", "]", "}", "\n", "if", "not", "param", ".", "requires_grad", ":", "\n", "                ", "params", ".", "append", "(", "param_group", ")", "\n", "continue", "\n", "", "if", "bypass_duplicate", "and", "self", ".", "_is_in", "(", "param_group", ",", "params", ")", ":", "\n", "                ", "warnings", ".", "warn", "(", "f'{prefix} is duplicate. It is skipped since '", "\n", "f'bypass_duplicate={bypass_duplicate}'", ")", "\n", "continue", "\n", "# if the parameter match one of the custom keys, ignore other rules", "\n", "", "is_custom", "=", "False", "\n", "for", "key", "in", "sorted_keys", ":", "\n", "                ", "if", "key", "in", "f'{prefix}.{name}'", ":", "\n", "                    ", "is_custom", "=", "True", "\n", "lr_mult", "=", "custom_keys", "[", "key", "]", ".", "get", "(", "'lr_mult'", ",", "1.", ")", "\n", "param_group", "[", "'lr'", "]", "=", "self", ".", "base_lr", "*", "lr_mult", "\n", "if", "self", ".", "base_wd", "is", "not", "None", ":", "\n", "                        ", "decay_mult", "=", "custom_keys", "[", "key", "]", ".", "get", "(", "'decay_mult'", ",", "1.", ")", "\n", "param_group", "[", "'weight_decay'", "]", "=", "self", ".", "base_wd", "*", "decay_mult", "\n", "", "break", "\n", "", "", "if", "not", "is_custom", ":", "\n", "# bias_lr_mult affects all bias parameters except for norm.bias", "\n", "                ", "if", "name", "==", "'bias'", "and", "not", "is_norm", ":", "\n", "                    ", "param_group", "[", "'lr'", "]", "=", "self", ".", "base_lr", "*", "bias_lr_mult", "\n", "# apply weight decay policies", "\n", "", "if", "self", ".", "base_wd", "is", "not", "None", ":", "\n", "# norm decay", "\n", "                    ", "if", "is_norm", ":", "\n", "                        ", "param_group", "[", "\n", "'weight_decay'", "]", "=", "self", ".", "base_wd", "*", "norm_decay_mult", "\n", "# depth-wise conv", "\n", "", "elif", "is_dwconv", ":", "\n", "                        ", "param_group", "[", "\n", "'weight_decay'", "]", "=", "self", ".", "base_wd", "*", "dwconv_decay_mult", "\n", "# bias lr and decay", "\n", "", "elif", "name", "==", "'bias'", ":", "\n", "                        ", "param_group", "[", "\n", "'weight_decay'", "]", "=", "self", ".", "base_wd", "*", "bias_decay_mult", "\n", "", "", "", "params", ".", "append", "(", "param_group", ")", "\n", "\n", "", "for", "child_name", ",", "child_mod", "in", "module", ".", "named_children", "(", ")", ":", "\n", "            ", "child_prefix", "=", "f'{prefix}.{child_name}'", "if", "prefix", "else", "child_name", "\n", "self", ".", "add_params", "(", "params", ",", "child_mod", ",", "prefix", "=", "child_prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.default_constructor.DefaultOptimizerConstructor.__call__": [[193, 209], ["hasattr", "default_constructor.DefaultOptimizerConstructor.optimizer_cfg.copy", "default_constructor.DefaultOptimizerConstructor.add_params", "vedacore.misc.build_from_cfg", "model.parameters", "vedacore.misc.build_from_cfg"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.default_constructor.DefaultOptimizerConstructor.add_params", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["", "", "def", "__call__", "(", "self", ",", "model", ")", ":", "\n", "        ", "if", "hasattr", "(", "model", ",", "'module'", ")", ":", "\n", "            ", "model", "=", "model", ".", "module", "\n", "\n", "", "optimizer_cfg", "=", "self", ".", "optimizer_cfg", ".", "copy", "(", ")", "\n", "# if no paramwise option is specified, just use the global setting", "\n", "if", "not", "self", ".", "paramwise_cfg", ":", "\n", "            ", "optimizer_cfg", "[", "'params'", "]", "=", "model", ".", "parameters", "(", ")", "\n", "return", "build_from_cfg", "(", "optimizer_cfg", ",", "registry", ",", "'optimizer'", ")", "\n", "\n", "# set param-wise lr and weight decay recursively", "\n", "", "params", "=", "[", "]", "\n", "self", ".", "add_params", "(", "params", ",", "model", ")", "\n", "optimizer_cfg", "[", "'params'", "]", "=", "params", "\n", "\n", "return", "build_from_cfg", "(", "optimizer_cfg", ",", "registry", ",", "'optimizer'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.builder.register_torch_optimizers": [[10, 21], ["dir", "module_name.startswith", "getattr", "inspect.isclass", "issubclass", "torch_optimizers.append", "vedacore.misc.registry.register_module"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.register_module"], ["def", "register_torch_optimizers", "(", ")", ":", "\n", "    ", "torch_optimizers", "=", "[", "]", "\n", "for", "module_name", "in", "dir", "(", "torch", ".", "optim", ")", ":", "\n", "        ", "if", "module_name", ".", "startswith", "(", "'__'", ")", ":", "\n", "            ", "continue", "\n", "", "_optim", "=", "getattr", "(", "torch", ".", "optim", ",", "module_name", ")", "\n", "if", "inspect", ".", "isclass", "(", "_optim", ")", "and", "issubclass", "(", "_optim", ",", "\n", "torch", ".", "optim", ".", "Optimizer", ")", ":", "\n", "            ", "registry", ".", "register_module", "(", "'optimizer'", ")", "(", "_optim", ")", "\n", "torch_optimizers", ".", "append", "(", "module_name", ")", "\n", "", "", "return", "torch_optimizers", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.builder.build_optimizer_constructor": [[26, 28], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["def", "build_optimizer_constructor", "(", "cfg", ")", ":", "\n", "    ", "return", "build_from_cfg", "(", "cfg", ",", "registry", ",", "'optimizer_builder'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.builder.build_optimizer": [[30, 42], ["copy.deepcopy", "copy.deepcopy.pop", "copy.deepcopy.pop", "builder.build_optimizer_constructor", "build_optimizer_constructor.", "dict"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.builder.build_optimizer_constructor"], ["", "def", "build_optimizer", "(", "model", ",", "cfg", ")", ":", "\n", "    ", "optimizer_cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "constructor_type", "=", "optimizer_cfg", ".", "pop", "(", "'constructor'", ",", "\n", "'DefaultOptimizerConstructor'", ")", "\n", "paramwise_cfg", "=", "optimizer_cfg", ".", "pop", "(", "'paramwise_cfg'", ",", "None", ")", "\n", "optim_constructor", "=", "build_optimizer_constructor", "(", "\n", "dict", "(", "\n", "typename", "=", "constructor_type", ",", "\n", "optimizer_cfg", "=", "optimizer_cfg", ",", "\n", "paramwise_cfg", "=", "paramwise_cfg", ")", ")", "\n", "optimizer", "=", "optim_constructor", "(", "model", ")", "\n", "return", "optimizer", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.get_model_complexity_info": [[34, 112], ["isinstance", "flops_counter.add_flops_counting_methods", "add_flops_counting_methods.eval", "add_flops_counting_methods.start_flops_count", "add_flops_counting_methods.compute_average_flops_cost", "add_flops_counting_methods.stop_flops_count", "type", "len", "input_constructor", "add_flops_counting_methods.", "add_flops_counting_methods.", "flops_counter.print_model_with_flops", "torch.ones().new_empty", "torch.ones().new_empty", "flops_counter.flops_to_string", "flops_counter.params_to_string", "torch.ones().new_empty", "torch.ones().new_empty", "torch.ones", "torch.ones", "next", "next", "torch.ones", "torch.ones", "add_flops_counting_methods.parameters", "add_flops_counting_methods.parameters"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.add_flops_counting_methods", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.start_flops_count", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.compute_average_flops_cost", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.stop_flops_count", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.print_model_with_flops", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.flops_to_string", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.params_to_string"], ["def", "get_model_complexity_info", "(", "model", ",", "\n", "input_shape", ",", "\n", "print_per_layer_stat", "=", "True", ",", "\n", "as_strings", "=", "True", ",", "\n", "input_constructor", "=", "None", ",", "\n", "flush", "=", "False", ",", "\n", "ost", "=", "sys", ".", "stdout", ")", ":", "\n", "    ", "\"\"\"Get complexity information of a model.\n\n    This method can calculate FLOPs and parameter counts of a model with\n    corresponding input shape. It can also print complexity information for\n    each layer in a model.\n\n    Supported layers are listed as below:\n        - Convolutions: `nn.Conv1d`, `nn.Conv2d`, `nn.Conv3d`.\n        - Activations: `nn.ReLU`, `nn.PReLU`, `nn.ELU`, `nn.LeakyReLU`,\n            `nn.ReLU6`.\n        - Poolings: `nn.MaxPool1d`, `nn.MaxPool2d`, `nn.MaxPool3d`,\n            `nn.AvgPool1d`, `nn.AvgPool2d`, `nn.AvgPool3d`,\n            `nn.AdaptiveMaxPool1d`, `nn.AdaptiveMaxPool2d`,\n            `nn.AdaptiveMaxPool3d`, `nn.AdaptiveAvgPool1d`,\n            `nn.AdaptiveAvgPool2d`, `nn.AdaptiveAvgPool3d`.\n        - BatchNorms: `nn.BatchNorm1d`, `nn.BatchNorm2d`, `nn.BatchNorm3d`.\n        - Linear: `nn.Linear`.\n        - Deconvolution: `nn.ConvTranspose2d`.\n        - Upsample: `nn.Upsample`.\n\n    Args:\n        model (nn.Module): The model for complexity calculation.\n        input_shape (tuple): Input shape used for calculation.\n        print_per_layer_stat (bool): Whether to print complexity information\n            for each layer in a model. Default: True.\n        as_strings (bool): Output FLOPs and params counts in a string form.\n            Default: True.\n        input_constructor (None | callable): If specified, it takes a callable\n            method that generates input. otherwise, it will generate a random\n            tensor with input shape to calculate FLOPs. Default: None.\n        flush (bool): same as that in :func:`print`. Default: False.\n        ost (stream): same as `file` param in :func:`print`.\n            Default: sys.stdout.\n\n    Returns:\n        tuple[float | str]: If `as_strings` is set to True, it will return\n            FLOPs and parameter counts in a string format. otherwise, it will\n            return those in a float number format.\n    \"\"\"", "\n", "assert", "type", "(", "input_shape", ")", "is", "tuple", "\n", "assert", "len", "(", "input_shape", ")", ">=", "1", "\n", "assert", "isinstance", "(", "model", ",", "nn", ".", "Module", ")", "\n", "flops_model", "=", "add_flops_counting_methods", "(", "model", ")", "\n", "flops_model", ".", "eval", "(", ")", "\n", "flops_model", ".", "start_flops_count", "(", ")", "\n", "if", "input_constructor", ":", "\n", "        ", "input", "=", "input_constructor", "(", "input_shape", ")", "\n", "_", "=", "flops_model", "(", "**", "input", ")", "\n", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "batch", "=", "torch", ".", "ones", "(", "(", ")", ")", ".", "new_empty", "(", "\n", "(", "1", ",", "*", "input_shape", ")", ",", "\n", "dtype", "=", "next", "(", "flops_model", ".", "parameters", "(", ")", ")", ".", "dtype", ",", "\n", "device", "=", "next", "(", "flops_model", ".", "parameters", "(", ")", ")", ".", "device", ")", "\n", "", "except", "StopIteration", ":", "\n", "# Avoid StopIteration for models which have no parameters,", "\n", "# like `nn.Relu()`, `nn.AvgPool2d`, etc.", "\n", "            ", "batch", "=", "torch", ".", "ones", "(", "(", ")", ")", ".", "new_empty", "(", "(", "1", ",", "*", "input_shape", ")", ")", "\n", "\n", "", "_", "=", "flops_model", "(", "batch", ")", "\n", "\n", "", "flops_count", ",", "params_count", "=", "flops_model", ".", "compute_average_flops_cost", "(", ")", "\n", "if", "print_per_layer_stat", ":", "\n", "        ", "print_model_with_flops", "(", "\n", "flops_model", ",", "flops_count", ",", "params_count", ",", "ost", "=", "ost", ",", "flush", "=", "flush", ")", "\n", "", "flops_model", ".", "stop_flops_count", "(", ")", "\n", "\n", "if", "as_strings", ":", "\n", "        ", "return", "flops_to_string", "(", "flops_count", ")", ",", "params_to_string", "(", "params_count", ")", "\n", "\n", "", "return", "flops_count", ",", "params_count", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.flops_to_string": [[114, 155], ["str", "round", "str", "str", "round", "str", "str", "round", "str", "str", "round", "round", "str", "round"], "function", ["None"], ["", "def", "flops_to_string", "(", "flops", ",", "units", "=", "'GFLOPs'", ",", "precision", "=", "2", ")", ":", "\n", "    ", "\"\"\"Convert FLOPs number into a string.\n\n    Note that Here we take a multiply-add counts as one FLOP.\n\n    Args:\n        flops (float): FLOPs number to be converted.\n        units (str | None): Converted FLOPs units. Options are None, 'GFLOPs',\n            'MFLOPs', 'KFLOPs', 'FLOPs'. If set to None, it will automatically\n            choose the most suitable unit for FLOPs. Default: 'GFLOPs'.\n        precision (int): Digit number after the decimal point. Default: 2.\n\n    Returns:\n        str: The converted FLOPs number with units.\n\n    Examples:\n        >>> flops_to_string(1e9)\n        '1.0 GFLOPs'\n        >>> flops_to_string(2e5, 'MFLOPs')\n        '0.2 MFLOPs'\n        >>> flops_to_string(3e-9, None)\n        '3e-09 FLOPs'\n    \"\"\"", "\n", "if", "units", "is", "None", ":", "\n", "        ", "if", "flops", "//", "10", "**", "9", ">", "0", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "9", ",", "precision", ")", ")", "+", "' GFLOPs'", "\n", "", "elif", "flops", "//", "10", "**", "6", ">", "0", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "6", ",", "precision", ")", ")", "+", "' MFLOPs'", "\n", "", "elif", "flops", "//", "10", "**", "3", ">", "0", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "3", ",", "precision", ")", ")", "+", "' KFLOPs'", "\n", "", "else", ":", "\n", "            ", "return", "str", "(", "flops", ")", "+", "' FLOPs'", "\n", "", "", "else", ":", "\n", "        ", "if", "units", "==", "'GFLOPs'", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "9", ",", "precision", ")", ")", "+", "' '", "+", "units", "\n", "", "elif", "units", "==", "'MFLOPs'", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "6", ",", "precision", ")", ")", "+", "' '", "+", "units", "\n", "", "elif", "units", "==", "'KFLOPs'", ":", "\n", "            ", "return", "str", "(", "round", "(", "flops", "/", "10.", "**", "3", ",", "precision", ")", ")", "+", "' '", "+", "units", "\n", "", "else", ":", "\n", "            ", "return", "str", "(", "flops", ")", "+", "' FLOPs'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.params_to_string": [[157, 192], ["str", "str", "str", "round", "str", "str", "round", "round", "str", "round"], "function", ["None"], ["", "", "", "def", "params_to_string", "(", "num_params", ",", "units", "=", "None", ",", "precision", "=", "2", ")", ":", "\n", "    ", "\"\"\"Convert parameter number into a string.\n\n    Args:\n        num_params (float): Parameter number to be converted.\n        units (str | None): Converted FLOPs units. Options are None, 'M',\n            'K' and ''. If set to None, it will automatically choose the most\n            suitable unit for Parameter number. Default: None.\n        precision (int): Digit number after the decimal point. Default: 2.\n\n    Returns:\n        str: The converted parameter number with units.\n\n    Examples:\n        >>> params_to_string(1e9)\n        '1000.0 M'\n        >>> params_to_string(2e5)\n        '200.0 k'\n        >>> params_to_string(3e-9)\n        '3e-09'\n    \"\"\"", "\n", "if", "units", "is", "None", ":", "\n", "        ", "if", "num_params", "//", "10", "**", "6", ">", "0", ":", "\n", "            ", "return", "str", "(", "round", "(", "num_params", "/", "10", "**", "6", ",", "precision", ")", ")", "+", "' M'", "\n", "", "elif", "num_params", "//", "10", "**", "3", ":", "\n", "            ", "return", "str", "(", "round", "(", "num_params", "/", "10", "**", "3", ",", "precision", ")", ")", "+", "' k'", "\n", "", "else", ":", "\n", "            ", "return", "str", "(", "num_params", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "units", "==", "'M'", ":", "\n", "            ", "return", "str", "(", "round", "(", "num_params", "/", "10.", "**", "6", ",", "precision", ")", ")", "+", "' '", "+", "units", "\n", "", "elif", "units", "==", "'K'", ":", "\n", "            ", "return", "str", "(", "round", "(", "num_params", "/", "10.", "**", "3", ",", "precision", ")", ")", "+", "' '", "+", "units", "\n", "", "else", ":", "\n", "            ", "return", "str", "(", "num_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.print_model_with_flops": [[194, 301], ["model.apply", "print", "model.apply", "flops_counter.is_supported_instance", "flops_counter.is_supported_instance", "flops_counter..accumulate_params", "flops_counter..accumulate_flops", "accumulate_flops.__get__", "accumulate_params.__get__", "flops_repr.__get__", "hasattr", "hasattr", "flops_counter..children", "flops_counter..children", "m.accumulate_params", "m.accumulate_flops", "flops_counter.params_to_string", "flops_counter.flops_to_string", "flops_counter..original_extra_repr"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.is_supported_instance", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.is_supported_instance", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.params_to_string", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.flops_to_string"], ["", "", "", "def", "print_model_with_flops", "(", "model", ",", "\n", "total_flops", ",", "\n", "total_params", ",", "\n", "units", "=", "'GFLOPs'", ",", "\n", "precision", "=", "3", ",", "\n", "ost", "=", "sys", ".", "stdout", ",", "\n", "flush", "=", "False", ")", ":", "\n", "    ", "\"\"\"Print a model with FLOPs for each layer.\n\n    Args:\n        model (nn.Module): The model to be printed.\n        total_flops (float): Total FLOPs of the model.\n        total_params (float): Total parameter counts of the model.\n        units (str | None): Converted FLOPs units. Default: 'GFLOPs'.\n        precision (int): Digit number after the decimal point. Default: 3.\n        ost (stream): same as `file` param in :func:`print`.\n            Default: sys.stdout.\n        flush (bool): same as that in :func:`print`. Default: False.\n\n    Example:\n        >>> class ExampleModel(nn.Module):\n\n        >>> def __init__(self):\n        >>>     super().__init__()\n        >>>     self.conv1 = nn.Conv2d(3, 8, 3)\n        >>>     self.conv2 = nn.Conv2d(8, 256, 3)\n        >>>     self.conv3 = nn.Conv2d(256, 8, 3)\n        >>>     self.avg_pool = nn.AdaptiveAvgPool2d((1, 1))\n        >>>     self.flatten = nn.Flatten()\n        >>>     self.fc = nn.Linear(8, 1)\n\n        >>> def forward(self, x):\n        >>>     x = self.conv1(x)\n        >>>     x = self.conv2(x)\n        >>>     x = self.conv3(x)\n        >>>     x = self.avg_pool(x)\n        >>>     x = self.flatten(x)\n        >>>     x = self.fc(x)\n        >>>     return x\n\n        >>> model = ExampleModel()\n        >>> x = (3, 16, 16)\n        to print the complexity inforamtion state for each layer, you can use\n        >>> get_model_complexity_info(model, x)\n        or directly use\n        >>> print_model_with_flops(model, 4579784.0, 37361)\n        ExampleModel(\n          0.037 M, 100.000% Params, 0.005 GFLOPs, 100.000% FLOPs,\n          (conv1): Conv2d(0.0 M, 0.600% Params, 0.0 GFLOPs, 0.959% FLOPs, 3, 8, kernel_size=(3, 3), stride=(1, 1))  # noqa: E501\n          (conv2): Conv2d(0.019 M, 50.020% Params, 0.003 GFLOPs, 58.760% FLOPs, 8, 256, kernel_size=(3, 3), stride=(1, 1))\n          (conv3): Conv2d(0.018 M, 49.356% Params, 0.002 GFLOPs, 40.264% FLOPs, 256, 8, kernel_size=(3, 3), stride=(1, 1))\n          (avg_pool): AdaptiveAvgPool2d(0.0 M, 0.000% Params, 0.0 GFLOPs, 0.017% FLOPs, output_size=(1, 1))\n          (flatten): Flatten(0.0 M, 0.000% Params, 0.0 GFLOPs, 0.000% FLOPs, )\n          (fc): Linear(0.0 M, 0.024% Params, 0.0 GFLOPs, 0.000% FLOPs, in_features=8, out_features=1, bias=True)\n        )\n    \"\"\"", "\n", "\n", "def", "accumulate_params", "(", "self", ")", ":", "\n", "        ", "if", "is_supported_instance", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "__params__", "\n", "", "else", ":", "\n", "            ", "sum", "=", "0", "\n", "for", "m", "in", "self", ".", "children", "(", ")", ":", "\n", "                ", "sum", "+=", "m", ".", "accumulate_params", "(", ")", "\n", "", "return", "sum", "\n", "\n", "", "", "def", "accumulate_flops", "(", "self", ")", ":", "\n", "        ", "if", "is_supported_instance", "(", "self", ")", ":", "\n", "            ", "return", "self", ".", "__flops__", "/", "model", ".", "__batch_counter__", "\n", "", "else", ":", "\n", "            ", "sum", "=", "0", "\n", "for", "m", "in", "self", ".", "children", "(", ")", ":", "\n", "                ", "sum", "+=", "m", ".", "accumulate_flops", "(", ")", "\n", "", "return", "sum", "\n", "\n", "", "", "def", "flops_repr", "(", "self", ")", ":", "\n", "        ", "accumulated_num_params", "=", "self", ".", "accumulate_params", "(", ")", "\n", "accumulated_flops_cost", "=", "self", ".", "accumulate_flops", "(", ")", "\n", "return", "', '", ".", "join", "(", "[", "\n", "params_to_string", "(", "\n", "accumulated_num_params", ",", "units", "=", "'M'", ",", "precision", "=", "precision", ")", ",", "\n", "'{:.3%} Params'", ".", "format", "(", "accumulated_num_params", "/", "total_params", ")", ",", "\n", "flops_to_string", "(", "\n", "accumulated_flops_cost", ",", "units", "=", "units", ",", "precision", "=", "precision", ")", ",", "\n", "'{:.3%} FLOPs'", ".", "format", "(", "accumulated_flops_cost", "/", "total_flops", ")", ",", "\n", "self", ".", "original_extra_repr", "(", ")", "\n", "]", ")", "\n", "\n", "", "def", "add_extra_repr", "(", "m", ")", ":", "\n", "        ", "m", ".", "accumulate_flops", "=", "accumulate_flops", ".", "__get__", "(", "m", ")", "\n", "m", ".", "accumulate_params", "=", "accumulate_params", ".", "__get__", "(", "m", ")", "\n", "flops_extra_repr", "=", "flops_repr", ".", "__get__", "(", "m", ")", "\n", "if", "m", ".", "extra_repr", "!=", "flops_extra_repr", ":", "\n", "            ", "m", ".", "original_extra_repr", "=", "m", ".", "extra_repr", "\n", "m", ".", "extra_repr", "=", "flops_extra_repr", "\n", "assert", "m", ".", "extra_repr", "!=", "m", ".", "original_extra_repr", "\n", "\n", "", "", "def", "del_extra_repr", "(", "m", ")", ":", "\n", "        ", "if", "hasattr", "(", "m", ",", "'original_extra_repr'", ")", ":", "\n", "            ", "m", ".", "extra_repr", "=", "m", ".", "original_extra_repr", "\n", "del", "m", ".", "original_extra_repr", "\n", "", "if", "hasattr", "(", "m", ",", "'accumulate_flops'", ")", ":", "\n", "            ", "del", "m", ".", "accumulate_flops", "\n", "\n", "", "", "model", ".", "apply", "(", "add_extra_repr", ")", "\n", "print", "(", "model", ",", "file", "=", "ost", ",", "flush", "=", "flush", ")", "\n", "model", ".", "apply", "(", "del_extra_repr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.get_model_parameters_number": [[303, 314], ["sum", "p.numel", "model.parameters"], "function", ["None"], ["", "def", "get_model_parameters_number", "(", "model", ")", ":", "\n", "    ", "\"\"\"Calculate parameter number of a model.\n\n    Args:\n        model (nn.module): The model for parameter number calculation.\n\n    Returns:\n        float: Parameter number of the model.\n    \"\"\"", "\n", "num_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "return", "num_params", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.add_flops_counting_methods": [[316, 331], ["start_flops_count.__get__", "stop_flops_count.__get__", "reset_flops_count.__get__", "compute_average_flops_cost.__get__", "net_main_module.reset_flops_count"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.reset_flops_count"], ["", "def", "add_flops_counting_methods", "(", "net_main_module", ")", ":", "\n", "# adding additional methods to the existing module object,", "\n", "# this is done this way so that each function has access to self object", "\n", "    ", "net_main_module", ".", "start_flops_count", "=", "start_flops_count", ".", "__get__", "(", "\n", "net_main_module", ")", "\n", "net_main_module", ".", "stop_flops_count", "=", "stop_flops_count", ".", "__get__", "(", "\n", "net_main_module", ")", "\n", "net_main_module", ".", "reset_flops_count", "=", "reset_flops_count", ".", "__get__", "(", "\n", "net_main_module", ")", "\n", "net_main_module", ".", "compute_average_flops_cost", "=", "compute_average_flops_cost", ".", "__get__", "(", "# noqa: E501", "\n", "net_main_module", ")", "\n", "\n", "net_main_module", ".", "reset_flops_count", "(", ")", "\n", "\n", "return", "net_main_module", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.compute_average_flops_cost": [[333, 349], ["flops_counter..modules", "flops_counter.get_model_parameters_number", "flops_counter.is_supported_instance"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.get_model_parameters_number", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.is_supported_instance"], ["", "def", "compute_average_flops_cost", "(", "self", ")", ":", "\n", "    ", "\"\"\"Compute average FLOPs cost.\n\n    A method to compute average FLOPs cost, which will be available after\n    `add_flops_counting_methods()` is called on a desired net object.\n\n    Returns:\n        float: Current mean flops consumption per image.\n    \"\"\"", "\n", "batches_count", "=", "self", ".", "__batch_counter__", "\n", "flops_sum", "=", "0", "\n", "for", "module", "in", "self", ".", "modules", "(", ")", ":", "\n", "        ", "if", "is_supported_instance", "(", "module", ")", ":", "\n", "            ", "flops_sum", "+=", "module", ".", "__flops__", "\n", "", "", "params_sum", "=", "get_model_parameters_number", "(", "self", ")", "\n", "return", "flops_sum", "/", "batches_count", ",", "params_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.start_flops_count": [[351, 372], ["flops_counter.add_batch_counter_hook_function", "flops_counter..apply", "flops_counter.is_supported_instance", "functools.partial", "hasattr", "module.register_forward_hook", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.add_batch_counter_hook_function", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.is_supported_instance"], ["", "def", "start_flops_count", "(", "self", ")", ":", "\n", "    ", "\"\"\"Activate the computation of mean flops consumption per image.\n\n    A method to activate the computation of mean flops consumption per image.\n    which will be available after `add_flops_counting_methods()` is called on a\n    desired net object. It should be called before running the network.\n    \"\"\"", "\n", "add_batch_counter_hook_function", "(", "self", ")", "\n", "\n", "def", "add_flops_counter_hook_function", "(", "module", ")", ":", "\n", "        ", "if", "is_supported_instance", "(", "module", ")", ":", "\n", "            ", "if", "hasattr", "(", "module", ",", "'__flops_handle__'", ")", ":", "\n", "                ", "return", "\n", "\n", "", "else", ":", "\n", "                ", "handle", "=", "module", ".", "register_forward_hook", "(", "\n", "MODULES_MAPPING", "[", "type", "(", "module", ")", "]", ")", "\n", "\n", "", "module", ".", "__flops_handle__", "=", "handle", "\n", "\n", "", "", "self", ".", "apply", "(", "partial", "(", "add_flops_counter_hook_function", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.stop_flops_count": [[374, 383], ["flops_counter.remove_batch_counter_hook_function", "flops_counter..apply"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.remove_batch_counter_hook_function"], ["", "def", "stop_flops_count", "(", "self", ")", ":", "\n", "    ", "\"\"\"Stop computing the mean flops consumption per image.\n\n    A method to stop computing the mean flops consumption per image, which will\n    be available after `add_flops_counting_methods()` is called on a desired\n    net object. It can be called to pause the computation whenever.\n    \"\"\"", "\n", "remove_batch_counter_hook_function", "(", "self", ")", "\n", "self", ".", "apply", "(", "remove_flops_counter_hook_function", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.reset_flops_count": [[385, 393], ["flops_counter.add_batch_counter_variables_or_reset", "flops_counter..apply"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.add_batch_counter_variables_or_reset"], ["", "def", "reset_flops_count", "(", "self", ")", ":", "\n", "    ", "\"\"\"Reset statistics computed so far.\n\n    A method to Reset computed statistics, which will be available after\n    `add_flops_counting_methods()` is called on a desired net object.\n    \"\"\"", "\n", "add_batch_counter_variables_or_reset", "(", "self", ")", "\n", "self", ".", "apply", "(", "add_flops_counter_variable_or_reset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.empty_flops_counter_hook": [[396, 398], ["None"], "function", ["None"], ["", "def", "empty_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "module", ".", "__flops__", "+=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.upsample_flops_counter_hook": [[400, 407], ["int"], "function", ["None"], ["", "def", "upsample_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "output_size", "=", "output", "[", "0", "]", "\n", "batch_size", "=", "output_size", ".", "shape", "[", "0", "]", "\n", "output_elements_count", "=", "batch_size", "\n", "for", "val", "in", "output_size", ".", "shape", "[", "1", ":", "]", ":", "\n", "        ", "output_elements_count", "*=", "val", "\n", "", "module", ".", "__flops__", "+=", "int", "(", "output_elements_count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.relu_flops_counter_hook": [[409, 412], ["output.numel", "int"], "function", ["None"], ["", "def", "relu_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "active_elements_count", "=", "output", ".", "numel", "(", ")", "\n", "module", ".", "__flops__", "+=", "int", "(", "active_elements_count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.linear_flops_counter_hook": [[414, 419], ["int", "numpy.prod"], "function", ["None"], ["", "def", "linear_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "output_last_dim", "=", "output", ".", "shape", "[", "\n", "-", "1", "]", "# pytorch checks dimensions, so here we don't care much", "\n", "module", ".", "__flops__", "+=", "int", "(", "np", ".", "prod", "(", "input", ".", "shape", ")", "*", "output_last_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.pool_flops_counter_hook": [[421, 424], ["int", "numpy.prod"], "function", ["None"], ["", "def", "pool_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "module", ".", "__flops__", "+=", "int", "(", "np", ".", "prod", "(", "input", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.bn_flops_counter_hook": [[426, 433], ["numpy.prod", "int"], "function", ["None"], ["", "def", "bn_flops_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "\n", "batch_flops", "=", "np", ".", "prod", "(", "input", ".", "shape", ")", "\n", "if", "module", ".", "affine", ":", "\n", "        ", "batch_flops", "*=", "2", "\n", "", "module", ".", "__flops__", "+=", "int", "(", "batch_flops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.deconv_flops_counter_hook": [[435, 460], ["int"], "function", ["None"], ["", "def", "deconv_flops_counter_hook", "(", "conv_module", ",", "input", ",", "output", ")", ":", "\n", "# Can have multiple inputs, getting the first one", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "\n", "batch_size", "=", "input", ".", "shape", "[", "0", "]", "\n", "input_height", ",", "input_width", "=", "input", ".", "shape", "[", "2", ":", "]", "\n", "\n", "kernel_height", ",", "kernel_width", "=", "conv_module", ".", "kernel_size", "\n", "in_channels", "=", "conv_module", ".", "in_channels", "\n", "out_channels", "=", "conv_module", ".", "out_channels", "\n", "groups", "=", "conv_module", ".", "groups", "\n", "\n", "filters_per_channel", "=", "out_channels", "//", "groups", "\n", "conv_per_position_flops", "=", "(", "\n", "kernel_height", "*", "kernel_width", "*", "in_channels", "*", "filters_per_channel", ")", "\n", "\n", "active_elements_count", "=", "batch_size", "*", "input_height", "*", "input_width", "\n", "overall_conv_flops", "=", "conv_per_position_flops", "*", "active_elements_count", "\n", "bias_flops", "=", "0", "\n", "if", "conv_module", ".", "bias", "is", "not", "None", ":", "\n", "        ", "output_height", ",", "output_width", "=", "output", ".", "shape", "[", "2", ":", "]", "\n", "bias_flops", "=", "out_channels", "*", "batch_size", "*", "output_height", "*", "output_height", "\n", "", "overall_flops", "=", "overall_conv_flops", "+", "bias_flops", "\n", "\n", "conv_module", ".", "__flops__", "+=", "int", "(", "overall_flops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.conv_flops_counter_hook": [[462, 491], ["list", "list", "int", "int", "int", "numpy.prod", "numpy.prod"], "function", ["None"], ["", "def", "conv_flops_counter_hook", "(", "conv_module", ",", "input", ",", "output", ")", ":", "\n", "# Can have multiple inputs, getting the first one", "\n", "    ", "input", "=", "input", "[", "0", "]", "\n", "\n", "batch_size", "=", "input", ".", "shape", "[", "0", "]", "\n", "output_dims", "=", "list", "(", "output", ".", "shape", "[", "2", ":", "]", ")", "\n", "\n", "kernel_dims", "=", "list", "(", "conv_module", ".", "kernel_size", ")", "\n", "in_channels", "=", "conv_module", ".", "in_channels", "\n", "out_channels", "=", "conv_module", ".", "out_channels", "\n", "groups", "=", "conv_module", ".", "groups", "\n", "\n", "filters_per_channel", "=", "out_channels", "//", "groups", "\n", "conv_per_position_flops", "=", "int", "(", "\n", "np", ".", "prod", "(", "kernel_dims", ")", ")", "*", "in_channels", "*", "filters_per_channel", "\n", "\n", "active_elements_count", "=", "batch_size", "*", "int", "(", "np", ".", "prod", "(", "output_dims", ")", ")", "\n", "\n", "overall_conv_flops", "=", "conv_per_position_flops", "*", "active_elements_count", "\n", "\n", "bias_flops", "=", "0", "\n", "\n", "if", "conv_module", ".", "bias", "is", "not", "None", ":", "\n", "\n", "        ", "bias_flops", "=", "out_channels", "*", "active_elements_count", "\n", "\n", "", "overall_flops", "=", "overall_conv_flops", "+", "bias_flops", "\n", "\n", "conv_module", ".", "__flops__", "+=", "int", "(", "overall_flops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.batch_counter_hook": [[493, 504], ["len", "len", "print"], "function", ["None"], ["", "def", "batch_counter_hook", "(", "module", ",", "input", ",", "output", ")", ":", "\n", "    ", "batch_size", "=", "1", "\n", "if", "len", "(", "input", ")", ">", "0", ":", "\n", "# Can have multiple inputs, getting the first one", "\n", "        ", "input", "=", "input", "[", "0", "]", "\n", "batch_size", "=", "len", "(", "input", ")", "\n", "", "else", ":", "\n", "        ", "pass", "\n", "print", "(", "'Warning! No positional inputs found for a module, '", "\n", "'assuming batch size is 1.'", ")", "\n", "", "module", ".", "__batch_counter__", "+=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.add_batch_counter_variables_or_reset": [[506, 509], ["None"], "function", ["None"], ["", "def", "add_batch_counter_variables_or_reset", "(", "module", ")", ":", "\n", "\n", "    ", "module", ".", "__batch_counter__", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.add_batch_counter_hook_function": [[511, 517], ["hasattr", "module.register_forward_hook"], "function", ["None"], ["", "def", "add_batch_counter_hook_function", "(", "module", ")", ":", "\n", "    ", "if", "hasattr", "(", "module", ",", "'__batch_counter_handle__'", ")", ":", "\n", "        ", "return", "\n", "\n", "", "handle", "=", "module", ".", "register_forward_hook", "(", "batch_counter_hook", ")", "\n", "module", ".", "__batch_counter_handle__", "=", "handle", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.remove_batch_counter_hook_function": [[519, 523], ["hasattr", "module.__batch_counter_handle__.remove"], "function", ["None"], ["", "def", "remove_batch_counter_hook_function", "(", "module", ")", ":", "\n", "    ", "if", "hasattr", "(", "module", ",", "'__batch_counter_handle__'", ")", ":", "\n", "        ", "module", ".", "__batch_counter_handle__", ".", "remove", "(", ")", "\n", "del", "module", ".", "__batch_counter_handle__", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.add_flops_counter_variable_or_reset": [[525, 533], ["flops_counter.is_supported_instance", "flops_counter.get_model_parameters_number", "hasattr", "hasattr", "print", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.is_supported_instance", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.get_model_parameters_number"], ["", "", "def", "add_flops_counter_variable_or_reset", "(", "module", ")", ":", "\n", "    ", "if", "is_supported_instance", "(", "module", ")", ":", "\n", "        ", "if", "hasattr", "(", "module", ",", "'__flops__'", ")", "or", "hasattr", "(", "module", ",", "'__params__'", ")", ":", "\n", "            ", "print", "(", "'Warning: variables __flops__ or __params__ are already '", "\n", "'defined for the module'", "+", "type", "(", "module", ")", ".", "__name__", "+", "\n", "' ptflops can affect your code!'", ")", "\n", "", "module", ".", "__flops__", "=", "0", "\n", "module", ".", "__params__", "=", "get_model_parameters_number", "(", "module", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.is_supported_instance": [[535, 539], ["type"], "function", ["None"], ["", "", "def", "is_supported_instance", "(", "module", ")", ":", "\n", "    ", "if", "type", "(", "module", ")", "in", "MODULES_MAPPING", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.remove_flops_counter_hook_function": [[541, 546], ["flops_counter.is_supported_instance", "hasattr", "module.__flops_handle__.remove"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.flops_counter.is_supported_instance"], ["", "def", "remove_flops_counter_hook_function", "(", "module", ")", ":", "\n", "    ", "if", "is_supported_instance", "(", "module", ")", ":", "\n", "        ", "if", "hasattr", "(", "module", ",", "'__flops_handle__'", ")", ":", "\n", "            ", "module", ".", "__flops_handle__", ".", "remove", "(", ")", "\n", "del", "module", ".", "__flops_handle__", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.constant_init": [[6, 11], ["hasattr", "torch.init.constant_", "hasattr", "torch.init.constant_"], "function", ["None"], ["def", "constant_init", "(", "module", ",", "val", ",", "bias", "=", "0", ")", ":", "\n", "    ", "if", "hasattr", "(", "module", ",", "'weight'", ")", "and", "module", ".", "weight", "is", "not", "None", ":", "\n", "        ", "nn", ".", "init", ".", "constant_", "(", "module", ".", "weight", ",", "val", ")", "\n", "", "if", "hasattr", "(", "module", ",", "'bias'", ")", "and", "module", ".", "bias", "is", "not", "None", ":", "\n", "        ", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.xavier_init": [[13, 21], ["torch.init.xavier_uniform_", "torch.init.xavier_normal_", "hasattr", "torch.init.constant_"], "function", ["None"], ["", "", "def", "xavier_init", "(", "module", ",", "gain", "=", "1", ",", "bias", "=", "0", ",", "distribution", "=", "'normal'", ")", ":", "\n", "    ", "assert", "distribution", "in", "[", "'uniform'", ",", "'normal'", "]", "\n", "if", "distribution", "==", "'uniform'", ":", "\n", "        ", "nn", ".", "init", ".", "xavier_uniform_", "(", "module", ".", "weight", ",", "gain", "=", "gain", ")", "\n", "", "else", ":", "\n", "        ", "nn", ".", "init", ".", "xavier_normal_", "(", "module", ".", "weight", ",", "gain", "=", "gain", ")", "\n", "", "if", "hasattr", "(", "module", ",", "'bias'", ")", "and", "module", ".", "bias", "is", "not", "None", ":", "\n", "        ", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init": [[23, 27], ["torch.init.normal_", "hasattr", "torch.init.constant_"], "function", ["None"], ["", "", "def", "normal_init", "(", "module", ",", "mean", "=", "0", ",", "std", "=", "1", ",", "bias", "=", "0", ")", ":", "\n", "    ", "nn", ".", "init", ".", "normal_", "(", "module", ".", "weight", ",", "mean", ",", "std", ")", "\n", "if", "hasattr", "(", "module", ",", "'bias'", ")", "and", "module", ".", "bias", "is", "not", "None", ":", "\n", "        ", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.uniform_init": [[29, 33], ["torch.init.uniform_", "hasattr", "torch.init.constant_"], "function", ["None"], ["", "", "def", "uniform_init", "(", "module", ",", "a", "=", "0", ",", "b", "=", "1", ",", "bias", "=", "0", ")", ":", "\n", "    ", "nn", ".", "init", ".", "uniform_", "(", "module", ".", "weight", ",", "a", ",", "b", ")", "\n", "if", "hasattr", "(", "module", ",", "'bias'", ")", "and", "module", ".", "bias", "is", "not", "None", ":", "\n", "        ", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.kaiming_init": [[35, 50], ["torch.init.kaiming_uniform_", "torch.init.kaiming_normal_", "hasattr", "torch.init.constant_"], "function", ["None"], ["", "", "def", "kaiming_init", "(", "module", ",", "\n", "a", "=", "0", ",", "\n", "mode", "=", "'fan_out'", ",", "\n", "nonlinearity", "=", "'relu'", ",", "\n", "bias", "=", "0", ",", "\n", "distribution", "=", "'normal'", ")", ":", "\n", "    ", "assert", "distribution", "in", "[", "'uniform'", ",", "'normal'", "]", "\n", "if", "distribution", "==", "'uniform'", ":", "\n", "        ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "\n", "module", ".", "weight", ",", "a", "=", "a", ",", "mode", "=", "mode", ",", "nonlinearity", "=", "nonlinearity", ")", "\n", "", "else", ":", "\n", "        ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "module", ".", "weight", ",", "a", "=", "a", ",", "mode", "=", "mode", ",", "nonlinearity", "=", "nonlinearity", ")", "\n", "", "if", "hasattr", "(", "module", ",", "'bias'", ")", "and", "module", ".", "bias", "is", "not", "None", ":", "\n", "        ", "nn", ".", "init", ".", "constant_", "(", "module", ".", "bias", ",", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.caffe2_xavier_init": [[52, 61], ["weight_init.kaiming_init"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.kaiming_init"], ["", "", "def", "caffe2_xavier_init", "(", "module", ",", "bias", "=", "0", ")", ":", "\n", "# `XavierFill` in Caffe2 corresponds to `kaiming_uniform_` in PyTorch", "\n", "# Acknowledgment to FAIR's internal code", "\n", "    ", "kaiming_init", "(", "\n", "module", ",", "\n", "a", "=", "1", ",", "\n", "mode", "=", "'fan_in'", ",", "\n", "nonlinearity", "=", "'leaky_relu'", ",", "\n", "distribution", "=", "'uniform'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.bias_init_with_prob": [[63, 67], ["float", "numpy.log"], "function", ["None"], ["", "def", "bias_init_with_prob", "(", "prior_prob", ")", ":", "\n", "    ", "\"\"\"initialize conv/fc bias value according to giving probablity.\"\"\"", "\n", "bias_init", "=", "float", "(", "-", "np", ".", "log", "(", "(", "1", "-", "prior_prob", ")", "/", "prior_prob", ")", ")", "\n", "return", "bias_init", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.res_layer.ResLayer.__init__": [[27, 106], ["dict", "torch.nn.Sequential.__init__", "torch.nn.Sequential.extend", "torch.nn.Sequential", "layers.append", "range", "range", "layers.append", "torch.nn.Sequential.append", "block", "layers.append", "layers.append", "block", "torch.nn.AvgPool2d", "vedacore.modules.build_conv_layer", "block", "block", "vedacore.modules.build_norm_layer"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.conv.build_conv_layer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.norm.build_norm_layer"], ["def", "__init__", "(", "self", ",", "\n", "block", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "num_blocks", ",", "\n", "stride", "=", "1", ",", "\n", "avg_down", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "downsample_first", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "block", "=", "block", "\n", "\n", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "[", "]", "\n", "conv_stride", "=", "stride", "\n", "if", "avg_down", "and", "stride", "!=", "1", ":", "\n", "                ", "conv_stride", "=", "1", "\n", "downsample", ".", "append", "(", "\n", "nn", ".", "AvgPool2d", "(", "\n", "kernel_size", "=", "stride", ",", "\n", "stride", "=", "stride", ",", "\n", "ceil_mode", "=", "True", ",", "\n", "count_include_pad", "=", "False", ")", ")", "\n", "", "downsample", ".", "extend", "(", "[", "\n", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "conv_stride", ",", "\n", "bias", "=", "False", ")", ",", "\n", "build_norm_layer", "(", "norm_cfg", ",", "planes", "*", "block", ".", "expansion", ")", "[", "1", "]", "\n", "]", ")", "\n", "downsample", "=", "nn", ".", "Sequential", "(", "*", "downsample", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "if", "downsample_first", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "num_blocks", ")", ":", "\n", "                ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "\n", "", "", "else", ":", "# downsample_first=False is for HourglassModule", "\n", "            ", "for", "_", "in", "range", "(", "num_blocks", "-", "1", ")", ":", "\n", "                ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "inplanes", ",", "\n", "stride", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", "=", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "stride", "=", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "**", "kwargs", ")", ")", "\n", "", "super", "(", "ResLayer", ",", "self", ")", ".", "__init__", "(", "*", "layers", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.activation.build_activation_layer": [[12, 24], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["", "def", "build_activation_layer", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"Build activation layer.\n\n    Args:\n        cfg (dict): The activation layer config, which should contain:\n            - type (str): Layer type.\n            - layer args: Args needed to instantiate an activation layer.\n\n    Returns:\n        nn.Module: Created activation layer.\n    \"\"\"", "\n", "return", "build_from_cfg", "(", "cfg", ",", "registry", ",", "'activation'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.non_local._NonLocalNd.__init__": [[33, 82], ["torch.Module.__init__", "conv_module.ConvModule", "conv_module.ConvModule", "conv_module.ConvModule", "conv_module.ConvModule", "non_local._NonLocalNd.init_weights", "ValueError"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "reduction", "=", "2", ",", "\n", "use_scale", "=", "True", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "mode", "=", "'embedded_gaussian'", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "_NonLocalNd", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "use_scale", "=", "use_scale", "\n", "self", ".", "inter_channels", "=", "in_channels", "//", "reduction", "\n", "self", ".", "mode", "=", "mode", "\n", "\n", "if", "mode", "not", "in", "[", "'embedded_gaussian'", ",", "'dot_product'", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Mode should be in 'embedded_gaussian' or 'dot_product', \"", "\n", "f'but got {mode} instead.'", ")", "\n", "\n", "# g, theta, phi are defaulted as `nn.ConvNd`.", "\n", "# Here we use ConvModule for potential usage.", "\n", "", "self", ".", "g", "=", "ConvModule", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "self", ".", "theta", "=", "ConvModule", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "self", ".", "phi", "=", "ConvModule", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "self", ".", "conv_out", "=", "ConvModule", "(", "\n", "self", ".", "inter_channels", ",", "\n", "self", ".", "in_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "\n", "self", ".", "init_weights", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.non_local._NonLocalNd.init_weights": [[83, 96], ["utils.normal_init", "utils.constant_init", "utils.constant_init", "utils.normal_init", "utils.normal_init"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.constant_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.constant_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init"], ["", "def", "init_weights", "(", "self", ",", "std", "=", "0.01", ",", "zeros_init", "=", "True", ")", ":", "\n", "        ", "for", "m", "in", "[", "self", ".", "g", ",", "self", ".", "theta", ",", "self", ".", "phi", "]", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "std", ")", "\n", "", "if", "zeros_init", ":", "\n", "            ", "if", "self", ".", "conv_out", ".", "norm_cfg", "is", "None", ":", "\n", "                ", "constant_init", "(", "self", ".", "conv_out", ".", "conv", ",", "0", ")", "\n", "", "else", ":", "\n", "                ", "constant_init", "(", "self", ".", "conv_out", ".", "norm", ",", "0", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "self", ".", "conv_out", ".", "norm_cfg", "is", "None", ":", "\n", "                ", "normal_init", "(", "self", ".", "conv_out", ".", "conv", ",", "std", "=", "std", ")", "\n", "", "else", ":", "\n", "                ", "normal_init", "(", "self", ".", "conv_out", ".", "norm", ",", "std", "=", "std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.non_local._NonLocalNd.embedded_gaussian": [[97, 107], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "pairwise_weight.softmax.softmax.softmax"], "methods", ["None"], ["", "", "", "def", "embedded_gaussian", "(", "self", ",", "theta_x", ",", "phi_x", ")", ":", "\n", "# NonLocal1d pairwise_weight: [N, H, H]", "\n", "# NonLocal2d pairwise_weight: [N, HxW, HxW]", "\n", "# NonLocal3d pairwise_weight: [N, TxHxW, TxHxW]", "\n", "        ", "pairwise_weight", "=", "torch", ".", "matmul", "(", "theta_x", ",", "phi_x", ")", "\n", "if", "self", ".", "use_scale", ":", "\n", "# theta_x.shape[-1] is `self.inter_channels`", "\n", "            ", "pairwise_weight", "/=", "theta_x", ".", "shape", "[", "-", "1", "]", "**", "0.5", "\n", "", "pairwise_weight", "=", "pairwise_weight", ".", "softmax", "(", "dim", "=", "-", "1", ")", "\n", "return", "pairwise_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.non_local._NonLocalNd.dot_product": [[108, 115], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul"], "methods", ["None"], ["", "def", "dot_product", "(", "self", ",", "theta_x", ",", "phi_x", ")", ":", "\n", "# NonLocal1d pairwise_weight: [N, H, H]", "\n", "# NonLocal2d pairwise_weight: [N, HxW, HxW]", "\n", "# NonLocal3d pairwise_weight: [N, TxHxW, TxHxW]", "\n", "        ", "pairwise_weight", "=", "torch", ".", "matmul", "(", "theta_x", ",", "phi_x", ")", "\n", "pairwise_weight", "/=", "pairwise_weight", ".", "shape", "[", "-", "1", "]", "\n", "return", "pairwise_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.non_local._NonLocalNd.forward": [[116, 159], ["x.size", "non_local._NonLocalNd.g().view", "g_x.permute.permute.permute", "non_local._NonLocalNd.theta().view", "theta_x.permute.permute.permute", "non_local._NonLocalNd.phi().view", "getattr", "getattr.", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "y.permute().contiguous().reshape.permute().contiguous().reshape.permute().contiguous().reshape", "non_local._NonLocalNd.conv_out", "non_local._NonLocalNd.g", "non_local._NonLocalNd.theta", "non_local._NonLocalNd.phi", "y.permute().contiguous().reshape.permute().contiguous().reshape.permute().contiguous", "x.size", "y.permute().contiguous().reshape.permute().contiguous().reshape.permute"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# Assume `reduction = 1`, then `inter_channels = C`", "\n", "# NonLocal1d x: [N, C, H]", "\n", "# NonLocal2d x: [N, C, H, W]", "\n", "# NonLocal3d x: [N, C, T, H, W]", "\n", "        ", "n", "=", "x", ".", "size", "(", "0", ")", "\n", "\n", "# NonLocal1d g_x: [N, H, C]", "\n", "# NonLocal2d g_x: [N, HxW, C]", "\n", "# NonLocal3d g_x: [N, TxHxW, C]", "\n", "g_x", "=", "self", ".", "g", "(", "x", ")", ".", "view", "(", "n", ",", "self", ".", "inter_channels", ",", "-", "1", ")", "\n", "g_x", "=", "g_x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n", "# NonLocal1d theta_x: [N, H, C]", "\n", "# NonLocal2d theta_x: [N, HxW, C]", "\n", "# NonLocal3d theta_x: [N, TxHxW, C]", "\n", "theta_x", "=", "self", ".", "theta", "(", "x", ")", ".", "view", "(", "n", ",", "self", ".", "inter_channels", ",", "-", "1", ")", "\n", "theta_x", "=", "theta_x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n", "# NonLocal1d phi_x: [N, C, H]", "\n", "# NonLocal2d phi_x: [N, C, HxW]", "\n", "# NonLocal3d phi_x: [N, C, TxHxW]", "\n", "phi_x", "=", "self", ".", "phi", "(", "x", ")", ".", "view", "(", "n", ",", "self", ".", "inter_channels", ",", "-", "1", ")", "\n", "\n", "pairwise_func", "=", "getattr", "(", "self", ",", "self", ".", "mode", ")", "\n", "# NonLocal1d pairwise_weight: [N, H, H]", "\n", "# NonLocal2d pairwise_weight: [N, HxW, HxW]", "\n", "# NonLocal3d pairwise_weight: [N, TxHxW, TxHxW]", "\n", "pairwise_weight", "=", "pairwise_func", "(", "theta_x", ",", "phi_x", ")", "\n", "\n", "# NonLocal1d y: [N, H, C]", "\n", "# NonLocal2d y: [N, HxW, C]", "\n", "# NonLocal3d y: [N, TxHxW, C]", "\n", "y", "=", "torch", ".", "matmul", "(", "pairwise_weight", ",", "g_x", ")", "\n", "# NonLocal1d y: [N, C, H]", "\n", "# NonLocal2d y: [N, C, H, W]", "\n", "# NonLocal3d y: [N, C, T, H, W]", "\n", "y", "=", "y", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", ".", "reshape", "(", "n", ",", "self", ".", "inter_channels", ",", "\n", "*", "x", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "\n", "output", "=", "x", "+", "self", ".", "conv_out", "(", "y", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.non_local.NonLocal1d.__init__": [[174, 188], ["dict", "non_local._NonLocalNd.__init__", "torch.MaxPool1d", "torch.MaxPool1d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "sub_sample", "=", "False", ",", "\n", "conv_cfg", "=", "dict", "(", "typename", "=", "'Conv1d'", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "NonLocal1d", ",", "self", ")", ".", "__init__", "(", "\n", "in_channels", ",", "conv_cfg", "=", "conv_cfg", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "sub_sample", "=", "sub_sample", "\n", "\n", "if", "sub_sample", ":", "\n", "            ", "max_pool_layer", "=", "nn", ".", "MaxPool1d", "(", "kernel_size", "=", "2", ")", "\n", "self", ".", "g", "=", "nn", ".", "Sequential", "(", "self", ".", "g", ",", "max_pool_layer", ")", "\n", "self", ".", "phi", "=", "nn", ".", "Sequential", "(", "self", ".", "phi", ",", "max_pool_layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.non_local.NonLocal2d.__init__": [[203, 217], ["dict", "non_local._NonLocalNd.__init__", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "sub_sample", "=", "False", ",", "\n", "conv_cfg", "=", "dict", "(", "typename", "=", "'Conv2d'", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "NonLocal2d", ",", "self", ")", ".", "__init__", "(", "\n", "in_channels", ",", "conv_cfg", "=", "conv_cfg", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "sub_sample", "=", "sub_sample", "\n", "\n", "if", "sub_sample", ":", "\n", "            ", "max_pool_layer", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "(", "2", ",", "2", ")", ")", "\n", "self", ".", "g", "=", "nn", ".", "Sequential", "(", "self", ".", "g", ",", "max_pool_layer", ")", "\n", "self", ".", "phi", "=", "nn", ".", "Sequential", "(", "self", ".", "phi", ",", "max_pool_layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.non_local.NonLocal3d.__init__": [[232, 245], ["dict", "non_local._NonLocalNd.__init__", "torch.MaxPool3d", "torch.MaxPool3d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "sub_sample", "=", "False", ",", "\n", "conv_cfg", "=", "dict", "(", "typename", "=", "'Conv3d'", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "NonLocal3d", ",", "self", ")", ".", "__init__", "(", "\n", "in_channels", ",", "conv_cfg", "=", "conv_cfg", ",", "**", "kwargs", ")", "\n", "self", ".", "sub_sample", "=", "sub_sample", "\n", "\n", "if", "sub_sample", ":", "\n", "            ", "max_pool_layer", "=", "nn", ".", "MaxPool3d", "(", "kernel_size", "=", "(", "1", ",", "2", ",", "2", ")", ")", "\n", "self", ".", "g", "=", "nn", ".", "Sequential", "(", "self", ".", "g", ",", "max_pool_layer", ")", "\n", "self", ".", "phi", "=", "nn", ".", "Sequential", "(", "self", ".", "phi", ",", "max_pool_layer", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.hsigmoid.HSigmoid.__init__": [[15, 17], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "HSigmoid", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.hsigmoid.HSigmoid.forward": [[18, 22], ["x.clamp_"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "(", "x", "+", "1", ")", "/", "2", "\n", "\n", "return", "x", ".", "clamp_", "(", "0", ",", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.norm.infer_abbr": [[25, 72], ["hasattr", "issubclass", "inspect.isclass", "TypeError", "issubclass", "issubclass", "issubclass", "type", "class_type.__name__.lower"], "function", ["None"], ["def", "infer_abbr", "(", "class_type", ")", ":", "\n", "    ", "\"\"\"Infer abbreviation from the class name.\n\n    When we build a norm layer with `build_norm_layer()`, we want to preserve\n    the norm type in variable names, e.g, self.bn1, self.gn. This method will\n    infer the abbreviation to map class types to abbreviations.\n\n    Rule 1: If the class has the property \"abbr\", return the property.\n    Rule 2: If the parent class is _BatchNorm, GroupNorm, LayerNorm or\n    InstanceNorm, the abbreviation of this layer will be \"bn\", \"gn\", \"ln\" and\n    \"in\" respectively.\n    Rule 3: If the class name contains \"batch\", \"group\", \"layer\" or \"instance\",\n    the abbreviation of this layer will be \"bn\", \"gn\", \"ln\" and \"in\"\n    respectively.\n    Rule 4: Otherwise, the abbreviation falls back to \"norm\".\n\n    Args:\n        class_type (type): The norm layer type.\n\n    Returns:\n        str: The inferred abbreviation.\n    \"\"\"", "\n", "if", "not", "inspect", ".", "isclass", "(", "class_type", ")", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "f'class_type must be a type, but got {type(class_type)}'", ")", "\n", "", "if", "hasattr", "(", "class_type", ",", "'abbr'", ")", ":", "\n", "        ", "return", "class_type", ".", "abbr", "\n", "", "if", "issubclass", "(", "class_type", ",", "_InstanceNorm", ")", ":", "# IN is a subclass of BN", "\n", "        ", "return", "'in'", "\n", "", "elif", "issubclass", "(", "class_type", ",", "_BatchNorm", ")", ":", "\n", "        ", "return", "'bn'", "\n", "", "elif", "issubclass", "(", "class_type", ",", "nn", ".", "GroupNorm", ")", ":", "\n", "        ", "return", "'gn'", "\n", "", "elif", "issubclass", "(", "class_type", ",", "nn", ".", "LayerNorm", ")", ":", "\n", "        ", "return", "'ln'", "\n", "", "else", ":", "\n", "        ", "class_name", "=", "class_type", ".", "__name__", ".", "lower", "(", ")", "\n", "if", "'batch'", "in", "class_name", ":", "\n", "            ", "return", "'bn'", "\n", "", "elif", "'group'", "in", "class_name", ":", "\n", "            ", "return", "'gn'", "\n", "", "elif", "'layer'", "in", "class_name", ":", "\n", "            ", "return", "'ln'", "\n", "", "elif", "'instance'", "in", "class_name", ":", "\n", "            ", "return", "'in'", "\n", "", "else", ":", "\n", "            ", "return", "'norm'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.norm.build_norm_layer": [[74, 122], ["cfg.copy", "cfg.copy.pop", "NORM_LAYERS.get", "norm.infer_abbr", "isinstance", "cfg.copy.pop", "cfg.copy.setdefault", "norm_layer.parameters", "isinstance", "TypeError", "KeyError", "KeyError", "str", "NORM_LAYERS.get.", "NORM_LAYERS.get.", "norm_layer._specify_ddp_gpu_num"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.norm.infer_abbr"], ["", "", "", "def", "build_norm_layer", "(", "cfg", ",", "num_features", ",", "postfix", "=", "''", ")", ":", "\n", "    ", "\"\"\"Build normalization layer.\n\n    Args:\n        cfg (dict): The norm layer config, which should contain:\n            - type (str): Layer type.\n            - layer args: Args needed to instantiate a norm layer.\n            - requires_grad (bool, optional): Whether stop gradient updates.\n        num_features (int): Number of input channels.\n        postfix (int | str): The postfix to be appended into norm abbreviation\n            to create named layer.\n\n    Returns:\n        tuple[str, nn.Module]:\n            name (str): The layer name consisting of abbreviation and postfix,\n                e.g., bn1, gn.\n            layer (nn.Module): Created norm layer.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "cfg", ",", "dict", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'cfg must be a dict'", ")", "\n", "", "if", "'typename'", "not", "in", "cfg", ":", "\n", "        ", "raise", "KeyError", "(", "'the cfg dict must contain the key \"typename\"'", ")", "\n", "", "cfg_", "=", "cfg", ".", "copy", "(", ")", "\n", "\n", "layer_type", "=", "cfg_", ".", "pop", "(", "'typename'", ")", "\n", "if", "layer_type", "not", "in", "NORM_LAYERS", ":", "\n", "        ", "raise", "KeyError", "(", "f'Unrecognized norm type {layer_type}'", ")", "\n", "\n", "", "norm_layer", "=", "NORM_LAYERS", ".", "get", "(", "layer_type", ")", "\n", "abbr", "=", "infer_abbr", "(", "norm_layer", ")", "\n", "\n", "assert", "isinstance", "(", "postfix", ",", "(", "int", ",", "str", ")", ")", "\n", "name", "=", "abbr", "+", "str", "(", "postfix", ")", "\n", "\n", "requires_grad", "=", "cfg_", ".", "pop", "(", "'requires_grad'", ",", "True", ")", "\n", "cfg_", ".", "setdefault", "(", "'eps'", ",", "1e-5", ")", "\n", "if", "layer_type", "!=", "'GN'", ":", "\n", "        ", "layer", "=", "norm_layer", "(", "num_features", ",", "**", "cfg_", ")", "\n", "if", "layer_type", "==", "'SyncBN'", ":", "\n", "            ", "layer", ".", "_specify_ddp_gpu_num", "(", "1", ")", "\n", "", "", "else", ":", "\n", "        ", "assert", "'num_groups'", "in", "cfg_", "\n", "layer", "=", "norm_layer", "(", "num_channels", "=", "num_features", ",", "**", "cfg_", ")", "\n", "\n", "", "for", "param", "in", "layer", ".", "parameters", "(", ")", ":", "\n", "        ", "param", ".", "requires_grad", "=", "requires_grad", "\n", "\n", "", "return", "name", ",", "layer", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.norm.is_norm": [[124, 147], ["isinstance", "isinstance", "isinstance", "vedacore.misc.is_tuple_of", "TypeError", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_tuple_of"], ["", "def", "is_norm", "(", "layer", ",", "exclude", "=", "None", ")", ":", "\n", "    ", "\"\"\"Check if a layer is a normalization layer.\n\n    Args:\n        layer (nn.Module): The layer to be checked.\n        exclude (type | tuple[type]): Types to be excluded.\n\n    Returns:\n        bool: Whether the layer is a norm layer.\n    \"\"\"", "\n", "if", "exclude", "is", "not", "None", ":", "\n", "        ", "if", "not", "isinstance", "(", "exclude", ",", "tuple", ")", ":", "\n", "            ", "exclude", "=", "(", "exclude", ",", ")", "\n", "", "if", "not", "is_tuple_of", "(", "exclude", ",", "type", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "f'\"exclude\" must be either None or type or a tuple of types, '", "\n", "f'but got {type(exclude)}: {exclude}'", ")", "\n", "\n", "", "", "if", "exclude", "and", "isinstance", "(", "layer", ",", "exclude", ")", ":", "\n", "        ", "return", "False", "\n", "\n", "", "all_norm_bases", "=", "(", "_BatchNorm", ",", "_InstanceNorm", ",", "nn", ".", "GroupNorm", ",", "nn", ".", "LayerNorm", ")", "\n", "return", "isinstance", "(", "layer", ",", "all_norm_bases", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.scale.Scale.__init__": [[15, 18], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "scale", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "Scale", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "scale", ",", "dtype", "=", "torch", ".", "float", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.scale.Scale.forward": [[19, 21], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "scale", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.conv.build_conv_layer": [[15, 48], ["cfg.copy.pop", "CONV_LAYERS.get.", "dict", "cfg.copy", "KeyError", "CONV_LAYERS.get", "isinstance", "TypeError", "KeyError"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["def", "build_conv_layer", "(", "cfg", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Build convolution layer.\n\n    Args:\n        cfg (None or dict): The conv layer config, which should contain:\n            - type (str): Layer type.\n            - layer args: Args needed to instantiate an activation layer.\n        args (argument list): Arguments passed to the `__init__`\n            method of the corresponding conv layer.\n        kwargs (keyword arguments): Keyword arguments passed to the `__init__`\n            method of the corresponding conv layer.\n\n    Returns:\n        nn.Module: Created conv layer.\n    \"\"\"", "\n", "if", "cfg", "is", "None", ":", "\n", "        ", "cfg_", "=", "dict", "(", "typename", "=", "'Conv2d'", ")", "\n", "", "else", ":", "\n", "        ", "if", "not", "isinstance", "(", "cfg", ",", "dict", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'cfg must be a dict'", ")", "\n", "", "if", "'typename'", "not", "in", "cfg", ":", "\n", "            ", "raise", "KeyError", "(", "'the cfg dict must contain the key \"typename\"'", ")", "\n", "", "cfg_", "=", "cfg", ".", "copy", "(", ")", "\n", "\n", "", "layer_type", "=", "cfg_", ".", "pop", "(", "'typename'", ")", "\n", "if", "layer_type", "not", "in", "CONV_LAYERS", ":", "\n", "        ", "raise", "KeyError", "(", "f'Unrecognized norm type {layer_type}'", ")", "\n", "", "else", ":", "\n", "        ", "conv_layer", "=", "CONV_LAYERS", ".", "get", "(", "layer_type", ")", "\n", "\n", "", "layer", "=", "conv_layer", "(", "*", "args", ",", "**", "kwargs", ",", "**", "cfg_", ")", "\n", "\n", "return", "layer", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.conv_module.ConvModule.__init__": [[57, 149], ["dict", "torch.Module.__init__", "conv.build_conv_layer", "conv_module.ConvModule.init_weights", "isinstance", "isinstance", "isinstance", "isinstance", "set", "set", "warnings.warn", "dict", "padding.build_padding_layer", "torch.utils.spectral_norm", "norm.build_norm_layer", "conv_module.ConvModule.add_module", "act_cfg.copy", "activation.build_activation_layer", "len", "order.index", "order.index", "act_cfg.copy.setdefault"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.conv.build_conv_layer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.padding.build_padding_layer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.norm.build_norm_layer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.activation.build_activation_layer"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "bias", "=", "'auto'", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "dict", "(", "typename", "=", "'ReLU'", ")", ",", "\n", "inplace", "=", "True", ",", "\n", "with_spectral_norm", "=", "False", ",", "\n", "padding_mode", "=", "'zeros'", ",", "\n", "order", "=", "(", "'conv'", ",", "'norm'", ",", "'act'", ")", ")", ":", "\n", "        ", "super", "(", "ConvModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "conv_cfg", "is", "None", "or", "isinstance", "(", "conv_cfg", ",", "dict", ")", "\n", "assert", "norm_cfg", "is", "None", "or", "isinstance", "(", "norm_cfg", ",", "dict", ")", "\n", "assert", "act_cfg", "is", "None", "or", "isinstance", "(", "act_cfg", ",", "dict", ")", "\n", "official_padding_mode", "=", "[", "'zeros'", ",", "'circular'", "]", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "act_cfg", "=", "act_cfg", "\n", "self", ".", "inplace", "=", "inplace", "\n", "self", ".", "with_spectral_norm", "=", "with_spectral_norm", "\n", "self", ".", "with_explicit_padding", "=", "padding_mode", "not", "in", "official_padding_mode", "\n", "self", ".", "order", "=", "order", "\n", "assert", "isinstance", "(", "self", ".", "order", ",", "tuple", ")", "and", "len", "(", "self", ".", "order", ")", "==", "3", "\n", "assert", "set", "(", "order", ")", "==", "set", "(", "[", "'conv'", ",", "'norm'", ",", "'act'", "]", ")", "\n", "\n", "self", ".", "with_norm", "=", "norm_cfg", "is", "not", "None", "\n", "self", ".", "with_activation", "=", "act_cfg", "is", "not", "None", "\n", "# if the conv layer is before a norm layer, bias is unnecessary.", "\n", "if", "bias", "==", "'auto'", ":", "\n", "            ", "bias", "=", "not", "self", ".", "with_norm", "\n", "", "self", ".", "with_bias", "=", "bias", "\n", "\n", "if", "self", ".", "with_norm", "and", "self", ".", "with_bias", ":", "\n", "            ", "warnings", ".", "warn", "(", "'ConvModule has norm and bias at the same time'", ")", "\n", "\n", "", "if", "self", ".", "with_explicit_padding", ":", "\n", "            ", "pad_cfg", "=", "dict", "(", "typename", "=", "padding_mode", ")", "\n", "self", ".", "padding_layer", "=", "build_padding_layer", "(", "pad_cfg", ",", "padding", ")", "\n", "\n", "# reset padding to 0 for conv module", "\n", "", "conv_padding", "=", "0", "if", "self", ".", "with_explicit_padding", "else", "padding", "\n", "# build convolution layer", "\n", "self", ".", "conv", "=", "build_conv_layer", "(", "\n", "conv_cfg", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "conv_padding", ",", "\n", "dilation", "=", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "bias", ")", "\n", "# export the attributes of self.conv to a higher level for convenience", "\n", "self", ".", "in_channels", "=", "self", ".", "conv", ".", "in_channels", "\n", "self", ".", "out_channels", "=", "self", ".", "conv", ".", "out_channels", "\n", "self", ".", "kernel_size", "=", "self", ".", "conv", ".", "kernel_size", "\n", "self", ".", "stride", "=", "self", ".", "conv", ".", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilation", "=", "self", ".", "conv", ".", "dilation", "\n", "self", ".", "transposed", "=", "self", ".", "conv", ".", "transposed", "\n", "self", ".", "output_padding", "=", "self", ".", "conv", ".", "output_padding", "\n", "self", ".", "groups", "=", "self", ".", "conv", ".", "groups", "\n", "\n", "if", "self", ".", "with_spectral_norm", ":", "\n", "            ", "self", ".", "conv", "=", "nn", ".", "utils", ".", "spectral_norm", "(", "self", ".", "conv", ")", "\n", "\n", "# build normalization layers", "\n", "", "if", "self", ".", "with_norm", ":", "\n", "# norm layer is after conv layer", "\n", "            ", "if", "order", ".", "index", "(", "'norm'", ")", ">", "order", ".", "index", "(", "'conv'", ")", ":", "\n", "                ", "norm_channels", "=", "out_channels", "\n", "", "else", ":", "\n", "                ", "norm_channels", "=", "in_channels", "\n", "", "self", ".", "norm_name", ",", "norm", "=", "build_norm_layer", "(", "norm_cfg", ",", "norm_channels", ")", "\n", "self", ".", "add_module", "(", "self", ".", "norm_name", ",", "norm", ")", "\n", "\n", "# build activation layer", "\n", "", "if", "self", ".", "with_activation", ":", "\n", "            ", "act_cfg_", "=", "act_cfg", ".", "copy", "(", ")", "\n", "# nn.Tanh has no 'inplace' argument", "\n", "if", "act_cfg_", "[", "'typename'", "]", "not", "in", "[", "'Tanh'", ",", "'PReLU'", ",", "'Sigmoid'", "]", ":", "\n", "                ", "act_cfg_", ".", "setdefault", "(", "'inplace'", ",", "inplace", ")", "\n", "", "self", ".", "activate", "=", "build_activation_layer", "(", "act_cfg_", ")", "\n", "\n", "# Use msra init by default", "\n", "", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.conv_module.ConvModule.norm": [[150, 153], ["getattr"], "methods", ["None"], ["", "@", "property", "\n", "def", "norm", "(", "self", ")", ":", "\n", "        ", "return", "getattr", "(", "self", ",", "self", ".", "norm_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.conv_module.ConvModule.init_weights": [[154, 175], ["hasattr", "utils.kaiming_init", "utils.constant_init", "conv_module.ConvModule.act_cfg.get"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.kaiming_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.constant_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "# 1. It is mainly for customized conv layers with their own", "\n", "#    initialization manners by calling their own ``init_weights()``,", "\n", "#    and we do not want ConvModule to override the initialization.", "\n", "# 2. For customized conv layers without their own initialization", "\n", "#    manners (that is, they don't have their own ``init_weights()``)", "\n", "#    and PyTorch's conv layers, they will be initialized by", "\n", "#    this method with default ``kaiming_init``.", "\n", "# Note: For PyTorch's conv layers, they will be overwritten by our", "\n", "#    initialization implementation using default ``kaiming_init``.", "\n", "        ", "if", "not", "hasattr", "(", "self", ".", "conv", ",", "'init_weights'", ")", ":", "\n", "            ", "if", "self", ".", "with_activation", "and", "self", ".", "act_cfg", "[", "'typename'", "]", "==", "'LeakyReLU'", ":", "\n", "                ", "nonlinearity", "=", "'leaky_relu'", "\n", "a", "=", "self", ".", "act_cfg", ".", "get", "(", "'negative_slope'", ",", "0.01", ")", "\n", "", "else", ":", "\n", "                ", "nonlinearity", "=", "'relu'", "\n", "a", "=", "0", "\n", "", "kaiming_init", "(", "self", ".", "conv", ",", "a", "=", "a", ",", "nonlinearity", "=", "nonlinearity", ")", "\n", "", "if", "self", ".", "with_norm", ":", "\n", "            ", "constant_init", "(", "self", ".", "norm", ",", "1", ",", "bias", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.conv_module.ConvModule.forward": [[176, 187], ["conv_module.ConvModule.conv", "conv_module.ConvModule.padding_layer", "conv_module.ConvModule.norm", "conv_module.ConvModule.activate"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.conv_module.ConvModule.norm"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "activate", "=", "True", ",", "norm", "=", "True", ")", ":", "\n", "        ", "for", "layer", "in", "self", ".", "order", ":", "\n", "            ", "if", "layer", "==", "'conv'", ":", "\n", "                ", "if", "self", ".", "with_explicit_padding", ":", "\n", "                    ", "x", "=", "self", ".", "padding_layer", "(", "x", ")", "\n", "", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "", "elif", "layer", "==", "'norm'", "and", "norm", "and", "self", ".", "with_norm", ":", "\n", "                ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "elif", "layer", "==", "'act'", "and", "activate", "and", "self", ".", "with_activation", ":", "\n", "                ", "x", "=", "self", ".", "activate", "(", "x", ")", "\n", "", "", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.plugin.build_plugin_layer": [[11, 40], ["cfg.copy", "cfg.copy.pop", "isinstance", "plugin_layer", "isinstance", "KeyError", "str"], "function", ["None"], ["def", "build_plugin_layer", "(", "cfg", ",", "postfix", "=", "''", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Build plugin layer.\n\n    Args:\n        cfg (None or dict): cfg should contain:\n            type (str): identify plugin layer type.\n            layer args: args needed to instantiate a plugin layer.\n        postfix (int, str): appended into norm abbreviation to\n            create named layer.\n\n    Returns:\n        name (str): abbreviation + postfix\n        layer (nn.Module): created plugin layer\n    \"\"\"", "\n", "assert", "isinstance", "(", "cfg", ",", "dict", ")", "and", "'type'", "in", "cfg", "\n", "cfg_", "=", "cfg", ".", "copy", "(", ")", "\n", "\n", "layer_type", "=", "cfg_", ".", "pop", "(", "'type'", ")", "\n", "if", "layer_type", "not", "in", "plugin_cfg", ":", "\n", "        ", "raise", "KeyError", "(", "f'Unrecognized plugin type {layer_type}'", ")", "\n", "", "else", ":", "\n", "        ", "abbr", ",", "plugin_layer", "=", "plugin_cfg", "[", "layer_type", "]", "\n", "\n", "", "assert", "isinstance", "(", "postfix", ",", "(", "int", ",", "str", ")", ")", "\n", "name", "=", "abbr", "+", "str", "(", "postfix", ")", "\n", "\n", "layer", "=", "plugin_layer", "(", "**", "kwargs", ",", "**", "cfg_", ")", "\n", "\n", "return", "name", ",", "layer", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.padding.build_padding_layer": [[10, 36], ["cfg.copy", "cfg.copy.pop", "PADDING_LAYERS.get.", "isinstance", "TypeError", "KeyError", "KeyError", "PADDING_LAYERS.get"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["def", "build_padding_layer", "(", "cfg", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Build padding layer.\n\n    Args:\n        cfg (None or dict): The padding layer config, which should contain:\n            - type (str): Layer type.\n            - layer args: Args needed to instantiate a padding layer.\n\n    Returns:\n        nn.Module: Created padding layer.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "cfg", ",", "dict", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'cfg must be a dict'", ")", "\n", "", "if", "'typename'", "not", "in", "cfg", ":", "\n", "        ", "raise", "KeyError", "(", "'the cfg dict must contain the key \"typename\"'", ")", "\n", "\n", "", "cfg_", "=", "cfg", ".", "copy", "(", ")", "\n", "padding_type", "=", "cfg_", ".", "pop", "(", "'typename'", ")", "\n", "if", "padding_type", "not", "in", "PADDING_LAYERS", ":", "\n", "        ", "raise", "KeyError", "(", "f'Unrecognized padding type {padding_type}.'", ")", "\n", "", "else", ":", "\n", "        ", "padding_layer", "=", "PADDING_LAYERS", ".", "get", "(", "padding_type", ")", "\n", "\n", "", "layer", "=", "padding_layer", "(", "*", "args", ",", "**", "kwargs", ",", "**", "cfg_", ")", "\n", "\n", "return", "layer", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.hswish.HSwish.__init__": [[20, 23], ["torch.Module.__init__", "torch.ReLU6"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "inplace", "=", "False", ")", ":", "\n", "        ", "super", "(", "HSwish", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "act", "=", "nn", ".", "ReLU6", "(", "inplace", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.hswish.HSwish.forward": [[24, 26], ["hswish.HSwish.act"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "act", "(", "x", "+", "3", ")", "/", "6", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.enhance_module.build_enhance_module": [[4, 18], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["def", "build_enhance_module", "(", "cfg", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "\"\"\"Build enhance module.\n\n    Args:\n        cfg (dict): The enhance module config, which should contain:\n            - type (str): Layer type.\n            - module args: Args needed to instantiate an enhance module.\n        default_args (dict | None): The default config for enhance module.\n            Default: None\n\n    Returns:\n        nn.Module: Created enhance module.\n    \"\"\"", "\n", "return", "build_from_cfg", "(", "cfg", ",", "registry", ",", "'enhance_module'", ",", "default_args", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.upsample.PixelShufflePack.__init__": [[29, 42], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "upsample.PixelShufflePack.init_weights"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "scale_factor", ",", "\n", "upsample_kernel", ")", ":", "\n", "        ", "super", "(", "PixelShufflePack", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "scale_factor", "=", "scale_factor", "\n", "self", ".", "upsample_kernel", "=", "upsample_kernel", "\n", "self", ".", "upsample_conv", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "out_channels", "*", "scale_factor", "*", "scale_factor", ",", "\n", "self", ".", "upsample_kernel", ",", "\n", "padding", "=", "(", "self", ".", "upsample_kernel", "-", "1", ")", "//", "2", ")", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.upsample.PixelShufflePack.init_weights": [[43, 45], ["utils.xavier_init"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.xavier_init"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "xavier_init", "(", "self", ".", "upsample_conv", ",", "distribution", "=", "'uniform'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.upsample.PixelShufflePack.forward": [[46, 50], ["upsample.PixelShufflePack.upsample_conv", "torch.pixel_shuffle", "torch.pixel_shuffle"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "upsample_conv", "(", "x", ")", "\n", "x", "=", "F", ".", "pixel_shuffle", "(", "x", ",", "self", ".", "scale_factor", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.upsample.build_upsample_layer": [[52, 83], ["cfg.copy", "cfg.copy.pop", "vedacore.misc.registry.get", "registry.get.", "isinstance", "TypeError", "KeyError", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "", "def", "build_upsample_layer", "(", "cfg", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Build upsample layer.\n\n    Args:\n        cfg (dict): The upsample layer config, which should contain:\n            - type (str): Layer type.\n            - scale_factor (int): Upsample ratio, which is not applicable to\n                deconv.\n            - layer args: Args needed to instantiate a upsample layer.\n        args (argument list): Arguments passed to the `__init__`\n            method of the corresponding conv layer.\n        kwargs (keyword arguments): Keyword arguments passed to the `__init__`\n            method of the corresponding conv layer.\n\n    Returns:\n        nn.Module: Created upsample layer.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "cfg", ",", "dict", ")", ":", "\n", "        ", "raise", "TypeError", "(", "f'cfg must be a dict, but got {type(cfg)}'", ")", "\n", "", "if", "'typename'", "not", "in", "cfg", ":", "\n", "        ", "raise", "KeyError", "(", "\n", "f'the cfg dict must contain the key \"typename\", but got {cfg}'", ")", "\n", "", "cfg_", "=", "cfg", ".", "copy", "(", ")", "\n", "\n", "layer_type", "=", "cfg_", ".", "pop", "(", "'typename'", ")", "\n", "upsample", "=", "registry", ".", "get", "(", "layer_type", ",", "'upsample'", ")", "\n", "\n", "if", "upsample", "is", "nn", ".", "Upsample", ":", "\n", "        ", "cfg_", "[", "'mode'", "]", "=", "layer_type", "\n", "", "layer", "=", "upsample", "(", "*", "args", ",", "**", "kwargs", ",", "**", "cfg_", ")", "\n", "return", "layer", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConvFunction.forward": [[17, 59], ["torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "ctx.save_for_backward", "input.new_empty", "ValueError", "deform_conv.DeformConvFunction._output_size", "input.new_empty", "input.new_empty", "min", "deform_conv_ext.deform_conv_forward", "input.dim", "weight.size", "weight.size", "input.dim"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConvFunction._output_size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "\n", "input", ",", "\n", "offset", ",", "\n", "weight", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "im2col_step", "=", "64", ")", ":", "\n", "        ", "if", "input", "is", "not", "None", "and", "input", ".", "dim", "(", ")", "!=", "4", ":", "\n", "            ", "raise", "ValueError", "(", "f'Expected 4D tensor as input, got {input.dim()}'", "\n", "'D tensor instead.'", ")", "\n", "", "ctx", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "ctx", ".", "padding", "=", "_pair", "(", "padding", ")", "\n", "ctx", ".", "dilation", "=", "_pair", "(", "dilation", ")", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "im2col_step", "=", "im2col_step", "\n", "\n", "ctx", ".", "save_for_backward", "(", "input", ",", "offset", ",", "weight", ")", "\n", "\n", "output", "=", "input", ".", "new_empty", "(", "\n", "DeformConvFunction", ".", "_output_size", "(", "input", ",", "weight", ",", "ctx", ".", "padding", ",", "\n", "ctx", ".", "dilation", ",", "ctx", ".", "stride", ")", ")", "\n", "\n", "ctx", ".", "bufs_", "=", "[", "input", ".", "new_empty", "(", "0", ")", ",", "input", ".", "new_empty", "(", "0", ")", "]", "# columns, ones", "\n", "\n", "if", "not", "input", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "else", ":", "\n", "            ", "cur_im2col_step", "=", "min", "(", "ctx", ".", "im2col_step", ",", "input", ".", "shape", "[", "0", "]", ")", "\n", "assert", "(", "input", ".", "shape", "[", "0", "]", "%", "\n", "cur_im2col_step", ")", "==", "0", ",", "'im2col step must divide batchsize'", "\n", "deform_conv_ext", ".", "deform_conv_forward", "(", "\n", "input", ",", "weight", ",", "offset", ",", "output", ",", "ctx", ".", "bufs_", "[", "0", "]", ",", "ctx", ".", "bufs_", "[", "1", "]", ",", "\n", "weight", ".", "size", "(", "3", ")", ",", "weight", ".", "size", "(", "2", ")", ",", "ctx", ".", "stride", "[", "1", "]", ",", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "ctx", ".", "padding", "[", "0", "]", ",", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "ctx", ".", "groups", ",", "ctx", ".", "deformable_groups", ",", "\n", "cur_im2col_step", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConvFunction.backward": [[60, 97], ["min", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "deform_conv_ext.deform_conv_backward_input", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "deform_conv_ext.deform_conv_backward_parameters", "weight.size", "weight.size", "weight.size", "weight.size"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "input", ",", "offset", ",", "weight", "=", "ctx", ".", "saved_tensors", "\n", "\n", "grad_input", "=", "grad_offset", "=", "grad_weight", "=", "None", "\n", "\n", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "else", ":", "\n", "            ", "cur_im2col_step", "=", "min", "(", "ctx", ".", "im2col_step", ",", "input", ".", "shape", "[", "0", "]", ")", "\n", "assert", "(", "input", ".", "shape", "[", "0", "]", "%", "\n", "cur_im2col_step", ")", "==", "0", ",", "'im2col step must divide batchsize'", "\n", "\n", "if", "ctx", ".", "needs_input_grad", "[", "0", "]", "or", "ctx", ".", "needs_input_grad", "[", "1", "]", ":", "\n", "                ", "grad_input", "=", "torch", ".", "zeros_like", "(", "input", ")", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "deform_conv_ext", ".", "deform_conv_backward_input", "(", "\n", "input", ",", "offset", ",", "grad_output", ",", "grad_input", ",", "\n", "grad_offset", ",", "weight", ",", "ctx", ".", "bufs_", "[", "0", "]", ",", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "ctx", ".", "stride", "[", "1", "]", ",", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "ctx", ".", "padding", "[", "0", "]", ",", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "ctx", ".", "groups", ",", "ctx", ".", "deformable_groups", ",", "\n", "cur_im2col_step", ")", "\n", "\n", "", "if", "ctx", ".", "needs_input_grad", "[", "2", "]", ":", "\n", "                ", "grad_weight", "=", "torch", ".", "zeros_like", "(", "weight", ")", "\n", "deform_conv_ext", ".", "deform_conv_backward_parameters", "(", "\n", "input", ",", "offset", ",", "grad_output", ",", "\n", "grad_weight", ",", "ctx", ".", "bufs_", "[", "0", "]", ",", "ctx", ".", "bufs_", "[", "1", "]", ",", "weight", ".", "size", "(", "3", ")", ",", "\n", "weight", ".", "size", "(", "2", ")", ",", "ctx", ".", "stride", "[", "1", "]", ",", "ctx", ".", "stride", "[", "0", "]", ",", "\n", "ctx", ".", "padding", "[", "1", "]", ",", "ctx", ".", "padding", "[", "0", "]", ",", "ctx", ".", "dilation", "[", "1", "]", ",", "\n", "ctx", ".", "dilation", "[", "0", "]", ",", "ctx", ".", "groups", ",", "ctx", ".", "deformable_groups", ",", "1", ",", "\n", "cur_im2col_step", ")", "\n", "\n", "", "", "return", "(", "grad_input", ",", "grad_offset", ",", "grad_weight", ",", "None", ",", "None", ",", "None", ",", "None", ",", "\n", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConvFunction._output_size": [[98, 112], ["weight.size", "range", "input.size", "input.size", "all", "ValueError", "input.dim", "map", "weight.size", "map"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "@", "staticmethod", "\n", "def", "_output_size", "(", "input", ",", "weight", ",", "padding", ",", "dilation", ",", "stride", ")", ":", "\n", "        ", "channels", "=", "weight", ".", "size", "(", "0", ")", "\n", "output_size", "=", "(", "input", ".", "size", "(", "0", ")", ",", "channels", ")", "\n", "for", "d", "in", "range", "(", "input", ".", "dim", "(", ")", "-", "2", ")", ":", "\n", "            ", "in_size", "=", "input", ".", "size", "(", "d", "+", "2", ")", "\n", "pad", "=", "padding", "[", "d", "]", "\n", "kernel", "=", "dilation", "[", "d", "]", "*", "(", "weight", ".", "size", "(", "d", "+", "2", ")", "-", "1", ")", "+", "1", "\n", "stride_", "=", "stride", "[", "d", "]", "\n", "output_size", "+=", "(", "(", "in_size", "+", "(", "2", "*", "pad", ")", "-", "kernel", ")", "//", "stride_", "+", "1", ",", ")", "\n", "", "if", "not", "all", "(", "map", "(", "lambda", "s", ":", "s", ">", "0", ",", "output_size", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'convolution input is too small (output would be '", "\n", "f'{\"x\".join(map(str, output_size))})'", ")", "\n", "", "return", "output_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvFunction.forward": [[116, 150], ["input.new_empty", "deform_conv_ext.modulated_deform_conv_forward", "input.new_empty", "ctx.save_for_backward", "deform_conv.ModulatedDeformConvFunction._infer_shape", "input.new_empty", "input.new_empty"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvFunction._infer_shape"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "\n", "input", ",", "\n", "offset", ",", "\n", "mask", ",", "\n", "weight", ",", "\n", "bias", "=", "None", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ")", ":", "\n", "        ", "ctx", ".", "stride", "=", "stride", "\n", "ctx", ".", "padding", "=", "padding", "\n", "ctx", ".", "dilation", "=", "dilation", "\n", "ctx", ".", "groups", "=", "groups", "\n", "ctx", ".", "deformable_groups", "=", "deformable_groups", "\n", "ctx", ".", "with_bias", "=", "bias", "is", "not", "None", "\n", "if", "not", "ctx", ".", "with_bias", ":", "\n", "            ", "bias", "=", "input", ".", "new_empty", "(", "1", ")", "# fake tensor", "\n", "", "if", "not", "input", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "if", "weight", ".", "requires_grad", "or", "mask", ".", "requires_grad", "or", "offset", ".", "requires_grad", "or", "input", ".", "requires_grad", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "input", ",", "offset", ",", "mask", ",", "weight", ",", "bias", ")", "\n", "", "output", "=", "input", ".", "new_empty", "(", "\n", "ModulatedDeformConvFunction", ".", "_infer_shape", "(", "ctx", ",", "input", ",", "weight", ")", ")", "\n", "ctx", ".", "_bufs", "=", "[", "input", ".", "new_empty", "(", "0", ")", ",", "input", ".", "new_empty", "(", "0", ")", "]", "\n", "deform_conv_ext", ".", "modulated_deform_conv_forward", "(", "\n", "input", ",", "weight", ",", "bias", ",", "ctx", ".", "_bufs", "[", "0", "]", ",", "offset", ",", "mask", ",", "output", ",", "\n", "ctx", ".", "_bufs", "[", "1", "]", ",", "weight", ".", "shape", "[", "2", "]", ",", "weight", ".", "shape", "[", "3", "]", ",", "ctx", ".", "stride", ",", "\n", "ctx", ".", "stride", ",", "ctx", ".", "padding", ",", "ctx", ".", "padding", ",", "ctx", ".", "dilation", ",", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "groups", ",", "ctx", ".", "deformable_groups", ",", "ctx", ".", "with_bias", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvFunction.backward": [[151, 173], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "deform_conv_ext.modulated_deform_conv_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "input", ",", "offset", ",", "mask", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "grad_input", "=", "torch", ".", "zeros_like", "(", "input", ")", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "grad_mask", "=", "torch", ".", "zeros_like", "(", "mask", ")", "\n", "grad_weight", "=", "torch", ".", "zeros_like", "(", "weight", ")", "\n", "grad_bias", "=", "torch", ".", "zeros_like", "(", "bias", ")", "\n", "deform_conv_ext", ".", "modulated_deform_conv_backward", "(", "\n", "input", ",", "weight", ",", "bias", ",", "ctx", ".", "_bufs", "[", "0", "]", ",", "offset", ",", "mask", ",", "ctx", ".", "_bufs", "[", "1", "]", ",", "\n", "grad_input", ",", "grad_weight", ",", "grad_bias", ",", "grad_offset", ",", "grad_mask", ",", "\n", "grad_output", ",", "weight", ".", "shape", "[", "2", "]", ",", "weight", ".", "shape", "[", "3", "]", ",", "ctx", ".", "stride", ",", "\n", "ctx", ".", "stride", ",", "ctx", ".", "padding", ",", "ctx", ".", "padding", ",", "ctx", ".", "dilation", ",", "ctx", ".", "dilation", ",", "\n", "ctx", ".", "groups", ",", "ctx", ".", "deformable_groups", ",", "ctx", ".", "with_bias", ")", "\n", "if", "not", "ctx", ".", "with_bias", ":", "\n", "            ", "grad_bias", "=", "None", "\n", "\n", "", "return", "(", "grad_input", ",", "grad_offset", ",", "grad_mask", ",", "grad_weight", ",", "grad_bias", ",", "\n", "None", ",", "None", ",", "None", ",", "None", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvFunction._infer_shape": [[174, 185], ["input.size", "weight.size"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "@", "staticmethod", "\n", "def", "_infer_shape", "(", "ctx", ",", "input", ",", "weight", ")", ":", "\n", "        ", "n", "=", "input", ".", "size", "(", "0", ")", "\n", "channels_out", "=", "weight", ".", "size", "(", "0", ")", "\n", "height", ",", "width", "=", "input", ".", "shape", "[", "2", ":", "4", "]", "\n", "kernel_h", ",", "kernel_w", "=", "weight", ".", "shape", "[", "2", ":", "4", "]", "\n", "height_out", "=", "(", "height", "+", "2", "*", "ctx", ".", "padding", "-", "\n", "(", "ctx", ".", "dilation", "*", "(", "kernel_h", "-", "1", ")", "+", "1", ")", ")", "//", "ctx", ".", "stride", "+", "1", "\n", "width_out", "=", "(", "width", "+", "2", "*", "ctx", ".", "padding", "-", "\n", "(", "ctx", ".", "dilation", "*", "(", "kernel_w", "-", "1", ")", "+", "1", ")", ")", "//", "ctx", ".", "stride", "+", "1", "\n", "return", "n", ",", "channels_out", ",", "height_out", ",", "width_out", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConv.__init__": [[193, 229], ["torch.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._single", "torch.nn.modules.utils._single", "torch.nn.modules.utils._single", "torch.Parameter", "torch.Parameter", "torch.Parameter", "deform_conv.DeformConv.reset_parameters", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConv.reset_parameters"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "False", ")", ":", "\n", "        ", "super", "(", "DeformConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "not", "bias", "\n", "assert", "in_channels", "%", "groups", "==", "0", ",", "f'in_channels {in_channels} is not divisible by groups {groups}'", "\n", "assert", "out_channels", "%", "groups", "==", "0", ",", "f'out_channels {out_channels} is not divisible '", "f'by groups {groups}'", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "stride", "=", "_pair", "(", "stride", ")", "\n", "self", ".", "padding", "=", "_pair", "(", "padding", ")", "\n", "self", ".", "dilation", "=", "_pair", "(", "dilation", ")", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "deformable_groups", "=", "deformable_groups", "\n", "# enable compatibility with nn.Conv2d", "\n", "self", ".", "transposed", "=", "False", "\n", "self", ".", "output_padding", "=", "_single", "(", "0", ")", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "self", ".", "groups", ",", "\n", "*", "self", ".", "kernel_size", ")", ")", "\n", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConv.reset_parameters": [[230, 236], ["deform_conv.DeformConv.weight.data.uniform_", "math.sqrt"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "n", "=", "self", ".", "in_channels", "\n", "for", "k", "in", "self", ".", "kernel_size", ":", "\n", "            ", "n", "*=", "k", "\n", "", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "n", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConv.forward": [[237, 254], ["deform_conv", "max", "max", "torch.pad().contiguous", "torch.pad().contiguous", "torch.pad().contiguous", "torch.pad().contiguous", "torch.pad().contiguous", "torch.pad().contiguous", "out[].contiguous", "torch.pad().contiguous.size", "torch.pad().contiguous.size", "torch.pad().contiguous.size", "torch.pad().contiguous.size", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "out[].contiguous.size", "out[].contiguous.size"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "forward", "(", "self", ",", "x", ",", "offset", ")", ":", "\n", "# To fix an assert error in deform_conv_cuda.cpp:128", "\n", "# input image is smaller than kernel", "\n", "        ", "input_pad", "=", "(", "\n", "x", ".", "size", "(", "2", ")", "<", "self", ".", "kernel_size", "[", "0", "]", "or", "x", ".", "size", "(", "3", ")", "<", "self", ".", "kernel_size", "[", "1", "]", ")", "\n", "if", "input_pad", ":", "\n", "            ", "pad_h", "=", "max", "(", "self", ".", "kernel_size", "[", "0", "]", "-", "x", ".", "size", "(", "2", ")", ",", "0", ")", "\n", "pad_w", "=", "max", "(", "self", ".", "kernel_size", "[", "1", "]", "-", "x", ".", "size", "(", "3", ")", ",", "0", ")", "\n", "x", "=", "F", ".", "pad", "(", "x", ",", "(", "0", ",", "pad_w", ",", "0", ",", "pad_h", ")", ",", "'constant'", ",", "0", ")", ".", "contiguous", "(", ")", "\n", "offset", "=", "F", ".", "pad", "(", "offset", ",", "(", "0", ",", "pad_w", ",", "0", ",", "pad_h", ")", ",", "'constant'", ",", "\n", "0", ")", ".", "contiguous", "(", ")", "\n", "", "out", "=", "deform_conv", "(", "x", ",", "offset", ",", "self", ".", "weight", ",", "self", ".", "stride", ",", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "self", ".", "groups", ",", "self", ".", "deformable_groups", ")", "\n", "if", "input_pad", ":", "\n", "            ", "out", "=", "out", "[", ":", ",", ":", ",", ":", "out", ".", "size", "(", "2", ")", "-", "pad_h", ",", ":", "out", ".", "size", "(", "3", ")", "-", "\n", "pad_w", "]", ".", "contiguous", "(", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConvPack.__init__": [[282, 295], ["deform_conv.DeformConv.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "deform_conv.DeformConvPack.init_offset", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConvPack.init_offset"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "DeformConvPack", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "conv_offset", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "deformable_groups", "*", "2", "*", "self", ".", "kernel_size", "[", "0", "]", "*", "\n", "self", ".", "kernel_size", "[", "1", "]", ",", "\n", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "stride", "=", "_pair", "(", "self", ".", "stride", ")", ",", "\n", "padding", "=", "_pair", "(", "self", ".", "padding", ")", ",", "\n", "dilation", "=", "_pair", "(", "self", ".", "dilation", ")", ",", "\n", "bias", "=", "True", ")", "\n", "self", ".", "init_offset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConvPack.init_offset": [[296, 299], ["deform_conv.DeformConvPack.conv_offset.weight.data.zero_", "deform_conv.DeformConvPack.conv_offset.bias.data.zero_"], "methods", ["None"], ["", "def", "init_offset", "(", "self", ")", ":", "\n", "        ", "self", ".", "conv_offset", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv_offset", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConvPack.forward": [[300, 304], ["deform_conv.DeformConvPack.conv_offset", "deform_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "offset", "=", "self", ".", "conv_offset", "(", "x", ")", "\n", "return", "deform_conv", "(", "x", ",", "offset", ",", "self", ".", "weight", ",", "self", ".", "stride", ",", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "self", ".", "groups", ",", "self", ".", "deformable_groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.DeformConvPack._load_from_state_dict": [[305, 331], ["local_metadata.get", "super()._load_from_state_dict", "print", "state_dict.pop", "state_dict.pop", "prefix.rstrip"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvPack._load_from_state_dict"], ["", "def", "_load_from_state_dict", "(", "self", ",", "state_dict", ",", "prefix", ",", "local_metadata", ",", "strict", ",", "\n", "missing_keys", ",", "unexpected_keys", ",", "error_msgs", ")", ":", "\n", "        ", "version", "=", "local_metadata", ".", "get", "(", "'version'", ",", "None", ")", "\n", "\n", "if", "version", "is", "None", "or", "version", "<", "2", ":", "\n", "# the key is different in early versions", "\n", "# In version < 2, DeformConvPack loads previous benchmark models.", "\n", "            ", "if", "(", "prefix", "+", "'conv_offset.weight'", "not", "in", "state_dict", "\n", "and", "prefix", "[", ":", "-", "1", "]", "+", "'_offset.weight'", "in", "state_dict", ")", ":", "\n", "                ", "state_dict", "[", "prefix", "+", "'conv_offset.weight'", "]", "=", "state_dict", ".", "pop", "(", "\n", "prefix", "[", ":", "-", "1", "]", "+", "'_offset.weight'", ")", "\n", "", "if", "(", "prefix", "+", "'conv_offset.bias'", "not", "in", "state_dict", "\n", "and", "prefix", "[", ":", "-", "1", "]", "+", "'_offset.bias'", "in", "state_dict", ")", ":", "\n", "                ", "state_dict", "[", "prefix", "+", "\n", "'conv_offset.bias'", "]", "=", "state_dict", ".", "pop", "(", "prefix", "[", ":", "-", "1", "]", "+", "\n", "'_offset.bias'", ")", "\n", "\n", "", "", "if", "version", "is", "not", "None", "and", "version", ">", "1", ":", "\n", "            ", "print", "(", "\n", "f'DeformConvPack {prefix.rstrip(\".\")} is upgraded to '", "\n", "'version 2.'", ",", "\n", "logger", "=", "'root'", ")", "\n", "\n", "", "super", "(", ")", ".", "_load_from_state_dict", "(", "state_dict", ",", "prefix", ",", "local_metadata", ",", "\n", "strict", ",", "missing_keys", ",", "unexpected_keys", ",", "\n", "error_msgs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConv.__init__": [[335, 367], ["torch.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._single", "torch.nn.modules.utils._single", "torch.nn.modules.utils._single", "torch.Parameter", "torch.Parameter", "torch.Parameter", "deform_conv.ModulatedDeformConv.init_weights", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Parameter", "torch.Parameter", "torch.Parameter", "deform_conv.ModulatedDeformConv.register_parameter", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "ModulatedDeformConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "deformable_groups", "=", "deformable_groups", "\n", "self", ".", "with_bias", "=", "bias", "\n", "# enable compatibility with nn.Conv2d", "\n", "self", ".", "transposed", "=", "False", "\n", "self", ".", "output_padding", "=", "_single", "(", "0", ")", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "groups", ",", "\n", "*", "self", ".", "kernel_size", ")", ")", "\n", "if", "bias", ":", "\n", "            ", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_channels", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConv.init_weights": [[368, 376], ["deform_conv.ModulatedDeformConv.weight.data.uniform_", "math.sqrt", "deform_conv.ModulatedDeformConv.bias.data.zero_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "n", "=", "self", ".", "in_channels", "\n", "for", "k", "in", "self", ".", "kernel_size", ":", "\n", "            ", "n", "*=", "k", "\n", "", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "n", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "self", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConv.forward": [[377, 381], ["modulated_deform_conv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "offset", ",", "mask", ")", ":", "\n", "        ", "return", "modulated_deform_conv", "(", "x", ",", "offset", ",", "mask", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "\n", "self", ".", "stride", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "\n", "self", ".", "groups", ",", "self", ".", "deformable_groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvPack.__init__": [[402, 415], ["deform_conv.ModulatedDeformConv.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "deform_conv.ModulatedDeformConvPack.init_weights", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ModulatedDeformConvPack", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "conv_offset", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "deformable_groups", "*", "3", "*", "self", ".", "kernel_size", "[", "0", "]", "*", "\n", "self", ".", "kernel_size", "[", "1", "]", ",", "\n", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "stride", "=", "_pair", "(", "self", ".", "stride", ")", ",", "\n", "padding", "=", "_pair", "(", "self", ".", "padding", ")", ",", "\n", "dilation", "=", "_pair", "(", "self", ".", "dilation", ")", ",", "\n", "bias", "=", "True", ")", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvPack.init_weights": [[416, 421], ["deform_conv.ModulatedDeformConv.init_weights", "hasattr", "deform_conv.ModulatedDeformConvPack.conv_offset.weight.data.zero_", "deform_conv.ModulatedDeformConvPack.conv_offset.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "super", "(", "ModulatedDeformConvPack", ",", "self", ")", ".", "init_weights", "(", ")", "\n", "if", "hasattr", "(", "self", ",", "'conv_offset'", ")", ":", "\n", "            ", "self", ".", "conv_offset", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv_offset", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvPack.forward": [[422, 430], ["deform_conv.ModulatedDeformConvPack.conv_offset", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "modulated_deform_conv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv_offset", "(", "x", ")", "\n", "o1", ",", "o2", ",", "mask", "=", "torch", ".", "chunk", "(", "out", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "o1", ",", "o2", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "torch", ".", "sigmoid", "(", "mask", ")", "\n", "return", "modulated_deform_conv", "(", "x", ",", "offset", ",", "mask", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "\n", "self", ".", "stride", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "\n", "self", ".", "groups", ",", "self", ".", "deformable_groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvPack._load_from_state_dict": [[431, 458], ["local_metadata.get", "super()._load_from_state_dict", "print", "state_dict.pop", "state_dict.pop", "prefix.rstrip"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_conv.ModulatedDeformConvPack._load_from_state_dict"], ["", "def", "_load_from_state_dict", "(", "self", ",", "state_dict", ",", "prefix", ",", "local_metadata", ",", "strict", ",", "\n", "missing_keys", ",", "unexpected_keys", ",", "error_msgs", ")", ":", "\n", "        ", "version", "=", "local_metadata", ".", "get", "(", "'version'", ",", "None", ")", "\n", "\n", "if", "version", "is", "None", "or", "version", "<", "2", ":", "\n", "# the key is different in early versions", "\n", "# In version < 2, ModulatedDeformConvPack", "\n", "# loads previous benchmark models.", "\n", "            ", "if", "(", "prefix", "+", "'conv_offset.weight'", "not", "in", "state_dict", "\n", "and", "prefix", "[", ":", "-", "1", "]", "+", "'_offset.weight'", "in", "state_dict", ")", ":", "\n", "                ", "state_dict", "[", "prefix", "+", "'conv_offset.weight'", "]", "=", "state_dict", ".", "pop", "(", "\n", "prefix", "[", ":", "-", "1", "]", "+", "'_offset.weight'", ")", "\n", "", "if", "(", "prefix", "+", "'conv_offset.bias'", "not", "in", "state_dict", "\n", "and", "prefix", "[", ":", "-", "1", "]", "+", "'_offset.bias'", "in", "state_dict", ")", ":", "\n", "                ", "state_dict", "[", "prefix", "+", "\n", "'conv_offset.bias'", "]", "=", "state_dict", ".", "pop", "(", "prefix", "[", ":", "-", "1", "]", "+", "\n", "'_offset.bias'", ")", "\n", "\n", "", "", "if", "version", "is", "not", "None", "and", "version", ">", "1", ":", "\n", "            ", "print", "(", "\n", "f'ModulatedDeformConvPack {prefix.rstrip(\".\")} is upgraded to '", "\n", "'version 2.'", ",", "\n", "logger", "=", "'root'", ")", "\n", "\n", "", "super", "(", ")", ".", "_load_from_state_dict", "(", "state_dict", ",", "prefix", ",", "local_metadata", ",", "\n", "strict", ",", "missing_keys", ",", "unexpected_keys", ",", "\n", "error_msgs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_pool.DeformRoIPoolingFunction.forward": [[14, 59], ["torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "data.new_empty", "data.new_empty", "deform_pool_ext.deform_psroi_pooling_forward", "isinstance", "isinstance", "ctx.save_for_backward"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "\n", "data", ",", "\n", "rois", ",", "\n", "offset", ",", "\n", "spatial_scale", ",", "\n", "out_size", ",", "\n", "out_channels", ",", "\n", "no_trans", ",", "\n", "group_size", "=", "1", ",", "\n", "part_size", "=", "None", ",", "\n", "sample_per_part", "=", "4", ",", "\n", "trans_std", "=", ".0", ")", ":", "\n", "# TODO: support unsquare RoIs", "\n", "        ", "out_h", ",", "out_w", "=", "_pair", "(", "out_size", ")", "\n", "assert", "isinstance", "(", "out_h", ",", "int", ")", "and", "isinstance", "(", "out_w", ",", "int", ")", "\n", "assert", "out_h", "==", "out_w", "\n", "out_size", "=", "out_h", "# out_h and out_w must be equal", "\n", "\n", "ctx", ".", "spatial_scale", "=", "spatial_scale", "\n", "ctx", ".", "out_size", "=", "out_size", "\n", "ctx", ".", "out_channels", "=", "out_channels", "\n", "ctx", ".", "no_trans", "=", "no_trans", "\n", "ctx", ".", "group_size", "=", "group_size", "\n", "ctx", ".", "part_size", "=", "out_size", "if", "part_size", "is", "None", "else", "part_size", "\n", "ctx", ".", "sample_per_part", "=", "sample_per_part", "\n", "ctx", ".", "trans_std", "=", "trans_std", "\n", "\n", "assert", "0.0", "<=", "ctx", ".", "trans_std", "<=", "1.0", "\n", "if", "not", "data", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "n", "=", "rois", ".", "shape", "[", "0", "]", "\n", "output", "=", "data", ".", "new_empty", "(", "n", ",", "out_channels", ",", "out_size", ",", "out_size", ")", "\n", "output_count", "=", "data", ".", "new_empty", "(", "n", ",", "out_channels", ",", "out_size", ",", "out_size", ")", "\n", "deform_pool_ext", ".", "deform_psroi_pooling_forward", "(", "\n", "data", ",", "rois", ",", "offset", ",", "output", ",", "output_count", ",", "ctx", ".", "no_trans", ",", "\n", "ctx", ".", "spatial_scale", ",", "ctx", ".", "out_channels", ",", "ctx", ".", "group_size", ",", "ctx", ".", "out_size", ",", "\n", "ctx", ".", "part_size", ",", "ctx", ".", "sample_per_part", ",", "ctx", ".", "trans_std", ")", "\n", "\n", "if", "data", ".", "requires_grad", "or", "rois", ".", "requires_grad", "or", "offset", ".", "requires_grad", ":", "\n", "            ", "ctx", ".", "save_for_backward", "(", "data", ",", "rois", ",", "offset", ")", "\n", "", "ctx", ".", "output_count", "=", "output_count", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_pool.DeformRoIPoolingFunction.backward": [[60, 79], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "deform_pool_ext.deform_psroi_pooling_backward"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "if", "not", "grad_output", ".", "is_cuda", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "data", ",", "rois", ",", "offset", "=", "ctx", ".", "saved_tensors", "\n", "output_count", "=", "ctx", ".", "output_count", "\n", "grad_input", "=", "torch", ".", "zeros_like", "(", "data", ")", "\n", "grad_rois", "=", "None", "\n", "grad_offset", "=", "torch", ".", "zeros_like", "(", "offset", ")", "\n", "\n", "deform_pool_ext", ".", "deform_psroi_pooling_backward", "(", "\n", "grad_output", ",", "data", ",", "rois", ",", "offset", ",", "output_count", ",", "grad_input", ",", "\n", "grad_offset", ",", "ctx", ".", "no_trans", ",", "ctx", ".", "spatial_scale", ",", "ctx", ".", "out_channels", ",", "\n", "ctx", ".", "group_size", ",", "ctx", ".", "out_size", ",", "ctx", ".", "part_size", ",", "ctx", ".", "sample_per_part", ",", "\n", "ctx", ".", "trans_std", ")", "\n", "return", "(", "grad_input", ",", "grad_rois", ",", "grad_offset", ",", "None", ",", "None", ",", "None", ",", "None", ",", "\n", "None", ",", "None", ",", "None", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_pool.DeformRoIPooling.__init__": [[86, 104], ["torch.Module.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "spatial_scale", ",", "\n", "out_size", ",", "\n", "out_channels", ",", "\n", "no_trans", ",", "\n", "group_size", "=", "1", ",", "\n", "part_size", "=", "None", ",", "\n", "sample_per_part", "=", "4", ",", "\n", "trans_std", "=", ".0", ")", ":", "\n", "        ", "super", "(", "DeformRoIPooling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "spatial_scale", "=", "spatial_scale", "\n", "self", ".", "out_size", "=", "_pair", "(", "out_size", ")", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "no_trans", "=", "no_trans", "\n", "self", ".", "group_size", "=", "group_size", "\n", "self", ".", "part_size", "=", "out_size", "if", "part_size", "is", "None", "else", "part_size", "\n", "self", ".", "sample_per_part", "=", "sample_per_part", "\n", "self", ".", "trans_std", "=", "trans_std", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_pool.DeformRoIPooling.forward": [[105, 113], ["deform_roi_pooling", "data.new_empty"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "data", ",", "rois", ",", "offset", ")", ":", "\n", "        ", "if", "self", ".", "no_trans", ":", "\n", "            ", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "", "return", "deform_roi_pooling", "(", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "\n", "self", ".", "out_size", ",", "self", ".", "out_channels", ",", "\n", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "\n", "self", ".", "part_size", ",", "self", ".", "sample_per_part", ",", "\n", "self", ".", "trans_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_pool.DeformRoIPoolingPack.__init__": [[117, 150], ["deform_pool.DeformRoIPooling.__init__", "range", "torch.Sequential", "torch.Sequential", "deform_pool.DeformRoIPoolingPack.offset_fc[].weight.data.zero_", "deform_pool.DeformRoIPoolingPack.offset_fc[].bias.data.zero_", "seq.append", "torch.Linear", "torch.Linear", "seq.append", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "spatial_scale", ",", "\n", "out_size", ",", "\n", "out_channels", ",", "\n", "no_trans", ",", "\n", "group_size", "=", "1", ",", "\n", "part_size", "=", "None", ",", "\n", "sample_per_part", "=", "4", ",", "\n", "trans_std", "=", ".0", ",", "\n", "num_offset_fcs", "=", "3", ",", "\n", "deform_fc_channels", "=", "1024", ")", ":", "\n", "        ", "super", "(", "DeformRoIPoolingPack", ",", "\n", "self", ")", ".", "__init__", "(", "spatial_scale", ",", "out_size", ",", "out_channels", ",", "no_trans", ",", "\n", "group_size", ",", "part_size", ",", "sample_per_part", ",", "trans_std", ")", "\n", "\n", "self", ".", "num_offset_fcs", "=", "num_offset_fcs", "\n", "self", ".", "deform_fc_channels", "=", "deform_fc_channels", "\n", "\n", "if", "not", "no_trans", ":", "\n", "            ", "seq", "=", "[", "]", "\n", "ic", "=", "self", ".", "out_size", "[", "0", "]", "*", "self", ".", "out_size", "[", "1", "]", "*", "self", ".", "out_channels", "\n", "for", "i", "in", "range", "(", "self", ".", "num_offset_fcs", ")", ":", "\n", "                ", "if", "i", "<", "self", ".", "num_offset_fcs", "-", "1", ":", "\n", "                    ", "oc", "=", "self", ".", "deform_fc_channels", "\n", "", "else", ":", "\n", "                    ", "oc", "=", "self", ".", "out_size", "[", "0", "]", "*", "self", ".", "out_size", "[", "1", "]", "*", "2", "\n", "", "seq", ".", "append", "(", "nn", ".", "Linear", "(", "ic", ",", "oc", ")", ")", "\n", "ic", "=", "oc", "\n", "if", "i", "<", "self", ".", "num_offset_fcs", "-", "1", ":", "\n", "                    ", "seq", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "", "", "self", ".", "offset_fc", "=", "nn", ".", "Sequential", "(", "*", "seq", ")", "\n", "self", ".", "offset_fc", "[", "-", "1", "]", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "offset_fc", "[", "-", "1", "]", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_pool.DeformRoIPoolingPack.forward": [[151, 177], ["data.size", "data.new_empty", "data.new_empty", "deform_roi_pooling", "data.new_empty", "deform_roi_pooling", "deform_pool.DeformRoIPoolingPack.offset_fc", "offset.view.view.view", "deform_roi_pooling", "deform_roi_pooling.view"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "", "def", "forward", "(", "self", ",", "data", ",", "rois", ")", ":", "\n", "        ", "assert", "data", ".", "size", "(", "1", ")", "==", "self", ".", "out_channels", "\n", "n", "=", "rois", ".", "shape", "[", "0", "]", "\n", "if", "n", "==", "0", ":", "\n", "            ", "return", "data", ".", "new_empty", "(", "n", ",", "self", ".", "out_channels", ",", "self", ".", "out_size", "[", "0", "]", ",", "\n", "self", ".", "out_size", "[", "1", "]", ")", "\n", "", "if", "self", ".", "no_trans", ":", "\n", "            ", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "return", "deform_roi_pooling", "(", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "\n", "self", ".", "out_size", ",", "self", ".", "out_channels", ",", "\n", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "\n", "self", ".", "part_size", ",", "self", ".", "sample_per_part", ",", "\n", "self", ".", "trans_std", ")", "\n", "", "else", ":", "\n", "            ", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "x", "=", "deform_roi_pooling", "(", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "\n", "self", ".", "out_size", ",", "self", ".", "out_channels", ",", "True", ",", "\n", "self", ".", "group_size", ",", "self", ".", "part_size", ",", "\n", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "\n", "offset", "=", "self", ".", "offset_fc", "(", "x", ".", "view", "(", "n", ",", "-", "1", ")", ")", "\n", "offset", "=", "offset", ".", "view", "(", "n", ",", "2", ",", "self", ".", "out_size", "[", "0", "]", ",", "self", ".", "out_size", "[", "1", "]", ")", "\n", "return", "deform_roi_pooling", "(", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "\n", "self", ".", "out_size", ",", "self", ".", "out_channels", ",", "\n", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "\n", "self", ".", "part_size", ",", "self", ".", "sample_per_part", ",", "\n", "self", ".", "trans_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_pool.ModulatedDeformRoIPoolingPack.__init__": [[181, 233], ["deform_pool.DeformRoIPooling.__init__", "range", "torch.Sequential", "torch.Sequential", "deform_pool.ModulatedDeformRoIPoolingPack.offset_fc[].weight.data.zero_", "deform_pool.ModulatedDeformRoIPoolingPack.offset_fc[].bias.data.zero_", "range", "torch.Sequential", "torch.Sequential", "deform_pool.ModulatedDeformRoIPoolingPack.mask_fc[].weight.data.zero_", "deform_pool.ModulatedDeformRoIPoolingPack.mask_fc[].bias.data.zero_", "offset_fc_seq.append", "mask_fc_seq.append", "torch.Linear", "torch.Linear", "offset_fc_seq.append", "torch.Linear", "torch.Linear", "mask_fc_seq.append", "mask_fc_seq.append", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Sigmoid", "torch.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "spatial_scale", ",", "\n", "out_size", ",", "\n", "out_channels", ",", "\n", "no_trans", ",", "\n", "group_size", "=", "1", ",", "\n", "part_size", "=", "None", ",", "\n", "sample_per_part", "=", "4", ",", "\n", "trans_std", "=", ".0", ",", "\n", "num_offset_fcs", "=", "3", ",", "\n", "num_mask_fcs", "=", "2", ",", "\n", "deform_fc_channels", "=", "1024", ")", ":", "\n", "        ", "super", "(", "ModulatedDeformRoIPoolingPack", ",", "\n", "self", ")", ".", "__init__", "(", "spatial_scale", ",", "out_size", ",", "out_channels", ",", "no_trans", ",", "\n", "group_size", ",", "part_size", ",", "sample_per_part", ",", "trans_std", ")", "\n", "\n", "self", ".", "num_offset_fcs", "=", "num_offset_fcs", "\n", "self", ".", "num_mask_fcs", "=", "num_mask_fcs", "\n", "self", ".", "deform_fc_channels", "=", "deform_fc_channels", "\n", "\n", "if", "not", "no_trans", ":", "\n", "            ", "offset_fc_seq", "=", "[", "]", "\n", "ic", "=", "self", ".", "out_size", "[", "0", "]", "*", "self", ".", "out_size", "[", "1", "]", "*", "self", ".", "out_channels", "\n", "for", "i", "in", "range", "(", "self", ".", "num_offset_fcs", ")", ":", "\n", "                ", "if", "i", "<", "self", ".", "num_offset_fcs", "-", "1", ":", "\n", "                    ", "oc", "=", "self", ".", "deform_fc_channels", "\n", "", "else", ":", "\n", "                    ", "oc", "=", "self", ".", "out_size", "[", "0", "]", "*", "self", ".", "out_size", "[", "1", "]", "*", "2", "\n", "", "offset_fc_seq", ".", "append", "(", "nn", ".", "Linear", "(", "ic", ",", "oc", ")", ")", "\n", "ic", "=", "oc", "\n", "if", "i", "<", "self", ".", "num_offset_fcs", "-", "1", ":", "\n", "                    ", "offset_fc_seq", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "", "", "self", ".", "offset_fc", "=", "nn", ".", "Sequential", "(", "*", "offset_fc_seq", ")", "\n", "self", ".", "offset_fc", "[", "-", "1", "]", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "offset_fc", "[", "-", "1", "]", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "mask_fc_seq", "=", "[", "]", "\n", "ic", "=", "self", ".", "out_size", "[", "0", "]", "*", "self", ".", "out_size", "[", "1", "]", "*", "self", ".", "out_channels", "\n", "for", "i", "in", "range", "(", "self", ".", "num_mask_fcs", ")", ":", "\n", "                ", "if", "i", "<", "self", ".", "num_mask_fcs", "-", "1", ":", "\n", "                    ", "oc", "=", "self", ".", "deform_fc_channels", "\n", "", "else", ":", "\n", "                    ", "oc", "=", "self", ".", "out_size", "[", "0", "]", "*", "self", ".", "out_size", "[", "1", "]", "\n", "", "mask_fc_seq", ".", "append", "(", "nn", ".", "Linear", "(", "ic", ",", "oc", ")", ")", "\n", "ic", "=", "oc", "\n", "if", "i", "<", "self", ".", "num_mask_fcs", "-", "1", ":", "\n", "                    ", "mask_fc_seq", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "", "else", ":", "\n", "                    ", "mask_fc_seq", ".", "append", "(", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "", "", "self", ".", "mask_fc", "=", "nn", ".", "Sequential", "(", "*", "mask_fc_seq", ")", "\n", "self", ".", "mask_fc", "[", "-", "2", "]", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "mask_fc", "[", "-", "2", "]", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.dcn.deform_pool.ModulatedDeformRoIPoolingPack.forward": [[234, 261], ["data.size", "data.new_empty", "data.new_empty", "deform_roi_pooling", "data.new_empty", "deform_roi_pooling", "deform_pool.ModulatedDeformRoIPoolingPack.offset_fc", "offset.view.view.view", "deform_pool.ModulatedDeformRoIPoolingPack.mask_fc", "mask.view.view.view", "deform_roi_pooling.view", "deform_roi_pooling.view", "deform_roi_pooling"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "", "def", "forward", "(", "self", ",", "data", ",", "rois", ")", ":", "\n", "        ", "assert", "data", ".", "size", "(", "1", ")", "==", "self", ".", "out_channels", "\n", "n", "=", "rois", ".", "shape", "[", "0", "]", "\n", "if", "n", "==", "0", ":", "\n", "            ", "return", "data", ".", "new_empty", "(", "n", ",", "self", ".", "out_channels", ",", "self", ".", "out_size", "[", "0", "]", ",", "\n", "self", ".", "out_size", "[", "1", "]", ")", "\n", "", "if", "self", ".", "no_trans", ":", "\n", "            ", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "return", "deform_roi_pooling", "(", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "\n", "self", ".", "out_size", ",", "self", ".", "out_channels", ",", "\n", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "\n", "self", ".", "part_size", ",", "self", ".", "sample_per_part", ",", "\n", "self", ".", "trans_std", ")", "\n", "", "else", ":", "\n", "            ", "offset", "=", "data", ".", "new_empty", "(", "0", ")", "\n", "x", "=", "deform_roi_pooling", "(", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "\n", "self", ".", "out_size", ",", "self", ".", "out_channels", ",", "True", ",", "\n", "self", ".", "group_size", ",", "self", ".", "part_size", ",", "\n", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "\n", "offset", "=", "self", ".", "offset_fc", "(", "x", ".", "view", "(", "n", ",", "-", "1", ")", ")", "\n", "offset", "=", "offset", ".", "view", "(", "n", ",", "2", ",", "self", ".", "out_size", "[", "0", "]", ",", "self", ".", "out_size", "[", "1", "]", ")", "\n", "mask", "=", "self", ".", "mask_fc", "(", "x", ".", "view", "(", "n", ",", "-", "1", ")", ")", "\n", "mask", "=", "mask", ".", "view", "(", "n", ",", "1", ",", "self", ".", "out_size", "[", "0", "]", ",", "self", ".", "out_size", "[", "1", "]", ")", "\n", "return", "deform_roi_pooling", "(", "\n", "data", ",", "rois", ",", "offset", ",", "self", ".", "spatial_scale", ",", "self", ".", "out_size", ",", "\n", "self", ".", "out_channels", ",", "self", ".", "no_trans", ",", "self", ".", "group_size", ",", "\n", "self", ".", "part_size", ",", "self", ".", "sample_per_part", ",", "self", ".", "trans_std", ")", "*", "mask", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.nms": [[9, 62], ["isinstance", "isinstance", "torch.from_numpy().to.new_zeros", "nms_ext.nms.cpu().numpy", "torch.from_numpy().to", "TypeError", "nms_ext.nms", "nms_ext.nms", "nms_ext.nms.cpu", "torch.from_numpy", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.nms", "home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.nms"], ["def", "nms", "(", "dets", ",", "iou_thr", ",", "device_id", "=", "None", ")", ":", "\n", "    ", "\"\"\"Dispatch to either CPU or GPU NMS implementations.\n\n    The input can be either a torch tensor or numpy array. GPU NMS will be used\n    if the input is a gpu tensor or device_id is specified, otherwise CPU NMS\n    will be used. The returned type will always be the same as inputs.\n\n    Arguments:\n        dets (torch.Tensor or np.ndarray): segments with scores.\n        iou_thr (float): IoU threshold for NMS.\n        device_id (int, optional): when `dets` is a numpy array, if `device_id`\n            is None, then cpu nms is used, otherwise gpu_nms will be used.\n\n    Returns:\n        tuple: kept segments and indice, which is always the same data type as\n            the input.\n\n    Example:\n        >>> dets = np.array([[49.1, 51.0, 0.95],\n        >>>                  [49.3, 51.0, 0.9],\n        >>>                  [49.2, 51.0, 0.55],\n        >>>                  [35.1, 39.1, 0.53],\n        >>>                  [35.6, 39.3, 0.5],\n        >>>                  [35.3, 39.9, 0.4],\n        >>>                  [35.2, 39.7, 0.3]], dtype=np.float32)\n        >>> iou_thr = 0.6\n        >>> suppressed, inds = nms(dets, iou_thr)\n        >>> assert len(inds) == len(suppressed) == 3\n    \"\"\"", "\n", "# convert dets (tensor or numpy array) to tensor", "\n", "if", "isinstance", "(", "dets", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "is_numpy", "=", "False", "\n", "dets_th", "=", "dets", "\n", "", "elif", "isinstance", "(", "dets", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "is_numpy", "=", "True", "\n", "device", "=", "'cpu'", "if", "device_id", "is", "None", "else", "f'cuda:{device_id}'", "\n", "dets_th", "=", "torch", ".", "from_numpy", "(", "dets", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'dets must be either a Tensor or numpy array, '", "\n", "f'but got {type(dets)}'", ")", "\n", "\n", "# execute cpu or cuda nms", "\n", "", "if", "dets_th", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "inds", "=", "dets_th", ".", "new_zeros", "(", "0", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "", "else", ":", "\n", "        ", "if", "dets_th", ".", "is_cuda", ":", "\n", "            ", "inds", "=", "nms_ext", ".", "nms", "(", "dets_th", ",", "iou_thr", ")", "\n", "", "else", ":", "\n", "            ", "inds", "=", "nms_ext", ".", "nms", "(", "dets_th", ",", "iou_thr", ")", "\n", "\n", "", "", "if", "is_numpy", ":", "\n", "        ", "inds", "=", "inds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "return", "dets", "[", "inds", ",", ":", "]", ",", "inds", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.soft_nms": [[64, 119], ["isinstance", "nms_ext.soft_nms", "dets.detach().cpu", "isinstance", "ValueError", "torch.from_numpy", "TypeError", "new_dets.to", "inds.to", "new_dets.numpy().astype", "inds.numpy().astype", "dets.detach", "new_dets.numpy", "inds.numpy", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.soft_nms", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to"], ["", "def", "soft_nms", "(", "dets", ",", "iou_thr", ",", "method", "=", "'linear'", ",", "sigma", "=", "0.5", ",", "min_score", "=", "1e-3", ")", ":", "\n", "    ", "\"\"\"Dispatch to only CPU Soft NMS implementations.\n\n    The input can be either a torch tensor or numpy array.\n    The returned type will always be the same as inputs.\n\n    Arguments:\n        dets (torch.Tensor or np.ndarray): segments with scores.\n        iou_thr (float): IoU threshold for Soft NMS.\n        method (str): either 'linear' or 'gaussian'\n        sigma (float): hyperparameter for gaussian method\n        min_score (float): score filter threshold\n\n    Returns:\n        tuple: new det segments and indice, which is always the same\n        data type as the input.\n\n    Example:\n        >>> dets = np.array([[4., 5., 0.95],\n        >>>                  [4., 5., 0.9],\n        >>>                  [3., 4., 0.55],\n        >>>                  [3., 4., 0.5],\n        >>>                  [3., 4., 0.4],\n        >>>                  [3., 4., 0.0]], dtype=np.float32)\n        >>> iou_thr = 0.6\n        >>> new_dets, inds = soft_nms(dets, iou_thr, sigma=0.5)\n        >>> assert len(inds) == len(new_dets) == 2\n    \"\"\"", "\n", "# convert dets (tensor or numpy array) to tensor", "\n", "if", "isinstance", "(", "dets", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "is_tensor", "=", "True", "\n", "dets_t", "=", "dets", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "", "elif", "isinstance", "(", "dets", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "is_tensor", "=", "False", "\n", "dets_t", "=", "torch", ".", "from_numpy", "(", "dets", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'dets must be either a Tensor or numpy array, '", "\n", "f'but got {type(dets)}'", ")", "\n", "\n", "", "method_codes", "=", "{", "'linear'", ":", "1", ",", "'gaussian'", ":", "2", "}", "\n", "if", "method", "not", "in", "method_codes", ":", "\n", "        ", "raise", "ValueError", "(", "f'Invalid method for SoftNMS: {method}'", ")", "\n", "", "results", "=", "nms_ext", ".", "soft_nms", "(", "dets_t", ",", "iou_thr", ",", "method_codes", "[", "method", "]", ",", "sigma", ",", "\n", "min_score", ")", "\n", "\n", "new_dets", "=", "results", "[", ":", ",", ":", "3", "]", "\n", "inds", "=", "results", "[", ":", ",", "3", "]", "\n", "\n", "if", "is_tensor", ":", "\n", "        ", "return", "new_dets", ".", "to", "(", "\n", "device", "=", "dets", ".", "device", ",", "dtype", "=", "dets", ".", "dtype", ")", ",", "inds", ".", "to", "(", "\n", "device", "=", "dets", ".", "device", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "", "else", ":", "\n", "        ", "return", "new_dets", ".", "numpy", "(", ")", ".", "astype", "(", "dets", ".", "dtype", ")", ",", "inds", ".", "numpy", "(", ")", ".", "astype", "(", "\n", "np", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.batched_nms": [[121, 160], ["nms_cfg.copy", "nms_cfg.copy.pop", "nms_cfg.copy.pop", "eval", "eval.", "segments.max", "torch.cat", "torch.cat", "inds.to"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to"], ["", "", "def", "batched_nms", "(", "segments", ",", "scores", ",", "inds", ",", "nms_cfg", ",", "class_agnostic", "=", "False", ")", ":", "\n", "    ", "\"\"\"Performs non-maximum suppression in a batched fashion.\n\n    Modified from https://github.com/pytorch/vision/blob\n    /505cd6957711af790211896d32b40291bea1bc21/torchvision/ops/boxes.py#L39.\n    In order to perform NMS independently per class, we add an offset to all\n    the segments. The offset is dependent only on the class idx, and is large\n    enough so that segments from different classes do not overlap.\n\n    Arguments:\n        segments (torch.Tensor): segments in shape (N, 2).\n        scores (torch.Tensor): scores in shape (N, ).\n        inds (torch.Tensor): each index value correspond to a segment cluster,\n            and NMS will not be applied between elements of different inds,\n            shape (N, ).\n        nms_cfg (dict): specify nms type and class_agnostic as well as other\n            parameters like iou_thr.\n        class_agnostic (bool): if true, nms is class agnostic,\n            i.e. IoU thresholding happens over all segments,\n            regardless of the predicted class\n\n    Returns:\n        tuple: kept segments and indice.\n    \"\"\"", "\n", "nms_cfg_", "=", "nms_cfg", ".", "copy", "(", ")", "\n", "class_agnostic", "=", "nms_cfg_", ".", "pop", "(", "'class_agnostic'", ",", "class_agnostic", ")", "\n", "if", "class_agnostic", ":", "\n", "        ", "segments_for_nms", "=", "segments", "\n", "", "else", ":", "\n", "        ", "max_coordinate", "=", "segments", ".", "max", "(", ")", "\n", "offsets", "=", "inds", ".", "to", "(", "segments", ")", "*", "(", "max_coordinate", "+", "1", ")", "\n", "segments_for_nms", "=", "segments", "+", "offsets", "[", ":", ",", "None", "]", "\n", "", "nms_type", "=", "nms_cfg_", ".", "pop", "(", "'typename'", ",", "'nms'", ")", "\n", "nms_op", "=", "eval", "(", "nms_type", ")", "\n", "dets", ",", "keep", "=", "nms_op", "(", "\n", "torch", ".", "cat", "(", "[", "segments_for_nms", ",", "scores", "[", ":", ",", "None", "]", "]", ",", "-", "1", ")", ",", "**", "nms_cfg_", ")", "\n", "segments", "=", "segments", "[", "keep", "]", "\n", "scores", "=", "dets", "[", ":", ",", "-", "1", "]", "\n", "return", "torch", ".", "cat", "(", "[", "segments", ",", "scores", "[", ":", ",", "None", "]", "]", ",", "-", "1", ")", ",", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.nms_match": [[162, 194], ["isinstance", "isinstance", "nms_ext.nms_match", "dets.detach().cpu", "torch.from_numpy", "dets.new_tensor", "numpy.array", "dets.detach"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.nms_match"], ["", "def", "nms_match", "(", "dets", ",", "thresh", ")", ":", "\n", "    ", "\"\"\"Matched dets into different groups by NMS.\n\n    NMS match is Similar to NMS but when a segment is suppressed, nms match\n    will record the indice of supporessed segment and form a group with the\n    indice of kept segment. In each group, indice is sorted as score order.\n\n    Arguments:\n        dets (torch.Tensor | np.ndarray): Det segments with scores, shape\n            (N, 3).\n        iou_thr (float): IoU thresh for NMS.\n\n    Returns:\n        List[Tensor | ndarray]: The outer list corresponds different matched\n            group, the inner Tensor corresponds the indices for a group in\n            score order.\n    \"\"\"", "\n", "if", "dets", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "matched", "=", "[", "]", "\n", "", "else", ":", "\n", "        ", "assert", "dets", ".", "shape", "[", "-", "1", "]", "==", "3", ",", "'inputs dets.shape should be (N, 3), '", "f'but get {dets.shape}'", "\n", "if", "isinstance", "(", "dets", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "dets_t", "=", "dets", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "", "else", ":", "\n", "            ", "dets_t", "=", "torch", ".", "from_numpy", "(", "dets", ")", "\n", "", "matched", "=", "nms_ext", ".", "nms_match", "(", "dets_t", ",", "thresh", ")", "\n", "\n", "", "if", "isinstance", "(", "dets", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "[", "dets", ".", "new_tensor", "(", "m", ",", "dtype", "=", "torch", ".", "long", ")", "for", "m", "in", "matched", "]", "\n", "", "else", ":", "\n", "        ", "return", "[", "np", ".", "array", "(", "m", ",", "dtype", "=", "np", ".", "int", ")", "for", "m", "in", "matched", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.sigmoid_focal_loss.sigmoid_focal_loss.SigmoidFocalLossFunction.forward": [[12, 23], ["ctx.save_for_backward", "sigmoid_focal_loss_ext.forward"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.forward"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ",", "target", ",", "gamma", "=", "2.0", ",", "alpha", "=", "0.25", ")", ":", "\n", "        ", "ctx", ".", "save_for_backward", "(", "input", ",", "target", ")", "\n", "num_classes", "=", "input", ".", "shape", "[", "1", "]", "\n", "ctx", ".", "num_classes", "=", "num_classes", "\n", "ctx", ".", "gamma", "=", "gamma", "\n", "ctx", ".", "alpha", "=", "alpha", "\n", "\n", "loss", "=", "sigmoid_focal_loss_ext", ".", "forward", "(", "input", ",", "target", ",", "num_classes", ",", "\n", "gamma", ",", "alpha", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.sigmoid_focal_loss.sigmoid_focal_loss.SigmoidFocalLossFunction.backward": [[24, 35], ["d_loss.contiguous.contiguous.contiguous", "sigmoid_focal_loss_ext.backward"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.sigmoid_focal_loss.sigmoid_focal_loss.SigmoidFocalLossFunction.backward"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "d_loss", ")", ":", "\n", "        ", "input", ",", "target", "=", "ctx", ".", "saved_tensors", "\n", "num_classes", "=", "ctx", ".", "num_classes", "\n", "gamma", "=", "ctx", ".", "gamma", "\n", "alpha", "=", "ctx", ".", "alpha", "\n", "d_loss", "=", "d_loss", ".", "contiguous", "(", ")", "\n", "d_input", "=", "sigmoid_focal_loss_ext", ".", "backward", "(", "input", ",", "target", ",", "d_loss", ",", "\n", "num_classes", ",", "gamma", ",", "alpha", ")", "\n", "return", "d_input", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.sigmoid_focal_loss.sigmoid_focal_loss.SigmoidFocalLoss.__init__": [[43, 47], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "gamma", ",", "alpha", ")", ":", "\n", "        ", "super", "(", "SigmoidFocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.sigmoid_focal_loss.sigmoid_focal_loss.SigmoidFocalLoss.forward": [[48, 52], ["sigmoid_focal_loss", "sigmoid_focal_loss.sum"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.focal_loss.sigmoid_focal_loss"], ["", "def", "forward", "(", "self", ",", "logits", ",", "targets", ")", ":", "\n", "        ", "assert", "logits", ".", "is_cuda", "\n", "loss", "=", "sigmoid_focal_loss", "(", "logits", ",", "targets", ",", "self", ".", "gamma", ",", "self", ".", "alpha", ")", "\n", "return", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.sigmoid_focal_loss.sigmoid_focal_loss.SigmoidFocalLoss.__repr__": [[53, 57], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "tmpstr", "=", "self", ".", "__class__", ".", "__name__", "\n", "tmpstr", "+=", "f'(gamma={self.gamma}, alpha={self.alpha})'", "\n", "return", "tmpstr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load": [[16, 47], ["isinstance", "misc.is_str", "str", "misc.is_str", "TypeError", "handler.load_from_path", "hasattr", "str.split", "handler.load_from_fileobj", "TypeError"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str", "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.load_from_path", "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.load_from_fileobj"], ["def", "load", "(", "file", ",", "file_format", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Load data from json/yaml/pickle files.\n\n    This method provides a unified api for loading data from serialized files.\n\n    Args:\n        file (str or :obj:`Path` or file-like object): Filename or a file-like\n            object.\n        file_format (str, optional): If not specified, the file format will be\n            inferred from the file extension, otherwise use the specified one.\n            Currently supported formats include \"json\", \"yaml/yml\" and\n            \"pickle/pkl\".\n\n    Returns:\n        The content from the file.\n    \"\"\"", "\n", "if", "isinstance", "(", "file", ",", "Path", ")", ":", "\n", "        ", "file", "=", "str", "(", "file", ")", "\n", "", "if", "file_format", "is", "None", "and", "is_str", "(", "file", ")", ":", "\n", "        ", "file_format", "=", "file", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "", "if", "file_format", "not", "in", "file_handlers", ":", "\n", "        ", "raise", "TypeError", "(", "f'Unsupported format: {file_format}'", ")", "\n", "\n", "", "handler", "=", "file_handlers", "[", "file_format", "]", "\n", "if", "is_str", "(", "file", ")", ":", "\n", "        ", "obj", "=", "handler", ".", "load_from_path", "(", "file", ",", "**", "kwargs", ")", "\n", "", "elif", "hasattr", "(", "file", ",", "'read'", ")", ":", "\n", "        ", "obj", "=", "handler", ".", "load_from_fileobj", "(", "file", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'\"file\" must be a filepath str or a file-object'", ")", "\n", "", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.dump": [[49, 85], ["isinstance", "str", "misc.is_str", "TypeError", "handler.dump_to_str", "misc.is_str", "handler.dump_to_path", "hasattr", "str.split", "ValueError", "handler.dump_to_fileobj", "TypeError"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str", "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.dump_to_str", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str", "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.dump_to_path", "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.dump_to_fileobj"], ["", "def", "dump", "(", "obj", ",", "file", "=", "None", ",", "file_format", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Dump data to json/yaml/pickle strings or files.\n\n    This method provides a unified api for dumping data as strings or to files,\n    and also supports custom arguments for each file format.\n\n    Args:\n        obj (any): The python object to be dumped.\n        file (str or :obj:`Path` or file-like object, optional): If not\n            specified, then the object is dump to a str, otherwise to a file\n            specified by the filename or file-like object.\n        file_format (str, optional): Same as :func:`load`.\n\n    Returns:\n        bool: True for success, False otherwise.\n    \"\"\"", "\n", "if", "isinstance", "(", "file", ",", "Path", ")", ":", "\n", "        ", "file", "=", "str", "(", "file", ")", "\n", "", "if", "file_format", "is", "None", ":", "\n", "        ", "if", "is_str", "(", "file", ")", ":", "\n", "            ", "file_format", "=", "file", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "", "elif", "file", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "'file_format must be specified since file is None'", ")", "\n", "", "", "if", "file_format", "not", "in", "file_handlers", ":", "\n", "        ", "raise", "TypeError", "(", "f'Unsupported format: {file_format}'", ")", "\n", "\n", "", "handler", "=", "file_handlers", "[", "file_format", "]", "\n", "if", "file", "is", "None", ":", "\n", "        ", "return", "handler", ".", "dump_to_str", "(", "obj", ",", "**", "kwargs", ")", "\n", "", "elif", "is_str", "(", "file", ")", ":", "\n", "        ", "handler", ".", "dump_to_path", "(", "obj", ",", "file", ",", "**", "kwargs", ")", "\n", "", "elif", "hasattr", "(", "file", ",", "'write'", ")", ":", "\n", "        ", "handler", ".", "dump_to_fileobj", "(", "obj", ",", "file", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'\"file\" must be a filename str or a file-object'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io._register_handler": [[87, 104], ["isinstance", "isinstance", "TypeError", "misc.is_list_of", "TypeError", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_list_of"], ["", "", "def", "_register_handler", "(", "handler", ",", "file_formats", ")", ":", "\n", "    ", "\"\"\"Register a handler for some file extensions.\n\n    Args:\n        handler (:obj:`BaseFileHandler`): Handler to be registered.\n        file_formats (str or list[str]): File formats to be handled by this\n            handler.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "handler", ",", "BaseFileHandler", ")", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "f'handler must be a child of BaseFileHandler, not {type(handler)}'", ")", "\n", "", "if", "isinstance", "(", "file_formats", ",", "str", ")", ":", "\n", "        ", "file_formats", "=", "[", "file_formats", "]", "\n", "", "if", "not", "is_list_of", "(", "file_formats", ",", "str", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'file_formats must be a str or a list of str'", ")", "\n", "", "for", "ext", "in", "file_formats", ":", "\n", "        ", "file_handlers", "[", "ext", "]", "=", "handler", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.register_handler": [[106, 113], ["io._register_handler", "cls"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io._register_handler"], ["", "", "def", "register_handler", "(", "file_formats", ",", "**", "kwargs", ")", ":", "\n", "\n", "    ", "def", "wrap", "(", "cls", ")", ":", "\n", "        ", "_register_handler", "(", "cls", "(", "**", "kwargs", ")", ",", "file_formats", ")", "\n", "return", "cls", "\n", "\n", "", "return", "wrap", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.BaseStorageBackend.get": [[13, 16], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.BaseStorageBackend.get_text": [[17, 20], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.CephBackend.__init__": [[31, 41], ["ceph.S3Client", "warnings.warn", "isinstance", "ImportError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "path_mapping", "=", "None", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "import", "ceph", "\n", "warnings", ".", "warn", "(", "'Ceph is deprecate in favor of Petrel.'", ")", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please install ceph to enable CephBackend.'", ")", "\n", "\n", "", "self", ".", "_client", "=", "ceph", ".", "S3Client", "(", ")", "\n", "assert", "isinstance", "(", "path_mapping", ",", "dict", ")", "or", "path_mapping", "is", "None", "\n", "self", ".", "path_mapping", "=", "path_mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.CephBackend.get": [[42, 50], ["str", "file_client.CephBackend._client.Get", "memoryview", "file_client.CephBackend.path_mapping.items", "filepath.replace.replace.replace"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "filepath", "=", "str", "(", "filepath", ")", "\n", "if", "self", ".", "path_mapping", "is", "not", "None", ":", "\n", "            ", "for", "k", ",", "v", "in", "self", ".", "path_mapping", ".", "items", "(", ")", ":", "\n", "                ", "filepath", "=", "filepath", ".", "replace", "(", "k", ",", "v", ")", "\n", "", "", "value", "=", "self", ".", "_client", ".", "Get", "(", "filepath", ")", "\n", "value_buf", "=", "memoryview", "(", "value", ")", "\n", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.CephBackend.get_text": [[51, 53], ["None"], "methods", ["None"], ["", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.PetrelBackend.__init__": [[65, 75], ["client.Client", "isinstance", "ImportError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "path_mapping", "=", "None", ",", "enable_mc", "=", "True", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from", "petrel_client", "import", "client", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please install petrel_client to enable '", "\n", "'PetrelBackend.'", ")", "\n", "\n", "", "self", ".", "_client", "=", "client", ".", "Client", "(", "enable_mc", "=", "enable_mc", ")", "\n", "assert", "isinstance", "(", "path_mapping", ",", "dict", ")", "or", "path_mapping", "is", "None", "\n", "self", ".", "path_mapping", "=", "path_mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.PetrelBackend.get": [[76, 84], ["str", "file_client.PetrelBackend._client.Get", "memoryview", "file_client.PetrelBackend.path_mapping.items", "filepath.replace.replace.replace"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "filepath", "=", "str", "(", "filepath", ")", "\n", "if", "self", ".", "path_mapping", "is", "not", "None", ":", "\n", "            ", "for", "k", ",", "v", "in", "self", ".", "path_mapping", ".", "items", "(", ")", ":", "\n", "                ", "filepath", "=", "filepath", ".", "replace", "(", "k", ",", "v", ")", "\n", "", "", "value", "=", "self", ".", "_client", ".", "Get", "(", "filepath", ")", "\n", "value_buf", "=", "memoryview", "(", "value", ")", "\n", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.PetrelBackend.get_text": [[85, 87], ["None"], "methods", ["None"], ["", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.MemcachedBackend.__init__": [[99, 115], ["mc.MemcachedClient.GetInstance", "mc.pyvector", "sys.path.append", "ImportError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "server_list_cfg", ",", "client_cfg", ",", "sys_path", "=", "None", ")", ":", "\n", "        ", "if", "sys_path", "is", "not", "None", ":", "\n", "            ", "import", "sys", "\n", "sys", ".", "path", ".", "append", "(", "sys_path", ")", "\n", "", "try", ":", "\n", "            ", "import", "mc", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "\n", "'Please install memcached to enable MemcachedBackend.'", ")", "\n", "\n", "", "self", ".", "server_list_cfg", "=", "server_list_cfg", "\n", "self", ".", "client_cfg", "=", "client_cfg", "\n", "self", ".", "_client", "=", "mc", ".", "MemcachedClient", ".", "GetInstance", "(", "self", ".", "server_list_cfg", ",", "\n", "self", ".", "client_cfg", ")", "\n", "# mc.pyvector servers as a point which points to a memory cache", "\n", "self", ".", "_mc_buffer", "=", "mc", ".", "pyvector", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.MemcachedBackend.get": [[116, 122], ["str", "file_client.MemcachedBackend._client.Get", "mc.ConvertBuffer"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "filepath", "=", "str", "(", "filepath", ")", "\n", "import", "mc", "\n", "self", ".", "_client", ".", "Get", "(", "filepath", ",", "self", ".", "_mc_buffer", ")", "\n", "value_buf", "=", "mc", ".", "ConvertBuffer", "(", "self", ".", "_mc_buffer", ")", "\n", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.MemcachedBackend.get_text": [[123, 125], ["None"], "methods", ["None"], ["", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.LmdbBackend.__init__": [[145, 163], ["str", "lmdb.open", "ImportError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "db_path", ",", "\n", "readonly", "=", "True", ",", "\n", "lock", "=", "False", ",", "\n", "readahead", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "import", "lmdb", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please install lmdb to enable LmdbBackend.'", ")", "\n", "\n", "", "self", ".", "db_path", "=", "str", "(", "db_path", ")", "\n", "self", ".", "_client", "=", "lmdb", ".", "open", "(", "\n", "self", ".", "db_path", ",", "\n", "readonly", "=", "readonly", ",", "\n", "lock", "=", "lock", ",", "\n", "readahead", "=", "readahead", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.LmdbBackend.get": [[164, 174], ["str", "file_client.LmdbBackend._client.begin", "txn.get", "str.encode"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.encode"], ["", "def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "\"\"\"Get values according to the filepath.\n\n        Args:\n            filepath (str | obj:`Path`): Here, filepath is the lmdb key.\n        \"\"\"", "\n", "filepath", "=", "str", "(", "filepath", ")", "\n", "with", "self", ".", "_client", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "value_buf", "=", "txn", ".", "get", "(", "filepath", ".", "encode", "(", "'ascii'", ")", ")", "\n", "", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.LmdbBackend.get_text": [[175, 177], ["None"], "methods", ["None"], ["", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.HardDiskBackend.get": [[182, 187], ["str", "open", "f.read"], "methods", ["None"], ["def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "filepath", "=", "str", "(", "filepath", ")", "\n", "with", "open", "(", "filepath", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "value_buf", "=", "f", ".", "read", "(", ")", "\n", "", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.HardDiskBackend.get_text": [[188, 193], ["str", "open", "f.read"], "methods", ["None"], ["", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "filepath", "=", "str", "(", "filepath", ")", "\n", "with", "open", "(", "filepath", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "value_buf", "=", "f", ".", "read", "(", ")", "\n", "", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.FileClient.__init__": [[216, 223], ["ValueError", "list", "file_client.FileClient._backends.keys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "backend", "=", "'disk'", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "backend", "not", "in", "self", ".", "_backends", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f'Backend {backend} is not supported. Currently supported ones'", "\n", "f' are {list(self._backends.keys())}'", ")", "\n", "", "self", ".", "backend", "=", "backend", "\n", "self", ".", "client", "=", "self", ".", "_backends", "[", "backend", "]", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.FileClient._register_backend": [[224, 241], ["isinstance", "TypeError", "inspect.isclass", "TypeError", "issubclass", "TypeError", "KeyError", "type", "type"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_register_backend", "(", "cls", ",", "name", ",", "backend", ",", "force", "=", "False", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "name", ",", "str", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'the backend name should be a string, '", "\n", "f'but got {type(name)}'", ")", "\n", "", "if", "not", "inspect", ".", "isclass", "(", "backend", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "f'backend should be a class but got {type(backend)}'", ")", "\n", "", "if", "not", "issubclass", "(", "backend", ",", "BaseStorageBackend", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "f'backend {backend} is not a subclass of BaseStorageBackend'", ")", "\n", "", "if", "not", "force", "and", "name", "in", "cls", ".", "_backends", ":", "\n", "            ", "raise", "KeyError", "(", "\n", "f'{name} is already registered as a storage backend, '", "\n", "'add \"force=True\" if you want to override it'", ")", "\n", "\n", "", "cls", ".", "_backends", "[", "name", "]", "=", "backend", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.FileClient.register_backend": [[242, 291], ["cls._register_backend", "cls._register_backend"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.FileClient._register_backend", "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.FileClient._register_backend"], ["", "@", "classmethod", "\n", "def", "register_backend", "(", "cls", ",", "name", ",", "backend", "=", "None", ",", "force", "=", "False", ")", ":", "\n", "        ", "\"\"\"Register a backend to FileClient.\n\n        This method can be used as a normal class method or a decorator.\n\n        .. code-block:: python\n\n            class NewBackend(BaseStorageBackend):\n\n                def get(self, filepath):\n                    return filepath\n\n                def get_text(self, filepath):\n                    return filepath\n\n            FileClient.register_backend('new', NewBackend)\n\n        or\n\n        .. code-block:: python\n\n            @FileClient.register_backend('new')\n            class NewBackend(BaseStorageBackend):\n\n                def get(self, filepath):\n                    return filepath\n\n                def get_text(self, filepath):\n                    return filepath\n\n        Args:\n            name (str): The name of the registered backend.\n            backend (class, optional): The backend class to be registered,\n                which must be a subclass of :class:`BaseStorageBackend`.\n                When this method is used as a decorator, backend is None.\n                Defaults to None.\n            force (bool, optional): Whether to override the backend if the name\n                has already been registered. Defaults to False.\n        \"\"\"", "\n", "if", "backend", "is", "not", "None", ":", "\n", "            ", "cls", ".", "_register_backend", "(", "name", ",", "backend", ",", "force", "=", "force", ")", "\n", "return", "\n", "\n", "", "def", "_register", "(", "backend_cls", ")", ":", "\n", "            ", "cls", ".", "_register_backend", "(", "name", ",", "backend_cls", ",", "force", "=", "force", ")", "\n", "return", "backend_cls", "\n", "\n", "", "return", "_register", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.FileClient.get": [[292, 294], ["file_client.FileClient.client.get"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "return", "self", ".", "client", ".", "get", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.FileClient.get_text": [[295, 297], ["file_client.FileClient.client.get_text"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.file_client.FileClient.get_text"], ["", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "return", "self", ".", "client", ".", "get_text", "(", "filepath", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.parse.list_from_file": [[2, 26], ["open", "range", "f.readline", "item_list.append", "line.rstrip"], "function", ["None"], ["def", "list_from_file", "(", "filename", ",", "prefix", "=", "''", ",", "offset", "=", "0", ",", "max_num", "=", "0", ")", ":", "\n", "    ", "\"\"\"Load a text file and parse the content as a list of strings.\n\n    Args:\n        filename (str): Filename.\n        prefix (str): The prefix to be inserted to the begining of each item.\n        offset (int): The offset of lines.\n        max_num (int): The maximum number of lines to be read,\n            zeros and negatives mean no limitation.\n\n    Returns:\n        list[str]: A list of strings.\n    \"\"\"", "\n", "cnt", "=", "0", "\n", "item_list", "=", "[", "]", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "for", "_", "in", "range", "(", "offset", ")", ":", "\n", "            ", "f", ".", "readline", "(", ")", "\n", "", "for", "line", "in", "f", ":", "\n", "            ", "if", "max_num", ">", "0", "and", "cnt", ">=", "max_num", ":", "\n", "                ", "break", "\n", "", "item_list", ".", "append", "(", "prefix", "+", "line", ".", "rstrip", "(", "'\\n'", ")", ")", "\n", "cnt", "+=", "1", "\n", "", "", "return", "item_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.parse.dict_from_file": [[28, 52], ["open", "line.rstrip().split", "key_type", "len", "line.rstrip", "len"], "function", ["None"], ["", "def", "dict_from_file", "(", "filename", ",", "key_type", "=", "str", ")", ":", "\n", "    ", "\"\"\"Load a text file and parse the content as a dict.\n\n    Each line of the text file will be two or more columns splited by\n    whitespaces or tabs. The first column will be parsed as dict keys, and\n    the following columns will be parsed as dict values.\n\n    Args:\n        filename(str): Filename.\n        key_type(type): Type of the dict's keys. str is user by default and\n            type conversion will be performed if specified.\n\n    Returns:\n        dict: The parsed contents.\n    \"\"\"", "\n", "mapping", "=", "{", "}", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "for", "line", "in", "f", ":", "\n", "            ", "items", "=", "line", ".", "rstrip", "(", "'\\n'", ")", ".", "split", "(", ")", "\n", "assert", "len", "(", "items", ")", ">=", "2", "\n", "key", "=", "key_type", "(", "items", "[", "0", "]", ")", "\n", "val", "=", "items", "[", "1", ":", "]", "if", "len", "(", "items", ")", ">", "2", "else", "items", "[", "1", "]", "\n", "mapping", "[", "key", "]", "=", "val", "\n", "", "", "return", "mapping", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.json_handler.JsonHandler.load_from_fileobj": [[9, 11], ["json.load"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load"], ["    ", "def", "load_from_fileobj", "(", "self", ",", "file", ")", ":", "\n", "        ", "return", "json", ".", "load", "(", "file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.json_handler.JsonHandler.dump_to_fileobj": [[12, 14], ["json.dump"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump"], ["", "def", "dump_to_fileobj", "(", "self", ",", "obj", ",", "file", ",", "**", "kwargs", ")", ":", "\n", "        ", "json", ".", "dump", "(", "obj", ",", "file", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.json_handler.JsonHandler.dump_to_str": [[15, 17], ["json.dumps"], "methods", ["None"], ["", "def", "dump_to_str", "(", "self", ",", "obj", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "json", ".", "dumps", "(", "obj", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.base.BaseFileHandler.load_from_fileobj": [[7, 10], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "load_from_fileobj", "(", "self", ",", "file", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.base.BaseFileHandler.dump_to_fileobj": [[11, 14], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "dump_to_fileobj", "(", "self", ",", "obj", ",", "file", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.base.BaseFileHandler.dump_to_str": [[15, 18], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "dump_to_str", "(", "self", ",", "obj", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.base.BaseFileHandler.load_from_path": [[19, 22], ["open", "base.BaseFileHandler.load_from_fileobj"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.load_from_fileobj"], ["", "def", "load_from_path", "(", "self", ",", "filepath", ",", "mode", "=", "'r'", ",", "**", "kwargs", ")", ":", "\n", "        ", "with", "open", "(", "filepath", ",", "mode", ")", "as", "f", ":", "\n", "            ", "return", "self", ".", "load_from_fileobj", "(", "f", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.base.BaseFileHandler.dump_to_path": [[23, 26], ["open", "base.BaseFileHandler.dump_to_fileobj"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.dump_to_fileobj"], ["", "", "def", "dump_to_path", "(", "self", ",", "obj", ",", "filepath", ",", "mode", "=", "'w'", ",", "**", "kwargs", ")", ":", "\n", "        ", "with", "open", "(", "filepath", ",", "mode", ")", "as", "f", ":", "\n", "            ", "self", ".", "dump_to_fileobj", "(", "obj", ",", "f", ",", "**", "kwargs", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.yaml_handler.YamlHandler.load_from_fileobj": [[15, 18], ["kwargs.setdefault", "yaml.load"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load"], ["    ", "def", "load_from_fileobj", "(", "self", ",", "file", ",", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", ".", "setdefault", "(", "'Loader'", ",", "Loader", ")", "\n", "return", "yaml", ".", "load", "(", "file", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.yaml_handler.YamlHandler.dump_to_fileobj": [[19, 22], ["kwargs.setdefault", "yaml.dump"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump"], ["", "def", "dump_to_fileobj", "(", "self", ",", "obj", ",", "file", ",", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", ".", "setdefault", "(", "'Dumper'", ",", "Dumper", ")", "\n", "yaml", ".", "dump", "(", "obj", ",", "file", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.yaml_handler.YamlHandler.dump_to_str": [[23, 26], ["kwargs.setdefault", "yaml.dump"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump"], ["", "def", "dump_to_str", "(", "self", ",", "obj", ",", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", ".", "setdefault", "(", "'Dumper'", ",", "Dumper", ")", "\n", "return", "yaml", ".", "dump", "(", "obj", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.load_from_fileobj": [[9, 11], ["pickle.load"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load"], ["    ", "def", "load_from_fileobj", "(", "self", ",", "file", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "pickle", ".", "load", "(", "file", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.load_from_path": [[12, 15], ["super().load_from_path"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.load_from_path"], ["", "def", "load_from_path", "(", "self", ",", "filepath", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "super", "(", "PickleHandler", ",", "self", ")", ".", "load_from_path", "(", "\n", "filepath", ",", "mode", "=", "'rb'", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.dump_to_str": [[16, 19], ["kwargs.setdefault", "pickle.dumps"], "methods", ["None"], ["", "def", "dump_to_str", "(", "self", ",", "obj", ",", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", ".", "setdefault", "(", "'protocol'", ",", "2", ")", "\n", "return", "pickle", ".", "dumps", "(", "obj", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.dump_to_fileobj": [[20, 23], ["kwargs.setdefault", "pickle.dump"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump"], ["", "def", "dump_to_fileobj", "(", "self", ",", "obj", ",", "file", ",", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", ".", "setdefault", "(", "'protocol'", ",", "2", ")", "\n", "pickle", ".", "dump", "(", "obj", ",", "file", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.dump_to_path": [[24, 27], ["super().dump_to_path"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.handlers.pickle_handler.PickleHandler.dump_to_path"], ["", "def", "dump_to_path", "(", "self", ",", "obj", ",", "filepath", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "PickleHandler", ",", "self", ")", ".", "dump_to_path", "(", "\n", "obj", ",", "filepath", ",", "mode", "=", "'wb'", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.__init__": [[17, 38], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "modes", ",", "dataloaders", ",", "engines", ",", "hook_pool", ",", "logger", ",", "\n", "workdir", ")", ":", "\n", "        ", "for", "mode", "in", "modes", ":", "\n", "            ", "assert", "mode", "in", "BaseLooper", ".", "MODES", "\n", "assert", "mode", "in", "dataloaders", "\n", "assert", "mode", "in", "engines", "\n", "\n", "", "self", ".", "modes", "=", "modes", "\n", "self", ".", "dataloaders", "=", "dataloaders", "\n", "self", ".", "engines", "=", "engines", "\n", "self", ".", "cur_results", "=", "{", "BaseLooper", ".", "TRAIN", ":", "None", ",", "BaseLooper", ".", "VAL", ":", "None", "}", "\n", "self", ".", "his_results", "=", "{", "BaseLooper", ".", "TRAIN", ":", "None", ",", "BaseLooper", ".", "VAL", ":", "None", "}", "\n", "self", ".", "hook_pool", "=", "hook_pool", "\n", "self", ".", "logger", "=", "logger", "\n", "self", ".", "workdir", "=", "workdir", "\n", "\n", "self", ".", "meta", "=", "None", "\n", "self", ".", "_iter", "=", "0", "\n", "self", ".", "_inner_iter", "=", "0", "\n", "self", ".", "_epoch", "=", "0", "\n", "self", ".", "_mode", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.start": [[39, 42], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "start", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.train_engine": [[43, 46], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "train_engine", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "engines", "[", "BaseLooper", ".", "TRAIN", "]", ".", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.val_engine": [[47, 50], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "val_engine", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "engines", "[", "BaseLooper", ".", "VAL", "]", ".", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.train_dataloader": [[51, 54], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "train_dataloader", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "dataloaders", "[", "BaseLooper", ".", "TRAIN", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.val_dataloader": [[55, 58], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "val_dataloader", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "dataloaders", "[", "BaseLooper", ".", "VAL", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.train_dataset": [[59, 62], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "train_dataset", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "train_dataloader", ".", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.val_dataset": [[63, 66], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "val_dataset", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "val_dataloader", ".", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.cur_train_results": [[67, 70], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "cur_train_results", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "cur_results", "[", "BaseLooper", ".", "TRAIN", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.his_train_results": [[71, 74], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "his_train_results", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "his_results", "[", "BaseLooper", ".", "TRAIN", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.cur_val_results": [[75, 78], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "cur_val_results", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "cur_results", "[", "BaseLooper", ".", "VAL", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.his_val_results": [[83, 86], ["None"], "methods", ["None"], ["", "@", "his_val_results", ".", "setter", "\n", "def", "his_val_results", "(", "self", ",", "data", ")", ":", "\n", "        ", "self", ".", "his_results", "[", "BaseLooper", ".", "VAL", "]", "=", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.iter": [[87, 90], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "iter", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.inner_iter": [[91, 94], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "inner_iter", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_inner_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.epoch": [[95, 98], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "epoch", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.load_weights": [[99, 120], ["torch.cuda.is_available", "base_looper.BaseLooper.logger.info", "base_looper.BaseLooper.engines.values", "torch.cuda.current_device", "vedacore.parallel.is_module_wrapper", "vedacore.misc.load_weights", "storage.cuda"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.utils.is_module_wrapper", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_weights"], ["", "def", "load_weights", "(", "self", ",", "\n", "filepath", ",", "\n", "map_location", "=", "'cpu'", ",", "\n", "strict", "=", "False", ",", "\n", "prefix", "=", "None", ")", ":", "\n", "        ", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "device_id", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", "\n", "\n", "# map_location = lambda storage, loc: storage.cuda(device_id)", "\n", "def", "map_location", "(", "storage", ",", "loc", ")", ":", "\n", "                ", "storage", ".", "cuda", "(", "device_id", ")", "\n", "\n", "", "", "self", ".", "logger", ".", "info", "(", "'Loading weights from %s'", ",", "filepath", ")", "\n", "# Wether to load train or val engine is OK", "\n", "# they share the same model", "\n", "for", "engine", "in", "self", ".", "engines", ".", "values", "(", ")", ":", "\n", "            ", "if", "is_module_wrapper", "(", "engine", ")", ":", "\n", "                ", "engine", "=", "engine", ".", "module", "\n", "", "model", "=", "engine", ".", "model", "\n", "load_weights", "(", "model", ",", "filepath", ",", "map_location", ",", "strict", ",", "self", ".", "logger", ",", "\n", "prefix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.load_optimizer": [[121, 137], ["torch.cuda.is_available", "base_looper.BaseLooper.logger.info", "vedacore.parallel.is_module_wrapper", "vedacore.misc.load_optimizer", "torch.cuda.current_device", "storage.cuda"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.utils.is_module_wrapper", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_optimizer"], ["", "", "def", "load_optimizer", "(", "self", ",", "filepath", ",", "map_location", "=", "'cpu'", ")", ":", "\n", "        ", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "device_id", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", "\n", "\n", "# map_location = lambda storage, loc: storage.cuda(device_id)", "\n", "def", "map_location", "(", "storage", ",", "loc", ")", ":", "\n", "                ", "storage", ".", "cuda", "(", "device_id", ")", "\n", "\n", "", "", "self", ".", "logger", ".", "info", "(", "'Loading optimizer from %s'", ",", "filepath", ")", "\n", "# Wether to load train or val engine is OK", "\n", "# they share the same model", "\n", "engine", "=", "self", ".", "train_engine", "\n", "if", "is_module_wrapper", "(", "engine", ")", ":", "\n", "            ", "engine", "=", "engine", ".", "module", "\n", "", "optimizer", "=", "engine", ".", "optimizer", "\n", "load_optimizer", "(", "optimizer", ",", "filepath", ",", "map_location", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.load_meta": [[138, 152], ["torch.cuda.is_available", "base_looper.BaseLooper.logger.info", "vedacore.misc.load_meta", "torch.cuda.current_device", "storage.cuda"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_meta"], ["", "def", "load_meta", "(", "self", ",", "filepath", ",", "map_location", "=", "'cpu'", ")", ":", "\n", "        ", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "device_id", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", "\n", "\n", "# map_location = lambda storage, loc: storage.cuda(device_id)", "\n", "def", "map_location", "(", "storage", ",", "loc", ")", ":", "\n", "                ", "storage", ".", "cuda", "(", "device_id", ")", "\n", "\n", "", "", "self", ".", "logger", ".", "info", "(", "'Loading meta from %s'", ",", "filepath", ")", "\n", "# Wether to load train or val engine is OK", "\n", "# they share the same model", "\n", "meta", "=", "load_meta", "(", "filepath", ",", "map_location", ")", "\n", "self", ".", "_epoch", "=", "meta", "[", "'epoch'", "]", "\n", "self", ".", "_iter", "=", "meta", "[", "'iter'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.save_snapshot": [[153, 202], ["filename_tmpl.format", "os.join", "vedacore.misc.save_weights", "base_looper.BaseLooper.logger.info", "dict", "isinstance", "dict.update", "log_info.append", "vedacore.parallel.is_module_wrapper", "vedacore.misc.save_optimizer", "log_info.append", "vedacore.misc.save_meta", "dict.update", "TypeError", "type"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.save_weights", "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.utils.is_module_wrapper", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.save_optimizer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.save_meta", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update"], ["", "def", "save_snapshot", "(", "self", ",", "\n", "out_dir", ",", "\n", "filename_tmpl", "=", "'epoch_{}'", ",", "\n", "save_optim_flag", "=", "True", ",", "\n", "save_meta_flag", "=", "True", ",", "\n", "meta", "=", "None", ")", ":", "\n", "        ", "\"\"\"Save the checkpoint.\n\n        Args:\n            out_dir (str): The directory that checkpoints are saved.\n            filename_tmpl (str, optional): The checkpoint filename template,\n                which contains a placeholder for the epoch number.\n                Defaults to 'epoch_{}.pth'.\n            save_optimizer (bool, optional): Whether to save the optimizer to\n                the checkpoint. Defaults to True.\n            meta (dict, optional): The meta information to be saved in the\n                checkpoint. Defaults to None.\n        \"\"\"", "\n", "if", "meta", "is", "None", ":", "\n", "            ", "meta", "=", "dict", "(", "epoch", "=", "self", ".", "epoch", ",", "iter", "=", "self", ".", "iter", ")", "\n", "", "elif", "isinstance", "(", "meta", ",", "dict", ")", ":", "\n", "            ", "meta", ".", "update", "(", "epoch", "=", "self", ".", "epoch", ",", "iter", "=", "self", ".", "iter", ")", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "f'meta should be a dict or None, but got {type(meta)}'", ")", "\n", "", "if", "self", ".", "meta", "is", "not", "None", ":", "\n", "            ", "meta", ".", "update", "(", "self", ".", "meta", ")", "\n", "\n", "", "filename", "=", "filename_tmpl", ".", "format", "(", "self", ".", "epoch", ")", "\n", "prefix", "=", "osp", ".", "join", "(", "out_dir", ",", "filename", ")", "\n", "log_info", "=", "[", "'weights'", "]", "\n", "if", "save_optim_flag", ":", "\n", "            ", "log_info", ".", "append", "(", "'optimizer'", ")", "\n", "filepath", "=", "'%s_optim.pth'", "%", "prefix", "\n", "engine", "=", "self", ".", "train_engine", "\n", "if", "is_module_wrapper", "(", "engine", ")", ":", "\n", "                ", "engine", "=", "engine", ".", "module", "\n", "", "optimizer", "=", "engine", ".", "optimizer", "\n", "save_optimizer", "(", "optimizer", ",", "filepath", ")", "\n", "", "if", "save_meta_flag", ":", "\n", "            ", "log_info", ".", "append", "(", "'meta'", ")", "\n", "filepath", "=", "'%s_meta.pth'", "%", "prefix", "\n", "save_meta", "(", "meta", ",", "filepath", ")", "\n", "\n", "", "filepath", "=", "'%s_weights.pth'", "%", "prefix", "\n", "model", "=", "self", ".", "train_engine", ".", "model", "\n", "save_weights", "(", "model", ",", "filepath", ")", "\n", "self", ".", "logger", ".", "info", "(", "'Saved %s at epoch %d, iter %d as %s'", "%", "\n", "(", "', '", ".", "join", "(", "log_info", ")", ",", "self", ".", "epoch", ",", "self", ".", "iter", ",", "prefix", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.current_lr": [[203, 222], ["isinstance", "isinstance", "dict", "optimizer.items", "RuntimeError"], "methods", ["None"], ["", "def", "current_lr", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get current learning rates.\n\n        Returns:\n            list[float] | dict[str, list[float]]: Current learning rates of all\n                param groups. If the runner has a dict of optimizers, this\n                method will return a dict.\n        \"\"\"", "\n", "optimizer", "=", "self", ".", "train_engine", ".", "optimizer", "\n", "if", "isinstance", "(", "optimizer", ",", "torch", ".", "optim", ".", "Optimizer", ")", ":", "\n", "            ", "lr", "=", "[", "group", "[", "'lr'", "]", "for", "group", "in", "optimizer", ".", "param_groups", "]", "\n", "", "elif", "isinstance", "(", "optimizer", ",", "dict", ")", ":", "\n", "            ", "lr", "=", "dict", "(", ")", "\n", "for", "name", ",", "optim", "in", "optimizer", ".", "items", "(", ")", ":", "\n", "                ", "lr", "[", "name", "]", "=", "[", "group", "[", "'lr'", "]", "for", "group", "in", "optim", ".", "param_groups", "]", "\n", "", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "'lr is not applicable because optimizer does not exist.'", ")", "\n", "", "return", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.mode": [[227, 230], ["None"], "methods", ["None"], ["", "@", "mode", ".", "setter", "\n", "def", "mode", "(", "self", ",", "mode", ")", ":", "\n", "        ", "self", ".", "_mode", "=", "mode", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.epoch_based_looper.EpochBasedLooper.__init__": [[6, 10], ["base_looper.BaseLooper.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "modes", ",", "dataloaders", ",", "engines", ",", "hook_pool", ",", "logger", ",", "\n", "workdir", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "modes", ",", "dataloaders", ",", "engines", ",", "hook_pool", ",", "logger", ",", "\n", "workdir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.epoch_based_looper.EpochBasedLooper.epoch_loop": [[11, 22], ["enumerate", "epoch_based_looper.EpochBasedLooper.hook_pool.fire", "engine", "epoch_based_looper.EpochBasedLooper.hook_pool.fire"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.fire", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.fire"], ["", "def", "epoch_loop", "(", "self", ",", "mode", ")", ":", "\n", "        ", "self", ".", "mode", "=", "mode", "\n", "dataloader", "=", "self", ".", "dataloaders", "[", "mode", "]", "\n", "engine", "=", "self", ".", "engines", "[", "mode", "]", "\n", "for", "idx", ",", "data", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "self", ".", "hook_pool", ".", "fire", "(", "f'before_{mode}_iter'", ",", "self", ")", "\n", "self", ".", "cur_results", "[", "mode", "]", "=", "engine", "(", "data", ")", "\n", "if", "mode", "==", "BaseLooper", ".", "TRAIN", ":", "\n", "                ", "self", ".", "_iter", "+=", "1", "\n", "", "self", ".", "_inner_iter", "=", "idx", "+", "1", "\n", "self", ".", "hook_pool", ".", "fire", "(", "f'after_{mode}_iter'", ",", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.epoch_based_looper.EpochBasedLooper.start": [[23, 35], ["epoch_based_looper.EpochBasedLooper.hook_pool.fire", "mode.lower.lower.lower", "epoch_based_looper.EpochBasedLooper.hook_pool.fire", "epoch_based_looper.EpochBasedLooper.epoch_loop", "epoch_based_looper.EpochBasedLooper.hook_pool.fire", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.fire", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.fire", "home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.epoch_based_looper.EpochBasedLooper.epoch_loop", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.fire"], ["", "", "def", "start", "(", "self", ",", "max_epochs", ")", ":", "\n", "        ", "self", ".", "hook_pool", ".", "fire", "(", "'before_run'", ",", "self", ")", "\n", "while", "self", ".", "epoch", "<", "max_epochs", ":", "\n", "            ", "for", "mode", "in", "self", ".", "modes", ":", "\n", "                ", "mode", "=", "mode", ".", "lower", "(", ")", "\n", "self", ".", "hook_pool", ".", "fire", "(", "f'before_{mode}_epoch'", ",", "self", ")", "\n", "self", ".", "epoch_loop", "(", "mode", ")", "\n", "if", "mode", "==", "BaseLooper", ".", "TRAIN", ":", "\n", "                    ", "self", ".", "_epoch", "+=", "1", "\n", "", "self", ".", "hook_pool", ".", "fire", "(", "f'after_{mode}_epoch'", ",", "self", ")", "\n", "", "if", "len", "(", "self", ".", "modes", ")", "==", "1", "and", "self", ".", "modes", "[", "0", "]", "==", "EpochBasedLooper", ".", "VAL", ":", "\n", "                ", "break", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.ConfigDict.__missing__": [[23, 25], ["KeyError"], "methods", ["None"], ["    ", "def", "__missing__", "(", "self", ",", "name", ")", ":", "\n", "        ", "raise", "KeyError", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.ConfigDict.__getattr__": [[26, 37], ["super().__getattr__", "AttributeError"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__getattr__"], ["", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "value", "=", "super", "(", "ConfigDict", ",", "self", ")", ".", "__getattr__", "(", "name", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "ex", "=", "AttributeError", "(", "f\"'{self.__class__.__name__}' object has no \"", "\n", "f\"attribute '{name}'\"", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "ex", "=", "e", "\n", "", "else", ":", "\n", "            ", "return", "value", "\n", "", "raise", "ex", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._validate_py_syntax": [[83, 91], ["open", "f.read", "ast.parse", "SyntaxError"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "_validate_py_syntax", "(", "filename", ")", ":", "\n", "        ", "with", "open", "(", "filename", ")", "as", "f", ":", "\n", "            ", "content", "=", "f", ".", "read", "(", ")", "\n", "", "try", ":", "\n", "            ", "ast", ".", "parse", "(", "content", ")", "\n", "", "except", "SyntaxError", ":", "\n", "            ", "raise", "SyntaxError", "(", "'There are syntax errors in config '", "\n", "f'file {filename}'", ")", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._file2dict": [[93, 155], ["os.abspath", "utils.check_file_exist", "os.abspath.endswith", "os.expanduser", "os.abspath.endswith", "open", "f.read", "os.dirname", "fileio.load.pop", "list", "list", "dict", "config.Config._merge_a_into_b", "list.append", "tempfile.TemporaryDirectory", "tempfile.NamedTemporaryFile", "os.basename", "shutil.copyfile", "sys.path.insert", "config.Config._validate_py_syntax", "importlib.import_module", "sys.path.pop", "tempfile.NamedTemporaryFile.close", "fileio.load", "IOError", "isinstance", "config.Config._file2dict", "list.append", "list.append", "config.Config._merge_a_into_b", "os.join", "os.splitext", "os.join", "len", "KeyError", "importlib.import_module.__dict__.items", "name.startswith", "config.Config._merge_a_into_b", "c.keys"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.check_file_exist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._merge_a_into_b", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._validate_py_syntax", "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._file2dict", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._merge_a_into_b", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._merge_a_into_b"], ["", "", "@", "staticmethod", "\n", "def", "_file2dict", "(", "filename", ")", ":", "\n", "        ", "filename", "=", "osp", ".", "abspath", "(", "osp", ".", "expanduser", "(", "filename", ")", ")", "\n", "check_file_exist", "(", "filename", ")", "\n", "if", "filename", ".", "endswith", "(", "'.py'", ")", ":", "\n", "            ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "temp_config_dir", ":", "\n", "                ", "temp_config_file", "=", "tempfile", ".", "NamedTemporaryFile", "(", "\n", "dir", "=", "temp_config_dir", ",", "suffix", "=", "'.py'", ")", "\n", "temp_config_name", "=", "osp", ".", "basename", "(", "temp_config_file", ".", "name", ")", "\n", "shutil", ".", "copyfile", "(", "filename", ",", "\n", "osp", ".", "join", "(", "temp_config_dir", ",", "temp_config_name", ")", ")", "\n", "temp_module_name", "=", "osp", ".", "splitext", "(", "temp_config_name", ")", "[", "0", "]", "\n", "sys", ".", "path", ".", "insert", "(", "0", ",", "temp_config_dir", ")", "\n", "Config", ".", "_validate_py_syntax", "(", "filename", ")", "\n", "mod", "=", "import_module", "(", "temp_module_name", ")", "\n", "sys", ".", "path", ".", "pop", "(", "0", ")", "\n", "cfg_dict", "=", "{", "\n", "name", ":", "value", "\n", "for", "name", ",", "value", "in", "mod", ".", "__dict__", ".", "items", "(", ")", "\n", "if", "not", "name", ".", "startswith", "(", "'__'", ")", "\n", "}", "\n", "# delete imported module", "\n", "del", "sys", ".", "modules", "[", "temp_module_name", "]", "\n", "# close temp file", "\n", "temp_config_file", ".", "close", "(", ")", "\n", "", "", "elif", "filename", ".", "endswith", "(", "(", "'.yml'", ",", "'.yaml'", ",", "'.json'", ")", ")", ":", "\n", "            ", "from", ".", ".", "import", "fileio", "\n", "cfg_dict", "=", "fileio", ".", "load", "(", "filename", ")", "\n", "", "else", ":", "\n", "            ", "raise", "IOError", "(", "'Only py/yml/yaml/json type are supported now!'", ")", "\n", "\n", "", "cfg_text", "=", "filename", "+", "'\\n'", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "cfg_text", "+=", "f", ".", "read", "(", ")", "\n", "\n", "", "if", "BASE_KEY", "in", "cfg_dict", ":", "\n", "            ", "cfg_dir", "=", "osp", ".", "dirname", "(", "filename", ")", "\n", "base_filename", "=", "cfg_dict", ".", "pop", "(", "BASE_KEY", ")", "\n", "base_filename", "=", "base_filename", "if", "isinstance", "(", "\n", "base_filename", ",", "list", ")", "else", "[", "base_filename", "]", "\n", "\n", "cfg_dict_list", "=", "list", "(", ")", "\n", "cfg_text_list", "=", "list", "(", ")", "\n", "for", "f", "in", "base_filename", ":", "\n", "                ", "_cfg_dict", ",", "_cfg_text", "=", "Config", ".", "_file2dict", "(", "osp", ".", "join", "(", "cfg_dir", ",", "f", ")", ")", "\n", "cfg_dict_list", ".", "append", "(", "_cfg_dict", ")", "\n", "cfg_text_list", ".", "append", "(", "_cfg_text", ")", "\n", "\n", "", "base_cfg_dict", "=", "dict", "(", ")", "\n", "for", "c", "in", "cfg_dict_list", ":", "\n", "                ", "if", "len", "(", "base_cfg_dict", ".", "keys", "(", ")", "&", "c", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "                    ", "raise", "KeyError", "(", "'Duplicate key is not allowed among bases'", ")", "\n", "", "base_cfg_dict", ".", "update", "(", "c", ")", "\n", "\n", "", "base_cfg_dict", "=", "Config", ".", "_merge_a_into_b", "(", "cfg_dict", ",", "base_cfg_dict", ")", "\n", "cfg_dict", "=", "base_cfg_dict", "\n", "\n", "# merge cfg_text", "\n", "cfg_text_list", ".", "append", "(", "cfg_text", ")", "\n", "cfg_text", "=", "'\\n'", ".", "join", "(", "cfg_text_list", ")", "\n", "\n", "", "return", "cfg_dict", ",", "cfg_text", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._merge_a_into_b": [[156, 174], ["b.copy.copy.copy", "a.items", "isinstance", "config.Config._merge_a_into_b", "v.pop", "isinstance", "TypeError", "type"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._merge_a_into_b"], ["", "@", "staticmethod", "\n", "def", "_merge_a_into_b", "(", "a", ",", "b", ")", ":", "\n", "# merge dict `a` into dict `b` (non-inplace). values in `a` will", "\n", "# overwrite `b`.", "\n", "# copy first to avoid inplace modification", "\n", "        ", "b", "=", "b", ".", "copy", "(", ")", "\n", "for", "k", ",", "v", "in", "a", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "dict", ")", "and", "k", "in", "b", "and", "not", "v", ".", "pop", "(", "DELETE_KEY", ",", "False", ")", ":", "\n", "                ", "if", "not", "isinstance", "(", "b", "[", "k", "]", ",", "dict", ")", ":", "\n", "                    ", "raise", "TypeError", "(", "\n", "f'{k}={v} in child config cannot inherit from base '", "\n", "f'because {k} is a dict in the child config but is of '", "\n", "f'type {type(b[k])} in base config. You may set '", "\n", "f'`{DELETE_KEY}=True` to ignore the base config'", ")", "\n", "", "b", "[", "k", "]", "=", "Config", ".", "_merge_a_into_b", "(", "v", ",", "b", "[", "k", "]", ")", "\n", "", "else", ":", "\n", "                ", "b", "[", "k", "]", "=", "v", "\n", "", "", "return", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.fromfile": [[175, 179], ["config.Config._file2dict", "config.Config"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._file2dict"], ["", "@", "staticmethod", "\n", "def", "fromfile", "(", "filename", ")", ":", "\n", "        ", "cfg_dict", ",", "cfg_text", "=", "Config", ".", "_file2dict", "(", "filename", ")", "\n", "return", "Config", "(", "cfg_dict", ",", "cfg_text", "=", "cfg_text", ",", "filename", "=", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.auto_argparser": [[180, 191], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "config.Config.fromfile", "argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "config.add_args", "argparse.ArgumentParser.parse_known_args"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.fromfile", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.add_args"], ["", "@", "staticmethod", "\n", "def", "auto_argparser", "(", "description", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate argparser from config file automatically (experimental)\"\"\"", "\n", "partial_parser", "=", "ArgumentParser", "(", "description", "=", "description", ")", "\n", "partial_parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'config file path'", ")", "\n", "cfg_file", "=", "partial_parser", ".", "parse_known_args", "(", ")", "[", "0", "]", ".", "config", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "cfg_file", ")", "\n", "parser", "=", "ArgumentParser", "(", "description", "=", "description", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'config file path'", ")", "\n", "add_args", "(", "parser", ",", "cfg", ")", "\n", "return", "parser", ",", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__init__": [[192, 212], ["super().__setattr__", "super().__setattr__", "super().__setattr__", "dict", "config.ConfigDict", "isinstance", "TypeError", "KeyError", "open", "f.read", "type"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__setattr__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__setattr__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__setattr__"], ["", "def", "__init__", "(", "self", ",", "cfg_dict", "=", "None", ",", "cfg_text", "=", "None", ",", "filename", "=", "None", ")", ":", "\n", "        ", "if", "cfg_dict", "is", "None", ":", "\n", "            ", "cfg_dict", "=", "dict", "(", ")", "\n", "", "elif", "not", "isinstance", "(", "cfg_dict", ",", "dict", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'cfg_dict must be a dict, but '", "\n", "f'got {type(cfg_dict)}'", ")", "\n", "", "for", "key", "in", "cfg_dict", ":", "\n", "            ", "if", "key", "in", "RESERVED_KEYS", ":", "\n", "                ", "raise", "KeyError", "(", "f'{key} is reserved for config file'", ")", "\n", "\n", "", "", "super", "(", "Config", ",", "self", ")", ".", "__setattr__", "(", "'_cfg_dict'", ",", "ConfigDict", "(", "cfg_dict", ")", ")", "\n", "super", "(", "Config", ",", "self", ")", ".", "__setattr__", "(", "'_filename'", ",", "filename", ")", "\n", "if", "cfg_text", ":", "\n", "            ", "text", "=", "cfg_text", "\n", "", "elif", "filename", ":", "\n", "            ", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "text", "=", "f", ".", "read", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "text", "=", "''", "\n", "", "super", "(", "Config", ",", "self", ")", ".", "__setattr__", "(", "'_text'", ",", "text", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.filename": [[213, 216], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "filename", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_filename", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.text": [[217, 220], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "text", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_text", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.pretty_text": [[221, 314], ["config.Config._cfg_dict.to_dict", "config.Config.pretty_text._format_dict"], "methods", ["None"], ["", "@", "property", "\n", "def", "pretty_text", "(", "self", ")", ":", "\n", "\n", "        ", "indent", "=", "4", "\n", "\n", "def", "_indent", "(", "s_", ",", "num_spaces", ")", ":", "\n", "            ", "s", "=", "s_", ".", "split", "(", "'\\n'", ")", "\n", "if", "len", "(", "s", ")", "==", "1", ":", "\n", "                ", "return", "s_", "\n", "", "first", "=", "s", ".", "pop", "(", "0", ")", "\n", "s", "=", "[", "(", "num_spaces", "*", "' '", ")", "+", "line", "for", "line", "in", "s", "]", "\n", "s", "=", "'\\n'", ".", "join", "(", "s", ")", "\n", "s", "=", "first", "+", "'\\n'", "+", "s", "\n", "return", "s", "\n", "\n", "", "def", "_format_basic_types", "(", "k", ",", "v", ",", "use_mapping", "=", "False", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "str", ")", ":", "\n", "                ", "v_str", "=", "f\"'{v}'\"", "\n", "", "else", ":", "\n", "                ", "v_str", "=", "str", "(", "v", ")", "\n", "\n", "", "if", "use_mapping", ":", "\n", "                ", "k_str", "=", "f\"'{k}'\"", "if", "isinstance", "(", "k", ",", "str", ")", "else", "str", "(", "k", ")", "\n", "attr_str", "=", "f'{k_str}: {v_str}'", "\n", "", "else", ":", "\n", "                ", "attr_str", "=", "f'{str(k)}={v_str}'", "\n", "", "attr_str", "=", "_indent", "(", "attr_str", ",", "indent", ")", "\n", "\n", "return", "attr_str", "\n", "\n", "", "def", "_format_list", "(", "k", ",", "v", ",", "use_mapping", "=", "False", ")", ":", "\n", "# check if all items in the list are dict", "\n", "            ", "if", "all", "(", "isinstance", "(", "_", ",", "dict", ")", "for", "_", "in", "v", ")", ":", "\n", "                ", "v_str", "=", "'[\\n'", "\n", "v_str", "+=", "'\\n'", ".", "join", "(", "\n", "f'dict({_indent(_format_dict(v_), indent)}),'", "\n", "for", "v_", "in", "v", ")", ".", "rstrip", "(", "','", ")", "\n", "if", "use_mapping", ":", "\n", "                    ", "k_str", "=", "f\"'{k}'\"", "if", "isinstance", "(", "k", ",", "str", ")", "else", "str", "(", "k", ")", "\n", "attr_str", "=", "f'{k_str}: {v_str}'", "\n", "", "else", ":", "\n", "                    ", "attr_str", "=", "f'{str(k)}={v_str}'", "\n", "", "attr_str", "=", "_indent", "(", "attr_str", ",", "indent", ")", "+", "']'", "\n", "", "else", ":", "\n", "                ", "attr_str", "=", "_format_basic_types", "(", "k", ",", "v", ",", "use_mapping", ")", "\n", "", "return", "attr_str", "\n", "\n", "", "def", "_contain_invalid_identifier", "(", "dict_str", ")", ":", "\n", "            ", "contain_invalid_identifier", "=", "False", "\n", "for", "key_name", "in", "dict_str", ":", "\n", "                ", "contain_invalid_identifier", "|=", "(", "not", "str", "(", "key_name", ")", ".", "isidentifier", "(", ")", ")", "\n", "", "return", "contain_invalid_identifier", "\n", "\n", "", "def", "_format_dict", "(", "input_dict", ",", "outest_level", "=", "False", ")", ":", "\n", "            ", "r", "=", "''", "\n", "s", "=", "[", "]", "\n", "\n", "use_mapping", "=", "_contain_invalid_identifier", "(", "input_dict", ")", "\n", "if", "use_mapping", ":", "\n", "                ", "r", "+=", "'{'", "\n", "", "for", "idx", ",", "(", "k", ",", "v", ")", "in", "enumerate", "(", "input_dict", ".", "items", "(", ")", ")", ":", "\n", "                ", "is_last", "=", "idx", ">=", "len", "(", "input_dict", ")", "-", "1", "\n", "end", "=", "''", "if", "outest_level", "or", "is_last", "else", "','", "\n", "if", "isinstance", "(", "v", ",", "dict", ")", ":", "\n", "                    ", "v_str", "=", "'\\n'", "+", "_format_dict", "(", "v", ")", "\n", "if", "use_mapping", ":", "\n", "                        ", "k_str", "=", "f\"'{k}'\"", "if", "isinstance", "(", "k", ",", "str", ")", "else", "str", "(", "k", ")", "\n", "attr_str", "=", "f'{k_str}: dict({v_str}'", "\n", "", "else", ":", "\n", "                        ", "attr_str", "=", "f'{str(k)}=dict({v_str}'", "\n", "", "attr_str", "=", "_indent", "(", "attr_str", ",", "indent", ")", "+", "')'", "+", "end", "\n", "", "elif", "isinstance", "(", "v", ",", "list", ")", ":", "\n", "                    ", "attr_str", "=", "_format_list", "(", "k", ",", "v", ",", "use_mapping", ")", "+", "end", "\n", "", "else", ":", "\n", "                    ", "attr_str", "=", "_format_basic_types", "(", "k", ",", "v", ",", "use_mapping", ")", "+", "end", "\n", "\n", "", "s", ".", "append", "(", "attr_str", ")", "\n", "", "r", "+=", "'\\n'", ".", "join", "(", "s", ")", "\n", "if", "use_mapping", ":", "\n", "                ", "r", "+=", "'}'", "\n", "", "return", "r", "\n", "\n", "", "cfg_dict", "=", "self", ".", "_cfg_dict", ".", "to_dict", "(", ")", "\n", "text", "=", "_format_dict", "(", "cfg_dict", ",", "outest_level", "=", "True", ")", "\n", "# copied from setup.cfg", "\n", "yapf_style", "=", "dict", "(", "\n", "based_on_style", "=", "'pep8'", ",", "\n", "blank_line_before_nested_class_or_def", "=", "True", ",", "\n", "split_before_expression_after_opening_paren", "=", "True", ")", "\n", "text", ",", "_", "=", "FormatCode", "(", "text", ",", "style_config", "=", "yapf_style", ",", "verify", "=", "True", ")", "\n", "\n", "return", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__repr__": [[315, 317], ["config.Config._cfg_dict.__repr__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.iou_calculators.iou_calculator.SegmentOverlaps.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'Config (path: {self.filename}): {self._cfg_dict.__repr__()}'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__len__": [[318, 320], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_cfg_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__getattr__": [[321, 323], ["getattr"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "getattr", "(", "self", ".", "_cfg_dict", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__getitem__": [[324, 326], ["config.Config._cfg_dict.__getitem__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.ClassBalancedDataset.__getitem__"], ["", "def", "__getitem__", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "self", ".", "_cfg_dict", ".", "__getitem__", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__setattr__": [[327, 331], ["isinstance", "config.Config._cfg_dict.__setattr__", "config.ConfigDict"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__setattr__"], ["", "def", "__setattr__", "(", "self", ",", "name", ",", "value", ")", ":", "\n", "        ", "if", "isinstance", "(", "value", ",", "dict", ")", ":", "\n", "            ", "value", "=", "ConfigDict", "(", "value", ")", "\n", "", "self", ".", "_cfg_dict", ".", "__setattr__", "(", "name", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__setitem__": [[332, 336], ["isinstance", "config.Config._cfg_dict.__setitem__", "config.ConfigDict"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__setitem__"], ["", "def", "__setitem__", "(", "self", ",", "name", ",", "value", ")", ":", "\n", "        ", "if", "isinstance", "(", "value", ",", "dict", ")", ":", "\n", "            ", "value", "=", "ConfigDict", "(", "value", ")", "\n", "", "self", ".", "_cfg_dict", ".", "__setitem__", "(", "name", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__iter__": [[337, 339], ["iter"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "_cfg_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump": [[340, 355], ["super().__getattribute__().to_dict", "config.Config.filename.endswith", "super().__getattribute__", "fileio.dump", "fileio.dump", "open", "f.write", "config.Config.filename.split"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump"], ["", "def", "dump", "(", "self", ",", "file", "=", "None", ")", ":", "\n", "        ", "cfg_dict", "=", "super", "(", "Config", ",", "self", ")", ".", "__getattribute__", "(", "'_cfg_dict'", ")", ".", "to_dict", "(", ")", "\n", "if", "self", ".", "filename", ".", "endswith", "(", "'.py'", ")", ":", "\n", "            ", "if", "file", "is", "None", ":", "\n", "                ", "return", "self", ".", "pretty_text", "\n", "", "else", ":", "\n", "                ", "with", "open", "(", "file", ",", "'w'", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "self", ".", "pretty_text", ")", "\n", "", "", "", "else", ":", "\n", "            ", "from", ".", ".", "import", "fileio", "\n", "if", "file", "is", "None", ":", "\n", "                ", "file_format", "=", "self", ".", "filename", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "return", "fileio", ".", "dump", "(", "cfg_dict", ",", "file_format", "=", "file_format", ")", "\n", "", "else", ":", "\n", "                ", "fileio", ".", "dump", "(", "cfg_dict", ",", "file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.merge_from_dict": [[356, 386], ["options.items", "super().__getattribute__", "super().__setattr__", "full_key.split", "config.Config._merge_a_into_b", "d.setdefault", "config.ConfigDict"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.__setattr__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config._merge_a_into_b"], ["", "", "", "def", "merge_from_dict", "(", "self", ",", "options", ")", ":", "\n", "        ", "\"\"\"Merge list into cfg_dict.\n\n        Merge the dict parsed by MultipleKVAction into this cfg.\n\n        Examples:\n            >>> options = {'model.backbone.depth': 50,\n            ...            'model.backbone.with_cp':True}\n            >>> cfg = Config(dict(model=dict(backbone=dict(type='ResNet'))))\n            >>> cfg.merge_from_dict(options)\n            >>> cfg_dict = super(Config, self).__getattribute__('_cfg_dict')\n            >>> assert cfg_dict == dict(\n            ...     model=dict(backbone=dict(depth=50, with_cp=True)))\n\n        Args:\n            options (dict): dict of configs to merge from.\n        \"\"\"", "\n", "option_cfg_dict", "=", "{", "}", "\n", "for", "full_key", ",", "v", "in", "options", ".", "items", "(", ")", ":", "\n", "            ", "d", "=", "option_cfg_dict", "\n", "key_list", "=", "full_key", ".", "split", "(", "'.'", ")", "\n", "for", "subkey", "in", "key_list", "[", ":", "-", "1", "]", ":", "\n", "                ", "d", ".", "setdefault", "(", "subkey", ",", "ConfigDict", "(", ")", ")", "\n", "d", "=", "d", "[", "subkey", "]", "\n", "", "subkey", "=", "key_list", "[", "-", "1", "]", "\n", "d", "[", "subkey", "]", "=", "v", "\n", "\n", "", "cfg_dict", "=", "super", "(", "Config", ",", "self", ")", ".", "__getattribute__", "(", "'_cfg_dict'", ")", "\n", "super", "(", "Config", ",", "self", ")", ".", "__setattr__", "(", "\n", "'_cfg_dict'", ",", "Config", ".", "_merge_a_into_b", "(", "option_cfg_dict", ",", "cfg_dict", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.DictAction._parse_int_float_bool": [[395, 408], ["int", "float", "val.lower", "val.lower"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "_parse_int_float_bool", "(", "val", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "int", "(", "val", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "pass", "\n", "", "try", ":", "\n", "            ", "return", "float", "(", "val", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "pass", "\n", "", "if", "val", ".", "lower", "(", ")", "in", "[", "'true'", ",", "'false'", "]", ":", "\n", "            ", "return", "True", "if", "val", ".", "lower", "(", ")", "==", "'true'", "else", "False", "\n", "", "return", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.DictAction.__call__": [[409, 418], ["setattr", "kv.split", "config.DictAction._parse_int_float_bool", "len", "val.split"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.DictAction._parse_int_float_bool"], ["", "def", "__call__", "(", "self", ",", "parser", ",", "namespace", ",", "values", ",", "option_string", "=", "None", ")", ":", "\n", "        ", "options", "=", "{", "}", "\n", "for", "kv", "in", "values", ":", "\n", "            ", "key", ",", "val", "=", "kv", ".", "split", "(", "'='", ",", "maxsplit", "=", "1", ")", "\n", "val", "=", "[", "self", ".", "_parse_int_float_bool", "(", "v", ")", "for", "v", "in", "val", ".", "split", "(", "','", ")", "]", "\n", "if", "len", "(", "val", ")", "==", "1", ":", "\n", "                ", "val", "=", "val", "[", "0", "]", "\n", "", "options", "[", "key", "]", "=", "val", "\n", "", "setattr", "(", "namespace", ",", "self", ".", "dest", ",", "options", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.add_args": [[39, 56], ["cfg.items", "isinstance", "parser.add_argument", "isinstance", "parser.add_argument", "isinstance", "parser.add_argument", "isinstance", "parser.add_argument", "isinstance", "config.add_args", "isinstance", "parser.add_argument", "print", "type", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.add_args"], ["", "", "def", "add_args", "(", "parser", ",", "cfg", ",", "prefix", "=", "''", ")", ":", "\n", "    ", "for", "k", ",", "v", "in", "cfg", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "v", ",", "str", ")", ":", "\n", "            ", "parser", ".", "add_argument", "(", "'--'", "+", "prefix", "+", "k", ")", "\n", "", "elif", "isinstance", "(", "v", ",", "int", ")", ":", "\n", "            ", "parser", ".", "add_argument", "(", "'--'", "+", "prefix", "+", "k", ",", "type", "=", "int", ")", "\n", "", "elif", "isinstance", "(", "v", ",", "float", ")", ":", "\n", "            ", "parser", ".", "add_argument", "(", "'--'", "+", "prefix", "+", "k", ",", "type", "=", "float", ")", "\n", "", "elif", "isinstance", "(", "v", ",", "bool", ")", ":", "\n", "            ", "parser", ".", "add_argument", "(", "'--'", "+", "prefix", "+", "k", ",", "action", "=", "'store_true'", ")", "\n", "", "elif", "isinstance", "(", "v", ",", "dict", ")", ":", "\n", "            ", "add_args", "(", "parser", ",", "v", ",", "prefix", "+", "k", "+", "'.'", ")", "\n", "", "elif", "isinstance", "(", "v", ",", "abc", ".", "Iterable", ")", ":", "\n", "            ", "parser", ".", "add_argument", "(", "'--'", "+", "prefix", "+", "k", ",", "type", "=", "type", "(", "v", "[", "0", "]", ")", ",", "nargs", "=", "'+'", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "f'cannot parse key {prefix + k} of type {type(v)}'", ")", "\n", "", "", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.logging.get_logger": [[9, 64], ["logging.getLogger", "logging.StreamHandler", "parallel.get_dist_info", "logging.Formatter", "name.startswith", "logging.FileHandler", "handlers.append", "handler.setFormatter", "handler.setLevel", "logging.getLogger.addHandler", "logging.getLogger.setLevel", "logging.getLogger.setLevel"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.get_dist_info"], ["def", "get_logger", "(", "name", ",", "log_file", "=", "None", ",", "log_level", "=", "logging", ".", "INFO", ")", ":", "\n", "    ", "\"\"\"Initialize and get a logger by name.\n\n    If the logger has not been initialized, this method will initialize the\n    logger by adding one or two handlers, otherwise the initialized logger will\n    be directly returned. During initialization, a StreamHandler will always be\n    added. If `log_file` is specified and the process rank is 0, a FileHandler\n    will also be added.\n\n    Args:\n        name (str): Logger name.\n        log_file (str | None): The log filename. If specified, a FileHandler\n            will be added to the logger.\n        log_level (int): The logger level. Note that only the process of\n            rank 0 is affected, and other processes will set the level to\n            \"Error\" thus be silent most of the time.\n\n    Returns:\n        logging.Logger: The expected logger.\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "name", ")", "\n", "logger", ".", "propagate", "=", "False", "\n", "if", "name", "in", "logger_initialized", ":", "\n", "        ", "return", "logger", "\n", "# handle hierarchical names", "\n", "# e.g., logger \"a\" is initialized, then logger \"a.b\" will skip the", "\n", "# initialization since it is a child of \"a\".", "\n", "", "for", "logger_name", "in", "logger_initialized", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "logger_name", ")", ":", "\n", "            ", "return", "logger", "\n", "\n", "", "", "stream_handler", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "handlers", "=", "[", "stream_handler", "]", "\n", "\n", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "# only rank 0 will add a FileHandler", "\n", "if", "rank", "==", "0", "and", "log_file", "is", "not", "None", ":", "\n", "        ", "file_handler", "=", "logging", ".", "FileHandler", "(", "log_file", ",", "'w'", ")", "\n", "handlers", ".", "append", "(", "file_handler", ")", "\n", "\n", "", "formatter", "=", "logging", ".", "Formatter", "(", "\n", "'%(asctime)s - %(name)s - %(levelname)s - %(message)s'", ")", "\n", "for", "handler", "in", "handlers", ":", "\n", "        ", "handler", ".", "setFormatter", "(", "formatter", ")", "\n", "handler", ".", "setLevel", "(", "log_level", ")", "\n", "logger", ".", "addHandler", "(", "handler", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "        ", "logger", ".", "setLevel", "(", "log_level", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "setLevel", "(", "logging", ".", "ERROR", ")", "\n", "\n", "", "logger_initialized", "[", "name", "]", "=", "True", "\n", "\n", "return", "logger", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.logging.print_log": [[66, 91], ["print", "isinstance", "logger.log", "isinstance", "logging.get_logger", "get_logger.log", "TypeError", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.logging.get_logger"], ["", "def", "print_log", "(", "msg", ",", "logger", "=", "None", ",", "level", "=", "logging", ".", "INFO", ")", ":", "\n", "    ", "\"\"\"Print a log message.\n\n    Args:\n        msg (str): The message to be logged.\n        logger (logging.Logger | str | None): The logger to be used.\n            Some special loggers are:\n            - \"silent\": no message will be printed.\n            - other str: the logger obtained with `get_root_logger(logger)`.\n            - None: The `print()` method will be used to print log messages.\n        level (int): Logging level. Only available when `logger` is a Logger\n            object or \"root\".\n    \"\"\"", "\n", "if", "logger", "is", "None", ":", "\n", "        ", "print", "(", "msg", ")", "\n", "", "elif", "isinstance", "(", "logger", ",", "logging", ".", "Logger", ")", ":", "\n", "        ", "logger", ".", "log", "(", "level", ",", "msg", ")", "\n", "", "elif", "logger", "==", "'silent'", ":", "\n", "        ", "pass", "\n", "", "elif", "isinstance", "(", "logger", ",", "str", ")", ":", "\n", "        ", "_logger", "=", "get_logger", "(", "logger", ")", "\n", "_logger", ".", "log", "(", "level", ",", "msg", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "'logger should be either a logging.Logger object, str, '", "\n", "f'\"silent\" or None, but got {type(logger)}'", ")", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.decorator.singleton_arg": [[5, 17], ["functools.wraps", "func", "json.dumps", "json.dumps"], "function", ["None"], ["def", "singleton_arg", "(", "func", ")", ":", "\n", "    ", "_instances", "=", "{", "}", "\n", "\n", "@", "wraps", "(", "func", ")", "\n", "def", "wrapper_call", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "arg_str", "=", "'%s_%s'", "%", "(", "json", ".", "dumps", "(", "args", ")", ",", "json", ".", "dumps", "(", "kwargs", ")", ")", "\n", "if", "arg_str", "not", "in", "_instances", ":", "\n", "            ", "ret", "=", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "_instances", "[", "arg_str", "]", "=", "ret", "\n", "", "return", "_instances", "[", "arg_str", "]", "\n", "\n", "", "return", "wrapper_call", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.TimerError.__init__": [[7, 10], ["Exception.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "message", ")", ":", "\n", "        ", "self", ".", "message", "=", "message", "\n", "super", "(", "TimerError", ",", "self", ")", ".", "__init__", "(", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.Timer.__init__": [[38, 43], ["timer.Timer.start"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.start"], ["def", "__init__", "(", "self", ",", "start", "=", "True", ",", "print_tmpl", "=", "None", ")", ":", "\n", "        ", "self", ".", "_is_running", "=", "False", "\n", "self", ".", "print_tmpl", "=", "print_tmpl", "if", "print_tmpl", "else", "'{:.3f}'", "\n", "if", "start", ":", "\n", "            ", "self", ".", "start", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.Timer.is_running": [[44, 48], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "is_running", "(", "self", ")", ":", "\n", "        ", "\"\"\"bool: indicate whether the timer is running\"\"\"", "\n", "return", "self", ".", "_is_running", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.Timer.__enter__": [[49, 52], ["timer.Timer.start"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.start"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "start", "(", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.Timer.__exit__": [[53, 56], ["print", "timer.Timer.print_tmpl.format", "timer.Timer.since_last_check"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.Timer.since_last_check"], ["", "def", "__exit__", "(", "self", ",", "type", ",", "value", ",", "traceback", ")", ":", "\n", "        ", "print", "(", "self", ".", "print_tmpl", ".", "format", "(", "self", ".", "since_last_check", "(", ")", ")", ")", "\n", "self", ".", "_is_running", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.Timer.start": [[57, 63], ["time.time.time", "time.time.time"], "methods", ["None"], ["", "def", "start", "(", "self", ")", ":", "\n", "        ", "\"\"\"Start the timer.\"\"\"", "\n", "if", "not", "self", ".", "_is_running", ":", "\n", "            ", "self", ".", "_t_start", "=", "time", "(", ")", "\n", "self", ".", "_is_running", "=", "True", "\n", "", "self", ".", "_t_last", "=", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.Timer.since_start": [[64, 73], ["time.time.time", "timer.TimerError"], "methods", ["None"], ["", "def", "since_start", "(", "self", ")", ":", "\n", "        ", "\"\"\"Total time since the timer is started.\n\n        Returns (float): Time in seconds.\n        \"\"\"", "\n", "if", "not", "self", ".", "_is_running", ":", "\n", "            ", "raise", "TimerError", "(", "'timer is not running'", ")", "\n", "", "self", ".", "_t_last", "=", "time", "(", ")", "\n", "return", "self", ".", "_t_last", "-", "self", ".", "_t_start", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.Timer.since_last_check": [[74, 87], ["time.time.time", "timer.TimerError", "time.time.time"], "methods", ["None"], ["", "def", "since_last_check", "(", "self", ")", ":", "\n", "        ", "\"\"\"Time since the last checking.\n\n        Either :func:`since_start` or :func:`since_last_check` is a checking\n        operation.\n\n        Returns (float): Time in seconds.\n        \"\"\"", "\n", "if", "not", "self", ".", "_is_running", ":", "\n", "            ", "raise", "TimerError", "(", "'timer is not running'", ")", "\n", "", "dur", "=", "time", "(", ")", "-", "self", ".", "_t_last", "\n", "self", ".", "_t_last", "=", "time", "(", ")", "\n", "return", "dur", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.__init__": [[15, 17], ["dict"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_module_dict", "=", "dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.__new__": [[18, 22], ["object.__new__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.__new__"], ["", "def", "__new__", "(", "cls", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "cls", ".", "_instance", "is", "None", ":", "\n", "            ", "cls", ".", "_instance", "=", "object", ".", "__new__", "(", "cls", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "return", "cls", ".", "_instance", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.__len__": [[23, 25], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_module_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.__contains__": [[26, 28], ["registry.Registry.get"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "__contains__", "(", "self", ",", "key", ")", ":", "\n", "        ", "return", "self", ".", "get", "(", "key", ")", "is", "not", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.__repr__": [[29, 33], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "format_str", "=", "self", ".", "__class__", ".", "__name__", "+", "f'(items={self._module_dict})'", "\n", "return", "format_str", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.module_dict": [[34, 37], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "module_dict", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_module_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get": [[38, 54], ["KeyError", "KeyError"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "cls_name", ",", "module_name", "=", "'module'", ")", ":", "\n", "        ", "\"\"\"Get the registry record.\n\n        Args:\n            key (str): The class name in string format.\n\n        Returns:\n            class: The corresponding class.\n        \"\"\"", "\n", "if", "module_name", "not", "in", "self", ".", "_module_dict", ":", "\n", "            ", "raise", "KeyError", "(", "f'{module_name} is not in registry'", ")", "\n", "", "dd", "=", "self", ".", "_module_dict", "[", "module_name", "]", "\n", "if", "cls_name", "not", "in", "dd", ":", "\n", "            ", "raise", "KeyError", "(", "f'{cls_name} is not registered in {module_name}'", ")", "\n", "\n", "", "return", "dd", "[", "cls_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry._register_module": [[55, 66], ["registry.Registry._module_dict.setdefault", "inspect.isclass", "TypeError", "dict", "KeyError", "type"], "methods", ["None"], ["", "def", "_register_module", "(", "self", ",", "cls", ",", "module_name", ")", ":", "\n", "        ", "if", "not", "inspect", ".", "isclass", "(", "cls", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'module must be a class, '", "f'but got {type(cls)}'", ")", "\n", "\n", "", "cls_name", "=", "cls", ".", "__name__", "\n", "self", ".", "_module_dict", ".", "setdefault", "(", "module_name", ",", "dict", "(", ")", ")", "\n", "dd", "=", "self", ".", "_module_dict", "[", "module_name", "]", "\n", "if", "cls_name", "in", "dd", ":", "\n", "            ", "raise", "KeyError", "(", "f'{cls_name} is already registered '", "\n", "f'in {module_name}'", ")", "\n", "", "dd", "[", "cls_name", "]", "=", "cls", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.register_module": [[67, 74], ["registry.Registry._register_module"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry._register_module"], ["", "def", "register_module", "(", "self", ",", "module_name", "=", "'module'", ")", ":", "\n", "\n", "        ", "def", "_register", "(", "cls", ")", ":", "\n", "            ", "self", ".", "_register_module", "(", "cls", ",", "module_name", ")", "\n", "return", "cls", "\n", "\n", "", "return", "_register", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg": [[79, 103], ["cfg.copy", "cfg.copy.pop", "utils.is_str", "registry.get.", "isinstance", "TypeError", "KeyError", "isinstance", "TypeError", "TypeError", "registry.get", "TypeError", "default_args.items", "isinstance", "cfg.copy.setdefault", "type", "type", "type", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["def", "build_from_cfg", "(", "cfg", ",", "registry", ",", "module_name", "=", "'module'", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "cfg", ",", "dict", ")", ":", "\n", "        ", "raise", "TypeError", "(", "f'cfg must be a dict, but got {type(cfg)}'", ")", "\n", "", "if", "'typename'", "not", "in", "cfg", ":", "\n", "        ", "raise", "KeyError", "(", "\n", "f'the cfg dict must contain the key \"typename\", but got {cfg}'", ")", "\n", "", "if", "not", "isinstance", "(", "registry", ",", "Registry", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'registry must be a registry object, '", "\n", "f'but got {type(registry)}'", ")", "\n", "", "if", "not", "(", "isinstance", "(", "default_args", ",", "dict", ")", "or", "default_args", "is", "None", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'default_args must be a dict or None, '", "\n", "f'but got {type(default_args)}'", ")", "\n", "\n", "", "args", "=", "cfg", ".", "copy", "(", ")", "\n", "obj_type", "=", "args", ".", "pop", "(", "'typename'", ")", "\n", "if", "is_str", "(", "obj_type", ")", ":", "\n", "        ", "obj_cls", "=", "registry", ".", "get", "(", "obj_type", ",", "module_name", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "f'type must be a str, but got {type(obj_type)}'", ")", "\n", "\n", "", "if", "default_args", "is", "not", "None", ":", "\n", "        ", "for", "name", ",", "value", "in", "default_args", ".", "items", "(", ")", ":", "\n", "            ", "args", ".", "setdefault", "(", "name", ",", "value", ")", "\n", "", "", "return", "obj_cls", "(", "**", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_module": [[105, 126], ["cfg.copy", "cfg.copy.pop", "utils.is_str", "getattr.", "isinstance", "TypeError", "KeyError", "TypeError", "getattr", "TypeError", "default_args.items", "isinstance", "cfg.copy.setdefault", "type", "type", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str"], ["", "def", "build_from_module", "(", "cfg", ",", "module", ",", "default_args", "=", "None", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "cfg", ",", "dict", ")", ":", "\n", "        ", "raise", "TypeError", "(", "f'cfg must be a dict, but got {type(cfg)}'", ")", "\n", "", "if", "'typename'", "not", "in", "cfg", ":", "\n", "        ", "raise", "KeyError", "(", "\n", "f'the cfg dict must contain the key \"typename\", but got {cfg}'", ")", "\n", "", "if", "not", "(", "isinstance", "(", "default_args", ",", "dict", ")", "or", "default_args", "is", "None", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'default_args must be a dict or None, '", "\n", "f'but got {type(default_args)}'", ")", "\n", "\n", "", "args", "=", "cfg", ".", "copy", "(", ")", "\n", "obj_type", "=", "args", ".", "pop", "(", "'typename'", ")", "\n", "if", "is_str", "(", "obj_type", ")", ":", "\n", "        ", "obj_cls", "=", "getattr", "(", "module", ",", "obj_type", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "f'type must be a str, but got {type(obj_type)}'", ")", "\n", "\n", "", "if", "default_args", "is", "not", "None", ":", "\n", "        ", "for", "name", ",", "value", "in", "default_args", ".", "items", "(", ")", ":", "\n", "            ", "args", ".", "setdefault", "(", "name", ",", "value", ")", "\n", "", "", "return", "obj_cls", "(", "**", "args", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.__init__": [[11, 18], ["progressbar.ProgressBar.start"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.start"], ["def", "__init__", "(", "self", ",", "task_num", "=", "0", ",", "bar_width", "=", "50", ",", "start", "=", "True", ",", "file", "=", "sys", ".", "stdout", ")", ":", "\n", "        ", "self", ".", "task_num", "=", "task_num", "\n", "self", ".", "bar_width", "=", "bar_width", "\n", "self", ".", "completed", "=", "0", "\n", "self", ".", "file", "=", "file", "\n", "if", "start", ":", "\n", "            ", "self", ".", "start", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.terminal_width": [[19, 23], ["shutil.get_terminal_size"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "terminal_width", "(", "self", ")", ":", "\n", "        ", "width", ",", "_", "=", "get_terminal_size", "(", ")", "\n", "return", "width", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.start": [[24, 32], ["progressbar.ProgressBar.file.flush", "timer.Timer", "progressbar.ProgressBar.file.write", "progressbar.ProgressBar.file.write"], "methods", ["None"], ["", "def", "start", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "task_num", ">", "0", ":", "\n", "            ", "self", ".", "file", ".", "write", "(", "f'[{\" \" * self.bar_width}] 0/{self.task_num}, '", "\n", "'elapsed: 0s, ETA:'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "file", ".", "write", "(", "'completed: 0, elapsed: 0s'", ")", "\n", "", "self", ".", "file", ".", "flush", "(", ")", "\n", "self", ".", "timer", "=", "Timer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update": [[33, 60], ["progressbar.ProgressBar.timer.since_start", "progressbar.ProgressBar.file.flush", "float", "int", "min", "max", "int", "progressbar.ProgressBar.file.write", "progressbar.ProgressBar.file.write", "float", "int", "msg.format", "int", "int", "int", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.timer.Timer.since_start"], ["", "def", "update", "(", "self", ",", "num_tasks", "=", "1", ")", ":", "\n", "        ", "assert", "num_tasks", ">", "0", "\n", "self", ".", "completed", "+=", "num_tasks", "\n", "elapsed", "=", "self", ".", "timer", ".", "since_start", "(", ")", "\n", "if", "elapsed", ">", "0", ":", "\n", "            ", "fps", "=", "self", ".", "completed", "/", "elapsed", "\n", "", "else", ":", "\n", "            ", "fps", "=", "float", "(", "'inf'", ")", "\n", "", "if", "self", ".", "task_num", ">", "0", ":", "\n", "            ", "percentage", "=", "self", ".", "completed", "/", "float", "(", "self", ".", "task_num", ")", "\n", "eta", "=", "int", "(", "elapsed", "*", "(", "1", "-", "percentage", ")", "/", "percentage", "+", "0.5", ")", "\n", "msg", "=", "f'\\r[{{}}] {self.completed}/{self.task_num}, '", "f'{fps:.1f} task/s, elapsed: {int(elapsed + 0.5)}s, '", "f'ETA: {eta:5}s'", "\n", "\n", "bar_width", "=", "min", "(", "self", ".", "bar_width", ",", "\n", "int", "(", "self", ".", "terminal_width", "-", "len", "(", "msg", ")", ")", "+", "2", ",", "\n", "int", "(", "self", ".", "terminal_width", "*", "0.6", ")", ")", "\n", "bar_width", "=", "max", "(", "2", ",", "bar_width", ")", "\n", "mark_width", "=", "int", "(", "bar_width", "*", "percentage", ")", "\n", "bar_chars", "=", "'>'", "*", "mark_width", "+", "' '", "*", "(", "bar_width", "-", "mark_width", ")", "\n", "self", ".", "file", ".", "write", "(", "msg", ".", "format", "(", "bar_chars", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "file", ".", "write", "(", "\n", "f'completed: {self.completed}, elapsed: {int(elapsed + 0.5)}s,'", "\n", "f' {fps:.1f} tasks/s'", ")", "\n", "", "self", ".", "file", ".", "flush", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.color.color_val": [[24, 51], ["utils.is_str", "isinstance", "isinstance", "isinstance", "len", "isinstance", "numpy.all", "color.astype.astype", "tuple", "TypeError", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str"], ["", "def", "color_val", "(", "color", ")", ":", "\n", "    ", "\"\"\"Convert various input to color tuples.\n\n    Args:\n        color (:obj:`Color`/str/tuple/int/ndarray): Color inputs\n    Returns:\n        tuple[int]: A tuple of 3 integers indicating BGR channels.\n    \"\"\"", "\n", "if", "is_str", "(", "color", ")", ":", "\n", "        ", "return", "Color", "[", "color", "]", ".", "value", "\n", "", "elif", "isinstance", "(", "color", ",", "Color", ")", ":", "\n", "        ", "return", "color", ".", "value", "\n", "", "elif", "isinstance", "(", "color", ",", "tuple", ")", ":", "\n", "        ", "assert", "len", "(", "color", ")", "==", "3", "\n", "for", "channel", "in", "color", ":", "\n", "            ", "assert", "0", "<=", "channel", "<=", "255", "\n", "", "return", "color", "\n", "", "elif", "isinstance", "(", "color", ",", "int", ")", ":", "\n", "        ", "assert", "0", "<=", "color", "<=", "255", "\n", "return", "color", ",", "color", ",", "color", "\n", "", "elif", "isinstance", "(", "color", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "assert", "color", ".", "ndim", "==", "1", "and", "color", ".", "size", "==", "3", "\n", "assert", "np", ".", "all", "(", "(", "color", ">=", "0", ")", "&", "(", "color", "<=", "255", ")", ")", "\n", "color", "=", "color", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "return", "tuple", "(", "color", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "f'Invalid type for color: {type(color)}'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.multi_apply": [[14, 18], ["map", "tuple", "functools.partial", "map", "zip"], "function", ["None"], ["\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.unmap": [[20, 31], ["data.dim", "data.new_full", "data.new_full", "inds.type", "data.size", "inds.type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["return", "isinstance", "(", "module", ",", "module_wrappers", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.check_file_exist": [[33, 36], ["os.isfile", "FileNotFoundError", "msg_tmpl.format"], "function", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.mkdir_or_exist": [[38, 43], ["os.expanduser", "os.makedirs", "os.makedirs"], "function", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_seq_of": [[45, 67], ["isinstance", "isinstance", "isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_list_of": [[69, 75], ["utils.is_seq_of"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_seq_of"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_tuple_of": [[77, 83], ["utils.is_seq_of"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_seq_of"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.slice_list": [[85, 109], ["isinstance", "range", "isinstance", "TypeError", "len", "out_list.append", "int", "sum", "len", "ValueError", "len", "len", "sum", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str": [[111, 117], ["isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.set_random_seed": [[119, 137], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.manual_seed", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all"], "function", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.reduce_mean": [[139, 145], ["tensor.clone.clone", "torch.all_reduce", "tensor.clone.div_", "torch.is_available", "torch.is_initialized", "torch.get_world_size"], "function", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.get_torchvision_models": [[18, 28], ["dict", "pkgutil.walk_packages", "importlib.import_module", "hasattr", "getattr", "dict.update"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update"], ["def", "get_torchvision_models", "(", ")", ":", "\n", "    ", "model_urls", "=", "dict", "(", ")", "\n", "for", "_", ",", "name", ",", "ispkg", "in", "pkgutil", ".", "walk_packages", "(", "torchvision", ".", "models", ".", "__path__", ")", ":", "\n", "        ", "if", "ispkg", ":", "\n", "            ", "continue", "\n", "", "_zoo", "=", "import_module", "(", "f'torchvision.models.{name}'", ")", "\n", "if", "hasattr", "(", "_zoo", ",", "'model_urls'", ")", ":", "\n", "            ", "_urls", "=", "getattr", "(", "_zoo", ",", "'model_urls'", ")", "\n", "model_urls", ".", "update", "(", "_urls", ")", "\n", "", "", "return", "model_urls", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.get_open_mmlab_models": [[30, 37], ["os.path.dirname", "os.path.dirname", "os.path.join", "os.path.join", "yaml.load", "open"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load"], ["", "def", "get_open_mmlab_models", "(", ")", ":", "\n", "    ", "current_dir", "=", "os", ".", "path", ".", "dirname", "(", "__file__", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "current_dir", ",", "'..'", ",", "'model_zoo'", ",", "'open_mmlab.yaml'", ")", "\n", "\n", "model_urls", "=", "yaml", ".", "load", "(", "open", "(", "file_path", ")", ")", "\n", "\n", "return", "model_urls", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_url_dist": [[40, 52], ["parallel.get_dist_info", "int", "os.environ.get", "os.environ.get", "torch.utils.model_zoo.load_url", "torch.distributed.barrier", "torch.utils.model_zoo.load_url"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.get_dist_info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "load_url_dist", "(", "url", ",", "model_dir", "=", "None", ")", ":", "\n", "    ", "\"\"\"In distributed setting, this function only download checkpoint at local\n    rank 0.\"\"\"", "\n", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "rank", "=", "int", "(", "os", ".", "environ", ".", "get", "(", "'LOCAL_RANK'", ",", "rank", ")", ")", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "checkpoint", "=", "model_zoo", ".", "load_url", "(", "url", ",", "model_dir", "=", "model_dir", ")", "\n", "", "if", "world_size", ">", "1", ":", "\n", "        ", "torch", ".", "distributed", ".", "barrier", "(", ")", "\n", "if", "rank", ">", "0", ":", "\n", "            ", "checkpoint", "=", "model_zoo", ".", "load_url", "(", "url", ",", "model_dir", "=", "model_dir", ")", "\n", "", "", "return", "checkpoint", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_state_dict": [[55, 121], ["getattr", "state_dict.copy.copy", "checkpoint.load_state_dict.load"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load"], ["", "def", "load_state_dict", "(", "module", ",", "state_dict", ",", "strict", "=", "False", ",", "logger", "=", "None", ")", ":", "\n", "    ", "\"\"\"Load state_dict to a module.\n\n    This method is modified from :meth:`torch.nn.Module.load_state_dict`.\n    Default value for ``strict`` is set to ``False`` and the message for\n    param mismatch will be shown even if strict is False.\n\n    Args:\n        module (Module): Module that receives the state_dict.\n        state_dict (OrderedDict): Weights.\n        strict (bool): whether to strictly enforce that the keys\n            in :attr:`state_dict` match the keys returned by this module's\n            :meth:`~torch.nn.Module.state_dict` function. Default: ``False``.\n        logger (:obj:`logging.Logger`, optional): Logger to log the error\n            message. If not specified, print function will be used.\n    \"\"\"", "\n", "unexpected_keys", "=", "[", "]", "\n", "all_missing_keys", "=", "[", "]", "\n", "err_msg", "=", "[", "]", "\n", "\n", "metadata", "=", "getattr", "(", "state_dict", ",", "'_metadata'", ",", "None", ")", "\n", "state_dict", "=", "state_dict", ".", "copy", "(", ")", "\n", "if", "metadata", "is", "not", "None", ":", "\n", "        ", "state_dict", ".", "_metadata", "=", "metadata", "\n", "\n", "# use _load_from_state_dict to enable checkpoint version control", "\n", "", "def", "load", "(", "module", ",", "prefix", "=", "''", ")", ":", "\n", "# recursively check parallel module in case that the model has a", "\n", "# complicated structure, e.g., nn.Module(nn.Module(DDP))", "\n", "        ", "if", "is_module_wrapper", "(", "module", ")", ":", "\n", "            ", "module", "=", "module", ".", "module", "\n", "", "local_metadata", "=", "{", "}", "if", "metadata", "is", "None", "else", "metadata", ".", "get", "(", "\n", "prefix", "[", ":", "-", "1", "]", ",", "{", "}", ")", "\n", "module", ".", "_load_from_state_dict", "(", "state_dict", ",", "prefix", ",", "local_metadata", ",", "True", ",", "\n", "all_missing_keys", ",", "unexpected_keys", ",", "\n", "err_msg", ")", "\n", "for", "name", ",", "child", "in", "module", ".", "_modules", ".", "items", "(", ")", ":", "\n", "            ", "if", "child", "is", "not", "None", ":", "\n", "                ", "load", "(", "child", ",", "prefix", "+", "name", "+", "'.'", ")", "\n", "\n", "", "", "", "load", "(", "module", ")", "\n", "load", "=", "None", "# break load->load reference cycle", "\n", "\n", "# ignore \"num_batches_tracked\" of BN layers", "\n", "missing_keys", "=", "[", "\n", "key", "for", "key", "in", "all_missing_keys", "if", "'num_batches_tracked'", "not", "in", "key", "\n", "]", "\n", "\n", "if", "unexpected_keys", ":", "\n", "        ", "err_msg", ".", "append", "(", "'unexpected key in source '", "\n", "f'state_dict: {\", \".join(unexpected_keys)}\\n'", ")", "\n", "", "if", "missing_keys", ":", "\n", "        ", "err_msg", ".", "append", "(", "\n", "f'missing keys in source state_dict: {\", \".join(missing_keys)}\\n'", ")", "\n", "\n", "", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "if", "len", "(", "err_msg", ")", ">", "0", "and", "rank", "==", "0", ":", "\n", "        ", "err_msg", ".", "insert", "(", "\n", "0", ",", "'The model and loaded state dict do not match exactly\\n'", ")", "\n", "err_msg", "=", "'\\n'", ".", "join", "(", "err_msg", ")", "\n", "if", "strict", ":", "\n", "            ", "raise", "RuntimeError", "(", "err_msg", ")", "\n", "", "elif", "logger", "is", "not", "None", ":", "\n", "            ", "logger", ".", "warning", "(", "err_msg", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "err_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint._load_checkpoint": [[124, 154], ["filepath.startswith", "checkpoint.get_torchvision_models", "checkpoint.load_url_dist", "filepath.startswith", "checkpoint.get_open_mmlab_models", "checkpoint.load_url_dist", "filepath.startswith", "checkpoint.load_url_dist", "torch.load", "os.isfile", "IOError"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.get_torchvision_models", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_url_dist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.get_open_mmlab_models", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_url_dist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_url_dist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load"], ["", "", "", "def", "_load_checkpoint", "(", "filepath", ",", "map_location", "=", "None", ")", ":", "\n", "    ", "\"\"\"Load checkpoint from somewhere (modelzoo, file, url).\n\n    Args:\n        filepath (str): Accept local filepath, URL, ``torchvision://xxx``,\n            ``open-mmlab://xxx``. Please refer to ``docs/model_zoo.md`` for\n            details.\n        map_location (str | None): Same as :func:`torch.load`. Default: None.\n\n    Returns:\n        dict | OrderedDict: The loaded checkpoint. It can be either an\n            OrderedDict storing model weights or a dict containing other\n            information, which depends on the checkpoint.\n    \"\"\"", "\n", "if", "filepath", ".", "startswith", "(", "'torchvision://'", ")", ":", "\n", "        ", "model_urls", "=", "get_torchvision_models", "(", ")", "\n", "model_name", "=", "filepath", "[", "14", ":", "]", "\n", "checkpoint", "=", "load_url_dist", "(", "model_urls", "[", "model_name", "]", ")", "\n", "", "elif", "filepath", ".", "startswith", "(", "'open-mmlab://'", ")", ":", "\n", "        ", "model_urls", "=", "get_open_mmlab_models", "(", ")", "\n", "model_name", "=", "filepath", "[", "13", ":", "]", "\n", "checkpoint", "=", "load_url_dist", "(", "model_urls", "[", "model_name", "]", ")", "\n", "checkpoint", "=", "checkpoint", "[", "'state_dict'", "]", "\n", "", "elif", "filepath", ".", "startswith", "(", "(", "'http://'", ",", "'https://'", ")", ")", ":", "\n", "        ", "checkpoint", "=", "load_url_dist", "(", "filepath", ")", "\n", "", "else", ":", "\n", "        ", "if", "not", "osp", ".", "isfile", "(", "filepath", ")", ":", "\n", "            ", "raise", "IOError", "(", "f'{filepath} is not a file'", ")", "\n", "", "checkpoint", "=", "torch", ".", "load", "(", "filepath", ",", "map_location", "=", "map_location", ")", "\n", "", "return", "checkpoint", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.weights_to_cpu": [[157, 170], ["collections.OrderedDict", "state_dict.items", "val.cpu"], "function", ["None"], ["", "def", "weights_to_cpu", "(", "state_dict", ")", ":", "\n", "    ", "\"\"\"Copy a model state_dict to cpu.\n\n    Args:\n        state_dict (OrderedDict): Model weights on GPU.\n\n    Returns:\n        OrderedDict: Model weights on CPU.\n    \"\"\"", "\n", "state_dict_cpu", "=", "OrderedDict", "(", ")", "\n", "for", "key", ",", "val", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "        ", "state_dict_cpu", "[", "key", "]", "=", "val", ".", "cpu", "(", ")", "\n", "", "return", "state_dict_cpu", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.optimizer_to_cpu": [[172, 190], ["collections.OrderedDict", "state_dict.items", "dict", "val.items", "isinstance", "v.cpu.cpu"], "function", ["None"], ["", "def", "optimizer_to_cpu", "(", "state_dict", ")", ":", "\n", "    ", "\"\"\"Copy a optimizer to cpu.\n\n    Args:\n        state_dict (OrderedDict): Model weights on GPU.\n\n    Returns:\n        OrderedDict: optimizer on CPU.\n    \"\"\"", "\n", "state_dict_cpu", "=", "OrderedDict", "(", ")", "\n", "for", "key", ",", "val", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "        ", "tmp", "=", "dict", "(", ")", "\n", "for", "k", ",", "v", "in", "val", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "v", "=", "v", ".", "cpu", "(", ")", "\n", "", "tmp", "[", "k", "]", "=", "v", "\n", "", "state_dict_cpu", "[", "key", "]", "=", "tmp", "\n", "", "return", "state_dict_cpu", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.save_weights": [[192, 208], ["utils.mkdir_or_exist", "parallel.is_module_wrapper", "checkpoint.weights_to_cpu", "os.dirname", "model.state_dict", "open", "torch.save", "f.flush"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.mkdir_or_exist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.utils.is_module_wrapper", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.weights_to_cpu"], ["", "def", "save_weights", "(", "model", ",", "filepath", ")", ":", "\n", "    ", "\"\"\"Save checkpoint to file.\n\n    Args:\n        model (Module): Module whose params are to be saved.\n        filepath (str): Checkpoint filepath.\n    \"\"\"", "\n", "mkdir_or_exist", "(", "osp", ".", "dirname", "(", "filepath", ")", ")", "\n", "if", "is_module_wrapper", "(", "model", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "\n", "", "checkpoint", "=", "weights_to_cpu", "(", "model", ".", "state_dict", "(", ")", ")", "\n", "# immediately flush buffer", "\n", "with", "open", "(", "filepath", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "torch", ".", "save", "(", "checkpoint", ",", "f", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.save_optimizer": [[210, 237], ["utils.mkdir_or_exist", "isinstance", "os.dirname", "optimizer.state_dict", "checkpoint.optimizer_to_cpu", "isinstance", "open", "torch.save", "f.flush", "optimizer.items", "optim.state_dict", "checkpoint.optimizer_to_cpu"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.mkdir_or_exist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.optimizer_to_cpu", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.optimizer_to_cpu"], ["", "", "def", "save_optimizer", "(", "optimizer", ",", "filepath", ")", ":", "\n", "    ", "\"\"\"Save checkpoint to file.\n\n    The checkpoint will have 2 fields: ``meta``, ``state_dict``.\n    By default ``meta`` will epoch and iteration info.\n\n    Args:\n        optimizer (:obj:`Optimizer`): Optimizer to be saved.\n        meta (dict): Metadata to be saved in checkpoint.\n        filepath (str): Checkpoint filepath.\n    \"\"\"", "\n", "mkdir_or_exist", "(", "osp", ".", "dirname", "(", "filepath", ")", ")", "\n", "# save optimizer state dict in the checkpoint", "\n", "if", "isinstance", "(", "optimizer", ",", "Optimizer", ")", ":", "\n", "        ", "state_dict", "=", "optimizer", ".", "state_dict", "(", ")", "\n", "state_dict", "[", "'state'", "]", "=", "optimizer_to_cpu", "(", "state_dict", "[", "'state'", "]", ")", "\n", "", "elif", "isinstance", "(", "optimizer", ",", "dict", ")", ":", "\n", "        ", "state_dict", "=", "{", "}", "\n", "for", "name", ",", "optim", "in", "optimizer", ".", "items", "(", ")", ":", "\n", "            ", "state_dict", "[", "name", "]", "=", "optim", ".", "state_dict", "(", ")", "\n", "state_dict", "[", "name", "]", "[", "'state'", "]", "=", "optimizer_to_cpu", "(", "\n", "state_dict", "[", "name", "]", "[", "'state'", "]", ")", "\n", "\n", "# immediately flush buffer", "\n", "", "", "with", "open", "(", "filepath", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "torch", ".", "save", "(", "state_dict", ",", "f", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.save_meta": [[239, 255], ["utils.mkdir_or_exist", "os.dirname", "open", "torch.save", "f.flush"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.mkdir_or_exist"], ["", "", "def", "save_meta", "(", "meta", ",", "filepath", ")", ":", "\n", "    ", "\"\"\"Save checkpoint to file.\n\n    The checkpoint will have 2 fields: ``meta``, ``state_dict``. By default\n    ``meta`` will epoch and iteration info.\n\n    Args:\n        optimizer (:obj:`Optimizer`): Optimizer to be saved.\n        meta (dict): Metadata to be saved in checkpoint.\n        filepath (str): Checkpoint filepath.\n    \"\"\"", "\n", "mkdir_or_exist", "(", "osp", ".", "dirname", "(", "filepath", ")", ")", "\n", "# immediately flush buffer", "\n", "with", "open", "(", "filepath", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "torch", ".", "save", "(", "meta", ",", "f", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_weights": [[257, 286], ["checkpoint._load_checkpoint", "[].startswith", "checkpoint.load_state_dict", "list", "_load_checkpoint.items", "_load_checkpoint.items", "_load_checkpoint.keys"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint._load_checkpoint", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_state_dict"], ["", "", "def", "load_weights", "(", "model", ",", "\n", "filepath", ",", "\n", "map_location", "=", "None", ",", "\n", "strict", "=", "False", ",", "\n", "logger", "=", "None", ",", "\n", "prefix", "=", "None", ")", ":", "\n", "    ", "\"\"\"Load checkpoint from a file or URI.\n\n    Args:\n        model (Module): Module to load checkpoint.\n        filepath (str): Accept local filepath, URL, ``torchvision://xxx``,\n            ``open-mmlab://xxx``. Please refer to ``docs/model_zoo.md`` for\n            details.\n        map_location (str): Same as :func:`torch.load`.\n        strict (bool): Whether to allow different params for the model and\n            checkpoint.\n        logger (:mod:`logging.Logger` or None): The logger for error message.\n\n    Returns:\n        dict or OrderedDict: The loaded checkpoint.\n    \"\"\"", "\n", "state_dict", "=", "_load_checkpoint", "(", "filepath", ",", "map_location", ")", "\n", "# strip prefix of state_dict", "\n", "if", "list", "(", "state_dict", ".", "keys", "(", ")", ")", "[", "0", "]", ".", "startswith", "(", "'module.'", ")", ":", "\n", "        ", "state_dict", "=", "{", "k", "[", "7", ":", "]", ":", "v", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", "}", "\n", "", "if", "prefix", "is", "not", "None", ":", "\n", "        ", "state_dict", "=", "{", "'%s.%s'", "%", "(", "prefix", ",", "k", ")", ":", "v", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", "}", "\n", "# load state_dict", "\n", "", "load_state_dict", "(", "model", ",", "state_dict", ",", "strict", ",", "logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_optimizer": [[288, 302], ["checkpoint._load_checkpoint", "optimizer.load_state_dict"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint._load_checkpoint", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_state_dict"], ["", "def", "load_optimizer", "(", "optimizer", ",", "filepath", ",", "map_location", "=", "None", ")", ":", "\n", "    ", "\"\"\"Load checkpoint from a file or URI.\n\n    Args:\n        optimizer (Module): Optimizer to load checkpoint.\n        filepath (str): Accept local filepath, URL, ``torchvision://xxx``,\n            ``open-mmlab://xxx``. Please refer to ``docs/model_zoo.md`` for\n            details.\n        map_location (str): Same as :func:`torch.load`.\n    Returns:\n        meta (dict): epoch and iter information\n    \"\"\"", "\n", "state_dict", "=", "_load_checkpoint", "(", "filepath", ",", "map_location", ")", "\n", "optimizer", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_meta": [[304, 318], ["checkpoint._load_checkpoint"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint._load_checkpoint"], ["", "def", "load_meta", "(", "filepath", ",", "map_location", "=", "None", ")", ":", "\n", "    ", "\"\"\"Load checkpoint from a file or URI.\n\n    Args:\n        optimizer (Module): Optimizer to load checkpoint.\n        filepath (str): Accept local filepath, URL, ``torchvision://xxx``,\n            ``open-mmlab://xxx``. Please refer to ``docs/model_zoo.md`` for\n            details.\n        map_location (str): Same as :func:`torch.load`.\n    Returns:\n        meta (dict): epoch and iter information\n    \"\"\"", "\n", "state_dict", "=", "_load_checkpoint", "(", "filepath", ",", "map_location", ")", "\n", "return", "state_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.logger.get_root_logger": [[6, 18], ["vedacore.misc.get_logger"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.logging.get_logger"], ["from", ".", "base_hook", "import", "BaseHook", "\n", "\n", "\n", "@", "registry", ".", "register_module", "(", "'hook'", ")", "\n", "class", "LoggerHook", "(", "BaseHook", ")", ":", "\n", "\n", "    ", "def", "__init__", "(", "self", ",", "interval", "=", "1", ",", "by_epoch", "=", "True", ")", ":", "\n", "        ", "self", ".", "interval", "=", "interval", "\n", "self", ".", "by_epoch", "=", "by_epoch", "\n", "\n", "", "def", "_train_log_info", "(", "self", ",", "log_dict", ",", "looper", ")", ":", "\n", "        ", "if", "log_dict", "[", "'mode'", "]", "==", "'train'", ":", "\n", "            ", "if", "isinstance", "(", "log_dict", "[", "'lr'", "]", ",", "dict", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.anchor.videos_to_levels": [[6, 19], ["torch.stack", "level_targets.append"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack"], ["def", "videos_to_levels", "(", "target", ",", "num_levels", ")", ":", "\n", "    ", "\"\"\"Convert targets by image to targets by feature level.\n\n    [target_video0, target_video1] -> [target_level0, target_level1, ...]\n    \"\"\"", "\n", "target", "=", "torch", ".", "stack", "(", "target", ",", "0", ")", "\n", "level_targets", "=", "[", "]", "\n", "start", "=", "0", "\n", "for", "n", "in", "num_levels", ":", "\n", "        ", "end", "=", "start", "+", "n", "\n", "level_targets", ".", "append", "(", "target", "[", ":", ",", "start", ":", "end", "]", ")", "\n", "start", "=", "end", "\n", "", "return", "level_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.anchor.anchor_inside_flags": [[21, 42], ["None"], "function", ["None"], ["", "def", "anchor_inside_flags", "(", "flat_anchors", ",", "valid_flags", ",", "tsize", ",", "allowed_border", "=", "0", ")", ":", "\n", "    ", "\"\"\"Check whether the anchors are inside the border.\n\n    Args:\n        flat_anchors (torch.Tensor): Flatten anchors, shape (n, 2).\n        valid_flags (torch.Tensor): An existing valid flags of anchors.\n        tsize (int): Temporal size of current video.\n        allowed_border (int, optional): The border to allow the valid anchor.\n            Defaults to 0.\n\n    Returns:\n        torch.Tensor: Flags indicating whether the anchors are inside a\n            valid range.\n    \"\"\"", "\n", "if", "allowed_border", ">=", "0", ":", "\n", "        ", "inside_flags", "=", "(", "\n", "valid_flags", "&", "(", "flat_anchors", "[", ":", ",", "0", "]", ">=", "-", "allowed_border", ")", "&", "\n", "(", "flat_anchors", "[", ":", ",", "1", "]", "<", "tsize", "+", "allowed_border", ")", ")", "\n", "", "else", ":", "\n", "        ", "inside_flags", "=", "valid_flags", "\n", "", "return", "inside_flags", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.photometric.imnormalize": [[5, 19], ["img.copy().astype.copy().astype", "photometric.imnormalize_", "img.copy().astype.copy"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.photometric.imnormalize_"], ["def", "imnormalize", "(", "img", ",", "mean", ",", "std", ",", "to_rgb", "=", "True", ")", ":", "\n", "    ", "\"\"\"Normalize an image with mean and std.\n\n    Args:\n        img (ndarray): Image to be normalized.\n        mean (ndarray): The mean to be used for normalize.\n        std (ndarray): The std to be used for normalize.\n        to_rgb (bool): Whether to convert to rgb.\n\n    Returns:\n        ndarray: The normalized image.\n    \"\"\"", "\n", "img", "=", "img", ".", "copy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "return", "imnormalize_", "(", "img", ",", "mean", ",", "std", ",", "to_rgb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.photometric.imnormalize_": [[21, 42], ["numpy.float64", "np.float64.reshape", "numpy.float64", "std.reshape"], "function", ["None"], ["", "def", "imnormalize_", "(", "img", ",", "mean", ",", "std", ",", "to_rgb", "=", "True", ")", ":", "\n", "    ", "\"\"\"Inplace normalize an image with mean and std.\n\n    Args:\n        img (ndarray): Image to be normalized.\n        mean (ndarray): The mean to be used for normalize.\n        std (ndarray): The std to be used for normalize.\n        to_rgb (bool): Whether to convert to rgb.\n\n    Returns:\n        ndarray: The normalized image.\n    \"\"\"", "\n", "# cv2 inplace normalization does not accept uint8", "\n", "assert", "img", ".", "dtype", "!=", "np", ".", "uint8", "\n", "mean", "=", "np", ".", "float64", "(", "mean", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "stdinv", "=", "1", "/", "np", ".", "float64", "(", "std", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "if", "to_rgb", ":", "\n", "        ", "img", "=", "img", "[", "...", ",", ":", ":", "-", "1", "]", "# inplace", "\n", "", "img", "-=", "mean", "# inplace", "\n", "img", "*=", "stdinv", "# inplace", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.photometric.imdenormalize": [[44, 53], ["mean.reshape().astype.reshape().astype", "std.reshape().astype.reshape().astype", "cv2.multiply", "cv2.add", "cv2.cvtColor", "mean.reshape().astype.reshape", "std.reshape().astype.reshape"], "function", ["None"], ["", "def", "imdenormalize", "(", "img", ",", "mean", ",", "std", ",", "to_bgr", "=", "True", ")", ":", "\n", "    ", "assert", "img", ".", "dtype", "!=", "np", ".", "uint8", "\n", "mean", "=", "mean", ".", "reshape", "(", "1", ",", "-", "1", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "std", "=", "std", ".", "reshape", "(", "1", ",", "-", "1", ")", ".", "astype", "(", "np", ".", "float64", ")", "\n", "img", "=", "cv2", ".", "multiply", "(", "img", ",", "std", ")", "# make a copy", "\n", "cv2", ".", "add", "(", "img", ",", "mean", ",", "img", ")", "# inplace", "\n", "if", "to_bgr", ":", "\n", "        ", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_RGB2BGR", ",", "img", ")", "# inplace", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.photometric.iminvert": [[55, 65], ["numpy.full_like"], "function", ["None"], ["", "def", "iminvert", "(", "img", ")", ":", "\n", "    ", "\"\"\"Invert (negate) an image.\n\n    Args:\n        img (ndarray): Image to be inverted.\n\n    Returns:\n        ndarray: The inverted image.\n    \"\"\"", "\n", "return", "np", ".", "full_like", "(", "img", ",", "255", ")", "-", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.photometric.solarize": [[67, 79], ["numpy.where"], "function", ["None"], ["", "def", "solarize", "(", "img", ",", "thr", "=", "128", ")", ":", "\n", "    ", "\"\"\"Solarize an image (invert all pixel values above a threshold)\n\n    Args:\n        img (ndarray): Image to be solarized.\n        thr (int): Threshold for solarizing (0 - 255).\n\n    Returns:\n        ndarray: The solarized image.\n    \"\"\"", "\n", "img", "=", "np", ".", "where", "(", "img", "<", "thr", ",", "img", ",", "255", "-", "img", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.photometric.posterize": [[81, 94], ["numpy.left_shift", "numpy.right_shift"], "function", ["None"], ["", "def", "posterize", "(", "img", ",", "bits", ")", ":", "\n", "    ", "\"\"\"Posterize an image (reduce the number of bits for each color channel)\n\n    Args:\n        img (ndarray): Image to be posterized.\n        bits (int): Number of bits (1 to 8) to use for posterizing.\n\n    Returns:\n        ndarray: The posterized image.\n    \"\"\"", "\n", "shift", "=", "8", "-", "bits", "\n", "img", "=", "np", ".", "left_shift", "(", "np", ".", "right_shift", "(", "img", ",", "shift", ")", ",", "shift", ")", "\n", "return", "img", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io.use_backend": [[34, 54], ["ImportError", "TurboJPEG", "ImportError"], "function", ["None"], ["", "if", "file_format", "is", "None", "and", "is_str", "(", "file", ")", ":", "\n", "        ", "file_format", "=", "file", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "", "if", "file_format", "not", "in", "file_handlers", ":", "\n", "        ", "raise", "TypeError", "(", "f'Unsupported format: {file_format}'", ")", "\n", "\n", "", "handler", "=", "file_handlers", "[", "file_format", "]", "\n", "if", "is_str", "(", "file", ")", ":", "\n", "        ", "obj", "=", "handler", ".", "load_from_path", "(", "file", ",", "**", "kwargs", ")", "\n", "", "elif", "hasattr", "(", "file", ",", "'read'", ")", ":", "\n", "        ", "obj", "=", "handler", ".", "load_from_fileobj", "(", "file", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'\"file\" must be a filepath str or a file-object'", ")", "\n", "", "return", "obj", "\n", "\n", "\n", "", "def", "dump", "(", "obj", ",", "file", "=", "None", ",", "file_format", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io._jpegflag": [[56, 70], ["channel_order.lower.lower", "ValueError", "ValueError"], "function", ["None"], ["\n", "if", "isinstance", "(", "file", ",", "Path", ")", ":", "\n", "        ", "file", "=", "str", "(", "file", ")", "\n", "", "if", "file_format", "is", "None", ":", "\n", "        ", "if", "is_str", "(", "file", ")", ":", "\n", "            ", "file_format", "=", "file", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "", "elif", "file", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io._pillow2array": [[72, 121], ["channel_order.lower.lower", "ValueError", "numpy.array", "numpy.array", "img.convert.convert", "img.convert.convert", "Image.new", "img.convert.paste", "img.convert.convert", "numpy.array", "ValueError", "img.convert.split"], "function", ["None"], ["'file_format must be specified since file is None'", ")", "\n", "", "", "if", "file_format", "not", "in", "file_handlers", ":", "\n", "        ", "raise", "TypeError", "(", "f'Unsupported format: {file_format}'", ")", "\n", "\n", "", "handler", "=", "file_handlers", "[", "file_format", "]", "\n", "if", "file", "is", "None", ":", "\n", "        ", "return", "handler", ".", "dump_to_str", "(", "obj", ",", "**", "kwargs", ")", "\n", "", "elif", "is_str", "(", "file", ")", ":", "\n", "        ", "handler", ".", "dump_to_path", "(", "obj", ",", "file", ",", "**", "kwargs", ")", "\n", "", "elif", "hasattr", "(", "file", ",", "'write'", ")", ":", "\n", "        ", "handler", ".", "dump_to_fileobj", "(", "obj", ",", "file", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'\"file\" must be a filename str or a file-object'", ")", "\n", "\n", "\n", "", "", "def", "_register_handler", "(", "handler", ",", "file_formats", ")", ":", "\n", "    ", "\"\"\"Register a handler for some file extensions.\n\n    Args:\n        handler (:obj:`BaseFileHandler`): Handler to be registered.\n        file_formats (str or list[str]): File formats to be handled by this\n            handler.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "handler", ",", "BaseFileHandler", ")", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "f'handler must be a child of BaseFileHandler, not {type(handler)}'", ")", "\n", "", "if", "isinstance", "(", "file_formats", ",", "str", ")", ":", "\n", "        ", "file_formats", "=", "[", "file_formats", "]", "\n", "", "if", "not", "is_list_of", "(", "file_formats", ",", "str", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'file_formats must be a str or a list of str'", ")", "\n", "", "for", "ext", "in", "file_formats", ":", "\n", "        ", "file_handlers", "[", "ext", "]", "=", "handler", "\n", "\n", "\n", "", "", "def", "register_handler", "(", "file_formats", ",", "**", "kwargs", ")", ":", "\n", "\n", "    ", "def", "wrap", "(", "cls", ")", ":", "\n", "        ", "_register_handler", "(", "cls", "(", "**", "kwargs", ")", ",", "file_formats", ")", "\n", "return", "cls", "\n", "\n", "", "return", "wrap", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io.imread": [[123, 175], ["isinstance", "isinstance", "ValueError", "str", "vedacore.misc.is_str", "vedacore.misc.check_file_exist", "TypeError", "open", "jpeg.decode", "Image.open", "io._pillow2array", "cv2.imread", "in_file.read", "io._jpegflag", "vedacore.misc.is_str", "cv2.cvtColor"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.check_file_exist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.decode", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io._pillow2array", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io.imread", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io._jpegflag", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io.imfrombytes": [[178, 215], ["ValueError", "jpeg.decode", "io._jpegflag", "io.BytesIO", "Image.open", "io._pillow2array", "numpy.frombuffer", "cv2.imdecode", "vedacore.misc.is_str", "cv2.cvtColor"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.decode", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io._jpegflag", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io._pillow2array", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io.imwrite": [[217, 234], ["cv2.imwrite", "os.abspath", "vedacore.misc.mkdir_or_exist", "os.dirname"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io.imwrite", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.mkdir_or_exist"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.imconvert": [[6, 20], ["getattr", "cv2.cvtColor", "src.upper", "dst.upper"], "function", ["None"], ["def", "imconvert", "(", "img", ",", "src", ",", "dst", ")", ":", "\n", "    ", "\"\"\"Convert an image from the src colorspace to dst colorspace.\n\n    Args:\n        img (ndarray): The input image.\n        src (str): The source colorspace, e.g., 'rgb', 'hsv'.\n        dst (str): The destination colorspace, e.g., 'rgb', 'hsv'.\n\n    Returns:\n        ndarray: The converted image.\n    \"\"\"", "\n", "code", "=", "getattr", "(", "cv2", ",", "f'COLOR_{src.upper()}2{dst.upper()}'", ")", "\n", "out_img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "code", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.bgr2gray": [[22, 37], ["cv2.cvtColor"], "function", ["None"], ["", "def", "bgr2gray", "(", "img", ",", "keepdim", "=", "False", ")", ":", "\n", "    ", "\"\"\"Convert a BGR image to grayscale image.\n\n    Args:\n        img (ndarray): The input image.\n        keepdim (bool): If False (by default), then return the grayscale image\n            with 2 dims, otherwise 3 dims.\n\n    Returns:\n        ndarray: The converted grayscale image.\n    \"\"\"", "\n", "out_img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2GRAY", ")", "\n", "if", "keepdim", ":", "\n", "        ", "out_img", "=", "out_img", "[", "...", ",", "None", "]", "\n", "", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.rgb2gray": [[39, 54], ["cv2.cvtColor"], "function", ["None"], ["", "def", "rgb2gray", "(", "img", ",", "keepdim", "=", "False", ")", ":", "\n", "    ", "\"\"\"Convert a RGB image to grayscale image.\n\n    Args:\n        img (ndarray): The input image.\n        keepdim (bool): If False (by default), then return the grayscale image\n            with 2 dims, otherwise 3 dims.\n\n    Returns:\n        ndarray: The converted grayscale image.\n    \"\"\"", "\n", "out_img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_RGB2GRAY", ")", "\n", "if", "keepdim", ":", "\n", "        ", "out_img", "=", "out_img", "[", "...", ",", "None", "]", "\n", "", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.gray2bgr": [[56, 68], ["cv2.cvtColor"], "function", ["None"], ["", "def", "gray2bgr", "(", "img", ")", ":", "\n", "    ", "\"\"\"Convert a grayscale image to BGR image.\n\n    Args:\n        img (ndarray): The input image.\n\n    Returns:\n        ndarray: The converted BGR image.\n    \"\"\"", "\n", "img", "=", "img", "[", "...", ",", "None", "]", "if", "img", ".", "ndim", "==", "2", "else", "img", "\n", "out_img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_GRAY2BGR", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.gray2rgb": [[70, 82], ["cv2.cvtColor"], "function", ["None"], ["", "def", "gray2rgb", "(", "img", ")", ":", "\n", "    ", "\"\"\"Convert a grayscale image to RGB image.\n\n    Args:\n        img (ndarray): The input image.\n\n    Returns:\n        ndarray: The converted RGB image.\n    \"\"\"", "\n", "img", "=", "img", "[", "...", ",", "None", "]", "if", "img", ".", "ndim", "==", "2", "else", "img", "\n", "out_img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_GRAY2RGB", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_input_type_range": [[84, 110], ["img.astype.astype", "TypeError"], "function", ["None"], ["", "def", "_convert_input_type_range", "(", "img", ")", ":", "\n", "    ", "\"\"\"Convert the type and range of the input image.\n\n    It converts the input image to np.float32 type and range of [0, 1].\n    It is mainly used for pre-processing the input image in colorspace\n    convertion functions such as rgb2ycbcr and ycbcr2rgb.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n\n    Returns:\n        (ndarray): The converted image with type of np.float32 and range of\n            [0, 1].\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "img_type", "==", "np", ".", "float32", ":", "\n", "        ", "pass", "\n", "", "elif", "img_type", "==", "np", ".", "uint8", ":", "\n", "        ", "img", "/=", "255.", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'The img type should be np.float32 or np.uint8, '", "\n", "f'but got {img_type}'", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_output_type_range": [[112, 141], ["img.round.astype", "TypeError", "img.round.round"], "function", ["None"], ["", "def", "_convert_output_type_range", "(", "img", ",", "dst_type", ")", ":", "\n", "    ", "\"\"\"Convert the type and range of the image according to dst_type.\n\n    It converts the image to desired type and range. If `dst_type` is np.uint8,\n    images will be converted to np.uint8 type with range [0, 255]. If\n    `dst_type` is np.float32, it converts the image to np.float32 type with\n    range [0, 1].\n    It is mainly used for post-processing images in colorspace convertion\n    functions such as rgb2ycbcr and ycbcr2rgb.\n\n    Args:\n        img (ndarray): The image to be converted with np.float32 type and\n            range [0, 255].\n        dst_type (np.uint8 | np.float32): If dst_type is np.uint8, it\n            converts the image to np.uint8 type with range [0, 255]. If\n            dst_type is np.float32, it converts the image to np.float32 type\n            with range [0, 1].\n\n    Returns:\n        (ndarray): The converted image with desired type and range.\n    \"\"\"", "\n", "if", "dst_type", "not", "in", "(", "np", ".", "uint8", ",", "np", ".", "float32", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'The dst_type should be np.float32 or np.uint8, '", "\n", "f'but got {dst_type}'", ")", "\n", "", "if", "dst_type", "==", "np", ".", "uint8", ":", "\n", "        ", "img", "=", "img", ".", "round", "(", ")", "\n", "", "else", ":", "\n", "        ", "img", "/=", "255.", "\n", "", "return", "img", ".", "astype", "(", "dst_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.rgb2ycbcr": [[143, 175], ["colorspace._convert_input_type_range", "colorspace._convert_output_type_range", "numpy.dot", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_input_type_range", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_output_type_range"], ["", "def", "rgb2ycbcr", "(", "img", ",", "y_only", "=", "False", ")", ":", "\n", "    ", "\"\"\"Convert a RGB image to YCbCr image.\n\n    This function produces the same results as Matlab's `rgb2ycbcr` function.\n    It implements the ITU-R BT.601 conversion for standard-definition\n    television. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion.\n\n    It differs from a similar function in cv2.cvtColor: `RGB <-> YCrCb`.\n    In OpenCV, it implements a JPEG conversion. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n        y_only (bool): Whether to only return Y channel. Default: False.\n\n    Returns:\n        ndarray: The converted YCbCr image. The output image has the same type\n            and range as input image.\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "_convert_input_type_range", "(", "img", ")", "\n", "if", "y_only", ":", "\n", "        ", "out_img", "=", "np", ".", "dot", "(", "img", ",", "[", "65.481", ",", "128.553", ",", "24.966", "]", ")", "+", "16.0", "\n", "", "else", ":", "\n", "        ", "out_img", "=", "np", ".", "matmul", "(", "\n", "img", ",", "[", "[", "65.481", ",", "-", "37.797", ",", "112.0", "]", ",", "[", "128.553", ",", "-", "74.203", ",", "-", "93.786", "]", ",", "\n", "[", "24.966", ",", "112.0", ",", "-", "18.214", "]", "]", ")", "+", "[", "16", ",", "128", ",", "128", "]", "\n", "", "out_img", "=", "_convert_output_type_range", "(", "out_img", ",", "img_type", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.bgr2ycbcr": [[177, 209], ["colorspace._convert_input_type_range", "colorspace._convert_output_type_range", "numpy.dot", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_input_type_range", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_output_type_range"], ["", "def", "bgr2ycbcr", "(", "img", ",", "y_only", "=", "False", ")", ":", "\n", "    ", "\"\"\"Convert a BGR image to YCbCr image.\n\n    The bgr version of rgb2ycbcr.\n    It implements the ITU-R BT.601 conversion for standard-definition\n    television. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion.\n\n    It differs from a similar function in cv2.cvtColor: `BGR <-> YCrCb`.\n    In OpenCV, it implements a JPEG conversion. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n        y_only (bool): Whether to only return Y channel. Default: False.\n\n    Returns:\n        ndarray: The converted YCbCr image. The output image has the same type\n            and range as input image.\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "_convert_input_type_range", "(", "img", ")", "\n", "if", "y_only", ":", "\n", "        ", "out_img", "=", "np", ".", "dot", "(", "img", ",", "[", "24.966", ",", "128.553", ",", "65.481", "]", ")", "+", "16.0", "\n", "", "else", ":", "\n", "        ", "out_img", "=", "np", ".", "matmul", "(", "\n", "img", ",", "[", "[", "24.966", ",", "112.0", ",", "-", "18.214", "]", ",", "[", "128.553", ",", "-", "74.203", ",", "-", "93.786", "]", ",", "\n", "[", "65.481", ",", "-", "37.797", ",", "112.0", "]", "]", ")", "+", "[", "16", ",", "128", ",", "128", "]", "\n", "", "out_img", "=", "_convert_output_type_range", "(", "out_img", ",", "img_type", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.ycbcr2rgb": [[211, 241], ["colorspace._convert_output_type_range", "colorspace._convert_input_type_range", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_output_type_range", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_input_type_range"], ["", "def", "ycbcr2rgb", "(", "img", ")", ":", "\n", "    ", "\"\"\"Convert a YCbCr image to RGB image.\n\n    This function produces the same results as Matlab's ycbcr2rgb function.\n    It implements the ITU-R BT.601 conversion for standard-definition\n    television. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion.\n\n    It differs from a similar function in cv2.cvtColor: `YCrCb <-> RGB`.\n    In OpenCV, it implements a JPEG conversion. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n\n    Returns:\n        ndarray: The converted RGB image. The output image has the same type\n            and range as input image.\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "_convert_input_type_range", "(", "img", ")", "*", "255", "\n", "out_img", "=", "np", ".", "matmul", "(", "img", ",", "[", "[", "0.00456621", ",", "0.00456621", ",", "0.00456621", "]", ",", "\n", "[", "0", ",", "-", "0.00153632", ",", "0.00791071", "]", ",", "\n", "[", "0.00625893", ",", "-", "0.00318811", ",", "0", "]", "]", ")", "*", "255.0", "+", "[", "\n", "-", "222.921", ",", "135.576", ",", "-", "276.836", "\n", "]", "\n", "out_img", "=", "_convert_output_type_range", "(", "out_img", ",", "img_type", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.ycbcr2bgr": [[243, 273], ["colorspace._convert_output_type_range", "colorspace._convert_input_type_range", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_output_type_range", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace._convert_input_type_range"], ["", "def", "ycbcr2bgr", "(", "img", ")", ":", "\n", "    ", "\"\"\"Convert a YCbCr image to BGR image.\n\n    The bgr version of ycbcr2rgb.\n    It implements the ITU-R BT.601 conversion for standard-definition\n    television. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion.\n\n    It differs from a similar function in cv2.cvtColor: `YCrCb <-> BGR`.\n    In OpenCV, it implements a JPEG conversion. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n\n    Returns:\n        ndarray: The converted BGR image. The output image has the same type\n            and range as input image.\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "_convert_input_type_range", "(", "img", ")", "*", "255", "\n", "out_img", "=", "np", ".", "matmul", "(", "img", ",", "[", "[", "0.00456621", ",", "0.00456621", ",", "0.00456621", "]", ",", "\n", "[", "0.00791071", ",", "-", "0.00153632", ",", "0", "]", ",", "\n", "[", "0", ",", "-", "0.00318811", ",", "0.00625893", "]", "]", ")", "*", "255.0", "+", "[", "\n", "-", "276.836", ",", "135.576", ",", "-", "222.921", "\n", "]", "\n", "out_img", "=", "_convert_output_type_range", "(", "out_img", ",", "img_type", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.colorspace.convert_color_factory": [[275, 294], ["getattr", "cv2.cvtColor", "src.upper", "dst.upper", "dst.upper", "src.upper", "dst.upper"], "function", ["None"], ["", "def", "convert_color_factory", "(", "src", ",", "dst", ")", ":", "\n", "\n", "    ", "code", "=", "getattr", "(", "cv2", ",", "f'COLOR_{src.upper()}2{dst.upper()}'", ")", "\n", "\n", "def", "convert_color", "(", "img", ")", ":", "\n", "        ", "out_img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "code", ")", "\n", "return", "out_img", "\n", "\n", "", "convert_color", ".", "__doc__", "=", "f\"\"\"Convert a {src.upper()} image to {dst.upper()}\n        image.\n\n    Args:\n        img (ndarray or str): The input image.\n\n    Returns:\n        ndarray: The converted {dst.upper()} image.\n    \"\"\"", "\n", "\n", "return", "convert_color", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric._scale_size": [[6, 18], ["int", "int", "float", "float"], "function", ["None"], ["def", "_scale_size", "(", "size", ",", "scale", ")", ":", "\n", "    ", "\"\"\"Rescale a size by a ratio.\n\n    Args:\n        size (tuple[int]): (w, h).\n        scale (float): Scaling factor.\n\n    Returns:\n        tuple[int]: scaled size.\n    \"\"\"", "\n", "w", ",", "h", "=", "size", "\n", "return", "int", "(", "w", "*", "float", "(", "scale", ")", "+", "0.5", ")", ",", "int", "(", "h", "*", "float", "(", "scale", ")", "+", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imresize": [[39, 67], ["cv2.resize"], "function", ["None"], ["def", "imresize", "(", "img", ",", "\n", "size", ",", "\n", "return_scale", "=", "False", ",", "\n", "interpolation", "=", "'bilinear'", ",", "\n", "out", "=", "None", ")", ":", "\n", "    ", "\"\"\"Resize image to a given size.\n\n    Args:\n        img (ndarray): The input image.\n        size (tuple[int]): Target size (w, h).\n        return_scale (bool): Whether to return `w_scale` and `h_scale`.\n        interpolation (str): Interpolation method, accepted values are\n            \"nearest\", \"bilinear\", \"bicubic\", \"area\", \"lanczos\".\n        out (ndarray): The output destination.\n\n    Returns:\n        tuple | ndarray: (`resized_img`, `w_scale`, `h_scale`) or\n            `resized_img`.\n    \"\"\"", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "resized_img", "=", "cv2", ".", "resize", "(", "\n", "img", ",", "size", ",", "dst", "=", "out", ",", "interpolation", "=", "interp_codes", "[", "interpolation", "]", ")", "\n", "if", "not", "return_scale", ":", "\n", "        ", "return", "resized_img", "\n", "", "else", ":", "\n", "        ", "w_scale", "=", "size", "[", "0", "]", "/", "w", "\n", "h_scale", "=", "size", "[", "1", "]", "/", "h", "\n", "return", "resized_img", ",", "w_scale", ",", "h_scale", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imresize_like": [[69, 84], ["geometric.imresize"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imresize"], ["", "", "def", "imresize_like", "(", "img", ",", "dst_img", ",", "return_scale", "=", "False", ",", "interpolation", "=", "'bilinear'", ")", ":", "\n", "    ", "\"\"\"Resize image to the same size of a given image.\n\n    Args:\n        img (ndarray): The input image.\n        dst_img (ndarray): The target image.\n        return_scale (bool): Whether to return `w_scale` and `h_scale`.\n        interpolation (str): Same as :func:`resize`.\n\n    Returns:\n        tuple or ndarray: (`resized_img`, `w_scale`, `h_scale`) or\n            `resized_img`.\n    \"\"\"", "\n", "h", ",", "w", "=", "dst_img", ".", "shape", "[", ":", "2", "]", "\n", "return", "imresize", "(", "img", ",", "(", "w", ",", "h", ")", ",", "return_scale", ",", "interpolation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.rescale_size": [[86, 121], ["isinstance", "geometric._scale_size", "isinstance", "ValueError", "max", "min", "min", "TypeError", "max", "min", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric._scale_size"], ["", "def", "rescale_size", "(", "old_size", ",", "scale", ",", "return_scale", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculate the new size to be rescaled to.\n\n    Args:\n        old_size (tuple[int]): The old size (w, h) of image.\n        scale (float | tuple[int]): The scaling factor or maximum size.\n            If it is a float number, then the image will be rescaled by this\n            factor, else if it is a tuple of 2 integers, then the image will\n            be rescaled as large as possible within the scale.\n        return_scale (bool): Whether to return the scaling factor besides the\n            rescaled image size.\n\n    Returns:\n        tuple[int]: The new rescaled image size.\n    \"\"\"", "\n", "w", ",", "h", "=", "old_size", "\n", "if", "isinstance", "(", "scale", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "        ", "if", "scale", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "f'Invalid scale {scale}, must be positive.'", ")", "\n", "", "scale_factor", "=", "scale", "\n", "", "elif", "isinstance", "(", "scale", ",", "tuple", ")", ":", "\n", "        ", "max_long_edge", "=", "max", "(", "scale", ")", "\n", "max_short_edge", "=", "min", "(", "scale", ")", "\n", "scale_factor", "=", "min", "(", "max_long_edge", "/", "max", "(", "h", ",", "w", ")", ",", "\n", "max_short_edge", "/", "min", "(", "h", ",", "w", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "f'Scale must be a number or tuple of int, but got {type(scale)}'", ")", "\n", "\n", "", "new_size", "=", "_scale_size", "(", "(", "w", ",", "h", ")", ",", "scale_factor", ")", "\n", "\n", "if", "return_scale", ":", "\n", "        ", "return", "new_size", ",", "scale_factor", "\n", "", "else", ":", "\n", "        ", "return", "new_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imrescale": [[123, 146], ["geometric.rescale_size", "geometric.imresize"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.rescale_size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imresize"], ["", "", "def", "imrescale", "(", "img", ",", "scale", ",", "return_scale", "=", "False", ",", "interpolation", "=", "'bilinear'", ")", ":", "\n", "    ", "\"\"\"Resize image while keeping the aspect ratio.\n\n    Args:\n        img (ndarray): The input image.\n        scale (float | tuple[int]): The scaling factor or maximum size.\n            If it is a float number, then the image will be rescaled by this\n            factor, else if it is a tuple of 2 integers, then the image will\n            be rescaled as large as possible within the scale.\n        return_scale (bool): Whether to return the scaling factor besides the\n            rescaled image.\n        interpolation (str): Same as :func:`resize`.\n\n    Returns:\n        ndarray: The rescaled image.\n    \"\"\"", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "new_size", ",", "scale_factor", "=", "rescale_size", "(", "(", "w", ",", "h", ")", ",", "scale", ",", "return_scale", "=", "True", ")", "\n", "rescaled_img", "=", "imresize", "(", "img", ",", "new_size", ",", "interpolation", "=", "interpolation", ")", "\n", "if", "return_scale", ":", "\n", "        ", "return", "rescaled_img", ",", "scale_factor", "\n", "", "else", ":", "\n", "        ", "return", "rescaled_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imflip": [[148, 163], ["numpy.flip", "numpy.flip"], "function", ["None"], ["", "", "def", "imflip", "(", "img", ",", "direction", "=", "'horizontal'", ")", ":", "\n", "    ", "\"\"\"Flip an image horizontally or vertically.\n\n    Args:\n        img (ndarray): Image to be flipped.\n        direction (str): The flip direction, either \"horizontal\" or \"vertical\".\n\n    Returns:\n        ndarray: The flipped image.\n    \"\"\"", "\n", "assert", "direction", "in", "[", "'horizontal'", ",", "'vertical'", "]", "\n", "if", "direction", "==", "'horizontal'", ":", "\n", "        ", "return", "np", ".", "flip", "(", "img", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "        ", "return", "np", ".", "flip", "(", "img", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imflip_": [[165, 180], ["cv2.flip", "cv2.flip"], "function", ["None"], ["", "", "def", "imflip_", "(", "img", ",", "direction", "=", "'horizontal'", ")", ":", "\n", "    ", "\"\"\"Inplace flip an image horizontally or vertically.\n\n    Args:\n        img (ndarray): Image to be flipped.\n        direction (str): The flip direction, either \"horizontal\" or \"vertical\".\n\n    Returns:\n        ndarray: The flipped image (inplace).\n    \"\"\"", "\n", "assert", "direction", "in", "[", "'horizontal'", ",", "'vertical'", "]", "\n", "if", "direction", "==", "'horizontal'", ":", "\n", "        ", "return", "cv2", ".", "flip", "(", "img", ",", "1", ",", "img", ")", "\n", "", "else", ":", "\n", "        ", "return", "cv2", ".", "flip", "(", "img", ",", "0", ",", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imrotate": [[182, 236], ["isinstance", "cv2.getRotationMatrix2D", "cv2.warpAffine", "ValueError", "numpy.abs", "numpy.abs", "int", "int", "numpy.round", "numpy.round"], "function", ["None"], ["", "", "def", "imrotate", "(", "img", ",", "\n", "angle", ",", "\n", "center", "=", "None", ",", "\n", "scale", "=", "1.0", ",", "\n", "interpolation", "=", "'bilinear'", ",", "\n", "border_mode", "=", "'constant'", ",", "\n", "border_value", "=", "0", ",", "\n", "auto_bound", "=", "False", ")", ":", "\n", "    ", "\"\"\"Rotate an image.\n\n    Args:\n        img (ndarray): Image to be rotated.\n        angle (float): Rotation angle in degrees, positive values mean\n            clockwise rotation.\n        center (tuple[float], optional): Center point (w, h) of the rotation in\n            the source image. If not specified, the center of the image will be\n            used.\n        scale (float): Isotropic scale factor.\n        interpolation (str): Interpolation method, accepted values are\n            \"nearest\", \"bilinear\", \"bicubic\", \"area\", \"lanczos\".\n        border_mode (str): Border mode, accepted values are \"constant\",\n            \"isolated\", \"reflect\", \"reflect101\", \"replicate\", \"transparent\",\n            \"wrap\"\n        border_value (int, tuple or list): Border value.\n        auto_bound (bool): Whether to adjust the image size to cover the whole\n            rotated image.\n\n    Returns:\n        ndarray: The rotated image.\n    \"\"\"", "\n", "if", "center", "is", "not", "None", "and", "auto_bound", ":", "\n", "        ", "raise", "ValueError", "(", "'`auto_bound` conflicts with `center`'", ")", "\n", "", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "if", "center", "is", "None", ":", "\n", "        ", "center", "=", "(", "(", "w", "-", "1", ")", "*", "0.5", ",", "(", "h", "-", "1", ")", "*", "0.5", ")", "\n", "", "assert", "isinstance", "(", "center", ",", "tuple", ")", "\n", "\n", "matrix", "=", "cv2", ".", "getRotationMatrix2D", "(", "center", ",", "-", "angle", ",", "scale", ")", "\n", "if", "auto_bound", ":", "\n", "        ", "cos", "=", "np", ".", "abs", "(", "matrix", "[", "0", ",", "0", "]", ")", "\n", "sin", "=", "np", ".", "abs", "(", "matrix", "[", "0", ",", "1", "]", ")", "\n", "new_w", "=", "h", "*", "sin", "+", "w", "*", "cos", "\n", "new_h", "=", "h", "*", "cos", "+", "w", "*", "sin", "\n", "matrix", "[", "0", ",", "2", "]", "+=", "(", "new_w", "-", "w", ")", "*", "0.5", "\n", "matrix", "[", "1", ",", "2", "]", "+=", "(", "new_h", "-", "h", ")", "*", "0.5", "\n", "w", "=", "int", "(", "np", ".", "round", "(", "new_w", ")", ")", "\n", "h", "=", "int", "(", "np", ".", "round", "(", "new_h", ")", ")", "\n", "", "rotated", "=", "cv2", ".", "warpAffine", "(", "\n", "img", ",", "\n", "matrix", ",", "(", "w", ",", "h", ")", ",", "\n", "flags", "=", "interp_codes", "[", "interpolation", "]", ",", "\n", "borderMode", "=", "border_codes", "[", "border_mode", "]", ",", "\n", "borderValue", "=", "border_value", ")", "\n", "return", "rotated", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.bbox_clip": [[238, 254], ["numpy.empty", "numpy.maximum", "numpy.minimum"], "function", ["None"], ["", "def", "bbox_clip", "(", "bboxes", ",", "img_shape", ")", ":", "\n", "    ", "\"\"\"Clip bboxes to fit the image shape.\n\n    Args:\n        bboxes (ndarray): Shape (..., 4*k)\n        img_shape (tuple[int]): (height, width) of the image.\n\n    Returns:\n        ndarray: Clipped bboxes.\n    \"\"\"", "\n", "assert", "bboxes", ".", "shape", "[", "-", "1", "]", "%", "4", "==", "0", "\n", "cmin", "=", "np", ".", "empty", "(", "bboxes", ".", "shape", "[", "-", "1", "]", ",", "dtype", "=", "bboxes", ".", "dtype", ")", "\n", "cmin", "[", "0", ":", ":", "2", "]", "=", "img_shape", "[", "1", "]", "-", "1", "\n", "cmin", "[", "1", ":", ":", "2", "]", "=", "img_shape", "[", "0", "]", "-", "1", "\n", "clipped_bboxes", "=", "np", ".", "maximum", "(", "np", ".", "minimum", "(", "bboxes", ",", "cmin", ")", ",", "0", ")", "\n", "return", "clipped_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.bbox_scaling": [[256, 280], ["float", "bboxes.copy", "geometric.bbox_clip", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.bbox_clip", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack"], ["", "def", "bbox_scaling", "(", "bboxes", ",", "scale", ",", "clip_shape", "=", "None", ")", ":", "\n", "    ", "\"\"\"Scaling bboxes w.r.t the box center.\n\n    Args:\n        bboxes (ndarray): Shape(..., 4).\n        scale (float): Scaling factor.\n        clip_shape (tuple[int], optional): If specified, bboxes that exceed the\n            boundary will be clipped according to the given shape (h, w).\n\n    Returns:\n        ndarray: Scaled bboxes.\n    \"\"\"", "\n", "if", "float", "(", "scale", ")", "==", "1.0", ":", "\n", "        ", "scaled_bboxes", "=", "bboxes", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "        ", "w", "=", "bboxes", "[", "...", ",", "2", "]", "-", "bboxes", "[", "...", ",", "0", "]", "+", "1", "\n", "h", "=", "bboxes", "[", "...", ",", "3", "]", "-", "bboxes", "[", "...", ",", "1", "]", "+", "1", "\n", "dw", "=", "(", "w", "*", "(", "scale", "-", "1", ")", ")", "*", "0.5", "\n", "dh", "=", "(", "h", "*", "(", "scale", "-", "1", ")", ")", "*", "0.5", "\n", "scaled_bboxes", "=", "bboxes", "+", "np", ".", "stack", "(", "(", "-", "dw", ",", "-", "dh", ",", "dw", ",", "dh", ")", ",", "axis", "=", "-", "1", ")", "\n", "", "if", "clip_shape", "is", "not", "None", ":", "\n", "        ", "return", "bbox_clip", "(", "scaled_bboxes", ",", "clip_shape", ")", "\n", "", "else", ":", "\n", "        ", "return", "scaled_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imcrop": [[282, 334], ["bbox_scaling().astype", "geometric.bbox_clip", "range", "isinstance", "tuple", "patches.append", "len", "geometric.bbox_scaling", "tuple", "numpy.array", "numpy.ones", "range"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.bbox_clip", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.bbox_scaling"], ["", "", "def", "imcrop", "(", "img", ",", "bboxes", ",", "scale", "=", "1.0", ",", "pad_fill", "=", "None", ")", ":", "\n", "    ", "\"\"\"Crop image patches.\n\n    3 steps: scale the bboxes -> clip bboxes -> crop and pad.\n\n    Args:\n        img (ndarray): Image to be cropped.\n        bboxes (ndarray): Shape (k, 4) or (4, ), location of cropped bboxes.\n        scale (float, optional): Scale ratio of bboxes, the default value\n            1.0 means no padding.\n        pad_fill (Number | list[Number]): Value to be filled for padding.\n            Default: None, which means no padding.\n\n    Returns:\n        list[ndarray] | ndarray: The cropped image patches.\n    \"\"\"", "\n", "chn", "=", "1", "if", "img", ".", "ndim", "==", "2", "else", "img", ".", "shape", "[", "2", "]", "\n", "if", "pad_fill", "is", "not", "None", ":", "\n", "        ", "if", "isinstance", "(", "pad_fill", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "pad_fill", "=", "[", "pad_fill", "for", "_", "in", "range", "(", "chn", ")", "]", "\n", "", "assert", "len", "(", "pad_fill", ")", "==", "chn", "\n", "\n", "", "_bboxes", "=", "bboxes", "[", "None", ",", "...", "]", "if", "bboxes", ".", "ndim", "==", "1", "else", "bboxes", "\n", "scaled_bboxes", "=", "bbox_scaling", "(", "_bboxes", ",", "scale", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "clipped_bbox", "=", "bbox_clip", "(", "scaled_bboxes", ",", "img", ".", "shape", ")", "\n", "\n", "patches", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "clipped_bbox", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "tuple", "(", "clipped_bbox", "[", "i", ",", ":", "]", ")", "\n", "if", "pad_fill", "is", "None", ":", "\n", "            ", "patch", "=", "img", "[", "y1", ":", "y2", "+", "1", ",", "x1", ":", "x2", "+", "1", ",", "...", "]", "\n", "", "else", ":", "\n", "            ", "_x1", ",", "_y1", ",", "_x2", ",", "_y2", "=", "tuple", "(", "scaled_bboxes", "[", "i", ",", ":", "]", ")", "\n", "if", "chn", "==", "1", ":", "\n", "                ", "patch_shape", "=", "(", "_y2", "-", "_y1", "+", "1", ",", "_x2", "-", "_x1", "+", "1", ")", "\n", "", "else", ":", "\n", "                ", "patch_shape", "=", "(", "_y2", "-", "_y1", "+", "1", ",", "_x2", "-", "_x1", "+", "1", ",", "chn", ")", "\n", "", "patch", "=", "np", ".", "array", "(", "\n", "pad_fill", ",", "dtype", "=", "img", ".", "dtype", ")", "*", "np", ".", "ones", "(", "\n", "patch_shape", ",", "dtype", "=", "img", ".", "dtype", ")", "\n", "x_start", "=", "0", "if", "_x1", ">=", "0", "else", "-", "_x1", "\n", "y_start", "=", "0", "if", "_y1", ">=", "0", "else", "-", "_y1", "\n", "w", "=", "x2", "-", "x1", "+", "1", "\n", "h", "=", "y2", "-", "y1", "+", "1", "\n", "patch", "[", "y_start", ":", "y_start", "+", "h", ",", "x_start", ":", "x_start", "+", "w", ",", "\n", "...", "]", "=", "img", "[", "y1", ":", "y1", "+", "h", ",", "x1", ":", "x1", "+", "w", ",", "...", "]", "\n", "", "patches", ".", "append", "(", "patch", ")", "\n", "\n", "", "if", "bboxes", ".", "ndim", "==", "1", ":", "\n", "        ", "return", "patches", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "return", "patches", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.impad": [[336, 359], ["zip", "numpy.empty", "isinstance", "len", "len", "len", "len", "len"], "function", ["None"], ["", "", "def", "impad", "(", "img", ",", "shape", ",", "pad_val", "=", "0", ")", ":", "\n", "    ", "\"\"\"Pad an image or images to a certain shape.\n\n    Args:\n        img (ndarray): Image to be padded.\n        shape (tuple[int]): Expected padding shape (h, w).\n        pad_val (Number | Sequence[Number]): Values to be filled in padding\n            areas. Default: 0.\n\n    Returns:\n        ndarray: The padded image.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "pad_val", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "        ", "assert", "len", "(", "pad_val", ")", "==", "img", ".", "shape", "[", "-", "1", "]", "\n", "", "if", "len", "(", "shape", ")", "<", "len", "(", "img", ".", "shape", ")", ":", "\n", "        ", "shape", "=", "shape", "+", "(", "img", ".", "shape", "[", "-", "1", "]", ",", ")", "\n", "", "assert", "len", "(", "shape", ")", "==", "len", "(", "img", ".", "shape", ")", "\n", "for", "s", ",", "img_s", "in", "zip", "(", "shape", ",", "img", ".", "shape", ")", ":", "\n", "        ", "assert", "s", ">=", "img_s", "\n", "", "pad", "=", "np", ".", "empty", "(", "shape", ",", "dtype", "=", "img", ".", "dtype", ")", "\n", "pad", "[", "...", "]", "=", "pad_val", "\n", "pad", "[", ":", "img", ".", "shape", "[", "0", "]", ",", ":", "img", ".", "shape", "[", "1", "]", ",", ":", "img", ".", "shape", "[", "2", "]", ",", "...", "]", "=", "img", "\n", "return", "pad", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.impad_to_multiple": [[361, 375], ["tuple", "geometric.impad", "int", "numpy.ceil"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.impad"], ["", "def", "impad_to_multiple", "(", "img", ",", "divisor", ",", "pad_val", "=", "0", ")", ":", "\n", "    ", "\"\"\"Pad an image to ensure each edge to be multiple to some number.\n\n    Args:\n        img (ndarray): Image to be padded.\n        divisor (int): Padded image edges will be multiple to divisor.\n        pad_val (Number | Sequence[Number]): Same as :func:`impad`.\n\n    Returns:\n        ndarray: The padded image.\n    \"\"\"", "\n", "pad_shape", "=", "tuple", "(", "\n", "int", "(", "np", ".", "ceil", "(", "shape", "/", "divisor", ")", ")", "*", "divisor", "for", "shape", "in", "img", ".", "shape", "[", ":", "-", "1", "]", ")", "\n", "return", "impad", "(", "img", ",", "pad_shape", ",", "pad_val", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.snapshot.SnapshotHook.__init__": [[30, 43], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "interval", "=", "-", "1", ",", "\n", "by_epoch", "=", "True", ",", "\n", "save_optim_flag", "=", "True", ",", "\n", "outdir", "=", "None", ",", "\n", "max_keep_ckpts", "=", "-", "1", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "interval", "=", "interval", "\n", "self", ".", "by_epoch", "=", "by_epoch", "\n", "self", ".", "save_optim_flag", "=", "save_optim_flag", "\n", "self", ".", "outdir", "=", "outdir", "\n", "self", ".", "max_keep_ckpts", "=", "max_keep_ckpts", "\n", "self", ".", "args", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.snapshot.SnapshotHook.after_train_epoch": [[44, 65], ["looper.save_snapshot", "snapshot.SnapshotHook.args.get", "range", "snapshot.SnapshotHook.every_n_epochs", "os.path.join", "os.path.exists", "snapshot.SnapshotHook.format", "os.remove"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.save_snapshot", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.every_n_epochs"], ["", "@", "master_only", "\n", "def", "after_train_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "if", "not", "self", ".", "by_epoch", "or", "not", "self", ".", "every_n_epochs", "(", "looper", ",", "self", ".", "interval", ")", ":", "\n", "            ", "return", "\n", "\n", "", "if", "not", "self", ".", "outdir", ":", "\n", "            ", "self", ".", "outdir", "=", "looper", ".", "workdir", "\n", "", "looper", ".", "save_snapshot", "(", "\n", "self", ".", "outdir", ",", "save_optim_flag", "=", "self", ".", "save_optim_flag", ",", "**", "self", ".", "args", ")", "\n", "\n", "# remove other checkpoints", "\n", "if", "self", ".", "max_keep_ckpts", ">", "0", ":", "\n", "            ", "filename_tmpl", "=", "self", ".", "args", ".", "get", "(", "'filename_tmpl'", ",", "'epoch_{}.pth'", ")", "\n", "current_epoch", "=", "looper", ".", "epoch", "+", "1", "\n", "for", "epoch", "in", "range", "(", "current_epoch", "-", "self", ".", "max_keep_ckpts", ",", "0", ",", "-", "1", ")", ":", "\n", "                ", "ckpt_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "outdir", ",", "\n", "filename_tmpl", ".", "format", "(", "epoch", ")", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "ckpt_path", ")", ":", "\n", "                    ", "os", ".", "remove", "(", "ckpt_path", ")", "\n", "", "else", ":", "\n", "                    ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.snapshot.SnapshotHook.after_train_iter": [[66, 91], ["looper.logger.info", "looper.save_checkpoint", "snapshot.SnapshotHook.args.get", "range", "snapshot.SnapshotHook.every_n_iters", "os.path.join", "os.path.exists", "snapshot.SnapshotHook.format", "os.remove"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.every_n_iters"], ["", "", "", "", "@", "master_only", "\n", "def", "after_train_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "if", "self", ".", "by_epoch", "or", "not", "self", ".", "every_n_iters", "(", "looper", ",", "self", ".", "interval", ")", ":", "\n", "            ", "return", "\n", "\n", "", "looper", ".", "logger", ".", "info", "(", "\n", "f'Saving checkpoint at {looper.iter + 1} iterations'", ")", "\n", "if", "not", "self", ".", "outdir", ":", "\n", "            ", "self", ".", "outdir", "=", "looper", ".", "workdir", "\n", "", "looper", ".", "save_checkpoint", "(", "\n", "self", ".", "outdir", ",", "save_optimizer", "=", "self", ".", "save_optimizer", ",", "**", "self", ".", "args", ")", "\n", "\n", "# remove other checkpoints", "\n", "if", "self", ".", "max_keep_ckpts", ">", "0", ":", "\n", "            ", "filename_tmpl", "=", "self", ".", "args", ".", "get", "(", "'filename_tmpl'", ",", "'iter_{}.pth'", ")", "\n", "current_iter", "=", "looper", ".", "iter", "+", "1", "\n", "for", "_iter", "in", "range", "(", "\n", "current_iter", "-", "self", ".", "max_keep_ckpts", "*", "self", ".", "interval", ",", "0", ",", "\n", "-", "self", ".", "interval", ")", ":", "\n", "                ", "ckpt_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "outdir", ",", "\n", "filename_tmpl", ".", "format", "(", "_iter", ")", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "ckpt_path", ")", ":", "\n", "                    ", "os", ".", "remove", "(", "ckpt_path", ")", "\n", "", "else", ":", "\n", "                    ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.snapshot.SnapshotHook.modes": [[92, 95], ["None"], "methods", ["None"], ["", "", "", "", "@", "property", "\n", "def", "modes", "(", "self", ")", ":", "\n", "        ", "return", "[", "'train'", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.eval.EvalHook.__init__": [[63, 70], ["dict", "time.strftime", "time.localtime", "random.randint"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "tmpdir", "=", "None", ",", "eval_cfg", "=", "dict", "(", ")", ")", ":", "\n", "        ", "if", "tmpdir", "is", "None", ":", "\n", "            ", "timestamp", "=", "time", ".", "strftime", "(", "'%Y%m%d%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "self", ".", "tmpdir", "=", "'%s_%03d'", "%", "(", "timestamp", ",", "random", ".", "randint", "(", "0", ",", "999", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "tmpdir", "=", "tmpdir", "\n", "", "self", ".", "eval_cfg", "=", "eval_cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.eval.EvalHook.after_val_iter": [[71, 76], ["looper.his_val_results.extend"], "methods", ["None"], ["", "def", "after_val_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "cur_results", "=", "looper", ".", "cur_val_results", "\n", "if", "looper", ".", "his_val_results", "is", "None", ":", "\n", "            ", "looper", ".", "his_val_results", "=", "[", "]", "\n", "", "looper", ".", "his_val_results", ".", "extend", "(", "cur_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.eval.EvalHook.after_val_epoch": [[77, 93], ["vedacore.parallel.get_dist_info", "eval.collect_results_cpu", "looper.val_dataset.evaluate", "looper.val_dataset.evaluate.items", "len", "logger.info"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.get_dist_info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.eval.collect_results_cpu", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.evaluate", "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.info"], ["", "def", "after_val_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "results", "=", "looper", ".", "his_val_results", "\n", "logger", "=", "looper", ".", "logger", "\n", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "if", "world_size", ">", "1", ":", "\n", "            ", "all_results", "=", "collect_results_cpu", "(", "results", ",", "len", "(", "looper", ".", "val_dataset", ")", ",", "\n", "self", ".", "tmpdir", ")", "\n", "", "else", ":", "\n", "            ", "all_results", "=", "results", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "metric", "=", "looper", ".", "val_dataset", ".", "evaluate", "(", "\n", "all_results", ",", "logger", "=", "logger", ",", "**", "self", ".", "eval_cfg", ")", "\n", "for", "k", ",", "v", "in", "metric", ".", "items", "(", ")", ":", "\n", "                ", "if", "'copypaste'", "in", "k", ":", "\n", "                    ", "logger", ".", "info", "(", "f'{k}: {v}'", ")", "\n", "", "", "", "looper", ".", "his_val_results", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.eval.EvalHook.modes": [[94, 97], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "modes", "(", "self", ")", ":", "\n", "        ", "return", "[", "'val'", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.eval.collect_results_cpu": [[16, 58], ["vedacore.parallel.get_dist_info", "vedacore.dump", "torch.barrier", "torch.full", "torch.full", "torch.broadcast", "torch.full.cpu().numpy().tobytes().decode().rstrip", "vedacore.misc.mkdir_or_exist", "os.join", "range", "zip", "shutil.rmtree", "tempfile.mkdtemp", "torch.tensor", "torch.tensor", "os.join", "part_list.append", "ordered_results.extend", "bytearray", "torch.full.cpu().numpy().tobytes().decode", "vedacore.load", "list", "torch.tensor.encode", "len", "torch.full.cpu().numpy().tobytes", "torch.full.cpu().numpy", "torch.full.cpu"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.get_dist_info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.mkdir_or_exist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.decode", "home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load", "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.encode"], ["def", "collect_results_cpu", "(", "result_part", ",", "size", ",", "tmpdir", "=", "None", ")", ":", "\n", "# adapted from https://github.com/open-mmlab/mmcv or", "\n", "# https://github.com/open-mmlab/mmdetection", "\n", "    ", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "# create a tmp dir if it is not specified", "\n", "if", "tmpdir", "is", "None", ":", "\n", "        ", "MAX_LEN", "=", "512", "\n", "# 32 is whitespace", "\n", "dir_tensor", "=", "torch", ".", "full", "(", "(", "MAX_LEN", ",", ")", ",", "\n", "32", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "\n", "device", "=", "'cuda'", ")", "\n", "if", "rank", "==", "0", ":", "\n", "            ", "tmpdir", "=", "tempfile", ".", "mkdtemp", "(", ")", "\n", "tmpdir", "=", "torch", ".", "tensor", "(", "\n", "bytearray", "(", "tmpdir", ".", "encode", "(", ")", ")", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "'cuda'", ")", "\n", "dir_tensor", "[", ":", "len", "(", "tmpdir", ")", "]", "=", "tmpdir", "\n", "", "dist", ".", "broadcast", "(", "dir_tensor", ",", "0", ")", "\n", "tmpdir", "=", "dir_tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tobytes", "(", ")", ".", "decode", "(", ")", ".", "rstrip", "(", ")", "\n", "", "else", ":", "\n", "        ", "mkdir_or_exist", "(", "tmpdir", ")", "\n", "# dump the part result to the dir", "\n", "", "fileio", ".", "dump", "(", "result_part", ",", "osp", ".", "join", "(", "tmpdir", ",", "f'part_{rank}.pkl'", ")", ")", "\n", "dist", ".", "barrier", "(", ")", "\n", "# collect all parts", "\n", "if", "rank", "!=", "0", ":", "\n", "        ", "return", "None", "\n", "", "else", ":", "\n", "# load results of all parts from tmp dir", "\n", "        ", "part_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "world_size", ")", ":", "\n", "            ", "part_file", "=", "osp", ".", "join", "(", "tmpdir", ",", "f'part_{i}.pkl'", ")", "\n", "part_list", ".", "append", "(", "fileio", ".", "load", "(", "part_file", ")", ")", "\n", "# sort the results", "\n", "", "ordered_results", "=", "[", "]", "\n", "for", "res", "in", "zip", "(", "*", "part_list", ")", ":", "\n", "            ", "ordered_results", ".", "extend", "(", "list", "(", "res", ")", ")", "\n", "# the dataloader may pad some samples", "\n", "", "ordered_results", "=", "ordered_results", "[", ":", "size", "]", "\n", "# remove tmp dir", "\n", "shutil", ".", "rmtree", "(", "tmpdir", ")", "\n", "return", "ordered_results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_run": [[6, 8], ["None"], "methods", ["None"], ["    ", "def", "before_run", "(", "self", ",", "looper", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_run": [[9, 11], ["None"], "methods", ["None"], ["", "def", "after_run", "(", "self", ",", "looper", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_epoch": [[12, 14], ["None"], "methods", ["None"], ["", "def", "before_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_epoch": [[15, 17], ["None"], "methods", ["None"], ["", "def", "after_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_iter": [[18, 20], ["None"], "methods", ["None"], ["", "def", "before_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_iter": [[21, 23], ["None"], "methods", ["None"], ["", "def", "after_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_train_epoch": [[24, 26], ["base_hook.BaseHook.before_epoch"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_epoch"], ["", "def", "before_train_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "self", ".", "before_epoch", "(", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_val_epoch": [[27, 29], ["base_hook.BaseHook.before_epoch"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_epoch"], ["", "def", "before_val_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "self", ".", "before_epoch", "(", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_train_epoch": [[30, 32], ["base_hook.BaseHook.after_epoch"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_epoch"], ["", "def", "after_train_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "self", ".", "after_epoch", "(", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_val_epoch": [[33, 35], ["base_hook.BaseHook.after_epoch"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_epoch"], ["", "def", "after_val_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "self", ".", "after_epoch", "(", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_train_iter": [[36, 38], ["base_hook.BaseHook.before_iter"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_iter"], ["", "def", "before_train_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "self", ".", "before_iter", "(", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_val_iter": [[39, 41], ["base_hook.BaseHook.before_iter"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.before_iter"], ["", "def", "before_val_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "self", ".", "before_iter", "(", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_train_iter": [[42, 44], ["base_hook.BaseHook.after_iter"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_iter"], ["", "def", "after_train_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "self", ".", "after_iter", "(", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_val_iter": [[45, 47], ["base_hook.BaseHook.after_iter"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.after_iter"], ["", "def", "after_val_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "self", ".", "after_iter", "(", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.every_n_epochs": [[48, 50], ["None"], "methods", ["None"], ["", "def", "every_n_epochs", "(", "self", ",", "looper", ",", "n", ")", ":", "\n", "        ", "return", "looper", ".", "epoch", "%", "n", "==", "0", "if", "n", ">", "0", "else", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.every_n_inner_iters": [[51, 53], ["None"], "methods", ["None"], ["", "def", "every_n_inner_iters", "(", "self", ",", "looper", ",", "n", ")", ":", "\n", "        ", "return", "looper", ".", "inner_iter", "%", "n", "==", "0", "if", "n", ">", "0", "else", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.every_n_iters": [[54, 56], ["None"], "methods", ["None"], ["", "def", "every_n_iters", "(", "self", ",", "looper", ",", "n", ")", ":", "\n", "        ", "return", "looper", ".", "iter", "%", "n", "==", "0", "if", "n", ">", "0", "else", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.end_of_epoch": [[57, 59], ["len"], "methods", ["None"], ["", "def", "end_of_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "return", "looper", ".", "inner_iter", "+", "1", "==", "len", "(", "looper", ".", "data_loader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.modes": [[60, 64], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "modes", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.worker_init.WorkerInitHook.before_train_epoch": [[9, 13], ["hasattr", "worker_init_fn.set_epoch"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.DistributedGroupSampler.set_epoch"], ["def", "before_train_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "worker_init_fn", "=", "looper", ".", "train_dataloader", ".", "worker_init_fn", "\n", "if", "worker_init_fn", "is", "not", "None", "and", "hasattr", "(", "worker_init_fn", ",", "'set_epoch'", ")", ":", "\n", "            ", "worker_init_fn", ".", "set_epoch", "(", "looper", ".", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.worker_init.WorkerInitHook.modes": [[14, 17], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "modes", "(", "self", ")", ":", "\n", "        ", "return", "[", "'train'", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.logger.LoggerHook.__init__": [[12, 15], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "interval", "=", "1", ",", "by_epoch", "=", "True", ")", ":", "\n", "        ", "self", ".", "interval", "=", "interval", "\n", "self", ".", "by_epoch", "=", "by_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.logger.LoggerHook._train_log_info": [[16, 43], ["log_dict.items", "looper.logger.info", "isinstance", "isinstance", "log_items.append", "log_dict[].items", "lr_str.append", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.info"], ["", "def", "_train_log_info", "(", "self", ",", "log_dict", ",", "looper", ")", ":", "\n", "        ", "if", "log_dict", "[", "'mode'", "]", "==", "'train'", ":", "\n", "            ", "if", "isinstance", "(", "log_dict", "[", "'lr'", "]", ",", "dict", ")", ":", "\n", "                ", "lr_str", "=", "[", "]", "\n", "for", "k", ",", "val", "in", "log_dict", "[", "'lr'", "]", ".", "items", "(", ")", ":", "\n", "                    ", "lr_str", ".", "append", "(", "f'lr_{k}: {val:.4}'", ")", "\n", "", "lr_str", "=", "' '", ".", "join", "(", "lr_str", ")", "\n", "", "else", ":", "\n", "                ", "lr_str", "=", "f'lr: {log_dict[\"lr\"]:.4}'", "\n", "\n", "# by epoch: Epoch [4][100/1000]", "\n", "# by iter:  Iter [100/100000]", "\n", "", "if", "self", ".", "by_epoch", ":", "\n", "                ", "log_str", "=", "f'Epoch [{log_dict[\"epoch\"]}][{log_dict[\"iter\"]}'", "f'/{len(looper.train_dataloader)}] {lr_str}, '", "\n", "", "", "log_items", "=", "[", "]", "\n", "for", "name", ",", "val", "in", "log_dict", ".", "items", "(", ")", ":", "\n", "# TODO: resolve this hack", "\n", "# these items have been in log_str", "\n", "            ", "if", "name", "in", "[", "'mode'", ",", "'iter'", ",", "'lr'", ",", "'epoch'", "]", ":", "\n", "                ", "continue", "\n", "", "if", "isinstance", "(", "val", ",", "float", ")", ":", "\n", "                ", "val", "=", "f'{val:.4f}'", "\n", "", "log_items", ".", "append", "(", "f'{name}: {val}'", ")", "\n", "", "log_str", "+=", "', '", ".", "join", "(", "log_items", ")", "\n", "\n", "looper", ".", "logger", ".", "info", "(", "log_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.logger.LoggerHook.after_train_iter": [[44, 70], ["collections.OrderedDict", "looper.current_lr", "isinstance", "dict", "logger.LoggerHook.every_n_inner_iters", "isinstance", "looper.current_lr.items", "logger.LoggerHook._train_log_info", "isinstance", "log_dict[].update"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.current_lr", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.every_n_inner_iters", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.logger.LoggerHook._train_log_info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update"], ["", "def", "after_train_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "log_dict", "=", "OrderedDict", "(", ")", "\n", "cur_lr", "=", "looper", ".", "current_lr", "(", ")", "\n", "# only record lr of the first param group", "\n", "if", "isinstance", "(", "cur_lr", ",", "list", ")", ":", "\n", "            ", "log_dict", "[", "'lr'", "]", "=", "cur_lr", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "cur_lr", ",", "dict", ")", "\n", "log_dict", "[", "'lr'", "]", "=", "{", "}", "\n", "for", "k", ",", "lr_", "in", "cur_lr", ".", "items", "(", ")", ":", "\n", "                ", "assert", "isinstance", "(", "lr_", ",", "list", ")", "\n", "log_dict", "[", "'lr'", "]", ".", "update", "(", "{", "k", ":", "lr_", "[", "0", "]", "}", ")", "\n", "\n", "", "", "log_dict", "[", "'mode'", "]", "=", "looper", ".", "mode", "\n", "log_dict", "[", "'epoch'", "]", "=", "looper", ".", "epoch", "+", "1", "\n", "\n", "if", "self", ".", "by_epoch", ":", "\n", "            ", "log_dict", "[", "'iter'", "]", "=", "looper", ".", "inner_iter", "\n", "", "else", ":", "\n", "            ", "log_dict", "[", "'iter'", "]", "=", "looper", ".", "iter", "\n", "\n", "", "results", "=", "looper", ".", "cur_train_results", "\n", "log_dict", "=", "dict", "(", "log_dict", ",", "**", "results", "[", "'log_vars'", "]", ")", "\n", "\n", "if", "self", ".", "every_n_inner_iters", "(", "looper", ",", "self", ".", "interval", ")", ":", "\n", "            ", "self", ".", "_train_log_info", "(", "log_dict", ",", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.logger.LoggerHook._val_log_info": [[71, 76], ["looper.logger.info", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.info"], ["", "", "def", "_val_log_info", "(", "self", ",", "log_dict", ",", "looper", ")", ":", "\n", "        ", "log_str", "=", "f'Validating '", "f'[{log_dict[\"iter\"]}/{len(looper.val_dataloader)}]'", "\n", "\n", "looper", ".", "logger", ".", "info", "(", "log_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.logger.LoggerHook.after_val_iter": [[77, 87], ["collections.OrderedDict", "logger.LoggerHook.every_n_inner_iters", "logger.LoggerHook._val_log_info"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.base_hook.BaseHook.every_n_inner_iters", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.logger.LoggerHook._val_log_info"], ["", "def", "after_val_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "if", "'train'", "in", "looper", ".", "modes", ":", "\n", "            ", "return", "\n", "\n", "", "log_dict", "=", "OrderedDict", "(", ")", "\n", "log_dict", "[", "'mode'", "]", "=", "looper", ".", "mode", "\n", "log_dict", "[", "'iter'", "]", "=", "looper", ".", "inner_iter", "\n", "\n", "if", "self", ".", "every_n_inner_iters", "(", "looper", ",", "self", ".", "interval", ")", ":", "\n", "            ", "self", ".", "_val_log_info", "(", "log_dict", ",", "looper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.logger.LoggerHook.modes": [[88, 91], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "modes", "(", "self", ")", ":", "\n", "        ", "return", "[", "'train'", ",", "'val'", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.builder.build_hook": [[4, 6], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "import", "torch", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.__init__": [[6, 11], ["hook_pool.HookPool.register_hooks"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.register_hooks"], ["    ", "def", "__init__", "(", "self", ",", "hooks", ",", "modes", ",", "logger", ")", ":", "\n", "        ", "self", ".", "hooks", "=", "[", "]", "\n", "self", ".", "modes", "=", "modes", "\n", "self", ".", "logger", "=", "logger", "\n", "self", ".", "register_hooks", "(", "hooks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.register_hook": [[12, 19], ["builder.build_hook", "set", "set", "hook_pool.HookPool.hooks.insert", "hook_pool.HookPool.logger.warning"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.builder.build_hook"], ["", "def", "register_hook", "(", "self", ",", "hook_cfg", ")", ":", "\n", "        ", "hook", "=", "build_hook", "(", "hook_cfg", ")", "\n", "if", "set", "(", "hook", ".", "modes", ")", "&", "set", "(", "self", ".", "modes", ")", ":", "\n", "            ", "self", ".", "hooks", ".", "insert", "(", "-", "1", ",", "hook", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "logger", ".", "warning", "(", "\n", "f'{hook.__class__.__name__} is not in modes {self.modes}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.register_hooks": [[20, 23], ["hook_pool.HookPool.register_hook"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.register_hook"], ["", "", "def", "register_hooks", "(", "self", ",", "hook_cfgs", ")", ":", "\n", "        ", "for", "hook_cfg", "in", "hook_cfgs", ":", "\n", "            ", "self", ".", "register_hook", "(", "hook_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.fire": [[24, 27], ["getattr"], "methods", ["None"], ["", "", "def", "fire", "(", "self", ",", "hook_type", ",", "looper", ")", ":", "\n", "        ", "for", "hook", "in", "self", ".", "hooks", ":", "\n", "            ", "getattr", "(", "hook", ",", "hook_type", ")", "(", "looper", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.__init__": [[23, 55], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "by_epoch", "=", "True", ",", "\n", "warmup", "=", "None", ",", "\n", "warmup_iters", "=", "0", ",", "\n", "warmup_ratio", "=", "0.1", ",", "\n", "warmup_by_epoch", "=", "False", ")", ":", "\n", "# validate the \"warmup\" argument", "\n", "        ", "if", "warmup", "is", "not", "None", ":", "\n", "            ", "if", "warmup", "not", "in", "[", "'constant'", ",", "'linear'", ",", "'exp'", "]", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f'\"{warmup}\" is not a supported type for warming up, valid'", "\n", "' types are \"constant\" and \"linear\"'", ")", "\n", "", "", "if", "warmup", "is", "not", "None", ":", "\n", "            ", "assert", "warmup_iters", ">", "0", ",", "'\"warmup_iters\" must be a positive integer'", "\n", "assert", "0", "<", "warmup_ratio", "<=", "1.0", ",", "'\"warmup_ratio\" must be in range (0,1]'", "\n", "\n", "", "self", ".", "by_epoch", "=", "by_epoch", "\n", "self", ".", "warmup", "=", "warmup", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_ratio", "=", "warmup_ratio", "\n", "self", ".", "warmup_by_epoch", "=", "warmup_by_epoch", "\n", "\n", "if", "self", ".", "warmup_by_epoch", ":", "\n", "            ", "self", ".", "warmup_epochs", "=", "self", ".", "warmup_iters", "\n", "self", ".", "warmup_iters", "=", "None", "\n", "", "else", ":", "\n", "            ", "self", ".", "warmup_epochs", "=", "None", "\n", "\n", "", "self", ".", "base_lr", "=", "[", "]", "# initial lr for all param groups", "\n", "self", ".", "regular_lr", "=", "[", "]", "# expected lr if no warming up is performed", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook._set_lr": [[56, 65], ["isinstance", "optimizer.items", "zip", "zip"], "methods", ["None"], ["", "def", "_set_lr", "(", "self", ",", "looper", ",", "lr_groups", ")", ":", "\n", "        ", "optimizer", "=", "looper", ".", "train_engine", ".", "optimizer", "\n", "if", "isinstance", "(", "optimizer", ",", "dict", ")", ":", "\n", "            ", "for", "k", ",", "optim", "in", "optimizer", ".", "items", "(", ")", ":", "\n", "                ", "for", "param_group", ",", "lr", "in", "zip", "(", "optim", ".", "param_groups", ",", "lr_groups", "[", "k", "]", ")", ":", "\n", "                    ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "", "", "", "else", ":", "\n", "            ", "for", "param_group", ",", "lr", "in", "zip", "(", "optimizer", ".", "param_groups", ",", "lr_groups", ")", ":", "\n", "                ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.get_lr": [[66, 68], ["None"], "methods", ["None"], ["", "", "", "def", "get_lr", "(", "self", ",", "looper", ",", "base_lr", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.get_regular_lr": [[69, 83], ["isinstance", "looper.optimizer.keys", "lr_groups.update", "lr_scheduler.LrSchedulerHook.get_lr", "lr_scheduler.LrSchedulerHook.get_lr"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CyclicLrSchedulerHook.get_lr", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CyclicLrSchedulerHook.get_lr"], ["", "def", "get_regular_lr", "(", "self", ",", "looper", ")", ":", "\n", "        ", "optimizer", "=", "looper", ".", "train_engine", ".", "optimizer", "\n", "if", "isinstance", "(", "optimizer", ",", "dict", ")", ":", "\n", "            ", "lr_groups", "=", "{", "}", "\n", "for", "k", "in", "looper", ".", "optimizer", ".", "keys", "(", ")", ":", "\n", "                ", "_lr_group", "=", "[", "\n", "self", ".", "get_lr", "(", "looper", ",", "_base_lr", ")", "\n", "for", "_base_lr", "in", "self", ".", "base_lr", "[", "k", "]", "\n", "]", "\n", "lr_groups", ".", "update", "(", "{", "k", ":", "_lr_group", "}", ")", "\n", "\n", "", "return", "lr_groups", "\n", "", "else", ":", "\n", "            ", "return", "[", "self", ".", "get_lr", "(", "looper", ",", "_base_lr", ")", "for", "_base_lr", "in", "self", ".", "base_lr", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.get_warmup_lr": [[84, 94], ["None"], "methods", ["None"], ["", "", "def", "get_warmup_lr", "(", "self", ",", "cur_iters", ")", ":", "\n", "        ", "if", "self", ".", "warmup", "==", "'constant'", ":", "\n", "            ", "warmup_lr", "=", "[", "_lr", "*", "self", ".", "warmup_ratio", "for", "_lr", "in", "self", ".", "regular_lr", "]", "\n", "", "elif", "self", ".", "warmup", "==", "'linear'", ":", "\n", "            ", "k", "=", "(", "1", "-", "cur_iters", "/", "self", ".", "warmup_iters", ")", "*", "(", "1", "-", "self", ".", "warmup_ratio", ")", "\n", "warmup_lr", "=", "[", "_lr", "*", "(", "1", "-", "k", ")", "for", "_lr", "in", "self", ".", "regular_lr", "]", "\n", "", "elif", "self", ".", "warmup", "==", "'exp'", ":", "\n", "            ", "k", "=", "self", ".", "warmup_ratio", "**", "(", "1", "-", "cur_iters", "/", "self", ".", "warmup_iters", ")", "\n", "warmup_lr", "=", "[", "_lr", "*", "k", "for", "_lr", "in", "self", ".", "regular_lr", "]", "\n", "", "return", "warmup_lr", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.before_run": [[95, 113], ["isinstance", "optimizer.items", "lr_scheduler.LrSchedulerHook.base_lr.update", "group.setdefault", "group.setdefault"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update"], ["", "def", "before_run", "(", "self", ",", "looper", ")", ":", "\n", "# NOTE: when resuming from a checkpoint, if 'initial_lr' is not saved,", "\n", "# it will be set according to the optimizer params", "\n", "        ", "optimizer", "=", "looper", ".", "train_engine", ".", "optimizer", "\n", "if", "isinstance", "(", "optimizer", ",", "dict", ")", ":", "\n", "            ", "self", ".", "base_lr", "=", "{", "}", "\n", "for", "k", ",", "optim", "in", "optimizer", ".", "items", "(", ")", ":", "\n", "                ", "for", "group", "in", "optim", ".", "param_groups", ":", "\n", "                    ", "group", ".", "setdefault", "(", "'initial_lr'", ",", "group", "[", "'lr'", "]", ")", "\n", "", "_base_lr", "=", "[", "\n", "group", "[", "'initial_lr'", "]", "for", "group", "in", "optim", ".", "param_groups", "\n", "]", "\n", "self", ".", "base_lr", ".", "update", "(", "{", "k", ":", "_base_lr", "}", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "group", "in", "optimizer", ".", "param_groups", ":", "\n", "                ", "group", ".", "setdefault", "(", "'initial_lr'", ",", "group", "[", "'lr'", "]", ")", "\n", "", "self", ".", "base_lr", "=", "[", "\n", "group", "[", "'initial_lr'", "]", "for", "group", "in", "optimizer", ".", "param_groups", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.before_train_epoch": [[115, 125], ["lr_scheduler.LrSchedulerHook.get_regular_lr", "lr_scheduler.LrSchedulerHook._set_lr", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.get_regular_lr", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook._set_lr"], ["", "", "def", "before_train_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "if", "self", ".", "warmup_iters", "is", "None", ":", "\n", "            ", "epoch_len", "=", "len", "(", "looper", ".", "data_loader", ")", "\n", "self", ".", "warmup_iters", "=", "self", ".", "warmup_epochs", "*", "epoch_len", "\n", "\n", "", "if", "not", "self", ".", "by_epoch", ":", "\n", "            ", "return", "\n", "\n", "", "self", ".", "regular_lr", "=", "self", ".", "get_regular_lr", "(", "looper", ")", "\n", "self", ".", "_set_lr", "(", "looper", ",", "self", ".", "regular_lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.before_train_iter": [[126, 143], ["lr_scheduler.LrSchedulerHook.get_regular_lr", "lr_scheduler.LrSchedulerHook._set_lr", "lr_scheduler.LrSchedulerHook.get_warmup_lr", "lr_scheduler.LrSchedulerHook._set_lr", "lr_scheduler.LrSchedulerHook._set_lr", "lr_scheduler.LrSchedulerHook.get_warmup_lr", "lr_scheduler.LrSchedulerHook._set_lr"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.get_regular_lr", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook._set_lr", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.get_warmup_lr", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook._set_lr", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook._set_lr", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.get_warmup_lr", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook._set_lr"], ["", "def", "before_train_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "cur_iter", "=", "looper", ".", "iter", "\n", "if", "not", "self", ".", "by_epoch", ":", "\n", "            ", "self", ".", "regular_lr", "=", "self", ".", "get_regular_lr", "(", "looper", ")", "\n", "if", "self", ".", "warmup", "is", "None", "or", "cur_iter", ">=", "self", ".", "warmup_iters", ":", "\n", "                ", "self", ".", "_set_lr", "(", "looper", ",", "self", ".", "regular_lr", ")", "\n", "", "else", ":", "\n", "                ", "warmup_lr", "=", "self", ".", "get_warmup_lr", "(", "cur_iter", ")", "\n", "self", ".", "_set_lr", "(", "looper", ",", "warmup_lr", ")", "\n", "", "", "elif", "self", ".", "by_epoch", ":", "\n", "            ", "if", "self", ".", "warmup", "is", "None", "or", "cur_iter", ">", "self", ".", "warmup_iters", ":", "\n", "                ", "return", "\n", "", "elif", "cur_iter", "==", "self", ".", "warmup_iters", ":", "\n", "                ", "self", ".", "_set_lr", "(", "looper", ",", "self", ".", "regular_lr", ")", "\n", "", "else", ":", "\n", "                ", "warmup_lr", "=", "self", ".", "get_warmup_lr", "(", "cur_iter", ")", "\n", "self", ".", "_set_lr", "(", "looper", ",", "warmup_lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.LrSchedulerHook.modes": [[144, 147], ["None"], "methods", ["None"], ["", "", "", "@", "property", "\n", "def", "modes", "(", "self", ")", ":", "\n", "        ", "return", "[", "'train'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.FixedLrSchedulerHook.__init__": [[152, 154], ["lr_scheduler.LrSchedulerHook.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "FixedLrSchedulerHook", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.FixedLrSchedulerHook.get_lr": [[155, 157], ["None"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ",", "looper", ",", "base_lr", ")", ":", "\n", "        ", "return", "base_lr", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.StepLrSchedulerHook.__init__": [[162, 174], ["isinstance", "isinstance", "lr_scheduler.LrSchedulerHook.__init__", "isinstance", "TypeError", "isinstance"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "step", ",", "gamma", "=", "0.1", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "isinstance", "(", "step", ",", "(", "list", ",", "int", ")", ")", "\n", "if", "isinstance", "(", "step", ",", "list", ")", ":", "\n", "            ", "for", "s", "in", "step", ":", "\n", "                ", "assert", "isinstance", "(", "s", ",", "int", ")", "and", "s", ">", "0", "\n", "", "", "elif", "isinstance", "(", "step", ",", "int", ")", ":", "\n", "            ", "assert", "step", ">", "0", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "'\"step\" must be a list or integer'", ")", "\n", "", "self", ".", "step", "=", "step", "\n", "self", ".", "gamma", "=", "gamma", "\n", "super", "(", "StepLrSchedulerHook", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.StepLrSchedulerHook.get_lr": [[175, 187], ["isinstance", "len", "enumerate"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ",", "looper", ",", "base_lr", ")", ":", "\n", "        ", "progress", "=", "looper", ".", "epoch", "if", "self", ".", "by_epoch", "else", "looper", ".", "iter", "\n", "\n", "if", "isinstance", "(", "self", ".", "step", ",", "int", ")", ":", "\n", "            ", "return", "base_lr", "*", "(", "self", ".", "gamma", "**", "(", "progress", "//", "self", ".", "step", ")", ")", "\n", "\n", "", "exp", "=", "len", "(", "self", ".", "step", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "self", ".", "step", ")", ":", "\n", "            ", "if", "progress", "<", "s", ":", "\n", "                ", "exp", "=", "i", "\n", "break", "\n", "", "", "return", "base_lr", "*", "self", ".", "gamma", "**", "exp", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.ExpLrSchedulerHook.__init__": [[192, 195], ["lr_scheduler.LrSchedulerHook.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "gamma", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "gamma", "=", "gamma", "\n", "super", "(", "ExpLrSchedulerHook", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.ExpLrSchedulerHook.get_lr": [[196, 199], ["None"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ",", "looper", ",", "base_lr", ")", ":", "\n", "        ", "progress", "=", "looper", ".", "epoch", "if", "self", ".", "by_epoch", "else", "looper", ".", "iter", "\n", "return", "base_lr", "*", "self", ".", "gamma", "**", "progress", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.PolyLrSchedulerHook.__init__": [[204, 208], ["lr_scheduler.LrSchedulerHook.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "power", "=", "1.", ",", "min_lr", "=", "0.", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "power", "=", "power", "\n", "self", ".", "min_lr", "=", "min_lr", "\n", "super", "(", "PolyLrSchedulerHook", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.PolyLrSchedulerHook.get_lr": [[209, 218], ["None"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ",", "looper", ",", "base_lr", ")", ":", "\n", "        ", "if", "self", ".", "by_epoch", ":", "\n", "            ", "progress", "=", "looper", ".", "epoch", "\n", "max_progress", "=", "looper", ".", "max_epochs", "\n", "", "else", ":", "\n", "            ", "progress", "=", "looper", ".", "iter", "\n", "max_progress", "=", "looper", ".", "max_iters", "\n", "", "coeff", "=", "(", "1", "-", "progress", "/", "max_progress", ")", "**", "self", ".", "power", "\n", "return", "(", "base_lr", "-", "self", ".", "min_lr", ")", "*", "coeff", "+", "self", ".", "min_lr", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.InvLrSchedulerHook.__init__": [[223, 227], ["lr_scheduler.LrSchedulerHook.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "gamma", ",", "power", "=", "1.", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "power", "=", "power", "\n", "super", "(", "InvLrSchedulerHook", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.InvLrSchedulerHook.get_lr": [[228, 231], ["None"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ",", "looper", ",", "base_lr", ")", ":", "\n", "        ", "progress", "=", "looper", ".", "epoch", "if", "self", ".", "by_epoch", "else", "looper", ".", "iter", "\n", "return", "base_lr", "*", "(", "1", "+", "self", ".", "gamma", "*", "progress", ")", "**", "(", "-", "self", ".", "power", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CosineAnnealingLrSchedulerHook.__init__": [[236, 241], ["lr_scheduler.LrSchedulerHook.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "min_lr", "=", "None", ",", "min_lr_ratio", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "(", "min_lr", "is", "None", ")", "^", "(", "min_lr_ratio", "is", "None", ")", "\n", "self", ".", "min_lr", "=", "min_lr", "\n", "self", ".", "min_lr_ratio", "=", "min_lr_ratio", "\n", "super", "(", "CosineAnnealingLrSchedulerHook", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CosineAnnealingLrSchedulerHook.get_lr": [[242, 255], ["lr_scheduler.annealing_cos"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.annealing_cos"], ["", "def", "get_lr", "(", "self", ",", "looper", ",", "base_lr", ")", ":", "\n", "        ", "if", "self", ".", "by_epoch", ":", "\n", "            ", "progress", "=", "looper", ".", "epoch", "\n", "max_progress", "=", "looper", ".", "max_epochs", "\n", "", "else", ":", "\n", "            ", "progress", "=", "looper", ".", "iter", "\n", "max_progress", "=", "looper", ".", "max_iters", "\n", "\n", "", "if", "self", ".", "min_lr_ratio", "is", "not", "None", ":", "\n", "            ", "target_lr", "=", "base_lr", "*", "self", ".", "min_lr_ratio", "\n", "", "else", ":", "\n", "            ", "target_lr", "=", "self", ".", "min_lr", "\n", "", "return", "annealing_cos", "(", "base_lr", ",", "target_lr", ",", "progress", "/", "max_progress", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CosineRestartLrSchedulerHook.__init__": [[271, 288], ["lr_scheduler.LrSchedulerHook.__init__", "len", "len", "sum", "range", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "\n", "periods", ",", "\n", "restart_weights", "=", "[", "1", "]", ",", "\n", "min_lr", "=", "None", ",", "\n", "min_lr_ratio", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "assert", "(", "min_lr", "is", "None", ")", "^", "(", "min_lr_ratio", "is", "None", ")", "\n", "self", ".", "periods", "=", "periods", "\n", "self", ".", "min_lr", "=", "min_lr", "\n", "self", ".", "min_lr_ratio", "=", "min_lr_ratio", "\n", "self", ".", "restart_weights", "=", "restart_weights", "\n", "assert", "(", "len", "(", "self", ".", "periods", ")", "==", "len", "(", "self", ".", "restart_weights", ")", "\n", ")", ",", "'periods and restart_weights should have the same length.'", "\n", "super", "(", "CosineRestartLrSchedulerHook", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "self", ".", "cumulative_periods", "=", "[", "\n", "sum", "(", "self", ".", "periods", "[", "0", ":", "i", "+", "1", "]", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "periods", ")", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CosineRestartLrSchedulerHook.get_lr": [[290, 308], ["lr_scheduler.get_position_from_periods", "min", "lr_scheduler.annealing_cos"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.get_position_from_periods", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.annealing_cos"], ["", "def", "get_lr", "(", "self", ",", "looper", ",", "base_lr", ")", ":", "\n", "        ", "if", "self", ".", "by_epoch", ":", "\n", "            ", "progress", "=", "looper", ".", "epoch", "\n", "", "else", ":", "\n", "            ", "progress", "=", "looper", ".", "iter", "\n", "\n", "", "if", "self", ".", "min_lr_ratio", "is", "not", "None", ":", "\n", "            ", "target_lr", "=", "base_lr", "*", "self", ".", "min_lr_ratio", "\n", "", "else", ":", "\n", "            ", "target_lr", "=", "self", ".", "min_lr", "\n", "\n", "", "idx", "=", "get_position_from_periods", "(", "progress", ",", "self", ".", "cumulative_periods", ")", "\n", "current_weight", "=", "self", ".", "restart_weights", "[", "idx", "]", "\n", "nearest_restart", "=", "0", "if", "idx", "==", "0", "else", "self", ".", "cumulative_periods", "[", "idx", "-", "1", "]", "\n", "current_periods", "=", "self", ".", "periods", "[", "idx", "]", "\n", "\n", "alpha", "=", "min", "(", "(", "progress", "-", "nearest_restart", ")", "/", "current_periods", ",", "1", ")", "\n", "return", "annealing_cos", "(", "base_lr", ",", "target_lr", ",", "alpha", ",", "current_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CyclicLrSchedulerHook.__init__": [[349, 377], ["isinstance", "lr_scheduler.LrSchedulerHook.__init__", "isinstance", "len", "ValueError", "len", "type"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "\n", "by_epoch", "=", "False", ",", "\n", "target_ratio", "=", "(", "10", ",", "1e-4", ")", ",", "\n", "cyclic_times", "=", "1", ",", "\n", "step_ratio_up", "=", "0.4", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "isinstance", "(", "target_ratio", ",", "float", ")", ":", "\n", "            ", "target_ratio", "=", "(", "target_ratio", ",", "target_ratio", "/", "1e5", ")", "\n", "", "elif", "isinstance", "(", "target_ratio", ",", "tuple", ")", ":", "\n", "            ", "target_ratio", "=", "(", "target_ratio", "[", "0", "]", ",", "target_ratio", "[", "0", "]", "/", "1e5", ")", "if", "len", "(", "target_ratio", ")", "==", "1", "else", "target_ratio", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'target_ratio should be either float '", "\n", "f'or tuple, got {type(target_ratio)}'", ")", "\n", "\n", "", "assert", "len", "(", "target_ratio", ")", "==", "2", ",", "'\"target_ratio\" must be list or tuple of two floats'", "\n", "assert", "0", "<=", "step_ratio_up", "<", "1.0", ",", "'\"step_ratio_up\" must be in range [0,1)'", "\n", "\n", "self", ".", "target_ratio", "=", "target_ratio", "\n", "self", ".", "cyclic_times", "=", "cyclic_times", "\n", "self", ".", "step_ratio_up", "=", "step_ratio_up", "\n", "self", ".", "lr_phases", "=", "[", "]", "# init lr_phases", "\n", "\n", "assert", "not", "by_epoch", ",", "'currently only support \"by_epoch\" = False'", "\n", "super", "(", "CyclicLrSchedulerHook", ",", "self", ")", ".", "__init__", "(", "by_epoch", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CyclicLrSchedulerHook.before_run": [[378, 389], ["lr_scheduler.LrSchedulerHook.before_run", "int", "lr_scheduler.CyclicLrSchedulerHook.lr_phases.append", "lr_scheduler.CyclicLrSchedulerHook.lr_phases.append"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CyclicLrSchedulerHook.before_run"], ["", "def", "before_run", "(", "self", ",", "looper", ")", ":", "\n", "        ", "super", "(", "CyclicLrSchedulerHook", ",", "self", ")", ".", "before_run", "(", "looper", ")", "\n", "# initiate lr_phases", "\n", "# total lr_phases are separated as up and down", "\n", "max_iter_per_phase", "=", "looper", ".", "max_iters", "//", "self", ".", "cyclic_times", "\n", "iter_up_phase", "=", "int", "(", "self", ".", "step_ratio_up", "*", "max_iter_per_phase", ")", "\n", "self", ".", "lr_phases", ".", "append", "(", "\n", "[", "0", ",", "iter_up_phase", ",", "max_iter_per_phase", ",", "1", ",", "self", ".", "target_ratio", "[", "0", "]", "]", ")", "\n", "self", ".", "lr_phases", ".", "append", "(", "[", "\n", "iter_up_phase", ",", "max_iter_per_phase", ",", "max_iter_per_phase", ",", "\n", "self", ".", "target_ratio", "[", "0", "]", ",", "self", ".", "target_ratio", "[", "1", "]", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.CyclicLrSchedulerHook.get_lr": [[391, 401], ["lr_scheduler.annealing_cos"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.annealing_cos"], ["", "def", "get_lr", "(", "self", ",", "looper", ",", "base_lr", ")", ":", "\n", "        ", "curr_iter", "=", "looper", ".", "iter", "\n", "for", "(", "start_iter", ",", "end_iter", ",", "max_iter_per_phase", ",", "start_ratio", ",", "\n", "end_ratio", ")", "in", "self", ".", "lr_phases", ":", "\n", "            ", "curr_iter", "%=", "max_iter_per_phase", "\n", "if", "start_iter", "<=", "curr_iter", "<", "end_iter", ":", "\n", "                ", "progress", "=", "curr_iter", "-", "start_iter", "\n", "return", "annealing_cos", "(", "base_lr", "*", "start_ratio", ",", "\n", "base_lr", "*", "end_ratio", ",", "\n", "progress", "/", "(", "end_iter", "-", "start_iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.get_position_from_periods": [[310, 328], ["enumerate", "ValueError"], "function", ["None"], ["", "", "def", "get_position_from_periods", "(", "iteration", ",", "cumulative_periods", ")", ":", "\n", "    ", "\"\"\"Get the position from a period list.\n\n    It will return the index of the right-closest number in the period list.\n    For example, the cumulative_periods = [100, 200, 300, 400],\n    if iteration == 50, return 0;\n    if iteration == 210, return 2;\n    if iteration == 300, return 3.\n    Args:\n        iteration (int): Current iteration.\n        cumulative_periods (list[int]): Cumulative period list.\n    Returns:\n        int: The position of the right-closest number in the period list.\n    \"\"\"", "\n", "for", "i", ",", "period", "in", "enumerate", "(", "cumulative_periods", ")", ":", "\n", "        ", "if", "iteration", "<", "period", ":", "\n", "            ", "return", "i", "\n", "", "", "raise", "ValueError", "(", "f'Current iteration {iteration} exceeds '", "\n", "f'cumulative_periods {cumulative_periods}'", ")", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.lr_scheduler.annealing_cos": [[403, 418], ["math.cos"], "function", ["None"], ["", "", "", "", "def", "annealing_cos", "(", "start", ",", "end", ",", "factor", ",", "weight", "=", "1", ")", ":", "\n", "    ", "\"\"\"Calculate annealing cos learning rate.\n\n    Cosine anneal from `weight * start + (1 - weight) * end` to `end` as\n    percentage goes from 0.0 to 1.0.\n    Args:\n        start (float): The starting learning rate of the cosine annealing.\n        end (float): The ending learing rate of the cosine annealing.\n        factor (float): The coefficient of `pi` when calculating the current\n            percentage. Range from 0.0 to 1.0.\n        weight (float, optional): The combination factor of `start` and `end`\n            when calculating the actual starting learning rate. Default to 1.\n    \"\"\"", "\n", "cos_out", "=", "cos", "(", "pi", "*", "factor", ")", "+", "1", "\n", "return", "end", "+", "0.5", "*", "weight", "*", "(", "start", "-", "end", ")", "*", "cos_out", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.optimizer.OptimizerHook.__init__": [[10, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "grad_clip", "=", "None", ")", ":", "\n", "        ", "self", ".", "grad_clip", "=", "grad_clip", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.optimizer.OptimizerHook.clip_grads": [[13, 18], ["list", "filter", "len", "torch.nn.utils.clip_grad.clip_grad_norm_"], "methods", ["None"], ["", "def", "clip_grads", "(", "self", ",", "params", ")", ":", "\n", "        ", "params", "=", "list", "(", "\n", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", "and", "p", ".", "grad", "is", "not", "None", ",", "params", ")", ")", "\n", "if", "len", "(", "params", ")", ">", "0", ":", "\n", "            ", "return", "clip_grad", ".", "clip_grad_norm_", "(", "params", ",", "**", "self", ".", "grad_clip", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.optimizer.OptimizerHook.after_train_iter": [[19, 29], ["optimizer.zero_grad", "results[].backward", "optimizer.step", "optimizer.OptimizerHook.clip_grads", "model.parameters"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.sigmoid_focal_loss.sigmoid_focal_loss.SigmoidFocalLossFunction.backward", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.optimizer.OptimizerHook.clip_grads"], ["", "", "def", "after_train_iter", "(", "self", ",", "looper", ")", ":", "\n", "        ", "optimizer", "=", "looper", ".", "train_engine", ".", "optimizer", "\n", "results", "=", "looper", ".", "cur_train_results", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "results", "[", "'loss'", "]", ".", "backward", "(", ")", "\n", "if", "self", ".", "grad_clip", "is", "not", "None", ":", "\n", "            ", "model", "=", "looper", ".", "train_engine", ".", "model", "\n", "# grad_norm = self.clip_grads(model.parameters())", "\n", "self", ".", "clip_grads", "(", "model", ".", "parameters", "(", ")", ")", "\n", "", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.optimizer.OptimizerHook.modes": [[30, 33], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "modes", "(", "self", ")", ":", "\n", "        ", "return", "[", "'train'", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.sampler_seed.DistSamplerSeedHook.before_train_epoch": [[15, 24], ["hasattr", "looper.train_dataloader.sampler.set_epoch", "hasattr", "looper.train_dataloader.batch_sampler.sampler.set_epoch"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.DistributedGroupSampler.set_epoch", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.DistributedGroupSampler.set_epoch"], ["def", "before_train_epoch", "(", "self", ",", "looper", ")", ":", "\n", "        ", "if", "hasattr", "(", "looper", ".", "train_dataloader", ".", "sampler", ",", "'set_epoch'", ")", ":", "\n", "# in case the data loader uses `SequentialSampler` in Pytorch", "\n", "            ", "looper", ".", "train_dataloader", ".", "sampler", ".", "set_epoch", "(", "looper", ".", "epoch", ")", "\n", "", "elif", "hasattr", "(", "looper", ".", "train_dataloader", ".", "batch_sampler", ".", "sampler", ",", "\n", "'set_epoch'", ")", ":", "\n", "# batch sampler in pytorch warps the sampler as its attributes.", "\n", "            ", "looper", ".", "train_dataloader", ".", "batch_sampler", ".", "sampler", ".", "set_epoch", "(", "\n", "looper", ".", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.sampler_seed.DistSamplerSeedHook.modes": [[25, 28], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "modes", "(", "self", ")", ":", "\n", "        ", "return", "[", "'train'", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.tools.trainval.parse_args": [[12, 25], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.thumos14.txt2json.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Train a detector'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'train config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'--workdir'", ",", "help", "=", "'the dir to save logs and models'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--launcher'", ",", "\n", "choices", "=", "[", "'none'", ",", "'pytorch'", "]", ",", "\n", "default", "=", "'none'", ",", "\n", "help", "=", "'job launcher'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "# TODO", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.tools.trainval.main": [[27, 60], ["trainval.parse_args", "vedacore.misc.Config.fromfile", "Config.fromfile.get", "Config.fromfile.get", "vedacore.misc.set_random_seed", "vedacore.misc.mkdir_or_exist", "shutil.copy", "time.strftime", "os.join", "vedatad.misc.get_root_logger", "vedatad.assembler.trainval", "vedacore.parallel.init_dist", "os.abspath", "time.localtime", "Config.fromfile.get", "os.join", "os.splitext", "os.basename"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.thumos14.txt2json.parse_args", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.fromfile", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.set_random_seed", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.mkdir_or_exist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.logger.get_root_logger", "home.repos.pwc.inspect_result.Media-Smart_vedatad.assembler.trainval.trainval", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.init_dist", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "\n", "if", "args", ".", "launcher", "==", "'none'", ":", "\n", "        ", "distributed", "=", "False", "\n", "", "else", ":", "\n", "        ", "distributed", "=", "True", "\n", "init_dist", "(", "args", ".", "launcher", ",", "**", "cfg", ".", "dist_params", ")", "\n", "\n", "# workdir is determined in this priority: CLI > segment in file > filename", "\n", "", "if", "args", ".", "workdir", "is", "not", "None", ":", "\n", "# update configs according to CLI args if args.work_dir is not None", "\n", "        ", "cfg", ".", "workdir", "=", "args", ".", "workdir", "\n", "", "elif", "cfg", ".", "get", "(", "'workdir'", ",", "None", ")", "is", "None", ":", "\n", "# use config filename as default work_dir if cfg.work_dir is None", "\n", "        ", "cfg", ".", "workdir", "=", "osp", ".", "join", "(", "'./workdir'", ",", "\n", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "args", ".", "config", ")", ")", "[", "0", "]", ")", "\n", "\n", "", "seed", "=", "cfg", ".", "get", "(", "'seed'", ",", "None", ")", "\n", "deterministic", "=", "cfg", ".", "get", "(", "'deterministic'", ",", "False", ")", "\n", "set_random_seed", "(", "seed", ",", "deterministic", ")", "\n", "\n", "# create work_dir", "\n", "mkdir_or_exist", "(", "osp", ".", "abspath", "(", "cfg", ".", "workdir", ")", ")", "\n", "shutil", ".", "copy", "(", "args", ".", "config", ",", "cfg", ".", "workdir", ")", "\n", "# init the logger before other steps", "\n", "timestamp", "=", "time", ".", "strftime", "(", "'%Y%m%d_%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "cfg", ".", "workdir", ",", "f'{timestamp}.log'", ")", "\n", "logger", "=", "get_root_logger", "(", "log_file", "=", "log_file", ",", "log_level", "=", "cfg", ".", "log_level", ")", "\n", "\n", "trainval", "(", "cfg", ",", "distributed", ",", "logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.tools.test.parse_args": [[12, 26], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.thumos14.txt2json.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Test a detector'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'test config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "help", "=", "'output result file in pickle format'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--eval-options'", ",", "\n", "nargs", "=", "'+'", ",", "\n", "action", "=", "DictAction", ",", "\n", "help", "=", "'custom options for evaluation, the key-value pair in xxx=yyy '", "\n", "'format will be kwargs for dataset.evaluate() function'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.tools.test.prepare": [[28, 41], ["vedatad.engines.build_engine", "vedacore.misc.load_weights", "torch.cuda.current_device", "vedacore.parallel.MMDataParallel", "vedatad.datasets.build_dataset", "vedatad.datasets.build_dataloader", "vedacore.parallel.MMDataParallel.to", "dict", "torch.cuda.current_device"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.builder.build_engine", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_weights", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataloader", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to"], ["", "def", "prepare", "(", "cfg", ",", "checkpoint", ")", ":", "\n", "\n", "    ", "engine", "=", "build_engine", "(", "cfg", ".", "val_engine", ")", "\n", "load_weights", "(", "engine", ".", "model", ",", "checkpoint", ",", "map_location", "=", "'cpu'", ")", "\n", "\n", "device", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", "\n", "engine", "=", "MMDataParallel", "(", "\n", "engine", ".", "to", "(", "device", ")", ",", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ")", "\n", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "val", ",", "dict", "(", "test_mode", "=", "True", ")", ")", "\n", "dataloader", "=", "build_dataloader", "(", "dataset", ",", "1", ",", "1", ",", "dist", "=", "False", ",", "shuffle", "=", "False", ")", "\n", "\n", "return", "engine", ",", "dataloader", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.tools.test.test": [[43, 58], ["engine.eval", "vedacore.misc.ProgressBar", "enumerate", "len", "results.append", "len", "range", "torch.no_grad", "vedacore.misc.ProgressBar.update", "engine"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update"], ["", "def", "test", "(", "engine", ",", "data_loader", ")", ":", "\n", "    ", "engine", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "prog_bar", "=", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "engine", "(", "data", ")", "[", "0", "]", "\n", "\n", "", "results", ".", "append", "(", "result", ")", "\n", "batch_size", "=", "len", "(", "data", "[", "'video_metas'", "]", "[", "0", "]", ".", "data", ")", "\n", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "prog_bar", ".", "update", "(", ")", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.tools.test.main": [[60, 78], ["test.parse_args", "vedacore.misc.Config.fromfile", "test.prepare", "test.test", "data_loader.dataset.evaluate", "ValueError", "print", "vedacore.fileio.dump", "dict", "parse_args.out.endswith"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.thumos14.txt2json.parse_args", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.fromfile", "home.repos.pwc.inspect_result.Media-Smart_vedatad.tools.test.prepare", "home.repos.pwc.inspect_result.Media-Smart_vedatad.tools.test.test", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.evaluate", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump"], ["", "def", "main", "(", ")", ":", "\n", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "\n", "if", "args", ".", "out", "is", "not", "None", "and", "not", "args", ".", "out", ".", "endswith", "(", "(", "'.pkl'", ",", "'.pickle'", ")", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'The output file must be a pkl file.'", ")", "\n", "\n", "", "engine", ",", "data_loader", "=", "prepare", "(", "cfg", ",", "args", ".", "checkpoint", ")", "\n", "\n", "results", "=", "test", "(", "engine", ",", "data_loader", ")", "\n", "\n", "if", "args", ".", "out", ":", "\n", "        ", "print", "(", "f'\\nwriting results to {args.out}'", ")", "\n", "dump", "(", "results", ",", "args", ".", "out", ")", "\n", "\n", "", "kwargs", "=", "dict", "(", ")", "if", "args", ".", "eval_options", "is", "None", "else", "args", ".", "eval_options", "\n", "data_loader", ".", "dataset", ".", "evaluate", "(", "results", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.thumos14.txt2json.parse_args": [[10, 19], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.thumos14.txt2json.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Generate annotation'", ")", "\n", "parser", ".", "add_argument", "(", "'--anno_root'", ",", "type", "=", "str", ",", "help", "=", "'annotations root dir'", ")", "\n", "parser", ".", "add_argument", "(", "'--video_root'", ",", "type", "=", "str", ",", "help", "=", "'videos root dir'", ")", "\n", "parser", ".", "add_argument", "(", "'--mode'", ",", "choices", "=", "[", "'val'", ",", "'test'", "]", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.thumos14.txt2json.main": [[21, 61], ["txt2json.parse_args", "os.path.join", "os.path.join", "collections.OrderedDict", "collections.OrderedDict.items", "os.path.join", "collections.OrderedDict", "glob.glob", "glob.glob", "os.path.join", "cv2.VideoCapture", "float", "float", "int", "int", "cv2.VideoCapture.release", "open", "json.dump", "os.path.join", "os.path.join", "[].split", "open", "f.readlines", "cv2.VideoCapture.get", "cv2.VideoCapture.get", "cv2.VideoCapture.get", "cv2.VideoCapture.get", "line.strip().split", "[].append", "collections.OrderedDict", "dict", "os.path.split", "line.strip", "float", "float"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.thumos14.txt2json.parse_args", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "anno_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "anno_root", ",", "args", ".", "mode", ")", "\n", "video_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "video_root", ",", "args", ".", "mode", ")", "\n", "\n", "database", "=", "OrderedDict", "(", ")", "\n", "if", "args", ".", "mode", "==", "'test'", ":", "\n", "        ", "txt_files", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "anno_dir", ",", "'[B-Z]*.txt'", ")", ")", "\n", "", "else", ":", "\n", "        ", "txt_files", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "anno_dir", ",", "'[A-Z]*.txt'", ")", ")", "\n", "", "for", "txt_file", "in", "txt_files", ":", "\n", "        ", "class_name", "=", "os", ".", "path", ".", "split", "(", "txt_file", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "with", "open", "(", "txt_file", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "video_name", ",", "start", ",", "end", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "if", "video_name", "not", "in", "database", ":", "\n", "                    ", "database", "[", "video_name", "]", "=", "OrderedDict", "(", "annotations", "=", "[", "]", ")", "\n", "", "database", "[", "video_name", "]", "[", "'annotations'", "]", ".", "append", "(", "\n", "dict", "(", "segment", "=", "[", "float", "(", "start", ")", ",", "float", "(", "end", ")", "]", ",", "label", "=", "class_name", ")", ")", "\n", "\n", "", "", "", "for", "video_name", ",", "video_info", "in", "database", ".", "items", "(", ")", ":", "\n", "        ", "video_file", "=", "os", ".", "path", ".", "join", "(", "video_dir", ",", "f'{video_name}.mp4'", ")", "\n", "cap", "=", "cv2", ".", "VideoCapture", "(", "video_file", ")", "\n", "fps", "=", "float", "(", "cap", ".", "get", "(", "cv2", ".", "CAP_PROP_FPS", ")", ")", "\n", "frame_count", "=", "float", "(", "cap", ".", "get", "(", "cv2", ".", "CAP_PROP_FRAME_COUNT", ")", ")", "\n", "duration", "=", "frame_count", "/", "fps", "\n", "width", "=", "int", "(", "cap", ".", "get", "(", "cv2", ".", "CAP_PROP_FRAME_WIDTH", ")", ")", "\n", "height", "=", "int", "(", "cap", ".", "get", "(", "cv2", ".", "CAP_PROP_FRAME_HEIGHT", ")", ")", "\n", "\n", "video_info", "[", "'duration'", "]", "=", "duration", "\n", "video_info", "[", "'resolution'", "]", "=", "f'{width}x{height}'", "\n", "video_info", "[", "'subset'", "]", "=", "args", ".", "mode", "\n", "\n", "cap", ".", "release", "(", ")", "\n", "\n", "", "out_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "anno_root", ",", "f'{args.mode}.json'", ")", "\n", "out", "=", "OrderedDict", "(", "database", "=", "database", ",", "taxonomy", "=", "[", "]", ",", "version", "=", "'THUMOS14'", ")", "\n", "with", "open", "(", "out_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "out", ",", "f", ",", "indent", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.__init__": [[53, 87], ["custom.CustomDataset.get_classes", "custom.CustomDataset.load_annotations", "pipelines.Compose", "custom.CustomDataset.get_subset_by_classes", "custom.CustomDataset.load_proposals", "custom.CustomDataset._filter_videos", "custom.CustomDataset._set_group_flag"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.get_classes", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.thumos14.Thumos14Dataset.load_annotations", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.get_subset_by_classes", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.load_proposals", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset._filter_videos", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset._set_group_flag"], ["def", "__init__", "(", "self", ",", "\n", "ann_file", ",", "\n", "pipeline", ",", "\n", "classes", "=", "None", ",", "\n", "video_prefix", "=", "''", ",", "\n", "proposal_file", "=", "None", ",", "\n", "test_mode", "=", "False", ")", ":", "\n", "        ", "self", ".", "ann_file", "=", "ann_file", "\n", "self", ".", "video_prefix", "=", "video_prefix", "\n", "self", ".", "proposal_file", "=", "proposal_file", "\n", "self", ".", "test_mode", "=", "test_mode", "\n", "self", ".", "CLASSES", "=", "self", ".", "get_classes", "(", "classes", ")", "\n", "\n", "# load annotations (and proposals)", "\n", "self", ".", "data_infos", "=", "self", ".", "load_annotations", "(", "self", ".", "ann_file", ")", "\n", "# filter data infos if classes are customized", "\n", "if", "self", ".", "custom_classes", ":", "\n", "            ", "self", ".", "data_infos", "=", "self", ".", "get_subset_by_classes", "(", ")", "\n", "\n", "", "if", "self", ".", "proposal_file", "is", "not", "None", ":", "\n", "            ", "self", ".", "proposals", "=", "self", ".", "load_proposals", "(", "self", ".", "proposal_file", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "proposals", "=", "None", "\n", "# filter videos too small", "\n", "", "if", "not", "test_mode", ":", "\n", "            ", "valid_inds", "=", "self", ".", "_filter_videos", "(", ")", "\n", "self", ".", "data_infos", "=", "[", "self", ".", "data_infos", "[", "i", "]", "for", "i", "in", "valid_inds", "]", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "                ", "self", ".", "proposals", "=", "[", "self", ".", "proposals", "[", "i", "]", "for", "i", "in", "valid_inds", "]", "\n", "# set group flag for the sampler", "\n", "", "", "if", "not", "self", ".", "test_mode", ":", "\n", "            ", "self", ".", "_set_group_flag", "(", ")", "\n", "# processing pipeline", "\n", "", "self", ".", "pipeline", "=", "Compose", "(", "pipeline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.__len__": [[88, 91], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Total number of samples of data.\"\"\"", "\n", "return", "len", "(", "self", ".", "data_infos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.load_annotations": [[92, 95], ["vedacore.load"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load"], ["", "def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "\"\"\"Load annotation from annotation file.\"\"\"", "\n", "return", "fileio", ".", "load", "(", "ann_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.load_proposals": [[96, 99], ["vedacore.load"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load"], ["", "def", "load_proposals", "(", "self", ",", "proposal_file", ")", ":", "\n", "        ", "\"\"\"Load proposal from proposal file.\"\"\"", "\n", "return", "fileio", ".", "load", "(", "proposal_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.get_ann_info": [[100, 111], ["None"], "methods", ["None"], ["", "def", "get_ann_info", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get annotation by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Annotation info of specified index.\n        \"\"\"", "\n", "\n", "return", "self", ".", "data_infos", "[", "idx", "]", "[", "'ann'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.get_cat_ids": [[112, 123], ["[].astype().tolist", "[].astype"], "methods", ["None"], ["", "def", "get_cat_ids", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get category ids by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            list[int]: All categories in the image of specified index.\n        \"\"\"", "\n", "\n", "return", "self", ".", "data_infos", "[", "idx", "]", "[", "'ann'", "]", "[", "'labels'", "]", ".", "astype", "(", "np", ".", "int", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.pre_pipeline": [[124, 129], ["None"], "methods", ["None"], ["", "def", "pre_pipeline", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Prepare results dict for pipeline.\"\"\"", "\n", "results", "[", "'video_prefix'", "]", "=", "self", ".", "video_prefix", "\n", "results", "[", "'proposal_file'", "]", "=", "self", ".", "proposal_file", "\n", "results", "[", "'segment_fields'", "]", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset._filter_videos": [[130, 137], ["enumerate", "min", "valid_inds.append"], "methods", ["None"], ["", "def", "_filter_videos", "(", "self", ",", "min_size", "=", "32", ")", ":", "\n", "        ", "\"\"\"Filter images too small.\"\"\"", "\n", "valid_inds", "=", "[", "]", "\n", "for", "i", ",", "video_info", "in", "enumerate", "(", "self", ".", "data_infos", ")", ":", "\n", "            ", "if", "min", "(", "video_info", "[", "'width'", "]", ",", "video_info", "[", "'height'", "]", ")", ">=", "min_size", ":", "\n", "                ", "valid_inds", ".", "append", "(", "i", ")", "\n", "", "", "return", "valid_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset._set_group_flag": [[138, 149], ["numpy.zeros", "range", "len", "len"], "methods", ["None"], ["", "def", "_set_group_flag", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set flag according to image aspect ratio.\n\n        Images with aspect ratio greater than 1 will be set as group 1,\n        otherwise group 0.\n        \"\"\"", "\n", "self", ".", "flag", "=", "np", ".", "zeros", "(", "len", "(", "self", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "video_info", "=", "self", ".", "data_infos", "[", "i", "]", "\n", "if", "video_info", "[", "'width'", "]", "/", "video_info", "[", "'height'", "]", ">", "1", ":", "\n", "                ", "self", ".", "flag", "[", "i", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset._rand_another": [[150, 154], ["numpy.random.choice", "numpy.where"], "methods", ["None"], ["", "", "", "def", "_rand_another", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get another random index from the same group as the given index.\"\"\"", "\n", "pool", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "self", ".", "flag", "[", "idx", "]", ")", "[", "0", "]", "\n", "return", "np", ".", "random", ".", "choice", "(", "pool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.__getitem__": [[155, 177], ["custom.CustomDataset.prepare_test_video", "custom.CustomDataset.prepare_train_video", "custom.CustomDataset._rand_another"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.prepare_test_video", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.prepare_train_video", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset._rand_another"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get training/test data after pipeline.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Training/test data (with annotation if `test_mode` is set\n                True).\n        \"\"\"", "\n", "\n", "if", "self", ".", "test_mode", ":", "\n", "            ", "data", "=", "self", ".", "prepare_test_video", "(", "idx", ")", "\n", "return", "data", "\n", "\n", "", "while", "True", ":", "\n", "            ", "data", "=", "self", ".", "prepare_train_video", "(", "idx", ")", "\n", "if", "data", "is", "None", ":", "\n", "                ", "idx", "=", "self", ".", "_rand_another", "(", "idx", ")", "\n", "continue", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.prepare_train_video": [[178, 199], ["custom.CustomDataset.get_ann_info", "dict", "custom.CustomDataset.pre_pipeline", "custom.CustomDataset.pipeline", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.get_ann_info", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.pre_pipeline"], ["", "", "def", "prepare_train_video", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get training data and annotations after pipeline.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Training data and annotation after pipeline with new keys\n                introduced by pipeline.\n        \"\"\"", "\n", "\n", "video_info", "=", "self", ".", "data_infos", "[", "idx", "]", "\n", "ann_info", "=", "self", ".", "get_ann_info", "(", "idx", ")", "\n", "if", "len", "(", "ann_info", "[", "'segments'", "]", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "", "results", "=", "dict", "(", "video_info", "=", "video_info", ",", "ann_info", "=", "ann_info", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "results", "[", "'proposals'", "]", "=", "self", ".", "proposals", "[", "idx", "]", "\n", "", "self", ".", "pre_pipeline", "(", "results", ")", "\n", "return", "self", ".", "pipeline", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.prepare_test_video": [[200, 217], ["dict", "custom.CustomDataset.pre_pipeline", "custom.CustomDataset.pipeline"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.pre_pipeline"], ["", "def", "prepare_test_video", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get testing data after pipeline.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Testing data after pipeline with new keys intorduced by\n            piepline.\n        \"\"\"", "\n", "\n", "video_info", "=", "self", ".", "data_infos", "[", "idx", "]", "\n", "results", "=", "dict", "(", "video_info", "=", "video_info", ")", "\n", "if", "self", ".", "proposals", "is", "not", "None", ":", "\n", "            ", "results", "[", "'proposals'", "]", "=", "self", ".", "proposals", "[", "idx", "]", "\n", "", "self", ".", "pre_pipeline", "(", "results", ")", "\n", "return", "self", ".", "pipeline", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.get_classes": [[218, 243], ["isinstance", "vedacore.list_from_file", "isinstance", "ValueError", "type"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.parse.list_from_file"], ["", "@", "classmethod", "\n", "def", "get_classes", "(", "cls", ",", "classes", "=", "None", ")", ":", "\n", "        ", "\"\"\"Get class names of current dataset.\n\n        Args:\n            classes (Sequence[str] | str | None): If classes is None, use\n                default CLASSES defined by builtin dataset. If classes is a\n                string, take it as a file name. The file contains the name of\n                classes where each line contains one class name. If classes is\n                a tuple or list, override the CLASSES defined by the dataset.\n        \"\"\"", "\n", "if", "classes", "is", "None", ":", "\n", "            ", "cls", ".", "custom_classes", "=", "False", "\n", "return", "cls", ".", "CLASSES", "\n", "\n", "", "cls", ".", "custom_classes", "=", "True", "\n", "if", "isinstance", "(", "classes", ",", "str", ")", ":", "\n", "# take it as a file path", "\n", "            ", "class_names", "=", "fileio", ".", "list_from_file", "(", "classes", ")", "\n", "", "elif", "isinstance", "(", "classes", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "            ", "class_names", "=", "classes", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Unsupported type {type(classes)} of classes.'", ")", "\n", "\n", "", "return", "class_names", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.get_subset_by_classes": [[244, 246], ["None"], "methods", ["None"], ["", "def", "get_subset_by_classes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset._det2json": [[247, 261], ["dict", "range", "len", "enumerate", "collections.defaultdict", "dict", "segment.tolist", "dict", "[].append"], "methods", ["None"], ["", "def", "_det2json", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Convert detection results to ActivityNet json style.\"\"\"", "\n", "json_results", "=", "dict", "(", "\n", "version", "=", "''", ",", "results", "=", "defaultdict", "(", "list", ")", ",", "external_data", "=", "dict", "(", ")", ")", "\n", "for", "idx", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "video_name", "=", "self", ".", "data_infos", "[", "idx", "]", "[", "'video_name'", "]", "\n", "for", "label", ",", "segments", "in", "enumerate", "(", "results", "[", "idx", "]", ")", ":", "\n", "                ", "for", "segment", "in", "segments", ":", "\n", "                    ", "start", ",", "end", ",", "score", "=", "segment", ".", "tolist", "(", ")", "\n", "label_name", "=", "self", ".", "CLASSES", "[", "label", "]", "\n", "res", "=", "dict", "(", "\n", "segment", "=", "[", "start", ",", "end", "]", ",", "score", "=", "score", ",", "label", "=", "label_name", ")", "\n", "json_results", "[", "'results'", "]", "[", "video_name", "]", ".", "append", "(", "res", ")", "\n", "", "", "", "return", "json_results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.results2json": [[262, 281], ["custom.CustomDataset._det2json", "vedacore.dump"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset._det2json", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.config.Config.dump"], ["", "def", "results2json", "(", "self", ",", "results", ",", "outfile_prefix", ")", ":", "\n", "        ", "\"\"\"Dump the detection results to an ActivityNet style json file.\n\n        Args:\n            results (list[list | tuple | ndarray]): Testing results of the\n                dataset.\n            outfile_prefix (str): The filename prefix of the json files. If the\n                prefix is \"somepath/xxx\", the json file will be named\n                \"somepath/xxx.json\"\n\n        Returns:\n            str: output filename.\n        \"\"\"", "\n", "\n", "json_results", "=", "self", ".", "_det2json", "(", "results", ")", "\n", "result_file", "=", "f'{outfile_prefix}.json'", "\n", "fileio", ".", "dump", "(", "json_results", ",", "result_file", ",", "indent", "=", "4", ")", "\n", "\n", "return", "result_file", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.format_results": [[282, 310], ["isinstance", "custom.CustomDataset.results2json", "len", "len", "len", "len", "tempfile.TemporaryDirectory", "os.join"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.results2json"], ["", "def", "format_results", "(", "self", ",", "results", ",", "jsonfile_prefix", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Format the results to json (standard format for ActivityNet\n        evaluation).\n\n        Args:\n            results (list[tuple | numpy.ndarray]): Testing results of the\n                dataset.\n            jsonfile_prefix (str | None): The prefix of json files. It includes\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\n                If not specified, a temp file will be created. Default: None.\n\n        Returns:\n            tuple: (result_file, tmp_dir), result_file is saved file name,\n                tmp_dir is the temporal directory created \\\n                for saving json files when jsonfile_prefix is not specified.\n        \"\"\"", "\n", "assert", "isinstance", "(", "results", ",", "list", ")", ",", "'results must be a list'", "\n", "assert", "len", "(", "results", ")", "==", "len", "(", "self", ")", ",", "(", "\n", "'The length of results is not equal to the dataset len: {} != {}'", ".", "\n", "format", "(", "len", "(", "results", ")", ",", "len", "(", "self", ")", ")", ")", "\n", "\n", "if", "jsonfile_prefix", "is", "None", ":", "\n", "            ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "jsonfile_prefix", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'results'", ")", "\n", "", "else", ":", "\n", "            ", "tmp_dir", "=", "None", "\n", "", "result_file", "=", "self", ".", "results2json", "(", "results", ",", "jsonfile_prefix", ")", "\n", "return", "result_file", ",", "tmp_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.convert2time": [[311, 323], ["copy.deepcopy", "enumerate", "time_results.append", "res.append"], "methods", ["None"], ["", "def", "convert2time", "(", "self", ",", "results", ")", ":", "\n", "        ", "time_results", "=", "[", "]", "\n", "_results", "=", "deepcopy", "(", "results", ")", "\n", "for", "idx", ",", "video_results", "in", "enumerate", "(", "_results", ")", ":", "\n", "            ", "fps", "=", "self", ".", "data_infos", "[", "idx", "]", "[", "'fps'", "]", "\n", "res", "=", "[", "]", "\n", "for", "class_result", "in", "video_results", ":", "\n", "                ", "class_result", "[", ":", ",", ":", "2", "]", "/=", "fps", "\n", "res", ".", "append", "(", "class_result", ")", "\n", "", "time_results", ".", "append", "(", "res", ")", "\n", "\n", "", "return", "time_results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.evaluate": [[324, 374], ["isinstance", "vedatad.misc.evaluation.eval_map", "custom.CustomDataset.convert2time", "custom.CustomDataset.format_results", "custom.CustomDataset.get_ann_info", "range", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.eval_map", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.convert2time", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.format_results", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.custom.CustomDataset.get_ann_info"], ["", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "mode", "=", "'anet'", ",", "\n", "logger", "=", "None", ",", "\n", "jsonfile_prefix", "=", "None", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "scale_ranges", "=", "None", ",", "\n", "convert2time", "=", "True", ")", ":", "\n", "        ", "\"\"\"Evaluate the dataset.\n\n        Args:\n            results (list): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated.\n            mode (str | None): Mode name, there are minor differences in\n                metrics for different modes, e.g. \"anet\", \"voc07\", \"voc12\" etc.\n                Default: anet.\n            logger (logging.Logger | None | str): Logger used for printing\n                related information during evaluation. Default: None.\n            jsonfile_prefix (str | None): The prefix of json file. It includes\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\n                Default: None.\n            proposal_nums (Sequence[int]): Proposal number used for evaluating\n                recalls, such as recall@100, recall@1000.\n                Default: (100, 300, 1000).\n            iou_thr (float | list[float]): IoU threshold. It must be a float\n                when evaluating mAP, and can be a list when evaluating recall.\n                Default: 0.5.\n            scale_ranges (list[tuple] | None): Scale ranges for evaluating mAP.\n                Default: None.\n            convert2time (bool): Whether convert results to time. Default: True\n        \"\"\"", "\n", "if", "convert2time", ":", "\n", "            ", "results", "=", "self", ".", "convert2time", "(", "results", ")", "\n", "\n", "", "if", "jsonfile_prefix", "is", "not", "None", ":", "\n", "            ", "self", ".", "format_results", "(", "results", ",", "jsonfile_prefix", ")", "\n", "\n", "", "annotations", "=", "[", "self", ".", "get_ann_info", "(", "i", ")", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", "]", "\n", "eval_results", "=", "{", "}", "\n", "assert", "isinstance", "(", "iou_thr", ",", "float", ")", "\n", "mean_ap", ",", "_", "=", "eval_map", "(", "\n", "results", ",", "\n", "annotations", ",", "\n", "scale_ranges", "=", "scale_ranges", ",", "\n", "iou_thr", "=", "iou_thr", ",", "\n", "mode", "=", "mode", ",", "\n", "logger", "=", "logger", ",", "\n", "label_names", "=", "self", ".", "CLASSES", ")", "\n", "eval_results", "[", "'mAP'", "]", "=", "mean_ap", "\n", "return", "eval_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.WorkerInit.__init__": [[127, 134], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.WorkerInit.set_epoch": [[135, 137], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.WorkerInit.__call__": [[138, 143], ["numpy.random.seed", "random.seed"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder._concat_dataset": [[24, 42], ["cfg.get", "cfg.get", "len", "range", "ConcatDataset", "copy.deepcopy", "isinstance", "isinstance", "datasets.append", "builder.build_dataset"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataset"], ["\n", "\n", "def", "build_optimizer_constructor", "(", "cfg", ")", ":", "\n", "    ", "return", "build_from_cfg", "(", "cfg", ",", "registry", ",", "'optimizer_builder'", ")", "\n", "\n", "\n", "", "def", "build_optimizer", "(", "model", ",", "cfg", ")", ":", "\n", "    ", "optimizer_cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "constructor_type", "=", "optimizer_cfg", ".", "pop", "(", "'constructor'", ",", "\n", "'DefaultOptimizerConstructor'", ")", "\n", "paramwise_cfg", "=", "optimizer_cfg", ".", "pop", "(", "'paramwise_cfg'", ",", "None", ")", "\n", "optim_constructor", "=", "build_optimizer_constructor", "(", "\n", "dict", "(", "\n", "typename", "=", "constructor_type", ",", "\n", "optimizer_cfg", "=", "optimizer_cfg", ",", "\n", "paramwise_cfg", "=", "paramwise_cfg", ")", ")", "\n", "optimizer", "=", "optim_constructor", "(", "model", ")", "\n", "return", "optimizer", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataset": [[44, 61], ["isinstance", "ConcatDataset", "RepeatDataset", "builder.build_dataset", "builder.build_dataset", "ClassBalancedDataset", "isinstance", "builder.build_dataset", "cfg.get", "builder._concat_dataset", "vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder._concat_dataset", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataloader": [[63, 123], ["vedacore.parallel.get_dist_info", "torch.utils.data.DataLoader", "builder.WorkerInit", "samplers.DistributedGroupSampler", "samplers.DistributedSampler", "samplers.GroupSampler", "functools.partial"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.get_dist_info"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.thumos14.Thumos14Dataset.__init__": [[23, 25], ["custom.CustomDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Thumos14Dataset", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.thumos14.Thumos14Dataset.load_annotations": [[26, 89], ["vedacore.fileio.load", "data[].items", "dict", "float", "glob.glob", "len", "int", "vedacore.image.imread", "dict", "data_infos.append", "os.join", "round", "numpy.zeros", "numpy.zeros", "numpy.array", "numpy.array", "numpy.zeros", "numpy.array", "min", "min", "numpy.array.append", "numpy.array.astype", "numpy.array.astype", "numpy.array.astype", "max", "max", "numpy.array.append", "numpy.array.append", "thumos14.Thumos14Dataset.CLASSES.index"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.fileio.io.load", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io.imread"], ["", "def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "\"\"\"Load annotation from Thumos14 json ann_file.\n\n        Args:\n            ann_file (str): Path of JSON file.\n\n        Returns:\n            list[dict]: Annotation info from JSON file.\n        \"\"\"", "\n", "\n", "data_infos", "=", "[", "]", "\n", "data", "=", "fileio", ".", "load", "(", "ann_file", ")", "\n", "for", "video_name", ",", "video_info", "in", "data", "[", "'database'", "]", ".", "items", "(", ")", ":", "\n", "            ", "data_info", "=", "dict", "(", ")", "\n", "data_info", "[", "'video_name'", "]", "=", "video_name", "\n", "data_info", "[", "'duration'", "]", "=", "float", "(", "video_info", "[", "'duration'", "]", ")", "\n", "imgfiles", "=", "glob", ".", "glob", "(", "osp", ".", "join", "(", "self", ".", "video_prefix", ",", "video_name", ",", "'*'", ")", ")", "\n", "num_imgs", "=", "len", "(", "imgfiles", ")", "\n", "data_info", "[", "'frames'", "]", "=", "num_imgs", "\n", "data_info", "[", "'fps'", "]", "=", "int", "(", "round", "(", "num_imgs", "/", "video_info", "[", "'duration'", "]", ")", ")", "\n", "img", "=", "imread", "(", "imgfiles", "[", "0", "]", ")", "\n", "data_info", "[", "'height'", "]", ",", "data_info", "[", "'width'", "]", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "\n", "segments", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "segments_ignore", "=", "[", "]", "\n", "for", "ann", "in", "video_info", "[", "'annotations'", "]", ":", "\n", "                ", "label", "=", "ann", "[", "'label'", "]", "\n", "segment", "=", "ann", "[", "'segment'", "]", "\n", "\n", "if", "not", "self", ".", "test_mode", ":", "\n", "                    ", "segment", "[", "0", "]", "=", "min", "(", "video_info", "[", "'duration'", "]", ",", "\n", "max", "(", "0", ",", "segment", "[", "0", "]", ")", ")", "\n", "segment", "[", "1", "]", "=", "min", "(", "video_info", "[", "'duration'", "]", ",", "\n", "max", "(", "0", ",", "segment", "[", "1", "]", ")", ")", "\n", "if", "segment", "[", "0", "]", ">=", "segment", "[", "1", "]", ":", "\n", "                        ", "continue", "\n", "\n", "", "", "if", "label", "==", "'Ambiguous'", ":", "\n", "                    ", "segments_ignore", ".", "append", "(", "segment", ")", "\n", "", "elif", "label", "in", "self", ".", "CLASSES", ":", "\n", "                    ", "segments", ".", "append", "(", "segment", ")", "\n", "labels", ".", "append", "(", "self", ".", "CLASSES", ".", "index", "(", "label", ")", ")", "\n", "", "else", ":", "\n", "                    ", "continue", "\n", "", "", "if", "not", "segments", ":", "\n", "                ", "segments", "=", "np", ".", "zeros", "(", "(", "0", ",", "2", ")", ")", "\n", "labels", "=", "np", ".", "zeros", "(", "(", "0", ",", ")", ")", "\n", "", "else", ":", "\n", "                ", "segments", "=", "np", ".", "array", "(", "segments", ")", "\n", "labels", "=", "np", ".", "array", "(", "labels", ")", "\n", "", "if", "not", "segments_ignore", ":", "\n", "                ", "segments_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", "2", ")", ")", "\n", "", "else", ":", "\n", "                ", "segments_ignore", "=", "np", ".", "array", "(", "segments_ignore", ")", "\n", "", "data_info", "[", "'ann'", "]", "=", "dict", "(", "\n", "segments", "=", "segments", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "labels", "=", "labels", ".", "astype", "(", "np", ".", "int64", ")", ",", "\n", "segments_ignore", "=", "segments_ignore", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "data_infos", ".", "append", "(", "data_info", ")", "\n", "\n", "", "return", "data_infos", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.ConcatDataset.__init__": [[24, 32], ["torch.utils.data.dataset.ConcatDataset.__init__", "hasattr", "range", "numpy.concatenate", "len", "flags.append"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "datasets", ")", ":", "\n", "        ", "super", "(", "ConcatDataset", ",", "self", ")", ".", "__init__", "(", "datasets", ")", "\n", "self", ".", "CLASSES", "=", "datasets", "[", "0", "]", ".", "CLASSES", "\n", "if", "hasattr", "(", "datasets", "[", "0", "]", ",", "'flag'", ")", ":", "\n", "            ", "flags", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "datasets", ")", ")", ":", "\n", "                ", "flags", ".", "append", "(", "datasets", "[", "i", "]", ".", "flag", ")", "\n", "", "self", ".", "flag", "=", "np", ".", "concatenate", "(", "flags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.ConcatDataset.get_cat_ids": [[33, 54], ["bisect.bisect_right", "dataset_wrappers.ConcatDataset.datasets[].get_cat_ids", "len", "ValueError", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.RepeatDataset.get_cat_ids"], ["", "", "def", "get_cat_ids", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get category ids of concatenated dataset by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            list[int]: All categories in the image of specified index.\n        \"\"\"", "\n", "\n", "if", "idx", "<", "0", ":", "\n", "            ", "if", "-", "idx", ">", "len", "(", "self", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "'absolute value of index should not exceed dataset length'", ")", "\n", "", "idx", "=", "len", "(", "self", ")", "+", "idx", "\n", "", "dataset_idx", "=", "bisect", ".", "bisect_right", "(", "self", ".", "cumulative_sizes", ",", "idx", ")", "\n", "if", "dataset_idx", "==", "0", ":", "\n", "            ", "sample_idx", "=", "idx", "\n", "", "else", ":", "\n", "            ", "sample_idx", "=", "idx", "-", "self", ".", "cumulative_sizes", "[", "dataset_idx", "-", "1", "]", "\n", "", "return", "self", ".", "datasets", "[", "dataset_idx", "]", ".", "get_cat_ids", "(", "sample_idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.RepeatDataset.__init__": [[70, 78], ["hasattr", "len", "numpy.tile"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dataset", ",", "times", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "times", "=", "times", "\n", "self", ".", "CLASSES", "=", "dataset", ".", "CLASSES", "\n", "if", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", ":", "\n", "            ", "self", ".", "flag", "=", "np", ".", "tile", "(", "self", ".", "dataset", ".", "flag", ",", "times", ")", "\n", "\n", "", "self", ".", "_ori_len", "=", "len", "(", "self", ".", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.RepeatDataset.__getitem__": [[79, 81], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "dataset", "[", "idx", "%", "self", ".", "_ori_len", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.RepeatDataset.get_cat_ids": [[82, 93], ["dataset_wrappers.RepeatDataset.dataset.get_cat_ids"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.RepeatDataset.get_cat_ids"], ["", "def", "get_cat_ids", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Get category ids of repeat dataset by index.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            list[int]: All categories in the image of specified index.\n        \"\"\"", "\n", "\n", "return", "self", ".", "dataset", ".", "get_cat_ids", "(", "idx", "%", "self", ".", "_ori_len", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.RepeatDataset.__len__": [[94, 97], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Length after repetition.\"\"\"", "\n", "return", "self", ".", "times", "*", "self", ".", "_ori_len", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.ClassBalancedDataset.__init__": [[133, 150], ["dataset_wrappers.ClassBalancedDataset._get_repeat_factors", "enumerate", "hasattr", "numpy.asarray", "repeat_indices.extend", "zip", "flags.extend", "len", "len", "math.ceil", "int", "math.ceil"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.ClassBalancedDataset._get_repeat_factors"], ["def", "__init__", "(", "self", ",", "dataset", ",", "oversample_thr", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "oversample_thr", "=", "oversample_thr", "\n", "self", ".", "CLASSES", "=", "dataset", ".", "CLASSES", "\n", "\n", "repeat_factors", "=", "self", ".", "_get_repeat_factors", "(", "dataset", ",", "oversample_thr", ")", "\n", "repeat_indices", "=", "[", "]", "\n", "for", "dataset_index", ",", "repeat_factor", "in", "enumerate", "(", "repeat_factors", ")", ":", "\n", "            ", "repeat_indices", ".", "extend", "(", "[", "dataset_index", "]", "*", "math", ".", "ceil", "(", "repeat_factor", ")", ")", "\n", "", "self", ".", "repeat_indices", "=", "repeat_indices", "\n", "\n", "flags", "=", "[", "]", "\n", "if", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", ":", "\n", "            ", "for", "flag", ",", "repeat_factor", "in", "zip", "(", "self", ".", "dataset", ".", "flag", ",", "repeat_factors", ")", ":", "\n", "                ", "flags", ".", "extend", "(", "[", "flag", "]", "*", "int", "(", "math", ".", "ceil", "(", "repeat_factor", ")", ")", ")", "\n", "", "assert", "len", "(", "flags", ")", "==", "len", "(", "repeat_indices", ")", "\n", "", "self", ".", "flag", "=", "np", ".", "asarray", "(", "flags", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.ClassBalancedDataset._get_repeat_factors": [[151, 193], ["collections.defaultdict", "len", "range", "collections.defaultdict.items", "range", "set", "max", "set", "max", "repeat_factors.append", "dataset_wrappers.ClassBalancedDataset.dataset.get_cat_ids", "math.sqrt", "collections.defaultdict.items", "dataset_wrappers.ClassBalancedDataset.dataset.get_cat_ids"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.RepeatDataset.get_cat_ids", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.RepeatDataset.get_cat_ids"], ["", "def", "_get_repeat_factors", "(", "self", ",", "dataset", ",", "repeat_thr", ")", ":", "\n", "        ", "\"\"\"Get repeat factor for each images in the dataset.\n\n        Args:\n            dataset (:obj:`CustomDataset`): The dataset\n            repeat_thr (float): The threshold of frequency. If an image\n                contains the categories whose frequency below the threshold,\n                it would be repeated.\n\n        Returns:\n            list[float]: The repeat factors for each images in the dataset.\n        \"\"\"", "\n", "\n", "# 1. For each category c, compute the fraction # of images", "\n", "#   that contain it: f(c)", "\n", "category_freq", "=", "defaultdict", "(", "int", ")", "\n", "num_images", "=", "len", "(", "dataset", ")", "\n", "for", "idx", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "cat_ids", "=", "set", "(", "self", ".", "dataset", ".", "get_cat_ids", "(", "idx", ")", ")", "\n", "for", "cat_id", "in", "cat_ids", ":", "\n", "                ", "category_freq", "[", "cat_id", "]", "+=", "1", "\n", "", "", "for", "k", ",", "v", "in", "category_freq", ".", "items", "(", ")", ":", "\n", "            ", "category_freq", "[", "k", "]", "=", "v", "/", "num_images", "\n", "\n", "# 2. For each category c, compute the category-level repeat factor:", "\n", "#    r(c) = max(1, sqrt(t/f(c)))", "\n", "", "category_repeat", "=", "{", "\n", "cat_id", ":", "max", "(", "1.0", ",", "math", ".", "sqrt", "(", "repeat_thr", "/", "cat_freq", ")", ")", "\n", "for", "cat_id", ",", "cat_freq", "in", "category_freq", ".", "items", "(", ")", "\n", "}", "\n", "\n", "# 3. For each image I, compute the image-level repeat factor:", "\n", "#    r(I) = max_{c in I} r(c)", "\n", "repeat_factors", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "num_images", ")", ":", "\n", "            ", "cat_ids", "=", "set", "(", "self", ".", "dataset", ".", "get_cat_ids", "(", "idx", ")", ")", "\n", "repeat_factor", "=", "max", "(", "\n", "{", "category_repeat", "[", "cat_id", "]", "\n", "for", "cat_id", "in", "cat_ids", "}", ")", "\n", "repeat_factors", ".", "append", "(", "repeat_factor", ")", "\n", "\n", "", "return", "repeat_factors", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.ClassBalancedDataset.__getitem__": [[194, 197], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "ori_index", "=", "self", ".", "repeat_indices", "[", "idx", "]", "\n", "return", "self", ".", "dataset", "[", "ori_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.dataset_wrappers.ClassBalancedDataset.__len__": [[198, 201], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Length after repetition.\"\"\"", "\n", "return", "len", "(", "self", ".", "repeat_indices", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.GroupSampler.__init__": [[15, 25], ["hasattr", "dataset.flag.astype", "numpy.bincount", "enumerate", "int", "numpy.ceil"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "samples_per_gpu", "=", "1", ")", ":", "\n", "        ", "assert", "hasattr", "(", "dataset", ",", "'flag'", ")", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "samples_per_gpu", "=", "samples_per_gpu", "\n", "self", ".", "flag", "=", "dataset", ".", "flag", ".", "astype", "(", "np", ".", "int64", ")", "\n", "self", ".", "group_sizes", "=", "np", ".", "bincount", "(", "self", ".", "flag", ")", "\n", "self", ".", "num_samples", "=", "0", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "self", ".", "num_samples", "+=", "int", "(", "np", ".", "ceil", "(", "\n", "size", "/", "self", ".", "samples_per_gpu", ")", ")", "*", "self", ".", "samples_per_gpu", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.GroupSampler.__iter__": [[26, 49], ["enumerate", "numpy.concatenate", "numpy.concatenate", "indices.astype().tolist.astype().tolist.astype().tolist", "iter", "numpy.random.shuffle", "numpy.concatenate", "indices.astype().tolist.astype().tolist.append", "len", "numpy.where", "len", "len", "numpy.random.permutation", "indices.astype().tolist.astype().tolist.astype", "int", "numpy.random.choice", "range", "numpy.ceil", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.iter"], ["", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "indices", "=", "[", "]", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "if", "size", "==", "0", ":", "\n", "                ", "continue", "\n", "", "indice", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "i", ")", "[", "0", "]", "\n", "assert", "len", "(", "indice", ")", "==", "size", "\n", "np", ".", "random", ".", "shuffle", "(", "indice", ")", "\n", "num_extra", "=", "int", "(", "np", ".", "ceil", "(", "size", "/", "self", ".", "samples_per_gpu", ")", "\n", ")", "*", "self", ".", "samples_per_gpu", "-", "len", "(", "indice", ")", "\n", "indice", "=", "np", ".", "concatenate", "(", "\n", "[", "indice", ",", "np", ".", "random", ".", "choice", "(", "indice", ",", "num_extra", ")", "]", ")", "\n", "indices", ".", "append", "(", "indice", ")", "\n", "", "indices", "=", "np", ".", "concatenate", "(", "indices", ")", "\n", "indices", "=", "[", "\n", "indices", "[", "i", "*", "self", ".", "samples_per_gpu", ":", "(", "i", "+", "1", ")", "*", "self", ".", "samples_per_gpu", "]", "\n", "for", "i", "in", "np", ".", "random", ".", "permutation", "(", "\n", "range", "(", "len", "(", "indices", ")", "//", "self", ".", "samples_per_gpu", ")", ")", "\n", "]", "\n", "indices", "=", "np", ".", "concatenate", "(", "indices", ")", "\n", "indices", "=", "indices", ".", "astype", "(", "np", ".", "int64", ")", ".", "tolist", "(", ")", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.GroupSampler.__len__": [[50, 52], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.DistributedGroupSampler.__init__": [[72, 100], ["vedacore.parallel.get_dist_info", "hasattr", "numpy.bincount", "enumerate", "int", "math.ceil"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.dist_utils.get_dist_info"], ["def", "__init__", "(", "self", ",", "\n", "dataset", ",", "\n", "samples_per_gpu", "=", "1", ",", "\n", "num_replicas", "=", "None", ",", "\n", "rank", "=", "None", ",", "\n", "seed", "=", "0", ")", ":", "\n", "        ", "_rank", ",", "_num_replicas", "=", "get_dist_info", "(", ")", "\n", "if", "num_replicas", "is", "None", ":", "\n", "            ", "num_replicas", "=", "_num_replicas", "\n", "", "if", "rank", "is", "None", ":", "\n", "            ", "rank", "=", "_rank", "\n", "", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "samples_per_gpu", "=", "samples_per_gpu", "\n", "self", ".", "num_replicas", "=", "num_replicas", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "epoch", "=", "0", "\n", "self", ".", "seed", "=", "seed", "if", "seed", "is", "not", "None", "else", "0", "\n", "\n", "assert", "hasattr", "(", "self", ".", "dataset", ",", "'flag'", ")", "\n", "self", ".", "flag", "=", "self", ".", "dataset", ".", "flag", "\n", "self", ".", "group_sizes", "=", "np", ".", "bincount", "(", "self", ".", "flag", ")", "\n", "\n", "self", ".", "num_samples", "=", "0", "\n", "for", "i", ",", "j", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "self", ".", "num_samples", "+=", "int", "(", "\n", "math", ".", "ceil", "(", "self", ".", "group_sizes", "[", "i", "]", "*", "1.0", "/", "self", ".", "samples_per_gpu", "/", "\n", "self", ".", "num_replicas", ")", ")", "*", "self", ".", "samples_per_gpu", "\n", "", "self", ".", "total_size", "=", "self", ".", "num_samples", "*", "self", ".", "num_replicas", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.DistributedGroupSampler.__iter__": [[101, 140], ["torch.Generator", "torch.Generator.manual_seed", "enumerate", "iter", "len", "len", "indice[].tolist", "indice[].tolist.copy", "range", "indice[].tolist.extend", "indices.extend", "list", "range", "numpy.where", "len", "len", "indice[].tolist.extend", "torch.randperm", "int", "len", "list", "math.ceil", "torch.randperm", "int"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "# deterministically shuffle based on epoch", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", "+", "self", ".", "seed", ")", "\n", "\n", "indices", "=", "[", "]", "\n", "for", "i", ",", "size", "in", "enumerate", "(", "self", ".", "group_sizes", ")", ":", "\n", "            ", "if", "size", ">", "0", ":", "\n", "                ", "indice", "=", "np", ".", "where", "(", "self", ".", "flag", "==", "i", ")", "[", "0", "]", "\n", "assert", "len", "(", "indice", ")", "==", "size", "\n", "indice", "=", "indice", "[", "list", "(", "torch", ".", "randperm", "(", "int", "(", "size", ")", ",", "\n", "generator", "=", "g", ")", ")", "]", ".", "tolist", "(", ")", "\n", "extra", "=", "int", "(", "\n", "math", ".", "ceil", "(", "\n", "size", "*", "1.0", "/", "self", ".", "samples_per_gpu", "/", "self", ".", "num_replicas", ")", "\n", ")", "*", "self", ".", "samples_per_gpu", "*", "self", ".", "num_replicas", "-", "len", "(", "indice", ")", "\n", "# pad indice", "\n", "tmp", "=", "indice", ".", "copy", "(", ")", "\n", "for", "_", "in", "range", "(", "extra", "//", "size", ")", ":", "\n", "                    ", "indice", ".", "extend", "(", "tmp", ")", "\n", "", "indice", ".", "extend", "(", "tmp", "[", ":", "extra", "%", "size", "]", ")", "\n", "indices", ".", "extend", "(", "indice", ")", "\n", "\n", "", "", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "\n", "indices", "=", "[", "\n", "indices", "[", "j", "]", "for", "i", "in", "list", "(", "\n", "torch", ".", "randperm", "(", "\n", "len", "(", "indices", ")", "//", "self", ".", "samples_per_gpu", ",", "generator", "=", "g", ")", ")", "\n", "for", "j", "in", "range", "(", "i", "*", "self", ".", "samples_per_gpu", ",", "(", "i", "+", "1", ")", "*", "\n", "self", ".", "samples_per_gpu", ")", "\n", "]", "\n", "\n", "# subsample", "\n", "offset", "=", "self", ".", "num_samples", "*", "self", ".", "rank", "\n", "indices", "=", "indices", "[", "offset", ":", "offset", "+", "self", ".", "num_samples", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.DistributedGroupSampler.__len__": [[141, 143], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.group_sampler.DistributedGroupSampler.set_epoch": [[144, 146], ["None"], "methods", ["None"], ["", "def", "set_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "epoch", "=", "epoch", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.distributed_sampler.DistributedSampler.__init__": [[9, 18], ["torch.utils.data.DistributedSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "dataset", ",", "\n", "num_replicas", "=", "None", ",", "\n", "rank", "=", "None", ",", "\n", "shuffle", "=", "True", ",", "\n", "seed", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "dataset", ",", "num_replicas", "=", "num_replicas", ",", "rank", "=", "rank", ")", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "self", ".", "seed", "=", "seed", "if", "seed", "is", "not", "None", "else", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.distributed_sampler.DistributedSampler.__iter__": [[19, 37], ["iter", "torch.Generator", "torch.Generator.manual_seed", "torch.randperm().tolist", "torch.arange().tolist", "len", "len", "torch.randperm", "torch.arange", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.loopers.base_looper.BaseLooper.iter"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "# deterministically shuffle based on epoch", "\n", "        ", "if", "self", ".", "shuffle", ":", "\n", "            ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", "+", "self", ".", "seed", ")", "\n", "indices", "=", "torch", ".", "randperm", "(", "len", "(", "self", ".", "dataset", ")", ",", "generator", "=", "g", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "            ", "indices", "=", "torch", ".", "arange", "(", "len", "(", "self", ".", "dataset", ")", ")", ".", "tolist", "(", ")", "\n", "\n", "# add extra samples to make it evenly divisible", "\n", "", "indices", "+=", "indices", "[", ":", "(", "self", ".", "total_size", "-", "len", "(", "indices", ")", ")", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "total_size", "\n", "\n", "# subsample", "\n", "indices", "=", "indices", "[", "self", ".", "rank", ":", "self", ".", "total_size", ":", "self", ".", "num_replicas", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "\n", "return", "iter", "(", "indices", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.base_sampler.BaseSampler.__init__": [[13, 25], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "num", "=", "num", "\n", "self", ".", "pos_fraction", "=", "pos_fraction", "\n", "self", ".", "neg_pos_ub", "=", "neg_pos_ub", "\n", "self", ".", "add_gt_as_proposals", "=", "add_gt_as_proposals", "\n", "self", ".", "pos_sampler", "=", "self", "\n", "self", ".", "neg_sampler", "=", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.base_sampler.BaseSampler._sample_pos": [[26, 30], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_sample_pos", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive samples.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.base_sampler.BaseSampler._sample_neg": [[31, 35], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_sample_neg", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative samples.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.base_sampler.BaseSampler.sample": [[36, 106], ["torch.cat.new_zeros", "int", "base_sampler.BaseSampler.pos_sampler._sample_pos", "pos_inds.unique.unique.unique", "pos_inds.unique.unique.numel", "base_sampler.BaseSampler.neg_sampler._sample_neg", "neg_inds.unique.unique.unique", "sampling_result.SamplingResult.SamplingResult", "len", "torch.cat", "assign_result.add_gt_", "torch.cat.new_ones", "torch.cat", "max", "int", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.pseudo_sampler.PseudoSampler._sample_pos", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.pseudo_sampler.PseudoSampler._sample_neg", "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.add_gt_"], ["", "def", "sample", "(", "self", ",", "\n", "assign_result", ",", "\n", "segments", ",", "\n", "gt_segments", ",", "\n", "gt_labels", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive and negative segments.\n\n        This is a simple implementation of segment sampling given candidates,\n        assigning results and ground truth segments.\n\n        Args:\n            assign_result (:obj:`AssignResult`): Segment assigning results.\n            segments (Tensor): Segments to be sampled from.\n            gt_segments (Tensor): Ground truth segments.\n            gt_labels (Tensor, optional): Class labels of ground truth\n                segments.\n\n        Returns:\n            :obj:`SamplingResult`: Sampling result.\n\n        Example:\n            >>> from vedatad.misc.segment import RandomSampler\n            >>> from vedatad.misc.segment.assigners import AssignResult\n            >>> from vedatad.misc.segment.demodata import ensure_rng, random_segments\n            >>> rng = ensure_rng(None)\n            >>> assign_result = AssignResult.random(rng=rng)\n            >>> segments = random_segments(assign_result.num_preds, rng=rng)\n            >>> gt_segments = random_segments(assign_result.num_gts, rng=rng)\n            >>> gt_labels = None\n            >>> self = RandomSampler(num=32, pos_fraction=0.5, neg_pos_ub=-1,\n            >>>                      add_gt_as_proposals=False)\n            >>> self = self.sample(assign_result, segments, gt_segments, gt_labels) # noqa: E501\n        \"\"\"", "\n", "if", "len", "(", "segments", ".", "shape", ")", "<", "2", ":", "\n", "            ", "segments", "=", "segments", "[", "None", ",", ":", "]", "\n", "\n", "", "segments", "=", "segments", "[", ":", ",", ":", "2", "]", "\n", "\n", "gt_flags", "=", "segments", ".", "new_zeros", "(", "(", "segments", ".", "shape", "[", "0", "]", ",", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "if", "self", ".", "add_gt_as_proposals", "and", "len", "(", "gt_segments", ")", ">", "0", ":", "\n", "            ", "if", "gt_labels", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "'gt_labels must be given when add_gt_as_proposals is True'", ")", "\n", "", "segments", "=", "torch", ".", "cat", "(", "[", "gt_segments", ",", "segments", "]", ",", "dim", "=", "0", ")", "\n", "assign_result", ".", "add_gt_", "(", "gt_labels", ")", "\n", "gt_ones", "=", "segments", ".", "new_ones", "(", "\n", "gt_segments", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "gt_flags", "=", "torch", ".", "cat", "(", "[", "gt_ones", ",", "gt_flags", "]", ")", "\n", "\n", "", "num_expected_pos", "=", "int", "(", "self", ".", "num", "*", "self", ".", "pos_fraction", ")", "\n", "pos_inds", "=", "self", ".", "pos_sampler", ".", "_sample_pos", "(", "\n", "assign_result", ",", "num_expected_pos", ",", "segments", "=", "segments", ",", "**", "kwargs", ")", "\n", "# We found that sampled indices have duplicated items occasionally.", "\n", "# (may be a bug of PyTorch)", "\n", "pos_inds", "=", "pos_inds", ".", "unique", "(", ")", "\n", "num_sampled_pos", "=", "pos_inds", ".", "numel", "(", ")", "\n", "num_expected_neg", "=", "self", ".", "num", "-", "num_sampled_pos", "\n", "if", "self", ".", "neg_pos_ub", ">=", "0", ":", "\n", "            ", "_pos", "=", "max", "(", "1", ",", "num_sampled_pos", ")", "\n", "neg_upper_bound", "=", "int", "(", "self", ".", "neg_pos_ub", "*", "_pos", ")", "\n", "if", "num_expected_neg", ">", "neg_upper_bound", ":", "\n", "                ", "num_expected_neg", "=", "neg_upper_bound", "\n", "", "", "neg_inds", "=", "self", ".", "neg_sampler", ".", "_sample_neg", "(", "\n", "assign_result", ",", "num_expected_neg", ",", "segments", "=", "segments", ",", "**", "kwargs", ")", "\n", "neg_inds", "=", "neg_inds", ".", "unique", "(", ")", "\n", "\n", "sampling_result", "=", "SamplingResult", "(", "pos_inds", ",", "neg_inds", ",", "segments", ",", "\n", "gt_segments", ",", "assign_result", ",", "gt_flags", ")", "\n", "return", "sampling_result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.__init__": [[23, 32], ["base_sampler.BaseSampler.__init__", "demodata.ensure_rng", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.demodata.ensure_rng", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["def", "__init__", "(", "self", ",", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "neg_pos_ub", "=", "-", "1", ",", "\n", "add_gt_as_proposals", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "RandomSampler", ",", "self", ")", ".", "__init__", "(", "num", ",", "pos_fraction", ",", "neg_pos_ub", ",", "\n", "add_gt_as_proposals", ")", "\n", "self", ".", "rng", "=", "demodata", ".", "ensure_rng", "(", "kwargs", ".", "get", "(", "'rng'", ",", "None", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice": [[33, 58], ["isinstance", "len", "torch.tensor", "torch.randperm", "rand_inds.cpu().numpy.cpu().numpy.cpu().numpy", "torch.tensor.numel", "torch.cuda.current_device", "rand_inds.cpu().numpy.cpu().numpy.cpu"], "methods", ["None"], ["", "def", "random_choice", "(", "self", ",", "gallery", ",", "num", ")", ":", "\n", "        ", "\"\"\"Random select some elements from the gallery.\n\n        If `gallery` is a Tensor, the returned indices will be a Tensor;\n        If `gallery` is a ndarray or list, the returned indices will be a\n        ndarray.\n\n        Args:\n            gallery (Tensor | ndarray | list): indices pool.\n            num (int): expected sample num.\n\n        Returns:\n            Tensor or ndarray: sampled indices.\n        \"\"\"", "\n", "assert", "len", "(", "gallery", ")", ">=", "num", "\n", "\n", "is_tensor", "=", "isinstance", "(", "gallery", ",", "torch", ".", "Tensor", ")", "\n", "if", "not", "is_tensor", ":", "\n", "            ", "gallery", "=", "torch", ".", "tensor", "(", "\n", "gallery", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "", "perm", "=", "torch", ".", "randperm", "(", "gallery", ".", "numel", "(", ")", ",", "device", "=", "gallery", ".", "device", ")", "[", ":", "num", "]", "\n", "rand_inds", "=", "gallery", "[", "perm", "]", "\n", "if", "not", "is_tensor", ":", "\n", "            ", "rand_inds", "=", "rand_inds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "return", "rand_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler._sample_pos": [[59, 68], ["torch.nonzero", "pos_inds.squeeze.squeeze.numel", "pos_inds.squeeze.squeeze.squeeze", "pos_inds.squeeze.squeeze.numel", "random_sampler.RandomSampler.random_choice"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice"], ["", "def", "_sample_pos", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Randomly sample some positive samples.\"\"\"", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "pos_inds", "=", "pos_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "pos_inds", ".", "numel", "(", ")", "<=", "num_expected", ":", "\n", "            ", "return", "pos_inds", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "random_choice", "(", "pos_inds", ",", "num_expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler._sample_neg": [[69, 78], ["torch.nonzero", "neg_inds.squeeze.squeeze.numel", "neg_inds.squeeze.squeeze.squeeze", "len", "random_sampler.RandomSampler.random_choice"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice"], ["", "", "def", "_sample_neg", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Randomly sample some negative samples.\"\"\"", "\n", "neg_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", "==", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "neg_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "neg_inds", "=", "neg_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "len", "(", "neg_inds", ")", "<=", "num_expected", ":", "\n", "            ", "return", "neg_inds", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "random_choice", "(", "neg_inds", ",", "num_expected", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.instance_balanced_pos_sampler.InstanceBalancedPosSampler._sample_pos": [[15, 59], ["torch.nonzero", "pos_inds.squeeze.squeeze.numel", "pos_inds.squeeze.squeeze.squeeze", "pos_inds.squeeze.squeeze.numel", "assign_result.gt_inds[].unique", "len", "int", "torch.cat", "torch.nonzero", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.append", "len", "numpy.array", "torch.from_numpy().to().long", "torch.cat", "round", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.numel", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.squeeze", "len", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.random_choice", "len", "list", "len", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.random_choice", "len", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.random_choice", "i.item", "torch.from_numpy().to", "float", "set", "set", "pos_inds.squeeze.squeeze.cpu", "instance_balanced_pos_sampler.InstanceBalancedPosSampler.cpu", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to"], ["def", "_sample_pos", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive segments.\n\n        Args:\n            assign_result (:obj:`AssignResult`): The assigned results of\n                segments.\n            num_expected (int): The number of expected positive samples\n\n        Returns:\n            Tensor or ndarray: sampled indices.\n        \"\"\"", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "pos_inds", "=", "pos_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "pos_inds", ".", "numel", "(", ")", "<=", "num_expected", ":", "\n", "            ", "return", "pos_inds", "\n", "", "else", ":", "\n", "            ", "unique_gt_inds", "=", "assign_result", ".", "gt_inds", "[", "pos_inds", "]", ".", "unique", "(", ")", "\n", "num_gts", "=", "len", "(", "unique_gt_inds", ")", "\n", "num_per_gt", "=", "int", "(", "round", "(", "num_expected", "/", "float", "(", "num_gts", ")", ")", "+", "1", ")", "\n", "sampled_inds", "=", "[", "]", "\n", "for", "i", "in", "unique_gt_inds", ":", "\n", "                ", "inds", "=", "torch", ".", "nonzero", "(", "\n", "assign_result", ".", "gt_inds", "==", "i", ".", "item", "(", ")", ",", "as_tuple", "=", "False", ")", "\n", "if", "inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "                    ", "inds", "=", "inds", ".", "squeeze", "(", "1", ")", "\n", "", "else", ":", "\n", "                    ", "continue", "\n", "", "if", "len", "(", "inds", ")", ">", "num_per_gt", ":", "\n", "                    ", "inds", "=", "self", ".", "random_choice", "(", "inds", ",", "num_per_gt", ")", "\n", "", "sampled_inds", ".", "append", "(", "inds", ")", "\n", "", "sampled_inds", "=", "torch", ".", "cat", "(", "sampled_inds", ")", "\n", "if", "len", "(", "sampled_inds", ")", "<", "num_expected", ":", "\n", "                ", "num_extra", "=", "num_expected", "-", "len", "(", "sampled_inds", ")", "\n", "extra_inds", "=", "np", ".", "array", "(", "\n", "list", "(", "set", "(", "pos_inds", ".", "cpu", "(", ")", ")", "-", "set", "(", "sampled_inds", ".", "cpu", "(", ")", ")", ")", ")", "\n", "if", "len", "(", "extra_inds", ")", ">", "num_extra", ":", "\n", "                    ", "extra_inds", "=", "self", ".", "random_choice", "(", "extra_inds", ",", "num_extra", ")", "\n", "", "extra_inds", "=", "torch", ".", "from_numpy", "(", "extra_inds", ")", ".", "to", "(", "\n", "assign_result", ".", "gt_inds", ".", "device", ")", ".", "long", "(", ")", "\n", "sampled_inds", "=", "torch", ".", "cat", "(", "[", "sampled_inds", ",", "extra_inds", "]", ")", "\n", "", "elif", "len", "(", "sampled_inds", ")", ">", "num_expected", ":", "\n", "                ", "sampled_inds", "=", "self", ".", "random_choice", "(", "sampled_inds", ",", "num_expected", ")", "\n", "", "return", "sampled_inds", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.iou_balanced_neg_sampler.IoUBalancedNegSampler.__init__": [[31, 47], ["random_sampler.RandomSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "floor_thr", "=", "-", "1", ",", "\n", "floor_fraction", "=", "0", ",", "\n", "num_bins", "=", "3", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "IoUBalancedNegSampler", ",", "self", ")", ".", "__init__", "(", "num", ",", "pos_fraction", ",", "\n", "**", "kwargs", ")", "\n", "assert", "floor_thr", ">=", "0", "or", "floor_thr", "==", "-", "1", "\n", "assert", "0", "<=", "floor_fraction", "<=", "1", "\n", "assert", "num_bins", ">=", "1", "\n", "\n", "self", ".", "floor_thr", "=", "floor_thr", "\n", "self", ".", "floor_fraction", "=", "floor_fraction", "\n", "self", ".", "num_bins", "=", "num_bins", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.iou_balanced_neg_sampler.IoUBalancedNegSampler.sample_via_interval": [[48, 89], ["max_overlaps.max", "int", "range", "numpy.concatenate", "set", "list", "numpy.concatenate.append", "len", "numpy.array", "numpy.concatenate", "len", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "numpy.array", "len", "list", "len", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "numpy.where", "numpy.logical_and", "set"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice"], ["", "def", "sample_via_interval", "(", "self", ",", "max_overlaps", ",", "full_set", ",", "num_expected", ")", ":", "\n", "        ", "\"\"\"Sample according to the iou interval.\n\n        Args:\n            max_overlaps (torch.Tensor): IoU between segments and ground truth\n                segments.\n            full_set (set(int)): A full set of indices of segments.\n            num_expected (int): Number of expected samples.\n\n        Returns:\n            np.ndarray: Indices  of samples\n        \"\"\"", "\n", "max_iou", "=", "max_overlaps", ".", "max", "(", ")", "\n", "iou_interval", "=", "(", "max_iou", "-", "self", ".", "floor_thr", ")", "/", "self", ".", "num_bins", "\n", "per_num_expected", "=", "int", "(", "num_expected", "/", "self", ".", "num_bins", ")", "\n", "\n", "sampled_inds", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_bins", ")", ":", "\n", "            ", "start_iou", "=", "self", ".", "floor_thr", "+", "i", "*", "iou_interval", "\n", "end_iou", "=", "self", ".", "floor_thr", "+", "(", "i", "+", "1", ")", "*", "iou_interval", "\n", "tmp_set", "=", "set", "(", "\n", "np", ".", "where", "(", "\n", "np", ".", "logical_and", "(", "max_overlaps", ">=", "start_iou", ",", "\n", "max_overlaps", "<", "end_iou", ")", ")", "[", "0", "]", ")", "\n", "tmp_inds", "=", "list", "(", "tmp_set", "&", "full_set", ")", "\n", "if", "len", "(", "tmp_inds", ")", ">", "per_num_expected", ":", "\n", "                ", "tmp_sampled_set", "=", "self", ".", "random_choice", "(", "tmp_inds", ",", "\n", "per_num_expected", ")", "\n", "", "else", ":", "\n", "                ", "tmp_sampled_set", "=", "np", ".", "array", "(", "tmp_inds", ",", "dtype", "=", "np", ".", "int", ")", "\n", "", "sampled_inds", ".", "append", "(", "tmp_sampled_set", ")", "\n", "\n", "", "sampled_inds", "=", "np", ".", "concatenate", "(", "sampled_inds", ")", "\n", "if", "len", "(", "sampled_inds", ")", "<", "num_expected", ":", "\n", "            ", "num_extra", "=", "num_expected", "-", "len", "(", "sampled_inds", ")", "\n", "extra_inds", "=", "np", ".", "array", "(", "list", "(", "full_set", "-", "set", "(", "sampled_inds", ")", ")", ")", "\n", "if", "len", "(", "extra_inds", ")", ">", "num_extra", ":", "\n", "                ", "extra_inds", "=", "self", ".", "random_choice", "(", "extra_inds", ",", "num_extra", ")", "\n", "", "sampled_inds", "=", "np", ".", "concatenate", "(", "[", "sampled_inds", ",", "extra_inds", "]", ")", "\n", "\n", "", "return", "sampled_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.iou_balanced_neg_sampler.IoUBalancedNegSampler._sample_neg": [[90, 161], ["torch.nonzero", "neg_inds.squeeze.squeeze.numel", "neg_inds.squeeze.squeeze.squeeze", "len", "assign_result.max_overlaps.cpu().numpy", "set", "list", "list", "int", "numpy.concatenate", "torch.from_numpy().long().to", "neg_inds.squeeze.squeeze.cpu().numpy", "set", "set", "len", "numpy.array", "len", "len", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "numpy.array", "len", "numpy.array", "numpy.concatenate", "assign_result.max_overlaps.cpu", "set", "set", "set", "set", "iou_balanced_neg_sampler.IoUBalancedNegSampler.sample_via_interval", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "len", "list", "len", "iou_balanced_neg_sampler.IoUBalancedNegSampler.random_choice", "torch.from_numpy().long", "neg_inds.squeeze.squeeze.cpu", "numpy.where", "numpy.where", "set", "numpy.logical_and", "numpy.where", "numpy.where", "numpy.where", "set", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.iou_balanced_neg_sampler.IoUBalancedNegSampler.sample_via_interval", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.random_sampler.RandomSampler.random_choice"], ["", "def", "_sample_neg", "(", "self", ",", "assign_result", ",", "num_expected", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative segments.\n\n        Args:\n            assign_result (:obj:`AssignResult`): The assigned results of\n                segments.\n            num_expected (int): The number of expected negative samples\n\n        Returns:\n            Tensor or ndarray: sampled indices.\n        \"\"\"", "\n", "neg_inds", "=", "torch", ".", "nonzero", "(", "assign_result", ".", "gt_inds", "==", "0", ",", "as_tuple", "=", "False", ")", "\n", "if", "neg_inds", ".", "numel", "(", ")", "!=", "0", ":", "\n", "            ", "neg_inds", "=", "neg_inds", ".", "squeeze", "(", "1", ")", "\n", "", "if", "len", "(", "neg_inds", ")", "<=", "num_expected", ":", "\n", "            ", "return", "neg_inds", "\n", "", "else", ":", "\n", "            ", "max_overlaps", "=", "assign_result", ".", "max_overlaps", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# balance sampling for negative samples", "\n", "neg_set", "=", "set", "(", "neg_inds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "if", "self", ".", "floor_thr", ">", "0", ":", "\n", "                ", "floor_set", "=", "set", "(", "\n", "np", ".", "where", "(", "\n", "np", ".", "logical_and", "(", "max_overlaps", ">=", "0", ",", "\n", "max_overlaps", "<", "self", ".", "floor_thr", ")", ")", "[", "0", "]", ")", "\n", "iou_sampling_set", "=", "set", "(", "\n", "np", ".", "where", "(", "max_overlaps", ">=", "self", ".", "floor_thr", ")", "[", "0", "]", ")", "\n", "", "elif", "self", ".", "floor_thr", "==", "0", ":", "\n", "                ", "floor_set", "=", "set", "(", "np", ".", "where", "(", "max_overlaps", "==", "0", ")", "[", "0", "]", ")", "\n", "iou_sampling_set", "=", "set", "(", "\n", "np", ".", "where", "(", "max_overlaps", ">", "self", ".", "floor_thr", ")", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                ", "floor_set", "=", "set", "(", ")", "\n", "iou_sampling_set", "=", "set", "(", "\n", "np", ".", "where", "(", "max_overlaps", ">", "self", ".", "floor_thr", ")", "[", "0", "]", ")", "\n", "# for sampling interval calculation", "\n", "self", ".", "floor_thr", "=", "0", "\n", "\n", "", "floor_neg_inds", "=", "list", "(", "floor_set", "&", "neg_set", ")", "\n", "iou_sampling_neg_inds", "=", "list", "(", "iou_sampling_set", "&", "neg_set", ")", "\n", "num_expected_iou_sampling", "=", "int", "(", "num_expected", "*", "\n", "(", "1", "-", "self", ".", "floor_fraction", ")", ")", "\n", "if", "len", "(", "iou_sampling_neg_inds", ")", ">", "num_expected_iou_sampling", ":", "\n", "                ", "if", "self", ".", "num_bins", ">=", "2", ":", "\n", "                    ", "iou_sampled_inds", "=", "self", ".", "sample_via_interval", "(", "\n", "max_overlaps", ",", "set", "(", "iou_sampling_neg_inds", ")", ",", "\n", "num_expected_iou_sampling", ")", "\n", "", "else", ":", "\n", "                    ", "iou_sampled_inds", "=", "self", ".", "random_choice", "(", "\n", "iou_sampling_neg_inds", ",", "num_expected_iou_sampling", ")", "\n", "", "", "else", ":", "\n", "                ", "iou_sampled_inds", "=", "np", ".", "array", "(", "\n", "iou_sampling_neg_inds", ",", "dtype", "=", "np", ".", "int", ")", "\n", "", "num_expected_floor", "=", "num_expected", "-", "len", "(", "iou_sampled_inds", ")", "\n", "if", "len", "(", "floor_neg_inds", ")", ">", "num_expected_floor", ":", "\n", "                ", "sampled_floor_inds", "=", "self", ".", "random_choice", "(", "\n", "floor_neg_inds", ",", "num_expected_floor", ")", "\n", "", "else", ":", "\n", "                ", "sampled_floor_inds", "=", "np", ".", "array", "(", "floor_neg_inds", ",", "dtype", "=", "np", ".", "int", ")", "\n", "", "sampled_inds", "=", "np", ".", "concatenate", "(", "\n", "(", "sampled_floor_inds", ",", "iou_sampled_inds", ")", ")", "\n", "if", "len", "(", "sampled_inds", ")", "<", "num_expected", ":", "\n", "                ", "num_extra", "=", "num_expected", "-", "len", "(", "sampled_inds", ")", "\n", "extra_inds", "=", "np", ".", "array", "(", "list", "(", "neg_set", "-", "set", "(", "sampled_inds", ")", ")", ")", "\n", "if", "len", "(", "extra_inds", ")", ">", "num_extra", ":", "\n", "                    ", "extra_inds", "=", "self", ".", "random_choice", "(", "extra_inds", ",", "num_extra", ")", "\n", "", "sampled_inds", "=", "np", ".", "concatenate", "(", "(", "sampled_inds", ",", "extra_inds", ")", ")", "\n", "", "sampled_inds", "=", "torch", ".", "from_numpy", "(", "sampled_inds", ")", ".", "long", "(", ")", ".", "to", "(", "\n", "assign_result", ".", "gt_inds", ".", "device", ")", "\n", "return", "sampled_inds", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.combined_sampler.CombinedSampler.__init__": [[12, 16], ["base_sampler.BaseSampler.__init__", "builder.build_sampler", "builder.build_sampler"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.builder.build_sampler", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.builder.build_sampler"], ["def", "__init__", "(", "self", ",", "pos_sampler", ",", "neg_sampler", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "CombinedSampler", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "pos_sampler", "=", "build_sampler", "(", "pos_sampler", ",", "**", "kwargs", ")", "\n", "self", ".", "neg_sampler", "=", "build_sampler", "(", "neg_sampler", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.combined_sampler.CombinedSampler._sample_pos": [[17, 20], ["None"], "methods", ["None"], ["", "def", "_sample_pos", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive samples.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.combined_sampler.CombinedSampler._sample_neg": [[21, 24], ["None"], "methods", ["None"], ["", "def", "_sample_neg", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative samples.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.__init__": [[26, 51], ["gt_segments.view.view.numel", "torch.empty_like().view", "sampling_result.SamplingResult.pos_assigned_gt_inds.numel", "len", "gt_segments.view.view.view", "torch.empty_like"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pos_inds", ",", "neg_inds", ",", "segments", ",", "gt_segments", ",", "\n", "assign_result", ",", "gt_flags", ")", ":", "\n", "        ", "self", ".", "pos_inds", "=", "pos_inds", "\n", "self", ".", "neg_inds", "=", "neg_inds", "\n", "self", ".", "pos_segments", "=", "segments", "[", "pos_inds", "]", "\n", "self", ".", "neg_segments", "=", "segments", "[", "neg_inds", "]", "\n", "self", ".", "pos_is_gt", "=", "gt_flags", "[", "pos_inds", "]", "\n", "\n", "self", ".", "num_gts", "=", "gt_segments", ".", "shape", "[", "0", "]", "\n", "self", ".", "pos_assigned_gt_inds", "=", "assign_result", ".", "gt_inds", "[", "pos_inds", "]", "-", "1", "\n", "\n", "if", "gt_segments", ".", "numel", "(", ")", "==", "0", ":", "\n", "# hack for index error case", "\n", "            ", "assert", "self", ".", "pos_assigned_gt_inds", ".", "numel", "(", ")", "==", "0", "\n", "self", ".", "pos_gt_segments", "=", "torch", ".", "empty_like", "(", "gt_segments", ")", ".", "view", "(", "-", "1", ",", "2", ")", "\n", "", "else", ":", "\n", "            ", "if", "len", "(", "gt_segments", ".", "shape", ")", "<", "2", ":", "\n", "                ", "gt_segments", "=", "gt_segments", ".", "view", "(", "-", "1", ",", "2", ")", "\n", "\n", "", "self", ".", "pos_gt_segments", "=", "gt_segments", "[", "self", ".", "pos_assigned_gt_inds", ",", ":", "]", "\n", "\n", "", "if", "assign_result", ".", "labels", "is", "not", "None", ":", "\n", "            ", "self", ".", "pos_gt_labels", "=", "assign_result", ".", "labels", "[", "pos_inds", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "pos_gt_labels", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.segments": [[52, 56], ["torch.cat"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "segments", "(", "self", ")", ":", "\n", "        ", "\"\"\"torch.Tensor: concatenated positive and negative segments\"\"\"", "\n", "return", "torch", ".", "cat", "(", "[", "self", ".", "pos_segments", ",", "self", ".", "neg_segments", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to": [[57, 71], ["_dict.items", "isinstance", "value.to"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "\"\"\"Change the device of the data inplace.\n\n        Example:\n            >>> self = SamplingResult.random()\n            >>> print(f'self = {self.to(None)}')\n            >>> # xdoctest: +REQUIRES(--gpu)\n            >>> print(f'self = {self.to(0)}')\n        \"\"\"", "\n", "_dict", "=", "self", ".", "__dict__", "\n", "for", "key", ",", "value", "in", "_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "_dict", "[", "key", "]", "=", "value", ".", "to", "(", "device", ")", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.__nice__": [[72, 79], ["sampling_result.SamplingResult.info.copy", "sampling_result.SamplingResult.pop", "sampling_result.SamplingResult.pop", "sorted", "sampling_result.SamplingResult.items"], "methods", ["None"], ["", "def", "__nice__", "(", "self", ")", ":", "\n", "        ", "data", "=", "self", ".", "info", ".", "copy", "(", ")", "\n", "data", "[", "'pos_segments'", "]", "=", "data", ".", "pop", "(", "'pos_segments'", ")", ".", "shape", "\n", "data", "[", "'neg_segments'", "]", "=", "data", ".", "pop", "(", "'neg_segments'", ")", ".", "shape", "\n", "parts", "=", "[", "f\"'{k}': {v!r}\"", "for", "k", ",", "v", "in", "sorted", "(", "data", ".", "items", "(", ")", ")", "]", "\n", "body", "=", "'    '", "+", "',\\n    '", ".", "join", "(", "parts", ")", "\n", "return", "'{\\n'", "+", "body", "+", "'\\n}'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.info": [[80, 91], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "info", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns a dictionary of info about the object.\"\"\"", "\n", "return", "{", "\n", "'pos_inds'", ":", "self", ".", "pos_inds", ",", "\n", "'neg_inds'", ":", "self", ".", "neg_inds", ",", "\n", "'pos_segments'", ":", "self", ".", "pos_segments", ",", "\n", "'neg_segments'", ":", "self", ".", "neg_segments", ",", "\n", "'pos_is_gt'", ":", "self", ".", "pos_is_gt", ",", "\n", "'num_gts'", ":", "self", ".", "num_gts", ",", "\n", "'pos_assigned_gt_inds'", ":", "self", ".", "pos_assigned_gt_inds", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.random": [[93, 153], ["demodata.ensure_rng", "AssignResult.random", "demodata.random_segments", "demodata.random_segments", "RandomSampler", "RandomSampler.sample", "demodata.ensure_rng.rand", "gt_segments.squeeze.squeeze.squeeze", "segments.squeeze.squeeze.squeeze"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.demodata.ensure_rng", "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.random", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.demodata.random_segments", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.demodata.random_segments", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.pseudo_sampler.PseudoSampler.sample"], ["", "@", "classmethod", "\n", "def", "random", "(", "cls", ",", "rng", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            rng (None | int | numpy.random.RandomState): seed or state.\n            kwargs (keyword arguments):\n                - num_preds: number of predicted segments\n                - num_gts: number of true segments\n                - p_ignore (float): probability of a predicted segment assinged\n                    to an ignored truth.\n                - p_assigned (float): probability of a predicted segment not\n                    being assigned.\n                - p_use_label (float | bool): with labels or not.\n\n        Returns:\n            :obj:`SamplingResult`: Randomly generated sampling result.\n\n        Example:\n            >>> self = SamplingResult.random()\n            >>> print(self.__dict__)\n        \"\"\"", "\n", "from", ".", ".", "import", "demodata", "\n", "from", ".", ".", "assigners", ".", "assign_result", "import", "AssignResult", "\n", "from", ".", "random_sampler", "import", "RandomSampler", "\n", "rng", "=", "demodata", ".", "ensure_rng", "(", "rng", ")", "\n", "\n", "# make probabalistic?", "\n", "num", "=", "32", "\n", "pos_fraction", "=", "0.5", "\n", "neg_pos_ub", "=", "-", "1", "\n", "\n", "assign_result", "=", "AssignResult", ".", "random", "(", "rng", "=", "rng", ",", "**", "kwargs", ")", "\n", "\n", "# Note we could just compute an assignment", "\n", "segments", "=", "demodata", ".", "random_segments", "(", "assign_result", ".", "num_preds", ",", "rng", "=", "rng", ")", "\n", "gt_segments", "=", "demodata", ".", "random_segments", "(", "assign_result", ".", "num_gts", ",", "rng", "=", "rng", ")", "\n", "\n", "if", "rng", ".", "rand", "(", ")", ">", "0.2", ":", "\n", "# sometimes algorithms squeeze their data, be robust to that", "\n", "            ", "gt_segments", "=", "gt_segments", ".", "squeeze", "(", ")", "\n", "segments", "=", "segments", ".", "squeeze", "(", ")", "\n", "\n", "", "if", "assign_result", ".", "labels", "is", "None", ":", "\n", "            ", "gt_labels", "=", "None", "\n", "", "else", ":", "\n", "            ", "gt_labels", "=", "None", "# todo", "\n", "\n", "", "if", "gt_labels", "is", "None", ":", "\n", "            ", "add_gt_as_proposals", "=", "False", "\n", "", "else", ":", "\n", "            ", "add_gt_as_proposals", "=", "True", "# make probabalistic?", "\n", "\n", "", "sampler", "=", "RandomSampler", "(", "\n", "num", ",", "\n", "pos_fraction", ",", "\n", "neg_pos_ub", "=", "neg_pos_ub", ",", "\n", "add_gt_as_proposals", "=", "add_gt_as_proposals", ",", "\n", "rng", "=", "rng", ")", "\n", "self", "=", "sampler", ".", "sample", "(", "assign_result", ",", "segments", ",", "gt_segments", ",", "gt_labels", ")", "\n", "return", "self", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.pseudo_sampler.PseudoSampler.__init__": [[14, 16], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.pseudo_sampler.PseudoSampler._sample_pos": [[17, 20], ["None"], "methods", ["None"], ["", "def", "_sample_pos", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample positive samples.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.pseudo_sampler.PseudoSampler._sample_neg": [[21, 24], ["None"], "methods", ["None"], ["", "def", "_sample_neg", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Sample negative samples.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.pseudo_sampler.PseudoSampler.sample": [[25, 44], ["torch.nonzero().squeeze().unique", "torch.nonzero().squeeze().unique", "segments.new_zeros", "sampling_result.SamplingResult.SamplingResult", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero", "torch.nonzero"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "assign_result", ",", "segments", ",", "gt_segments", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Directly returns the positive and negative indices  of samples.\n\n        Args:\n            assign_result (:obj:`AssignResult`): Assigned results\n            segments (torch.Tensor): Segments\n            gt_segments (torch.Tensor): Ground truth segments\n\n        Returns:\n            :obj:`SamplingResult`: sampler results\n        \"\"\"", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "\n", "assign_result", ".", "gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", "-", "1", ")", ".", "unique", "(", ")", "\n", "neg_inds", "=", "torch", ".", "nonzero", "(", "\n", "assign_result", ".", "gt_inds", "==", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", "-", "1", ")", ".", "unique", "(", ")", "\n", "gt_flags", "=", "segments", ".", "new_zeros", "(", "segments", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "sampling_result", "=", "SamplingResult", "(", "pos_inds", ",", "neg_inds", ",", "segments", ",", "\n", "gt_segments", ",", "assign_result", ",", "gt_flags", ")", "\n", "return", "sampling_result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.SpatialRandomFlip.__init__": [[25, 31], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "flip_ratio", "=", "None", ",", "direction", "=", "'horizontal'", ")", ":", "\n", "        ", "self", ".", "flip_ratio", "=", "flip_ratio", "\n", "self", ".", "direction", "=", "direction", "\n", "if", "flip_ratio", "is", "not", "None", ":", "\n", "            ", "assert", "0", "<=", "flip_ratio", "<=", "1", "\n", "", "assert", "direction", "in", "[", "'horizontal'", ",", "'vertical'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.SpatialRandomFlip.__call__": [[32, 51], ["numpy.random.rand", "results.get", "numpy.flip", "numpy.flip"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to flip images.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Flipped results, 'flip', 'flip_direction' keys are added into\n                result dict.\n        \"\"\"", "\n", "\n", "if", "np", ".", "random", ".", "rand", "(", ")", "<", "self", ".", "flip_ratio", ":", "\n", "            ", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'imgs'", "]", ")", ":", "\n", "                ", "if", "self", ".", "direction", "==", "'horizontal'", ":", "\n", "                    ", "results", "[", "key", "]", "=", "np", ".", "flip", "(", "results", "[", "key", "]", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                    ", "results", "[", "key", "]", "=", "np", ".", "flip", "(", "results", "[", "key", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.SpatialRandomFlip.__repr__": [[52, 54], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(flip_ratio={self.flip_ratio})'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Pad.__init__": [[70, 77], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", "=", "None", ",", "size_divisor", "=", "None", ",", "pad_val", "=", "0", ")", ":", "\n", "        ", "self", ".", "size", "=", "size", "\n", "self", ".", "size_divisor", "=", "size_divisor", "\n", "self", ".", "pad_val", "=", "pad_val", "\n", "# only one of size and size_divisor should be valid", "\n", "assert", "size", "is", "not", "None", "or", "size_divisor", "is", "not", "None", "\n", "assert", "size", "is", "None", "or", "size_divisor", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Pad._pad_imgs": [[78, 89], ["results.get", "vedacore.impad", "vedacore.impad_to_multiple"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.impad", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.impad_to_multiple"], ["", "def", "_pad_imgs", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Pad images according to ``self.size``.\"\"\"", "\n", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'imgs'", "]", ")", ":", "\n", "            ", "if", "self", ".", "size", "is", "not", "None", ":", "\n", "                ", "padded_imgs", "=", "image", ".", "impad", "(", "\n", "results", "[", "key", "]", ",", "shape", "=", "self", ".", "size", ",", "pad_val", "=", "self", ".", "pad_val", ")", "\n", "", "elif", "self", ".", "size_divisor", "is", "not", "None", ":", "\n", "                ", "padded_imgs", "=", "image", ".", "impad_to_multiple", "(", "\n", "results", "[", "key", "]", ",", "self", ".", "size_divisor", ",", "pad_val", "=", "self", ".", "pad_val", ")", "\n", "", "results", "[", "key", "]", "=", "padded_imgs", "\n", "", "results", "[", "'pad_tsize'", "]", "=", "padded_imgs", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Pad.__call__": [[90, 101], ["transforms.Pad._pad_imgs"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Pad._pad_imgs"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to pad images.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Updated result dict.\n        \"\"\"", "\n", "self", ".", "_pad_imgs", "(", "results", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Pad.__repr__": [[102, 108], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(size={self.size}, '", "\n", "repr_str", "+=", "f'size_divisor={self.size_divisor}, '", "\n", "repr_str", "+=", "f'pad_val={self.pad_val})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Normalize.__init__": [[123, 127], ["numpy.array", "numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mean", ",", "std", ",", "to_rgb", "=", "True", ")", ":", "\n", "        ", "self", ".", "mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "to_rgb", "=", "to_rgb", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Normalize.__call__": [[128, 144], ["results.get", "dict", "vedacore.imnormalize"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.photometric.imnormalize"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to normalize images.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Normalized results, 'img_norm_cfg' key is added into\n                result dict.\n        \"\"\"", "\n", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'imgs'", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "image", ".", "imnormalize", "(", "results", "[", "key", "]", ",", "self", ".", "mean", ",", "self", ".", "std", ",", "\n", "self", ".", "to_rgb", ")", "\n", "", "results", "[", "'img_norm_cfg'", "]", "=", "dict", "(", "\n", "mean", "=", "self", ".", "mean", ",", "std", "=", "self", ".", "std", ",", "to_rgb", "=", "self", ".", "to_rgb", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Normalize.__repr__": [[145, 149], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(mean={self.mean}, std={self.std}, to_rgb={self.to_rgb})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.SpatialRandomCrop.__init__": [[162, 165], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "crop_size", ")", ":", "\n", "        ", "assert", "crop_size", "[", "0", "]", ">", "0", "and", "crop_size", "[", "1", "]", ">", "0", "\n", "self", ".", "crop_size", "=", "crop_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.SpatialRandomCrop.__call__": [[166, 191], ["results.get", "max", "max", "numpy.random.randint", "numpy.random.randint"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to randomly crop images.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Randomly cropped results, 'imgs_shape' key in result dict\n                is updated according to crop size.\n        \"\"\"", "\n", "\n", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'imgs'", "]", ")", ":", "\n", "            ", "imgs", "=", "results", "[", "key", "]", "\n", "margin_h", "=", "max", "(", "imgs", ".", "shape", "[", "1", "]", "-", "self", ".", "crop_size", "[", "0", "]", ",", "0", ")", "\n", "margin_w", "=", "max", "(", "imgs", ".", "shape", "[", "2", "]", "-", "self", ".", "crop_size", "[", "1", "]", ",", "0", ")", "\n", "offset_h", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "margin_h", "+", "1", ")", "\n", "offset_w", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "margin_w", "+", "1", ")", "\n", "crop_y1", ",", "crop_y2", "=", "offset_h", ",", "offset_h", "+", "self", ".", "crop_size", "[", "0", "]", "\n", "crop_x1", ",", "crop_x2", "=", "offset_w", ",", "offset_w", "+", "self", ".", "crop_size", "[", "1", "]", "\n", "\n", "# crop images", "\n", "imgs", "=", "imgs", "[", ":", ",", "crop_y1", ":", "crop_y2", ",", "crop_x1", ":", "crop_x2", ",", "...", "]", "\n", "results", "[", "key", "]", "=", "imgs", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.SpatialRandomCrop.__repr__": [[192, 194], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(crop_size={self.crop_size})'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.SpatialCenterCrop.__init__": [[207, 210], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "crop_size", ")", ":", "\n", "        ", "assert", "crop_size", "[", "0", "]", ">", "0", "and", "crop_size", "[", "1", "]", ">", "0", "\n", "self", ".", "crop_size", "=", "crop_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.SpatialCenterCrop.__call__": [[211, 236], ["results.get", "max", "max", "int", "int"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to center crop images.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Randomly cropped results, 'imgs_shape' key in result dict\n                is updated according to crop size.\n        \"\"\"", "\n", "\n", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'imgs'", "]", ")", ":", "\n", "            ", "imgs", "=", "results", "[", "key", "]", "\n", "margin_h", "=", "max", "(", "imgs", ".", "shape", "[", "1", "]", "-", "self", ".", "crop_size", "[", "0", "]", ",", "0", ")", "\n", "margin_w", "=", "max", "(", "imgs", ".", "shape", "[", "2", "]", "-", "self", ".", "crop_size", "[", "1", "]", ",", "0", ")", "\n", "offset_h", "=", "int", "(", "margin_h", "/", "2", ")", "\n", "offset_w", "=", "int", "(", "margin_w", "/", "2", ")", "\n", "crop_y1", ",", "crop_y2", "=", "offset_h", ",", "offset_h", "+", "self", ".", "crop_size", "[", "0", "]", "\n", "crop_x1", ",", "crop_x2", "=", "offset_w", ",", "offset_w", "+", "self", ".", "crop_size", "[", "1", "]", "\n", "\n", "# crop images", "\n", "imgs", "=", "imgs", "[", ":", ",", "crop_y1", ":", "crop_y2", ",", "crop_x1", ":", "crop_x2", ",", "...", "]", "\n", "results", "[", "key", "]", "=", "imgs", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.SpatialCenterCrop.__repr__": [[237, 239], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(crop_size={self.crop_size})'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.PhotoMetricDistortion.__init__": [[263, 274], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "brightness_delta", "=", "32", ",", "\n", "contrast_range", "=", "(", "0.5", ",", "1.5", ")", ",", "\n", "saturation_range", "=", "(", "0.5", ",", "1.5", ")", ",", "\n", "hue_delta", "=", "18", ",", "\n", "p", "=", "0.5", ")", ":", "\n", "        ", "self", ".", "brightness_delta", "=", "brightness_delta", "\n", "self", ".", "contrast_lower", ",", "self", ".", "contrast_upper", "=", "contrast_range", "\n", "self", ".", "saturation_lower", ",", "self", ".", "saturation_upper", "=", "saturation_range", "\n", "self", ".", "hue_delta", "=", "hue_delta", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.PhotoMetricDistortion.__call__": [[275, 351], ["numpy.random.uniform", "numpy.random.randint", "numpy.random.randint", "numpy.array", "numpy.random.randint", "numpy.array", "transforms.PhotoMetricDistortion.__call__._filter"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to perform photometric distortion on images.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Result dict with images distorted.\n        \"\"\"", "\n", "\n", "if", "'img_fields'", "in", "results", ":", "\n", "            ", "assert", "results", "[", "'img_fields'", "]", "==", "[", "\n", "'imgs'", "\n", "]", ",", "(", "'Only single img_fields is allowed'", ")", "\n", "", "imgs", "=", "results", "[", "'imgs'", "]", "\n", "assert", "imgs", ".", "dtype", "==", "np", ".", "float32", ",", "(", "\n", "'PhotoMetricDistortion needs the input imgs of dtype np.float32'", "\n", "', please set \"to_float32=True\" in \"LoadFrames\" pipeline'", ")", "\n", "\n", "def", "_filter", "(", "img", ")", ":", "\n", "            ", "img", "[", "img", "<", "0", "]", "=", "0", "\n", "img", "[", "img", ">", "255", "]", "=", "255", "\n", "return", "img", "\n", "\n", "", "if", "random", ".", "uniform", "(", "0", ",", "1", ")", "<=", "self", ".", "p", ":", "\n", "\n", "# random brightness", "\n", "            ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "                ", "delta", "=", "random", ".", "uniform", "(", "-", "self", ".", "brightness_delta", ",", "\n", "self", ".", "brightness_delta", ")", "\n", "imgs", "+=", "delta", "\n", "imgs", "=", "_filter", "(", "imgs", ")", "\n", "\n", "# mode == 0 --> do random contrast first", "\n", "# mode == 1 --> do random contrast last", "\n", "", "mode", "=", "random", ".", "randint", "(", "2", ")", "\n", "if", "mode", "==", "1", ":", "\n", "                ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "                    ", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "contrast_lower", ",", "\n", "self", ".", "contrast_upper", ")", "\n", "imgs", "*=", "alpha", "\n", "imgs", "=", "_filter", "(", "imgs", ")", "\n", "\n", "# convert color from BGR to HSV", "\n", "", "", "imgs", "=", "np", ".", "array", "(", "[", "image", ".", "bgr2hsv", "(", "img", ")", "for", "img", "in", "imgs", "]", ")", "\n", "\n", "# random saturation", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "                ", "imgs", "[", "...", ",", "1", "]", "*=", "random", ".", "uniform", "(", "self", ".", "saturation_lower", ",", "\n", "self", ".", "saturation_upper", ")", "\n", "\n", "# random hue", "\n", "# if random.randint(2):", "\n", "", "if", "True", ":", "\n", "                ", "imgs", "[", "...", ",", "0", "]", "+=", "random", ".", "uniform", "(", "-", "self", ".", "hue_delta", ",", "self", ".", "hue_delta", ")", "\n", "imgs", "[", "...", ",", "0", "]", "[", "imgs", "[", "...", ",", "0", "]", ">", "360", "]", "-=", "360", "\n", "imgs", "[", "...", ",", "0", "]", "[", "imgs", "[", "...", ",", "0", "]", "<", "0", "]", "+=", "360", "\n", "\n", "# convert color from HSV to BGR", "\n", "", "imgs", "=", "np", ".", "array", "(", "[", "image", ".", "hsv2bgr", "(", "img", ")", "for", "img", "in", "imgs", "]", ")", "\n", "imgs", "=", "_filter", "(", "imgs", ")", "\n", "\n", "# random contrast", "\n", "if", "mode", "==", "0", ":", "\n", "                ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "                    ", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "contrast_lower", ",", "\n", "self", ".", "contrast_upper", ")", "\n", "imgs", "*=", "alpha", "\n", "imgs", "=", "_filter", "(", "imgs", ")", "\n", "\n", "# randomly swap channels", "\n", "", "", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "                ", "imgs", "=", "imgs", "[", "...", ",", "random", ".", "permutation", "(", "3", ")", "]", "\n", "\n", "", "results", "[", "'imgs'", "]", "=", "imgs", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.PhotoMetricDistortion.__repr__": [[352, 361], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(\\nbrightness_delta={self.brightness_delta},\\n'", "\n", "repr_str", "+=", "'contrast_range='", "\n", "repr_str", "+=", "f'{(self.contrast_lower, self.contrast_upper)},\\n'", "\n", "repr_str", "+=", "'saturation_range='", "\n", "repr_str", "+=", "f'{(self.saturation_lower, self.saturation_upper)},\\n'", "\n", "repr_str", "+=", "f'hue_delta={self.hue_delta})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.TemporalRandomCrop.__init__": [[372, 377], ["dict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_frames", "=", "768", ",", "iof_th", "=", "0", ")", ":", "\n", "        ", "self", ".", "num_frames", "=", "num_frames", "\n", "self", ".", "iof_th", "=", "iof_th", "\n", "self", ".", "segment2label", "=", "dict", "(", "\n", "gt_segments", "=", "'gt_labels'", ",", "gt_segments_ignore", "=", "'gt_labels_ignore'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.TemporalRandomCrop.get_valid_mask": [[378, 385], ["numpy.maximum", "vedatad.misc.segment.segment_overlaps", "vedatad.misc.segment.segment_overlaps"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment_overlaps", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment_overlaps"], ["", "def", "get_valid_mask", "(", "self", ",", "segments", ",", "patch", ",", "iof_th", ")", ":", "\n", "        ", "gt_iofs", "=", "segment_overlaps", "(", "segments", ",", "patch", ",", "mode", "=", "'iof'", ")", "[", ":", ",", "0", "]", "\n", "patch_iofs", "=", "segment_overlaps", "(", "patch", ",", "segments", ",", "mode", "=", "'iof'", ")", "[", "0", ",", ":", "]", "\n", "iofs", "=", "np", ".", "maximum", "(", "gt_iofs", ",", "patch_iofs", ")", "\n", "mask", "=", "iofs", ">", "iof_th", "\n", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.TemporalRandomCrop.__call__": [[386, 426], ["min", "numpy.random.randint", "numpy.array", "transforms.TemporalRandomCrop.get_valid_mask", "results.get", "numpy.count_nonzero", "transforms.TemporalRandomCrop.get_valid_mask", "segments[].clip", "segments[].clip"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.TemporalRandomCrop.get_valid_mask", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.TemporalRandomCrop.get_valid_mask"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to random temporally crop video frame.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Temporally cropped results, 'img_ids' is updated in\n                result dict.\n        \"\"\"", "\n", "\n", "total_frames", "=", "results", "[", "'tsize'", "]", "\n", "patch_num_frames", "=", "min", "(", "self", ".", "num_frames", ",", "total_frames", ")", "\n", "while", "True", ":", "\n", "            ", "start", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "total_frames", "-", "patch_num_frames", "+", "1", ")", "\n", "end", "=", "start", "+", "patch_num_frames", "\n", "patch", "=", "np", ".", "array", "(", "[", "[", "start", ",", "end", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "mask", "=", "self", ".", "get_valid_mask", "(", "results", "[", "'gt_segments'", "]", ",", "patch", ",", "\n", "self", ".", "iof_th", ")", "\n", "if", "np", ".", "count_nonzero", "(", "mask", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "for", "key", "in", "results", ".", "get", "(", "'segment_fields'", ",", "[", "]", ")", ":", "\n", "                ", "segments", "=", "results", "[", "key", "]", "\n", "mask", "=", "self", ".", "get_valid_mask", "(", "segments", ",", "patch", ",", "self", ".", "iof_th", ")", "\n", "segments", "=", "segments", "[", "mask", "]", "\n", "segments", "[", ":", ",", "0", "]", "=", "segments", "[", ":", ",", "0", "]", ".", "clip", "(", "min", "=", "start", ")", "\n", "segments", "[", ":", ",", "1", "]", "=", "segments", "[", ":", ",", "1", "]", ".", "clip", "(", "max", "=", "end", ")", "\n", "segments", "-=", "start", "\n", "results", "[", "key", "]", "=", "segments", "\n", "\n", "label_key", "=", "self", ".", "segment2label", "[", "key", "]", "\n", "if", "label_key", "in", "results", ":", "\n", "                    ", "results", "[", "label_key", "]", "=", "results", "[", "label_key", "]", "[", "mask", "]", "\n", "", "", "results", "[", "'img_ids'", "]", "=", "results", "[", "'img_ids'", "]", "[", "start", ":", "end", "]", "\n", "results", "[", "'tsize'", "]", "=", "end", "-", "start", "\n", "results", "[", "'tshift'", "]", "=", "start", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.TemporalRandomCrop.__repr__": [[427, 433], ["None"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(num_frames={self.num_frames},'", "\n", "repr_str", "+=", "f'iof_th={self.iof_th})'", "\n", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Rotate.__init__": [[450, 463], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "limit", ",", "\n", "interpolation", "=", "'bilinear'", ",", "\n", "border_mode", "=", "'constant'", ",", "\n", "border_value", "=", "0", ",", "\n", "p", "=", "0.5", ")", ":", "\n", "        ", "if", "isinstance", "(", "limit", ",", "int", ")", ":", "\n", "            ", "limit", "=", "(", "-", "limit", ",", "limit", ")", "\n", "", "self", ".", "limit", "=", "limit", "\n", "self", ".", "interpolation", "=", "interpolation", "\n", "self", ".", "border_mode", "=", "border_mode", "\n", "self", ".", "border_value", "=", "border_value", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Rotate.__call__": [[464, 488], ["numpy.random.uniform", "numpy.random.uniform", "results.get", "numpy.array", "vedacore.imrotate"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.geometric.imrotate"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to random rotate images.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Spatially rotated results.\n        \"\"\"", "\n", "\n", "if", "random", ".", "uniform", "(", "0", ",", "1", ")", "<=", "self", ".", "p", ":", "\n", "            ", "angle", "=", "random", ".", "uniform", "(", "*", "self", ".", "limit", ")", "\n", "for", "key", "in", "results", ".", "get", "(", "'img_fields'", ",", "[", "'imgs'", "]", ")", ":", "\n", "                ", "imgs", "=", "[", "\n", "image", ".", "imrotate", "(", "\n", "img", ",", "\n", "angle", "=", "angle", ",", "\n", "interpolation", "=", "self", ".", "interpolation", ",", "\n", "border_mode", "=", "self", ".", "border_mode", ",", "\n", "border_value", "=", "self", ".", "border_value", ")", "for", "img", "in", "results", "[", "key", "]", "\n", "]", "\n", "results", "[", "key", "]", "=", "np", ".", "array", "(", "imgs", ")", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.Rotate.__repr__": [[489, 498], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(limit={self.limit},'", "\n", "repr_str", "+=", "f'interpolation={self.interpolation},'", "\n", "repr_str", "+=", "f'border_mode={self.border_mode},'", "\n", "repr_str", "+=", "f'border_value={self.border_value},'", "\n", "repr_str", "+=", "f'p={self.p})'", "\n", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.TemporalCrop.__init__": [[504, 507], ["dict"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "segment2label", "=", "dict", "(", "\n", "gt_segments", "=", "'gt_labels'", ",", "gt_segments_ignore", "=", "'gt_labels_ignore'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.transforms.TemporalCrop.__call__": [[508, 541], ["numpy.array", "results.get", "segments[].clip", "segments[].clip", "vedatad.misc.segment.segment_overlaps"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment_overlaps"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to temporally crop video frame.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Temporally cropped results, 'img_ids', 'tsize', 'tshift' is\n                updated in result dict.\n        \"\"\"", "\n", "\n", "start", ",", "end", "=", "results", "[", "'patch'", "]", "\n", "patch", "=", "np", ".", "array", "(", "[", "start", ",", "end", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "key", "in", "results", ".", "get", "(", "'segment_fields'", ",", "[", "]", ")", ":", "\n", "            ", "segments", "=", "results", "[", "key", "]", "\n", "iofs", "=", "segment_overlaps", "(", "segments", ",", "patch", "[", "None", ",", ":", "]", ",", "mode", "=", "'iof'", ")", "[", ":", ",", "0", "]", "\n", "mask", "=", "iofs", ">", "0", "\n", "segments", "=", "segments", "[", "mask", "]", "\n", "segments", "[", ":", ",", "0", "]", "=", "segments", "[", ":", ",", "0", "]", ".", "clip", "(", "min", "=", "start", ")", "\n", "segments", "[", ":", ",", "1", "]", "=", "segments", "[", ":", ",", "1", "]", ".", "clip", "(", "max", "=", "end", ")", "\n", "segments", "-=", "start", "\n", "results", "[", "key", "]", "=", "segments", "\n", "\n", "label_key", "=", "self", ".", "segment2label", "[", "key", "]", "\n", "if", "label_key", "in", "results", ":", "\n", "                ", "labels", "=", "results", "[", "label_key", "]", "\n", "labels", "=", "labels", "[", "mask", "]", "\n", "results", "[", "label_key", "]", "=", "labels", "\n", "", "", "results", "[", "'img_ids'", "]", "=", "results", "[", "'img_ids'", "]", "[", "start", ":", "end", "]", "\n", "results", "[", "'tsize'", "]", "=", "end", "-", "start", "\n", "results", "[", "'tshift'", "]", "=", "start", "\n", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.auto_augment.AutoAugment.__init__": [[55, 68], ["copy.deepcopy", "isinstance", "compose.Compose", "len", "isinstance", "len", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "policies", ")", ":", "\n", "        ", "assert", "isinstance", "(", "policies", ",", "list", ")", "and", "len", "(", "policies", ")", ">", "0", ",", "'Policies must be a non-empty list.'", "\n", "for", "policy", "in", "policies", ":", "\n", "            ", "assert", "isinstance", "(", "policy", ",", "list", ")", "and", "len", "(", "policy", ")", ">", "0", ",", "'Each policy in policies must be a non-empty list.'", "\n", "for", "augment", "in", "policy", ":", "\n", "                ", "assert", "isinstance", "(", "augment", ",", "dict", ")", "and", "'type'", "in", "augment", ",", "'Each specific augmentation must be a dict with key'", "' \"type\".'", "\n", "\n", "", "", "self", ".", "policies", "=", "copy", ".", "deepcopy", "(", "policies", ")", "\n", "self", ".", "transforms", "=", "[", "Compose", "(", "policy", ")", "for", "policy", "in", "self", ".", "policies", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.auto_augment.AutoAugment.__call__": [[69, 72], ["numpy.random.choice", "numpy.random.choice."], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "transform", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "transforms", ")", "\n", "return", "transform", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.auto_augment.AutoAugment.__repr__": [[73, 75], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'{self.__class__.__name__}(policies={self.policies}'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.test_time_aug.OverlapCropAug.__init__": [[15, 21], ["compose.Compose"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transforms", ",", "num_frames", ",", "overlap_ratio", "=", "0.5", ")", ":", "\n", "        ", "assert", "0", "<=", "overlap_ratio", "<", "1", "\n", "\n", "self", ".", "transforms", "=", "Compose", "(", "transforms", ")", "\n", "self", ".", "num_frames", "=", "num_frames", "\n", "self", ".", "overlap_ratio", "=", "overlap_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.test_time_aug.OverlapCropAug.__call__": [[22, 54], ["int", "min", "results.copy", "aug_data.append", "data.items", "test_time_aug.OverlapCropAug.transforms", "aug_data_dict[].append"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to apply test time augment transforms on results.\n\n        Args:\n            results (dict): Result dict contains the data to transform.\n\n        Returns:\n           dict[str: list]: The augmented data, where each value is wrapped\n               into a list.\n        \"\"\"", "\n", "\n", "stride", "=", "int", "(", "self", ".", "num_frames", "*", "(", "1", "-", "self", ".", "overlap_ratio", ")", ")", "\n", "tsize", "=", "results", "[", "'tsize'", "]", "\n", "start", "=", "0", "\n", "aug_data", "=", "[", "]", "\n", "while", "True", ":", "\n", "            ", "end", "=", "min", "(", "start", "+", "self", ".", "num_frames", ",", "tsize", ")", "\n", "_results", "=", "results", ".", "copy", "(", ")", "\n", "_results", "[", "'patch'", "]", "=", "[", "start", ",", "end", "]", "\n", "aug_data", ".", "append", "(", "self", ".", "transforms", "(", "_results", ")", ")", "\n", "\n", "if", "end", "==", "tsize", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "start", "+=", "stride", "\n", "\n", "# list of dict to dict of list", "\n", "", "", "aug_data_dict", "=", "{", "key", ":", "[", "]", "for", "key", "in", "aug_data", "[", "0", "]", "}", "\n", "for", "data", "in", "aug_data", ":", "\n", "            ", "for", "key", ",", "val", "in", "data", ".", "items", "(", ")", ":", "\n", "                ", "aug_data_dict", "[", "key", "]", ".", "append", "(", "val", ")", "\n", "", "", "return", "aug_data_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.test_time_aug.OverlapCropAug.__repr__": [[55, 61], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(transforms={self.transforms}, '", "\n", "repr_str", "+=", "f'num_frames={self.num_frames}, '", "\n", "repr_str", "+=", "f'overlap_ratio={self.overlap_ratio})'", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadMetaInfo.__call__": [[16, 24], ["list", "range"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "results", "[", "'img_ids'", "]", "=", "list", "(", "range", "(", "results", "[", "'video_info'", "]", "[", "'frames'", "]", ")", ")", "\n", "results", "[", "'ori_tsize'", "]", "=", "results", "[", "'video_info'", "]", "[", "'frames'", "]", "\n", "results", "[", "'tsize'", "]", "=", "results", "[", "'video_info'", "]", "[", "'frames'", "]", "\n", "results", "[", "'fps'", "]", "=", "results", "[", "'video_info'", "]", "[", "'fps'", "]", "\n", "results", "[", "'duration'", "]", "=", "results", "[", "'video_info'", "]", "[", "'duration'", "]", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadFrames.__init__": [[45, 53], ["dict", "file_client_args.copy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "to_float32", "=", "False", ",", "\n", "color_type", "=", "'color'", ",", "\n", "file_client_args", "=", "dict", "(", "backend", "=", "'disk'", ")", ")", ":", "\n", "        ", "self", ".", "to_float32", "=", "to_float32", "\n", "self", ".", "color_type", "=", "color_type", "\n", "self", ".", "file_client_args", "=", "file_client_args", ".", "copy", "(", ")", "\n", "self", ".", "file_client", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadFrames.__call__": [[54, 94], ["sorted", "numpy.array", "vedacore.FileClient", "vedacore.FileClient", "os.join", "glob.glob", "len", "loading.LoadFrames.file_client.get", "vedacore.imfrombytes", "vedacore.imfrombytes", "numpy.array.append", "os.join", "img.astype.astype.astype"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io.imfrombytes", "home.repos.pwc.inspect_result.Media-Smart_vedatad.image.io.imfrombytes"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call functions to load frames and get frames meta information.\n\n        Args:\n            results (dict): Result dict from :obj:`.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded frames and meta information.\n        \"\"\"", "\n", "\n", "if", "self", ".", "file_client", "is", "None", ":", "\n", "            ", "self", ".", "file_client", "=", "fileio", ".", "FileClient", "(", "**", "self", ".", "file_client_args", ")", "\n", "\n", "", "if", "results", "[", "'video_prefix'", "]", "is", "not", "None", ":", "\n", "            ", "video_name", "=", "osp", ".", "join", "(", "results", "[", "'video_prefix'", "]", ",", "\n", "results", "[", "'video_info'", "]", "[", "'video_name'", "]", ")", "\n", "", "else", ":", "\n", "            ", "video_name", "=", "results", "[", "'video_info'", "]", "[", "'video_name'", "]", "\n", "\n", "", "imgfiles", "=", "sorted", "(", "glob", ".", "glob", "(", "osp", ".", "join", "(", "video_name", ",", "'*'", ")", ")", ")", "\n", "assert", "len", "(", "imgfiles", ")", "==", "results", "[", "'video_info'", "]", "[", "'frames'", "]", "\n", "\n", "imgs", "=", "[", "]", "\n", "for", "img_id", "in", "results", "[", "'img_ids'", "]", ":", "\n", "            ", "filename", "=", "imgfiles", "[", "img_id", "]", "\n", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "filename", ")", "\n", "img", "=", "image", ".", "imfrombytes", "(", "img_bytes", ",", "flag", "=", "self", ".", "color_type", ")", "\n", "if", "self", ".", "to_float32", ":", "\n", "                ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "", "imgs", ".", "append", "(", "img", ")", "\n", "", "imgs", "=", "np", ".", "array", "(", "imgs", ")", "\n", "\n", "results", "[", "'video_name'", "]", "=", "video_name", "\n", "results", "[", "'ori_video_name'", "]", "=", "results", "[", "'video_info'", "]", "[", "'video_name'", "]", "\n", "results", "[", "'imgs'", "]", "=", "imgs", "\n", "results", "[", "'tsize'", "]", "=", "imgs", ".", "shape", "[", "0", "]", "\n", "results", "[", "'pad_tsize'", "]", "=", "imgs", ".", "shape", "[", "0", "]", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'imgs'", "]", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadFrames.__repr__": [[95, 101], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "(", "f'{self.__class__.__name__}('", "\n", "f'to_float32={self.to_float32}, '", "\n", "f\"color_type='{self.color_type}', \"", "\n", "f'file_client_args={self.file_client_args})'", ")", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadAnnotations.__init__": [[117, 125], ["dict", "file_client_args.copy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "with_segment", "=", "True", ",", "\n", "with_label", "=", "True", ",", "\n", "file_client_args", "=", "dict", "(", "backend", "=", "'disk'", ")", ")", ":", "\n", "        ", "self", ".", "with_segment", "=", "with_segment", "\n", "self", ".", "with_label", "=", "with_label", "\n", "self", ".", "file_client_args", "=", "file_client_args", ".", "copy", "(", ")", "\n", "self", ".", "file_client", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadAnnotations._load_segments": [[126, 145], ["ann_info[].copy", "ann_info.get", "results[].append", "ann_info.get.copy", "results[].append"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "_load_segments", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Private function to load segment annotations.\n\n        Args:\n            results (dict): Result dict from :obj:`.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded segment annotations.\n        \"\"\"", "\n", "\n", "ann_info", "=", "results", "[", "'ann_info'", "]", "\n", "results", "[", "'gt_segments'", "]", "=", "ann_info", "[", "'segments'", "]", ".", "copy", "(", ")", "\n", "\n", "gt_segments_ignore", "=", "ann_info", ".", "get", "(", "'segments_ignore'", ",", "None", ")", "\n", "if", "gt_segments_ignore", "is", "not", "None", ":", "\n", "            ", "results", "[", "'gt_segments_ignore'", "]", "=", "gt_segments_ignore", ".", "copy", "(", ")", "\n", "results", "[", "'segment_fields'", "]", ".", "append", "(", "'gt_segments_ignore'", ")", "\n", "", "results", "[", "'segment_fields'", "]", ".", "append", "(", "'gt_segments'", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadAnnotations._load_labels": [[146, 158], ["[].copy"], "methods", ["None"], ["", "def", "_load_labels", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Private function to load label annotations.\n\n        Args:\n            results (dict): Result dict from :obj:`.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded label annotations.\n        \"\"\"", "\n", "\n", "results", "[", "'gt_labels'", "]", "=", "results", "[", "'ann_info'", "]", "[", "'labels'", "]", ".", "copy", "(", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadAnnotations.__call__": [[159, 176], ["loading.LoadAnnotations._load_segments", "loading.LoadAnnotations._load_labels"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadAnnotations._load_segments", "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadAnnotations._load_labels"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to load multiple types annotations.\n\n        Args:\n            results (dict): Result dict from :obj:`.CustomDataset`.\n\n        Returns:\n            dict: The dict contains loaded segment, label annotations.\n        \"\"\"", "\n", "\n", "if", "self", ".", "with_segment", ":", "\n", "            ", "results", "=", "self", ".", "_load_segments", "(", "results", ")", "\n", "if", "results", "is", "None", ":", "\n", "                ", "return", "None", "\n", "", "", "if", "self", ".", "with_label", ":", "\n", "            ", "results", "=", "self", ".", "_load_labels", "(", "results", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.LoadAnnotations.__repr__": [[177, 182], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(with_segment={self.with_segment}, '", "\n", "repr_str", "+=", "f'with_label={self.with_label})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.loading.Time2Frame.__call__": [[188, 202], ["results.get"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to switch time point to frame index.\n\n        Args:\n            results (dict): Result dict from loading pipeline.\n\n        Returns:\n            dict: Switch results.\n        \"\"\"", "\n", "\n", "for", "key", "in", "results", ".", "get", "(", "'segment_fields'", ",", "[", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "results", "[", "key", "]", "*", "results", "[", "'fps'", "]", "\n", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.ToTensor.__init__": [[43, 45], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "keys", ")", ":", "\n", "        ", "self", ".", "keys", "=", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.ToTensor.__call__": [[46, 59], ["formating.to_tensor"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.to_tensor"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to convert data in results to :obj:`torch.Tensor`.\n\n        Args:\n            results (dict): Result dict contains the data to convert.\n\n        Returns:\n            dict: The result dict contains the data converted\n                to :obj:`torch.Tensor`.\n        \"\"\"", "\n", "for", "key", "in", "self", ".", "keys", ":", "\n", "            ", "results", "[", "key", "]", "=", "to_tensor", "(", "results", "[", "key", "]", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.ToTensor.__repr__": [[60, 62], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(keys={self.keys})'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.ImageToTensor.__init__": [[76, 78], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "keys", ")", ":", "\n", "        ", "self", ".", "keys", "=", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.ImageToTensor.__call__": [[79, 96], ["formating.to_tensor", "len", "numpy.expand_dims", "numpy.expand_dims.transpose"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.to_tensor"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to convert image in results to :obj:`torch.Tensor` and\n        transpose the channel order.\n\n        Args:\n            results (dict): Result dict contains the image data to convert.\n\n        Returns:\n            dict: The result dict contains the image converted\n                to :obj:`torch.Tensor` and transposed to (C, H, W) order.\n        \"\"\"", "\n", "for", "key", "in", "self", ".", "keys", ":", "\n", "            ", "img", "=", "results", "[", "key", "]", "\n", "if", "len", "(", "img", ".", "shape", ")", "<", "3", ":", "\n", "                ", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "-", "1", ")", "\n", "", "results", "[", "key", "]", "=", "to_tensor", "(", "img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.ImageToTensor.__repr__": [[97, 99], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(keys={self.keys})'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.Transpose.__init__": [[110, 113], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "keys", ",", "order", ")", ":", "\n", "        ", "self", ".", "keys", "=", "keys", "\n", "self", ".", "order", "=", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.Transpose.__call__": [[114, 127], ["results[].transpose"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to transpose the channel order of data in results.\n\n        Args:\n            results (dict): Result dict contains the data to transpose.\n\n        Returns:\n            dict: The result dict contains the data transposed to\n                ``self.order``.\n        \"\"\"", "\n", "for", "key", "in", "self", ".", "keys", ":", "\n", "            ", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "transpose", "(", "self", ".", "order", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.Transpose.__repr__": [[128, 131], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(keys={self.keys}, order={self.order})'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.ToDataContainer.__init__": [[145, 149], ["dict", "dict", "dict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "fields", "=", "(", "dict", "(", "key", "=", "'img'", ",", "stack", "=", "True", ")", ",", "dict", "(", "key", "=", "'gt_bboxes'", ")", ",", "\n", "dict", "(", "key", "=", "'gt_labels'", ")", ")", ")", ":", "\n", "        ", "self", ".", "fields", "=", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.ToDataContainer.__call__": [[150, 167], ["field.copy.copy.copy", "field.copy.copy.pop", "vedacore.parallel.DataContainer"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to convert data in results to\n        :obj:`DataContainer`.\n\n        Args:\n            results (dict): Result dict contains the data to convert.\n\n        Returns:\n            dict: The result dict contains the data converted to\n                :obj:`DataContainer`.\n        \"\"\"", "\n", "\n", "for", "field", "in", "self", ".", "fields", ":", "\n", "            ", "field", "=", "field", ".", "copy", "(", ")", "\n", "key", "=", "field", ".", "pop", "(", "'key'", ")", "\n", "results", "[", "key", "]", "=", "DC", "(", "results", "[", "key", "]", ",", "**", "field", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.ToDataContainer.__repr__": [[168, 170], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(fields={self.fields})'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.DefaultFormatBundle.__call__": [[187, 213], ["formating.DefaultFormatBundle._add_default_meta_keys", "numpy.ascontiguousarray", "vedacore.parallel.DataContainer", "vedacore.parallel.DataContainer", "len", "numpy.expand_dims", "numpy.expand_dims.transpose", "formating.to_tensor", "formating.to_tensor"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.DefaultFormatBundle._add_default_meta_keys", "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.to_tensor", "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.to_tensor"], ["def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to transform and format common fields in results.\n\n        Args:\n            results (dict): Result dict contains the data to convert.\n\n        Returns:\n            dict: The result dict contains the data that is formatted with\n                default bundle.\n        \"\"\"", "\n", "\n", "if", "'imgs'", "in", "results", ":", "\n", "            ", "imgs", "=", "results", "[", "'imgs'", "]", "\n", "# add default meta keys", "\n", "results", "=", "self", ".", "_add_default_meta_keys", "(", "results", ")", "\n", "if", "len", "(", "imgs", ".", "shape", ")", "<", "4", ":", "\n", "                ", "imgs", "=", "np", ".", "expand_dims", "(", "imgs", ",", "-", "1", ")", "\n", "", "imgs", "=", "np", ".", "ascontiguousarray", "(", "imgs", ".", "transpose", "(", "3", ",", "0", ",", "1", ",", "2", ")", ")", "\n", "results", "[", "'imgs'", "]", "=", "DC", "(", "to_tensor", "(", "imgs", ")", ",", "stack", "=", "True", ",", "pad_dims", "=", "3", ")", "\n", "", "for", "key", "in", "[", "\n", "'proposals'", ",", "'gt_segments'", ",", "'gt_segments_ignore'", ",", "'gt_labels'", "\n", "]", ":", "\n", "            ", "if", "key", "not", "in", "results", ":", "\n", "                ", "continue", "\n", "", "results", "[", "key", "]", "=", "DC", "(", "to_tensor", "(", "results", "[", "key", "]", ")", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.DefaultFormatBundle._add_default_meta_keys": [[214, 238], ["results.setdefault", "results.setdefault", "results.setdefault", "dict", "len", "numpy.zeros", "numpy.ones"], "methods", ["None"], ["", "def", "_add_default_meta_keys", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Add default meta keys.\n\n        We set default meta keys including `pad_shape`, `scale_factor` and\n        `img_norm_cfg` to avoid the case where no `Resize`, `Normalize` and\n        `Pad` are implemented during the whole pipeline.\n\n        Args:\n            results (dict): Result dict contains the data to convert.\n\n        Returns:\n            results (dict): Updated result dict contains the data to convert.\n        \"\"\"", "\n", "imgs", "=", "results", "[", "'imgs'", "]", "\n", "num_channels", "=", "1", "if", "len", "(", "imgs", ".", "shape", ")", "<", "3", "else", "imgs", ".", "shape", "[", "-", "1", "]", "\n", "results", ".", "setdefault", "(", "\n", "'img_norm_cfg'", ",", "\n", "dict", "(", "\n", "mean", "=", "np", ".", "zeros", "(", "num_channels", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "std", "=", "np", ".", "ones", "(", "num_channels", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "to_rgb", "=", "False", ")", ")", "\n", "results", ".", "setdefault", "(", "'tscale_factor'", ",", "1.0", ")", "\n", "results", ".", "setdefault", "(", "'tshift'", ",", "0.0", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.DefaultFormatBundle.__repr__": [[239, 241], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.Collect.__init__": [[282, 289], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "keys", ",", "\n", "meta_keys", "=", "(", "'video_name'", ",", "'ori_video_name'", ",", "'img_norm_cfg'", ",", "\n", "'ori_tsize'", ",", "'tshift'", ",", "'tsize'", ",", "'pad_tsize'", ",", "\n", "'tscale_factor'", ")", ")", ":", "\n", "        ", "self", ".", "keys", "=", "keys", "\n", "self", ".", "meta_keys", "=", "meta_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.Collect.__call__": [[290, 311], ["vedacore.parallel.DataContainer"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to collect keys in results. The keys in ``meta_keys``\n        will be converted to :obj:DataContainer.\n\n        Args:\n            results (dict): Result dict contains the data to collect.\n\n        Returns:\n            dict: The result dict contains the following keys\n                - keys in``self.keys``\n                - ``img_metas``\n        \"\"\"", "\n", "\n", "data", "=", "{", "}", "\n", "img_meta", "=", "{", "}", "\n", "for", "key", "in", "self", ".", "meta_keys", ":", "\n", "            ", "img_meta", "[", "key", "]", "=", "results", "[", "key", "]", "\n", "", "data", "[", "'video_metas'", "]", "=", "DC", "(", "img_meta", ",", "cpu_only", "=", "True", ")", "\n", "for", "key", "in", "self", ".", "keys", ":", "\n", "            ", "data", "[", "key", "]", "=", "results", "[", "key", "]", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.Collect.__repr__": [[312, 315], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "f'(keys={self.keys}, meta_keys={self.meta_keys})'", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.WrapFieldsToLists.__call__": [[338, 353], ["results.items"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to wrap fields into lists.\n\n        Args:\n            results (dict): Result dict contains the data to wrap.\n\n        Returns:\n            dict: The result dict where value of ``self.keys`` are wrapped\n                into list.\n        \"\"\"", "\n", "\n", "# Wrap dict fields into lists", "\n", "for", "key", ",", "val", "in", "results", ".", "items", "(", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "[", "val", "]", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.WrapFieldsToLists.__repr__": [[354, 356], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'{self.__class__.__name__}()'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.formating.to_tensor": [[10, 33], ["isinstance", "isinstance", "torch.from_numpy", "isinstance", "torch.tensor", "isinstance", "vedacore.misc.is_str", "torch.LongTensor", "isinstance", "torch.FloatTensor", "TypeError", "type"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.is_str"], ["def", "to_tensor", "(", "data", ")", ":", "\n", "    ", "\"\"\"Convert objects of various python types to :obj:`torch.Tensor`.\n\n    Supported types are: :class:`numpy.ndarray`, :class:`torch.Tensor`,\n    :class:`Sequence`, :class:`int` and :class:`float`.\n\n    Args:\n        data (torch.Tensor | numpy.ndarray | Sequence | int | float): Data to\n            be converted.\n    \"\"\"", "\n", "\n", "if", "isinstance", "(", "data", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "data", "\n", "", "elif", "isinstance", "(", "data", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "data", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "Sequence", ")", "and", "not", "is_str", "(", "data", ")", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "data", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "int", ")", ":", "\n", "        ", "return", "torch", ".", "LongTensor", "(", "[", "data", "]", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "float", ")", ":", "\n", "        ", "return", "torch", ".", "FloatTensor", "(", "[", "data", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "f'type {type(data)} cannot be converted to tensor.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.compose.Compose.__init__": [[14, 25], ["isinstance", "isinstance", "vedacore.misc.build_from_cfg", "compose.Compose.transforms.append", "callable", "compose.Compose.transforms.append", "TypeError"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["def", "__init__", "(", "self", ",", "transforms", ")", ":", "\n", "        ", "assert", "isinstance", "(", "transforms", ",", "collections", ".", "abc", ".", "Sequence", ")", "\n", "self", ".", "transforms", "=", "[", "]", "\n", "for", "transform", "in", "transforms", ":", "\n", "            ", "if", "isinstance", "(", "transform", ",", "dict", ")", ":", "\n", "                ", "transform", "=", "build_from_cfg", "(", "transform", ",", "registry", ",", "'pipeline'", ")", "\n", "self", ".", "transforms", ".", "append", "(", "transform", ")", "\n", "", "elif", "callable", "(", "transform", ")", ":", "\n", "                ", "self", ".", "transforms", ".", "append", "(", "transform", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "'transform must be callable or a dict'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.compose.Compose.__call__": [[26, 41], ["t"], "methods", ["None"], ["", "", "", "def", "__call__", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Call function to apply transforms sequentially.\n\n        Args:\n            data (dict): A result dict contains the data to transform.\n\n        Returns:\n           dict: Transformed data.\n        \"\"\"", "\n", "\n", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "data", "=", "t", "(", "data", ")", "\n", "if", "data", "is", "None", ":", "\n", "                ", "return", "None", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.pipelines.compose.Compose.__repr__": [[42, 49], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "format_string", "=", "self", ".", "__class__", ".", "__name__", "+", "'('", "\n", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "format_string", "+=", "'\\n'", "\n", "format_string", "+=", "f'    {t}'", "\n", "", "format_string", "+=", "'\\n)'", "\n", "return", "format_string", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.base_meshgrid.BaseMeshGrid.__init__": [[6, 9], ["len"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "strides", ")", ":", "\n", "        ", "assert", "len", "(", "strides", ")", ">", "0", "\n", "self", ".", "strides", "=", "strides", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.base_meshgrid.BaseMeshGrid.gen_anchor_mesh": [[10, 13], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "gen_anchor_mesh", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.builder.build_meshgrid": [[4, 7], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "import", "torch", "\n", "\n", "from", "vedacore", ".", "misc", "import", "build_from_cfg", ",", "registry", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid.__init__": [[14, 17], ["base_meshgrid.BaseMeshGrid.__init__", "base_anchors.build_base_anchor().generate", "base_anchors.build_base_anchor"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.base_anchors.segment.SegmentBaseAnchor.generate", "home.repos.pwc.inspect_result.Media-Smart_vedatad.base_anchors.builder.build_base_anchor"], ["    ", "def", "__init__", "(", "self", ",", "strides", ",", "base_anchor", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "strides", ")", "\n", "self", ".", "base_anchors", "=", "build_base_anchor", "(", "base_anchor", ")", ".", "generate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid.gen_anchor_mesh": [[18, 51], ["len", "segment_anchor_meshgrid.SegmentAnchorMeshGrid._gen_anchor_mesh", "enumerate", "segment_anchor_meshgrid.SegmentAnchorMeshGrid.valid_flags", "valid_flag_list.append", "range"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid._gen_anchor_mesh", "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid.valid_flags"], ["", "def", "gen_anchor_mesh", "(", "self", ",", "\n", "featmap_tsizes", ",", "\n", "video_metas", ",", "\n", "dtype", "=", "torch", ".", "float", ",", "\n", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Get anchors according to feature map sizes.\n\n        Args:\n            featmap_tsizes (list[int]): Multi-level feature map temporal sizes.\n            video_metas (list[dict]): Video meta info.\n            device (torch.device | str): Device for returned tensors\n        Returns:\n            tuple:\n                anchor_list (list[Tensor]): Anchors of each video.\n                valid_flag_list (list[Tensor]): Valid flags of each video.\n        \"\"\"", "\n", "num_videos", "=", "len", "(", "video_metas", ")", "\n", "\n", "# since feature map temporal sizes of all videos are the same, we only", "\n", "# compute anchors for one time", "\n", "multi_level_anchors", "=", "self", ".", "_gen_anchor_mesh", "(", "featmap_tsizes", ",", "dtype", ",", "\n", "device", ")", "\n", "anchor_list", "=", "[", "multi_level_anchors", "for", "_", "in", "range", "(", "num_videos", ")", "]", "\n", "\n", "# for each video, we compute valid flags of multi level anchors", "\n", "valid_flag_list", "=", "[", "]", "\n", "for", "video_id", ",", "video_meta", "in", "enumerate", "(", "video_metas", ")", ":", "\n", "            ", "multi_level_flags", "=", "self", ".", "valid_flags", "(", "featmap_tsizes", ",", "\n", "video_meta", "[", "'pad_tsize'", "]", ",", "\n", "device", ")", "\n", "valid_flag_list", ".", "append", "(", "multi_level_flags", ")", "\n", "\n", "", "return", "anchor_list", ",", "valid_flag_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid._gen_anchor_mesh": [[52, 72], ["range", "len", "segment_anchor_meshgrid.SegmentAnchorMeshGrid._single_level_anchor_mesh", "multi_level_anchors.append", "segment_anchor_meshgrid.SegmentAnchorMeshGrid.base_anchors[].to().to", "segment_anchor_meshgrid.SegmentAnchorMeshGrid.base_anchors[].to"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid._single_level_anchor_mesh", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to"], ["", "def", "_gen_anchor_mesh", "(", "self", ",", "featmap_tsizes", ",", "dtype", ",", "device", ")", ":", "\n", "        ", "\"\"\"Get points according to feature map sizes.\n\n        Args:\n            featmap_tsizes (list[int]): Multi-level feature map temporal sizes.\n            dtype (torch.dtype): Type of points.\n            device (torch.device): Device of points.\n        Returns:\n            tuple: points of each image.\n        \"\"\"", "\n", "assert", "self", ".", "num_levels", "==", "len", "(", "featmap_tsizes", ")", "\n", "multi_level_anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "            ", "anchors", "=", "self", ".", "_single_level_anchor_mesh", "(", "\n", "self", ".", "base_anchors", "[", "i", "]", ".", "to", "(", "device", ")", ".", "to", "(", "dtype", ")", ",", "\n", "featmap_tsizes", "[", "i", "]", ",", "\n", "self", ".", "strides", "[", "i", "]", ",", "\n", "device", "=", "device", ")", "\n", "multi_level_anchors", ".", "append", "(", "anchors", ")", "\n", "", "return", "multi_level_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid._single_level_anchor_mesh": [[73, 101], ["shifts.type_as.type_as.type_as", "all_anchors.view.view.view", "torch.arange"], "methods", ["None"], ["", "def", "_single_level_anchor_mesh", "(", "self", ",", "base_anchors", ",", "featmap_tsize", ",", "stride", ",", "\n", "device", ")", ":", "\n", "        ", "\"\"\"Generate grid anchors of a single level.\n\n        Note:\n            This function is usually called by method ``self.grid_anchors``.\n\n        Args:\n            base_anchors (torch.Tensor): The base anchors of a feature grid.\n            featmap_tsize (int): Temporal size of the feature maps.\n            stride (int, optional): Stride of the feature map.\n                Defaults to .\n            device (str, optional): Device the tensor will be put on.\n                Defaults to 'cuda'.\n\n        Returns:\n            torch.Tensor: Anchors in the overall feature maps.\n        \"\"\"", "\n", "shifts", "=", "torch", ".", "arange", "(", "0", ",", "featmap_tsize", ",", "device", "=", "device", ")", "*", "stride", "\n", "shifts", "=", "shifts", ".", "type_as", "(", "base_anchors", ")", "\n", "# add A anchors (1, A, 2) to K shifts (K, 1, 1) to get", "\n", "# shifted anchors (K, A, 2), reshape to (K*A, 2)", "\n", "\n", "all_anchors", "=", "base_anchors", "[", "None", ",", ":", ",", ":", "]", "+", "shifts", "[", ":", ",", "None", ",", "None", "]", "\n", "all_anchors", "=", "all_anchors", ".", "view", "(", "-", "1", ",", "2", ")", "\n", "# first A rows correspond to A anchors of 0 in feature map,", "\n", "# then 1, 2, ...", "\n", "return", "all_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid.valid_flags": [[102, 128], ["range", "len", "min", "segment_anchor_meshgrid.SegmentAnchorMeshGrid._single_level_valid_flags", "multi_level_flags.append", "int", "numpy.ceil"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid._single_level_valid_flags"], ["", "def", "valid_flags", "(", "self", ",", "featmap_tsizes", ",", "pad_tsize", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Generate valid flags of anchors in multiple feature levels.\n\n        Args:\n            featmap_tsizes (list(tuple)): List of feature map temporal sizes in\n                multiple feature levels.\n            pad_tsize (int): The padded temporal size of the video.\n            device (str): Device where the anchors will be put on.\n\n        Return:\n            list(torch.Tensor): Valid flags of anchors in multiple levels.\n        \"\"\"", "\n", "assert", "self", ".", "num_levels", "==", "len", "(", "featmap_tsizes", ")", "\n", "multi_level_flags", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_levels", ")", ":", "\n", "            ", "anchor_stride", "=", "self", ".", "strides", "[", "i", "]", "\n", "feat_tsize", "=", "featmap_tsizes", "[", "i", "]", "\n", "valid_feat_tsize", "=", "min", "(", "\n", "int", "(", "np", ".", "ceil", "(", "pad_tsize", "/", "anchor_stride", ")", ")", ",", "feat_tsize", ")", "\n", "flags", "=", "self", ".", "_single_level_valid_flags", "(", "\n", "feat_tsize", ",", "\n", "valid_feat_tsize", ",", "\n", "self", ".", "num_base_anchors", "[", "i", "]", ",", "\n", "device", "=", "device", ")", "\n", "multi_level_flags", ".", "append", "(", "flags", ")", "\n", "", "return", "multi_level_flags", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid._single_level_valid_flags": [[129, 154], ["torch.zeros", "valid[].expand().contiguous().view", "valid[].expand().contiguous", "valid[].expand", "valid[].expand().contiguous().view.size"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "_single_level_valid_flags", "(", "self", ",", "\n", "featmap_tsize", ",", "\n", "valid_tsize", ",", "\n", "num_base_anchors", ",", "\n", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Generate the valid flags of anchor in a single feature map.\n\n        Args:\n            featmap_tsize (int): The temporal size of feature maps.\n            valid_tsize (int): The valid temporal size of the feature\n                maps.\n            num_base_anchors (int): The number of base anchors.\n            device (str, optional): Device where the flags will be put on.\n                Defaults to 'cuda'.\n\n        Returns:\n            torch.Tensor: The valid flags of each anchor in a single level\n                feature map.\n        \"\"\"", "\n", "assert", "valid_tsize", "<=", "featmap_tsize", "\n", "valid", "=", "torch", ".", "zeros", "(", "featmap_tsize", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", "\n", "valid", "[", ":", "valid_tsize", "]", "=", "1", "\n", "valid", "=", "valid", "[", ":", ",", "None", "]", ".", "expand", "(", "valid", ".", "size", "(", "0", ")", ",", "\n", "num_base_anchors", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "return", "valid", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid.num_levels": [[155, 159], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_levels", "(", "self", ")", ":", "\n", "        ", "\"\"\"int: number of feature levels that the generator will be applied\"\"\"", "\n", "return", "len", "(", "self", ".", "strides", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid.num_base_anchors": [[160, 164], ["base_anchors.size"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "@", "property", "\n", "def", "num_base_anchors", "(", "self", ")", ":", "\n", "        ", "\"\"\"list[int]: total number of base anchors in a feature grid\"\"\"", "\n", "return", "[", "base_anchors", ".", "size", "(", "0", ")", "for", "base_anchors", "in", "self", ".", "base_anchors", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.base_anchors.segment.SegmentBaseAnchor.__init__": [[12, 56], ["ValueError", "torch.Tensor", "len", "len", "numpy.array", "torch.Tensor", "ValueError", "range"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "base_sizes", ",", "\n", "scales", "=", "None", ",", "\n", "octave_base_scale", "=", "None", ",", "\n", "scales_per_octave", "=", "None", ",", "\n", "centers", "=", "None", ",", "\n", "center_offset", "=", "0.", ")", ":", "\n", "        ", "\"\"\"Generate base anchors.\n\n        list(torch.Tensor): Base anchors of a feature grid in multiple\n            feature levels.\n        \"\"\"", "\n", "if", "center_offset", "!=", "0", ":", "\n", "            ", "assert", "centers", "is", "None", ",", "(", "\n", "f'center cannot be set when center_offset '", "\n", "f'!=0, {centers} is given.'", ")", "\n", "", "if", "not", "(", "0", "<=", "center_offset", "<=", "1", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'center_offset should be in range [0, 1], '", "\n", "f'{center_offset} is given.'", ")", "\n", "", "if", "centers", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "centers", ")", "==", "len", "(", "base_sizes", ")", ",", "(", "\n", "f'The number of base_sizes should be the same as centers, '", "\n", "f'got {base_sizes} and {centers}'", ")", "\n", "\n", "# calculate scales of anchors", "\n", "", "assert", "(", "\n", "(", "octave_base_scale", "is", "not", "None", "and", "scales_per_octave", "is", "not", "None", ")", "^", "\n", "(", "scales", "is", "not", "None", ")", "\n", ")", ",", "(", "'scales and octave_base_scale with scales_per_octave cannot be '", "\n", "'set at the same time'", ")", "\n", "if", "scales", "is", "not", "None", ":", "\n", "            ", "self", ".", "scales", "=", "torch", ".", "Tensor", "(", "scales", ")", "\n", "", "elif", "octave_base_scale", "is", "not", "None", "and", "scales_per_octave", "is", "not", "None", ":", "\n", "            ", "octave_scales", "=", "np", ".", "array", "(", "\n", "[", "2", "**", "(", "i", "/", "scales_per_octave", ")", "for", "i", "in", "range", "(", "scales_per_octave", ")", "]", ")", "\n", "scales", "=", "octave_scales", "*", "octave_base_scale", "\n", "self", ".", "scales", "=", "torch", ".", "Tensor", "(", "scales", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Either scales or octave_base_scale with '", "\n", "'scales_per_octave should be set'", ")", "\n", "\n", "", "self", ".", "base_sizes", "=", "base_sizes", "\n", "self", ".", "centers", "=", "centers", "\n", "self", ".", "center_offset", "=", "center_offset", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.base_anchors.segment.SegmentBaseAnchor.generate": [[57, 67], ["enumerate", "multi_level_base_anchors.append", "segment.SegmentBaseAnchor._single_level_base_anchors"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.base_anchors.segment.SegmentBaseAnchor._single_level_base_anchors"], ["", "def", "generate", "(", "self", ")", ":", "\n", "        ", "multi_level_base_anchors", "=", "[", "]", "\n", "for", "i", ",", "base_size", "in", "enumerate", "(", "self", ".", "base_sizes", ")", ":", "\n", "            ", "center", "=", "None", "\n", "if", "self", ".", "centers", "is", "not", "None", ":", "\n", "                ", "center", "=", "self", ".", "centers", "[", "i", "]", "\n", "", "multi_level_base_anchors", ".", "append", "(", "\n", "self", ".", "_single_level_base_anchors", "(", "base_size", ",", "self", ".", "scales", ",", "\n", "self", ".", "center_offset", ",", "center", ")", ")", "\n", "", "return", "multi_level_base_anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.base_anchors.segment.SegmentBaseAnchor._single_level_base_anchors": [[68, 95], ["torch.stack"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack"], ["", "@", "staticmethod", "\n", "def", "_single_level_base_anchors", "(", "base_size", ",", "\n", "scales", ",", "\n", "center_offset", ",", "\n", "center", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate base anchors of a single level.\n\n        Args:\n            base_size (int | float): Basic temporal size of an anchor.\n            scales (torch.Tensor): Scales of the anchor.\n            center (tuple[float], optional): The center of the base anchor\n                related to a single feature grid. Defaults to None.\n\n        Returns:\n            torch.Tensor: Anchors in a single-level feature maps\n        \"\"\"", "\n", "if", "center", "is", "None", ":", "\n", "            ", "center", "=", "center_offset", "*", "(", "base_size", "-", "1", ")", "\n", "\n", "", "intervals", "=", "base_size", "*", "scales", "\n", "\n", "# use float anchor and the anchor's center is aligned with the", "\n", "# pixel center", "\n", "base_anchors", "=", "[", "center", "-", "0.5", "*", "intervals", ",", "center", "+", "0.5", "*", "intervals", "]", "\n", "base_anchors", "=", "torch", ".", "stack", "(", "base_anchors", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "base_anchors", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.base_anchors.builder.build_base_anchor": [[4, 6], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "import", "torch", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.converters.builder.build_converter": [[4, 6], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "import", "torch", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.converters.segment_anchor_converter.SegmentAnchorConverter.__init__": [[11, 20], ["base_converter.BaseConverter.__init__", "vedatad.misc.segment.build_segment_coder"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.builder.build_segment_coder"], ["    ", "def", "__init__", "(", "self", ",", "num_classes", ",", "nms_pre", ",", "segment_coder", ",", "use_sigmoid", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "segment_coder", "=", "build_segment_coder", "(", "segment_coder", ")", "\n", "self", ".", "use_sigmoid_cls", "=", "use_sigmoid", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "+", "1", "\n", "", "self", ".", "nms_pre", "=", "nms_pre", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.converters.segment_anchor_converter.SegmentAnchorConverter.get_segments": [[21, 64], ["len", "range", "len", "len", "len", "segment_anchor_converter.SegmentAnchorConverter._get_segments_single", "result_list.append", "[].detach", "[].detach", "range", "range"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.converters.segment_anchor_converter.SegmentAnchorConverter._get_segments_single"], ["", "def", "get_segments", "(", "self", ",", "mlvl_anchors", ",", "video_metas", ",", "cls_scores", ",", "\n", "segment_preds", ")", ":", "\n", "        ", "\"\"\"Transform network output for a batch into segment predictions.\n\n        Aapted from https://github.com/open-mmlab/mmdetection\n\n        Args:\n            video_metas (list[dict]): Meta information of each video, e.g.,\n                tsize, tshift, etc.\n            cls_scores (list[Tensor]): Segment scores for each scale level\n                Has shape (N, num_anchors * num_classes, T)\n            segment_preds (list[Tensor]): Segment energies / deltas for each\n                scale level with shape (N, num_anchors * 2, T)\n\n        Returns:\n            list[tuple[Tensor, Tensor, Tensor]]: Each item in result_list is\n                3-tuple. The first item is a (n, 2) tensor, where 2 columns are\n                time points (start, end). The second item is a (n,) tensor\n                where each item is the predicted class score of the segment.\n                The third item is a (n,) tensor where each item is the\n                predicted centerness score of the segment.\n\n        Example:\n        \"\"\"", "\n", "assert", "len", "(", "cls_scores", ")", "==", "len", "(", "segment_preds", ")", "\n", "num_levels", "=", "len", "(", "cls_scores", ")", "\n", "\n", "result_list", "=", "[", "]", "\n", "for", "video_id", "in", "range", "(", "len", "(", "video_metas", ")", ")", ":", "\n", "            ", "cls_score_list", "=", "[", "\n", "cls_scores", "[", "i", "]", "[", "video_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "segment_pred_list", "=", "[", "\n", "segment_preds", "[", "i", "]", "[", "video_id", "]", ".", "detach", "(", ")", "for", "i", "in", "range", "(", "num_levels", ")", "\n", "]", "\n", "# TODO: hard code. 0 for anchor_list, 1 for valid_flag_list", "\n", "anchors", "=", "mlvl_anchors", "[", "0", "]", "[", "video_id", "]", "\n", "proposals", "=", "self", ".", "_get_segments_single", "(", "cls_score_list", ",", "\n", "segment_pred_list", ",", "anchors", ",", "\n", "video_metas", "[", "video_id", "]", ",", "\n", "self", ".", "nms_pre", ")", "\n", "result_list", ".", "append", "(", "proposals", ")", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.converters.segment_anchor_converter.SegmentAnchorConverter._get_segments_single": [[65, 135], ["zip", "torch.cat", "torch.cat", "torch.cat.new_ones().detach", "len", "len", "len", "cls_score.permute().reshape.permute().reshape.permute().reshape", "segment_pred.permute().reshape.permute().reshape.permute().reshape", "segment_anchor_converter.SegmentAnchorConverter.segment_coder.decode", "torch.cat.append", "torch.cat.append", "torch.cat.new_zeros", "torch.cat", "cls_score.permute().reshape.permute().reshape.sigmoid", "cls_score.permute().reshape.permute().reshape.softmax", "max_scores.topk", "torch.cat.new_ones", "cls_score.permute().reshape.permute().reshape.size", "segment_pred.permute().reshape.permute().reshape.size", "cls_score.permute().reshape.permute().reshape.permute", "segment_pred.permute().reshape.permute().reshape.permute", "cls_score.permute().reshape.softmax.max", "scores[].max"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.decode", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "_get_segments_single", "(", "self", ",", "cls_score_list", ",", "segment_pred_list", ",", "\n", "mlvl_anchors", ",", "video_metas", ",", "nms_pre", ")", ":", "\n", "        ", "\"\"\"Transform outputs for a single batch item into segment predictions.\n\n        Aapted from https://github.com/open-mmlab/mmdetection\n\n        Args:\n            cls_score_list (list[Tensor]): Segment scores for a single scale\n                level with shape (num_anchors * num_classes, T).\n            segment_pred_list (list[Tensor]): Segment energies / deltas for a\n                single scale level with shape (num_anchors * 2, T).\n            mlvl_anchors (list[Tensor]): Segment reference for a single scale\n                level with shape (num_total_anchors, 2).\n            video_metas (dict): Meta information of the video, e.g.,\n                tsize, tshift, etc.\n\n        Returns:\n            tuple[Tensor, Tensor, Tensor]: The first item is a (n, 2) tensor,\n                where 2 columns are time points (start, end). The second item\n                is a (n,) tensor where each item is the predicted class score\n                of the segment. The third item is a (n,) tensor where each item\n                is the predicted centerness score of the segment.\n        \"\"\"", "\n", "tsize", "=", "video_metas", "[", "'tsize'", "]", "\n", "tscale_factor", "=", "video_metas", "[", "'tscale_factor'", "]", "\n", "tshift", "=", "video_metas", "[", "'tshift'", "]", "\n", "assert", "(", "len", "(", "cls_score_list", ")", "==", "len", "(", "segment_pred_list", ")", "==", "\n", "len", "(", "mlvl_anchors", ")", ")", "\n", "mlvl_segments", "=", "[", "]", "\n", "mlvl_scores", "=", "[", "]", "\n", "for", "cls_score", ",", "segment_pred", ",", "anchors", "in", "zip", "(", "cls_score_list", ",", "\n", "segment_pred_list", ",", "\n", "mlvl_anchors", ")", ":", "\n", "            ", "assert", "cls_score", ".", "size", "(", ")", "[", "-", "1", "]", "==", "segment_pred", ".", "size", "(", ")", "[", "-", "1", "]", "\n", "cls_score", "=", "cls_score", ".", "permute", "(", "1", ",", "\n", "0", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "cls_out_channels", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                ", "scores", "=", "cls_score", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "                ", "scores", "=", "cls_score", ".", "softmax", "(", "-", "1", ")", "\n", "", "segment_pred", "=", "segment_pred", ".", "permute", "(", "1", ",", "0", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "if", "nms_pre", ">", "0", "and", "scores", ".", "shape", "[", "0", "]", ">", "nms_pre", ":", "\n", "# Get maximum scores for foreground classes.", "\n", "                ", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "                    ", "max_scores", ",", "_", "=", "scores", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "# remind that we set FG labels to [0, num_class-1]", "\n", "# since  v2.0", "\n", "# BG cat_id: num_class", "\n", "                    ", "max_scores", ",", "_", "=", "scores", "[", ":", ",", ":", "-", "1", "]", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "_", ",", "topk_inds", "=", "max_scores", ".", "topk", "(", "nms_pre", ")", "\n", "anchors", "=", "anchors", "[", "topk_inds", ",", ":", "]", "\n", "segment_pred", "=", "segment_pred", "[", "topk_inds", ",", ":", "]", "\n", "scores", "=", "scores", "[", "topk_inds", ",", ":", "]", "\n", "", "segments", "=", "self", ".", "segment_coder", ".", "decode", "(", "\n", "anchors", ",", "segment_pred", ",", "max_t", "=", "tsize", ")", "\n", "mlvl_segments", ".", "append", "(", "segments", ")", "\n", "mlvl_scores", ".", "append", "(", "scores", ")", "\n", "", "mlvl_segments", "=", "torch", ".", "cat", "(", "mlvl_segments", ")", "\n", "mlvl_scores", "=", "torch", ".", "cat", "(", "mlvl_scores", ")", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "# Add a dummy background class to the backend when using sigmoid", "\n", "# remind that we set FG labels to [0, num_class-1] since  v2.0", "\n", "# BG cat_id: num_class", "\n", "            ", "padding", "=", "mlvl_scores", ".", "new_zeros", "(", "mlvl_scores", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "mlvl_scores", "=", "torch", ".", "cat", "(", "[", "mlvl_scores", ",", "padding", "]", ",", "dim", "=", "1", ")", "\n", "", "mlvl_centerness", "=", "mlvl_scores", ".", "new_ones", "(", "mlvl_scores", ".", "shape", "[", "0", "]", ")", ".", "detach", "(", ")", "\n", "mlvl_segments", "+=", "tshift", "\n", "mlvl_segments", "/=", "tscale_factor", "\n", "return", "mlvl_segments", ",", "mlvl_scores", ",", "mlvl_centerness", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.converters.base_converter.BaseConverter.__init__": [[6, 8], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.converters.base_converter.BaseConverter.get_segments": [[9, 12], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_segments", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assembler.trainval.trainval": [[10, 83], ["dict", "dict", "cfg.get", "vedacore.hooks.HookPool", "vedacore.loopers.EpochBasedLooper", "isinstance", "vedacore.loopers.EpochBasedLooper.start", "vedatad.datasets.build_dataset", "vedatad.datasets.build_dataloader", "vedatad.engines.build_engine", "vedatad.datasets.build_dataset", "vedatad.datasets.build_dataloader", "vedatad.engines.build_engine", "vedacore.loopers.EpochBasedLooper.hook_pool.register_hook", "vedacore.loopers.EpochBasedLooper.load_weights", "vedacore.parallel.MMDistributedDataParallel", "vedacore.parallel.MMDataParallel", "dict", "vedacore.parallel.MMDistributedDataParallel", "vedacore.parallel.MMDataParallel", "dict", "vedacore.loopers.EpochBasedLooper.hook_pool.register_hook", "vedacore.loopers.EpochBasedLooper.load_optimizer", "vedacore.loopers.EpochBasedLooper.load_meta", "logger.warning", "logger.warning", "cfg.get", "vedacore.parallel.MMDataParallel.cuda", "vedacore.parallel.MMDataParallel.cuda", "vedacore.parallel.MMDataParallel.cuda", "vedacore.parallel.MMDataParallel.cuda", "dict", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.start", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataloader", "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.builder.build_engine", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataset", "home.repos.pwc.inspect_result.Media-Smart_vedatad.datasets.builder.build_dataloader", "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.builder.build_engine", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.register_hook", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_weights", "home.repos.pwc.inspect_result.Media-Smart_vedatad.hooks.hook_pool.HookPool.register_hook", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_optimizer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.checkpoint.load_meta", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["\n", "\n", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Train a detector'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'train config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'--workdir'", ",", "help", "=", "'the dir to save logs and models'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--launcher'", ",", "\n", "choices", "=", "[", "'none'", ",", "'pytorch'", "]", ",", "\n", "default", "=", "'none'", ",", "\n", "help", "=", "'job launcher'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "# TODO", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "\n", "if", "args", ".", "launcher", "==", "'none'", ":", "\n", "        ", "distributed", "=", "False", "\n", "", "else", ":", "\n", "        ", "distributed", "=", "True", "\n", "init_dist", "(", "args", ".", "launcher", ",", "**", "cfg", ".", "dist_params", ")", "\n", "\n", "# workdir is determined in this priority: CLI > segment in file > filename", "\n", "", "if", "args", ".", "workdir", "is", "not", "None", ":", "\n", "# update configs according to CLI args if args.work_dir is not None", "\n", "        ", "cfg", ".", "workdir", "=", "args", ".", "workdir", "\n", "", "elif", "cfg", ".", "get", "(", "'workdir'", ",", "None", ")", "is", "None", ":", "\n", "# use config filename as default work_dir if cfg.work_dir is None", "\n", "        ", "cfg", ".", "workdir", "=", "osp", ".", "join", "(", "'./workdir'", ",", "\n", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "args", ".", "config", ")", ")", "[", "0", "]", ")", "\n", "\n", "", "seed", "=", "cfg", ".", "get", "(", "'seed'", ",", "None", ")", "\n", "deterministic", "=", "cfg", ".", "get", "(", "'deterministic'", ",", "False", ")", "\n", "set_random_seed", "(", "seed", ",", "deterministic", ")", "\n", "\n", "# create work_dir", "\n", "mkdir_or_exist", "(", "osp", ".", "abspath", "(", "cfg", ".", "workdir", ")", ")", "\n", "shutil", ".", "copy", "(", "args", ".", "config", ",", "cfg", ".", "workdir", ")", "\n", "# init the logger before other steps", "\n", "timestamp", "=", "time", ".", "strftime", "(", "'%Y%m%d_%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "cfg", ".", "workdir", ",", "f'{timestamp}.log'", ")", "\n", "logger", "=", "get_root_logger", "(", "log_file", "=", "log_file", ",", "log_level", "=", "cfg", ".", "log_level", ")", "\n", "\n", "trainval", "(", "cfg", ",", "distributed", ",", "logger", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build": [[6, 27], ["isinstance", "torch.Sequential", "vedacore.misc.build_from_cfg", "vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "from", "vedacore", ".", "misc", "import", "build_from_cfg", ",", "registry", "\n", "\n", "\n", "def", "register_torch_optimizers", "(", ")", ":", "\n", "    ", "torch_optimizers", "=", "[", "]", "\n", "for", "module_name", "in", "dir", "(", "torch", ".", "optim", ")", ":", "\n", "        ", "if", "module_name", ".", "startswith", "(", "'__'", ")", ":", "\n", "            ", "continue", "\n", "", "_optim", "=", "getattr", "(", "torch", ".", "optim", ",", "module_name", ")", "\n", "if", "inspect", ".", "isclass", "(", "_optim", ")", "and", "issubclass", "(", "_optim", ",", "\n", "torch", ".", "optim", ".", "Optimizer", ")", ":", "\n", "            ", "registry", ".", "register_module", "(", "'optimizer'", ")", "(", "_optim", ")", "\n", "torch_optimizers", ".", "append", "(", "module_name", ")", "\n", "", "", "return", "torch_optimizers", "\n", "\n", "\n", "", "register_torch_optimizers", "(", ")", "\n", "\n", "\n", "def", "build_optimizer_constructor", "(", "cfg", ")", ":", "\n", "    ", "return", "build_from_cfg", "(", "cfg", ",", "registry", ",", "'optimizer_builder'", ")", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build_backbone": [[29, 32], ["builder.build"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build"], ["\n", "", "def", "build_optimizer", "(", "model", ",", "cfg", ")", ":", "\n", "    ", "optimizer_cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "constructor_type", "=", "optimizer_cfg", ".", "pop", "(", "'constructor'", ",", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build_neck": [[34, 37], ["builder.build"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build"], ["paramwise_cfg", "=", "optimizer_cfg", ".", "pop", "(", "'paramwise_cfg'", ",", "None", ")", "\n", "optim_constructor", "=", "build_optimizer_constructor", "(", "\n", "dict", "(", "\n", "typename", "=", "constructor_type", ",", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build_head": [[39, 42], ["builder.build"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build"], ["paramwise_cfg", "=", "paramwise_cfg", ")", ")", "\n", "optimizer", "=", "optim_constructor", "(", "model", ")", "\n", "return", "optimizer", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build_detector": [[44, 47], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.srm.SRM.__init__": [[10, 13], ["torch.Module.__init__", "vedacore.misc.build_from_module"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_module"], ["def", "__init__", "(", "self", ",", "srm_cfg", ")", ":", "\n", "        ", "super", "(", "SRM", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "srm", "=", "build_from_module", "(", "srm_cfg", ",", "nn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.srm.SRM.init_weights": [[14, 16], ["None"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.srm.SRM.forward": [[17, 22], ["srm.SRM.srm", "x.squeeze().squeeze.squeeze().squeeze.squeeze().squeeze", "x.squeeze().squeeze.squeeze().squeeze.squeeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "srm", "(", "x", ")", "\n", "x", "=", "x", ".", "squeeze", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.fpn.FPN.__init__": [[66, 158], ["dict", "torch.Module.__init__", "isinstance", "len", "upsample_cfg.copy", "isinstance", "isinstance", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "vedacore.modules.ConvModule", "vedacore.modules.ConvModule", "fpn.FPN.lateral_convs.append", "fpn.FPN.fpn_convs.append", "range", "len", "vedacore.modules.ConvModule", "fpn.FPN.fpn_convs.append"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "num_outs", ",", "\n", "start_level", "=", "0", ",", "\n", "end_level", "=", "-", "1", ",", "\n", "add_extra_convs", "=", "False", ",", "\n", "extra_convs_on_inputs", "=", "True", ",", "\n", "relu_before_extra_convs", "=", "False", ",", "\n", "no_norm_on_lateral", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "None", ",", "\n", "upsample_cfg", "=", "dict", "(", "mode", "=", "'nearest'", ")", ")", ":", "\n", "        ", "super", "(", "FPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "list", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "\n", "self", ".", "num_outs", "=", "num_outs", "\n", "self", ".", "relu_before_extra_convs", "=", "relu_before_extra_convs", "\n", "self", ".", "no_norm_on_lateral", "=", "no_norm_on_lateral", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "self", ".", "upsample_cfg", "=", "upsample_cfg", ".", "copy", "(", ")", "\n", "\n", "if", "end_level", "==", "-", "1", ":", "\n", "            ", "self", ".", "backbone_end_level", "=", "self", ".", "num_ins", "\n", "assert", "num_outs", ">=", "self", ".", "num_ins", "-", "start_level", "\n", "", "else", ":", "\n", "# if end_level < inputs, no extra level is allowed", "\n", "            ", "self", ".", "backbone_end_level", "=", "end_level", "\n", "assert", "end_level", "<=", "len", "(", "in_channels", ")", "\n", "assert", "num_outs", "==", "end_level", "-", "start_level", "\n", "", "self", ".", "start_level", "=", "start_level", "\n", "self", ".", "end_level", "=", "end_level", "\n", "self", ".", "add_extra_convs", "=", "add_extra_convs", "\n", "assert", "isinstance", "(", "add_extra_convs", ",", "(", "str", ",", "bool", ")", ")", "\n", "if", "isinstance", "(", "add_extra_convs", ",", "str", ")", ":", "\n", "# Extra_convs_source choices: 'on_input', 'on_lateral', 'on_output'", "\n", "            ", "assert", "add_extra_convs", "in", "(", "'on_input'", ",", "'on_lateral'", ",", "'on_output'", ")", "\n", "", "elif", "add_extra_convs", ":", "# True", "\n", "            ", "if", "extra_convs_on_inputs", ":", "\n", "# For compatibility with previous release", "\n", "# TODO: deprecate `extra_convs_on_inputs`", "\n", "                ", "self", ".", "add_extra_convs", "=", "'on_input'", "\n", "", "else", ":", "\n", "                ", "self", ".", "add_extra_convs", "=", "'on_output'", "\n", "\n", "", "", "self", ".", "lateral_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "fpn_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "start_level", ",", "self", ".", "backbone_end_level", ")", ":", "\n", "            ", "l_conv", "=", "ConvModule", "(", "\n", "in_channels", "[", "i", "]", ",", "\n", "out_channels", ",", "\n", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", "if", "not", "self", ".", "no_norm_on_lateral", "else", "None", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "fpn_conv", "=", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "\n", "self", ".", "lateral_convs", ".", "append", "(", "l_conv", ")", "\n", "self", ".", "fpn_convs", ".", "append", "(", "fpn_conv", ")", "\n", "\n", "# add extra conv layers (e.g., RetinaNet)", "\n", "", "extra_levels", "=", "num_outs", "-", "self", ".", "backbone_end_level", "+", "self", ".", "start_level", "\n", "if", "self", ".", "add_extra_convs", "and", "extra_levels", ">=", "1", ":", "\n", "            ", "for", "i", "in", "range", "(", "extra_levels", ")", ":", "\n", "                ", "if", "i", "==", "0", "and", "self", ".", "add_extra_convs", "==", "'on_input'", ":", "\n", "                    ", "in_channels", "=", "self", ".", "in_channels", "[", "self", ".", "backbone_end_level", "-", "1", "]", "\n", "", "else", ":", "\n", "                    ", "in_channels", "=", "out_channels", "\n", "", "extra_fpn_conv", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "self", ".", "fpn_convs", ".", "append", "(", "extra_fpn_conv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.fpn.FPN.init_weights": [[160, 165], ["fpn.FPN.modules", "isinstance", "vedacore.modules.xavier_init"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.xavier_init"], ["", "", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the weights of FPN module.\"\"\"", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "_ConvNd", ")", ":", "\n", "                ", "xavier_init", "(", "m", ",", "distribution", "=", "'uniform'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.fpn.FPN.forward": [[166, 221], ["len", "range", "tuple", "len", "len", "lateral_conv", "len", "enumerate", "torch.interpolate", "torch.interpolate", "tuple", "torch.interpolate", "torch.interpolate", "range", "range", "outs.append", "range", "map", "outs.append", "torch.max_pool2d", "torch.max_pool2d", "outs.append", "outs.append", "int", "torch.relu", "torch.relu"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "assert", "len", "(", "inputs", ")", "==", "len", "(", "self", ".", "in_channels", ")", "\n", "\n", "# build laterals", "\n", "laterals", "=", "[", "\n", "lateral_conv", "(", "inputs", "[", "i", "+", "self", ".", "start_level", "]", ")", "\n", "for", "i", ",", "lateral_conv", "in", "enumerate", "(", "self", ".", "lateral_convs", ")", "\n", "]", "\n", "\n", "# build top-down path", "\n", "used_backbone_levels", "=", "len", "(", "laterals", ")", "\n", "for", "i", "in", "range", "(", "used_backbone_levels", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "# In some cases, fixing `scale factor` (e.g. 2) is preferred, but", "\n", "#  it cannot co-exist with `size` in `F.interpolate`.", "\n", "            ", "if", "'scale_factor'", "in", "self", ".", "upsample_cfg", ":", "\n", "                ", "laterals", "[", "i", "-", "1", "]", "+=", "F", ".", "interpolate", "(", "laterals", "[", "i", "]", ",", "\n", "**", "self", ".", "upsample_cfg", ")", "\n", "", "else", ":", "\n", "                ", "prev_shape", "=", "laterals", "[", "i", "-", "1", "]", ".", "shape", "[", "2", ":", "]", "\n", "# This is a workaround when converting PyTorch model", "\n", "# to ONNX model", "\n", "prev_shape", "=", "tuple", "(", "map", "(", "lambda", "x", ":", "int", "(", "x", ")", ",", "prev_shape", ")", ")", "\n", "laterals", "[", "i", "-", "1", "]", "+=", "F", ".", "interpolate", "(", "\n", "laterals", "[", "i", "]", ",", "size", "=", "prev_shape", ",", "**", "self", ".", "upsample_cfg", ")", "\n", "\n", "# build outputs", "\n", "# part 1: from original levels", "\n", "", "", "outs", "=", "[", "\n", "self", ".", "fpn_convs", "[", "i", "]", "(", "laterals", "[", "i", "]", ")", "for", "i", "in", "range", "(", "used_backbone_levels", ")", "\n", "]", "\n", "# part 2: add extra levels", "\n", "if", "self", ".", "num_outs", ">", "len", "(", "outs", ")", ":", "\n", "# use max pool to get more levels on top of outputs", "\n", "# (e.g., Faster R-CNN, Mask R-CNN)", "\n", "            ", "if", "not", "self", ".", "add_extra_convs", ":", "\n", "                ", "for", "i", "in", "range", "(", "self", ".", "num_outs", "-", "used_backbone_levels", ")", ":", "\n", "                    ", "outs", ".", "append", "(", "F", ".", "max_pool2d", "(", "outs", "[", "-", "1", "]", ",", "1", ",", "stride", "=", "2", ")", ")", "\n", "# add conv layers on top of original feature maps (RetinaNet)", "\n", "", "", "else", ":", "\n", "                ", "if", "self", ".", "add_extra_convs", "==", "'on_input'", ":", "\n", "                    ", "extra_source", "=", "inputs", "[", "self", ".", "backbone_end_level", "-", "1", "]", "\n", "", "elif", "self", ".", "add_extra_convs", "==", "'on_lateral'", ":", "\n", "                    ", "extra_source", "=", "laterals", "[", "-", "1", "]", "\n", "", "elif", "self", ".", "add_extra_convs", "==", "'on_output'", ":", "\n", "                    ", "extra_source", "=", "outs", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "                    ", "raise", "NotImplementedError", "\n", "", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "used_backbone_levels", "]", "(", "extra_source", ")", ")", "\n", "for", "i", "in", "range", "(", "used_backbone_levels", "+", "1", ",", "self", ".", "num_outs", ")", ":", "\n", "                    ", "if", "self", ".", "relu_before_extra_convs", ":", "\n", "                        ", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "i", "]", "(", "F", ".", "relu", "(", "outs", "[", "-", "1", "]", ")", ")", ")", "\n", "", "else", ":", "\n", "                        ", "outs", ".", "append", "(", "self", ".", "fpn_convs", "[", "i", "]", "(", "outs", "[", "-", "1", "]", ")", ")", "\n", "", "", "", "", "return", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.tdm.TDM.__init__": [[14, 57], ["dict", "dict", "dict", "torch.Module.__init__", "len", "range", "torch.nn.modules.utils._ntuple", "torch.nn.modules.utils._ntuple", "torch.nn.modules.utils._ntuple", "torch.nn.modules.utils._ntuple", "torch.nn.modules.utils._ntuple", "len", "len", "len", "len", "len", "len", "tdm.TDM.make_td_layer", "tdm.TDM.add_module", "tdm.TDM.td_layers.append"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.tdm.TDM.make_td_layer"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "stage_layers", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "kernel_sizes", "=", "3", ",", "\n", "strides", "=", "2", ",", "\n", "paddings", "=", "1", ",", "\n", "dilations", "=", "1", ",", "\n", "out_channels", "=", "256", ",", "\n", "conv_cfg", "=", "dict", "(", "typename", "=", "'Conv1d'", ")", ",", "\n", "norm_cfg", "=", "dict", "(", "typename", "=", "'BN1d'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "typename", "=", "'ReLU'", ")", ",", "\n", "out_indices", "=", "(", "0", ",", "1", ",", "2", ",", "3", ",", "4", ")", ")", ":", "\n", "        ", "super", "(", "TDM", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "num_stages", "=", "len", "(", "stage_layers", ")", "\n", "self", ".", "stage_layers", "=", "stage_layers", "\n", "self", ".", "kernel_sizes", "=", "_ntuple", "(", "self", ".", "num_stages", ")", "(", "kernel_sizes", ")", "\n", "self", ".", "strides", "=", "_ntuple", "(", "self", ".", "num_stages", ")", "(", "strides", ")", "\n", "self", ".", "paddings", "=", "_ntuple", "(", "self", ".", "num_stages", ")", "(", "paddings", ")", "\n", "self", ".", "dilations", "=", "_ntuple", "(", "self", ".", "num_stages", ")", "(", "dilations", ")", "\n", "self", ".", "out_channels", "=", "_ntuple", "(", "self", ".", "num_stages", ")", "(", "out_channels", ")", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "act_cfg", "=", "act_cfg", "\n", "self", ".", "out_indices", "=", "out_indices", "\n", "\n", "assert", "(", "len", "(", "self", ".", "stage_layers", ")", "==", "len", "(", "self", ".", "kernel_sizes", ")", "==", "len", "(", "\n", "self", ".", "strides", ")", "==", "len", "(", "self", ".", "paddings", ")", "==", "len", "(", "self", ".", "dilations", ")", "==", "len", "(", "\n", "self", ".", "out_channels", ")", ")", "\n", "\n", "self", ".", "td_layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_stages", ")", ":", "\n", "            ", "td_layer", "=", "self", ".", "make_td_layer", "(", "self", ".", "stage_layers", "[", "i", "]", ",", "in_channels", ",", "\n", "self", ".", "out_channels", "[", "i", "]", ",", "\n", "self", ".", "kernel_sizes", "[", "i", "]", ",", "\n", "self", ".", "strides", "[", "i", "]", ",", "self", ".", "paddings", "[", "i", "]", ",", "\n", "self", ".", "dilations", "[", "i", "]", ",", "self", ".", "conv_cfg", ",", "\n", "self", ".", "norm_cfg", ",", "self", ".", "act_cfg", ")", "\n", "in_channels", "=", "self", ".", "out_channels", "[", "i", "]", "\n", "layer_name", "=", "f'layer{i + 1}'", "\n", "self", ".", "add_module", "(", "layer_name", ",", "td_layer", ")", "\n", "self", ".", "td_layers", ".", "append", "(", "layer_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.tdm.TDM.make_td_layer": [[58, 84], ["layers.append", "range", "torch.Sequential", "vedacore.modules.ConvModule", "layers.append", "vedacore.modules.ConvModule"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "make_td_layer", "(", "num_layer", ",", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "\n", "stride", ",", "padding", ",", "dilation", ",", "conv_cfg", ",", "norm_cfg", ",", "act_cfg", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "dilation", "=", "dilation", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ")", ")", "\n", "for", "_", "in", "range", "(", "1", ",", "num_layer", ")", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.tdm.TDM.init_weights": [[85, 92], ["tdm.TDM.modules", "isinstance", "vedacore.modules.kaiming_init", "isinstance", "vedacore.modules.constant_init"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.kaiming_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.constant_init"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initiate the parameters.\"\"\"", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "_ConvNd", ")", ":", "\n", "                ", "kaiming_init", "(", "m", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "_BatchNorm", ")", ":", "\n", "                ", "constant_init", "(", "m", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.tdm.TDM.train": [[93, 101], ["super().train", "tdm.TDM.modules", "isinstance", "m.eval"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.train"], ["", "", "", "def", "train", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "\"\"\"Set the optimization status when training.\"\"\"", "\n", "super", "(", ")", ".", "train", "(", "mode", ")", "\n", "\n", "if", "mode", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "_BatchNorm", ")", ":", "\n", "                    ", "m", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.necks.tdm.TDM.forward": [[102, 116], ["enumerate", "tuple", "outs.append", "getattr", "getattr.", "len", "outs.append"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "outs", "=", "[", "]", "\n", "if", "0", "in", "self", ".", "out_indices", ":", "\n", "            ", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "for", "i", ",", "layer_name", "in", "enumerate", "(", "self", ".", "td_layers", ")", ":", "\n", "            ", "layer", "=", "getattr", "(", "self", ",", "layer_name", ")", "\n", "x", "=", "layer", "(", "x", ")", "\n", "if", "(", "i", "+", "1", ")", "in", "self", ".", "out_indices", ":", "\n", "                ", "outs", ".", "append", "(", "x", ")", "\n", "", "", "if", "len", "(", "outs", ")", "==", "1", ":", "\n", "            ", "return", "outs", "[", "0", "]", "\n", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.detectors.base_detector.BaseDetector.__init__": [[6, 8], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.detectors.single_stage_detector.SingleStageDetector.__init__": [[12, 22], ["base_detector.BaseDetector.__init__", "builder.build_backbone", "builder.build_head", "single_stage_detector.SingleStageDetector.init_weights", "builder.build_neck"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build_backbone", "home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build_head", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights", "home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build_neck"], ["    ", "def", "__init__", "(", "self", ",", "backbone", ",", "head", ",", "neck", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "backbone", ")", "\n", "if", "neck", ":", "\n", "            ", "self", ".", "neck", "=", "build_neck", "(", "neck", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "neck", "=", "None", "\n", "", "self", ".", "head", "=", "build_head", "(", "head", ")", "\n", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.detectors.single_stage_detector.SingleStageDetector.init_weights": [[23, 33], ["single_stage_detector.SingleStageDetector.backbone.init_weights", "single_stage_detector.SingleStageDetector.head.init_weights", "isinstance", "single_stage_detector.SingleStageDetector.neck.init_weights", "m.init_weights"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "self", ".", "backbone", ".", "init_weights", "(", ")", "\n", "if", "self", ".", "neck", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "neck", ",", "nn", ".", "Sequential", ")", ":", "\n", "                ", "for", "m", "in", "self", ".", "neck", ":", "\n", "                    ", "m", ".", "init_weights", "(", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "neck", ".", "init_weights", "(", ")", "\n", "\n", "", "", "self", ".", "head", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.detectors.single_stage_detector.SingleStageDetector.forward_impl": [[34, 40], ["single_stage_detector.SingleStageDetector.backbone", "single_stage_detector.SingleStageDetector.head", "single_stage_detector.SingleStageDetector.neck"], "methods", ["None"], ["", "def", "forward_impl", "(", "self", ",", "x", ")", ":", "\n", "        ", "feats", "=", "self", ".", "backbone", "(", "x", ")", "\n", "if", "self", ".", "neck", ":", "\n", "            ", "feats", "=", "self", ".", "neck", "(", "feats", ")", "\n", "", "feats", "=", "self", ".", "head", "(", "feats", ")", "\n", "return", "feats", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.detectors.single_stage_detector.SingleStageDetector.forward": [[41, 50], ["single_stage_detector.SingleStageDetector.train", "single_stage_detector.SingleStageDetector.forward_impl", "single_stage_detector.SingleStageDetector.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "single_stage_detector.SingleStageDetector.forward_impl"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.train", "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.forward_impl", "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.forward_impl"], ["", "def", "forward", "(", "self", ",", "x", ",", "train", "=", "True", ")", ":", "\n", "        ", "if", "train", ":", "\n", "            ", "self", ".", "train", "(", ")", "\n", "feats", "=", "self", ".", "forward_impl", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "feats", "=", "self", ".", "forward_impl", "(", "x", ")", "\n", "", "", "return", "feats", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.base_dense_head.BaseDenseHead.__init__": [[11, 13], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "BaseDenseHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.retina_head.RetinaHead.__init__": [[30, 43], ["anchor_head.AnchorHead.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "num_anchors", ",", "\n", "in_channels", ",", "\n", "stacked_convs", "=", "4", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "stacked_convs", "=", "stacked_convs", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "super", "(", "RetinaHead", ",", "self", ")", ".", "__init__", "(", "num_classes", ",", "num_anchors", ",", "in_channels", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.retina_head.RetinaHead._init_layers": [[44, 76], ["torch.ReLU", "torch.ModuleList", "torch.ModuleList", "range", "torch.Conv1d", "torch.Conv1d", "retina_head.RetinaHead.cls_convs.append", "retina_head.RetinaHead.reg_convs.append", "vedacore.modules.ConvModule", "vedacore.modules.ConvModule"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "cls_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reg_convs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "stacked_convs", ")", ":", "\n", "            ", "chn", "=", "self", ".", "in_channels", "if", "i", "==", "0", "else", "self", ".", "feat_channels", "\n", "self", ".", "cls_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "self", ".", "reg_convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "chn", ",", "\n", "self", ".", "feat_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ")", ")", "\n", "", "self", ".", "retina_cls", "=", "nn", ".", "Conv1d", "(", "\n", "self", ".", "feat_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "retina_reg", "=", "nn", ".", "Conv1d", "(", "\n", "self", ".", "feat_channels", ",", "self", ".", "num_anchors", "*", "2", ",", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.retina_head.RetinaHead.init_weights": [[77, 86], ["vedacore.modules.bias_init_with_prob", "vedacore.modules.normal_init", "vedacore.modules.normal_init", "vedacore.modules.normal_init", "vedacore.modules.normal_init"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.bias_init_with_prob", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "for", "m", "in", "self", ".", "cls_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "for", "m", "in", "self", ".", "reg_convs", ":", "\n", "            ", "normal_init", "(", "m", ".", "conv", ",", "std", "=", "0.01", ")", "\n", "", "bias_cls", "=", "bias_init_with_prob", "(", "0.01", ")", "\n", "normal_init", "(", "self", ".", "retina_cls", ",", "std", "=", "0.01", ",", "bias", "=", "bias_cls", ")", "\n", "normal_init", "(", "self", ".", "retina_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.retina_head.RetinaHead.forward_single": [[87, 109], ["retina_head.RetinaHead.retina_cls", "retina_head.RetinaHead.retina_reg", "cls_conv", "reg_conv"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature of a single scale level.\n\n        Args:\n            x (Tensor): Features of a single scale level.\n\n        Returns:\n            tuple:\n                cls_score (Tensor): Cls scores for a single scale level\n                    the channels number is num_anchors * num_classes.\n                segment_pred (Tensor): Box energies / deltas for a single scale\n                    level, the channels number is num_anchors * 2.\n        \"\"\"", "\n", "cls_feat", "=", "x", "\n", "reg_feat", "=", "x", "\n", "for", "cls_conv", "in", "self", ".", "cls_convs", ":", "\n", "            ", "cls_feat", "=", "cls_conv", "(", "cls_feat", ")", "\n", "", "for", "reg_conv", "in", "self", ".", "reg_convs", ":", "\n", "            ", "reg_feat", "=", "reg_conv", "(", "reg_feat", ")", "\n", "", "cls_score", "=", "self", ".", "retina_cls", "(", "cls_feat", ")", "\n", "segment_pred", "=", "self", ".", "retina_reg", "(", "reg_feat", ")", "\n", "return", "cls_score", ",", "segment_pred", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.anchor_head.AnchorHead.__init__": [[21, 41], ["base_dense_head.BaseDenseHead.__init__", "anchor_head.AnchorHead._init_layers", "ValueError"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.anchor_head.AnchorHead._init_layers"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "num_anchors", ",", "\n", "in_channels", ",", "\n", "feat_channels", "=", "256", ",", "\n", "use_sigmoid", "=", "True", ")", ":", "\n", "        ", "super", "(", "AnchorHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "num_anchors", "=", "num_anchors", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "feat_channels", "=", "feat_channels", "\n", "if", "use_sigmoid", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "+", "1", "\n", "\n", "", "if", "self", ".", "cls_out_channels", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "f'num_classes={num_classes} is too small'", ")", "\n", "\n", "", "self", ".", "_init_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.anchor_head.AnchorHead._init_layers": [[42, 47], ["torch.Conv1d", "torch.Conv1d"], "methods", ["None"], ["", "def", "_init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize layers of the head.\"\"\"", "\n", "self", ".", "conv_cls", "=", "nn", ".", "Conv1d", "(", "self", ".", "in_channels", ",", "\n", "self", ".", "num_anchors", "*", "self", ".", "cls_out_channels", ",", "1", ")", "\n", "self", ".", "conv_reg", "=", "nn", ".", "Conv1d", "(", "self", ".", "in_channels", ",", "self", ".", "num_anchors", "*", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.anchor_head.AnchorHead.init_weights": [[48, 52], ["vedacore.modules.normal_init", "vedacore.modules.normal_init"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.normal_init"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize weights of the head.\"\"\"", "\n", "normal_init", "(", "self", ".", "conv_cls", ",", "std", "=", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv_reg", ",", "std", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.anchor_head.AnchorHead.forward_single": [[53, 69], ["anchor_head.AnchorHead.conv_cls", "anchor_head.AnchorHead.conv_reg"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward feature of a single scale level.\n\n        Args:\n            x (Tensor): Features of a single scale level.\n\n        Returns:\n            tuple:\n                cls_score (Tensor): Cls scores for a single scale level\n                    the channels number is num_anchors * num_classes.\n                segment_pred (Tensor): Segment energies / deltas for a single\n                    scale level, the channels number is num_anchors * 2.\n        \"\"\"", "\n", "cls_score", "=", "self", ".", "conv_cls", "(", "x", ")", "\n", "segment_pred", "=", "self", ".", "conv_reg", "(", "x", ")", "\n", "return", "cls_score", ",", "segment_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.heads.anchor_head.AnchorHead.forward": [[70, 88], ["vedacore.misc.multi_apply"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.multi_apply"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"Forward features from the upstream network.\n\n        Args:\n            feats (tuple[Tensor]): Features from the upstream network, each is\n                a 3D-tensor.\n\n        Returns:\n            tuple: Usually a tuple of classification scores and segment\n                prediction.\n                cls_scores (list[Tensor]): Classification scores for all scale\n                    levels, each is a 3D-tensor, the channels number is\n                    num_anchors * num_classes.\n                segment_preds (list[Tensor]): Segment energies / deltas for all\n                    scale levels, each is a 3D-tensor, the channels number is\n                    num_anchors * 2.\n        \"\"\"", "\n", "return", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.BasicBlock3d.__init__": [[43, 124], ["dict", "dict", "dict", "dict", "torch.Module.__init__", "set().issubset", "vedacore.modules.ConvModule", "vedacore.modules.ConvModule", "vedacore.modules.build_activation_layer", "vedacore.modules.build_enhance_module", "set", "dict"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.activation.build_activation_layer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.enhance_module.build_enhance_module"], ["def", "__init__", "(", "self", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "spatial_stride", "=", "1", ",", "\n", "temporal_stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "downsample", "=", "None", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "inflate", "=", "True", ",", "\n", "enhance", "=", "False", ",", "\n", "enhance_cfg", "=", "dict", "(", ")", ",", "\n", "conv_cfg", "=", "dict", "(", "typename", "=", "'Conv3d'", ")", ",", "\n", "norm_cfg", "=", "dict", "(", "typename", "=", "'BN3d'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "typename", "=", "'ReLU'", ")", ",", "\n", "with_cp", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "style", "in", "[", "'pytorch'", ",", "'caffe'", "]", "\n", "# make sure that only ``inflate_style`` is passed into kwargs", "\n", "assert", "set", "(", "kwargs", ")", ".", "issubset", "(", "[", "'inflate_style'", "]", ")", "\n", "\n", "self", ".", "inplanes", "=", "inplanes", "\n", "self", ".", "planes", "=", "planes", "\n", "self", ".", "spatial_stride", "=", "spatial_stride", "\n", "self", ".", "temporal_stride", "=", "temporal_stride", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "style", "=", "style", "\n", "self", ".", "inflate", "=", "inflate", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "act_cfg", "=", "act_cfg", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "self", ".", "enhance", "=", "enhance", "\n", "self", ".", "enhance_cfg", "=", "enhance_cfg", "\n", "\n", "self", ".", "conv1_stride_s", "=", "spatial_stride", "\n", "self", ".", "conv2_stride_s", "=", "1", "\n", "self", ".", "conv1_stride_t", "=", "temporal_stride", "\n", "self", ".", "conv2_stride_t", "=", "1", "\n", "\n", "if", "self", ".", "inflate", ":", "\n", "            ", "conv1_kernel_size", "=", "(", "3", ",", "3", ",", "3", ")", "\n", "conv1_padding", "=", "(", "1", ",", "dilation", ",", "dilation", ")", "\n", "conv2_kernel_size", "=", "(", "3", ",", "3", ",", "3", ")", "\n", "conv2_padding", "=", "(", "1", ",", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "conv1_kernel_size", "=", "(", "1", ",", "3", ",", "3", ")", "\n", "conv1_padding", "=", "(", "0", ",", "dilation", ",", "dilation", ")", "\n", "conv2_kernel_size", "=", "(", "1", ",", "3", ",", "3", ")", "\n", "conv2_padding", "=", "(", "0", ",", "1", ",", "1", ")", "\n", "\n", "", "self", ".", "conv1", "=", "ConvModule", "(", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "conv1_kernel_size", ",", "\n", "stride", "=", "(", "self", ".", "conv1_stride_t", ",", "self", ".", "conv1_stride_s", ",", "\n", "self", ".", "conv1_stride_s", ")", ",", "\n", "padding", "=", "conv1_padding", ",", "\n", "dilation", "=", "(", "1", ",", "dilation", ",", "dilation", ")", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "act_cfg", "=", "self", ".", "act_cfg", ")", "\n", "\n", "self", ".", "conv2", "=", "ConvModule", "(", "\n", "planes", ",", "\n", "planes", "*", "self", ".", "expansion", ",", "\n", "conv2_kernel_size", ",", "\n", "stride", "=", "(", "self", ".", "conv2_stride_t", ",", "self", ".", "conv2_stride_s", ",", "\n", "self", ".", "conv2_stride_s", ")", ",", "\n", "padding", "=", "conv2_padding", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "relu", "=", "build_activation_layer", "(", "self", ".", "act_cfg", ")", "\n", "\n", "if", "self", ".", "enhance", ":", "\n", "            ", "self", ".", "enhance_module", "=", "build_enhance_module", "(", "\n", "self", ".", "enhance_cfg", ",", "\n", "default_args", "=", "dict", "(", "in_channels", "=", "self", ".", "conv2", ".", "norm", ".", "num_features", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.BasicBlock3d.forward": [[125, 151], ["resnet3d.BasicBlock3d.relu", "resnet3d.BasicBlock3d.conv1", "resnet3d.BasicBlock3d.conv2", "torch.checkpoint", "torch.checkpoint", "resnet3d.BasicBlock3d.forward._inner_forward"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Defines the computation performed at every call.\"\"\"", "\n", "\n", "def", "_inner_forward", "(", "x", ")", ":", "\n", "            ", "\"\"\"Forward wrapper for utilizing checkpoint.\"\"\"", "\n", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "                ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "=", "out", "+", "identity", "\n", "return", "out", "\n", "\n", "", "if", "self", ".", "with_cp", "and", "x", ".", "requires_grad", ":", "\n", "            ", "out", "=", "cp", ".", "checkpoint", "(", "_inner_forward", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "_inner_forward", "(", "x", ")", "\n", "", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "enhance", ":", "\n", "            ", "out", "=", "self", ".", "enhance_module", "(", "out", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.Bottleneck3d.__init__": [[184, 286], ["dict", "dict", "dict", "dict", "torch.Module.__init__", "vedacore.modules.ConvModule", "vedacore.modules.ConvModule", "vedacore.modules.ConvModule", "vedacore.modules.build_activation_layer", "vedacore.modules.build_enhance_module", "dict"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.activation.build_activation_layer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.bricks.enhance_module.build_enhance_module"], ["def", "__init__", "(", "self", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "spatial_stride", "=", "1", ",", "\n", "temporal_stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "downsample", "=", "None", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "inflate", "=", "True", ",", "\n", "inflate_style", "=", "'3x1x1'", ",", "\n", "enhance", "=", "False", ",", "\n", "enhance_cfg", "=", "dict", "(", ")", ",", "\n", "conv_cfg", "=", "dict", "(", "type", "=", "'Conv3d'", ")", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN3d'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ",", "\n", "with_cp", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "style", "in", "[", "'pytorch'", ",", "'caffe'", "]", "\n", "assert", "inflate_style", "in", "[", "'3x1x1'", ",", "'3x3x3'", "]", "\n", "\n", "self", ".", "inplanes", "=", "inplanes", "\n", "self", ".", "planes", "=", "planes", "\n", "self", ".", "spatial_stride", "=", "spatial_stride", "\n", "self", ".", "temporal_stride", "=", "temporal_stride", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "style", "=", "style", "\n", "self", ".", "inflate", "=", "inflate", "\n", "self", ".", "inflate_style", "=", "inflate_style", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "act_cfg", "=", "act_cfg", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "self", ".", "enhance", "=", "enhance", "\n", "self", ".", "enhance_cfg", "=", "enhance_cfg", "\n", "\n", "if", "self", ".", "style", "==", "'pytorch'", ":", "\n", "            ", "self", ".", "conv1_stride_s", "=", "1", "\n", "self", ".", "conv2_stride_s", "=", "spatial_stride", "\n", "self", ".", "conv1_stride_t", "=", "1", "\n", "self", ".", "conv2_stride_t", "=", "temporal_stride", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv1_stride_s", "=", "spatial_stride", "\n", "self", ".", "conv2_stride_s", "=", "1", "\n", "self", ".", "conv1_stride_t", "=", "temporal_stride", "\n", "self", ".", "conv2_stride_t", "=", "1", "\n", "\n", "", "if", "self", ".", "inflate", ":", "\n", "            ", "if", "inflate_style", "==", "'3x1x1'", ":", "\n", "                ", "conv1_kernel_size", "=", "(", "3", ",", "1", ",", "1", ")", "\n", "conv1_padding", "=", "(", "1", ",", "0", ",", "0", ")", "\n", "conv2_kernel_size", "=", "(", "1", ",", "3", ",", "3", ")", "\n", "conv2_padding", "=", "(", "0", ",", "dilation", ",", "dilation", ")", "\n", "", "else", ":", "\n", "                ", "conv1_kernel_size", "=", "(", "1", ",", "1", ",", "1", ")", "\n", "conv1_padding", "=", "(", "0", ",", "0", ",", "0", ")", "\n", "conv2_kernel_size", "=", "(", "3", ",", "3", ",", "3", ")", "\n", "conv2_padding", "=", "(", "1", ",", "dilation", ",", "dilation", ")", "\n", "", "", "else", ":", "\n", "            ", "conv1_kernel_size", "=", "(", "1", ",", "1", ",", "1", ")", "\n", "conv1_padding", "=", "(", "0", ",", "0", ",", "0", ")", "\n", "conv2_kernel_size", "=", "(", "1", ",", "3", ",", "3", ")", "\n", "conv2_padding", "=", "(", "0", ",", "dilation", ",", "dilation", ")", "\n", "\n", "", "self", ".", "conv1", "=", "ConvModule", "(", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "conv1_kernel_size", ",", "\n", "stride", "=", "(", "self", ".", "conv1_stride_t", ",", "self", ".", "conv1_stride_s", ",", "\n", "self", ".", "conv1_stride_s", ")", ",", "\n", "padding", "=", "conv1_padding", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "act_cfg", "=", "self", ".", "act_cfg", ")", "\n", "\n", "self", ".", "conv2", "=", "ConvModule", "(", "\n", "planes", ",", "\n", "planes", ",", "\n", "conv2_kernel_size", ",", "\n", "stride", "=", "(", "self", ".", "conv2_stride_t", ",", "self", ".", "conv2_stride_s", ",", "\n", "self", ".", "conv2_stride_s", ")", ",", "\n", "padding", "=", "conv2_padding", ",", "\n", "dilation", "=", "(", "1", ",", "dilation", ",", "dilation", ")", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "act_cfg", "=", "self", ".", "act_cfg", ")", "\n", "\n", "self", ".", "conv3", "=", "ConvModule", "(", "\n", "planes", ",", "\n", "planes", "*", "self", ".", "expansion", ",", "\n", "1", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "# No activation in the third ConvModule for bottleneck", "\n", "act_cfg", "=", "None", ")", "\n", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "relu", "=", "build_activation_layer", "(", "self", ".", "act_cfg", ")", "\n", "\n", "if", "self", ".", "enhance", ":", "\n", "            ", "self", ".", "enhance_module", "=", "build_enhance_module", "(", "\n", "self", ".", "enhance_cfg", ",", "\n", "default_args", "=", "dict", "(", "in_channels", "=", "self", ".", "conv3", ".", "norm", ".", "num_features", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.Bottleneck3d.forward": [[287, 314], ["resnet3d.Bottleneck3d.relu", "resnet3d.Bottleneck3d.conv1", "resnet3d.Bottleneck3d.conv2", "resnet3d.Bottleneck3d.conv3", "torch.checkpoint", "torch.checkpoint", "resnet3d.Bottleneck3d.forward._inner_forward"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Defines the computation performed at every call.\"\"\"", "\n", "\n", "def", "_inner_forward", "(", "x", ")", ":", "\n", "            ", "\"\"\"Forward wrapper for utilizing checkpoint.\"\"\"", "\n", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "                ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "=", "out", "+", "identity", "\n", "return", "out", "\n", "\n", "", "if", "self", ".", "with_cp", "and", "x", ".", "requires_grad", ":", "\n", "            ", "out", "=", "cp", ".", "checkpoint", "(", "_inner_forward", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "_inner_forward", "(", "x", ")", "\n", "", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "enhance", ":", "\n", "            ", "out", "=", "self", ".", "enhance_module", "(", "out", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.__init__": [[379, 475], ["dict", "dict", "dict", "dict", "torch.Module.__init__", "resnet3d.ResNet3d._make_stem_layer", "enumerate", "KeyError", "max", "len", "len", "len", "torch.nn.modules.utils._ntuple", "torch.nn.modules.utils._ntuple", "torch.nn.modules.utils._ntuple", "torch.nn.modules.utils._ntuple", "resnet3d.ResNet3d.make_res_layer", "resnet3d.ResNet3d.add_module", "resnet3d.ResNet3d.res_layers.append", "len"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d._make_stem_layer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.make_res_layer"], ["def", "__init__", "(", "self", ",", "\n", "depth", ",", "\n", "in_channels", "=", "3", ",", "\n", "num_stages", "=", "4", ",", "\n", "base_channels", "=", "64", ",", "\n", "out_indices", "=", "(", "3", ",", ")", ",", "\n", "spatial_strides", "=", "(", "1", ",", "2", ",", "2", ",", "2", ")", ",", "\n", "temporal_strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "dilations", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "conv1_kernel", "=", "(", "5", ",", "7", ",", "7", ")", ",", "\n", "conv1_stride_t", "=", "2", ",", "\n", "pool1_stride_t", "=", "2", ",", "\n", "with_pool2", "=", "True", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "frozen_stages", "=", "-", "1", ",", "\n", "inflate", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "inflate_style", "=", "'3x1x1'", ",", "\n", "conv_cfg", "=", "dict", "(", "typename", "=", "'Conv3d'", ")", ",", "\n", "norm_cfg", "=", "dict", "(", "typename", "=", "'BN3d'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "typename", "=", "'ReLU'", ")", ",", "\n", "norm_eval", "=", "False", ",", "\n", "with_cp", "=", "False", ",", "\n", "enhance", "=", "(", "0", ",", "0", ",", "0", ",", "0", ")", ",", "\n", "enhance_cfg", "=", "dict", "(", ")", ",", "\n", "zero_init_residual", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "depth", "not", "in", "self", ".", "arch_settings", ":", "\n", "            ", "raise", "KeyError", "(", "f'invalid depth {depth} for resnet'", ")", "\n", "", "self", ".", "depth", "=", "depth", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "base_channels", "=", "base_channels", "\n", "self", ".", "num_stages", "=", "num_stages", "\n", "assert", "1", "<=", "num_stages", "<=", "4", "\n", "self", ".", "out_indices", "=", "out_indices", "\n", "assert", "max", "(", "out_indices", ")", "<", "num_stages", "\n", "self", ".", "spatial_strides", "=", "spatial_strides", "\n", "self", ".", "temporal_strides", "=", "temporal_strides", "\n", "self", ".", "dilations", "=", "dilations", "\n", "assert", "len", "(", "spatial_strides", ")", "==", "len", "(", "temporal_strides", ")", "==", "len", "(", "\n", "dilations", ")", "==", "num_stages", "\n", "self", ".", "conv1_kernel", "=", "conv1_kernel", "\n", "self", ".", "conv1_stride_t", "=", "conv1_stride_t", "\n", "self", ".", "pool1_stride_t", "=", "pool1_stride_t", "\n", "self", ".", "with_pool2", "=", "with_pool2", "\n", "self", ".", "style", "=", "style", "\n", "self", ".", "frozen_stages", "=", "frozen_stages", "\n", "self", ".", "stage_inflations", "=", "_ntuple", "(", "num_stages", ")", "(", "inflate", ")", "\n", "self", ".", "enhance_stages", "=", "_ntuple", "(", "num_stages", ")", "(", "enhance", ")", "\n", "self", ".", "inflate_style", "=", "inflate_style", "\n", "self", ".", "conv_cfg", "=", "conv_cfg", "\n", "self", ".", "norm_cfg", "=", "norm_cfg", "\n", "self", ".", "act_cfg", "=", "act_cfg", "\n", "self", ".", "norm_eval", "=", "norm_eval", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "self", ".", "zero_init_residual", "=", "zero_init_residual", "\n", "\n", "self", ".", "block", ",", "stage_blocks", "=", "self", ".", "arch_settings", "[", "depth", "]", "\n", "self", ".", "stage_blocks", "=", "stage_blocks", "[", ":", "num_stages", "]", "\n", "self", ".", "inplanes", "=", "self", ".", "base_channels", "\n", "\n", "self", ".", "enhance_cfg", "=", "enhance_cfg", "\n", "\n", "self", ".", "_make_stem_layer", "(", ")", "\n", "\n", "self", ".", "res_layers", "=", "[", "]", "\n", "for", "i", ",", "num_blocks", "in", "enumerate", "(", "self", ".", "stage_blocks", ")", ":", "\n", "            ", "spatial_stride", "=", "spatial_strides", "[", "i", "]", "\n", "temporal_stride", "=", "temporal_strides", "[", "i", "]", "\n", "dilation", "=", "dilations", "[", "i", "]", "\n", "planes", "=", "self", ".", "base_channels", "*", "2", "**", "i", "\n", "res_layer", "=", "self", ".", "make_res_layer", "(", "\n", "self", ".", "block", ",", "\n", "self", ".", "inplanes", ",", "\n", "planes", ",", "\n", "num_blocks", ",", "\n", "spatial_stride", "=", "spatial_stride", ",", "\n", "temporal_stride", "=", "temporal_stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "style", "=", "self", ".", "style", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "act_cfg", "=", "self", ".", "act_cfg", ",", "\n", "enhance", "=", "self", ".", "enhance_stages", "[", "i", "]", ",", "\n", "enhance_cfg", "=", "self", ".", "enhance_cfg", ",", "\n", "inflate", "=", "self", ".", "stage_inflations", "[", "i", "]", ",", "\n", "inflate_style", "=", "self", ".", "inflate_style", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "self", ".", "block", ".", "expansion", "\n", "layer_name", "=", "f'layer{i + 1}'", "\n", "self", ".", "add_module", "(", "layer_name", ",", "res_layer", ")", "\n", "self", ".", "res_layers", ".", "append", "(", "layer_name", ")", "\n", "\n", "", "self", ".", "feat_dim", "=", "self", ".", "block", ".", "expansion", "*", "self", ".", "base_channels", "*", "2", "**", "(", "\n", "len", "(", "self", ".", "stage_blocks", ")", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.make_res_layer": [[476, 587], ["dict", "layers.append", "range", "torch.Sequential", "torch.Sequential", "vedacore.modules.ConvModule", "block", "layers.append", "isinstance", "isinstance", "len", "len", "block"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "make_res_layer", "(", "block", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "blocks", ",", "\n", "spatial_stride", "=", "1", ",", "\n", "temporal_stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "style", "=", "'pytorch'", ",", "\n", "inflate", "=", "1", ",", "\n", "inflate_style", "=", "'3x1x1'", ",", "\n", "enhance", "=", "0", ",", "\n", "enhance_cfg", "=", "dict", "(", ")", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "None", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "with_cp", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Build residual layer for ResNet3D.\n\n        Args:\n            block (nn.Module): Residual module to be built.\n            inplanes (int): Number of channels for the input feature\n                in each block.\n            planes (int): Number of channels for the output feature\n                in each block.\n            blocks (int): Number of residual blocks.\n            spatial_stride (int | Sequence[int]): Spatial strides in\n                residual and conv layers. Default: 1.\n            temporal_stride (int | Sequence[int]): Temporal strides in\n                residual and conv layers. Default: 1.\n            dilation (int): Spacing between kernel elements. Default: 1.\n            style (str): ``pytorch`` or ``caffe``. If set to ``pytorch``,\n                the stride-two layer is the 3x3 conv layer, otherwise\n                the stride-two layer is the first 1x1 conv layer.\n                Default: ``pytorch``.\n            inflate (int | Sequence[int]): Determine whether to inflate\n                for each block. Default: 1.\n            inflate_style (str): ``3x1x1`` or ``1x1x1``. which determines\n                the kernel sizes and padding strides for conv1 and conv2\n                in each block. Default: '3x1x1'.\n            enhance (int | Sequence[int]): Determine whether to apply enhance\n                module in the corresponding block of each stages.\n                Default: 0.\n            enhance_cfg (dict): Config for enhance module.\n                Default: ``dict()``.\n            conv_cfg (dict | None): Config for norm layers. Default: None.\n            norm_cfg (dict | None): Config for norm layers. Default: None.\n            act_cfg (dict | None): Config for activate layers. Default: None.\n            with_cp (bool | None): Use checkpoint or not. Using checkpoint\n                will save some memory while slowing down the training speed.\n                Default: False.\n        Returns:\n            nn.Module: A residual layer for the given config.\n        \"\"\"", "\n", "inflate", "=", "inflate", "if", "not", "isinstance", "(", "inflate", ",", "\n", "int", ")", "else", "(", "inflate", ",", ")", "*", "blocks", "\n", "enhance", "=", "enhance", "if", "not", "isinstance", "(", "enhance", ",", "\n", "int", ")", "else", "(", "enhance", ",", ")", "*", "blocks", "\n", "assert", "len", "(", "inflate", ")", "==", "blocks", "and", "len", "(", "enhance", ")", "==", "blocks", "\n", "downsample", "=", "None", "\n", "if", "spatial_stride", "!=", "1", "or", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "ConvModule", "(", "\n", "inplanes", ",", "\n", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "(", "temporal_stride", ",", "spatial_stride", ",", "spatial_stride", ")", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "None", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "spatial_stride", "=", "spatial_stride", ",", "\n", "temporal_stride", "=", "temporal_stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "downsample", "=", "downsample", ",", "\n", "style", "=", "style", ",", "\n", "inflate", "=", "(", "inflate", "[", "0", "]", "==", "1", ")", ",", "\n", "inflate_style", "=", "inflate_style", ",", "\n", "enhance", "=", "(", "enhance", "[", "0", "]", "==", "1", ")", ",", "\n", "enhance_cfg", "=", "enhance_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "**", "kwargs", ")", ")", "\n", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "spatial_stride", "=", "1", ",", "\n", "temporal_stride", "=", "1", ",", "\n", "dilation", "=", "dilation", ",", "\n", "style", "=", "style", ",", "\n", "inflate", "=", "(", "inflate", "[", "i", "]", "==", "1", ")", ",", "\n", "inflate_style", "=", "inflate_style", ",", "\n", "enhance", "=", "(", "enhance", "[", "i", "]", "==", "1", ")", ",", "\n", "enhance_cfg", "=", "enhance_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "**", "kwargs", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d._make_stem_layer": [[588, 607], ["vedacore.modules.ConvModule", "torch.MaxPool3d", "torch.MaxPool3d", "torch.MaxPool3d", "torch.MaxPool3d", "tuple", "torch.nn.modules.utils._triple", "torch.nn.modules.utils._triple"], "methods", ["None"], ["", "def", "_make_stem_layer", "(", "self", ")", ":", "\n", "        ", "\"\"\"Construct the stem layers consists of a conv+norm+act module and a\n        pooling layer.\"\"\"", "\n", "self", ".", "conv1", "=", "ConvModule", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "base_channels", ",", "\n", "kernel_size", "=", "self", ".", "conv1_kernel", ",", "\n", "stride", "=", "(", "self", ".", "conv1_stride_t", ",", "2", ",", "2", ")", ",", "\n", "padding", "=", "tuple", "(", "[", "(", "k", "-", "1", ")", "//", "2", "for", "k", "in", "_triple", "(", "self", ".", "conv1_kernel", ")", "]", ")", ",", "\n", "conv_cfg", "=", "self", ".", "conv_cfg", ",", "\n", "norm_cfg", "=", "self", ".", "norm_cfg", ",", "\n", "act_cfg", "=", "self", ".", "act_cfg", ")", "\n", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool3d", "(", "\n", "kernel_size", "=", "(", "1", ",", "3", ",", "3", ")", ",", "\n", "stride", "=", "(", "self", ".", "pool1_stride_t", ",", "2", ",", "2", ")", ",", "\n", "padding", "=", "(", "0", ",", "1", ",", "1", ")", ")", "\n", "\n", "self", ".", "pool2", "=", "nn", ".", "MaxPool3d", "(", "kernel_size", "=", "(", "2", ",", "1", ",", "1", ")", ",", "stride", "=", "(", "2", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d._freeze_stages": [[608, 621], ["range", "resnet3d.ResNet3d.conv1.eval", "resnet3d.ResNet3d.conv1.parameters", "getattr", "getattr.eval", "getattr.parameters"], "methods", ["None"], ["", "def", "_freeze_stages", "(", "self", ")", ":", "\n", "        ", "\"\"\"Prevent all the parameters from being optimized before\n        ``self.frozen_stages``.\"\"\"", "\n", "if", "self", ".", "frozen_stages", ">=", "0", ":", "\n", "            ", "self", ".", "conv1", ".", "eval", "(", ")", "\n", "for", "param", "in", "self", ".", "conv1", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "", "for", "i", "in", "range", "(", "1", ",", "self", ".", "frozen_stages", "+", "1", ")", ":", "\n", "            ", "m", "=", "getattr", "(", "self", ",", "f'layer{i}'", ")", "\n", "m", ".", "eval", "(", ")", "\n", "for", "param", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.init_weights": [[622, 636], ["resnet3d.ResNet3d.modules", "isinstance", "resnet3d.ResNet3d.modules", "vedacore.modules.kaiming_init", "isinstance", "isinstance", "vedacore.modules.constant_init", "vedacore.modules.constant_init", "isinstance", "vedacore.modules.constant_init"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.kaiming_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.constant_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.constant_init", "home.repos.pwc.inspect_result.Media-Smart_vedatad.utils.weight_init.constant_init"], ["", "", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initiate the parameters in backbone.\"\"\"", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "_ConvNd", ")", ":", "\n", "                ", "kaiming_init", "(", "m", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "_BatchNorm", ")", ":", "\n", "                ", "constant_init", "(", "m", ",", "1", ")", "\n", "\n", "", "", "if", "self", ".", "zero_init_residual", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "Bottleneck3d", ")", ":", "\n", "                    ", "constant_init", "(", "m", ".", "conv3", ".", "bn", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "BasicBlock3d", ")", ":", "\n", "                    ", "constant_init", "(", "m", ".", "conv2", ".", "bn", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.forward": [[637, 660], ["resnet3d.ResNet3d.conv1", "resnet3d.ResNet3d.maxpool", "enumerate", "tuple", "getattr", "getattr.", "len", "resnet3d.ResNet3d.pool2", "outs.append"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Defines the computation performed at every call.\n\n        Args:\n            x (torch.Tensor): The input data.\n        Returns:\n            torch.Tensor: The feature of the input\n            samples extracted by the backbone.\n        \"\"\"", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "outs", "=", "[", "]", "\n", "for", "i", ",", "layer_name", "in", "enumerate", "(", "self", ".", "res_layers", ")", ":", "\n", "            ", "res_layer", "=", "getattr", "(", "self", ",", "layer_name", ")", "\n", "x", "=", "res_layer", "(", "x", ")", "\n", "if", "i", "==", "0", "and", "self", ".", "with_pool2", ":", "\n", "                ", "x", "=", "self", ".", "pool2", "(", "x", ")", "\n", "", "if", "i", "in", "self", ".", "out_indices", ":", "\n", "                ", "outs", ".", "append", "(", "x", ")", "\n", "", "", "if", "len", "(", "outs", ")", "==", "1", ":", "\n", "            ", "return", "outs", "[", "0", "]", "\n", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.train": [[661, 669], ["super().train", "resnet3d.ResNet3d._freeze_stages", "resnet3d.ResNet3d.modules", "isinstance", "m.eval"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d.train", "home.repos.pwc.inspect_result.Media-Smart_vedatad.backbones.resnet3d.ResNet3d._freeze_stages"], ["", "def", "train", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "\"\"\"Set the optimization status when training.\"\"\"", "\n", "super", "(", ")", ".", "train", "(", "mode", ")", "\n", "self", ".", "_freeze_stages", "(", ")", "\n", "if", "mode", "and", "self", ".", "norm_eval", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "_BatchNorm", ")", ":", "\n", "                    ", "m", ".", "eval", "(", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.segment_anchor_criterion.SegmentAnchorCriterion.__init__": [[34, 79], ["dict", "dict", "dict", "base_criterion.BaseCriterion.__init__", "loss_cls.get", "vedatad.misc.segment.build_segment_coder", "losses.build_loss", "losses.build_loss", "vedatad.bridge.build_meshgrid", "ValueError", "vedatad.misc.segment.build_assigner", "vedatad.misc.segment.build_sampler", "hasattr", "dict"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.builder.build_segment_coder", "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.builder.build_loss", "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.builder.build_loss", "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.builder.build_meshgrid", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.builder.build_assigner", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.builder.build_sampler"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", ",", "\n", "meshgrid", ",", "\n", "segment_coder", "=", "dict", "(", "\n", "typename", "=", "'DeltaSegmentCoder'", ",", "\n", "target_means", "=", "(", ".0", ",", ".0", ")", ",", "\n", "target_stds", "=", "(", "1.0", ",", "1.0", ")", ")", ",", "\n", "reg_decoded_segment", "=", "False", ",", "\n", "loss_cls", "=", "dict", "(", "\n", "typename", "=", "'CrossEntropyLoss'", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "loss_weight", "=", "1.0", ")", ",", "\n", "loss_segment", "=", "dict", "(", "\n", "typename", "=", "'SmoothL1Loss'", ",", "beta", "=", "1.0", "/", "9.0", ",", "loss_weight", "=", "1.0", ")", ",", "\n", "train_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "use_sigmoid_cls", "=", "loss_cls", ".", "get", "(", "'use_sigmoid'", ",", "False", ")", "\n", "# TODO better way to determine whether sample or not", "\n", "self", ".", "sampling", "=", "loss_cls", "[", "'typename'", "]", "not", "in", "[", "\n", "'FocalLoss'", ",", "'GHMC'", ",", "'QualityFocalLoss'", "\n", "]", "\n", "if", "self", ".", "use_sigmoid_cls", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "+", "1", "\n", "\n", "", "if", "self", ".", "cls_out_channels", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "f'num_classes={num_classes} is too small'", ")", "\n", "", "self", ".", "reg_decoded_segment", "=", "reg_decoded_segment", "\n", "self", ".", "background_label", "=", "num_classes", "\n", "self", ".", "segment_coder", "=", "build_segment_coder", "(", "segment_coder", ")", "\n", "self", ".", "loss_cls", "=", "build_loss", "(", "loss_cls", ")", "\n", "self", ".", "loss_segment", "=", "build_loss", "(", "loss_segment", ")", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "if", "self", ".", "train_cfg", ":", "\n", "            ", "self", ".", "assigner", "=", "build_assigner", "(", "self", ".", "train_cfg", ".", "assigner", ")", "\n", "# use PseudoSampler when sampling is False", "\n", "if", "self", ".", "sampling", "and", "hasattr", "(", "self", ".", "train_cfg", ",", "'sampler'", ")", ":", "\n", "                ", "sampler_cfg", "=", "self", ".", "train_cfg", ".", "sampler", "\n", "", "else", ":", "\n", "                ", "sampler_cfg", "=", "dict", "(", "typename", "=", "'PseudoSampler'", ")", "\n", "", "self", ".", "sampler", "=", "build_sampler", "(", "sampler_cfg", ")", "\n", "\n", "", "self", ".", "meshgrid", "=", "build_meshgrid", "(", "meshgrid", ")", "\n", "# usually the numbers of anchors for each level are the same", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.segment_anchor_criterion.SegmentAnchorCriterion._get_targets_single": [[83, 185], ["vedatad.misc.anchor.anchor_inside_flags", "segment_anchor_criterion.SegmentAnchorCriterion.assigner.assign", "segment_anchor_criterion.SegmentAnchorCriterion.sampler.sample", "torch.zeros_like", "torch.zeros_like", "anchors.new_full", "anchors.new_zeros", "vedatad.misc.anchor.anchor_inside_flags.any", "len", "len", "flat_anchors.size", "vedacore.misc.unmap", "vedacore.misc.unmap", "vedacore.misc.unmap", "vedacore.misc.unmap", "segment_anchor_criterion.SegmentAnchorCriterion.segment_coder.encode"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.anchor.anchor_inside_flags", "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.max_iou_assigner.MaxIoUAssigner.assign", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.pseudo_sampler.PseudoSampler.sample", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.unmap", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.unmap", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.unmap", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.unmap", "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.encode"], ["", "def", "_get_targets_single", "(", "self", ",", "\n", "flat_anchors", ",", "\n", "valid_flags", ",", "\n", "video_meta", ",", "\n", "gt_segments", ",", "\n", "gt_labels", ",", "\n", "gt_segments_ignore", ",", "\n", "unmap_outputs", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute regression and classification targets for anchors in a\n        single video.\n\n        Adapted from https://github.com/open-mmlab/mmdetection\n\n        Args:\n            flat_anchors (Tensor): Multi-level anchors of the video, which are\n                concatenated into a single tensor of shape (num_anchors, 2)\n            valid_flags (Tensor): Multi level valid flags of the video, which\n                are concatenated into a single tensor of shape (num_anchors,).\n            video_meta (dict): Meta info of the video.\n            gt_segments (Tensor): Ground truth segments of the video,\n                shape (num_gts, 2).\n            gt_labels (Tensor): Ground truth labels of each segment,\n                shape (num_gts,).\n            gt_segments_ignore (Tensor): Ground truth segments to be\n                ignored, shape (num_ignored_gts, 2).\n            unmap_outputs (bool): Whether to map outputs back to the original\n                set of anchors.\n\n        Returns:\n            tuple:\n                labels_list (list[Tensor]): Labels of each level\n                label_weights_list (list[Tensor]): Label weights of each level\n                segment_targets_list (list[Tensor]): Segment targets of each\n                    level\n                segment_weights_list (list[Tensor]): Segment weights of each\n                    level\n                num_total_pos (int): Number of positive samples in all videos\n                num_total_neg (int): Number of negative samples in all videos\n        \"\"\"", "\n", "inside_flags", "=", "anchor_inside_flags", "(", "flat_anchors", ",", "valid_flags", ",", "\n", "video_meta", "[", "'tsize'", "]", ",", "\n", "self", ".", "train_cfg", ".", "allowed_border", ")", "\n", "if", "not", "inside_flags", ".", "any", "(", ")", ":", "\n", "            ", "return", "(", "None", ",", ")", "*", "7", "\n", "# assign gt and sample anchors", "\n", "", "anchors", "=", "flat_anchors", "[", "inside_flags", ",", ":", "]", "\n", "\n", "assign_result", "=", "self", ".", "assigner", ".", "assign", "(", "\n", "anchors", ",", "gt_segments", ",", "gt_segments_ignore", ",", "\n", "None", "if", "self", ".", "sampling", "else", "gt_labels", ")", "\n", "sampling_result", "=", "self", ".", "sampler", ".", "sample", "(", "assign_result", ",", "anchors", ",", "\n", "gt_segments", ")", "\n", "\n", "num_valid_anchors", "=", "anchors", ".", "shape", "[", "0", "]", "\n", "segment_targets", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "segment_weights", "=", "torch", ".", "zeros_like", "(", "anchors", ")", "\n", "labels", "=", "anchors", ".", "new_full", "(", "(", "num_valid_anchors", ",", ")", ",", "\n", "self", ".", "background_label", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "label_weights", "=", "anchors", ".", "new_zeros", "(", "num_valid_anchors", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "pos_inds", "=", "sampling_result", ".", "pos_inds", "\n", "neg_inds", "=", "sampling_result", ".", "neg_inds", "\n", "if", "len", "(", "pos_inds", ")", ">", "0", ":", "\n", "            ", "if", "not", "self", ".", "reg_decoded_segment", ":", "\n", "                ", "pos_segment_targets", "=", "self", ".", "segment_coder", ".", "encode", "(", "\n", "sampling_result", ".", "pos_segments", ",", "\n", "sampling_result", ".", "pos_gt_segments", ")", "\n", "", "else", ":", "\n", "                ", "pos_segment_targets", "=", "sampling_result", ".", "pos_gt_segments", "\n", "", "segment_targets", "[", "pos_inds", ",", ":", "]", "=", "pos_segment_targets", "\n", "segment_weights", "[", "pos_inds", ",", ":", "]", "=", "1.0", "\n", "if", "gt_labels", "is", "None", ":", "\n", "# only rpn gives gt_labels as None, this time FG is 1", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "sampling_result", ".", "pos_assigned_gt_inds", "]", "\n", "", "if", "self", ".", "train_cfg", ".", "pos_weight", "<=", "0", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "1.0", "\n", "", "else", ":", "\n", "                ", "label_weights", "[", "pos_inds", "]", "=", "self", ".", "train_cfg", ".", "pos_weight", "\n", "", "", "if", "len", "(", "neg_inds", ")", ">", "0", ":", "\n", "            ", "label_weights", "[", "neg_inds", "]", "=", "1.0", "\n", "\n", "# map up to original set of anchors", "\n", "", "if", "unmap_outputs", ":", "\n", "            ", "num_total_anchors", "=", "flat_anchors", ".", "size", "(", "0", ")", "\n", "labels", "=", "unmap", "(", "\n", "labels", ",", "\n", "num_total_anchors", ",", "\n", "inside_flags", ",", "\n", "fill", "=", "self", ".", "background_label", ")", "# fill bg label", "\n", "label_weights", "=", "unmap", "(", "label_weights", ",", "num_total_anchors", ",", "\n", "inside_flags", ")", "\n", "segment_targets", "=", "unmap", "(", "segment_targets", ",", "num_total_anchors", ",", "\n", "inside_flags", ")", "\n", "segment_weights", "=", "unmap", "(", "segment_weights", ",", "num_total_anchors", ",", "\n", "inside_flags", ")", "\n", "\n", "", "return", "(", "labels", ",", "label_weights", ",", "segment_targets", ",", "segment_weights", ",", "\n", "pos_inds", ",", "neg_inds", ",", "sampling_result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.segment_anchor_criterion.SegmentAnchorCriterion.get_targets": [[186, 286], ["len", "range", "vedacore.misc.multi_apply", "list", "any", "sum", "sum", "vedatad.misc.anchor.videos_to_levels", "vedatad.misc.anchor.videos_to_levels", "vedatad.misc.anchor.videos_to_levels", "vedatad.misc.anchor.videos_to_levels", "enumerate", "len", "len", "anchors.size", "concat_anchor_list.append", "concat_valid_flag_list.append", "vedatad.misc.anchor.videos_to_levels", "tuple", "len", "len", "torch.cat", "torch.cat", "max", "max", "range", "range", "inds.numel", "inds.numel"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.multi_apply", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.anchor.videos_to_levels", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.anchor.videos_to_levels", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.anchor.videos_to_levels", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.anchor.videos_to_levels", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.anchor.videos_to_levels"], ["", "def", "get_targets", "(", "self", ",", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "video_metas", ",", "\n", "gt_segments_list", ",", "\n", "gt_labels_list", ",", "\n", "gt_segments_ignore_list", "=", "None", ",", "\n", "unmap_outputs", "=", "True", ",", "\n", "return_sampling_results", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute regression and classification targets for anchors in\n        multiple videos.\n\n        Adapted from https://github.com/open-mmlab/mmdetection\n\n        Args:\n            anchor_list (list[list[Tensor]]): Multi level anchors of each\n                video. The outer list indicates videos, and the inner list\n                corresponds to feature levels of the video. Each element of\n                the inner list is a tensor of shape (num_anchors, 2).\n            valid_flag_list (list[list[Tensor]]): Multi level valid flags of\n                each video. The outer list indicates videos, and the inner list\n                corresponds to feature levels of the video. Each element of\n                the inner list is a tensor of shape (num_anchors, )\n            video_metas (list[dict]): Meta info of each video.\n            gt_segments_list (list[Tensor]): Ground truth segments of each\n                image.\n            gt_labels_list (list[Tensor]): Ground truth labels of each segment.\n            gt_segments_ignore_list (None | list[Tensor]): Ground truth\n                segments to be ignored.\n            unmap_outputs (bool): Whether to map outputs back to the original\n                set of anchors.\n\n        Returns:\n            tuple:\n                labels_list (list[Tensor]): Labels of each level\n                label_weights_list (list[Tensor]): Label weights of each level\n                segment_targets_list (list[Tensor]): Segment targets of each\n                    level\n                segment_weights_list (list[Tensor]): Segment weights of each\n                    level.\n                num_total_pos (int): Number of positive samples in all videos\n                num_total_neg (int): Number of negative samples in all videos\n            additional_returns: This function enables user-defined returns from\n                `self._get_targets_single`. These returns are currently refined\n                to properties at each feature map (i.e. having T dimension).\n                The results will be concatenated after the end\n        \"\"\"", "\n", "num_videos", "=", "len", "(", "video_metas", ")", "\n", "assert", "len", "(", "anchor_list", ")", "==", "len", "(", "valid_flag_list", ")", "==", "num_videos", "\n", "\n", "# anchor number of multi levels", "\n", "num_level_anchors", "=", "[", "anchors", ".", "size", "(", "0", ")", "for", "anchors", "in", "anchor_list", "[", "0", "]", "]", "\n", "# concat all level anchors to a single tensor", "\n", "concat_anchor_list", "=", "[", "]", "\n", "concat_valid_flag_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_videos", ")", ":", "\n", "            ", "assert", "len", "(", "anchor_list", "[", "i", "]", ")", "==", "len", "(", "valid_flag_list", "[", "i", "]", ")", "\n", "concat_anchor_list", ".", "append", "(", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", ")", "\n", "concat_valid_flag_list", ".", "append", "(", "torch", ".", "cat", "(", "valid_flag_list", "[", "i", "]", ")", ")", "\n", "\n", "# compute targets for each image", "\n", "", "if", "gt_segments_ignore_list", "is", "None", ":", "\n", "            ", "gt_segments_ignore_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_videos", ")", "]", "\n", "", "if", "gt_labels_list", "is", "None", ":", "\n", "            ", "gt_labels_list", "=", "[", "None", "for", "_", "in", "range", "(", "num_videos", ")", "]", "\n", "", "results", "=", "multi_apply", "(", "\n", "self", ".", "_get_targets_single", ",", "\n", "concat_anchor_list", ",", "\n", "concat_valid_flag_list", ",", "\n", "video_metas", ",", "\n", "gt_segments_list", ",", "\n", "gt_labels_list", ",", "\n", "gt_segments_ignore_list", ",", "\n", "unmap_outputs", "=", "unmap_outputs", ")", "\n", "(", "all_labels", ",", "all_label_weights", ",", "all_segment_targets", ",", "\n", "all_segment_weights", ",", "pos_inds_list", ",", "neg_inds_list", ",", "\n", "sampling_results_list", ")", "=", "results", "[", ":", "7", "]", "\n", "rest_results", "=", "list", "(", "results", "[", "7", ":", "]", ")", "# user-added return values", "\n", "# no valid anchors", "\n", "if", "any", "(", "[", "labels", "is", "None", "for", "labels", "in", "all_labels", "]", ")", ":", "\n", "            ", "return", "None", "\n", "# sampled anchors of all images", "\n", "", "num_total_pos", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "pos_inds_list", "]", ")", "\n", "num_total_neg", "=", "sum", "(", "[", "max", "(", "inds", ".", "numel", "(", ")", ",", "1", ")", "for", "inds", "in", "neg_inds_list", "]", ")", "\n", "# split targets to a list w.r.t. multiple levels", "\n", "labels_list", "=", "videos_to_levels", "(", "all_labels", ",", "num_level_anchors", ")", "\n", "label_weights_list", "=", "videos_to_levels", "(", "all_label_weights", ",", "\n", "num_level_anchors", ")", "\n", "segment_targets_list", "=", "videos_to_levels", "(", "all_segment_targets", ",", "\n", "num_level_anchors", ")", "\n", "segment_weights_list", "=", "videos_to_levels", "(", "all_segment_weights", ",", "\n", "num_level_anchors", ")", "\n", "res", "=", "(", "labels_list", ",", "label_weights_list", ",", "segment_targets_list", ",", "\n", "segment_weights_list", ",", "num_total_pos", ",", "num_total_neg", ")", "\n", "if", "return_sampling_results", ":", "\n", "            ", "res", "=", "res", "+", "(", "sampling_results_list", ",", ")", "\n", "", "for", "i", ",", "r", "in", "enumerate", "(", "rest_results", ")", ":", "# user-added return values", "\n", "            ", "rest_results", "[", "i", "]", "=", "videos_to_levels", "(", "r", ",", "num_level_anchors", ")", "\n", "\n", "", "return", "res", "+", "tuple", "(", "rest_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.segment_anchor_criterion.SegmentAnchorCriterion.loss_single": [[287, 336], ["labels.reshape.reshape.reshape", "label_weights.reshape.reshape.reshape", "cls_score.permute().reshape.permute().reshape.permute().reshape", "segment_anchor_criterion.SegmentAnchorCriterion.loss_cls", "segment_targets.reshape.reshape.reshape", "segment_weights.reshape.reshape.reshape", "segment_anchor_criterion.SegmentAnchorCriterion.permute().reshape", "segment_anchor_criterion.SegmentAnchorCriterion.loss_segment", "anchors.reshape.reshape.reshape", "segment_anchor_criterion.SegmentAnchorCriterion.segment_coder.decode", "cls_score.permute().reshape.permute().reshape.permute", "segment_anchor_criterion.SegmentAnchorCriterion.permute"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.decode"], ["", "def", "loss_single", "(", "self", ",", "cls_score", ",", "segment_pred", ",", "anchors", ",", "labels", ",", "\n", "label_weights", ",", "segment_targets", ",", "segment_weights", ",", "\n", "num_total_samples", ")", ":", "\n", "        ", "\"\"\"Compute loss of a single scale level.\n\n        Adapted from https://github.com/open-mmlab/mmdetection\n\n        Args:\n            cls_score (Tensor): Segment scores for each scale level\n                Has shape (N, num_anchors * num_classes, T).\n            segment_pred (Tensor): Segment energies / deltas for each scale\n                level with shape (N, num_anchors * 2, T).\n            anchors (Tensor): Segment reference for each scale level with shape\n                (N, num_total_anchors, 2).\n            labels (Tensor): Labels of each anchors with shape\n                (N, num_total_anchors).\n            label_weights (Tensor): Label weights of each anchor with shape\n                (N, num_total_anchors)\n            segment_targets (Tensor): Segment regression targets of each anchor\n                with shape (N, num_total_anchors, 2).\n            segment_weights (Tensor): Segment regression loss weights of each\n                anchor with shape (N, num_total_anchors, 2).\n            num_total_samples (int): If sampling, num total samples equal to\n                the number of total anchors; Otherwise, it is the number of\n                positive anchors.\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "# classification loss", "\n", "labels", "=", "labels", ".", "reshape", "(", "-", "1", ")", "\n", "label_weights", "=", "label_weights", ".", "reshape", "(", "-", "1", ")", "\n", "cls_score", "=", "cls_score", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "\n", "self", ".", "cls_out_channels", ")", "\n", "loss_cls", "=", "self", ".", "loss_cls", "(", "\n", "cls_score", ",", "labels", ",", "label_weights", ",", "avg_factor", "=", "num_total_samples", ")", "\n", "# regression loss", "\n", "segment_targets", "=", "segment_targets", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "segment_weights", "=", "segment_weights", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "segment_pred", "=", "segment_pred", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "if", "self", ".", "reg_decoded_segment", ":", "\n", "            ", "anchors", "=", "anchors", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "segment_pred", "=", "self", ".", "segment_coder", ".", "decode", "(", "anchors", ",", "segment_pred", ")", "\n", "", "loss_segment", "=", "self", ".", "loss_segment", "(", "\n", "segment_pred", ",", "\n", "segment_targets", ",", "\n", "segment_weights", ",", "\n", "avg_factor", "=", "num_total_samples", ")", "\n", "return", "loss_cls", ",", "loss_segment", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.segment_anchor_criterion.SegmentAnchorCriterion.loss": [[337, 409], ["segment_anchor_criterion.SegmentAnchorCriterion.meshgrid.gen_anchor_mesh", "segment_anchor_criterion.SegmentAnchorCriterion.get_targets", "range", "vedatad.misc.anchor.videos_to_levels", "vedacore.misc.multi_apply", "segment_anchor_criterion.SegmentAnchorCriterion._parse_losses", "dict", "anchors.size", "len", "concat_anchor_list.append", "dict", "featmap.size", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid.gen_anchor_mesh", "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.segment_anchor_criterion.SegmentAnchorCriterion.get_targets", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.anchor.videos_to_levels", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.utils.multi_apply", "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.base_criterion.BaseCriterion._parse_losses", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "loss", "(", "self", ",", "\n", "feats", ",", "\n", "video_metas", ",", "\n", "gt_segments", ",", "\n", "gt_labels", ",", "\n", "gt_segments_ignore", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute losses of the head.\n\n        Adapted from https://github.com/open-mmlab/mmdetection\n\n        Args:\n            feats (list[list[Tensor], list[Tensor]]): Features containing cls\n                and seg features.\n                cls_scores (list[Tensor]): Segment scores for each scale level\n                    Has shape (N, num_anchors * num_classes, T)\n                seg_preds (list[Tensor]): Segment energies / deltas for each\n                    scale level with shape (N, num_anchors * 2, T)\n            video_metas (list[dict]): Meta information of each video, e.g.,\n                video shape, etc.\n            gt_segments (list[Tensor]): Ground truth segments for each video\n                with shape (num_gts, 2) in [start, end] format.\n            gt_labels (list[Tensor]): class indices corresponding to each\n                segment\n            gt_segments_ignore (None | list[Tensor]): specify which segments\n                can be ignored when computing the loss. Default: None\n\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "cls_scores", ",", "segment_preds", "=", "feats", "\n", "featmap_tsizes", "=", "[", "featmap", ".", "size", "(", ")", "[", "2", "]", "for", "featmap", "in", "cls_scores", "]", "\n", "\n", "device", "=", "cls_scores", "[", "0", "]", ".", "device", "\n", "\n", "anchor_list", ",", "valid_flag_list", "=", "self", ".", "meshgrid", ".", "gen_anchor_mesh", "(", "\n", "featmap_tsizes", ",", "video_metas", ",", "device", "=", "device", ")", "\n", "cls_reg_targets", "=", "self", ".", "get_targets", "(", "\n", "anchor_list", ",", "\n", "valid_flag_list", ",", "\n", "video_metas", ",", "\n", "gt_segments", ",", "\n", "gt_labels", ",", "\n", "gt_segments_ignore_list", "=", "gt_segments_ignore", ")", "\n", "if", "cls_reg_targets", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "(", "labels_list", ",", "label_weights_list", ",", "segment_targets_list", ",", "\n", "segment_weights_list", ",", "num_total_pos", ",", "num_total_neg", ")", "=", "cls_reg_targets", "\n", "num_total_samples", "=", "(", "\n", "num_total_pos", "+", "num_total_neg", "if", "self", ".", "sampling", "else", "num_total_pos", ")", "\n", "\n", "# anchor number of multi levels", "\n", "num_level_anchors", "=", "[", "anchors", ".", "size", "(", "0", ")", "for", "anchors", "in", "anchor_list", "[", "0", "]", "]", "\n", "# concat all level anchors and flags to a single tensor", "\n", "concat_anchor_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "anchor_list", ")", ")", ":", "\n", "            ", "concat_anchor_list", ".", "append", "(", "torch", ".", "cat", "(", "anchor_list", "[", "i", "]", ")", ")", "\n", "", "all_anchor_list", "=", "videos_to_levels", "(", "concat_anchor_list", ",", "\n", "num_level_anchors", ")", "\n", "\n", "losses_cls", ",", "losses_segment", "=", "multi_apply", "(", "\n", "self", ".", "loss_single", ",", "\n", "cls_scores", ",", "\n", "segment_preds", ",", "\n", "all_anchor_list", ",", "\n", "labels_list", ",", "\n", "label_weights_list", ",", "\n", "segment_targets_list", ",", "\n", "segment_weights_list", ",", "\n", "num_total_samples", "=", "num_total_samples", ")", "\n", "loss", ",", "log_vars", "=", "self", ".", "_parse_losses", "(", "\n", "dict", "(", "loss_cls", "=", "losses_cls", ",", "loss_segment", "=", "losses_segment", ")", ")", "\n", "return", "dict", "(", "loss", "=", "loss", ",", "log_vars", "=", "log_vars", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.builder.build_criterion": [[4, 6], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "import", "torch", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.base_criterion.BaseCriterion.__init__": [[10, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.base_criterion.BaseCriterion.loss": [[13, 16], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "loss", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.base_criterion.BaseCriterion._parse_losses": [[17, 53], ["collections.OrderedDict", "losses.items", "sum", "collections.OrderedDict.items", "isinstance", "loss_value.data.clone.data.clone.item", "loss_value.data.clone.data.clone.mean", "isinstance", "torch.is_available", "torch.is_available", "torch.is_initialized", "torch.is_initialized", "loss_value.data.clone.data.clone.data.clone", "torch.all_reduce", "torch.all_reduce", "sum", "TypeError", "collections.OrderedDict.items", "loss_value.data.clone.data.clone.div_", "torch.get_world_size", "torch.get_world_size", "_loss.mean"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_parse_losses", "(", "losses", ")", ":", "\n", "        ", "\"\"\"Parse the raw outputs (losses) of the network.\n\n        Adapted from https://github.com/open-mmlab/mmdetection\n\n        Args:\n            losses (dict): Raw output of the network, which usually contain\n                losses and other necessary infomation.\n        Returns:\n            tuple[Tensor, dict]: (loss, log_vars), loss is the loss tensor \\\n                which may be a weighted sum of all losses, log_vars contains \\\n                all the variables to be sent to the logger.\n        \"\"\"", "\n", "log_vars", "=", "OrderedDict", "(", ")", "\n", "for", "loss_name", ",", "loss_value", "in", "losses", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "loss_value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "mean", "(", ")", "\n", "", "elif", "isinstance", "(", "loss_value", ",", "list", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "sum", "(", "_loss", ".", "mean", "(", ")", "for", "_loss", "in", "loss_value", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "\n", "f'{loss_name} is not a tensor or list of tensors'", ")", "\n", "\n", "", "", "loss", "=", "sum", "(", "_value", "for", "_key", ",", "_value", "in", "log_vars", ".", "items", "(", ")", "\n", "if", "'loss'", "in", "_key", ")", "\n", "\n", "log_vars", "[", "'loss'", "]", "=", "loss", "\n", "for", "loss_name", ",", "loss_value", "in", "log_vars", ".", "items", "(", ")", ":", "\n", "# reduce loss when distributed training", "\n", "            ", "if", "dist", ".", "is_available", "(", ")", "and", "dist", ".", "is_initialized", "(", ")", ":", "\n", "                ", "loss_value", "=", "loss_value", ".", "data", ".", "clone", "(", ")", "\n", "dist", ".", "all_reduce", "(", "loss_value", ".", "div_", "(", "dist", ".", "get_world_size", "(", ")", ")", ")", "\n", "", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "item", "(", ")", "\n", "\n", "", "return", "loss", ",", "log_vars", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.builder.build_loss": [[4, 6], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "import", "torch", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.IoULoss.__init__": [[155, 160], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "eps", "=", "1e-6", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "IoULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.IoULoss.forward": [[161, 202], ["weight.mean.mean.mean", "iou_loss.iou_loss", "torch.any", "torch.any", "torch.any", "torch.any", "weight.mean.mean.dim"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.iou_loss", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning target of the prediction.\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Defaults to None. Options are \"none\", \"mean\" and \"sum\".\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "(", "weight", "is", "not", "None", ")", "and", "(", "not", "torch", ".", "any", "(", "weight", ">", "0", ")", ")", "and", "(", "\n", "reduction", "!=", "'none'", ")", ":", "\n", "            ", "return", "(", "pred", "*", "weight", ")", ".", "sum", "(", ")", "# 0", "\n", "", "if", "weight", "is", "not", "None", "and", "weight", ".", "dim", "(", ")", ">", "1", ":", "\n", "# TODO: remove this in the future", "\n", "# reduce the weight of shape (n, 4) to (n,) to match the", "\n", "# iou_loss of shape (n,)", "\n", "            ", "assert", "weight", ".", "shape", "==", "pred", ".", "shape", "\n", "weight", "=", "weight", ".", "mean", "(", "-", "1", ")", "\n", "", "loss", "=", "self", ".", "loss_weight", "*", "iou_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.BoundedIoULoss.__init__": [[207, 213], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "beta", "=", "0.2", ",", "eps", "=", "1e-3", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "BoundedIoULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.BoundedIoULoss.forward": [[214, 236], ["iou_loss.bounded_iou_loss", "torch.any", "torch.any", "torch.any", "torch.any"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.bounded_iou_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "weight", "is", "not", "None", "and", "not", "torch", ".", "any", "(", "weight", ">", "0", ")", ":", "\n", "            ", "return", "(", "pred", "*", "weight", ")", ".", "sum", "(", ")", "# 0", "\n", "", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "loss", "=", "self", ".", "loss_weight", "*", "bounded_iou_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "beta", "=", "self", ".", "beta", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.GIoULoss.__init__": [[241, 246], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "eps", "=", "1e-6", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "GIoULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.GIoULoss.forward": [[247, 274], ["weight.mean.mean.mean", "iou_loss.giou_loss", "torch.any", "torch.any", "torch.any", "torch.any", "weight.mean.mean.dim"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.giou_loss", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "weight", "is", "not", "None", "and", "not", "torch", ".", "any", "(", "weight", ">", "0", ")", ":", "\n", "            ", "return", "(", "pred", "*", "weight", ")", ".", "sum", "(", ")", "# 0", "\n", "", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "weight", "is", "not", "None", "and", "weight", ".", "dim", "(", ")", ">", "1", ":", "\n", "# TODO: remove this in the future", "\n", "# reduce the weight of shape (n, 4) to (n,) to match the", "\n", "# giou_loss of shape (n,)", "\n", "            ", "assert", "weight", ".", "shape", "==", "pred", ".", "shape", "\n", "weight", "=", "weight", ".", "mean", "(", "-", "1", ")", "\n", "", "loss", "=", "self", ".", "loss_weight", "*", "giou_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.DIoULoss.__init__": [[279, 284], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "eps", "=", "1e-6", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "DIoULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.DIoULoss.forward": [[285, 312], ["weight.mean.mean.mean", "iou_loss.diou_loss", "torch.any", "torch.any", "torch.any", "torch.any", "weight.mean.mean.dim"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.diou_loss", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "weight", "is", "not", "None", "and", "not", "torch", ".", "any", "(", "weight", ">", "0", ")", ":", "\n", "            ", "return", "(", "pred", "*", "weight", ")", ".", "sum", "(", ")", "# 0", "\n", "", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "weight", "is", "not", "None", "and", "weight", ".", "dim", "(", ")", ">", "1", ":", "\n", "# TODO: remove this in the future", "\n", "# reduce the weight of shape (n, 4) to (n,) to match the", "\n", "# giou_loss of shape (n,)", "\n", "            ", "assert", "weight", ".", "shape", "==", "pred", ".", "shape", "\n", "weight", "=", "weight", ".", "mean", "(", "-", "1", ")", "\n", "", "loss", "=", "self", ".", "loss_weight", "*", "diou_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.iou_loss": [[11, 29], ["vedatad.misc.segment.segment_overlaps().clamp", "segment_overlaps().clamp.log", "vedatad.misc.segment.segment_overlaps"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment_overlaps"], ["@", "weighted_loss", "\n", "def", "iou_loss", "(", "pred", ",", "target", ",", "eps", "=", "1e-6", ")", ":", "\n", "    ", "\"\"\"IoU loss.\n\n    Computing the IoU loss between a set of predicted segments and target\n        segments.\n    The loss is calculated as negative log of IoU.\n    Args:\n        pred (torch.Tensor): Predicted segments of format (start, end),\n            shape (n, 2).\n        target (torch.Tensor): Corresponding gt segments, shape (n, 2).\n        eps (float): Eps to avoid log(0).\n    Return:\n        torch.Tensor: Loss tensor.\n    \"\"\"", "\n", "ious", "=", "segment_overlaps", "(", "pred", ",", "target", ",", "is_aligned", "=", "True", ")", ".", "clamp", "(", "min", "=", "eps", ")", "\n", "loss", "=", "-", "ious", ".", "log", "(", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.bounded_iou_loss": [[31, 63], ["torch.stack().view", "torch.stack().view", "torch.where", "torch.where", "torch.no_grad", "torch.no_grad", "torch.max", "torch.max", "torch.min", "torch.min", "loss_center.size", "torch.zeros_like", "torch.zeros_like", "torch.stack", "torch.stack", "d_center.abs", "d_center.abs"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack"], ["", "@", "weighted_loss", "\n", "def", "bounded_iou_loss", "(", "pred", ",", "target", ",", "beta", "=", "0.2", ",", "eps", "=", "1e-3", ")", ":", "\n", "    ", "\"\"\"BIoULoss. This is an implementation of paper `Improving Object\n    Localization with Fitness NMS and Bounded IoU Loss.\n\n    <https://arxiv.org/abs/1711.00164>`_.\n    Args:\n        pred (torch.Tensor): Predicted segments.\n        target (torch.Tensor): Target segments.\n        beta (float): beta parameter in smoothl1.\n        eps (float): eps to avoid NaN.\n    \"\"\"", "\n", "pred_center", "=", "(", "pred", "[", ":", ",", "0", "]", "+", "pred", "[", ":", ",", "1", "]", ")", "*", "0.5", "\n", "pred_interval", "=", "pred", "[", ":", ",", "1", "]", "-", "pred", "[", ":", ",", "0", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "target_center", "=", "(", "target", "[", ":", ",", "0", "]", "+", "target", "[", ":", ",", "1", "]", ")", "*", "0.5", "\n", "target_interval", "=", "target", "[", ":", ",", "1", "]", "-", "target", "[", ":", ",", "0", "]", "\n", "\n", "", "d_center", "=", "target_center", "-", "pred_center", "\n", "\n", "loss_center", "=", "1", "-", "torch", ".", "max", "(", "(", "target_interval", "-", "2", "*", "d_center", ".", "abs", "(", ")", ")", "/", "\n", "(", "target_interval", "+", "2", "*", "d_center", ".", "abs", "(", ")", "+", "eps", ")", ",", "\n", "torch", ".", "zeros_like", "(", "d_center", ")", ")", "\n", "loss_interval", "=", "1", "-", "torch", ".", "min", "(", "target_interval", "/", "\n", "(", "pred_interval", "+", "eps", ")", ",", "pred_interval", "/", "\n", "(", "target_interval", "+", "eps", ")", ")", "\n", "loss_comb", "=", "torch", ".", "stack", "(", "[", "loss_center", ",", "loss_interval", "]", ",", "\n", "dim", "=", "-", "1", ")", ".", "view", "(", "loss_center", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n", "loss", "=", "torch", ".", "where", "(", "loss_comb", "<", "beta", ",", "0.5", "*", "loss_comb", "*", "loss_comb", "/", "beta", ",", "\n", "loss_comb", "-", "0.5", "*", "beta", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.giou_loss": [[65, 99], ["torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max"], "function", ["None"], ["", "@", "weighted_loss", "\n", "def", "giou_loss", "(", "pred", ",", "target", ",", "eps", "=", "1e-7", ")", ":", "\n", "    ", "r\"\"\"`Generalized Intersection over Union: A Metric and A Loss for Bounding\n    Box Regression <https://arxiv.org/abs/1902.09630>`_.\n    Args:\n        pred (torch.Tensor): Predicted segments of format (start, end),\n            shape (n, 2).\n        target (torch.Tensor): Corresponding gt segments, shape (n, 2).\n        eps (float): Eps to avoid log(0).\n    Return:\n        Tensor: Loss tensor.\n    \"\"\"", "\n", "# overlap", "\n", "start", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", "0", "]", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "end", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", "1", "]", ",", "target", "[", ":", ",", "1", "]", ")", "\n", "overlap", "=", "(", "end", "-", "start", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "\n", "# union", "\n", "ap", "=", "pred", "[", ":", ",", "1", "]", "-", "pred", "[", ":", ",", "0", "]", "\n", "ag", "=", "target", "[", ":", ",", "1", "]", "-", "target", "[", ":", ",", "0", "]", "\n", "union", "=", "ap", "+", "ag", "-", "overlap", "+", "eps", "\n", "\n", "# IoU", "\n", "ious", "=", "overlap", "/", "union", "\n", "\n", "# enclose area", "\n", "enclose_start", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", "0", "]", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "enclose_end", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", "1", "]", ",", "target", "[", ":", ",", "1", "]", ")", "\n", "enclose_interval", "=", "(", "enclose_end", "-", "enclose_start", ")", ".", "clamp", "(", "min", "=", "0", ")", "+", "eps", "\n", "\n", "# GIoU", "\n", "gious", "=", "ious", "-", "(", "enclose_interval", "-", "union", ")", "/", "enclose_interval", "\n", "loss", "=", "1", "-", "gious", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.iou_loss.diou_loss": [[101, 141], ["torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max"], "function", ["None"], ["", "@", "weighted_loss", "\n", "def", "diou_loss", "(", "pred", ",", "target", ",", "eps", "=", "1e-7", ")", ":", "\n", "    ", "r\"\"\"`Implementation of Distance-IoU Loss: Faster and Better\n    Learning for Bounding Box Regression, https://arxiv.org/abs/1911.08287`_.\n    Code is modified from https://github.com/Zzh-tju/DIoU.\n    Args:\n        pred (Tensor): Predicted segments of format (start, end),\n            shape (n, 2).\n        target (Tensor): Corresponding gt segments, shape (n, 2).\n        eps (float): Eps to avoid log(0).\n    Return:\n        Tensor: Loss tensor.\n    \"\"\"", "\n", "# overlap", "\n", "start", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", "0", "]", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "end", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", "1", "]", ",", "target", "[", ":", ",", "1", "]", ")", "\n", "overlap", "=", "(", "end", "-", "start", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "\n", "# union", "\n", "ap", "=", "pred", "[", ":", ",", "1", "]", "-", "pred", "[", ":", ",", "0", "]", "\n", "ag", "=", "target", "[", ":", ",", "1", "]", "-", "target", "[", ":", ",", "0", "]", "\n", "union", "=", "ap", "+", "ag", "-", "overlap", "+", "eps", "\n", "\n", "# IoU", "\n", "ious", "=", "overlap", "/", "union", "\n", "\n", "# enclose area", "\n", "enclose_start", "=", "torch", ".", "min", "(", "pred", "[", ":", ",", "0", "]", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "enclose_end", "=", "torch", ".", "max", "(", "pred", "[", ":", ",", "1", "]", ",", "target", "[", ":", ",", "1", "]", ")", "\n", "enclose_interval", "=", "(", "enclose_end", "-", "enclose_start", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "c2", "=", "enclose_interval", "**", "2", "+", "eps", "\n", "\n", "pred_center", "=", "(", "pred", "[", ":", ",", "0", "]", "+", "pred", "[", ":", ",", "1", "]", ")", "*", "0.5", "\n", "target_center", "=", "(", "target", "[", ":", ",", "0", "]", "+", "target", "[", ":", ",", "1", "]", ")", "*", "0.5", "\n", "rho2", "=", "(", "target_center", "-", "pred_center", ")", "**", "2", "\n", "\n", "# DIoU", "\n", "dious", "=", "ious", "-", "rho2", "/", "c2", "\n", "loss", "=", "1", "-", "dious", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.focal_loss.FocalLoss.__init__": [[92, 118], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "use_sigmoid", "=", "True", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"`Focal Loss <https://arxiv.org/abs/1708.02002>`_\n        Args:\n            use_sigmoid (bool, optional): Whether to the prediction is\n                used for sigmoid or softmax. Defaults to True.\n            gamma (float, optional): The gamma for calculating the modulating\n                factor. Defaults to 2.0.\n            alpha (float, optional): A balanced form for Focal Loss.\n                Defaults to 0.25.\n            reduction (str, optional): The method used to reduce the loss into\n                a scalar. Defaults to 'mean'. Options are \"none\", \"mean\" and\n                \"sum\".\n            loss_weight (float, optional): Weight of loss. Defaults to 1.0.\n        \"\"\"", "\n", "super", "(", "FocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "use_sigmoid", "is", "True", ",", "'Only sigmoid focal loss supported now.'", "\n", "self", ".", "use_sigmoid", "=", "use_sigmoid", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.focal_loss.FocalLoss.forward": [[119, 155], ["vedacore.ops.sigmoid_focal_loss"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.focal_loss.sigmoid_focal_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning label of the prediction.\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Options are \"none\", \"mean\" and \"sum\".\n        Returns:\n            torch.Tensor: The calculated loss\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "self", ".", "use_sigmoid", ":", "\n", "            ", "loss_cls", "=", "self", ".", "loss_weight", "*", "sigmoid_focal_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "gamma", "=", "self", ".", "gamma", ",", "\n", "alpha", "=", "self", ".", "alpha", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "return", "loss_cls", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.focal_loss.py_sigmoid_focal_loss": [[11, 43], ["pred.sigmoid", "target.type_as.type_as", "utils.weight_reduce_loss", "pt.pow", "torch.binary_cross_entropy_with_logits"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.utils.weight_reduce_loss"], ["def", "py_sigmoid_focal_loss", "(", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ")", ":", "\n", "    ", "\"\"\"PyTorch version of `Focal Loss <https://arxiv.org/abs/1708.02002>`_.\n\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, C), C is the\n            number of classes\n        target (torch.Tensor): The learning label of the prediction.\n        weight (torch.Tensor, optional): Sample-wise loss weight.\n        gamma (float, optional): The gamma for calculating the modulating\n            factor. Defaults to 2.0.\n        alpha (float, optional): A balanced form for Focal Loss.\n            Defaults to 0.25.\n        reduction (str, optional): The method used to reduce the loss into\n            a scalar. Defaults to 'mean'.\n        avg_factor (int, optional): Average factor that is used to average\n            the loss. Defaults to None.\n    \"\"\"", "\n", "pred_sigmoid", "=", "pred", ".", "sigmoid", "(", ")", "\n", "target", "=", "target", ".", "type_as", "(", "pred", ")", "\n", "pt", "=", "(", "1", "-", "pred_sigmoid", ")", "*", "target", "+", "pred_sigmoid", "*", "(", "1", "-", "target", ")", "\n", "focal_weight", "=", "(", "alpha", "*", "target", "+", "(", "1", "-", "alpha", ")", "*", "\n", "(", "1", "-", "target", ")", ")", "*", "pt", ".", "pow", "(", "gamma", ")", "\n", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "pred", ",", "target", ",", "reduction", "=", "'none'", ")", "*", "focal_weight", "\n", "loss", "=", "weight_reduce_loss", "(", "loss", ",", "weight", ",", "reduction", ",", "avg_factor", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.focal_loss.sigmoid_focal_loss": [[45, 87], ["vedacore.ops.sigmoid_focal_loss", "utils.weight_reduce_loss", "weight.view.size", "utils.weight_reduce_loss.size", "weight.view.view", "weight.view.view", "weight.view.numel", "utils.weight_reduce_loss.numel", "utils.weight_reduce_loss.size"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.focal_loss.sigmoid_focal_loss", "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.utils.weight_reduce_loss", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "sigmoid_focal_loss", "(", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "gamma", "=", "2.0", ",", "\n", "alpha", "=", "0.25", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ")", ":", "\n", "    ", "r\"\"\"A warpper of cuda version `Focal Loss\n    <https://arxiv.org/abs/1708.02002>`_.\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, C), C is the number\n            of classes.\n        target (torch.Tensor): The learning label of the prediction.\n        weight (torch.Tensor, optional): Sample-wise loss weight.\n        gamma (float, optional): The gamma for calculating the modulating\n            factor. Defaults to 2.0.\n        alpha (float, optional): A balanced form for Focal Loss.\n            Defaults to 0.25.\n        reduction (str, optional): The method used to reduce the loss into\n            a scalar. Defaults to 'mean'. Options are \"none\", \"mean\" and \"sum\".\n        avg_factor (int, optional): Average factor that is used to average\n            the loss. Defaults to None.\n    \"\"\"", "\n", "# Function.apply does not accept keyword arguments, so the decorator", "\n", "# \"weighted_loss\" is not applicable", "\n", "loss", "=", "_sigmoid_focal_loss", "(", "pred", ",", "target", ",", "gamma", ",", "alpha", ")", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "if", "weight", ".", "shape", "!=", "loss", ".", "shape", ":", "\n", "            ", "if", "weight", ".", "size", "(", "0", ")", "==", "loss", ".", "size", "(", "0", ")", ":", "\n", "# For most cases, weight is of shape (num_priors, ),", "\n", "#  which means it does not have the second axis num_class", "\n", "                ", "weight", "=", "weight", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "# Sometimes, weight per anchor per class is also needed. e.g.", "\n", "#  in FSAF. But it may be flattened of shape", "\n", "#  (num_priors x num_class, ), while loss is still of shape", "\n", "#  (num_priors, num_class).", "\n", "                ", "assert", "weight", ".", "numel", "(", ")", "==", "loss", ".", "numel", "(", ")", "\n", "weight", "=", "weight", ".", "view", "(", "loss", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "", "", "assert", "weight", ".", "ndim", "==", "loss", ".", "ndim", "\n", "", "loss", "=", "weight_reduce_loss", "(", "loss", ",", "weight", ",", "reduction", ",", "avg_factor", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.utils.reduce_loss": [[6, 23], ["torch._Reduction.get_enum", "loss.mean", "loss.sum"], "function", ["None"], ["    ", "\"\"\"Check if a module is a module wrapper.\n\n    The following 3 modules in MMCV (and their subclasses) are regarded as\n    module wrappers: DataParallel, DistributedDataParallel,\n    MMDistributedDataParallel (the deprecated version). You may add you own\n    module wrapper by registering it to parallel.MODULE_WRAPPERS.\n\n    Args:\n        module (nn.Module): The module to be checked.\n\n    Returns:\n        bool: True if the input module is a module wrapper.\n    \"\"\"", "\n", "module_wrappers", "=", "(", "DataParallel", ",", "DistributedDataParallel", ")", "\n", "return", "isinstance", "(", "module", ",", "module_wrappers", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.utils.weight_reduce_loss": [[25, 51], ["utils.reduce_loss", "reduce_loss.sum", "ValueError"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.utils.reduce_loss"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.utils.weighted_loss": [[53, 92], ["functools.wraps", "loss_func", "utils.weight_reduce_loss"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.utils.weight_reduce_loss"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.cross_entropy_loss.CrossEntropyLoss.__init__": [[99, 125], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "use_sigmoid", "=", "False", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "class_weight", "=", "None", ",", "\n", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"CrossEntropyLoss.\n\n        Args:\n            use_sigmoid (bool, optional): Whether the prediction uses sigmoid\n                of softmax. Defaults to False.\n            reduction (str, optional): . Defaults to 'mean'.\n                Options are \"none\", \"mean\" and \"sum\".\n            class_weight (list[float], optional): Weight of each class.\n                Defaults to None.\n            loss_weight (float, optional): Weight of the loss. Defaults to 1.0.\n        \"\"\"", "\n", "super", "(", "CrossEntropyLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "use_sigmoid", "=", "use_sigmoid", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "self", ".", "class_weight", "=", "class_weight", "\n", "\n", "if", "self", ".", "use_sigmoid", ":", "\n", "            ", "self", ".", "cls_criterion", "=", "binary_cross_entropy", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_criterion", "=", "cross_entropy", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.cross_entropy_loss.CrossEntropyLoss.forward": [[126, 162], ["cls_score.new_tensor", "cross_entropy_loss.CrossEntropyLoss.cls_criterion"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "\n", "cls_score", ",", "\n", "label", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            cls_score (torch.Tensor): The prediction.\n            label (torch.Tensor): The learning label of the prediction.\n            weight (torch.Tensor, optional): Sample-wise loss weight.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction (str, optional): The method used to reduce the loss.\n                Options are \"none\", \"mean\" and \"sum\".\n        Returns:\n            torch.Tensor: The calculated loss\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "if", "self", ".", "class_weight", "is", "not", "None", ":", "\n", "            ", "class_weight", "=", "cls_score", ".", "new_tensor", "(", "self", ".", "class_weight", ")", "\n", "", "else", ":", "\n", "            ", "class_weight", "=", "None", "\n", "", "loss_cls", "=", "self", ".", "loss_weight", "*", "self", ".", "cls_criterion", "(", "\n", "cls_score", ",", "\n", "label", ",", "\n", "weight", ",", "\n", "class_weight", "=", "class_weight", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss_cls", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.cross_entropy_loss.cross_entropy": [[11, 42], ["torch.cross_entropy", "utils.weight_reduce_loss", "weight.float.float"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.cross_entropy_loss.cross_entropy", "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.utils.weight_reduce_loss"], ["def", "cross_entropy", "(", "pred", ",", "\n", "label", ",", "\n", "weight", "=", "None", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ",", "\n", "class_weight", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate the CrossEntropy loss.\n\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, C), C is the number\n            of classes.\n        label (torch.Tensor): The learning label of the prediction.\n        weight (torch.Tensor, optional): Sample-wise loss weight.\n        reduction (str, optional): The method used to reduce the loss.\n        avg_factor (int, optional): Average factor that is used to average\n            the loss. Defaults to None.\n        class_weight (list[float], optional): The weight for each class.\n\n    Returns:\n        torch.Tensor: The calculated loss\n    \"\"\"", "\n", "# element-wise losses", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "pred", ",", "label", ",", "weight", "=", "class_weight", ",", "reduction", "=", "'none'", ")", "\n", "\n", "# apply weights and do the reduction", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "weight", "=", "weight", ".", "float", "(", ")", "\n", "", "loss", "=", "weight_reduce_loss", "(", "\n", "loss", ",", "weight", "=", "weight", ",", "reduction", "=", "reduction", ",", "avg_factor", "=", "avg_factor", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.cross_entropy_loss._expand_binary_labels": [[44, 58], ["labels.new_full", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze.numel", "label_weights.view().expand", "labels.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "label_weights.size", "label_weights.view"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "_expand_binary_labels", "(", "labels", ",", "label_weights", ",", "label_channels", ")", ":", "\n", "# Caution: this function should only be used in RPN", "\n", "# in other files such as in ghm_loss, the _expand_binary_labels", "\n", "# is used for multi-class classification.", "\n", "    ", "bin_labels", "=", "labels", ".", "new_full", "(", "(", "labels", ".", "size", "(", "0", ")", ",", "label_channels", ")", ",", "0", ")", "\n", "inds", "=", "torch", ".", "nonzero", "(", "labels", ">=", "1", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "if", "inds", ".", "numel", "(", ")", ">", "0", ":", "\n", "        ", "bin_labels", "[", "inds", ",", "labels", "[", "inds", "]", "-", "1", "]", "=", "1", "\n", "", "if", "label_weights", "is", "None", ":", "\n", "        ", "bin_label_weights", "=", "None", "\n", "", "else", ":", "\n", "        ", "bin_label_weights", "=", "label_weights", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand", "(", "\n", "label_weights", ".", "size", "(", "0", ")", ",", "label_channels", ")", "\n", "", "return", "bin_labels", ",", "bin_label_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.cross_entropy_loss.binary_cross_entropy": [[60, 94], ["torch.binary_cross_entropy_with_logits", "utils.weight_reduce_loss", "pred.dim", "label.dim", "cross_entropy_loss._expand_binary_labels", "weight.float.float", "label.float", "pred.size"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.utils.weight_reduce_loss", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.dim", "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.cross_entropy_loss._expand_binary_labels", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "binary_cross_entropy", "(", "pred", ",", "\n", "label", ",", "\n", "weight", "=", "None", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "avg_factor", "=", "None", ",", "\n", "class_weight", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate the binary CrossEntropy loss.\n\n    Args:\n        pred (torch.Tensor): The prediction with shape (N, 1).\n        label (torch.Tensor): The learning label of the prediction.\n        weight (torch.Tensor, optional): Sample-wise loss weight.\n        reduction (str, optional): The method used to reduce the loss.\n            Options are \"none\", \"mean\" and \"sum\".\n        avg_factor (int, optional): Average factor that is used to average\n            the loss. Defaults to None.\n        class_weight (list[float], optional): The weight for each class.\n\n    Returns:\n        torch.Tensor: The calculated loss\n    \"\"\"", "\n", "if", "pred", ".", "dim", "(", ")", "!=", "label", ".", "dim", "(", ")", ":", "\n", "        ", "label", ",", "weight", "=", "_expand_binary_labels", "(", "label", ",", "weight", ",", "pred", ".", "size", "(", "-", "1", ")", ")", "\n", "\n", "# weighted element-wise losses", "\n", "", "if", "weight", "is", "not", "None", ":", "\n", "        ", "weight", "=", "weight", ".", "float", "(", ")", "\n", "", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "pred", ",", "label", ".", "float", "(", ")", ",", "weight", "=", "class_weight", ",", "reduction", "=", "'none'", ")", "\n", "# do the reduction for the weighted loss", "\n", "loss", "=", "weight_reduce_loss", "(", "\n", "loss", ",", "weight", ",", "reduction", "=", "reduction", ",", "avg_factor", "=", "avg_factor", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.smooth_l1_loss.SmoothL1Loss.__init__": [[59, 64], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "beta", "=", "1.0", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "SmoothL1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.smooth_l1_loss.SmoothL1Loss.forward": [[65, 97], ["smooth_l1_loss.smooth_l1_loss"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.smooth_l1_loss.smooth_l1_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning target of the prediction.\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Defaults to None.\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "loss_bbox", "=", "self", ".", "loss_weight", "*", "smooth_l1_loss", "(", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", ",", "\n", "beta", "=", "self", ".", "beta", ",", "\n", "reduction", "=", "reduction", ",", "\n", "avg_factor", "=", "avg_factor", ",", "\n", "**", "kwargs", ")", "\n", "return", "loss_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.smooth_l1_loss.L1Loss.__init__": [[109, 113], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "reduction", "=", "'mean'", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "L1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.smooth_l1_loss.L1Loss.forward": [[114, 139], ["smooth_l1_loss.l1_loss"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.smooth_l1_loss.l1_loss"], ["", "def", "forward", "(", "self", ",", "\n", "pred", ",", "\n", "target", ",", "\n", "weight", "=", "None", ",", "\n", "avg_factor", "=", "None", ",", "\n", "reduction_override", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            pred (torch.Tensor): The prediction.\n            target (torch.Tensor): The learning target of the prediction.\n            weight (torch.Tensor, optional): The weight of loss for each\n                prediction. Defaults to None.\n            avg_factor (int, optional): Average factor that is used to average\n                the loss. Defaults to None.\n            reduction_override (str, optional): The reduction method used to\n                override the original reduction method of the loss.\n                Defaults to None.\n        \"\"\"", "\n", "assert", "reduction_override", "in", "(", "None", ",", "'none'", ",", "'mean'", ",", "'sum'", ")", "\n", "reduction", "=", "(", "\n", "reduction_override", "if", "reduction_override", "else", "self", ".", "reduction", ")", "\n", "loss_bbox", "=", "self", ".", "loss_weight", "*", "l1_loss", "(", "\n", "pred", ",", "target", ",", "weight", ",", "reduction", "=", "reduction", ",", "avg_factor", "=", "avg_factor", ")", "\n", "return", "loss_bbox", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.smooth_l1_loss.smooth_l1_loss": [[10, 29], ["torch.abs", "torch.abs", "torch.where", "torch.where", "pred.size", "target.size", "target.numel"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["@", "weighted_loss", "\n", "def", "smooth_l1_loss", "(", "pred", ",", "target", ",", "beta", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"Smooth L1 loss.\n\n    Args:\n        pred (torch.Tensor): The prediction.\n        target (torch.Tensor): The learning target of the prediction.\n        beta (float, optional): The threshold in the piecewise function.\n            Defaults to 1.0.\n\n    Returns:\n        torch.Tensor: Calculated loss\n    \"\"\"", "\n", "assert", "beta", ">", "0", "\n", "assert", "pred", ".", "size", "(", ")", "==", "target", ".", "size", "(", ")", "and", "target", ".", "numel", "(", ")", ">", "0", "\n", "diff", "=", "torch", ".", "abs", "(", "pred", "-", "target", ")", "\n", "loss", "=", "torch", ".", "where", "(", "diff", "<", "beta", ",", "0.5", "*", "diff", "*", "diff", "/", "beta", ",", "\n", "diff", "-", "0.5", "*", "beta", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.losses.smooth_l1_loss.l1_loss": [[31, 45], ["torch.abs", "torch.abs", "pred.size", "target.size", "target.numel"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "@", "weighted_loss", "\n", "def", "l1_loss", "(", "pred", ",", "target", ")", ":", "\n", "    ", "\"\"\"L1 loss.\n\n    Args:\n        pred (torch.Tensor): The prediction.\n        target (torch.Tensor): The learning target of the prediction.\n\n    Returns:\n        torch.Tensor: Calculated loss\n    \"\"\"", "\n", "assert", "pred", ".", "size", "(", ")", "==", "target", ".", "size", "(", ")", "and", "target", ".", "numel", "(", ")", ">", "0", "\n", "loss", "=", "torch", ".", "abs", "(", "pred", "-", "target", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment_overlaps": [[9, 108], ["isinstance", "isinstance", "torch.from_numpy.size", "torch.from_numpy.size", "torch.max.new_tensor", "torch.max", "torch.from_numpy", "torch.from_numpy", "torch.max", "torch.min", "torch.max", "torch.min", "ious.numpy.numpy", "torch.from_numpy.size", "torch.from_numpy.size", "torch.from_numpy.size", "torch.from_numpy.size", "torch.from_numpy.new", "torch.from_numpy.new"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["@", "registry", ".", "register_module", "(", "'base_anchor'", ")", "\n", "class", "SegmentBaseAnchor", ":", "\n", "\n", "    ", "def", "__init__", "(", "self", ",", "\n", "base_sizes", ",", "\n", "scales", "=", "None", ",", "\n", "octave_base_scale", "=", "None", ",", "\n", "scales_per_octave", "=", "None", ",", "\n", "centers", "=", "None", ",", "\n", "center_offset", "=", "0.", ")", ":", "\n", "        ", "\"\"\"Generate base anchors.\n\n        list(torch.Tensor): Base anchors of a feature grid in multiple\n            feature levels.\n        \"\"\"", "\n", "if", "center_offset", "!=", "0", ":", "\n", "            ", "assert", "centers", "is", "None", ",", "(", "\n", "f'center cannot be set when center_offset '", "\n", "f'!=0, {centers} is given.'", ")", "\n", "", "if", "not", "(", "0", "<=", "center_offset", "<=", "1", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'center_offset should be in range [0, 1], '", "\n", "f'{center_offset} is given.'", ")", "\n", "", "if", "centers", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "centers", ")", "==", "len", "(", "base_sizes", ")", ",", "(", "\n", "f'The number of base_sizes should be the same as centers, '", "\n", "f'got {base_sizes} and {centers}'", ")", "\n", "\n", "# calculate scales of anchors", "\n", "", "assert", "(", "\n", "(", "octave_base_scale", "is", "not", "None", "and", "scales_per_octave", "is", "not", "None", ")", "^", "\n", "(", "scales", "is", "not", "None", ")", "\n", ")", ",", "(", "'scales and octave_base_scale with scales_per_octave cannot be '", "\n", "'set at the same time'", ")", "\n", "if", "scales", "is", "not", "None", ":", "\n", "            ", "self", ".", "scales", "=", "torch", ".", "Tensor", "(", "scales", ")", "\n", "", "elif", "octave_base_scale", "is", "not", "None", "and", "scales_per_octave", "is", "not", "None", ":", "\n", "            ", "octave_scales", "=", "np", ".", "array", "(", "\n", "[", "2", "**", "(", "i", "/", "scales_per_octave", ")", "for", "i", "in", "range", "(", "scales_per_octave", ")", "]", ")", "\n", "scales", "=", "octave_scales", "*", "octave_base_scale", "\n", "self", ".", "scales", "=", "torch", ".", "Tensor", "(", "scales", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Either scales or octave_base_scale with '", "\n", "'scales_per_octave should be set'", ")", "\n", "\n", "", "self", ".", "base_sizes", "=", "base_sizes", "\n", "self", ".", "centers", "=", "centers", "\n", "self", ".", "center_offset", "=", "center_offset", "\n", "\n", "", "def", "generate", "(", "self", ")", ":", "\n", "        ", "multi_level_base_anchors", "=", "[", "]", "\n", "for", "i", ",", "base_size", "in", "enumerate", "(", "self", ".", "base_sizes", ")", ":", "\n", "            ", "center", "=", "None", "\n", "if", "self", ".", "centers", "is", "not", "None", ":", "\n", "                ", "center", "=", "self", ".", "centers", "[", "i", "]", "\n", "", "multi_level_base_anchors", ".", "append", "(", "\n", "self", ".", "_single_level_base_anchors", "(", "base_size", ",", "self", ".", "scales", ",", "\n", "self", ".", "center_offset", ",", "center", ")", ")", "\n", "", "return", "multi_level_base_anchors", "\n", "\n", "", "@", "staticmethod", "\n", "def", "_single_level_base_anchors", "(", "base_size", ",", "\n", "scales", ",", "\n", "center_offset", ",", "\n", "center", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate base anchors of a single level.\n\n        Args:\n            base_size (int | float): Basic temporal size of an anchor.\n            scales (torch.Tensor): Scales of the anchor.\n            center (tuple[float], optional): The center of the base anchor\n                related to a single feature grid. Defaults to None.\n\n        Returns:\n            torch.Tensor: Anchors in a single-level feature maps\n        \"\"\"", "\n", "if", "center", "is", "None", ":", "\n", "            ", "center", "=", "center_offset", "*", "(", "base_size", "-", "1", ")", "\n", "\n", "", "intervals", "=", "base_size", "*", "scales", "\n", "\n", "# use float anchor and the anchor's center is aligned with the", "\n", "# pixel center", "\n", "base_anchors", "=", "[", "center", "-", "0.5", "*", "intervals", ",", "center", "+", "0.5", "*", "intervals", "]", "\n", "base_anchors", "=", "torch", ".", "stack", "(", "base_anchors", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "base_anchors", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.multiclass_nms": [[110, 129], ["nms_cfg.copy", "nms_cfg.copy.get", "nms_cfg_.get.startswith", "segment._lb_multiclass_nms", "segment._multiclass_nmw", "segment._multiclass_nms"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment._lb_multiclass_nms", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment._multiclass_nmw", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment._multiclass_nms"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment._multiclass_nms": [[131, 183], ["vedacore.ops.batched_nms", "multi_scores.size", "multi_segments.view", "multi_segments[].expand", "valid_mask.nonzero", "multi_segments.new_zeros.numel", "multi_segments.new_zeros", "multi_segments.new_zeros", "multi_scores.size"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.batched_nms", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment._lb_multiclass_nms": [[185, 266], ["scores.argsort", "torch.empty", "torch.empty", "torch.empty", "torch.cat", "multi_scores.size", "multi_segments.view", "multi_segments[].expand", "valid_mask.nonzero", "multi_segments.new_zeros.numel", "multi_segments.new_zeros", "multi_segments.new_zeros", "min", "torch.cat", "torch.cat", "torch.cat", "vedacore.ops.batched_nms", "multi_scores.size"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.nms.nms_wrapper.batched_nms", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment._multiclass_nmw": [[268, 360], ["torch.stack.argsort", "nms_cfg.get", "nms_cfg.get", "torch.cat", "accu_weights.sum", "multi_scores.size", "multi_segments.view", "multi_segments[].expand", "valid_mask.nonzero", "torch.stack.numel", "multi_segments.new_zeros", "multi_segments.new_zeros", "scores.argsort.numel", "segment._multiclass_nmw._nmw"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.distance2segment": [[362, 379], ["torch.stack", "start.clamp.clamp", "end.clamp.clamp"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment2distance": [[381, 398], ["torch.stack", "left.clamp.clamp", "right.clamp.clamp"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment2roi": [[400, 420], ["enumerate", "torch.cat", "rois_list.append", "segments.size", "segments.new_full", "torch.cat", "segments.new_zeros", "segments.size"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment2result": [[422, 439], ["segments.cpu().numpy.cpu().numpy", "labels.cpu().numpy.cpu().numpy", "numpy.zeros", "range", "segments.cpu().numpy.cpu", "labels.cpu().numpy.cpu", "range"], "function", ["None"], []], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.demodata.ensure_rng": [[7, 29], ["isinstance", "numpy.random.RandomState", "numpy.np.float32"], "function", ["None"], ["def", "ensure_rng", "(", "rng", "=", "None", ")", ":", "\n", "    ", "\"\"\"Simple version of the ``kwarray.ensure_rng``\n\n    Args:\n        rng (int | numpy.random.RandomState | None):\n            if None, then defaults to the global rng. Otherwise this can be an\n            integer or a RandomState class\n    Returns:\n        (numpy.random.RandomState) : rng -\n            a numpy random number generator\n\n    References:\n        https://gitlab.kitware.com/computer-vision/kwarray/blob/master/kwarray/util_random.py#L270\n    \"\"\"", "\n", "\n", "if", "rng", "is", "None", ":", "\n", "        ", "rng", "=", "np", ".", "random", ".", "mtrand", ".", "_rand", "\n", "", "elif", "isinstance", "(", "rng", ",", "int", ")", ":", "\n", "        ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "rng", ")", "\n", "", "else", ":", "\n", "        ", "rng", "=", "rng", "\n", "", "return", "rng", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.demodata.random_segments": [[31, 61], ["demodata.ensure_rng", "ensure_rng.rand().astype", "numpy.minimum", "numpy.maximum", "torch.from_numpy", "ensure_rng.rand"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.demodata.ensure_rng"], ["", "def", "random_segments", "(", "num", "=", "1", ",", "scale", "=", "1", ",", "rng", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        Tensor: shape (n, 2) in start, end format.\n\n    References:\n        https://gitlab.kitware.com/computer-vision/kwimage/blob/master/kwimage/structs/boxes.py#L1390\n\n    Example:\n        >>> num = 3\n        >>> scale = 512\n        >>> rng = 0\n        >>> segments = random_segments(num, scale, rng)\n        >>> print(segments)\n        tensor([[280.9925, 366.1769],\n                [278.9802, 308.6148],\n                [216.9113, 330.6978]])\n    \"\"\"", "\n", "rng", "=", "ensure_rng", "(", "rng", ")", "\n", "\n", "segments", "=", "rng", ".", "rand", "(", "num", ",", "2", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "start", "=", "np", ".", "minimum", "(", "segments", "[", ":", ",", "0", "]", ",", "segments", "[", ":", ",", "1", "]", ")", "\n", "end", "=", "np", ".", "maximum", "(", "segments", "[", ":", ",", "0", "]", ",", "segments", "[", ":", ",", "1", "]", ")", "\n", "\n", "segments", "[", ":", ",", "0", "]", "=", "start", "*", "scale", "\n", "segments", "[", ":", ",", "1", "]", "=", "end", "*", "scale", "\n", "\n", "segments", "=", "torch", ".", "from_numpy", "(", "segments", ")", "\n", "return", "segments", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.util_mixins.NiceRepr.__nice__": [[75, 85], ["hasattr", "str", "NotImplementedError", "len"], "methods", ["None"], ["def", "__nice__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: a \"nice\" summary string describing this module\"\"\"", "\n", "if", "hasattr", "(", "self", ",", "'__len__'", ")", ":", "\n", "# It is a common pattern for objects to use __len__ in __nice__", "\n", "# As a convenience we define a default __nice__ for these objects", "\n", "            ", "return", "str", "(", "len", "(", "self", ")", ")", "\n", "", "else", ":", "\n", "# In all other cases force the subclass to overload __nice__", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "f'Define the __nice__ method for {self.__class__!r}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.util_mixins.NiceRepr.__repr__": [[86, 95], ["util_mixins.NiceRepr.__nice__", "warnings.warn", "object.__repr__", "hex", "str", "id"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.__nice__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.iou_calculators.iou_calculator.SegmentOverlaps.__repr__"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: the string of the module\"\"\"", "\n", "try", ":", "\n", "            ", "nice", "=", "self", ".", "__nice__", "(", ")", "\n", "classname", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "f'<{classname}({nice}) at {hex(id(self))}>'", "\n", "", "except", "NotImplementedError", "as", "ex", ":", "\n", "            ", "warnings", ".", "warn", "(", "str", "(", "ex", ")", ",", "category", "=", "RuntimeWarning", ")", "\n", "return", "object", ".", "__repr__", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.util_mixins.NiceRepr.__str__": [[96, 105], ["util_mixins.NiceRepr.__nice__", "warnings.warn", "object.__repr__", "str"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.__nice__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.iou_calculators.iou_calculator.SegmentOverlaps.__repr__"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: the string of the module\"\"\"", "\n", "try", ":", "\n", "            ", "classname", "=", "self", ".", "__class__", ".", "__name__", "\n", "nice", "=", "self", ".", "__nice__", "(", ")", "\n", "return", "f'<{classname}({nice})>'", "\n", "", "except", "NotImplementedError", "as", "ex", ":", "\n", "            ", "warnings", ".", "warn", "(", "str", "(", "ex", ")", ",", "category", "=", "RuntimeWarning", ")", "\n", "return", "object", ".", "__repr__", "(", "self", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.builder.build_assigner": [[4, 7], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "import", "torch", "\n", "\n", "from", "vedacore", ".", "misc", "import", "build_from_cfg", ",", "registry", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.builder.build_sampler": [[9, 12], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "def", "register_torch_optimizers", "(", ")", ":", "\n", "    ", "torch_optimizers", "=", "[", "]", "\n", "for", "module_name", "in", "dir", "(", "torch", ".", "optim", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.builder.build_segment_coder": [[14, 19], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["            ", "continue", "\n", "", "_optim", "=", "getattr", "(", "torch", ".", "optim", ",", "module_name", ")", "\n", "if", "inspect", ".", "isclass", "(", "_optim", ")", "and", "issubclass", "(", "_optim", ",", "\n", "torch", ".", "optim", ".", "Optimizer", ")", ":", "\n", "            ", "registry", ".", "register_module", "(", "'optimizer'", ")", "(", "_optim", ")", "\n", "torch_optimizers", ".", "append", "(", "module_name", ")", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.base_segment_coder.BaseSegmentCoder.__init__": [[9, 11], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.base_segment_coder.BaseSegmentCoder.encode": [[12, 16], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "encode", "(", "self", ",", "segments", ",", "gt_segments", ")", ":", "\n", "        ", "\"\"\"Encode deltas between segments and ground truth segments.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.base_segment_coder.BaseSegmentCoder.decode": [[17, 22], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "decode", "(", "self", ",", "segments", ",", "segments_pred", ")", ":", "\n", "        ", "\"\"\"Decode the predicted segments according to prediction and base\n        segments.\"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.delta_segment_coder.DeltaSegmentCoder.__init__": [[25, 29], ["base_segment_coder.BaseSegmentCoder.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "target_means", "=", "(", "0.", ",", "0.", ")", ",", "target_stds", "=", "(", "1.", ",", "1.", ")", ")", ":", "\n", "        ", "super", "(", "BaseSegmentCoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "means", "=", "target_means", "\n", "self", ".", "stds", "=", "target_stds", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.delta_segment_coder.DeltaSegmentCoder.encode": [[30, 48], ["delta_segment_coder.segment2delta", "segments.size", "gt_segments.size", "segments.size", "gt_segments.size"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.delta_segment_coder.segment2delta", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "encode", "(", "self", ",", "segments", ",", "gt_segments", ")", ":", "\n", "        ", "\"\"\"Get segment regression transformation deltas that can be used to\n        transform the ``segments`` into the ``gt_segments``.\n\n        Args:\n            segments (torch.Tensor): Source segments, e.g., object proposals.\n            gt_segments (torch.Tensor): Target of the transformation, e.g.,\n                ground-truth segments.\n\n        Returns:\n            torch.Tensor: segment transformation deltas\n        \"\"\"", "\n", "\n", "assert", "segments", ".", "size", "(", "0", ")", "==", "gt_segments", ".", "size", "(", "0", ")", "\n", "assert", "segments", ".", "size", "(", "-", "1", ")", "==", "gt_segments", ".", "size", "(", "-", "1", ")", "==", "2", "\n", "encoded_segments", "=", "segment2delta", "(", "segments", ",", "gt_segments", ",", "self", ".", "means", ",", "\n", "self", ".", "stds", ")", "\n", "return", "encoded_segments", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.delta_segment_coder.DeltaSegmentCoder.decode": [[49, 67], ["delta_segment_coder.delta2segment", "pred_segments.size", "segments.size"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.delta_segment_coder.delta2segment", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "decode", "(", "self", ",", "segments", ",", "pred_segments", ",", "max_t", "=", "None", ")", ":", "\n", "        ", "\"\"\"Apply transformation `pred_segments` to `segments`.\n\n        Args:\n            segments (torch.Tensor): Basic segments.\n            pred_segments (torch.Tensor): Encoded segments with shape\n            max_t (int, optional): Maximum time of segments.\n                Defaults to None.\n\n        Returns:\n            torch.Tensor: Decoded segments.\n        \"\"\"", "\n", "\n", "assert", "pred_segments", ".", "size", "(", "0", ")", "==", "segments", ".", "size", "(", "0", ")", "\n", "decoded_segments", "=", "delta2segment", "(", "segments", ",", "pred_segments", ",", "self", ".", "means", ",", "\n", "self", ".", "stds", ",", "max_t", ")", "\n", "\n", "return", "decoded_segments", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.delta_segment_coder.segment2delta": [[69, 107], ["proposals.float.float", "gt.float.float", "torch.log", "torch.stack", "deltas.sub_().div_.new_tensor().unsqueeze", "deltas.sub_().div_.new_tensor().unsqueeze", "deltas.sub_().div_.sub_().div_", "proposals.float.size", "gt.float.size", "deltas.sub_().div_.new_tensor", "deltas.sub_().div_.new_tensor", "deltas.sub_().div_.sub_"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "", "def", "segment2delta", "(", "proposals", ",", "gt", ",", "means", "=", "(", "0.", ",", "0.", ")", ",", "stds", "=", "(", "1.", ",", "1.", ")", ")", ":", "\n", "    ", "\"\"\"Compute deltas of proposals w.r.t. gt.\n\n    We usually compute the deltas of center, interval of proposals w.r.t ground\n    truth segments to get regression target.\n    This is the inverse function of :func:`delta2segment`.\n\n    Args:\n        proposals (Tensor): Segments to be transformed, shape (N, ..., 2)\n        gt (Tensor): Gt segments to be used as base, shape (N, ..., 2)\n        means (Sequence[float]): Denormalizing means for delta coordinates\n        stds (Sequence[float]): Denormalizing standard deviation for delta\n            coordinates\n\n    Returns:\n        Tensor: deltas with shape (N, 2), where columns represent d_center,\n            d_interval\n    \"\"\"", "\n", "assert", "proposals", ".", "size", "(", ")", "==", "gt", ".", "size", "(", ")", "\n", "\n", "proposals", "=", "proposals", ".", "float", "(", ")", "\n", "gt", "=", "gt", ".", "float", "(", ")", "\n", "\n", "p_center", "=", "(", "proposals", "[", "...", ",", "0", "]", "+", "proposals", "[", "...", ",", "1", "]", ")", "*", "0.5", "\n", "p_interval", "=", "proposals", "[", "...", ",", "1", "]", "-", "proposals", "[", "...", ",", "0", "]", "\n", "\n", "g_center", "=", "(", "gt", "[", "...", ",", "0", "]", "+", "gt", "[", "...", ",", "1", "]", ")", "*", "0.5", "\n", "g_interval", "=", "gt", "[", "...", ",", "1", "]", "-", "gt", "[", "...", ",", "0", "]", "\n", "\n", "d_center", "=", "(", "g_center", "-", "p_center", ")", "/", "p_interval", "\n", "d_interval", "=", "torch", ".", "log", "(", "g_interval", "/", "p_interval", ")", "\n", "deltas", "=", "torch", ".", "stack", "(", "[", "d_center", ",", "d_interval", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "means", "=", "deltas", ".", "new_tensor", "(", "means", ")", ".", "unsqueeze", "(", "0", ")", "\n", "stds", "=", "deltas", ".", "new_tensor", "(", "stds", ")", ".", "unsqueeze", "(", "0", ")", "\n", "deltas", "=", "deltas", ".", "sub_", "(", "means", ")", ".", "div_", "(", "stds", ")", "\n", "\n", "return", "deltas", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.delta_segment_coder.delta2segment": [[109, 170], ["deltas.new_tensor().repeat", "deltas.new_tensor().repeat", "torch.stack().view_as", "d_interval.exp", "start.clamp.clamp", "end.clamp.clamp", "deltas.new_tensor", "deltas.size", "deltas.new_tensor", "deltas.size", "torch.stack"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.stack"], ["", "def", "delta2segment", "(", "rois", ",", "deltas", ",", "means", "=", "(", "0.", ",", "0.", ")", ",", "stds", "=", "(", "1.", ",", "1.", ")", ",", "max_t", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply deltas to shift/scale base segments.\n\n    Typically the rois are anchor or proposed segments and the deltas are\n    network outputs used to shift/scale those segments.\n    This is the inverse function of :func:`segment2delta`.\n\n    Args:\n        rois (Tensor): Segments to be transformed. Has shape (N, 2)\n        deltas (Tensor): Encoded offsets with respect to each roi.\n            Has shape (N, 2 * num_classes). Note N = num_anchors * T when\n            rois is a grid of anchors. Offset encoding follows [1]_.\n        means (Sequence[float]): Denormalizing means for delta coordinates\n        stds (Sequence[float]): Denormalizing standard deviation for delta\n            coordinates\n        max_t (int): Maximum time for segments. specifies T\n\n    Returns:\n        Tensor: Segments with shape (N, 2), where columns represent\n            start, end.\n\n    References:\n        .. [1] https://arxiv.org/abs/1311.2524\n\n    Example:\n        >>> rois = torch.Tensor([[ 0.,  1.],\n        >>>                      [ 0.,  1.],\n        >>>                      [ 0.,  1.],\n        >>>                      [ 5., 5.]])\n        >>> deltas = torch.Tensor([[  0.,   0.],\n        >>>                        [  1.,   1.],\n        >>>                        [  0.,   2.],\n        >>>                        [ 0.7, -0.5]])\n        >>> delta2segment(rois, deltas, max_t=32)\n        tensor([[0.0000, 1.0000],\n                [0.1409, 2.8591],\n                [0.0000, 4.1945],\n                [5.0000, 5.0000]])\n    \"\"\"", "\n", "means", "=", "deltas", ".", "new_tensor", "(", "means", ")", ".", "repeat", "(", "1", ",", "deltas", ".", "size", "(", "1", ")", "//", "2", ")", "\n", "stds", "=", "deltas", ".", "new_tensor", "(", "stds", ")", ".", "repeat", "(", "1", ",", "deltas", ".", "size", "(", "1", ")", "//", "2", ")", "\n", "denorm_deltas", "=", "deltas", "*", "stds", "+", "means", "\n", "d_center", "=", "denorm_deltas", "[", ":", ",", "0", ":", ":", "2", "]", "\n", "d_interval", "=", "denorm_deltas", "[", ":", ",", "1", ":", ":", "2", "]", "\n", "# Compute center of each roi", "\n", "p_center", "=", "(", "(", "rois", "[", ":", ",", "0", "]", "+", "rois", "[", ":", ",", "1", "]", ")", "*", "\n", "0.5", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "d_center", ")", "\n", "# Compute interval of each roi", "\n", "p_interval", "=", "(", "rois", "[", ":", ",", "1", "]", "-", "rois", "[", ":", ",", "0", "]", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "d_interval", ")", "\n", "# Use exp(network energy) to enlarge/shrink each roi", "\n", "g_interval", "=", "p_interval", "*", "d_interval", ".", "exp", "(", ")", "\n", "# Use network energy to shift the center of each roi", "\n", "g_center", "=", "p_center", "+", "p_interval", "*", "d_center", "\n", "# Convert center-xy/width/height to top-left, bottom-right", "\n", "start", "=", "g_center", "-", "g_interval", "*", "0.5", "\n", "end", "=", "g_center", "+", "g_interval", "*", "0.5", "\n", "if", "max_t", "is", "not", "None", ":", "\n", "        ", "start", "=", "start", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_t", ")", "\n", "end", "=", "end", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "max_t", ")", "\n", "", "segments", "=", "torch", ".", "stack", "(", "[", "start", ",", "end", "]", ",", "dim", "=", "-", "1", ")", ".", "view_as", "(", "deltas", ")", "\n", "return", "segments", "\n", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.__init__": [[11, 13], ["base_segment_coder.BaseSegmentCoder.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "BaseSegmentCoder", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.encode": [[14, 17], ["None"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "segments", ",", "gt_segments", ")", ":", "\n", "        ", "\"\"\"torch.Tensor: return the given ``segments``\"\"\"", "\n", "return", "gt_segments", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.coders.pseudo_segment_coder.PseudoSegmentCoder.decode": [[18, 21], ["None"], "methods", ["None"], ["", "def", "decode", "(", "self", ",", "segments", ",", "pred_segments", ")", ":", "\n", "        ", "\"\"\"torch.Tensor: return the given ``pred_segments``\"\"\"", "\n", "return", "pred_segments", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.base_assigner.BaseAssigner.assign": [[9, 18], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "assign", "(", "self", ",", "\n", "segments", ",", "\n", "gt_segments", ",", "\n", "gt_segments_ignore", "=", "None", ",", "\n", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign segments to either a ground truth segment or a negative\n        segment.\"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.max_iou_assigner.MaxIoUAssigner.__init__": [[42, 61], ["dict", "iou_calculators.build_iou_calculator"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.iou_calculators.builder.build_iou_calculator"], ["def", "__init__", "(", "self", ",", "\n", "pos_iou_thr", ",", "\n", "neg_iou_thr", ",", "\n", "min_pos_iou", "=", ".0", ",", "\n", "gt_max_assign_all", "=", "True", ",", "\n", "ignore_iof_thr", "=", "-", "1", ",", "\n", "ignore_wrt_candidates", "=", "True", ",", "\n", "match_low_quality", "=", "True", ",", "\n", "gpu_assign_thr", "=", "-", "1", ",", "\n", "iou_calculator", "=", "dict", "(", "typename", "=", "'SegmentOverlaps'", ")", ")", ":", "\n", "        ", "self", ".", "pos_iou_thr", "=", "pos_iou_thr", "\n", "self", ".", "neg_iou_thr", "=", "neg_iou_thr", "\n", "self", ".", "min_pos_iou", "=", "min_pos_iou", "\n", "self", ".", "gt_max_assign_all", "=", "gt_max_assign_all", "\n", "self", ".", "ignore_iof_thr", "=", "ignore_iof_thr", "\n", "self", ".", "ignore_wrt_candidates", "=", "ignore_wrt_candidates", "\n", "self", ".", "gpu_assign_thr", "=", "gpu_assign_thr", "\n", "self", ".", "match_low_quality", "=", "match_low_quality", "\n", "self", ".", "iou_calculator", "=", "build_iou_calculator", "(", "iou_calculator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.max_iou_assigner.MaxIoUAssigner.assign": [[62, 133], ["max_iou_assigner.MaxIoUAssigner.iou_calculator", "max_iou_assigner.MaxIoUAssigner.assign_wrt_overlaps", "segments.cpu.cpu.cpu", "gt_segments.cpu.cpu.cpu", "max_iou_assigner.MaxIoUAssigner.gt_inds.to", "max_iou_assigner.MaxIoUAssigner.max_overlaps.to", "gt_segments_ignore.cpu.cpu.cpu", "gt_labels.cpu.cpu.cpu", "gt_segments_ignore.cpu.cpu.numel", "segments.cpu.cpu.numel", "max_iou_assigner.MaxIoUAssigner.iou_calculator", "max_iou_assigner.MaxIoUAssigner.max", "max_iou_assigner.MaxIoUAssigner.iou_calculator", "max_iou_assigner.MaxIoUAssigner.max", "max_iou_assigner.MaxIoUAssigner.labels.to"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.max_iou_assigner.MaxIoUAssigner.assign_wrt_overlaps", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to", "home.repos.pwc.inspect_result.Media-Smart_vedatad.samplers.sampling_result.SamplingResult.to"], ["", "def", "assign", "(", "self", ",", "\n", "segments", ",", "\n", "gt_segments", ",", "\n", "gt_segments_ignore", "=", "None", ",", "\n", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign gt to segments.\n\n        This method assign a gt segment to every segment (proposal/anchor),\n        each segment will be assigned with -1, or a semi-positive number. -1\n        means negative sample, semi-positive number is the index (0-based) of\n        assigned gt.\n        The assignment is done in following steps, the order matters.\n\n        1. assign every segment to the background\n        2. assign proposals whose iou with all gts < neg_iou_thr to 0\n        3. for each segment, if the iou with its nearest gt >= pos_iou_thr,\n           assign it to that segment\n        4. for each gt segment, assign its nearest proposals (may be more than\n           one) to itself\n\n        Args:\n            segments (Tensor): Segments to be assigned, shape(n, 2).\n            gt_segments (Tensor): Groundtruth segments, shape (k, 2).\n            gt_segments_ignore (Tensor, optional): Ground truth segments that\n                are labelled as `ignored`.\n            gt_labels (Tensor, optional): Label of gt_segments, shape (k, ).\n\n        Returns:\n            :obj:`AssignResult`: The assign result.\n\n        Example:\n            >>> self = MaxIoUAssigner(0.5, 0.5)\n            >>> segments = torch.Tensor([[0., 10.], [10., 20.]])\n            >>> gt_segments = torch.Tensor([[0., 10.]])\n            >>> assign_result = self.assign(segments, gt_segments)\n            >>> expected_gt_inds = torch.LongTensor([1, 0])\n            >>> assert torch.all(assign_result.gt_inds == expected_gt_inds)\n        \"\"\"", "\n", "assign_on_cpu", "=", "True", "if", "(", "self", ".", "gpu_assign_thr", ">", "0", ")", "and", "(", "\n", "gt_segments", ".", "shape", "[", "0", "]", ">", "self", ".", "gpu_assign_thr", ")", "else", "False", "\n", "# compute overlap and assign gt on CPU when number of GT is large", "\n", "if", "assign_on_cpu", ":", "\n", "            ", "device", "=", "segments", ".", "device", "\n", "segments", "=", "segments", ".", "cpu", "(", ")", "\n", "gt_segments", "=", "gt_segments", ".", "cpu", "(", ")", "\n", "if", "gt_segments_ignore", "is", "not", "None", ":", "\n", "                ", "gt_segments_ignore", "=", "gt_segments_ignore", ".", "cpu", "(", ")", "\n", "", "if", "gt_labels", "is", "not", "None", ":", "\n", "                ", "gt_labels", "=", "gt_labels", ".", "cpu", "(", ")", "\n", "\n", "", "", "overlaps", "=", "self", ".", "iou_calculator", "(", "gt_segments", ",", "segments", ")", "\n", "\n", "if", "(", "self", ".", "ignore_iof_thr", ">", "0", "and", "gt_segments_ignore", "is", "not", "None", "\n", "and", "gt_segments_ignore", ".", "numel", "(", ")", ">", "0", "and", "segments", ".", "numel", "(", ")", ">", "0", ")", ":", "\n", "            ", "if", "self", ".", "ignore_wrt_candidates", ":", "\n", "                ", "ignore_overlaps", "=", "self", ".", "iou_calculator", "(", "\n", "segments", ",", "gt_segments_ignore", ",", "mode", "=", "'iof'", ")", "\n", "ignore_max_overlaps", ",", "_", "=", "ignore_overlaps", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "ignore_overlaps", "=", "self", ".", "iou_calculator", "(", "\n", "gt_segments_ignore", ",", "segments", ",", "mode", "=", "'iof'", ")", "\n", "ignore_max_overlaps", ",", "_", "=", "ignore_overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "", "overlaps", "[", ":", ",", "ignore_max_overlaps", ">", "self", ".", "ignore_iof_thr", "]", "=", "-", "1", "\n", "\n", "", "assign_result", "=", "self", ".", "assign_wrt_overlaps", "(", "overlaps", ",", "gt_labels", ")", "\n", "if", "assign_on_cpu", ":", "\n", "            ", "assign_result", ".", "gt_inds", "=", "assign_result", ".", "gt_inds", ".", "to", "(", "device", ")", "\n", "assign_result", ".", "max_overlaps", "=", "assign_result", ".", "max_overlaps", ".", "to", "(", "device", ")", "\n", "if", "assign_result", ".", "labels", "is", "not", "None", ":", "\n", "                ", "assign_result", ".", "labels", "=", "assign_result", ".", "labels", ".", "to", "(", "device", ")", "\n", "", "", "return", "assign_result", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.max_iou_assigner.MaxIoUAssigner.assign_wrt_overlaps": [[134, 221], ["overlaps.new_full", "overlaps.max", "overlaps.max", "isinstance", "assign_result.AssignResult", "overlaps.size", "overlaps.size", "overlaps.new_zeros", "assign_result.AssignResult", "isinstance", "range", "overlaps.new_full.new_full", "torch.nonzero().squeeze", "overlaps.new_full", "torch.nonzero().squeeze.numel", "len", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["", "def", "assign_wrt_overlaps", "(", "self", ",", "overlaps", ",", "gt_labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"Assign w.r.t. the overlaps of segments with gts.\n\n        Args:\n            overlaps (Tensor): Overlaps between k gt_segments and n segments,\n                shape(k, n).\n            gt_labels (Tensor, optional): Labels of k gt_segments, shape (k, ).\n\n        Returns:\n            :obj:`AssignResult`: The assign result.\n        \"\"\"", "\n", "num_gts", ",", "num_segments", "=", "overlaps", ".", "size", "(", "0", ")", ",", "overlaps", ".", "size", "(", "1", ")", "\n", "\n", "# 1. assign -1 by default", "\n", "assigned_gt_inds", "=", "overlaps", ".", "new_full", "(", "(", "num_segments", ",", ")", ",", "\n", "-", "1", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "if", "num_gts", "==", "0", "or", "num_segments", "==", "0", ":", "\n", "# No ground truth or segments, return empty assignment", "\n", "            ", "max_overlaps", "=", "overlaps", ".", "new_zeros", "(", "(", "num_segments", ",", ")", ")", "\n", "if", "num_gts", "==", "0", ":", "\n", "# No truth, assign everything to background", "\n", "                ", "assigned_gt_inds", "[", ":", "]", "=", "0", "\n", "", "if", "gt_labels", "is", "None", ":", "\n", "                ", "assigned_labels", "=", "None", "\n", "", "else", ":", "\n", "                ", "assigned_labels", "=", "overlaps", ".", "new_full", "(", "(", "num_segments", ",", ")", ",", "\n", "-", "1", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "", "return", "AssignResult", "(", "\n", "num_gts", ",", "\n", "assigned_gt_inds", ",", "\n", "max_overlaps", ",", "\n", "labels", "=", "assigned_labels", ")", "\n", "\n", "# for each anchor, which gt best overlaps with it", "\n", "# for each anchor, the max iou of all gts", "\n", "", "max_overlaps", ",", "argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "# for each gt, which anchor best overlaps with it", "\n", "# for each gt, the max iou of all proposals", "\n", "gt_max_overlaps", ",", "gt_argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "1", ")", "\n", "\n", "# 2. assign negative: below", "\n", "# the negative inds are set to be 0", "\n", "if", "isinstance", "(", "self", ".", "neg_iou_thr", ",", "float", ")", ":", "\n", "            ", "assigned_gt_inds", "[", "(", "max_overlaps", ">=", "0", ")", "\n", "&", "(", "max_overlaps", "<", "self", ".", "neg_iou_thr", ")", "]", "=", "0", "\n", "", "elif", "isinstance", "(", "self", ".", "neg_iou_thr", ",", "tuple", ")", ":", "\n", "            ", "assert", "len", "(", "self", ".", "neg_iou_thr", ")", "==", "2", "\n", "assigned_gt_inds", "[", "(", "max_overlaps", ">=", "self", ".", "neg_iou_thr", "[", "0", "]", ")", "\n", "&", "(", "max_overlaps", "<", "self", ".", "neg_iou_thr", "[", "1", "]", ")", "]", "=", "0", "\n", "\n", "# 3. assign positive: above positive IoU threshold", "\n", "", "pos_inds", "=", "max_overlaps", ">=", "self", ".", "pos_iou_thr", "\n", "assigned_gt_inds", "[", "pos_inds", "]", "=", "argmax_overlaps", "[", "pos_inds", "]", "+", "1", "\n", "\n", "if", "self", ".", "match_low_quality", ":", "\n", "# Low-quality matching will overwirte the assigned_gt_inds assigned", "\n", "# in Step 3. Thus, the assigned gt might not be the best one for", "\n", "# prediction.", "\n", "# For example, if segment A has 0.9 and 0.8 iou with GT segment", "\n", "# 1 & 2, segment 1 will be assigned as the best target for segment", "\n", "# A in step 3.", "\n", "# However, if GT segment 2's gt_argmax_overlaps = A, segment A's", "\n", "# assigned_gt_inds will be overwritten to be segment B.", "\n", "# This might be the reason that it is not used in ROI Heads.", "\n", "            ", "for", "i", "in", "range", "(", "num_gts", ")", ":", "\n", "                ", "if", "gt_max_overlaps", "[", "i", "]", ">=", "self", ".", "min_pos_iou", ":", "\n", "                    ", "if", "self", ".", "gt_max_assign_all", ":", "\n", "                        ", "max_iou_inds", "=", "overlaps", "[", "i", ",", ":", "]", "==", "gt_max_overlaps", "[", "i", "]", "\n", "assigned_gt_inds", "[", "max_iou_inds", "]", "=", "i", "+", "1", "\n", "", "else", ":", "\n", "                        ", "assigned_gt_inds", "[", "gt_argmax_overlaps", "[", "i", "]", "]", "=", "i", "+", "1", "\n", "\n", "", "", "", "", "if", "gt_labels", "is", "not", "None", ":", "\n", "            ", "assigned_labels", "=", "assigned_gt_inds", ".", "new_full", "(", "(", "num_segments", ",", ")", ",", "-", "1", ")", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "\n", "assigned_gt_inds", ">", "0", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "if", "pos_inds", ".", "numel", "(", ")", ">", "0", ":", "\n", "                ", "assigned_labels", "[", "pos_inds", "]", "=", "gt_labels", "[", "\n", "assigned_gt_inds", "[", "pos_inds", "]", "-", "1", "]", "\n", "", "", "else", ":", "\n", "            ", "assigned_labels", "=", "None", "\n", "\n", "", "return", "AssignResult", "(", "\n", "num_gts", ",", "assigned_gt_inds", ",", "max_overlaps", ",", "labels", "=", "assigned_labels", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.__init__": [[44, 51], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_gts", ",", "gt_inds", ",", "max_overlaps", ",", "labels", "=", "None", ")", ":", "\n", "        ", "self", ".", "num_gts", "=", "num_gts", "\n", "self", ".", "gt_inds", "=", "gt_inds", "\n", "self", ".", "max_overlaps", "=", "max_overlaps", "\n", "self", ".", "labels", "=", "labels", "\n", "# Interface for possible user-defined properties", "\n", "self", ".", "_extra_properties", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.num_preds": [[52, 56], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_preds", "(", "self", ")", ":", "\n", "        ", "\"\"\"int: the number of predictions in this assignment\"\"\"", "\n", "return", "len", "(", "self", ".", "gt_inds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.set_extra_property": [[57, 61], ["None"], "methods", ["None"], ["", "def", "set_extra_property", "(", "self", ",", "key", ",", "value", ")", ":", "\n", "        ", "\"\"\"Set user-defined new property.\"\"\"", "\n", "assert", "key", "not", "in", "self", ".", "info", "\n", "self", ".", "_extra_properties", "[", "key", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.get_extra_property": [[62, 65], ["assign_result.AssignResult._extra_properties.get"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "get_extra_property", "(", "self", ",", "key", ")", ":", "\n", "        ", "\"\"\"Get user-defined property.\"\"\"", "\n", "return", "self", ".", "_extra_properties", ".", "get", "(", "key", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.info": [[66, 78], ["basic_info.update"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.progressbar.ProgressBar.update"], ["", "@", "property", "\n", "def", "info", "(", "self", ")", ":", "\n", "        ", "\"\"\"dict: a dictionary of info about the object\"\"\"", "\n", "basic_info", "=", "{", "\n", "'num_gts'", ":", "self", ".", "num_gts", ",", "\n", "'num_preds'", ":", "self", ".", "num_preds", ",", "\n", "'gt_inds'", ":", "self", ".", "gt_inds", ",", "\n", "'max_overlaps'", ":", "self", ".", "max_overlaps", ",", "\n", "'labels'", ":", "self", ".", "labels", ",", "\n", "}", "\n", "basic_info", ".", "update", "(", "self", ".", "_extra_properties", ")", "\n", "return", "basic_info", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.__nice__": [[79, 97], ["parts.append", "parts.append", "parts.append", "parts.append", "parts.append", "parts.append", "parts.append", "tuple", "tuple", "tuple"], "methods", ["None"], ["", "def", "__nice__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: a \"nice\" summary string describing this assign result\"\"\"", "\n", "parts", "=", "[", "]", "\n", "parts", ".", "append", "(", "f'num_gts={self.num_gts!r}'", ")", "\n", "if", "self", ".", "gt_inds", "is", "None", ":", "\n", "            ", "parts", ".", "append", "(", "f'gt_inds={self.gt_inds!r}'", ")", "\n", "", "else", ":", "\n", "            ", "parts", ".", "append", "(", "f'gt_inds.shape={tuple(self.gt_inds.shape)!r}'", ")", "\n", "", "if", "self", ".", "max_overlaps", "is", "None", ":", "\n", "            ", "parts", ".", "append", "(", "f'max_overlaps={self.max_overlaps!r}'", ")", "\n", "", "else", ":", "\n", "            ", "parts", ".", "append", "(", "'max_overlaps.shape='", "\n", "f'{tuple(self.max_overlaps.shape)!r}'", ")", "\n", "", "if", "self", ".", "labels", "is", "None", ":", "\n", "            ", "parts", ".", "append", "(", "f'labels={self.labels!r}'", ")", "\n", "", "else", ":", "\n", "            ", "parts", ".", "append", "(", "f'labels.shape={tuple(self.labels.shape)!r}'", ")", "\n", "", "return", "', '", ".", "join", "(", "parts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.random": [[98, 191], ["demodata.ensure_rng", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "kwargs.get", "cls", "kwargs.get", "demodata.ensure_rng.randint", "demodata.ensure_rng.randint", "torch.zeros", "torch.zeros", "torch.from_numpy", "torch.from_numpy", "min", "demodata.ensure_rng.shuffle", "assigned_idxs.sort", "torch.zeros", "np.arange", "demodata.ensure_rng.shuffle", "torch.from_numpy", "torch.from_numpy", "torch.zeros", "demodata.ensure_rng.rand", "min", "np.where", "torch.from_numpy", "demodata.ensure_rng.randint", "demodata.ensure_rng.rand", "demodata.ensure_rng.rand", "torch.from_numpy.sum", "demodata.ensure_rng.rand", "torch.zeros", "torch.from_numpy", "demodata.ensure_rng.rand", "demodata.ensure_rng.randint"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.demodata.ensure_rng", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "@", "classmethod", "\n", "def", "random", "(", "cls", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Create random AssignResult for tests or debugging.\n\n        Args:\n            num_preds: number of predicted segments\n            num_gts: number of true segments\n            p_ignore (float): probability of a predicted segment assinged to an\n                ignored truth\n            p_assigned (float): probability of a predicted segment not being\n                assigned\n            p_use_label (float | bool): with labels or not\n            rng (None | int | numpy.random.RandomState): seed or state\n\n        Returns:\n            :obj:`AssignResult`: Randomly generated assign results.\n\n        Example:\n            >>> self = AssignResult.random()\n            >>> print(self.info)\n        \"\"\"", "\n", "from", ".", ".", "import", "demodata", "\n", "rng", "=", "demodata", ".", "ensure_rng", "(", "kwargs", ".", "get", "(", "'rng'", ",", "None", ")", ")", "\n", "\n", "num_gts", "=", "kwargs", ".", "get", "(", "'num_gts'", ",", "None", ")", "\n", "num_preds", "=", "kwargs", ".", "get", "(", "'num_preds'", ",", "None", ")", "\n", "p_ignore", "=", "kwargs", ".", "get", "(", "'p_ignore'", ",", "0.3", ")", "\n", "p_assigned", "=", "kwargs", ".", "get", "(", "'p_assigned'", ",", "0.7", ")", "\n", "p_use_label", "=", "kwargs", ".", "get", "(", "'p_use_label'", ",", "0.5", ")", "\n", "num_classes", "=", "kwargs", ".", "get", "(", "'p_use_label'", ",", "3", ")", "\n", "\n", "if", "num_gts", "is", "None", ":", "\n", "            ", "num_gts", "=", "rng", ".", "randint", "(", "0", ",", "8", ")", "\n", "", "if", "num_preds", "is", "None", ":", "\n", "            ", "num_preds", "=", "rng", ".", "randint", "(", "0", ",", "16", ")", "\n", "\n", "", "if", "num_gts", "==", "0", ":", "\n", "            ", "max_overlaps", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "gt_inds", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "if", "p_use_label", "is", "True", "or", "p_use_label", "<", "rng", ".", "rand", "(", ")", ":", "\n", "                ", "labels", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "", "else", ":", "\n", "                ", "labels", "=", "None", "\n", "", "", "else", ":", "\n", "            ", "import", "numpy", "as", "np", "\n", "\n", "# Create an overlap for each predicted segment", "\n", "max_overlaps", "=", "torch", ".", "from_numpy", "(", "rng", ".", "rand", "(", "num_preds", ")", ")", "\n", "\n", "# Construct gt_inds for each predicted segment", "\n", "is_assigned", "=", "torch", ".", "from_numpy", "(", "rng", ".", "rand", "(", "num_preds", ")", "<", "p_assigned", ")", "\n", "# maximum number of assignments constraints", "\n", "n_assigned", "=", "min", "(", "num_preds", ",", "min", "(", "num_gts", ",", "is_assigned", ".", "sum", "(", ")", ")", ")", "\n", "\n", "assigned_idxs", "=", "np", ".", "where", "(", "is_assigned", ")", "[", "0", "]", "\n", "rng", ".", "shuffle", "(", "assigned_idxs", ")", "\n", "assigned_idxs", "=", "assigned_idxs", "[", "0", ":", "n_assigned", "]", "\n", "assigned_idxs", ".", "sort", "(", ")", "\n", "\n", "is_assigned", "[", ":", "]", "=", "0", "\n", "is_assigned", "[", "assigned_idxs", "]", "=", "True", "\n", "\n", "is_ignore", "=", "torch", ".", "from_numpy", "(", "\n", "rng", ".", "rand", "(", "num_preds", ")", "<", "p_ignore", ")", "&", "is_assigned", "\n", "\n", "gt_inds", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "\n", "true_idxs", "=", "np", ".", "arange", "(", "num_gts", ")", "\n", "rng", ".", "shuffle", "(", "true_idxs", ")", "\n", "true_idxs", "=", "torch", ".", "from_numpy", "(", "true_idxs", ")", "\n", "gt_inds", "[", "is_assigned", "]", "=", "true_idxs", "[", ":", "n_assigned", "]", "\n", "\n", "gt_inds", "=", "torch", ".", "from_numpy", "(", "\n", "rng", ".", "randint", "(", "1", ",", "num_gts", "+", "1", ",", "size", "=", "num_preds", ")", ")", "\n", "gt_inds", "[", "is_ignore", "]", "=", "-", "1", "\n", "gt_inds", "[", "~", "is_assigned", "]", "=", "0", "\n", "max_overlaps", "[", "~", "is_assigned", "]", "=", "0", "\n", "\n", "if", "p_use_label", "is", "True", "or", "p_use_label", "<", "rng", ".", "rand", "(", ")", ":", "\n", "                ", "if", "num_classes", "==", "0", ":", "\n", "                    ", "labels", "=", "torch", ".", "zeros", "(", "num_preds", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "", "else", ":", "\n", "                    ", "labels", "=", "torch", ".", "from_numpy", "(", "\n", "# remind that we set FG labels to [0, num_class-1]", "\n", "# since  v2.0", "\n", "# BG cat_id: num_class", "\n", "rng", ".", "randint", "(", "0", ",", "num_classes", ",", "size", "=", "num_preds", ")", ")", "\n", "labels", "[", "~", "is_assigned", "]", "=", "0", "\n", "", "", "else", ":", "\n", "                ", "labels", "=", "None", "\n", "\n", "", "", "self", "=", "cls", "(", "num_gts", ",", "gt_inds", ",", "max_overlaps", ",", "labels", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.assigners.assign_result.AssignResult.add_gt_": [[192, 207], ["torch.arange", "torch.cat", "torch.cat", "torch.cat", "len", "assign_result.AssignResult.max_overlaps.new_ones", "len"], "methods", ["None"], ["", "def", "add_gt_", "(", "self", ",", "gt_labels", ")", ":", "\n", "        ", "\"\"\"Add ground truth as assigned results.\n\n        Args:\n            gt_labels (torch.Tensor): Labels of gt segments\n        \"\"\"", "\n", "self_inds", "=", "torch", ".", "arange", "(", "\n", "1", ",", "len", "(", "gt_labels", ")", "+", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "gt_labels", ".", "device", ")", "\n", "self", ".", "gt_inds", "=", "torch", ".", "cat", "(", "[", "self_inds", ",", "self", ".", "gt_inds", "]", ")", "\n", "\n", "self", ".", "max_overlaps", "=", "torch", ".", "cat", "(", "\n", "[", "self", ".", "max_overlaps", ".", "new_ones", "(", "len", "(", "gt_labels", ")", ")", ",", "self", ".", "max_overlaps", "]", ")", "\n", "\n", "if", "self", ".", "labels", "is", "not", "None", ":", "\n", "            ", "self", ".", "labels", "=", "torch", ".", "cat", "(", "[", "gt_labels", ",", "self", ".", "labels", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.iou_calculators.iou_calculator.SegmentOverlaps.__call__": [[11, 33], ["segment.segment_overlaps", "segments1.size", "segments2.size", "segments1.size", "segments2.size"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment_overlaps", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size", "home.repos.pwc.inspect_result.Media-Smart_vedatad.parallel.data_container.DataContainer.size"], ["def", "__call__", "(", "self", ",", "segments1", ",", "segments2", ",", "mode", "=", "'iou'", ",", "is_aligned", "=", "False", ")", ":", "\n", "        ", "\"\"\"Calculate IoU between 2D bboxes.\n\n        Args:\n            segments1 (Tensor): segments have shape (m, 2) in <start, end>\n                format, or shape (m, 3) in <start, end, score> format.\n            segments2 (Tensor): segments have shape (m, 2) in <start, end>\n                format, shape (m, 3) in <start, end, score> format, or be\n                empty. If is_aligned is ``True``, then m and n must be equal.\n            mode (str): \"iou\" (intersection over union) or iof (intersection\n                over foreground).\n\n        Returns:\n            ious(Tensor): shape (m, n) if is_aligned == False else shape (m, 1)\n        \"\"\"", "\n", "assert", "segments1", ".", "size", "(", "-", "1", ")", "in", "[", "0", ",", "2", ",", "3", "]", "\n", "assert", "segments2", ".", "size", "(", "-", "1", ")", "in", "[", "0", ",", "2", ",", "3", "]", "\n", "if", "segments1", ".", "size", "(", "-", "1", ")", "==", "3", ":", "\n", "            ", "segments1", "=", "segments1", "[", "...", ",", ":", "2", "]", "\n", "", "if", "segments2", ".", "size", "(", "-", "1", ")", "==", "3", ":", "\n", "            ", "segments2", "=", "segments2", "[", "...", ",", ":", "4", "]", "\n", "", "return", "segment_overlaps", "(", "segments1", ",", "segments2", ",", "mode", ",", "is_aligned", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.iou_calculators.iou_calculator.SegmentOverlaps.__repr__": [[34, 38], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"str: a string describing the module\"\"\"", "\n", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "+", "'()'", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.iou_calculators.builder.build_iou_calculator": [[4, 7], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "import", "torch", "\n", "\n", "from", "vedacore", ".", "misc", "import", "build_from_cfg", ",", "registry", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.average_precision": [[11, 56], ["numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.hstack", "numpy.hstack", "range", "range", "numpy.maximum", "numpy.sum", "range", "ValueError", "numpy.where", "numpy.arange", "precs.max"], "function", ["None"], ["def", "average_precision", "(", "recalls", ",", "precisions", ",", "mode", "=", "'area'", ")", ":", "\n", "    ", "\"\"\"Calculate average precision (for single or multiple scales).\n\n    Args:\n        recalls (ndarray): shape (num_scales, num_dets) or (num_dets, )\n        precisions (ndarray): shape (num_scales, num_dets) or (num_dets, )\n        mode (str): 'area' or '11points', 'area' means calculating the area\n            under precision-recall curve, '11points' means calculating\n            the average precision of recalls at [0, 0.1, ..., 1]\n\n    Returns:\n        float or ndarray: calculated average precision\n    \"\"\"", "\n", "no_scale", "=", "False", "\n", "if", "recalls", ".", "ndim", "==", "1", ":", "\n", "        ", "no_scale", "=", "True", "\n", "recalls", "=", "recalls", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "precisions", "=", "precisions", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "", "assert", "recalls", ".", "shape", "==", "precisions", ".", "shape", "and", "recalls", ".", "ndim", "==", "2", "\n", "num_scales", "=", "recalls", ".", "shape", "[", "0", "]", "\n", "ap", "=", "np", ".", "zeros", "(", "num_scales", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "if", "mode", "==", "'area'", ":", "\n", "        ", "zeros", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "1", ")", ",", "dtype", "=", "recalls", ".", "dtype", ")", "\n", "ones", "=", "np", ".", "ones", "(", "(", "num_scales", ",", "1", ")", ",", "dtype", "=", "recalls", ".", "dtype", ")", "\n", "mrec", "=", "np", ".", "hstack", "(", "(", "zeros", ",", "recalls", ",", "ones", ")", ")", "\n", "mpre", "=", "np", ".", "hstack", "(", "(", "zeros", ",", "precisions", ",", "zeros", ")", ")", "\n", "for", "i", "in", "range", "(", "mpre", ".", "shape", "[", "1", "]", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "mpre", "[", ":", ",", "i", "-", "1", "]", "=", "np", ".", "maximum", "(", "mpre", "[", ":", ",", "i", "-", "1", "]", ",", "mpre", "[", ":", ",", "i", "]", ")", "\n", "", "for", "i", "in", "range", "(", "num_scales", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "mrec", "[", "i", ",", "1", ":", "]", "!=", "mrec", "[", "i", ",", ":", "-", "1", "]", ")", "[", "0", "]", "\n", "ap", "[", "i", "]", "=", "np", ".", "sum", "(", "\n", "(", "mrec", "[", "i", ",", "ind", "+", "1", "]", "-", "mrec", "[", "i", ",", "ind", "]", ")", "*", "mpre", "[", "i", ",", "ind", "+", "1", "]", ")", "\n", "", "", "elif", "mode", "==", "'11points'", ":", "\n", "        ", "for", "i", "in", "range", "(", "num_scales", ")", ":", "\n", "            ", "for", "thr", "in", "np", ".", "arange", "(", "0", ",", "1", "+", "1e-3", ",", "0.1", ")", ":", "\n", "                ", "precs", "=", "precisions", "[", "i", ",", "recalls", "[", "i", ",", ":", "]", ">=", "thr", "]", "\n", "prec", "=", "precs", ".", "max", "(", ")", "if", "precs", ".", "size", ">", "0", "else", "0", "\n", "ap", "[", "i", "]", "+=", "prec", "\n", "", "ap", "/=", "11", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "'Unrecognized mode, only \"area\" and \"11points\" are supported'", ")", "\n", "", "if", "no_scale", ":", "\n", "        ", "ap", "=", "ap", "[", "0", "]", "\n", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.tpfp_default": [[58, 148], ["numpy.concatenate", "numpy.vstack", "len", "numpy.zeros", "numpy.zeros", "vedatad.misc.segment.segment_overlaps", "vedatad.misc.segment.segment_overlaps.max", "vedatad.misc.segment.segment_overlaps.argmax", "numpy.argsort", "enumerate", "numpy.zeros", "numpy.zeros", "numpy.ones", "enumerate", "numpy.zeros_like"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment_overlaps"], ["", "def", "tpfp_default", "(", "det_segments", ",", "\n", "gt_segments", ",", "\n", "gt_segments_ignore", "=", "None", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "area_ranges", "=", "None", ")", ":", "\n", "    ", "\"\"\"Check if detected segments are true positive or false positive.\n\n    Args:\n        det_segments (ndarray): Detected segments of this video, of shape\n            (m, 3).\n        gt_segments (ndarray): GT segments of this video, of shape (n, 2).\n        gt_segments_ignore (ndarray): Ignored gt segments of this video,\n            of shape (k, 2). Default: None\n        iou_thr (float): IoU threshold to be considered as matched.\n            Default: 0.5.\n        area_ranges (list[tuple] | None): Range of segment areas to be\n            evaluated, in the format [(min1, max1), (min2, max2), ...].\n            Default: None.\n\n    Returns:\n        tuple[np.ndarray]: (tp, fp) whose elements are 0 and 1. The shape of\n            each array is (num_scales, m).\n    \"\"\"", "\n", "# an indicator of ignored gts", "\n", "gt_ignore_inds", "=", "np", ".", "concatenate", "(", "\n", "(", "np", ".", "zeros", "(", "gt_segments", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", ",", "\n", "np", ".", "ones", "(", "gt_segments_ignore", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", ")", ")", "\n", "# stack gt_segments and gt_segments_ignore for convenience", "\n", "gt_segments", "=", "np", ".", "vstack", "(", "(", "gt_segments", ",", "gt_segments_ignore", ")", ")", "\n", "\n", "num_dets", "=", "det_segments", ".", "shape", "[", "0", "]", "\n", "num_gts", "=", "gt_segments", ".", "shape", "[", "0", "]", "\n", "if", "area_ranges", "is", "None", ":", "\n", "        ", "area_ranges", "=", "[", "(", "None", ",", "None", ")", "]", "\n", "", "num_scales", "=", "len", "(", "area_ranges", ")", "\n", "# tp and fp are of shape (num_scales, num_gts), each row is tp or fp of", "\n", "# a certain scale", "\n", "tp", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_dets", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "fp", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_dets", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# if there is no gt segments in this video, then all det segments", "\n", "# within area range are false positives", "\n", "if", "gt_segments", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "if", "area_ranges", "==", "[", "(", "None", ",", "None", ")", "]", ":", "\n", "            ", "fp", "[", "...", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "det_areas", "=", "det_segments", "[", ":", ",", "1", "]", "-", "det_segments", "[", ":", ",", "0", "]", "\n", "for", "i", ",", "(", "min_area", ",", "max_area", ")", "in", "enumerate", "(", "area_ranges", ")", ":", "\n", "                ", "fp", "[", "i", ",", "(", "det_areas", ">=", "min_area", ")", "&", "(", "det_areas", "<", "max_area", ")", "]", "=", "1", "\n", "", "", "return", "tp", ",", "fp", "\n", "\n", "# if there is no det segments in this video, return tp, fp", "\n", "", "if", "det_segments", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "tp", ",", "fp", "\n", "\n", "", "ious", "=", "segment_overlaps", "(", "det_segments", "[", ":", ",", ":", "2", "]", ",", "gt_segments", ")", "\n", "\n", "# for each det, the max iou with all gts", "\n", "ious_max", "=", "ious", ".", "max", "(", "axis", "=", "1", ")", "\n", "# for each det, which gt overlaps most with it", "\n", "ious_argmax", "=", "ious", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "# sort all dets in descending order by scores", "\n", "sort_inds", "=", "np", ".", "argsort", "(", "-", "det_segments", "[", ":", ",", "-", "1", "]", ")", "\n", "for", "k", ",", "(", "min_area", ",", "max_area", ")", "in", "enumerate", "(", "area_ranges", ")", ":", "\n", "        ", "gt_covered", "=", "np", ".", "zeros", "(", "num_gts", ",", "dtype", "=", "bool", ")", "\n", "# if no area range is specified, gt_area_ignore is all False", "\n", "if", "min_area", "is", "None", ":", "\n", "            ", "gt_area_ignore", "=", "np", ".", "zeros_like", "(", "gt_ignore_inds", ",", "dtype", "=", "bool", ")", "\n", "", "else", ":", "\n", "            ", "gt_areas", "=", "gt_segments", "[", ":", ",", "1", "]", "-", "gt_segments", "[", ":", ",", "0", "]", "\n", "gt_area_ignore", "=", "(", "gt_areas", "<", "min_area", ")", "|", "(", "gt_areas", ">=", "max_area", ")", "\n", "", "for", "i", "in", "sort_inds", ":", "\n", "            ", "if", "ious_max", "[", "i", "]", ">=", "iou_thr", ":", "\n", "                ", "matched_gt", "=", "ious_argmax", "[", "i", "]", "\n", "if", "not", "(", "gt_ignore_inds", "[", "matched_gt", "]", "\n", "or", "gt_area_ignore", "[", "matched_gt", "]", ")", ":", "\n", "                    ", "if", "not", "gt_covered", "[", "matched_gt", "]", ":", "\n", "                        ", "gt_covered", "[", "matched_gt", "]", "=", "True", "\n", "tp", "[", "k", ",", "i", "]", "=", "1", "\n", "", "else", ":", "\n", "                        ", "fp", "[", "k", ",", "i", "]", "=", "1", "\n", "# otherwise ignore this detected segment, tp = 0, fp = 0", "\n", "", "", "", "elif", "min_area", "is", "None", ":", "\n", "                ", "fp", "[", "k", ",", "i", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "segment", "=", "det_segments", "[", "i", ",", ":", "2", "]", "\n", "area", "=", "segment", "[", "1", "]", "-", "segment", "[", "0", "]", "\n", "if", "min_area", "<=", "area", "<", "max_area", ":", "\n", "                    ", "fp", "[", "k", ",", "i", "]", "=", "1", "\n", "", "", "", "", "return", "tp", ",", "fp", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.tpfp_anet": [[150, 210], ["numpy.zeros", "numpy.zeros", "vedatad.misc.segment.segment_overlaps", "numpy.argsort", "numpy.zeros", "numpy.argsort"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment_overlaps"], ["", "def", "tpfp_anet", "(", "det_segments", ",", "\n", "gt_segments", ",", "\n", "gt_segments_ignore", "=", "None", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "scale_ranges", "=", "None", ")", ":", "\n", "    ", "\"\"\"Check if detected segments are true positive or false positive.\n\n    Args:\n        det_segments (ndarray): Detected segments of this video, of shape\n            (m, 3).\n        gt_segments (ndarray): GT segments of this video, of shape (n, 2).\n        gt_segments_ignore (ndarray): Ignored gt segments of this video,\n            of shape (k, 2). Default: None\n        iou_thr (float): IoU threshold to be considered as matched.\n            Default: 0.5.\n        scale_ranges (list[tuple] | None): Range of segment areas to be\n            evaluated, in the format [(min1, max1), (min2, max2), ...].\n            Default: None.\n\n    Returns:\n        tuple[np.ndarray]: (tp, fp) whose elements are 0 and 1. The shape of\n            each array is (num_scales, m).\n    \"\"\"", "\n", "assert", "gt_segments_ignore", ".", "shape", "[", "0", "]", "==", "0", ",", "(", "\n", "'gt_segments_ignore shape should be 0.'", ")", "\n", "assert", "scale_ranges", "is", "None", ",", "'scale_ranges should set to None.'", "\n", "\n", "num_dets", "=", "det_segments", ".", "shape", "[", "0", "]", "\n", "num_gts", "=", "gt_segments", ".", "shape", "[", "0", "]", "\n", "num_scales", "=", "1", "\n", "# tp and fp are of shape (num_scales, num_dets), each row is tp or fp of", "\n", "# a certain scale", "\n", "tp", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_dets", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "fp", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_dets", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# if there is no gt segments in this video, then all det segments", "\n", "# within area range are false positives", "\n", "if", "gt_segments", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "fp", "[", "...", "]", "=", "1", "\n", "return", "tp", ",", "fp", "\n", "\n", "", "ious", "=", "segment_overlaps", "(", "det_segments", "[", ":", ",", ":", "2", "]", ",", "gt_segments", ")", "\n", "\n", "# sort all dets in descending order by scores", "\n", "sort_inds", "=", "np", ".", "argsort", "(", "-", "det_segments", "[", ":", ",", "-", "1", "]", ")", "\n", "gt_covered", "=", "np", ".", "zeros", "(", "num_gts", ",", "dtype", "=", "bool", ")", "\n", "for", "i", "in", "sort_inds", ":", "\n", "        ", "gt_ious", "=", "ious", "[", "i", "]", "\n", "sort_gt_inds", "=", "np", ".", "argsort", "(", "-", "gt_ious", ")", "\n", "for", "matched_gt", "in", "sort_gt_inds", ":", "\n", "            ", "if", "gt_ious", "[", "matched_gt", "]", ">=", "iou_thr", ":", "\n", "                ", "if", "not", "gt_covered", "[", "matched_gt", "]", ":", "\n", "                    ", "gt_covered", "[", "matched_gt", "]", "=", "True", "\n", "tp", "[", "0", ",", "i", "]", "=", "1", "\n", "break", "\n", "", "", "else", ":", "\n", "                ", "fp", "[", "0", ",", "i", "]", "=", "1", "\n", "", "", "if", "fp", "[", "0", ",", "i", "]", "==", "0", "and", "tp", "[", "0", ",", "i", "]", "==", "0", ":", "\n", "            ", "fp", "[", "0", ",", "i", "]", "=", "1", "\n", "", "", "return", "tp", ",", "fp", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.get_cls_results": [[212, 238], ["cls_gts.append", "ann.get", "cls_gts_ignore.append", "cls_gts_ignore.append", "numpy.empty"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.Registry.get"], ["", "def", "get_cls_results", "(", "det_results", ",", "annotations", ",", "class_id", ")", ":", "\n", "    ", "\"\"\"Get det results and gt information of a certain class.\n\n    Args:\n        det_results (list[list]): Same as `eval_map()`.\n        annotations (list[dict]): Same as `eval_map()`.\n        class_id (int): ID of a specific class.\n\n    Returns:\n        tuple[list[np.ndarray]]: detected segments, gt segments,\n            ignored gt segments\n    \"\"\"", "\n", "cls_dets", "=", "[", "video_res", "[", "class_id", "]", "for", "video_res", "in", "det_results", "]", "\n", "cls_gts", "=", "[", "]", "\n", "cls_gts_ignore", "=", "[", "]", "\n", "for", "ann", "in", "annotations", ":", "\n", "        ", "gt_inds", "=", "ann", "[", "'labels'", "]", "==", "class_id", "\n", "cls_gts", ".", "append", "(", "ann", "[", "'segments'", "]", "[", "gt_inds", ",", ":", "]", ")", "\n", "\n", "if", "ann", ".", "get", "(", "'labels_ignore'", ",", "None", ")", "is", "not", "None", ":", "\n", "            ", "ignore_inds", "=", "ann", "[", "'labels_ignore'", "]", "==", "class_id", "\n", "cls_gts_ignore", ".", "append", "(", "ann", "[", "'segments_ignore'", "]", "[", "ignore_inds", ",", ":", "]", ")", "\n", "", "else", ":", "\n", "            ", "cls_gts_ignore", ".", "append", "(", "np", ".", "empty", "(", "(", "0", ",", "2", ")", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "\n", "", "", "return", "cls_dets", ",", "cls_gts", ",", "cls_gts_ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.eval_map": [[240, 361], ["len", "len", "range", "mean_ap.print_map_summary", "len", "len", "len", "mean_ap.get_cls_results", "tuple", "numpy.zeros", "enumerate", "numpy.vstack", "numpy.argsort", "numpy.cumsum", "numpy.cumsum", "mean_ap.average_precision", "eval_results.append", "numpy.vstack", "numpy.vstack", "range", "concurrent.futures.ThreadPoolExecutor", "executor.map", "zip", "numpy.hstack", "numpy.hstack", "numpy.finfo", "numpy.maximum", "numpy.maximum", "num_gts.item.item", "numpy.any", "numpy.array().mean().item", "enumerate", "mean_ap.append", "mean_ap.append", "aps.append", "numpy.sum", "all_ap[].mean", "numpy.array().mean", "range", "range", "numpy.array"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.print_map_summary", "home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.get_cls_results", "home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.average_precision"], ["", "def", "eval_map", "(", "det_results", ",", "\n", "annotations", ",", "\n", "scale_ranges", "=", "None", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "mode", "=", "None", ",", "\n", "logger", "=", "None", ",", "\n", "nproc", "=", "4", ",", "\n", "label_names", "=", "None", ")", ":", "\n", "    ", "\"\"\"Evaluate mAP of a dataset.\n\n    Args:\n        det_results (list[list]): [[cls1_det, cls2_det, ...], ...].\n            The outer list indicates videos, and the inner list indicates\n            per-class detected segments.\n        annotations (list[dict]): Ground truth annotations where each item of\n            the list indicates a video. Keys of annotations are:\n\n            - `segments`: numpy array of shape (n, 2)\n            - `labels`: numpy array of shape (n, )\n            - `segments_ignore` (optional): numpy array of shape (k, 2)\n            - `labels_ignore` (optional): numpy array of shape (k, )\n        scale_ranges (list[tuple] | None): Range of scales to be evaluated,\n            in the format [(min1, max1), (min2, max2), ...]. A range of\n            (32, 64) means the area range between (32, 64).\n            Default: None.\n        iou_thr (float): IoU threshold to be considered as matched.\n            Default: 0.5.\n        mode (str | None): Mode name, there are minor differences in metrics\n            for different modes, e.g. \"anet\", \"voc07\", \"voc12\" etc.\n            Default: None.\n        logger (logging.Logger | str | None): The way to print the mAP\n            summary. See `mmdet.utils.print_log()` for details. Default: None.\n        nproc (int): Processes used for computing TP and FP.\n            Default: 4.\n        label_names (list[str] | None): Label names.\n\n    Returns:\n        tuple: (mAP, [dict, dict, ...])\n    \"\"\"", "\n", "assert", "len", "(", "det_results", ")", "==", "len", "(", "annotations", ")", "\n", "\n", "num_videos", "=", "len", "(", "det_results", ")", "\n", "num_scales", "=", "len", "(", "scale_ranges", ")", "if", "scale_ranges", "is", "not", "None", "else", "1", "\n", "num_classes", "=", "len", "(", "det_results", "[", "0", "]", ")", "# positive class num", "\n", "\n", "eval_results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_classes", ")", ":", "\n", "# get gt and det segments of this class", "\n", "        ", "cls_dets", ",", "cls_gts", ",", "cls_gts_ignore", "=", "get_cls_results", "(", "\n", "det_results", ",", "annotations", ",", "i", ")", "\n", "\n", "# choose proper function according to datasets to compute tp and fp", "\n", "if", "mode", "in", "[", "'anet'", "]", ":", "\n", "            ", "tpfp_func", "=", "tpfp_anet", "\n", "", "else", ":", "\n", "            ", "tpfp_func", "=", "tpfp_default", "\n", "# compute tp and fp for each video with multiple processes", "\n", "", "with", "ThreadPoolExecutor", "(", "nproc", ")", "as", "executor", ":", "\n", "            ", "tpfp", "=", "executor", ".", "map", "(", "tpfp_func", ",", "cls_dets", ",", "cls_gts", ",", "cls_gts_ignore", ",", "\n", "[", "iou_thr", "for", "_", "in", "range", "(", "num_videos", ")", "]", ",", "\n", "[", "scale_ranges", "for", "_", "in", "range", "(", "num_videos", ")", "]", ")", "\n", "", "tp", ",", "fp", "=", "tuple", "(", "zip", "(", "*", "tpfp", ")", ")", "\n", "# calculate gt number of each scale", "\n", "# ignored gts or gts beyond the specific scale are not counted", "\n", "num_gts", "=", "np", ".", "zeros", "(", "num_scales", ",", "dtype", "=", "int", ")", "\n", "for", "j", ",", "segment", "in", "enumerate", "(", "cls_gts", ")", ":", "\n", "            ", "if", "scale_ranges", "is", "None", ":", "\n", "                ", "num_gts", "[", "0", "]", "+=", "segment", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "gt_areas", "=", "segment", "[", ":", ",", "1", "]", "-", "segment", "[", ":", ",", "0", "]", "\n", "for", "k", ",", "(", "min_area", ",", "max_area", ")", "in", "enumerate", "(", "scale_ranges", ")", ":", "\n", "                    ", "num_gts", "[", "k", "]", "+=", "np", ".", "sum", "(", "(", "gt_areas", ">=", "min_area", ")", "\n", "&", "(", "gt_areas", "<", "max_area", ")", ")", "\n", "# sort all det segments by score, also sort tp and fp", "\n", "", "", "", "cls_dets", "=", "np", ".", "vstack", "(", "cls_dets", ")", "\n", "num_dets", "=", "cls_dets", ".", "shape", "[", "0", "]", "\n", "sort_inds", "=", "np", ".", "argsort", "(", "-", "cls_dets", "[", ":", ",", "-", "1", "]", ")", "\n", "tp", "=", "np", ".", "hstack", "(", "tp", ")", "[", ":", ",", "sort_inds", "]", "\n", "fp", "=", "np", ".", "hstack", "(", "fp", ")", "[", ":", ",", "sort_inds", "]", "\n", "# calculate recall and precision with tp and fp", "\n", "tp", "=", "np", ".", "cumsum", "(", "tp", ",", "axis", "=", "1", ")", "\n", "fp", "=", "np", ".", "cumsum", "(", "fp", ",", "axis", "=", "1", ")", "\n", "eps", "=", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", "\n", "recalls", "=", "tp", "/", "np", ".", "maximum", "(", "num_gts", "[", ":", ",", "np", ".", "newaxis", "]", ",", "eps", ")", "\n", "precisions", "=", "tp", "/", "np", ".", "maximum", "(", "(", "tp", "+", "fp", ")", ",", "eps", ")", "\n", "# calculate AP", "\n", "if", "scale_ranges", "is", "None", ":", "\n", "            ", "recalls", "=", "recalls", "[", "0", ",", ":", "]", "\n", "precisions", "=", "precisions", "[", "0", ",", ":", "]", "\n", "num_gts", "=", "num_gts", ".", "item", "(", ")", "\n", "", "ap_mode", "=", "'area'", "if", "mode", "!=", "'voc07'", "else", "'11points'", "\n", "ap", "=", "average_precision", "(", "recalls", ",", "precisions", ",", "ap_mode", ")", "\n", "eval_results", ".", "append", "(", "{", "\n", "'num_gts'", ":", "num_gts", ",", "\n", "'num_dets'", ":", "num_dets", ",", "\n", "'recall'", ":", "recalls", ",", "\n", "'precision'", ":", "precisions", ",", "\n", "'ap'", ":", "ap", "\n", "}", ")", "\n", "", "if", "scale_ranges", "is", "not", "None", ":", "\n", "# shape (num_classes, num_scales)", "\n", "        ", "all_ap", "=", "np", ".", "vstack", "(", "[", "cls_result", "[", "'ap'", "]", "for", "cls_result", "in", "eval_results", "]", ")", "\n", "all_num_gts", "=", "np", ".", "vstack", "(", "\n", "[", "cls_result", "[", "'num_gts'", "]", "for", "cls_result", "in", "eval_results", "]", ")", "\n", "mean_ap", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_scales", ")", ":", "\n", "            ", "if", "np", ".", "any", "(", "all_num_gts", "[", ":", ",", "i", "]", ">", "0", ")", ":", "\n", "                ", "mean_ap", ".", "append", "(", "all_ap", "[", "all_num_gts", "[", ":", ",", "i", "]", ">", "0", ",", "i", "]", ".", "mean", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "mean_ap", ".", "append", "(", "0.0", ")", "\n", "", "", "", "else", ":", "\n", "        ", "aps", "=", "[", "]", "\n", "for", "cls_result", "in", "eval_results", ":", "\n", "            ", "if", "cls_result", "[", "'num_gts'", "]", ">", "0", ":", "\n", "                ", "aps", ".", "append", "(", "cls_result", "[", "'ap'", "]", ")", "\n", "", "", "mean_ap", "=", "np", ".", "array", "(", "aps", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "if", "aps", "else", "0.0", "\n", "\n", "", "print_map_summary", "(", "\n", "mean_ap", ",", "eval_results", ",", "label_names", ",", "scale_ranges", ",", "logger", "=", "logger", ")", "\n", "\n", "return", "mean_ap", ",", "eval_results", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.evaluation.mean_ap.print_map_summary": [[363, 425], ["isinstance", "len", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "range", "len", "isinstance", "range", "table_data.append", "terminaltables.AsciiTable", "vedacore.misc.print_log", "len", "str", "vedacore.misc.print_log", "table_data.append", "numpy.array", "range"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.logging.print_log", "home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.logging.print_log"], ["", "def", "print_map_summary", "(", "mean_ap", ",", "\n", "results", ",", "\n", "label_names", "=", "None", ",", "\n", "scale_ranges", "=", "None", ",", "\n", "logger", "=", "None", ")", ":", "\n", "    ", "\"\"\"Print mAP and results of each class.\n\n    A table will be printed to show the gts/dets/recall/AP of each class and\n    the mAP.\n\n    Args:\n        mean_ap (float): Calculated from `eval_map()`.\n        results (list[dict]): Calculated from `eval_map()`.\n        label_names (list[str] | None): Label names.\n        scale_ranges (list[tuple] | None): Range of scales to be evaluated.\n        logger (logging.Logger | str | None): The way to print the mAP\n            summary. See `mmdet.utils.print_log()` for details. Default: None.\n    \"\"\"", "\n", "\n", "if", "logger", "==", "'silent'", ":", "\n", "        ", "return", "\n", "\n", "", "if", "isinstance", "(", "results", "[", "0", "]", "[", "'ap'", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "num_scales", "=", "len", "(", "results", "[", "0", "]", "[", "'ap'", "]", ")", "\n", "", "else", ":", "\n", "        ", "num_scales", "=", "1", "\n", "\n", "", "if", "scale_ranges", "is", "not", "None", ":", "\n", "        ", "assert", "len", "(", "scale_ranges", ")", "==", "num_scales", "\n", "\n", "", "num_classes", "=", "len", "(", "results", ")", "\n", "\n", "recalls", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_classes", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "aps", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_classes", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "num_gts", "=", "np", ".", "zeros", "(", "(", "num_scales", ",", "num_classes", ")", ",", "dtype", "=", "int", ")", "\n", "for", "i", ",", "cls_result", "in", "enumerate", "(", "results", ")", ":", "\n", "        ", "if", "cls_result", "[", "'recall'", "]", ".", "size", ">", "0", ":", "\n", "            ", "recalls", "[", ":", ",", "i", "]", "=", "np", ".", "array", "(", "cls_result", "[", "'recall'", "]", ",", "ndmin", "=", "2", ")", "[", ":", ",", "-", "1", "]", "\n", "", "aps", "[", ":", ",", "i", "]", "=", "cls_result", "[", "'ap'", "]", "\n", "num_gts", "[", ":", ",", "i", "]", "=", "cls_result", "[", "'num_gts'", "]", "\n", "\n", "", "if", "label_names", "is", "None", ":", "\n", "        ", "label_names", "=", "[", "str", "(", "i", ")", "for", "i", "in", "range", "(", "num_classes", ")", "]", "\n", "\n", "", "if", "not", "isinstance", "(", "mean_ap", ",", "list", ")", ":", "\n", "        ", "mean_ap", "=", "[", "mean_ap", "]", "\n", "\n", "", "header", "=", "[", "'class'", ",", "'gts'", ",", "'dets'", ",", "'recall'", ",", "'ap'", "]", "\n", "for", "i", "in", "range", "(", "num_scales", ")", ":", "\n", "        ", "if", "scale_ranges", "is", "not", "None", ":", "\n", "            ", "print_log", "(", "f'Scale range {scale_ranges[i]}'", ",", "logger", "=", "logger", ")", "\n", "", "table_data", "=", "[", "header", "]", "\n", "for", "j", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "row_data", "=", "[", "\n", "label_names", "[", "j", "]", ",", "num_gts", "[", "i", ",", "j", "]", ",", "results", "[", "j", "]", "[", "'num_dets'", "]", ",", "\n", "f'{recalls[i, j]:.3f}'", ",", "f'{aps[i, j]:.3f}'", "\n", "]", "\n", "table_data", ".", "append", "(", "row_data", ")", "\n", "", "table_data", ".", "append", "(", "[", "'mAP'", ",", "''", ",", "''", ",", "''", ",", "f'{mean_ap[i]:.3f}'", "]", ")", "\n", "table", "=", "AsciiTable", "(", "table_data", ")", "\n", "table", ".", "inner_footing_row_border", "=", "True", "\n", "print_log", "(", "'\\n'", "+", "table", ".", "table", ",", "logger", "=", "logger", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.builder.build_engine": [[4, 6], ["vedacore.misc.build_from_cfg"], "function", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.misc.registry.build_from_cfg"], ["\n", "import", "torch", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine.__init__": [[12, 22], ["base_engine.BaseEngine.__init__", "vedatad.bridge.build_meshgrid", "vedatad.bridge.build_converter"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.builder.build_meshgrid", "home.repos.pwc.inspect_result.Media-Smart_vedatad.converters.builder.build_converter"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "meshgrid", ",", "converter", ",", "num_classes", ",", "use_sigmoid", ",", "\n", "test_cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "model", ")", "\n", "self", ".", "meshgrid", "=", "build_meshgrid", "(", "meshgrid", ")", "\n", "self", ".", "converter", "=", "build_converter", "(", "converter", ")", "\n", "if", "use_sigmoid", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_out_channels", "=", "num_classes", "+", "1", "\n", "", "self", ".", "test_cfg", "=", "test_cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine.extract_feats": [[23, 26], ["infer_engine.InferEngine.model"], "methods", ["None"], ["", "def", "extract_feats", "(", "self", ",", "img", ")", ":", "\n", "        ", "feats", "=", "self", ".", "model", "(", "img", ",", "train", "=", "False", ")", "\n", "return", "feats", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine._get_raw_dets": [[27, 47], ["infer_engine.InferEngine.extract_feats", "infer_engine.InferEngine.meshgrid.gen_anchor_mesh", "infer_engine.InferEngine.converter.get_segments"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.extract_feats", "home.repos.pwc.inspect_result.Media-Smart_vedatad.meshgrids.segment_anchor_meshgrid.SegmentAnchorMeshGrid.gen_anchor_mesh", "home.repos.pwc.inspect_result.Media-Smart_vedatad.converters.base_converter.BaseConverter.get_segments"], ["", "def", "_get_raw_dets", "(", "self", ",", "imgs", ",", "video_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            imgs (torch.Tensor): shape N*3*T*H*W, N is batch size\n            video_metas (list): len(video_metas) = N\n        Returns:\n            dets(list): len(dets) is the batch size, len(dets[ii]) = #classes,\n                dets[ii][jj] is an np.array whose shape is N*3\n        \"\"\"", "\n", "feats", "=", "self", ".", "extract_feats", "(", "imgs", ")", "\n", "\n", "featmap_tsizes", "=", "[", "feat", ".", "shape", "[", "2", "]", "for", "feat", "in", "feats", "[", "0", "]", "]", "\n", "dtype", "=", "feats", "[", "0", "]", "[", "0", "]", ".", "dtype", "\n", "device", "=", "feats", "[", "0", "]", "[", "0", "]", ".", "device", "\n", "anchor_mesh", "=", "self", ".", "meshgrid", ".", "gen_anchor_mesh", "(", "featmap_tsizes", ",", "\n", "video_metas", ",", "dtype", ",", "device", ")", "\n", "# segments, scores, score_factor", "\n", "dets", "=", "self", ".", "converter", ".", "get_segments", "(", "anchor_mesh", ",", "video_metas", ",", "*", "feats", ")", "\n", "\n", "return", "dets", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine._simple_infer": [[48, 75], ["infer_engine.InferEngine._get_raw_dets", "len", "range", "vedatad.misc.segment.multiclass_nms", "vedatad.misc.segment.segment2result", "result_list.append"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine._get_raw_dets", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.multiclass_nms", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment2result"], ["", "def", "_simple_infer", "(", "self", ",", "imgs", ",", "video_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            imgs (torch.Tensor): shape N*3*T*H*W, N is batch size\n            video_metas (list): len(video_metas) = N\n        Returns:\n            dets(list): len(dets) is the batch size, len(dets[ii]) = #classes,\n                dets[ii][jj] is an np.array whose shape is N*3\n        \"\"\"", "\n", "dets", "=", "self", ".", "_get_raw_dets", "(", "imgs", ",", "video_metas", ")", "\n", "batch_size", "=", "len", "(", "dets", ")", "\n", "\n", "result_list", "=", "[", "]", "\n", "for", "ii", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "segments", ",", "scores", ",", "centerness", "=", "dets", "[", "ii", "]", "\n", "det_segments", ",", "det_labels", "=", "multiclass_nms", "(", "\n", "segments", ",", "\n", "scores", ",", "\n", "self", ".", "test_cfg", ".", "score_thr", ",", "\n", "self", ".", "test_cfg", ".", "nms", ",", "\n", "self", ".", "test_cfg", ".", "max_per_video", ",", "\n", "score_factors", "=", "centerness", ")", "\n", "segment_result", "=", "segment2result", "(", "det_segments", ",", "det_labels", ",", "\n", "self", ".", "cls_out_channels", ")", "\n", "result_list", ".", "append", "(", "segment_result", ")", "\n", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine._aug_infer": [[76, 112], ["len", "range", "len", "len", "range", "range", "len", "len", "len", "infer_engine.InferEngine._get_raw_dets", "dets.append", "range", "merged_dets.append", "vedatad.misc.segment.multiclass_nms", "vedatad.misc.segment.segment2result", "result_list.append", "range", "single_video.append", "single_class.append", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine._get_raw_dets", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.multiclass_nms", "home.repos.pwc.inspect_result.Media-Smart_vedatad.segment.segment.segment2result"], ["", "def", "_aug_infer", "(", "self", ",", "imgs_list", ",", "video_metas_list", ")", ":", "\n", "        ", "assert", "len", "(", "imgs_list", ")", "==", "len", "(", "video_metas_list", ")", "\n", "dets", "=", "[", "]", "\n", "ntransforms", "=", "len", "(", "imgs_list", ")", "\n", "for", "idx", "in", "range", "(", "len", "(", "imgs_list", ")", ")", ":", "\n", "            ", "imgs", "=", "imgs_list", "[", "idx", "]", "\n", "video_metas", "=", "video_metas_list", "[", "idx", "]", "\n", "tdets", "=", "self", ".", "_get_raw_dets", "(", "imgs", ",", "video_metas", ")", "\n", "dets", ".", "append", "(", "tdets", ")", "\n", "", "batch_size", "=", "len", "(", "dets", "[", "0", "]", ")", "\n", "nclasses", "=", "len", "(", "dets", "[", "0", "]", "[", "0", "]", ")", "\n", "merged_dets", "=", "[", "]", "\n", "for", "ii", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "single_video", "=", "[", "]", "\n", "for", "kk", "in", "range", "(", "nclasses", ")", ":", "\n", "                ", "single_class", "=", "[", "]", "\n", "for", "jj", "in", "range", "(", "ntransforms", ")", ":", "\n", "                    ", "single_class", ".", "append", "(", "dets", "[", "jj", "]", "[", "ii", "]", "[", "kk", "]", ")", "\n", "", "single_video", ".", "append", "(", "torch", ".", "cat", "(", "single_class", ",", "axis", "=", "0", ")", ")", "\n", "", "merged_dets", ".", "append", "(", "single_video", ")", "\n", "\n", "", "result_list", "=", "[", "]", "\n", "for", "ii", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "segments", ",", "scores", ",", "centerness", "=", "merged_dets", "[", "ii", "]", "\n", "det_segments", ",", "det_labels", "=", "multiclass_nms", "(", "\n", "segments", ",", "\n", "scores", ",", "\n", "self", ".", "test_cfg", ".", "score_thr", ",", "\n", "self", ".", "test_cfg", ".", "nms", ",", "\n", "self", ".", "test_cfg", ".", "max_per_video", ",", "\n", "score_factors", "=", "centerness", ")", "\n", "segment_result", "=", "segment2result", "(", "det_segments", ",", "det_labels", ",", "\n", "self", ".", "cls_out_channels", ")", "\n", "result_list", ".", "append", "(", "segment_result", ")", "\n", "\n", "", "return", "result_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine.infer": [[113, 118], ["len", "infer_engine.InferEngine._simple_infer", "infer_engine.InferEngine._aug_infer"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine._simple_infer", "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine._aug_infer"], ["", "def", "infer", "(", "self", ",", "imgs", ",", "video_metas", ")", ":", "\n", "        ", "if", "len", "(", "imgs", ")", "==", "1", ":", "\n", "            ", "return", "self", ".", "_simple_infer", "(", "imgs", "[", "0", "]", ",", "video_metas", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_aug_infer", "(", "imgs", ",", "video_metas", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.base_engine.BaseEngine.__init__": [[8, 11], ["torch.Module.__init__", "vedatad.models.build_detector"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.models.builder.build_detector"], ["    ", "def", "__init__", "(", "self", ",", "model", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "build_detector", "(", "model", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.val_engine.ValEngine.__init__": [[8, 12], ["infer_engine.InferEngine.__init__"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "meshgrid", ",", "converter", ",", "num_classes", ",", "use_sigmoid", ",", "\n", "test_cfg", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "model", ",", "meshgrid", ",", "converter", ",", "num_classes", ",", "use_sigmoid", ",", "\n", "test_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.val_engine.ValEngine.forward": [[13, 15], ["val_engine.ValEngine.forward_impl"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.forward_impl"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "self", ".", "forward_impl", "(", "**", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.val_engine.ValEngine.forward_impl": [[16, 19], ["val_engine.ValEngine.infer"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.infer_engine.InferEngine.infer"], ["", "def", "forward_impl", "(", "self", ",", "imgs", ",", "video_metas", ")", ":", "\n", "        ", "dets", "=", "self", ".", "infer", "(", "imgs", ",", "video_metas", ")", "\n", "return", "dets", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__": [[10, 14], ["base_engine.BaseEngine.__init__", "vedatad.criteria.build_criterion", "vedacore.optimizers.build_optimizer"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.__init__", "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.builder.build_criterion", "home.repos.pwc.inspect_result.Media-Smart_vedatad.optimizers.builder.build_optimizer"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "criterion", ",", "optimizer", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "model", ")", "\n", "self", ".", "criterion", "=", "build_criterion", "(", "criterion", ")", "\n", "self", ".", "optimizer", "=", "build_optimizer", "(", "self", ".", "model", ",", "optimizer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.extract_feats": [[15, 18], ["train_engine.TrainEngine.model"], "methods", ["None"], ["", "def", "extract_feats", "(", "self", ",", "img", ")", ":", "\n", "        ", "feats", "=", "self", ".", "model", "(", "img", ",", "train", "=", "True", ")", "\n", "return", "feats", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.forward": [[19, 21], ["train_engine.TrainEngine.forward_impl"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.forward_impl"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "self", ".", "forward_impl", "(", "**", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.forward_impl": [[22, 32], ["train_engine.TrainEngine.extract_feats", "train_engine.TrainEngine.criterion.loss"], "methods", ["home.repos.pwc.inspect_result.Media-Smart_vedatad.engines.train_engine.TrainEngine.extract_feats", "home.repos.pwc.inspect_result.Media-Smart_vedatad.criteria.base_criterion.BaseCriterion.loss"], ["", "def", "forward_impl", "(", "self", ",", "\n", "imgs", ",", "\n", "video_metas", ",", "\n", "gt_segments", ",", "\n", "gt_labels", ",", "\n", "gt_segments_ignore", "=", "None", ")", ":", "\n", "        ", "feats", "=", "self", ".", "extract_feats", "(", "imgs", ")", "\n", "losses", "=", "self", ".", "criterion", ".", "loss", "(", "feats", ",", "video_metas", ",", "gt_segments", ",", "\n", "gt_labels", ",", "gt_segments_ignore", ")", "\n", "return", "losses", "\n", "", "", ""]]}