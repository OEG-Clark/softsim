{"home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.timer": [[20, 27], ["time.process_time", "time.process_time", "time.append"], "function", ["None"], ["@", "contextmanager", "\n", "def", "timer", "(", ")", ":", "\n", "    ", "time", "=", "[", "]", "\n", "t0", "=", "process_time", "(", ")", "\n", "yield", "time", "\n", "t1", "=", "process_time", "(", ")", "\n", "time", ".", "append", "(", "t1", "-", "t0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.trdata": [[32, 37], ["gala.imio.read_h5_stack", "gala.imio.read_h5_stack", "gala.imio.read_h5_stack", "os.path.join", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack"], ["def", "trdata", "(", ")", ":", "\n", "    ", "wstr", "=", "imio", ".", "read_h5_stack", "(", "os", ".", "path", ".", "join", "(", "dd", ",", "'train-ws.lzf.h5'", ")", ")", "\n", "prtr", "=", "imio", ".", "read_h5_stack", "(", "os", ".", "path", ".", "join", "(", "dd", ",", "'train-p1.lzf.h5'", ")", ")", "\n", "gttr", "=", "imio", ".", "read_h5_stack", "(", "os", ".", "path", ".", "join", "(", "dd", ",", "'train-gt.lzf.h5'", ")", ")", "\n", "return", "wstr", ",", "prtr", ",", "gttr", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.tsdata": [[39, 44], ["gala.imio.read_h5_stack", "gala.imio.read_h5_stack", "gala.imio.read_h5_stack", "os.path.join", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack"], ["", "def", "tsdata", "(", ")", ":", "\n", "    ", "wsts", "=", "imio", ".", "read_h5_stack", "(", "os", ".", "path", ".", "join", "(", "dd", ",", "'test-ws.lzf.h5'", ")", ")", "\n", "prts", "=", "imio", ".", "read_h5_stack", "(", "os", ".", "path", ".", "join", "(", "dd", ",", "'test-p1.lzf.h5'", ")", ")", "\n", "gtts", "=", "imio", ".", "read_h5_stack", "(", "os", ".", "path", ".", "join", "(", "dd", ",", "'test-gt.lzf.h5'", ")", ")", "\n", "return", "wsts", ",", "prts", ",", "gtts", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.trgraph": [[46, 50], ["bench_gala.trdata", "gala.agglo.Rag"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.trdata"], ["", "def", "trgraph", "(", ")", ":", "\n", "    ", "ws", ",", "pr", ",", "ts", "=", "trdata", "(", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "ws", ",", "pr", ")", "\n", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.tsgraph": [[52, 56], ["bench_gala.tsdata", "gala.agglo.Rag"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.tsdata"], ["", "def", "tsgraph", "(", ")", ":", "\n", "    ", "ws", ",", "pr", ",", "ts", "=", "tsdata", "(", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "ws", ",", "pr", ",", "feature_manager", "=", "em", ")", "\n", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.trexamples": [[58, 64], ["gala.imio.read_h5_stack", "bench_gala.trgraph", "trgraph.learn_agglomerate", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.trgraph", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_agglomerate"], ["", "def", "trexamples", "(", ")", ":", "\n", "    ", "gt", "=", "imio", ".", "read_h5_stack", "(", "os", ".", "path", ".", "join", "(", "dd", ",", "'train-gt.lzf.h5'", ")", ")", "\n", "g", "=", "trgraph", "(", ")", "\n", "(", "X", ",", "y", ",", "w", ",", "e", ")", ",", "_", "=", "g", ".", "learn_agglomerate", "(", "gt", ",", "em", ",", "min_num_epochs", "=", "5", ")", "\n", "y", "=", "y", "[", ":", ",", "0", "]", "\n", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.classifier": [[66, 71], ["bench_gala.trexamples", "gala.classify.DefaultRandomForest", "classify.DefaultRandomForest.fit"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.trexamples", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit"], ["", "def", "classifier", "(", ")", ":", "\n", "    ", "X", ",", "y", "=", "trexamples", "(", ")", "\n", "rf", "=", "classify", ".", "DefaultRandomForest", "(", ")", "\n", "rf", ".", "fit", "(", "X", ",", "y", ")", "\n", "return", "rf", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.policy": [[73, 77], ["gala.classify.DefaultRandomForest", "gala.agglo.classifier_probability"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.classifier_probability"], ["", "def", "policy", "(", ")", ":", "\n", "    ", "rf", "=", "classify", ".", "DefaultRandomForest", "(", ")", "\n", "cl", "=", "agglo", ".", "classifier_probability", "(", "em", ",", "rf", ")", "\n", "return", "cl", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.tsgraph_queue": [[79, 85], ["bench_gala.tsgraph", "bench_gala.policy", "tsgraph.rebuild_merge_queue"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.tsgraph", "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.policy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rebuild_merge_queue"], ["", "def", "tsgraph_queue", "(", ")", ":", "\n", "    ", "g", "=", "tsgraph", "(", ")", "\n", "cl", "=", "policy", "(", ")", "\n", "g", ".", "merge_priority_function", "=", "cl", "\n", "g", ".", "rebuild_merge_queue", "(", ")", "\n", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.bench_suite": [[86, 121], ["collections.OrderedDict", "collections.OrderedDict", "bench_gala.trdata", "asv.extern.asizeof.asizeof", "asv.extern.asizeof.asizeof", "asv.extern.asizeof.asizeof", "gala.agglo.classifier_probability", "bench_gala.tsdata", "gala.agglo.Rag", "asv.extern.asizeof.asizeof", "bench_gala.timer", "gala.agglo.Rag", "bench_gala.timer", "agglo.Rag.set_feature_manager", "asv.extern.asizeof.asizeof", "bench_gala.timer", "agglo.Rag.learn_flat", "bench_gala.timer", "agglo.Rag.learn_agglomerate", "bench_gala.timer", "gala.classify.DefaultRandomForest", "classify.DefaultRandomForest.fit", "bench_gala.timer", "agglo.Rag.agglomerate"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.trdata", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.classifier_probability", "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.tsdata", "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.timer", "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.timer", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_feature_manager", "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.timer", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_flat", "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.timer", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.timer", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.timer", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate"], ["", "def", "bench_suite", "(", ")", ":", "\n", "    ", "times", "=", "OrderedDict", "(", ")", "\n", "memory", "=", "OrderedDict", "(", ")", "\n", "wstr", ",", "prtr", ",", "gttr", "=", "trdata", "(", ")", "\n", "with", "timer", "(", ")", "as", "t_build_rag", ":", "\n", "        ", "g", "=", "agglo", ".", "Rag", "(", "wstr", ",", "prtr", ")", "\n", "", "times", "[", "'build RAG'", "]", "=", "t_build_rag", "[", "0", "]", "\n", "memory", "[", "'base RAG'", "]", "=", "asizeof", "(", "g", ")", "\n", "with", "timer", "(", ")", "as", "t_features", ":", "\n", "        ", "g", ".", "set_feature_manager", "(", "em", ")", "\n", "", "times", "[", "'build feature caches'", "]", "=", "t_features", "[", "0", "]", "\n", "memory", "[", "'feature caches'", "]", "=", "asizeof", "(", "g", ")", "-", "memory", "[", "'base RAG'", "]", "\n", "with", "timer", "(", ")", "as", "t_flat", ":", "\n", "        ", "_ignore", "=", "g", ".", "learn_flat", "(", "gttr", ",", "em", ")", "\n", "", "times", "[", "'learn flat'", "]", "=", "t_flat", "[", "0", "]", "\n", "with", "timer", "(", ")", "as", "t_gala", ":", "\n", "        ", "(", "X", ",", "y", ",", "w", ",", "e", ")", ",", "allepochs", "=", "g", ".", "learn_agglomerate", "(", "gttr", ",", "em", ",", "\n", "min_num_epochs", "=", "5", ")", "\n", "y", "=", "y", "[", ":", ",", "0", "]", "# ignore rand-sign and vi-sign schemes", "\n", "", "memory", "[", "'training data'", "]", "=", "asizeof", "(", "(", "X", ",", "y", ",", "w", ",", "e", ")", ")", "\n", "times", "[", "'learn agglo'", "]", "=", "t_gala", "[", "0", "]", "\n", "with", "timer", "(", ")", "as", "t_train_classifier", ":", "\n", "        ", "cl", "=", "classify", ".", "DefaultRandomForest", "(", ")", "\n", "cl", ".", "fit", "(", "X", ",", "y", ")", "\n", "", "times", "[", "'classifier training'", "]", "=", "t_train_classifier", "[", "0", "]", "\n", "memory", "[", "'classifier training'", "]", "=", "asizeof", "(", "cl", ")", "\n", "policy", "=", "agglo", ".", "classifier_probability", "(", "em", ",", "cl", ")", "\n", "wsts", ",", "prts", ",", "gtts", "=", "tsdata", "(", ")", "\n", "gtest", "=", "agglo", ".", "Rag", "(", "wsts", ",", "prts", ",", "merge_priority_function", "=", "policy", ",", "\n", "feature_manager", "=", "em", ")", "\n", "with", "timer", "(", ")", "as", "t_segment", ":", "\n", "        ", "gtest", ".", "agglomerate", "(", "np", ".", "inf", ")", "\n", "", "times", "[", "'segment test volume'", "]", "=", "t_segment", "[", "0", "]", "\n", "memory", "[", "'segment test volume'", "]", "=", "asizeof", "(", "gtest", ")", "\n", "return", "times", ",", "memory", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.benchmarks.bench_gala.print_bench_results": [[123, 132], ["print", "print", "print", "print"], "function", ["None"], ["", "def", "print_bench_results", "(", "times", "=", "None", ",", "memory", "=", "None", ")", ":", "\n", "    ", "if", "times", "is", "not", "None", ":", "\n", "        ", "print", "(", "'Timing results:'", ")", "\n", "for", "key", "in", "times", ":", "\n", "            ", "print", "(", "'--- '", ",", "key", ",", "times", "[", "key", "]", ")", "\n", "", "", "if", "memory", "is", "not", "None", ":", "\n", "        ", "print", "(", "'Memory results:'", ")", "\n", "for", "key", "in", "memory", ":", "\n", "            ", "print", "(", "'--- '", ",", "key", ",", "'%.3f MB'", "%", "(", "memory", "[", "key", "]", "/", "1e6", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.doc.conf.Mock.__init__": [[28, 30], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.doc.conf.Mock.__call__": [[31, 33], ["conf.Mock"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "Mock", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.doc.conf.Mock.__getattr__": [[34, 42], ["name[].upper", "type", "conf.Mock"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "if", "name", "in", "(", "'__file__'", ",", "'__path__'", ")", ":", "\n", "            ", "return", "'/dev/null'", "\n", "", "elif", "name", "[", "0", "]", "==", "name", "[", "0", "]", ".", "upper", "(", ")", ":", "\n", "            ", "return", "type", "(", "name", ",", "(", ")", ",", "{", "}", ")", "\n", "", "else", ":", "\n", "            ", "return", "Mock", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.logo.logo.logo_iterate": [[17, 51], ["itertools.count", "itertools.permutations", "numpy.zeros", "numpy.arange().astype", "itertools.permutations", "itertools.product", "itertools.permutations", "itertools.permutations", "itertools.product", "skimage.color.label2rgb", "skimage.io.imsave", "logo._split_img_horizontal", "skimage.color.label2rgb", "skimage.io.imsave", "skimage.color.label2rgb", "skimage.io.imsave", "logo._split_img_horizontal", "skimage.color.label2rgb", "skimage.io.imsave", "numpy.arange", "next", "next", "next", "next"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.logo.logo._split_img_horizontal", "home.repos.pwc.inspect_result.janelia-flyem_gala.logo.logo._split_img_horizontal"], ["def", "logo_iterate", "(", "labels", ",", "image", ",", "fns", "=", "d", "+", "'logo-%03i.png'", ")", ":", "\n", "    ", "height", ",", "width", "=", "labels", ".", "shape", "\n", "background", "=", "(", "labels", "==", "0", ")", "\n", "foreground", "=", "~", "background", "\n", "counter", "=", "it", ".", "count", "(", ")", "\n", "\n", "# part one: just foreground/background", "\n", "colorcombos", "=", "it", ".", "permutations", "(", "colors", ",", "2", ")", "\n", "lab2", "=", "np", ".", "zeros", "(", "labels", ".", "shape", ",", "np", ".", "uint8", ")", "\n", "lab2", "[", "foreground", "]", "=", "1", "\n", "for", "cs", "in", "colorcombos", ":", "\n", "        ", "img", "=", "color", ".", "label2rgb", "(", "lab2", ",", "image", ",", "colors", "=", "cs", ")", "\n", "io", ".", "imsave", "(", "fns", "%", "next", "(", "counter", ")", ",", "img", ")", "\n", "\n", "# part two: background split", "\n", "", "splits", "=", "np", ".", "arange", "(", "500", ",", "1600", ",", "100", ")", ".", "astype", "(", "int", ")", "\n", "colorcombos", "=", "it", ".", "permutations", "(", "colors", ",", "3", ")", "\n", "for", "s", ",", "cs", "in", "it", ".", "product", "(", "splits", ",", "colorcombos", ")", ":", "\n", "        ", "im", ",", "lab", "=", "_split_img_horizontal", "(", "image", ",", "lab2", ",", "background", ",", "s", ")", "\n", "img", "=", "color", ".", "label2rgb", "(", "lab", ",", "im", ",", "colors", "=", "cs", ")", "\n", "io", ".", "imsave", "(", "fns", "%", "next", "(", "counter", ")", ",", "img", ")", "\n", "\n", "# part three: foreground split", "\n", "", "colorcombos", "=", "it", ".", "permutations", "(", "colors", ",", "3", ")", "\n", "for", "cs", "in", "colorcombos", ":", "\n", "        ", "img", "=", "color", ".", "label2rgb", "(", "labels", ",", "image", ",", "colors", "=", "cs", ")", "\n", "io", ".", "imsave", "(", "fns", "%", "next", "(", "counter", ")", ",", "img", ")", "\n", "\n", "# part four: both split", "\n", "", "colorcombos", "=", "it", ".", "permutations", "(", "colors", ",", "4", ")", "\n", "for", "s", ",", "cs", "in", "it", ".", "product", "(", "splits", ",", "colorcombos", ")", ":", "\n", "        ", "im", ",", "lab", "=", "_split_img_horizontal", "(", "image", ",", "labels", ",", "background", ",", "s", ")", "\n", "img", "=", "color", ".", "label2rgb", "(", "lab", ",", "im", ",", "colors", "=", "cs", ")", "\n", "io", ".", "imsave", "(", "fns", "%", "next", "(", "counter", ")", ",", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.logo.logo._split_img_horizontal": [[53, 62], ["numpy.zeros_like", "numpy.zeros_like", "numpy.copy", "numpy.copy", "labels.max"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "", "def", "_split_img_horizontal", "(", "image", ",", "labels", ",", "background", ",", "height", ")", ":", "\n", "    ", "image", ",", "labels", "=", "np", ".", "copy", "(", "image", ")", ",", "np", ".", "copy", "(", "labels", ")", "\n", "lower", "=", "np", ".", "zeros_like", "(", "background", ")", "\n", "lower", "[", "height", ":", ",", ":", "]", "=", "True", "\n", "labels", "[", "background", "&", "lower", "]", "=", "labels", ".", "max", "(", ")", "+", "1", "\n", "strip", "=", "np", ".", "zeros_like", "(", "background", ")", "\n", "strip", "[", "height", ":", "(", "height", "+", "20", ")", ",", ":", "]", "=", "True", "\n", "image", "[", "strip", "&", "background", "]", "=", "0.16", "\n", "return", "image", ",", "labels", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.imshow_grey": [[12, 28], ["axis.imshow", "matplotlib.pyplot.subplots"], "function", ["None"], ["def", "imshow_grey", "(", "im", ",", "axis", "=", "None", ")", ":", "\n", "    ", "\"\"\"Show a segmentation using a gray colormap.\n\n    Parameters\n    ----------\n    im : np.ndarray of int, shape (M, N)\n        The segmentation to be displayed.\n\n    Returns\n    -------\n    fig : plt.Figure\n        The image shown.\n    \"\"\"", "\n", "if", "axis", "is", "None", ":", "\n", "        ", "fig", ",", "axis", "=", "plt", ".", "subplots", "(", ")", "\n", "", "return", "axis", ".", "imshow", "(", "im", ",", "cmap", "=", "'gray'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.imshow_magma": [[30, 46], ["axis.imshow", "matplotlib.pyplot.subplots"], "function", ["None"], ["", "def", "imshow_magma", "(", "im", ",", "axis", "=", "None", ")", ":", "\n", "    ", "\"\"\"Show a segmentation using a magma colormap.\n\n    Parameters\n    ----------\n    im : np.ndarray of int, shape (M, N)\n        The segmentation to be displayed.\n\n    Returns\n    -------\n    fig : plt.Figure\n        The image shown.\n    \"\"\"", "\n", "if", "axis", "is", "None", ":", "\n", "        ", "fig", ",", "axis", "=", "plt", ".", "subplots", "(", ")", "\n", "", "return", "axis", ".", "imshow", "(", "im", ",", "cmap", "=", "'magma'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.imshow_rand": [[48, 76], ["numpy.random.random", "matplotlib.cm.colors.ListedColormap", "axis.imshow", "matplotlib.pyplot.subplots", "numpy.concatenate", "skimage.color.lab2rgb", "math.ceil", "numpy.zeros", "numpy.max"], "function", ["None"], ["", "def", "imshow_rand", "(", "im", ",", "axis", "=", "None", ",", "labrandom", "=", "True", ")", ":", "\n", "    ", "\"\"\"Show a segmentation using a random colormap.\n\n    Parameters\n    ----------\n    im : np.ndarray of int, shape (M, N)\n        The segmentation to be displayed.\n    labrandom : bool, optional\n        Use random points in the Lab colorspace instead of RGB.\n\n    Returns\n    -------\n    fig : plt.Figure\n        The image shown.\n    \"\"\"", "\n", "if", "axis", "is", "None", ":", "\n", "        ", "fig", ",", "axis", "=", "plt", ".", "subplots", "(", ")", "\n", "", "rand_colors", "=", "np", ".", "random", ".", "random", "(", "size", "=", "(", "ceil", "(", "np", ".", "max", "(", "im", ")", ")", ",", "3", ")", ")", "\n", "if", "labrandom", ":", "\n", "        ", "rand_colors", "[", ":", ",", "0", "]", "=", "rand_colors", "[", ":", ",", "0", "]", "*", "81", "+", "39", "\n", "rand_colors", "[", ":", ",", "1", "]", "=", "rand_colors", "[", ":", ",", "1", "]", "*", "185", "-", "86", "\n", "rand_colors", "[", ":", ",", "2", "]", "=", "rand_colors", "[", ":", ",", "2", "]", "*", "198", "-", "108", "\n", "rand_colors", "=", "color", ".", "lab2rgb", "(", "rand_colors", "[", "np", ".", "newaxis", ",", "...", "]", ")", "[", "0", "]", "\n", "rand_colors", "[", "rand_colors", "<", "0", "]", "=", "0", "\n", "rand_colors", "[", "rand_colors", ">", "1", "]", "=", "1", "\n", "", "rcmap", "=", "cm", ".", "colors", ".", "ListedColormap", "(", "np", ".", "concatenate", "(", "(", "np", ".", "zeros", "(", "(", "1", ",", "3", ")", ")", ",", "\n", "rand_colors", ")", ")", ")", "\n", "return", "axis", ".", "imshow", "(", "im", ",", "cmap", "=", "rcmap", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.show_multiple_images": [[78, 116], ["len", "matplotlib.pyplot.figure", "range", "ax.set_title", "plt.figure.add_subplot", "viz.imshow_grey", "viz.imshow_magma", "viz.imshow_rand", "ax.imshow", "print"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.set_title", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.imshow_grey", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.imshow_magma", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.imshow_rand"], ["", "def", "show_multiple_images", "(", "*", "images", ",", "axes", "=", "None", ",", "image_type", "=", "'raw'", ")", ":", "\n", "    ", "\"\"\"Returns a figure with subplots containing multiple images.\n\n    Parameters\n    ----------\n    images : np.ndarray of int, shape (M, N)\n        The input images to be displayed.\n    axes: matplotlib.AxesImage, optional\n        Whether to pass in multiple axes. Must be equal to the number of\n        input images.\n    image_type : string, optional\n        Displays the images with different colormaps. Set to display\n        'raw' by default. Other options that are accepted\n        are 'grey' and 'magma', or 'rand'.\n\n    Returns\n    -------\n    fig : plt.Figure\n        The image shown.\n    \"\"\"", "\n", "number_of_im", "=", "len", "(", "images", ")", "\n", "figure", "=", "plt", ".", "figure", "(", ")", "\n", "for", "i", "in", "range", "(", "number_of_im", ")", ":", "\n", "        ", "ax", "=", "(", "figure", ".", "add_subplot", "(", "1", ",", "number_of_im", ",", "i", "+", "1", ")", "if", "axes", "is", "None", "\n", "else", "axes", "[", "i", "]", ")", "\n", "if", "image_type", "==", "'grey'", "or", "image_type", "==", "'gray'", ":", "\n", "            ", "imshow_grey", "(", "images", "[", "i", "]", ",", "axis", "=", "ax", ")", "\n", "", "elif", "image_type", "==", "'magma'", ":", "\n", "            ", "imshow_magma", "(", "images", "[", "i", "]", ",", "axis", "=", "ax", ")", "\n", "", "elif", "image_type", "==", "'rand'", ":", "\n", "            ", "imshow_rand", "(", "images", "[", "i", "]", ",", "axis", "=", "ax", ")", "\n", "", "elif", "image_type", "==", "'raw'", ":", "\n", "            ", "ax", ".", "imshow", "(", "images", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"not a valid image type.\"", ")", "\n", "return", "None", "\n", "", "ax", ".", "set_title", "(", "f'Image number {i+1} with a {image_type} colormap.'", ")", "\n", "", "return", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.draw_seg": [[118, 155], ["numpy.zeros_like", "numpy.unique", "im[].mean"], "function", ["None"], ["", "def", "draw_seg", "(", "seg", ",", "im", ")", ":", "\n", "    ", "\"\"\"Return a segmentation map matching the original image color.\n\n    Parameters\n    ----------\n    seg : np.ndarray of int, shape (M, N, ...)\n        The segmentation to be displayed\n    im : np.ndarray, shape (M, N, ..., C)\n        The image corresponding to the segmentation.\n\n    Returns\n    -------\n    out : np.ndarray, same shape and type as `im`.\n        An image where each segment has uniform color.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 1, 2, 2],\n    ...               [1, 2, 2, 3],\n    ...               [2, 2, 3, 3]])\n    >>> g = np.array([[0.5, 0.2, 1.0, 0.9],\n    ...               [0.2, 0.8, 0.9, 0.6],\n    ...               [0.9, 0.9, 0.4, 0.5]])\n    >>> draw_seg(a, g)\n    array([[0.3, 0.3, 0.9, 0.9],\n           [0.3, 0.9, 0.9, 0.5],\n           [0.9, 0.9, 0.5, 0.5]])\n    \"\"\"", "\n", "out", "=", "np", ".", "zeros_like", "(", "im", ")", "\n", "labels", "=", "np", ".", "unique", "(", "seg", ")", "\n", "if", "(", "seg", "==", "0", ")", ".", "any", "(", ")", ":", "\n", "        ", "labels", "=", "labels", "[", "1", ":", "]", "\n", "", "for", "u", "in", "labels", ":", "\n", "        ", "mask", "=", "(", "seg", "==", "u", ")", ".", "nonzero", "(", ")", "\n", "color", "=", "im", "[", "mask", "]", ".", "mean", "(", "axis", "=", "0", ")", "\n", "out", "[", "mask", "]", "=", "color", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.display_3d_segmentations": [[157, 207], ["len", "list", "matplotlib.pyplot.figure", "enumerate", "itertools.combinations_with_replacement", "matplotlib.pyplot.subplot", "viz.imshow_grey", "matplotlib.pyplot.subplot", "viz.imshow_magma", "range", "matplotlib.pyplot.subplot", "viz.imshow_rand", "range", "numpy.rollaxis", "numpy.rollaxis", "numpy.rollaxis"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.imshow_grey", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.imshow_magma", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.imshow_rand"], ["", "def", "display_3d_segmentations", "(", "segs", ",", "image", "=", "None", ",", "probability_map", "=", "None", ",", "axis", "=", "0", ",", "\n", "z", "=", "None", ",", "fignum", "=", "None", ")", ":", "\n", "    ", "\"\"\"Show slices of multiple 3D segmentations.\n\n    Parameters\n    ----------\n    segs : list or tuple of np.ndarray of int, shape (M, N, P)\n        The segmentations to be examined.\n    image : np.ndarray, shape (M, N, P[, 3]), optional\n        The image corresponding to the segmentations.\n    probability_map : np.ndarray, shape (M, N, P), optional\n        The segment boundary probability map.\n    axis : int in {0, 1, 2}, optional\n        The axis along which to show a slice of the segmentation.\n    z : int in [0, `(M, N, P)[axis]`), optional\n        The slice to display. Defaults to the middle slice.\n    fignum : int, optional\n        Which figure number to use. Uses the default (new figure) if none is\n        provided.\n\n    Returns\n    -------\n    fig : plt.Figure\n        The figure handle.\n    \"\"\"", "\n", "numplots", "=", "len", "(", "segs", ")", "\n", "if", "image", "is", "not", "None", ":", "\n", "        ", "numplots", "+=", "1", "\n", "", "if", "probability_map", "is", "not", "None", ":", "\n", "        ", "numplots", "+=", "1", "\n", "", "candidate_plot_arrangements", "=", "list", "(", "it", ".", "combinations_with_replacement", "(", "\n", "range", "(", "1", ",", "5", ")", ",", "2", ")", ")", "\n", "# get the smallest plot arrangement that can display the number of", "\n", "# segmentations we want", "\n", "plot_arrangement", "=", "[", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "candidate_plot_arrangements", "\n", "if", "i", "*", "j", ">=", "numplots", "]", "[", "0", "]", "\n", "fig", "=", "plt", ".", "figure", "(", "fignum", ")", "\n", "current_subplot", "=", "1", "\n", "if", "image", "is", "not", "None", ":", "\n", "        ", "plt", ".", "subplot", "(", "*", "plot_arrangement", "+", "(", "current_subplot", ",", ")", ")", "\n", "imshow_grey", "(", "np", ".", "rollaxis", "(", "image", ",", "axis", ")", "[", "z", "]", ")", "\n", "current_subplot", "+=", "1", "\n", "", "if", "probability_map", "is", "not", "None", ":", "\n", "        ", "plt", ".", "subplot", "(", "*", "plot_arrangement", "+", "(", "current_subplot", ",", ")", ")", "\n", "imshow_magma", "(", "np", ".", "rollaxis", "(", "probability_map", ",", "axis", ")", "[", "z", "]", ")", "\n", "current_subplot", "+=", "1", "\n", "", "for", "i", ",", "j", "in", "enumerate", "(", "range", "(", "current_subplot", ",", "numplots", "+", "1", ")", ")", ":", "\n", "        ", "plt", ".", "subplot", "(", "*", "plot_arrangement", "+", "(", "j", ",", ")", ")", "\n", "imshow_rand", "(", "np", ".", "rollaxis", "(", "segs", "[", "i", "]", ",", "axis", ")", "[", "z", "]", ")", "\n", "", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.plot_vi": [[209, 242], ["g.get_segmentation", "matplotlib.pyplot.plot", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "v.append", "n.append", "matplotlib.pyplot.figure", "evaluate.vi", "len", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi"], ["", "def", "plot_vi", "(", "g", ",", "history", ",", "gt", ",", "fig", "=", "None", ")", ":", "\n", "    ", "\"\"\"Plot the VI from segmentations based on Rag and sequence of merges.\n\n    Parameters\n    ----------\n    g : agglo.Rag object\n        The region adjacency graph.\n\n    history : list of tuples\n        The merge history of the RAG.\n\n    gt : np.ndarray\n        The ground truth corresponding to the RAG.\n\n    fig : plt.Figure, optional\n        Use this figure for plotting. If not provided, a new figure is created.\n\n    Returns\n    -------\n    None\n    \"\"\"", "\n", "v", "=", "[", "]", "\n", "n", "=", "[", "]", "\n", "seg", "=", "g", ".", "get_segmentation", "(", ")", "\n", "for", "i", "in", "history", ":", "\n", "        ", "seg", "[", "seg", "==", "i", "[", "1", "]", "]", "=", "i", "[", "0", "]", "\n", "v", ".", "append", "(", "evaluate", ".", "vi", "(", "seg", ",", "gt", ")", ")", "\n", "n", ".", "append", "(", "len", "(", "np", ".", "unique", "(", "seg", ")", "-", "1", ")", ")", "\n", "", "if", "fig", "is", "None", ":", "\n", "        ", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "", "plt", ".", "plot", "(", "n", ",", "v", ",", "figure", "=", "fig", ")", "\n", "plt", ".", "xlabel", "(", "'Number of segments'", ",", "figure", "=", "fig", ")", "\n", "plt", ".", "ylabel", "(", "'vi'", ",", "figure", "=", "fig", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.plot_vi_breakdown_panel": [[244, 277], ["numpy.arange", "matplotlib.pyplot.scatter", "matplotlib.pyplot.xlim", "matplotlib.pyplot.ylim", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "max", "max", "matplotlib.pyplot.plot", "min", "max", "min", "max", "max", "max", "max"], "function", ["None"], ["", "def", "plot_vi_breakdown_panel", "(", "px", ",", "h", ",", "title", ",", "xlab", ",", "ylab", ",", "hlines", ",", "scatter_size", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Plot a single panel (over or undersegmentation) of VI breakdown plot.\n\n    Parameters\n    ----------\n    px : np.ndarray of float, shape (N,)\n        The probability (size) of each segment.\n    h : np.ndarray of float, shape (N,)\n        The conditional entropy of that segment.\n    title, xlab, ylab : string\n        Parameters for `matplotlib.plt.plot`.\n    hlines : iterable of float\n        Plot hyperbolic lines of same VI contribution. For each value `v` in\n        `hlines`, draw the line `h = v/px`.\n    scatter_size : int, optional\n    **kwargs : dict\n        Additional keyword arguments for `matplotlib.pyplot.plot`.\n\n    Returns\n    -------\n    None\n    \"\"\"", "\n", "x", "=", "np", ".", "arange", "(", "max", "(", "min", "(", "px", ")", ",", "1e-10", ")", ",", "max", "(", "px", ")", ",", "(", "max", "(", "px", ")", "-", "min", "(", "px", ")", ")", "/", "100.0", ")", "\n", "for", "val", "in", "hlines", ":", "\n", "        ", "plt", ".", "plot", "(", "x", ",", "val", "/", "x", ",", "color", "=", "'gray'", ",", "ls", "=", "':'", ",", "**", "kwargs", ")", "\n", "", "plt", ".", "scatter", "(", "px", ",", "h", ",", "label", "=", "title", ",", "s", "=", "scatter_size", ",", "**", "kwargs", ")", "\n", "# Make points clickable to identify ID. This section needs work.", "\n", "plt", ".", "xlim", "(", "xmin", "=", "-", "0.05", "*", "max", "(", "px", ")", ",", "xmax", "=", "1.05", "*", "max", "(", "px", ")", ")", "\n", "plt", ".", "ylim", "(", "ymin", "=", "-", "0.05", "*", "max", "(", "h", ")", ",", "ymax", "=", "1.05", "*", "max", "(", "h", ")", ")", "\n", "plt", ".", "xlabel", "(", "xlab", ")", "\n", "plt", ".", "ylabel", "(", "ylab", ")", "\n", "plt", ".", "title", "(", "title", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.plot_vi_breakdown": [[279, 340], ["matplotlib.pyplot.ion", "evaluate.vi_tables", "matplotlib.pyplot.figure", "viz.plot_vi_breakdown_panel", "viz.plot_vi_breakdown_panel", "type", "max", "numpy.arange", "matplotlib.pyplot.subplot", "matplotlib.pyplot.subplot", "matplotlib.pyplot.title", "matplotlib.pyplot.legend", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "max", "matplotlib.pyplot.xlim", "max", "matplotlib.pyplot.ylim", "cu[].max", "co[].max", "px.max", "py.max", "lpygx.min", "lpxgy.min"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi_tables", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.plot_vi_breakdown_panel", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.plot_vi_breakdown_panel"], ["", "def", "plot_vi_breakdown", "(", "seg", ",", "gt", ",", "ignore_seg", "=", "[", "]", ",", "ignore_gt", "=", "[", "]", ",", "\n", "hlines", "=", "None", ",", "subplot", "=", "False", ",", "figsize", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Plot conditional entropy H(Y|X) vs P(X) for both seg|gt and gt|seg.\n\n    Parameters\n    ----------\n    seg : np.ndarray of int, shape (M, [N, ..., P])\n        The automatic (candidate) segmentation.\n    gt : np.ndarray of int, shape (M, [N, ..., P]) (same as `seg`)\n        The gold standard/ground truth segmentation.\n    ignore_seg : list of int, optional\n        Ignore segments in this list from the automatic segmentation during\n        evaluation and plotting.\n    ignore_gt : list of int, optional\n        Ignore segments in this list from the ground truth segmentation during\n        evaluation and plotting.\n    hlines : int, optional\n        Plot this many isoclines between the minimum and maximum VI\n        contributions.\n    subplot : bool, optional\n        If True, plot oversegmentation and undersegmentation in separate\n        subplots.\n    figsize : tuple of float, optional\n        The figure width and height, in inches.\n    **kwargs : dict\n        Additional keyword arguments for `matplotlib.pyplot.plot`.\n\n    Returns\n    -------\n    None\n    \"\"\"", "\n", "plt", ".", "ion", "(", ")", "\n", "pxy", ",", "px", ",", "py", ",", "hxgy", ",", "hygx", ",", "lpygx", ",", "lpxgy", "=", "evaluate", ".", "vi_tables", "(", "seg", ",", "gt", ",", "\n", "ignore_seg", ",", "ignore_gt", ")", "\n", "cu", "=", "-", "px", "*", "lpygx", "\n", "co", "=", "-", "py", "*", "lpxgy", "\n", "if", "hlines", "is", "None", ":", "\n", "        ", "hlines", "=", "[", "]", "\n", "", "elif", "hlines", "==", "True", ":", "\n", "        ", "hlines", "=", "10", "\n", "", "if", "type", "(", "hlines", ")", "==", "int", ":", "\n", "        ", "maxc", "=", "max", "(", "cu", "[", "cu", "!=", "0", "]", ".", "max", "(", ")", ",", "co", "[", "co", "!=", "0", "]", ".", "max", "(", ")", ")", "\n", "hlines", "=", "np", ".", "arange", "(", "maxc", "/", "hlines", ",", "maxc", ",", "maxc", "/", "hlines", ")", "\n", "", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "if", "subplot", ":", "plt", ".", "subplot", "(", "1", ",", "2", ",", "1", ")", "\n", "plot_vi_breakdown_panel", "(", "px", ",", "-", "lpygx", ",", "\n", "'False merges'", ",", "'p(S=seg)'", ",", "'H(G|S=seg)'", ",", "\n", "hlines", ",", "c", "=", "'blue'", ",", "**", "kwargs", ")", "\n", "if", "subplot", ":", "plt", ".", "subplot", "(", "1", ",", "2", ",", "2", ")", "\n", "plot_vi_breakdown_panel", "(", "py", ",", "-", "lpxgy", ",", "\n", "'False splits'", ",", "'p(G=gt)'", ",", "'H(S|G=gt)'", ",", "\n", "hlines", ",", "c", "=", "'orange'", ",", "**", "kwargs", ")", "\n", "if", "not", "subplot", ":", "\n", "        ", "plt", ".", "title", "(", "'vi contributions by body.'", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'upper right'", ",", "scatterpoints", "=", "1", ")", "\n", "plt", ".", "xlabel", "(", "'Segment size (fraction of volume)'", ",", "fontsize", "=", "'large'", ")", "\n", "plt", ".", "ylabel", "(", "'Conditional entropy (bits)'", ",", "fontsize", "=", "'large'", ")", "\n", "xmax", "=", "max", "(", "px", ".", "max", "(", ")", ",", "py", ".", "max", "(", ")", ")", "\n", "plt", ".", "xlim", "(", "-", "0.05", "*", "xmax", ",", "1.05", "*", "xmax", ")", "\n", "ymax", "=", "max", "(", "-", "lpygx", ".", "min", "(", ")", ",", "-", "lpxgy", ".", "min", "(", ")", ")", "\n", "plt", ".", "ylim", "(", "-", "0.05", "*", "ymax", ",", "1.05", "*", "ymax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.add_opts_to_plot": [[342, 382], ["zip", "type", "len", "len", "itertools.cycle", "type", "len", "len", "itertools.cycle", "points.append", "matplotlib.pyplot.scatter", "ar.sum().argmin", "ar.sum"], "function", ["None"], ["", "", "def", "add_opts_to_plot", "(", "ars", ",", "colors", "=", "'k'", ",", "markers", "=", "'^'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"In an existing active split-vi plot, add the point of optimal VI.\n\n    By default, a star marker is used.\n\n    Parameters\n    ----------\n    ars : list of numpy arrays\n        Each array has shape (2, N) and represents a split-VI curve,\n        with `ars[i][0]` holding the undersegmentation and `ars[i][1]`\n        holding the oversegmentation for each `i`.\n    colors : string, list of string, or list of float tuple, optional\n        A color specification or list of color specifications. If there\n        are fewer colors than split-VI arrays, the colors are cycled.\n    markers : string, or list of string, optional\n        Point marker specification (as defined in matplotlib) or list\n        thereof. As with colors, if there are fewer markers than VI\n        arrays, the markers are cycled.\n    **kwargs : dict (string keys), optional\n        Keyword arguments to be passed through to\n        `matplotlib.pyplot.scatter`.\n\n    Returns\n    -------\n    points : list of `matplotlib.collections.PathCollection`\n        The points returned by each of the calls to `scatter`.\n    \"\"\"", "\n", "if", "type", "(", "colors", ")", "not", "in", "[", "list", ",", "tuple", "]", ":", "\n", "        ", "colors", "=", "[", "colors", "]", "\n", "", "if", "len", "(", "colors", ")", "<", "len", "(", "ars", ")", ":", "\n", "        ", "colors", "=", "it", ".", "cycle", "(", "colors", ")", "\n", "", "if", "type", "(", "markers", ")", "not", "in", "[", "list", ",", "tuple", "]", ":", "\n", "        ", "markers", "=", "[", "markers", "]", "\n", "", "if", "len", "(", "markers", ")", "<", "len", "(", "ars", ")", ":", "\n", "        ", "markers", "=", "it", ".", "cycle", "(", "markers", ")", "\n", "", "points", "=", "[", "]", "\n", "for", "ar", ",", "c", ",", "m", "in", "zip", "(", "ars", ",", "colors", ",", "markers", ")", ":", "\n", "        ", "opt", "=", "ar", "[", ":", ",", "ar", ".", "sum", "(", "axis", "=", "0", ")", ".", "argmin", "(", ")", "]", "\n", "points", ".", "append", "(", "plt", ".", "scatter", "(", "opt", "[", "0", "]", ",", "opt", "[", "1", "]", ",", "c", "=", "c", ",", "marker", "=", "m", ",", "**", "kwargs", ")", ")", "\n", "", "return", "points", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.add_nats_to_plot": [[383, 429], ["zip", "type", "len", "len", "itertools.cycle", "type", "len", "len", "itertools.cycle", "type", "len", "len", "itertools.cycle", "points.append", "matplotlib.pyplot.scatter", "numpy.flatnonzero"], "function", ["None"], ["", "def", "add_nats_to_plot", "(", "ars", ",", "tss", ",", "stops", "=", "0.5", ",", "colors", "=", "'k'", ",", "markers", "=", "'o'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"In an existing active split-vi plot, add the natural stopping point.\n\n    By default, a circle marker is used.\n\n    Parameters\n    ----------\n    ars : list of numpy arrays\n        Each array has shape (2, N) and represents a split-VI curve,\n        with `ars[i][0]` holding the undersegmentation and `ars[i][1]`\n        holding the oversegmentation for each `i`.\n    tss : list of numpy arrays\n        Each array has shape (N,) and represents the algorithm\n        threshold that gave rise to the VI measurements in `ars`.\n    stops : float, optional\n        The natural stopping point for the algorithm. For example, if\n        an algorithm merges segments according to a merge probability,\n        the natural stopping point is at $p=0.5$, when there are even\n        odds of the merge being a true merge.\n    colors : string, list of string, or list of float tuple, optional\n        A color specification or list of color specifications. If there\n        are fewer colors than split-VI arrays, the colors are cycled.\n    markers : string, or list of string, optional\n        Point marker specification (as defined in matplotlib) or list\n        thereof. As with colors, if there are fewer markers than VI\n        arrays, the markers are cycled.\n    **kwargs : dict (string keys), optional\n        Keyword arguments to be passed through to\n        `matplotlib.pyplot.scatter`.\n\n    Returns\n    -------\n    points : list of `matplotlib.collections.PathCollection`\n        The points returned by each of the calls to `scatter`.\n    \"\"\"", "\n", "if", "type", "(", "colors", ")", "not", "in", "[", "list", ",", "tuple", "]", ":", "colors", "=", "[", "colors", "]", "\n", "if", "len", "(", "colors", ")", "<", "len", "(", "ars", ")", ":", "colors", "=", "it", ".", "cycle", "(", "colors", ")", "\n", "if", "type", "(", "markers", ")", "not", "in", "[", "list", ",", "tuple", "]", ":", "markers", "=", "[", "markers", "]", "\n", "if", "len", "(", "markers", ")", "<", "len", "(", "ars", ")", ":", "markers", "=", "it", ".", "cycle", "(", "markers", ")", "\n", "if", "type", "(", "stops", ")", "not", "in", "[", "list", ",", "tuple", "]", ":", "stops", "=", "[", "stops", "]", "\n", "if", "len", "(", "stops", ")", "<", "len", "(", "ars", ")", ":", "stops", "=", "it", ".", "cycle", "(", "stops", ")", "\n", "points", "=", "[", "]", "\n", "for", "ar", ",", "ts", ",", "stop", ",", "c", ",", "m", "in", "zip", "(", "ars", ",", "tss", ",", "stops", ",", "colors", ",", "markers", ")", ":", "\n", "        ", "nat", "=", "ar", "[", ":", ",", "np", ".", "flatnonzero", "(", "ts", "<", "stop", ")", "[", "-", "1", "]", "]", "\n", "points", ".", "append", "(", "plt", ".", "scatter", "(", "nat", "[", "0", "]", ",", "nat", "[", "1", "]", ",", "c", "=", "c", ",", "marker", "=", "m", ",", "**", "kwargs", ")", ")", "\n", "", "return", "points", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.plot_split_vi": [[430, 473], ["zip", "type", "type", "len", "len", "itertools.cycle", "type", "len", "len", "itertools.cycle", "lines.append", "lines.append", "matplotlib.pyplot.plot", "matplotlib.pyplot.scatter", "kwargs.get"], "function", ["None"], ["", "def", "plot_split_vi", "(", "ars", ",", "best", "=", "None", ",", "colors", "=", "'k'", ",", "linespecs", "=", "'-'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Make a split-VI plot.\n\n    The split-VI plot was introduced in Nunez-Iglesias et al, 2013 [1]\n\n    Parameters\n    ----------\n    ars : array or list of arrays of float, shape (2, N)\n        The input VI arrays. `ars[i][0]` should contain the\n        undersegmentation and `ars[i][1]` the oversegmentation.\n    best : array-like of float, len=2, optional\n        Agglomerative segmentations can't get to (0, 0) VI if the\n        starting superpixels are not perfectly aligned with the gold\n        standard segmentation. Therefore, there is a point of best\n        achievable VI. `best` should contain the coordinates of this\n        point.\n    colors : matplotlib color specification or list thereof, optional\n        The color of each line being plotted. If there are fewer colors\n        than arrays, they are cycled.\n    linespecs : matplotlib line type spec, or list thereof, optional\n        The line type to plot with ('-', '--', '-.', etc).\n    kwargs : dict, string keys, optional\n        Additional keyword arguments to pass through to plt.plot.\n\n    Returns\n    -------\n    lines : matplotlib Lines2D object(s)\n        The lines plotted.\n    \"\"\"", "\n", "if", "type", "(", "ars", ")", "not", "in", "[", "list", ",", "tuple", "]", ":", "ars", "=", "[", "ars", "]", "\n", "if", "type", "(", "colors", ")", "not", "in", "[", "list", ",", "tuple", "]", ":", "colors", "=", "[", "colors", "]", "\n", "if", "len", "(", "colors", ")", "<", "len", "(", "ars", ")", ":", "colors", "=", "it", ".", "cycle", "(", "colors", ")", "\n", "if", "type", "(", "linespecs", ")", "not", "in", "[", "list", ",", "tuple", "]", ":", "linespecs", "=", "[", "linespecs", "]", "\n", "if", "len", "(", "linespecs", ")", "<", "len", "(", "ars", ")", ":", "linespecs", "=", "it", ".", "cycle", "(", "linespecs", ")", "\n", "lines", "=", "[", "]", "\n", "for", "ar", ",", "color", ",", "linespec", "in", "zip", "(", "ars", ",", "colors", ",", "linespecs", ")", ":", "\n", "        ", "lines", ".", "append", "(", "plt", ".", "plot", "(", "ar", "[", "0", "]", ",", "ar", "[", "1", "]", ",", "c", "=", "color", ",", "ls", "=", "linespec", ",", "**", "kwargs", ")", ")", "\n", "", "if", "best", "is", "not", "None", ":", "\n", "        ", "lines", ".", "append", "(", "plt", ".", "scatter", "(", "\n", "best", "[", "0", "]", ",", "best", "[", "1", "]", ",", "\n", "c", "=", "kwargs", ".", "get", "(", "'best-color'", ",", "'k'", ")", ",", "marker", "=", "(", "5", ",", "3", ",", "0", ")", ",", "**", "kwargs", ")", "\n", ")", "\n", "", "return", "lines", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.plot_decision_function": [[475, 530], ["numpy.array", "numpy.linspace", "numpy.meshgrid", "numpy.hstack", "numpy.reshape", "matplotlib.pyplot.subplots", "ax.imshow", "ax.set_xticks", "ax.set_yticks", "matplotlib.pyplot.show", "clf.predict_proba", "ax.scatter", "numpy.min", "numpy.max", "numpy.reshape", "numpy.reshape", "matplotlib.cm.viridis", "matplotlib.cm.viridis", "numpy.zeros", "labels.astype", "numpy.max"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.predict_proba"], ["", "def", "plot_decision_function", "(", "clf", ",", "data_range", "=", "None", ",", "\n", "features", "=", "None", ",", "labels", "=", "None", ",", "feature_columns", "=", "[", "0", ",", "1", "]", ",", "\n", "n_gridpoints", "=", "201", ")", ":", "\n", "    ", "\"\"\"Plot the decision function of a classifier in 2D.\n\n    Parameters\n    ----------\n    clf : scikit-learn classifier\n        The classifier to be evaluated.\n    data_range : tuple of int, optional\n        The range of values to be evaluated.\n    features : 2D array of float, optional\n        The features of the training data.\n    labels : 1D array of int, optional\n        The labels of the training data.\n    feature_columns : tuple of int, optional\n        Which feature columns to plot, if there are more than two.\n    n_gridpoints : int, optional\n        The number of points to place on each dimension of the 2D grid.\n    \"\"\"", "\n", "if", "features", "is", "not", "None", ":", "\n", "        ", "features", "=", "features", "[", ":", ",", "feature_columns", "]", "\n", "minfeat", ",", "maxfeat", "=", "np", ".", "min", "(", "features", ")", ",", "np", ".", "max", "(", "features", ")", "\n", "featrange", "=", "maxfeat", "-", "minfeat", "\n", "\n", "", "if", "data_range", "is", "None", ":", "\n", "        ", "if", "features", "is", "None", ":", "\n", "            ", "data_range", "=", "(", "0", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "data_range", "=", "(", "minfeat", "-", "0.05", "*", "featrange", ",", "\n", "maxfeat", "+", "0.05", "*", "featrange", ")", "\n", "\n", "", "", "data_range", "=", "np", ".", "array", "(", "data_range", ")", "\n", "\n", "grid", "=", "np", ".", "linspace", "(", "*", "data_range", ",", "num", "=", "n_gridpoints", ",", "endpoint", "=", "True", ")", "\n", "rr", ",", "cc", "=", "np", ".", "meshgrid", "(", "grid", ",", "grid", ",", "sparse", "=", "False", ")", "\n", "feature_space", "=", "np", ".", "hstack", "(", "(", "np", ".", "reshape", "(", "rr", ",", "(", "-", "1", ",", "1", ")", ")", ",", "\n", "np", ".", "reshape", "(", "cc", ",", "(", "-", "1", ",", "1", ")", ")", ")", ")", "\n", "prediction", "=", "clf", ".", "predict_proba", "(", "feature_space", ")", "[", ":", ",", "1", "]", "# Pr(class(X)=1)", "\n", "prediction", "=", "np", ".", "reshape", "(", "prediction", ",", "(", "n_gridpoints", ",", "n_gridpoints", ")", ")", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "imshow", "(", "prediction", ",", "cmap", "=", "'RdBu'", ")", "\n", "ax", ".", "set_xticks", "(", "[", "]", ")", "\n", "ax", ".", "set_yticks", "(", "[", "]", ")", "\n", "\n", "features", "=", "(", "features", "-", "data_range", "[", "0", "]", ")", "/", "(", "data_range", "[", "1", "]", "-", "data_range", "[", "0", "]", ")", "\n", "\n", "if", "features", "is", "not", "None", ":", "\n", "        ", "if", "labels", "is", "not", "None", ":", "\n", "            ", "label_colors", "=", "cm", ".", "viridis", "(", "labels", ".", "astype", "(", "float", ")", "/", "np", ".", "max", "(", "labels", ")", ")", "\n", "", "else", ":", "\n", "            ", "label_colors", "=", "cm", ".", "viridis", "(", "np", ".", "zeros", "(", "features", ".", "shape", "[", "0", "]", ")", ")", "\n", "", "ax", ".", "scatter", "(", "*", "(", "features", ".", "T", "*", "n_gridpoints", ")", ",", "c", "=", "label_colors", ")", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.viz.plot_seeds": [[532, 538], ["ax.imshow", "ax.plot", "matplotlib.pyplot.subplots", "numpy.nonzero"], "function", ["None"], ["", "def", "plot_seeds", "(", "raw_image", ",", "seed_image", ",", "ax", "=", "None", ")", ":", "\n", "    ", "if", "ax", "is", "None", ":", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ")", "\n", "", "ax", ".", "imshow", "(", "raw_image", ",", "cmap", "=", "'gray'", ",", "interpolation", "=", "'nearest'", ")", "\n", "plt", ".", "autoscale", "=", "False", "\n", "ax", ".", "plot", "(", "*", "np", ".", "nonzero", "(", "seed_image", ")", "[", ":", ":", "-", "1", "]", ",", "'r.'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.__init__": [[5, 22], ["logging.getLogger", "app_logger.AppLogger.app_logger.setLevel", "logging.StreamHandler", "logging.Formatter", "app_logger.AppLogger.console.setFormatter", "app_logger.AppLogger.app_logger.addHandler", "app_logger.AppLogger.console.setLevel", "app_logger.AppLogger.console.setLevel", "app_logger.AppLogger.set_log_file"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.set_log_file"], ["    ", "def", "__init__", "(", "self", ",", "debug", ",", "logger_name", ",", "log_filename", "=", "None", ")", ":", "\n", "        ", "self", ".", "app_logger", "=", "logging", ".", "getLogger", "(", "logger_name", ")", "\n", "self", ".", "app_logger", ".", "propagate", "=", "False", "\n", "self", ".", "app_logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "\n", "self", ".", "console", "=", "logging", ".", "StreamHandler", "(", "sys", ".", "stdout", ")", "\n", "if", "debug", ":", "\n", "            ", "self", ".", "console", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "console", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "\n", "", "formatter", "=", "logging", ".", "Formatter", "(", "'%(levelname)-8s %(message)s'", ")", "\n", "self", ".", "console", ".", "setFormatter", "(", "formatter", ")", "\n", "self", ".", "app_logger", ".", "addHandler", "(", "self", ".", "console", ")", "\n", "\n", "if", "log_filename", "is", "not", "None", ":", "\n", "            ", "set_log_file", "(", "self", ".", "app_logger", ",", "log_filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.get_logger": [[23, 25], ["None"], "methods", ["None"], ["", "", "def", "get_logger", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "app_logger", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.set_debug_console": [[26, 28], ["app_logger.AppLogger.console.setLevel"], "methods", ["None"], ["", "def", "set_debug_console", "(", "self", ")", ":", "\n", "        ", "self", ".", "console", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.set_log_file": [[29, 38], ["logging.FileHandler", "logging.FileHandler.setLevel", "app_logger.AppLogger.app_logger.addHandler", "logging.FileHandler.setFormatter", "logging.FileHandler.setFormatter", "logging.Formatter", "logging.Formatter"], "methods", ["None"], ["", "def", "set_log_file", "(", "self", ",", "log_filename", ",", "regression", "=", "False", ")", ":", "\n", "        ", "prim", "=", "logging", ".", "FileHandler", "(", "log_filename", ",", "'a'", ")", "\n", "prim", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "if", "regression", ":", "\n", "            ", "prim", ".", "setFormatter", "(", "logging", ".", "Formatter", "(", "'%(levelname)-8s %(message)s'", ")", ")", "\n", "", "else", ":", "\n", "            ", "prim", ".", "setFormatter", "(", "logging", ".", "Formatter", "(", "fmt", "=", "'%(asctime)s %(levelname)-8s %(message)s'", ",", "\n", "datefmt", "=", "'%m-%d-%y %H:%M'", ")", ")", "\n", "", "self", ".", "app_logger", ".", "addHandler", "(", "prim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.session_manager.Session.__init__": [[48, 107], ["str", "argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "option_manager.OptionManager", "session_manager.Session.options_parser.help_message", "argparse.ArgumentParser.parse_args", "os.path.exists", "os.path.exists", "applogger.set_log_file", "session_manager.Session.options_parser.load_config", "session_manager.Session.master_logger.info", "session_manager.Session.export_config", "datetime.datetime.now", "option_fn", "applogger.set_debug_console", "os.path.exists", "os.makedirs", "Exception", "master_logger.warning", "os.remove", "open"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.help_message", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.set_log_file", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.load_config", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.session_manager.Session.export_config", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.set_debug_console"], ["def", "__init__", "(", "self", ",", "name", ",", "description", ",", "master_logger", ",", "applogger", ",", "option_fn", "=", "None", ")", ":", "\n", "        ", "self", ".", "master_logger", "=", "master_logger", "\n", "\n", "self", ".", "session_location", "=", "None", "\n", "self", ".", "start_time", "=", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ")", "\n", "self", ".", "end_time", "=", "None", "\n", "self", ".", "options_parser", "=", "None", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "description", ",", "\n", "formatter_class", "=", "argparse", ".", "RawDescriptionHelpFormatter", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'session_location'", ",", "type", "=", "str", ",", "help", "=", "\"Directory for session\"", ")", "\n", "parser", ".", "add_argument", "(", "'--config-file'", ",", "'-c'", ",", "help", "=", "'json config file'", ")", "\n", "parser", ".", "add_argument", "(", "'-v'", ",", "'--verbose'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "\n", "help", "=", "'Print runtime information about execution.'", ")", "\n", "parser", ".", "add_argument", "(", "'--regression'", ",", "action", "=", "\"store_true\"", ",", "default", "=", "False", ",", "\n", "help", "=", "argparse", ".", "SUPPRESS", ")", "\n", "\n", "# create json and command line options ", "\n", "self", ".", "options_parser", "=", "option_manager", ".", "OptionManager", "(", "master_logger", ",", "parser", ")", "\n", "\n", "if", "option_fn", "is", "not", "None", ":", "\n", "            ", "option_fn", "(", "self", ".", "options_parser", ")", "\n", "", "parser", ".", "epilog", "=", "self", ".", "options_parser", ".", "help_message", "(", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "self", ".", "regression", "=", "args", ".", "regression", "\n", "self", ".", "verbose", "=", "args", ".", "verbose", "\n", "self", ".", "session_location", "=", "args", ".", "session_location", "\n", "self", ".", "config_file", "=", "args", ".", "config_file", "\n", "\n", "# set verbosity ", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "applogger", ".", "set_debug_console", "(", ")", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "session_location", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "session_location", ")", "\n", "\n", "# check for old files ", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "session_location", "+", "\"/.running\"", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Session \"", "+", "self", ".", "session_location", "+", "\" incomplete\"", ")", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "session_location", "+", "\"/.finished\"", ")", ":", "\n", "            ", "master_logger", ".", "warning", "(", "\"Overwriting previous session: \"", "+", "self", ".", "session_location", ")", "\n", "os", ".", "remove", "(", "self", ".", "session_location", "+", "\"/.finished\"", ")", "\n", "\n", "# set log name", "\n", "", "log_filename", "=", "self", ".", "session_location", "+", "\"/.\"", "+", "name", "+", "\".log\"", "\n", "applogger", ".", "set_log_file", "(", "log_filename", ",", "self", ".", "regression", ")", "\n", "\n", "# load the options from the config file and args    ", "\n", "self", ".", "options", "=", "self", ".", "options_parser", ".", "load_config", "(", "self", ".", "config_file", ",", "args", ")", "\n", "self", ".", "master_logger", ".", "info", "(", "\"Options loaded and verified\"", ")", "\n", "\n", "\n", "self", ".", "export_config", "(", ")", "\n", "\n", "with", "open", "(", "self", ".", "session_location", "+", "\"/.running\"", ",", "'w'", ")", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.session_manager.Session.export_config": [[108, 122], ["getpass.getuser", "os.path.realpath", "session_manager.Session.options_parser.export_json"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.export_json"], ["", "", "def", "export_config", "(", "self", ")", ":", "\n", "        ", "config_data", "=", "{", "}", "\n", "meta_data", "=", "{", "}", "\n", "meta_data", "[", "\"version\"", "]", "=", "1.0", "\n", "meta_data", "[", "\"user\"", "]", "=", "getpass", ".", "getuser", "(", ")", "\n", "meta_data", "[", "\"issued-command\"", "]", "=", "' '", ".", "join", "(", "sys", ".", "argv", ")", "\n", "meta_data", "[", "\"issued-from\"", "]", "=", "os", ".", "path", ".", "realpath", "(", "'.'", ")", "\n", "meta_data", "[", "\"start-time\"", "]", "=", "self", ".", "start_time", "\n", "if", "self", ".", "end_time", ":", "\n", "            ", "meta_data", "[", "\"end-time\"", "]", "=", "self", ".", "end_time", "\n", "", "config_data", "[", "\"meta-data\"", "]", "=", "meta_data", "\n", "\n", "if", "self", ".", "options_parser", "is", "not", "None", ":", "\n", "            ", "self", ".", "options_parser", ".", "export_json", "(", "self", ".", "session_location", "+", "\"/config.json\"", ",", "config_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.session_manager.Session.__del__": [[124, 132], ["os.path.exists", "str", "session_manager.Session.export_config", "os.remove", "open", "datetime.datetime.now"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.session_manager.Session.export_config"], ["", "", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "session_location", "is", "not", "None", ":", "\n", "            ", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "session_location", "+", "\"/.running\"", ")", ":", "\n", "                ", "os", ".", "remove", "(", "self", ".", "session_location", "+", "\"/.running\"", ")", "\n", "", "with", "open", "(", "self", ".", "session_location", "+", "\"/.finished\"", ",", "'w'", ")", ":", "\n", "                ", "pass", "\n", "", "self", ".", "end_time", "=", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ")", "\n", "self", ".", "export_config", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionConfig.__init__": [[5, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "description", ",", "default_val", ",", "required", ",", "dtype", ",", "warning", ",", "verify_fn", ")", ":", "\n", "        ", "self", ".", "description", "=", "description", "\n", "self", ".", "default_val", "=", "default_val", "\n", "self", ".", "required", "=", "required", "\n", "self", ".", "dtype", "=", "dtype", "\n", "self", ".", "warning", "=", "warning", "\n", "self", ".", "verify_fn", "=", "verify_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionNamespace.__init__": [[14, 16], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "", "def", "get_value", "(", "self", ",", "name", ")", ":", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionNamespace.get_value": [[16, 22], ["name.replace.replace.replace", "Exception"], "methods", ["None"], ["", "def", "get_value", "(", "self", ",", "name", ")", ":", "\n", "        ", "name", "=", "name", ".", "replace", "(", "'-'", ",", "'_'", ")", "\n", "if", "name", "in", "self", ".", "__dict__", ":", "\n", "            ", "return", "self", ".", "__dict__", "[", "name", "]", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Option attribute: \"", "+", "name", "+", "\" does not exist\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionNamespace.__contains__": [[23, 26], ["key.replace.replace.replace"], "methods", ["None"], ["", "", "def", "__contains__", "(", "self", ",", "key", ")", ":", "\n", "        ", "key", "=", "key", ".", "replace", "(", "'-'", ",", "'_'", ")", "\n", "return", "key", "in", "self", ".", "__dict__", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.__init__": [[38, 43], ["option_manager.OptionNamespace"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "master_logger", ",", "arg_parser", ")", ":", "\n", "        ", "self", ".", "master_logger", "=", "master_logger", "\n", "self", ".", "options_config", "=", "{", "}", "\n", "self", ".", "options", "=", "OptionNamespace", "(", ")", "\n", "self", ".", "arg_parser", "=", "arg_parser", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.load_config": [[44, 99], ["option_manager.OptionManager.options_config.items", "option_manager.OptionManager.options_config.items", "option_manager.OptionManager.master_logger.warning", "open", "json.load", "open.close", "Exception", "setattr", "setattr", "option.verify_fn", "option_manager.OptionManager.master_logger.warning", "option_manager.OptionManager.master_logger.warning", "name.replace", "name.replace", "option_manager.OptionManager.master_logger.debug", "option_manager.OptionManager.master_logger.debug", "option_manager.OptionManager.master_logger.debug", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "load_config", "(", "self", ",", "file_name", ",", "args", "=", "None", ")", ":", "\n", "        ", "\"\"\"Returns an OptionNamespace\"\"\"", "\n", "\n", "json_data", "=", "None", "\n", "\n", "if", "file_name", "is", "None", ":", "\n", "            ", "self", ".", "master_logger", ".", "warning", "(", "\"Configuration file not supplied, using flags only\"", ")", "\n", "", "else", ":", "\n", "            ", "try", ":", "\n", "                ", "json_file", "=", "open", "(", "file_name", ")", "\n", "json_data", "=", "json", ".", "load", "(", "json_file", ")", "\n", "json_file", ".", "close", "(", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "self", ".", "master_logger", ".", "warning", "(", "\"error in opening \"", "+", "file_name", "+", "\" (%s) , using flags only\"", "%", "str", "(", "e", ")", ")", "\n", "\n", "", "", "args_dict", "=", "None", "\n", "if", "args", ":", "\n", "            ", "args_dict", "=", "args", ".", "__dict__", "\n", "\n", "", "for", "name", ",", "option", "in", "self", ".", "options_config", ".", "items", "(", ")", ":", "\n", "            ", "option_val", "=", "None", "\n", "if", "json_data", "is", "not", "None", "and", "name", "in", "json_data", ":", "\n", "                ", "option_val", "=", "json_data", "[", "name", "]", "\n", "\n", "", "overridden", "=", "False", "\n", "#nametemp = name.replace('-','_') ", "\n", "nametemp", "=", "name", "\n", "if", "args_dict", "and", "nametemp", "in", "args_dict", "and", "args_dict", "[", "nametemp", "]", "is", "not", "None", ":", "\n", "                ", "option_val", "=", "args_dict", "[", "nametemp", "]", "\n", "overridden", "=", "True", "\n", "\n", "", "if", "option", ".", "required", "and", "option_val", "is", "None", ":", "\n", "                ", "raise", "Exception", "(", "name", "+", "\" needs to be specified\"", ")", "\n", "", "elif", "option", ".", "warning", "and", "option_val", "is", "None", ":", "\n", "                ", "self", ".", "master_logger", ".", "warning", "(", "name", "+", "\" was not specified\"", ")", "\n", "", "elif", "option_val", "is", "None", ":", "\n", "                ", "self", ".", "master_logger", ".", "debug", "(", "name", "+", "\" was not specified and set to default \"", "\n", "+", "str", "(", "option", ".", "default_val", ")", ")", "\n", "", "elif", "option_val", "is", "not", "None", "and", "overridden", ":", "\n", "                ", "self", ".", "master_logger", ".", "debug", "(", "name", "+", "\" was overridden by command line to \"", "\n", "+", "str", "(", "option_val", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "master_logger", ".", "debug", "(", "name", "+", "\" was set to \"", "+", "str", "(", "option_val", ")", ")", "\n", "\n", "", "if", "option_val", "is", "not", "None", ":", "\n", "                ", "setattr", "(", "self", ".", "options", ",", "name", ".", "replace", "(", "'-'", ",", "'_'", ")", ",", "option_val", ")", "\n", "", "else", ":", "\n", "                ", "setattr", "(", "self", ".", "options", ",", "name", ".", "replace", "(", "'-'", ",", "'_'", ")", ",", "option", ".", "default_val", ")", "\n", "\n", "", "", "for", "name", ",", "option", "in", "self", ".", "options_config", ".", "items", "(", ")", ":", "\n", "            ", "if", "option", ".", "verify_fn", "is", "not", "None", ":", "\n", "                ", "option", ".", "verify_fn", "(", "self", ",", "self", ".", "options", ",", "self", ".", "master_logger", ")", "\n", "\n", "", "", "return", "self", ".", "options", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.verify_option": [[100, 104], ["option_manager.OptionManager.options_config[].verify_fn", "Exception"], "methods", ["None"], ["", "def", "verify_option", "(", "self", ",", "name", ")", ":", "\n", "        ", "if", "name", "not", "in", "self", ".", "options_config", ":", "\n", "            ", "raise", "Exception", "(", "\"Trying to verify a non-existent option\"", ")", "\n", "", "self", ".", "options_config", "[", "name", "]", ".", "verify_fn", "(", "self", ",", "self", ".", "options", ",", "self", ".", "master_logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.help_message": [[105, 117], ["option_manager.OptionManager.options_config.items", "str", "str"], "methods", ["None"], ["", "def", "help_message", "(", "self", ")", ":", "\n", "        ", "config_format", "=", "\"Command Options\\n\\n\"", "\n", "for", "name", ",", "option", "in", "self", ".", "options_config", ".", "items", "(", ")", ":", "\n", "            ", "if", "option", ".", "dtype", "==", "bool", ":", "\n", "                ", "name", "=", "\"[enable|disable]-\"", "+", "name", "\n", "", "config_format", "+=", "name", "+", "\": \"", "+", "option", ".", "description", "+", "\" \"", "\n", "if", "option", ".", "required", ":", "\n", "                ", "config_format", "+=", "\"(required: \"", "+", "str", "(", "option", ".", "dtype", ")", "+", "\")\"", "\n", "", "else", ":", "\n", "                ", "config_format", "+=", "\"(default: \"", "+", "str", "(", "option", ".", "default_val", ")", "+", "\")\"", "\n", "", "config_format", "+=", "\"\\n\\n\"", "\n", "", "return", "config_format", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.export_json": [[118, 132], ["option_manager.OptionManager.options_config.items", "open", "open.write", "json.dumps", "option_manager.OptionManager.options.get_value"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionNamespace.get_value"], ["", "def", "export_json", "(", "self", ",", "file_name", ",", "json_data", "=", "None", ")", ":", "\n", "        ", "if", "json_data", "is", "None", ":", "\n", "            ", "json_data", "=", "{", "}", "\n", "\n", "", "for", "name", ",", "option", "in", "self", ".", "options_config", ".", "items", "(", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "option_val", "=", "self", ".", "options", ".", "get_value", "(", "name", ")", "\n", "#if option_val is not None:", "\n", "json_data", "[", "name", "]", "=", "option_val", "\n", "", "except", "Exception", ":", "\n", "                ", "return", "\n", "\n", "", "", "fout", "=", "open", "(", "file_name", ",", "'w'", ")", "\n", "fout", ".", "write", "(", "json", ".", "dumps", "(", "json_data", ",", "indent", "=", "4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option": [[133, 167], ["option_manager.OptionConfig", "Exception", "option_manager.OptionManager.arg_parser.add_argument", "option_manager.OptionManager.arg_parser.add_argument", "Exception", "option_manager.OptionManager.arg_parser.add_argument", "option_manager.OptionManager.arg_parser.add_argument", "str", "str"], "methods", ["None"], ["", "def", "create_option", "(", "self", ",", "unique_name", ",", "description", ",", "default_val", "=", "None", ",", "\n", "required", "=", "True", ",", "dtype", "=", "str", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "shortcut", "=", "None", ",", "\n", "warning", "=", "False", ",", "hidden", "=", "False", ")", ":", "\n", "# create options", "\n", "        ", "if", "unique_name", "in", "self", ".", "options", ":", "\n", "            ", "raise", "Exception", "(", "\"Cannot create option with duplicate name: \"", "+", "str", "(", "unique_name", ")", ")", "\n", "\n", "", "option", "=", "OptionConfig", "(", "description", ",", "default_val", ",", "required", ",", "dtype", ",", "warning", ",", "verify_fn", ")", "\n", "\n", "self", ".", "options_config", "[", "unique_name", "]", "=", "option", "\n", "\n", "help_message", "=", "description", "\n", "if", "hidden", "==", "True", ":", "\n", "            ", "help_message", "=", "argparse", ".", "SUPPRESS", "\n", "\n", "", "if", "dtype", "==", "bool", ":", "\n", "            ", "if", "default_val", "is", "None", ":", "\n", "                ", "raise", "Exception", "(", "\"Cannot create a bool option without a default value: \"", "\n", "+", "str", "(", "unique_name", ")", ")", "\n", "", "true_val", "=", "\"store_true\"", "\n", "false_val", "=", "\"store_false\"", "\n", "\n", "#group = self.arg_parser.add_mutuall_exclusive_group() ", "\n", "self", ".", "arg_parser", ".", "add_argument", "(", "\"--\"", "+", "\"enable-\"", "+", "unique_name", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "help_message", ",", "default", "=", "None", ",", "dest", "=", "unique_name", ")", "\n", "self", ".", "arg_parser", ".", "add_argument", "(", "\"--\"", "+", "\"disable-\"", "+", "unique_name", ",", "action", "=", "\"store_false\"", ",", "\n", "help", "=", "help_message", ",", "default", "=", "None", ",", "dest", "=", "unique_name", ")", "\n", "", "else", ":", "\n", "            ", "if", "shortcut", ":", "\n", "                ", "self", ".", "arg_parser", ".", "add_argument", "(", "\"--\"", "+", "unique_name", ",", "\"-\"", "+", "shortcut", ",", "type", "=", "dtype", ",", "\n", "nargs", "=", "num_args", ",", "help", "=", "help_message", ",", "default", "=", "None", ",", "dest", "=", "unique_name", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "arg_parser", ".", "add_argument", "(", "\"--\"", "+", "unique_name", ",", "type", "=", "dtype", ",", "nargs", "=", "num_args", ",", "\n", "help", "=", "help_message", ",", "default", "=", "None", ",", "dest", "=", "unique_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.image_stack_verify": [[12, 21], ["options.image_stack.endswith", "glob.glob", "len", "Exception", "os.path.exists", "Exception"], "function", ["None"], ["def", "image_stack_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "image_stack", "is", "not", "None", ":", "\n", "        ", "if", "options", ".", "image_stack", ".", "endswith", "(", "'.png'", ")", ":", "\n", "            ", "images", "=", "glob", ".", "glob", "(", "options", ".", "image_stack", ")", "\n", "if", "len", "(", "images", ")", "==", "0", ":", "\n", "                ", "raise", "Exception", "(", "\"No images found at \"", "+", "options", ".", "image_stack", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "image_stack", ")", ":", "\n", "                ", "raise", "Exception", "(", "\"Image volume does not exist at \"", "+", "options", ".", "image_stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.gen_pixel_verify": [[22, 28], ["Exception", "Exception"], "function", ["None"], ["", "", "", "", "def", "gen_pixel_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "gen_pixel", ":", "\n", "        ", "if", "options", ".", "ilp_file", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "\"Generating pixel probabilities cannot be done without an ILP\"", ")", "\n", "", "if", "\"extract-ilp-prediction\"", "in", "options", "and", "not", "options", ".", "extract_ilp_prediction", "and", "options", ".", "image_stack", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "\"Image volume needs to be supplied to generate pixel probabilities\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.pixelprob_file_verify": [[29, 33], ["os.path.exists", "Exception"], "function", ["None"], ["", "", "", "def", "pixelprob_file_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "pixelprob_file", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "pixelprob_file", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Pixel prob file \"", "+", "options", ".", "ilp_file", "+", "\" not found\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.ilp_file_verify": [[34, 38], ["os.path.exists", "Exception"], "function", ["None"], ["", "", "", "def", "ilp_file_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "ilp_file", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "ilp_file", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"ILP file \"", "+", "options", ".", "ilp_file", "+", "\" not found\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.temp_dir_verify": [[39, 46], ["util.make_dir"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.util.make_dir"], ["", "", "", "def", "temp_dir_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "\"\"\"\n    If a base temporary directory has been specified, make sure it exists or\n    can be created.\n    \"\"\"", "\n", "if", "options", ".", "temp_dir", "is", "not", "None", ":", "\n", "        ", "util", ".", "make_dir", "(", "options", ".", "temp_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.create_pixel_options": [[48, 78], ["options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option"], ["", "", "def", "create_pixel_options", "(", "options_parser", ",", "standalone", "=", "True", ")", ":", "\n", "    ", "options_parser", ".", "create_option", "(", "\"image-stack\"", ",", "\"image file(s) (h5 or png format)\"", ",", "\n", "required", "=", "standalone", ",", "verify_fn", "=", "image_stack_verify", ",", "\n", "shortcut", "=", "'I'", ",", "warning", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"pixelprob-name\"", ",", "\"Name for pixel classification\"", ",", "\n", "default_val", "=", "\"pixel_boundpred.h5\"", ",", "required", "=", "False", ",", "dtype", "=", "str", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "(", "not", "standalone", ")", ")", "\n", "\n", "\n", "options_parser", ".", "create_option", "(", "\"ilp-file\"", ",", "\"ILP file containing pixel classifier\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "standalone", ",", "dtype", "=", "str", ",", "verify_fn", "=", "ilp_file_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"temp-dir\"", ",", "\"Path to writable temporary directory\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "standalone", ",", "dtype", "=", "str", ",", "verify_fn", "=", "temp_dir_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "if", "not", "standalone", ":", "\n", "        ", "options_parser", ".", "create_option", "(", "\"pixelprob-file\"", ",", "\"Pixel classification file\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "False", ",", "dtype", "=", "str", ",", "verify_fn", "=", "pixelprob_file_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"extract-ilp-prediction\"", ",", "\"Extract prediction from ILP\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"gen-pixel\"", ",", "\"Enable pixel prediction\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "verify_fn", "=", "gen_pixel_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'GP'", ",", "warning", "=", "True", ",", "hidden", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.gen_pixel_probabilities": [[80, 132], ["master_logger.info", "master_logger.info", "sys.exit", "master_logger.info", "os.path.join", "master_logger.info", "os.system", "util.make_temp_dir", "shutil.rmtree"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.util.make_temp_dir"], ["", "", "def", "gen_pixel_probabilities", "(", "session_location", ",", "options", ",", "master_logger", ",", "image_filename", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Generates pixel probabilities using classifier in options.ilp_file.\n\n    Args:\n        session_location:  String.  Where we should export generated pixel probabilities.\n        options:  OptionNamespace.\n        image_filename:  String.  Input image file name.  If given, overrides image-stack\n            key in options.\n\n    Returns:\n        Filename of pixel probabilities\n\n    Side-effects:\n        Generates hdf5 file of pixel probabilities in session_location directory.\n        File will be named 'STACKED_prediction.h5' and probabilities will be in\n        hdf group /volume/predictions\n    \"\"\"", "\n", "master_logger", ".", "info", "(", "\"Generating Pixel Probabilities\"", ")", "\n", "\n", "if", "image_filename", "is", "None", ":", "\n", "        ", "image_filename", "=", "options", ".", "image_stack", "\n", "\n", "", "if", "\"extract-ilp-prediction\"", "in", "options", "and", "options", ".", "extract_ilp_prediction", ":", "\n", "        ", "master_logger", ".", "info", "(", "\"Extract .ilp prediction option has been deprecated\"", ")", "\n", "sys", ".", "exit", "(", "2", ")", "\n", "", "else", ":", "\n", "        ", "master_logger", ".", "info", "(", "\"Running Ilastik in headless mode\"", ")", "\n", "\n", "pixel_prob_filename", "=", "os", ".", "path", ".", "join", "(", "session_location", ",", "'STACKED_prediction.h5'", ")", "\n", "ilastik_command", "=", "(", "\"ilastik_headless\"", "\n", "#\" --headless\"", "\n", "\" --preconvert_stacks\"", "\n", "\" --project={project_file}\"", "\n", "\" --output_axis_order=xyzc\"", "# gala assumes ilastik output is always xyzc", "\n", "\" --output_format=hdf5\"", "\n", "\" --output_filename_format={pixel_prob_filename}\"", "\n", "\" --output_internal_path=/volume/predictions\"", "\n", "\"\"", ".", "format", "(", "project_file", "=", "options", ".", "ilp_file", ",", "\n", "pixel_prob_filename", "=", "pixel_prob_filename", ")", ")", "\n", "if", "options", ".", "temp_dir", "is", "not", "None", ":", "\n", "            ", "temp_dir", "=", "util", ".", "make_temp_dir", "(", "options", ".", "temp_dir", ")", "\n", "ilastik_command", "+=", "\" --sys_tmp_dir={}\"", ".", "format", "(", "options", ".", "temp_dir", ")", "\n", "\n", "# Add the input file as the last arg", "\n", "", "ilastik_command", "+=", "' \"'", "+", "image_filename", "+", "'\"'", "\n", "master_logger", ".", "info", "(", "\"Executing ilastik headless command for pixel classification:\\n%s\"", "%", "ilastik_command", ")", "\n", "os", ".", "system", "(", "ilastik_command", ")", "\n", "if", "options", ".", "temp_dir", "is", "not", "None", ":", "\n", "            ", "shutil", ".", "rmtree", "(", "temp_dir", ")", "\n", "\n", "", "return", "pixel_prob_filename", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.entrypoint": [[134, 147], ["app_logger.AppLogger", "app_logger.AppLogger.get_logger", "session_manager.Session", "pixel.gen_pixel_probabilities", "applogger.get_logger.error", "applogger.get_logger.error", "str", "str", "traceback.format_exc", "traceback.format_exc"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.get_logger", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.gen_pixel_probabilities"], ["", "", "def", "entrypoint", "(", "argv", ")", ":", "\n", "    ", "applogger", "=", "app_logger", ".", "AppLogger", "(", "False", ",", "'gen-pixel'", ")", "\n", "master_logger", "=", "applogger", ".", "get_logger", "(", ")", "\n", "\n", "try", ":", "\n", "        ", "session", "=", "session_manager", ".", "Session", "(", "\"gen-pixel\"", ",", "\"Pixel classification wrapper for Ilastik\"", ",", "\n", "master_logger", ",", "applogger", ",", "create_pixel_options", ")", "\n", "\n", "gen_pixel_probabilities", "(", "session", ".", "session_location", ",", "session", ".", "options", ",", "master_logger", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "", "except", "KeyboardInterrupt", "as", "err", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.__init__": [[18, 62], ["numpy.array", "numpy.array", "libNeuroProofRag.init_stack", "stack_np.Stack.stack.get_feature_mgr", "range", "stack_np.Stack.stack.add_empty_channel", "stack_np.Stack.fmgr.set_overlap_function", "stack_np.Stack.build_partial", "stack_np.Stack.fmgr.set_python_rf_function", "Exception", "stack_np.get_prob_handle", "stack_np.Stack.fmgr.add_hist_feature", "stack_np.Stack.fmgr.add_moment_feature", "stack_np.Stack.fmgr.add_inclusiveness_feature", "Exception"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_partial", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.get_prob_handle"], ["def", "__init__", "(", "self", ",", "watershed", "=", "numpy", ".", "array", "(", "[", "]", ")", ",", "probabilities", "=", "numpy", ".", "array", "(", "[", "]", ")", ",", "\n", "single_channel", "=", "True", ",", "classifier", "=", "None", ",", "synapse_file", "=", "None", ",", "feature_info", "=", "None", ",", "\n", "master_logger", "=", "None", ",", "num_channels", "=", "1", ",", "overlap", "=", "False", ")", ":", "\n", "        ", "\"\"\"Create a graph from a watershed volume and image volume.\n        \n        \"\"\"", "\n", "self", ".", "master_logger", "=", "master_logger", "\n", "self", ".", "single_channel", "=", "single_channel", "\n", "self", ".", "all_syn_locs", "=", "[", "]", "\n", "\n", "self", ".", "stack", "=", "neuroproof", ".", "init_stack", "(", ")", "\n", "\n", "self", ".", "fmgr", "=", "self", ".", "stack", ".", "get_feature_mgr", "(", ")", "\n", "self", ".", "synapse_file", "=", "synapse_file", "\n", "\n", "if", "not", "self", ".", "single_channel", "and", "probabilities", "is", "not", "None", ":", "\n", "            ", "num_channels", "=", "probabilities", ".", "shape", "[", "probabilities", ".", "ndim", "-", "1", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "0", ",", "num_channels", ")", ":", "\n", "            ", "self", ".", "stack", ".", "add_empty_channel", "(", ")", "\n", "\n", "", "if", "overlap", ":", "\n", "            ", "self", ".", "fmgr", ".", "set_overlap_function", "(", ")", "\n", "\n", "", "if", "classifier", "is", "not", "None", ":", "\n", "            ", "if", "not", "overlap", ":", "\n", "                ", "self", ".", "fmgr", ".", "set_python_rf_function", "(", "get_prob_handle", "(", "classifier", ")", ")", "\n", "\n", "", "if", "feature_info", "is", "not", "None", ":", "\n", "                ", "for", "feature", "in", "feature_info", "[", "'feature_list'", "]", ":", "\n", "                    ", "desc", "=", "feature_info", "[", "feature", "]", "\n", "if", "feature", "==", "\"histogram\"", ":", "\n", "                        ", "self", ".", "fmgr", ".", "add_hist_feature", "(", "desc", "[", "\"nbins\"", "]", ",", "desc", "[", "\"compute_percentiles\"", "]", ",", "False", ")", "\n", "", "elif", "feature", "==", "\"moments\"", ":", "\n", "                        ", "self", ".", "fmgr", ".", "add_moment_feature", "(", "desc", "[", "\"nmoments\"", "]", ",", "desc", "[", "\"use_diff\"", "]", ")", "\n", "", "elif", "feature", "==", "\"inclusiveness\"", ":", "\n", "                        ", "self", ".", "fmgr", ".", "add_inclusiveness_feature", "(", "True", ")", "\n", "", "else", ":", "\n", "                        ", "raise", "Exception", "(", "\"Feature \"", "+", "feature", "+", "\" not supported in NeuroProof\"", ")", "\n", "", "", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\"No feature information for Rag\"", ")", "\n", "\n", "", "", "if", "watershed", "is", "not", "None", ":", "\n", "            ", "self", ".", "build_partial", "(", "watershed", ",", "probabilities", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.init_build": [[64, 80], ["morpho.pad", "watershed.astype.astype.astype", "libNeuroProofRag.reinit_stack", "morpho.pad.astype", "morpho.pad", "libNeuroProofRag.add_prediction_channel", "range", "morpho.pad", "libNeuroProofRag.add_prediction_channel"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad"], ["", "", "def", "init_build", "(", "self", ",", "watershed", ",", "probabilities", ")", ":", "\n", "        ", "watershed", "=", "morpho", ".", "pad", "(", "watershed", ",", "0", ")", "\n", "watershed", "=", "watershed", ".", "astype", "(", "numpy", ".", "double", ")", "\n", "\n", "neuroproof", ".", "reinit_stack", "(", "self", ".", "stack", ",", "watershed", ")", "\n", "\n", "probabilities", "=", "probabilities", ".", "astype", "(", "numpy", ".", "double", ")", "\n", "num_channels", "=", "1", "\n", "if", "self", ".", "single_channel", ":", "\n", "            ", "probabilities", "=", "morpho", ".", "pad", "(", "probabilities", ",", "0", ")", "\n", "neuroproof", ".", "add_prediction_channel", "(", "self", ".", "stack", ",", "probabilities", ")", "\n", "", "else", ":", "\n", "            ", "num_channels", "=", "probabilities", ".", "shape", "[", "probabilities", ".", "ndim", "-", "1", "]", "\n", "for", "channel", "in", "range", "(", "0", ",", "num_channels", ")", ":", "\n", "                ", "curr_prob", "=", "morpho", ".", "pad", "(", "probabilities", "[", "...", ",", "channel", "]", ",", "0", ")", "\n", "neuroproof", ".", "add_prediction_channel", "(", "self", ".", "stack", ",", "curr_prob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.init_build2": [[82, 98], ["morpho.pad", "watershed.astype.astype.astype", "libNeuroProofRag.reinit_stack2", "morpho.pad.astype", "morpho.pad", "libNeuroProofRag.add_prediction_channel2", "range", "morpho.pad", "libNeuroProofRag.add_prediction_channel2"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad"], ["", "", "", "def", "init_build2", "(", "self", ",", "watershed", ",", "probabilities", ")", ":", "\n", "        ", "watershed", "=", "morpho", ".", "pad", "(", "watershed", ",", "0", ")", "\n", "watershed", "=", "watershed", ".", "astype", "(", "numpy", ".", "double", ")", "\n", "\n", "neuroproof", ".", "reinit_stack2", "(", "self", ".", "stack", ",", "watershed", ")", "\n", "\n", "probabilities", "=", "probabilities", ".", "astype", "(", "numpy", ".", "double", ")", "\n", "num_channels", "=", "1", "\n", "if", "self", ".", "single_channel", ":", "\n", "            ", "probabilities", "=", "morpho", ".", "pad", "(", "probabilities", ",", "0", ")", "\n", "neuroproof", ".", "add_prediction_channel2", "(", "self", ".", "stack", ",", "probabilities", ")", "\n", "", "else", ":", "\n", "            ", "num_channels", "=", "probabilities", ".", "shape", "[", "probabilities", ".", "ndim", "-", "1", "]", "\n", "for", "channel", "in", "range", "(", "0", ",", "num_channels", ")", ":", "\n", "                ", "curr_prob", "=", "morpho", ".", "pad", "(", "probabilities", "[", "...", ",", "channel", "]", ",", "0", ")", "\n", "neuroproof", ".", "add_prediction_channel2", "(", "self", ".", "stack", ",", "curr_prob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_partial": [[100, 110], ["stack_np.Stack.init_build", "stack_np.Stack.stack.build_rag", "stack_np.Stack.set_exclusions"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.init_build", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_exclusions"], ["", "", "", "def", "build_partial", "(", "self", ",", "watershed", ",", "probabilities", ")", ":", "\n", "        ", "self", ".", "depth", ",", "self", ".", "height", ",", "self", ".", "width", "=", "watershed", ".", "shape", "\n", "self", ".", "all_syn_locs", "=", "None", "\n", "\n", "self", ".", "init_build", "(", "watershed", ",", "probabilities", ")", "\n", "\n", "self", ".", "stack", ".", "build_rag", "(", ")", "\n", "\n", "if", "self", ".", "synapse_file", "is", "not", "None", ":", "\n", "            ", "self", ".", "set_exclusions", "(", "self", ".", "synapse_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.dilate_edges": [[111, 116], ["supervoxels.astype.astype.astype", "libNeuroProofRag.dilate_supervoxels"], "methods", ["None"], ["", "", "def", "dilate_edges", "(", "self", ",", "supervoxels", ")", ":", "\n", "# create temporary stack and write supervoxels like get segmentation", "\n", "        ", "supervoxels", "=", "supervoxels", ".", "astype", "(", "numpy", ".", "double", ")", "\n", "neuroproof", ".", "dilate_supervoxels", "(", "supervoxels", ")", "\n", "return", "supervoxels", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_border": [[117, 131], ["stack_np.Stack.init_build", "stack_np.Stack.init_build2", "stack_np.Stack.stack.build_rag_border", "morpho.pad", "mask1.astype.astype.astype", "morpho.pad", "mask2.astype.astype.astype", "libNeuroProofRag.init_masks"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.init_build", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.init_build2", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad"], ["", "def", "build_border", "(", "self", ",", "supervoxels1", ",", "prediction1", ",", "supervoxels2", ",", "\n", "prediction2", ",", "mask1", ",", "mask2", ",", "reset_edges", ")", ":", "\n", "        ", "self", ".", "init_build", "(", "supervoxels1", ",", "prediction1", ")", "\n", "self", ".", "init_build2", "(", "supervoxels2", ",", "prediction2", ")", "\n", "\n", "if", "mask1", "is", "not", "None", "and", "mask2", "is", "not", "None", ":", "\n", "            ", "mask1", "=", "morpho", ".", "pad", "(", "mask1", ",", "0", ")", "\n", "mask1", "=", "mask1", ".", "astype", "(", "numpy", ".", "double", ")", "\n", "mask2", "=", "morpho", ".", "pad", "(", "mask2", ",", "0", ")", "\n", "mask2", "=", "mask2", ".", "astype", "(", "numpy", ".", "double", ")", "\n", "# use masks to handle 0 cases ", "\n", "neuroproof", ".", "init_masks", "(", "self", ".", "stack", ",", "mask1", ",", "mask2", ")", "\n", "\n", "", "self", ".", "stack", ".", "build_rag_border", "(", "reset_edges", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes": [[132, 134], ["stack_np.Stack.stack.get_num_bodies"], "methods", ["None"], ["", "def", "number_of_nodes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "stack", ".", "get_num_bodies", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.__copy__": [[135, 137], ["Exception"], "methods", ["None"], ["", "def", "__copy__", "(", "self", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"Not implemented yet\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.copy": [[138, 140], ["Exception"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"Not implemented yet\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.agglomerate": [[141, 143], ["stack_np.Stack.stack.agglomerate_rag"], "methods", ["None"], ["", "def", "agglomerate", "(", "self", ",", "threshold", "=", "0.1", ")", ":", "\n", "        ", "self", ".", "stack", ".", "agglomerate_rag", "(", "threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_cutoff": [[144, 146], ["stack_np.Stack.fmgr.set_overlap_cutoff"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_cutoff"], ["", "def", "set_overlap_cutoff", "(", "self", ",", "threshold", ")", ":", "\n", "        ", "self", ".", "fmgr", ".", "set_overlap_cutoff", "(", "threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_border_weight": [[147, 149], ["stack_np.Stack.fmgr.set_border_weight"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_border_weight"], ["", "def", "set_border_weight", "(", "self", ",", "weight", ")", ":", "\n", "        ", "self", ".", "fmgr", ".", "set_border_weight", "(", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_max": [[150, 152], ["stack_np.Stack.fmgr.set_overlap_max"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_max"], ["", "def", "set_overlap_max", "(", "self", ")", ":", "\n", "        ", "self", ".", "fmgr", ".", "set_overlap_max", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_saved_probs": [[153, 155], ["stack_np.Stack.stack.set_saved_probs"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_saved_probs"], ["", "def", "set_saved_probs", "(", "self", ")", ":", "\n", "        ", "self", ".", "stack", ".", "set_saved_probs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_min": [[156, 158], ["stack_np.Stack.fmgr.set_overlap_min"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_min"], ["", "def", "set_overlap_min", "(", "self", ")", ":", "\n", "        ", "self", ".", "fmgr", ".", "set_overlap_min", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.agglomerate_border": [[159, 169], ["stack_np.Stack.stack.disable_nonborder_edges", "stack_np.Stack.stack.agglomerate_rag", "stack_np.Stack.stack.enable_nonborder_edges", "stack_np.Stack.stack.get_transformations", "dict"], "methods", ["None"], ["", "def", "agglomerate_border", "(", "self", ",", "threshold", "=", "0.1", ")", ":", "\n", "        ", "self", ".", "stack", ".", "disable_nonborder_edges", "(", ")", "\n", "\n", "self", ".", "stack", ".", "agglomerate_rag", "(", "threshold", ")", "\n", "\n", "self", ".", "stack", ".", "enable_nonborder_edges", "(", ")", "\n", "\n", "transactions", "=", "self", ".", "stack", ".", "get_transformations", "(", ")", "\n", "\n", "return", "dict", "(", "transactions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.get_segmentation": [[171, 175], ["numpy.zeros", "libNeuroProofRag.write_volume_to_buffer"], "methods", ["None"], ["", "def", "get_segmentation", "(", "self", ")", ":", "\n", "        ", "seg_buffer", "=", "numpy", ".", "zeros", "(", "(", "self", ".", "depth", ",", "self", ".", "height", ",", "self", ".", "width", ")", ",", "numpy", ".", "uint32", ")", "\n", "neuroproof", ".", "write_volume_to_buffer", "(", "self", ".", "stack", ",", "seg_buffer", ")", "\n", "return", "seg_buffer", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.remove_inclusions": [[176, 178], ["stack_np.Stack.stack.remove_inclusions"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.remove_inclusions"], ["", "def", "remove_inclusions", "(", "self", ")", ":", "\n", "        ", "self", ".", "stack", ".", "remove_inclusions", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.write_plaza_json": [[180, 254], ["stack_np.Stack.stack.get_rag", "stack_np.Stack.get_nodes", "stack_np.Stack.stack.determine_edge_locations", "stack_np.Stack.get_edges", "open", "open.write", "body_syn.items", "stack_np.Stack.stack.is_orphan", "stack_np.Stack.master_logger.info", "stack_np.Stack.master_logger.info", "edge.get_node1().get_node_id", "edge.get_node2().get_node_id", "edge.get_node1().get_size", "edge.get_node2().get_size", "edge.is_preserve", "edge.is_false_edge", "edge_list.append", "json.dumps", "stack_np.Stack.stack.get_body_id", "synapse_bodies.append", "orphan_list.append", "stack_np.Stack.stack.get_edge_weight", "node.get_node_id", "edge.get_node1", "edge.get_node2", "edge.get_node1", "edge.get_node2", "stack_np.Stack.stack.get_edge_loc"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write"], ["", "def", "write_plaza_json", "(", "self", ",", "outfile_name", ",", "synapse_file", ",", "offsetz", "=", "0", ",", "disable_locs", "=", "False", ")", ":", "\n", "        ", "json_data", "=", "{", "}", "\n", "# write synapse", "\n", "synapse_bodies", "=", "[", "]", "\n", "if", "self", ".", "all_syn_locs", "is", "not", "None", ":", "\n", "            ", "body_syn", "=", "{", "}", "\n", "for", "loc", "in", "self", ".", "all_syn_locs", ":", "\n", "                ", "x", ",", "y", ",", "z", "=", "loc", "\n", "bodyid", "=", "self", ".", "stack", ".", "get_body_id", "(", "x", ",", "y", ",", "z", ")", "\n", "\n", "if", "bodyid", "==", "0", ":", "\n", "                    ", "continue", "\n", "\n", "", "if", "bodyid", "in", "body_syn", ":", "\n", "                    ", "body_syn", "[", "bodyid", "]", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "body_syn", "[", "bodyid", "]", "=", "1", "\n", "\n", "", "", "for", "key", ",", "val", "in", "body_syn", ".", "items", "(", ")", ":", "\n", "                ", "synapse_bodies", ".", "append", "(", "[", "key", ",", "val", "]", ")", "\n", "", "", "json_data", "[", "\"synapse_bodies\"", "]", "=", "synapse_bodies", "\n", "\n", "rag", "=", "self", ".", "stack", ".", "get_rag", "(", ")", "\n", "\n", "# write orphans", "\n", "orphan_list", "=", "[", "]", "\n", "for", "node", "in", "rag", ".", "get_nodes", "(", ")", ":", "\n", "            ", "status", "=", "self", ".", "stack", ".", "is_orphan", "(", "node", ")", "\n", "if", "status", ":", "\n", "                ", "orphan_list", ".", "append", "(", "node", ".", "get_node_id", "(", ")", ")", "\n", "", "", "json_data", "[", "\"orphan_bodies\"", "]", "=", "orphan_list", "\n", "\n", "if", "self", ".", "master_logger", "is", "not", "None", ":", "\n", "            ", "self", ".", "master_logger", ".", "info", "(", "\"Determining optimal edge locations\"", ")", "\n", "", "self", ".", "stack", ".", "determine_edge_locations", "(", "False", ")", "\n", "if", "self", ".", "master_logger", "is", "not", "None", ":", "\n", "            ", "self", ".", "master_logger", ".", "info", "(", "\"Finished determining optimal edge locations\"", ")", "\n", "\n", "", "edge_list", "=", "[", "]", "\n", "for", "edge", "in", "rag", ".", "get_edges", "(", ")", ":", "\n", "            ", "edge_data", "=", "{", "}", "\n", "edge_data", "[", "\"node1\"", "]", "=", "edge", ".", "get_node1", "(", ")", ".", "get_node_id", "(", ")", "\n", "edge_data", "[", "\"node2\"", "]", "=", "edge", ".", "get_node2", "(", ")", ".", "get_node_id", "(", ")", "\n", "edge_data", "[", "\"size1\"", "]", "=", "edge", ".", "get_node1", "(", ")", ".", "get_size", "(", ")", "\n", "edge_data", "[", "\"size2\"", "]", "=", "edge", ".", "get_node2", "(", ")", ".", "get_size", "(", ")", "\n", "\n", "preserve", "=", "edge", ".", "is_preserve", "(", ")", "\n", "false_edge", "=", "edge", ".", "is_false_edge", "(", ")", "\n", "edge_data", "[", "\"preserve\"", "]", "=", "preserve", "\n", "edge_data", "[", "\"false_edge\"", "]", "=", "false_edge", "\n", "\n", "if", "false_edge", ":", "\n", "                ", "edge_data", "[", "\"weight\"", "]", "=", "1.0", "\n", "edge_data", "[", "\"location\"", "]", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "", "else", ":", "\n", "                ", "edge_data", "[", "\"weight\"", "]", "=", "self", ".", "stack", ".", "get_edge_weight", "(", "edge", ")", "\n", "\n", "if", "disable_locs", ":", "\n", "                    ", "x", "=", "0", "\n", "y", "=", "0", "\n", "z", "=", "0", "\n", "", "else", ":", "\n", "                    ", "x", ",", "y", ",", "z", "=", "self", ".", "stack", ".", "get_edge_loc", "(", "edge", ")", "\n", "\n", "", "edge_data", "[", "\"location\"", "]", "=", "[", "x", ",", "y", ",", "z", "+", "offsetz", "]", "\n", "\n", "\n", "\n", "", "edge_list", ".", "append", "(", "edge_data", ")", "\n", "\n", "", "json_data", "[", "\"edge_list\"", "]", "=", "edge_list", "\n", "\n", "fout", "=", "open", "(", "outfile_name", ",", "'w'", ")", "\n", "fout", ".", "write", "(", "json", ".", "dumps", "(", "json_data", ",", "indent", "=", "4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_exclusions": [[256, 282], ["open", "json.load", "stack_np.Stack.all_syn_locs.append", "curr_locs.append", "range", "stack_np.Stack.all_syn_locs.append", "curr_locs.append", "len", "range", "len", "stack_np.Stack.stack.add_edge_constraint", "stack_np.Stack.master_logger.error"], "methods", ["None"], ["", "def", "set_exclusions", "(", "self", ",", "synapse_volume", ")", ":", "\n", "        ", "syn_file", "=", "open", "(", "synapse_volume", ",", "'r'", ")", "\n", "json_vals", "=", "json", ".", "load", "(", "syn_file", ")", "\n", "\n", "self", ".", "all_syn_locs", "=", "[", "]", "\n", "\n", "for", "item", "in", "json_vals", "[", "\"data\"", "]", ":", "\n", "            ", "curr_locs", "=", "[", "]", "\n", "loc_arr", "=", "(", "item", "[", "\"T-bar\"", "]", ")", "[", "\"location\"", "]", "\n", "loc", "=", "(", "loc_arr", "[", "0", "]", ",", "loc_arr", "[", "1", "]", ",", "loc_arr", "[", "2", "]", ")", "\n", "\n", "self", ".", "all_syn_locs", ".", "append", "(", "loc", ")", "\n", "curr_locs", ".", "append", "(", "loc", ")", "\n", "\n", "for", "psd", "in", "item", "[", "\"partners\"", "]", ":", "\n", "                ", "loc_arr", "=", "psd", "[", "\"location\"", "]", "\n", "loc", "=", "(", "loc_arr", "[", "0", "]", ",", "loc_arr", "[", "1", "]", ",", "loc_arr", "[", "2", "]", ")", "\n", "\n", "self", ".", "all_syn_locs", ".", "append", "(", "loc", ")", "\n", "curr_locs", ".", "append", "(", "loc", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "0", ",", "len", "(", "curr_locs", ")", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "curr_locs", ")", ")", ":", "\n", "                    ", "status", "=", "self", ".", "stack", ".", "add_edge_constraint", "(", "curr_locs", "[", "i", "]", ",", "curr_locs", "[", "j", "]", ")", "\n", "if", "not", "status", "and", "self", ".", "master_logger", "is", "not", "None", ":", "\n", "                        ", "self", ".", "master_logger", ".", "error", "(", "\"Tbar/PSD lie in same superpixel\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.learn_agglomerate": [[284, 287], ["Exception"], "methods", ["None"], ["", "", "", "", "", "def", "learn_agglomerate", "(", "self", ",", "gts", ",", "feature_map", ",", "min_num_samples", "=", "1", ",", "\n", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"Learn agglomerate not implemented in NeuroProof yet\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.get_prob_handle": [[9, 14], ["float", "classifier.predict_proba", "numpy.array"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.predict_proba"], ["def", "get_prob_handle", "(", "classifier", ")", ":", "\n", "    ", "def", "get_prob", "(", "features", ")", ":", "\n", "        ", "prediction", "=", "classifier", ".", "predict_proba", "(", "array", "(", "features", ")", ")", "[", "0", ",", "1", "]", "\n", "return", "float", "(", "prediction", ")", "\n", "", "return", "get_prob", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.DefaultRandomForest.__init__": [[189, 195], ["sklearn.ensemble.RandomForestClassifier.__init__"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_estimators", "=", "100", ",", "criterion", "=", "'entropy'", ",", "max_depth", "=", "20", ",", "\n", "bootstrap", "=", "False", ",", "random_state", "=", "None", ",", "n_jobs", "=", "-", "1", ")", ":", "\n", "        ", "super", "(", "DefaultRandomForest", ",", "self", ")", ".", "__init__", "(", "\n", "n_estimators", "=", "n_estimators", ",", "criterion", "=", "criterion", ",", "\n", "max_depth", "=", "max_depth", ",", "bootstrap", "=", "bootstrap", ",", "\n", "random_state", "=", "random_state", ",", "n_jobs", "=", "n_jobs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.__init__": [[198, 204], ["BaseVigraRandomForest"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "ntrees", "=", "255", ",", "use_feature_importance", "=", "False", ",", "\n", "sample_classes_individually", "=", "False", ")", ":", "\n", "        ", "self", ".", "rf", "=", "BaseVigraRandomForest", "(", "treeCount", "=", "ntrees", ",", "\n", "sample_classes_individually", "=", "sample_classes_individually", ")", "\n", "self", ".", "use_feature_importance", "=", "use_feature_importance", "\n", "self", ".", "sample_classes_individually", "=", "sample_classes_individually", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit": [[205, 214], ["classify.VigraRandomForest.check_features_vector", "classify.VigraRandomForest.check_labels_vector", "classify.VigraRandomForest.rf.learnRFWithFeatureSelection", "classify.VigraRandomForest.rf.learnRF"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.check_features_vector", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.check_labels_vector"], ["", "def", "fit", "(", "self", ",", "features", ",", "labels", ")", ":", "\n", "        ", "features", "=", "self", ".", "check_features_vector", "(", "features", ")", "\n", "labels", "=", "self", ".", "check_labels_vector", "(", "labels", ")", "\n", "if", "self", ".", "use_feature_importance", ":", "\n", "            ", "self", ".", "oob", ",", "self", ".", "feature_importance", "=", "self", ".", "rf", ".", "learnRFWithFeatureSelection", "(", "features", ",", "labels", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "oob", "=", "self", ".", "rf", ".", "learnRF", "(", "features", ",", "labels", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.predict_proba": [[215, 218], ["classify.VigraRandomForest.check_features_vector", "classify.VigraRandomForest.rf.predictProbabilities"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.check_features_vector"], ["", "def", "predict_proba", "(", "self", ",", "features", ")", ":", "\n", "        ", "features", "=", "self", ".", "check_features_vector", "(", "features", ")", "\n", "return", "self", ".", "rf", ".", "predictProbabilities", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.predict": [[219, 222], ["classify.VigraRandomForest.check_features_vector", "classify.VigraRandomForest.rf.predictLabels"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.check_features_vector"], ["", "def", "predict", "(", "self", ",", "features", ")", ":", "\n", "        ", "features", "=", "self", ".", "check_features_vector", "(", "features", ")", "\n", "return", "self", ".", "rf", ".", "predictLabels", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.check_features_vector": [[223, 229], ["features.astype.astype.astype"], "methods", ["None"], ["", "def", "check_features_vector", "(", "self", ",", "features", ")", ":", "\n", "        ", "if", "features", ".", "dtype", "!=", "np", ".", "float32", ":", "\n", "            ", "features", "=", "features", ".", "astype", "(", "np", ".", "float32", ")", "\n", "", "if", "features", ".", "ndim", "==", "1", ":", "\n", "            ", "features", "=", "features", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "", "return", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.check_labels_vector": [[230, 240], ["labels.astype.astype.reshape", "labels.astype.astype.astype", "len", "labels.astype.astype.min", "numpy.unique"], "methods", ["None"], ["", "def", "check_labels_vector", "(", "self", ",", "labels", ")", ":", "\n", "        ", "if", "labels", ".", "dtype", "!=", "np", ".", "uint32", ":", "\n", "            ", "if", "len", "(", "np", ".", "unique", "(", "labels", "[", "labels", "<", "0", "]", ")", ")", "==", "1", "and", "not", "(", "labels", "==", "0", ")", ".", "any", "(", ")", ":", "\n", "                ", "labels", "[", "labels", "<", "0", "]", "=", "0", "\n", "", "else", ":", "\n", "                ", "labels", "=", "labels", "+", "labels", ".", "min", "(", ")", "\n", "", "labels", "=", "labels", ".", "astype", "(", "np", ".", "uint32", ")", "\n", "", "labels", "=", "labels", ".", "reshape", "(", "(", "labels", ".", "size", ",", "1", ")", ")", "\n", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.save_to_disk": [[241, 249], ["classify.VigraRandomForest.rf.writeHDF5", "h5py.File", "hasattr", "getattr"], "methods", ["None"], ["", "def", "save_to_disk", "(", "self", ",", "fn", ",", "rfgroupname", "=", "'rf'", ")", ":", "\n", "        ", "self", ".", "rf", ".", "writeHDF5", "(", "fn", ",", "rfgroupname", ")", "\n", "attr_list", "=", "[", "'oob'", ",", "'feature_importance'", ",", "'use_feature_importance'", ",", "\n", "'feature_description'", "]", "\n", "f", "=", "h5py", ".", "File", "(", "fn", ")", "\n", "for", "attr", "in", "attr_list", ":", "\n", "            ", "if", "hasattr", "(", "self", ",", "attr", ")", ":", "\n", "                ", "f", "[", "rfgroupname", "]", ".", "attrs", "[", "attr", "]", "=", "getattr", "(", "self", ",", "attr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.load_from_disk": [[250, 256], ["BaseVigraRandomForest", "h5py.File", "str", "print", "setattr"], "methods", ["None"], ["", "", "", "def", "load_from_disk", "(", "self", ",", "fn", ",", "rfgroupname", "=", "'rf'", ")", ":", "\n", "        ", "self", ".", "rf", "=", "BaseVigraRandomForest", "(", "str", "(", "fn", ")", ",", "rfgroupname", ")", "\n", "f", "=", "h5py", ".", "File", "(", "fn", ",", "'r'", ")", "\n", "for", "attr", "in", "f", "[", "rfgroupname", "]", ".", "attrs", ":", "\n", "            ", "print", "(", "\"f[%s] = %s\"", "%", "(", "attr", ",", "f", "[", "rfgroupname", "]", ".", "attrs", "[", "attr", "]", ")", ")", "\n", "setattr", "(", "self", ",", "attr", ",", "f", "[", "rfgroupname", "]", ".", "attrs", "[", "attr", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.default_classifier_extension": [[27, 57], ["isinstance"], "function", ["None"], ["", "def", "default_classifier_extension", "(", "cl", ",", "use_joblib", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Return the default classifier file extension for the given classifier.\n\n    Parameters\n    ----------\n    cl : sklearn estimator or VigraRandomForest object\n        A classifier to be saved.\n    use_joblib : bool, optional\n        Whether or not joblib will be used to save the classifier.\n\n    Returns\n    -------\n    ext : string\n        File extension\n\n    Examples\n    --------\n    >>> cl = RandomForestClassifier()\n    >>> default_classifier_extension(cl)\n    '.classifier.joblib'\n    >>> default_classifier_extension(cl, False)\n    '.classifier'\n    \"\"\"", "\n", "if", "isinstance", "(", "cl", ",", "VigraRandomForest", ")", ":", "\n", "        ", "return", "\".classifier.h5\"", "\n", "", "elif", "use_joblib", ":", "\n", "        ", "return", "\".classifier.joblib\"", "\n", "", "else", ":", "\n", "        ", "return", "\".classifier\"", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.load_classifier": [[59, 101], ["IOError", "os.path.exists", "IOError", "joblib.load", "classify.VigraRandomForest", "open", "pickle.load", "pck.load.load_from_disk", "logging.error", "logging.error"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.load_from_disk"], ["", "", "def", "load_classifier", "(", "fn", ")", ":", "\n", "    ", "\"\"\"Load a classifier previously saved to disk, given a filename.\n    \n    Supported classifier types are:\n    - scikit-learn classifiers saved using either pickle or joblib persistence\n    - vigra random forest classifiers saved in HDF5 format\n\n    Parameters\n    ----------\n    fn : string\n        Filename in which the classifier is stored.\n\n    Returns\n    -------\n    cl : classifier object\n        cl is one of the supported classifier types; these support at least\n        the standard scikit-learn interface of `fit()` and `predict_proba()`\n    \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "fn", ")", ":", "\n", "        ", "raise", "IOError", "(", "\"No such file or directory: '%s'\"", "%", "fn", ")", "\n", "", "try", ":", "\n", "        ", "with", "open", "(", "fn", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "cl", "=", "pck", ".", "load", "(", "f", ")", "\n", "", "return", "cl", "\n", "", "except", "(", "pck", ".", "UnpicklingError", ",", "UnicodeDecodeError", ")", ":", "\n", "        ", "pass", "\n", "", "try", ":", "\n", "        ", "cl", "=", "joblib", ".", "load", "(", "fn", ")", "\n", "return", "cl", "\n", "", "except", "KeyError", ":", "\n", "        ", "pass", "\n", "", "if", "vigra_available", ":", "\n", "        ", "cl", "=", "VigraRandomForest", "(", ")", "\n", "try", ":", "\n", "            ", "cl", ".", "load_from_disk", "(", "fn", ")", "\n", "return", "cl", "\n", "", "except", "IOError", "as", "e", ":", "\n", "            ", "logging", ".", "error", "(", "e", ")", "\n", "", "except", "RuntimeError", "as", "e", ":", "\n", "            ", "logging", ".", "error", "(", "e", ")", "\n", "", "", "raise", "IOError", "(", "\"File '%s' does not appear to be a valid classifier file\"", "\n", "%", "fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.save_classifier": [[102, 134], ["isinstance", "cl.save_to_disk", "joblib.dump", "open", "pickle.dump", "kwargs.get"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.save_to_disk"], ["", "def", "save_classifier", "(", "cl", ",", "fn", ",", "use_joblib", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Save a classifier to disk.\n\n    Parameters\n    ----------\n    cl : classifier object\n        Pickleable object or a classify.VigraRandomForest object.\n    fn : string\n        Writeable path/filename.\n    use_joblib : bool, optional\n        Whether to prefer joblib persistence to pickle.\n    kwargs : keyword arguments\n        Keyword arguments to be passed on to either `pck.dump` or \n        `joblib.dump`.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    For joblib persistence, `compress=3` is the default.\n    \"\"\"", "\n", "if", "isinstance", "(", "cl", ",", "VigraRandomForest", ")", ":", "\n", "        ", "cl", ".", "save_to_disk", "(", "fn", ")", "\n", "", "elif", "use_joblib", ":", "\n", "        ", "if", "'compress'", "not", "in", "kwargs", ":", "\n", "            ", "kwargs", "[", "'compress'", "]", "=", "3", "\n", "", "joblib", ".", "dump", "(", "cl", ",", "fn", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "with", "open", "(", "fn", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "pck", ".", "dump", "(", "cl", ",", "f", ",", "protocol", "=", "kwargs", ".", "get", "(", "'protocol'", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.get_classifier": [[136, 186], ["name.lower.lower", "name.lower.startswith", "name.lower.find", "classify.VigraRandomForest", "name.lower.find", "name.lower.find", "classify.DefaultRandomForest", "GaussianNB", "LogisticRegression", "NotImplementedError"], "function", ["None"], ["", "", "", "def", "get_classifier", "(", "name", "=", "'random forest'", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return a classifier given a name.\n\n    Parameters\n    ----------\n    name : string\n        The name of the classifier, e.g. 'random forest' or 'naive bayes'.\n    *args, **kwargs :\n        Additional arguments to pass to the constructor of the classifier.\n\n    Returns\n    -------\n    cl : classifier\n        A classifier object implementing the scikit-learn interface.\n\n    Raises\n    ------\n    NotImplementedError\n        If the classifier name is not recognized.\n\n    Examples\n    --------\n    >>> cl = get_classifier('random forest', n_estimators=47)\n    >>> isinstance(cl, RandomForestClassifier)\n    True\n    >>> cl.n_estimators\n    47\n    >>> from numpy.testing import assert_raises\n    >>> assert_raises(NotImplementedError, get_classifier, 'perfect class')\n    \"\"\"", "\n", "name", "=", "name", ".", "lower", "(", ")", "\n", "is_random_forest", "=", "name", ".", "find", "(", "'random'", ")", ">", "-", "1", "and", "name", ".", "find", "(", "'forest'", ")", ">", "-", "1", "\n", "is_naive_bayes", "=", "name", ".", "find", "(", "'naive'", ")", ">", "-", "1", "\n", "is_logistic", "=", "name", ".", "startswith", "(", "'logis'", ")", "\n", "if", "vigra_available", "and", "is_random_forest", ":", "\n", "        ", "if", "'random_state'", "in", "kwargs", ":", "\n", "            ", "del", "kwargs", "[", "'random_state'", "]", "\n", "", "return", "VigraRandomForest", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "is_random_forest", ":", "\n", "        ", "return", "DefaultRandomForest", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "is_naive_bayes", ":", "\n", "        ", "from", "sklearn", ".", "naive_bayes", "import", "GaussianNB", "\n", "if", "'random_state'", "in", "kwargs", ":", "\n", "            ", "del", "kwargs", "[", "'random_state'", "]", "\n", "", "return", "GaussianNB", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "is_logistic", ":", "\n", "        ", "from", "sklearn", ".", "linear_model", "import", "LogisticRegression", "\n", "return", "LogisticRegression", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Classifier \"%s\" is either not installed '", "\n", "'or not implemented in Gala.'", ")", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.read_rf_info": [[258, 261], ["h5py.File", "list", "map"], "function", ["None"], ["", "", "", "def", "read_rf_info", "(", "fn", ")", ":", "\n", "    ", "f", "=", "h5py", ".", "File", "(", "fn", ")", "\n", "return", "list", "(", "map", "(", "np", ".", "array", ",", "[", "f", "[", "'oob'", "]", ",", "f", "[", "'feature_importance'", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.concatenate_data_elements": [[262, 269], ["list", "map", "zip"], "function", ["None"], ["", "def", "concatenate_data_elements", "(", "alldata", ")", ":", "\n", "    ", "\"\"\"Return one big learning set from a list of learning sets.\n    \n    A learning set is a list/tuple of length 4 containing features, labels,\n    weights, and node merge history.\n    \"\"\"", "\n", "return", "list", "(", "map", "(", "np", ".", "concatenate", ",", "zip", "(", "*", "alldata", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.unique_learning_data_elements": [[270, 282], ["classify.concatenate_data_elements", "f.view", "numpy.unique", "numpy.bincount", "logging.debug", "list", "type", "map", "len", "np.bincount.min", "numpy.mean", "numpy.median", "np.bincount.max"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.concatenate_data_elements"], ["", "def", "unique_learning_data_elements", "(", "alldata", ")", ":", "\n", "    ", "if", "type", "(", "alldata", "[", "0", "]", ")", "not", "in", "(", "list", ",", "tuple", ")", ":", "alldata", "=", "[", "alldata", "]", "\n", "f", ",", "l", ",", "w", ",", "h", "=", "concatenate_data_elements", "(", "alldata", ")", "\n", "af", "=", "f", ".", "view", "(", "'|S%d'", "%", "(", "f", ".", "itemsize", "*", "(", "len", "(", "f", "[", "0", "]", ")", ")", ")", ")", "\n", "_", ",", "uids", ",", "iids", "=", "np", ".", "unique", "(", "af", ",", "return_index", "=", "True", ",", "return_inverse", "=", "True", ")", "\n", "bcs", "=", "np", ".", "bincount", "(", "iids", ")", "\n", "logging", ".", "debug", "(", "\n", "'repeat feature vec min %d, mean %.2f, median %.2f, max %d.'", "%", "\n", "(", "bcs", ".", "min", "(", ")", ",", "np", ".", "mean", "(", "bcs", ")", ",", "np", ".", "median", "(", "bcs", ")", ",", "bcs", ".", "max", "(", ")", ")", "\n", ")", "\n", "def", "get_uniques", "(", "ar", ")", ":", "return", "ar", "[", "uids", "]", "\n", "return", "list", "(", "map", "(", "get_uniques", ",", "[", "f", ",", "l", ",", "w", ",", "h", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.sample_training_data": [[283, 308], ["len", "random.sample", "list", "range"], "function", ["None"], ["", "def", "sample_training_data", "(", "features", ",", "labels", ",", "num_samples", "=", "None", ")", ":", "\n", "    ", "\"\"\"Get a random sample from a classification training dataset.\n\n    Parameters\n    ----------\n    features: np.ndarray [M x N]\n        The M (number of samples) by N (number of features) feature matrix.\n    labels: np.ndarray [M] or [M x 1]\n        The training label for each feature vector.\n    num_samples: int, optional\n        The size of the training sample to draw. Return full dataset if `None`\n        or if num_samples >= M.\n\n    Returns\n    -------\n    feat: np.ndarray [num_samples x N]\n        The sampled feature vectors.\n    lab: np.ndarray [num_samples] or [num_samples x 1]\n        The sampled training labels\n    \"\"\"", "\n", "m", "=", "len", "(", "features", ")", "\n", "if", "num_samples", "is", "None", "or", "num_samples", ">=", "m", ":", "\n", "        ", "return", "features", ",", "labels", "\n", "", "idxs", "=", "random", ".", "sample", "(", "list", "(", "range", "(", "m", ")", ")", ",", "num_samples", ")", "\n", "return", "features", "[", "idxs", "]", ",", "labels", "[", "idxs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.save_training_data_to_disk": [[309, 317], ["h5py.File", "zip", "h5py.File.close"], "function", ["None"], ["", "def", "save_training_data_to_disk", "(", "data", ",", "fn", ",", "names", "=", "None", ",", "info", "=", "'N/A'", ")", ":", "\n", "    ", "if", "names", "is", "None", ":", "\n", "        ", "names", "=", "[", "'features'", ",", "'labels'", ",", "'weights'", ",", "'history'", "]", "\n", "", "fout", "=", "h5py", ".", "File", "(", "fn", ",", "'w'", ")", "\n", "for", "data_elem", ",", "name", "in", "zip", "(", "data", ",", "names", ")", ":", "\n", "        ", "fout", "[", "name", "]", "=", "data_elem", "\n", "", "fout", ".", "attrs", "[", "'info'", "]", "=", "info", "\n", "fout", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.load_training_data_from_disk": [[318, 326], ["h5py.File", "data.append", "numpy.array"], "function", ["None"], ["", "def", "load_training_data_from_disk", "(", "fn", ",", "names", "=", "None", ",", "info", "=", "'N/A'", ")", ":", "\n", "    ", "if", "names", "is", "None", ":", "\n", "        ", "names", "=", "[", "'features'", ",", "'labels'", ",", "'weights'", ",", "'history'", "]", "\n", "", "fin", "=", "h5py", ".", "File", "(", "fn", ",", "'r'", ")", "\n", "data", "=", "[", "]", "\n", "for", "name", "in", "names", ":", "\n", "        ", "data", ".", "append", "(", "np", ".", "array", "(", "fin", "[", "name", "]", ")", ")", "\n", "", "return", "data", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR.__init__": [[390, 405], ["scipy.csr_matrix", "scipy.csr_matrix", "numpy.empty", "numpy.empty", "numpy.empty", "scipy.csr_matrix.__init__"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__"], ["def", "__init__", "(", "self", ",", "arg1", ",", "shape", "=", "None", ",", "dtype", "=", "None", ",", "copy", "=", "False", ",", "\n", "max_num_rows", "=", "None", ",", "max_nonzero", "=", "None", ",", "\n", "expansion_factor", "=", "2", ")", ":", "\n", "        ", "other", "=", "sparse", ".", "csr_matrix", "(", "arg1", ",", "shape", "=", "shape", ",", "dtype", "=", "dtype", ",", "copy", "=", "copy", ")", "\n", "if", "max_nonzero", "is", "None", ":", "\n", "            ", "max_nonzero", "=", "other", ".", "nnz", "*", "expansion_factor", "\n", "", "if", "max_num_rows", "is", "None", ":", "\n", "            ", "max_num_rows", "=", "other", ".", "shape", "[", "0", "]", "*", "expansion_factor", "\n", "", "self", ".", "curr_nonzero", "=", "other", ".", "nnz", "\n", "self", ".", "curr_indptr", "=", "other", ".", "shape", "[", "0", "]", "+", "1", "\n", "self", ".", "_data", "=", "np", ".", "empty", "(", "max_nonzero", ",", "dtype", "=", "other", ".", "dtype", ")", "\n", "self", ".", "_indices", "=", "np", ".", "empty", "(", "max_nonzero", ",", "dtype", "=", "other", ".", "indices", ".", "dtype", ")", "\n", "self", ".", "_indptr", "=", "np", ".", "empty", "(", "max_num_rows", "+", "1", ",", "dtype", "=", "other", ".", "indptr", ".", "dtype", ")", "\n", "super", "(", ")", ".", "__init__", "(", "(", "other", ".", "data", ",", "other", ".", "indices", ",", "other", ".", "indptr", ")", ",", "\n", "shape", "=", "other", ".", "shape", ",", "dtype", "=", "other", ".", "dtype", ",", "copy", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR.data": [[412, 430], ["numpy.isscalar", "len", "len", "evaluate.csrRowExpandableCSR._double_data_and_indices"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._double_data_and_indices"], ["", "@", "data", ".", "setter", "\n", "def", "data", "(", "self", ",", "value", ")", ":", "\n", "        ", "\"\"\"Setter for the data property.\n\n        We have to special-case for a few kinds of values.\n\n        When creating a new instance, the csr_matrix class removes some\n        zeros from the array and ends up setting data to a smaller array.\n        In that case, we need to make sure that we reset `self.curr_nonzero`\n        and copy the relevant part of the array.\n        \"\"\"", "\n", "if", "np", ".", "isscalar", "(", "value", ")", "or", "len", "(", "value", ")", "==", "self", ".", "curr_nonzero", ":", "\n", "            ", "self", ".", "_data", "[", ":", "self", ".", "curr_nonzero", "]", "=", "value", "\n", "", "else", ":", "# `value` is array-like of different length", "\n", "            ", "self", ".", "curr_nonzero", "=", "len", "(", "value", ")", "\n", "while", "self", ".", "_data", ".", "size", "<", "self", ".", "curr_nonzero", ":", "\n", "                ", "self", ".", "_double_data_and_indices", "(", ")", "\n", "", "self", ".", "_data", "[", ":", "self", ".", "curr_nonzero", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR.indices": [[435, 444], ["numpy.isscalar", "len", "len", "evaluate.csrRowExpandableCSR._double_data_and_indices"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._double_data_and_indices"], ["", "@", "indices", ".", "setter", "\n", "def", "indices", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "np", ".", "isscalar", "(", "value", ")", "or", "len", "(", "value", ")", "==", "self", ".", "curr_nonzero", ":", "\n", "            ", "self", ".", "_indices", "[", ":", "self", ".", "curr_nonzero", "]", "=", "value", "\n", "", "else", ":", "# `value` is array-like of different length", "\n", "            ", "self", ".", "curr_nonzero", "=", "len", "(", "value", ")", "\n", "while", "self", ".", "_indices", ".", "size", "<", "self", ".", "curr_nonzero", ":", "\n", "                ", "self", ".", "_double_data_and_indices", "(", ")", "\n", "", "self", ".", "_indices", "[", ":", "self", ".", "curr_nonzero", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR.indptr": [[449, 458], ["numpy.isscalar", "len", "len", "evaluate.csrRowExpandableCSR._double_data_and_indices"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._double_data_and_indices"], ["", "@", "indptr", ".", "setter", "\n", "def", "indptr", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "np", ".", "isscalar", "(", "value", ")", "or", "len", "(", "value", ")", "==", "self", ".", "curr_indptr", ":", "\n", "            ", "self", ".", "_indptr", "[", ":", "self", ".", "curr_indptr", "]", "=", "value", "\n", "", "else", ":", "# `value` is array-like of different length", "\n", "            ", "self", ".", "curr_indptr", "=", "len", "(", "value", ")", "\n", "while", "self", ".", "_indptr", ".", "size", "<", "self", ".", "curr_indptr", ":", "\n", "                ", "self", ".", "_double_data_and_indices", "(", ")", "\n", "", "self", ".", "_indptr", "[", ":", "self", ".", "curr_indptr", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR.__setitem__": [[459, 469], ["numpy.isscalar", "super().__setitem__", "evaluate.csrRowExpandableCSR._append_row_at", "numpy.isscalar", "evaluate.csrRowExpandableCSR._zero_row"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR.__setitem__", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._append_row_at", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._zero_row"], ["", "", "def", "__setitem__", "(", "self", ",", "index", ",", "value", ")", ":", "\n", "        ", "if", "np", ".", "isscalar", "(", "index", ")", ":", "\n", "            ", "if", "index", ">=", "self", ".", "shape", "[", "0", "]", ":", "# appending a row", "\n", "                ", "self", ".", "_append_row_at", "(", "index", ",", "value", ")", "\n", "", "else", ":", "\n", "                ", "if", "np", ".", "isscalar", "(", "value", ")", ":", "\n", "                    ", "if", "value", "==", "0", ":", "# zeroing out a row", "\n", "                        ", "self", ".", "_zero_row", "(", "index", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "super", "(", ")", ".", "__setitem__", "(", "index", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._append_row_at": [[470, 495], ["numpy.isscalar", "numpy.full", "scipy.isspmatrix_csr", "scipy.isspmatrix_csr", "scipy.csr_matrix", "scipy.csr_matrix", "evaluate.csrRowExpandableCSR._double_indptr", "evaluate.csrRowExpandableCSR._double_data_and_indices", "int"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._double_indptr", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._double_data_and_indices"], ["", "", "def", "_append_row_at", "(", "self", ",", "index", ",", "value", ")", ":", "\n", "# first: normalize the input value. We want a sparse CSR matrix as", "\n", "# input, to make data copying logic much simpler.", "\n", "        ", "if", "np", ".", "isscalar", "(", "value", ")", ":", "\n", "            ", "value", "=", "np", ".", "full", "(", "self", ".", "shape", "[", "1", "]", ",", "value", ")", "# make a full row if scalar", "\n", "", "if", "not", "sparse", ".", "isspmatrix_csr", "(", "value", ")", ":", "\n", "            ", "value", "=", "sparse", ".", "csr_matrix", "(", "value", ")", "\n", "\n", "# Make sure we have sufficient room for the new row.", "\n", "", "if", "index", "+", "2", ">", "self", ".", "_indptr", ".", "size", ":", "\n", "            ", "self", ".", "_double_indptr", "(", ")", "\n", "", "num_values", "=", "value", ".", "nnz", "\n", "if", "self", ".", "curr_nonzero", "+", "num_values", ">", "self", ".", "_data", ".", "size", ":", "\n", "            ", "self", ".", "_double_data_and_indices", "(", ")", "\n", "", "i", ",", "j", "=", "self", ".", "indptr", "[", "-", "1", "]", ",", "self", ".", "indptr", "[", "-", "1", "]", "+", "num_values", "\n", "self", ".", "_indptr", "[", "self", ".", "curr_indptr", ":", "index", "+", "1", "]", "=", "i", "\n", "self", ".", "_indptr", "[", "index", "+", "1", "]", "=", "j", "\n", "self", ".", "curr_indptr", "=", "index", "+", "2", "\n", "self", ".", "_indices", "[", "i", ":", "j", "]", "=", "value", ".", "indices", "[", ":", "]", "\n", "self", ".", "_data", "[", "i", ":", "j", "]", "=", "value", ".", "data", "[", ":", "]", "\n", "self", ".", "curr_nonzero", "+=", "num_values", "\n", "# It turns out that the `shape` attribute is a property in SciPy", "\n", "# sparse matrices, and can't be set directly. So, we bypass it and", "\n", "# set the corresponding tuple directly, interfaces be damned.", "\n", "self", ".", "_shape", "=", "(", "int", "(", "index", "+", "1", ")", ",", "self", ".", "shape", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._zero_row": [[496, 500], ["None"], "methods", ["None"], ["", "def", "_zero_row", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Set all elements of row `index` to 0.\"\"\"", "\n", "i", ",", "j", "=", "self", ".", "indptr", "[", "index", ":", "index", "+", "2", "]", "\n", "self", ".", "data", "[", "i", ":", "j", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._double_indptr": [[501, 509], ["numpy.empty"], "methods", ["None"], ["", "def", "_double_indptr", "(", "self", ")", ":", "\n", "        ", "\"\"\"Double the size of the array backing `indptr`.\n\n        Doubling on demand gives amortized constant time append.\n        \"\"\"", "\n", "old_indptr", "=", "self", ".", "_indptr", "\n", "self", ".", "_indptr", "=", "np", ".", "empty", "(", "2", "*", "old_indptr", ".", "size", ",", "old_indptr", ".", "dtype", ")", "\n", "self", ".", "_indptr", "[", ":", "old_indptr", ".", "size", "]", "=", "old_indptr", "[", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.csrRowExpandableCSR._double_data_and_indices": [[510, 524], ["numpy.empty", "numpy.empty"], "methods", ["None"], ["", "def", "_double_data_and_indices", "(", "self", ")", ":", "\n", "        ", "\"\"\"Double size of the arrays backing `indices` and `data` attributes.\n\n        Doubling on demand gives amortized constant time append. Since these\n        two arrays are always the same size in the CSR format, they are\n        doubled together in the same function.\n        \"\"\"", "\n", "n", "=", "self", ".", "_data", ".", "size", "\n", "old_data", "=", "self", ".", "_data", "\n", "self", ".", "_data", "=", "np", ".", "empty", "(", "2", "*", "n", ",", "old_data", ".", "dtype", ")", "\n", "self", ".", "_data", "[", ":", "n", "]", "=", "old_data", "[", ":", "]", "\n", "old_indices", "=", "self", ".", "_indices", "\n", "self", ".", "_indices", "=", "np", ".", "empty", "(", "2", "*", "n", ",", "old_indices", ".", "dtype", ")", "\n", "self", ".", "_indices", "[", ":", "n", "]", "=", "old_indices", "[", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.nzcol": [[18, 44], ["mat[].nonzero"], "function", ["None"], ["def", "nzcol", "(", "mat", ",", "row_idx", ")", ":", "\n", "    ", "\"\"\"Return the nonzero elements of given row in a CSR matrix.\n\n    Parameters\n    ----------\n    mat : CSR matrix\n        Input matrix.\n    row_idx : int\n        The index of the row (if `mat` is CSR) for which the nonzero\n        elements are desired.\n\n    Returns\n    -------\n    nz : array of int\n        The location of nonzero elements of `mat[main_axis_idx]`.\n\n    Examples\n    --------\n    >>> mat = sparse.csr_matrix(np.array([[0, 1, 0, 0], [0, 5, 8, 0]]))\n    >>> nzcol(mat, 1)\n    array([1, 2], dtype=int32)\n    >>> mat[1, 2] = 0\n    >>> nzcol(mat, 1)\n    array([1], dtype=int32)\n    \"\"\"", "\n", "return", "mat", "[", "row_idx", "]", ".", "nonzero", "(", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.pixel_wise_boundary_precision_recall": [[46, 74], ["float"], "function", ["None"], ["", "def", "pixel_wise_boundary_precision_recall", "(", "pred", ",", "gt", ")", ":", "\n", "    ", "\"\"\"Evaluate voxel prediction accuracy against a ground truth.\n\n    Parameters\n    ----------\n    pred : np.ndarray of int or bool, arbitrary shape\n        The voxel-wise discrete prediction. 1 for boundary, 0 for non-boundary.\n    gt : np.ndarray of int or bool, same shape as `pred`\n        The ground truth boundary voxels. 1 for boundary, 0 for non-boundary.\n\n    Returns\n    -------\n    pr : float\n    rec : float\n        The precision and recall values associated with the prediction.\n\n    Notes\n    -----\n    Precision is defined as \"True Positives / Total Positive Calls\", and\n    Recall is defined as \"True Positives / Total Positives in Ground Truth\".\n\n    This function only calculates this value for discretized predictions,\n    i.e. it does not work with continuous prediction confidence values.\n    \"\"\"", "\n", "tp", "=", "float", "(", "(", "gt", "*", "pred", ")", ".", "sum", "(", ")", ")", "\n", "fp", "=", "(", "pred", "*", "(", "1", "-", "gt", ")", ")", ".", "sum", "(", ")", "\n", "fn", "=", "(", "gt", "*", "(", "1", "-", "pred", ")", ")", ".", "sum", "(", ")", "\n", "return", "tp", "/", "(", "tp", "+", "fp", ")", ",", "tp", "/", "(", "tp", "+", "fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.wiggle_room_precision_recall": [[76, 115], ["scipy.generate_binary_structure", "scipy.binary_dilation", "scipy.iterate_structure", "scipy.grey_dilation", "numpy.setdiff1d", "sklearn.metrics.precision_recall_curve", "sklearn.metrics.precision_recall_curve", "list", "numpy.unique", "numpy.unique", "nd.binary_dilation.ravel", "pred.ravel", "boundary.ravel", "nd.grey_dilation.ravel", "zip", "nd.grey_dilation.ravel", "numpy.flatnonzero"], "function", ["None"], ["", "def", "wiggle_room_precision_recall", "(", "pred", ",", "boundary", ",", "margin", "=", "2", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Voxel-wise, continuous value precision recall curve allowing drift.\n\n    Voxel-wise precision recall evaluates predictions against a ground truth.\n    Wiggle-room precision recall (WRPR, \"warper\") allows calls from nearby\n    voxels to be counted as correct. Specifically, if a voxel is predicted to\n    be a boundary within a dilation distance of `margin` (distance defined\n    according to `connectivity`) of a true boundary voxel, it will be counted\n    as a True Positive in the Precision, and vice-versa for the Recall.\n\n    Parameters\n    ----------\n    pred : np.ndarray of float, arbitrary shape\n        The prediction values, expressed as probability of observing a boundary\n        (i.e. a voxel with label 1).\n    boundary : np.ndarray of int, same shape as pred\n        The true boundary map. 1 indicates boundary, 0 indicates non-boundary.\n    margin : int, optional\n        The number of dilations that define the margin. default: 2.\n    connectivity : {1, ..., pred.ndim}, optional\n        The morphological voxel connectivity (defined as in SciPy) for the\n        dilation step.\n\n    Returns\n    -------\n    ts, pred, rec : np.ndarray of float, shape `(len(np.unique(pred)+1),)`\n        The prediction value thresholds corresponding to each precision and\n        recall value, the precision values, and the recall values.\n    \"\"\"", "\n", "struct", "=", "nd", ".", "generate_binary_structure", "(", "boundary", ".", "ndim", ",", "connectivity", ")", "\n", "gtd", "=", "nd", ".", "binary_dilation", "(", "boundary", ",", "struct", ",", "margin", ")", "\n", "struct_m", "=", "nd", ".", "iterate_structure", "(", "struct", ",", "margin", ")", "\n", "pred_dil", "=", "nd", ".", "grey_dilation", "(", "pred", ",", "footprint", "=", "struct_m", ")", "\n", "missing", "=", "np", ".", "setdiff1d", "(", "np", ".", "unique", "(", "pred", ")", ",", "np", ".", "unique", "(", "pred_dil", ")", ")", "\n", "for", "m", "in", "missing", ":", "\n", "        ", "pred_dil", ".", "ravel", "(", ")", "[", "np", ".", "flatnonzero", "(", "pred", "==", "m", ")", "[", "0", "]", "]", "=", "m", "\n", "", "prec", ",", "_", ",", "ts", "=", "precision_recall_curve", "(", "gtd", ".", "ravel", "(", ")", ",", "pred", ".", "ravel", "(", ")", ")", "\n", "_", ",", "rec", ",", "_", "=", "precision_recall_curve", "(", "boundary", ".", "ravel", "(", ")", ",", "pred_dil", ".", "ravel", "(", ")", ")", "\n", "return", "list", "(", "zip", "(", "ts", ",", "prec", ",", "rec", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.get_stratified_sample": [[117, 153], ["numpy.unique", "len"], "function", ["None"], ["", "def", "get_stratified_sample", "(", "ar", ",", "n", ")", ":", "\n", "    ", "\"\"\"Get a regularly-spaced sample of the unique values of an array.\n\n    Parameters\n    ----------\n    ar : np.ndarray, arbitrary shape and type\n        The input array.\n    n : int\n        The desired sample size.\n\n    Returns\n    -------\n    u : np.ndarray, shape approximately (n,)\n\n    Notes\n    -----\n    If `len(np.unique(ar)) <= 2*n`, all the values of `ar` are returned. The\n    requested sample size is taken as an approximate lower bound.\n\n    Examples\n    --------\n    >>> ar = np.array([[0, 4, 1, 3],\n    ...                [4, 1, 3, 5],\n    ...                [3, 5, 2, 1]])\n    >>> np.unique(ar)\n    array([0, 1, 2, 3, 4, 5])\n    >>> get_stratified_sample(ar, 3)\n    array([0, 2, 4])\n    \"\"\"", "\n", "u", "=", "np", ".", "unique", "(", "ar", ")", "\n", "nu", "=", "len", "(", "u", ")", "\n", "if", "nu", "<", "2", "*", "n", ":", "\n", "        ", "return", "u", "\n", "", "else", ":", "\n", "        ", "step", "=", "nu", "//", "n", "\n", "return", "u", "[", "0", ":", "nu", ":", "step", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.edit_distance": [[155, 181], ["evaluate.raw_edit_distance", "agglo.best_possible_segmentation", "evaluate.raw_edit_distance"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.raw_edit_distance", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.best_possible_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.raw_edit_distance"], ["", "", "def", "edit_distance", "(", "aseg", ",", "gt", ",", "size_threshold", "=", "1000", ",", "sp", "=", "None", ")", ":", "\n", "    ", "\"\"\"Find the number of splits and merges needed to convert `aseg` to `gt`.\n\n    Parameters\n    ----------\n    aseg : np.ndarray, int type, arbitrary shape\n        The candidate automatic segmentation being evaluated.\n    gt : np.ndarray, int type, same shape as `aseg`\n        The ground truth segmentation.\n    size_threshold : int or float, optional\n        Ignore splits or merges smaller than this number of voxels.\n    sp : np.ndarray, int type, same shape as `aseg`, optional\n        A superpixel map. If provided, compute the edit distance to the best\n        possible agglomeration of `sp` to `gt`, rather than to `gt` itself.\n\n    Returns\n    -------\n    (false_merges, false_splits) : float\n        The number of splits and merges needed to convert aseg to gt.\n    \"\"\"", "\n", "if", "sp", "is", "None", ":", "\n", "        ", "return", "raw_edit_distance", "(", "aseg", ",", "gt", ",", "size_threshold", ")", "\n", "", "else", ":", "\n", "        ", "from", ".", "import", "agglo", "\n", "bps", "=", "agglo", ".", "best_possible_segmentation", "(", "sp", ",", "gt", ")", "\n", "return", "raw_edit_distance", "(", "aseg", ",", "bps", ",", "size_threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.raw_edit_distance": [[183, 210], ["evaluate.contingency_table", "[].sum", "[].sum", "skimage.segmentation.relabel_sequential", "skimage.segmentation.relabel_sequential", "contingency_table.data.nonzero", "contingency_table.data.nonzero", "contingency_table.sum", "contingency_table.sum"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["", "", "def", "raw_edit_distance", "(", "aseg", ",", "gt", ",", "size_threshold", "=", "1000", ")", ":", "\n", "    ", "\"\"\"Compute the edit distance between two segmentations.\n\n    Parameters\n    ----------\n    aseg : np.ndarray, int type, arbitrary shape\n        The candidate automatic segmentation.\n    gt : np.ndarray, int type, same shape as `aseg`\n        The ground truth segmentation.\n    size_threshold : int or float, optional\n        Ignore splits or merges smaller than this number of voxels.\n\n    Returns\n    -------\n    (false_merges, false_splits) : float\n        The number of splits and merges required to convert aseg to gt.\n    \"\"\"", "\n", "aseg", "=", "relabel_sequential", "(", "aseg", ")", "[", "0", "]", "\n", "gt", "=", "relabel_sequential", "(", "gt", ")", "[", "0", "]", "\n", "r", "=", "contingency_table", "(", "aseg", ",", "gt", ",", "ignore_seg", "=", "[", "0", "]", ",", "ignore_gt", "=", "[", "0", "]", ",", "norm", "=", "False", ")", "\n", "r", ".", "data", "[", "r", ".", "data", "<=", "size_threshold", "]", "=", "0", "\n", "# make each segment overlap count for 1, since it will be one", "\n", "# operation to fix (split or merge)", "\n", "r", ".", "data", "[", "r", ".", "data", ".", "nonzero", "(", ")", "]", "/=", "r", ".", "data", "[", "r", ".", "data", ".", "nonzero", "(", ")", "]", "\n", "false_splits", "=", "(", "r", ".", "sum", "(", "axis", "=", "0", ")", "-", "1", ")", "[", "1", ":", "]", ".", "sum", "(", ")", "\n", "false_merges", "=", "(", "r", ".", "sum", "(", "axis", "=", "1", ")", "-", "1", ")", "[", "1", ":", "]", ".", "sum", "(", ")", "\n", "return", "(", "false_merges", ",", "false_splits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table": [[212, 250], ["seg.ravel", "gt.ravel", "numpy.zeros", "numpy.ones", "scipy.coo_matrix().tocsr", "sparse.coo_matrix().tocsr.sum", "scipy.coo_matrix"], "function", ["None"], ["", "def", "contingency_table", "(", "seg", ",", "gt", ",", "*", ",", "ignore_seg", "=", "(", ")", ",", "ignore_gt", "=", "(", ")", ",", "norm", "=", "True", ")", ":", "\n", "    ", "\"\"\"Return the contingency table for all regions in matched segmentations.\n\n    Parameters\n    ----------\n    seg : np.ndarray, int type, arbitrary shape\n        A candidate segmentation.\n    gt : np.ndarray, int type, same shape as `seg`\n        The ground truth segmentation.\n    ignore_seg : iterable of int, optional\n        Values to ignore in `seg`. Voxels in `seg` having a value in this list\n        will not contribute to the contingency table. (default: [0])\n    ignore_gt : iterable of int, optional\n        Values to ignore in `gt`. Voxels in `gt` having a value in this list\n        will not contribute to the contingency table. (default: [0])\n    norm : bool, optional\n        Whether to normalize the table so that it sums to 1.\n\n    Returns\n    -------\n    cont : scipy.sparse.csr_matrix\n        A contingency table. `cont[i, j]` will equal the number of voxels\n        labeled `i` in `seg` and `j` in `gt`. (Or the proportion of such voxels\n        if `norm=True`.)\n    \"\"\"", "\n", "segr", "=", "seg", ".", "ravel", "(", ")", "\n", "gtr", "=", "gt", ".", "ravel", "(", ")", "\n", "ignored", "=", "np", ".", "zeros", "(", "segr", ".", "shape", ",", "np", ".", "bool", ")", "\n", "data", "=", "np", ".", "ones", "(", "gtr", ".", "shape", ")", "\n", "for", "i", "in", "ignore_seg", ":", "\n", "        ", "ignored", "[", "segr", "==", "i", "]", "=", "True", "\n", "", "for", "j", "in", "ignore_gt", ":", "\n", "        ", "ignored", "[", "gtr", "==", "j", "]", "=", "True", "\n", "", "data", "[", "ignored", "]", "=", "0", "\n", "cont", "=", "sparse", ".", "coo_matrix", "(", "(", "data", ",", "(", "segr", ",", "gtr", ")", ")", ")", ".", "tocsr", "(", ")", "\n", "if", "norm", ":", "\n", "        ", "cont", "/=", "cont", ".", "sum", "(", ")", "\n", "", "return", "cont", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.assignment_table": [[252, 301], ["evaluate._mindiff", "contingency_table.max().toarray", "numpy.repeat", "scipy.csr_matrix", "sparse.csr_matrix.eliminate_zeros", "seg_or_ctable.copy", "evaluate.contingency_table", "numpy.diff", "numpy.random.randn", "contingency_table.max"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate._mindiff", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["", "def", "assignment_table", "(", "seg_or_ctable", ",", "gt", "=", "None", ",", "*", ",", "dtype", "=", "np", ".", "bool_", ")", ":", "\n", "    ", "\"\"\"Create an assignment table of value in `seg` to `gt`.\n\n    Parameters\n    ----------\n    seg_or_ctable : array of int, or 2D array of float\n        The segmentation to assign. Every value in `seg` will be\n        assigned to a single value in `gt`.\n        Alternatively, pass a single, pre-computed contingency table\n        to be converted to an assignment table.\n    gt : array of int, same shape as seg\n        The segmentation to assign to. Don't pass if `seg_or_cont` is\n        a contingency matrix.\n    dtype : numpy dtype specification\n        The desired data type for the assignment matrix.\n\n    Returns\n    -------\n    assignments : sparse matrix\n        A matrix with `True` at position [i, j] if segment i in `seg`\n        is assigned to segment j in `gt`.\n\n    Examples\n    --------\n    >>> seg = np.array([0, 1, 1, 1, 2, 2])\n    >>> gt = np.array([1, 1, 1, 2, 2, 2])\n    >>> assignment_table(seg, gt).toarray()\n    array([[False,  True, False],\n           [False,  True, False],\n           [False, False,  True]])\n    >>> cont = contingency_table(seg, gt)\n    >>> assignment_table(cont).toarray()\n    array([[False,  True, False],\n           [False,  True, False],\n           [False, False,  True]])\n    \"\"\"", "\n", "if", "gt", "is", "None", ":", "\n", "        ", "ctable", "=", "seg_or_ctable", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "        ", "ctable", "=", "contingency_table", "(", "seg_or_ctable", ",", "gt", ",", "norm", "=", "False", ")", "\n", "", "minval", "=", "_mindiff", "(", "ctable", ".", "data", ")", "\n", "ctable", ".", "data", "+=", "np", ".", "random", ".", "randn", "(", "ctable", ".", "data", ".", "size", ")", "*", "0.01", "*", "minval", "\n", "maxes", "=", "ctable", ".", "max", "(", "axis", "=", "1", ")", ".", "toarray", "(", ")", "\n", "maxes_repeated", "=", "np", ".", "repeat", "(", "maxes", ",", "np", ".", "diff", "(", "ctable", ".", "indptr", ")", ")", "\n", "assignments", "=", "sparse", ".", "csr_matrix", "(", "(", "ctable", ".", "data", "==", "maxes_repeated", ",", "\n", "ctable", ".", "indices", ",", "ctable", ".", "indptr", ")", ",", "\n", "dtype", "=", "dtype", ")", "\n", "assignments", ".", "eliminate_zeros", "(", ")", "\n", "return", "assignments", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate._mindiff": [[303, 332], ["numpy.sort", "numpy.diff", "numpy.min", "numpy.concatenate"], "function", ["None"], ["", "def", "_mindiff", "(", "arr", ")", ":", "\n", "    ", "\"\"\"Compute the smallest nonzero difference between elements in arr\n\n    Parameters\n    ----------\n    arr : array\n        Array of *positive* numeric values.\n\n    Returns\n    -------\n    mindiff : float\n        The smallest nonzero difference between any two elements in arr.\n\n    Examples\n    --------\n    >>> arr = np.array([5, 5, 2.5, 7, 9.2])\n    >>> _mindiff(arr)\n    2.0\n    >>> arr = np.array([0.5, 0.5])\n    >>> _mindiff(arr)\n    0.5\n    \"\"\"", "\n", "arr", "=", "np", ".", "sort", "(", "arr", ")", "# this *must* be a copy!", "\n", "diffs", "=", "np", ".", "diff", "(", "arr", ")", "\n", "diffs", "=", "diffs", "[", "diffs", "!=", "0", "]", "\n", "if", "arr", "[", "0", "]", "!=", "0", ":", "\n", "        ", "diffs", "=", "np", ".", "concatenate", "(", "(", "diffs", ",", "[", "arr", "[", "0", "]", "]", ")", ")", "\n", "", "mindiff", "=", "np", ".", "min", "(", "diffs", ")", "\n", "return", "mindiff", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.merge_contingency_table": [[526, 544], ["evaluate.contingency_table", "evaluate.csrRowExpandableCSR"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["", "", "def", "merge_contingency_table", "(", "a", ",", "b", ",", "ignore_seg", "=", "[", "0", "]", ",", "ignore_gt", "=", "[", "0", "]", ")", ":", "\n", "    ", "\"\"\"A contingency table that has additional rows for merging initial rows.\n\n    Parameters\n    ----------\n    a\n    b\n    ignore_seg\n    ignore_gt\n\n    Returns\n    -------\n    ct : array, shape (2M + 1, N)\n    \"\"\"", "\n", "ct", "=", "contingency_table", "(", "a", ",", "b", ",", "\n", "ignore_seg", "=", "ignore_seg", ",", "ignore_gt", "=", "ignore_gt", ")", "\n", "ctout", "=", "csrRowExpandableCSR", "(", "ct", ")", "\n", "return", "ctout", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.xlogx": [[546, 578], ["np.asarray.nonzero", "numpy.log2", "isinstance", "isinstance", "numpy.asarray", "x.copy"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "xlogx", "(", "x", ",", "out", "=", "None", ",", "in_place", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute x * log_2(x).\n\n    We define 0 * log_2(0) = 0\n\n    Parameters\n    ----------\n    x : np.ndarray or scipy.sparse.csc_matrix or csr_matrix\n        The input array.\n    out : same type as x (optional)\n        If provided, use this array/matrix for the result.\n    in_place : bool (optional, default False)\n        Operate directly on x.\n\n    Returns\n    -------\n    y : same type as x\n        Result of x * log_2(x).\n    \"\"\"", "\n", "if", "in_place", ":", "\n", "        ", "y", "=", "x", "\n", "", "elif", "out", "is", "None", ":", "\n", "        ", "y", "=", "x", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "        ", "y", "=", "out", "\n", "", "if", "isinstance", "(", "y", ",", "sparse", ".", "csc_matrix", ")", "or", "isinstance", "(", "y", ",", "sparse", ".", "csr_matrix", ")", ":", "\n", "        ", "z", "=", "y", ".", "data", "\n", "", "else", ":", "\n", "        ", "z", "=", "np", ".", "asarray", "(", "y", ")", "# ensure np.matrix converted to np.array", "\n", "", "nz", "=", "z", ".", "nonzero", "(", ")", "\n", "z", "[", "nz", "]", "*=", "np", ".", "log2", "(", "z", "[", "nz", "]", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.special_points_evaluate": [[580, 622], ["eval_fct", "range", "numpy.ravel_multi_index", "x.ravel", "y.ravel", "range", "len"], "function", ["None"], ["", "def", "special_points_evaluate", "(", "eval_fct", ",", "coords", ",", "flatten", "=", "True", ",", "coord_format", "=", "True", ")", ":", "\n", "    ", "\"\"\"Return an evaluation function to only evaluate at special coordinates.\n\n    Parameters\n    ----------\n    eval_fct : function taking at least two np.ndarray of equal shapes as args\n        The function to be used for evaluation.\n    coords : np.ndarray of int, shape (n_points, n_dim) or (n_points,)\n        The coordinates at which to evaluate the function. The coordinates can\n        either be subscript format (one index into each dimension of input\n        arrays) or index format (a single index into the linear array). For\n        the latter, use `flatten=False`.\n    flatten : bool, optional\n        Whether to flatten the coordinates (default) or leave them untouched\n        (if they are already in raveled format).\n    coord_format : bool, optional\n        Format the coordinates to a tuple of np.ndarray as numpy expects. Set\n        to False if coordinates are already in this format or flattened.\n\n    Returns\n    -------\n    special_eval_fct : function taking at least two np.ndarray of equal shapes\n        The returned function is the same as the above function but only\n        evaluated at the coordinates specified. This can be used, for example,\n        to subsample a volume, or to evaluate only whether synapses are\n        correctly assigned, rather than every voxel, in a neuronal image\n        volume.\n    \"\"\"", "\n", "if", "coord_format", ":", "\n", "        ", "coords", "=", "[", "coords", "[", ":", ",", "i", "]", "for", "i", "in", "range", "(", "coords", ".", "shape", "[", "1", "]", ")", "]", "\n", "", "def", "special_eval_fct", "(", "x", ",", "y", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "flatten", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "coords", ")", ")", ":", "\n", "                ", "if", "coords", "[", "i", "]", "[", "0", "]", "<", "0", ":", "\n", "                    ", "coords", "[", "i", "]", "+=", "x", ".", "shape", "[", "i", "]", "\n", "", "", "coords2", "=", "np", ".", "ravel_multi_index", "(", "coords", ",", "x", ".", "shape", ")", "\n", "", "else", ":", "\n", "            ", "coords2", "=", "coords", "\n", "", "sx", "=", "x", ".", "ravel", "(", ")", "[", "coords2", "]", "\n", "sy", "=", "y", ".", "ravel", "(", ")", "[", "coords2", "]", "\n", "return", "eval_fct", "(", "sx", ",", "sy", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "return", "special_eval_fct", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.make_synaptic_functions": [[624, 658], ["synio.raveler_synapse_annotations_to_coords", "numpy.array", "functools.partial", "list", "isinstance", "functools.partial.", "list", "itertools.chain", "map", "evaluate.split_vi"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi"], ["", "def", "make_synaptic_functions", "(", "fn", ",", "fcts", ")", ":", "\n", "    ", "\"\"\"Make evaluation functions that only evaluate at synaptic sites.\n\n    Parameters\n    ----------\n    fn : string\n        Filename containing synapse coordinates, in Raveler format. [1]\n    fcts : function, or iterable of functions\n        Functions to be converted to synaptic evaluation.\n\n    Returns\n    -------\n    syn_fcts : function or iterable of functions\n        Evaluation functions that will evaluate only at synaptic sites.\n\n    Raises\n    ------\n    ImportError : if the `syngeo` package [2, 3] is not installed.\n\n    References\n    ----------\n    [1] https://wiki.janelia.org/wiki/display/flyem/synapse+annotation+file+format\n    [2] https://github.com/janelia-flyem/synapse-geometry\n    [3] https://github.com/jni/synapse-geometry\n    \"\"\"", "\n", "from", "syngeo", "import", "io", "as", "synio", "\n", "synapse_coords", "=", "synio", ".", "raveler_synapse_annotations_to_coords", "(", "fn", ",", "'arrays'", ")", "\n", "synapse_coords", "=", "np", ".", "array", "(", "list", "(", "it", ".", "chain", "(", "*", "synapse_coords", ")", ")", ")", "\n", "make_function", "=", "partial", "(", "special_points_evaluate", ",", "coords", "=", "synapse_coords", ")", "\n", "if", "not", "isinstance", "(", "fcts", ",", "coll", ".", "Iterable", ")", ":", "\n", "        ", "return", "make_function", "(", "fcts", ")", "\n", "", "else", ":", "\n", "        ", "return", "list", "(", "map", "(", "make_function", ",", "fcts", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.make_synaptic_vi": [[660, 663], ["evaluate.make_synaptic_functions"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.make_synaptic_functions"], ["", "", "def", "make_synaptic_vi", "(", "fn", ")", ":", "\n", "    ", "\"\"\"Shortcut for `make_synaptic_functions(fn, split_vi)`.\"\"\"", "\n", "return", "make_synaptic_functions", "(", "fn", ",", "split_vi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi": [[665, 697], ["numpy.ones", "numpy.dot", "evaluate.split_vi"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi"], ["", "def", "vi", "(", "x", ",", "y", "=", "None", ",", "weights", "=", "np", ".", "ones", "(", "2", ")", ",", "ignore_x", "=", "[", "0", "]", ",", "ignore_y", "=", "[", "0", "]", ")", ":", "\n", "    ", "\"\"\"Return the variation of information metric. [1]\n\n    VI(X, Y) = H(X | Y) + H(Y | X), where H(.|.) denotes the conditional\n    entropy.\n\n    Parameters\n    ----------\n    x : np.ndarray\n        Label field (int type) or contingency table (float). `x` is\n        interpreted as a contingency table (summing to 1.0) if and only if `y`\n        is not provided.\n    y : np.ndarray of int, same shape as x, optional\n        A label field to compare to `x`.\n    weights : np.ndarray of float, shape (2,), optional\n        The weights of the conditional entropies of `x` and `y`. Equal weights\n        are the default.\n    ignore_x, ignore_y : list of int, optional\n        Any points having a label in this list are ignored in the evaluation.\n        Ignore 0-labeled points by default.\n\n    Returns\n    -------\n    v : float\n        The variation of information between `x` and `y`.\n\n    References\n    ----------\n    [1] Meila, M. (2007). Comparing clusterings - an information based\n    distance. Journal of Multivariate Analysis 98, 873-895.\n    \"\"\"", "\n", "return", "np", ".", "dot", "(", "weights", ",", "split_vi", "(", "x", ",", "y", ",", "ignore_x", ",", "ignore_y", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.split_vi": [[699, 734], ["evaluate.vi_tables", "numpy.array", "hygx.sum", "hxgy.sum"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi_tables"], ["", "def", "split_vi", "(", "x", ",", "y", "=", "None", ",", "ignore_x", "=", "[", "0", "]", ",", "ignore_y", "=", "[", "0", "]", ")", ":", "\n", "    ", "\"\"\"Return the symmetric conditional entropies associated with the VI.\n\n    The variation of information is defined as VI(X,Y) = H(X|Y) + H(Y|X).\n    If Y is the ground-truth segmentation, then H(Y|X) can be interpreted\n    as the amount of under-segmentation of Y and H(X|Y) is then the amount\n    of over-segmentation.  In other words, a perfect over-segmentation\n    will have H(Y|X)=0 and a perfect under-segmentation will have H(X|Y)=0.\n\n    If y is None, x is assumed to be a contingency table.\n\n    Parameters\n    ----------\n    x : np.ndarray\n        Label field (int type) or contingency table (float). `x` is\n        interpreted as a contingency table (summing to 1.0) if and only if `y`\n        is not provided.\n    y : np.ndarray of int, same shape as x, optional\n        A label field to compare to `x`.\n    ignore_x, ignore_y : list of int, optional\n        Any points having a label in this list are ignored in the evaluation.\n        Ignore 0-labeled points by default.\n\n    Returns\n    -------\n    sv : np.ndarray of float, shape (2,)\n        The conditional entropies of Y|X and X|Y.\n\n    See Also\n    --------\n    vi\n    \"\"\"", "\n", "_", ",", "_", ",", "_", ",", "hxgy", ",", "hygx", ",", "_", ",", "_", "=", "vi_tables", "(", "x", ",", "y", ",", "ignore_x", ",", "ignore_y", ")", "\n", "# false merges, false splits", "\n", "return", "np", ".", "array", "(", "[", "hygx", ".", "sum", "(", ")", ",", "hxgy", ".", "sum", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi_pairwise_matrix": [[736, 771], ["numpy.array", "numpy.tril().astype", "scipy.spatial.distance.squareform", "s.ravel", "scipy.spatial.distance.squareform", "scipy.spatial.distance.pdist", "evaluate.split_vi", "evaluate.split_vi", "scipy.spatial.distance.pdist", "numpy.tril", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi"], ["", "def", "vi_pairwise_matrix", "(", "segs", ",", "split", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute the pairwise VI distances within a set of segmentations.\n\n    If 'split' is set to True, two matrices are returned, one for each\n    direction of the conditional entropy.\n\n    0-labeled pixels are ignored.\n\n    Parameters\n    ----------\n    segs : iterable of np.ndarray of int\n        A list or iterable of segmentations. All arrays must have the same\n        shape.\n    split : bool, optional\n        Should the split VI be returned, or just the VI itself (default)?\n\n    Returns\n    -------\n    vi_sq : np.ndarray of float, shape (len(segs), len(segs))\n        The distances between segmentations. If `split==False`, this is a\n        symmetric square matrix of distances. Otherwise, the lower triangle\n        of the output matrix is the false split distance, while the upper\n        triangle is the false merge distance.\n    \"\"\"", "\n", "d", "=", "np", ".", "array", "(", "[", "s", ".", "ravel", "(", ")", "for", "s", "in", "segs", "]", ")", "\n", "if", "split", ":", "\n", "        ", "def", "dmerge", "(", "x", ",", "y", ")", ":", "return", "split_vi", "(", "x", ",", "y", ")", "[", "0", "]", "\n", "def", "dsplit", "(", "x", ",", "y", ")", ":", "return", "split_vi", "(", "x", ",", "y", ")", "[", "1", "]", "\n", "merges", ",", "splits", "=", "[", "squareform", "(", "pdist", "(", "d", ",", "df", ")", ")", "for", "df", "in", "[", "dmerge", ",", "dsplit", "]", "]", "\n", "out", "=", "merges", "\n", "tri", "=", "np", ".", "tril", "(", "np", ".", "ones", "(", "splits", ".", "shape", ")", ",", "-", "1", ")", ".", "astype", "(", "bool", ")", "\n", "out", "[", "tri", "]", "=", "splits", "[", "tri", "]", "\n", "", "else", ":", "\n", "        ", "out", "=", "squareform", "(", "pdist", "(", "d", ",", "vi", ")", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.split_vi_threshold": [[773, 795], ["evaluate.split_vi", "scipy.ndimage.measurements.label"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi"], ["", "def", "split_vi_threshold", "(", "tup", ")", ":", "\n", "    ", "\"\"\"Compute VI with tuple input (to support multiprocessing).\n\n    Parameters\n    ----------\n    tup : a tuple, (np.ndarray, np.ndarray, [int], [int], float)\n        The tuple should consist of::\n            - the UCM for the candidate segmentation,\n            - the gold standard,\n            - list of ignored labels in the segmentation,\n            - list of ignored labels in the gold standard,\n            - threshold to use for the UCM.\n\n    Returns\n    -------\n    sv : np.ndarray of float, shape (2,)\n        The undersegmentation and oversegmentation of the comparison between\n        applying a threshold and connected components labeling of the first\n        array, and the second array.\n    \"\"\"", "\n", "ucm", ",", "gt", ",", "ignore_seg", ",", "ignore_gt", ",", "t", "=", "tup", "\n", "return", "split_vi", "(", "label", "(", "ucm", "<", "t", ")", "[", "0", "]", ",", "gt", ",", "ignore_seg", ",", "ignore_gt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi_by_threshold": [[797, 842], ["numpy.concatenate", "numpy.unique", "len", "len", "multiprocessing.Pool", "multiprocessing.Pool.map", "evaluate.split_vi_threshold", "numpy.arange", "numpy.array", "len", "len"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.split_vi_threshold"], ["", "def", "vi_by_threshold", "(", "ucm", ",", "gt", ",", "ignore_seg", "=", "[", "]", ",", "ignore_gt", "=", "[", "]", ",", "npoints", "=", "None", ",", "\n", "nprocessors", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute the VI at every threshold of the provided UCM.\n\n    Parameters\n    ----------\n    ucm : np.ndarray of float, arbitrary shape\n        The Ultrametric Contour Map, where each 0.0-region is separated by a\n        boundary. Higher values of the boundary indicate more confidence in\n        its presence.\n    gt : np.ndarray of int, same shape as `ucm`\n        The ground truth segmentation.\n    ignore_seg : list of int, optional\n        The labels to ignore in the segmentation of the UCM.\n    ignore_gt : list of int, optional\n        The labels to ignore in the ground truth.\n    npoints : int, optional\n        The number of thresholds to sample. By default, all thresholds are\n        sampled.\n    nprocessors : int, optional\n        Number of processors to use for the parallel evaluation of different\n        thresholds.\n\n    Returns\n    -------\n    result : np.ndarray of float, shape (3, npoints)\n        The evaluation of segmentation at each threshold. The rows of this\n        array are:\n            - the threshold used\n            - the undersegmentation component of VI\n            - the oversegmentation component of VI\n    \"\"\"", "\n", "ts", "=", "np", ".", "unique", "(", "ucm", ")", "[", "1", ":", "]", "\n", "if", "npoints", "is", "None", ":", "\n", "        ", "npoints", "=", "len", "(", "ts", ")", "\n", "", "if", "len", "(", "ts", ")", ">", "2", "*", "npoints", ":", "\n", "        ", "ts", "=", "ts", "[", "np", ".", "arange", "(", "1", ",", "len", "(", "ts", ")", ",", "len", "(", "ts", ")", "/", "npoints", ")", "]", "\n", "", "if", "nprocessors", "==", "1", ":", "# this should avoid pickling overhead", "\n", "        ", "result", "=", "[", "split_vi_threshold", "(", "(", "ucm", ",", "gt", ",", "ignore_seg", ",", "ignore_gt", ",", "t", ")", ")", "\n", "for", "t", "in", "ts", "]", "\n", "", "else", ":", "\n", "        ", "p", "=", "multiprocessing", ".", "Pool", "(", "nprocessors", ")", "\n", "result", "=", "p", ".", "map", "(", "split_vi_threshold", ",", "\n", "(", "(", "ucm", ",", "gt", ",", "ignore_seg", ",", "ignore_gt", ",", "t", ")", "for", "t", "in", "ts", ")", ")", "\n", "", "return", "np", ".", "concatenate", "(", "(", "ts", "[", "np", ".", "newaxis", ",", ":", "]", ",", "np", ".", "array", "(", "result", ")", ".", "T", ")", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.rand_by_threshold": [[844, 878], ["numpy.zeros", "enumerate", "numpy.concatenate", "numpy.unique", "len", "len", "evaluate.rand_index", "evaluate.adj_rand_index", "len", "scipy.ndimage.measurements.label", "numpy.arange", "len", "len"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.rand_index", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.adj_rand_index"], ["", "def", "rand_by_threshold", "(", "ucm", ",", "gt", ",", "npoints", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute Rand and Adjusted Rand indices for each threshold of a UCM\n\n    Parameters\n    ----------\n    ucm : np.ndarray, arbitrary shape\n        An Ultrametric Contour Map of region boundaries having specific\n        values. Higher values indicate higher boundary probabilities.\n    gt : np.ndarray, int type, same shape as ucm\n        The ground truth segmentation.\n    npoints : int, optional\n        If provided, only compute values at npoints thresholds, rather than\n        all thresholds. Useful when ucm has an extremely large number of\n        unique values.\n\n    Returns\n    -------\n    ris : np.ndarray of float, shape (3, len(np.unique(ucm))) or (3, npoints)\n        The rand indices of the segmentation induced by thresholding and\n        labeling `ucm` at different values. The 3 rows of `ris` are the values\n        used for thresholding, the corresponding Rand Index at that threshold,\n        and the corresponding Adjusted Rand Index at that threshold.\n    \"\"\"", "\n", "ts", "=", "np", ".", "unique", "(", "ucm", ")", "[", "1", ":", "]", "\n", "if", "npoints", "is", "None", ":", "\n", "        ", "npoints", "=", "len", "(", "ts", ")", "\n", "", "if", "len", "(", "ts", ")", ">", "2", "*", "npoints", ":", "\n", "        ", "ts", "=", "ts", "[", "np", ".", "arange", "(", "1", ",", "len", "(", "ts", ")", ",", "len", "(", "ts", ")", "/", "npoints", ")", "]", "\n", "", "result", "=", "np", ".", "zeros", "(", "(", "2", ",", "len", "(", "ts", ")", ")", ")", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "ts", ")", ":", "\n", "        ", "seg", "=", "label", "(", "ucm", "<", "t", ")", "[", "0", "]", "\n", "result", "[", "0", ",", "i", "]", "=", "rand_index", "(", "seg", ",", "gt", ")", "\n", "result", "[", "1", ",", "i", "]", "=", "adj_rand_index", "(", "seg", ",", "gt", ")", "\n", "", "return", "np", ".", "concatenate", "(", "(", "ts", "[", "np", ".", "newaxis", ",", ":", "]", ",", "result", ")", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.adapted_rand_error": [[879, 944], ["evaluate.contingency_table", "contingency_table.sum().A.ravel", "contingency_table.sum().A.ravel", "contingency_table.sum", "contingency_table.sum"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["", "def", "adapted_rand_error", "(", "seg", ",", "gt", ",", "all_stats", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute Adapted Rand error as defined by the SNEMI3D contest [1]\n\n    Formula is given as 1 - the maximal F-score of the Rand index\n    (excluding the zero component of the original labels). Adapted\n    from the SNEMI3D MATLAB script, hence the strange style.\n\n    Parameters\n    ----------\n    seg : np.ndarray\n        the segmentation to score, where each value is the label at that point\n    gt : np.ndarray, same shape as seg\n        the groundtruth to score against, where each value is a label\n    all_stats : boolean, optional\n        whether to also return precision and recall as a 3-tuple with rand_error\n\n    Returns\n    -------\n    are : float\n        The adapted Rand error; equal to $1 - \\frac{2pr}{p + r}$,\n        where $p$ and $r$ are the precision and recall described below.\n    prec : float, optional\n        The adapted Rand precision. (Only returned when `all_stats` is ``True``.)\n    rec : float, optional\n        The adapted Rand recall.  (Only returned when `all_stats` is ``True``.)\n\n    References\n    ----------\n    [1]: http://brainiac2.mit.edu/SNEMI3D/evaluation\n    \"\"\"", "\n", "# segA is query, segB is truth", "\n", "segA", "=", "seg", "\n", "segB", "=", "gt", "\n", "\n", "n", "=", "segA", ".", "size", "\n", "\n", "# This is the contingency table obtained from segA and segB, we obtain", "\n", "# the marginal probabilities from the table.", "\n", "p_ij", "=", "contingency_table", "(", "segA", ",", "segB", ",", "norm", "=", "False", ")", "\n", "\n", "# Sum of the joint distribution squared", "\n", "sum_p_ij", "=", "p_ij", ".", "data", "@", "p_ij", ".", "data", "\n", "\n", "# These are the axix-wise sums (np.sumaxis)", "\n", "a_i", "=", "p_ij", ".", "sum", "(", "axis", "=", "0", ")", ".", "A", ".", "ravel", "(", ")", "\n", "b_i", "=", "p_ij", ".", "sum", "(", "axis", "=", "1", ")", ".", "A", ".", "ravel", "(", ")", "\n", "\n", "# Sum of the segment labeled 'A'", "\n", "sum_a", "=", "a_i", "@", "a_i", "\n", "# Sum of the segment labeled 'B'", "\n", "sum_b", "=", "b_i", "@", "b_i", "\n", "\n", "# This is the new code, wherein 'n' is subtacted from the numerator", "\n", "# and the denominator.", "\n", "\n", "precision", "=", "(", "sum_p_ij", "-", "n", ")", "/", "(", "sum_a", "-", "n", ")", "\n", "recall", "=", "(", "sum_p_ij", "-", "n", ")", "/", "(", "sum_b", "-", "n", ")", "\n", "\n", "fscore", "=", "2.", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", ")", "\n", "are", "=", "1.", "-", "fscore", "\n", "\n", "if", "all_stats", ":", "\n", "        ", "return", "(", "are", ",", "precision", ",", "recall", ")", "\n", "", "else", ":", "\n", "        ", "return", "are", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.calc_entropy": [[946, 958], ["split_vals.items", "split_vals.items", "float", "float", "numpy.log2"], "function", ["None"], ["", "", "def", "calc_entropy", "(", "split_vals", ",", "count", ")", ":", "\n", "    ", "col_count", "=", "0", "\n", "for", "key", ",", "val", "in", "split_vals", ".", "items", "(", ")", ":", "\n", "        ", "col_count", "+=", "val", "\n", "", "col_prob", "=", "float", "(", "col_count", ")", "/", "count", "\n", "\n", "ent_val", "=", "0", "\n", "for", "key", ",", "val", "in", "split_vals", ".", "items", "(", ")", ":", "\n", "        ", "val_norm", "=", "float", "(", "val", ")", "/", "count", "\n", "temp", "=", "(", "val_norm", "/", "col_prob", ")", "\n", "ent_val", "+=", "temp", "*", "np", ".", "log2", "(", "temp", ")", "\n", "", "return", "-", "(", "col_prob", "*", "ent_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.split_vi_mem": [[960, 1011], ["numpy.unique", "numpy.unique", "x.ravel", "y.ravel", "print", "range", "print", "x_map.items", "y_map.items", "sorted", "sorted", "len", "evaluate.calc_entropy", "evaluate.calc_entropy", "x_ents.items", "y_ents.items", "x_map[].setdefault", "y_map[].setdefault"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.calc_entropy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.calc_entropy"], ["", "def", "split_vi_mem", "(", "x", ",", "y", ")", ":", "\n", "    ", "x_labels", "=", "np", ".", "unique", "(", "x", ")", "\n", "y_labels", "=", "np", ".", "unique", "(", "y", ")", "\n", "x_labels0", "=", "x_labels", "[", "x_labels", "!=", "0", "]", "\n", "y_labels0", "=", "y_labels", "[", "y_labels", "!=", "0", "]", "\n", "\n", "x_map", "=", "{", "}", "\n", "y_map", "=", "{", "}", "\n", "\n", "for", "label", "in", "x_labels0", ":", "\n", "        ", "x_map", "[", "label", "]", "=", "{", "}", "\n", "\n", "", "for", "label", "in", "y_labels0", ":", "\n", "        ", "y_map", "[", "label", "]", "=", "{", "}", "\n", "\n", "", "x_flat", "=", "x", ".", "ravel", "(", ")", "\n", "y_flat", "=", "y", ".", "ravel", "(", ")", "\n", "\n", "count", "=", "0", "\n", "print", "(", "\"Analyzing similarities\"", ")", "\n", "for", "pos", "in", "range", "(", "0", ",", "len", "(", "x_flat", ")", ")", ":", "\n", "        ", "x_val", "=", "x_flat", "[", "pos", "]", "\n", "y_val", "=", "y_flat", "[", "pos", "]", "\n", "\n", "if", "x_val", "!=", "0", "and", "y_val", "!=", "0", ":", "\n", "            ", "x_map", "[", "x_val", "]", ".", "setdefault", "(", "y_val", ",", "0", ")", "\n", "y_map", "[", "y_val", "]", ".", "setdefault", "(", "x_val", ",", "0", ")", "\n", "(", "x_map", "[", "x_val", "]", ")", "[", "y_val", "]", "+=", "1", "\n", "(", "y_map", "[", "y_val", "]", ")", "[", "x_val", "]", "+=", "1", "\n", "count", "+=", "1", "\n", "", "", "print", "(", "\"Finished analyzing similarities\"", ")", "\n", "\n", "x_ents", "=", "{", "}", "\n", "y_ents", "=", "{", "}", "\n", "x_sum", "=", "0.0", "\n", "y_sum", "=", "0.0", "\n", "\n", "for", "key", ",", "vals", "in", "x_map", ".", "items", "(", ")", ":", "\n", "        ", "x_ents", "[", "key", "]", "=", "calc_entropy", "(", "vals", ",", "count", ")", "\n", "x_sum", "+=", "x_ents", "[", "key", "]", "\n", "\n", "", "for", "key", ",", "vals", "in", "y_map", ".", "items", "(", ")", ":", "\n", "        ", "y_ents", "[", "key", "]", "=", "calc_entropy", "(", "vals", ",", "count", ")", "\n", "y_sum", "+=", "y_ents", "[", "key", "]", "\n", "\n", "", "x_s", "=", "sorted", "(", "x_ents", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", "\n", "y_s", "=", "sorted", "(", "y_ents", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", "\n", "x_sorted", "=", "[", "pair", "[", "0", "]", "for", "pair", "in", "x_s", "]", "\n", "y_sorted", "=", "[", "pair", "[", "0", "]", "for", "pair", "in", "y_s", "]", "\n", "\n", "return", "x_sum", ",", "y_sum", ",", "x_sorted", ",", "x_ents", ",", "y_sorted", ",", "y_ents", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.divide_rows": [[1013, 1050], ["matrix.copy", "type", "numpy.take", "out.tocsr.data.nonzero", "type", "out.tocsr.tocsc", "out.tocsr.tocsr"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "divide_rows", "(", "matrix", ",", "column", ",", "in_place", "=", "False", ")", ":", "\n", "    ", "\"\"\"Divide each row of `matrix` by the corresponding element in `column`.\n\n    The result is as follows: out[i, j] = matrix[i, j] / column[i]\n\n    Parameters\n    ----------\n    matrix : np.ndarray, scipy.sparse.csc_matrix or csr_matrix, shape (M, N)\n        The input matrix.\n    column : a 1D np.ndarray, shape (M,)\n        The column dividing `matrix`.\n    in_place : bool (optional, default False)\n        Do the computation in-place.\n\n    Returns\n    -------\n    out : same type as `matrix`\n        The result of the row-wise division.\n    \"\"\"", "\n", "if", "in_place", ":", "\n", "        ", "out", "=", "matrix", "\n", "", "else", ":", "\n", "        ", "out", "=", "matrix", ".", "copy", "(", ")", "\n", "", "if", "type", "(", "out", ")", "in", "[", "sparse", ".", "csc_matrix", ",", "sparse", ".", "csr_matrix", "]", ":", "\n", "        ", "if", "type", "(", "out", ")", "==", "sparse", ".", "csr_matrix", ":", "\n", "            ", "convert_to_csr", "=", "True", "\n", "out", "=", "out", ".", "tocsc", "(", ")", "\n", "", "else", ":", "\n", "            ", "convert_to_csr", "=", "False", "\n", "", "column_repeated", "=", "np", ".", "take", "(", "column", ",", "out", ".", "indices", ")", "\n", "nz", "=", "out", ".", "data", ".", "nonzero", "(", ")", "\n", "out", ".", "data", "[", "nz", "]", "/=", "column_repeated", "[", "nz", "]", "\n", "if", "convert_to_csr", ":", "\n", "            ", "out", "=", "out", ".", "tocsr", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "out", "/=", "column", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.divide_columns": [[1052, 1089], ["matrix.copy", "type", "numpy.take", "out.tocsc.data.nonzero", "type", "out.tocsc.tocsr", "out.tocsc.tocsc"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "divide_columns", "(", "matrix", ",", "row", ",", "in_place", "=", "False", ")", ":", "\n", "    ", "\"\"\"Divide each column of `matrix` by the corresponding element in `row`.\n\n    The result is as follows: out[i, j] = matrix[i, j] / row[j]\n\n    Parameters\n    ----------\n    matrix : np.ndarray, scipy.sparse.csc_matrix or csr_matrix, shape (M, N)\n        The input matrix.\n    column : a 1D np.ndarray, shape (N,)\n        The row dividing `matrix`.\n    in_place : bool (optional, default False)\n        Do the computation in-place.\n\n    Returns\n    -------\n    out : same type as `matrix`\n        The result of the row-wise division.\n    \"\"\"", "\n", "if", "in_place", ":", "\n", "        ", "out", "=", "matrix", "\n", "", "else", ":", "\n", "        ", "out", "=", "matrix", ".", "copy", "(", ")", "\n", "", "if", "type", "(", "out", ")", "in", "[", "sparse", ".", "csc_matrix", ",", "sparse", ".", "csr_matrix", "]", ":", "\n", "        ", "if", "type", "(", "out", ")", "==", "sparse", ".", "csc_matrix", ":", "\n", "            ", "convert_to_csc", "=", "True", "\n", "out", "=", "out", ".", "tocsr", "(", ")", "\n", "", "else", ":", "\n", "            ", "convert_to_csc", "=", "False", "\n", "", "row_repeated", "=", "np", ".", "take", "(", "row", ",", "out", ".", "indices", ")", "\n", "nz", "=", "out", ".", "data", ".", "nonzero", "(", ")", "\n", "out", ".", "data", "[", "nz", "]", "/=", "row_repeated", "[", "nz", "]", "\n", "if", "convert_to_csc", ":", "\n", "            ", "out", "=", "out", ".", "tocsc", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "out", "/=", "row", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi_tables": [[1091, 1144], ["numpy.array().ravel", "numpy.array().ravel", "numpy.zeros", "xlogx().sum().ravel", "numpy.zeros", "xlogx().sum().ravel", "evaluate.contingency_table", "float", "np.array().ravel.nonzero", "np.array().ravel.nonzero", "numpy.shape", "numpy.shape", "list", "cont.sum", "numpy.array", "numpy.array", "xlogx().sum", "xlogx().sum", "map", "contingency_table.sum", "contingency_table.sum", "evaluate.xlogx", "evaluate.xlogx", "evaluate.divide_rows", "evaluate.divide_columns"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.xlogx", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.xlogx", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.divide_rows", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.divide_columns"], ["", "def", "vi_tables", "(", "x", ",", "y", "=", "None", ",", "ignore_x", "=", "[", "0", "]", ",", "ignore_y", "=", "[", "0", "]", ")", ":", "\n", "    ", "\"\"\"Return probability tables used for calculating VI.\n\n    If y is None, x is assumed to be a contingency table.\n\n    Parameters\n    ----------\n    x, y : np.ndarray\n        Either x and y are provided as equal-shaped np.ndarray label fields\n        (int type), or y is not provided and x is a contingency table\n        (sparse.csc_matrix) that may or may not sum to 1.\n    ignore_x, ignore_y : list of int, optional\n        Rows and columns (respectively) to ignore in the contingency table.\n        These are labels that are not counted when evaluating VI.\n\n    Returns\n    -------\n    pxy : sparse.csc_matrix of float\n        The normalized contingency table.\n    px, py, hxgy, hygx, lpygx, lpxgy : np.ndarray of float\n        The proportions of each label in `x` and `y` (`px`, `py`), the\n        per-segment conditional entropies of `x` given `y` and vice-versa, the\n        per-segment conditional probability p log p.\n    \"\"\"", "\n", "if", "y", "is", "not", "None", ":", "\n", "        ", "pxy", "=", "contingency_table", "(", "x", ",", "y", ",", "ignore_seg", "=", "ignore_x", ",", "ignore_gt", "=", "ignore_y", ")", "\n", "", "else", ":", "\n", "        ", "cont", "=", "x", "\n", "total", "=", "float", "(", "cont", ".", "sum", "(", ")", ")", "\n", "# normalize, since it is an identity op if already done", "\n", "pxy", "=", "cont", "/", "total", "\n", "\n", "# Calculate probabilities", "\n", "", "px", "=", "np", ".", "array", "(", "pxy", ".", "sum", "(", "axis", "=", "1", ")", ")", ".", "ravel", "(", ")", "\n", "py", "=", "np", ".", "array", "(", "pxy", ".", "sum", "(", "axis", "=", "0", ")", ")", ".", "ravel", "(", ")", "\n", "# Remove zero rows/cols", "\n", "nzx", "=", "px", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "nzy", "=", "py", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "nzpx", "=", "px", "[", "nzx", "]", "\n", "nzpy", "=", "py", "[", "nzy", "]", "\n", "nzpxy", "=", "pxy", "[", "nzx", ",", ":", "]", "[", ":", ",", "nzy", "]", "\n", "\n", "# Calculate log conditional probabilities and entropies", "\n", "lpygx", "=", "np", ".", "zeros", "(", "np", ".", "shape", "(", "px", ")", ")", "\n", "lpygx", "[", "nzx", "]", "=", "xlogx", "(", "divide_rows", "(", "nzpxy", ",", "nzpx", ")", ")", ".", "sum", "(", "axis", "=", "1", ")", ".", "ravel", "(", ")", "\n", "# \\sum_x{p_{y|x} \\log{p_{y|x}}}", "\n", "hygx", "=", "-", "(", "px", "*", "lpygx", ")", "# \\sum_x{p_x H(Y|X=x)} = H(Y|X)", "\n", "\n", "lpxgy", "=", "np", ".", "zeros", "(", "np", ".", "shape", "(", "py", ")", ")", "\n", "lpxgy", "[", "nzy", "]", "=", "xlogx", "(", "divide_columns", "(", "nzpxy", ",", "nzpy", ")", ")", ".", "sum", "(", "axis", "=", "0", ")", ".", "ravel", "(", ")", "\n", "hxgy", "=", "-", "(", "py", "*", "lpxgy", ")", "\n", "\n", "return", "[", "pxy", "]", "+", "list", "(", "map", "(", "np", ".", "asarray", ",", "[", "px", ",", "py", ",", "hxgy", ",", "hygx", ",", "lpygx", ",", "lpxgy", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.sorted_vi_components": [[1146, 1186], ["evaluate.vi_tables", "skimage.segmentation.relabel_sequential", "skimage.segmentation.relabel_sequential"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi_tables"], ["", "def", "sorted_vi_components", "(", "s1", ",", "s2", ",", "ignore1", "=", "[", "0", "]", ",", "ignore2", "=", "[", "0", "]", ",", "compress", "=", "False", ")", ":", "\n", "    ", "\"\"\"Return lists of the most entropic segments in s1|s2 and s2|s1.\n\n    Parameters\n    ----------\n    s1, s2 : np.ndarray of int\n        Segmentations to be compared. Usually, `s1` will be a candidate\n        segmentation and `s2` will be the ground truth or target segmentation.\n    ignore1, ignore2 : list of int, optional\n        Labels in these lists are ignored in computing the VI. 0-labels are\n        ignored by default; pass empty lists to use all labels.\n    compress : bool, optional\n        The 'compress' flag performs a remapping of the labels before doing\n        the VI computation, resulting in memory savings when many labels are\n        not used in the volume. (For example, if you have just two labels, 1\n        and 1,000,000, 'compress=False' will give a vector of length\n        1,000,000, whereas with 'compress=True' it will have just size 2.)\n\n    Returns\n    -------\n    ii1 : np.ndarray of int\n        The labels in `s2` having the most entropy. If `s1` is the automatic\n        segmentation, these are the worst false merges.\n    h2g1 : np.ndarray of float\n        The conditional entropy corresponding to the labels in `ii1`.\n    ii2 : np.ndarray of int (seg)\n        The labels in `s1` having the most entropy. These correspond to the\n        worst false splits.\n    h2g1 : np.ndarray of float\n        The conditional entropy corresponding to the labels in `ii2`.\n    \"\"\"", "\n", "if", "compress", ":", "\n", "        ", "s1", ",", "forw1", ",", "back1", "=", "relabel_sequential", "(", "s1", ")", "\n", "s2", ",", "forw2", ",", "back2", "=", "relabel_sequential", "(", "s2", ")", "\n", "", "_", ",", "_", ",", "_", ",", "h1g2", ",", "h2g1", ",", "_", ",", "_", "=", "vi_tables", "(", "s1", ",", "s2", ",", "ignore1", ",", "ignore2", ")", "\n", "i1", "=", "(", "-", "h1g2", ")", ".", "argsort", "(", ")", "\n", "i2", "=", "(", "-", "h2g1", ")", ".", "argsort", "(", ")", "\n", "ii1", "=", "back1", "[", "i1", "]", "if", "compress", "else", "i1", "\n", "ii2", "=", "back2", "[", "i2", "]", "if", "compress", "else", "i2", "\n", "return", "ii1", ",", "h1g2", "[", "i1", "]", ",", "ii2", ",", "h2g1", "[", "i2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.split_components": [[1188, 1223], ["numpy.asarray().ravel", "numpy.asarray().ravel", "[].toarray().ravel", "[].toarray().ravel", "list", "zip", "numpy.asarray", "numpy.asarray", "[].toarray", "[].toarray", "cont.sum", "cont.sum", "evaluate.divide_rows", "evaluate.divide_columns"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.divide_rows", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.divide_columns"], ["", "def", "split_components", "(", "idx", ",", "cont", ",", "num_elems", "=", "4", ",", "axis", "=", "0", ")", ":", "\n", "    ", "\"\"\"Return the indices of the bodies most overlapping with body idx.\n\n    Parameters\n    ----------\n    idx : int\n        The segment index being examined.\n    cont : sparse.csc_matrix\n        The normalized contingency table.\n    num_elems : int, optional\n        The number of overlapping bodies desired.\n    axis : int, optional\n        The axis along which to perform the calculations. Assuming `cont` has\n        the automatic segmentation as the rows and the gold standard as the\n        columns, `axis=0` will return the segment IDs in the gold standard of\n        the worst merges comprising `idx`, while `axis=1` will return the\n        segment IDs in the automatic segmentation of the worst splits\n        comprising `idx`.\n\n    Value:\n    comps : list of (int, float, float) tuples\n        `num_elems` indices of the biggest overlaps comprising `idx`, along\n        with the percent of `idx` that they comprise and the percent of\n        themselves that overlaps with `idx`.\n    \"\"\"", "\n", "if", "axis", "==", "1", ":", "\n", "        ", "cont", "=", "cont", ".", "T", "\n", "", "x_sizes", "=", "np", ".", "asarray", "(", "cont", ".", "sum", "(", "axis", "=", "1", ")", ")", ".", "ravel", "(", ")", "\n", "y_sizes", "=", "np", ".", "asarray", "(", "cont", ".", "sum", "(", "axis", "=", "0", ")", ")", ".", "ravel", "(", ")", "\n", "cc", "=", "divide_rows", "(", "cont", ",", "x_sizes", ")", "[", "idx", "]", ".", "toarray", "(", ")", ".", "ravel", "(", ")", "\n", "cct", "=", "divide_columns", "(", "cont", ",", "y_sizes", ")", "[", "idx", "]", ".", "toarray", "(", ")", ".", "ravel", "(", ")", "\n", "idxs", "=", "(", "-", "cc", ")", ".", "argsort", "(", ")", "[", ":", "num_elems", "]", "\n", "probs", "=", "cc", "[", "idxs", "]", "\n", "probst", "=", "cct", "[", "idxs", "]", "\n", "return", "list", "(", "zip", "(", "idxs", ",", "probs", ",", "probst", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.rand_values": [[1225, 1266], ["cont_table.sum", "cont_table.multiply().sum", "cont_table.multiply", "numpy.asarray", "numpy.asarray", "cont_table.sum", "cont_table.sum"], "function", ["None"], ["", "def", "rand_values", "(", "cont_table", ")", ":", "\n", "    ", "\"\"\"Calculate values for Rand Index and related values, e.g. Adjusted Rand.\n\n    Parameters\n    ----------\n    cont_table : scipy.sparse.csc_matrix\n        A contingency table of the two segmentations.\n\n    Returns\n    -------\n    a, b, c, d : float\n        The values necessary for computing Rand Index and related values. [1, 2]\n    a : float\n        Refers to the number of pairs of elements in the input image that are\n        both the same in seg1 and in seg2,\n    b : float\n        Refers to the number of pairs of elements in the input image that are\n        different in both seg1 and in seg2.\n    c : float\n        Refers to the number of pairs of elements in the input image that are\n        the same in seg1 but different in seg2.\n    d : float\n        Refers to the number of pairs of elements in the input image that are\n        different in seg1 but the same in seg2.\n\n\n    References\n    ----------\n    [1] Rand, W. M. (1971). Objective criteria for the evaluation of\n    clustering methods. J Am Stat Assoc.\n    [2] http://en.wikipedia.org/wiki/Rand_index#Definition on 2013-05-16.\n    \"\"\"", "\n", "n", "=", "cont_table", ".", "sum", "(", ")", "\n", "sum1", "=", "(", "cont_table", ".", "multiply", "(", "cont_table", ")", ")", ".", "sum", "(", ")", "\n", "sum2", "=", "(", "np", ".", "asarray", "(", "cont_table", ".", "sum", "(", "axis", "=", "1", ")", ")", "**", "2", ")", ".", "sum", "(", ")", "\n", "sum3", "=", "(", "np", ".", "asarray", "(", "cont_table", ".", "sum", "(", "axis", "=", "0", ")", ")", "**", "2", ")", ".", "sum", "(", ")", "\n", "a", "=", "(", "sum1", "-", "n", ")", "/", "2.0", ";", "\n", "b", "=", "(", "sum2", "-", "sum1", ")", "/", "2", "\n", "c", "=", "(", "sum3", "-", "sum1", ")", "/", "2", "\n", "d", "=", "(", "sum1", "+", "n", "**", "2", "-", "sum2", "-", "sum3", ")", "/", "2", "\n", "return", "a", ",", "b", ",", "c", ",", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.rand_index": [[1268, 1291], ["evaluate.rand_values", "evaluate.contingency_table"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.rand_values", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["", "def", "rand_index", "(", "x", ",", "y", "=", "None", ")", ":", "\n", "    ", "\"\"\"Return the unadjusted Rand index. [1]\n\n    Parameters\n    ----------\n    x, y : np.ndarray\n        Either x and y are provided as equal-shaped np.ndarray label fields\n        (int type), or y is not provided and x is a contingency table\n        (sparse.csc_matrix) that is *not* normalised to sum to 1.\n\n    Returns\n    -------\n    ri : float\n        The Rand index of `x` and `y`.\n\n    References\n    ----------\n    [1] WM Rand. (1971) Objective criteria for the evaluation of\n    clustering methods. J Am Stat Assoc. 66: 846\u2013850\n    \"\"\"", "\n", "cont", "=", "x", "if", "y", "is", "None", "else", "contingency_table", "(", "x", ",", "y", ",", "norm", "=", "False", ")", "\n", "a", ",", "b", ",", "c", ",", "d", "=", "rand_values", "(", "cont", ")", "\n", "return", "(", "a", "+", "d", ")", "/", "(", "a", "+", "b", "+", "c", "+", "d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.adj_rand_index": [[1293, 1318], ["evaluate.rand_values", "evaluate.contingency_table"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.rand_values", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["", "def", "adj_rand_index", "(", "x", ",", "y", "=", "None", ")", ":", "\n", "    ", "\"\"\"Return the adjusted Rand index.\n\n    The Adjusted Rand Index (ARI) is the deviation of the Rand Index from the\n    expected value if the marginal distributions of the contingency table were\n    independent. Its value ranges from 1 (perfectly correlated marginals) to\n    -1 (perfectly anti-correlated).\n\n    Parameters\n    ----------\n    x, y : np.ndarray\n        Either x and y are provided as equal-shaped np.ndarray label fields\n        (int type), or y is not provided and x is a contingency table\n        (sparse.csc_matrix) that is *not* normalised to sum to 1.\n\n    Returns\n    -------\n    ari : float\n        The adjusted Rand index of `x` and `y`.\n    \"\"\"", "\n", "cont", "=", "x", "if", "y", "is", "None", "else", "contingency_table", "(", "x", ",", "y", ",", "norm", "=", "False", ")", "\n", "a", ",", "b", ",", "c", ",", "d", "=", "rand_values", "(", "cont", ")", "\n", "nk", "=", "a", "+", "b", "+", "c", "+", "d", "\n", "return", "(", "nk", "*", "(", "a", "+", "d", ")", "-", "(", "(", "a", "+", "b", ")", "*", "(", "a", "+", "c", ")", "+", "(", "c", "+", "d", ")", "*", "(", "b", "+", "d", ")", ")", ")", "/", "(", "\n", "nk", "**", "2", "-", "(", "(", "a", "+", "b", ")", "*", "(", "a", "+", "c", ")", "+", "(", "c", "+", "d", ")", "*", "(", "b", "+", "d", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.fm_index": [[1320, 1343], ["evaluate.rand_values", "evaluate.contingency_table", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.rand_values", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["", "def", "fm_index", "(", "x", ",", "y", "=", "None", ")", ":", "\n", "    ", "\"\"\"Return the Fowlkes-Mallows index. [1]\n\n    Parameters\n    ----------\n    x, y : np.ndarray\n        Either x and y are provided as equal-shaped np.ndarray label fields\n        (int type), or y is not provided and x is a contingency table\n        (sparse.csc_matrix) that is *not* normalised to sum to 1.\n\n    Returns\n    -------\n    fm : float\n        The FM index of `x` and `y`. 1 is perfect agreement.\n\n    References\n    ----------\n    [1] EB Fowlkes & CL Mallows. (1983) A method for comparing two\n    hierarchical clusterings. J Am Stat Assoc 78: 553\n    \"\"\"", "\n", "cont", "=", "x", "if", "y", "is", "None", "else", "contingency_table", "(", "x", ",", "y", ",", "norm", "=", "False", ")", "\n", "a", ",", "b", ",", "c", ",", "d", "=", "rand_values", "(", "cont", ")", "\n", "return", "a", "/", "(", "np", ".", "sqrt", "(", "(", "a", "+", "b", ")", "*", "(", "a", "+", "c", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.reduce_vi": [[1345, 1391], ["numpy.arange", "list", "numpy.zeros", "numpy.zeros", "enumerate", "enumerate", "itertools.permutations", "len", "len", "range", "h5py.File", "tuple", "logging.warning", "h5py.File.close", "numpy.array", "logging.warning", "logging.warning"], "function", ["None"], ["", "def", "reduce_vi", "(", "fn_pattern", "=", "'testing/%i/flat-single-channel-tr%i-%i-%.2f.lzf.h5'", ",", "\n", "iterable", "=", "[", "(", "ts", ",", "tr", ",", "ts", ")", "for", "ts", ",", "tr", "in", "it", ".", "permutations", "(", "range", "(", "8", ")", ",", "2", ")", "]", ",", "\n", "thresholds", "=", "np", ".", "arange", "(", "0", ",", "1.01", ",", "0.01", ")", ")", ":", "\n", "    ", "\"\"\"Compile evaluation results embedded in many .h5 files under \"vi\".\n\n    Parameters\n    ----------\n    fn_pattern : string, optional\n        A format string defining the files to be examined.\n    iterable : iterable of tuples, optional\n        The (partial) tuples to apply to the format string to obtain\n        individual files.\n    thresholds : iterable of float, optional\n        The final tuple elements to apply to the format string. The final\n        tuples are the product of `iterable` and `thresholds`.\n\n    Returns\n    -------\n    vi : np.ndarray of float, shape (3, len(thresholds))\n        The under and over segmentation components of VI at each threshold.\n        `vi[0, :]` is the threshold, `vi[1, :]` the undersegmentation and\n        `vi[2, :]` is the oversegmentation.\n    \"\"\"", "\n", "iterable", "=", "list", "(", "iterable", ")", "\n", "vi", "=", "np", ".", "zeros", "(", "(", "3", ",", "len", "(", "thresholds", ")", ",", "len", "(", "iterable", ")", ")", ",", "np", ".", "double", ")", "\n", "current_vi", "=", "np", ".", "zeros", "(", "3", ")", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "        ", "for", "j", ",", "v", "in", "enumerate", "(", "iterable", ")", ":", "\n", "            ", "current_fn", "=", "fn_pattern", "%", "(", "tuple", "(", "v", ")", "+", "(", "t", ",", ")", ")", "\n", "try", ":", "\n", "                ", "f", "=", "h5py", ".", "File", "(", "current_fn", ",", "'r'", ")", "\n", "", "except", "IOError", ":", "\n", "                ", "logging", ".", "warning", "(", "'IOError: could not open file %s'", "%", "current_fn", ")", "\n", "", "else", ":", "\n", "                ", "try", ":", "\n", "                    ", "current_vi", "=", "np", ".", "array", "(", "f", "[", "'vi'", "]", ")", "[", ":", ",", "0", "]", "\n", "", "except", "IOError", ":", "\n", "                    ", "logging", ".", "warning", "(", "'IOError: could not open file %s'", "\n", "%", "current_fn", ")", "\n", "", "except", "KeyError", ":", "\n", "                    ", "logging", ".", "warning", "(", "'KeyError: could not find vi in file %s'", "\n", "%", "current_fn", ")", "\n", "", "finally", ":", "\n", "                    ", "f", ".", "close", "(", ")", "\n", "", "", "vi", "[", ":", ",", "i", ",", "j", "]", "+=", "current_vi", "\n", "", "", "return", "vi", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.sem": [[1393, 1413], ["ar.ravel.ravel", "numpy.std", "numpy.sqrt"], "function", ["None"], ["", "def", "sem", "(", "ar", ",", "axis", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate the standard error of the mean (SEM) along an axis.\n\n    Parameters\n    ----------\n    ar : np.ndarray\n        The input array of values.\n    axis : int, optional\n        Calculate SEM along the given axis. If omitted, calculate along the\n        raveled array.\n\n    Returns\n    -------\n    sem : float or np.ndarray of float\n        The SEM over the whole array (if `axis=None`) or over the chosen axis.\n    \"\"\"", "\n", "if", "axis", "is", "None", ":", "\n", "        ", "ar", "=", "ar", ".", "ravel", "(", ")", "\n", "axis", "=", "0", "\n", "", "return", "np", ".", "std", "(", "ar", ",", "axis", "=", "axis", ")", "/", "np", ".", "sqrt", "(", "ar", ".", "shape", "[", "axis", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi_statistics": [[1415, 1431], ["numpy.mean", "evaluate.sem", "numpy.median"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.sem"], ["", "def", "vi_statistics", "(", "vi_table", ")", ":", "\n", "    ", "\"\"\"Descriptive statistics from a block of related VI evaluations.\n\n    Parameters\n    ----------\n    vi_table : np.ndarray of float\n        An array containing VI evaluations of various samples. The last axis\n        represents the samples.\n\n    Returns\n    -------\n    means, sems, medians : np.ndarrays of float\n        The statistics of the given array along the samples axis.\n    \"\"\"", "\n", "return", "np", ".", "mean", "(", "vi_table", ",", "axis", "=", "-", "1", ")", ",", "sem", "(", "vi_table", ",", "axis", "=", "-", "1", ")", ",", "np", ".", "median", "(", "vi_table", ",", "axis", "=", "-", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.image_stack_verify": [[11, 15], ["os.path.exists", "Exception"], "function", ["None"], ["def", "image_stack_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "test_stack", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "test_stack", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Image volume does not exist at \"", "+", "options", ".", "test_stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.image_stack_verify2": [[16, 20], ["os.path.exists", "Exception"], "function", ["None"], ["", "", "", "def", "image_stack_verify2", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "gt_stack", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "gt_stack", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Image volume does not exist at \"", "+", "options", ".", "gt_stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.graph_file_verify": [[21, 25], ["os.path.exists", "Exception"], "function", ["None"], ["", "", "", "def", "graph_file_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "ragprob_file", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "ragprob_file", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"ragprob file not found \"", "+", "options", ".", "ragprob_file", "+", "\" not found\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.create_valprob_options": [[26, 42], ["options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option"], ["", "", "", "def", "create_valprob_options", "(", "options_parser", ")", ":", "\n", "    ", "options_parser", ".", "create_option", "(", "\"test-stack\"", ",", "\"initial segmentation (to any percentage)\"", ",", "\n", "required", "=", "True", ",", "verify_fn", "=", "image_stack_verify", ",", "\n", "shortcut", "=", "'T'", ",", "warning", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"gt-stack\"", ",", "\"ground truth stack (~100 percent complete)\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "True", ",", "dtype", "=", "str", ",", "verify_fn", "=", "image_stack_verify2", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'G'", ",", "warning", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"ragprob-file\"", ",", "\"RAG probability file\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "True", ",", "dtype", "=", "str", ",", "verify_fn", "=", "graph_file_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'R'", ",", "warning", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"size-threshold\"", ",", "\"Number of voxels used in threshold\"", ",", "\n", "default_val", "=", "25000", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'ST'", ",", "warning", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.load_graph_json": [[43, 57], ["open", "json.load", "pairprob_list.append"], "function", ["None"], ["", "def", "load_graph_json", "(", "json_file", ")", ":", "\n", "    ", "json_file_handle", "=", "open", "(", "json_file", ")", "\n", "json_data", "=", "json", ".", "load", "(", "json_file_handle", ")", "\n", "\n", "pairprob_list", "=", "[", "]", "\n", "for", "edge", "in", "json_data", "[", "\"edge_list\"", "]", ":", "\n", "        ", "node1", "=", "edge", "[", "\"node1\"", "]", "\n", "node2", "=", "edge", "[", "\"node2\"", "]", "\n", "if", "node1", ">", "node2", ":", "\n", "            ", "node2", ",", "node1", "=", "node1", ",", "node2", "\n", "", "weight", "=", "edge", "[", "\"weight\"", "]", "\n", "pairprob_list", ".", "append", "(", "(", "node1", ",", "node2", ",", "weight", ")", ")", "\n", "\n", "", "return", "pairprob_list", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.find_gt_bodies": [[58, 76], ["numpy.ndenumerate", "body2indices.items", "body2indices.setdefault", "body2indices[].setdefault", "val.items"], "function", ["None"], ["", "def", "find_gt_bodies", "(", "gt_stack", ",", "test_stack", ")", ":", "\n", "    ", "body2indices", "=", "{", "}", "\n", "for", "index", ",", "value", "in", "numpy", ".", "ndenumerate", "(", "test_stack", ")", ":", "\n", "        ", "body2indices", ".", "setdefault", "(", "value", ",", "{", "}", ")", "\n", "value2", "=", "gt_stack", "[", "index", "]", "\n", "body2indices", "[", "value", "]", ".", "setdefault", "(", "value2", ",", "0", ")", "\n", "(", "body2indices", "[", "value", "]", ")", "[", "value2", "]", "+=", "1", "\n", "\n", "", "body2gtbody", "=", "{", "}", "\n", "for", "key", ",", "val", "in", "body2indices", ".", "items", "(", ")", ":", "\n", "        ", "max_val", "=", "0", "\n", "max_id", "=", "0", "\n", "for", "key2", ",", "val2", "in", "val", ".", "items", "(", ")", ":", "\n", "            ", "if", "val2", ">", "max_val", ":", "\n", "                ", "max_val", "=", "val2", "\n", "max_id", "=", "key2", "\n", "", "", "body2gtbody", "[", "key", "]", "=", "max_id", "\n", "", "return", "body2gtbody", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.process_edge": [[77, 103], ["libNeuroProofPriority.get_next_edge", "libNeuroProofPriority.get_edge_val", "libNeuroProofPriority.set_edge_result", "dirtybodies.add", "bodyremap[].extend", "int", "int", "int", "int"], "function", ["None"], ["", "def", "process_edge", "(", "body2gtbody", ",", "nomerge_hist", ",", "tot_hist", ",", "nomerge_hist2", ",", "tot_hist2", ",", "dirtybodies", ",", "bodyremap", ")", ":", "\n", "    ", "priority", "=", "neuroproof", ".", "get_next_edge", "(", ")", "\n", "(", "body1", ",", "body2", ")", "=", "priority", ".", "body_pair", "\n", "weight", "=", "neuroproof", ".", "get_edge_val", "(", "priority", ")", "\n", "\n", "if", "body1", "not", "in", "dirtybodies", "and", "body2", "not", "in", "dirtybodies", ":", "\n", "        ", "tot_hist", "[", "int", "(", "weight", "*", "100", ")", "]", "+=", "1", "\n", "", "tot_hist2", "[", "int", "(", "weight", "*", "100", ")", "]", "+=", "1", "\n", "link", "=", "True", "\n", "if", "body2gtbody", "[", "body1", "]", "!=", "body2gtbody", "[", "body2", "]", ":", "\n", "        ", "if", "body1", "not", "in", "dirtybodies", "and", "body2", "not", "in", "dirtybodies", ":", "\n", "            ", "nomerge_hist", "[", "int", "(", "weight", "*", "100", ")", "]", "+=", "1", "\n", "", "nomerge_hist2", "[", "int", "(", "weight", "*", "100", ")", "]", "+=", "1", "\n", "link", "=", "False", "\n", "", "else", ":", "\n", "        ", "if", "body2", "not", "in", "bodyremap", ":", "\n", "            ", "bodyremap", "[", "body2", "]", "=", "[", "body2", "]", "\n", "", "if", "body1", "not", "in", "bodyremap", ":", "\n", "            ", "bodyremap", "[", "body1", "]", "=", "[", "body1", "]", "\n", "\n", "", "dirtybodies", ".", "add", "(", "body1", ")", "\n", "bodyremap", "[", "body1", "]", ".", "extend", "(", "bodyremap", "[", "body2", "]", ")", "\n", "del", "bodyremap", "[", "body2", "]", "\n", "\n", "\n", "", "neuroproof", ".", "set_edge_result", "(", "priority", ".", "body_pair", ",", "link", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.auto_proofread": [[105, 180], ["set", "range", "libNeuroProofPriority.initialize_priority_scheduler", "libNeuroProofPriority.set_body_mode", "libNeuroProofPriority.set_synapse_mode", "libNeuroProofPriority.set_orphan_mode", "master_logger.info", "range", "master_logger.info", "range", "bodyremap.items", "os.system", "os.system", "open", "open", "open.readlines", "master_logger.info", "master_logger.info", "master_logger.info", "master_logger.info", "nomerge_hist.append", "tot_hist.append", "nomerge_hist2.append", "tot_hist2.append", "libNeuroProofPriority.get_estimated_num_remaining_edges", "valprob.process_edge", "libNeuroProofPriority.get_estimated_num_remaining_edges", "valprob.process_edge", "libNeuroProofPriority.get_estimated_num_remaining_edges", "valprob.process_edge", "print", "print", "line.split", "int", "int", "open.write", "str", "str", "str", "str", "float", "float", "float", "float", "str", "str"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.process_edge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.process_edge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.process_edge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write"], ["", "def", "auto_proofread", "(", "body2gtbody", ",", "rag_file", ",", "size_threshold", ",", "master_logger", ",", "test_stack", ",", "session_location", ")", ":", "\n", "    ", "nomerge_hist", "=", "[", "]", "\n", "tot_hist", "=", "[", "]", "\n", "nomerge_hist2", "=", "[", "]", "\n", "tot_hist2", "=", "[", "]", "\n", "dirtybodies", "=", "set", "(", ")", "\n", "for", "iter1", "in", "range", "(", "0", ",", "101", ")", ":", "\n", "        ", "nomerge_hist", ".", "append", "(", "0", ")", "\n", "tot_hist", ".", "append", "(", "0", ")", "\n", "nomerge_hist2", ".", "append", "(", "0", ")", "\n", "tot_hist2", ".", "append", "(", "0", ")", "\n", "\n", "", "neuroproof", ".", "initialize_priority_scheduler", "(", "rag_file", ",", "0.1", ",", "0.9", ",", "0.1", ")", "\n", "\n", "bodyremap", "=", "{", "}", "\n", "\n", "num_body", "=", "0", "\n", "neuroproof", ".", "set_body_mode", "(", "size_threshold", ",", "0", ")", "\n", "while", "neuroproof", ".", "get_estimated_num_remaining_edges", "(", ")", ">", "0", ":", "\n", "        ", "process_edge", "(", "body2gtbody", ",", "nomerge_hist", ",", "tot_hist", ",", "nomerge_hist2", ",", "tot_hist2", ",", "dirtybodies", ",", "bodyremap", ")", "\n", "num_body", "+=", "1", "\n", "\n", "", "num_synapse", "=", "0", "\n", "neuroproof", ".", "set_synapse_mode", "(", "0.1", ")", "\n", "while", "neuroproof", ".", "get_estimated_num_remaining_edges", "(", ")", ">", "0", ":", "\n", "        ", "process_edge", "(", "body2gtbody", ",", "nomerge_hist", ",", "tot_hist", ",", "nomerge_hist2", ",", "tot_hist2", ",", "dirtybodies", ",", "bodyremap", ")", "\n", "num_synapse", "+=", "1", "\n", "\n", "", "num_orphan", "=", "0", "\n", "neuroproof", ".", "set_orphan_mode", "(", "size_threshold", ",", "size_threshold", ",", "size_threshold", ")", "\n", "while", "neuroproof", ".", "get_estimated_num_remaining_edges", "(", ")", ">", "0", ":", "\n", "        ", "process_edge", "(", "body2gtbody", ",", "nomerge_hist", ",", "tot_hist", ",", "nomerge_hist2", ",", "tot_hist2", ",", "dirtybodies", ",", "bodyremap", ")", "\n", "num_orphan", "+=", "1", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Probability Actual Agreement with Groundtruth Flat\"", ")", "\n", "for", "iter1", "in", "range", "(", "0", ",", "101", ")", ":", "\n", "        ", "if", "tot_hist", "[", "iter1", "]", "==", "0", ":", "\n", "            ", "per", "=", "0", "\n", "", "else", ":", "\n", "            ", "per", "=", "(", "float", "(", "nomerge_hist", "[", "iter1", "]", ")", "/", "float", "(", "tot_hist", "[", "iter1", "]", ")", "*", "100", ")", "\n", "", "print", "(", "iter1", ",", "\", \"", ",", "per", ",", "\", \"", ",", "tot_hist", "[", "iter1", "]", ")", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Probability Actual Agreement with Groundtruth Est\"", ")", "\n", "for", "iter1", "in", "range", "(", "0", ",", "101", ")", ":", "\n", "        ", "if", "tot_hist2", "[", "iter1", "]", "==", "0", ":", "\n", "            ", "per", "=", "0", "\n", "", "else", ":", "\n", "            ", "per", "=", "(", "float", "(", "nomerge_hist2", "[", "iter1", "]", ")", "/", "float", "(", "tot_hist2", "[", "iter1", "]", ")", "*", "100", ")", "\n", "", "print", "(", "iter1", ",", "\", \"", ",", "per", ",", "\", \"", ",", "tot_hist2", "[", "iter1", "]", ")", "\n", "\n", "", "body2body", "=", "{", "}", "\n", "for", "key", ",", "vallist", "in", "bodyremap", ".", "items", "(", ")", ":", "\n", "        ", "for", "body", "in", "vallist", ":", "\n", "            ", "body2body", "[", "body", "]", "=", "key", "\n", "\n", "", "", "os", ".", "system", "(", "\"cp -R \"", "+", "test_stack", "+", "\"/superpixel_maps \"", "+", "session_location", "+", "\"/\"", ")", "\n", "os", ".", "system", "(", "\"cp \"", "+", "test_stack", "+", "\"/superpixel_to_segment_map.txt \"", "+", "session_location", "+", "\"/\"", ")", "\n", "\n", "mapping_file", "=", "open", "(", "test_stack", "+", "\"/segment_to_body_map.txt\"", ")", "\n", "outfile", "=", "open", "(", "session_location", "+", "\"/segment_to_body_map.txt\"", ",", "'w'", ")", "\n", "\n", "for", "line", "in", "mapping_file", ".", "readlines", "(", ")", ":", "\n", "        ", "vals", "=", "line", ".", "split", "(", "' '", ")", "\n", "\n", "seg", "=", "int", "(", "vals", "[", "0", "]", ")", "\n", "body", "=", "int", "(", "vals", "[", "1", "]", ")", "\n", "\n", "if", "body", "in", "body2body", ":", "\n", "            ", "body", "=", "body2body", "[", "body", "]", "\n", "", "outfile", ".", "write", "(", "str", "(", "seg", ")", "+", "\" \"", "+", "str", "(", "body", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Num body: \"", "+", "str", "(", "num_body", ")", ")", "\n", "master_logger", ".", "info", "(", "\"Num synapse: \"", "+", "str", "(", "num_synapse", ")", ")", "\n", "master_logger", ".", "info", "(", "\"Num orphan: \"", "+", "str", "(", "num_orphan", ")", ")", "\n", "master_logger", ".", "info", "(", "\"Num total: \"", "+", "str", "(", "num_body", "+", "num_synapse", "+", "num_orphan", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.valprob": [[182, 218], ["master_logger.info", "imio.read_image_stack", "master_logger.info", "imio.read_image_stack", "master_logger.info", "master_logger.info", "valprob.load_graph_json", "master_logger.info", "master_logger.info", "valprob.find_gt_bodies", "master_logger.info", "range", "master_logger.info", "range", "valprob.auto_proofread", "nomerge_hist.append", "tot_hist.append", "print", "int", "int", "float", "float"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.load_graph_json", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.find_gt_bodies", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.auto_proofread"], ["", "def", "valprob", "(", "session_location", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "master_logger", ".", "info", "(", "\"Reading gt_stack\"", ")", "\n", "gt_stack", "=", "imio", ".", "read_image_stack", "(", "options", ".", "gt_stack", ")", "\n", "master_logger", ".", "info", "(", "\"Reading test_stack\"", ")", "\n", "test_stack", "=", "imio", ".", "read_image_stack", "(", "options", ".", "test_stack", ")", "\n", "master_logger", ".", "info", "(", "\"Finished reading stacks\"", ")", "\n", "\n", "\n", "master_logger", ".", "info", "(", "\"Loading graph json\"", ")", "\n", "pairprob_list", "=", "load_graph_json", "(", "options", ".", "ragprob_file", ")", "\n", "master_logger", ".", "info", "(", "\"Finished loading graph json\"", ")", "\n", "\n", "master_logger", ".", "info", "(", "\"Matching bodies to GT\"", ")", "\n", "body2gtbody", "=", "find_gt_bodies", "(", "gt_stack", ",", "test_stack", ")", "\n", "master_logger", ".", "info", "(", "\"Finished matching bodies to GT\"", ")", "\n", "\n", "nomerge_hist", "=", "[", "]", "\n", "tot_hist", "=", "[", "]", "\n", "for", "iter1", "in", "range", "(", "0", ",", "101", ")", ":", "\n", "        ", "nomerge_hist", ".", "append", "(", "0", ")", "\n", "tot_hist", ".", "append", "(", "0", ")", "\n", "\n", "", "for", "(", "node1", ",", "node2", ",", "prob", ")", "in", "pairprob_list", ":", "\n", "        ", "tot_hist", "[", "int", "(", "prob", "*", "100", ")", "]", "+=", "1", "\n", "if", "body2gtbody", "[", "node1", "]", "!=", "body2gtbody", "[", "node2", "]", ":", "\n", "            ", "nomerge_hist", "[", "int", "(", "prob", "*", "100", ")", "]", "+=", "1", "\n", "\n", "", "", "master_logger", ".", "info", "(", "\"Probability Agreement with Groundtruth\"", ")", "\n", "for", "iter1", "in", "range", "(", "0", ",", "101", ")", ":", "\n", "        ", "if", "tot_hist", "[", "iter1", "]", "==", "0", ":", "\n", "            ", "per", "=", "0", "\n", "", "else", ":", "\n", "            ", "per", "=", "(", "float", "(", "nomerge_hist", "[", "iter1", "]", ")", "/", "float", "(", "tot_hist", "[", "iter1", "]", ")", "*", "100", ")", "\n", "", "print", "(", "iter1", ",", "\", \"", ",", "per", ",", "\", \"", ",", "tot_hist", "[", "iter1", "]", ")", "\n", "\n", "", "auto_proofread", "(", "body2gtbody", ",", "options", ".", "ragprob_file", ",", "options", ".", "size_threshold", ",", "master_logger", ",", "options", ".", "test_stack", ",", "session_location", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.entrypoint": [[220, 233], ["app_logger.AppLogger", "app_logger.AppLogger.get_logger", "session_manager.Session", "valprob.valprob", "applogger.get_logger.error", "applogger.get_logger.error", "str", "str", "traceback.format_exc", "traceback.format_exc"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.get_logger", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.valprob.valprob"], ["", "def", "entrypoint", "(", "argv", ")", ":", "\n", "    ", "applogger", "=", "app_logger", ".", "AppLogger", "(", "False", ",", "'valprob'", ")", "\n", "master_logger", "=", "applogger", ".", "get_logger", "(", ")", "\n", "\n", "try", ":", "\n", "        ", "session", "=", "session_manager", ".", "Session", "(", "\"valprob\"", ",", "\"Validate the predicted probabilities against 100% groundtruth\"", ",", "\n", "master_logger", ",", "applogger", ",", "create_valprob_options", ")", "\n", "\n", "valprob", "(", "session", ".", "session_location", ",", "session", ".", "options", ",", "master_logger", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "", "except", "KeyboardInterrupt", "as", "err", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.__init__": [[6, 20], ["heapq.heapify", "len", "len", "iterprogress.StandardProgressBar", "iterprogress.NoProgressBar"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "items", "=", "[", "]", ",", "length", "=", "None", ",", "with_progress", "=", "False", ",", "\n", "prog_title", "=", "'Agglomerating... '", ")", ":", "\n", "        ", "if", "length", "is", "None", ":", "\n", "            ", "self", ".", "num_valid_items", "=", "len", "(", "items", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "num_valid_items", "=", "length", "\n", "", "self", ".", "original_length", "=", "self", ".", "num_valid_items", "\n", "self", ".", "q", "=", "items", "\n", "heapify", "(", "self", ".", "q", ")", "\n", "self", ".", "is_null_queue", "=", "len", "(", "items", ")", "==", "0", "\n", "if", "with_progress", ":", "\n", "            ", "self", ".", "pbar", "=", "StandardProgressBar", "(", "prog_title", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "pbar", "=", "NoProgressBar", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.__len__": [[21, 23], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_valid_items", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.finish": [[24, 26], ["mergequeue.MergeQueue.pbar.finish"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.finish"], ["", "def", "finish", "(", "self", ")", ":", "\n", "        ", "self", ".", "pbar", ".", "finish", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.is_empty": [[27, 29], ["len"], "methods", ["None"], ["", "def", "is_empty", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "q", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.peek": [[30, 34], ["heapq.heappop"], "methods", ["None"], ["", "def", "peek", "(", "self", ")", ":", "\n", "        ", "while", "not", "self", ".", "q", "[", "0", "]", "[", "1", "]", ":", "\n", "            ", "heappop", "(", "self", ".", "q", ")", "\n", "", "return", "self", ".", "q", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.pop": [[35, 39], ["mergequeue.MergeQueue.pbar.start", "mergequeue.MergeQueue.pop_no_start"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.pop_no_start"], ["", "def", "pop", "(", "self", ")", ":", "\n", "        ", "self", ".", "pop", "=", "self", ".", "pop_no_start", "\n", "self", ".", "pbar", ".", "start", "(", "self", ".", "original_length", ")", "\n", "return", "self", ".", "pop_no_start", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.pop_no_start": [[40, 50], ["heapq.heappop", "mergequeue.MergeQueue.invalidate", "mergequeue.MergeQueue.pbar.update_i", "heapq.heappop", "IndexError"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.invalidate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.update_i"], ["", "def", "pop_no_start", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "while", "not", "self", ".", "q", "[", "0", "]", "[", "1", "]", ":", "\n", "                ", "_", "=", "heappop", "(", "self", ".", "q", ")", "\n", "", "", "except", "IndexError", ":", "\n", "            ", "raise", "IndexError", "(", "'pop from empty merge queue'", ")", "\n", "", "item", "=", "heappop", "(", "self", ".", "q", ")", "\n", "self", ".", "invalidate", "(", "item", ")", "\n", "self", ".", "pbar", ".", "update_i", "(", "self", ".", "original_length", "-", "self", ".", "num_valid_items", ")", "\n", "return", "item", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.push": [[51, 55], ["mergequeue.MergeQueue.push_next"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.push_next"], ["", "def", "push", "(", "self", ",", "item", ")", ":", "\n", "        ", "self", ".", "is_null_queue", "=", "False", "\n", "self", ".", "push", "=", "self", ".", "push_next", "\n", "self", ".", "push_next", "(", "item", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.push_next": [[56, 59], ["heapq.heappush"], "methods", ["None"], ["", "def", "push_next", "(", "self", ",", "item", ")", ":", "\n", "        ", "heappush", "(", "self", ".", "q", ",", "item", ")", "\n", "self", ".", "num_valid_items", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.invalidate": [[60, 64], ["None"], "methods", ["None"], ["", "def", "invalidate", "(", "self", ",", "item", ")", ":", "\n", "        ", "if", "item", "[", "1", "]", ":", "\n", "            ", "self", ".", "num_valid_items", "-=", "1", "\n", "", "item", "[", "1", "]", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue._total_len": [[65, 67], ["len"], "methods", ["None"], ["", "def", "_total_len", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "q", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.filters.nd_sobel_magnitude": [[5, 29], ["image.astype.astype", "numpy.zeros_like", "enumerate", "numpy.sqrt", "numpy.ones", "scipy.ndimage.sobel"], "function", ["None"], ["def", "nd_sobel_magnitude", "(", "image", ",", "spacing", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute the magnitude of Sobel gradients along all axes.\n\n    Parameters\n    ----------\n    image : array\n        The input image.\n    spacing : list of float, optional\n        The voxel spacing along each dimension.\n\n    Returns\n    -------\n    filtered : array\n        The filtered image.\n    \"\"\"", "\n", "image", "=", "image", ".", "astype", "(", "np", ".", "float", ")", "\n", "filtered", "=", "np", ".", "zeros_like", "(", "image", ")", "\n", "if", "spacing", "is", "None", ":", "\n", "        ", "spacing", "=", "np", ".", "ones", "(", "image", ".", "ndim", ",", "np", ".", "float32", ")", "\n", "", "for", "ax", ",", "sp", "in", "enumerate", "(", "spacing", ")", ":", "\n", "        ", "axsobel", "=", "ndi", ".", "sobel", "(", "image", ",", "axis", "=", "ax", ")", "/", "sp", "\n", "filtered", "+=", "axsobel", "*", "axsobel", "\n", "", "filtered", "=", "np", ".", "sqrt", "(", "filtered", ")", "\n", "return", "filtered", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.grab_extant": [[25, 62], ["None"], "function", ["None"], ["def", "grab_extant", "(", "blocks", ",", "border", ")", ":", "\n", "    ", "smallestx", "=", "9999999", "\n", "smallesty", "=", "9999999", "\n", "smallestz", "=", "9999999", "\n", "largestx", "=", "0", "\n", "largesty", "=", "0", "\n", "largestz", "=", "0", "\n", "\n", "for", "block", "in", "blocks", ":", "\n", "        ", "pt1", "=", "block", "[", "\"near-lower-left\"", "]", "\n", "if", "pt1", "[", "0", "]", "<", "smallestx", ":", "\n", "            ", "smallestx", "=", "pt1", "[", "0", "]", "\n", "", "if", "pt1", "[", "1", "]", "<", "smallesty", ":", "\n", "            ", "smallesty", "=", "pt1", "[", "1", "]", "\n", "", "if", "pt1", "[", "2", "]", "<", "smallestz", ":", "\n", "            ", "smallestz", "=", "pt1", "[", "2", "]", "\n", "\n", "", "pt2", "=", "block", "[", "\"far-upper-right\"", "]", "\n", "if", "pt2", "[", "0", "]", ">", "largestx", ":", "\n", "            ", "largestx", "=", "pt2", "[", "0", "]", "\n", "", "if", "pt2", "[", "1", "]", ">", "largesty", ":", "\n", "            ", "largesty", "=", "pt2", "[", "1", "]", "\n", "", "if", "pt2", "[", "2", "]", ">", "largestz", ":", "\n", "            ", "largestz", "=", "pt2", "[", "2", "]", "\n", "\n", "", "", "largestx", "+=", "border", "\n", "largesty", "+=", "border", "\n", "largestz", "+=", "border", "\n", "smallestx", "-=", "border", "\n", "smallesty", "-=", "border", "\n", "smallestz", "-=", "border", "\n", "# determine image dimensions", "\n", "xsize", "=", "largestx", "-", "smallestx", "+", "1", "\n", "ysize", "=", "largesty", "-", "smallesty", "+", "1", "\n", "zsize", "=", "largestz", "-", "smallestz", "+", "1", "\n", "\n", "return", "largestx", ",", "largesty", ",", "largestz", ",", "smallestx", ",", "smallesty", ",", "smallestz", ",", "xsize", ",", "ysize", ",", "zsize", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.find_close_tbars": [[64, 127], ["set", "segmentation_stitch.grab_extant", "set", "tbar_hash.union.union", "list", "list.extend", "h5py.File", "json.loads", "str", "set.add", "datetime.datetime.utcnow", "math.sqrt", "json_data[].append"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.grab_extant"], ["", "def", "find_close_tbars", "(", "regions", ",", "proximity", ",", "border", ")", ":", "\n", "    ", "json_data", "=", "None", "\n", "tbar_hash", "=", "set", "(", ")", "\n", "\n", "blocks", "=", "None", "\n", "for", "region", "in", "regions", ":", "\n", "        ", "if", "blocks", "is", "None", ":", "\n", "            ", "blocks", "=", "list", "(", "region", ")", "\n", "", "else", ":", "\n", "            ", "blocks", ".", "extend", "(", "region", ")", "\n", "\n", "", "", "largestx", ",", "largesty", ",", "largestz", ",", "smallestx", ",", "smallesty", ",", "smallestz", ",", "xsize", ",", "ysize", ",", "zsize", "=", "grab_extant", "(", "blocks", ",", "border", ")", "\n", "\n", "for", "region", "in", "regions", ":", "\n", "        ", "tbar_hash_temp", "=", "set", "(", ")", "\n", "for", "block", "in", "region", ":", "\n", "            ", "pt1", "=", "block", "[", "\"near-lower-left\"", "]", "\n", "pt2", "=", "block", "[", "\"far-upper-right\"", "]", "\n", "startx", "=", "pt1", "[", "0", "]", "-", "smallestx", "-", "border", "\n", "starty", "=", "largesty", "-", "pt2", "[", "1", "]", "-", "border", "\n", "startz", "=", "pt1", "[", "2", "]", "-", "border", "\n", "\n", "f", "=", "h5py", ".", "File", "(", "block", "[", "'segmentation-file'", "]", ",", "'r'", ")", "\n", "if", "'synapse-annotations'", "in", "f", ":", "\n", "                ", "j_str", "=", "f", "[", "'synapse-annotations'", "]", "[", "0", "]", "\n", "block_synapse_data", "=", "json", ".", "loads", "(", "j_str", ")", "\n", "synapse_list", "=", "block_synapse_data", "[", "'data'", "]", "\n", "\n", "if", "json_data", "is", "None", ":", "\n", "                    ", "json_data", "=", "block_synapse_data", "\n", "meta", "=", "json_data", "[", "'metadata'", "]", "\n", "meta", "[", "'session path'", "]", "=", "''", "\n", "meta", "[", "'date'", "]", "=", "str", "(", "datetime", ".", "datetime", ".", "utcnow", "(", ")", ")", "\n", "meta", "[", "'computer'", "]", "=", "''", "\n", "json_data", "[", "'data'", "]", "=", "[", "]", "\n", "\n", "", "for", "synapse", "in", "synapse_list", ":", "\n", "                    ", "loc", "=", "synapse", "[", "\"T-bar\"", "]", "[", "\"location\"", "]", "\n", "x", "=", "loc", "[", "0", "]", "+", "startx", "\n", "y", "=", "loc", "[", "1", "]", "+", "starty", "\n", "z", "=", "loc", "[", "2", "]", "+", "startz", "\n", "tbar_hash_temp", ".", "add", "(", "(", "x", ",", "y", ",", "z", ")", ")", "\n", "\n", "for", "point", "in", "tbar_hash", ":", "\n", "                        ", "x2", ",", "y2", ",", "z2", "=", "point", "\n", "dist", "=", "math", ".", "sqrt", "(", "(", "x2", "-", "x", ")", "**", "2", "+", "(", "y2", "-", "y", ")", "**", "2", "+", "(", "z2", "-", "z", ")", "**", "2", ")", "\n", "if", "dist", "<=", "proximity", ":", "\n", "                            ", "synapse", "[", "\"T-bar\"", "]", "[", "\"location\"", "]", "[", "0", "]", "=", "x", "\n", "synapse", "[", "\"T-bar\"", "]", "[", "\"location\"", "]", "[", "1", "]", "=", "y", "\n", "synapse", "[", "\"T-bar\"", "]", "[", "\"location\"", "]", "[", "2", "]", "=", "z", "\n", "\n", "for", "partner", "in", "synapse", "[", "'partners'", "]", ":", "\n", "                                ", "loc", "=", "partner", "[", "'location'", "]", "\n", "partner", "[", "'location'", "]", "[", "0", "]", "=", "loc", "[", "0", "]", "+", "startx", "\n", "partner", "[", "'location'", "]", "[", "1", "]", "=", "loc", "[", "1", "]", "+", "starty", "\n", "partner", "[", "'location'", "]", "[", "2", "]", "=", "loc", "[", "2", "]", "+", "startz", "\n", "\n", "", "json_data", "[", "'data'", "]", ".", "append", "(", "synapse", ")", "\n", "break", "\n", "\n", "", "", "", "", "", "tbar_hash", "=", "tbar_hash", ".", "union", "(", "tbar_hash_temp", ")", "\n", "\n", "", "return", "json_data", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.update_filename": [[128, 136], ["re.findall", "int", "re.sub", "re.findall", "re.sub", "nums[].rstrip", "str", "str", "str"], "function", ["None"], ["", "def", "update_filename", "(", "name", ",", "md5", ")", ":", "\n", "    ", "nums", "=", "re", ".", "findall", "(", "r'\\d+\\.'", ",", "name", ")", "\n", "val", "=", "int", "(", "nums", "[", "-", "1", "]", ".", "rstrip", "(", "'.'", ")", ")", "\n", "temp_name", "=", "re", ".", "sub", "(", "r'v\\d+\\.'", ",", "str", "(", "\"v\"", "+", "str", "(", "val", "+", "1", ")", "+", "\".\"", ")", ",", "name", ")", "\n", "hashes", "=", "re", ".", "findall", "(", "r'-[0-9a-f]+-'", ",", "name", ")", "\n", "match_hash", "=", "hashes", "[", "-", "1", "]", "\n", "temp_name", "=", "re", ".", "sub", "(", "match_hash", ",", "str", "(", "\"-\"", "+", "md5", "+", "\"-\"", ")", ",", "temp_name", ")", "\n", "return", "temp_name", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.grab_pred_seg": [[138, 147], ["imio.read_image_stack", "imio.read_mapped_segmentation", "segmentation.transpose.transpose"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_mapped_segmentation"], ["", "def", "grab_pred_seg", "(", "pred_name", ",", "seg_name", ",", "border_size", ")", ":", "\n", "    ", "prediction", "=", "imio", ".", "read_image_stack", "(", "pred_name", ",", "\n", "group", "=", "PREDICTIONS_HDF5_GROUP", ")", "\n", "segmentation", "=", "imio", ".", "read_mapped_segmentation", "(", "seg_name", ")", "\n", "segmentation", "=", "segmentation", ".", "transpose", "(", "(", "2", ",", "1", ",", "0", ")", ")", "\n", "if", "border_size", ">", "0", ":", "\n", "        ", "prediction", "=", "prediction", "[", "border_size", ":", "(", "-", "1", "*", "border_size", ")", ",", "border_size", ":", "(", "-", "1", "*", "border_size", ")", ",", "border_size", ":", "(", "-", "1", "*", "border_size", ")", "]", "\n", "segmentation", "=", "segmentation", "[", "border_size", ":", "(", "-", "1", "*", "border_size", ")", ",", "border_size", ":", "(", "-", "1", "*", "border_size", ")", ",", "border_size", ":", "(", "-", "1", "*", "border_size", ")", "]", "\n", "", "return", "prediction", ",", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.examine_boundary": [[150, 395], ["range", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "range", "master_logger.info", "agglom_stack.build_border", "numpy.append", "master_logger.info", "master_logger.info", "segmentation_stitch.grab_pred_seg", "segmentation_stitch.grab_pred_seg", "b1_prediction_temp.transpose.transpose", "b1_seg_temp.transpose.transpose", "prediction_vol_temp.transpose.transpose", "b1_prediction_temp.transpose.transpose", "b1_seg_temp.transpose.transpose", "prediction_vol_temp.transpose.transpose", "b2_prediction_temp.transpose.transpose", "b2_seg_temp.transpose.transpose", "prediction_vol_temp.transpose.transpose", "b2_prediction_temp.transpose.transpose", "b2_seg_temp.transpose.transpose", "prediction_vol_temp.transpose.transpose", "master_logger.info", "morpho.remove_small_connected_components", "skimage.morphology.watershed", "master_logger.info", "agglom_stack.dilate_edges", "numpy.unique", "numpy.unique", "agglom_stack.dilate_edges", "agglom_stack.dilate_edges", "scipy.ndimage.label", "set", "range", "segmentation_stitch.examine_boundary.load_disjoint_bodies"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_border", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.grab_pred_seg", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.grab_pred_seg", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.dilate_edges", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.dilate_edges", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.dilate_edges"], ["", "def", "examine_boundary", "(", "axis", ",", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", ",", "\n", "b1pt", ",", "b2pt", ",", "b1pt2", ",", "b2pt2", ",", "block1", ",", "block2", ",", "agglom_stack", ",", "border_size", ",", "master_logger", ",", "options", ",", "\n", "all_bodies", ",", "disjoint_face_bodies", ",", "already_examined1", ",", "already_examined2", ")", ":", "\n", "    ", "overlap", "=", "False", "\n", "\n", "dimmin", "=", "[", "]", "\n", "dimmax", "=", "[", "]", "\n", "\n", "if", "b1pt", "[", "axis", "]", "==", "(", "b2pt", "[", "axis", "]", "+", "1", ")", "or", "(", "b1pt", "[", "axis", "]", "+", "1", ")", "==", "b2pt", "[", "axis", "]", ":", "\n", "        ", "overlap", "=", "True", "\n", "for", "axis2", "in", "range", "(", "0", ",", "3", ")", ":", "\n", "            ", "if", "axis2", "==", "axis", ":", "\n", "                ", "continue", "\n", "", "b1loc1", "=", "b1pt", "[", "axis2", "]", "\n", "b1loc2", "=", "b1pt2", "[", "axis2", "]", "\n", "if", "b1loc1", ">", "b1loc2", ":", "\n", "                ", "b1loc1", ",", "b1loc2", "=", "b1loc2", ",", "b1loc1", "\n", "\n", "", "b2loc1", "=", "b2pt", "[", "axis2", "]", "\n", "b2loc2", "=", "b2pt2", "[", "axis2", "]", "\n", "if", "b2loc1", ">", "b2loc2", ":", "\n", "                ", "b2loc1", ",", "b2loc2", "=", "b2loc2", ",", "b2loc1", "\n", "\n", "", "if", "b1loc1", ">", "b2loc2", "or", "b1loc2", "<", "b2loc1", ":", "\n", "                ", "overlap", "=", "False", "\n", "", "else", ":", "\n", "                ", "dimmin", ".", "append", "(", "min", "(", "b1loc1", ",", "b2loc1", ")", ")", "\n", "dimmax", ".", "append", "(", "max", "(", "b1loc2", ",", "b2loc2", ")", ")", "\n", "\n", "\n", "# if face overlaps make 2 part image", "\n", "# build RAG from 2 think image (special status for edges)", "\n", "", "", "", "if", "overlap", ":", "\n", "        ", "if", "b1_prediction", "is", "None", ":", "\n", "            ", "b1_prediction", ",", "b1_seg", "=", "grab_pred_seg", "(", "block1", "[", "\"prediction-file\"", "]", ",", "block1", "[", "\"segmentation-file\"", "]", ",", "border_size", ")", "\n", "\n", "", "if", "b2_prediction", "is", "None", ":", "\n", "            ", "b2_prediction", ",", "b2_seg", "=", "grab_pred_seg", "(", "block2", "[", "\"prediction-file\"", "]", ",", "block2", "[", "\"segmentation-file\"", "]", ",", "border_size", ")", "\n", "\n", "", "(", "xt", ",", "yt", ",", "zt", ",", "ch", ")", "=", "b1_prediction", ".", "shape", "\n", "\n", "prediction1", "=", "numpy", ".", "zeros", "(", "(", "dimmax", "[", "0", "]", "-", "dimmin", "[", "0", "]", "+", "1", ",", "dimmax", "[", "1", "]", "-", "dimmin", "[", "1", "]", "+", "1", ",", "1", ",", "ch", ")", ",", "\n", "dtype", "=", "b1_prediction", ".", "dtype", ")", "\n", "\n", "prediction_vol", "=", "numpy", ".", "zeros", "(", "(", "dimmax", "[", "0", "]", "-", "dimmin", "[", "0", "]", "+", "1", ",", "\n", "dimmax", "[", "1", "]", "-", "dimmin", "[", "1", "]", "+", "1", ",", "50", "+", "50", ",", "ch", ")", ",", "dtype", "=", "b1_prediction", ".", "dtype", ")", "\n", "\n", "prediction2", "=", "numpy", ".", "zeros", "(", "(", "dimmax", "[", "0", "]", "-", "dimmin", "[", "0", "]", "+", "1", ",", "dimmax", "[", "1", "]", "-", "dimmin", "[", "1", "]", "+", "1", ",", "1", ",", "ch", ")", ",", "\n", "dtype", "=", "b1_prediction", ".", "dtype", ")", "\n", "supervoxels1", "=", "numpy", ".", "zeros", "(", "(", "dimmax", "[", "0", "]", "-", "dimmin", "[", "0", "]", "+", "1", ",", "dimmax", "[", "1", "]", "-", "dimmin", "[", "1", "]", "+", "1", ",", "1", ")", ",", "\n", "dtype", "=", "b1_seg", ".", "dtype", ")", "\n", "supervoxels2", "=", "numpy", ".", "zeros", "(", "(", "dimmax", "[", "0", "]", "-", "dimmin", "[", "0", "]", "+", "1", ",", "dimmax", "[", "1", "]", "-", "dimmin", "[", "1", "]", "+", "1", ",", "1", ")", ",", "\n", "dtype", "=", "b1_seg", ".", "dtype", ")", "\n", "\n", "# load prediction and supervoxel slices into image", "\n", "lower", "=", "[", "]", "\n", "upper", "=", "[", "]", "\n", "lowerb", "=", "[", "]", "\n", "upperb", "=", "[", "]", "\n", "pos", "=", "0", "\n", "firstblock_first", "=", "False", "\n", "for", "axis2", "in", "range", "(", "0", ",", "3", ")", ":", "\n", "            ", "loc1", "=", "b1pt", "[", "axis2", "]", "\n", "loc2", "=", "b1pt2", "[", "axis2", "]", "\n", "if", "loc1", ">", "loc2", ":", "\n", "                ", "firstblock_first", "=", "True", "\n", "loc1", ",", "loc2", "=", "loc2", ",", "loc1", "\n", "", "if", "axis", "==", "axis2", ":", "\n", "               ", "lower", ".", "append", "(", "b1pt", "[", "axis", "]", "-", "loc1", ")", "\n", "upper", ".", "append", "(", "b1pt", "[", "axis", "]", "-", "loc1", "+", "1", ")", "\n", "", "else", ":", "\n", "               ", "lower", ".", "append", "(", "0", ")", "\n", "upper", ".", "append", "(", "loc2", "-", "loc1", "+", "1", ")", "\n", "lowerb", ".", "append", "(", "loc1", "-", "dimmin", "[", "pos", "]", ")", "\n", "upperb", ".", "append", "(", "loc2", "-", "dimmin", "[", "pos", "]", "+", "1", ")", "\n", "pos", "+=", "1", "\n", "\n", "", "", "b1_prediction_temp", "=", "b1_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "b1_seg_temp", "=", "b1_seg", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "\n", "prediction_vol_temp", "=", "None", "\n", "\n", "if", "axis", "==", "0", ":", "\n", "            ", "b1_prediction_temp", "=", "b1_prediction_temp", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ",", "3", ")", ")", "\n", "b1_seg_temp", "=", "b1_seg_temp", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "if", "lower", "[", "0", "]", "==", "0", ":", "\n", "                ", "prediction_vol_temp", "=", "b1_prediction", "[", "lower", "[", "0", "]", ":", "50", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "                ", "prediction_vol_temp", "=", "b1_prediction", "[", "upper", "[", "0", "]", "-", "50", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "", "prediction_vol_temp", "=", "prediction_vol_temp", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ",", "3", ")", ")", "\n", "", "if", "axis", "==", "1", ":", "\n", "            ", "b1_prediction_temp", "=", "b1_prediction_temp", ".", "transpose", "(", "(", "0", ",", "2", ",", "1", ",", "3", ")", ")", "\n", "b1_seg_temp", "=", "b1_seg_temp", ".", "transpose", "(", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "if", "lower", "[", "1", "]", "==", "0", ":", "\n", "                ", "prediction_vol_temp", "=", "b1_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "50", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "                ", "prediction_vol_temp", "=", "b1_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "upper", "[", "1", "]", "-", "50", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "", "prediction_vol_temp", "=", "prediction_vol_temp", ".", "transpose", "(", "(", "0", ",", "2", ",", "1", ",", "3", ")", ")", "\n", "", "if", "axis", "==", "2", ":", "\n", "            ", "if", "lower", "[", "2", "]", "==", "0", ":", "\n", "                ", "prediction_vol_temp", "=", "b1_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "50", "]", "\n", "", "else", ":", "\n", "                ", "prediction_vol_temp", "=", "b1_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "upper", "[", "2", "]", "-", "50", ":", "upper", "[", "2", "]", "]", "\n", "\n", "", "", "if", "firstblock_first", ":", "\n", "            ", "prediction_vol", "[", "lowerb", "[", "0", "]", ":", "upperb", "[", "0", "]", ",", "lowerb", "[", "1", "]", ":", "upperb", "[", "1", "]", ",", "0", ":", "50", "]", "=", "prediction_vol_temp", "\n", "", "else", ":", "\n", "            ", "prediction_vol", "[", "lowerb", "[", "0", "]", ":", "upperb", "[", "0", "]", ",", "lowerb", "[", "1", "]", ":", "upperb", "[", "1", "]", ",", "50", ":", "100", "]", "=", "prediction_vol_temp", "\n", "\n", "", "prediction1", "[", "lowerb", "[", "0", "]", ":", "upperb", "[", "0", "]", ",", "lowerb", "[", "1", "]", ":", "upperb", "[", "1", "]", "]", "=", "b1_prediction_temp", "\n", "supervoxels1", "[", "lowerb", "[", "0", "]", ":", "upperb", "[", "0", "]", ",", "lowerb", "[", "1", "]", ":", "upperb", "[", "1", "]", "]", "=", "b1_seg_temp", "\n", "\n", "lower", "=", "[", "]", "\n", "upper", "=", "[", "]", "\n", "lowerb", "=", "[", "]", "\n", "upperb", "=", "[", "]", "\n", "pos", "=", "0", "\n", "for", "axis2", "in", "range", "(", "0", ",", "3", ")", ":", "\n", "            ", "loc1", "=", "b2pt", "[", "axis2", "]", "\n", "loc2", "=", "b2pt2", "[", "axis2", "]", "\n", "if", "loc1", ">", "loc2", ":", "\n", "                ", "loc1", ",", "loc2", "=", "loc2", ",", "loc1", "\n", "", "if", "axis", "==", "axis2", ":", "\n", "               ", "lower", ".", "append", "(", "b2pt", "[", "axis", "]", "-", "loc1", ")", "\n", "upper", ".", "append", "(", "b2pt", "[", "axis", "]", "-", "loc1", "+", "1", ")", "\n", "", "else", ":", "\n", "               ", "lower", ".", "append", "(", "0", ")", "\n", "upper", ".", "append", "(", "loc2", "-", "loc1", "+", "1", ")", "\n", "lowerb", ".", "append", "(", "loc1", "-", "dimmin", "[", "pos", "]", ")", "\n", "upperb", ".", "append", "(", "loc2", "-", "dimmin", "[", "pos", "]", "+", "1", ")", "\n", "pos", "+=", "1", "\n", "\n", "", "", "b2_prediction_temp", "=", "b2_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "b2_seg_temp", "=", "b2_seg", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "\n", "if", "axis", "==", "0", ":", "\n", "            ", "b2_prediction_temp", "=", "b2_prediction_temp", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ",", "3", ")", ")", "\n", "b2_seg_temp", "=", "b2_seg_temp", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "if", "lower", "[", "0", "]", "==", "0", ":", "\n", "                ", "prediction_vol_temp", "=", "b2_prediction", "[", "lower", "[", "0", "]", ":", "50", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "                ", "prediction_vol_temp", "=", "b2_prediction", "[", "upper", "[", "0", "]", "-", "50", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "", "prediction_vol_temp", "=", "prediction_vol_temp", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ",", "3", ")", ")", "\n", "", "if", "axis", "==", "1", ":", "\n", "            ", "b2_prediction_temp", "=", "b2_prediction_temp", ".", "transpose", "(", "(", "0", ",", "2", ",", "1", ",", "3", ")", ")", "\n", "b2_seg_temp", "=", "b2_seg_temp", ".", "transpose", "(", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "if", "lower", "[", "1", "]", "==", "0", ":", "\n", "                ", "prediction_vol_temp", "=", "b2_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "50", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "", "else", ":", "\n", "                ", "prediction_vol_temp", "=", "b2_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "upper", "[", "1", "]", "-", "50", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "upper", "[", "2", "]", "]", "\n", "", "prediction_vol_temp", "=", "prediction_vol_temp", ".", "transpose", "(", "(", "0", ",", "2", ",", "1", ",", "3", ")", ")", "\n", "", "if", "axis", "==", "2", ":", "\n", "            ", "if", "lower", "[", "2", "]", "==", "0", ":", "\n", "                ", "prediction_vol_temp", "=", "b2_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "lower", "[", "2", "]", ":", "50", "]", "\n", "", "else", ":", "\n", "                ", "prediction_vol_temp", "=", "b2_prediction", "[", "lower", "[", "0", "]", ":", "upper", "[", "0", "]", ",", "lower", "[", "1", "]", ":", "upper", "[", "1", "]", ",", "upper", "[", "2", "]", "-", "50", ":", "upper", "[", "2", "]", "]", "\n", "\n", "", "", "if", "not", "firstblock_first", ":", "\n", "            ", "prediction_vol", "[", "lowerb", "[", "0", "]", ":", "upperb", "[", "0", "]", ",", "lowerb", "[", "1", "]", ":", "upperb", "[", "1", "]", ",", "0", ":", "50", "]", "=", "prediction_vol_temp", "\n", "", "else", ":", "\n", "            ", "prediction_vol", "[", "lowerb", "[", "0", "]", ":", "upperb", "[", "0", "]", ",", "lowerb", "[", "1", "]", ":", "upperb", "[", "1", "]", ",", "50", ":", "100", "]", "=", "prediction_vol_temp", "\n", "\n", "", "prediction2", "[", "lowerb", "[", "0", "]", ":", "upperb", "[", "0", "]", ",", "lowerb", "[", "1", "]", ":", "upperb", "[", "1", "]", "]", "=", "b2_prediction_temp", "\n", "supervoxels2", "[", "lowerb", "[", "0", "]", ":", "upperb", "[", "0", "]", ",", "lowerb", "[", "1", "]", ":", "upperb", "[", "1", "]", "]", "=", "b2_seg_temp", "\n", "\n", "master_logger", ".", "info", "(", "\"Examining border between \"", "+", "block1", "[", "\"segmentation-file\"", "]", "+", "\" and \"", "+", "block2", "[", "\"segmentation-file\"", "]", ")", "\n", "\n", "mask1", "=", "None", "\n", "mask2", "=", "None", "\n", "\n", "if", "options", ".", "run_watershed", ":", "\n", "# generate watershed as in gala main flow over thick boundary stuff", "\n", "            ", "master_logger", ".", "info", "(", "\"Generating watershed in boundary region\"", ")", "\n", "boundary_vol", "=", "prediction_vol", "[", "...", ",", "0", "]", "\n", "seeds", "=", "label", "(", "boundary_vol", "==", "0", ")", "[", "0", "]", "\n", "seeds", "=", "morpho", ".", "remove_small_connected_components", "(", "seeds", ",", "5", ")", "\n", "supervoxels", "=", "skmorph", ".", "watershed", "(", "boundary_vol", ",", "seeds", ")", "\n", "master_logger", ".", "info", "(", "\"Finished generating watershed in boundary region\"", ")", "\n", "\n", "# generate thick boundary in neuroproof and return volume", "\n", "supervoxels", "=", "agglom_stack", ".", "dilate_edges", "(", "supervoxels", ")", "\n", "\n", "# grab inner 2 slices and mask supervoxels (ignore if one 0) ", "\n", "# OR increase edge size to 0 when one is 0", "\n", "mask1", "=", "supervoxels", "[", ":", ",", ":", ",", "49", ":", "50", "]", "\n", "mask2", "=", "supervoxels", "[", ":", ",", ":", ",", "50", ":", "51", "]", "\n", "\n", "if", "not", "firstblock_first", ":", "\n", "                ", "mask2", "=", "supervoxels", "[", ":", ",", ":", ",", "49", ":", "50", "]", "\n", "mask1", "=", "supervoxels", "[", ":", ",", ":", ",", "50", ":", "51", "]", "\n", "\n", "# special build mode", "\n", "", "", "agglom_stack", ".", "build_border", "(", "supervoxels1", ",", "prediction1", ",", "supervoxels2", ",", "\n", "prediction2", ",", "mask1", ",", "mask2", ",", "not", "options", ".", "vertical_mode", ")", "\n", "\n", "# load disjoint block face and disjoint bodies", "\n", "body_list1", "=", "[", "]", "\n", "body_list2", "=", "[", "]", "\n", "\n", "if", "not", "already_examined1", ":", "\n", "            ", "body_list1", "=", "unique", "(", "supervoxels1", ")", "\n", "", "if", "not", "already_examined2", ":", "\n", "            ", "body_list2", "=", "unique", "(", "supervoxels2", ")", "\n", "", "body_list", "=", "numpy", ".", "append", "(", "body_list1", ",", "body_list2", ")", "\n", "\n", "master_logger", ".", "info", "(", "\"Finding disjoint bodies on one face\"", ")", "\n", "if", "not", "already_examined1", ":", "\n", "            ", "supervoxels1", "=", "agglom_stack", ".", "dilate_edges", "(", "supervoxels1", ")", "\n", "", "if", "not", "already_examined2", ":", "\n", "            ", "supervoxels2", "=", "agglom_stack", ".", "dilate_edges", "(", "supervoxels2", ")", "\n", "\n", "# run cc on supervoxels", "\n", "", "def", "load_disjoint_bodies", "(", "supervoxels0s", ",", "disjoint_bodies", ")", ":", "\n", "            ", "supervoxels_sep", ",", "num_ccs", "=", "label", "(", "supervoxels0s", ")", "\n", "bodies_found", "=", "set", "(", ")", "\n", "\n", "# find one location for each cc and add to bodies found", "\n", "for", "cc_id", "in", "range", "(", "1", ",", "num_ccs", "+", "1", ")", ":", "\n", "                ", "loc1", ",", "loc2", ",", "dummy", "=", "numpy", ".", "where", "(", "supervoxels_sep", "==", "cc_id", ")", "\n", "# hack to deal with small disjoint bodies created", "\n", "# by inadvertently pinching off small non-disjoint pieces", "\n", "if", "len", "(", "loc1", ")", "<", "5", ":", "\n", "                    ", "continue", "\n", "", "loc1", "=", "loc1", "[", "0", "]", "\n", "loc2", "=", "loc2", "[", "0", "]", "\n", "corresponding_body", "=", "supervoxels0s", "[", "loc1", ",", "loc2", ",", "0", "]", "\n", "if", "corresponding_body", "in", "bodies_found", ":", "\n", "                    ", "disjoint_bodies", ".", "add", "(", "corresponding_body", ")", "\n", "", "else", ":", "\n", "                    ", "bodies_found", ".", "add", "(", "corresponding_body", ")", "\n", "\n", "", "", "", "if", "not", "already_examined1", ":", "\n", "            ", "load_disjoint_bodies", "(", "supervoxels1", ",", "disjoint_face_bodies", ")", "\n", "", "if", "not", "already_examined2", ":", "\n", "            ", "load_disjoint_bodies", "(", "supervoxels2", ",", "disjoint_face_bodies", ")", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Finding bodies on multiple faces\"", ")", "\n", "# see if body has already been added", "\n", "for", "body", "in", "body_list", ":", "\n", "            ", "if", "body", "in", "all_bodies", ":", "\n", "                ", "disjoint_face_bodies", ".", "add", "(", "body", ")", "\n", "", "else", ":", "\n", "                ", "all_bodies", ".", "add", "(", "body", ")", "\n", "\n", "", "", "", "return", "overlap", ",", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.run_stitching": [[397, 730], ["hashlib.md5().hexdigest", "classify.load_classifier", "json.loads", "master_logger.info", "stack_np.Stack", "stack_np.Stack.set_overlap_cutoff", "stack_np.Stack.set_border_weight", "set", "set", "master_logger.info", "range", "segmentation_stitch.find_close_tbars", "master_logger.info", "stack_np.Stack.agglomerate_border", "master_logger.info", "set", "master_logger.info", "stack_np.Stack.set_overlap_cutoff", "stack_np.Stack.set_overlap_max", "stack_np.Stack.set_saved_probs", "stack_np.Stack.write_plaza_json", "open", "open.write", "open", "open.write", "range", "json.dumps", "open", "open.write", "re.findall", "str", "json.load", "regions_blocks_temp.append", "regions_blocks.append", "imio.read_image_stack", "stack_np.Stack.set_overlap_max", "stack_np.Stack.set_overlap_min", "len", "os.path.exists", "os.makedirs", "body_list.append", "json.dumps", "json.dumps", "len", "json.load", "config_data[].append", "segmentation_stitch.update_filename", "h5py.File", "numpy.array", "numpy.array", "h5py.File", "h5py.File.create_dataset", "h5py.File.create_dataset", "open", "open.write", "Exception", "hashlib.md5", "open", "Exception", "list.append", "str", "set", "range", "list", "list.extend", "master_logger.info", "segmentation_stitch.grab_pred_seg", "str", "str", "set.add", "set.add", "block_configs_orig.append", "block_configs.append", "open", "h5py.File.copy", "h5py.File.copy", "segmentation_stitch.update_filename", "json.dumps", "json.load", "len", "len", "stack_np.Stack.build_partial", "stack_np.Stack.build_partial", "stack_np.Stack.build_partial", "stack_np.Stack.build_partial", "stack_np.Stack.build_partial", "stack_np.Stack.build_partial", "stack_np.Stack.number_of_nodes", "stack_np.Stack.number_of_nodes", "int", "block_configs_orig.append", "block_configs.append", "open", "segmentation_stitch.run_stitching.already_examined"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.load_classifier", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_cutoff", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_border_weight", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.find_close_tbars", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.agglomerate_border", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_cutoff", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_max", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_saved_probs", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write_plaza_json", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_max", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.set_overlap_min", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.update_filename", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.grab_pred_seg", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.update_filename", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_partial", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_partial", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_partial", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_partial", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_partial", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.build_partial", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes"], ["", "def", "run_stitching", "(", "session_location", ",", "options", ",", "master_logger", ")", ":", "\n", "# Assumptions", "\n", "# 1.  assume global id space (unique ids between partitions)", "\n", "# 2.  segmentations will be label volumes and mappings", "\n", "# 3.  segmentations are z,y,x and predictions are x,y,z (must transpose)", "\n", "# 4.  0,0 is the lower-left corner of the image", "\n", "# 5.  assume coordinates in json is x,y,z", "\n", "\n", "# prevent stitch if hashes are different", "\n", "\n", "    ", "match_hash", "=", "None", "\n", "for", "region", "in", "options", ".", "regions", ":", "\n", "        ", "hashes", "=", "re", ".", "findall", "(", "r'-[0-9a-f]+-'", ",", "region", ")", "\n", "match_hash_temp", "=", "hashes", "[", "-", "1", "]", "\n", "if", "match_hash", "is", "not", "None", "and", "match_hash_temp", "!=", "match_hash", ":", "\n", "            ", "raise", "Exception", "(", "\"Incompatible segmentations: hashes do not match\"", ")", "\n", "", "match_hash", "=", "match_hash_temp", "\n", "\n", "", "md5_str", "=", "hashlib", ".", "md5", "(", "' '", ".", "join", "(", "sys", ".", "argv", ")", ")", ".", "hexdigest", "(", ")", "\n", "\n", "cl", "=", "classify", ".", "load_classifier", "(", "options", ".", "classifier", ")", "\n", "fm_info", "=", "json", ".", "loads", "(", "str", "(", "cl", ".", "feature_description", ")", ")", "\n", "\n", "\n", "border_size", "=", "None", "\n", "regions_blocks", "=", "[", "]", "\n", "regions_blocks_temp", "=", "[", "]", "\n", "for", "region", "in", "options", ".", "regions", ":", "\n", "        ", "blocks", "=", "[", "]", "\n", "\n", "region_json", "=", "json", ".", "load", "(", "open", "(", "region", ")", ")", "\n", "blocks_temp", "=", "region_json", "[", "\"subvolumes\"", "]", "\n", "regions_blocks_temp", ".", "append", "(", "blocks_temp", ")", "\n", "\n", "border_size_temp", "=", "region_json", "[", "\"border\"", "]", "\n", "if", "border_size", "is", "not", "None", "and", "border_size", "!=", "border_size_temp", ":", "\n", "            ", "raise", "Exception", "(", "\"border attrubute not the same in all regions\"", ")", "\n", "", "border_size", "=", "border_size_temp", "\n", "\n", "for", "block", "in", "blocks_temp", ":", "\n", "            ", "if", "'config-file'", "in", "block", ":", "\n", "                ", "config_file", "=", "block", "[", "'config-file'", "]", "\n", "config_data", "=", "json", ".", "load", "(", "open", "(", "config_file", ")", ")", "\n", "block", "=", "config_data", "[", "\"subvolumes\"", "]", "[", "0", "]", "\n", "", "blocks", ".", "append", "(", "block", ")", "\n", "", "regions_blocks", ".", "append", "(", "blocks", ")", "\n", "\n", "", "pred_probe", "=", "regions_blocks", "[", "0", "]", "[", "0", "]", "[", "'prediction-file'", "]", "\n", "\n", "num_channels", "=", "1", "\n", "if", "True", ":", "\n", "        ", "prediction", "=", "imio", ".", "read_image_stack", "(", "pred_probe", ",", "\n", "group", "=", "PREDICTIONS_HDF5_GROUP", ")", "\n", "num_channels", "=", "prediction", ".", "shape", "[", "prediction", ".", "ndim", "-", "1", "]", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Number of prediction channels: \"", "+", "str", "(", "num_channels", ")", ")", "\n", "\n", "agglom_stack", "=", "stack_np", ".", "Stack", "(", "None", ",", "None", ",", "single_channel", "=", "False", ",", "classifier", "=", "cl", ",", "feature_info", "=", "fm_info", ",", "\n", "synapse_file", "=", "None", ",", "master_logger", "=", "master_logger", ",", "num_channels", "=", "num_channels", ",", "overlap", "=", "True", ")", "\n", "agglom_stack", ".", "set_overlap_cutoff", "(", "options", ".", "overlap_threshold", ")", "\n", "agglom_stack", ".", "set_border_weight", "(", "options", ".", "border_weight_factor", ")", "\n", "\n", "if", "options", ".", "aggressive_stitch", ":", "\n", "# use the maximum overlap between the two regions as the merge criterion", "\n", "        ", "agglom_stack", ".", "set_overlap_max", "(", ")", "\n", "", "else", ":", "\n", "# use the minimum overlap between the two regions as the merge criterion", "\n", "        ", "agglom_stack", ".", "set_overlap_min", "(", ")", "\n", "\n", "", "all_bodies", "=", "set", "(", ")", "\n", "disjoint_face_bodies", "=", "set", "(", ")", "\n", "\n", "def", "already_examined", "(", "faces", ",", "face_name", ")", ":", "\n", "        ", "if", "face_name", "in", "faces", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n", "", "", "master_logger", ".", "info", "(", "\"Examining sub-blocks\"", ")", "\n", "for", "iter1", "in", "range", "(", "0", ",", "len", "(", "regions_blocks", ")", ")", ":", "\n", "        ", "region1", "=", "regions_blocks", "[", "iter1", "]", "\n", "for", "block1", "in", "region1", ":", "\n", "            ", "b1pt1", "=", "block1", "[", "\"near-lower-left\"", "]", "\n", "b1pt2", "=", "block1", "[", "\"far-upper-right\"", "]", "\n", "b1_prediction", "=", "None", "\n", "b1_seg", "=", "None", "\n", "\n", "faces", "=", "set", "(", ")", "\n", "\n", "for", "iter2", "in", "range", "(", "iter1", "+", "1", ",", "len", "(", "regions_blocks", ")", ")", ":", "\n", "                ", "region2", "=", "regions_blocks", "[", "iter2", "]", "\n", "\n", "for", "block2", "in", "region2", ":", "\n", "                    ", "b2pt1", "=", "block2", "[", "\"near-lower-left\"", "]", "\n", "b2pt2", "=", "block2", "[", "\"far-upper-right\"", "]", "\n", "\n", "b2_prediction", "=", "None", "\n", "b2_seg", "=", "None", "\n", "\n", "if", "\"faces\"", "not", "in", "block2", ":", "\n", "                        ", "block2", "[", "\"faces\"", "]", "=", "set", "(", ")", "\n", "\n", "", "already_examined1", "=", "already_examined", "(", "faces", ",", "\"yz1\"", ")", "\n", "already_examined2", "=", "already_examined", "(", "block2", "[", "\"faces\"", "]", ",", "\"yz2\"", ")", "\n", "overlap", ",", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", "=", "examine_boundary", "(", "0", ",", "\n", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", ",", "b1pt1", ",", "b2pt2", ",", "b1pt2", ",", "\n", "b2pt1", ",", "block1", ",", "block2", ",", "agglom_stack", ",", "border_size", ",", "master_logger", ",", "options", ",", "\n", "all_bodies", ",", "disjoint_face_bodies", ",", "already_examined1", ",", "already_examined2", ")", "\n", "if", "overlap", ":", "\n", "                        ", "faces", ".", "add", "(", "\"yz1\"", ")", "\n", "block2", "[", "\"faces\"", "]", ".", "add", "(", "\"yz2\"", ")", "\n", "\n", "", "already_examined1", "=", "already_examined", "(", "faces", ",", "\"xz1\"", ")", "\n", "already_examined2", "=", "already_examined", "(", "block2", "[", "\"faces\"", "]", ",", "\"xz2\"", ")", "\n", "overlap", ",", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", "=", "examine_boundary", "(", "1", ",", "\n", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", ",", "b1pt1", ",", "b2pt2", ",", "\n", "b1pt2", ",", "b2pt1", ",", "block1", ",", "block2", ",", "agglom_stack", ",", "border_size", ",", "master_logger", ",", "options", ",", "\n", "all_bodies", ",", "disjoint_face_bodies", ",", "already_examined1", ",", "already_examined2", ")", "\n", "if", "overlap", ":", "\n", "                        ", "faces", ".", "add", "(", "\"xz1\"", ")", "\n", "block2", "[", "\"faces\"", "]", ".", "add", "(", "\"xz2\"", ")", "\n", "\n", "", "already_examined1", "=", "already_examined", "(", "faces", ",", "\"xy1\"", ")", "\n", "already_examined2", "=", "already_examined", "(", "block2", "[", "\"faces\"", "]", ",", "\"xy2\"", ")", "\n", "overlap", ",", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", "=", "examine_boundary", "(", "2", ",", "\n", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", ",", "b1pt1", ",", "b2pt2", ",", "\n", "b1pt2", ",", "b2pt1", ",", "block1", ",", "block2", ",", "agglom_stack", ",", "border_size", ",", "master_logger", ",", "options", ",", "\n", "all_bodies", ",", "disjoint_face_bodies", ",", "already_examined1", ",", "already_examined2", ")", "\n", "if", "overlap", ":", "\n", "                        ", "faces", ".", "add", "(", "\"xy1\"", ")", "\n", "block2", "[", "\"faces\"", "]", ".", "add", "(", "\"xy2\"", ")", "\n", "\n", "", "already_examined1", "=", "already_examined", "(", "faces", ",", "\"yz2\"", ")", "\n", "already_examined2", "=", "already_examined", "(", "block2", "[", "\"faces\"", "]", ",", "\"yz1\"", ")", "\n", "overlap", ",", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", "=", "examine_boundary", "(", "0", ",", "\n", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", ",", "b1pt2", ",", "b2pt1", ",", "\n", "b1pt1", ",", "b2pt2", ",", "block1", ",", "block2", ",", "agglom_stack", ",", "border_size", ",", "master_logger", ",", "options", ",", "\n", "all_bodies", ",", "disjoint_face_bodies", ",", "already_examined1", ",", "already_examined2", ")", "\n", "if", "overlap", ":", "\n", "                        ", "faces", ".", "add", "(", "\"yz2\"", ")", "\n", "block2", "[", "\"faces\"", "]", ".", "add", "(", "\"yz1\"", ")", "\n", "\n", "", "already_examined1", "=", "already_examined", "(", "faces", ",", "\"xz2\"", ")", "\n", "already_examined2", "=", "already_examined", "(", "block2", "[", "\"faces\"", "]", ",", "\"xz1\"", ")", "\n", "overlap", ",", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", "=", "examine_boundary", "(", "1", ",", "\n", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", ",", "b1pt2", ",", "b2pt1", ",", "\n", "b1pt1", ",", "b2pt2", ",", "block1", ",", "block2", ",", "agglom_stack", ",", "border_size", ",", "master_logger", ",", "options", ",", "\n", "all_bodies", ",", "disjoint_face_bodies", ",", "already_examined1", ",", "already_examined2", ")", "\n", "if", "overlap", ":", "\n", "                        ", "faces", ".", "add", "(", "\"xz2\"", ")", "\n", "block2", "[", "\"faces\"", "]", ".", "add", "(", "\"xz1\"", ")", "\n", "\n", "", "already_examined1", "=", "already_examined", "(", "faces", ",", "\"xy2\"", ")", "\n", "already_examined2", "=", "already_examined", "(", "block2", "[", "\"faces\"", "]", ",", "\"xy1\"", ")", "\n", "overlap", ",", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", "=", "examine_boundary", "(", "2", ",", "\n", "b1_prediction", ",", "b1_seg", ",", "b2_prediction", ",", "b2_seg", ",", "b1pt2", ",", "b2pt1", ",", "\n", "b1pt1", ",", "b2pt2", ",", "block1", ",", "block2", ",", "agglom_stack", ",", "border_size", ",", "master_logger", ",", "options", ",", "\n", "all_bodies", ",", "disjoint_face_bodies", ",", "already_examined1", ",", "already_examined2", ")", "\n", "if", "overlap", ":", "\n", "                        ", "faces", ".", "add", "(", "\"xy2\"", ")", "\n", "block2", "[", "\"faces\"", "]", ".", "add", "(", "\"xy1\"", ")", "\n", "\n", "", "", "", "block1", "[", "\"faces\"", "]", "=", "faces", "\n", "\n", "# find all synapses that conflict by mapping to a global space and returning json data", "\n", "", "", "tbar_json", "=", "find_close_tbars", "(", "regions_blocks", ",", "options", ".", "tbar_proximity", ",", "border_size", ")", "\n", "\n", "blocks", "=", "None", "\n", "for", "region", "in", "regions_blocks", ":", "\n", "        ", "if", "blocks", "is", "None", ":", "\n", "            ", "blocks", "=", "list", "(", "region", ")", "\n", "", "else", ":", "\n", "            ", "blocks", ".", "extend", "(", "region", ")", "\n", "\n", "", "", "for", "block", "in", "blocks", ":", "\n", "        ", "faces", "=", "block", "[", "\"faces\"", "]", "\n", "\n", "if", "len", "(", "faces", ")", ">", "0", "and", "options", ".", "buffer_width", ">", "1", ":", "\n", "            ", "master_logger", ".", "info", "(", "\"Examining buffer area: \"", "+", "block", "[", "\"segmentation-file\"", "]", ")", "\n", "pred_master", ",", "seg_master", "=", "grab_pred_seg", "(", "block", "[", "\"prediction-file\"", "]", ",", "block", "[", "\"segmentation-file\"", "]", ",", "border_size", ")", "\n", "if", "\"xy1\"", "in", "faces", ":", "\n", "                ", "pred", "=", "pred_master", "[", ":", ",", ":", ",", "0", ":", "options", ".", "buffer_width", "]", "\n", "seg", "=", "seg_master", "[", ":", ",", ":", ",", "0", ":", "options", ".", "buffer_width", "]", "\n", "agglom_stack", ".", "build_partial", "(", "seg", ",", "pred", ")", "\n", "\n", "", "if", "\"xy2\"", "in", "faces", ":", "\n", "                ", "pred", "=", "pred_master", "[", ":", ",", ":", ",", "(", "-", "1", "*", "options", ".", "buffer_width", ")", ":", "]", "\n", "seg", "=", "seg_master", "[", ":", ",", ":", ",", "(", "-", "1", "*", "options", ".", "buffer_width", ")", ":", "]", "\n", "agglom_stack", ".", "build_partial", "(", "seg", ",", "pred", ")", "\n", "\n", "", "if", "\"xz1\"", "in", "faces", ":", "\n", "                ", "pred", "=", "pred_master", "[", ":", ",", "0", ":", "options", ".", "buffer_width", ",", ":", "]", "\n", "seg", "=", "seg_master", "[", ":", ",", "0", ":", "options", ".", "buffer_width", ",", ":", "]", "\n", "agglom_stack", ".", "build_partial", "(", "seg", ",", "pred", ")", "\n", "\n", "", "if", "\"xz2\"", "in", "faces", ":", "\n", "                ", "pred", "=", "pred_master", "[", ":", ",", "(", "-", "1", "*", "options", ".", "buffer_width", ")", ":", ",", ":", "]", "\n", "seg", "=", "seg_master", "[", ":", ",", "(", "-", "1", "*", "options", ".", "buffer_width", ")", ":", ",", ":", "]", "\n", "agglom_stack", ".", "build_partial", "(", "seg", ",", "pred", ")", "\n", "\n", "", "if", "\"yz1\"", "in", "faces", ":", "\n", "                ", "pred", "=", "pred_master", "[", "0", ":", "options", ".", "buffer_width", ",", ":", ",", ":", "]", "\n", "seg", "=", "seg_master", "[", "0", ":", "options", ".", "buffer_width", ",", ":", ",", ":", "]", "\n", "agglom_stack", ".", "build_partial", "(", "seg", ",", "pred", ")", "\n", "\n", "", "if", "\"yz2\"", "in", "faces", ":", "\n", "                ", "pred", "=", "pred_master", "[", "(", "-", "1", "*", "options", ".", "buffer_width", ")", ":", ",", ":", ",", ":", "]", "\n", "seg", "=", "seg_master", "[", "(", "-", "1", "*", "options", ".", "buffer_width", ")", ":", ",", ":", ",", ":", "]", "\n", "agglom_stack", ".", "build_partial", "(", "seg", ",", "pred", ")", "\n", "\n", "\n", "# special merge mode that preserves special nature of border edges and returns all tranformations", "\n", "", "", "", "master_logger", ".", "info", "(", "\"Starting agglomeration to threshold \"", "+", "str", "(", "options", ".", "segmentation_threshold", ")", "\n", "+", "\" with \"", "+", "str", "(", "agglom_stack", ".", "number_of_nodes", "(", ")", ")", ")", "\n", "transaction_dict", "=", "agglom_stack", ".", "agglomerate_border", "(", "options", ".", "segmentation_threshold", ")", "\n", "master_logger", ".", "info", "(", "\"Finished agglomeration to threshold \"", "+", "str", "(", "options", ".", "segmentation_threshold", ")", "\n", "+", "\" with \"", "+", "str", "(", "agglom_stack", ".", "number_of_nodes", "(", ")", ")", ")", "\n", "\n", "\n", "# output stitched segmentation and update blocks accordingly", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "session_location", "+", "\"/seg_data\"", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "session_location", "+", "\"/seg_data\"", ")", "\n", "\n", "", "file_base", "=", "os", ".", "path", ".", "abspath", "(", "session_location", ")", "+", "\"/seg_data/seg-\"", "+", "str", "(", "options", ".", "segmentation_threshold", ")", "+", "\"-\"", "+", "md5_str", "+", "\"-\"", "\n", "# version is maintained relative to the hash    ", "\n", "graph_loc", "=", "file_base", "+", "\"graphv1.json\"", "\n", "tbar_debug_loc", "=", "file_base", "+", "\"synapse-verify.json\"", "\n", "body_annotations_fn", "=", "file_base", "+", "\"annotations-body.json\"", "\n", "\n", "disjoint_face_bodies_mapped", "=", "set", "(", ")", "\n", "for", "bodyid", "in", "disjoint_face_bodies", ":", "\n", "        ", "if", "bodyid", "in", "transaction_dict", ":", "\n", "            ", "disjoint_face_bodies_mapped", ".", "add", "(", "transaction_dict", "[", "bodyid", "]", ")", "\n", "", "else", ":", "\n", "            ", "disjoint_face_bodies_mapped", ".", "add", "(", "bodyid", ")", "\n", "\n", "", "", "body_list", "=", "[", "]", "\n", "for", "bodyid", "in", "disjoint_face_bodies_mapped", ":", "\n", "         ", "body_list", ".", "append", "(", "{", "\"status\"", ":", "\"uncorrected\"", ",", "\n", "\"body ID\"", ":", "int", "(", "bodyid", ")", ",", "\n", "\"anchor\"", ":", "\"anchor\"", "}", ")", "\n", "\n", "", "body_data", "=", "{", "}", "\n", "body_data", "[", "\"data\"", "]", "=", "body_list", "\n", "body_data", "[", "\"metadata\"", "]", "=", "{", "\n", "\"username\"", ":", "\"auto\"", ",", "\n", "\"description\"", ":", "\"anchor annotations\"", ",", "\n", "\"file version\"", ":", "3", ",", "\n", "\"software\"", ":", "\"Raveler\"", "\n", "}", "\n", "\n", "master_logger", ".", "info", "(", "\"Writing graph.json\"", ")", "\n", "\n", "# set threshold value for outputing as appropriate (edge size * 2)", "\n", "agglom_stack", ".", "set_overlap_cutoff", "(", "0", ")", "\n", "# use the maximum overlap between the two regions as the the split criterion (proofread 0-0.7)", "\n", "agglom_stack", ".", "set_overlap_max", "(", ")", "\n", "agglom_stack", ".", "set_saved_probs", "(", ")", "\n", "agglom_stack", ".", "write_plaza_json", "(", "graph_loc", ",", "None", ",", "0", ",", "True", ")", "\n", "\n", "# write tbar debug file", "\n", "jw", "=", "open", "(", "tbar_debug_loc", ",", "'w'", ")", "\n", "jw", ".", "write", "(", "json", ".", "dumps", "(", "tbar_json", ",", "indent", "=", "4", ")", ")", "\n", "\n", "# write body annotation file", "\n", "jw", "=", "open", "(", "body_annotations_fn", ",", "'w'", ")", "\n", "jw", ".", "write", "(", "json", ".", "dumps", "(", "body_data", ",", "indent", "=", "4", ")", ")", "\n", "\n", "json_data", "=", "{", "}", "\n", "json_data", "[", "'graph'", "]", "=", "graph_loc", "\n", "json_data", "[", "'tbar-debug'", "]", "=", "tbar_debug_loc", "\n", "json_data", "[", "'annotations-body'", "]", "=", "body_annotations_fn", "\n", "json_data", "[", "'border'", "]", "=", "border_size", "\n", "block_configs", "=", "[", "]", "\n", "block_configs_orig", "=", "[", "]", "\n", "\n", "\n", "# load config files into subvolumes", "\n", "for", "iter1", "in", "range", "(", "0", ",", "len", "(", "regions_blocks_temp", ")", ")", ":", "\n", "        ", "region", "=", "regions_blocks_temp", "[", "iter1", "]", "\n", "noconfig", "=", "True", "\n", "for", "block", "in", "region", ":", "\n", "            ", "if", "'config-file'", "in", "block", ":", "\n", "                ", "block_configs_orig", ".", "append", "(", "block", "[", "'config-file'", "]", ")", "\n", "block_configs", ".", "append", "(", "{", "'config-file'", ":", "update_filename", "(", "block", "[", "'config-file'", "]", ",", "md5_str", ")", "}", ")", "\n", "noconfig", "=", "False", "\n", "", "", "if", "noconfig", ":", "\n", "            ", "block_configs_orig", ".", "append", "(", "options", ".", "regions", "[", "iter1", "]", ")", "\n", "block_configs", ".", "append", "(", "{", "'config-file'", ":", "update_filename", "(", "options", ".", "regions", "[", "iter1", "]", ",", "md5_str", ")", "}", ")", "\n", "\n", "", "", "json_data", "[", "'subvolumes'", "]", "=", "block_configs", "\n", "\n", "# write out json file", "\n", "json_str", "=", "json", ".", "dumps", "(", "json_data", ",", "indent", "=", "4", ")", "\n", "json_file", "=", "session_location", "+", "\"/seg-\"", "+", "str", "(", "options", ".", "segmentation_threshold", ")", "+", "\"-\"", "+", "md5_str", "+", "\"-v1.json\"", "\n", "jw", "=", "open", "(", "json_file", ",", "'w'", ")", "\n", "jw", ".", "write", "(", "json_str", ")", "\n", "\n", "# copy volumes to new version", "\n", "for", "block_file", "in", "block_configs_orig", ":", "\n", "        ", "config_data", "=", "json", ".", "load", "(", "open", "(", "block_file", ")", ")", "\n", "\n", "if", "'log'", "not", "in", "config_data", ":", "\n", "            ", "config_data", "[", "'log'", "]", "=", "[", "]", "\n", "\n", "", "config_data", "[", "'log'", "]", ".", "append", "(", "str", "(", "datetime", ".", "datetime", ".", "utcnow", "(", ")", ")", "+", "\" \"", "+", "(", "' '", ".", "join", "(", "sys", ".", "argv", ")", ")", ")", "\n", "\n", "block", "=", "config_data", "[", "\"subvolumes\"", "]", "[", "0", "]", "\n", "\n", "seg_file", "=", "block", "[", "\"segmentation-file\"", "]", "\n", "new_seg_file", "=", "update_filename", "(", "seg_file", ",", "md5_str", ")", "\n", "block", "[", "\"segmentation-file\"", "]", "=", "new_seg_file", "\n", "\n", "hfile", "=", "h5py", ".", "File", "(", "seg_file", ",", "'r'", ")", "\n", "trans", "=", "numpy", ".", "array", "(", "hfile", "[", "\"transforms\"", "]", ")", "\n", "stack", "=", "numpy", ".", "array", "(", "hfile", "[", "\"stack\"", "]", ")", "\n", "\n", "for", "mapping", "in", "trans", ":", "\n", "            ", "if", "mapping", "[", "1", "]", "in", "transaction_dict", ":", "\n", "                ", "mapping", "[", "1", "]", "=", "transaction_dict", "[", "mapping", "[", "1", "]", "]", "\n", "\n", "", "", "hfile_write", "=", "h5py", ".", "File", "(", "new_seg_file", ",", "'w'", ")", "\n", "hfile_write", ".", "create_dataset", "(", "\"transforms\"", ",", "data", "=", "trans", ")", "\n", "hfile_write", ".", "create_dataset", "(", "\"stack\"", ",", "data", "=", "stack", ")", "\n", "\n", "if", "'synapse-annotations'", "in", "hfile", ":", "\n", "            ", "hfile_write", ".", "copy", "(", "hfile", "[", "'synapse-annotations'", "]", ",", "'synapse-annotations'", ")", "\n", "", "if", "'bookmark-annotations'", "in", "hfile", ":", "\n", "            ", "hfile_write", ".", "copy", "(", "hfile", "[", "'bookmark-annotations'", "]", ",", "'bookmark-annotations'", ")", "\n", "\n", "", "jw", "=", "open", "(", "update_filename", "(", "block_file", ",", "md5_str", ")", ",", "'w'", ")", "\n", "jw", ".", "write", "(", "json", ".", "dumps", "(", "config_data", ",", "indent", "=", "4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.regions_file_verify": [[732, 739], ["os.path.exists", "Exception", "region.endswith", "Exception"], "function", ["None"], ["", "", "def", "regions_file_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "regions", ":", "\n", "        ", "for", "region", "in", "options", ".", "regions", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "region", ")", ":", "\n", "                ", "raise", "Exception", "(", "\"Region file \"", "+", "region", "+", "\" not found\"", ")", "\n", "", "if", "not", "region", ".", "endswith", "(", "'.json'", ")", ":", "\n", "                ", "raise", "Exception", "(", "\"Region file \"", "+", "region", "+", "\" does not end with .json\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.classifier_verify": [[740, 744], ["os.path.exists", "Exception"], "function", ["None"], ["", "", "", "", "def", "classifier_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "classifier", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "classifier", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Classifier \"", "+", "options", ".", "classifier", "+", "\" not found\"", ")", "\n", "# Note -- Classifier could be a variety of extensions (.h5, .joblib, etc) depending", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.create_stitching_options": [[748, 789], ["options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option"], ["", "", "", "def", "create_stitching_options", "(", "options_parser", ")", ":", "\n", "    ", "options_parser", ".", "create_option", "(", "\"regions\"", ",", "\"JSON files corresponding to disjoint region that contain an array for each block providing info on segmentation, boundary prediction, x-y-z lower-left location, x-y-z upper right\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "True", ",", "dtype", "=", "str", ",", "verify_fn", "=", "regions_file_verify", ",", "num_args", "=", "'+'", ",", "shortcut", "=", "'r'", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"classifier\"", ",", "\"H5 file containing RF (specific for border or just used in one of the substacks)\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "True", ",", "dtype", "=", "str", ",", "verify_fn", "=", "classifier_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'k'", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"aggressive-stitch\"", ",", "\"More aggressively stitch segments to reduce remaining work\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "num_args", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"vertical-mode\"", ",", "\"Enables special handling of bodies across horizontally stitched substacks when vertically stitching\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "num_args", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"run-watershed\"", ",", "\"Generate a watershed to estimate potential edges\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "num_args", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"segmentation-threshold\"", ",", "\"Segmentation threshold\"", ",", "\n", "default_val", "=", "0.3", ",", "required", "=", "False", ",", "dtype", "=", "float", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'ST'", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"border-weight-factor\"", ",", "\"Weight to give pixels likely on a boundary -- 0 is no weight\"", ",", "\n", "default_val", "=", "1.0", ",", "required", "=", "False", ",", "dtype", "=", "float", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"overlap-threshold\"", ",", "\"Minimum size of overlap considered for stitching\"", ",", "\n", "default_val", "=", "0", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"tbar-proximity\"", ",", "\"Minimum pixel separation between different tbars in a border region beyond which the tbars get flagged\"", ",", "\n", "default_val", "=", "10", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"buffer-width\"", ",", "\"Width of the stitching region\"", ",", "\n", "default_val", "=", "0", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "\n", "options_parser", ".", "create_option", "(", "\"border-size\"", ",", "\"DEPRECATED: Size of the border in pixels of the denormalized cubes\"", ",", "\n", "default_val", "=", "10", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.entrypoint": [[793, 807], ["app_logger.AppLogger", "app_logger.AppLogger.get_logger", "session_manager.Session", "applogger.get_logger.info", "segmentation_stitch.run_stitching", "applogger.get_logger.error", "applogger.get_logger.error", "str", "str", "traceback.format_exc", "traceback.format_exc"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.get_logger", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_stitch.run_stitching"], ["", "def", "entrypoint", "(", "argv", ")", ":", "\n", "    ", "applogger", "=", "app_logger", ".", "AppLogger", "(", "False", ",", "'seg-stitch'", ")", "\n", "master_logger", "=", "applogger", ".", "get_logger", "(", ")", "\n", "\n", "try", ":", "\n", "        ", "session", "=", "session_manager", ".", "Session", "(", "\"seg-stitch\"", ",", "\n", "\"Stitches multiple regions by recomputing the RAG along the border and reports changes to the RAG and mappings of each block -- the regions are not actually concatenated in Raveler space\"", ",", "\n", "master_logger", ",", "applogger", ",", "create_stitching_options", ")", "\n", "master_logger", ".", "info", "(", "\"Session location: \"", "+", "session", ".", "session_location", ")", "\n", "run_stitching", "(", "session", ".", "session_location", ",", "session", ".", "options", ",", "master_logger", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "", "except", "KeyboardInterrupt", "as", "err", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.sparselol.SparseLOL.__init__": [[8, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "csr", ")", ":", "\n", "        ", "self", ".", "indptr", "=", "csr", ".", "indptr", "\n", "self", ".", "indices", "=", "csr", ".", "indices", "\n", "self", ".", "data", "=", "csr", ".", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.sparselol.SparseLOL.__getitem__": [[13, 19], ["numpy.isscalar", "ValueError"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "if", "np", ".", "isscalar", "(", "item", ")", ":", "# get the column indices for the given row", "\n", "            ", "start", ",", "stop", "=", "self", ".", "indptr", "[", "item", ":", "item", "+", "2", "]", "\n", "return", "self", ".", "indices", "[", "start", ":", "stop", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'SparseLOL can only be indexed by an integer.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.sparselol.extents": [[20, 48], ["labels.astype().ravel.astype().ravel", "numpy.bincount", "numpy.concatenate().astype", "numpy.empty_like", "sparselol_cy.extents_count", "numpy.ones", "numpy.lib.stride_tricks.as_strided", "scipy.sparse.csr_matrix", "numpy.arange", "labels.astype().ravel.ravel", "np.concatenate().astype.copy", "labels.astype().ravel.astype", "numpy.concatenate", "numpy.cumsum"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "", "", "def", "extents", "(", "labels", ",", "input_indices", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute the extents of every integer value in ``arr``.\n\n    Parameters\n    ----------\n    labels : array of int\n        The array of values to be mapped.\n    input_indices : array of int\n        The indices corresponding to the label values passed. If `None`,\n        we assume ``range(labels.size)``.\n\n    Returns\n    -------\n    locs : sparse.csr_matrix\n        A sparse matrix in which the nonzero elements of row i are the\n        indices of value i in ``arr``.\n    \"\"\"", "\n", "labels", "=", "labels", ".", "astype", "(", "label_dtype", ")", ".", "ravel", "(", ")", "\n", "if", "input_indices", "is", "None", ":", "\n", "        ", "input_indices", "=", "np", ".", "arange", "(", "labels", ".", "size", ",", "dtype", "=", "np", ".", "intp", ")", "\n", "", "counts", "=", "np", ".", "bincount", "(", "labels", ")", "\n", "indptr", "=", "np", ".", "concatenate", "(", "[", "[", "0", "]", ",", "np", ".", "cumsum", "(", "counts", ")", "]", ")", ".", "astype", "(", "np", ".", "intp", ")", "\n", "indices", "=", "np", ".", "empty_like", "(", "labels", ")", "\n", "extents_count", "(", "labels", ".", "ravel", "(", ")", ",", "indptr", ".", "copy", "(", ")", ",", "input_indices", ",", "out", "=", "indices", ")", "\n", "one", "=", "np", ".", "ones", "(", "(", "1", ",", ")", ",", "dtype", "=", "int", ")", "\n", "data", "=", "stride_tricks", ".", "as_strided", "(", "one", ",", "shape", "=", "indices", ".", "shape", ",", "strides", "=", "(", "0", ",", ")", ")", "\n", "locs", "=", "sparse", ".", "csr_matrix", "(", "(", "data", ",", "indices", ",", "indptr", ")", ",", "dtype", "=", "int", ")", "\n", "return", "locs", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.image_stack_verify": [[11, 15], ["os.path.exists", "Exception"], "function", ["None"], ["def", "image_stack_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "test_stack", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "test_stack", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Image volume does not exist at \"", "+", "options", ".", "test_stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.image_stack_verify2": [[16, 20], ["os.path.exists", "Exception"], "function", ["None"], ["", "", "", "def", "image_stack_verify2", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "gt_stack", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "gt_stack", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Image volume does not exist at \"", "+", "options", ".", "gt_stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.graph_file_verify": [[21, 25], ["os.path.exists", "Exception"], "function", ["None"], ["", "", "", "def", "graph_file_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "ragprob_file", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "ragprob_file", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"ragprob file not found \"", "+", "options", ".", "ragprob_file", "+", "\" not found\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.create_auto_options": [[26, 42], ["options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option"], ["", "", "", "def", "create_auto_options", "(", "options_parser", ")", ":", "\n", "    ", "options_parser", ".", "create_option", "(", "\"test-stack\"", ",", "\"initial segmentation (to any percentage)\"", ",", "\n", "required", "=", "True", ",", "verify_fn", "=", "image_stack_verify", ",", "\n", "shortcut", "=", "'T'", ",", "warning", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"gt-stack\"", ",", "\"ground truth stack (~100 percent complete)\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "True", ",", "dtype", "=", "str", ",", "verify_fn", "=", "image_stack_verify2", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'G'", ",", "warning", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"ragprob-file\"", ",", "\"RAG probability file\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "True", ",", "dtype", "=", "str", ",", "verify_fn", "=", "graph_file_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'R'", ",", "warning", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"size-threshold\"", ",", "\"Number of voxels used in threshold\"", ",", "\n", "default_val", "=", "25000", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'ST'", ",", "warning", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.load_graph_json": [[43, 57], ["open", "json.load", "pairprob_list.append"], "function", ["None"], ["", "def", "load_graph_json", "(", "json_file", ")", ":", "\n", "    ", "json_file_handle", "=", "open", "(", "json_file", ")", "\n", "json_data", "=", "json", ".", "load", "(", "json_file_handle", ")", "\n", "\n", "pairprob_list", "=", "[", "]", "\n", "for", "edge", "in", "json_data", "[", "\"edge_list\"", "]", ":", "\n", "        ", "node1", "=", "edge", "[", "\"node1\"", "]", "\n", "node2", "=", "edge", "[", "\"node2\"", "]", "\n", "if", "node1", ">", "node2", ":", "\n", "            ", "node2", ",", "node1", "=", "node1", ",", "node2", "\n", "", "weight", "=", "edge", "[", "\"weight\"", "]", "\n", "pairprob_list", ".", "append", "(", "(", "node1", ",", "node2", ",", "weight", ")", ")", "\n", "\n", "", "return", "pairprob_list", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.find_gt_bodies": [[58, 76], ["numpy.ndenumerate", "body2indices.items", "body2indices.setdefault", "body2indices[].setdefault", "val.items"], "function", ["None"], ["", "def", "find_gt_bodies", "(", "gt_stack", ",", "test_stack", ")", ":", "\n", "    ", "body2indices", "=", "{", "}", "\n", "for", "index", ",", "value", "in", "numpy", ".", "ndenumerate", "(", "test_stack", ")", ":", "\n", "        ", "body2indices", ".", "setdefault", "(", "value", ",", "{", "}", ")", "\n", "value2", "=", "gt_stack", "[", "index", "]", "\n", "body2indices", "[", "value", "]", ".", "setdefault", "(", "value2", ",", "0", ")", "\n", "(", "body2indices", "[", "value", "]", ")", "[", "value2", "]", "+=", "1", "\n", "\n", "", "body2gtbody", "=", "{", "}", "\n", "for", "key", ",", "val", "in", "body2indices", ".", "items", "(", ")", ":", "\n", "        ", "max_val", "=", "0", "\n", "max_id", "=", "0", "\n", "for", "key2", ",", "val2", "in", "val", ".", "items", "(", ")", ":", "\n", "            ", "if", "val2", ">", "max_val", ":", "\n", "                ", "max_val", "=", "val2", "\n", "max_id", "=", "key2", "\n", "", "", "body2gtbody", "[", "key", "]", "=", "max_id", "\n", "", "return", "body2gtbody", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.process_edge": [[77, 103], ["libNeuroProofPriority.get_next_edge", "libNeuroProofPriority.get_edge_val", "libNeuroProofPriority.set_edge_result", "dirtybodies.add", "bodyremap[].extend", "int", "int", "int", "int"], "function", ["None"], ["", "def", "process_edge", "(", "body2gtbody", ",", "nomerge_hist", ",", "tot_hist", ",", "nomerge_hist2", ",", "tot_hist2", ",", "dirtybodies", ",", "bodyremap", ")", ":", "\n", "    ", "priority", "=", "neuroproof", ".", "get_next_edge", "(", ")", "\n", "(", "body1", ",", "body2", ")", "=", "priority", ".", "body_pair", "\n", "weight", "=", "neuroproof", ".", "get_edge_val", "(", "priority", ")", "\n", "\n", "if", "body1", "not", "in", "dirtybodies", "and", "body2", "not", "in", "dirtybodies", ":", "\n", "        ", "tot_hist", "[", "int", "(", "weight", "*", "100", ")", "]", "+=", "1", "\n", "", "tot_hist2", "[", "int", "(", "weight", "*", "100", ")", "]", "+=", "1", "\n", "link", "=", "True", "\n", "if", "body2gtbody", "[", "body1", "]", "!=", "body2gtbody", "[", "body2", "]", ":", "\n", "        ", "if", "body1", "not", "in", "dirtybodies", "and", "body2", "not", "in", "dirtybodies", ":", "\n", "            ", "nomerge_hist", "[", "int", "(", "weight", "*", "100", ")", "]", "+=", "1", "\n", "", "nomerge_hist2", "[", "int", "(", "weight", "*", "100", ")", "]", "+=", "1", "\n", "link", "=", "False", "\n", "", "else", ":", "\n", "        ", "if", "body2", "not", "in", "bodyremap", ":", "\n", "            ", "bodyremap", "[", "body2", "]", "=", "[", "body2", "]", "\n", "", "if", "body1", "not", "in", "bodyremap", ":", "\n", "            ", "bodyremap", "[", "body1", "]", "=", "[", "body1", "]", "\n", "\n", "", "dirtybodies", ".", "add", "(", "body1", ")", "\n", "bodyremap", "[", "body1", "]", ".", "extend", "(", "bodyremap", "[", "body2", "]", ")", "\n", "del", "bodyremap", "[", "body2", "]", "\n", "\n", "\n", "", "neuroproof", ".", "set_edge_result", "(", "priority", ".", "body_pair", ",", "link", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.auto_proofread": [[105, 180], ["set", "range", "libNeuroProofPriority.initialize_priority_scheduler", "libNeuroProofPriority.set_body_mode", "libNeuroProofPriority.set_synapse_mode", "libNeuroProofPriority.set_orphan_mode", "master_logger.info", "range", "master_logger.info", "range", "bodyremap.items", "os.system", "os.system", "open", "open", "open.readlines", "master_logger.info", "master_logger.info", "master_logger.info", "master_logger.info", "nomerge_hist.append", "tot_hist.append", "nomerge_hist2.append", "tot_hist2.append", "libNeuroProofPriority.get_estimated_num_remaining_edges", "auto.process_edge", "libNeuroProofPriority.get_estimated_num_remaining_edges", "auto.process_edge", "libNeuroProofPriority.get_estimated_num_remaining_edges", "auto.process_edge", "print", "print", "line.split", "int", "int", "open.write", "str", "str", "str", "str", "float", "float", "float", "float", "str", "str"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.process_edge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.process_edge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.process_edge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write"], ["", "def", "auto_proofread", "(", "body2gtbody", ",", "rag_file", ",", "size_threshold", ",", "master_logger", ",", "test_stack", ",", "session_location", ")", ":", "\n", "    ", "nomerge_hist", "=", "[", "]", "\n", "tot_hist", "=", "[", "]", "\n", "nomerge_hist2", "=", "[", "]", "\n", "tot_hist2", "=", "[", "]", "\n", "dirtybodies", "=", "set", "(", ")", "\n", "for", "iter1", "in", "range", "(", "0", ",", "101", ")", ":", "\n", "        ", "nomerge_hist", ".", "append", "(", "0", ")", "\n", "tot_hist", ".", "append", "(", "0", ")", "\n", "nomerge_hist2", ".", "append", "(", "0", ")", "\n", "tot_hist2", ".", "append", "(", "0", ")", "\n", "\n", "", "neuroproof", ".", "initialize_priority_scheduler", "(", "rag_file", ",", "0.1", ",", "0.9", ",", "0.1", ")", "\n", "\n", "bodyremap", "=", "{", "}", "\n", "\n", "num_body", "=", "0", "\n", "neuroproof", ".", "set_body_mode", "(", "size_threshold", ",", "0", ")", "\n", "while", "neuroproof", ".", "get_estimated_num_remaining_edges", "(", ")", ">", "0", ":", "\n", "        ", "process_edge", "(", "body2gtbody", ",", "nomerge_hist", ",", "tot_hist", ",", "nomerge_hist2", ",", "tot_hist2", ",", "dirtybodies", ",", "bodyremap", ")", "\n", "num_body", "+=", "1", "\n", "\n", "", "num_synapse", "=", "0", "\n", "neuroproof", ".", "set_synapse_mode", "(", "0.1", ")", "\n", "while", "neuroproof", ".", "get_estimated_num_remaining_edges", "(", ")", ">", "0", ":", "\n", "        ", "process_edge", "(", "body2gtbody", ",", "nomerge_hist", ",", "tot_hist", ",", "nomerge_hist2", ",", "tot_hist2", ",", "dirtybodies", ",", "bodyremap", ")", "\n", "num_synapse", "+=", "1", "\n", "\n", "", "num_orphan", "=", "0", "\n", "neuroproof", ".", "set_orphan_mode", "(", "size_threshold", ",", "size_threshold", ",", "size_threshold", ")", "\n", "while", "neuroproof", ".", "get_estimated_num_remaining_edges", "(", ")", ">", "0", ":", "\n", "        ", "process_edge", "(", "body2gtbody", ",", "nomerge_hist", ",", "tot_hist", ",", "nomerge_hist2", ",", "tot_hist2", ",", "dirtybodies", ",", "bodyremap", ")", "\n", "num_orphan", "+=", "1", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Probability Actual Agreement with Groundtruth Flat\"", ")", "\n", "for", "iter1", "in", "range", "(", "0", ",", "101", ")", ":", "\n", "        ", "if", "tot_hist", "[", "iter1", "]", "==", "0", ":", "\n", "            ", "per", "=", "0", "\n", "", "else", ":", "\n", "            ", "per", "=", "(", "float", "(", "nomerge_hist", "[", "iter1", "]", ")", "/", "float", "(", "tot_hist", "[", "iter1", "]", ")", "*", "100", ")", "\n", "", "print", "(", "iter1", ",", "\", \"", ",", "per", ",", "\", \"", ",", "tot_hist", "[", "iter1", "]", ")", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Probability Actual Agreement with Groundtruth Est\"", ")", "\n", "for", "iter1", "in", "range", "(", "0", ",", "101", ")", ":", "\n", "        ", "if", "tot_hist2", "[", "iter1", "]", "==", "0", ":", "\n", "            ", "per", "=", "0", "\n", "", "else", ":", "\n", "            ", "per", "=", "(", "float", "(", "nomerge_hist2", "[", "iter1", "]", ")", "/", "float", "(", "tot_hist2", "[", "iter1", "]", ")", "*", "100", ")", "\n", "", "print", "(", "iter1", ",", "\", \"", ",", "per", ",", "\", \"", ",", "tot_hist2", "[", "iter1", "]", ")", "\n", "\n", "", "body2body", "=", "{", "}", "\n", "for", "key", ",", "vallist", "in", "bodyremap", ".", "items", "(", ")", ":", "\n", "        ", "for", "body", "in", "vallist", ":", "\n", "            ", "body2body", "[", "body", "]", "=", "key", "\n", "\n", "", "", "os", ".", "system", "(", "\"cp -R \"", "+", "test_stack", "+", "\"/superpixel_maps \"", "+", "session_location", "+", "\"/\"", ")", "\n", "os", ".", "system", "(", "\"cp \"", "+", "test_stack", "+", "\"/superpixel_to_segment_map.txt \"", "+", "session_location", "+", "\"/\"", ")", "\n", "\n", "mapping_file", "=", "open", "(", "test_stack", "+", "\"/segment_to_body_map.txt\"", ")", "\n", "outfile", "=", "open", "(", "session_location", "+", "\"/segment_to_body_map.txt\"", ",", "'w'", ")", "\n", "\n", "for", "line", "in", "mapping_file", ".", "readlines", "(", ")", ":", "\n", "        ", "vals", "=", "line", ".", "split", "(", "' '", ")", "\n", "\n", "seg", "=", "int", "(", "vals", "[", "0", "]", ")", "\n", "body", "=", "int", "(", "vals", "[", "1", "]", ")", "\n", "\n", "if", "body", "in", "body2body", ":", "\n", "            ", "body", "=", "body2body", "[", "body", "]", "\n", "", "outfile", ".", "write", "(", "str", "(", "seg", ")", "+", "\" \"", "+", "str", "(", "body", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Num body: \"", "+", "str", "(", "num_body", ")", ")", "\n", "master_logger", ".", "info", "(", "\"Num synapse: \"", "+", "str", "(", "num_synapse", ")", ")", "\n", "master_logger", ".", "info", "(", "\"Num orphan: \"", "+", "str", "(", "num_orphan", ")", ")", "\n", "master_logger", ".", "info", "(", "\"Num total: \"", "+", "str", "(", "num_body", "+", "num_synapse", "+", "num_orphan", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.auto": [[182, 223], ["master_logger.info", "imio.read_image_stack", "master_logger.info", "imio.read_image_stack", "master_logger.info", "master_logger.info", "auto.load_graph_json", "master_logger.info", "master_logger.info", "auto.find_gt_bodies", "master_logger.info", "h5py.File", "h5py.File.create_dataset", "numpy.array", "h5py.File.create_dataset", "list", "print", "body2body.items", "print", "body2body.items", "remap_list.append"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.load_graph_json", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.find_gt_bodies"], ["", "def", "auto", "(", "session_location", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "master_logger", ".", "info", "(", "\"Reading gt_stack\"", ")", "\n", "gt_stack", "=", "imio", ".", "read_image_stack", "(", "options", ".", "gt_stack", ")", "\n", "master_logger", ".", "info", "(", "\"Reading test_stack\"", ")", "\n", "test_stack", "=", "imio", ".", "read_image_stack", "(", "options", ".", "test_stack", ")", "\n", "master_logger", ".", "info", "(", "\"Finished reading stacks\"", ")", "\n", "\n", "\n", "master_logger", ".", "info", "(", "\"Loading graph json\"", ")", "\n", "pairprob_list", "=", "load_graph_json", "(", "options", ".", "ragprob_file", ")", "\n", "master_logger", ".", "info", "(", "\"Finished loading graph json\"", ")", "\n", "\n", "master_logger", ".", "info", "(", "\"Matching bodies to GT\"", ")", "\n", "body2gtbody", "=", "find_gt_bodies", "(", "gt_stack", ",", "test_stack", ")", "\n", "master_logger", ".", "info", "(", "\"Finished matching bodies to GT\"", ")", "\n", "\n", "body2body", "=", "{", "}", "\n", "\n", "for", "(", "node1", ",", "node2", ",", "dummy", ")", "in", "pairprob_list", ":", "\n", "        ", "body2body", "[", "node1", "]", "=", "node1", "\n", "body2body", "[", "node2", "]", "=", "node2", "\n", "\n", "", "for", "(", "node1", ",", "node2", ",", "dummy", ")", "in", "pairprob_list", ":", "\n", "        ", "if", "body2gtbody", "[", "node1", "]", "==", "body2gtbody", "[", "node2", "]", ":", "\n", "            ", "print", "(", "\"merge: \"", ",", "node1", ",", "node2", ")", "\n", "node2", "=", "body2body", "[", "node2", "]", "\n", "node1", "=", "body2body", "[", "node1", "]", "\n", "body2body", "[", "node1", "]", "=", "node2", "\n", "remap_list", "=", "[", "]", "\n", "for", "b1", ",", "b2", "in", "body2body", ".", "items", "(", ")", ":", "\n", "                ", "if", "b2", "==", "node1", ":", "\n", "                    ", "remap_list", ".", "append", "(", "b1", ")", "\n", "", "", "for", "b1", "in", "remap_list", ":", "\n", "                ", "body2body", "[", "b1", "]", "=", "node2", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "\"split: \"", ",", "node1", ",", "node2", ")", "\n", "\n", "", "", "f1", "=", "h5py", ".", "File", "(", "'proofread.h5'", ",", "'w'", ")", "\n", "f1", ".", "create_dataset", "(", "'stack'", ",", "data", "=", "test_stack", ")", "\n", "arr", "=", "numpy", ".", "array", "(", "list", "(", "body2body", ".", "items", "(", ")", ")", ")", "\n", "f1", ".", "create_dataset", "(", "'transforms'", ",", "data", "=", "arr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.entrypoint": [[225, 238], ["app_logger.AppLogger", "app_logger.AppLogger.get_logger", "session_manager.Session", "auto.auto", "applogger.get_logger.error", "applogger.get_logger.error", "str", "str", "traceback.format_exc", "traceback.format_exc"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.get_logger", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.auto.auto"], ["", "def", "entrypoint", "(", "argv", ")", ":", "\n", "    ", "applogger", "=", "app_logger", ".", "AppLogger", "(", "False", ",", "'auto'", ")", "\n", "master_logger", "=", "applogger", ".", "get_logger", "(", ")", "\n", "\n", "try", ":", "\n", "        ", "session", "=", "session_manager", ".", "Session", "(", "\"auto\"", ",", "\"Validate the predicted probabilities against 100% groundtruth\"", ",", "\n", "master_logger", ",", "applogger", ",", "create_auto_options", ")", "\n", "\n", "auto", "(", "session", ".", "session_location", ",", "session", ".", "options", ",", "master_logger", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "", "except", "KeyboardInterrupt", "as", "err", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.__init__": [[43, 61], ["numpy.array", "features.default.snemi3d", "serve.Solver._build_rag", "serve.Solver._configure_from_file", "serve.Solver._connect_to_id_service", "serve.Solver._connect_to_client"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.default.snemi3d", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver._build_rag", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver._configure_from_file", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver._connect_to_id_service", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver._connect_to_client"], ["def", "__init__", "(", "self", ",", "labels", ",", "image", "=", "np", ".", "array", "(", "[", "]", ")", ",", "\n", "feature_manager", "=", "features", ".", "default", ".", "snemi3d", "(", ")", ",", "\n", "address", "=", "None", ",", "relearn_threshold", "=", "20", ",", "\n", "config_file", "=", "None", ")", ":", "\n", "        ", "self", ".", "labels", "=", "labels", "\n", "self", ".", "image", "=", "image", "\n", "self", ".", "feature_manager", "=", "feature_manager", "\n", "self", ".", "_build_rag", "(", ")", "\n", "config_address", ",", "id_address", "=", "self", ".", "_configure_from_file", "(", "config_file", ")", "\n", "self", ".", "id_service", "=", "self", ".", "_connect_to_id_service", "(", "id_address", ")", "\n", "self", ".", "_connect_to_client", "(", "address", "or", "config_address", ")", "\n", "self", ".", "history", "=", "[", "]", "\n", "self", ".", "separate", "=", "[", "]", "\n", "self", ".", "features", "=", "[", "]", "\n", "self", ".", "targets", "=", "[", "]", "\n", "self", ".", "relearn_threshold", "=", "relearn_threshold", "\n", "self", ".", "relearn_trigger", "=", "relearn_threshold", "\n", "self", ".", "recently_solved", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver._build_rag": [[62, 68], ["agglo.Rag", "serve.Solver.rag.copy"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "_build_rag", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build the region-adjacency graph from the label image.\"\"\"", "\n", "self", ".", "rag", "=", "agglo", ".", "Rag", "(", "self", ".", "labels", ",", "self", ".", "image", ",", "\n", "feature_manager", "=", "self", ".", "feature_manager", ",", "\n", "normalize_probabilities", "=", "True", ")", "\n", "self", ".", "original_rag", "=", "self", ".", "rag", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver._configure_from_file": [[69, 98], ["open", "json.load", "json.load.get", "json.load.get"], "methods", ["None"], ["", "def", "_configure_from_file", "(", "self", ",", "filename", ")", ":", "\n", "        ", "\"\"\"Get all configuration parameters from a JSON file.\n\n        The file specification is currently in flux, but looks like:\n\n        ```\n        {'id_service_url': 'tcp://localhost:5555',\n         'client_url': 'tcp://*:9001',\n         'solver_url': 'tcp://localhost:9001'}\n        ```\n\n        Parameters\n        ----------\n        filename : str\n            The input filename.\n\n        Returns\n        -------\n        address : str\n            The URL to bind a ZMQ socket to.\n        id_address : str\n            The URL to bind an ID service to\n        \"\"\"", "\n", "if", "filename", "is", "None", ":", "\n", "            ", "return", "None", ",", "None", "\n", "", "with", "open", "(", "filename", ",", "'r'", ")", "as", "fin", ":", "\n", "            ", "config", "=", "json", ".", "load", "(", "fin", ")", "\n", "", "return", "(", "config", ".", "get", "(", "'client_url'", ",", "None", ")", ",", "\n", "config", ".", "get", "(", "'id_service_url'", ",", "None", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver._connect_to_client": [[99, 102], ["zmq.Context().socket", "serve.Solver.comm.bind", "zmq.Context"], "methods", ["None"], ["", "def", "_connect_to_client", "(", "self", ",", "address", ")", ":", "\n", "        ", "self", ".", "comm", "=", "zmq", ".", "Context", "(", ")", ".", "socket", "(", "zmq", ".", "PAIR", ")", "\n", "self", ".", "comm", ".", "bind", "(", "address", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver._connect_to_id_service": [[103, 120], ["zmq.Context().socket", "zmq.Context().socket.connect", "print", "zmq.Context().socket.send_json", "print", "zmq.Context().socket.recv_json", "zmq.Context", "numpy.max"], "methods", ["None"], ["", "def", "_connect_to_id_service", "(", "self", ",", "url", ")", ":", "\n", "        ", "if", "url", "is", "not", "None", ":", "\n", "            ", "service_comm", "=", "zmq", ".", "Context", "(", ")", ".", "socket", "(", "zmq", ".", "REQ", ")", "\n", "service_comm", ".", "connect", "(", "url", ")", "\n", "\n", "def", "get_ids", "(", "count", ")", ":", "\n", "                ", "print", "(", "'requesting %i ids...'", "%", "count", ")", "\n", "service_comm", ".", "send_json", "(", "{", "'count'", ":", "count", "}", ")", "\n", "print", "(", "'receiving %i ids...'", "%", "count", ")", "\n", "received", "=", "service_comm", ".", "recv_json", "(", ")", "\n", "id_range", "=", "received", "[", "'begin'", "]", ",", "received", "[", "'end'", "]", "\n", "return", "id_range", "\n", "", "", "else", ":", "\n", "            ", "def", "get_ids", "(", "count", ")", ":", "\n", "                ", "start", "=", "np", ".", "max", "(", "self", ".", "labels", ")", "+", "2", "\n", "return", "start", ",", "start", "+", "count", "\n", "", "", "return", "get_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.send_segmentation": [[121, 150], ["serve.Solver.relearn", "serve.Solver.rag.agglomerate", "set", "serve.Solver.id_service", "dict", "list", "list", "print", "len", "print", "int", "len", "zip", "map", "range", "serve.Solver.comm.send_json", "serve.Solver.rag.tree.get_map", "range", "len"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.relearn", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate"], ["", "def", "send_segmentation", "(", "self", ")", ":", "\n", "        ", "\"\"\"Send a segmentation to ZMQ as a fragment-to-segment lookup table.\n\n        The format of the lookup table (LUT) is specified in the BigCat\n        wiki [1]_.\n\n        References\n        ----------\n        .. [1] https://github.com/saalfeldlab/bigcat/wiki/Actors,-responsibilities,-and-inter-process-communication\n        \"\"\"", "\n", "if", "len", "(", "self", ".", "targets", ")", "<", "self", ".", "relearn_threshold", ":", "\n", "            ", "print", "(", "'server has insufficient data to resolve'", ")", "\n", "return", "\n", "", "self", ".", "relearn", "(", ")", "# correct way to do it is to implement RAG splits", "\n", "self", ".", "rag", ".", "agglomerate", "(", "0.5", ")", "\n", "self", ".", "recently_solved", "=", "True", "\n", "dst_tree", "=", "[", "int", "(", "i", ")", "for", "i", "in", "self", ".", "rag", ".", "tree", ".", "get_map", "(", "0.5", ")", "]", "\n", "unique", "=", "set", "(", "dst_tree", ")", "\n", "start", ",", "end", "=", "self", ".", "id_service", "(", "len", "(", "unique", ")", ")", "\n", "remap", "=", "dict", "(", "zip", "(", "unique", ",", "range", "(", "start", ",", "end", ")", ")", ")", "\n", "dst", "=", "list", "(", "map", "(", "remap", ".", "__getitem__", ",", "dst_tree", ")", ")", "\n", "src", "=", "list", "(", "range", "(", "len", "(", "dst", ")", ")", ")", "\n", "message", "=", "{", "'type'", ":", "'fragment-segment-lut'", ",", "\n", "'data'", ":", "{", "'fragments'", ":", "src", ",", "'segments'", ":", "dst", "}", "}", "\n", "print", "(", "'server sending:'", ",", "message", ")", "\n", "try", ":", "\n", "            ", "self", ".", "comm", ".", "send_json", "(", "message", ",", "flags", "=", "zmq", ".", "NOBLOCK", ")", "\n", "", "except", "zmq", ".", "error", ".", "Again", ":", "\n", "            ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.listen": [[151, 208], ["time.time", "serve.Solver.comm.recv_json", "print", "serve.Solver.learn_merge", "time.time", "print", "serve.Solver.send_segmentation", "time.time", "print", "print", "print", "serve.Solver.learn_separation", "print", "serve.Solver.send_segmentation", "serve.Solver.send_segmentation", "print"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.learn_merge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.send_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.learn_separation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.send_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.send_segmentation"], ["", "", "def", "listen", "(", "self", ",", "send_every", "=", "None", ")", ":", "\n", "        ", "\"\"\"Listen to ZMQ port for instructions and data.\n\n        The instructions conform to the proofreading protocol defined in the\n        BigCat wiki [1]_.\n\n        Parameters\n        ----------\n        send_every : int or float, optional\n            Send a new segmentation every `send_every` seconds.\n\n        References\n        ----------\n        .. [1] https://github.com/saalfeldlab/bigcat/wiki/Actors,-responsibilities,-and-inter-process-communication\n        \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "recv_flags", "=", "zmq", ".", "NOBLOCK", "\n", "while", "True", ":", "\n", "            ", "if", "send_every", "is", "not", "None", ":", "\n", "                ", "elapsed_time", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "if", "elapsed_time", ">", "send_every", ":", "\n", "                    ", "print", "(", "'server resolving'", ")", "\n", "self", ".", "send_segmentation", "(", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "", "", "try", ":", "\n", "                ", "if", "recv_flags", "==", "zmq", ".", "NOBLOCK", ":", "\n", "                    ", "print", "(", "'server receiving no blocking...'", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "'server receiving blocking...'", ")", "\n", "", "message", "=", "self", ".", "comm", ".", "recv_json", "(", "flags", "=", "recv_flags", ")", "\n", "print", "(", "'server received:'", ",", "message", ")", "\n", "recv_flags", "=", "zmq", ".", "NOBLOCK", "\n", "", "except", "zmq", ".", "error", ".", "Again", ":", "# no message received", "\n", "                ", "recv_flags", "=", "zmq", ".", "NULL", "\n", "print", "(", "'server: no message received in time'", ")", "\n", "if", "not", "self", ".", "recently_solved", ":", "\n", "                    ", "print", "(", "'server resolving'", ")", "\n", "self", ".", "send_segmentation", "(", ")", "\n", "", "continue", "\n", "", "command", "=", "message", "[", "'type'", "]", "\n", "data", "=", "message", "[", "'data'", "]", "\n", "if", "command", "==", "'merge'", ":", "\n", "                ", "segments", "=", "data", "[", "'fragments'", "]", "\n", "self", ".", "learn_merge", "(", "segments", ")", "\n", "", "elif", "command", "==", "'separate'", ":", "\n", "                ", "fragment", "=", "data", "[", "'fragment'", "]", "\n", "separate_from", "=", "data", "[", "'from'", "]", "\n", "self", ".", "learn_separation", "(", "fragment", ",", "separate_from", ")", "\n", "", "elif", "command", "==", "'request'", ":", "\n", "                ", "what", "=", "data", "[", "'what'", "]", "\n", "if", "what", "==", "'fragment-segment-lut'", ":", "\n", "                    ", "self", ".", "send_segmentation", "(", ")", "\n", "", "", "elif", "command", "==", "'stop'", ":", "\n", "                ", "return", "\n", "", "else", ":", "\n", "                ", "print", "(", "'command %s not recognized.'", "%", "command", ")", "\n", "continue", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.learn_merge": [[209, 228], ["set", "networkx.dfs_preorder_nodes", "next", "networkx.subgraph", "serve.Solver.features.append", "serve.Solver.history.append", "serve.Solver.rag.merge_nodes", "serve.Solver.targets.append", "serve.Solver.rag.tree.highest_ancestor", "serve.Solver.feature_manager", "len", "set"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes"], ["", "", "", "def", "learn_merge", "(", "self", ",", "segments", ")", ":", "\n", "        ", "\"\"\"Learn that a pair of segments should be merged.\n\n        Parameters\n        ----------\n        segments : tuple of int\n            A pair of segment identifiers.\n        \"\"\"", "\n", "segments", "=", "set", "(", "self", ".", "rag", ".", "tree", ".", "highest_ancestor", "(", "s", ")", "for", "s", "in", "segments", ")", "\n", "# ensure the segments are ordered such that every subsequent", "\n", "# pair shares an edge", "\n", "ordered", "=", "nx", ".", "dfs_preorder_nodes", "(", "nx", ".", "subgraph", "(", "self", ".", "rag", ",", "segments", ")", ")", "\n", "s0", "=", "next", "(", "ordered", ")", "\n", "for", "s1", "in", "ordered", ":", "\n", "            ", "self", ".", "features", ".", "append", "(", "self", ".", "feature_manager", "(", "self", ".", "rag", ",", "s0", ",", "s1", ")", ")", "\n", "self", ".", "history", ".", "append", "(", "(", "s0", ",", "s1", ")", ")", "\n", "s0", "=", "self", ".", "rag", ".", "merge_nodes", "(", "s0", ",", "s1", ")", "\n", "self", ".", "targets", ".", "append", "(", "MERGE_LABEL", ")", "\n", "", "self", ".", "recently_solved", "=", "False", "or", "len", "(", "set", "(", "self", ".", "targets", ")", ")", "<", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.learn_separation": [[229, 254], ["serve.Solver.rag.tree.highest_ancestor", "serve.Solver.original_rag.neighbors", "serve.Solver.rag.tree.highest_ancestor", "serve.Solver.rag.has_edge", "serve.Solver.original_rag.has_edge", "serve.Solver.separate.append", "serve.Solver.features.append", "serve.Solver.targets.append", "serve.Solver.features.append", "serve.Solver.targets.append", "len", "serve.Solver.feature_manager", "serve.Solver.feature_manager", "set"], "methods", ["None"], ["", "def", "learn_separation", "(", "self", ",", "fragment", ",", "separate_from", ")", ":", "\n", "        ", "\"\"\"Learn that a pair of fragments should never be in the same segment.\n\n        Parameters\n        ----------\n        fragments : tuple of int\n            A pair of fragment identifiers.\n        \"\"\"", "\n", "f0", "=", "fragment", "\n", "if", "not", "separate_from", ":", "\n", "            ", "separate_from", "=", "self", ".", "original_rag", ".", "neighbors", "(", "f0", ")", "\n", "", "s0", "=", "self", ".", "rag", ".", "tree", ".", "highest_ancestor", "(", "f0", ")", "\n", "for", "f1", "in", "separate_from", ":", "\n", "            ", "if", "self", ".", "rag", ".", "boundary_body", "in", "(", "f0", ",", "f1", ")", ":", "\n", "                ", "continue", "\n", "", "s1", "=", "self", ".", "rag", ".", "tree", ".", "highest_ancestor", "(", "f1", ")", "\n", "if", "self", ".", "rag", ".", "has_edge", "(", "s0", ",", "s1", ")", ":", "\n", "                ", "self", ".", "features", ".", "append", "(", "self", ".", "feature_manager", "(", "self", ".", "rag", ",", "s0", ",", "s1", ")", ")", "\n", "self", ".", "targets", ".", "append", "(", "SEPAR_LABEL", ")", "\n", "", "if", "self", ".", "original_rag", ".", "has_edge", "(", "f0", ",", "f1", ")", ":", "\n", "                ", "self", ".", "features", ".", "append", "(", "self", ".", "feature_manager", "(", "self", ".", "original_rag", ",", "\n", "f0", ",", "f1", ")", ")", "\n", "self", ".", "targets", ".", "append", "(", "SEPAR_LABEL", ")", "\n", "", "self", ".", "separate", ".", "append", "(", "(", "f0", ",", "f1", ")", ")", "\n", "", "self", ".", "recently_solved", "=", "False", "or", "len", "(", "set", "(", "self", ".", "targets", ")", ")", "<", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.relearn": [[255, 269], ["classify.DefaultRandomForest().fit", "agglo.classifier_probability", "serve.Solver.original_rag.copy", "serve.Solver.rag.rebuild_merge_queue", "enumerate", "[].add", "[].add", "classify.DefaultRandomForest"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.classifier_probability", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rebuild_merge_queue"], ["", "def", "relearn", "(", "self", ")", ":", "\n", "        ", "\"\"\"Learn a new merge policy using data gathered so far.\n\n        This resets the state of the RAG to contain only the merges and\n        separations received over the course of its history.\n        \"\"\"", "\n", "clf", "=", "classify", ".", "DefaultRandomForest", "(", ")", ".", "fit", "(", "self", ".", "features", ",", "self", ".", "targets", ")", "\n", "self", ".", "policy", "=", "agglo", ".", "classifier_probability", "(", "self", ".", "feature_manager", ",", "clf", ")", "\n", "self", ".", "rag", "=", "self", ".", "original_rag", ".", "copy", "(", ")", "\n", "self", ".", "rag", ".", "merge_priority_function", "=", "self", ".", "policy", "\n", "self", ".", "rag", ".", "rebuild_merge_queue", "(", ")", "\n", "for", "i", ",", "(", "s0", ",", "s1", ")", "in", "enumerate", "(", "self", ".", "separate", ")", ":", "\n", "            ", "self", ".", "rag", ".", "node", "[", "s0", "]", "[", "'exclusions'", "]", ".", "add", "(", "i", ")", "\n", "self", ".", "rag", ".", "node", "[", "s1", "]", "[", "'exclusions'", "]", ".", "add", "(", "i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.proofread": [[271, 340], ["agglo2.best_segmentation", "agglo2.fast_rag", "zmq.Context().socket", "zmq.Context().socket.connect", "evaluate.contingency_table().tocsc", "numpy.unique", "sklearn.utils.check_random_state", "sklearn.utils.check_random_state.shuffle", "zip", "print", "zmq.Context().socket.recv_json", "print", "range", "time.sleep", "print", "zmq.Context().socket.send_json", "print", "zmq.Context().socket.send_json", "print", "zmq.Context().socket.send_json", "zmq.Context", "str", "evaluate.contingency_table", "int", "print", "zmq.Context().socket.send_json", "int", "ev.contingency_table().tocsc.getcol", "int", "int"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.best_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.fast_rag", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["", "", "", "def", "proofread", "(", "fragments", ",", "true_segmentation", ",", "host", "=", "'tcp://localhost'", ",", "port", "=", "5556", ",", "\n", "num_operations", "=", "10", ",", "mode", "=", "'fast paint'", ",", "stop_when_finished", "=", "False", ",", "\n", "request_seg", "=", "True", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"Simulate a proofreader by sending and receiving messages to a Solver.\n\n    Parameters\n    ----------\n    fragments : array of int\n        The initial segmentation to be proofread.\n    true_segmentation : array of int\n        The target segmentation. Should be a superset of `fragments`.\n    host : string\n        The host to serve ZMQ commands to.\n    port : int\n        Port on which to connect ZMQ.\n    num_operations : int, optional\n        How many proofreading operations to perform before returning.\n    mode : string, optional\n        The mode with which to simulate proofreading.\n    stop_when_finished : bool, optional\n        Send the solver a \"stop\" action when done proofreading. Useful\n        when running tests so we don't intend to continue proofreading.\n    random_state : None or int or numpy.RandomState instance, optional\n        Fix the random state for proofreading.\n\n    Returns\n    -------\n    lut : tuple of array-like of int\n        A look-up table from fragments (first array) to segments\n        (second array), obtained by requesting it from the Solver after\n        initial proofreading simulation.\n    \"\"\"", "\n", "true", "=", "agglo2", ".", "best_segmentation", "(", "fragments", ",", "true_segmentation", ")", "\n", "base_graph", "=", "agglo2", ".", "fast_rag", "(", "fragments", ")", "\n", "comm", "=", "zmq", ".", "Context", "(", ")", ".", "socket", "(", "zmq", ".", "PAIR", ")", "\n", "comm", ".", "connect", "(", "host", "+", "':'", "+", "str", "(", "port", ")", ")", "\n", "ctable", "=", "ev", ".", "contingency_table", "(", "fragments", ",", "true", ")", ".", "tocsc", "(", ")", "\n", "true_labels", "=", "np", ".", "unique", "(", "true", ")", "\n", "random", "=", "check_random_state", "(", "random_state", ")", "\n", "random", ".", "shuffle", "(", "true_labels", ")", "\n", "for", "_", ",", "label", "in", "zip", "(", "range", "(", "num_operations", ")", ",", "true_labels", ")", ":", "\n", "        ", "time", ".", "sleep", "(", "3", ")", "\n", "components", "=", "[", "int", "(", "i", ")", "for", "i", "in", "ctable", ".", "getcol", "(", "int", "(", "label", ")", ")", ".", "indices", "]", "\n", "merge_msg", "=", "{", "'type'", ":", "'merge'", ",", "'data'", ":", "{", "'fragments'", ":", "components", "}", "}", "\n", "print", "(", "'proofreader sends:'", ",", "merge_msg", ")", "\n", "comm", ".", "send_json", "(", "merge_msg", ")", "\n", "for", "fragment", "in", "components", ":", "\n", "            ", "others", "=", "[", "int", "(", "neighbor", ")", "for", "neighbor", "in", "base_graph", "[", "fragment", "]", "\n", "if", "neighbor", "not", "in", "components", "]", "\n", "if", "not", "others", ":", "\n", "                ", "continue", "\n", "", "split_msg", "=", "{", "'type'", ":", "'separate'", ",", "\n", "'data'", ":", "{", "'fragment'", ":", "int", "(", "fragment", ")", ",", "'from'", ":", "others", "}", "}", "\n", "print", "(", "'proofreader sends:'", ",", "split_msg", ")", "\n", "comm", ".", "send_json", "(", "split_msg", ")", "\n", "", "", "if", "request_seg", ":", "# if no request, assume server sends periodic updates", "\n", "        ", "req_msg", "=", "{", "'type'", ":", "'request'", ",", "'data'", ":", "{", "'what'", ":", "'fragment-segment-lut'", "}", "}", "\n", "print", "(", "'proofreader sends:'", ",", "req_msg", ")", "\n", "comm", ".", "send_json", "(", "req_msg", ")", "\n", "", "print", "(", "'proofreader receiving...'", ")", "\n", "response", "=", "comm", ".", "recv_json", "(", ")", "\n", "print", "(", "'proofreader received:'", ",", "response", ")", "\n", "src", "=", "response", "[", "'data'", "]", "[", "'fragments'", "]", "\n", "dst", "=", "response", "[", "'data'", "]", "[", "'segments'", "]", "\n", "if", "stop_when_finished", ":", "\n", "        ", "stop_msg", "=", "{", "'type'", ":", "'stop'", ",", "'data'", ":", "{", "}", "}", "\n", "print", "(", "'proofreader sends: '", ",", "stop_msg", ")", "\n", "comm", ".", "send_json", "(", "stop_msg", ")", "\n", "", "return", "src", ",", "dst", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.main": [[342, 359], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "imio.read_cremi", "serve.Solver", "serve.Solver.listen"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_cremi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.Solver.listen"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "'gala-serve'", ")", "\n", "parser", ".", "add_argument", "(", "'-f'", ",", "'--config-file'", ",", "help", "=", "'JSON configuration file'", ")", "\n", "parser", ".", "add_argument", "(", "'input_file'", ",", "help", "=", "'Input image file'", ")", "\n", "parser", ".", "add_argument", "(", "'-F'", ",", "'--fragment-group'", ",", "\n", "default", "=", "'volumes/labels/fragments'", ",", "\n", "help", "=", "'Group path in HDF file for fragments'", ")", "\n", "parser", ".", "add_argument", "(", "'-p'", ",", "'--membrane-probabilities'", ",", "\n", "default", "=", "'volumes/membrane'", ",", "\n", "help", "=", "'Group path in HDF file for membrane prob map'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "from", ".", "import", "imio", "\n", "frags", ",", "probs", "=", "imio", ".", "read_cremi", "(", "args", ".", "input_file", ",", "\n", "[", "args", ".", "fragment_group", ",", "\n", "args", ".", "membrane_probabilities", "]", ")", "\n", "solver", "=", "Solver", "(", "frags", ",", "probs", ",", "config_file", "=", "args", ".", "config_file", ")", "\n", "solver", ".", "listen", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.ncut.ncutW": [[7, 81], ["numpy.ravel", "scipy.sparse.diags", "scipy.sparse.linalg.eigs", "numpy.real", "numpy.real", "range", "range", "scipy.sparse.diags", "W.sum", "numpy.argsort", "scipy.sparse.linalg.norm", "scipy.cluster.vq.kmeans2", "range", "labels_list.append", "distortion_list.append", "numpy.full", "numpy.sum", "numpy.mean", "numpy.argmin", "numpy.sqrt", "numpy.ones", "scipy.sparse.linalg.norm", "enumerate"], "function", ["None"], ["def", "ncutW", "(", "W", ",", "num_eigs", "=", "10", ",", "kmeans_iters", "=", "10", ",", "offset", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"Run the normalized cut algorithm on the affinity matrix, W.\n\n    (as implemented in Ng, Jordan, and Weiss, 2002)\n\n    Parameters\n    ----------\n    W : scipy sparse matrix\n        Square matrix with high values for edges to be preserved, and low\n        values for edges to be cut.\n    num_eigs : int, optional\n        Number of eigenvectors of the affinity matrix to use for clustering.\n    kmeans_iters : int, optional\n        Number of iterations of the k-means algorithm to run when clustering\n        eigenvectors.\n    offset : float, optional\n        Diagonal offset used to stabilise the eigenvector computation.\n\n    Returns\n    -------\n    labels : array of int\n        `labels[i]` is an integer value mapping node/row `i` to the cluster\n        ID `labels[i]`.\n    eigenvectors : list of array of float\n        The computed eigenvectors of `W + offset * I`, where `I` is the\n        identity matrix of same size as `W`.\n    eigenvalues : array of float\n        The corresponding eigenvalues.\n    \"\"\"", "\n", "\n", "n", ",", "m", "=", "W", ".", "shape", "\n", "# Add an offset in case some rows are zero", "\n", "# We also add the offset below to the diagonal matrix. See (Yu, 2001),", "\n", "# \"Understanding Popout through Repulsion\" for more information.  This", "\n", "# helps to stabilize the eigenvector computation.", "\n", "W", "=", "W", "+", "sparse", ".", "diags", "(", "np", ".", "full", "(", "n", ",", "offset", ")", ")", "\n", "\n", "d", "=", "np", ".", "ravel", "(", "W", ".", "sum", "(", "axis", "=", "1", ")", ")", "\n", "Dinv2", "=", "sparse", ".", "diags", "(", "1", "/", "(", "np", ".", "sqrt", "(", "d", ")", "+", "offset", "*", "np", ".", "ones", "(", "n", ")", ")", ")", "\n", "P", "=", "Dinv2", "@", "W", "@", "Dinv2", "\n", "\n", "# Get the eigenvectors and sort by eigenvalue", "\n", "eigvals", ",", "U", "=", "eigs", "(", "P", ",", "num_eigs", ",", "which", "=", "'LR'", ")", "\n", "eigvals", "=", "np", ".", "real", "(", "eigvals", ")", "# it should be real anyway", "\n", "U", "=", "np", ".", "real", "(", "U", ")", "\n", "ind", "=", "np", ".", "argsort", "(", "eigvals", ")", "[", ":", ":", "-", "1", "]", "\n", "eigvals", "=", "eigvals", "[", "ind", "]", "\n", "U", "=", "U", "[", ":", ",", "ind", "]", "\n", "\n", "# Normalize", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "U", "[", "i", ",", ":", "]", "/=", "norm", "(", "U", "[", "i", ",", ":", "]", ")", "\n", "\n", "# Cluster them into labels, running k-means multiple times", "\n", "", "labels_list", "=", "[", "]", "\n", "distortion_list", "=", "[", "]", "\n", "for", "_iternum", "in", "range", "(", "kmeans_iters", ")", ":", "\n", "# Cluster", "\n", "        ", "centroid", ",", "labels", "=", "vq", ".", "kmeans2", "(", "U", ",", "num_eigs", ",", "minit", "=", "'points'", ")", "\n", "# Calculate distortion", "\n", "distortion", "=", "0", "\n", "for", "j", "in", "range", "(", "num_eigs", ")", ":", "\n", "            ", "numvals", "=", "np", ".", "sum", "(", "labels", "==", "j", ")", "\n", "if", "numvals", "==", "0", ":", "\n", "                ", "continue", "\n", "", "distortion", "+=", "np", ".", "mean", "(", "[", "norm", "(", "v", "-", "centroid", "[", "j", "]", ")", "**", "2", "for", "(", "i", ",", "v", ")", "in", "\n", "enumerate", "(", "U", ")", "if", "labels", "[", "i", "]", "==", "j", "]", ")", "\n", "# Save values", "\n", "", "labels_list", ".", "append", "(", "labels", ")", "\n", "distortion_list", ".", "append", "(", "distortion", ")", "\n", "# Use lowest distortion", "\n", "", "labels", "=", "labels_list", "[", "np", ".", "argmin", "(", "distortion_list", ")", "]", "\n", "\n", "return", "labels", ",", "U", ",", "eigvals", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack": [[33, 110], ["os.path.isdir", "os.path.split", "kwargs.get", "any", "numpy.squeeze", "os.path.expanduser", "len", "len", "kwargs.get.extend", "len", "fn.endswith", "args[].endswith", "fnmatch.filter", "fns[].endswith", "imio.read_multi_page_tif", "fnmatch.filter.sort", "skimage.io.imread", "numpy.zeros", "enumerate", "fn.endswith", "fn.endswith", "imio.read_prediction_from_ilastik_batch", "fn.endswith", "len", "type", "os.listdir", "len", "os.path.join", "os.path.join", "skimage.io.imread", "os.path.join", "imio.read_h5_stack", "os.path.isfile", "os.path.join", "os.path.join", "os.path.join", "imio.raveler_to_labeled_volume", "os.path.split", "len"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_multi_page_tif", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_prediction_from_ilastik_batch", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.raveler_to_labeled_volume"], ["def", "read_image_stack", "(", "fn", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Read a 3D volume of images in image or .h5 format into a numpy.ndarray.\n\n    This function attempts to automatically determine input file types and\n    wraps specific image-reading functions.\n\n    Parameters\n    ----------\n    fn : filename (string)\n        A file path or glob pattern specifying one or more valid image files.\n        The file format is automatically determined from this argument.\n\n    *args : filenames (string, optional)\n        More than one positional argument will be interpreted as a list of\n        filenames pointing to all the 2D images in the stack.\n\n    **kwargs : keyword arguments (optional)\n        Arguments to be passed to the underlying functions. A 'crop'\n        keyword argument is supported, as a list of length 6:\n        [xmin, xmax, ymin, ymax, zmin, zmax]. Use 'None' for no crop in\n        that coordinate.\n\n    Returns\n    -------\n    stack : 3-dimensional numpy ndarray\n\n    Notes\n    -----\n        If reading in .h5 format, keyword arguments are passed through to\n        read_h5_stack().\n\n        Automatic file type detection may be deprecated in the future.\n    \"\"\"", "\n", "# TODO: Refactor.  Rather than have implicit designation of stack format", "\n", "# based on filenames (*_boundpred.h5, etc), require explicit parameters", "\n", "# in config JSON files.", "\n", "if", "os", ".", "path", ".", "isdir", "(", "fn", ")", ":", "\n", "        ", "fn", "+=", "'/'", "\n", "", "d", ",", "fn", "=", "split_path", "(", "os", ".", "path", ".", "expanduser", "(", "fn", ")", ")", "\n", "if", "len", "(", "d", ")", "==", "0", ":", "d", "=", "'.'", "\n", "crop", "=", "kwargs", ".", "get", "(", "'crop'", ",", "[", "None", "]", "*", "6", ")", "\n", "if", "crop", "is", "None", ":", "\n", "        ", "crop", "=", "[", "None", "]", "*", "6", "\n", "", "if", "len", "(", "crop", ")", "==", "4", ":", "crop", ".", "extend", "(", "[", "None", "]", "*", "2", ")", "\n", "elif", "len", "(", "crop", ")", "==", "2", ":", "crop", "=", "[", "None", "]", "*", "4", "+", "crop", "\n", "kwargs", "[", "'crop'", "]", "=", "crop", "\n", "if", "any", "(", "fn", ".", "endswith", "(", "ext", ")", "for", "ext", "in", "supported_image_extensions", ")", ":", "\n", "# image types, such as a set of pngs or a multi-page tiff", "\n", "        ", "xmin", ",", "xmax", ",", "ymin", ",", "ymax", ",", "zmin", ",", "zmax", "=", "crop", "\n", "if", "len", "(", "args", ")", ">", "0", "and", "type", "(", "args", "[", "0", "]", ")", "==", "str", "and", "args", "[", "0", "]", ".", "endswith", "(", "fn", "[", "-", "3", ":", "]", ")", ":", "\n", "# input is a list of filenames", "\n", "            ", "fns", "=", "[", "fn", "]", "+", "[", "split_path", "(", "f", ")", "[", "1", "]", "for", "f", "in", "args", "]", "\n", "", "else", ":", "\n", "# input is a filename pattern to match", "\n", "            ", "fns", "=", "fnfilter", "(", "os", ".", "listdir", "(", "d", ")", ",", "fn", ")", "\n", "", "if", "len", "(", "fns", ")", "==", "1", "and", "fns", "[", "0", "]", ".", "endswith", "(", "'.tif'", ")", ":", "\n", "            ", "stack", "=", "read_multi_page_tif", "(", "join_path", "(", "d", ",", "fns", "[", "0", "]", ")", ",", "crop", ")", "\n", "", "else", ":", "\n", "            ", "fns", ".", "sort", "(", "key", "=", "alphanumeric_key", ")", "# sort filenames numerically", "\n", "fns", "=", "fns", "[", "zmin", ":", "zmax", "]", "\n", "im0", "=", "imread", "(", "join_path", "(", "d", ",", "fns", "[", "0", "]", ")", ")", "\n", "ars", "=", "(", "imread", "(", "join_path", "(", "d", ",", "fn", ")", ")", "for", "fn", "in", "fns", ")", "\n", "im0", "=", "im0", "[", "xmin", ":", "xmax", ",", "ymin", ":", "ymax", "]", "\n", "dtype", "=", "im0", ".", "dtype", "\n", "stack", "=", "zeros", "(", "(", "len", "(", "fns", ")", ",", ")", "+", "im0", ".", "shape", ",", "dtype", ")", "\n", "for", "i", ",", "im", "in", "enumerate", "(", "ars", ")", ":", "\n", "                ", "stack", "[", "i", "]", "=", "im", "[", "xmin", ":", "xmax", ",", "ymin", ":", "ymax", "]", "\n", "", "", "", "elif", "fn", ".", "endswith", "(", "'_boundpred.h5'", ")", "or", "fn", ".", "endswith", "(", "'_processed.h5'", ")", ":", "\n", "# Ilastik batch prediction output file", "\n", "        ", "stack", "=", "read_prediction_from_ilastik_batch", "(", "os", ".", "path", ".", "join", "(", "d", ",", "fn", ")", ",", "**", "kwargs", ")", "\n", "", "elif", "fn", ".", "endswith", "(", "'.h5'", ")", ":", "\n", "# other HDF5 file", "\n", "        ", "stack", "=", "read_h5_stack", "(", "join_path", "(", "d", ",", "fn", ")", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "d", ",", "'superpixel_to_segment_map.txt'", ")", ")", ":", "\n", "# Raveler export", "\n", "        ", "stack", "=", "raveler_to_labeled_volume", "(", "d", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "return", "squeeze", "(", "stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_image_stack": [[111, 156], ["os.path.expanduser", "os.path.expanduser.endswith", "imio.write_png_image_stack", "os.path.expanduser.endswith", "imio.write_h5_stack", "os.path.expanduser.endswith", "imio.write_vtk", "ValueError"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_png_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_vtk"], ["", "def", "write_image_stack", "(", "npy_vol", ",", "fn", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Write a numpy.ndarray 3D volume to a stack of images or an HDF5 file.\n    \n    Parameters\n    ----------\n    npy_vol : numpy ndarray\n        The volume to be written to disk.\n    \n    fn : string\n        The filename to be written, or a format string when writing a 3D\n        stack to a 2D format (e.g. a png image stack).\n    \n    **kwargs : keyword arguments\n        Keyword arguments to be passed to wrapped functions. See\n        corresponding docs for valid arguments.\n    \n    Returns\n    -------\n    out : None\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from gala.imio import write_image_stack\n    >>> im = 255 * np.array([\n    ... [[0, 1, 0], [1, 0, 1], [0, 1, 0]],\n    ... [[1, 0, 1], [0, 1, 0], [1, 0, 1]]], dtype=uint8)\n    >>> im.shape\n    (2, 3, 3)\n    >>> write_image_stack(im, 'image-example-%02i.png', axis=0)\n    >>> import os\n    >>> fns = sorted(filter(lambda x: x.endswith('.png'), os.listdir('.')))\n    >>> fns # two 3x3 images\n    ['image-example-00.png', 'image-example-01.png']\n    >>> os.remove(fns[0]); os.remove(fns[1]) # doctest cleanup\n    \"\"\"", "\n", "fn", "=", "os", ".", "path", ".", "expanduser", "(", "fn", ")", "\n", "if", "fn", ".", "endswith", "(", "'.png'", ")", ":", "\n", "        ", "write_png_image_stack", "(", "npy_vol", ",", "fn", ",", "**", "kwargs", ")", "\n", "", "elif", "fn", ".", "endswith", "(", "'.h5'", ")", ":", "\n", "        ", "write_h5_stack", "(", "npy_vol", ",", "fn", ",", "**", "kwargs", ")", "\n", "", "elif", "fn", ".", "endswith", "(", "'.vtk'", ")", ":", "\n", "        ", "write_vtk", "(", "npy_vol", ",", "fn", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Image format not supported: '", "+", "fn", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.pil_to_numpy": [[159, 173], ["numpy.squeeze", "numpy.array().reshape", "numpy.array", "img.getdata"], "function", ["None"], ["", "", "def", "pil_to_numpy", "(", "img", ")", ":", "\n", "    ", "\"\"\"Convert an Image object to a numpy array.\n    \n    Parameters\n    ----------\n    img : Image object (from the Python Imaging Library)\n    \n    Returns\n    -------\n    ar : numpy ndarray\n        The corresponding numpy array (same shape as the image)\n    \"\"\"", "\n", "ar", "=", "squeeze", "(", "array", "(", "img", ".", "getdata", "(", ")", ")", ".", "reshape", "(", "(", "img", ".", "size", "[", "1", "]", ",", "img", ".", "size", "[", "0", "]", ",", "-", "1", ")", ")", ")", "\n", "return", "ar", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_multi_page_tif": [[174, 204], ["PIL.Image.open", "numpy.concatenate", "Image.open.seek", "pages.append", "Image.open.tell", "Image.open.seek", "imio.pil_to_numpy", "Image.open.tell"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.pil_to_numpy"], ["", "def", "read_multi_page_tif", "(", "fn", ",", "crop", "=", "[", "None", "]", "*", "6", ")", ":", "\n", "    ", "\"\"\"Read a multi-page tif file into a numpy array.\n    \n    Parameters\n    ----------\n    fn : string\n        The filename of the image file being read.\n    \n    Returns\n    -------\n    ar : numpy ndarray\n        The image stack in array format.\n\n    Notes\n    -----\n        Currently, only grayscale images are supported.\n    \"\"\"", "\n", "xmin", ",", "xmax", ",", "ymin", ",", "ymax", ",", "zmin", ",", "zmax", "=", "crop", "\n", "img", "=", "Image", ".", "open", "(", "fn", ")", "\n", "pages", "=", "[", "]", "\n", "if", "zmin", "is", "not", "None", "and", "zmin", ">", "0", ":", "\n", "        ", "img", ".", "seek", "(", "zmin", ")", "\n", "", "eof", "=", "False", "\n", "while", "not", "eof", "and", "img", ".", "tell", "(", ")", "!=", "zmax", ":", "\n", "        ", "pages", ".", "append", "(", "pil_to_numpy", "(", "img", ")", "[", "...", ",", "newaxis", "]", ")", "\n", "try", ":", "\n", "            ", "img", ".", "seek", "(", "img", ".", "tell", "(", ")", "+", "1", ")", "\n", "", "except", "EOFError", ":", "\n", "            ", "eof", "=", "True", "\n", "", "", "return", "concatenate", "(", "pages", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_png_image_stack": [[206, 255], ["numpy.swapaxes", "os.path.expanduser", "enumerate", "numpy.uint8", "PIL.Image.new", "Image.new.frombytes", "Image.new.save", "numpy.uint32.max", "numpy.uint16", "numpy.uint32", "pl.tostring", "numpy.uint32.max", "numpy.max"], "function", ["None"], ["", "def", "write_png_image_stack", "(", "npy_vol", ",", "fn", ",", "axis", "=", "-", "1", ",", "bitdepth", "=", "None", ")", ":", "\n", "    ", "\"\"\"Write a numpy.ndarray 3D volume to a stack of .png images.\n\n    Parameters\n    ----------\n    npy_vol : numpy ndarray, shape (M, N, P)\n        The volume to be written to disk.\n\n    fn : format string\n        The file pattern to which to write the volume.\n\n    axis : int, optional (default = -1)\n        The axis along which output the images. If the input array has shape\n        (M, N, P), and axis is 1, the function will write N images of shape\n        (M, P) to disk. In keeping with Python convention, -1 specifies the\n        last axis.\n\n    Returns\n    -------\n    None : None\n        No value is returned.\n\n    Notes\n    -----\n        Only 8-bit and 16-bit single-channel images are currently supported.\n    \"\"\"", "\n", "npy_vol", "=", "swapaxes", "(", "npy_vol", ",", "0", ",", "axis", ")", "\n", "fn", "=", "os", ".", "path", ".", "expanduser", "(", "fn", ")", "\n", "if", "0", "<=", "npy_vol", ".", "max", "(", ")", "<=", "1", "and", "npy_vol", ".", "dtype", "==", "double", ":", "\n", "        ", "bitdepth", "=", "16", "if", "None", "else", "bitdepth", "\n", "imdtype", "=", "uint16", "if", "bitdepth", "==", "16", "else", "uint8", "\n", "npy_vol", "=", "(", "(", "2", "**", "bitdepth", "-", "1", ")", "*", "npy_vol", ")", ".", "astype", "(", "imdtype", ")", "\n", "", "if", "1", "<", "npy_vol", ".", "max", "(", ")", "<", "256", "and", "bitdepth", "is", "None", "or", "bitdepth", "==", "8", ":", "\n", "        ", "mode", "=", "'L'", "\n", "mode_base", "=", "'L'", "\n", "npy_vol", "=", "uint8", "(", "npy_vol", ")", "\n", "", "elif", "256", "<=", "np", ".", "max", "(", "npy_vol", ")", "<", "2", "**", "16", "and", "bitdepth", "is", "None", "or", "bitdepth", "==", "16", ":", "\n", "        ", "mode", "=", "'I;16'", "\n", "mode_base", "=", "'I'", "\n", "npy_vol", "=", "uint16", "(", "npy_vol", ")", "\n", "", "else", ":", "\n", "        ", "mode", "=", "'RGBA'", "\n", "mode_base", "=", "'RGBA'", "\n", "npy_vol", "=", "uint32", "(", "npy_vol", ")", "\n", "", "for", "z", ",", "pl", "in", "enumerate", "(", "npy_vol", ")", ":", "\n", "        ", "im", "=", "Image", ".", "new", "(", "mode_base", ",", "pl", ".", "T", ".", "shape", ")", "\n", "im", ".", "frombytes", "(", "pl", ".", "tostring", "(", ")", ",", "'raw'", ",", "mode", ")", "\n", "im", ".", "save", "(", "fn", "%", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.extract_segments": [[258, 291], ["numpy.zeros", "enumerate"], "function", ["None"], ["", "", "def", "extract_segments", "(", "seg", ",", "ids", ")", ":", "\n", "    ", "\"\"\"Get a uint8 volume containing only the specified segment ids.\n\n    Parameters\n    ----------\n    seg : array of int\n        The input segmentation.\n    ids : list of int, maximum length 255\n        A list of segments to extract from `seg`.\n\n    Returns\n    -------\n    segs : array of uint8\n        A volume with 1, 2, ..., ``len(ids)`` labels where the required\n        segments were, and 0 elsewhere.\n\n    Notes\n    -----\n    This function is designed to output volumes to VTK format for\n    viewing in ITK-SNAP\n\n    Examples\n    --------\n    >>> segments = array([[45, 45, 51, 51],\n    ...                   [45, 83, 83, 51]])\n    >>> extract_segments(segments, [83, 45])\n    array([[2, 2, 0, 0],\n           [2, 1, 1, 0]], dtype=uint8)\n    \"\"\"", "\n", "segs", "=", "np", ".", "zeros", "(", "seg", ".", "shape", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "ids", ")", ":", "\n", "        ", "segs", "[", "seg", "==", "s", "]", "=", "i", "+", "1", "\n", "", "return", "segs", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_vtk": [[304, 343], ["open", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open.close", "open", "open.write", "open.close", "str.encode", "str.encode", "str.encode", "str.encode", "str.encode", "ar.tobytes", "str", "list", "list", "list", "map", "map", "map", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write"], ["def", "write_vtk", "(", "ar", ",", "fn", ",", "spacing", "=", "[", "1.0", ",", "1.0", ",", "1.0", "]", ")", ":", "\n", "    ", "\"\"\"Write 3D volume to VTK structured points format file.\n\n    Code adapted from Erik Vidholm's writeVTK.m Matlab implementation.\n\n    Parameters\n    ----------\n    ar : a numpy array, shape (M, N, P)\n        The array to be written to disk.\n    fn : string\n        The desired output filename.\n    spacing : iterable of float, optional (default: [1.0, 1.0, 1.0])\n        The voxel spacing in x, y, and z.\n\n    Returns\n    -------\n    None : None\n        This function does not have a return value.\n    \"\"\"", "\n", "# write header", "\n", "f", "=", "open", "(", "fn", ",", "'wb'", ")", "\n", "f", ".", "write", "(", "b'# vtk DataFile Version 3.0\\n'", ")", "\n", "f", ".", "write", "(", "b'created by write_vtk (Python implementation by JNI)\\n'", ")", "\n", "f", ".", "write", "(", "b'BINARY\\n'", ")", "\n", "f", ".", "write", "(", "b'DATASET STRUCTURED_POINTS\\n'", ")", "\n", "f", ".", "write", "(", "str", ".", "encode", "(", "' '", ".", "join", "(", "[", "'DIMENSIONS'", "]", "+", "\n", "list", "(", "map", "(", "str", ",", "ar", ".", "shape", "[", "-", "1", ":", ":", "-", "1", "]", ")", ")", ")", "+", "'\\n'", ")", ")", "\n", "f", ".", "write", "(", "str", ".", "encode", "(", "' '", ".", "join", "(", "[", "'ORIGIN'", "]", "+", "list", "(", "map", "(", "str", ",", "zeros", "(", "3", ")", ")", ")", ")", "+", "'\\n'", ")", ")", "\n", "f", ".", "write", "(", "str", ".", "encode", "(", "' '", ".", "join", "(", "[", "'SPACING'", "]", "+", "list", "(", "map", "(", "str", ",", "spacing", ")", ")", ")", "+", "'\\n'", ")", ")", "\n", "f", ".", "write", "(", "str", ".", "encode", "(", "'POINT_DATA '", "+", "str", "(", "ar", ".", "size", ")", "+", "'\\n'", ")", ")", "\n", "f", ".", "write", "(", "str", ".", "encode", "(", "'SCALARS image_data '", "+", "\n", "numpy_type_to_vtk_string", "[", "ar", ".", "dtype", ".", "type", "]", "+", "'\\n'", ")", ")", "\n", "f", ".", "write", "(", "b'LOOKUP_TABLE default\\n'", ")", ";", "\n", "f", ".", "close", "(", ")", "\n", "\n", "# write data as binary", "\n", "f", "=", "open", "(", "fn", ",", "'ab'", ")", "\n", "f", ".", "write", "(", "ar", ".", "tobytes", "(", ")", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_vtk": [[345, 372], ["open", "type_line.startswith", "numpy.fromstring().reshape", "bytes.decode", "int", "ar_shape.append", "open.readline", "range", "numpy.fromstring", "line.startswith", "shape_line.rstrip().split", "type_line.rstrip().split", "open.read", "line.startswith", "line.startswith", "shape_line.rstrip", "type_line.rstrip"], "function", ["None"], ["", "def", "read_vtk", "(", "fin", ")", ":", "\n", "    ", "\"\"\"Read a numpy volume from a VTK structured points file.\n\n    Code adapted from Erik Vidholm's readVTK.m Matlab implementation.\n\n    Parameters\n    ----------\n    fin : string\n        The input filename.\n\n    Returns\n    -------\n    ar : numpy ndarray\n        The array contained in the file.\n    \"\"\"", "\n", "f", "=", "open", "(", "fin", ",", "'rb'", ")", "\n", "num_lines_in_header", "=", "10", "\n", "lines", "=", "[", "bytes", ".", "decode", "(", "f", ".", "readline", "(", ")", ")", "for", "i", "in", "range", "(", "num_lines_in_header", ")", "]", "\n", "shape_line", "=", "[", "line", "for", "line", "in", "lines", "if", "line", ".", "startswith", "(", "'DIMENSIONS'", ")", "]", "[", "0", "]", "\n", "type_line", "=", "[", "line", "for", "line", "in", "lines", "\n", "if", "line", ".", "startswith", "(", "'SCALARS'", ")", "or", "line", ".", "startswith", "(", "'VECTORS'", ")", "]", "[", "0", "]", "\n", "ar_shape", "=", "[", "int", "(", "b", ")", "for", "b", "in", "shape_line", ".", "rstrip", "(", ")", ".", "split", "(", "' '", ")", "[", "-", "1", ":", "0", ":", "-", "1", "]", "]", "\n", "ar_type", "=", "vtk_string_to_numpy_type", "[", "type_line", ".", "rstrip", "(", ")", ".", "split", "(", "' '", ")", "[", "2", "]", "]", "\n", "if", "type_line", ".", "startswith", "(", "'VECTORS'", ")", ":", "\n", "        ", "ar_shape", ".", "append", "(", "-", "1", ")", "\n", "", "ar", "=", "fromstring", "(", "f", ".", "read", "(", ")", ",", "ar_type", ")", ".", "reshape", "(", "ar_shape", ")", "\n", "return", "ar", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack": [[375, 408], ["os.path.expanduser", "h5py.File", "numpy.array", "h5py.File.close", "ValueError", "numpy.ndim", "numpy.ndim"], "function", ["None"], ["", "def", "read_h5_stack", "(", "fn", ",", "group", "=", "'stack'", ",", "crop", "=", "[", "None", "]", "*", "6", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Read a volume in HDF5 format into numpy.ndarray.\n\n    Parameters\n    ----------\n    fn : string\n        The filename of the input HDF5 file.\n    group : string, optional (default 'stack')\n        The group within the HDF5 file containing the dataset.\n    crop : list of int, optional (default '[None]*6', no crop)\n        A crop to get of the volume of interest. Only available for 2D and 3D\n        volumes.\n\n    Returns\n    -------\n    stack : numpy ndarray\n        The stack contained in fn, possibly cropped.\n    \"\"\"", "\n", "fn", "=", "os", ".", "path", ".", "expanduser", "(", "fn", ")", "\n", "dset", "=", "h5py", ".", "File", "(", "fn", ",", "'r'", ")", "\n", "if", "group", "not", "in", "dset", ":", "\n", "        ", "raise", "ValueError", "(", "\"HDF5 file (%s) doesn't have group (%s)!\"", "%", "\n", "(", "fn", ",", "group", ")", ")", "\n", "", "a", "=", "dset", "[", "group", "]", "\n", "if", "ndim", "(", "a", ")", "==", "2", ":", "\n", "        ", "xmin", ",", "xmax", ",", "ymin", ",", "ymax", "=", "crop", "[", ":", "4", "]", "\n", "a", "=", "a", "[", "xmin", ":", "xmax", ",", "ymin", ":", "ymax", "]", "\n", "", "elif", "ndim", "(", "a", ")", "==", "3", ":", "\n", "        ", "xmin", ",", "xmax", ",", "ymin", ",", "ymax", ",", "zmin", ",", "zmax", "=", "crop", "\n", "a", "=", "a", "[", "xmin", ":", "xmax", ",", "ymin", ":", "ymax", ",", "zmin", ":", "zmax", "]", "\n", "", "stack", "=", "array", "(", "a", ")", "\n", "dset", ".", "close", "(", ")", "\n", "return", "stack", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.compute_sp_to_body_map": [[409, 431], ["numpy.unique().astype", "numpy.unique", "list", "zip", "sps.ravel", "bodies.ravel"], "function", ["None"], ["", "def", "compute_sp_to_body_map", "(", "sps", ",", "bodies", ")", ":", "\n", "    ", "\"\"\"Return unique (sp, body) pairs from a superpixel map and segmentation.\n\n    Parameters\n    ----------\n    sps : numpy ndarray, arbitrary shape\n        The superpixel (supervoxel) map.\n    bodies : numpy ndarray, same shape as sps\n        The corresponding segmentation.\n\n    Returns\n    -------\n    sp_to_body : numpy ndarray, shape (NUM_SPS, 2)\n\n    Notes\n    -----\n    No checks are made for sane inputs. This means that incorrect input,\n    such as non-matching shapes, or superpixels mapping to more than one\n    segment, will result in undefined behavior downstream with no warning.\n    \"\"\"", "\n", "sp_to_body", "=", "unique", "(", "list", "(", "zip", "(", "sps", ".", "ravel", "(", ")", ",", "bodies", ".", "ravel", "(", ")", ")", ")", ")", ".", "astype", "(", "uint64", ")", "\n", "return", "sp_to_body", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_mapped_segmentation": [[432, 458], ["os.path.expanduser", "h5py.File", "h5py.File.create_dataset", "h5py.File.create_dataset", "h5py.File.close"], "function", ["None"], ["", "def", "write_mapped_segmentation", "(", "superpixel_map", ",", "sp_to_body_map", ",", "fn", ",", "\n", "sp_group", "=", "'stack'", ",", "sp_to_body_group", "=", "'transforms'", ")", ":", "\n", "    ", "\"\"\"Write a mapped segmentation to an HDF5 file.\n\n    Parameters\n    ----------\n    superpixel_map : numpy ndarray, arbitrary shape\n    sp_to_body_map : numpy ndarray, shape (NUM_SPS, 2)\n        A many-to-one map of superpixels to bodies (segments), specified as\n        rows of (superpixel, body) pairs.\n    fn : string\n        The output filename.\n    sp_group : string, optional (default 'stack')\n        the group within the HDF5 file to store the superpixel map.\n    sp_to_body_group : string, optional (default 'transforms')\n        the group within the HDF5 file to store the superpixel to body map.\n\n    Returns\n    -------\n    None\n    \"\"\"", "\n", "fn", "=", "os", ".", "path", ".", "expanduser", "(", "fn", ")", "\n", "fout", "=", "h5py", ".", "File", "(", "fn", ",", "'w'", ")", "\n", "fout", ".", "create_dataset", "(", "sp_group", ",", "data", "=", "superpixel_map", ")", "\n", "fout", ".", "create_dataset", "(", "sp_to_body_group", ",", "data", "=", "sp_to_body_map", ")", "\n", "fout", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_mapped_segmentation": [[460, 482], ["imio.read_mapped_segmentation_raw", "imio.apply_segmentation_map"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_mapped_segmentation_raw", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.apply_segmentation_map"], ["", "def", "read_mapped_segmentation", "(", "fn", ",", "\n", "sp_group", "=", "'stack'", ",", "sp_to_body_group", "=", "'transforms'", ")", ":", "\n", "    ", "\"\"\"Read a volume in mapped HDF5 format into a numpy.ndarray pair.\n\n    Parameters\n    ----------\n    fn : string\n        The filename to open.\n    sp_group : string, optional (default 'stack')\n        The group within the HDF5 file where the superpixel map is stored.\n    sp_to_body_group : string, optional (default 'transforms')\n        The group within the HDF5 file where the superpixel to body map is\n        stored.\n\n    Returns\n    -------\n    segmentation : numpy ndarray, same shape as 'superpixels', int type\n        The segmentation induced by the superpixels and map.\n    \"\"\"", "\n", "sps", ",", "sp2body", "=", "read_mapped_segmentation_raw", "(", "fn", ",", "sp_group", ",", "sp_to_body_group", ")", "\n", "segmentation", "=", "apply_segmentation_map", "(", "sps", ",", "sp2body", ")", "\n", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.apply_segmentation_map": [[483, 503], ["numpy.zeros", "sp_to_body_map[].max"], "function", ["None"], ["", "def", "apply_segmentation_map", "(", "superpixels", ",", "sp_to_body_map", ")", ":", "\n", "    ", "\"\"\"Return a segmentation from superpixels and a superpixel to body map.\n\n    Parameters\n    ----------\n    superpixels : numpy ndarray, arbitrary shape, int type\n        A superpixel (or supervoxel) map (aka label field).\n    sp_to_body_map : numpy ndarray, shape (NUM_SUPERPIXELS, 2), int type\n        An array of (superpixel, body) map pairs.\n\n    Returns\n    -------\n    segmentation : numpy ndarray, same shape as 'superpixels', int type\n        The segmentation induced by the superpixels and map.\n    \"\"\"", "\n", "forward_map", "=", "np", ".", "zeros", "(", "sp_to_body_map", "[", ":", ",", "0", "]", ".", "max", "(", ")", "+", "1", ",", "\n", "sp_to_body_map", ".", "dtype", ")", "\n", "forward_map", "[", "sp_to_body_map", "[", ":", ",", "0", "]", "]", "=", "sp_to_body_map", "[", ":", ",", "1", "]", "\n", "segmentation", "=", "forward_map", "[", "superpixels", "]", "\n", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_mapped_segmentation_raw": [[504, 537], ["os.path.expanduser", "h5py.File", "numpy.array", "numpy.array", "h5py.File.close", "ValueError", "ValueError"], "function", ["None"], ["", "def", "read_mapped_segmentation_raw", "(", "fn", ",", "\n", "sp_group", "=", "'stack'", ",", "sp_to_body_group", "=", "'transforms'", ")", ":", "\n", "    ", "\"\"\"Read a volume in mapped HDF5 format into a numpy.ndarray pair.\n\n    Parameters\n    ----------\n    fn : string\n        The filename to open.\n    sp_group : string, optional (default 'stack')\n        The group within the HDF5 file where the superpixel map is stored.\n    sp_to_body_group : string, optional (default 'transforms')\n        The group within the HDF5 file where the superpixel to body map is\n        stored.\n\n    Returns\n    -------\n    sp_map : numpy ndarray, arbitrary shape\n        The superpixel (or supervoxel) map.\n    sp_to_body_map : numpy ndarray, shape (NUM_SUPERPIXELS, 2)\n        The superpixel to body (segment) map, as (superpixel, body) pairs.\n    \"\"\"", "\n", "fn", "=", "os", ".", "path", ".", "expanduser", "(", "fn", ")", "\n", "dset", "=", "h5py", ".", "File", "(", "fn", ",", "'r'", ")", "\n", "if", "sp_group", "not", "in", "dset", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"HDF5 file (%s) doesn't have group (%s)!\"", "%", "(", "fn", ",", "sp_group", ")", ")", "\n", "", "if", "sp_to_body_group", "not", "in", "dset", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"HDF5 file (%s) doesn't have group (%s)!\"", "%", "(", "fn", ",", "sp_to_body_group", ")", ")", "\n", "", "sp_map", "=", "array", "(", "dset", "[", "sp_group", "]", ")", "\n", "sp_to_body_map", "=", "array", "(", "dset", "[", "sp_to_body_group", "]", ")", "\n", "dset", ".", "close", "(", ")", "\n", "return", "sp_map", ",", "sp_to_body_map", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_h5_stack": [[539, 578], ["os.path.expanduser", "h5py.File", "h5py.File.create_dataset", "h5py.File.close", "attrs.items"], "function", ["None"], ["", "def", "write_h5_stack", "(", "npy_vol", ",", "fn", ",", "group", "=", "'stack'", ",", "compression", "=", "None", ",", "chunks", "=", "None", ",", "\n", "shuffle", "=", "None", ",", "attrs", "=", "None", ")", ":", "\n", "    ", "\"\"\"Write a numpy.ndarray 3D volume to an HDF5 file.\n\n    Parameters\n    ----------\n    npy_vol : numpy ndarray\n        The array to be saved to HDF5.\n    fn : string\n        The output filename.\n    group : string, optional (default: 'stack')\n        The group within the HDF5 file to write to.\n    compression : {None, 'gzip', 'szip', 'lzf'}, optional (default: None)\n        The compression to use, if any. Note that 'lzf' is only available\n        through h5py, so implementations in other languages will not be able\n        to read files created with this compression.\n    chunks : tuple, True, or None (default: None)\n        Whether to use chunking in the HDF5 dataset. Default is None. True\n        lets h5py choose a chunk size automatically. Otherwise, use a tuple\n        of int of the same length as `npy_vol.ndim`. From the h5py\n        documentation: \"In the real world, chunks of size 10kB - 300kB work\n        best, especially for compression. Very small chunks lead to lots of\n        overhead in the file, while very large chunks can result in \n        inefficient I/O.\"\n    shuffle : bool, optional\n        Shuffle the bytes on disk to improve compression efficiency.\n    attrs : dict, optional\n        A dictionary, keyed by string, of attributes to append to the dataset.\n    \"\"\"", "\n", "fn", "=", "os", ".", "path", ".", "expanduser", "(", "fn", ")", "\n", "fout", "=", "h5py", ".", "File", "(", "fn", ",", "'a'", ")", "\n", "if", "group", "in", "fout", ":", "\n", "        ", "del", "fout", "[", "group", "]", "\n", "", "fout", ".", "create_dataset", "(", "group", ",", "data", "=", "npy_vol", ",", "compression", "=", "compression", ",", "\n", "chunks", "=", "chunks", ",", "shuffle", "=", "shuffle", ")", "\n", "if", "attrs", "is", "not", "None", ":", "\n", "        ", "for", "attr", ",", "value", "in", "attrs", ".", "items", "(", ")", ":", "\n", "            ", "fout", "[", "group", "]", ".", "attrs", "[", "attr", "]", "=", "value", "\n", "", "", "fout", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.ucm_to_raveler": [[581, 616], ["imio.segs_to_raveler", "scipy.ndimage.measurements.label", "scipy.ndimage.measurements.label"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.segs_to_raveler"], ["", "def", "ucm_to_raveler", "(", "ucm", ",", "sp_threshold", "=", "0.0", ",", "body_threshold", "=", "0.1", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return Raveler map from a UCM.\n    \n    Parameters\n    ----------\n    ucm : numpy ndarray, shape (M, N, P)\n        An ultrametric contour map. This is a map of scored segment boundaries\n        such that if A, B, and C are segments, then \n        score(A, B) = score(B, C) >= score(A, C), for some permutation of\n        A, B, and C.\n        A hierarchical agglomeration process produces a UCM.\n    sp_threshold : float, optional (default: 0.0)\n        The value for which to threshold the UCM to obtain the superpixels.\n    body_threshold : float, optional (default: 0.1)\n        The value for which to threshold the UCM to obtain the segments/bodies.\n        The condition `body_threshold >= sp_threshold` should hold in order\n        to obtain sensible results.\n    **kwargs : dict, optional\n        Keyword arguments to be passed through to `segs_to_raveler`.\n\n    Returns\n    -------\n    superpixels : numpy ndarray, shape (M, N, P)\n        The superpixel map. Non-zero superpixels are unique to each plane.\n        That is, `np.unique(superpixels[i])` and `np.unique(superpixels[j])` \n        have only 0 as their intersection.\n    sp_to_segment : numpy ndarray, shape (Q, 3)\n        The superpixel to segment map. Segments are unique to each plane. The\n        first number on each line is the plane number.\n    segment_to_body : numpy ndarray, shape (R, 2)\n        The segment to body map.\n    \"\"\"", "\n", "sps", "=", "label", "(", "ucm", "<", "sp_threshold", ")", "[", "0", "]", "\n", "bodies", "=", "label", "(", "ucm", "<=", "body_threshold", ")", "[", "0", "]", "\n", "return", "segs_to_raveler", "(", "sps", ",", "bodies", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.segs_to_raveler": [[617, 670], ["imio.raveler_serial_section_map", "numpy.unique", "numpy.concatenate", "enumerate", "logging.info", "numpy.concatenate", "imio.raveler_serial_section_map", "list", "zip", "sp_map_i.astype", "numpy.concatenate.append", "logging.debug", "zip", "numpy.array", "numpy.unique", "str", "raveler_serial_section_map.ravel", "bodies.ravel", "list", "len", "zip", "str", "numpy.unique", "itertools.repeat", "len", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.raveler_serial_section_map", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.raveler_serial_section_map"], ["", "def", "segs_to_raveler", "(", "sps", ",", "bodies", ",", "min_size", "=", "0", ",", "do_conn_comp", "=", "False", ",", "sps_out", "=", "None", ")", ":", "\n", "    ", "\"\"\"Return a Raveler tuple from 3D superpixel and body maps.\n    \n    Parameters\n    ----------\n    sps : numpy ndarray, shape (M, N, P)\n        The supervoxel map.\n    bodies : numpy ndarray, shape (M, N, P)\n        The body map. Superpixels should not map to more than one body.\n    min_size : int, optional (default: 0)\n        Superpixels smaller than this size on a particular plane are blacked\n        out.\n    do_conn_comp : bool (default: False)\n        Whether to do a connected components operation on each plane. This is\n        required if we want superpixels to be contiguous on each plane, since\n        3D-contiguous superpixels are not guaranteed to be contiguous along\n        a slice.\n    sps_out : numpy ndarray, shape (M, N, P), optional (default: None)\n        A Raveler-compatible superpixel map, meaning that superpixels are\n        unique to each plane along axis 0. (See `superpixels` in the return\n        values.) If provided, this saves significant computation time.\n\n    Returns\n    -------\n    superpixels : numpy ndarray, shape (M, N, P)\n        The superpixel map. Non-zero superpixels are unique to each plane.\n        That is, `np.unique(superpixels[i])` and `np.unique(superpixels[j])` \n        have only 0 as their intersection.\n    sp_to_segment : numpy ndarray, shape (Q, 3)\n        The superpixel to segment map. Segments are unique to each plane. The\n        first number on each line is the plane number.\n    segment_to_body : numpy ndarray, shape (R, 2)\n        The segment to body map.\n    \"\"\"", "\n", "if", "sps_out", "is", "None", ":", "\n", "        ", "sps_out", "=", "raveler_serial_section_map", "(", "sps", ",", "min_size", ",", "do_conn_comp", ",", "False", ")", "\n", "", "segment_map", "=", "raveler_serial_section_map", "(", "bodies", ",", "min_size", ",", "do_conn_comp", ")", "\n", "segment_to_body", "=", "unique", "(", "list", "(", "zip", "(", "segment_map", ".", "ravel", "(", ")", ",", "bodies", ".", "ravel", "(", ")", ")", ")", ")", "\n", "segment_to_body", "=", "segment_to_body", "[", "segment_to_body", "[", ":", ",", "0", "]", "!=", "0", "]", "\n", "segment_to_body", "=", "concatenate", "(", "(", "array", "(", "[", "[", "0", ",", "0", "]", "]", ")", ",", "segment_to_body", ")", ",", "axis", "=", "0", ")", "\n", "sp_to_segment", "=", "[", "]", "\n", "for", "i", ",", "(", "sp_map_i", ",", "segment_map_i", ",", "body_map_i", ")", "in", "enumerate", "(", "zip", "(", "sps_out", ",", "segment_map", ",", "bodies", ")", ")", ":", "\n", "        ", "segment_map_i", "*=", "sp_map_i", ".", "astype", "(", "bool", ")", "\n", "valid", "=", "(", "sp_map_i", "!=", "0", ")", "+", "(", "segment_map_i", "==", "0", ")", "\n", "sp_to_segment", ".", "append", "(", "\n", "unique", "(", "list", "(", "zip", "(", "it", ".", "repeat", "(", "i", ")", ",", "sp_map_i", "[", "valid", "]", ",", "segment_map_i", "[", "valid", "]", ")", ")", ")", ")", "\n", "valid", "=", "segment_map", "!=", "0", "\n", "logging", ".", "debug", "(", "'plane %i done'", "%", "i", ")", "\n", "", "logging", ".", "info", "(", "'total superpixels before: '", "+", "str", "(", "len", "(", "unique", "(", "sps", ")", ")", ")", "+", "\n", "' total superpixels after: '", "+", "str", "(", "len", "(", "unique", "(", "sps_out", ")", ")", ")", ")", "\n", "sp_to_segment", "=", "concatenate", "(", "sp_to_segment", ",", "axis", "=", "0", ")", "\n", "return", "sps_out", ",", "sp_to_segment", ",", "segment_to_body", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.raveler_serial_section_map": [[671, 689], ["imio.serial_section_map"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.serial_section_map"], ["", "def", "raveler_serial_section_map", "(", "nd_map", ",", "min_size", "=", "0", ",", "do_conn_comp", "=", "False", ",", "\n", "globally_unique_ids", "=", "True", ")", ":", "\n", "    ", "\"\"\"Produce `serial_section_map` and label one corner of each plane as 0.\n\n    Raveler chokes when there are no pixels with label 0 on a plane, so this\n    function produces the serial section map as normal but then adds a 0 to\n    the [0, 0] corner of each plane, IF the volume doesn't already have 0\n    pixels.\n\n    Notes\n    -----\n        See `serial_section_map` for more info.\n    \"\"\"", "\n", "nd_map", "=", "serial_section_map", "(", "nd_map", ",", "min_size", ",", "do_conn_comp", ",", "\n", "globally_unique_ids", ")", "\n", "if", "not", "(", "nd_map", "==", "0", ")", ".", "any", "(", ")", ":", "\n", "        ", "nd_map", "[", ":", ",", "0", ",", "0", "]", "=", "0", "\n", "", "return", "nd_map", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.serial_section_map": [[690, 732], ["map", "zip", "numpy.concatenate", "morpho.remove_small_connected_components", "numpy.concatenate", "evaluate.relabel_from_one", "map", "len", "zip", "len", "numpy.array", "numpy.cumsum"], "function", ["None"], ["", "def", "serial_section_map", "(", "nd_map", ",", "min_size", "=", "0", ",", "do_conn_comp", "=", "False", ",", "\n", "globally_unique_ids", "=", "True", ")", ":", "\n", "    ", "\"\"\"Produce a plane-by-plane superpixel map with unique IDs.\n\n    Raveler requires sps to be unique and different on each plane. This\n    function converts a fully 3D superpixel map to a serial-2D superpixel\n    map compatible with Raveler.\n\n    Parameters\n    ----------\n    nd_map : np.ndarray, int, shape (M, N, P)\n        The original superpixel map.\n    min_size : int (optional, default 0)\n        Remove superpixels smaller than this size (on each plane)\n    do_conn_comp : bool (optional, default False)\n        In some cases, a single supervoxel may result in two disconnected\n        superpixels in 2D. Set to True to force these to have different IDs.\n    globally_unique_ids : bool (optional, default True)\n        If True, every plane has unique IDs, with plane n having IDs {i1, i2,\n        ..., in} and plane n+1 having IDs {in+1, in+2, ..., in+ip}, and so on.\n\n    Returns\n    -------\n    relabeled_planes : np.ndarray, int, shape (M, N, P)\n        A volume equal to nd_map but with superpixels relabeled along axis 0.\n        That is, the input volume is reinterpreted as M slices of shape (N, P).\n    \"\"\"", "\n", "if", "do_conn_comp", ":", "\n", "        ", "label_fct", "=", "label", "\n", "", "else", ":", "\n", "        ", "def", "label_fct", "(", "a", ")", ":", "\n", "            ", "relabeled", ",", "fmap", ",", "imap", "=", "evaluate", ".", "relabel_from_one", "(", "a", ")", "\n", "return", "relabeled", ",", "len", "(", "imap", ")", "\n", "", "", "def", "remove_small", "(", "a", ")", ":", "\n", "        ", "return", "morpho", ".", "remove_small_connected_components", "(", "a", ",", "min_size", ")", "\n", "", "mplanes", "=", "map", "(", "remove_small", ",", "nd_map", ")", "\n", "relabeled_planes", ",", "nids_per_plane", "=", "zip", "(", "*", "map", "(", "label_fct", ",", "mplanes", ")", ")", "\n", "start_ids", "=", "concatenate", "(", "(", "array", "(", "[", "0", "]", ",", "int", ")", ",", "cumsum", "(", "nids_per_plane", ")", "[", ":", "-", "1", "]", ")", ")", "if", "globally_unique_ids", "else", "[", "0", "]", "*", "len", "(", "nids_per_plane", ")", "\n", "relabeled_planes", "=", "[", "(", "relabeled_plane", "+", "start_id", ")", "[", "newaxis", ",", "...", "]", "\n", "for", "relabeled_plane", ",", "start_id", "in", "zip", "(", "relabeled_planes", ",", "start_ids", ")", "]", "\n", "return", "concatenate", "(", "relabeled_planes", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_to_raveler": [[733, 827], ["os.path.join", "os.path.join", "os.path.join", "numpy.savetxt", "numpy.savetxt", "imio.write_png_image_stack", "os.path.exists", "os.makedirs", "os.path.join", "os.path.join", "os.path.exists", "os.mkdir", "os.path.join", "imio.write_png_image_stack", "imio.write_json", "tempfile.TemporaryFile", "subprocess.call", "os.path.exists", "os.mkdir", "os.path.join", "type", "morpho.orphans", "morpho.non_traversing_segments", "imio.raveler_body_annotations", "os.path.join", "imio.write_to_raveler.call"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_png_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_png_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_json", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.orphans", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.non_traversing_segments", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.raveler_body_annotations"], ["", "def", "write_to_raveler", "(", "sps", ",", "sp_to_segment", ",", "segment_to_body", ",", "directory", ",", "gray", "=", "None", ",", "\n", "raveler_dir", "=", "'/usr/local/raveler-hdf'", ",", "nproc_contours", "=", "16", ",", "\n", "body_annot", "=", "None", ")", ":", "\n", "    ", "\"\"\"Output a segmentation to Raveler format. \n\n    Parameters\n    ----------\n    sps : np.ndarray, int, shape (nplanes, nx, ny)\n        The superpixel map. Superpixels can only occur on one plane.\n    sp_to_segment : np.ndarray, int, shape (nsps + nplanes, 3)\n        Superpixel-to-segment map as a 3 column list of (plane number,\n        superpixel id, segment id). Segments must be unique to a plane, and\n        each plane must contain the map {0: 0}\n    segment_to_body: np.ndarray, int, shape (nsegments, 2)\n        The segment to body map.\n    directory: string \n        The directory in which to write the stack. This directory and all\n        necessary subdirectories will be created.\n    gray: np.ndarray, uint8 or uint16, shape (nplanes, nx, ny) (optional)\n        The grayscale images corresponding to the superpixel maps.\n    raveler dir: string (optional, default `/usr/local/raveler-hdf`)\n        Where Raveler is installed.\n    nproc_contours: int (optional, default 16) \n        How many processes to use when generating the Raveler contours.\n    body_annot: dict or np.ndarray (optional)\n        Either a dictionary to write to JSON in Raveler body annotation\n        format, or a numpy ndarray of the segmentation from which to compute\n        orphans and non traversing bodies (which then get written out as body\n        annotations).\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n        Raveler is the EM segmentation proofreading tool developed in-house at\n        Janelia for the FlyEM project.\n    \"\"\"", "\n", "sp_path", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'superpixel_maps'", ")", "\n", "im_path", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'grayscale_maps'", ")", "\n", "tile_path", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'tiles'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "directory", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "directory", ")", "\n", "\n", "# write superpixel->segment->body maps", "\n", "", "savetxt", "(", "os", ".", "path", ".", "join", "(", "directory", ",", "'superpixel_to_segment_map.txt'", ")", ",", "\n", "sp_to_segment", ",", "'%i'", ")", "\n", "savetxt", "(", "os", ".", "path", ".", "join", "(", "directory", ",", "'segment_to_body_map.txt'", ")", ",", "\n", "segment_to_body", ",", "'%i'", ")", "\n", "\n", "# write superpixels", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "sp_path", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "sp_path", ")", "\n", "", "write_png_image_stack", "(", "sps", ",", "os", ".", "path", ".", "join", "(", "sp_path", ",", "'sp_map.%05i.png'", ")", ",", "\n", "bitdepth", "=", "16", ",", "axis", "=", "0", ")", "\n", "\n", "# write grayscale", "\n", "if", "gray", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "im_path", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "im_path", ")", "\n", "", "write_png_image_stack", "(", "gray", ",", "\n", "os", ".", "path", ".", "join", "(", "im_path", ",", "'img.%05d.png'", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# body annotations", "\n", "", "if", "body_annot", "is", "not", "None", ":", "\n", "        ", "if", "type", "(", "body_annot", ")", "==", "ndarray", ":", "\n", "            ", "orphans", "=", "morpho", ".", "orphans", "(", "body_annot", ")", "\n", "non_traversing", "=", "morpho", ".", "non_traversing_segments", "(", "body_annot", ")", "\n", "body_annot", "=", "raveler_body_annotations", "(", "orphans", ",", "non_traversing", ")", "\n", "", "write_json", "(", "body_annot", ",", "os", ".", "path", ".", "join", "(", "directory", ",", "'annotations-body.json'", ")", ")", "\n", "\n", "# make tiles, bounding boxes, and contours, and compile HDF5 stack info.", "\n", "", "with", "tmp", ".", "TemporaryFile", "(", ")", "as", "tmp_stdout", ":", "\n", "        ", "try", ":", "\n", "            ", "def", "call", "(", "arglist", ")", ":", "\n", "                ", "return", "subprocess", ".", "call", "(", "arglist", ",", "stdout", "=", "tmp_stdout", ")", "\n", "", "r1", "=", "call", "(", "[", "'createtiles'", ",", "im_path", ",", "sp_path", ",", "tile_path", "]", ")", "\n", "r2", "=", "call", "(", "[", "'bounds'", ",", "directory", "]", ")", "\n", "r3", "=", "call", "(", "[", "'compilestack'", ",", "directory", "]", ")", "\n", "", "except", ":", "\n", "            ", "logging", ".", "warning", "(", "\n", "'Error during Raveler export post-processing step. '", "+", "\n", "'Possible causes are that you do not have Raveler installed '", "+", "\n", "'or you did not specify the correct installation path.'", ")", "\n", "logging", ".", "warning", "(", "'Return codes: %i, %i, %i'", "%", "(", "r1", ",", "r2", ",", "r3", ")", ")", "\n", "#            with sys.exc_info() as ex:", "\n", "#                logging.warning('Exception info:\\n' + '\\n'.join(map(str, ex)))", "\n", "# make permissions friendly for proofreaders.", "\n", "", "", "try", ":", "\n", "        ", "subprocess", ".", "call", "(", "[", "'chmod'", ",", "'-R'", ",", "'go=u'", ",", "directory", "]", ")", "\n", "", "except", ":", "\n", "        ", "logging", ".", "warning", "(", "'Could not change Raveler export permissions.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.raveler_output_shortcut": [[828, 856], ["imio.segs_to_raveler", "imio.write_to_raveler"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.segs_to_raveler", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_to_raveler"], ["", "", "def", "raveler_output_shortcut", "(", "svs", ",", "seg", ",", "gray", ",", "outdir", ",", "sps_out", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute the Raveler format and write to directory, all at once.\n    \n    Parameters\n    ----------\n    svs : np.ndarray, int, shape (M, N, P)\n        The supervoxel map.\n    seg : np.ndarray, int, shape (M, N, P)\n        The segmentation map. It is assumed that no supervoxel crosses\n        any segment boundary.\n    gray : np.ndarray, uint8, shape (M, N, P)\n        The grayscale EM images corresponding to the above segmentations.\n    outdir : string\n        The export directory for the Raveler volume.\n    sps_out : np.ndarray, int, shape (M, N, P) (optional)\n        The precomputed serial section 2D superpixel map. Output will be\n        much faster if this is provided.\n\n    Returns\n    -------\n    sps_out : np.ndarray, int, shape (M, N, P)\n        The computed serial section 2D superpixel map. Keep this when\n        making multiple calls to `raveler_output_shortcut` with the\n        same supervoxel map.\n    \"\"\"", "\n", "sps_out", ",", "sp2seg", ",", "seg2body", "=", "segs_to_raveler", "(", "svs", ",", "seg", ",", "sps_out", "=", "sps_out", ")", "\n", "write_to_raveler", "(", "sps_out", ",", "sp2seg", ",", "seg2body", ",", "outdir", ",", "gray", ",", "body_annot", "=", "seg", ")", "\n", "return", "sps_out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.raveler_body_annotations": [[857, 892], ["data.extend", "int", "int"], "function", ["None"], ["", "def", "raveler_body_annotations", "(", "orphans", ",", "non_traversing", "=", "None", ")", ":", "\n", "    ", "\"\"\"Return a Raveler body annotation dictionary of orphan segments.\n\n    Orphans are labeled as body annotations with `not sure` status and\n    a string indicating `orphan` in the comments field.\n\n    Non-traversing segments have only one contact with the surface of\n    the volume, and are labeled `does not traverse` in the comments.\n\n    Parameters\n    ----------\n    orphans : iterable of int\n        The ID numbers corresponding to orphan segments.\n    non_traversing : iterable of int (optional, default None)\n        The ID numbers of segments having only one exit point in the volume.\n\n    Returns\n    -------\n    body_annotations : dict\n        A dictionary containing entries for 'data' and 'metadata' as\n        specified in the Raveler body annotations format [1, 2].\n\n    References\n    ----------\n    [1] https://wiki.janelia.org/wiki/display/flyem/body+annotation+file+format\n    and:\n    [2] https://wiki.janelia.org/wiki/display/flyem/generic+file+format\n    \"\"\"", "\n", "data", "=", "[", "{", "'status'", ":", "'not sure'", ",", "'comment'", ":", "'orphan'", ",", "'body ID'", ":", "int", "(", "o", ")", "}", "\n", "for", "o", "in", "orphans", "]", "\n", "if", "non_traversing", "is", "not", "None", ":", "\n", "        ", "data", ".", "extend", "(", "[", "{", "'status'", ":", "'not sure'", ",", "'comment'", ":", "'does not traverse'", ",", "\n", "'body ID'", ":", "int", "(", "n", ")", "}", "for", "n", "in", "non_traversing", "]", ")", "\n", "", "metadata", "=", "{", "'description'", ":", "'body annotations'", ",", "'file version'", ":", "2", "}", "\n", "return", "{", "'data'", ":", "data", ",", "'metadata'", ":", "metadata", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_json": [[893, 918], ["os.path.join", "open", "json.dump"], "function", ["None"], ["", "def", "write_json", "(", "annot", ",", "fn", "=", "'annotations-body.json'", ",", "directory", "=", "None", ")", ":", "\n", "    ", "\"\"\"Write an annotation dictionary in Raveler format to a JSON file.\n    \n    The annotation file format is described in:\n    https://wiki.janelia.org/wiki/display/flyem/body+annotation+file+format\n    and:\n    https://wiki.janelia.org/wiki/display/flyem/generic+file+format\n\n    Parameters\n    ----------\n    annot : dict\n        A body annotations dictionary (described in pages above).\n    fn : string (optional, default 'annotations-body.json')\n        The filename to which to write the file.\n    directory : string (optional, default None, or '.')\n        A directory in which to write the file.\n\n    Returns\n    -------\n    None\n    \"\"\"", "\n", "if", "directory", "is", "not", "None", ":", "\n", "        ", "fn", "=", "join_path", "(", "directory", ",", "fn", ")", "\n", "", "with", "open", "(", "fn", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "annot", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.raveler_rgba_to_int": [[920, 948], ["numpy.arange"], "function", ["None"], ["", "", "def", "raveler_rgba_to_int", "(", "im", ",", "ignore_alpha", "=", "True", ")", ":", "\n", "    ", "\"\"\"Convert a volume using Raveler's RGBA encoding to int. [1]\n\n    Parameters\n    ----------\n    im : np.ndarray, shape (M, N, P, 4)\n        The image stack to be converted.\n    ignore_alpha : bool, optional\n        By default, the alpha channel does not encode anything. However, if\n        we ever need 32 bits, it would be used. This function supports that\n        with `ignore_alpha=False`. (default is True.)\n\n    Returns\n    -------\n    im_int : np.ndarray, shape (M, N, P)\n        The label volume.\n\n    References\n    ----------\n    [1] https://wiki.janelia.org/wiki/display/flyem/Proofreading+data+and+formats\n    \"\"\"", "\n", "if", "im", ".", "ndim", "==", "4", "and", "im", ".", "shape", "[", "3", "]", "==", "4", ":", "\n", "        ", "if", "ignore_alpha", ":", "\n", "            ", "im", "=", "im", "[", "...", ",", ":", "3", "]", "\n", "", "im_int", "=", "(", "im", "*", "255", "**", "np", ".", "arange", "(", "im", ".", "shape", "[", "3", "]", ")", ")", ".", "sum", "(", "axis", "=", "3", ")", "\n", "", "else", ":", "\n", "        ", "im_int", "=", "im", "\n", "", "return", "im_int", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.raveler_to_labeled_volume": [[950, 1014], ["imio.read_image_stack", "imio.raveler_rgba_to_int", "numpy.loadtxt", "numpy.loadtxt", "sp2seg_list[].max", "sp2seg_list[].min", "seg2bod_list[].max", "numpy.zeros", "numpy.zeros_like", "enumerate", "os.path.join", "os.path.join", "os.path.join", "morpho.watershed", "json.load", "numpy.zeros", "numpy.ones_like", "open", "os.path.join", "a.get"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.raveler_rgba_to_int", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed"], ["", "def", "raveler_to_labeled_volume", "(", "rav_export_dir", ",", "get_glia", "=", "False", ",", "\n", "use_watershed", "=", "False", ",", "probability_map", "=", "None", ",", "crop", "=", "None", ")", ":", "\n", "    ", "\"\"\"Import a raveler export stack into a labeled segmented volume.\n    \n    Parameters\n    ----------\n    rav_export_dir : string\n        The directory containing the Raveler stack.\n    get_glia : bool (optional, default False)\n        Return the segment numbers corresponding to glia, if available.\n    use_watershed : bool (optional, default False)\n        Fill in 0-labeled voxels using watershed.\n    probability_map : np.ndarray, same shape as volume to be read (optional)\n        If `use_watershed` is True, use `probability_map` as the landscape. If\n        this is not provided, it uses a flat landscape.\n    crop : tuple of int (optional, default None)\n        A 6-tuple of [xmin, xmax, ymin, ymax, zmin, zmax].\n\n    Returns\n    -------\n    output_volume : np.ndarray, shape (Z, X, Y)\n        The segmentation in the Raveler volume.\n    glia : list of int (optional, only returned if `get_glia` is True)\n        The IDs in the segmentation corresponding to glial cells.\n    \"\"\"", "\n", "from", ".", "import", "morpho", "\n", "spmap", "=", "read_image_stack", "(", "\n", "os", ".", "path", ".", "join", "(", "rav_export_dir", ",", "'superpixel_maps'", ",", "'*.png'", ")", ",", "crop", "=", "crop", ")", "\n", "spmap", "=", "raveler_rgba_to_int", "(", "spmap", ")", "\n", "sp2seg_list", "=", "np", ".", "loadtxt", "(", "\n", "os", ".", "path", ".", "join", "(", "rav_export_dir", ",", "'superpixel_to_segment_map.txt'", ")", ",", "uint32", ")", "\n", "seg2bod_list", "=", "np", ".", "loadtxt", "(", "\n", "os", ".", "path", ".", "join", "(", "rav_export_dir", ",", "'segment_to_body_map.txt'", ")", ",", "uint32", ")", "\n", "sp2seg", "=", "{", "}", "\n", "max_sp", "=", "sp2seg_list", "[", ":", ",", "1", "]", ".", "max", "(", ")", "\n", "start_plane", "=", "sp2seg_list", "[", ":", ",", "0", "]", ".", "min", "(", ")", "\n", "for", "z", ",", "sp", ",", "seg", "in", "sp2seg_list", ":", "\n", "        ", "if", "z", "not", "in", "sp2seg", ":", "\n", "            ", "sp2seg", "[", "z", "]", "=", "zeros", "(", "max_sp", "+", "1", ",", "uint32", ")", "\n", "", "sp2seg", "[", "z", "]", "[", "sp", "]", "=", "seg", "\n", "", "max_seg", "=", "seg2bod_list", "[", ":", ",", "0", "]", ".", "max", "(", ")", "\n", "seg2bod", "=", "zeros", "(", "max_seg", "+", "1", ",", "uint32", ")", "\n", "seg2bod", "[", "seg2bod_list", "[", ":", ",", "0", "]", "]", "=", "seg2bod_list", "[", ":", ",", "1", "]", "\n", "initial_output_volume", "=", "zeros_like", "(", "spmap", ")", "\n", "for", "i", ",", "m", "in", "enumerate", "(", "spmap", ")", ":", "\n", "        ", "j", "=", "start_plane", "+", "i", "\n", "initial_output_volume", "[", "i", "]", "=", "seg2bod", "[", "sp2seg", "[", "j", "]", "[", "m", "]", "]", "\n", "", "if", "use_watershed", ":", "\n", "        ", "probs", "=", "np", ".", "ones_like", "(", "spmap", ")", "if", "probability_map", "is", "None", "else", "probability_map", "\n", "output_volume", "=", "morpho", ".", "watershed", "(", "probs", ",", "seeds", "=", "initial_output_volume", ")", "\n", "", "else", ":", "\n", "        ", "output_volume", "=", "initial_output_volume", "\n", "", "if", "(", "output_volume", "[", ":", ",", "0", ",", "0", "]", "==", "0", ")", ".", "all", "(", ")", "and", "(", "output_volume", "==", "0", ")", ".", "sum", "(", ")", "==", "output_volume", ".", "shape", "[", "0", "]", ":", "\n", "        ", "output_volume", "[", ":", ",", "0", ",", "0", "]", "=", "output_volume", "[", ":", ",", "0", ",", "1", "]", "\n", "", "if", "get_glia", ":", "\n", "        ", "annots", "=", "json", ".", "load", "(", "\n", "open", "(", "os", ".", "path", ".", "join", "(", "rav_export_dir", ",", "'annotations-body.json'", ")", ",", "'r'", ")", ")", "\n", "glia", "=", "[", "a", "[", "'body ID'", "]", "for", "a", "in", "annots", "[", "'data'", "]", "\n", "if", "a", ".", "get", "(", "'comment'", ",", "None", ")", "==", "'glia'", "]", "\n", "return", "output_volume", ",", "glia", "\n", "", "else", ":", "\n", "        ", "return", "output_volume", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_ilastik_project": [[1022, 1076], ["h5py.File", "numpy.array", "numpy.array", "enumerate", "numpy.array", "h5py.File.close", "type", "numpy.unique", "zip", "im.reshape.reshape", "lb.reshape.reshape", "label_attributes.items", "numpy.array", "numpy.concatenate", "max", "list", "len", "map", "ValueError", "map"], "function", ["None"], ["def", "write_ilastik_project", "(", "images", ",", "labels", ",", "fn", ",", "label_names", "=", "None", ")", ":", "\n", "    ", "\"\"\"Write one or more image volumes and corresponding labels to Ilastik.\n    \n    Parameters\n    ----------\n    images : np.ndarray or list of np.ndarray, shapes (M_i, N_i[, P_i])\n        The grayscale images to be saved.\n    labels : np.ndarray or list of np.ndarray, same shapes as `images`\n        The label maps corresponding to the images.\n    fn : string\n        The filename to save the project in.\n    label_names : list of string (optional)\n        The names corresponding to each label in `labels`. (Not implemented!)\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    Limitations:\n        Assumes the same labels are used for all images.\n        Supports only grayscale images and volumes, and a maximum of 8 labels.\n        Requires at least one unlabeled voxel in the label field.\n    \"\"\"", "\n", "f", "=", "h5py", ".", "File", "(", "fn", ",", "'w'", ")", "\n", "if", "type", "(", "images", ")", "!=", "list", ":", "\n", "        ", "images", "=", "[", "images", "]", "\n", "labels", "=", "[", "labels", "]", "\n", "", "ulbs", "=", "unique", "(", "concatenate", "(", "list", "(", "map", "(", "unique", ",", "labels", ")", ")", ")", ")", "[", "1", ":", "]", "\n", "colors", "=", "array", "(", "ilastik_label_colors", "[", ":", "len", "(", "ulbs", ")", "]", ")", "\n", "names", "=", "[", "'Label %i'", "%", "i", "for", "i", "in", "ulbs", "]", "\n", "names", "=", "array", "(", "names", ",", "'|S%i'", "%", "max", "(", "map", "(", "len", ",", "names", ")", ")", ")", "\n", "label_attributes", "=", "{", "'color'", ":", "colors", ",", "'name'", ":", "names", ",", "'number'", ":", "ulbs", "}", "\n", "for", "i", ",", "(", "im", ",", "lb", ")", "in", "enumerate", "(", "zip", "(", "images", ",", "labels", ")", ")", ":", "\n", "        ", "if", "im", ".", "ndim", "==", "2", ":", "\n", "            ", "new_shape", "=", "(", "1", ",", "1", ")", "+", "im", ".", "shape", "+", "(", "1", ",", ")", "\n", "", "elif", "im", ".", "ndim", "==", "3", ":", "\n", "            ", "new_shape", "=", "(", "1", ",", ")", "+", "im", ".", "shape", "+", "(", "1", ",", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unsupported number of dimensions in image.'", ")", "\n", "", "im", "=", "im", ".", "reshape", "(", "new_shape", ")", "\n", "lb", "=", "lb", ".", "reshape", "(", "new_shape", ")", "\n", "root", "=", "'DataSets/dataItem%02i/'", "%", "i", "\n", "f", "[", "root", "+", "'data'", "]", "=", "im", "\n", "f", "[", "root", "+", "'labels'", "]", "=", "lb", "\n", "for", "k", ",", "v", "in", "label_attributes", ".", "items", "(", ")", ":", "\n", "            ", "f", "[", "root", "+", "'labels'", "]", ".", "attrs", "[", "k", "]", "=", "v", "\n", "", "f", "[", "root", "]", ".", "attrs", "[", "'Name'", "]", "=", "''", "\n", "f", "[", "root", "]", ".", "attrs", "[", "'fileName'", "]", "=", "''", "\n", "", "for", "subgroup", "in", "[", "'Description'", ",", "'Labeler'", ",", "'Name'", "]", ":", "\n", "        ", "f", "[", "'Project/%s'", "%", "subgroup", "]", "=", "array", "(", "''", ",", "dtype", "=", "'|S1'", ")", "\n", "", "f", "[", "'ilastikVersion'", "]", "=", "array", "(", "0.5", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_ilastik_batch_volume": [[1077, 1098], ["imio.write_h5_stack", "im.reshape.reshape", "im.reshape.reshape", "ValueError"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_h5_stack"], ["", "def", "write_ilastik_batch_volume", "(", "im", ",", "fn", ")", ":", "\n", "    ", "\"\"\"Write a volume to an HDF5 file for Ilastik batch processing.\n    \n    Parameters\n    ----------\n    im : np.ndarray, shape (M, N[, P])\n        The image volume to be saved.\n    fn : string\n        The filename in which to save the volume.\n\n    Returns\n    -------\n    None\n    \"\"\"", "\n", "if", "im", ".", "ndim", "==", "2", ":", "\n", "        ", "im", "=", "im", ".", "reshape", "(", "(", "1", ",", "1", ")", "+", "im", ".", "shape", "+", "(", "1", ",", ")", ")", "\n", "", "elif", "im", ".", "ndim", "==", "3", ":", "\n", "        ", "im", "=", "im", ".", "reshape", "(", "(", "1", ",", ")", "+", "im", ".", "shape", "+", "(", "1", ",", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unsupported number of dimensions in image.'", ")", "\n", "", "write_h5_stack", "(", "im", ",", "fn", ",", "group", "=", "'/volume/data'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_prediction_from_ilastik_batch": [[1099, 1121], ["numpy.squeeze", "kwargs.get", "imio.read_h5_stack"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack"], ["", "def", "read_prediction_from_ilastik_batch", "(", "fn", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Read the prediction produced by Ilastik from batch processing.\n    \n    Parameters\n    ----------\n    fn : string\n        The filename to read from.\n    group : string (optional, default '/volume/prediction')\n        Where to read from in the HDF5 file hierarchy.\n    single_channel : bool (optional, default True)\n        Read only the 0th channel (final dimension) from the volume.\n\n    Returns\n    -------\n    None\n    \"\"\"", "\n", "if", "'group'", "not", "in", "kwargs", ":", "\n", "        ", "kwargs", "[", "'group'", "]", "=", "'/volume/prediction'", "\n", "", "a", "=", "squeeze", "(", "read_h5_stack", "(", "fn", ",", "**", "kwargs", ")", ")", "\n", "if", "kwargs", ".", "get", "(", "'single_channel'", ",", "True", ")", ":", "\n", "        ", "a", "=", "a", "[", "...", ",", "0", "]", "\n", "", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_cremi": [[1123, 1153], ["imio.read_h5_stack"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack"], ["", "def", "read_cremi", "(", "fn", ",", "datasets", "=", "[", "'/volumes/raw'", ",", "'/volumes/labels/neuron_ids'", "]", ")", ":", "\n", "    ", "\"\"\"Read volume formatted as described in CREMI data challenge [1]_.\n\n    The format is HDF5, with:\n        - raw image data (uint8) in: /volumes/raw\n        - (optional) membrane prediction data (uint8, inverted) in:\n          /volumes/membrane\n        - synaptic cleft annotations in: /volumes/labels/clefts\n        - neuron ids (uint64) in: /volumes/labels/neuron_ids\n        - (optional) fragment data (uint64) in: /volumes/labels/fragments\n\n    We currently ignore the synaptic cleft annotations, and return only\n    the raw image and the neuron ids.\n\n    Parameters\n    ----------\n    fn : string\n        The input filename.\n\n    Returns\n    -------\n    datasets : list of array\n        The arrays corresponding to the requested datasets.\n\n    References\n    ----------\n    .. [1]: https://cremi.org/data/\n    \"\"\"", "\n", "out", "=", "[", "read_h5_stack", "(", "fn", ",", "group", "=", "ds", ")", "for", "ds", "in", "datasets", "]", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_cremi": [[1155, 1171], ["data_dict.items", "imio.write_h5_stack"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_h5_stack"], ["", "def", "write_cremi", "(", "data_dict", ",", "fn", ",", "resolution", "=", "(", "40.", ",", "4.", ",", "4.", ")", ")", ":", "\n", "    ", "\"\"\"Write a volume formatted as described in CREMI data challenge [1]_.\n\n    Parameters\n    ----------\n    data_dict : dictionary of string to arrays\n        The data dictionary mapping HDF groups to arrays.\n    fn : string\n        The filename to write to.\n    resolution : tuple of float, optional\n        The resolution along each axis of the datasets. Currently, this\n        is the same for each dataset written.\n    \"\"\"", "\n", "for", "group", ",", "data", "in", "data_dict", ".", "items", "(", ")", ":", "\n", "        ", "write_h5_stack", "(", "data", ",", "fn", ",", "group", "=", "group", ",", "compression", "=", "'gzip'", ",", "\n", "attrs", "=", "{", "'resolution'", ":", "resolution", "}", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.complement": [[30, 32], ["a.max"], "function", ["None"], ["def", "complement", "(", "a", ")", ":", "\n", "    ", "return", "a", ".", "max", "(", ")", "-", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.remove_merged_boundaries": [[34, 70], ["labels.copy", "labels.copy", "scipy.ndimage.generate_binary_structure", "scipy.ndimage.grey_erosion", "scipy.ndimage.grey_dilation", "labels.max"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "remove_merged_boundaries", "(", "labels", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Remove boundaries in a label field when they separate the same region.\n\n    By convention, the boundary label is 0, and labels are positive.\n\n    Parameters\n    ----------\n    labels : array of int\n        The label field to be processed.\n    connectivity : int in {1, ..., labels.ndim}, optional\n        The morphological connectivity for considering neighboring voxels.\n\n    Returns\n    -------\n    labels_out : array of int\n        The same label field, with unnecessary boundaries removed.\n\n    Examples\n    --------\n    >>> labels = np.array([[1, 0, 1], [0, 1, 0], [2, 0, 3]], np.int)\n    >>> remove_merged_boundaries(labels)\n    array([[1, 1, 1],\n           [0, 1, 0],\n           [2, 0, 3]])\n    \"\"\"", "\n", "boundary", "=", "0", "\n", "labels_out", "=", "labels", ".", "copy", "(", ")", "\n", "is_boundary", "=", "(", "labels", "==", "boundary", ")", "\n", "labels_complement", "=", "labels", ".", "copy", "(", ")", "\n", "labels_complement", "[", "is_boundary", "]", "=", "labels", ".", "max", "(", ")", "+", "1", "\n", "se", "=", "ndi", ".", "generate_binary_structure", "(", "labels", ".", "ndim", ",", "connectivity", ")", "\n", "smaller_labels", "=", "ndi", ".", "grey_erosion", "(", "labels_complement", ",", "footprint", "=", "se", ")", "\n", "bigger_labels", "=", "ndi", ".", "grey_dilation", "(", "labels", ",", "footprint", "=", "se", ")", "\n", "merged", "=", "is_boundary", "&", "(", "smaller_labels", "==", "bigger_labels", ")", "\n", "labels_out", "[", "merged", "]", "=", "smaller_labels", "[", "merged", "]", "\n", "return", "labels_out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.morphological_reconstruction": [[72, 86], ["scipy.ndimage.generate_binary_structure", "scipy.ndimage.grey_dilation", "numpy.minimum"], "function", ["None"], ["", "def", "morphological_reconstruction", "(", "marker", ",", "mask", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Perform morphological reconstruction of the marker into the mask.\n    \n    See the Matlab image processing toolbox documentation for details:\n    http://www.mathworks.com/help/toolbox/images/f18-16264.html\n    \"\"\"", "\n", "sel", "=", "generate_binary_structure", "(", "marker", ".", "ndim", ",", "connectivity", ")", "\n", "diff", "=", "True", "\n", "while", "diff", ":", "\n", "        ", "markernew", "=", "grey_dilation", "(", "marker", ",", "footprint", "=", "sel", ")", "\n", "markernew", "=", "minimum", "(", "markernew", ",", "mask", ")", "\n", "diff", "=", "(", "markernew", "-", "marker", ")", ".", "max", "(", ")", ">", "0", "\n", "marker", "=", "markernew", "\n", "", "return", "marker", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.hminima": [[87, 105], ["a.max", "morpho.morphological_reconstruction"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.morphological_reconstruction"], ["", "def", "hminima", "(", "a", ",", "thresh", ")", ":", "\n", "    ", "\"\"\"Suppress all minima that are shallower than thresh.\n\n    Parameters\n    ----------\n    a : array\n        The input array on which to perform hminima.\n    thresh : float\n        Any local minima shallower than this will be flattened.\n\n    Returns\n    -------\n    out : array\n        A copy of the input array with shallow minima suppressed.\n    \"\"\"", "\n", "maxval", "=", "a", ".", "max", "(", ")", "\n", "ainv", "=", "maxval", "-", "a", "\n", "return", "maxval", "-", "morphological_reconstruction", "(", "ainv", "-", "thresh", ",", "ainv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.regional_minima": [[110, 117], ["numpy.unique", "[].min", "morpho.complement", "morpho.morphological_reconstruction", "scipy.ndimage.minimum_filter", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.complement", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.morphological_reconstruction"], ["def", "regional_minima", "(", "a", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Find the regional minima in an ndarray.\"\"\"", "\n", "values", "=", "unique", "(", "a", ")", "\n", "delta", "=", "(", "values", "-", "minimum_filter", "(", "values", ",", "footprint", "=", "ones", "(", "3", ")", ")", ")", "[", "1", ":", "]", ".", "min", "(", ")", "\n", "marker", "=", "complement", "(", "a", ")", "\n", "mask", "=", "marker", "+", "delta", "\n", "return", "marker", "==", "morphological_reconstruction", "(", "marker", ",", "mask", ",", "connectivity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.impose_minima": [[118, 135], ["a.max", "numpy.zeros_like", "minima.astype.astype", "morpho.morphological_reconstruction"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.morphological_reconstruction"], ["", "def", "impose_minima", "(", "a", ",", "minima", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Transform 'a' so that its only regional minima are those in 'minima'.\n    \n    Parameters:\n        'a': an ndarray\n        'minima': a boolean array of same shape as 'a'\n        'connectivity': the connectivity of the structuring element used in\n        morphological reconstruction.\n    Value:\n        an ndarray of same shape as a with unmarked local minima paved over.\n    \"\"\"", "\n", "m", "=", "a", ".", "max", "(", ")", "\n", "mask", "=", "m", "-", "a", "\n", "marker", "=", "zeros_like", "(", "mask", ")", "\n", "minima", "=", "minima", ".", "astype", "(", "bool", ")", "\n", "marker", "[", "minima", "]", "=", "mask", "[", "minima", "]", "\n", "return", "m", "-", "morphological_reconstruction", "(", "marker", ",", "mask", ",", "connectivity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.minimum_seeds": [[136, 152], ["current_seeds.copy", "scipy.ndimage.generate_binary_structure", "scipy.ndimage.grey_dilation", "len", "numpy.arange", "numpy.bincount", "current_seeds.copy.max", "scipy.ndimage.measurements.label", "numpy.concatenate", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "minimum_seeds", "(", "current_seeds", ",", "min_seed_coordinates", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Ensure that each point in given coordinates has its own seed.\"\"\"", "\n", "seeds", "=", "current_seeds", ".", "copy", "(", ")", "\n", "sel", "=", "generate_binary_structure", "(", "seeds", ".", "ndim", ",", "connectivity", ")", "\n", "if", "seeds", ".", "dtype", "==", "bool", ":", "\n", "        ", "seeds", "=", "label", "(", "seeds", ",", "sel", ")", "[", "0", "]", "\n", "", "new_seeds", "=", "grey_dilation", "(", "seeds", ",", "footprint", "=", "sel", ")", "\n", "overlap", "=", "new_seeds", "[", "min_seed_coordinates", "]", "\n", "seed_overlap_counts", "=", "bincount", "(", "concatenate", "(", "(", "overlap", ",", "unique", "(", "seeds", ")", ")", ")", ")", "-", "1", "\n", "seeds_to_delete", "=", "(", "seed_overlap_counts", ">", "1", ")", "[", "seeds", "]", "\n", "seeds", "[", "seeds_to_delete", "]", "=", "0", "\n", "seeds_to_add", "=", "[", "m", "[", "overlap", "==", "0", "]", "for", "m", "in", "min_seed_coordinates", "]", "\n", "start", "=", "seeds", ".", "max", "(", ")", "+", "1", "\n", "num_seeds", "=", "len", "(", "seeds_to_add", "[", "0", "]", ")", "\n", "seeds", "[", "seeds_to_add", "]", "=", "arange", "(", "start", ",", "start", "+", "num_seeds", ")", "\n", "return", "seeds", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.split_exclusions": [[153, 178], ["labels.copy.copy", "labels.copy.max", "exclusions.copy", "scipy.ndimage.generate_binary_structure", "range", "scipy.ndimage.grey_dilation", "numpy.bincount", "sum", "numpy.zeros", "hashed.ravel", "morpho.watershed", "exclusions.max", "scipy.ndimage.measurements.label", "scipy.ndimage.measurements.label"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed"], ["", "def", "split_exclusions", "(", "image", ",", "labels", ",", "exclusions", ",", "dilation", "=", "0", ",", "connectivity", "=", "1", ",", "\n", "standard_seeds", "=", "False", ")", ":", "\n", "    ", "\"\"\"Ensure that no segment in 'labels' overlaps more than one exclusion.\"\"\"", "\n", "labels", "=", "labels", ".", "copy", "(", ")", "\n", "cur_label", "=", "labels", ".", "max", "(", ")", "\n", "dilated_exclusions", "=", "exclusions", ".", "copy", "(", ")", "\n", "foot", "=", "generate_binary_structure", "(", "exclusions", ".", "ndim", ",", "connectivity", ")", "\n", "for", "i", "in", "range", "(", "dilation", ")", ":", "\n", "        ", "dilated_exclusions", "=", "grey_dilation", "(", "exclusions", ",", "footprint", "=", "foot", ")", "\n", "", "hashed", "=", "labels", "*", "(", "exclusions", ".", "max", "(", ")", "+", "1", ")", "+", "exclusions", "\n", "hashed", "[", "exclusions", "==", "0", "]", "=", "0", "\n", "violations", "=", "bincount", "(", "hashed", ".", "ravel", "(", ")", ")", ">", "1", "\n", "violations", "[", "0", "]", "=", "False", "\n", "if", "sum", "(", "violations", ")", "!=", "0", ":", "\n", "        ", "offending_labels", "=", "labels", "[", "violations", "[", "hashed", "]", "]", "\n", "mask", "=", "zeros", "(", "labels", ".", "shape", ",", "dtype", "=", "bool", ")", "\n", "for", "offlabel", "in", "offending_labels", ":", "\n", "            ", "mask", "+=", "labels", "==", "offlabel", "\n", "", "if", "standard_seeds", ":", "\n", "            ", "seeds", "=", "label", "(", "mask", "*", "(", "image", "==", "0", ")", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "seeds", "=", "label", "(", "mask", "*", "dilated_exclusions", ")", "[", "0", "]", "\n", "", "seeds", "[", "seeds", ">", "0", "]", "+=", "cur_label", "\n", "labels", "[", "mask", "]", "=", "watershed", "(", "image", ",", "seeds", ",", "connectivity", ",", "mask", ")", "[", "mask", "]", "\n", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed": [[180, 269], ["scipy.ndimage.generate_binary_structure", "numpy.unique", "morpho.pad", "morpho.pad", "pad.ravel", "impose_minima.ravel", "morpho.pad", "pad.ravel", "morpho.build_neighbors_array", "morpho.build_levels_dict", "iterprogress.with_progress", "morpho.juicy_center", "morpho.regional_minima", "remove_small_connected_components", "scipy.ndimage.morphology.binary_opening", "morpho.hminima", "skimage.morphology.watershed", "iterprogress.StandardProgressBar", "iterprogress.NoProgressBar", "enumerate", "collections.deque", "skimage.segmentation.relabel_sequential", "scipy.ndimage.measurements.label", "morpho.impose_minima", "pad.max", "impose_minima.max", "len", "len", "collections.deque.popleft", "numpy.unique", "scipy.ndimage.morphology.binary_opening.astype", "collections.deque.extend", "any", "len", "len", "ar[].argmin"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.build_neighbors_array", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.build_levels_dict", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.with_progress", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.regional_minima", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.hminima", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.impose_minima"], ["", "def", "watershed", "(", "a", ",", "seeds", "=", "None", ",", "connectivity", "=", "1", ",", "mask", "=", "None", ",", "smooth_thresh", "=", "0.0", ",", "\n", "smooth_seeds", "=", "False", ",", "minimum_seed_size", "=", "0", ",", "dams", "=", "False", ",", "\n", "override_skimage", "=", "False", ",", "show_progress", "=", "False", ")", ":", "\n", "    ", "\"\"\"Perform the watershed algorithm of Vincent & Soille (1991).\n    \n    Parameters\n    ----------\n    a : np.ndarray, arbitrary shape and type\n        The input image on which to perform the watershed transform.\n    seeds : np.ndarray, int or bool type, same shape as `a` (optional)\n        The seeds for the watershed. If provided, these are the only basins\n        allowed, and the algorithm proceeds by flooding from the seeds.\n        Otherwise, every local minimum is used as a seed.\n    connectivity : int, {1, ..., a.ndim} (optional, default 1)\n        The neighborhood of each pixel, defined as in `scipy.ndimage`.\n    mask : np.ndarray, type bool, same shape as `a`. (optional)\n        If provided, perform watershed only in the parts of `a` that are set\n        to `True` in `mask`.\n    smooth_thresh : float (optional, default 0.0)\n        Local minima that are less deep than this threshold are suppressed,\n        using `hminima`.\n    smooth_seeds : bool (optional, default False)\n        Perform binary opening on the seeds, using the same connectivity as\n        the watershed.\n    minimum_seed_size : int (optional, default 0)\n        Remove seed regions smaller than this size.\n    dams : bool (optional, default False)\n        Place a dam where two basins meet. Set this to True if you require\n        0-labeled boundaries between different regions.\n    override_skimage : bool (optional, default False)\n        skimage.morphology.watershed is used to implement the main part of the\n        algorithm when `dams=False`. Use this flag to use the separate pure\n        Python implementation instead.\n    show_progress : bool (optional, default False)\n        Show a cute little ASCII progress bar (using the progressbar package)\n\n    Returns\n    -------\n    ws : np.ndarray, same shape as `a`, int type.\n        The watershed transform of the input image.\n    \"\"\"", "\n", "seeded", "=", "seeds", "is", "not", "None", "\n", "sel", "=", "generate_binary_structure", "(", "a", ".", "ndim", ",", "connectivity", ")", "\n", "# various keyword arguments operate by modifying the input image `a`.", "\n", "# However, we operate on a copy of it called `b`, so that `a` can be used", "\n", "# to break ties.", "\n", "b", "=", "a", "\n", "if", "not", "seeded", ":", "\n", "        ", "seeds", "=", "regional_minima", "(", "a", ",", "connectivity", ")", "\n", "", "if", "minimum_seed_size", ">", "0", ":", "\n", "        ", "seeds", "=", "remove_small_connected_components", "(", "seeds", ",", "minimum_seed_size", ")", "\n", "seeds", "=", "relabel_sequential", "(", "seeds", ")", "[", "0", "]", "\n", "", "if", "smooth_seeds", ":", "\n", "        ", "seeds", "=", "binary_opening", "(", "seeds", ",", "sel", ")", "\n", "", "if", "smooth_thresh", ">", "0.0", ":", "\n", "        ", "b", "=", "hminima", "(", "a", ",", "smooth_thresh", ")", "\n", "", "if", "seeds", ".", "dtype", "==", "bool", ":", "\n", "        ", "seeds", "=", "label", "(", "seeds", ",", "sel", ")", "[", "0", "]", "\n", "", "if", "not", "override_skimage", "and", "not", "dams", ":", "\n", "        ", "return", "skimage", ".", "morphology", ".", "watershed", "(", "b", ",", "seeds", ",", "sel", ",", "None", ",", "mask", ")", "\n", "", "elif", "seeded", ":", "\n", "        ", "b", "=", "impose_minima", "(", "a", ",", "seeds", ".", "astype", "(", "bool", ")", ",", "connectivity", ")", "\n", "", "levels", "=", "unique", "(", "b", ")", "\n", "a", "=", "pad", "(", "a", ",", "a", ".", "max", "(", ")", "+", "1", ")", "\n", "b", "=", "pad", "(", "b", ",", "b", ".", "max", "(", ")", "+", "1", ")", "\n", "ar", "=", "a", ".", "ravel", "(", ")", "\n", "br", "=", "b", ".", "ravel", "(", ")", "\n", "ws", "=", "pad", "(", "seeds", ",", "0", ")", "\n", "wsr", "=", "ws", ".", "ravel", "(", ")", "\n", "neighbors", "=", "build_neighbors_array", "(", "a", ",", "connectivity", ")", "\n", "level_pixels", "=", "build_levels_dict", "(", "b", ")", "\n", "if", "show_progress", ":", "wspbar", "=", "ip", ".", "StandardProgressBar", "(", "'Watershed...'", ")", "\n", "else", ":", "wspbar", "=", "ip", ".", "NoProgressBar", "(", ")", "\n", "for", "i", ",", "level", "in", "ip", ".", "with_progress", "(", "enumerate", "(", "levels", ")", ",", "\n", "pbar", "=", "wspbar", ",", "length", "=", "len", "(", "levels", ")", ")", ":", "\n", "        ", "idxs_adjacent_to_labels", "=", "queue", "(", "[", "idx", "for", "idx", "in", "level_pixels", "[", "level", "]", "if", "\n", "any", "(", "wsr", "[", "neighbors", "[", "idx", "]", "]", ")", "]", ")", "\n", "while", "len", "(", "idxs_adjacent_to_labels", ")", ">", "0", ":", "\n", "            ", "idx", "=", "idxs_adjacent_to_labels", ".", "popleft", "(", ")", "\n", "if", "wsr", "[", "idx", "]", ">", "0", ":", "continue", "# in case we already processed it", "\n", "nidxs", "=", "neighbors", "[", "idx", "]", "# neighbors", "\n", "lnidxs", "=", "nidxs", "[", "(", "wsr", "[", "nidxs", "]", "!=", "0", ")", ".", "astype", "(", "bool", ")", "]", "# labeled neighbors", "\n", "adj_labels", "=", "unique", "(", "wsr", "[", "lnidxs", "]", ")", "\n", "if", "len", "(", "adj_labels", ")", "==", "1", "or", "len", "(", "adj_labels", ")", ">", "1", "and", "not", "dams", ":", "\n", "# assign a label", "\n", "                ", "wsr", "[", "idx", "]", "=", "wsr", "[", "lnidxs", "]", "[", "ar", "[", "lnidxs", "]", ".", "argmin", "(", ")", "]", "\n", "idxs_adjacent_to_labels", ".", "extend", "(", "nidxs", "[", "(", "(", "wsr", "[", "nidxs", "]", "==", "0", ")", "*", "\n", "(", "br", "[", "nidxs", "]", "==", "level", ")", ")", ".", "astype", "(", "bool", ")", "]", ")", "\n", "", "", "", "return", "juicy_center", "(", "ws", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.multiscale_regular_seeds": [[271, 302], ["numpy.zeros", "skimage.util.regular_grid", "morpho._thin_seeds", "numpy.all", "scipy.ndimage.label"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho._thin_seeds"], ["", "def", "multiscale_regular_seeds", "(", "off_limits", ",", "num_seeds", ")", ":", "\n", "    ", "\"\"\"Return evenly-spaced seeds, but thinned in areas with no boundaries.\n\n    Parameters\n    ----------\n    off_limits : array of bool, shape (M, N)\n        A binary array where `True` indicates the position of a boundary,\n        and thus where we don't want to place seeds.\n    num_seeds : int\n        The desired number of seeds.\n\n    Returns\n    -------\n    seeds : array of int, shape (M, N)\n        An array of seed points. Each seed gets its own integer ID,\n        starting from 1.\n    \"\"\"", "\n", "seeds_binary", "=", "np", ".", "zeros", "(", "off_limits", ".", "shape", ",", "dtype", "=", "bool", ")", "\n", "grid", "=", "util", ".", "regular_grid", "(", "off_limits", ".", "shape", ",", "num_seeds", ")", "\n", "seeds_binary", "[", "grid", "]", "=", "True", "\n", "seeds_binary", "&=", "~", "off_limits", "\n", "seeds_img", "=", "seeds_binary", "[", "grid", "]", "\n", "thinned_equal", "=", "False", "\n", "step", "=", "2", "\n", "while", "not", "thinned_equal", ":", "\n", "        ", "thinned", "=", "_thin_seeds", "(", "seeds_img", ",", "step", ")", "\n", "thinned_equal", "=", "np", ".", "all", "(", "seeds_img", "==", "thinned", ")", "\n", "seeds_img", "=", "thinned", "\n", "step", "*=", "2", "\n", "", "seeds_binary", "[", "grid", "]", "=", "seeds_img", "\n", "return", "ndi", ".", "label", "(", "seeds_binary", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho._thin_seeds": [[304, 315], ["numpy.copy", "range", "range", "numpy.all", "slice", "slice", "min", "min"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "_thin_seeds", "(", "seeds_img", ",", "step", ")", ":", "\n", "    ", "out", "=", "np", ".", "copy", "(", "seeds_img", ")", "\n", "m", ",", "n", "=", "seeds_img", ".", "shape", "\n", "for", "r", "in", "range", "(", "0", ",", "m", ",", "step", ")", ":", "\n", "        ", "for", "c", "in", "range", "(", "0", ",", "n", ",", "step", ")", ":", "\n", "            ", "window", "=", "(", "slice", "(", "r", ",", "min", "(", "r", "+", "5", "*", "step", "//", "2", ",", "m", ")", ",", "step", "//", "2", ")", ",", "\n", "slice", "(", "c", ",", "min", "(", "c", "+", "5", "*", "step", "//", "2", ",", "n", ")", ",", "step", "//", "2", ")", ")", "\n", "if", "np", ".", "all", "(", "seeds_img", "[", "window", "]", ")", ":", "\n", "                ", "out", "[", "window", "]", "[", "1", ":", ":", "2", ",", ":", "]", "=", "False", "\n", "out", "[", "window", "]", "[", ":", ",", "1", ":", ":", "2", "]", "=", "False", "\n", "", "", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.multiscale_seed_sequence": [[317, 327], ["numpy.zeros", "zip", "skimage.feature.hessian_matrix", "skimage.feature.hessian_matrix_eigvals", "morpho.multiscale_regular_seeds"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.multiscale_regular_seeds"], ["", "def", "multiscale_seed_sequence", "(", "prob", ",", "l1_threshold", "=", "0", ",", "grid_density", "=", "10", ")", ":", "\n", "    ", "npoints", "=", "(", "(", "prob", ".", "shape", "[", "1", "]", "//", "grid_density", ")", "*", "\n", "(", "prob", ".", "shape", "[", "2", "]", "//", "grid_density", ")", ")", "\n", "seeds", "=", "np", ".", "zeros", "(", "prob", ".", "shape", ",", "dtype", "=", "int", ")", "\n", "for", "seed", ",", "p", "in", "zip", "(", "seeds", ",", "prob", ")", ":", "\n", "        ", "hm", "=", "feature", ".", "hessian_matrix", "(", "p", ",", "sigma", "=", "3", ")", "\n", "l1", ",", "l2", "=", "feature", ".", "hessian_matrix_eigvals", "(", "*", "hm", ")", "\n", "curvy", "=", "(", "l1", ">", "l1_threshold", ")", "\n", "seed", "[", ":", "]", "=", "multiscale_regular_seeds", "(", "curvy", ",", "npoints", ")", "\n", "", "return", "seeds", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pipeline_compact_watershed": [[329, 352], ["numpy.reshape", "numpy.array", "np.array.max().max", "numpy.concatenate", "joblib.Parallel", "joblib.Parallel", "numpy.max", "np.array.max", "joblib.delayed", "joblib.delayed", "zip", "numpy.cumsum"], "function", ["None"], ["", "def", "pipeline_compact_watershed", "(", "prob", ",", "*", ",", "\n", "invert_prob", "=", "True", ",", "\n", "l1_threshold", "=", "0", ",", "\n", "grid_density", "=", "10", ",", "\n", "compactness", "=", "0.01", ",", "\n", "n_jobs", "=", "1", ")", ":", "\n", "    ", "if", "invert_prob", ":", "\n", "        ", "prob", "=", "np", ".", "max", "(", "prob", ")", "-", "prob", "\n", "", "seeds", "=", "joblib", ".", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "(", "\n", "joblib", ".", "delayed", "(", "multiscale_seed_sequence", ")", "(", "p", "[", "np", ".", "newaxis", ",", ":", "]", ",", "\n", "l1_threshold", "=", "l1_threshold", ",", "\n", "grid_density", "=", "grid_density", ")", "\n", "for", "p", "in", "prob", ")", "\n", "seeds", "=", "np", ".", "reshape", "(", "seeds", ",", "prob", ".", "shape", ")", "\n", "fragments", "=", "joblib", ".", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "(", "\n", "joblib", ".", "delayed", "(", "compact_watershed", ")", "(", "p", ",", "s", ",", "compactness", "=", "compactness", ")", "\n", "for", "p", ",", "s", "in", "zip", "(", "prob", ",", "seeds", ")", "\n", ")", "\n", "fragments", "=", "np", ".", "array", "(", "fragments", ")", "\n", "max_ids", "=", "fragments", ".", "max", "(", "axis", "=", "-", "1", ")", ".", "max", "(", "axis", "=", "-", "1", ")", "\n", "to_add", "=", "np", ".", "concatenate", "(", "(", "[", "0", "]", ",", "np", ".", "cumsum", "(", "max_ids", ")", "[", ":", "-", "1", "]", ")", ")", "\n", "fragments", "+=", "to_add", "[", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", "\n", "return", "fragments", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho._euclid_dist": [[354, 356], ["numpy.sqrt", "numpy.sum"], "function", ["None"], ["", "def", "_euclid_dist", "(", "a", ",", "b", ")", ":", "\n", "    ", "return", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "(", "a", "-", "b", ")", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.compact_watershed": [[358, 396], ["MergeQueue", "pad().ravel", "numpy.flatnonzero", "numpy.zeros", "pad().ravel", "morpho.pad", "pad.ravel", "morpho.raveled_steps_to_neighbors", "numpy.zeros_like", "morpho.juicy_center", "numpy.copy", "numpy.min", "skimage.morphology.watershed", "np.copy.astype", "MergeQueue.push", "len", "MergeQueue.pop", "skimage.morphology.watershed.reshape", "warnings.warn", "morpho.pad", "morpho.pad", "numpy.nonzero", "numpy.unravel_index", "numpy.array", "MergeQueue.push", "numpy.unravel_index", "morpho._euclid_dist"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.raveled_steps_to_neighbors", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.push", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.pop", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.push", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho._euclid_dist"], ["", "def", "compact_watershed", "(", "a", ",", "seeds", ",", "*", ",", "compactness", "=", "0.01", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "a", "=", "np", ".", "copy", "(", "a", ")", "\n", "a", "[", "np", ".", "nonzero", "(", "seeds", ")", "]", "=", "np", ".", "min", "(", "a", ")", "\n", "result", "=", "skimage", ".", "morphology", ".", "watershed", "(", "a", ",", "seeds", ",", "\n", "connectivity", "=", "connectivity", ",", "\n", "compactness", "=", "compactness", ")", "\n", "return", "result", "\n", "", "except", "TypeError", ":", "# old version of skimage", "\n", "        ", "import", "warnings", "\n", "warnings", ".", "warn", "(", "'skimage prior to 0.13; compact watershed will be slow.'", ")", "\n", "", "from", ".", "mergequeue", "import", "MergeQueue", "\n", "visiting_queue", "=", "MergeQueue", "(", ")", "\n", "seeds", "=", "pad", "(", "seeds", ",", "0", ")", ".", "ravel", "(", ")", "\n", "seed_coords", "=", "np", ".", "flatnonzero", "(", "seeds", ")", "\n", "visited", "=", "np", ".", "zeros", "(", "a", ".", "shape", ",", "dtype", "=", "bool", ")", "\n", "visited", "=", "pad", "(", "visited", ",", "True", ")", ".", "ravel", "(", ")", "\n", "ap", "=", "pad", "(", "a", ".", "astype", "(", "float", ")", ",", "np", ".", "inf", ")", "\n", "apr", "=", "ap", ".", "ravel", "(", ")", "\n", "neigh_sum", "=", "raveled_steps_to_neighbors", "(", "ap", ".", "shape", ",", "connectivity", ")", "\n", "result", "=", "np", ".", "zeros_like", "(", "seeds", ")", "\n", "for", "c", "in", "seed_coords", ":", "\n", "        ", "visiting_queue", ".", "push", "(", "[", "0", ",", "True", ",", "c", ",", "seeds", "[", "c", "]", ",", "\n", "np", ".", "unravel_index", "(", "c", ",", "ap", ".", "shape", ")", "]", ")", "\n", "", "while", "len", "(", "visiting_queue", ")", ">", "0", ":", "\n", "        ", "_", ",", "_", ",", "next_coord", ",", "next_label", ",", "next_origin", "=", "visiting_queue", ".", "pop", "(", ")", "\n", "if", "not", "visited", "[", "next_coord", "]", ":", "\n", "            ", "visited", "[", "next_coord", "]", "=", "True", "\n", "result", "[", "next_coord", "]", "=", "next_label", "\n", "neighbor_coords", "=", "next_coord", "+", "neigh_sum", "\n", "for", "coord", "in", "neighbor_coords", ":", "\n", "                ", "if", "not", "visited", "[", "coord", "]", ":", "\n", "                    ", "full_coord", "=", "np", ".", "array", "(", "np", ".", "unravel_index", "(", "coord", ",", "ap", ".", "shape", ")", ")", "\n", "cost", "=", "(", "apr", "[", "coord", "]", "+", "\n", "compactness", "*", "_euclid_dist", "(", "full_coord", ",", "next_origin", ")", ")", "\n", "visiting_queue", ".", "push", "(", "[", "cost", ",", "True", ",", "coord", ",", "next_label", ",", "\n", "next_origin", "]", ")", "\n", "", "", "", "", "return", "juicy_center", "(", "result", ".", "reshape", "(", "ap", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed_sequence": [[398, 458], ["list", "numpy.concatenate", "numpy.cumsum", "zip", "numpy.concatenate", "a.swapaxes().copy.swapaxes().copy", "itertools.repeat", "itertools.repeat", "joblib.Parallel", "map", "ws.swapaxes().copy.swapaxes().copy", "seeds.swapaxes.swapaxes", "mask.swapaxes.swapaxes", "numpy.array", "a.swapaxes().copy.swapaxes", "joblib.delayed", "zip", "ws.swapaxes().copy.swapaxes"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "watershed_sequence", "(", "a", ",", "seeds", "=", "None", ",", "mask", "=", "None", ",", "axis", "=", "0", ",", "n_jobs", "=", "1", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Perform a watershed on a plane-by-plane basis.\n\n    See documentation for `watershed` for available kwargs.\n\n    The watershed algorithm views image intensity as \"height\" and finds flood\n    basins within it. These basins are then viewed as the different labeled\n    regions of an image.\n\n    This function performs watershed on an ndarray on each plane separately,\n    then concatenate the results.\n\n    Parameters\n    ----------\n    a : numpy ndarray, arbitrary type or shape.\n        The input image on which to perform the watershed transform.\n    seeds : bool/int numpy.ndarray, same shape as a (optional, default None)\n        The seeds for the watershed.\n    mask : bool numpy.ndarray, same shape as a (optional, default None)\n        If provided, perform watershed only over voxels that are True in the\n        mask.\n    axis : int, {1, ..., a.ndim} (optional, default: 0)\n        Which axis defines the plane sequence. For example, if the input image\n        is 3D and axis=1, then the output will be the watershed on a[:, 0, :], \n        a[:, 1, :], a[:, 2, :], ... and so on.\n    n_jobs : int, optional\n        Use joblib to distribute each plane over given number of processing\n        cores. If -1, `multiprocessing.cpu_count` is used.\n\n    Returns\n    -------\n    ws : numpy ndarray, int type\n        The labeled watershed basins.\n\n    Other parameters\n    ----------------\n    **kwargs : keyword arguments passed through to the `watershed` function.\n    \"\"\"", "\n", "if", "axis", "!=", "0", ":", "\n", "        ", "a", "=", "a", ".", "swapaxes", "(", "0", ",", "axis", ")", ".", "copy", "(", ")", "\n", "if", "seeds", "is", "not", "None", ":", "\n", "            ", "seeds", "=", "seeds", ".", "swapaxes", "(", "0", ",", "axis", ")", "\n", "", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "mask", ".", "swapaxes", "(", "0", ",", "axis", ")", "\n", "", "", "if", "seeds", "is", "None", ":", "\n", "        ", "seeds", "=", "it", ".", "repeat", "(", "None", ")", "\n", "", "if", "mask", "is", "None", ":", "\n", "        ", "mask", "=", "it", ".", "repeat", "(", "None", ")", "\n", "", "ws", "=", "joblib", ".", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "(", "\n", "joblib", ".", "delayed", "(", "watershed", ")", "(", "i", ",", "seeds", "=", "s", ",", "mask", "=", "m", ",", "**", "kwargs", ")", "\n", "for", "i", ",", "s", ",", "m", "in", "zip", "(", "a", ",", "seeds", ",", "mask", ")", ")", "\n", "counts", "=", "list", "(", "map", "(", "np", ".", "max", ",", "ws", "[", ":", "-", "1", "]", ")", ")", "\n", "counts", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "[", "0", "]", ")", ",", "counts", ")", ")", "\n", "counts", "=", "np", ".", "cumsum", "(", "counts", ")", "\n", "for", "c", ",", "w", "in", "zip", "(", "counts", ",", "ws", ")", ":", "\n", "        ", "w", "+=", "c", "\n", "", "ws", "=", "np", ".", "concatenate", "(", "[", "w", "[", "np", ".", "newaxis", ",", "...", "]", "for", "w", "in", "ws", "]", ",", "axis", "=", "0", ")", "\n", "if", "axis", "!=", "0", ":", "\n", "        ", "ws", "=", "ws", ".", "swapaxes", "(", "0", ",", "axis", ")", ".", "copy", "(", ")", "\n", "", "return", "ws", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.manual_split": [[460, 494], ["scipy.ndimage.generate_binary_structure", "morpho.watershed", "seg.copy.copy", "zip", "scipy.ndimage.measurements.find_objects", "scipy.ndimage.morphology.binary_dilation", "probs.copy", "probs.min", "probs.max", "scipy.ndimage.measurements.label", "seeds.max", "numpy.unique", "probs.max", "seeds.astype", "seg.copy.max"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "manual_split", "(", "probs", ",", "seg", ",", "body", ",", "seeds", ",", "connectivity", "=", "1", ",", "boundary_seeds", "=", "None", ")", ":", "\n", "    ", "\"\"\"Manually split a body from a segmentation using seeded watershed.\n\n    Input:\n        - probs: the probability of boundary in the volume given.\n        - seg: the current segmentation.\n        - body: the label to be split.\n        - seeds: the seeds for the splitting (should be just two labels).\n        [-connectivity: the connectivity to use for watershed.]\n        [-boundary_seeds: if not None, these locations become inf in probs.]\n    Value:\n        - the segmentation with the selected body split.\n    \"\"\"", "\n", "struct", "=", "generate_binary_structure", "(", "seg", ".", "ndim", ",", "connectivity", ")", "\n", "body_pixels", "=", "seg", "==", "body", "\n", "bbox", "=", "find_objects", "(", "body_pixels", ")", "[", "0", "]", "\n", "body_pixels", "=", "body_pixels", "[", "bbox", "]", "\n", "body_boundary", "=", "binary_dilation", "(", "body_pixels", ",", "struct", ")", "-", "body_pixels", "\n", "non_body_pixels", "=", "True", "-", "body_pixels", "-", "body_boundary", "\n", "probs", "=", "probs", ".", "copy", "(", ")", "[", "bbox", "]", "\n", "probs", "[", "non_body_pixels", "]", "=", "probs", ".", "min", "(", ")", "-", "1", "\n", "if", "boundary_seeds", "is", "not", "None", ":", "\n", "        ", "probs", "[", "boundary_seeds", "[", "bbox", "]", "]", "=", "probs", ".", "max", "(", ")", "+", "1", "\n", "", "probs", "[", "body_boundary", "]", "=", "probs", ".", "max", "(", ")", "+", "1", "\n", "seeds", "=", "label", "(", "seeds", ".", "astype", "(", "bool", ")", "[", "bbox", "]", ",", "struct", ")", "[", "0", "]", "\n", "outer_seed", "=", "seeds", ".", "max", "(", ")", "+", "1", "# should be 3", "\n", "seeds", "[", "non_body_pixels", "]", "=", "outer_seed", "\n", "seg_new", "=", "watershed", "(", "probs", ",", "seeds", ",", "\n", "dams", "=", "(", "seg", "==", "0", ")", ".", "any", "(", ")", ",", "connectivity", "=", "connectivity", ",", "show_progress", "=", "True", ")", "\n", "seg", "=", "seg", ".", "copy", "(", ")", "\n", "new_seeds", "=", "unique", "(", "seeds", ")", "[", ":", "-", "1", "]", "\n", "for", "new_seed", ",", "new_label", "in", "zip", "(", "new_seeds", ",", "[", "0", ",", "body", ",", "seg", ".", "max", "(", ")", "+", "1", "]", ")", ":", "\n", "        ", "seg", "[", "bbox", "]", "[", "seg_new", "==", "new_seed", "]", "=", "new_label", "\n", "", "return", "seg", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.relabel_connected": [[496, 536], ["numpy.zeros_like", "numpy.empty_like", "scipy.ndimage.generate_binary_structure", "numpy.unique", "scipy.ndimage.label", "segment.nonzero"], "function", ["None"], ["", "def", "relabel_connected", "(", "im", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Ensure all labels in `im` are connected.\n\n    Parameters\n    ----------\n    im : array of int\n        The input label image.\n    connectivity : int in {1, ..., `im.ndim`}, optional\n        The connectivity used to determine if two voxels are neighbors.\n\n    Returns\n    -------\n    im_out : array of int\n        The relabeled image.\n\n    Examples\n    --------\n    >>> image = np.array([[1, 1, 2],\n    ...                   [2, 1, 1]])\n    >>> im_out = relabel_connected(image)\n    >>> im_out\n    array([[1, 1, 2],\n           [3, 1, 1]])\n    \"\"\"", "\n", "im_out", "=", "np", ".", "zeros_like", "(", "im", ")", "\n", "contiguous_segments", "=", "np", ".", "empty_like", "(", "im", ")", "\n", "structure", "=", "generate_binary_structure", "(", "im", ".", "ndim", ",", "connectivity", ")", "\n", "curr_label", "=", "0", "\n", "labels", "=", "np", ".", "unique", "(", "im", ")", "\n", "if", "labels", "[", "0", "]", "==", "0", ":", "\n", "        ", "labels", "=", "labels", "[", "1", ":", "]", "\n", "", "for", "label", "in", "labels", ":", "\n", "        ", "segment", "=", "(", "im", "==", "label", ")", "\n", "n_segments", "=", "ndi", ".", "label", "(", "segment", ",", "structure", ",", "\n", "output", "=", "contiguous_segments", ")", "\n", "seg", "=", "segment", ".", "nonzero", "(", ")", "\n", "contiguous_segments", "[", "seg", "]", "+=", "curr_label", "\n", "im_out", "[", "seg", "]", "+=", "contiguous_segments", "[", "seg", "]", "\n", "curr_label", "+=", "n_segments", "\n", "", "return", "im_out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.smallest_int_dtype": [[538, 558], ["numpy.iinfo", "numpy.iinfo", "numpy.iinfo", "numpy.iinfo", "numpy.iinfo", "numpy.iinfo", "numpy.iinfo", "numpy.iinfo", "numpy.iinfo", "numpy.iinfo", "numpy.iinfo", "numpy.iinfo"], "function", ["None"], ["", "def", "smallest_int_dtype", "(", "number", ",", "signed", "=", "False", ",", "mindtype", "=", "None", ")", ":", "\n", "    ", "if", "number", "<", "0", ":", "signed", "=", "True", "\n", "if", "not", "signed", ":", "\n", "        ", "if", "number", "<=", "iinfo", "(", "uint8", ")", ".", "max", ":", "\n", "            ", "return", "uint8", "\n", "", "if", "number", "<=", "iinfo", "(", "uint16", ")", ".", "max", ":", "\n", "            ", "return", "uint16", "\n", "", "if", "number", "<=", "iinfo", "(", "uint32", ")", ".", "max", ":", "\n", "            ", "return", "uint32", "\n", "", "if", "number", "<=", "iinfo", "(", "uint64", ")", ".", "max", ":", "\n", "            ", "return", "uint64", "\n", "", "", "else", ":", "\n", "        ", "if", "iinfo", "(", "int8", ")", ".", "min", "<=", "number", "<=", "iinfo", "(", "int8", ")", ".", "max", ":", "\n", "            ", "return", "int8", "\n", "", "if", "iinfo", "(", "int16", ")", ".", "min", "<=", "number", "<=", "iinfo", "(", "int16", ")", ".", "max", ":", "\n", "            ", "return", "int16", "\n", "", "if", "iinfo", "(", "int32", ")", ".", "min", "<=", "number", "<=", "iinfo", "(", "int32", ")", ".", "max", ":", "\n", "            ", "return", "int32", "\n", "", "if", "iinfo", "(", "int64", ")", ".", "min", "<=", "number", "<=", "iinfo", "(", "int64", ")", ".", "max", ":", "\n", "            ", "return", "int64", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho._is_container": [[559, 565], ["len"], "function", ["None"], ["", "", "", "def", "_is_container", "(", "a", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "n", "=", "len", "(", "a", ")", "\n", "return", "True", "\n", "", "except", "TypeError", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad": [[566, 609], ["len", "numpy.array", "numpy.array", "numpy.zeros", "numpy.ones", "ar.ravel", "list", "morpho._is_container", "morpho._is_container", "morpho.pad", "range", "max", "min", "max", "numpy.zeros.swapaxes", "numpy.zeros.swapaxes", "numpy.ones.swapaxes", "numpy.ones.swapaxes", "abs", "numpy.array.max", "ar.max", "numpy.array.min", "ar.min", "morpho.smallest_int_dtype", "numpy.np.inf"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho._is_container", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho._is_container", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.smallest_int_dtype"], ["", "", "def", "pad", "(", "ar", ",", "vals", ",", "axes", "=", "None", ")", ":", "\n", "    ", "if", "ar", ".", "size", "==", "0", ":", "\n", "        ", "return", "ar", "\n", "", "if", "axes", "is", "None", ":", "\n", "        ", "axes", "=", "list", "(", "range", "(", "ar", ".", "ndim", ")", ")", "\n", "", "if", "not", "_is_container", "(", "vals", ")", ":", "\n", "        ", "vals", "=", "[", "vals", "]", "\n", "", "if", "not", "_is_container", "(", "axes", ")", ":", "\n", "        ", "axes", "=", "[", "axes", "]", "\n", "", "padding_thickness", "=", "len", "(", "vals", ")", "\n", "newshape", "=", "array", "(", "ar", ".", "shape", ")", "\n", "for", "ax", "in", "axes", ":", "\n", "        ", "newshape", "[", "ax", "]", "+=", "2", "\n", "", "vals", "=", "array", "(", "vals", ")", "\n", "if", "ar", ".", "dtype", "==", "double", "or", "ar", ".", "dtype", "==", "float", ":", "\n", "        ", "new_dtype", "=", "double", "\n", "", "elif", "ar", ".", "dtype", "==", "bool", ":", "\n", "        ", "new_dtype", "=", "bool", "\n", "", "else", ":", "\n", "        ", "maxval", "=", "max", "(", "[", "vals", ".", "max", "(", ")", ",", "ar", ".", "max", "(", ")", "]", ")", "\n", "minval", "=", "min", "(", "[", "vals", ".", "min", "(", ")", ",", "ar", ".", "min", "(", ")", "]", ")", "\n", "if", "abs", "(", "minval", ")", ">", "maxval", ":", "\n", "            ", "signed", "=", "True", "\n", "extremeval", "=", "minval", "\n", "", "else", ":", "\n", "            ", "if", "minval", "<", "0", ":", "\n", "                ", "signed", "=", "True", "\n", "", "else", ":", "\n", "                ", "signed", "=", "False", "\n", "", "extremeval", "=", "maxval", "\n", "", "new_dtype", "=", "max", "(", "[", "smallest_int_dtype", "(", "extremeval", ",", "signed", ")", ",", "ar", ".", "dtype", "]", ")", "\n", "", "ar2", "=", "zeros", "(", "newshape", ",", "dtype", "=", "new_dtype", ")", "\n", "center", "=", "ones", "(", "newshape", ",", "dtype", "=", "bool", ")", "\n", "for", "ax", "in", "axes", ":", "\n", "        ", "ar2", ".", "swapaxes", "(", "0", ",", "ax", ")", "[", "0", ",", "...", "]", "=", "vals", "[", "0", "]", "\n", "ar2", ".", "swapaxes", "(", "0", ",", "ax", ")", "[", "-", "1", ",", "...", "]", "=", "vals", "[", "0", "]", "\n", "center", ".", "swapaxes", "(", "0", ",", "ax", ")", "[", "0", ",", "...", "]", "=", "False", "\n", "center", ".", "swapaxes", "(", "0", ",", "ax", ")", "[", "-", "1", ",", "...", "]", "=", "False", "\n", "", "ar2", "[", "center", "]", "=", "ar", ".", "ravel", "(", ")", "\n", "if", "padding_thickness", "==", "1", ":", "\n", "        ", "return", "ar2", "\n", "", "else", ":", "\n", "        ", "return", "pad", "(", "ar2", ",", "vals", "[", "1", ":", "]", ",", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center": [[610, 616], ["range", "ar.swapaxes.copy", "ar.swapaxes.swapaxes", "ar.swapaxes.swapaxes"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "", "def", "juicy_center", "(", "ar", ",", "skinsize", "=", "1", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "ar", ".", "ndim", ")", ":", "\n", "        ", "ar", "=", "ar", ".", "swapaxes", "(", "0", ",", "i", ")", "\n", "ar", "=", "ar", "[", "skinsize", ":", "-", "skinsize", "]", "\n", "ar", "=", "ar", ".", "swapaxes", "(", "0", ",", "i", ")", "\n", "", "return", "ar", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.surfaces": [[617, 625], ["range", "ar.swapaxes.swapaxes", "s.append", "s.append", "ar.swapaxes.swapaxes", "ar[].copy", "ar[].copy"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "surfaces", "(", "ar", ",", "skinsize", "=", "1", ")", ":", "\n", "    ", "s", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "ar", ".", "ndim", ")", ":", "\n", "        ", "ar", "=", "ar", ".", "swapaxes", "(", "0", ",", "i", ")", "\n", "s", ".", "append", "(", "ar", "[", "0", ":", "skinsize", "]", ".", "copy", "(", ")", ")", "\n", "s", ".", "append", "(", "ar", "[", "-", "skinsize", ":", "]", ".", "copy", "(", ")", ")", "\n", "ar", "=", "ar", ".", "swapaxes", "(", "0", ",", "i", ")", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.hollowed": [[626, 635], ["ar.copy", "slice"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "hollowed", "(", "ar", ",", "skinsize", "=", "1", ")", ":", "\n", "    ", "\"\"\"Return a copy of ar with the center zeroed out.\n\n    'skinsize' determines how thick of a crust to leave untouched.\n    \"\"\"", "\n", "slices", "=", "(", "slice", "(", "skinsize", ",", "-", "skinsize", ")", ",", ")", "*", "ar", ".", "ndim", "\n", "ar_out", "=", "ar", ".", "copy", "(", ")", "\n", "ar_out", "[", "slices", "]", "=", "0", "\n", "return", "ar_out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.build_levels_dict": [[636, 641], ["collections.defaultdict", "enumerate", "a.ravel", "d[].append"], "function", ["None"], ["", "def", "build_levels_dict", "(", "a", ")", ":", "\n", "    ", "d", "=", "defaultdict", "(", "list", ")", "\n", "for", "loc", ",", "val", "in", "enumerate", "(", "a", ".", "ravel", "(", ")", ")", ":", "\n", "        ", "d", "[", "val", "]", ".", "append", "(", "loc", ")", "\n", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.build_neighbors_array": [[642, 645], ["numpy.arange", "morpho.get_neighbor_idxs"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.get_neighbor_idxs"], ["", "def", "build_neighbors_array", "(", "ar", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "idxs", "=", "arange", "(", "ar", ".", "size", ",", "dtype", "=", "uint32", ")", "\n", "return", "get_neighbor_idxs", "(", "ar", ",", "idxs", ",", "connectivity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.raveled_steps_to_neighbors": [[647, 681], ["steps.extend", "range", "numpy.concatenate().astype", "numpy.cumprod", "numpy.array", "steps.append", "list", "numpy.array", "numpy.dot().ravel", "numpy.concatenate", "itertools.product", "list", "itertools.combinations", "numpy.dot"], "function", ["None"], ["", "def", "raveled_steps_to_neighbors", "(", "shape", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Compute the stepsize along all axes for given connectivity and shape.\n\n    Parameters\n    ----------\n    shape : tuple of int\n        The shape of the array along which we are stepping.\n    connectivity : int in {1, 2, ..., ``len(shape)``}\n        The number of orthogonal steps we can take to reach a \"neighbor\".\n\n    Returns\n    -------\n    steps : array of int64\n        The steps needed to get to neighbors from a particular raveled\n        index.\n\n    Examples\n    --------\n    >>> shape = (5, 4, 9)\n    >>> steps = raveled_steps_to_neighbors(shape)\n    >>> sorted(steps)\n    [-36, -9, -1, 1, 9, 36]\n    >>> steps2 = raveled_steps_to_neighbors(shape, 2)\n    >>> sorted(steps2)\n    [-45, -37, -36, -35, -27, -10, -9, -8, -1, 1, 8, 9, 10, 27, 35, 36, 37, 45]\n    \"\"\"", "\n", "stepsizes", "=", "np", ".", "cumprod", "(", "(", "1", ",", ")", "+", "shape", "[", "-", "1", ":", "0", ":", "-", "1", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "steps", "=", "[", "]", "\n", "steps", ".", "extend", "(", "(", "stepsizes", ",", "-", "stepsizes", ")", ")", "\n", "for", "nhops", "in", "range", "(", "2", ",", "connectivity", "+", "1", ")", ":", "\n", "        ", "prod", "=", "np", ".", "array", "(", "list", "(", "it", ".", "product", "(", "*", "(", "[", "[", "1", ",", "-", "1", "]", "]", "*", "nhops", ")", ")", ")", ")", "\n", "multisteps", "=", "np", ".", "array", "(", "list", "(", "it", ".", "combinations", "(", "stepsizes", ",", "nhops", ")", ")", ")", ".", "T", "\n", "steps", ".", "append", "(", "np", ".", "dot", "(", "prod", ",", "multisteps", ")", ".", "ravel", "(", ")", ")", "\n", "", "return", "np", ".", "concatenate", "(", "steps", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.get_neighbor_idxs": [[683, 720], ["numpy.isscalar", "numpy.array", "morpho.raveled_steps_to_neighbors"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.raveled_steps_to_neighbors"], ["", "def", "get_neighbor_idxs", "(", "ar", ",", "idxs", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Return indices of neighboring voxels given array, indices, connectivity.\n\n    Parameters\n    ----------\n    ar : ndarray\n        The array in which neighbors are to be found.\n    idxs : int or container of int\n        The indices for which to find neighbors.\n    connectivity : int in {1, 2, ..., ``ar.ndim``}\n        The number of orthogonal steps allowed to be considered a\n        neighbor.\n\n    Returns\n    -------\n    neighbor_idxs : 2D array, shape (nidxs, nneighbors)\n        The neighbor indices for each index passed.\n\n    Examples\n    --------\n    >>> ar = np.arange(16).reshape((4, 4))\n    >>> ar\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n    >>> get_neighbor_idxs(ar, [5, 10], connectivity=1)\n    array([[ 9,  6,  1,  4],\n           [14, 11,  6,  9]])\n    >>> get_neighbor_idxs(ar, 9, connectivity=2)\n    array([[13, 10,  5,  8, 14, 12,  6,  4]])\n    \"\"\"", "\n", "if", "isscalar", "(", "idxs", ")", ":", "# in case only a single idx is given", "\n", "        ", "idxs", "=", "[", "idxs", "]", "\n", "", "idxs", "=", "array", "(", "idxs", ")", "# in case a list or other array-like is given", "\n", "steps", "=", "raveled_steps_to_neighbors", "(", "ar", ".", "shape", ",", "connectivity", ")", "\n", "return", "idxs", "[", ":", ",", "np", ".", "newaxis", "]", "+", "steps", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.orphans": [[722, 750], ["numpy.setdiff1d", "numpy.unique", "numpy.unique", "numpy.concatenate", "s.ravel", "morpho.surfaces"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.surfaces"], ["", "def", "orphans", "(", "a", ")", ":", "\n", "    ", "\"\"\"Find all the segments that do not touch the volume boundary.\n    \n    This function differs from agglo.Rag.orphans() in that it does not use the\n    graph, but rather computes orphans directly from a volume.\n\n    Parameters\n    ----------\n    a : array of int\n        A segmented volume.\n\n    Returns\n    -------\n    orph : 1D array of int\n        The IDs of any segments not touching the volume boundary.\n\n    Examples\n    --------\n    >>> segs = np.array([[1, 1, 1, 2],\n    ...                  [1, 3, 4, 2],\n    ...                  [1, 2, 2, 2]], int)\n    >>> orphans(segs)\n    array([3, 4])\n    >>> orphans(segs[:2])\n    array([], dtype=int64)\n    \"\"\"", "\n", "return", "setdiff1d", "(", "\n", "unique", "(", "a", ")", ",", "unique", "(", "concatenate", "(", "[", "s", ".", "ravel", "(", ")", "for", "s", "in", "surfaces", "(", "a", ")", "]", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.non_traversing_segments": [[753, 785], ["morpho.hollowed", "numpy.flatnonzero", "numpy.array", "skimage.util.unique_rows", "numpy.flatnonzero", "skimage.measure.label", "list", "numpy.bincount", "zip", "hollowed.ravel", "surface_ccs.ravel"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.hollowed"], ["", "def", "non_traversing_segments", "(", "a", ")", ":", "\n", "    ", "\"\"\"Find segments that enter the volume but do not leave it elsewhere.\n\n    Parameters\n    ----------\n    a : array of int\n        A segmented volume.\n\n    Returns\n    -------\n    nt : 1D array of int\n        The IDs of any segments not traversing the volume.\n\n    Examples\n    --------\n    >>> segs = np.array([[1, 2, 3, 3, 4],\n    ...                  [1, 2, 2, 3, 4],\n    ...                  [1, 5, 5, 3, 4],\n    ...                  [1, 1, 5, 3, 4]], int)\n    >>> non_traversing_segments(segs)\n    array([1, 2, 4, 5])\n    \"\"\"", "\n", "surface", "=", "hollowed", "(", "a", ")", "\n", "surface_ccs", "=", "measure", ".", "label", "(", "surface", ")", "+", "1", "\n", "surface_ccs", "[", "surface", "==", "0", "]", "=", "0", "\n", "idxs", "=", "flatnonzero", "(", "surface", ")", "\n", "pairs", "=", "np", ".", "array", "(", "list", "(", "zip", "(", "surface", ".", "ravel", "(", ")", "[", "idxs", "]", ",", "\n", "surface_ccs", ".", "ravel", "(", ")", "[", "idxs", "]", ")", ")", ")", "\n", "unique_pairs", "=", "util", ".", "unique_rows", "(", "pairs", ")", "\n", "surface_singles", "=", "np", ".", "bincount", "(", "unique_pairs", "[", ":", ",", "0", "]", ")", "==", "1", "\n", "nt", "=", "np", ".", "flatnonzero", "(", "surface_singles", ")", "\n", "return", "nt", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.damify": [[787, 793], ["a.copy", "morpho.seg_to_bdry"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.seg_to_bdry"], ["", "def", "damify", "(", "a", ",", "in_place", "=", "False", ")", ":", "\n", "    ", "\"\"\"Add dams to a borderless segmentation.\"\"\"", "\n", "if", "not", "in_place", ":", "\n", "        ", "b", "=", "a", ".", "copy", "(", ")", "\n", "", "b", "[", "seg_to_bdry", "(", "a", ")", "]", "=", "0", "\n", "return", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.seg_to_bdry": [[794, 799], ["scipy.ndimage.generate_binary_structure", "scipy.ndimage.maximum_filter", "scipy.ndimage.minimum_filter"], "function", ["None"], ["", "def", "seg_to_bdry", "(", "seg", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Given a borderless segmentation, return the boundary map.\"\"\"", "\n", "strel", "=", "generate_binary_structure", "(", "seg", ".", "ndim", ",", "connectivity", ")", "\n", "return", "maximum_filter", "(", "seg", ",", "footprint", "=", "strel", ")", "!=", "minimum_filter", "(", "seg", ",", "footprint", "=", "strel", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.undam": [[800, 814], ["scipy.ndimage.distance_transform_cdt", "numpy.concatenate", "numpy.reshape.ravel", "numpy.reshape", "numpy.nonzero", "bdrymap.ravel", "numpy.dot", "i.ravel"], "function", ["None"], ["", "def", "undam", "(", "seg", ")", ":", "\n", "    ", "\"\"\" Assign zero-dams to nearest non-zero region. \"\"\"", "\n", "bdrymap", "=", "seg", "==", "0", "\n", "k", "=", "distance_transform_cdt", "(", "bdrymap", ",", "return_indices", "=", "True", ")", "\n", "ind", "=", "nonzero", "(", "bdrymap", ".", "ravel", "(", ")", ")", "[", "0", "]", "\n", "closest_sub", "=", "concatenate", "(", "[", "i", ".", "ravel", "(", ")", "[", ":", ",", "newaxis", "]", "for", "i", "in", "k", "[", "1", "]", "]", ",", "axis", "=", "1", ")", "\n", "closest_sub", "=", "closest_sub", "[", "ind", ",", ":", "]", "\n", "closest_ind", "=", "[", "\n", "dot", "(", "bdrymap", ".", "strides", ",", "i", ")", "/", "bdrymap", ".", "itemsize", "for", "i", "in", "closest_sub", "]", "\n", "sp", "=", "seg", ".", "shape", "\n", "seg", "=", "seg", ".", "ravel", "(", ")", "\n", "seg", "[", "ind", "]", "=", "seg", "[", "closest_ind", "]", "\n", "seg", "=", "reshape", "(", "seg", ",", "sp", ")", "\n", "return", "seg", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.grab_boundary": [[39, 49], ["master_logger.debug", "str"], "function", ["None"], ["def", "grab_boundary", "(", "prediction", ",", "channels", ",", "master_logger", ")", ":", "\n", "    ", "boundary", "=", "None", "\n", "master_logger", ".", "debug", "(", "\"Grabbing boundary labels: \"", "+", "str", "(", "channels", ")", ")", "\n", "for", "channel_id", "in", "channels", ":", "\n", "        ", "if", "boundary", "is", "None", ":", "\n", "            ", "boundary", "=", "prediction", "[", "...", ",", "channel_id", "]", "\n", "", "else", ":", "\n", "            ", "boundary", "+=", "prediction", "[", "...", ",", "channel_id", "]", "\n", "\n", "", "", "return", "boundary", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.gen_supervoxels": [[51, 152], ["master_logger.debug", "imio.read_image_stack", "master_logger.info", "prediction.transpose.transpose", "segmentation_pipeline.grab_boundary", "master_logger.info", "master_logger.debug", "master_logger.info", "numpy.ones().astype", "skimage.morphology.watershed", "master_logger.info", "os.path.isfile", "os.path.isfile", "Exception", "scipy.ndimage.label", "master_logger.debug", "morpho.remove_small_connected_components", "master_logger.debug", "open", "open.close", "morpho.remove_small_connected_components.copy", "master_logger.info", "syngeo.io.raveler_synapse_annotations_to_coords", "syngeo.io.volume_synapse_view", "morpho.split_exclusions", "master_logger.info", "str", "str", "scipy.ndimage.label", "morpho.remove_small_connected_components", "numpy.ones", "line.split", "synvol_cropped.copy.copy", "len", "masked_bboxes.append", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.grab_boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.split_exclusions", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "gen_supervoxels", "(", "options", ",", "prediction_file", ",", "master_logger", ")", ":", "\n", "    ", "\"\"\"Returns ndarray labeled using (optionally seeded) watershed algorithm\n\n    Args:\n        options:  OptionNamespace.\n        prediction_file:  String.  File name of prediction hdf5 file where predictions\n            are assumed to be in group PREDICTIONS_HDF5_GROUP.\n\n    Returns:\n        A 2-tuple of supervoxel and prediction ndarray.\n    \"\"\"", "\n", "master_logger", ".", "debug", "(", "\"Generating supervoxels\"", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "prediction_file", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"Training file not found: \"", "+", "prediction_file", ")", "\n", "\n", "", "prediction", "=", "imio", ".", "read_image_stack", "(", "prediction_file", ",", "group", "=", "PREDICTIONS_HDF5_GROUP", ")", "\n", "master_logger", ".", "info", "(", "\"Transposed boundary prediction\"", ")", "\n", "prediction", "=", "prediction", ".", "transpose", "(", "(", "2", ",", "1", ",", "0", ",", "3", ")", ")", "\n", "\n", "#if options.extract_ilp_prediction:", "\n", "#   prediction = prediction.transpose((2, 1, 0))", "\n", "\n", "# TODO -- Refactor.  If 'single-channel' and hdf5 prediction file is given, it looks like", "\n", "#   read_image_stack will return a modified volume and the bound-channels parameter must", "\n", "#   be 0 or there'll be conflict.", "\n", "boundary", "=", "grab_boundary", "(", "prediction", ",", "options", ".", "bound_channels", ",", "master_logger", ")", "\n", "master_logger", ".", "info", "(", "\"Shape of boundary: %s\"", "%", "str", "(", "boundary", ".", "shape", ")", ")", "\n", "\n", "# Prediction file is in format (t, x, y, z, c) but needs to be in format (z, x, y).", "\n", "# Also, raveler convention is (0,0) sits in bottom left while ilastik convention is", "\n", "# origin sits in top left.", "\n", "# imio.read_image_stack squeezes out the first dim.", "\n", "\n", "master_logger", ".", "debug", "(", "\"watershed seed value threshold: \"", "+", "str", "(", "options", ".", "seed_val", ")", ")", "\n", "seeds", "=", "label", "(", "boundary", "<=", "options", ".", "seed_val", ")", "[", "0", "]", "\n", "\n", "if", "options", ".", "seed_size", ">", "0", ":", "\n", "        ", "master_logger", ".", "debug", "(", "\"Removing small seeds\"", ")", "\n", "seeds", "=", "morpho", ".", "remove_small_connected_components", "(", "seeds", ",", "options", ".", "seed_size", ")", "\n", "master_logger", ".", "debug", "(", "\"Finished removing small seeds\"", ")", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Starting watershed\"", ")", "\n", "\n", "boundary_cropped", "=", "boundary", "\n", "seeds_cropped", "=", "seeds", "\n", "if", "options", ".", "border_size", ">", "0", ":", "\n", "        ", "boundary_cropped", "=", "boundary", "[", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", ",", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", ",", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", "]", "\n", "seeds_cropped", "=", "label", "(", "boundary_cropped", "<=", "options", ".", "seed_val", ")", "[", "0", "]", "\n", "if", "options", ".", "seed_size", ">", "0", ":", "\n", "            ", "seeds_cropped", "=", "morpho", ".", "remove_small_connected_components", "(", "seeds_cropped", ",", "options", ".", "seed_size", ")", "\n", "\n", "# Returns a matrix labeled using seeded watershed", "\n", "", "", "watershed_mask", "=", "numpy", ".", "ones", "(", "boundary_cropped", ".", "shape", ")", ".", "astype", "(", "numpy", ".", "uint8", ")", "\n", "\n", "# Used to specify region to ignore", "\n", "masked_bboxes", "=", "[", "]", "\n", "\n", "if", "options", ".", "mask_file", "is", "not", "None", ":", "\n", "        ", "mask_file", "=", "open", "(", "options", ".", "mask_file", ")", "\n", "for", "line", "in", "mask_file", ":", "\n", "            ", "br", "=", "line", ".", "split", "(", ")", "\n", "if", "len", "(", "br", ")", "==", "6", ":", "\n", "                ", "watershed_mask", "[", "int", "(", "br", "[", "2", "]", ")", ":", "(", "int", "(", "br", "[", "5", "]", ")", "+", "1", ")", ",", "\n", "int", "(", "br", "[", "1", "]", ")", ":", "(", "int", "(", "br", "[", "4", "]", ")", "+", "1", ")", ",", "int", "(", "br", "[", "0", "]", ")", ":", "(", "int", "(", "br", "[", "3", "]", ")", "+", "1", ")", "]", "=", "0", "\n", "masked_bboxes", ".", "append", "(", "br", ")", "\n", "", "", "mask_file", ".", "close", "(", ")", "\n", "\n", "", "supervoxels_cropped", "=", "skmorph", ".", "watershed", "(", "boundary_cropped", ",", "seeds_cropped", ",", "None", ",", "None", ",", "watershed_mask", ")", "\n", "\n", "supervoxels", "=", "supervoxels_cropped", "\n", "if", "options", ".", "border_size", ">", "0", ":", "\n", "        ", "supervoxels", "=", "seeds", ".", "copy", "(", ")", "\n", "supervoxels", ".", "dtype", "=", "supervoxels_cropped", ".", "dtype", "\n", "supervoxels", "[", ":", ",", ":", ",", ":", "]", "=", "0", "\n", "supervoxels", "[", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", ",", "\n", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", ",", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", "]", "=", "supervoxels_cropped", "\n", "\n", "", "master_logger", ".", "info", "(", "\"Finished watershed\"", ")", "\n", "\n", "if", "options", ".", "synapse_file", "is", "not", "None", ":", "\n", "        ", "master_logger", ".", "info", "(", "\"Processing synapses\"", ")", "\n", "pre_post_pairs", "=", "syngeo", ".", "io", ".", "raveler_synapse_annotations_to_coords", "(", "\n", "options", ".", "synapse_file", ")", "\n", "synapse_volume", "=", "syngeo", ".", "io", ".", "volume_synapse_view", "(", "pre_post_pairs", ",", "boundary", ".", "shape", ")", "\n", "if", "options", ".", "border_size", ">", "0", ":", "\n", "            ", "synvol_cropped", "=", "synapse_volume", "[", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", ",", "\n", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", ",", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", "]", "\n", "synvol_cropped", "=", "synvol_cropped", ".", "copy", "(", ")", "\n", "synapse_volume", "[", ":", ",", ":", ",", ":", "]", "=", "0", "\n", "synapse_volume", "[", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", ",", "\n", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", ",", "options", ".", "border_size", ":", "(", "-", "1", "*", "options", ".", "border_size", ")", "]", "=", "synvol_cropped", "\n", "", "for", "br", "in", "masked_bboxes", ":", "\n", "            ", "synapse_volume", "[", "(", "int", "(", "br", "[", "2", "]", ")", "+", "options", ".", "border_size", ")", ":", "(", "int", "(", "br", "[", "5", "]", ")", "+", "1", "+", "options", ".", "border_size", ")", ",", "\n", "(", "int", "(", "br", "[", "1", "]", ")", "+", "options", ".", "border_size", ")", ":", "(", "int", "(", "br", "[", "4", "]", ")", "+", "1", "+", "options", ".", "border_size", ")", ",", "\n", "(", "int", "(", "br", "[", "0", "]", ")", "+", "options", ".", "border_size", ")", ":", "(", "int", "(", "br", "[", "3", "]", ")", "+", "1", "+", "options", ".", "border_size", ")", "]", "=", "0", "\n", "\n", "", "supervoxels", "=", "morpho", ".", "split_exclusions", "(", "boundary", ",", "supervoxels", ",", "synapse_volume", ",", "\n", "options", ".", "synapse_dilation", ")", "\n", "master_logger", ".", "info", "(", "\"Finished processing synapses\"", ")", "\n", "\n", "", "return", "supervoxels", ",", "prediction", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.agglomeration": [[154, 236], ["sorted", "agglom_stack.get_segmentation", "hashlib.md5().hexdigest", "imio.compute_sp_to_body_map", "imio.write_mapped_segmentation", "os.path.abspath", "os.path.abspath", "os.path.dirname", "os.path.dirname", "os.path.basename", "os.path.basename", "len", "re.sub", "re.findall", "agglom_stack.write_plaza_json", "json.dumps", "open", "open.write", "master_logger.info", "agglom_stack.agglomerate", "master_logger.info", "imio.write_image_stack", "os.path.exists", "os.path.exists", "os.makedirs", "os.makedirs", "h5py.File", "json.load", "json.dumps", "h5py.new_vlen", "h5py.File.create_dataset", "os.path.abspath", "os.path.abspath", "re.findall", "len", "re.findall", "int", "int", "int", "int", "int", "int", "segmentation_pipeline.inclusion_removal", "hashlib.md5", "open", "glob.glob", "int", "str", "str", "agglom_stack.number_of_nodes", "agglom_stack.number_of_nodes", "str", "str", "str", "str", "str", "os.path.abspath", "os.path.abspath"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.compute_sp_to_body_map", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_mapped_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write_plaza_json", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.inclusion_removal", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes"], ["", "def", "agglomeration", "(", "options", ",", "agglom_stack", ",", "supervoxels", ",", "prediction", ",", "\n", "image_stack", ",", "session_location", ",", "sp_outs", ",", "master_logger", ")", ":", "\n", "\n", "    ", "seg_thresholds", "=", "sorted", "(", "options", ".", "segmentation_thresholds", ")", "\n", "for", "threshold", "in", "seg_thresholds", ":", "\n", "        ", "if", "threshold", "!=", "0", "or", "not", "options", ".", "use_neuroproof", ":", "\n", "            ", "master_logger", ".", "info", "(", "\"Starting agglomeration to threshold \"", "+", "str", "(", "threshold", ")", "\n", "+", "\" with \"", "+", "str", "(", "agglom_stack", ".", "number_of_nodes", "(", ")", ")", ")", "\n", "agglom_stack", ".", "agglomerate", "(", "threshold", ")", "\n", "master_logger", ".", "info", "(", "\"Finished agglomeration to threshold \"", "+", "str", "(", "threshold", ")", "\n", "+", "\" with \"", "+", "str", "(", "agglom_stack", ".", "number_of_nodes", "(", ")", ")", ")", "\n", "\n", "if", "options", ".", "inclusion_removal", ":", "\n", "                ", "inclusion_removal", "(", "agglom_stack", ",", "master_logger", ")", "\n", "\n", "", "", "segmentation", "=", "agglom_stack", ".", "get_segmentation", "(", ")", "\n", "\n", "if", "options", ".", "h5_output", ":", "\n", "            ", "imio", ".", "write_image_stack", "(", "segmentation", ",", "\n", "session_location", "+", "\"/agglom-\"", "+", "str", "(", "threshold", ")", "+", "\".lzf.h5\"", ",", "compression", "=", "'lzf'", ")", "\n", "\n", "\n", "", "md5hex", "=", "hashlib", ".", "md5", "(", "' '", ".", "join", "(", "sys", ".", "argv", ")", ")", ".", "hexdigest", "(", ")", "\n", "file_base", "=", "os", ".", "path", ".", "abspath", "(", "session_location", ")", "+", "\"/seg_data/seg-\"", "+", "str", "(", "threshold", ")", "+", "\"-\"", "+", "md5hex", "+", "\"-\"", "\n", "transforms", "=", "imio", ".", "compute_sp_to_body_map", "(", "supervoxels", ",", "segmentation", ")", "\n", "seg_loc", "=", "file_base", "+", "\"v1.h5\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "session_location", "+", "\"/seg_data\"", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "session_location", "+", "\"/seg_data\"", ")", "\n", "", "imio", ".", "write_mapped_segmentation", "(", "supervoxels", ",", "transforms", ",", "seg_loc", ")", "\n", "\n", "if", "options", ".", "synapse_file", "is", "not", "None", ":", "\n", "            ", "h5temp", "=", "h5py", ".", "File", "(", "seg_loc", ",", "'a'", ")", "\n", "syn_data", "=", "json", ".", "load", "(", "open", "(", "(", "options", ".", "synapse_file", ")", ")", ")", "\n", "meta", "=", "syn_data", "[", "'metadata'", "]", "\n", "meta", "[", "'username'", "]", "=", "\"auto\"", "\n", "syn_data_str", "=", "json", ".", "dumps", "(", "syn_data", ",", "indent", "=", "4", ")", "\n", "str_type", "=", "h5py", ".", "new_vlen", "(", "str", ")", "\n", "ds", "=", "h5temp", ".", "create_dataset", "(", "\"synapse-annotations\"", ",", "data", "=", "syn_data_str", ",", "shape", "=", "(", "1", ",", ")", ",", "dtype", "=", "str_type", ")", "\n", "\n", "", "graph_loc", "=", "file_base", "+", "\"graphv1.json\"", "\n", "\n", "json_data", "=", "{", "}", "\n", "json_data", "[", "'graph'", "]", "=", "graph_loc", "\n", "json_data", "[", "'border'", "]", "=", "options", ".", "border_size", "\n", "subvolume", "=", "{", "}", "\n", "subvolume", "[", "'segmentation-file'", "]", "=", "seg_loc", "\n", "subvolume", "[", "'prediction-file'", "]", "=", "os", ".", "path", ".", "abspath", "(", "session_location", ")", "+", "\"/STACKED_prediction.h5\"", "\n", "\n", "gray_file_whole", "=", "os", ".", "path", ".", "abspath", "(", "glob", ".", "glob", "(", "options", ".", "image_stack", ")", "[", "0", "]", ")", "\n", "gray_path", "=", "os", ".", "path", ".", "dirname", "(", "gray_file_whole", ")", "\n", "\n", "gray_file", "=", "os", ".", "path", ".", "basename", "(", "gray_file_whole", ")", "\n", "field_width", "=", "len", "(", "re", ".", "findall", "(", "r'\\d'", ",", "gray_file", ")", ")", "\n", "field_rep", "=", "\"%%0%dd\"", "%", "field_width", "\n", "gray_file", "=", "re", ".", "sub", "(", "r'\\d+'", ",", "field_rep", ",", "gray_file", ")", "\n", "\n", "subvolume", "[", "'grayscale-files'", "]", "=", "gray_path", "+", "\"/\"", "+", "gray_file", "\n", "\n", "# get extant", "\n", "x1", "=", "options", ".", "border_size", "\n", "y1", "=", "options", ".", "border_size", "\n", "z1", "=", "options", ".", "border_size", "\n", "z2", ",", "y2", ",", "x2", "=", "supervoxels", ".", "shape", "\n", "z2", "=", "z2", "-", "options", ".", "border_size", "-", "1", "\n", "y2", "=", "y2", "-", "options", ".", "border_size", "-", "1", "\n", "x2", "=", "x2", "-", "options", ".", "border_size", "-", "1", "\n", "extant", "=", "re", ".", "findall", "(", "r'\\d+-\\d+_\\d+-\\d+_\\d+-\\d+'", ",", "gray_path", ")", "\n", "if", "len", "(", "extant", ")", ">", "0", ":", "\n", "            ", "bbox", "=", "extant", "[", "0", "]", "\n", "x1", ",", "x2", ",", "y1", ",", "y2", ",", "z1", ",", "z2", "=", "re", ".", "findall", "(", "r'\\d+'", ",", "bbox", ")", "\n", "", "subvolume", "[", "\"far-upper-right\"", "]", "=", "[", "int", "(", "x2", ")", ",", "int", "(", "y2", ")", ",", "int", "(", "z2", ")", "]", "\n", "subvolume", "[", "\"near-lower-left\"", "]", "=", "[", "int", "(", "x1", ")", ",", "int", "(", "y1", ")", ",", "int", "(", "z1", ")", "]", "\n", "\n", "json_data", "[", "'subvolumes'", "]", "=", "[", "subvolume", "]", "\n", "\n", "agglom_stack", ".", "write_plaza_json", "(", "graph_loc", ",", "options", ".", "synapse_file", ",", "(", "int", "(", "z1", ")", "-", "(", "options", ".", "border_size", ")", ")", ")", "\n", "\n", "# write out json file", "\n", "json_str", "=", "json", ".", "dumps", "(", "json_data", ",", "indent", "=", "4", ")", "\n", "json_file", "=", "session_location", "+", "\"/seg-\"", "+", "str", "(", "threshold", ")", "+", "\"-\"", "+", "md5hex", "+", "\"-v1.json\"", "\n", "jw", "=", "open", "(", "json_file", ",", "'w'", ")", "\n", "jw", ".", "write", "(", "json_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.inclusion_removal": [[249, 253], ["master_logger.info", "agglom_stack.remove_inclusions", "master_logger.info", "str", "str", "agglom_stack.number_of_nodes", "agglom_stack.number_of_nodes"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.remove_inclusions", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes"], ["", "", "def", "inclusion_removal", "(", "agglom_stack", ",", "master_logger", ")", ":", "\n", "    ", "master_logger", ".", "info", "(", "\"Starting inclusion removal with \"", "+", "str", "(", "agglom_stack", ".", "number_of_nodes", "(", ")", ")", "+", "\" nodes\"", ")", "\n", "agglom_stack", ".", "remove_inclusions", "(", ")", "\n", "master_logger", ".", "info", "(", "\"Finished inclusion removal with \"", "+", "str", "(", "agglom_stack", ".", "number_of_nodes", "(", ")", ")", "+", "\" nodes\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.output_raveler": [[255, 281], ["master_logger.info", "imio.segs_to_raveler", "os.path.exists", "os.path.exists", "imio.write_to_raveler", "master_logger.warning", "shutil.rmtree"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.segs_to_raveler", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_to_raveler"], ["", "def", "output_raveler", "(", "segmentation", ",", "supervoxels", ",", "grayscale", ",", "name", ",", "session_location", ",", "master_logger", ",", "sps_out", "=", "None", ")", ":", "\n", "    ", "\"\"\"Output segmented data to a Raveler formatted directory\n\n    Args:\n        segmentation:  ndarray.\n        prediction_file:  String.  File name of prediction hdf5 file where predictions\n            are assumed to be in group PREDICTIONS_HDF5_GROUP.\n        grayscale:  ndarray of grayscale.\n        name:  String.  Directory name within raveler-export.\n        session_location:  String.  Top-level export directory.\n\n    Returns:\n        A 2-tuple of supervoxel and prediction matrices.\n    \"\"\"", "\n", "\n", "outdir", "=", "session_location", "+", "\"/raveler-export/\"", "+", "name", "+", "\"/\"", "\n", "master_logger", ".", "info", "(", "\"Exporting Raveler directory: \"", "+", "outdir", ")", "\n", "\n", "rav", "=", "imio", ".", "segs_to_raveler", "(", "supervoxels", ",", "segmentation", ",", "0", ",", "do_conn_comp", "=", "False", ",", "sps_out", "=", "sps_out", ")", "\n", "sps_out", ",", "dummy1", ",", "dummy2", "=", "rav", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "outdir", ")", ":", "\n", "        ", "master_logger", ".", "warning", "(", "\"Overwriting Raveler directory: \"", "+", "outdir", ")", "\n", "shutil", ".", "rmtree", "(", "outdir", ")", "\n", "", "imio", ".", "write_to_raveler", "(", "*", "rav", ",", "directory", "=", "outdir", ",", "gray", "=", "grayscale", ")", "\n", "return", "sps_out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.flow_perform_agglomeration": [[284, 339], ["numpy.array", "segmentation_pipeline.agglomeration", "syngeo.io.raveler_synapse_annotations_to_coords", "syngeo.io.volume_synapse_view", "classify.load_classifier", "json.loads", "master_logger.info", "master_logger.info", "master_logger.info", "segmentation_pipeline.grab_boundary", "agglo.Rag", "master_logger.info", "segmentation_pipeline.inclusion_removal", "str", "Exception", "stack_np.Stack", "features.io.create_fm", "agglo.Rag", "Exception", "master_logger.warning", "agglo.expected_change_vi", "agglo.classifier_probability"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.agglomeration", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.load_classifier", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.grab_boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.inclusion_removal", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.io.create_fm", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.expected_change_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.classifier_probability"], ["", "def", "flow_perform_agglomeration", "(", "options", ",", "supervoxels", ",", "prediction", ",", "image_stack", ",", "\n", "session_location", ",", "sps_out", ",", "master_logger", ")", ":", "\n", "# make synapse constraints", "\n", "    ", "synapse_volume", "=", "numpy", ".", "array", "(", "[", "]", ")", "\n", "if", "not", "options", ".", "use_neuroproof", "and", "options", ".", "synapse_file", "is", "not", "None", ":", "\n", "        ", "pre_post_pairs", "=", "syngeo", ".", "io", ".", "raveler_synapse_annotations_to_coords", "(", "\n", "options", ".", "synapse_file", ")", "\n", "synapse_volume", "=", "syngeo", ".", "io", ".", "volume_synapse_view", "(", "pre_post_pairs", ",", "supervoxels", ".", "shape", ")", "\n", "\n", "# ?! build RAG (automatically load features if classifier file is available, default to median", "\n", "# if no classifier, check if np mode or not, automatically load features in NP as well)", "\n", "\n", "", "if", "options", ".", "classifier", "is", "not", "None", ":", "\n", "        ", "cl", "=", "classify", ".", "load_classifier", "(", "options", ".", "classifier", ")", "\n", "fm_info", "=", "json", ".", "loads", "(", "str", "(", "cl", ".", "feature_description", ")", ")", "\n", "\n", "master_logger", ".", "info", "(", "\"Building RAG\"", ")", "\n", "if", "fm_info", "is", "None", "or", "fm_info", "[", "\"neuroproof_features\"", "]", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "\"agglomeration classifier to old to be used\"", ")", "\n", "", "if", "options", ".", "use_neuroproof", ":", "\n", "            ", "if", "not", "fm_info", "[", "\"neuroproof_features\"", "]", ":", "\n", "                ", "raise", "Exception", "(", "\"random forest created not using neuroproof\"", ")", "\n", "", "agglom_stack", "=", "stack_np", ".", "Stack", "(", "supervoxels", ",", "prediction", ",", "\n", "single_channel", "=", "False", ",", "classifier", "=", "cl", ",", "feature_info", "=", "fm_info", ",", "\n", "synapse_file", "=", "options", ".", "synapse_file", ",", "master_logger", "=", "master_logger", ")", "\n", "", "else", ":", "\n", "            ", "if", "fm_info", "[", "\"neuroproof_features\"", "]", ":", "\n", "                ", "master_logger", ".", "warning", "(", "\"random forest created using neuroproof features -- should still work\"", ")", "\n", "", "fm", "=", "features", ".", "io", ".", "create_fm", "(", "fm_info", ")", "\n", "if", "options", ".", "expected_vi", ":", "\n", "                ", "mpf", "=", "agglo", ".", "expected_change_vi", "(", "fm", ",", "cl", ",", "beta", "=", "options", ".", "vi_beta", ")", "\n", "", "else", ":", "\n", "                ", "mpf", "=", "agglo", ".", "classifier_probability", "(", "fm", ",", "cl", ")", "\n", "\n", "", "agglom_stack", "=", "agglo", ".", "Rag", "(", "supervoxels", ",", "prediction", ",", "mpf", ",", "\n", "feature_manager", "=", "fm", ",", "show_progress", "=", "True", ",", "nozeros", "=", "True", ",", "\n", "exclusions", "=", "synapse_volume", ")", "\n", "", "master_logger", ".", "info", "(", "\"Finished building RAG\"", ")", "\n", "", "else", ":", "\n", "        ", "master_logger", ".", "info", "(", "\"Building RAG\"", ")", "\n", "boundary", "=", "grab_boundary", "(", "prediction", ",", "options", ".", "bound_channels", ",", "master_logger", ")", "\n", "agglom_stack", "=", "agglo", ".", "Rag", "(", "supervoxels", ",", "boundary", ",", "\n", "merge_priority_function", "=", "agglo", ".", "boundary_median", ",", "\n", "show_progress", "=", "True", ",", "nozeros", "=", "True", ",", "exclusions", "=", "synapse_volume", ")", "\n", "master_logger", ".", "info", "(", "\"Finished building RAG\"", ")", "\n", "\n", "\n", "# remove inclusions ", "\n", "", "if", "options", ".", "inclusion_removal", ":", "\n", "        ", "inclusion_removal", "(", "agglom_stack", ",", "master_logger", ")", "\n", "\n", "# actually perform the agglomeration", "\n", "", "agglomeration", "(", "options", ",", "agglom_stack", ",", "supervoxels", ",", "prediction", ",", "image_stack", ",", "\n", "session_location", ",", "sps_out", ",", "master_logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.run_segmentation_pipeline": [[344, 416], ["Exception", "pixel.gen_pixel_probabilities", "segmentation_pipeline.gen_supervoxels", "imio.read_image_stack", "segmentation_pipeline.flow_perform_agglomeration", "master_logger.info", "imio.read_image_stack", "master_logger.info", "imio.write_image_stack", "master_logger.info", "imio.read_image_stack", "prediction.transpose.transpose", "master_logger.info", "Exception"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.gen_pixel_probabilities", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.gen_supervoxels", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.flow_perform_agglomeration", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_image_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_image_stack"], ["", "def", "run_segmentation_pipeline", "(", "session_location", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "\"\"\"Runs segmentation pipeline given classifier and input image in options.\n\n    Args:\n        session_location:  String.  Export data location.\n        options:  OptionNamespace.  Basically a dict with keys corresponding\n            to slightly altered names ('_' instead of '-') within JSON config file.\n\n    Returns:\n        A 2-tuple of supervoxel and prediction ndarray.\n    \"\"\"", "\n", "# read grayscale", "\n", "if", "options", ".", "image_stack", "is", "None", ":", "\n", "        ", "raise", "Exception", "(", "\"Must specify path to grayscale in 'image-stack'\"", ")", "\n", "\n", "# run boundary prediction -- produces a prediction file", "\n", "", "if", "options", ".", "gen_pixel", ":", "\n", "        ", "prediction_file", "=", "pixel", ".", "gen_pixel_probabilities", "(", "session_location", ",", "options", ",", "master_logger", ",", "\n", "options", ".", "image_stack", ")", "\n", "", "else", ":", "\n", "        ", "prediction_file", "=", "options", ".", "pixelprob_file", "\n", "\n", "\n", "# generate supervoxels -- produces supervoxels and output as appropriate", "\n", "", "supervoxels", "=", "None", "\n", "prediction", "=", "None", "\n", "if", "options", ".", "gen_supervoxels", ":", "\n", "        ", "supervoxels", ",", "prediction", "=", "gen_supervoxels", "(", "options", ",", "prediction_file", ",", "master_logger", ")", "\n", "", "elif", "options", ".", "supervoxels_file", ":", "\n", "        ", "master_logger", ".", "info", "(", "\"Reading supervoxels: \"", "+", "options", ".", "supervoxels_file", ")", "\n", "supervoxels", "=", "imio", ".", "read_image_stack", "(", "options", ".", "supervoxels_file", ")", "\n", "#supervoxels = imio.read_mapped_segmentation(options.supervoxels_file) ", "\n", "master_logger", ".", "info", "(", "\"Finished reading supervoxels\"", ")", "\n", "\n", "# write superpixels out to hdf5 and/or raveler files", "\n", "", "sps_out", "=", "None", "\n", "image_stack", "=", "None", "\n", "\n", "if", "options", ".", "raveler_output", ":", "\n", "        ", "image_stack", "=", "imio", ".", "read_image_stack", "(", "options", ".", "image_stack", ")", "\n", "if", "options", ".", "h5_output", ":", "\n", "            ", "imio", ".", "write_image_stack", "(", "supervoxels", ",", "\n", "session_location", "+", "\"/\"", "+", "options", ".", "supervoxels_name", ")", "\n", "\n", "", "", "\"\"\"\n    if supervoxels is not None:\n        if options.h5_output:\n            imio.write_image_stack(supervoxels,\n                session_location + \"/\" + options.supervoxels_name, compression='lzf')\n\n        if options.raveler_output:\n            image_stack = imio.read_image_stack(options.image_stack)\n            sps_out = output_raveler(supervoxels, supervoxels, image_stack, \n                \"supervoxels\", session_location, master_logger)\n            if options.synapse_file is not None:\n                shutil.copyfile(options.synapse_file,\n                         session_location + \"/raveler-export/supervoxels/annotations-synapse.json\") \n    \"\"\"", "\n", "\n", "# agglomerate and generate output", "\n", "if", "options", ".", "gen_agglomeration", ":", "\n", "        ", "if", "prediction", "is", "None", "and", "prediction_file", "is", "not", "None", ":", "\n", "            ", "master_logger", ".", "info", "(", "\"Reading pixel prediction: \"", "+", "prediction_file", ")", "\n", "prediction", "=", "imio", ".", "read_image_stack", "(", "prediction_file", ",", "\n", "group", "=", "PREDICTIONS_HDF5_GROUP", ")", "\n", "prediction", "=", "prediction", ".", "transpose", "(", "(", "2", ",", "1", ",", "0", ",", "3", ")", ")", "\n", "master_logger", ".", "info", "(", "\"Finished reading pixel prediction\"", ")", "\n", "", "elif", "prediction", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "\"No pixel probs available for agglomeration\"", ")", "\n", "\n", "", "flow_perform_agglomeration", "(", "options", ",", "supervoxels", ",", "prediction", ",", "image_stack", ",", "\n", "session_location", ",", "sps_out", ",", "master_logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.prediction_file_verify": [[418, 421], ["Exception", "os.path.isfile", "os.path.isfile"], "function", ["None"], ["", "", "def", "prediction_file_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "ilastik_prediction_file", "and", "not", "os", ".", "path", ".", "isfile", "(", "options", ".", "ilastik_prediction_file", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"ilastik-prediction-file (%s) specified in parameters does not exist\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.np_verify": [[422, 425], ["Exception"], "function", ["None"], ["", "", "def", "np_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "use_neuroproof", "and", "not", "np_installed", ":", "\n", "        ", "raise", "Exception", "(", "\"NeuroProof not properly installed on your machine.  Install or disable neuroproof\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.synapse_file_verify": [[426, 432], ["os.path.exists", "os.path.exists", "Exception", "options.synapse_file.endswith", "Exception"], "function", ["None"], ["", "", "def", "synapse_file_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "synapse_file", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "synapse_file", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Synapse file \"", "+", "options", ".", "synapse_file", "+", "\" not found\"", ")", "\n", "", "if", "not", "options", ".", "synapse_file", ".", "endswith", "(", "'.json'", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Synapse file \"", "+", "options", ".", "synapse_file", "+", "\" does not end with .json\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.classifier_verify": [[433, 437], ["os.path.exists", "os.path.exists", "Exception"], "function", ["None"], ["", "", "", "def", "classifier_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "classifier", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "classifier", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Classifier \"", "+", "options", ".", "classifier", "+", "\" not found\"", ")", "\n", "# Note -- Classifier could be a variety of extensions (.h5, .joblib, etc) depending", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.gen_supervoxels_verify": [[440, 443], ["Exception"], "function", ["None"], ["", "", "", "def", "gen_supervoxels_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "gen_supervoxels", "and", "not", "options", ".", "gen_pixel", "and", "options", ".", "pixelprob_file", "is", "None", ":", "\n", "        ", "raise", "Exception", "(", "\"Must have a pixel prediction to generate supervoxels\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.supervoxels_file_verify": [[445, 449], ["os.path.exists", "os.path.exists", "Exception"], "function", ["None"], ["", "", "def", "supervoxels_file_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "supervoxels_file", "is", "not", "None", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "options", ".", "supervoxels_file", ")", ":", "\n", "            ", "raise", "Exception", "(", "\"Supervoxel file \"", "+", "options", ".", "supervoxels_file", "+", "\" does not exist\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.gen_agglomeration_verify": [[450, 456], ["Exception", "Exception"], "function", ["None"], ["", "", "", "def", "gen_agglomeration_verify", "(", "options_parser", ",", "options", ",", "master_logger", ")", ":", "\n", "    ", "if", "options", ".", "gen_agglomeration", ":", "\n", "        ", "if", "not", "options", ".", "gen_supervoxels", "and", "options", ".", "supervoxels_file", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "\"No supervoxels available for agglomeration\"", ")", "\n", "", "if", "not", "options", ".", "gen_pixel", "and", "options", ".", "pixelprob_file", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "\"No prediction available for agglomeration\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.create_segmentation_pipeline_options": [[458, 541], ["pixel.create_pixel_options", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option", "options_parser.create_option"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.pixel.create_pixel_options", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.option_manager.OptionManager.create_option"], ["", "", "", "def", "create_segmentation_pipeline_options", "(", "options_parser", ")", ":", "\n", "    ", "pixel", ".", "create_pixel_options", "(", "options_parser", ",", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"ilastik-prediction-file\"", ",", "\n", "\"Name of prediction file generated by ilastik headless\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "False", ",", "dtype", "=", "str", ",", "verify_fn", "=", "prediction_file_verify", ",", "\n", "num_args", "=", "None", ",", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"use-neuroproof\"", ",", "\"Use NeuroProof\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "verify_fn", "=", "np_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'NP'", ",", "warning", "=", "False", ",", "hidden", "=", "(", "not", "np_installed", ")", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"supervoxels-name\"", ",", "\"Name for the supervoxel segmentation\"", ",", "\n", "default_val", "=", "\"supervoxels.h5\"", ",", "required", "=", "False", ",", "dtype", "=", "str", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"supervoxels-file\"", ",", "\"Supervoxel segmentation file or directory stack\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "False", ",", "dtype", "=", "str", ",", "verify_fn", "=", "supervoxels_file_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"gen-supervoxels\"", ",", "\"Enable supervoxel generation\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "verify_fn", "=", "gen_supervoxels_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'GS'", ",", "warning", "=", "True", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"inclusion-removal\"", ",", "\"Disable inclusion removal\"", ",", "\n", "default_val", "=", "True", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'IR'", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"seed-val\"", ",", "\"Threshold for choosing seeds\"", ",", "\n", "default_val", "=", "0", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"seed-size\"", ",", "\"Threshold for seed size\"", ",", "\n", "default_val", "=", "0", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'SS'", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"synapse-file\"", ",", "\"Json file containing synapse information\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "False", ",", "dtype", "=", "str", ",", "verify_fn", "=", "synapse_file_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'SJ'", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"mask-file\"", ",", "\"Text file specifying a region with no segmentation (left-hand coordinates and should be offset from border\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "False", ",", "dtype", "=", "str", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"segmentation-thresholds\"", ",", "\"Segmentation thresholds\"", ",", "\n", "default_val", "=", "[", "]", ",", "required", "=", "False", ",", "dtype", "=", "float", ",", "verify_fn", "=", "None", ",", "num_args", "=", "'+'", ",", "\n", "shortcut", "=", "'ST'", ",", "warning", "=", "True", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"gen-agglomeration\"", ",", "\"Enable agglomeration\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "verify_fn", "=", "gen_agglomeration_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'GA'", ",", "warning", "=", "True", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"raveler-output\"", ",", "\"Disable Raveler output\"", ",", "\n", "default_val", "=", "True", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"h5-output\"", ",", "\"Enable h5 output\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"classifier\"", ",", "\"H5 file containing RF\"", ",", "\n", "default_val", "=", "None", ",", "required", "=", "False", ",", "dtype", "=", "str", ",", "verify_fn", "=", "classifier_verify", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "'k'", ",", "warning", "=", "False", ",", "hidden", "=", "False", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"bound-channels\"", ",", "\"Channel numbers designated as boundary\"", ",", "\n", "default_val", "=", "[", "0", "]", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "'+'", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"expected-vi\"", ",", "\"Enable expected VI during agglomeration\"", ",", "\n", "default_val", "=", "False", ",", "required", "=", "False", ",", "dtype", "=", "bool", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"vi-beta\"", ",", "\"Relative penalty for false merges in weighted expected VI\"", ",", "\n", "default_val", "=", "1.0", ",", "required", "=", "False", ",", "dtype", "=", "float", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"synapse-dilation\"", ",", "\"Dilate synapse points by this amount\"", ",", "\n", "default_val", "=", "1", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n", "options_parser", ".", "create_option", "(", "\"border-size\"", ",", "\"Size of the border in pixels\"", ",", "\n", "default_val", "=", "0", ",", "required", "=", "False", ",", "dtype", "=", "int", ",", "verify_fn", "=", "None", ",", "num_args", "=", "None", ",", "\n", "shortcut", "=", "None", ",", "warning", "=", "False", ",", "hidden", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.entrypoint": [[542, 556], ["app_logger.AppLogger", "app_logger.AppLogger.get_logger", "session_manager.Session", "applogger.get_logger.info", "segmentation_pipeline.run_segmentation_pipeline", "applogger.get_logger.error", "applogger.get_logger.error", "str", "str", "traceback.format_exc", "traceback.format_exc"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.app_logger.AppLogger.get_logger", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.segmentation_pipeline.run_segmentation_pipeline"], ["", "def", "entrypoint", "(", "argv", ")", ":", "\n", "    ", "applogger", "=", "app_logger", ".", "AppLogger", "(", "False", ",", "'seg-pipeline'", ")", "\n", "master_logger", "=", "applogger", ".", "get_logger", "(", ")", "\n", "\n", "try", ":", "\n", "        ", "session", "=", "session_manager", ".", "Session", "(", "\"seg-pipeline\"", ",", "\n", "\"Segmentation pipeline (featuring boundary prediction, median agglomeration or trained agglomeration, inclusion removal, and raveler exports)\"", ",", "\n", "master_logger", ",", "applogger", ",", "create_segmentation_pipeline_options", ")", "\n", "master_logger", ".", "info", "(", "\"Session location: \"", "+", "session", ".", "session_location", ")", "\n", "run_segmentation_pipeline", "(", "session", ".", "session_location", ",", "session", ".", "options", ",", "master_logger", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "", "except", "KeyboardInterrupt", "as", "err", ":", "\n", "        ", "master_logger", ".", "error", "(", "str", "(", "traceback", ".", "format_exc", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.util.write_segmentation_pipeline_json": [[13, 23], ["isinstance", "open", "json.dump"], "function", ["None"], ["def", "write_segmentation_pipeline_json", "(", "jsonfn", ",", "ilfn", ",", "ilbfns", ",", "outdir", "=", "'.'", ")", ":", "\n", "    ", "if", "isinstance", "(", "ilbfns", ",", "str", ")", ":", "\n", "        ", "ilbfns", "=", "[", "ilbfns", "]", "\n", "", "d", "=", "{", "}", "\n", "d", "[", "'images'", "]", "=", "[", "{", "'name'", ":", "ilbfn", "}", "for", "ilbfn", "in", "ilbfns", "]", "\n", "d", "[", "'session'", "]", "=", "ilfn", "\n", "d", "[", "'output_dir'", "]", "=", "outdir", "\n", "d", "[", "'features'", "]", "=", "default_feature_set", "\n", "with", "open", "(", "jsonfn", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "d", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.util.make_dir": [[24, 35], ["os.makedirs", "Exception"], "function", ["None"], ["", "", "def", "make_dir", "(", "dirname", ")", ":", "\n", "    ", "\"\"\"\n    Make a directory if it doesn't already exist.\n    \"\"\"", "\n", "try", ":", "\n", "        ", "os", ".", "makedirs", "(", "dirname", ")", "\n", "", "except", "OSError", "as", "exc", ":", "\n", "        ", "if", "exc", ".", "errno", "==", "errno", ".", "EEXIST", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Unable to create directory: \"", "+", "dirname", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.util.make_temp_dir": [[36, 49], ["util.make_dir", "os.path.join", "util.make_dir", "uuid.uuid4"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.util.make_dir", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.util.make_dir"], ["", "", "", "def", "make_temp_dir", "(", "base_dirname", ",", "prefix", "=", "'tmp'", ")", ":", "\n", "    ", "\"\"\"\n    Make a unique temporary directory as a subdirectory of passed base\n    directory name.\n\n    Returns:\n        The unique temporary directory created.\n    \"\"\"", "\n", "make_dir", "(", "base_dirname", ")", "\n", "uid_hex", "=", "prefix", "+", "uuid", ".", "uuid4", "(", ")", ".", "hex", "\n", "tmp_dir", "=", "os", ".", "path", ".", "join", "(", "base_dirname", ",", "uid_hex", ")", "\n", "make_dir", "(", "tmp_dir", ")", "\n", "return", "tmp_dir", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.Rag.__init__": [[156, 160], ["agglo2.fast_rag", "viridis.tree.Ultrametric", "agglo2.Rag.graph.nodes"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.fast_rag"], ["def", "__init__", "(", "self", ",", "labels", ":", "np", ".", "ndarray", ",", "connectivity", ":", "int", "=", "1", ")", ":", "\n", "        ", "self", ".", "labels", "=", "labels", "\n", "self", ".", "graph", "=", "fast_rag", "(", "labels", ",", "connectivity", ")", "\n", "self", ".", "tree", "=", "tree", ".", "Ultrametric", "(", "init_nodes", "=", "self", ".", "graph", ".", "nodes", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.Rag.merge_subgraph": [[161, 185], ["agglo2.Rag.graph.subgraph", "len", "agglo2.Rag.graph.subgraph", "networkx.dfs_preorder_nodes", "next", "networkx.connected_components", "agglo2.Rag.tree.merge"], "methods", ["None"], ["", "def", "merge_subgraph", "(", "self", ",", "subgraph", ":", "Iterable", "=", "{", "}", ",", "\n", "source", ":", "int", "=", "None", ")", ":", "\n", "        ", "\"\"\"Merge nodes given by `subgraph`.\n\n        Parameters\n        ----------\n        subgraph : iterable of int, optional\n            A subset of nodes in `self.graph`.\n        source : int, optional\n            Merge subgraph starting at this node.\n        \"\"\"", "\n", "# first, turn node collection into graph (ie with corresponding edges)", "\n", "subgraph", "=", "self", ".", "graph", ".", "subgraph", "(", "subgraph", ")", "\n", "if", "len", "(", "subgraph", ")", "==", "0", ":", "\n", "# do nothing given empty subgraph", "\n", "            ", "return", "\n", "", "for", "connected_subgraph", "in", "(", "\n", "self", ".", "graph", ".", "subgraph", "(", "c", ")", "\n", "for", "c", "in", "nx", ".", "connected_components", "(", "subgraph", ")", "\n", ")", ":", "\n", "            ", "ordered_nodes", "=", "nx", ".", "dfs_preorder_nodes", "(", "connected_subgraph", ",", "source", ")", "\n", "current_node", "=", "next", "(", "ordered_nodes", ")", "\n", "for", "next_node", "in", "ordered_nodes", ":", "\n", "                ", "current_node", "=", "self", ".", "tree", ".", "merge", "(", "current_node", ",", "next_node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.Rag.current_segmentation": [[186, 204], ["agglo2.Rag.tree.get_map"], "methods", ["None"], ["", "", "", "def", "current_segmentation", "(", "self", ",", "\n", "cut_threshold", ":", "float", "=", "np", ".", "inf", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Return the segmentation implied by the graph and current merge tree.\n\n        Parameters\n        ----------\n        cut_threshold : float, optional\n            If provided, cut the merge tree at this threshold (virtually;\n            the tree is not modified) before calculating the segmentation.\n\n        Returns\n        -------\n        seg : array of int\n            The segmentation.\n\n        \"\"\"", "\n", "label_map", "=", "self", ".", "tree", ".", "get_map", "(", "cut_threshold", ")", "\n", "return", "label_map", "[", "self", ".", "labels", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.edge_matrix": [[13, 43], ["scipy.ndimage.generate_binary_structure", "scipy.ndimage.grey_erosion().ravel", "scipy.ndimage.grey_dilation().ravel", "labels.ravel.ravel", "numpy.flatnonzero", "numpy.flatnonzero", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "scipy.sparse.coo_matrix", "numpy.max", "scipy.ndimage.grey_erosion", "scipy.ndimage.grey_dilation"], "function", ["None"], ["def", "edge_matrix", "(", "labels", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"Generate a COO matrix containing the coordinates of edge pixels.\n\n    Parameters\n    ----------\n    labels : array of int\n        An array of labeled pixels (or voxels).\n    connectivity : int in {1, ..., labels.ndim}\n        The square connectivity for considering neighborhood.\n\n    Returns\n    -------\n    edges : sparse.coo_matrix\n        A COO matrix where (i, j) indicate neighboring labels and the\n        corresponding data element is the linear index of the edge pixel\n        in the labels array.\n    \"\"\"", "\n", "conn", "=", "ndi", ".", "generate_binary_structure", "(", "labels", ".", "ndim", ",", "connectivity", ")", "\n", "eroded", "=", "ndi", ".", "grey_erosion", "(", "labels", ",", "footprint", "=", "conn", ")", ".", "ravel", "(", ")", "\n", "dilated", "=", "ndi", ".", "grey_dilation", "(", "labels", ",", "footprint", "=", "conn", ")", ".", "ravel", "(", ")", "\n", "labels", "=", "labels", ".", "ravel", "(", ")", "\n", "boundaries0", "=", "np", ".", "flatnonzero", "(", "eroded", "!=", "labels", ")", "\n", "boundaries1", "=", "np", ".", "flatnonzero", "(", "dilated", "!=", "labels", ")", "\n", "labels_small", "=", "np", ".", "concatenate", "(", "(", "eroded", "[", "boundaries0", "]", ",", "labels", "[", "boundaries1", "]", ")", ")", "\n", "labels_large", "=", "np", ".", "concatenate", "(", "(", "labels", "[", "boundaries0", "]", ",", "dilated", "[", "boundaries1", "]", ")", ")", "\n", "n", "=", "np", ".", "max", "(", "labels_large", ")", "+", "1", "\n", "data", "=", "np", ".", "concatenate", "(", "(", "boundaries0", ",", "boundaries1", ")", ")", "\n", "sparse_graph", "=", "sparse", ".", "coo_matrix", "(", "(", "data", ",", "(", "labels_small", ",", "labels_large", ")", ")", ",", "\n", "dtype", "=", "np", ".", "int_", ",", "shape", "=", "(", "n", ",", "n", ")", ")", "\n", "return", "sparse_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.sparse_boundaries": [[45, 69], ["coo_boundaries.copy().tocsr", "numpy.arange", "numpy.ravel", "sparselol.extents", "sparselol.SparseLOL", "coo_boundaries.copy", "len"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.sparselol.extents", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "sparse_boundaries", "(", "coo_boundaries", ")", ":", "\n", "    ", "\"\"\"Use a sparselol to map edges to boundary extents.\n\n    Parameters\n    ----------\n    coo_boundaries : sparse.coo_matrix\n        The boundary locations encoded in ``(i, j, loc)`` form in a sparse COO\n        matrix (scipy), where ``loc`` is the raveled index of a pixel that is\n        part of the boundary between segments ``i`` and ``j``.\n\n    Returns\n    -------\n    edge_to_idx : CSR matrix\n        Maps each edge `[i, j]` to a unique index `v`.\n    bounds : SparseLOL\n        A map of edge indices to locations in the volume.\n    \"\"\"", "\n", "edge_to_idx", "=", "coo_boundaries", ".", "copy", "(", ")", ".", "tocsr", "(", ")", "\n", "# edge_to_idx: CSR matrix that maps each edge to a unique integer", "\n", "# we don't use the ID 0 so that empty spots can be used to mean \"no ID\".", "\n", "edge_to_idx", ".", "data", "=", "np", ".", "arange", "(", "1", ",", "len", "(", "edge_to_idx", ".", "data", ")", "+", "1", ",", "dtype", "=", "np", ".", "int_", ")", "\n", "edge_labels", "=", "np", ".", "ravel", "(", "edge_to_idx", "[", "coo_boundaries", ".", "row", ",", "coo_boundaries", ".", "col", "]", ")", "\n", "bounds", "=", "sparselol", ".", "extents", "(", "edge_labels", ",", "input_indices", "=", "coo_boundaries", ".", "data", ")", "\n", "return", "edge_to_idx", ",", "sparselol", ".", "SparseLOL", "(", "bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.fast_rag": [[71, 133], ["agglo2.edge_matrix", "numpy.broadcast_to", "edge_matrix.tocsr", "networkx.from_scipy_sparse_matrix", "numpy.ones", "networkx.Graph"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.edge_matrix"], ["", "def", "fast_rag", "(", "labels", ",", "connectivity", "=", "1", ",", "out", "=", "None", ")", ":", "\n", "    ", "\"\"\"Build a data-free region adjacency graph quickly.\n\n    Parameters\n    ----------\n    labels : array of int\n        Image pre-segmentation or segmentation\n    connectivity : int in {1, ..., labels.ndim}, optional\n        Use square connectivity equal to `connectivity`. See\n        `scipy.ndimage.generate_binary_structure` for more.\n    out : networkx.Graph, optional\n        Add edges into this graph object.\n\n    Returns\n    -------\n    g : networkx Graph\n        A graph where nodes represent regions in `labels` and edges\n        indicate adjacency.\n\n    Examples\n    --------\n    >>> labels = np.array([[1, 1, 1, 2, 2],\n    ...                    [1, 1, 1, 2, 2],\n    ...                    [3, 3, 4, 4, 4],\n    ...                    [3, 3, 4, 4, 4]], dtype=np.int_)\n    >>> sorted(fast_rag(labels).edges())\n    [(1, 2), (1, 3), (1, 4), (2, 4), (3, 4)]\n\n    Use the ``out`` parameter to build into an existing networkx graph.\n    Warning: the existing graph contents will be cleared!\n\n    >>> import networkx as nx\n    >>> g = nx.Graph()\n    >>> h = fast_rag(labels, out=g)\n    >>> g is h\n    True\n    >>> sorted(h.edges())\n    [(1, 2), (1, 3), (1, 4), (2, 4), (3, 4)]\n\n    The edges contain the number of pixels counted in the boundary:\n\n    >>> h[1][4]\n    {'count': 2}\n    >>> h[1][3]\n    {'count': 4}\n\n    ``fast_rag`` works on data of any dimension. For a 1D array:\n\n    >>> labels = np.array([1, 1, 5, 5], dtype=np.int_)\n    >>> list(fast_rag(labels).edges())\n    [(1, 5)]\n    \"\"\"", "\n", "coo_graph", "=", "edge_matrix", "(", "labels", ",", "connectivity", ")", "\n", "# use a broadcast array of ones as data; these will get aggregated", "\n", "# into counts when the COO is converted to CSR", "\n", "coo_graph", ".", "data", "=", "np", ".", "broadcast_to", "(", "np", ".", "ones", "(", "(", "1", ",", ")", ",", "dtype", "=", "np", ".", "int_", ")", ",", "\n", "coo_graph", ".", "row", ".", "shape", ")", "\n", "sparse_graph", "=", "coo_graph", ".", "tocsr", "(", ")", "\n", "rag", "=", "nx", ".", "Graph", "(", ")", "if", "out", "is", "None", "else", "out", "\n", "rag", "=", "nx", ".", "from_scipy_sparse_matrix", "(", "sparse_graph", ",", "create_using", "=", "rag", ",", "\n", "edge_attribute", "=", "'count'", ")", "\n", "return", "rag", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.best_segmentation": [[206, 244], ["evaluate.assignment_table().tocsc", "agglo2.Rag", "range", "agglo2.Rag.current_segmentation", "numpy.random.seed", "agglo2.Rag.merge_subgraph", "evaluate.assignment_table", "len"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.Rag.current_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_subgraph", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.assignment_table"], ["", "", "def", "best_segmentation", "(", "fragments", ":", "np", ".", "ndarray", ",", "ground_truth", ":", "np", ".", "ndarray", ",", "\n", "random_seed", ":", "int", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"Return the best segmentation possible when only merging in `fragments`.\n\n    Parameters\n    ----------\n    fragments : array of int\n        An initial oversegmentation.\n    ground_truth : array of int\n        The true segmentation.\n    random_seed : int, optional\n        Seed `numpy.random` with this value.\n\n    Returns\n    -------\n    segments : array of int\n        The closest segmentation to `ground_truth` that can be obtained\n        by only merging in `fragments`.\n\n    Examples\n    --------\n    >>> fragments = np.array([[1, 1, 1, 2],\n    ...                       [1, 1, 2, 2],\n    ...                       [3, 4, 4, 4]], dtype=np.int_)\n    >>> ground_truth = np.array([[1, 1, 2, 2]] * 3, dtype=np.int_)\n    >>> best_segmentation(fragments, ground_truth)\n    array([[5, 5, 5, 6],\n           [5, 5, 6, 6],\n           [5, 6, 6, 6]])\n    \"\"\"", "\n", "if", "random_seed", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "random_seed", ")", "\n", "", "assignments", "=", "ev", ".", "assignment_table", "(", "fragments", ",", "ground_truth", ")", ".", "tocsc", "(", ")", "\n", "indptr", "=", "assignments", ".", "indptr", "\n", "rag", "=", "Rag", "(", "fragments", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "indptr", ")", "-", "1", ")", ":", "\n", "        ", "rag", ".", "merge_subgraph", "(", "assignments", ".", "indices", "[", "indptr", "[", "i", "]", ":", "indptr", "[", "i", "+", "1", "]", "]", ")", "\n", "", "return", "rag", ".", "current_segmentation", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stitch.EvalAction.__call__": [[14, 16], ["setattr", "eval"], "methods", ["None"], ["    ", "def", "__call__", "(", "parser", ",", "namespace", ",", "values", ",", "option_string", "=", "None", ")", ":", "\n", "        ", "setattr", "(", "namespace", ",", "self", ".", "dest", ",", "eval", "(", "values", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stitch.is_one_to_one_mapping": [[17, 25], ["dict", "zip", "all", "array1.ravel", "array2.ravel", "pixelmap[].add", "set", "len", "dict.values"], "function", ["None"], ["", "", "def", "is_one_to_one_mapping", "(", "array1", ",", "array2", ")", ":", "\n", "    ", "pixelmap", "=", "dict", "(", ")", "\n", "for", "p1", ",", "p2", "in", "zip", "(", "array1", ".", "ravel", "(", ")", ",", "array2", ".", "ravel", "(", ")", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "pixelmap", "[", "p1", "]", ".", "add", "(", "p2", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "pixelmap", "[", "p1", "]", "=", "set", "(", "[", "p2", "]", ")", "\n", "", "", "return", "all", "(", "[", "len", "(", "m", ")", "==", "1", "for", "m", "in", "pixelmap", ".", "values", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stitch.crop_probs_and_ws": [[26, 31], ["scipy.ndimage.measurements.label"], "function", ["None"], ["", "def", "crop_probs_and_ws", "(", "crop", ",", "probs", ",", "ws", ")", ":", "\n", "    ", "xmin", ",", "xmax", ",", "ymin", ",", "ymax", ",", "zmin", ",", "zmax", "=", "crop", "\n", "probs", "=", "probs", "[", "xmin", ":", "xmax", ",", "ymin", ":", "ymax", ",", "zmin", ":", "zmax", "]", "\n", "ws", "=", "label", "(", "ws", "[", "xmin", ":", "xmax", ",", "ymin", ":", "ymax", ",", "zmin", ":", "zmax", "]", ")", "[", "0", "]", "\n", "return", "probs", ",", "ws", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.__init__": [[468, 515], ["numpy.array", "numpy.array", "features.base.Null", "numpy.array", "numpy.array", "networkx.Graph.__init__", "agglo.Rag.set_watershed", "agglo.Rag.set_probabilities", "agglo.Rag.set_orientations", "agglo.Rag.build_graph_from_watershed", "agglo.Rag.set_feature_manager", "agglo.Rag.set_ground_truth", "agglo.Rag.set_exclusions", "mergequeue.MergeQueue", "viridis.tree.Ultrametric", "set", "set", "iterprogress.StandardProgressBar", "iterprogress.NoProgressBar", "numpy.broadcast_to", "morpho.pad().ravel", "agglo.Rag.nodes", "agglo.Rag.nodes", "agglo.Rag.edges", "isfrozennode", "isfrozenedge", "morpho.pad", "agglo.Rag.frozen_nodes.add", "agglo.Rag.frozen_edges.add"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_watershed", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_probabilities", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_orientations", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_graph_from_watershed", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_feature_manager", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_ground_truth", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_exclusions", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad"], ["def", "__init__", "(", "self", ",", "watershed", "=", "array", "(", "[", "]", ",", "label_dtype", ")", ",", "\n", "probabilities", "=", "array", "(", "[", "]", ")", ",", "\n", "merge_priority_function", "=", "boundary_mean", ",", "gt_vol", "=", "None", ",", "\n", "feature_manager", "=", "features", ".", "base", ".", "Null", "(", ")", ",", "mask", "=", "None", ",", "\n", "show_progress", "=", "False", ",", "connectivity", "=", "1", ",", "\n", "channel_is_oriented", "=", "None", ",", "orientation_map", "=", "array", "(", "[", "]", ")", ",", "\n", "normalize_probabilities", "=", "False", ",", "exclusions", "=", "array", "(", "[", "]", ")", ",", "\n", "isfrozennode", "=", "None", ",", "isfrozenedge", "=", "None", ",", "use_slow", "=", "False", ",", "\n", "update_unchanged_edges", "=", "False", ")", ":", "\n", "\n", "        ", "super", "(", "Rag", ",", "self", ")", ".", "__init__", "(", "weighted", "=", "False", ")", "\n", "self", ".", "show_progress", "=", "show_progress", "\n", "self", ".", "connectivity", "=", "connectivity", "\n", "self", ".", "pbar", "=", "(", "ip", ".", "StandardProgressBar", "(", ")", "if", "self", ".", "show_progress", "\n", "else", "ip", ".", "NoProgressBar", "(", ")", ")", "\n", "self", ".", "set_watershed", "(", "watershed", ",", "connectivity", ")", "\n", "self", ".", "set_probabilities", "(", "probabilities", ",", "normalize_probabilities", ")", "\n", "self", ".", "set_orientations", "(", "orientation_map", ",", "channel_is_oriented", ")", "\n", "self", ".", "merge_priority_function", "=", "merge_priority_function", "\n", "self", ".", "max_merge_score", "=", "-", "inf", "\n", "if", "mask", "is", "None", ":", "\n", "            ", "self", ".", "mask", "=", "np", ".", "broadcast_to", "(", "[", "True", "]", ",", "self", ".", "watershed_r", ".", "shape", ")", "\n", "self", ".", "is_masked", "=", "False", "\n", "", "else", ":", "\n", "            ", "self", ".", "mask", "=", "morpho", ".", "pad", "(", "mask", ",", "True", ")", ".", "ravel", "(", ")", "\n", "self", ".", "is_masked", "=", "True", "\n", "", "self", ".", "use_slow", "=", "use_slow", "\n", "self", ".", "build_graph_from_watershed", "(", ")", "\n", "self", ".", "set_feature_manager", "(", "feature_manager", ")", "\n", "self", ".", "set_ground_truth", "(", "gt_vol", ")", "\n", "self", ".", "set_exclusions", "(", "exclusions", ")", "\n", "self", ".", "merge_queue", "=", "MergeQueue", "(", ")", "\n", "self", ".", "tree", "=", "tree", ".", "Ultrametric", "(", "self", ".", "nodes", "(", ")", ")", "\n", "self", ".", "frozen_nodes", "=", "set", "(", ")", "\n", "if", "isfrozennode", "is", "not", "None", ":", "\n", "            ", "for", "node", "in", "self", ".", "nodes", "(", ")", ":", "\n", "                ", "if", "isfrozennode", "(", "self", ",", "node", ")", ":", "\n", "                    ", "self", ".", "frozen_nodes", ".", "add", "(", "node", ")", "\n", "", "", "", "self", ".", "frozen_edges", "=", "set", "(", ")", "\n", "if", "isfrozenedge", "is", "not", "None", ":", "\n", "            ", "for", "n1", ",", "n2", "in", "self", ".", "edges", "(", ")", ":", "\n", "                ", "if", "isfrozenedge", "(", "self", ",", "n1", ",", "n2", ")", ":", "\n", "                    ", "self", ".", "frozen_edges", ".", "add", "(", "(", "n1", ",", "n2", ")", ")", "\n", "", "", "", "self", ".", "update_unchanged_edges", "=", "update_unchanged_edges", "\n", "if", "update_unchanged_edges", ":", "\n", "            ", "self", ".", "move_edge", "=", "self", ".", "merge_edge_properties", "\n", "", "self", ".", "fast_edges", "=", "not", "use_slow", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.__copy__": [[517, 536], ["agglo.Rag", "morpho.juicy_center", "agglo.Rag.mask.reshape", "morpho.juicy_center", "morpho.juicy_center", "morpho.juicy_center"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center"], ["", "def", "__copy__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of the object and attributes.\n        \"\"\"", "\n", "mask", "=", "(", "\n", "morpho", ".", "juicy_center", "(", "self", ".", "mask", ".", "reshape", "(", "self", ".", "probabilities", ".", "shape", ")", ")", "\n", "if", "self", ".", "is_masked", "\n", "else", "None", "\n", ")", "\n", "return", "Rag", "(", "\n", "watershed", "=", "morpho", ".", "juicy_center", "(", "self", ".", "watershed", ")", ",", "\n", "probabilities", "=", "morpho", ".", "juicy_center", "(", "self", ".", "probabilities", ")", ",", "\n", "merge_priority_function", "=", "self", ".", "merge_priority_function", ",", "\n", "gt_vol", "=", "morpho", ".", "juicy_center", "(", "self", ".", "gt", ")", "if", "self", ".", "gt", "else", "None", ",", "\n", "feature_manager", "=", "self", ".", "feature_manager", ",", "\n", "mask", "=", "mask", ",", "\n", "show_progress", "=", "self", ".", "show_progress", ",", "\n", "connectivity", "=", "self", ".", "connectivity", ",", "\n", "use_slow", "=", "self", ".", "use_slow", ",", "\n", "update_unchanged_edges", "=", "self", ".", "update_unchanged_edges", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy": [[539, 543], ["agglo.Rag.__copy__"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.__copy__"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of the object and attributes.\n        \"\"\"", "\n", "return", "self", ".", "__copy__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.extent": [[545, 562], ["numpy.concatenate().astype", "optimized.flood_fill", "numpy.ravel_multi_index", "set", "numpy.concatenate", "numpy.array", "numpy.fromiter", "len", "sys.stderr.write", "len"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write"], ["", "def", "extent", "(", "self", ",", "nodeid", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "ext", "=", "self", ".", "extents", "\n", "full_ext", "=", "[", "ext", "[", "f", "]", "for", "f", "in", "self", ".", "nodes", "[", "nodeid", "]", "[", "'fragments'", "]", "]", "\n", "return", "np", ".", "concatenate", "(", "full_ext", ")", ".", "astype", "(", "np", ".", "intp", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "extent_array", "=", "opt", ".", "flood_fill", "(", "self", ".", "watershed", ",", "\n", "np", ".", "array", "(", "self", ".", "nodes", "[", "nodeid", "]", "[", "'entrypoint'", "]", ")", ",", "\n", "np", ".", "fromiter", "(", "self", ".", "nodes", "[", "nodeid", "]", "[", "'fragments'", "]", ",", "\n", "dtype", "=", "int", ")", ")", "\n", "if", "len", "(", "extent_array", ")", "!=", "self", ".", "nodes", "[", "nodeid", "]", "[", "'size'", "]", ":", "\n", "                ", "sys", ".", "stderr", ".", "write", "(", "'Flood fill fail - found %d voxels but size'", "\n", "'expected %d\\n'", "%", "(", "len", "(", "extent_array", ")", ",", "\n", "self", ".", "nodes", "[", "nodeid", "]", "[", "'size'", "]", ")", ")", "\n", "", "raveled_indices", "=", "np", ".", "ravel_multi_index", "(", "extent_array", ".", "T", ",", "\n", "self", ".", "watershed", ".", "shape", ")", "\n", "return", "set", "(", "raveled_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary": [[563, 573], ["numpy.concatenate().astype", "numpy.concatenate"], "methods", ["None"], ["", "", "def", "boundary", "(", "self", ",", "u", ",", "v", ")", ":", "\n", "        ", "edge_dict", "=", "self", ".", "edges", "[", "u", ",", "v", "]", "\n", "try", ":", "\n", "            ", "boundary_ids", "=", "edge_dict", "[", "'boundary-ids'", "]", "\n", "", "except", "KeyError", ":", "# RAG built using old, slow method", "\n", "            ", "bound", "=", "edge_dict", "[", "'boundary'", "]", "\n", "", "else", ":", "\n", "            ", "all_bounds", "=", "[", "self", ".", "boundaries", "[", "i", "]", "for", "i", "in", "boundary_ids", "]", "\n", "bound", "=", "np", ".", "concatenate", "(", "all_bounds", ")", ".", "astype", "(", "np", ".", "intp", ")", "\n", "", "return", "bound", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.real_edges": [[575, 599], ["super().edges"], "methods", ["None"], ["", "def", "real_edges", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Return edges internal to the volume.\n\n        The RAG actually includes edges to a \"virtual\" region that\n        envelops the entire volume. This function returns the list of\n        edges that are internal to the volume.\n\n        Parameters\n        ----------\n        *args, **kwargs : arbitrary types\n            Arguments and keyword arguments are passed through to the\n            ``edges()`` function of the ``networkx.Graph`` class.\n\n        Returns\n        -------\n        edge_list : list of tuples\n            A list of pairs of node IDs, which are typically integers.\n\n        See Also\n        --------\n        real_edges_iter, networkx.Graph.edges\n        \"\"\"", "\n", "return", "[", "e", "for", "e", "in", "super", "(", "Rag", ",", "self", ")", ".", "edges", "(", "*", "args", ",", "**", "kwargs", ")", "if", "\n", "self", ".", "boundary_body", "not", "in", "e", "[", ":", "2", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.real_edges_iter": [[600, 621], ["super().edges_iter"], "methods", ["None"], ["", "def", "real_edges_iter", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Return iterator of edges internal to the volume.\n\n        The RAG actually includes edges to a \"virtual\" region that\n        envelops the entire volume. This function returns the list of\n        edges that are internal to the volume.\n\n        Parameters\n        ----------\n        *args, **kwargs : arbitrary types\n            Arguments and keyword arguments are passed through to the\n            ``edges()`` function of the ``networkx.Graph`` class.\n\n        Returns\n        -------\n        edges_iter : iterator of tuples\n            An iterator over pairs of node IDs, which are typically\n            integers.\n        \"\"\"", "\n", "return", "(", "e", "for", "e", "in", "super", "(", "Rag", ",", "self", ")", ".", "edges_iter", "(", "*", "args", ",", "**", "kwargs", ")", "if", "\n", "self", ".", "boundary_body", "not", "in", "e", "[", ":", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_graph_from_watershed": [[622, 649], ["agglo.Rag.build_nodes", "numpy.arange", "agglo.Rag.build_edges_slow", "agglo.Rag.build_edges_fast"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_edges_slow", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_edges_fast"], ["", "def", "build_graph_from_watershed", "(", "self", ",", "idxs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Build the graph object from the region labels.\n\n        The region labels should have been set ahead of time using\n        ``set_watershed()``.\n\n        Parameters\n        ----------\n        idxs : array-like of int, optional\n            Linear indices into raveled volume array. If provided, the\n            graph is built only for these indices.\n        \"\"\"", "\n", "if", "self", ".", "watershed", ".", "size", "==", "0", ":", "\n", "            ", "return", "# stop processing for empty graphs", "\n", "", "idxs_is_none", "=", "idxs", "is", "None", "\n", "if", "idxs_is_none", ":", "\n", "            ", "idxs", "=", "arange", "(", "self", ".", "watershed", ".", "size", ",", "dtype", "=", "self", ".", "steps", ".", "dtype", ")", "\n", "", "if", "self", ".", "is_masked", ":", "\n", "            ", "idxs", "=", "idxs", "[", "self", ".", "mask", "[", "idxs", "]", "]", "# use only masked idxs", "\n", "", "self", ".", "build_nodes", "(", "idxs", ")", "\n", "if", "self", ".", "is_masked", "or", "not", "idxs_is_none", "or", "self", ".", "use_slow", ":", "\n", "            ", "self", ".", "fast_edges", "=", "False", "\n", "inner_idxs", "=", "idxs", "[", "self", ".", "watershed_r", "[", "idxs", "]", "!=", "self", ".", "boundary_body", "]", "\n", "self", ".", "build_edges_slow", "(", "inner_idxs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fast_edges", "=", "True", "\n", "self", ".", "build_edges_fast", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_nodes": [[650, 664], ["agglo.Rag.add_node", "numpy.unique", "numpy.bincount", "hasattr", "sparselol.SparseLOL", "agglo.Rag.add_node", "numpy.array", "sparselol.extents", "numpy.unravel_index", "agglo.Rag.extent"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.sparselol.extents", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.extent"], ["", "", "def", "build_nodes", "(", "self", ",", "idxs", ")", ":", "\n", "        ", "self", ".", "add_node", "(", "self", ".", "boundary_body", ")", "\n", "labels", "=", "np", ".", "unique", "(", "self", ".", "watershed_r", "[", "idxs", "]", ")", "\n", "sizes", "=", "np", ".", "bincount", "(", "self", ".", "watershed_r", ")", "\n", "if", "not", "hasattr", "(", "self", ",", "'extents'", ")", ":", "\n", "            ", "self", ".", "extents", "=", "lol", ".", "SparseLOL", "(", "lol", ".", "extents", "(", "self", ".", "watershed", ")", ")", "\n", "", "for", "nodeid", "in", "labels", ":", "\n", "            ", "self", ".", "add_node", "(", "nodeid", ")", "\n", "node", "=", "self", ".", "nodes", "[", "nodeid", "]", "\n", "node", "[", "'size'", "]", "=", "sizes", "[", "nodeid", "]", "\n", "node", "[", "'fragments'", "]", "=", "{", "nodeid", "}", "# set literal", "\n", "node", "[", "'entrypoint'", "]", "=", "(", "\n", "np", ".", "array", "(", "np", ".", "unravel_index", "(", "self", ".", "extent", "(", "nodeid", ")", "[", "0", "]", ",", "\n", "self", ".", "watershed", ".", "shape", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_edges_slow": [[665, 681], ["iterprogress.with_progress", "set", "agglo.Rag.has_edge", "[].append", "agglo.Rag.add_edge"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.with_progress"], ["", "", "def", "build_edges_slow", "(", "self", ",", "idxs", ")", ":", "\n", "        ", "if", "self", ".", "show_progress", ":", "\n", "            ", "idxs", "=", "ip", ".", "with_progress", "(", "idxs", ",", "title", "=", "'Graph '", ",", "pbar", "=", "self", ".", "pbar", ")", "\n", "", "for", "idx", "in", "idxs", ":", "\n", "            ", "nodeid", "=", "self", ".", "watershed_r", "[", "idx", "]", "\n", "ns", "=", "idx", "+", "self", ".", "steps", "\n", "ns", "=", "ns", "[", "self", ".", "mask", "[", "ns", "]", "]", "\n", "adj", "=", "self", ".", "watershed_r", "[", "ns", "]", "\n", "adj", "=", "set", "(", "adj", ")", "\n", "for", "v", "in", "adj", ":", "\n", "                ", "if", "v", "==", "nodeid", ":", "\n", "                    ", "continue", "\n", "", "if", "self", ".", "has_edge", "(", "nodeid", ",", "v", ")", ":", "\n", "                    ", "self", ".", "edges", "[", "nodeid", ",", "v", "]", "[", "'boundary'", "]", ".", "append", "(", "idx", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "add_edge", "(", "nodeid", ",", "v", ",", "boundary", "=", "[", "idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_edges_fast": [[682, 693], ["agglo2.edge_matrix", "agglo2.sparse_boundaries", "edge_map.tocoo", "agglo.Rag.add_edges_from", "range"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.edge_matrix", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo2.sparse_boundaries"], ["", "", "", "", "def", "build_edges_fast", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build the graph edges using agglo2's sparse graph functions.\n        \"\"\"", "\n", "edges_coo", "=", "agglo2", ".", "edge_matrix", "(", "self", ".", "watershed", ",", "self", ".", "connectivity", ")", "\n", "edge_map", ",", "self", ".", "boundaries", "=", "agglo2", ".", "sparse_boundaries", "(", "edges_coo", ")", "\n", "coo", "=", "edge_map", ".", "tocoo", "(", ")", "\n", "edges_iter", "=", "(", "(", "i", ",", "j", ",", "{", "'boundary-ids'", ":", "{", "edge_map", "[", "i", ",", "j", "]", "}", "}", ")", "\n", "for", "i", "in", "range", "(", "edge_map", ".", "shape", "[", "0", "]", ")", "\n", "for", "j", "in", "edge_map", ".", "indices", "[", "edge_map", ".", "indptr", "[", "i", "]", ":", "\n", "edge_map", ".", "indptr", "[", "i", "+", "1", "]", "]", ")", "\n", "self", ".", "add_edges_from", "(", "edges_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_feature_manager": [[694, 708], ["agglo.Rag.compute_feature_caches"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.compute_feature_caches"], ["", "def", "set_feature_manager", "(", "self", ",", "feature_manager", ")", ":", "\n", "        ", "\"\"\"Set the feature manager and ensure feature caches are computed.\n\n        Parameters\n        ----------\n        feature_manager : ``features.base.Null`` object\n            The feature manager to be used by this RAG.\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "self", ".", "feature_manager", "=", "feature_manager", "\n", "self", ".", "compute_feature_caches", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.compute_feature_caches": [[710, 729], ["iterprogress.with_progress", "iterprogress.with_progress", "agglo.Rag.nodes", "agglo.Rag.feature_manager.create_node_cache", "agglo.Rag.edges", "agglo.Rag.feature_manager.create_edge_cache"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.with_progress", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.with_progress", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.create_node_cache", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.create_edge_cache"], ["", "def", "compute_feature_caches", "(", "self", ")", ":", "\n", "        ", "\"\"\"Use the feature manager to compute node and edge feature caches.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "for", "n", "in", "ip", ".", "with_progress", "(", "\n", "self", ".", "nodes", "(", ")", ",", "title", "=", "'Node caches '", ",", "pbar", "=", "self", ".", "pbar", ")", ":", "\n", "            ", "self", ".", "nodes", "[", "n", "]", "[", "'feature-cache'", "]", "=", "self", ".", "feature_manager", ".", "create_node_cache", "(", "self", ",", "n", ")", "\n", "", "for", "n1", ",", "n2", "in", "ip", ".", "with_progress", "(", "\n", "self", ".", "edges", "(", ")", ",", "title", "=", "'Edge caches '", ",", "pbar", "=", "self", ".", "pbar", ")", ":", "\n", "            ", "self", ".", "edges", "[", "n1", ",", "n2", "]", "[", "'feature-cache'", "]", "=", "self", ".", "feature_manager", ".", "create_edge_cache", "(", "self", ",", "n1", ",", "n2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_probabilities": [[731, 774], ["numpy.array", "probs.astype.astype.astype", "tuple", "len", "numpy.zeros_like", "agglo.Rag.probabilities.ravel", "probs.astype.astype.min", "probs.astype.astype.max", "morpho.pad", "len", "numpy.array", "agglo.Rag.probabilities.ravel", "list", "morpho.pad", "agglo.Rag.probabilities.reshape", "numpy.ones", "range"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad"], ["", "", "def", "set_probabilities", "(", "self", ",", "probs", "=", "array", "(", "[", "]", ")", ",", "normalize", "=", "False", ")", ":", "\n", "        ", "\"\"\"Set the `probabilities` attributes of the RAG.\n\n        For various reasons, including removing the need for bounds\n        checking when looking for neighboring pixels, the volume of\n        pixel-level probabilities is padded on all faces. In addition,\n        this function adds an attribute `probabilities_r`, a raveled\n        view of the padded probabilities array for quick access to\n        individual voxels using linear indices.\n\n        Parameters\n        ----------\n        probs : array\n            The input probabilities array.\n        normalize : bool, optional\n            If ``True``, the values in the array are scaled to be in\n            [0, 1].\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "if", "len", "(", "probs", ")", "==", "0", ":", "\n", "            ", "self", ".", "probabilities", "=", "zeros_like", "(", "self", ".", "watershed", ")", "\n", "self", ".", "probabilities_r", "=", "self", ".", "probabilities", ".", "ravel", "(", ")", "\n", "", "probs", "=", "probs", ".", "astype", "(", "'float'", ")", "\n", "if", "normalize", "and", "len", "(", "probs", ")", ">", "1", ":", "\n", "            ", "probs", "-=", "probs", ".", "min", "(", ")", "# ensure probs.min() == 0", "\n", "probs", "/=", "probs", ".", "max", "(", ")", "# ensure probs.max() == 1", "\n", "", "sp", "=", "probs", ".", "shape", "\n", "sw", "=", "tuple", "(", "array", "(", "self", ".", "watershed", ".", "shape", ",", "dtype", "=", "int", ")", "-", "2", "*", "self", ".", "pad_thickness", "*", "ones", "(", "self", ".", "watershed", ".", "ndim", ",", "dtype", "=", "int", ")", ")", "\n", "p_ndim", "=", "probs", ".", "ndim", "\n", "w_ndim", "=", "self", ".", "watershed", ".", "ndim", "\n", "padding", "=", "[", "inf", "]", "+", "(", "self", ".", "pad_thickness", "-", "1", ")", "*", "[", "0", "]", "\n", "if", "p_ndim", "==", "w_ndim", ":", "\n", "            ", "self", ".", "probabilities", "=", "morpho", ".", "pad", "(", "probs", ",", "padding", ")", "\n", "self", ".", "probabilities_r", "=", "self", ".", "probabilities", ".", "ravel", "(", ")", "[", ":", ",", "newaxis", "]", "\n", "", "elif", "p_ndim", "==", "w_ndim", "+", "1", ":", "\n", "            ", "axes", "=", "list", "(", "range", "(", "p_ndim", "-", "1", ")", ")", "\n", "self", ".", "probabilities", "=", "morpho", ".", "pad", "(", "probs", ",", "padding", ",", "axes", ")", "\n", "self", ".", "probabilities_r", "=", "self", ".", "probabilities", ".", "reshape", "(", "\n", "(", "self", ".", "watershed", ".", "size", ",", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_orientations": [[776, 816], ["morpho.pad().astype", "agglo.Rag.orientation_map.ravel", "len", "numpy.zeros_like", "agglo.Rag.orientation_map.ravel", "numpy.array", "numpy.zeros_like", "numpy.zeros_like", "agglo.Rag.probabilities_r[].max", "morpho.pad", "list", "range", "len"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad"], ["", "", "def", "set_orientations", "(", "self", ",", "orientation_map", ",", "channel_is_oriented", ")", ":", "\n", "        ", "\"\"\"Set the orientation map of the probability image.\n\n        Parameters\n        ----------\n        orientation_map : array of float\n            A map of angles of the same shape as the superpixel map.\n        channel_is_oriented : 1D array-like of bool\n            A vector having length the number of channels in the\n            probability map.\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "if", "len", "(", "orientation_map", ")", "==", "0", ":", "\n", "            ", "self", ".", "orientation_map", "=", "zeros_like", "(", "self", ".", "watershed", ")", "\n", "self", ".", "orientation_map_r", "=", "self", ".", "orientation_map", ".", "ravel", "(", ")", "\n", "", "padding", "=", "[", "0", "]", "+", "(", "self", ".", "pad_thickness", "-", "1", ")", "*", "[", "0", "]", "\n", "self", ".", "orientation_map", "=", "morpho", ".", "pad", "(", "orientation_map", ",", "padding", ")", ".", "astype", "(", "int", ")", "\n", "self", ".", "orientation_map_r", "=", "self", ".", "orientation_map", ".", "ravel", "(", ")", "\n", "if", "channel_is_oriented", "is", "None", ":", "\n", "            ", "nchannels", "=", "1", "if", "self", ".", "probabilities", ".", "ndim", "==", "self", ".", "watershed", ".", "ndim", "else", "self", ".", "probabilities", ".", "shape", "[", "-", "1", "]", "\n", "self", ".", "channel_is_oriented", "=", "array", "(", "[", "False", "]", "*", "nchannels", ")", "\n", "self", ".", "max_probabilities_r", "=", "zeros_like", "(", "self", ".", "probabilities_r", ")", "\n", "self", ".", "oriented_probabilities_r", "=", "zeros_like", "(", "self", ".", "probabilities_r", ")", "\n", "self", ".", "non_oriented_probabilities_r", "=", "self", ".", "probabilities_r", "\n", "", "else", ":", "\n", "            ", "self", ".", "channel_is_oriented", "=", "channel_is_oriented", "\n", "self", ".", "max_probabilities_r", "=", "self", ".", "probabilities_r", "[", ":", ",", "self", ".", "channel_is_oriented", "]", ".", "max", "(", "axis", "=", "1", ")", "\n", "self", ".", "oriented_probabilities_r", "=", "self", ".", "probabilities_r", "[", ":", ",", "self", ".", "channel_is_oriented", "]", "\n", "self", ".", "oriented_probabilities_r", "=", "self", ".", "oriented_probabilities_r", "[", "\n", "list", "(", "range", "(", "len", "(", "self", ".", "oriented_probabilities_r", ")", ")", ")", ",", "\n", "self", ".", "orientation_map_r", "]", "\n", "self", ".", "non_oriented_probabilities_r", "=", "self", ".", "probabilities_r", "[", ":", ",", "~", "self", ".", "channel_is_oriented", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_watershed": [[818, 850], ["numpy.array", "ws.astype.astype.astype", "morpho.pad", "agglo.Rag.watershed.ravel", "morpho.raveled_steps_to_neighbors", "skimage.segmentation.relabel_sequential", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.raveled_steps_to_neighbors"], ["", "", "def", "set_watershed", "(", "self", ",", "ws", "=", "array", "(", "[", "]", ",", "label_dtype", ")", ",", "connectivity", "=", "1", ")", ":", "\n", "        ", "\"\"\"Set the initial segmentation volume (watershed).\n\n        The initial segmentation is called `watershed` for historical\n        reasons only.\n\n        Parameters\n        ----------\n        ws : array of int\n            The initial segmentation.\n        connectivity : int in {1, ..., `ws.ndim`}, optional\n            The pixel neighborhood.\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "ws", "=", "ws", ".", "astype", "(", "label_dtype", ")", "\n", "try", ":", "\n", "            ", "self", ".", "boundary_body", "=", "np", ".", "max", "(", "ws", ")", "+", "1", "\n", "", "except", "ValueError", ":", "# empty watershed given", "\n", "            ", "self", ".", "boundary_body", "=", "1", "\n", "", "self", ".", "volume_size", "=", "ws", ".", "size", "\n", "if", "ws", ".", "size", ">", "0", ":", "\n", "            ", "ws", ",", "fw", ",", "inv", "=", "relabel_sequential", "(", "ws", ")", "\n", "self", ".", "inverse_watershed_map", "=", "inv", "# translates to original labels", "\n", "self", ".", "forward_map", "=", "fw", "\n", "", "self", ".", "watershed", "=", "morpho", ".", "pad", "(", "ws", ",", "self", ".", "boundary_body", ")", "\n", "self", ".", "watershed_r", "=", "self", ".", "watershed", ".", "ravel", "(", ")", "\n", "self", ".", "pad_thickness", "=", "1", "\n", "self", ".", "steps", "=", "morpho", ".", "raveled_steps_to_neighbors", "(", "self", ".", "watershed", ".", "shape", ",", "\n", "connectivity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.__contains__": [[851, 854], ["agglo.Rag.forward_map", "networkx.Graph.__contains__", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.__contains__"], ["", "def", "__contains__", "(", "self", ",", "value", ")", ":", "\n", "        ", "new_value", "=", "self", ".", "forward_map", "(", "np", ".", "asarray", "(", "value", ")", ")", "\n", "return", "super", "(", ")", ".", "__contains__", "(", "new_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_ground_truth": [[856, 888], ["morpho.pad", "evaluate.merge_contingency_table", "gt.max", "numpy.ones", "numpy.ones", "agglo.Rag.watershed.max", "agglo.Rag.number_of_nodes"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.merge_contingency_table", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes"], ["", "def", "set_ground_truth", "(", "self", ",", "gt", "=", "None", ")", ":", "\n", "        ", "\"\"\"Set the ground truth volume.\n\n        This is useful for tracking segmentation accuracy over time.\n\n        Parameters\n        ----------\n        gt : array of int\n            A ground truth segmentation of the same volume passed to\n            ``set_watershed``.\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "if", "gt", "is", "not", "None", ":", "\n", "            ", "gtm", "=", "gt", ".", "max", "(", ")", "+", "1", "\n", "gt_ignore", "=", "[", "0", ",", "gtm", "]", "if", "(", "gt", "==", "0", ")", ".", "any", "(", ")", "else", "[", "gtm", "]", "\n", "seg_ignore", "=", "[", "0", ",", "self", ".", "boundary_body", "]", "if", "(", "self", ".", "watershed", "==", "0", ")", ".", "any", "(", ")", "else", "[", "self", ".", "boundary_body", "]", "\n", "self", ".", "gt", "=", "morpho", ".", "pad", "(", "gt", ",", "gtm", ")", "\n", "self", ".", "rig", "=", "merge_contingency_table", "(", "self", ".", "watershed", ",", "self", ".", "gt", ",", "\n", "ignore_seg", "=", "seg_ignore", ",", "\n", "ignore_gt", "=", "gt_ignore", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "gt", "=", "None", "\n", "# null pattern to transparently allow merging of nodes.", "\n", "# Bonus feature: counts how many sp's went into a single node.", "\n", "try", ":", "\n", "                ", "self", ".", "rig", "=", "ones", "(", "2", "*", "self", ".", "watershed", ".", "max", "(", ")", "+", "1", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "self", ".", "rig", "=", "ones", "(", "2", "*", "self", ".", "number_of_nodes", "(", ")", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_exclusions": [[890, 919], ["agglo.Rag.nodes", "morpho.pad", "numpy.unique", "set", "set", "list", "morpho.pad.ravel", "numpy.flatnonzero", "agglo.Rag.extent"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.pad", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.extent"], ["", "", "", "def", "set_exclusions", "(", "self", ",", "excl", ")", ":", "\n", "        ", "\"\"\"Set an exclusion volume, forbidding certain merges.\n\n        Parameters\n        ----------\n        excl : array of int\n            Exclusions work as follows: the volume `excl` is the same\n            shape as the initial segmentation (see ``set_watershed``),\n            and consists of mostly 0s. Any voxels with *the same*\n            non-zero label will not be allowed to merge during\n            agglomeration (provided they were not merged in the initial\n            segmentation).\n\n            This allows manual separation *a priori* of difficult-to-\n            -segment regions.\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "if", "excl", ".", "size", "!=", "0", ":", "\n", "            ", "excl", "=", "morpho", ".", "pad", "(", "excl", ",", "[", "0", "]", "*", "self", ".", "pad_thickness", ")", "\n", "", "for", "n", "in", "self", ".", "nodes", "(", ")", ":", "\n", "            ", "if", "excl", ".", "size", "!=", "0", ":", "\n", "                ", "eids", "=", "unique", "(", "excl", ".", "ravel", "(", ")", "[", "self", ".", "extent", "(", "n", ")", "]", ")", "\n", "eids", "=", "eids", "[", "flatnonzero", "(", "eids", ")", "]", "\n", "self", ".", "nodes", "[", "n", "]", "[", "'exclusions'", "]", "=", "set", "(", "list", "(", "eids", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "nodes", "[", "n", "]", "[", "'exclusions'", "]", "=", "set", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_merge_queue": [[921, 954], ["agglo.Rag.real_edges", "zip", "mergequeue.MergeQueue", "agglo.Rag.merge_priority_function", "queue_items.append"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.real_edges"], ["", "", "", "def", "build_merge_queue", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build a queue of node pairs to be merged in a specific priority.\n\n        Returns\n        -------\n        mq : MergeQueue object\n            A MergeQueue is a Python ``deque`` with a specific element\n            structure: a list of length 4 containing:\n                 - the merge priority (any ordered type)\n                 - a 'valid' flag\n                 - and the two nodes in arbitrary order\n            The valid flag allows one to \"remove\" elements from the\n            queue in O(1) time by setting the flag to ``False``. Then,\n            one checks the flag when popping elements and ignores those\n            marked as invalid.\n\n            One other specific feature is that there are back-links from\n            edges to their corresponding queue items so that when nodes\n            are merged, affected edges can be invalidated and reinserted\n            in the queue with a new priority.\n        \"\"\"", "\n", "edges", "=", "self", ".", "real_edges", "(", ")", "\n", "if", "edges", ":", "\n", "            ", "weights", "=", "self", ".", "merge_priority_function", "(", "self", ",", "edges", ")", "\n", "", "else", ":", "\n", "            ", "weights", "=", "[", "]", "\n", "", "queue_items", "=", "[", "]", "\n", "for", "w", ",", "(", "l1", ",", "l2", ")", "in", "zip", "(", "weights", ",", "edges", ")", ":", "\n", "            ", "qitem", "=", "[", "w", ",", "True", ",", "l1", ",", "l2", "]", "\n", "queue_items", ".", "append", "(", "qitem", ")", "\n", "self", ".", "edges", "[", "l1", ",", "l2", "]", "[", "'qlink'", "]", "=", "qitem", "\n", "self", ".", "edges", "[", "l1", ",", "l2", "]", "[", "'weight'", "]", "=", "w", "\n", "", "return", "MergeQueue", "(", "queue_items", ",", "with_progress", "=", "self", ".", "show_progress", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rebuild_merge_queue": [[956, 964], ["agglo.Rag.build_merge_queue"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_merge_queue"], ["", "def", "rebuild_merge_queue", "(", "self", ")", ":", "\n", "        ", "\"\"\"Build a merge queue from scratch and assign to self.merge_queue.\n\n        See Also\n        --------\n        build_merge_queue\n        \"\"\"", "\n", "self", ".", "merge_queue", "=", "self", ".", "build_merge_queue", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate": [[966, 1013], ["agglo.Rag.merge_queue.is_empty", "tqdm.tqdm.tqdm", "tqdm.tqdm.tqdm.close", "agglo.Rag.build_merge_queue", "agglo.Rag.merge_queue.pop", "agglo.Rag.update_frozen_sets", "agglo.Rag.merge_nodes", "tqdm.tqdm.tqdm.update", "len", "history.append", "scores.append", "evaluation.append", "agglo.Rag.number_of_nodes", "agglo.Rag.merge_queue.peek", "agglo.Rag.split_vi", "agglo.Rag.number_of_nodes"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.is_empty", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_merge_queue", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.pop", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.update_frozen_sets", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.update", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.peek", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes"], ["", "def", "agglomerate", "(", "self", ",", "threshold", "=", "0.5", ",", "save_history", "=", "False", ")", ":", "\n", "        ", "\"\"\"Merge nodes hierarchically until given edge confidence threshold.\n\n        This is the main workhorse of the ``agglo`` module!\n\n        Parameters\n        ----------\n        threshold : float, optional\n            The edge priority at which to stop merging.\n        save_history : bool, optional\n            Whether to save and return a history of all the merges made.\n\n        Returns\n        -------\n        history : list of tuple of int, optional\n            The ordered history of node pairs merged.\n        scores : list of float, optional\n            The list of merge scores corresponding to the `history`.\n        evaluation : list of tuple, optional\n            The split VI after each merge. This is only meaningful if\n            a ground truth volume was provided at build time.\n\n        Notes\n        -----\n            This function returns ``None`` when `save_history` is\n            ``False``.\n        \"\"\"", "\n", "if", "self", ".", "merge_queue", ".", "is_empty", "(", ")", ":", "\n", "            ", "self", ".", "merge_queue", "=", "self", ".", "build_merge_queue", "(", ")", "\n", "", "history", ",", "scores", ",", "evaluation", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "# total merges is number of nodes minus boundary_node minus one.", "\n", "progress", "=", "tqdm", "(", "total", "=", "self", ".", "number_of_nodes", "(", ")", "-", "2", ")", "\n", "while", "len", "(", "self", ".", "merge_queue", ")", ">", "0", "and", "self", ".", "merge_queue", ".", "peek", "(", ")", "[", "0", "]", "<", "threshold", ":", "\n", "            ", "merge_priority", ",", "_", ",", "n1", ",", "n2", "=", "self", ".", "merge_queue", ".", "pop", "(", ")", "\n", "self", ".", "update_frozen_sets", "(", "n1", ",", "n2", ")", "\n", "self", ".", "merge_nodes", "(", "n1", ",", "n2", ",", "merge_priority", ")", "\n", "if", "save_history", ":", "\n", "                ", "history", ".", "append", "(", "(", "n1", ",", "n2", ")", ")", "\n", "scores", ".", "append", "(", "merge_priority", ")", "\n", "evaluation", ".", "append", "(", "\n", "(", "self", ".", "number_of_nodes", "(", ")", "-", "1", ",", "self", ".", "split_vi", "(", ")", ")", "\n", ")", "\n", "", "progress", ".", "update", "(", "1", ")", "\n", "", "progress", ".", "close", "(", ")", "\n", "if", "save_history", ":", "\n", "            ", "return", "history", ",", "scores", ",", "evaluation", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate_count": [[1015, 1065], ["agglo.Rag.merge_queue.is_empty", "range", "agglo.Rag.build_merge_queue", "agglo.Rag.merge_queue.pop", "agglo.Rag.merge_nodes", "len", "history.append", "evaluation.append", "agglo.Rag.split_vi", "agglo.Rag.number_of_nodes"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.is_empty", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_merge_queue", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.pop", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes"], ["", "", "def", "agglomerate_count", "(", "self", ",", "stepsize", "=", "100", ",", "save_history", "=", "False", ")", ":", "\n", "        ", "\"\"\"Agglomerate until 'stepsize' merges have been made.\n\n        This function is like ``agglomerate``, but rather than to a\n        certain threshold, a certain number of merges are made,\n        regardless of threshold.\n\n        Parameters\n        ----------\n        stepsize : int, optional\n            The number of merges to make.\n        save_history : bool, optional\n            Whether to save and return a history of all the merges made.\n\n        Returns\n        -------\n        history : list of tuple of int, optional\n            The ordered history of node pairs merged.\n        scores : list of float, optional\n            The list of merge scores corresponding to the `history`.\n        evaluation : list of tuple, optional\n            The split VI after each merge. This is only meaningful if\n            a ground truth volume was provided at build time.\n\n        Notes\n        -----\n            This function returns ``None`` when `save_history` is\n            ``False``.\n\n        See Also\n        --------\n        agglomerate\n        \"\"\"", "\n", "if", "self", ".", "merge_queue", ".", "is_empty", "(", ")", ":", "\n", "            ", "self", ".", "merge_queue", "=", "self", ".", "build_merge_queue", "(", ")", "\n", "", "history", ",", "evaluation", "=", "[", "]", ",", "[", "]", "\n", "i", "=", "0", "\n", "for", "i", "in", "range", "(", "stepsize", ")", ":", "\n", "            ", "if", "len", "(", "self", ".", "merge_queue", ")", "==", "0", ":", "\n", "                ", "break", "\n", "", "merge_priority", ",", "_", ",", "n1", ",", "n2", "=", "self", ".", "merge_queue", ".", "pop", "(", ")", "\n", "i", "+=", "1", "\n", "self", ".", "merge_nodes", "(", "n1", ",", "n2", ",", "merge_priority", ")", "\n", "if", "save_history", ":", "\n", "                ", "history", ".", "append", "(", "(", "n1", ",", "n2", ")", ")", "\n", "evaluation", ".", "append", "(", "\n", "(", "self", ".", "number_of_nodes", "(", ")", "-", "1", ",", "self", ".", "split_vi", "(", ")", ")", "\n", ")", "\n", "", "", "if", "save_history", ":", "\n", "            ", "return", "history", ",", "evaluation", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate_ladder": [[1067, 1102], ["agglo.make_ladder", "agglo.Rag.rebuild_merge_queue", "agglo.Rag.agglomerate", "agglo.Rag.merge_queue.finish", "agglo.Rag.rebuild_merge_queue", "max", "agglo.Rag.tree.nodes"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.make_ladder", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rebuild_merge_queue", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.finish", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rebuild_merge_queue"], ["", "", "def", "agglomerate_ladder", "(", "self", ",", "min_size", "=", "1000", ",", "strictness", "=", "2", ")", ":", "\n", "        ", "\"\"\"Merge sequentially all nodes smaller than `min_size`.\n\n        Parameters\n        ----------\n        min_size : int, optional\n            The smallest allowable segment after ladder completion.\n        strictness : {1, 2, 3}, optional\n            `strictness == 1`: all nodes smaller than `min_size` are\n            merged according to the merge priority function.\n            `strictness == 2`: in addition to `1`, small nodes can only\n            be merged to big nodes.\n            `strictness == 3`: in addition to `2`, nodes sharing less\n            than one pixel of boundary are not agglomerated.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        Nodes that are on the volume boundary are not agglomerated.\n        \"\"\"", "\n", "original_merge_priority_function", "=", "self", ".", "merge_priority_function", "\n", "self", ".", "merge_priority_function", "=", "make_ladder", "(", "\n", "self", ".", "merge_priority_function", ",", "min_size", ",", "strictness", "\n", ")", "\n", "self", ".", "rebuild_merge_queue", "(", ")", "\n", "self", ".", "agglomerate", "(", "inf", ")", "\n", "self", ".", "merge_priority_function", "=", "original_merge_priority_function", "\n", "self", ".", "merge_queue", ".", "finish", "(", ")", "\n", "self", ".", "rebuild_merge_queue", "(", ")", "\n", "max_score", "=", "max", "(", "[", "qitem", "[", "0", "]", "for", "qitem", "in", "self", ".", "merge_queue", ".", "q", "]", ")", "\n", "for", "n", "in", "self", ".", "tree", ".", "nodes", "(", ")", ":", "\n", "            ", "self", ".", "tree", ".", "nodes", "[", "n", "]", "[", "'w'", "]", "-=", "max_score", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_agglomerate": [[1104, 1271], ["learning_mode.lower.lower.lower", "labeling_mode.lower.lower.lower", "priority_mode.lower.lower.lower", "range", "type", "evaluate.merge_contingency_table", "copy.deepcopy", "agglo.Rag.copy", "agglo.Rag.rebuild_merge_queue", "alldata.append", "logging.debug", "agglo.Rag.get_segmentation", "alldata.append", "agglo.Rag.learn_epoch", "len", "agglo.Rag.learn_flat", "classify.unique_learning_data_elements", "classify.get_classifier", "classify.sample_training_data", "cl.fit.fit.fit", "active_function", "classify.unique_learning_data_elements", "classify.concatenate_data_elements", "len"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.merge_contingency_table", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rebuild_merge_queue", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_epoch", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_flat", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.unique_learning_data_elements", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.get_classifier", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.sample_training_data", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.unique_learning_data_elements", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.concatenate_data_elements"], ["", "", "def", "learn_agglomerate", "(", "self", ",", "gts", ",", "feature_map", ",", "\n", "min_num_samples", "=", "1", ",", "\n", "learn_flat", "=", "True", ",", "\n", "learning_mode", "=", "'strict'", ",", "\n", "labeling_mode", "=", "'assignment'", ",", "\n", "priority_mode", "=", "'active'", ",", "\n", "memory", "=", "True", ",", "\n", "unique", "=", "True", ",", "\n", "random_state", "=", "None", ",", "\n", "max_num_epochs", "=", "10", ",", "\n", "min_num_epochs", "=", "2", ",", "\n", "max_num_samples", "=", "np", ".", "inf", ",", "\n", "classifier", "=", "'random forest'", ",", "\n", "active_function", "=", "classifier_probability", ",", "\n", "mpf", "=", "boundary_mean", ")", ":", "\n", "        ", "\"\"\"Agglomerate while comparing to ground truth & classifying merges.\n\n        Parameters\n        ----------\n        gts : array of int or list thereof\n            The ground truth volume(s) corresponding to the current\n            probability map.\n        feature_map : function (Rag, node, node) -> array of float\n            The map from node pairs to a feature vector. This must\n            consist either of uncached features or of the cache used\n            when building the graph.\n        min_num_samples : int, optional\n            Continue training until this many training examples have\n            been collected.\n        learn_flat : bool, optional\n            Do a flat learning on the static graph with no\n            agglomeration.\n        learning_mode : {'strict', 'loose'}, optional\n            In 'strict' mode, if a \"don't merge\" edge is encountered,\n            it is added to the training set but the merge is not\n            executed. In 'loose' mode, the merge is allowed to proceed.\n        labeling_mode : {'assignment', 'vi-sign', 'rand-sign'}, optional\n            How to decide whether two nodes should be merged based on\n            the ground truth segmentations. ``'assignment'`` means the\n            nodes are assigned to the ground truth node with which they\n            share the highest overlap. ``'vi-sign'`` means the the VI\n            change of the switch is used (negative is better).\n            ``'rand-sign'`` means the change in Rand index is used\n            (positive is better).\n        priority_mode : string, optional\n            One of:\n                ``'active'``: Train a priority function with the data\n                              from previous epochs to obtain the next.\n                ``'random'``: Merge edges at random.\n                ``'mixed'``: Alternate between epochs of ``'active'``\n                             and ``'random'``.\n                ``'mean'``: Use the mean boundary value. (In this case,\n                            training is limited to 1 or 2 epochs.)\n                ``'custom'``: Use the function provided by `mpf`.\n        memory : bool, optional\n            Keep the training data from all epochs (rather than just\n            the most recent one).\n        unique : bool, optional\n            Remove duplicate feature vectors.\n        random_state : int, optional\n            If provided, this parameter is passed to `get_classifier`\n            to set the random state and allow consistent results across\n            tests.\n        max_num_epochs : int, optional\n            Do not train for longer than this (this argument *may*\n            override the `min_num_samples` argument).\n        min_num_epochs : int, optional\n            Train for no fewer than this number of epochs.\n        max_num_samples : int, optional\n            Train for no more than this number of samples.\n        classifier : string, optional\n            Any valid classifier descriptor. See\n            ``gala.classify.get_classifier()``\n        active_function : function (feat. map, classifier) -> function, optional\n            Use this to create the next priority function after an\n            epoch.\n        mpf : function (Rag, node, node) -> float\n            A merge priority function to use when ``priority_mode`` is\n            ``'custom'``.\n\n        Returns\n        -------\n        data : list of array\n            Four arrays containing:\n                - the feature vectors, shape ``(n_samples, n_features)``.\n                - the labels, shape ``(n_samples, 3)``. A value of `-1`\n                  means \"should merge\", while `1` means \"should\n                  not merge\". The columns correspond to the three\n                  labeling methods: assignment, VI sign, or RI sign.\n                - the VI and RI change of each merge, ``(n_edges, 2)``.\n                - the list of merged edges ``(n_edges, 2)``.\n        alldata : list of list of array\n            A list of lists like `data` above: one list for each epoch.\n\n        Notes\n        -----\n        The gala algorithm [1] uses the default parameters. For the\n        LASH algorithm [2], use:\n            - `learning_mode`: ``'loose'``\n            - `labeling_mode`: ``'rand-sign'``\n            - `memory`: ``False``\n\n        References\n        ----------\n        .. [1] Nunez-Iglesias et al, Machine learning of hierarchical\n               clustering to segment 2D and 3D images, PLOS ONE, 2013.\n        .. [2] Jain et al, Learning to agglomerate superpixel\n               hierarchies, NIPS, 2011.\n\n        See Also\n        --------\n        Rag\n        \"\"\"", "\n", "learning_mode", "=", "learning_mode", ".", "lower", "(", ")", "\n", "labeling_mode", "=", "labeling_mode", ".", "lower", "(", ")", "\n", "priority_mode", "=", "priority_mode", ".", "lower", "(", ")", "\n", "if", "priority_mode", "==", "'mean'", "and", "unique", ":", "\n", "            ", "max_num_epochs", "=", "2", "if", "learn_flat", "else", "1", "\n", "", "if", "priority_mode", "in", "[", "'random'", ",", "'mean'", "]", "and", "not", "memory", ":", "\n", "            ", "max_num_epochs", "=", "1", "\n", "", "label_type_keys", "=", "{", "'assignment'", ":", "0", ",", "'vi-sign'", ":", "1", ",", "'rand-sign'", ":", "2", "}", "\n", "if", "type", "(", "gts", ")", "!=", "list", ":", "\n", "            ", "gts", "=", "[", "gts", "]", "# allow using single ground truth as input", "\n", "", "master_ctables", "=", "[", "merge_contingency_table", "(", "self", ".", "get_segmentation", "(", ")", ",", "gt", ")", "\n", "for", "gt", "in", "gts", "]", "\n", "alldata", "=", "[", "]", "\n", "data", "=", "[", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "]", "\n", "for", "num_epochs", "in", "range", "(", "max_num_epochs", ")", ":", "\n", "            ", "ctables", "=", "deepcopy", "(", "master_ctables", ")", "\n", "if", "len", "(", "data", "[", "0", "]", ")", ">", "min_num_samples", "and", "num_epochs", ">=", "min_num_epochs", ":", "\n", "                ", "break", "\n", "", "if", "learn_flat", "and", "num_epochs", "==", "0", ":", "\n", "                ", "alldata", ".", "append", "(", "self", ".", "learn_flat", "(", "gts", ",", "feature_map", ")", ")", "\n", "data", "=", "unique_learning_data_elements", "(", "alldata", ")", "if", "memory", "else", "alldata", "[", "-", "1", "]", "\n", "continue", "\n", "", "g", "=", "self", ".", "copy", "(", ")", "\n", "if", "priority_mode", "==", "'mean'", ":", "\n", "                ", "g", ".", "merge_priority_function", "=", "boundary_mean", "\n", "", "elif", "num_epochs", ">", "0", "and", "priority_mode", "==", "'active'", "or", "num_epochs", "%", "2", "==", "1", "and", "priority_mode", "==", "'mixed'", ":", "\n", "                ", "cl", "=", "get_classifier", "(", "classifier", ",", "random_state", "=", "random_state", ")", "\n", "feat", ",", "lab", "=", "classify", ".", "sample_training_data", "(", "\n", "data", "[", "0", "]", ",", "data", "[", "1", "]", "[", ":", ",", "label_type_keys", "[", "labeling_mode", "]", "]", ",", "\n", "max_num_samples", ")", "\n", "cl", "=", "cl", ".", "fit", "(", "feat", ",", "lab", ")", "\n", "g", ".", "merge_priority_function", "=", "active_function", "(", "feature_map", ",", "cl", ")", "\n", "", "elif", "priority_mode", "==", "'random'", "or", "(", "priority_mode", "==", "'active'", "and", "num_epochs", "==", "0", ")", ":", "\n", "                ", "g", ".", "merge_priority_function", "=", "random_priority", "\n", "", "elif", "priority_mode", "==", "'custom'", ":", "\n", "                ", "g", ".", "merge_priority_function", "=", "mpf", "\n", "", "g", ".", "show_progress", "=", "False", "# bug in MergeQueue usage causes", "\n", "# progressbar crash.", "\n", "g", ".", "rebuild_merge_queue", "(", ")", "\n", "alldata", ".", "append", "(", "g", ".", "learn_epoch", "(", "ctables", ",", "feature_map", ",", "\n", "learning_mode", "=", "learning_mode", ",", "\n", "labeling_mode", "=", "labeling_mode", ")", ")", "\n", "if", "memory", ":", "\n", "                ", "if", "unique", ":", "\n", "                    ", "data", "=", "unique_learning_data_elements", "(", "alldata", ")", "\n", "", "else", ":", "\n", "                    ", "data", "=", "concatenate_data_elements", "(", "alldata", ")", "\n", "", "", "else", ":", "\n", "                ", "data", "=", "alldata", "[", "-", "1", "]", "\n", "", "logging", ".", "debug", "(", "'data size %d at epoch %d'", "%", "(", "len", "(", "data", "[", "0", "]", ")", ",", "num_epochs", ")", ")", "\n", "", "return", "data", ",", "alldata", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_flat": [[1273, 1310], ["list", "type", "evaluate.merge_contingency_table", "evaluate.assignment_table", "map", "agglo.Rag.get_segmentation", "zip", "agglo.Rag.learn_edge", "agglo.Rag.real_edges"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.merge_contingency_table", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.assignment_table", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_edge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.real_edges"], ["", "def", "learn_flat", "(", "self", ",", "gts", ",", "feature_map", ")", ":", "\n", "        ", "\"\"\"Learn all edges on the graph, but don't agglomerate.\n\n        Parameters\n        ----------\n        gts : array of int or list thereof\n            The ground truth volume(s) corresponding to the current\n            probability map.\n        feature_map : function (Rag, node, node) -> array of float\n            The map from node pairs to a feature vector. This must\n            consist either of uncached features or of the cache used\n            when building the graph.\n\n        Returns\n        -------\n        data : list of array\n            Four arrays containing:\n                - the feature vectors, shape ``(n_samples, n_features)``.\n                - the labels, shape ``(n_samples, 3)``. A value of `-1`\n                  means \"should merge\", while `1` means \"should\n                  not merge\". The columns correspond to the three\n                  labeling methods: assignment, VI sign, or RI sign.\n                - the VI and RI change of each merge, ``(n_edges, 2)``.\n                - the list of merged edges ``(n_edges, 2)``.\n\n        See Also\n        --------\n        learn_agglomerate\n        \"\"\"", "\n", "if", "type", "(", "gts", ")", "!=", "list", ":", "\n", "            ", "gts", "=", "[", "gts", "]", "# allow using single ground truth as input", "\n", "", "ctables", "=", "[", "merge_contingency_table", "(", "self", ".", "get_segmentation", "(", ")", ",", "gt", ")", "\n", "for", "gt", "in", "gts", "]", "\n", "assignments", "=", "[", "ev", ".", "assignment_table", "(", "ct", ")", "for", "ct", "in", "ctables", "]", "\n", "return", "list", "(", "map", "(", "array", ",", "zip", "(", "*", "[", "\n", "self", ".", "learn_edge", "(", "e", ",", "ctables", ",", "assignments", ",", "feature_map", ")", "\n", "for", "e", "in", "self", ".", "real_edges", "(", ")", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_edge": [[1312, 1366], ["feature_map().ravel", "agglo.compute_local_vi_change", "agglo.compute_local_rand_change", "numpy.sign", "any", "any", "logging.debug", "feature_map", "agglo.compute_true_delta_vi", "numpy.mean", "map", "numpy.all", "agglo.compute_true_delta_rand", "numpy.isnan", "map", "evaluate.nzcol", "evaluate.nzcol"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_local_vi_change", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_local_rand_change", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_true_delta_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_true_delta_rand", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.nzcol", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.nzcol"], ["", "def", "learn_edge", "(", "self", ",", "edge", ",", "ctables", ",", "assignments", ",", "feature_map", ")", ":", "\n", "        ", "\"\"\"Determine whether an edge should be merged based on ground truth.\n\n        Parameters\n        ----------\n        edge : (int, int) tuple\n            An edge in the graph.\n        ctables : list of array\n            A list of contingency tables determining overlap between the\n            current segmentation and the ground truth.\n        assignments : list of array\n            Similar to the contingency tables, but each row is thresholded\n            so each segment corresponds to exactly one ground truth segment.\n        feature_map : function (Rag, node, node) -> array of float\n            The map from node pairs to a feature vector.\n\n        Returns\n        -------\n        features : 1D array of float\n            The feature vector for that edge.\n        labels : 1D array of float, length 3\n            The labels determining whether the edge should be merged.\n            A value of `-1` means \"should merge\", while `1` means \"should\n            not merge\". The columns correspond to the three labeling\n            methods: assignment, VI sign, or RI sign.\n        weights : 1D array of float, length 2\n            The VI and RI change of the merge.\n        nodes : tuple of int\n            The given edge.\n        \"\"\"", "\n", "n1", ",", "n2", "=", "edge", "\n", "features", "=", "feature_map", "(", "self", ",", "n1", ",", "n2", ")", ".", "ravel", "(", ")", "\n", "# Calculate weights for weighting data points", "\n", "s1", ",", "s2", "=", "[", "self", ".", "nodes", "[", "n", "]", "[", "'size'", "]", "for", "n", "in", "[", "n1", ",", "n2", "]", "]", "\n", "weights", "=", "compute_local_vi_change", "(", "s1", ",", "s2", ",", "self", ".", "volume_size", ")", ",", "compute_local_rand_change", "(", "s1", ",", "s2", ",", "self", ".", "volume_size", ")", "\n", "# Get the fraction of times that n1 and n2 assigned to", "\n", "# same segment in the ground truths", "\n", "cont_labels", "=", "[", "\n", "[", "(", "-", "1", ")", "**", "(", "np", ".", "all", "(", "ev", ".", "nzcol", "(", "a", ",", "n1", ")", "==", "ev", ".", "nzcol", "(", "a", ",", "n2", ")", ")", ")", "\n", "for", "a", "in", "assignments", "]", ",", "\n", "[", "compute_true_delta_vi", "(", "ctable", ",", "n1", ",", "n2", ")", "for", "ctable", "in", "ctables", "]", ",", "\n", "[", "-", "compute_true_delta_rand", "(", "ctable", ",", "n1", ",", "n2", ",", "self", ".", "volume_size", ")", "\n", "for", "ctable", "in", "ctables", "]", "\n", "]", "\n", "labels", "=", "[", "np", ".", "sign", "(", "mean", "(", "cont_label", ")", ")", "for", "cont_label", "in", "cont_labels", "]", "\n", "if", "any", "(", "map", "(", "isnan", ",", "labels", ")", ")", "or", "any", "(", "[", "label", "==", "0", "for", "label", "in", "labels", "]", ")", ":", "\n", "            ", "logging", ".", "debug", "(", "'NaN or 0 labels found. '", "+", "\n", "' '", ".", "join", "(", "map", "(", "str", ",", "[", "labels", ",", "(", "n1", ",", "n2", ")", "]", ")", ")", ")", "\n", "", "labels", "=", "[", "1", "if", "i", "==", "0", "or", "isnan", "(", "i", ")", "or", "n1", "in", "self", ".", "frozen_nodes", "or", "\n", "n2", "in", "self", ".", "frozen_nodes", "or", "(", "n1", ",", "n2", ")", "in", "self", ".", "frozen_edges", "else", "\n", "i", "for", "i", "in", "labels", "]", "\n", "return", "features", ",", "labels", ",", "weights", ",", "(", "n1", ",", "n2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_epoch": [[1368, 1424], ["list", "evaluate.csrRowExpandableCSR", "len", "agglo.Rag.merge_queue.pop", "agglo.Rag.learn_edge", "data.append", "map", "map", "agglo.Rag.merge_nodes", "zip", "zip", "ctable[].max"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.pop", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_edge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes"], ["", "def", "learn_epoch", "(", "self", ",", "ctables", ",", "feature_map", ",", "\n", "learning_mode", "=", "'permissive'", ",", "labeling_mode", "=", "'assignment'", ")", ":", "\n", "        ", "\"\"\"Learn the agglomeration process using various strategies.\n\n        Parameters\n        ----------\n        ctables : array of float or list thereof\n            One or more contingency tables between own segments and gold\n            standard segmentations\n        feature_map : function (Rag, node, node) -> array of float\n            The map from node pairs to a feature vector. This must\n            consist either of uncached features or of the cache used\n            when building the graph.\n        learning_mode : {'strict', 'permissive'}, optional\n            If ``'strict'``, don't proceed with a merge when it goes against\n            the ground truth. For historical reasons, 'loose' is allowed as\n            a synonym for 'strict'.\n        labeling_mode : {'assignment', 'vi-sign', 'rand-sign'}, optional\n            Which label to use for `learning_mode`. Note that all labels\n            are saved in the end.\n\n        Returns\n        -------\n        data : list of array\n            Four arrays containing:\n                - the feature vectors, shape ``(n_samples, n_features)``.\n                - the labels, shape ``(n_samples, 3)``. A value of `-1`\n                  means \"should merge\", while `1` means \"should\n                  not merge\". The columns correspond to the three\n                  labeling methods: assignment, VI sign, or RI sign.\n                - the VI and RI change of each merge, ``(n_edges, 2)``.\n                - the list of merged edges ``(n_edges, 2)``.\n        \"\"\"", "\n", "label_type_keys", "=", "{", "'assignment'", ":", "0", ",", "'vi-sign'", ":", "1", ",", "'rand-sign'", ":", "2", "}", "\n", "assignments", "=", "[", "ev", ".", "csrRowExpandableCSR", "(", "asst", ")", "\n", "for", "asst", "in", "map", "(", "ev", ".", "assignment_table", ",", "ctables", ")", "]", "\n", "g", "=", "self", "\n", "data", "=", "[", "]", "\n", "while", "len", "(", "g", ".", "merge_queue", ")", ">", "0", ":", "\n", "            ", "merge_priority", ",", "_", ",", "n1", ",", "n2", "=", "g", ".", "merge_queue", ".", "pop", "(", ")", "\n", "if", "g", ".", "boundary_body", "in", "(", "n1", ",", "n2", ")", ":", "\n", "                ", "continue", "\n", "", "dat", "=", "g", ".", "learn_edge", "(", "(", "n1", ",", "n2", ")", ",", "ctables", ",", "assignments", ",", "feature_map", ")", "\n", "data", ".", "append", "(", "dat", ")", "\n", "label", "=", "dat", "[", "1", "]", "[", "label_type_keys", "[", "labeling_mode", "]", "]", "\n", "if", "learning_mode", "!=", "'strict'", "or", "label", "<", "0", ":", "\n", "                ", "node_id", "=", "g", ".", "merge_nodes", "(", "n1", ",", "n2", ",", "merge_priority", ")", "\n", "for", "ctable", ",", "assignment", "in", "zip", "(", "ctables", ",", "assignments", ")", ":", "\n", "                    ", "ctable", "[", "node_id", "]", "=", "ctable", "[", "n1", "]", "+", "ctable", "[", "n2", "]", "\n", "ctable", "[", "n1", "]", "=", "0", "\n", "ctable", "[", "n2", "]", "=", "0", "\n", "assignment", "[", "node_id", "]", "=", "(", "ctable", "[", "node_id", "]", "==", "\n", "ctable", "[", "node_id", "]", ".", "max", "(", ")", ")", "\n", "assignment", "[", "n1", "]", "=", "0", "\n", "assignment", "[", "n2", "]", "=", "0", "\n", "", "", "", "return", "list", "(", "map", "(", "array", ",", "zip", "(", "*", "data", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.replay_merge_history": [[1426, 1469], ["itertools.count", "agglo.conditional_countdown", "zip", "itertools.repeat", "itertools.repeat", "next", "agglo.Rag.merge_nodes"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.conditional_countdown", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes"], ["", "def", "replay_merge_history", "(", "self", ",", "merge_seq", ",", "labels", "=", "None", ",", "num_errors", "=", "1", ")", ":", "\n", "        ", "\"\"\"Agglomerate according to a merge sequence, optionally labeled.\n\n        Parameters\n        ----------\n        merge_seq : iterable of pair of int\n            The sequence of node IDs to be merged.\n        labels : iterable of int in {-1, 0, 1}, optional\n            A sequence matching `merge_seq` specifying whether a merge\n            should take place or not. -1 or 0 mean \"should merge\", 1\n            otherwise.\n\n        Returns\n        -------\n        n : int\n            Number of elements consumed from `merge_seq`\n        e : (int, int)\n            Last merge pair observed.\n\n        Notes\n        -----\n        The merge sequence and labels *must* be generators if you don't want\n        to manually keep track of how much has been consumed. The merging\n        continues until `num_errors` false merges have been encountered, or\n        until the sequence is fully consumed.\n        \"\"\"", "\n", "if", "labels", "is", "None", ":", "\n", "            ", "labels1", "=", "it", ".", "repeat", "(", "False", ")", "\n", "labels2", "=", "it", ".", "repeat", "(", "False", ")", "\n", "", "else", ":", "\n", "            ", "labels1", "=", "(", "label", ">", "0", "for", "label", "in", "labels", ")", "\n", "labels2", "=", "(", "label", ">", "0", "for", "label", "in", "labels", ")", "\n", "", "counter", "=", "it", ".", "count", "(", ")", "\n", "errors_remaining", "=", "conditional_countdown", "(", "labels2", ",", "num_errors", ")", "\n", "nodes", "=", "None", "\n", "for", "nodes", ",", "label", ",", "errs", ",", "count", "in", "zip", "(", "merge_seq", ",", "labels1", ",", "errors_remaining", ",", "counter", ")", ":", "\n", "            ", "n1", ",", "n2", "=", "nodes", "\n", "if", "not", "label", ":", "\n", "                ", "self", ".", "merge_nodes", "(", "n1", ",", "n2", ")", "\n", "", "elif", "errs", "==", "0", ":", "\n", "                ", "break", "\n", "", "", "return", "next", "(", "counter", ")", ",", "nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rename_node": [[1471, 1492], ["agglo.Rag.add_node", "agglo.Rag.add_edges_from", "agglo.Rag.neighbors", "agglo.Rag.remove_node", "agglo.Rag.edges[].get", "agglo.Rag.neighbors"], "methods", ["None"], ["", "def", "rename_node", "(", "self", ",", "old", ",", "new", ")", ":", "\n", "        ", "\"\"\"Rename node `old` to `new`, updating edges and weights.\n\n        Parameters\n        ----------\n        old : int\n            The node being renamed.\n        new : int\n            The new node id.\n        \"\"\"", "\n", "self", ".", "add_node", "(", "new", ",", "**", "self", ".", "nodes", "[", "old", "]", ")", "\n", "self", ".", "add_edges_from", "(", "\n", "[", "(", "new", ",", "v", ",", "self", ".", "edges", "[", "old", ",", "v", "]", ")", "for", "v", "in", "self", ".", "neighbors", "(", "old", ")", "]", ")", "\n", "for", "v", "in", "self", ".", "neighbors", "(", "new", ")", ":", "\n", "            ", "qitem", "=", "self", ".", "edges", "[", "new", ",", "v", "]", ".", "get", "(", "'qlink'", ",", "None", ")", "\n", "if", "qitem", "is", "not", "None", ":", "\n", "                ", "if", "qitem", "[", "2", "]", "==", "old", ":", "\n", "                    ", "qitem", "[", "2", "]", "=", "new", "\n", "", "else", ":", "\n", "                    ", "qitem", "[", "3", "]", "=", "new", "\n", "", "", "", "self", ".", "remove_node", "(", "old", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes": [[1494, 1556], ["agglo.Rag.edges[].get", "[].update", "agglo.Rag.feature_manager.update_node_cache", "list", "list", "numpy.intersect1d", "numpy.setdiff1d", "agglo.Rag.update_merge_queue", "agglo.Rag.tree.merge", "agglo.Rag.remove_node", "agglo.Rag.rename_node", "len", "[].update", "agglo.Rag.neighbors", "agglo.Rag.neighbors", "numpy.array", "numpy.array", "agglo.Rag.merge_edge_properties", "edges_to_update.append", "numpy.concatenate", "agglo.Rag.move_edge", "agglo.Rag.merge_queue.invalidate", "edges_to_update.append"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.update", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.update_node_cache", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.update_merge_queue", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rename_node", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.update", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_edge_properties", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.move_edge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.invalidate"], ["", "def", "merge_nodes", "(", "self", ",", "n1", ",", "n2", ",", "merge_priority", "=", "0.0", ")", ":", "\n", "        ", "\"\"\"Merge two nodes, while updating the necessary edges.\n\n        Parameters\n        ----------\n        n1, n2 : int\n            Nodes determining the edge for which to update the UCM.\n        merge_priority : float, optional\n            The merge priority of the merge.\n\n        Returns\n        -------\n        node_id : int\n            The id of the node resulting from the merge.\n\n        Notes\n        -----\n        Additionally, the RIG (region intersection graph), the\n        contingency matrix to the ground truth (if provided) is\n        updated.\n        \"\"\"", "\n", "if", "len", "(", "self", ".", "nodes", "[", "n1", "]", "[", "'exclusions'", "]", "\n", "&", "self", ".", "nodes", "[", "n2", "]", "[", "'exclusions'", "]", ")", ">", "0", ":", "\n", "            ", "return", "\n", "", "else", ":", "\n", "            ", "self", ".", "nodes", "[", "n1", "]", "[", "'exclusions'", "]", ".", "update", "(", "self", ".", "nodes", "[", "n2", "]", "[", "'exclusions'", "]", ")", "\n", "", "w", "=", "self", ".", "edges", "[", "n1", ",", "n2", "]", ".", "get", "(", "'weight'", ",", "merge_priority", ")", "\n", "self", ".", "nodes", "[", "n1", "]", "[", "'size'", "]", "+=", "self", ".", "nodes", "[", "n2", "]", "[", "'size'", "]", "\n", "self", ".", "nodes", "[", "n1", "]", "[", "'fragments'", "]", ".", "update", "(", "self", ".", "nodes", "[", "n2", "]", "[", "'fragments'", "]", ")", "\n", "\n", "self", ".", "feature_manager", ".", "update_node_cache", "(", "self", ",", "n1", ",", "n2", ",", "\n", "self", ".", "nodes", "[", "n1", "]", "[", "'feature-cache'", "]", ",", "self", ".", "nodes", "[", "n2", "]", "[", "'feature-cache'", "]", ")", "\n", "nn1", "=", "list", "(", "self", ".", "neighbors", "(", "n1", ")", ")", "\n", "nn2", "=", "list", "(", "self", ".", "neighbors", "(", "n2", ")", ")", "\n", "common_neighbors", "=", "np", ".", "intersect1d", "(", "\n", "np", ".", "array", "(", "nn1", ")", ",", "np", ".", "array", "(", "nn2", ")", ",", "assume_unique", "=", "True", "\n", ")", "\n", "edges_to_update", "=", "[", "]", "\n", "for", "n", "in", "common_neighbors", ":", "\n", "            ", "self", ".", "merge_edge_properties", "(", "(", "n2", ",", "n", ")", ",", "(", "n1", ",", "n", ")", ")", "\n", "edges_to_update", ".", "append", "(", "(", "n1", ",", "n", ")", ")", "\n", "", "new_neighbors", "=", "np", ".", "setdiff1d", "(", "\n", "nn2", ",", "\n", "np", ".", "concatenate", "(", "(", "common_neighbors", ",", "[", "n1", "]", ")", ")", ",", "\n", "assume_unique", "=", "True", ",", "\n", ")", "\n", "for", "n", "in", "new_neighbors", ":", "\n", "            ", "self", ".", "move_edge", "(", "(", "n2", ",", "n", ")", ",", "(", "n1", ",", "n", ")", ")", "\n", "if", "self", ".", "update_unchanged_edges", ":", "\n", "                ", "edges_to_update", ".", "append", "(", "(", "n1", ",", "n", ")", ")", "\n", "", "", "try", ":", "\n", "            ", "self", ".", "merge_queue", ".", "invalidate", "(", "self", ".", "edges", "[", "n1", ",", "n2", "]", "[", "'qlink'", "]", ")", "\n", "", "except", "KeyError", ":", "# no edge or no queue link", "\n", "            ", "pass", "\n", "", "self", ".", "update_merge_queue", "(", "edges_to_update", ")", "\n", "node_id", "=", "self", ".", "tree", ".", "merge", "(", "n1", ",", "n2", ",", "w", ")", "\n", "self", ".", "remove_node", "(", "n2", ")", "\n", "self", ".", "rename_node", "(", "n1", ",", "node_id", ")", "\n", "self", ".", "rig", "[", "node_id", "]", "=", "self", ".", "rig", "[", "n1", "]", "+", "self", ".", "rig", "[", "n2", "]", "\n", "self", ".", "rig", "[", "n1", "]", "=", "0", "\n", "self", ".", "rig", "[", "n2", "]", "=", "0", "\n", "return", "node_id", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_subgraph": [[1557, 1580], ["type", "agglo.Rag.subgraph", "len", "agglo.Rag.subgraph", "list", "list", "list", "networkx.algorithms.traversal.depth_first_search.dfs_preorder_nodes", "agglo.Rag.merge_nodes", "networkx.connected_components"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes"], ["", "def", "merge_subgraph", "(", "self", ",", "subgraph", "=", "None", ",", "source", "=", "None", ")", ":", "\n", "        ", "\"\"\"Merge a (typically) connected set of nodes together.\n\n        Parameters\n        ----------\n        subgraph : agglo.Rag, networkx.Graph, or list of int (node id)\n            A subgraph to merge.\n        source : int (node id), optional\n            Merge the subgraph to this node.\n        \"\"\"", "\n", "if", "type", "(", "subgraph", ")", "not", "in", "[", "Rag", ",", "Graph", "]", ":", "# input is node list", "\n", "            ", "subgraph", "=", "self", ".", "subgraph", "(", "subgraph", ")", "\n", "", "if", "len", "(", "subgraph", ")", "==", "0", ":", "\n", "            ", "return", "\n", "", "for", "subsubgraph", "in", "(", "\n", "self", ".", "subgraph", "(", "list", "(", "c", ")", ")", "\n", "for", "c", "in", "list", "(", "nx", ".", "connected_components", "(", "subgraph", ")", ")", "\n", ")", ":", "\n", "            ", "node_dfs", "=", "list", "(", "dfs_preorder_nodes", "(", "subsubgraph", ",", "source", ")", ")", "\n", "# dfs_preorder_nodes returns iter, convert to list", "\n", "source_node", ",", "other_nodes", "=", "node_dfs", "[", "0", "]", ",", "node_dfs", "[", "1", ":", "]", "\n", "for", "current_node", "in", "other_nodes", ":", "\n", "                ", "source_node", "=", "self", ".", "merge_nodes", "(", "source_node", ",", "current_node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_node": [[1581, 1605], ["agglo.Rag.extent", "numpy.unique", "agglo.Rag.remove_node", "agglo.Rag.build_graph_from_watershed", "agglo.Rag.ncut"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.extent", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_graph_from_watershed", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.ncut"], ["", "", "", "def", "split_node", "(", "self", ",", "u", ",", "n", "=", "2", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Use normalized cuts [1] to split a node/segment.\n\n        Parameters\n        ----------\n        u : int (node id)\n            Which node to split.\n        n : int, optional\n            How many segments to split it into.\n\n        Returns\n        -------\n        None\n\n        References\n        ----------\n        .. [1] Shi, J., and Malik, J. (2000). Normalized cuts and image\n               segmentation. Pattern Analysis and Machine Intelligence.\n        \"\"\"", "\n", "node_extent", "=", "self", ".", "extent", "(", "u", ")", "\n", "labels", "=", "unique", "(", "self", ".", "watershed_r", "[", "node_extent", "]", ")", "\n", "self", ".", "remove_node", "(", "u", ")", "\n", "self", ".", "build_graph_from_watershed", "(", "idxs", "=", "node_extent", ")", "\n", "self", ".", "ncut", "(", "num_clusters", "=", "n", ",", "nodes", "=", "labels", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.separate_fragments": [[1606, 1633], ["viridis.tree.lowest_common_ancestor", "agglo.Rag.tree.children", "agglo.Rag.delete_merge", "agglo.Rag.tree.highest_ancestor", "agglo.Rag.tree.highest_ancestor"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.delete_merge"], ["", "def", "separate_fragments", "(", "self", ",", "f0", ",", "f1", ")", ":", "\n", "        ", "\"\"\"Ensure fragments (watersheds) f0 and f1 are in different nodes.\n\n        If f0 and f1 are the same segment, split that segment at the\n        lowest common ancestor of f0 and f1 in the merge tree, then add an\n        exclusion. Otherwise, simply add an exclusion.\n\n        Parameters\n        ----------\n        f0, f1 : int\n            The fragments to be separated.\n\n        Returns\n        -------\n        s0, s1 : int\n            The separated segments resulting from the break. If the\n            fragments were already in separate segments, return the\n            highest ancestor of each fragment on the merge tree.\n        \"\"\"", "\n", "lca", "=", "tree", ".", "lowest_common_ancestor", "(", "self", ".", "tree", ",", "f0", ",", "f1", ")", "\n", "if", "lca", "is", "not", "None", ":", "\n", "            ", "s0", ",", "s1", "=", "self", ".", "tree", ".", "children", "(", "lca", ")", "\n", "self", ".", "delete_merge", "(", "lca", ")", "\n", "", "else", ":", "\n", "            ", "s0", "=", "self", ".", "tree", ".", "highest_ancestor", "(", "f0", ")", "\n", "s1", "=", "self", ".", "tree", ".", "highest_ancestor", "(", "f1", ")", "\n", "", "return", "s0", ",", "s1", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.delete_merge": [[1634, 1651], ["agglo.Rag.tree.highest_ancestor", "agglo.Rag.tree.remove_node", "agglo.Rag.tree.leaves", "[].difference_update"], "methods", ["None"], ["", "def", "delete_merge", "(", "self", ",", "tree_node", ")", ":", "\n", "        ", "\"\"\"Delete the merge represented by `tree_node`.\n\n        Parameters\n        ----------\n        tree_node : int\n            A node that may not be currently in the graph, but was at\n            some point in its history.\n        \"\"\"", "\n", "highest", "=", "self", ".", "tree", ".", "highest_ancestor", "(", "tree_node", ")", "\n", "if", "highest", "!=", "tree_node", ":", "\n", "            ", "leaves", "=", "self", ".", "tree", ".", "leaves", "(", "tree_node", ")", "\n", "# the graph doesn't keep nodes in the history, only the", "\n", "# most recent nodes. So, we only need to find that one and", "\n", "# update its fragment list.", "\n", "self", ".", "nodes", "[", "highest", "]", "[", "'fragments'", "]", ".", "difference_update", "(", "leaves", ")", "\n", "", "self", ".", "tree", ".", "remove_node", "(", "tree_node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.move_edge": [[1652, 1666], ["agglo.Rag.add_edge"], "methods", ["None"], ["", "def", "move_edge", "(", "self", ",", "src", ",", "dst", ")", ":", "\n", "        ", "\"\"\"Move edge `src` to `dst`. If `dst` exists it is clobbered.\n\n        Parameters\n        ----------\n        src, dst : (int, int)\n            The edges being merged.\n        \"\"\"", "\n", "u", ",", "v", "=", "dst", "\n", "w", ",", "x", "=", "src", "\n", "self", ".", "add_edge", "(", "u", ",", "v", ",", "**", "self", ".", "edges", "[", "w", ",", "x", "]", ")", "\n", "if", "'qlink'", "in", "self", ".", "edges", "[", "u", ",", "v", "]", ":", "\n", "            ", "qelem", "=", "self", ".", "edges", "[", "u", ",", "v", "]", "[", "'qlink'", "]", "\n", "qelem", "[", "2", ":", "]", "=", "u", ",", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_edge_properties": [[1667, 1703], ["agglo.Rag.has_edge", "agglo.Rag.add_edge", "agglo.Rag.feature_manager.update_edge_cache", "agglo.Rag.merge_queue.invalidate", "[].update", "[].extend"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.update_edge_cache", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.invalidate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.update"], ["", "", "def", "merge_edge_properties", "(", "self", ",", "src", ",", "dst", ")", ":", "\n", "        ", "\"\"\"Merge the properties of edge src into edge dst.\n\n        Parameters\n        ----------\n        src, dst : (int, int)\n            Edges being merged.\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "u", ",", "v", "=", "dst", "\n", "w", ",", "x", "=", "src", "\n", "if", "not", "self", ".", "has_edge", "(", "u", ",", "v", ")", ":", "\n", "            ", "self", ".", "add_edge", "(", "u", ",", "v", ",", "**", "self", ".", "edges", "[", "w", ",", "x", "]", ")", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "fast_edges", ":", "\n", "                ", "self", ".", "edges", "[", "u", ",", "v", "]", "[", "'boundary-ids'", "]", ".", "update", "(", "\n", "self", ".", "edges", "[", "w", ",", "x", "]", "[", "'boundary-ids'", "]", "\n", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "edges", "[", "u", ",", "v", "]", "[", "'boundary'", "]", ".", "extend", "(", "\n", "self", ".", "edges", "[", "w", ",", "x", "]", "[", "'boundary'", "]", "\n", ")", "\n", "", "self", ".", "feature_manager", ".", "update_edge_cache", "(", "\n", "self", ",", "\n", "(", "u", ",", "v", ")", ",", "\n", "(", "w", ",", "x", ")", ",", "\n", "self", ".", "edges", "[", "u", ",", "v", "]", "[", "'feature-cache'", "]", ",", "\n", "self", ".", "edges", "[", "w", ",", "x", "]", "[", "'feature-cache'", "]", ",", "\n", ")", "\n", "", "try", ":", "\n", "            ", "self", ".", "merge_queue", ".", "invalidate", "(", "self", ".", "edges", "[", "w", ",", "x", "]", "[", "'qlink'", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.update_merge_queue": [[1705, 1727], ["agglo.Rag.merge_priority_function", "zip", "agglo.Rag.merge_queue.push", "agglo.Rag.merge_queue.invalidate"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.push", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.invalidate"], ["", "", "def", "update_merge_queue", "(", "self", ",", "edges", ")", ":", "\n", "        ", "\"\"\"Update the merge queue item for edge (u, v). Add new by default.\n\n        Parameters\n        ----------\n        u, v : int (node id)\n            Edge being updated.\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "edges", "=", "[", "e", "for", "e", "in", "edges", "if", "self", ".", "boundary_body", "not", "in", "e", "]", "\n", "if", "not", "self", ".", "merge_queue", ".", "is_null_queue", "and", "edges", ":", "\n", "            ", "weights", "=", "self", ".", "merge_priority_function", "(", "self", ",", "edges", ")", "\n", "for", "w", ",", "(", "u", ",", "v", ")", "in", "zip", "(", "weights", ",", "edges", ")", ":", "\n", "                ", "if", "'qlink'", "in", "self", ".", "edges", "[", "u", ",", "v", "]", ":", "\n", "                    ", "self", ".", "merge_queue", ".", "invalidate", "(", "self", ".", "edges", "[", "u", ",", "v", "]", "[", "'qlink'", "]", ")", "\n", "", "new_qitem", "=", "[", "w", ",", "True", ",", "u", ",", "v", "]", "\n", "self", ".", "edges", "[", "u", ",", "v", "]", "[", "'qlink'", "]", "=", "new_qitem", "\n", "self", ".", "edges", "[", "u", ",", "v", "]", "[", "'weight'", "]", "=", "w", "\n", "self", ".", "merge_queue", ".", "push", "(", "new_qitem", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation": [[1729, 1764], ["agglo.Rag.tree.get_map", "morpho.juicy_center", "morpho.remove_merged_boundaries", "agglo.Rag.agglomerate"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.remove_merged_boundaries", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate"], ["", "", "", "def", "get_segmentation", "(", "self", ",", "threshold", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the unpadded segmentation represented by the graph.\n\n        Remember that the segmentation volume is padded with an\n        \"artificial\" segment that envelops the volume. This function\n        simply removes the wrapping and returns a segmented volume.\n\n        Parameters\n        ----------\n        threshold : float, optional\n            Get the segmentation at the given threshold. If no\n            threshold is given, return the segmentation at the current\n            level of agglomeration.\n\n        Returns\n        -------\n        seg : array of int\n            The segmentation of the volume presently represented by the\n            graph.\n        \"\"\"", "\n", "if", "threshold", "is", "None", ":", "\n", "# a threshold of np.inf is the same as no threshold on the", "\n", "# tree when getting the map (see below). Thus, using a", "\n", "# threshold of `None` (the default), we get the segmentation", "\n", "# implied by the current merge tree.", "\n", "            ", "threshold", "=", "np", ".", "inf", "\n", "", "elif", "threshold", ">", "self", ".", "max_merge_score", ":", "\n", "# If a higher threshold is required than has been merged, we", "\n", "# continue the agglomeration until that threshold is hit.", "\n", "            ", "self", ".", "agglomerate", "(", "threshold", ")", "\n", "", "m", "=", "self", ".", "tree", ".", "get_map", "(", "threshold", ")", "\n", "seg", "=", "m", "[", "self", ".", "watershed", "]", "\n", "if", "self", ".", "pad_thickness", ">", "1", ":", "# volume has zero-boundaries", "\n", "            ", "seg", "=", "morpho", ".", "remove_merged_boundaries", "(", "seg", ",", "self", ".", "connectivity", ")", "\n", "", "return", "morpho", ".", "juicy_center", "(", "seg", ",", "self", ".", "pad_thickness", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_volume": [[1766, 1793], ["numpy.zeros_like", "numpy.zeros_like.ravel", "morpho.juicy_center", "agglo.Rag.nodes", "agglo.Rag.extent"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.extent"], ["", "def", "build_volume", "(", "self", ",", "nbunch", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return the segmentation induced by the graph.\n\n        Parameters\n        ----------\n        nbunch : iterable of int (node id), optional\n            A list of nodes for which to build the volume. All nodes\n            are used if this is not provided.\n\n        Returns\n        -------\n        seg : array of int\n            The segmentation implied by the graph.\n\n        Notes\n        -----\n        This function is very similar to ``get_segmentation``, but it\n        builds the segmentation from the bottom up, rather than using\n        the currently-stored segmentation.\n        \"\"\"", "\n", "v", "=", "zeros_like", "(", "self", ".", "watershed", ")", "\n", "vr", "=", "v", ".", "ravel", "(", ")", "\n", "if", "nbunch", "is", "None", ":", "\n", "            ", "nbunch", "=", "self", ".", "nodes", "(", ")", "\n", "", "for", "n", "in", "nbunch", ":", "\n", "            ", "vr", "[", "self", ".", "extent", "(", "n", ")", "]", "=", "n", "\n", "", "return", "morpho", ".", "juicy_center", "(", "v", ",", "self", ".", "pad_thickness", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.build_boundary_map": [[1795, 1824], ["numpy.zeros", "numpy.zeros.ravel", "sorted", "hasattr", "morpho.juicy_center", "len", "agglo.Rag.rebuild_merge_queue", "agglo.Rag.real_edges_iter", "agglo.Rag.boundary"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.juicy_center", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rebuild_merge_queue", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.real_edges_iter", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "build_boundary_map", "(", "self", ",", "ebunch", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return a map of the current merge priority.\n\n        Parameters\n        ----------\n        ebunch : iterable of (int, int), optional\n            The list of edges for which to build a map. Use all edges\n            if not provided.\n\n        Returns\n        -------\n        bm : array of float\n            The image of the edge weights.\n        \"\"\"", "\n", "if", "len", "(", "self", ".", "merge_queue", ")", "==", "0", ":", "\n", "            ", "self", ".", "rebuild_merge_queue", "(", ")", "\n", "", "m", "=", "zeros", "(", "self", ".", "watershed", ".", "shape", ",", "'float'", ")", "\n", "mr", "=", "m", ".", "ravel", "(", ")", "\n", "if", "ebunch", "is", "None", ":", "\n", "            ", "ebunch", "=", "self", ".", "real_edges_iter", "(", ")", "\n", "", "ebunch", "=", "sorted", "(", "\n", "[", "(", "self", ".", "edges", "[", "u", ",", "v", "]", "[", "'weight'", "]", ",", "u", ",", "v", ")", "for", "u", ",", "v", "in", "ebunch", "]", "\n", ")", "\n", "for", "w", ",", "u", ",", "v", "in", "ebunch", ":", "\n", "            ", "b", "=", "self", ".", "boundary", "(", "u", ",", "v", ")", "\n", "mr", "[", "b", "]", "=", "w", "\n", "", "if", "hasattr", "(", "self", ",", "'ignored_boundary'", ")", ":", "\n", "            ", "m", "[", "self", ".", "ignored_boundary", "]", "=", "inf", "\n", "", "return", "morpho", ".", "juicy_center", "(", "m", ",", "self", ".", "pad_thickness", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.remove_obvious_inclusions": [[1826, 1831], ["agglo.Rag.nodes", "agglo.Rag.degree", "agglo.Rag.merge_nodes", "agglo.Rag.neighbors"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes"], ["", "def", "remove_obvious_inclusions", "(", "self", ")", ":", "\n", "        ", "\"\"\"Merge any nodes with only one edge to their neighbors.\"\"\"", "\n", "for", "n", "in", "self", ".", "nodes", "(", ")", ":", "\n", "            ", "if", "self", ".", "degree", "(", "n", ")", "==", "1", ":", "\n", "                ", "self", ".", "merge_nodes", "(", "self", ".", "neighbors", "(", "n", ")", "[", "0", "]", ",", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.remove_inclusions": [[1833, 1858], ["list", "networkx.biconnected_components", "len", "list", "list.sort", "map", "cc.sort", "agglo.Rag.merge_subgraph", "enumerate"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_subgraph"], ["", "", "", "def", "remove_inclusions", "(", "self", ")", ":", "\n", "        ", "\"\"\"Merge any segments fully contained within other segments.\n\n        In 3D EM images, inclusions are not biologically plausible, so\n        this function can be used to remove them.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        None\n        \"\"\"", "\n", "bcc", "=", "list", "(", "biconnected_components", "(", "self", ")", ")", "\n", "if", "len", "(", "bcc", ")", ">", "1", ":", "\n", "            ", "container", "=", "[", "i", "for", "i", ",", "s", "in", "enumerate", "(", "bcc", ")", "if", "\n", "self", ".", "boundary_body", "in", "s", "]", "[", "0", "]", "\n", "del", "bcc", "[", "container", "]", "# remove the main graph", "\n", "bcc", "=", "list", "(", "map", "(", "list", ",", "bcc", ")", ")", "\n", "for", "cc", "in", "bcc", ":", "\n", "                ", "cc", ".", "sort", "(", "key", "=", "lambda", "x", ":", "self", ".", "nodes", "[", "x", "]", "[", "'size'", "]", ",", "reverse", "=", "True", ")", "\n", "", "bcc", ".", "sort", "(", "key", "=", "lambda", "x", ":", "self", ".", "nodes", "[", "x", "[", "0", "]", "]", "[", "'size'", "]", ")", "\n", "for", "cc", "in", "bcc", ":", "\n", "                ", "self", ".", "merge_subgraph", "(", "cc", ",", "cc", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.orphans": [[1860, 1878], ["agglo.Rag.nodes", "agglo.Rag.at_volume_boundary"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.at_volume_boundary"], ["", "", "", "def", "orphans", "(", "self", ")", ":", "\n", "        ", "\"\"\"List all the nodes that do not touch the volume boundary.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        orphans : list of int (node id)\n            A list of node ids.\n\n        Notes\n        -----\n        \"Orphans\" are not biologically plausible in EM data, so we can\n        flag them with this function for further scrutiny.\n        \"\"\"", "\n", "return", "[", "n", "for", "n", "in", "self", ".", "nodes", "(", ")", "if", "not", "self", ".", "at_volume_boundary", "(", "n", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.compute_orphans": [[1880, 1899], ["morpho.orphans", "agglo.Rag.get_segmentation"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.orphans", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation"], ["", "def", "compute_orphans", "(", "self", ")", ":", "\n", "        ", "\"\"\"Find all the segments that do not touch the volume boundary.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        orphans : list of int (node id)\n            A list of node ids.\n\n        Notes\n        -----\n        This function differs from ``orphans`` in that it does not use\n        the graph, but rather computes orphans directly from the\n        segmentation.\n        \"\"\"", "\n", "return", "morpho", ".", "orphans", "(", "self", ".", "get_segmentation", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.is_traversed_by_node": [[1901, 1923], ["numpy.zeros", "scipy.ndimage.measurements.label", "numpy.zeros.ravel", "numpy.ones", "agglo.Rag.at_volume_boundary", "agglo.Rag.boundary"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.at_volume_boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "is_traversed_by_node", "(", "self", ",", "n", ")", ":", "\n", "        ", "\"\"\"Determine whether a body traverses the volume.\n\n        This is defined as touching the volume boundary at two distinct\n        locations.\n\n        Parameters\n        ----------\n        n : int (node id)\n            The node being inspected.\n\n        Returns\n        -------\n        tr : bool\n            Whether the segment \"traverses\" the volume being segmented.\n        \"\"\"", "\n", "if", "not", "self", ".", "at_volume_boundary", "(", "n", ")", "or", "n", "==", "self", ".", "boundary_body", ":", "\n", "            ", "return", "False", "\n", "", "v", "=", "zeros", "(", "self", ".", "watershed", ".", "shape", ",", "'uint8'", ")", "\n", "v", ".", "ravel", "(", ")", "[", "self", ".", "boundary", "(", "n", ",", "self", ".", "boundary_body", ")", "]", "=", "1", "\n", "_", ",", "n", "=", "label", "(", "v", ",", "ones", "(", "[", "3", "]", "*", "v", ".", "ndim", ")", ")", "\n", "return", "n", ">", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.traversing_bodies": [[1925, 1928], ["agglo.Rag.nodes", "agglo.Rag.is_traversed_by_node"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.is_traversed_by_node"], ["", "def", "traversing_bodies", "(", "self", ")", ":", "\n", "        ", "\"\"\"List all bodies that traverse the volume.\"\"\"", "\n", "return", "[", "n", "for", "n", "in", "self", ".", "nodes", "(", ")", "if", "self", ".", "is_traversed_by_node", "(", "n", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.non_traversing_bodies": [[1930, 1934], ["agglo.Rag.nodes", "agglo.Rag.at_volume_boundary", "agglo.Rag.is_traversed_by_node"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.at_volume_boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.is_traversed_by_node"], ["", "def", "non_traversing_bodies", "(", "self", ")", ":", "\n", "        ", "\"\"\"List bodies that are not orphans and do not traverse the volume.\"\"\"", "\n", "return", "[", "n", "for", "n", "in", "self", ".", "nodes", "(", ")", "if", "self", ".", "at_volume_boundary", "(", "n", ")", "and", "\n", "not", "self", ".", "is_traversed_by_node", "(", "n", ")", "and", "n", "!=", "self", ".", "boundary_body", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.raveler_body_annotations": [[1936, 1948], ["agglo.Rag.compute_orphans", "agglo.Rag.compute_non_traversing_bodies", "int", "int"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.compute_orphans"], ["", "def", "raveler_body_annotations", "(", "self", ",", "traverse", "=", "False", ")", ":", "\n", "        ", "\"\"\"Return JSON-compatible dict formatted for Raveler annotations.\"\"\"", "\n", "orphans", "=", "self", ".", "compute_orphans", "(", ")", "\n", "non_traversing_bodies", "=", "self", ".", "compute_non_traversing_bodies", "(", ")", "if", "traverse", "else", "[", "]", "\n", "data", "=", "[", "{", "'status'", ":", "'not sure'", ",", "'comment'", ":", "'orphan'", ",", "'body ID'", ":", "int", "(", "o", ")", "}", "\n", "for", "o", "in", "orphans", "]", "+", "[", "{", "'status'", ":", "'not sure'", ",", "'comment'", ":", "'does not traverse'", ",", "\n", "'body ID'", ":", "int", "(", "n", ")", "}", "for", "n", "in", "non_traversing_bodies", "]", "\n", "metadata", "=", "{", "'description'", ":", "'body annotations'", ",", "'file version'", ":", "2", "}", "\n", "return", "{", "'data'", ":", "data", ",", "'metadata'", ":", "metadata", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.at_volume_boundary": [[1950, 1953], ["agglo.Rag.has_edge"], "methods", ["None"], ["", "def", "at_volume_boundary", "(", "self", ",", "n", ")", ":", "\n", "        ", "\"\"\"Return True if node n touches the volume boundary.\"\"\"", "\n", "return", "self", ".", "has_edge", "(", "n", ",", "self", ".", "boundary_body", ")", "or", "n", "==", "self", ".", "boundary_body", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.should_merge": [[1955, 1957], ["agglo.Rag.rig[].argmax", "agglo.Rag.rig[].argmax"], "methods", ["None"], ["", "def", "should_merge", "(", "self", ",", "n1", ",", "n2", ")", ":", "\n", "        ", "return", "self", ".", "rig", "[", "n1", "]", ".", "argmax", "(", ")", "==", "self", ".", "rig", "[", "n2", "]", ".", "argmax", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_pixel_label": [[1959, 1966], ["agglo.Rag.boundary", "agglo.Rag.should_merge", "agglo.Rag.probabilities_r[].argmin"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.should_merge"], ["", "def", "get_pixel_label", "(", "self", ",", "n1", ",", "n2", ")", ":", "\n", "        ", "boundary", "=", "self", ".", "boundary", "(", "n1", ",", "n2", ")", "\n", "min_idx", "=", "boundary", "[", "self", ".", "probabilities_r", "[", "boundary", ",", "0", "]", ".", "argmin", "(", ")", "]", "\n", "if", "self", ".", "should_merge", "(", "n1", ",", "n2", ")", ":", "\n", "            ", "return", "min_idx", ",", "2", "\n", "", "else", ":", "\n", "            ", "return", "min_idx", ",", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.pixel_labels_array": [[1968, 1976], ["numpy.zeros_like", "list", "ls.astype", "numpy.zeros_like.reshape", "agglo.Rag.get_pixel_label", "map", "agglo.Rag.real_edges", "zip"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_pixel_label", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.real_edges"], ["", "", "def", "pixel_labels_array", "(", "self", ",", "false_splits_only", "=", "False", ")", ":", "\n", "        ", "ar", "=", "zeros_like", "(", "self", ".", "watershed_r", ")", "\n", "labels", "=", "[", "self", ".", "get_pixel_label", "(", "*", "e", ")", "for", "e", "in", "self", ".", "real_edges", "(", ")", "]", "\n", "if", "false_splits_only", ":", "\n", "            ", "labels", "=", "[", "l", "for", "l", "in", "labels", "if", "l", "[", "1", "]", "==", "2", "]", "\n", "", "ids", ",", "ls", "=", "list", "(", "map", "(", "array", ",", "zip", "(", "*", "labels", ")", ")", ")", "\n", "ar", "[", "ids", "]", "=", "ls", ".", "astype", "(", "ar", ".", "dtype", ")", "\n", "return", "ar", ".", "reshape", "(", "self", ".", "watershed", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi": [[1978, 1985], ["numpy.array", "evaluate.split_vi", "evaluate.split_vi", "agglo.Rag.get_segmentation"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation"], ["", "def", "split_vi", "(", "self", ",", "gt", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "gt", "is", "None", "and", "gt", "is", "None", ":", "\n", "            ", "return", "array", "(", "[", "0", ",", "0", "]", ")", "\n", "", "elif", "self", ".", "gt", "is", "not", "None", ":", "\n", "            ", "return", "split_vi", "(", "self", ".", "rig", ")", "\n", "", "else", ":", "\n", "            ", "return", "split_vi", "(", "self", ".", "get_segmentation", "(", ")", ",", "gt", ",", "[", "0", "]", ",", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_edge_coordinates": [[1986, 1989], ["agglo.Rag.get_edge_coordinates"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.get_edge_coordinates"], ["", "", "def", "get_edge_coordinates", "(", "self", ",", "n1", ",", "n2", ",", "arbitrary", "=", "False", ")", ":", "\n", "        ", "\"\"\"Find where in the segmentation the edge (n1, n2) is most visible.\"\"\"", "\n", "return", "get_edge_coordinates", "(", "self", ",", "n1", ",", "n2", ",", "arbitrary", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write": [[1991, 1997], ["agglo.Rag.write_plaza_json", "ValueError"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write_plaza_json"], ["", "def", "write", "(", "self", ",", "fout", ",", "output_format", "=", "'GraphML'", ")", ":", "\n", "        ", "if", "output_format", "==", "'Plaza JSON'", ":", "\n", "            ", "self", ".", "write_plaza_json", "(", "fout", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unsupported output format for agglo.Rag: %s'", "\n", "%", "output_format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.write_plaza_json": [[1999, 2038], ["open", "json.load", "body_count.items", "open", "json.dump", "json_vals[].append", "list", "int", "int", "len", "numpy.float", "agglo.Rag.real_edges", "map", "agglo.Rag.boundary", "agglo.Rag.get_edge_coordinates"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.real_edges", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.get_edge_coordinates"], ["", "", "def", "write_plaza_json", "(", "self", ",", "fout", ",", "synapsejson", "=", "None", ",", "offsetz", "=", "0", ")", ":", "\n", "        ", "\"\"\"Write graph to Steve Plaza's JSON spec.\"\"\"", "\n", "json_vals", "=", "{", "}", "\n", "if", "synapsejson", "is", "not", "None", ":", "\n", "            ", "synapse_file", "=", "open", "(", "synapsejson", ")", "\n", "json_vals1", "=", "json", ".", "load", "(", "synapse_file", ")", "\n", "body_count", "=", "{", "}", "\n", "\n", "for", "item", "in", "json_vals1", "[", "\"data\"", "]", ":", "\n", "                ", "bodyid", "=", "(", "(", "item", "[", "\"T-bar\"", "]", ")", "[", "\"body ID\"", "]", ")", "\n", "if", "bodyid", "in", "body_count", ":", "\n", "                    ", "body_count", "[", "bodyid", "]", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "body_count", "[", "bodyid", "]", "=", "1", "\n", "", "for", "psd", "in", "item", "[", "\"partners\"", "]", ":", "\n", "                    ", "bodyid", "=", "psd", "[", "\"body ID\"", "]", "\n", "if", "bodyid", "in", "body_count", ":", "\n", "                        ", "body_count", "[", "bodyid", "]", "+=", "1", "\n", "", "else", ":", "\n", "                        ", "body_count", "[", "bodyid", "]", "=", "1", "\n", "\n", "", "", "", "json_vals", "[", "\"synapse_bodies\"", "]", "=", "[", "]", "\n", "for", "body", ",", "count", "in", "body_count", ".", "items", "(", ")", ":", "\n", "                ", "temp", "=", "[", "body", ",", "count", "]", "\n", "json_vals", "[", "\"synapse_bodies\"", "]", ".", "append", "(", "temp", ")", "\n", "\n", "", "", "edge_list", "=", "[", "\n", "{", "'location'", ":", "list", "(", "map", "(", "int", ",", "self", ".", "get_edge_coordinates", "(", "i", ",", "j", ")", "[", "-", "1", ":", ":", "-", "1", "]", ")", ")", ",", "\n", "'node1'", ":", "int", "(", "i", ")", ",", "'node2'", ":", "int", "(", "j", ")", ",", "\n", "'edge_size'", ":", "len", "(", "self", ".", "boundary", "(", "i", ",", "j", ")", ")", ",", "\n", "'size1'", ":", "self", ".", "nodes", "[", "i", "]", "[", "'size'", "]", ",", "\n", "'size2'", ":", "self", ".", "nodes", "[", "j", "]", "[", "'size'", "]", ",", "\n", "'weight'", ":", "float", "(", "self", ".", "edges", "[", "i", ",", "j", "]", "[", "'weight'", "]", ")", "}", "\n", "for", "i", ",", "j", "in", "self", ".", "real_edges", "(", ")", "\n", "]", "\n", "json_vals", "[", "'edge_list'", "]", "=", "edge_list", "\n", "\n", "with", "open", "(", "fout", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "json_vals", ",", "f", ",", "indent", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.ncut": [[2040, 2065], ["agglo.Rag.compute_W", "ncut.ncutW", "agglo.Rag.cluster_by_labels", "agglo.Rag.nodes"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.compute_W", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.ncut.ncutW", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.cluster_by_labels"], ["", "", "def", "ncut", "(", "self", ",", "num_clusters", "=", "10", ",", "kmeans_iters", "=", "5", ",", "sigma", "=", "255.0", "*", "20", ",", "nodes", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Run normalized cuts on the current set of fragments.\n\n        Parameters\n        ----------\n        num_clusters : int, optional\n            The desired number of clusters\n        kmeans_iters : int, optional\n            The maximum number of iterations for the kmeans clustering\n            of the Laplacian eigenvectors.\n        sigma : float, optional\n            The damping factor on the edge weights. The higher this value,\n            the closer to 1 (the maximum) edges with large weights will be.\n        nodes : collection of int, optional\n            Restrict the ncut to the listed nodes.\n        \"\"\"", "\n", "if", "nodes", "is", "None", ":", "\n", "            ", "nodes", "=", "self", ".", "nodes", "(", ")", "\n", "# Compute weight matrix", "\n", "", "W", "=", "self", ".", "compute_W", "(", "self", ".", "merge_priority_function", ",", "nodes", "=", "nodes", ")", "\n", "# Run normalized cut", "\n", "labels", ",", "eigvec", ",", "eigval", "=", "ncutW", "(", "W", ",", "num_clusters", ",", "kmeans_iters", ",", "**", "kwargs", ")", "\n", "# Merge nodes that are in same cluster", "\n", "self", ".", "cluster_by_labels", "(", "labels", ",", "nodes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.cluster_by_labels": [[2067, 2080], ["numpy.unique", "numpy.array", "ValueError", "agglo.Rag.nodes", "len", "len", "agglo.Rag.number_of_nodes", "len", "numpy.nonzero", "agglo.Rag.merge_nodes"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.stack_np.Stack.number_of_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes"], ["", "def", "cluster_by_labels", "(", "self", ",", "labels", ",", "nodes", "=", "None", ")", ":", "\n", "        ", "\"\"\"Merge all superpixels with the same label (1 label per 1 sp)\"\"\"", "\n", "if", "nodes", "is", "None", ":", "\n", "            ", "nodes", "=", "array", "(", "self", ".", "nodes", "(", ")", ")", "\n", "", "if", "not", "(", "len", "(", "labels", ")", "==", "len", "(", "nodes", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Number of labels should be %d but is %d.'", ",", "\n", "self", ".", "number_of_nodes", "(", ")", ",", "len", "(", "labels", ")", ")", "\n", "", "for", "l", "in", "unique", "(", "labels", ")", ":", "\n", "            ", "inds", "=", "nonzero", "(", "labels", "==", "l", ")", "[", "0", "]", "\n", "nodes_to_merge", "=", "nodes", "[", "inds", "]", "\n", "node1", "=", "nodes_to_merge", "[", "0", "]", "\n", "for", "node", "in", "nodes_to_merge", "[", "1", ":", "]", ":", "\n", "                ", "self", ".", "merge_nodes", "(", "node1", ",", "node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.compute_W": [[2082, 2100], ["len", "dict", "scipy.sparse.lil_matrix", "agglo.Rag.real_edges", "scipy.sparse.lil_matrix.tocsr", "numpy.array", "zip", "distance_function", "numpy.exp", "agglo.Rag.nodes", "range"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.real_edges"], ["", "", "", "def", "compute_W", "(", "self", ",", "distance_function", ",", "sigma", "=", "255.0", "*", "20", ",", "nodes", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute the weight matrix for n-cut clustering.\n\n        See `ncut` for parameters.\n        \"\"\"", "\n", "if", "nodes", "is", "None", ":", "\n", "            ", "nodes", "=", "array", "(", "self", ".", "nodes", "(", ")", ")", "\n", "", "n", "=", "len", "(", "nodes", ")", "\n", "nodes2ind", "=", "dict", "(", "zip", "(", "nodes", ",", "range", "(", "n", ")", ")", ")", "\n", "W", "=", "lil_matrix", "(", "(", "n", ",", "n", ")", ")", "\n", "for", "u", ",", "v", "in", "self", ".", "real_edges", "(", "nodes", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "i", ",", "j", "=", "nodes2ind", "[", "u", "]", ",", "nodes2ind", "[", "v", "]", "\n", "", "except", "KeyError", ":", "\n", "                ", "continue", "\n", "", "w", "=", "distance_function", "(", "self", ",", "(", "u", ",", "v", ")", ")", "\n", "W", "[", "i", ",", "j", "]", "=", "W", "[", "j", ",", "i", "]", "=", "np", ".", "exp", "(", "-", "w", "**", "2", "/", "sigma", ")", "\n", "", "return", "W", ".", "tocsr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.update_frozen_sets": [[2102, 2112], ["agglo.Rag.frozen_nodes.discard", "agglo.Rag.frozen_nodes.discard", "agglo.Rag.frozen_edges.copy", "agglo.Rag.frozen_edges.discard", "agglo.Rag.frozen_edges.add", "agglo.Rag.frozen_edges.add"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "update_frozen_sets", "(", "self", ",", "n1", ",", "n2", ")", ":", "\n", "        ", "self", ".", "frozen_nodes", ".", "discard", "(", "n1", ")", "\n", "self", ".", "frozen_nodes", ".", "discard", "(", "n2", ")", "\n", "for", "x", ",", "y", "in", "self", ".", "frozen_edges", ".", "copy", "(", ")", ":", "\n", "            ", "if", "n2", "in", "[", "x", ",", "y", "]", ":", "\n", "                ", "self", ".", "frozen_edges", ".", "discard", "(", "(", "x", ",", "y", ")", ")", "\n", "", "if", "x", "==", "n2", ":", "\n", "                ", "self", ".", "frozen_edges", ".", "add", "(", "(", "n1", ",", "y", ")", ")", "\n", "", "if", "y", "==", "n2", ":", "\n", "                ", "self", ".", "frozen_edges", ".", "add", "(", "(", "x", ",", "n1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.conditional_countdown": [[84, 117], ["pred"], "function", ["None"], ["def", "conditional_countdown", "(", "seq", ",", "start", "=", "1", ",", "pred", "=", "bool", ")", ":", "\n", "    ", "\"\"\"Count down from 'start' each time pred(elem) is true for elem in seq.\n\n    Used to know how many elements of a sequence remain that satisfy a\n    predicate.\n\n    Parameters\n    ----------\n    seq : iterable\n        Any sequence.\n    start : int, optional\n        The starting element.\n    pred : function, type(next(seq)) -> bool\n        A predicate acting on the elements of `seq`.\n\n    Examples\n    --------\n    >>> seq = range(10)\n    >>> cc = conditional_countdown(seq, start=5, pred=lambda x: x % 2 == 1)\n    >>> next(cc)\n    5\n    >>> next(cc)\n    4\n    >>> next(cc)\n    4\n    >>> next(cc)\n    3\n    \"\"\"", "\n", "remaining", "=", "start", "\n", "for", "elem", "in", "seq", ":", "\n", "        ", "if", "pred", "(", "elem", ")", ":", "\n", "            ", "remaining", "-=", "1", "\n", "", "yield", "remaining", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.batchify": [[124, 146], ["result.append", "func"], "function", ["None"], ["", "", "def", "batchify", "(", "func", ")", ":", "\n", "    ", "\"\"\"Convert classical (g, n1, n2) -> f policy to batch (g, [e]) -> [f]\n\n    This is meant for policies that wouldn't gain much from batch evaluation\n    or that aren't used very much.\n\n    Parameters\n    ----------\n    func : function\n        A merge priority function with signature (g, n1, n2) -> f.\n\n    Returns\n    -------\n    batch_func : function\n        A batch merge priority function with signature (g, [(n1, n2)]) -> [f].\n    \"\"\"", "\n", "def", "batch_func", "(", "g", ",", "edges", ")", ":", "\n", "        ", "result", "=", "[", "]", "\n", "for", "n1", ",", "n2", "in", "edges", ":", "\n", "            ", "result", ".", "append", "(", "func", "(", "g", ",", "n1", ",", "n2", ")", ")", "\n", "", "return", "result", "\n", "", "return", "batch_func", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.oriented_boundary_mean": [[148, 151], ["numpy.mean", "g.boundary"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "@", "batchify", "\n", "def", "oriented_boundary_mean", "(", "g", ",", "n1", ",", "n2", ")", ":", "\n", "    ", "return", "mean", "(", "g", ".", "oriented_probabilities_r", "[", "g", ".", "boundary", "(", "n1", ",", "n2", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean": [[153, 156], ["numpy.mean", "g.boundary"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "@", "batchify", "\n", "def", "boundary_mean", "(", "g", ",", "n1", ",", "n2", ")", ":", "\n", "    ", "return", "mean", "(", "g", ".", "probabilities_r", "[", "g", ".", "boundary", "(", "n1", ",", "n2", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_median": [[158, 161], ["numpy.median", "g.boundary"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "@", "batchify", "\n", "def", "boundary_median", "(", "g", ",", "n1", ",", "n2", ")", ":", "\n", "    ", "return", "median", "(", "g", ".", "probabilities_r", "[", "g", ".", "boundary", "(", "n1", ",", "n2", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.approximate_boundary_mean": [[163, 170], ["g.feature_manager.compute_edge_features"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.compute_edge_features"], ["", "@", "batchify", "\n", "def", "approximate_boundary_mean", "(", "g", ",", "n1", ",", "n2", ")", ":", "\n", "    ", "\"\"\"Return the boundary mean as computed by a MomentsFeatureManager.\n\n    The feature manager is assumed to have been set up for g at construction.\n    \"\"\"", "\n", "return", "g", ".", "feature_manager", ".", "compute_edge_features", "(", "g", ",", "n1", ",", "n2", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.make_ladder": [[172, 219], ["numpy.array", "numpy.empty", "enumerate", "numpy.empty", "len", "len", "len", "g.at_volume_boundary", "g.at_volume_boundary", "g.boundary", "agglo.boundary_mean"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.at_volume_boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.at_volume_boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean"], ["", "def", "make_ladder", "(", "priority_function", ",", "threshold", ",", "strictness", "=", "1", ")", ":", "\n", "    ", "\"\"\"Convert priority function to merge small segments first.\n\n    Small segments tend to mess with other segmentation metrics, so we\n    merge them early so that more sophisticated function can work on big\n    segments. This is particularly useful for bad fragment generation\n    methods that generate lots of tiny fragments.\n\n    Parameters\n    ----------\n    priority_function : function (g, [e]) -> [f]\n        The merge priority function to convert.\n    threshold : int or float\n        The minimum size to be considered for merging.\n    strictness : int in {1, 2, 3}\n        How hard to check for segment size:\n          - 1: only merge small nodes that are not at the volume boundary.\n          - 2: only merge small nodes not at the volume boundary, *but not\n               to each other.*\n          - 3: conditions 1 and 2 but also ensure that the boundary shared\n               between segments is bigger than 2 voxels.\n\n    Returns\n    -------\n    ladder_priority_function : function (g, [e]) -> [f]\n        Same as priority function but only for small segments, otherwise\n        returns infinity.\n    \"\"\"", "\n", "def", "ladder_function", "(", "g", ",", "edges", ")", ":", "\n", "        ", "edges", "=", "np", ".", "array", "(", "edges", ")", "\n", "pass_ladder", "=", "np", ".", "empty", "(", "len", "(", "edges", ")", ",", "dtype", "=", "bool", ")", "\n", "for", "i", ",", "(", "n1", ",", "n2", ")", "in", "enumerate", "(", "edges", ")", ":", "\n", "            ", "s1", "=", "g", ".", "nodes", "[", "n1", "]", "[", "'size'", "]", "\n", "s2", "=", "g", ".", "nodes", "[", "n2", "]", "[", "'size'", "]", "\n", "ladder_condition", "=", "(", "s1", "<", "threshold", "and", "not", "g", ".", "at_volume_boundary", "(", "n1", ")", ")", "or", "(", "s2", "<", "threshold", "and", "not", "g", ".", "at_volume_boundary", "(", "n2", ")", ")", "\n", "if", "strictness", ">=", "2", ":", "\n", "                ", "ladder_condition", "&=", "(", "(", "s1", "<", "threshold", ")", "!=", "(", "s2", "<", "threshold", ")", ")", "\n", "", "if", "strictness", ">=", "3", ":", "\n", "                ", "ladder_condition", "&=", "len", "(", "g", ".", "boundary", "(", "n1", ",", "n2", ")", ")", ">", "2", "\n", "", "pass_ladder", "[", "i", "]", "=", "ladder_condition", "\n", "", "priority", "=", "np", ".", "empty", "(", "len", "(", "edges", ")", ",", "dtype", "=", "float", ")", "\n", "priority", "[", "pass_ladder", "]", "=", "priority_function", "(", "g", ",", "edges", "[", "pass_ladder", "]", ")", "\n", "priority", "[", "~", "pass_ladder", "]", "=", "np", ".", "inf", "\n", "return", "priority", "\n", "", "return", "ladder_function", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.no_mito_merge": [[221, 255], ["priority_function", "enumerate"], "function", ["None"], ["", "def", "no_mito_merge", "(", "priority_function", ")", ":", "\n", "    ", "\"\"\"Convert priority function to avoid merging mitochondria.\n\n    Mitochondria are super annoying in segmentation. This uses pre-\n    -computed mitochondrion labels for the segments to avoid merging\n    anything that looks like a mitochondrion, in the beginning. These\n    can be dealt with later when the bulk of the segmentation is\n    correct.\n\n    Parameters\n    ----------\n    priority_function : function (g, [e]) -> [f]\n        The merge priority function to convert.\n\n    Returns\n    -------\n    mito_priority_function : function (g, [e]) -> [f]\n        Same as priority function, but avoids merging frozen nodes/edges.\n        Freezing can be defined using any property, not just mitochondria!\n\n    See Also\n    --------\n    mito_merge\n    \"\"\"", "\n", "def", "predict", "(", "g", ",", "edges", ")", ":", "\n", "        ", "priorities", "=", "priority_function", "(", "g", ",", "edges", ")", "\n", "for", "i", ",", "(", "n1", ",", "n2", ")", "in", "enumerate", "(", "edges", ")", ":", "\n", "            ", "frozen", "=", "(", "n1", "in", "g", ".", "frozen_nodes", "or", "\n", "n2", "in", "g", ".", "frozen_nodes", "or", "\n", "(", "n1", ",", "n2", ")", "in", "g", ".", "frozen_edges", ")", "\n", "if", "frozen", ":", "\n", "                ", "priorities", "[", "i", "]", "=", "np", ".", "inf", "\n", "", "", "return", "priorities", "\n", "", "return", "predict", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.mito_merge": [[257, 278], ["numpy.float", "sum", "len", "g.boundary", "len", "g.boundary", "g.neighbors"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "@", "batchify", "\n", "def", "mito_merge", "(", "g", ",", "n1", ",", "n2", ")", ":", "\n", "    ", "\"\"\"Simple priority funct to merge segments previously labeled as mito.\"\"\"", "\n", "if", "n1", "in", "g", ".", "frozen_nodes", "and", "n2", "in", "g", ".", "frozen_nodes", ":", "\n", "        ", "return", "np", ".", "inf", "\n", "", "elif", "(", "n1", ",", "n2", ")", "in", "g", ".", "frozen_edges", ":", "\n", "        ", "return", "np", ".", "inf", "\n", "", "elif", "n1", "not", "in", "g", ".", "frozen_nodes", "and", "n2", "not", "in", "g", ".", "frozen_nodes", ":", "\n", "        ", "return", "np", ".", "inf", "\n", "", "else", ":", "\n", "        ", "if", "n1", "in", "g", ".", "frozen_nodes", ":", "\n", "            ", "mito", "=", "n1", "\n", "cyto", "=", "n2", "\n", "", "else", ":", "\n", "            ", "mito", "=", "n2", "\n", "cyto", "=", "n1", "\n", "", "if", "g", ".", "nodes", "[", "mito", "]", "[", "'size'", "]", ">", "g", ".", "nodes", "[", "cyto", "]", "[", "'size'", "]", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "", "else", ":", "\n", "            ", "return", "1.0", "-", "(", "float", "(", "len", "(", "g", ".", "boundary", "(", "mito", ",", "cyto", ")", ")", ")", "/", "\n", "sum", "(", "[", "len", "(", "g", ".", "boundary", "(", "mito", ",", "x", ")", ")", "for", "x", "in", "g", ".", "neighbors", "(", "mito", ")", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.classifier_probability": [[280, 295], ["numpy.atleast_2d", "numpy.sum().astype", "numpy.empty", "numpy.atleast_2d", "len", "numpy.array", "numpy.sum", "feature_map", "classifier.predict_proba"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.predict_proba"], ["", "", "", "def", "classifier_probability", "(", "feature_map", ",", "classifier", ")", ":", "\n", "    ", "def", "predict", "(", "g", ",", "edges", ")", ":", "\n", "        ", "edges", "=", "np", ".", "atleast_2d", "(", "edges", ")", "\n", "boundary", "=", "np", ".", "sum", "(", "edges", "==", "g", ".", "boundary_body", ",", "axis", "=", "1", ")", ".", "astype", "(", "bool", ")", "\n", "result", "=", "np", ".", "empty", "(", "len", "(", "edges", ")", ")", "\n", "result", "[", "boundary", "]", "=", "np", ".", "inf", "\n", "features", "=", "np", ".", "atleast_2d", "(", "[", "feature_map", "(", "g", ",", "n1", ",", "n2", ")", "\n", "for", "n1", ",", "n2", "in", "edges", "[", "~", "boundary", "]", "]", ")", "\n", "if", "features", ".", "size", ">", "0", ":", "\n", "            ", "prediction", "=", "classifier", ".", "predict_proba", "(", "features", ")", "[", ":", ",", "1", "]", "\n", "", "else", ":", "\n", "            ", "prediction", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "", "result", "[", "~", "boundary", "]", "=", "prediction", "\n", "return", "result", "\n", "", "return", "predict", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.ordered_priority": [[297, 308], ["len", "enumerate", "numpy.float", "d.get"], "function", ["None"], ["", "def", "ordered_priority", "(", "edges", ")", ":", "\n", "    ", "d", "=", "{", "}", "\n", "n", "=", "len", "(", "edges", ")", "\n", "for", "i", ",", "(", "n1", ",", "n2", ")", "in", "enumerate", "(", "edges", ")", ":", "\n", "        ", "score", "=", "float", "(", "i", ")", "/", "n", "\n", "d", "[", "(", "n1", ",", "n2", ")", "]", "=", "score", "\n", "d", "[", "(", "n2", ",", "n1", ")", "]", "=", "score", "\n", "\n", "", "def", "ord", "(", "g", ",", "edges", ")", ":", "\n", "        ", "return", "[", "d", ".", "get", "(", "e", ",", "inf", ")", "for", "e", "in", "edges", "]", "\n", "", "return", "ord", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.expected_change_vi": [[310, 323], ["agglo.classifier_probability", "classifier_probability.", "numpy.fromiter", "numpy.fromiter", "agglo.compute_local_vi_change", "len", "len"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.classifier_probability", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_local_vi_change"], ["", "def", "expected_change_vi", "(", "feature_map", ",", "classifier", ",", "alpha", "=", "1.0", ",", "beta", "=", "1.0", ")", ":", "\n", "    ", "prob_func", "=", "classifier_probability", "(", "feature_map", ",", "classifier", ")", "\n", "def", "predict", "(", "g", ",", "edges", ")", ":", "\n", "        ", "p", "=", "prob_func", "(", "g", ",", "edges", ")", "# Prediction from the classifier", "\n", "# Calculate change in VI if n1 and n2 should not be merged", "\n", "n1_sizes", "=", "np", ".", "fromiter", "(", "(", "g", ".", "node", "[", "n1", "]", "[", "'size'", "]", "for", "n1", ",", "n2", "in", "edges", ")", ",", "\n", "dtype", "=", "float", ",", "count", "=", "len", "(", "edges", ")", ")", "\n", "n2_sizes", "=", "np", ".", "fromiter", "(", "(", "g", ".", "node", "[", "n2", "]", "[", "'size'", "]", "for", "n1", ",", "n2", "in", "edges", ")", ",", "\n", "dtype", "=", "float", ",", "count", "=", "len", "(", "edges", ")", ")", "\n", "v", "=", "compute_local_vi_change", "(", "n1_sizes", ",", "n2_sizes", ",", "g", ".", "volume_size", ")", "\n", "# Return expected change", "\n", "return", "p", "*", "alpha", "*", "v", "-", "(", "1", "-", "p", ")", "*", "beta", "*", "v", "\n", "", "return", "predict", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_local_vi_change": [[325, 331], ["numpy.log2", "numpy.log2", "numpy.log2"], "function", ["None"], ["", "def", "compute_local_vi_change", "(", "s1", ",", "s2", ",", "n", ")", ":", "\n", "    ", "\"\"\"Compute change in VI if we merge disjoint sizes s1,s2 in a volume n.\"\"\"", "\n", "py1", "=", "s1", "/", "n", "\n", "py2", "=", "s2", "/", "n", "\n", "py", "=", "py1", "+", "py2", "\n", "return", "-", "(", "py1", "*", "np", ".", "log2", "(", "py1", ")", "+", "py2", "*", "np", ".", "log2", "(", "py2", ")", "-", "py", "*", "np", ".", "log2", "(", "py", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_true_delta_vi": [[333, 342], ["ctable[].sum", "ctable[].sum", "evaluate.xlogx().sum", "evaluate.xlogx().sum", "evaluate.xlogx().sum", "evaluate.xlogx", "evaluate.xlogx", "evaluate.xlogx", "numpy.log2", "numpy.log2", "numpy.log2"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.xlogx", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.xlogx", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.xlogx"], ["", "def", "compute_true_delta_vi", "(", "ctable", ",", "n1", ",", "n2", ")", ":", "\n", "    ", "p1", "=", "ctable", "[", "n1", "]", ".", "sum", "(", ")", "\n", "p2", "=", "ctable", "[", "n2", "]", ".", "sum", "(", ")", "\n", "p3", "=", "p1", "+", "p2", "\n", "p1g_log_p1g", "=", "xlogx", "(", "ctable", "[", "n1", "]", ")", ".", "sum", "(", ")", "\n", "p2g_log_p2g", "=", "xlogx", "(", "ctable", "[", "n2", "]", ")", ".", "sum", "(", ")", "\n", "p3g_log_p3g", "=", "xlogx", "(", "ctable", "[", "n1", "]", "+", "ctable", "[", "n2", "]", ")", ".", "sum", "(", ")", "\n", "return", "p3", "*", "np", ".", "log2", "(", "p3", ")", "-", "p1", "*", "np", ".", "log2", "(", "p1", ")", "-", "p2", "*", "np", ".", "log2", "(", "p2", ")", "-", "2", "*", "(", "p3g_log_p3g", "-", "p1g_log_p1g", "-", "p2g_log_p2g", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.expected_change_rand": [[344, 355], ["agglo.classifier_probability", "classifier_probability.", "numpy.fromiter", "numpy.fromiter", "agglo.compute_local_rand_change", "len", "len"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.classifier_probability", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_local_rand_change"], ["", "def", "expected_change_rand", "(", "feature_map", ",", "classifier", ",", "alpha", "=", "1.0", ",", "beta", "=", "1.0", ")", ":", "\n", "    ", "prob_func", "=", "classifier_probability", "(", "feature_map", ",", "classifier", ")", "\n", "def", "predict", "(", "g", ",", "edges", ")", ":", "\n", "        ", "p", "=", "prob_func", "(", "g", ",", "edges", ")", "# Prediction from the classifier", "\n", "n1_sizes", "=", "np", ".", "fromiter", "(", "(", "g", ".", "node", "[", "n1", "]", "[", "'size'", "]", "for", "n1", ",", "n2", "in", "edges", ")", ",", "\n", "dtype", "=", "float", ",", "count", "=", "len", "(", "edges", ")", ")", "\n", "n2_sizes", "=", "np", ".", "fromiter", "(", "(", "g", ".", "node", "[", "n2", "]", "[", "'size'", "]", "for", "n1", ",", "n2", "in", "edges", ")", ",", "\n", "dtype", "=", "float", ",", "count", "=", "len", "(", "edges", ")", ")", "\n", "v", "=", "compute_local_rand_change", "(", "n1_sizes", ",", "n2_sizes", ",", "g", ".", "volume_size", ")", "\n", "return", "p", "*", "v", "*", "alpha", "-", "(", "1", "-", "p", ")", "*", "beta", "*", "v", "\n", "", "return", "predict", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_local_rand_change": [[357, 360], ["scipy.special.comb"], "function", ["None"], ["", "def", "compute_local_rand_change", "(", "s1", ",", "s2", ",", "n", ")", ":", "\n", "    ", "\"\"\"Compute change in rand if we merge disjoint sizes s1,s2 in volume n.\"\"\"", "\n", "return", "s1", "*", "s2", "/", "nchoosek", "(", "n", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.compute_true_delta_rand": [[362, 375], ["localct.data.sum", "scipy.special.comb", "numpy.array", "numpy.array", "localct.sum", "localct.sum"], "function", ["None"], ["", "def", "compute_true_delta_rand", "(", "ctable", ",", "n1", ",", "n2", ",", "n", ")", ":", "\n", "    ", "\"\"\"Compute change in RI obtained by merging rows n1 and n2.\n\n    This function assumes ctable is normalized to sum to 1.\n    \"\"\"", "\n", "localct", "=", "n", "*", "ctable", "[", "(", "n1", ",", "n2", ")", ",", ":", "]", "\n", "total", "=", "localct", ".", "data", ".", "sum", "(", ")", "\n", "sqtotal", "=", "(", "localct", ".", "data", "**", "2", ")", ".", "sum", "(", ")", "\n", "delta_sxy", "=", "1.", "/", "2", "*", "(", "(", "np", ".", "array", "(", "localct", ".", "sum", "(", "axis", "=", "0", ")", ")", "**", "2", ")", ".", "sum", "(", ")", "-", "\n", "sqtotal", ")", "\n", "delta_sx", "=", "1.", "/", "2", "*", "(", "total", "**", "2", "-", "\n", "(", "np", ".", "array", "(", "localct", ".", "sum", "(", "axis", "=", "1", ")", ")", "**", "2", ")", ".", "sum", "(", ")", ")", "\n", "return", "(", "2", "*", "delta_sxy", "-", "delta_sx", ")", "/", "nchoosek", "(", "n", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean_ladder": [[377, 380], ["agglo.make_ladder", "make_ladder."], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.make_ladder"], ["", "def", "boundary_mean_ladder", "(", "g", ",", "edges", ",", "threshold", ",", "strictness", "=", "1", ")", ":", "\n", "    ", "f", "=", "make_ladder", "(", "boundary_mean", ",", "threshold", ",", "strictness", ")", "\n", "return", "f", "(", "g", ",", "edges", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean_plus_sem": [[382, 387], ["numpy.fromiter", "numpy.fromiter", "map", "map", "len", "len", "g.boundary"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "boundary_mean_plus_sem", "(", "g", ",", "edges", ",", "alpha", "=", "-", "6", ")", ":", "\n", "    ", "bvals", "=", "[", "g", ".", "probabilities_r", "[", "g", ".", "boundary", "(", "n1", ",", "n2", ")", "]", "for", "n1", ",", "n2", "in", "edges", "]", "\n", "means", "=", "np", ".", "fromiter", "(", "map", "(", "mean", ",", "bvals", ")", ",", "dtype", "=", "float", ",", "count", "=", "len", "(", "edges", ")", ")", "\n", "sems", "=", "np", ".", "fromiter", "(", "map", "(", "sem", ",", "bvals", ")", ",", "dtype", "=", "float", ",", "count", "=", "len", "(", "edges", ")", ")", "\n", "return", "means", "+", "alpha", "*", "sems", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.random_priority": [[389, 394], ["numpy.atleast_2d", "numpy.random.rand", "len", "numpy.sum().astype", "numpy.sum"], "function", ["None"], ["", "def", "random_priority", "(", "g", ",", "edges", ")", ":", "\n", "    ", "edges", "=", "np", ".", "atleast_2d", "(", "edges", ")", "\n", "result", "=", "np", ".", "random", ".", "rand", "(", "len", "(", "edges", ")", ")", "\n", "result", "[", "np", ".", "sum", "(", "edges", "==", "g", ".", "boundary_body", ",", "axis", "=", "1", ")", ".", "astype", "(", "bool", ")", "]", "=", "np", ".", "inf", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.get_edge_coordinates": [[2114, 2125], ["g.boundary", "g.boundary.pop", "g.boundary.append", "numpy.unravel_index", "numpy.unravel_index", "numpy.array", "numpy.bincount().argmax", "numpy.bincount"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.mergequeue.MergeQueue.pop"], ["", "", "", "", "def", "get_edge_coordinates", "(", "g", ",", "n1", ",", "n2", ",", "arbitrary", "=", "False", ")", ":", "\n", "    ", "\"\"\"Find where in the segmentation the edge (n1, n2) is most visible.\"\"\"", "\n", "boundary", "=", "g", ".", "boundary", "(", "n1", ",", "n2", ")", "\n", "if", "arbitrary", ":", "\n", "# quickly get an arbitrary point on the boundary", "\n", "        ", "idx", "=", "boundary", ".", "pop", "(", ")", ";", "boundary", ".", "append", "(", "idx", ")", "\n", "coords", "=", "unravel_index", "(", "idx", ",", "g", ".", "watershed", ".", "shape", ")", "\n", "", "else", ":", "\n", "        ", "boundary_idxs", "=", "unravel_index", "(", "boundary", ",", "g", ".", "watershed", ".", "shape", ")", "\n", "coords", "=", "[", "bincount", "(", "dimcoords", ")", ".", "argmax", "(", ")", "for", "dimcoords", "in", "boundary_idxs", "]", "\n", "", "return", "array", "(", "coords", ")", "-", "g", ".", "pad_thickness", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.is_mito_boundary": [[2127, 2130], ["max", "numpy.mean", "g.boundary"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "is_mito_boundary", "(", "g", ",", "n1", ",", "n2", ",", "channel", "=", "2", ",", "threshold", "=", "0.5", ")", ":", "\n", "    ", "return", "max", "(", "np", ".", "mean", "(", "g", ".", "probabilities_r", "[", "g", ".", "boundary", "(", "n1", ",", "n2", ")", ",", "c", "]", ")", "\n", "for", "c", "in", "channel", ")", ">", "threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.is_mito": [[2132, 2135], ["max", "numpy.mean", "g.extent"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.extent"], ["", "def", "is_mito", "(", "g", ",", "n", ",", "channel", "=", "2", ",", "threshold", "=", "0.5", ")", ":", "\n", "    ", "return", "max", "(", "np", ".", "mean", "(", "g", ".", "probabilities_r", "[", "g", ".", "extent", "(", "n", ")", ",", "c", "]", ")", "\n", "for", "c", "in", "channel", ")", ">", "threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.best_possible_segmentation": [[2137, 2145], ["agglo.Rag", "evaluate.assignment_table().tocsc", "range", "agglo.Rag.get_segmentation", "agglo.Rag.merge_subgraph", "evaluate.assignment_table", "agglo.Rag.get_segmentation"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_subgraph", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.assignment_table", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation"], ["", "def", "best_possible_segmentation", "(", "ws", ",", "gt", ")", ":", "\n", "    ", "\"\"\"Build the best possible segmentation given a superpixel map.\"\"\"", "\n", "ws", "=", "Rag", "(", "ws", ")", "\n", "assignment", "=", "ev", ".", "assignment_table", "(", "ws", ".", "get_segmentation", "(", ")", ",", "gt", ")", ".", "tocsc", "(", ")", "\n", "for", "gt_node", "in", "range", "(", "assignment", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "i", ",", "j", "=", "assignment", ".", "indptr", "[", "gt_node", ":", "gt_node", "+", "2", "]", "\n", "ws", ".", "merge_subgraph", "(", "assignment", ".", "indices", "[", "i", ":", "j", "]", ")", "\n", "", "return", "ws", ".", "get_segmentation", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.__init__": [[4, 5], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n", "def", "start", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start": [[5, 6], ["None"], "methods", ["None"], ["def", "start", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n", "def", "update", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.update": [[6, 7], ["None"], "methods", ["None"], ["def", "update", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n", "def", "update_i", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.update_i": [[7, 8], ["None"], "methods", ["None"], ["def", "update_i", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n", "def", "finish", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.finish": [[8, 9], ["None"], "methods", ["None"], ["def", "finish", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n", "def", "set_title", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.set_title": [[9, 10], ["None"], "methods", ["None"], ["def", "set_title", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.with_progress": [[11, 20], ["iterprogress.NoProgressBar", "pbar.start", "len", "pbar.set_title", "pbar.update"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.set_title", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.update"], ["", "def", "with_progress", "(", "collection", ",", "length", "=", "None", ",", "title", "=", "None", ",", "pbar", "=", "NoProgressBar", "(", ")", ")", ":", "\n", "    ", "if", "length", "is", "None", ":", "\n", "        ", "length", "=", "len", "(", "collection", ")", "\n", "", "if", "title", "is", "not", "None", ":", "\n", "        ", "pbar", ".", "set_title", "(", "title", ")", "\n", "", "pbar", ".", "start", "(", "length", ")", "\n", "for", "elem", "in", "collection", ":", "\n", "        ", "yield", "elem", "\n", "pbar", ".", "update", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.__init__": [[6, 8], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "default_cache", "=", "'feature-cache'", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.__call__": [[9, 11], ["base.Null.compute_features"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Mock.compute_features"], ["", "def", "__call__", "(", "self", ",", "g", ",", "n1", ",", "n2", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "compute_features", "(", "g", ",", "n1", ",", "n2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.write_fm": [[12, 14], ["None"], "methods", ["None"], ["", "def", "write_fm", "(", "self", ",", "json_fm", "=", "{", "}", ")", ":", "\n", "        ", "return", "json_fm", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.compute_features": [[15, 28], ["numpy.concatenate", "base.Null.compute_node_features", "base.Null.compute_node_features", "base.Null.compute_node_features", "base.Null.compute_edge_features", "base.Null.compute_difference_features"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_node_features", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_node_features", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_node_features", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.compute_edge_features", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_difference_features"], ["", "def", "compute_features", "(", "self", ",", "g", ",", "n1", ",", "n2", "=", "None", ")", ":", "\n", "        ", "if", "n2", "is", "None", ":", "\n", "            ", "c1", "=", "g", ".", "nodes", "[", "n1", "]", "[", "self", ".", "default_cache", "]", "\n", "return", "self", ".", "compute_node_features", "(", "g", ",", "n1", ",", "c1", ")", "\n", "", "if", "g", ".", "nodes", "[", "n1", "]", "[", "'size'", "]", ">", "g", ".", "nodes", "[", "n2", "]", "[", "'size'", "]", ":", "\n", "            ", "n1", ",", "n2", "=", "n2", ",", "n1", "# smaller node first", "\n", "", "c1", ",", "c2", ",", "ce", "=", "[", "d", "[", "self", ".", "default_cache", "]", "for", "d", "in", "\n", "[", "g", ".", "nodes", "[", "n1", "]", ",", "g", ".", "nodes", "[", "n2", "]", ",", "g", ".", "edges", "[", "n1", ",", "n2", "]", "]", "]", "\n", "return", "np", ".", "concatenate", "(", "(", "\n", "self", ".", "compute_node_features", "(", "g", ",", "n1", ",", "c1", ")", ",", "\n", "self", ".", "compute_node_features", "(", "g", ",", "n2", ",", "c2", ")", ",", "\n", "self", ".", "compute_edge_features", "(", "g", ",", "n1", ",", "n2", ",", "ce", ")", ",", "\n", "self", ".", "compute_difference_features", "(", "g", ",", "n1", ",", "n2", ",", "c1", ",", "c2", ")", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.create_node_cache": [[29, 31], ["numpy.array"], "methods", ["None"], ["", "def", "create_node_cache", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "]", ")", "\n", "", "def", "create_edge_cache", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.create_edge_cache": [[31, 33], ["numpy.array"], "methods", ["None"], ["", "def", "create_edge_cache", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "]", ")", "\n", "", "def", "update_node_cache", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.update_node_cache": [[33, 35], ["None"], "methods", ["None"], ["", "def", "update_node_cache", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "", "def", "update_edge_cache", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.update_edge_cache": [[35, 37], ["None"], "methods", ["None"], ["", "def", "update_edge_cache", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "", "def", "compute_node_features", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.compute_node_features": [[37, 39], ["numpy.array"], "methods", ["None"], ["", "def", "compute_node_features", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "]", ")", "\n", "", "def", "compute_edge_features", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.compute_edge_features": [[39, 41], ["numpy.array"], "methods", ["None"], ["", "def", "compute_edge_features", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "]", ")", "\n", "", "def", "compute_difference_features", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Null.compute_difference_features": [[41, 43], ["numpy.array"], "methods", ["None"], ["", "def", "compute_difference_features", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Composite.__init__": [[46, 49], ["base.Null.__init__"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__"], ["    ", "def", "__init__", "(", "self", ",", "children", "=", "[", "]", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Composite", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "children", "=", "children", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Composite.write_fm": [[50, 54], ["json_fm.update", "child.write_fm"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.update", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.write_fm"], ["", "def", "write_fm", "(", "self", ",", "json_fm", "=", "{", "}", ")", ":", "\n", "        ", "for", "child", "in", "self", ".", "children", ":", "\n", "            ", "json_fm", ".", "update", "(", "child", ".", "write_fm", "(", "json_fm", ")", ")", "\n", "", "return", "json_fm", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Composite.create_node_cache": [[55, 57], ["c.create_node_cache"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.create_node_cache"], ["", "def", "create_node_cache", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "[", "c", ".", "create_node_cache", "(", "*", "args", ",", "**", "kwargs", ")", "for", "c", "in", "self", ".", "children", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Composite.create_edge_cache": [[58, 60], ["c.create_edge_cache"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.create_edge_cache"], ["", "def", "create_edge_cache", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "[", "c", ".", "create_edge_cache", "(", "*", "args", ",", "**", "kwargs", ")", "for", "c", "in", "self", ".", "children", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Composite.update_node_cache": [[61, 64], ["enumerate", "child.update_node_cache"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.update_node_cache"], ["", "def", "update_node_cache", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "dst", ",", "src", ")", ":", "\n", "        ", "for", "i", ",", "child", "in", "enumerate", "(", "self", ".", "children", ")", ":", "\n", "            ", "child", ".", "update_node_cache", "(", "g", ",", "n1", ",", "n2", ",", "dst", "[", "i", "]", ",", "src", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Composite.update_edge_cache": [[65, 68], ["enumerate", "child.update_edge_cache"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.update_edge_cache"], ["", "", "def", "update_edge_cache", "(", "self", ",", "g", ",", "e1", ",", "e2", ",", "dst", ",", "src", ")", ":", "\n", "        ", "for", "i", ",", "child", "in", "enumerate", "(", "self", ".", "children", ")", ":", "\n", "            ", "child", ".", "update_edge_cache", "(", "g", ",", "e1", ",", "e2", ",", "dst", "[", "i", "]", ",", "src", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Composite.compute_node_features": [[69, 75], ["enumerate", "numpy.concatenate", "features.append", "child.compute_node_features"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_node_features"], ["", "", "def", "compute_node_features", "(", "self", ",", "g", ",", "n", ",", "cache", "=", "None", ")", ":", "\n", "        ", "if", "cache", "is", "None", ":", "cache", "=", "g", ".", "nodes", "[", "n", "]", "[", "self", ".", "default_cache", "]", "\n", "features", "=", "[", "]", "\n", "for", "i", ",", "child", "in", "enumerate", "(", "self", ".", "children", ")", ":", "\n", "            ", "features", ".", "append", "(", "child", ".", "compute_node_features", "(", "g", ",", "n", ",", "cache", "[", "i", "]", ")", ")", "\n", "", "return", "np", ".", "concatenate", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Composite.compute_edge_features": [[76, 82], ["enumerate", "numpy.concatenate", "features.append", "child.compute_edge_features"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.compute_edge_features"], ["", "def", "compute_edge_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache", "=", "None", ")", ":", "\n", "        ", "if", "cache", "is", "None", ":", "cache", "=", "g", ".", "edges", "[", "n1", ",", "n2", "]", "[", "self", ".", "default_cache", "]", "\n", "features", "=", "[", "]", "\n", "for", "i", ",", "child", "in", "enumerate", "(", "self", ".", "children", ")", ":", "\n", "            ", "features", ".", "append", "(", "child", ".", "compute_edge_features", "(", "g", ",", "n1", ",", "n2", ",", "cache", "[", "i", "]", ")", ")", "\n", "", "return", "np", ".", "concatenate", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Composite.compute_difference_features": [[83, 91], ["enumerate", "numpy.concatenate", "features.append", "child.compute_difference_features"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_difference_features"], ["", "def", "compute_difference_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache1", "=", "None", ",", "cache2", "=", "None", ")", ":", "\n", "        ", "if", "cache1", "is", "None", ":", "cache1", "=", "g", ".", "nodes", "[", "n1", "]", "[", "self", ".", "default_cache", "]", "\n", "if", "cache2", "is", "None", ":", "cache2", "=", "g", ".", "nodes", "[", "n2", "]", "[", "self", ".", "default_cache", "]", "\n", "features", "=", "[", "]", "\n", "for", "i", ",", "child", "in", "enumerate", "(", "self", ".", "children", ")", ":", "\n", "            ", "features", ".", "append", "(", "child", ".", "compute_difference_features", "(", "\n", "g", ",", "n1", ",", "n2", ",", "cache1", "[", "i", "]", ",", "cache2", "[", "i", "]", ")", ")", "\n", "", "return", "np", ".", "concatenate", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Mock.__init__": [[120, 125], ["base.Null.__init__", "evaluate.contingency_table().toarray", "evaluate.contingency_table"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["def", "__init__", "(", "self", ",", "frag", ",", "gt", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "ctable", "=", "ev", ".", "contingency_table", "(", "frag", ",", "gt", ",", "ignore_seg", "=", "[", "]", ",", "\n", "ignore_gt", "=", "[", "]", ")", ".", "toarray", "(", ")", "\n", "self", ".", "_std", "=", "0.1", "# standard deviation of feature computations", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Mock.eps": [[126, 128], ["numpy.random.randn"], "methods", ["None"], ["", "def", "eps", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "random", ".", "randn", "(", "2", ")", "*", "self", ".", "_std", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Mock.compute_features": [[129, 143], ["numpy.array", "base._compute_delta_vi", "numpy.array", "base.Mock.eps", "len", "len", "numpy.array", "base.Mock.eps", "numpy.array", "base.Mock.eps"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.base._compute_delta_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Mock.eps", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Mock.eps", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base.Mock.eps"], ["", "def", "compute_features", "(", "self", ",", "g", ",", "n1", ",", "n2", "=", "None", ")", ":", "\n", "        ", "if", "n2", "is", "None", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "]", ")", "\n", "", "f1", ",", "f2", "=", "g", ".", "nodes", "[", "n1", "]", "[", "'fragments'", "]", ",", "g", ".", "nodes", "[", "n2", "]", "[", "'fragments'", "]", "\n", "f1", "-=", "{", "g", ".", "boundary_body", "}", "\n", "f2", "-=", "{", "g", ".", "boundary_body", "}", "\n", "should_merge", "=", "_compute_delta_vi", "(", "self", ".", "ctable", ",", "f1", ",", "f2", ")", "<", "0", "\n", "if", "should_merge", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "0.", ",", "0.", "]", ")", "+", "self", ".", "eps", "(", ")", "\n", "", "else", ":", "\n", "            ", "if", "len", "(", "f1", ")", "+", "len", "(", "f2", ")", "==", "2", ":", "# single-fragment merge", "\n", "                ", "return", "np", ".", "array", "(", "[", "1.", ",", "0.", "]", ")", "+", "self", ".", "eps", "(", ")", "\n", "", "else", ":", "# multi-fragment merge", "\n", "                ", "return", "np", ".", "array", "(", "[", "0.", ",", "1.", "]", ")", "+", "self", ".", "eps", "(", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.base._compute_delta_vi": [[93, 105], ["numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "evaluate.xlogx", "evaluate.xlogx", "evaluate.xlogx", "list", "list", "numpy.log2", "numpy.log2", "numpy.log2"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.xlogx", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.xlogx", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.xlogx"], ["", "", "def", "_compute_delta_vi", "(", "ctable", ",", "fragments0", ",", "fragments1", ")", ":", "\n", "    ", "c0", "=", "np", ".", "sum", "(", "ctable", "[", "list", "(", "fragments0", ")", "]", ",", "axis", "=", "0", ")", "\n", "c1", "=", "np", ".", "sum", "(", "ctable", "[", "list", "(", "fragments1", ")", "]", ",", "axis", "=", "0", ")", "\n", "cr", "=", "c0", "+", "c1", "\n", "p0", "=", "np", ".", "sum", "(", "c0", ")", "\n", "p1", "=", "np", ".", "sum", "(", "c1", ")", "\n", "pr", "=", "np", ".", "sum", "(", "cr", ")", "\n", "p0g", "=", "np", ".", "sum", "(", "ev", ".", "xlogx", "(", "c0", ")", ")", "\n", "p1g", "=", "np", ".", "sum", "(", "ev", ".", "xlogx", "(", "c1", ")", ")", "\n", "prg", "=", "np", ".", "sum", "(", "ev", ".", "xlogx", "(", "cr", ")", ")", "\n", "return", "(", "pr", "*", "np", ".", "log2", "(", "pr", ")", "-", "p0", "*", "np", ".", "log2", "(", "p0", ")", "-", "p1", "*", "np", ".", "log2", "(", "p1", ")", "-", "\n", "2", "*", "(", "prg", "-", "p0g", "-", "p1g", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.default.paper_em": [[3, 22], ["moments.Manager", "histogram.Manager", "graph.Manager", "base.Composite"], "function", ["None"], ["def", "paper_em", "(", ")", ":", "\n", "    ", "\"\"\"Return the feature manager used in the PLoS ONE paper.\n\n    This manager was used both for the FIBSEM segmentation (with\n    multi-channel probabilities) and the SNEMI3D segmentation. [1]_\n\n    Returns\n    -------\n    comp : `base.Composite` feature manager\n        The feature manager to use for graph agglomeration.\n\n    References\n    ----------\n    .. [1] http://brainiac2.mit.edu/SNEMI3D/content/gala-serial-2d-watershed\n    \"\"\"", "\n", "fm", "=", "moments", ".", "Manager", "(", ")", "\n", "fh", "=", "histogram", ".", "Manager", "(", "25", ",", "0", ",", "1", ",", "[", "0.1", ",", "0.5", ",", "0.9", "]", ")", "\n", "fg", "=", "graph", ".", "Manager", "(", ")", "\n", "return", "base", ".", "Composite", "(", "children", "=", "[", "fm", ",", "fh", ",", "fg", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.default.snemi3d": [[24, 44], ["moments.Manager", "histogram.Manager", "graph.Manager", "contact.Manager", "base.Composite"], "function", ["None"], ["", "def", "snemi3d", "(", ")", ":", "\n", "    ", "\"\"\"Return the best-performing feature manager for SNEMI3D.\n\n    This correspond's to Neal Donnelly's last submission in 2014 [1]_.\n\n    Returns\n    -------\n    comp : feature manager\n        Same as the `paper_em` manager but including also a `contact`\n        manager.\n\n    References\n    ----------\n    .. [1] http://brainiac2.mit.edu/SNEMI3D/content/gala-new-watersheds\n    \"\"\"", "\n", "fm", "=", "moments", ".", "Manager", "(", ")", "\n", "fh", "=", "histogram", ".", "Manager", "(", "25", ",", "0", ",", "1", ",", "[", "0.1", ",", "0.5", ",", "0.9", "]", ")", "\n", "fg", "=", "graph", ".", "Manager", "(", ")", "\n", "fc", "=", "contact", ".", "Manager", "(", ")", "\n", "return", "base", ".", "Composite", "(", "children", "=", "[", "fm", ",", "fh", ",", "fg", ",", "fc", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.orientation.Manager.__init__": [[6, 8], ["base.Null.__init__"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Manager", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.orientation.Manager.write_fm": [[9, 15], ["json_fm[].append"], "methods", ["None"], ["", "def", "write_fm", "(", "self", ",", "json_fm", "=", "{", "}", ")", ":", "\n", "        ", "if", "'feature_list'", "not", "in", "json_fm", ":", "\n", "            ", "json_fm", "[", "'feature_list'", "]", "=", "[", "]", "\n", "", "json_fm", "[", "'feature_list'", "]", ".", "append", "(", "'orientation'", ")", "\n", "json_fm", "[", "'orientation'", "]", "=", "{", "}", "\n", "return", "json_fm", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.orientation.Manager.create_node_cache": [[16, 34], ["numpy.zeros_like", "numpy.zeros_like.ravel", "numpy.array", "numpy.cov", "float", "numpy.linalg.eig", "list", "numpy.nonzero", "len", "numpy.argsort", "g.extent", "numpy.array", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.extent"], ["", "def", "create_node_cache", "(", "self", ",", "g", ",", "n", ")", ":", "\n", "# Get subscripts of extent (morpho.unravel_index was slow)", "\n", "        ", "M", "=", "np", ".", "zeros_like", "(", "g", ".", "watershed", ")", ";", "\n", "M", ".", "ravel", "(", ")", "[", "list", "(", "g", ".", "extent", "(", "n", ")", ")", "]", "=", "1", "\n", "ind", "=", "np", ".", "array", "(", "np", ".", "nonzero", "(", "M", ")", ")", ".", "T", "\n", "# Get second moment matrix", "\n", "smm", "=", "np", ".", "cov", "(", "ind", ".", "T", ")", "/", "float", "(", "len", "(", "ind", ")", ")", "\n", "try", ":", "\n", "# Get eigenvectors", "\n", "            ", "val", ",", "vec", "=", "eig", "(", "smm", ")", "\n", "idx", "=", "np", ".", "argsort", "(", "val", ")", "[", ":", ":", "-", "1", "]", "\n", "val", "=", "val", "[", "idx", "]", "\n", "vec", "=", "vec", "[", "idx", ",", ":", "]", "\n", "return", "[", "val", ",", "vec", ",", "ind", "]", "\n", "", "except", ":", "\n", "            ", "n", "=", "g", ".", "watershed", ".", "ndim", "\n", "return", "[", "np", ".", "array", "(", "[", "0", "]", "*", "n", ")", ",", "np", ".", "zeros", "(", "(", "n", ",", "n", ")", ")", ",", "ind", "]", "\n", "", "return", "[", "val", ",", "vec", ",", "ind", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.orientation.Manager.create_edge_cache": [[35, 52], ["numpy.zeros_like", "numpy.zeros_like.ravel", "numpy.array", "numpy.cov", "float", "numpy.linalg.eig", "g.boundary", "numpy.nonzero", "len", "numpy.argsort", "numpy.array", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "create_edge_cache", "(", "self", ",", "g", ",", "n1", ",", "n2", ")", ":", "\n", "# Get subscripts of extent (morpho.unravel_index was slow)", "\n", "        ", "M", "=", "np", ".", "zeros_like", "(", "g", ".", "watershed", ")", ";", "\n", "M", ".", "ravel", "(", ")", "[", "g", ".", "boundary", "(", "n1", ",", "n2", ")", "]", "=", "1", "\n", "ind", "=", "np", ".", "array", "(", "np", ".", "nonzero", "(", "M", ")", ")", ".", "T", "\n", "# Get second moment matrix", "\n", "smm", "=", "np", ".", "cov", "(", "ind", ".", "T", ")", "/", "float", "(", "len", "(", "ind", ")", ")", "\n", "try", ":", "\n", "# Get eigenvectors", "\n", "            ", "val", ",", "vec", "=", "eig", "(", "smm", ")", "\n", "idx", "=", "np", ".", "argsort", "(", "val", ")", "[", ":", ":", "-", "1", "]", "\n", "val", "=", "val", "[", "idx", "]", "\n", "vec", "=", "vec", "[", "idx", ",", ":", "]", "\n", "return", "[", "val", ",", "vec", ",", "ind", "]", "\n", "", "except", ":", "\n", "            ", "n", "=", "g", ".", "watershed", ".", "ndim", "\n", "return", "[", "np", ".", "array", "(", "[", "0", "]", "*", "n", ")", ",", "np", ".", "zeros", "(", "(", "n", ",", "n", ")", ")", ",", "ind", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.orientation.Manager.update_node_cache": [[53, 57], ["orientation.Manager.create_node_cache", "enumerate"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.create_node_cache"], ["", "", "def", "update_node_cache", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "dst", ",", "src", ")", ":", "\n", "        ", "c", "=", "self", ".", "create_node_cache", "(", "g", ",", "n1", ")", "\n", "for", "i", ",", "e", "in", "enumerate", "(", "c", ")", ":", "\n", "            ", "dst", "[", "i", "]", "=", "e", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.orientation.Manager.update_edge_cache": [[58, 62], ["orientation.Manager.create_edge_cache", "enumerate"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.create_edge_cache"], ["", "", "def", "update_edge_cache", "(", "self", ",", "g", ",", "e1", ",", "e2", ",", "dst", ",", "src", ")", ":", "\n", "        ", "c", "=", "self", ".", "create_edge_cache", "(", "g", ",", "*", "e1", ")", "\n", "for", "i", ",", "e", "in", "enumerate", "(", "c", ")", ":", "\n", "            ", "dst", "[", "i", "]", "=", "e", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.orientation.Manager.compute_node_features": [[63, 75], ["features.extend", "numpy.array", "features.append", "features.append"], "methods", ["None"], ["", "", "def", "compute_node_features", "(", "self", ",", "g", ",", "n", ",", "cache", "=", "None", ")", ":", "\n", "        ", "if", "cache", "is", "None", ":", "\n", "            ", "cache", "=", "g", ".", "node", "[", "n", "]", "[", "self", ".", "default_cache", "]", "\n", "", "val", "=", "cache", "[", "0", "]", "\n", "features", "=", "[", "]", "\n", "features", ".", "extend", "(", "val", ")", "\n", "# coherence measure", "\n", "if", "val", "[", "0", "]", "==", "0", "and", "val", "[", "1", "]", "==", "0", ":", "\n", "            ", "features", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "features", ".", "append", "(", "(", "(", "val", "[", "0", "]", "-", "val", "[", "1", "]", ")", "/", "(", "val", "[", "0", "]", "+", "val", "[", "1", "]", ")", ")", "**", "2", ")", "\n", "", "return", "np", ".", "array", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.orientation.Manager.compute_edge_features": [[76, 88], ["features.extend", "numpy.array", "features.append", "features.append"], "methods", ["None"], ["", "def", "compute_edge_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache", "=", "None", ")", ":", "\n", "        ", "if", "cache", "is", "None", ":", "\n", "            ", "cache", "=", "g", "[", "n1", "]", "[", "n2", "]", "[", "self", ".", "default_cache", "]", "\n", "", "val", "=", "cache", "[", "0", "]", "\n", "features", "=", "[", "]", "\n", "features", ".", "extend", "(", "val", ")", "\n", "# coherence measure", "\n", "if", "val", "[", "0", "]", "==", "0", "and", "val", "[", "1", "]", "==", "0", ":", "\n", "            ", "features", ".", "append", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "features", ".", "append", "(", "(", "(", "val", "[", "0", "]", "-", "val", "[", "1", "]", ")", "/", "(", "val", "[", "0", "]", "+", "val", "[", "1", "]", ")", ")", "**", "2", ")", "\n", "", "return", "np", ".", "array", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.orientation.Manager.compute_difference_features": [[89, 126], ["ind1.mean", "ind2.mean", "numpy.arccos", "features.append", "numpy.arccos", "numpy.arccos", "features.append", "features.append", "features.append", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm", "min", "min", "min", "min", "max", "numpy.mean", "max", "max", "max", "numpy.dot", "numpy.dot", "numpy.dot"], "methods", ["None"], ["", "def", "compute_difference_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache1", "=", "None", ",", "cache2", "=", "None", ")", ":", "\n", "        ", "if", "cache1", "is", "None", ":", "\n", "            ", "cache1", "=", "g", ".", "node", "[", "n1", "]", "[", "self", ".", "default_cache", "]", "\n", "", "vec1", "=", "cache1", "[", "1", "]", "\n", "ind1", "=", "cache1", "[", "2", "]", "\n", "\n", "if", "cache2", "is", "None", ":", "\n", "            ", "cache2", "=", "g", ".", "node", "[", "n2", "]", "[", "self", ".", "default_cache", "]", "\n", "", "vec2", "=", "cache2", "[", "1", "]", "\n", "ind2", "=", "cache2", "[", "2", "]", "\n", "\n", "v1", "=", "vec1", "[", ":", ",", "0", "]", "\n", "v2", "=", "vec2", "[", ":", ",", "0", "]", "\n", "# Line connecting centroids of regions", "\n", "m1", "=", "ind1", ".", "mean", "(", "axis", "=", "0", ")", "\n", "m2", "=", "ind2", ".", "mean", "(", "axis", "=", "0", ")", "\n", "v3", "=", "m1", "-", "m2", "# move to origin", "\n", "\n", "# Features are angle differences", "\n", "if", "norm", "(", "v1", ")", "!=", "0", ":", "v1", "/=", "norm", "(", "v1", ")", "\n", "if", "norm", "(", "v2", ")", "!=", "0", ":", "v2", "/=", "norm", "(", "v2", ")", "\n", "if", "norm", "(", "v3", ")", "!=", "0", ":", "v3", "/=", "norm", "(", "v3", ")", "\n", "\n", "features", "=", "[", "]", "\n", "ang1", "=", "np", ".", "arccos", "(", "min", "(", "max", "(", "np", ".", "dot", "(", "v1", ",", "v2", ")", ",", "-", "1", ")", ",", "1", ")", ")", "\n", "if", "ang1", ">", "np", ".", "pi", "/", "2.0", ":", "ang1", "=", "np", ".", "pi", "-", "ang1", "\n", "features", ".", "append", "(", "ang1", ")", "\n", "\n", "ang2", "=", "np", ".", "arccos", "(", "min", "(", "max", "(", "np", ".", "dot", "(", "v1", ",", "v3", ")", ",", "-", "1", ")", ",", "1", ")", ")", "\n", "if", "ang2", ">", "np", ".", "pi", "/", "2.0", ":", "ang2", "=", "np", ".", "pi", "-", "ang2", "\n", "ang3", "=", "np", ".", "arccos", "(", "min", "(", "max", "(", "np", ".", "dot", "(", "v2", ",", "v3", ")", ",", "-", "1", ")", ",", "1", ")", ")", "\n", "if", "ang3", ">", "np", ".", "pi", "/", "2.0", ":", "ang3", "=", "np", ".", "pi", "-", "ang3", "\n", "features", ".", "append", "(", "min", "(", "[", "ang2", ",", "ang3", "]", ")", ")", "\n", "features", ".", "append", "(", "max", "(", "[", "ang2", ",", "ang3", "]", ")", ")", "\n", "features", ".", "append", "(", "np", ".", "mean", "(", "[", "ang2", ",", "ang3", "]", ")", ")", "\n", "\n", "return", "np", ".", "array", "(", "features", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.graph.Manager.__init__": [[9, 11], ["base.Null.__init__"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Manager", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.graph.Manager.write_fm": [[12, 18], ["json_fm[].append"], "methods", ["None"], ["", "def", "write_fm", "(", "self", ",", "json_fm", "=", "{", "}", ")", ":", "\n", "        ", "if", "'feature_list'", "not", "in", "json_fm", ":", "\n", "            ", "json_fm", "[", "'feature_list'", "]", "=", "[", "]", "\n", "", "json_fm", "[", "'feature_list'", "]", ".", "append", "(", "'graph'", ")", "\n", "json_fm", "[", "'graph'", "]", "=", "{", "}", "\n", "return", "json_fm", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.graph.Manager.compute_node_features": [[19, 23], ["g.degree", "numpy.array", "networkx.algorithms.average_neighbor_degree"], "methods", ["None"], ["", "def", "compute_node_features", "(", "self", ",", "g", ",", "n", ",", "cache", "=", "None", ")", ":", "\n", "        ", "deg", "=", "g", ".", "degree", "(", "n", ")", "\n", "ndeg", "=", "nx", ".", "algorithms", ".", "average_neighbor_degree", "(", "g", ",", "nodes", "=", "[", "n", "]", ")", "[", "n", "]", "\n", "return", "np", ".", "array", "(", "[", "deg", ",", "ndeg", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.graph.Manager.compute_edge_features": [[24, 28], ["float", "numpy.array", "list", "list", "len", "g.neighbors", "g.neighbors", "numpy.intersect1d"], "methods", ["None"], ["", "def", "compute_edge_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache", "=", "None", ")", ":", "\n", "        ", "nn1", ",", "nn2", "=", "list", "(", "g", ".", "neighbors", "(", "n1", ")", ")", ",", "list", "(", "g", ".", "neighbors", "(", "n2", ")", ")", "\n", "common_neighbors", "=", "float", "(", "len", "(", "np", ".", "intersect1d", "(", "nn1", ",", "nn2", ")", ")", ")", "\n", "return", "np", ".", "array", "(", "[", "common_neighbors", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.graph.Manager.compute_difference_features": [[29, 32], ["graph.Manager.compute_node_features", "graph.Manager.compute_node_features"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_node_features", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_node_features"], ["", "def", "compute_difference_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache1", "=", "None", ",", "cache2", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "compute_node_features", "(", "g", ",", "n1", ",", "cache1", ")", "-", "self", ".", "compute_node_features", "(", "g", ",", "n2", ",", "cache2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.io.create_fm": [[4, 20], ["base.Composite", "len", "RuntimeError", "len", "children.append", "histogram.Manager.load_dict", "children.append", "moments.Manager.load_dict", "children.append", "Exception", "inclusion.Manager.load_dict"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.load_dict", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.load_dict", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.load_dict"], ["def", "create_fm", "(", "fm_info", ")", ":", "\n", "    ", "children", "=", "[", "]", "\n", "for", "feature", "in", "fm_info", "[", "'feature_list'", "]", ":", "\n", "        ", "if", "feature", "==", "\"histogram\"", ":", "\n", "            ", "children", ".", "append", "(", "histogram", ".", "Manager", ".", "load_dict", "(", "fm_info", "[", "feature", "]", ")", ")", "\n", "", "elif", "feature", "==", "\"moments\"", ":", "\n", "            ", "children", ".", "append", "(", "moments", ".", "Manager", ".", "load_dict", "(", "fm_info", "[", "feature", "]", ")", ")", "\n", "", "elif", "feature", "==", "\"inclusiveness\"", ":", "\n", "            ", "children", ".", "append", "(", "inclusion", ".", "Manager", ".", "load_dict", "(", "fm_info", "[", "feature", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\"Feature \"", "+", "feature", "+", "\" not found\"", ")", "\n", "", "", "if", "len", "(", "children", ")", "==", "0", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"No features loaded\"", ")", "\n", "", "if", "len", "(", "children", ")", "==", "1", ":", "\n", "        ", "return", "children", "[", "0", "]", "\n", "", "return", "base", ".", "Composite", "(", "children", "=", "children", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.__init__": [[20, 22], ["base.Null.__init__"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Manager", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.write_fm": [[23, 29], ["json_fm[].append"], "methods", ["None"], ["", "def", "write_fm", "(", "self", ",", "json_fm", "=", "{", "}", ")", ":", "\n", "        ", "if", "'feature_list'", "not", "in", "json_fm", ":", "\n", "            ", "json_fm", "[", "'feature_list'", "]", "=", "[", "]", "\n", "", "json_fm", "[", "'feature_list'", "]", ".", "append", "(", "'convex-hull'", ")", "\n", "json_fm", "[", "'convex-hull'", "]", "=", "{", "}", "\n", "return", "json_fm", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.convex_hull_ind": [[30, 39], ["numpy.zeros_like", "scipy.ndimage.binary_erosion", "numpy.array", "numpy.zeros_like.ravel", "numpy.zeros_like.ravel", "numpy.nonzero", "g.boundary", "list", "g.extent"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.extent"], ["", "def", "convex_hull_ind", "(", "self", ",", "g", ",", "n1", ",", "n2", "=", "None", ")", ":", "\n", "        ", "m", "=", "np", ".", "zeros_like", "(", "g", ".", "watershed", ")", ";", "\n", "if", "n2", "is", "not", "None", ":", "\n", "            ", "m", ".", "ravel", "(", ")", "[", "g", ".", "boundary", "(", "n1", ",", "n2", ")", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "m", ".", "ravel", "(", ")", "[", "list", "(", "g", ".", "extent", "(", "n1", ")", ")", "]", "=", "1", "\n", "", "m", "=", "m", "-", "nd", ".", "binary_erosion", "(", "m", ")", "#Only need border", "\n", "ind", "=", "np", ".", "array", "(", "np", ".", "nonzero", "(", "m", ")", ")", ".", "T", "\n", "return", "ind", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.convex_hull_vol": [[41, 59], ["Delaunay", "abs", "numpy.array.min", "numpy.array.max", "numpy.array", "Delaunay", "numpy.repeat", "list", "numpy.linalg.det", "itertools.product", "float", "scipy.special.factorial", "tuple", "numpy.array"], "methods", ["None"], ["", "def", "convex_hull_vol", "(", "self", ",", "ind", ",", "g", ")", ":", "\n", "# Compute the convex hull of the region", "\n", "        ", "try", ":", "\n", "            ", "tri", "=", "Delaunay", "(", "ind", ")", "\n", "", "except", ":", "\n", "# Just triangulate bounding box", "\n", "            ", "mins", "=", "ind", ".", "min", "(", "axis", "=", "0", ")", "\n", "maxes", "=", "ind", ".", "max", "(", "axis", "=", "0", ")", "\n", "maxes", "[", "maxes", "==", "mins", "]", "+=", "1", "\n", "ind", "=", "np", ".", "array", "(", "list", "(", "it", ".", "product", "(", "*", "tuple", "(", "np", ".", "array", "(", "[", "mins", ",", "maxes", "]", ")", ".", "T", ")", ")", ")", ")", "\n", "tri", "=", "Delaunay", "(", "ind", ")", "\n", "", "vol", "=", "0", "\n", "for", "simplex", "in", "tri", ".", "vertices", ":", "\n", "            ", "pts", "=", "tri", ".", "points", "[", "simplex", "]", ".", "T", "\n", "pts", "=", "pts", "-", "np", ".", "repeat", "(", "pts", "[", ":", ",", "0", "]", "[", ":", ",", "np", ".", "newaxis", "]", ",", "pts", ".", "shape", "[", "1", "]", ",", "axis", "=", "1", ")", "\n", "pts", "=", "pts", "[", ":", ",", "1", ":", "]", "\n", "vol", "+=", "abs", "(", "1", "/", "float", "(", "factorial", "(", "pts", ".", "shape", "[", "0", "]", ")", ")", "*", "det", "(", "pts", ")", ")", "\n", "return", "vol", ",", "tri", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.create_node_cache": [[60, 63], ["convex_hull.Manager.convex_hull_vol", "numpy.array", "convex_hull.Manager.convex_hull_ind"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.convex_hull_vol", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.convex_hull_ind"], ["", "", "def", "create_node_cache", "(", "self", ",", "g", ",", "n", ")", ":", "\n", "        ", "vol", ",", "tri", "=", "self", ".", "convex_hull_vol", "(", "self", ".", "convex_hull_ind", "(", "g", ",", "n", ")", ",", "g", ")", "\n", "return", "np", ".", "array", "(", "[", "tri", ",", "vol", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.create_edge_cache": [[64, 67], ["convex_hull.Manager.convex_hull_vol", "numpy.array", "convex_hull.Manager.convex_hull_ind"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.convex_hull_vol", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.convex_hull_ind"], ["", "def", "create_edge_cache", "(", "self", ",", "g", ",", "n1", ",", "n2", ")", ":", "\n", "        ", "vol", ",", "tri", "=", "self", ".", "convex_hull_vol", "(", "self", ".", "convex_hull_ind", "(", "g", ",", "n1", ",", "n2", ")", ",", "g", ")", "\n", "return", "np", ".", "array", "(", "[", "tri", ",", "vol", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.update_node_cache": [[68, 76], ["numpy.concatenate", "convex_hull.Manager.convex_hull_vol", "numpy.array", "numpy.unique", "numpy.unique", "tri1.convex_hull.ravel", "tri2.convex_hull.ravel"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.convex_hull_vol"], ["", "def", "update_node_cache", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "dst", ",", "src", ")", ":", "\n", "        ", "tri1", "=", "src", "[", "0", "]", "\n", "tri2", "=", "dst", "[", "0", "]", "\n", "ind1", "=", "tri1", ".", "points", "[", "np", ".", "unique", "(", "tri1", ".", "convex_hull", ".", "ravel", "(", ")", ")", "]", "\n", "ind2", "=", "tri2", ".", "points", "[", "np", ".", "unique", "(", "tri2", ".", "convex_hull", ".", "ravel", "(", ")", ")", "]", "\n", "allind", "=", "np", ".", "concatenate", "(", "(", "ind1", ",", "ind2", ")", ")", "\n", "vol", ",", "tri", "=", "self", ".", "convex_hull_vol", "(", "allind", ",", "g", ")", "\n", "dst", "=", "np", ".", "array", "(", "[", "tri", ",", "vol", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.update_edge_cache": [[77, 85], ["numpy.concatenate", "convex_hull.Manager.convex_hull_vol", "numpy.array", "numpy.unique", "numpy.unique", "tri1.convex_hull.ravel", "tri2.convex_hull.ravel"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.convex_hull_vol"], ["", "def", "update_edge_cache", "(", "self", ",", "g", ",", "e1", ",", "e2", ",", "dst", ",", "src", ")", ":", "\n", "        ", "tri1", "=", "src", "[", "0", "]", "\n", "tri2", "=", "dst", "[", "0", "]", "\n", "ind1", "=", "tri1", ".", "points", "[", "np", ".", "unique", "(", "tri1", ".", "convex_hull", ".", "ravel", "(", ")", ")", "]", "\n", "ind2", "=", "tri2", ".", "points", "[", "np", ".", "unique", "(", "tri2", ".", "convex_hull", ".", "ravel", "(", ")", ")", "]", "\n", "allind", "=", "np", ".", "concatenate", "(", "(", "ind1", ",", "ind2", ")", ")", "\n", "vol", ",", "tri", "=", "self", ".", "convex_hull_vol", "(", "allind", ",", "g", ")", "\n", "dst", "=", "np", ".", "array", "(", "[", "tri", ",", "vol", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.compute_node_features": [[86, 94], ["features.append", "features.append", "numpy.array", "float"], "methods", ["None"], ["", "def", "compute_node_features", "(", "self", ",", "g", ",", "n", ",", "cache", "=", "None", ")", ":", "\n", "        ", "if", "cache", "is", "None", ":", "\n", "            ", "cache", "=", "g", ".", "nodes", "[", "n", "]", "[", "self", ".", "default_cache", "]", "\n", "", "convex_vol", "=", "cache", "[", "1", "]", "\n", "features", "=", "[", "]", "\n", "features", ".", "append", "(", "convex_vol", ")", "\n", "features", ".", "append", "(", "convex_vol", "/", "float", "(", "g", ".", "nodes", "[", "n", "]", "[", "'size'", "]", ")", ")", "\n", "return", "np", ".", "array", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.compute_edge_features": [[95, 104], ["features.append", "features.append", "numpy.array", "len", "g.boundary"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "compute_edge_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache", "=", "None", ")", ":", "\n", "        ", "if", "cache", "is", "None", ":", "\n", "            ", "cache", "=", "g", ".", "edges", "[", "n1", ",", "n2", "]", "[", "self", ".", "default_cache", "]", "\n", "", "convex_vol", "=", "cache", "[", "1", "]", "\n", "\n", "features", "=", "[", "]", "\n", "features", ".", "append", "(", "convex_vol", ")", "\n", "features", ".", "append", "(", "convex_vol", "/", "len", "(", "g", ".", "boundary", "(", "n1", ",", "n2", ")", ")", ")", "\n", "return", "np", ".", "array", "(", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.compute_difference_features": [[105, 137], ["numpy.concatenate", "convex_hull.Manager.convex_hull_vol", "float", "float", "float", "features.append", "features.append", "features.append", "features.append", "features.append", "features.append", "features.append", "features.append", "numpy.array", "len", "abs", "abs", "abs", "abs", "numpy.unique", "numpy.unique", "g.boundary", "tri1.convex_hull.ravel", "tri2.convex_hull.ravel"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.convex_hull.Manager.convex_hull_vol", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "compute_difference_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache1", "=", "None", ",", "cache2", "=", "None", ")", ":", "\n", "        ", "if", "cache1", "is", "None", ":", "\n", "            ", "cache1", "=", "g", ".", "nodes", "[", "n1", "]", "[", "self", ".", "default_cache", "]", "\n", "", "tri1", "=", "cache1", "[", "0", "]", "\n", "convex_vol1", "=", "cache1", "[", "1", "]", "\n", "\n", "if", "cache2", "is", "None", ":", "\n", "            ", "cache2", "=", "g", ".", "nodes", "[", "n2", "]", "[", "self", ".", "default_cache", "]", "\n", "", "tri2", "=", "cache2", "[", "0", "]", "\n", "convex_vol2", "=", "cache2", "[", "1", "]", "\n", "\n", "ind1", "=", "tri1", ".", "points", "[", "np", ".", "unique", "(", "tri1", ".", "convex_hull", ".", "ravel", "(", ")", ")", "]", "\n", "ind2", "=", "tri2", ".", "points", "[", "np", ".", "unique", "(", "tri2", ".", "convex_hull", ".", "ravel", "(", ")", ")", "]", "\n", "allind", "=", "np", ".", "concatenate", "(", "(", "ind1", ",", "ind2", ")", ")", "\n", "convex_vol_both", ",", "tri_both", "=", "self", ".", "convex_hull_vol", "(", "allind", ",", "g", ")", "\n", "\n", "vol1", "=", "float", "(", "g", ".", "nodes", "[", "n1", "]", "[", "'size'", "]", ")", "\n", "vol2", "=", "float", "(", "g", ".", "nodes", "[", "n2", "]", "[", "'size'", "]", ")", "\n", "volborder", "=", "float", "(", "len", "(", "g", ".", "boundary", "(", "n1", ",", "n2", ")", ")", ")", "\n", "volboth", "=", "vol1", "+", "vol2", "\n", "\n", "features", "=", "[", "]", "\n", "features", ".", "append", "(", "abs", "(", "convex_vol1", "/", "vol1", "-", "convex_vol2", "/", "vol2", ")", ")", "\n", "features", ".", "append", "(", "abs", "(", "convex_vol1", "/", "vol1", "-", "convex_vol_both", "/", "volboth", ")", ")", "\n", "features", ".", "append", "(", "abs", "(", "convex_vol2", "/", "vol2", "-", "convex_vol_both", "/", "volboth", ")", ")", "\n", "features", ".", "append", "(", "abs", "(", "convex_vol_both", "/", "volboth", ")", ")", "\n", "features", ".", "append", "(", "(", "convex_vol1", "*", "vol2", ")", "/", "(", "convex_vol2", "*", "vol1", ")", ")", "\n", "features", ".", "append", "(", "volborder", "/", "vol1", ")", "\n", "features", ".", "append", "(", "volborder", "/", "vol2", ")", "\n", "features", ".", "append", "(", "volborder", "/", "volboth", ")", "\n", "\n", "return", "np", ".", "array", "(", "features", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.__init__": [[5, 7], ["base.Null.__init__"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Manager", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.load_dict": [[8, 12], ["cls"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "load_dict", "(", "cls", ",", "fm_info", ")", ":", "\n", "        ", "obj", "=", "cls", "(", ")", "\n", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.write_fm": [[13, 19], ["json_fm[].append"], "methods", ["None"], ["", "def", "write_fm", "(", "self", ",", "json_fm", "=", "{", "}", ")", ":", "\n", "        ", "if", "'feature_list'", "not", "in", "json_fm", ":", "\n", "            ", "json_fm", "[", "'feature_list'", "]", "=", "[", "]", "\n", "", "json_fm", "[", "'feature_list'", "]", ".", "append", "(", "'inclusiveness'", ")", "\n", "json_fm", "[", "'inclusiveness'", "]", "=", "{", "}", "\n", "return", "json_fm", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_node_features": [[20, 28], ["sorted", "numpy.array", "float", "float", "len", "sum", "float", "float", "g.boundary", "g.neighbors"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "compute_node_features", "(", "self", ",", "g", ",", "n", ",", "cache", "=", "None", ")", ":", "\n", "        ", "bd_lengths", "=", "sorted", "(", "[", "len", "(", "g", ".", "boundary", "(", "n", ",", "x", ")", ")", "for", "x", "in", "g", ".", "neighbors", "(", "n", ")", "]", ")", "\n", "ratio1", "=", "float", "(", "bd_lengths", "[", "-", "1", "]", ")", "/", "float", "(", "sum", "(", "bd_lengths", ")", ")", "\n", "try", ":", "\n", "            ", "ratio2", "=", "float", "(", "bd_lengths", "[", "-", "2", "]", ")", "/", "float", "(", "bd_lengths", "[", "-", "1", "]", ")", "\n", "", "except", "IndexError", ":", "\n", "            ", "ratio2", "=", "0.0", "\n", "", "return", "np", ".", "array", "(", "[", "ratio1", ",", "ratio2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_edge_features": [[29, 40], ["sorted", "sorted", "len", "ratios1.sort", "ratios2.sort", "numpy.concatenate", "g.boundary", "len", "len", "sum", "sum", "max", "max", "g.boundary", "g.neighbors", "g.boundary", "g.neighbors"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "compute_edge_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache", "=", "None", ")", ":", "\n", "        ", "bd_lengths1", "=", "sorted", "(", "[", "len", "(", "g", ".", "boundary", "(", "n1", ",", "x", ")", ")", "\n", "for", "x", "in", "g", ".", "neighbors", "(", "n1", ")", "]", ")", "\n", "bd_lengths2", "=", "sorted", "(", "[", "len", "(", "g", ".", "boundary", "(", "n2", ",", "x", ")", ")", "\n", "for", "x", "in", "g", ".", "neighbors", "(", "n2", ")", "]", ")", "\n", "boundlen", "=", "len", "(", "g", ".", "boundary", "(", "n1", ",", "n2", ")", ")", "\n", "ratios1", "=", "[", "boundlen", "/", "sum", "(", "bd_lengths1", ")", ",", "boundlen", "/", "sum", "(", "bd_lengths2", ")", "]", "\n", "ratios1", ".", "sort", "(", ")", "\n", "ratios2", "=", "[", "boundlen", "/", "max", "(", "bd_lengths1", ")", ",", "boundlen", "/", "max", "(", "bd_lengths2", ")", "]", "\n", "ratios2", ".", "sort", "(", ")", "\n", "return", "np", ".", "concatenate", "(", "(", "ratios1", ",", "ratios2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_difference_features": [[41, 44], ["inclusion.Manager.compute_node_features", "inclusion.Manager.compute_node_features"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_node_features", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.inclusion.Manager.compute_node_features"], ["", "def", "compute_difference_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache1", "=", "None", ",", "cache2", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "compute_node_features", "(", "g", ",", "n1", ",", "cache1", ")", "-", "self", ".", "compute_node_features", "(", "g", ",", "n2", ",", "cache2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__": [[13, 16], ["base.Null.__init__"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.__init__"], ["    ", "def", "__init__", "(", "self", ",", "ndim", "=", "3", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Manager", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "ndim", "=", "ndim", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.write_fm": [[17, 23], ["json_fm[].append"], "methods", ["None"], ["", "def", "write_fm", "(", "self", ",", "json_fm", "=", "{", "}", ")", ":", "\n", "        ", "if", "'feature_list'", "not", "in", "json_fm", ":", "\n", "            ", "json_fm", "[", "'feature_list'", "]", "=", "[", "]", "\n", "", "json_fm", "[", "'feature_list'", "]", ".", "append", "(", "'squiggliness'", ")", "\n", "json_fm", "[", "'squiggliness'", "]", "=", "{", "'ndim'", ":", "self", ".", "ndim", "}", "\n", "return", "json_fm", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.create_edge_cache": [[25, 29], ["g.boundary", "numpy.concatenate", "squiggliness.compute_bounding_box"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary", "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.compute_bounding_box"], ["", "def", "create_edge_cache", "(", "self", ",", "g", ",", "n1", ",", "n2", ")", ":", "\n", "        ", "edge_idxs", "=", "g", ".", "boundary", "(", "n1", ",", "n2", ")", "\n", "return", "np", ".", "concatenate", "(", "\n", "compute_bounding_box", "(", "edge_idxs", ",", "g", ".", "watershed", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.update_edge_cache": [[30, 37], ["numpy.concatenate().min", "numpy.concatenate().max", "numpy.concatenate", "numpy.concatenate"], "methods", ["None"], ["", "def", "update_edge_cache", "(", "self", ",", "g", ",", "e1", ",", "e2", ",", "dst", ",", "src", ")", ":", "\n", "        ", "dst", "[", ":", "self", ".", "ndim", "]", "=", "np", ".", "concatenate", "(", "\n", "(", "dst", "[", "np", ".", "newaxis", ",", ":", "self", ".", "ndim", "]", ",", "src", "[", "np", ".", "newaxis", ",", ":", "self", ".", "ndim", "]", ")", ",", "\n", "axis", "=", "0", ")", ".", "min", "(", "axis", "=", "0", ")", "\n", "dst", "[", "self", ".", "ndim", ":", "]", "=", "np", ".", "concatenate", "(", "\n", "(", "dst", "[", "np", ".", "newaxis", ",", "self", ".", "ndim", ":", "]", ",", "src", "[", "np", ".", "newaxis", ",", "self", ".", "ndim", ":", "]", ")", ",", "\n", "axis", "=", "0", ")", ".", "max", "(", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.Manager.compute_edge_features": [[38, 44], ["numpy.array", "[].prod", "len", "numpy.sort", "set", "g.boundary"], "methods", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.boundary"], ["", "def", "compute_edge_features", "(", "self", ",", "g", ",", "n1", ",", "n2", ",", "cache", "=", "None", ")", ":", "\n", "        ", "if", "cache", "is", "None", ":", "\n", "            ", "cache", "=", "g", "[", "n1", "]", "[", "n2", "]", "[", "self", ".", "default_cache", "]", "\n", "", "m", ",", "M", "=", "cache", "[", ":", "self", ".", "ndim", "]", ",", "cache", "[", "self", ".", "ndim", ":", "]", "\n", "plane_surface", "=", "np", ".", "sort", "(", "M", "-", "m", ")", "[", "1", ":", "]", ".", "prod", "(", ")", "*", "(", "3.0", "-", "g", ".", "pad_thickness", ")", "\n", "return", "np", ".", "array", "(", "[", "len", "(", "set", "(", "g", ".", "boundary", "(", "n1", ",", "n2", ")", ")", ")", "/", "plane_surface", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.features.squiggliness.compute_bounding_box": [[4, 11], ["len", "numpy.concatenate().reshape", "np.concatenate().reshape.min", "np.concatenate().reshape.max", "numpy.ones", "numpy.concatenate", "numpy.unravel_index", "list"], "function", ["None"], ["def", "compute_bounding_box", "(", "indices", ",", "shape", ")", ":", "\n", "    ", "d", "=", "len", "(", "shape", ")", "\n", "unraveled_indices", "=", "np", ".", "concatenate", "(", "\n", "np", ".", "unravel_index", "(", "list", "(", "indices", ")", ",", "shape", ")", ")", ".", "reshape", "(", "(", "-", "1", ",", "d", ")", ",", "order", "=", "'F'", ")", "\n", "m", "=", "unraveled_indices", ".", "min", "(", "axis", "=", "0", ")", "\n", "M", "=", "unraveled_indices", ".", "max", "(", "axis", "=", "0", ")", "+", "np", ".", "ones", "(", "d", ")", "\n", "return", "m", ",", "M", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_2_connectivity": [[26, 33], ["numpy.array", "numpy.array", "gala.agglo.Rag", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "gala.agglo.boundary_mean", "gala.agglo.boundary_mean", "gala.agglo.boundary_mean"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean"], ["def", "test_2_connectivity", "(", ")", ":", "\n", "    ", "p", "=", "np", ".", "array", "(", "[", "[", "1.", ",", "0.", "]", ",", "[", "0.", ",", "1.", "]", "]", ")", "\n", "ws", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", "]", ",", "[", "3", ",", "4", "]", "]", ",", "np", ".", "uint32", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "ws", ",", "p", ",", "connectivity", "=", "2", ",", "use_slow", "=", "True", ")", "\n", "assert_equal", "(", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "1", ",", "2", "]", "]", ")", ",", "[", "0.5", "]", ")", "\n", "assert_equal", "(", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "1", ",", "4", "]", "]", ")", ",", "[", "1.0", "]", ")", "\n", "assert_equal", "(", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "1", ",", "2", "]", ",", "[", "1", ",", "4", "]", "]", ")", ",", "[", "0.5", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_float_watershed": [[34, 42], ["numpy.array", "numpy.array", "gala.agglo.Rag", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "gala.agglo.boundary_mean", "gala.agglo.boundary_mean", "gala.agglo.boundary_mean"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean"], ["", "def", "test_float_watershed", "(", ")", ":", "\n", "    ", "\"\"\"Ensure float arrays passed as watersheds don't crash everything.\"\"\"", "\n", "p", "=", "np", ".", "array", "(", "[", "[", "1.", ",", "0.", "]", ",", "[", "0.", ",", "1.", "]", "]", ")", "\n", "ws", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", "]", ",", "[", "3", ",", "4", "]", "]", ",", "np", ".", "float32", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "ws", ",", "p", ",", "connectivity", "=", "2", ",", "use_slow", "=", "True", ")", "\n", "assert_equal", "(", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "1", ",", "2", "]", "]", ")", "[", "0", "]", ",", "0.5", ")", "\n", "assert_equal", "(", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "1", ",", "4", "]", "]", ")", "[", "0", "]", ",", "1.0", ")", "\n", "assert_equal", "(", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "1", ",", "2", "]", ",", "[", "1", ",", "4", "]", "]", ")", ",", "[", "0.5", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_empty_rag": [[44, 48], ["gala.agglo.Rag", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "list", "list", "agglo.Rag.nodes", "agglo.Rag.copy().nodes", "agglo.Rag.copy"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.copy"], ["", "def", "test_empty_rag", "(", ")", ":", "\n", "    ", "g", "=", "agglo", ".", "Rag", "(", ")", "\n", "assert_equal", "(", "list", "(", "g", ".", "nodes", "(", ")", ")", ",", "[", "]", ")", "\n", "assert_equal", "(", "list", "(", "g", ".", "copy", "(", ")", ".", "nodes", "(", ")", ")", ",", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_agglomeration": [[50, 57], ["gala.agglo.Rag", "agglo.Rag.agglomerate", "numpy.testing.assert_allclose", "gala.evaluate.vi", "agglo.Rag.get_segmentation"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation"], ["", "def", "test_agglomeration", "(", ")", ":", "\n", "    ", "i", "=", "1", "\n", "g", "=", "agglo", ".", "Rag", "(", "wss", "[", "i", "]", ",", "probs", "[", "i", "]", ",", "agglo", ".", "boundary_mean", ",", "\n", "normalize_probabilities", "=", "True", ")", "\n", "g", ".", "agglomerate", "(", "0.51", ")", "\n", "assert_allclose", "(", "ev", ".", "vi", "(", "g", ".", "get_segmentation", "(", ")", ",", "results", "[", "i", "]", ")", ",", "0.0", ",", "\n", "err_msg", "=", "'Mean agglomeration failed.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_ladder_agglomeration": [[59, 68], ["gala.agglo.Rag", "agglo.Rag.agglomerate_ladder", "agglo.Rag.agglomerate", "numpy.testing.assert_allclose", "gala.evaluate.vi", "agglo.Rag.get_segmentation"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate_ladder", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation"], ["", "def", "test_ladder_agglomeration", "(", ")", ":", "\n", "    ", "i", "=", "2", "\n", "g", "=", "agglo", ".", "Rag", "(", "wss", "[", "i", "]", ",", "probs", "[", "i", "]", ",", "agglo", ".", "boundary_mean", ",", "\n", "normalize_probabilities", "=", "True", ",", "use_slow", "=", "True", ",", "\n", "update_unchanged_edges", "=", "True", ")", "\n", "g", ".", "agglomerate_ladder", "(", "3", ")", "\n", "g", ".", "agglomerate", "(", "0.51", ")", "\n", "assert_allclose", "(", "ev", ".", "vi", "(", "g", ".", "get_segmentation", "(", ")", ",", "results", "[", "i", "]", ")", ",", "0.0", ",", "\n", "err_msg", "=", "'Ladder agglomeration failed.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_no_dam_agglomeration": [[69, 76], ["gala.agglo.Rag", "agglo.Rag.agglomerate", "numpy.testing.assert_allclose", "gala.evaluate.vi", "agglo.Rag.get_segmentation"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation"], ["", "def", "test_no_dam_agglomeration", "(", ")", ":", "\n", "    ", "i", "=", "3", "\n", "g", "=", "agglo", ".", "Rag", "(", "wss", "[", "i", "]", ",", "probs", "[", "i", "]", ",", "agglo", ".", "boundary_mean", ",", "\n", "normalize_probabilities", "=", "True", ")", "\n", "g", ".", "agglomerate", "(", "0.75", ")", "\n", "assert_allclose", "(", "ev", ".", "vi", "(", "g", ".", "get_segmentation", "(", ")", ",", "results", "[", "i", "]", ")", ",", "0.0", ",", "\n", "err_msg", "=", "'No dam agglomeration failed.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_mito": [[78, 92], ["gala.agglo.Rag", "agglo.Rag.agglomerate", "agglo.Rag.rebuild_merge_queue", "agglo.Rag.agglomerate", "numpy.testing.assert_allclose", "gala.agglo.no_mito_merge", "gala.evaluate.vi", "agglo.Rag.get_segmentation"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.rebuild_merge_queue", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.no_mito_merge", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation"], ["", "def", "test_mito", "(", ")", ":", "\n", "    ", "i", "=", "5", "\n", "def", "frozen", "(", "g", ",", "i", ")", ":", "\n", "        ", "\"hardcoded frozen nodes representing mitochondria\"", "\n", "return", "i", "in", "[", "3", ",", "4", "]", "\n", "", "g", "=", "agglo", ".", "Rag", "(", "wss", "[", "i", "]", ",", "probs", "[", "i", "]", ",", "agglo", ".", "no_mito_merge", "(", "agglo", ".", "boundary_mean", ")", ",", "\n", "normalize_probabilities", "=", "True", ",", "isfrozennode", "=", "frozen", ",", "\n", "use_slow", "=", "True", ")", "\n", "g", ".", "agglomerate", "(", "0.15", ")", "\n", "g", ".", "merge_priority_function", "=", "agglo", ".", "mito_merge", "\n", "g", ".", "rebuild_merge_queue", "(", ")", "\n", "g", ".", "agglomerate", "(", "1.0", ")", "\n", "assert_allclose", "(", "ev", ".", "vi", "(", "g", ".", "get_segmentation", "(", ")", ",", "results", "[", "i", "]", ")", ",", "0.0", ",", "\n", "err_msg", "=", "'Mito merge failed'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_mask": [[94, 105], ["numpy.array", "gala.agglo.Rag", "agglo.Rag.edges", "agglo.Rag.edges", "agglo.Rag.edges", "agglo.Rag.edges"], "function", ["None"], ["", "def", "test_mask", "(", ")", ":", "\n", "    ", "i", "=", "1", "\n", "mask", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", "]", "]", ",", "dtype", "=", "bool", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "wss", "[", "i", "]", ",", "probs", "[", "i", "]", ",", "mask", "=", "mask", ")", "\n", "assert", "3", "not", "in", "g", "\n", "assert", "(", "1", ",", "2", ")", "in", "g", ".", "edges", "(", ")", "\n", "assert", "(", "1", ",", "5", ")", "in", "g", ".", "edges", "(", ")", "or", "(", "5", ",", "1", ")", "in", "g", ".", "edges", "(", ")", "\n", "assert", "(", "2", ",", "4", ")", "in", "g", ".", "edges", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_traverse": [[107, 114], ["gala.agglo.Rag", "numpy.array", "agglo.Rag.traversing_bodies", "agglo.Rag.non_traversing_bodies"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.traversing_bodies", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.non_traversing_bodies"], ["", "def", "test_traverse", "(", ")", ":", "\n", "    ", "labels", "=", "[", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "[", "0", ",", "1", ",", "2", "]", "]", "\n", "g", "=", "agglo", ".", "Rag", "(", "np", ".", "array", "(", "labels", ")", ")", "\n", "assert", "g", ".", "traversing_bodies", "(", ")", "==", "[", "1", "]", "\n", "assert", "g", ".", "non_traversing_bodies", "(", ")", "==", "[", "0", ",", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_thin_fragment_agglo2": [[116, 120], ["numpy.array", "gala.agglo2.Rag", "agglo2.Rag.graph.edges"], "function", ["None"], ["", "def", "test_thin_fragment_agglo2", "(", ")", ":", "\n", "    ", "labels", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", ",", "3", "]", "]", "*", "3", ")", "\n", "g", "=", "agglo2", ".", "Rag", "(", "labels", ")", "\n", "assert", "(", "1", ",", "3", ")", "not", "in", "g", ".", "graph", ".", "edges", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_best_possible_segmentation": [[122, 127], ["numpy.array", "numpy.array", "gala.agglo.best_possible_segmentation", "numpy.all"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.best_possible_segmentation"], ["", "def", "test_best_possible_segmentation", "(", ")", ":", "\n", "    ", "ws", "=", "np", ".", "array", "(", "[", "[", "2", ",", "3", "]", ",", "[", "4", ",", "5", "]", "]", ",", "np", ".", "int32", ")", "\n", "gt", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", "]", ",", "[", "1", ",", "2", "]", "]", ",", "np", ".", "int32", ")", "\n", "best", "=", "agglo", ".", "best_possible_segmentation", "(", "ws", ",", "gt", ")", "\n", "assert", "np", ".", "all", "(", "best", "[", "0", ",", ":", "]", "==", "best", "[", "1", ",", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_set_ground_truth": [[129, 135], ["gala.agglo.Rag", "agglo.Rag.set_ground_truth", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_ground_truth"], ["", "def", "test_set_ground_truth", "(", ")", ":", "\n", "    ", "labels", "=", "[", "[", "1", ",", "0", ",", "2", "]", ",", "\n", "[", "1", ",", "0", ",", "2", "]", ",", "\n", "[", "1", ",", "0", ",", "2", "]", "]", "\n", "g", "=", "agglo", ".", "Rag", "(", "np", ".", "array", "(", "labels", ")", ")", "\n", "g", ".", "set_ground_truth", "(", "np", ".", "array", "(", "labels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_split_vi": [[137, 146], ["gala.agglo.Rag", "agglo.Rag.split_vi", "agglo.Rag.set_ground_truth", "agglo.Rag.split_vi", "numpy.all", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.set_ground_truth", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi"], ["", "def", "test_split_vi", "(", ")", ":", "\n", "    ", "labels", "=", "[", "[", "1", ",", "0", ",", "2", "]", ",", "\n", "[", "1", ",", "0", ",", "2", "]", ",", "\n", "[", "1", ",", "0", ",", "2", "]", "]", "\n", "g", "=", "agglo", ".", "Rag", "(", "np", ".", "array", "(", "labels", ")", ")", "\n", "vi0", "=", "g", ".", "split_vi", "(", "np", ".", "array", "(", "labels", ")", ")", "\n", "g", ".", "set_ground_truth", "(", "np", ".", "array", "(", "labels", ")", ")", "\n", "vi1", "=", "g", ".", "split_vi", "(", ")", "\n", "assert", "np", ".", "all", "(", "vi0", "==", "vi1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.dummy_data": [[148, 164], ["numpy.arange().reshape", "numpy.array", "scipy.ndimage.zoom", "scipy.ndimage.zoom", "gala.agglo.Rag", "numpy.array", "numpy.arange"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "dummy_data", "(", ")", ":", "\n", "    ", "frag", "=", "np", ".", "arange", "(", "1", ",", "17", ",", "dtype", "=", "int", ")", ".", "reshape", "(", "(", "4", ",", "4", ")", ")", "\n", "gt", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "2", ",", "2", "]", ",", "[", "1", ",", "1", ",", "2", ",", "2", "]", ",", "[", "3", "]", "*", "4", ",", "[", "3", "]", "*", "4", "]", ",", "dtype", "=", "int", ")", "\n", "pr", "=", "0.1", "*", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", ",", "9", ",", "7", ",", "0", ",", "2", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "9", ",", "7", ",", "0", ",", "2", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "9", ",", "7", ",", "0", ",", "2", ",", "0", "]", ",", "\n", "[", "9", ",", "8", ",", "7", ",", "9", ",", "7", ",", "8", ",", "9", ",", "9", "]", ",", "\n", "[", "9", ",", "8", ",", "7", ",", "9", ",", "7", ",", "8", ",", "9", ",", "9", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "frag", "=", "ndi", ".", "zoom", "(", "frag", ",", "2", ",", "order", "=", "0", ")", "\n", "gt", "=", "ndi", ".", "zoom", "(", "gt", ",", "2", ",", "order", "=", "0", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "frag", ",", "pr", ",", "merge_priority_function", "=", "agglo", ".", "boundary_mean", ")", "\n", "return", "frag", ",", "gt", ",", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_manual_agglo_fast_rag": [[166, 183], ["g.merge_subgraph", "g.merge_subgraph", "numpy.allclose", "g.merge_subgraph", "g.merge_nodes", "range", "set.union", "set.union", "set.union", "gala.agglo.boundary_mean", "gala.agglo.boundary_mean", "gala.agglo.boundary_mean", "gala.agglo.boundary_mean"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_subgraph", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_subgraph", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_subgraph", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.boundary_mean"], ["", "def", "test_manual_agglo_fast_rag", "(", "dummy_data", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "g", "=", "dummy_data", "\n", "assert", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "6", ",", "7", "]", "]", ")", "[", "0", "]", "==", "0.8", "\n", "assert", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "6", ",", "10", "]", "]", ")", "[", "0", "]", "==", "0.8", "\n", "original_ids_0", "=", "[", "g", "[", "u", "]", "[", "v", "]", "[", "'boundary-ids'", "]", "for", "u", ",", "v", "in", "[", "(", "5", ",", "9", ")", ",", "(", "6", ",", "10", ")", "]", "]", "\n", "original_ids_1", "=", "[", "g", "[", "u", "]", "[", "v", "]", "[", "'boundary-ids'", "]", "for", "u", ",", "v", "in", "[", "(", "7", ",", "11", ")", ",", "(", "8", ",", "12", ")", "]", "]", "\n", "original_ids_2", "=", "[", "g", "[", "u", "]", "[", "v", "]", "[", "'boundary-ids'", "]", "for", "u", ",", "v", "in", "[", "(", "2", ",", "3", ")", ",", "(", "6", ",", "7", ")", "]", "]", "\n", "g", ".", "merge_subgraph", "(", "[", "1", ",", "2", ",", "5", ",", "6", "]", ")", "# results in node ID 20", "\n", "assert", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "20", ",", "10", "]", "]", ")", "[", "0", "]", "==", "0.8", "\n", "g", ".", "merge_subgraph", "(", "range", "(", "9", ",", "17", ")", ")", "\n", "assert", "g", "[", "20", "]", "[", "27", "]", "[", "'boundary-ids'", "]", "==", "set", ".", "union", "(", "*", "original_ids_0", ")", "\n", "assert", "np", ".", "allclose", "(", "agglo", ".", "boundary_mean", "(", "g", ",", "[", "[", "20", ",", "27", "]", "]", ")", "[", "0", "]", ",", "0.8", ",", "atol", "=", "0.02", ")", "\n", "g", ".", "merge_subgraph", "(", "[", "3", ",", "4", ",", "7", ",", "8", "]", ")", "\n", "assert", "g", "[", "27", "]", "[", "30", "]", "[", "'boundary-ids'", "]", "==", "set", ".", "union", "(", "*", "original_ids_1", ")", "\n", "g", ".", "merge_nodes", "(", "27", ",", "30", ")", "\n", "assert", "g", "[", "20", "]", "[", "31", "]", "[", "'boundary-ids'", "]", "==", "set", ".", "union", "(", "*", "(", "original_ids_0", "+", "\n", "original_ids_2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_agglo.test_mean_agglo_fast_rag": [[185, 189], ["g.agglomerate", "gala.evaluate.vi", "g.get_segmentation"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation"], ["", "def", "test_mean_agglo_fast_rag", "(", "dummy_data", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "g", "=", "dummy_data", "\n", "g", ".", "agglomerate", "(", "0.5", ")", "\n", "assert", "ev", ".", "vi", "(", "g", ".", "get_segmentation", "(", ")", ",", "gt", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_imio.test_cremi_roundtrip": [[7, 22], ["numpy.random.randint", "numpy.random.randint", "range", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "np.random.randint.sort", "skimage._shared._tempfile.temporary_file", "gala.imio.write_cremi", "gala.imio.read_cremi", "h5py.File", "h5py.File.close"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_cremi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_cremi"], ["def", "test_cremi_roundtrip", "(", ")", ":", "\n", "    ", "raw_image", "=", "np", ".", "random", ".", "randint", "(", "256", ",", "size", "=", "(", "5", ",", "100", ",", "100", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "labels", "=", "np", ".", "random", ".", "randint", "(", "4096", ",", "size", "=", "raw_image", ".", "shape", ",", "dtype", "=", "np", ".", "uint64", ")", "\n", "for", "ax", "in", "range", "(", "labels", ".", "ndim", ")", ":", "\n", "        ", "labels", ".", "sort", "(", "axis", "=", "ax", ")", "# try to get something vaguely contiguous. =P", "\n", "", "with", "temporary_file", "(", "'.hdf'", ")", "as", "fout", ":", "\n", "        ", "imio", ".", "write_cremi", "(", "{", "'/volumes/raw'", ":", "raw_image", ",", "\n", "'/volumes/labels/neuron_ids'", ":", "labels", "}", ",", "fout", ")", "\n", "raw_in", ",", "lab_in", "=", "imio", ".", "read_cremi", "(", "fout", ")", "\n", "f", "=", "h5py", ".", "File", "(", "fout", ")", "\n", "stored_resolution", "=", "f", "[", "'/volumes/raw'", "]", ".", "attrs", "[", "'resolution'", "]", "\n", "f", ".", "close", "(", ")", "\n", "", "np", ".", "testing", ".", "assert_equal", "(", "stored_resolution", ",", "(", "40", ",", "4", ",", "4", ")", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "raw_in", ",", "raw_image", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "lab_in", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_imio.test_vtk_roundtrip": [[24, 37], ["range", "numpy.random.randint", "list", "numpy.random.choice", "numpy.issubdtype", "numpy.testing.assert_equal", "gala.imio.numpy_type_to_vtk_string.keys", "numpy.random.randint().astype", "numpy.random.rand().astype", "skimage._shared._tempfile.temporary_file", "gala.imio.write_vtk", "gala.imio.read_vtk", "numpy.random.randint", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.write_vtk", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_vtk"], ["", "def", "test_vtk_roundtrip", "(", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "ar_shape", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "50", ",", "size", "=", "3", ")", "\n", "dtypes", "=", "list", "(", "imio", ".", "numpy_type_to_vtk_string", ".", "keys", "(", ")", ")", "\n", "cur_dtype", "=", "np", ".", "random", ".", "choice", "(", "dtypes", ")", "\n", "if", "np", ".", "issubdtype", "(", "cur_dtype", ",", "np", ".", "integer", ")", ":", "\n", "            ", "ar", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "127", ",", "size", "=", "ar_shape", ")", ".", "astype", "(", "cur_dtype", ")", "\n", "", "else", ":", "\n", "            ", "ar", "=", "np", ".", "random", ".", "rand", "(", "*", "ar_shape", ")", ".", "astype", "(", "cur_dtype", ")", "\n", "", "with", "temporary_file", "(", "'.vtk'", ")", "as", "fout", ":", "\n", "            ", "imio", ".", "write_vtk", "(", "ar", ",", "fout", ")", "\n", "ar_in", "=", "imio", ".", "read_vtk", "(", "fout", ")", "\n", "", "np", ".", "testing", ".", "assert_equal", "(", "ar", ",", "ar_in", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_evaluate.test_contingency_table": [[5, 16], ["numpy.array", "numpy.array", "gala.evaluate.contingency_table", "gala.evaluate.contingency_table", "ev.contingency_table.todense", "numpy.testing.assert_equal", "numpy.array"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.contingency_table"], ["def", "test_contingency_table", "(", ")", ":", "\n", "    ", "seg", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "1", ",", "1", ",", "2", ",", "2", ",", "2", ",", "3", "]", ")", "\n", "gt", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "2", ",", "2", ",", "2", ",", "2", ",", "0", "]", ")", "\n", "ct", "=", "ev", ".", "contingency_table", "(", "seg", ",", "gt", ",", "ignore_seg", "=", "[", "]", ",", "ignore_gt", "=", "[", "]", ")", "\n", "ct0", "=", "ev", ".", "contingency_table", "(", "seg", ",", "gt", ",", "ignore_seg", "=", "[", "0", "]", ",", "ignore_gt", "=", "[", "0", "]", ")", "\n", "ctd", "=", "ct", ".", "todense", "(", ")", "\n", "assert_equal", "(", "ctd", ",", "np", ".", "array", "(", "[", "[", "0.", ",", "0.125", ",", "0.", "]", ",", "\n", "[", "0.", ",", "0.25", ",", "0.125", "]", ",", "\n", "[", "0.", ",", "0.", ",", "0.375", "]", ",", "\n", "[", "0.125", ",", "0.", ",", "0.", "]", "]", ")", ")", "\n", "assert", "ct", ".", "shape", "==", "ct0", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_evaluate.test_vi": [[18, 22], ["numpy.array", "numpy.array", "numpy.testing.assert_equal", "gala.evaluate.vi"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi"], ["", "def", "test_vi", "(", ")", ":", "\n", "    ", "seg", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "gt", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "8", ",", "8", "]", ")", "\n", "assert_equal", "(", "ev", ".", "vi", "(", "seg", ",", "gt", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_evaluate.test_are": [[23, 27], ["numpy.array", "numpy.array", "numpy.testing.assert_almost_equal", "gala.evaluate.adapted_rand_error"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.adapted_rand_error"], ["", "def", "test_are", "(", ")", ":", "\n", "    ", "seg", "=", "np", ".", "array", "(", "[", "[", "2", ",", "1", "]", ",", "[", "1", ",", "2", "]", "]", ")", "\n", "gt", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", "]", ",", "[", "3", ",", "1", "]", "]", ")", "\n", "assert_almost_equal", "(", "(", "ev", ".", "adapted_rand_error", "(", "seg", ",", "gt", ")", ")", ",", "0.3333333", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_defaults.test_paper_em": [[42, 46], ["gala.features.default.paper_em", "gala.agglo.Rag", "numpy.testing.assert_allclose", "default.paper_em."], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.default.paper_em"], ["def", "test_paper_em", "(", ")", ":", "\n", "    ", "feat", "=", "default", ".", "paper_em", "(", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "ws", ",", "prob", ",", "feature_manager", "=", "feat", ",", "use_slow", "=", "True", ")", "\n", "assert_allclose", "(", "feat", "(", "g", ",", "1", ",", "2", ")", ",", "ans12", ",", "atol", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_defaults.test_snemi": [[48, 55], ["gala.features.default.snemi3d", "gala.agglo.Rag", "numpy.concatenate", "numpy.testing.assert_allclose", "default.snemi3d."], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.features.default.snemi3d"], ["", "def", "test_snemi", "(", ")", ":", "\n", "    ", "feat", "=", "default", ".", "snemi3d", "(", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "ws", ",", "prob", ",", "feature_manager", "=", "feat", ",", "use_slow", "=", "True", ")", "\n", "# contact are edge features, so they are inserted just before the 8", "\n", "# difference features in the base paper_em vector.", "\n", "expected", "=", "np", ".", "concatenate", "(", "(", "ans12", "[", ":", "-", "8", "]", ",", "contact", ",", "ans12", "[", "-", "8", ":", "]", ")", ")", "\n", "assert_allclose", "(", "feat", "(", "g", ",", "1", ",", "2", ")", ",", "expected", ",", "atol", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._flood_fill_example": [[7, 14], ["numpy.array"], "function", ["None"], ["def", "_flood_fill_example", "(", ")", ":", "\n", "    ", "return", "np", ".", "array", "(", "[", "[", "[", "0", ",", "1", ",", "2", ",", "5", "]", ",", "\n", "[", "0", ",", "0", ",", "2", ",", "4", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "2", "]", "]", ",", "\n", "[", "[", "0", ",", "0", ",", "5", ",", "5", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "5", "]", ",", "\n", "[", "1", ",", "2", ",", "1", ",", "5", "]", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized.test_flood_fill_basic": [[15, 21], ["gala.optimized.flood_fill", "numpy.testing.assert_equal", "gala.optimized.flood_fill", "numpy.testing.assert_equal", "test_optimized._flood_fill_example", "set", "set", "test_optimized._flood_fill_example", "set", "set"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._flood_fill_example", "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._flood_fill_example"], ["", "def", "test_flood_fill_basic", "(", ")", ":", "\n", "    ", "fail_message", "=", "'Flood fill failed to find all matching labels.'", "\n", "t1", "=", "opt", ".", "flood_fill", "(", "_flood_fill_example", "(", ")", ",", "(", "0", ",", "0", ",", "0", ")", ",", "[", "0", "]", ",", "None", ",", "True", ")", "\n", "assert_equal", "(", "set", "(", "t1", ")", ",", "set", "(", "[", "0", ",", "4", ",", "5", ",", "9", ",", "12", ",", "13", "]", ")", ",", "fail_message", ")", "\n", "t2", "=", "opt", ".", "flood_fill", "(", "_flood_fill_example", "(", ")", ",", "(", "0", ",", "0", ",", "3", ")", ",", "[", "5", "]", ",", "None", ",", "True", ")", "\n", "assert_equal", "(", "set", "(", "t2", ")", ",", "set", "(", "[", "3", ",", "14", ",", "15", ",", "19", ",", "23", "]", ")", ",", "fail_message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized.test_flood_fill_with_no_hits": [[23, 27], ["gala.optimized.flood_fill", "numpy.testing.assert_equal", "test_optimized._flood_fill_example", "set", "set"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._flood_fill_example"], ["", "def", "test_flood_fill_with_no_hits", "(", ")", ":", "\n", "    ", "fail_message", "=", "'Flood fill failed with mismatching first label.'", "\n", "t", "=", "opt", ".", "flood_fill", "(", "_flood_fill_example", "(", ")", ",", "(", "0", ",", "1", ",", "3", ")", ",", "[", "2", "]", ",", "None", ",", "True", ")", "\n", "assert_equal", "(", "set", "(", "t", ")", ",", "set", "(", "[", "]", ")", ",", "fail_message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized.test_flood_fill_with_coordinates": [[29, 34], ["gala.optimized.flood_fill", "numpy.testing.assert_equal", "test_optimized._flood_fill_example", "set", "set", "map", "opt.flood_fill.tolist"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._flood_fill_example"], ["", "def", "test_flood_fill_with_coordinates", "(", ")", ":", "\n", "    ", "fail_message", "=", "'Flood fill failed with coordinate return'", "\n", "t", "=", "opt", ".", "flood_fill", "(", "_flood_fill_example", "(", ")", ",", "(", "0", ",", "0", ",", "0", ")", ",", "[", "0", "]", ",", "None", ",", "False", ")", "\n", "assert_equal", "(", "set", "(", "map", "(", "tuple", ",", "t", ".", "tolist", "(", ")", ")", ")", ",", "set", "(", "[", "(", "0", ",", "0", ",", "0", ")", ",", "(", "0", ",", "1", ",", "0", ")", ",", "(", "0", ",", "1", ",", "1", ")", ",", "(", "0", ",", "2", ",", "1", ")", ",", "(", "1", ",", "0", ",", "0", ")", ",", "\n", "(", "1", ",", "0", ",", "1", ")", "]", ")", ",", "fail_message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized.test_flood_fill_multiple_acceptable": [[36, 42], ["gala.optimized.flood_fill", "numpy.testing.assert_equal", "gala.optimized.flood_fill", "numpy.testing.assert_equal", "test_optimized._flood_fill_example", "set", "set", "test_optimized._flood_fill_example", "set", "set"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._flood_fill_example", "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._flood_fill_example"], ["", "def", "test_flood_fill_multiple_acceptable", "(", ")", ":", "\n", "    ", "fail_message", "=", "'Flood fill failed to flood with multiple acceptable labels'", "\n", "t1", "=", "opt", ".", "flood_fill", "(", "_flood_fill_example", "(", ")", ",", "(", "1", ",", "1", ",", "1", ")", ",", "[", "1", ",", "4", "]", ",", "None", ",", "True", ")", "\n", "assert_equal", "(", "set", "(", "t1", ")", ",", "set", "(", "[", "8", ",", "10", ",", "16", ",", "17", ",", "18", ",", "20", ",", "22", "]", ")", ",", "fail_message", ")", "\n", "t2", "=", "opt", ".", "flood_fill", "(", "_flood_fill_example", "(", ")", ",", "(", "0", ",", "1", ",", "2", ")", ",", "[", "2", ",", "5", "]", ",", "None", ",", "True", ")", "\n", "assert_equal", "(", "set", "(", "t2", ")", ",", "set", "(", "[", "2", ",", "3", ",", "6", ",", "11", ",", "14", ",", "15", ",", "19", ",", "23", "]", ")", ",", "fail_message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized.test_flood_fill_whole": [[44, 51], ["numpy.zeros", "gala.optimized.flood_fill", "numpy.testing.assert_equal", "len"], "function", ["None"], ["", "def", "test_flood_fill_whole", "(", ")", ":", "\n", "    ", "fail_message", "=", "'Flood fill failed to fill whole volume.'", "\n", "shape", "=", "(", "10", ",", "10", ",", "10", ")", "\n", "example2", "=", "np", ".", "zeros", "(", "shape", ",", "dtype", "=", "np", ".", "int", ")", "\n", "example2", "[", "5", ",", "5", ",", "5", "]", "=", "0", "\n", "t7", "=", "opt", ".", "flood_fill", "(", "example2", ",", "(", "5", ",", "5", ",", "5", ")", ",", "[", "0", "]", ",", "None", ",", "False", ")", "\n", "assert_equal", "(", "len", "(", "t7", ")", ",", "(", "example2", "==", "0", ")", ".", "sum", "(", ")", ",", "fail_message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized.test_flood_fill_pipes": [[53, 64], ["pytest.mark.skipif", "numpy.random.randint", "gala.optimized.flood_fill", "numpy.testing.assert_equal", "len"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "'GALA_TEST_FULL'", "not", "in", "os", ".", "environ", ",", "\n", "reason", "=", "(", "\"Test takes too long; \"", "\n", "\"set GALA_TEST_FULL env variable to run this.\"", ")", ")", "\n", "def", "test_flood_fill_pipes", "(", ")", ":", "\n", "    ", "fail_message", "=", "'Flood fill failed with thin columns in large volume.'", "\n", "example3", "=", "np", ".", "random", ".", "randint", "(", "6", ",", "size", "=", "(", "200", ",", "200", ",", "200", ")", ")", "\n", "example3", "[", "2", ",", "2", ",", ":", "]", "=", "6", "\n", "example3", "[", ":", ",", "2", ",", "150", "]", "=", "6", "\n", "example3", "[", "45", ",", ":", ",", ":", "]", "=", "6", "\n", "t8", "=", "opt", ".", "flood_fill", "(", "example3", ",", "(", "2", ",", "2", ",", "0", ")", ",", "[", "6", "]", ",", "None", ",", "True", ")", "\n", "assert_equal", "(", "len", "(", "t8", ")", ",", "(", "example3", "==", "6", ")", ".", "sum", "(", ")", ",", "fail_message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._despeckle_example": [[66, 108], ["numpy.array", "numpy.array"], "function", ["None"], ["", "def", "_despeckle_example", "(", ")", ":", "\n", "    ", "example", "=", "np", ".", "array", "(", "[", "[", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "4", ",", "4", ",", "4", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "-", "1", ",", "10", "]", ",", "\n", "[", "3", ",", "2", ",", "2", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "4", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "-", "1", ",", "10", "]", ",", "\n", "[", "3", ",", "3", ",", "2", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "-", "1", ",", "-", "1", "]", ",", "\n", "[", "3", ",", "3", ",", "2", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "4", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "11", ",", "11", ",", "11", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "11", ",", "6", ",", "11", ",", "11", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "5", ",", "3", ",", "5", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "11", ",", "6", ",", "6", ",", "11", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "5", ",", "3", ",", "5", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "11", ",", "11", ",", "11", ",", "11", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "5", ",", "5", ",", "5", ",", "5", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "5", ",", "5", ",", "5", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "5", ",", "5", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "5", ",", "5", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "9", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "5", ",", "5", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "9", ",", "9", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "9", ",", "9", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "9", ",", "9", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "expected", "=", "np", ".", "array", "(", "[", "[", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "-", "1", ",", "-", "1", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "-", "1", ",", "-", "1", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "-", "1", ",", "-", "1", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "11", ",", "11", ",", "11", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "3", ",", "3", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "11", ",", "11", ",", "11", ",", "11", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "5", ",", "3", ",", "5", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "11", ",", "11", ",", "11", ",", "11", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "3", ",", "5", ",", "3", ",", "5", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "11", ",", "11", ",", "11", ",", "11", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "3", ",", "5", ",", "5", ",", "5", ",", "5", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "5", ",", "5", ",", "5", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "5", ",", "5", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "5", ",", "5", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "9", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "5", ",", "5", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "9", ",", "9", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "9", ",", "9", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "9", ",", "9", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "7", ",", "7", ",", "7", ",", "7", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "return", "(", "example", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized.test_despeckle_in_place": [[110, 115], ["test_optimized._despeckle_example", "gala.optimized.despeckle_watershed", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._despeckle_example"], ["", "def", "test_despeckle_in_place", "(", ")", ":", "\n", "    ", "fail_message", "=", "\"despeckle_watershed failed to correctly despeckle in place\"", "\n", "example", ",", "expected", "=", "_despeckle_example", "(", ")", "\n", "opt", ".", "despeckle_watershed", "(", "example", ",", "in_place", "=", "True", ")", "\n", "assert_equal", "(", "example", ",", "expected", ",", "fail_message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized.test_despeckle_not_in_place": [[117, 124], ["test_optimized._despeckle_example", "gala.optimized.despeckle_watershed", "numpy.testing.assert_equal", "test_optimized._despeckle_example", "numpy.testing.assert_equal"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._despeckle_example", "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._despeckle_example"], ["", "def", "test_despeckle_not_in_place", "(", ")", ":", "\n", "    ", "fail_message", "=", "\"despeckle_watershed failed to correctly despeckle not in place\"", "\n", "example", ",", "expected", "=", "_despeckle_example", "(", ")", "\n", "calculated", "=", "opt", ".", "despeckle_watershed", "(", "example", ",", "in_place", "=", "False", ")", "\n", "assert_equal", "(", "calculated", ",", "expected", ",", "fail_message", ")", "\n", "example_2", ",", "e", "=", "_despeckle_example", "(", ")", "\n", "assert_equal", "(", "calculated", ",", "expected", ",", "\"despeckle watershed modified original when not in place.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized.test_despeckle_stack": [[125, 134], ["test_optimized._despeckle_example", "numpy.dstack().transpose", "numpy.dstack().transpose", "gala.optimized.despeckle_watershed", "numpy.testing.assert_equal", "numpy.dstack", "numpy.dstack", "numpy.rot90", "numpy.rot90", "numpy.rot90", "numpy.rot90"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_optimized._despeckle_example"], ["", "def", "test_despeckle_stack", "(", ")", ":", "\n", "    ", "fail_message", "=", "\"despeckle_watershed failed to correctly despeckle a stack of arrays\"", "\n", "example_single", ",", "expected_single", "=", "_despeckle_example", "(", ")", "\n", "example", "=", "np", ".", "dstack", "(", "(", "np", ".", "rot90", "(", "example_single", ",", "2", ")", ",", "example_single", ",", "\n", "np", ".", "rot90", "(", "example_single", ",", "2", ")", ",", "example_single", ")", ")", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "expected", "=", "np", ".", "dstack", "(", "(", "np", ".", "rot90", "(", "expected_single", ",", "2", ")", ",", "expected_single", ",", "\n", "np", ".", "rot90", "(", "expected_single", ",", "2", ")", ",", "expected_single", ")", ")", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "calculated", "=", "opt", ".", "despeckle_watershed", "(", "example", ")", "\n", "assert_equal", "(", "calculated", ",", "expected", ",", "fail_message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_watershed.time_me": [[11, 18], ["time.time", "time.time", "gala.morpho.watershed"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed"], ["def", "time_me", "(", "function", ")", ":", "\n", "    ", "def", "wrapped", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "r", "=", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "return", "r", ",", "(", "end", "-", "start", ")", "*", "1000", "\n", "", "return", "wrapped", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_watershed.test_watershed_images": [[31, 36], ["enumerate", "gala.morpho.watershed", "zip", "range"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed"], ["def", "test_watershed_images", "(", ")", ":", "\n", "    ", "wss", "=", "[", "morpho", ".", "watershed", "(", "probs", "[", "i", "]", ",", "dams", "=", "(", "i", "==", "0", ")", ")", "for", "i", "in", "range", "(", "2", ")", "]", "\n", "for", "i", ",", "(", "ws", ",", "res", ")", "in", "enumerate", "(", "zip", "(", "wss", ",", "results", ")", ")", ":", "\n", "        ", "yield", "(", "assert_array_equal", ",", "ws", ",", "res", ",", "\n", "'Image watershed test %i failed.'", "%", "i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_watershed.test_watershed": [[38, 42], ["numpy.array", "gala.morpho.watershed", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed"], ["", "", "def", "test_watershed", "(", ")", ":", "\n", "    ", "regular_watershed_result", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "0", ",", "2", ",", "0", ",", "3", ",", "3", ",", "3", ",", "0", ",", "4", ",", "4", "]", ")", "\n", "regular_watershed", "=", "morpho", ".", "watershed", "(", "landscape", ",", "dams", "=", "True", ")", "\n", "assert_array_equal", "(", "regular_watershed", ",", "regular_watershed_result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_watershed.test_watershed_nodams": [[44, 48], ["numpy.array", "gala.morpho.watershed", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed"], ["", "def", "test_watershed_nodams", "(", ")", ":", "\n", "    ", "nodam_watershed_result", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "2", ",", "2", ",", "2", ",", "3", ",", "3", ",", "3", ",", "4", ",", "4", ",", "4", "]", ")", "\n", "nodam_watershed", "=", "morpho", ".", "watershed", "(", "landscape", ",", "dams", "=", "False", ")", "\n", "assert_array_equal", "(", "nodam_watershed", ",", "nodam_watershed_result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_watershed.test_watershed_seeded": [[50, 58], ["numpy.array", "gala.morpho.watershed", "gala.morpho.watershed", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "scipy.ndimage.label"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed"], ["", "def", "test_watershed_seeded", "(", ")", ":", "\n", "    ", "seeds_bool", "=", "(", "landscape", "==", "0", ")", "\n", "seeds_unique", "=", "nd", ".", "label", "(", "seeds_bool", ")", "[", "0", "]", "\n", "seeded_watershed_result", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "2", ",", "2", ",", "2", ",", "0", ",", "3", ",", "3", "]", ")", "\n", "seeded_watershed1", "=", "morpho", ".", "watershed", "(", "landscape", ",", "seeds_bool", ",", "dams", "=", "True", ")", "\n", "seeded_watershed2", "=", "morpho", ".", "watershed", "(", "landscape", ",", "seeds_unique", ",", "dams", "=", "True", ")", "\n", "assert_array_equal", "(", "seeded_watershed1", ",", "seeded_watershed_result", ")", "\n", "assert_array_equal", "(", "seeded_watershed2", ",", "seeded_watershed_result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_watershed.test_watershed_seeded_nodams": [[60, 66], ["numpy.array", "gala.morpho.watershed", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed"], ["", "def", "test_watershed_seeded_nodams", "(", ")", ":", "\n", "    ", "seeds_bool", "=", "landscape", "==", "0", "\n", "seeded_nodam_ws_result", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "2", ",", "2", ",", "2", ",", "3", ",", "3", ",", "3", "]", ")", "\n", "seeded_nodam_ws", "=", "morpho", ".", "watershed", "(", "landscape", ",", "\n", "seeds", "=", "seeds_bool", ",", "override_skimage", "=", "True", ",", "dams", "=", "False", ")", "\n", "assert_array_equal", "(", "seeded_nodam_ws", ",", "seeded_nodam_ws_result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_watershed.test_watershed_saddle_basin": [[68, 73], ["numpy.array", "numpy.array", "gala.morpho.watershed", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.morpho.watershed"], ["", "def", "test_watershed_saddle_basin", "(", ")", ":", "\n", "    ", "saddle_landscape", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "3", "]", ",", "[", "2", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "3", "]", "]", ")", "\n", "saddle_result", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "2", ",", "2", ",", "2", "]", "]", ")", "\n", "saddle_ws", "=", "morpho", ".", "watershed", "(", "saddle_landscape", ",", "dams", "=", "True", ")", "\n", "assert_array_equal", "(", "saddle_ws", ",", "saddle_result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_watershed.test_watershed_plateau_performance": [[75, 87], ["numpy.ones", "test_watershed.time_me", "numpy.testing.assert_array_less", "time_me."], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_watershed.time_me"], ["", "def", "test_watershed_plateau_performance", "(", ")", ":", "\n", "    ", "\"\"\"Test time taken by watershed on plateaus is acceptable.\n    \n    Versions prior to 2d319e performed redundant computations in the\n    idxs_adjacent_to_labels queue which resulted in an explosion in \n    runtime on plateaus. This test checks against that behavior.\n    \"\"\"", "\n", "plat", "=", "np", ".", "ones", "(", "(", "11", ",", "11", ")", ")", "\n", "plat", "[", "5", ",", "5", "]", "=", "0", "\n", "timed_watershed", "=", "time_me", "(", "morpho", ".", "watershed", ")", "\n", "time_taken", "=", "timed_watershed", "(", "plat", ")", "[", "1", "]", "\n", "assert_array_less", "(", "time_taken", ",", "100", ",", "'watershed plateau too slow'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.feature_profile": [[16, 25], ["out.append", "out.append", "out.append", "out.append", "out.append", "out.append", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "f", "f", "f"], "function", ["None"], ["def", "feature_profile", "(", "g", ",", "f", ",", "n1", "=", "1", ",", "n2", "=", "2", ")", ":", "\n", "    ", "out", "=", "[", "]", "\n", "out", ".", "append", "(", "copy", "(", "g", ".", "edges", "[", "n1", ",", "n2", "]", "[", "'feature-cache'", "]", ")", ")", "\n", "out", ".", "append", "(", "copy", "(", "g", ".", "nodes", "[", "n1", "]", "[", "'feature-cache'", "]", ")", ")", "\n", "out", ".", "append", "(", "copy", "(", "g", ".", "nodes", "[", "n2", "]", "[", "'feature-cache'", "]", ")", ")", "\n", "out", ".", "append", "(", "f", "(", "g", ",", "n1", ",", "n2", ")", ")", "\n", "out", ".", "append", "(", "f", "(", "g", ",", "n1", ")", ")", "\n", "out", ".", "append", "(", "f", "(", "g", ",", "n2", ")", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.list_of_feature_arrays": [[27, 34], ["test_features.feature_profile", "zip", "g.merge_nodes", "feature_profile.extend", "test_features.feature_profile"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.feature_profile", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.merge_nodes", "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.feature_profile"], ["", "def", "list_of_feature_arrays", "(", "g", ",", "f", ",", "edges", "=", "[", "(", "1", ",", "2", ")", "]", ",", "merges", "=", "[", "]", ")", ":", "\n", "    ", "e1", ",", "edges", "=", "edges", "[", "0", "]", ",", "edges", "[", "1", ":", "]", "\n", "out", "=", "feature_profile", "(", "g", ",", "f", ",", "*", "e1", ")", "\n", "for", "edge", ",", "merge", "in", "zip", "(", "edges", ",", "merges", ")", ":", "\n", "        ", "g", ".", "merge_nodes", "(", "*", "merge", ")", "\n", "out", ".", "extend", "(", "feature_profile", "(", "g", ",", "f", ",", "*", "edge", ")", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.assert_equal_lists_or_arrays": [[36, 50], ["type", "type", "test_features.assert_equal_lists_or_arrays", "numpy.testing.assert_allclose", "zip", "type", "type", "numpy.testing.assert_approx_equal", "numpy.testing.assert_equal", "type", "type", "int", "numpy.log10"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.assert_equal_lists_or_arrays"], ["", "def", "assert_equal_lists_or_arrays", "(", "a1", ",", "a2", ",", "eps", "=", "1e-3", ")", ":", "\n", "    ", "\"\"\"Return True if ls1 and ls2 are arrays equal within eps or equal lists.\n    \n    The equality relationship can be nested. For example, lists of lists of \n    arrays that have identical structure will match.\n    \"\"\"", "\n", "if", "type", "(", "a1", ")", "==", "list", "and", "type", "(", "a2", ")", "==", "list", ":", "\n", "        ", "[", "assert_equal_lists_or_arrays", "(", "i1", ",", "i2", ",", "eps", ")", "for", "i1", ",", "i2", "in", "zip", "(", "a1", ",", "a2", ")", "]", "\n", "", "elif", "type", "(", "a1", ")", "==", "np", ".", "ndarray", "and", "type", "(", "a2", ")", "==", "np", ".", "ndarray", ":", "\n", "        ", "assert_allclose", "(", "a1", ",", "a2", ",", "atol", "=", "eps", ")", "\n", "", "elif", "type", "(", "a1", ")", "==", "float", "and", "type", "(", "a2", ")", "==", "float", ":", "\n", "        ", "assert_approx_equal", "(", "a1", ",", "a2", ",", "int", "(", "-", "np", ".", "log10", "(", "eps", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "assert_equal", "(", "a1", ",", "a2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.run_matched": [[62, 71], ["gala.agglo.Rag", "test_features.list_of_feature_arrays", "test_features.assert_equal_lists_or_arrays", "open", "pickle.load"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.list_of_feature_arrays", "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.assert_equal_lists_or_arrays"], ["def", "run_matched", "(", "f", ",", "fn", ",", "c", "=", "1", ",", "\n", "edges", "=", "[", "(", "1", ",", "2", ")", ",", "(", "6", ",", "3", ")", ",", "(", "7", ",", "4", ")", "]", ",", "\n", "merges", "=", "[", "(", "1", ",", "2", ")", ",", "(", "6", ",", "3", ")", "]", ")", ":", "\n", "    ", "p", "=", "probs1", "if", "c", "==", "1", "else", "probs2", "\n", "g", "=", "agglo", ".", "Rag", "(", "wss1", ",", "p", ",", "feature_manager", "=", "f", ",", "use_slow", "=", "True", ")", "\n", "o", "=", "list_of_feature_arrays", "(", "g", ",", "f", ",", "edges", ",", "merges", ")", "\n", "with", "open", "(", "fn", ",", "'rb'", ")", "as", "fin", ":", "\n", "        ", "r", "=", "pck", ".", "load", "(", "fin", ",", "encoding", "=", "'bytes'", ")", "\n", "", "assert_equal_lists_or_arrays", "(", "o", ",", "r", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.test_1channel_moment_features": [[73, 77], ["test_features.run_matched", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.run_matched"], ["", "def", "test_1channel_moment_features", "(", ")", ":", "\n", "    ", "f", "=", "f1", "\n", "run_matched", "(", "f", ",", "os", ".", "path", ".", "join", "(", "rundir", ",", "\n", "'toy-data/test-04-moments-1channel-12-13.pck'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.test_2channel_moment_features": [[78, 82], ["test_features.run_matched", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.run_matched"], ["", "def", "test_2channel_moment_features", "(", ")", ":", "\n", "    ", "f", "=", "f1", "\n", "run_matched", "(", "f", ",", "os", ".", "path", ".", "join", "(", "rundir", ",", "\n", "'toy-data/test-04-moments-2channel-12-13.pck'", ")", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.test_1channel_histogram_features": [[83, 87], ["test_features.run_matched", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.run_matched"], ["", "def", "test_1channel_histogram_features", "(", ")", ":", "\n", "    ", "f", "=", "f2", "\n", "run_matched", "(", "f", ",", "os", ".", "path", ".", "join", "(", "rundir", ",", "\n", "'toy-data/test-04-histogram-1channel-12-13.pck'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.test_2channel_histogram_features": [[88, 92], ["test_features.run_matched", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.run_matched"], ["", "def", "test_2channel_histogram_features", "(", ")", ":", "\n", "    ", "f", "=", "f2", "\n", "run_matched", "(", "f", ",", "os", ".", "path", ".", "join", "(", "rundir", ",", "\n", "'toy-data/test-04-histogram-2channel-12-13.pck'", ")", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.test_1channel_squiggliness_feature": [[93, 97], ["test_features.run_matched", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.run_matched"], ["", "def", "test_1channel_squiggliness_feature", "(", ")", ":", "\n", "    ", "f", "=", "f3", "\n", "run_matched", "(", "f", ",", "os", ".", "path", ".", "join", "(", "rundir", ",", "\n", "'toy-data/test-04-squiggle-1channel-12-13.pck'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.test_1channel_composite_feature": [[98, 102], ["test_features.run_matched", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.run_matched"], ["", "def", "test_1channel_composite_feature", "(", ")", ":", "\n", "    ", "f", "=", "f4", "\n", "run_matched", "(", "f", ",", "os", ".", "path", ".", "join", "(", "rundir", ",", "\n", "'toy-data/test-04-composite-1channel-12-13.pck'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.test_2channel_composite_feature": [[103, 107], ["test_features.run_matched", "os.path.join"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.run_matched"], ["", "def", "test_2channel_composite_feature", "(", ")", ":", "\n", "    ", "f", "=", "f4", "\n", "run_matched", "(", "f", ",", "os", ".", "path", ".", "join", "(", "rundir", ",", "\n", "'toy-data/test-04-composite-2channel-12-13.pck'", ")", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_features.test_convex_hull": [[109, 118], ["numpy.array", "gala.features.convex_hull.Manager", "gala.agglo.Rag", "numpy.array", "numpy.testing.assert_allclose", "features.convex_hull.Manager."], "function", ["None"], ["", "def", "test_convex_hull", "(", ")", ":", "\n", "    ", "ws", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", ",", "2", "]", ",", "\n", "[", "1", ",", "1", ",", "2", "]", ",", "\n", "[", "1", ",", "2", ",", "2", "]", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "chull", "=", "features", ".", "convex_hull", ".", "Manager", "(", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "ws", ",", "feature_manager", "=", "chull", ",", "use_slow", "=", "True", ")", "\n", "expected", "=", "np", ".", "array", "(", "[", "0.5", ",", "0.125", ",", "0.5", ",", "0.1", ",", "1.", ",", "0.167", ",", "0.025", ",", "0.069", ",", "\n", "0.44", ",", "0.056", ",", "1.25", ",", "1.5", ",", "1.2", ",", "0.667", "]", ")", "\n", "assert_allclose", "(", "chull", "(", "g", ",", "1", ",", "2", ")", ",", "expected", ",", "atol", "=", "0.01", ",", "rtol", "=", "1.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_server.id_serve": [[27, 36], ["zmq.Context", "zmq.Context.socket", "context.socket.bind", "context.socket.send_json", "context.socket.recv_json"], "function", ["None"], ["def", "id_serve", "(", "port", "=", "5555", ",", "curr_id", "=", "1", ")", ":", "\n", "    ", "context", "=", "zmq", ".", "Context", "(", ")", "\n", "socket", "=", "context", ".", "socket", "(", "zmq", ".", "REP", ")", "\n", "socket", ".", "bind", "(", "'tcp://*:%s'", "%", "port", ")", "\n", "while", "True", ":", "\n", "        ", "count", "=", "socket", ".", "recv_json", "(", ")", "[", "'count'", "]", "\n", "ids_rep", "=", "{", "'begin'", ":", "curr_id", ",", "'end'", ":", "curr_id", "+", "count", "}", "\n", "curr_id", "+=", "count", "\n", "socket", ".", "send_json", "(", "ids_rep", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_server.dummy_data": [[38, 46], ["numpy.arange().reshape", "numpy.array", "gala.features.base.Mock", "scipy.ndimage.zoom", "numpy.arange"], "function", ["None"], ["", "", "@", "pytest", ".", "fixture", "\n", "def", "dummy_data", "(", ")", ":", "\n", "    ", "frag0", "=", "np", ".", "arange", "(", "1", ",", "17", ",", "dtype", "=", "int", ")", ".", "reshape", "(", "(", "4", ",", "4", ")", ")", "\n", "gt0", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "2", ",", "2", "]", ",", "[", "1", ",", "1", ",", "2", ",", "2", "]", ",", "[", "3", "]", "*", "4", ",", "[", "3", "]", "*", "4", "]", ",", "dtype", "=", "int", ")", "\n", "frag", ",", "gt", "=", "(", "ndi", ".", "zoom", "(", "image", ",", "4", ",", "order", "=", "0", ",", "mode", "=", "'reflect'", ")", "\n", "for", "image", "in", "[", "frag0", ",", "gt0", "]", ")", "\n", "fman", "=", "features", ".", "base", ".", "Mock", "(", "frag", ",", "gt", ")", "\n", "return", "frag", ",", "gt", ",", "fman", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_server.dummy_data2": [[48, 55], ["gala.features.base.Mock"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "dummy_data2", "(", "dummy_data", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "_", "=", "dummy_data", "\n", "frag", "[", "7", ",", "7", ":", "9", "]", "=", "17", "\n", "frag", "[", "7", ":", "10", ",", "-", "1", "]", "=", "18", "\n", "fman", "=", "features", ".", "base", ".", "Mock", "(", "frag", ",", "gt", ")", "\n", "return", "frag", ",", "gt", ",", "fman", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_server.test_server": [[57, 71], ["gala.serve.Solver", "threading.Thread", "threading.Thread.start", "gala.serve.proofread", "threading.Thread.join", "numpy.array", "gala.evaluate.vi", "gala.evaluate.vi", "str"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.proofread", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi"], ["", "def", "test_server", "(", "dummy_data", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "fman", "=", "dummy_data", "\n", "host", ",", "port", "=", "'tcp://localhost'", ",", "5588", "\n", "solver", "=", "serve", ".", "Solver", "(", "frag", ",", "feature_manager", "=", "fman", ",", "\n", "address", "=", "'tcp://*:'", "+", "str", "(", "port", ")", ")", "\n", "thread", "=", "threading", ".", "Thread", "(", "target", "=", "solver", ".", "listen", ",", "name", "=", "'solver'", ")", "\n", "thread", ".", "start", "(", ")", "\n", "_", ",", "dst", "=", "serve", ".", "proofread", "(", "frag", ",", "gt", ",", "host", "=", "host", ",", "port", "=", "port", ",", "num_operations", "=", "2", ",", "\n", "stop_when_finished", "=", "True", ",", "random_state", "=", "0", ")", "\n", "result", "=", "np", ".", "array", "(", "dst", ")", "[", "frag", "]", "\n", "# test: resulting segmentation should be improvement over fragments alone", "\n", "assert", "(", "ev", ".", "vi", "(", "result", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", "<", "\n", "ev", ".", "vi", "(", "frag", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", ")", "\n", "thread", ".", "join", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_server.test_server_imperfect_fragments": [[73, 87], ["gala.serve.Solver", "threading.Thread", "threading.Thread.start", "gala.serve.proofread", "threading.Thread.join", "numpy.array", "gala.evaluate.vi", "gala.evaluate.vi", "str"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.proofread", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi"], ["", "def", "test_server_imperfect_fragments", "(", "dummy_data2", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "fman", "=", "dummy_data2", "\n", "host", ",", "port", "=", "'tcp://localhost'", ",", "5589", "\n", "solver", "=", "serve", ".", "Solver", "(", "frag", ",", "feature_manager", "=", "fman", ",", "\n", "address", "=", "'tcp://*:'", "+", "str", "(", "port", ")", ")", "\n", "thread", "=", "threading", ".", "Thread", "(", "target", "=", "solver", ".", "listen", ",", "name", "=", "'solver'", ")", "\n", "thread", ".", "start", "(", ")", "\n", "_", ",", "dst", "=", "serve", ".", "proofread", "(", "frag", ",", "gt", ",", "host", "=", "host", ",", "port", "=", "port", ",", "num_operations", "=", "2", ",", "\n", "stop_when_finished", "=", "True", ",", "random_state", "=", "0", ")", "\n", "result", "=", "np", ".", "array", "(", "dst", ")", "[", "frag", "]", "\n", "# test: resulting segmentation should be improvement over fragments alone", "\n", "assert", "(", "ev", ".", "vi", "(", "result", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", "<", "\n", "ev", ".", "vi", "(", "frag", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", ")", "\n", "thread", ".", "join", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_server.test_server_with_id_service": [[89, 120], ["threading.Thread", "threading.Thread.start", "threading.Thread", "threading.Thread.start", "config[].rsplit", "gala.serve.proofread", "threading.Thread.join", "skimage._shared._tempfile.temporary_file", "gala.serve.Solver", "numpy.array", "gala.evaluate.vi", "gala.evaluate.vi", "numpy.min", "open", "json.dump", "dict", "int"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.proofread", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi"], ["", "def", "test_server_with_id_service", "(", "dummy_data", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "fman", "=", "dummy_data", "\n", "id_service_port", "=", "5600", "\n", "config", "=", "{", "'client_url'", ":", "'tcp://*:5590'", ",", "\n", "'id_service_url'", ":", "'tcp://localhost:%i'", "%", "id_service_port", ",", "\n", "'solver_url'", ":", "'tcp://localhost:5590'", "}", "\n", "with", "temporary_file", "(", "'.json'", ")", "as", "config_filename", ":", "\n", "        ", "with", "open", "(", "config_filename", ",", "'w'", ")", "as", "fout", ":", "\n", "            ", "json", ".", "dump", "(", "config", ",", "fout", ")", "\n", "", "solver", "=", "serve", ".", "Solver", "(", "frag", ",", "feature_manager", "=", "fman", ",", "\n", "config_file", "=", "config_filename", ")", "\n", "", "starting_id", "=", "23461", "\n", "id_thread", "=", "threading", ".", "Thread", "(", "target", "=", "id_serve", ",", "name", "=", "'id-service'", ",", "\n", "daemon", "=", "True", ",", "\n", "kwargs", "=", "dict", "(", "port", "=", "id_service_port", ",", "\n", "curr_id", "=", "starting_id", ")", ")", "\n", "id_thread", ".", "start", "(", ")", "\n", "thread", "=", "threading", ".", "Thread", "(", "target", "=", "solver", ".", "listen", ",", "name", "=", "'solver'", ")", "\n", "thread", ".", "start", "(", ")", "\n", "host", ",", "port", "=", "config", "[", "'solver_url'", "]", ".", "rsplit", "(", "':'", ",", "maxsplit", "=", "1", ")", "\n", "_", ",", "dst", "=", "serve", ".", "proofread", "(", "frag", ",", "gt", ",", "host", "=", "host", ",", "port", "=", "int", "(", "port", ")", ",", "\n", "num_operations", "=", "2", ",", "stop_when_finished", "=", "True", ",", "\n", "random_state", "=", "0", ")", "\n", "result", "=", "np", ".", "array", "(", "dst", ")", "[", "frag", "]", "\n", "# test: resulting segmentation should be improvement over fragments alone", "\n", "assert", "(", "ev", ".", "vi", "(", "result", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", "<", "\n", "ev", ".", "vi", "(", "frag", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", ")", "\n", "# test 2: make sure ID service worked: starting ID should be as above", "\n", "# should be equal but boundary ID messes things up", "\n", "assert", "np", ".", "min", "(", "result", ")", ">", "starting_id", "\n", "thread", ".", "join", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_server.test_server_with_periodic_send": [[122, 153], ["threading.Thread", "threading.Thread.start", "threading.Thread", "threading.Thread.start", "config[].rsplit", "gala.serve.proofread", "skimage._shared._tempfile.temporary_file", "gala.serve.Solver", "numpy.array", "gala.evaluate.vi", "gala.evaluate.vi", "numpy.min", "open", "json.dump", "dict", "dict", "int"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.proofread", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi"], ["", "def", "test_server_with_periodic_send", "(", "dummy_data", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "fman", "=", "dummy_data", "\n", "id_service_port", "=", "5601", "\n", "config", "=", "{", "'client_url'", ":", "'tcp://*:5591'", ",", "\n", "'id_service_url'", ":", "'tcp://localhost:%i'", "%", "id_service_port", ",", "\n", "'solver_url'", ":", "'tcp://localhost:5591'", "}", "\n", "with", "temporary_file", "(", "'.json'", ")", "as", "config_filename", ":", "\n", "        ", "with", "open", "(", "config_filename", ",", "'w'", ")", "as", "fout", ":", "\n", "            ", "json", ".", "dump", "(", "config", ",", "fout", ")", "\n", "", "solver", "=", "serve", ".", "Solver", "(", "frag", ",", "feature_manager", "=", "fman", ",", "\n", "config_file", "=", "config_filename", ")", "\n", "", "starting_id", "=", "23461", "\n", "id_thread", "=", "threading", ".", "Thread", "(", "target", "=", "id_serve", ",", "name", "=", "'id-service'", ",", "\n", "daemon", "=", "True", ",", "\n", "kwargs", "=", "dict", "(", "port", "=", "id_service_port", ",", "\n", "curr_id", "=", "starting_id", ")", ")", "\n", "id_thread", ".", "start", "(", ")", "\n", "thread", "=", "threading", ".", "Thread", "(", "target", "=", "solver", ".", "listen", ",", "name", "=", "'solver'", ",", "daemon", "=", "True", ",", "\n", "kwargs", "=", "dict", "(", "send_every", "=", "10", ")", ")", "\n", "thread", ".", "start", "(", ")", "\n", "host", ",", "port", "=", "config", "[", "'solver_url'", "]", ".", "rsplit", "(", "':'", ",", "maxsplit", "=", "1", ")", "\n", "_", ",", "dst", "=", "serve", ".", "proofread", "(", "frag", ",", "gt", ",", "host", "=", "host", ",", "port", "=", "int", "(", "port", ")", ",", "\n", "num_operations", "=", "2", ",", "stop_when_finished", "=", "True", ",", "\n", "request_seg", "=", "False", ",", "random_state", "=", "0", ")", "\n", "result", "=", "np", ".", "array", "(", "dst", ")", "[", "frag", "]", "\n", "# test: resulting segmentation should be improvement over fragments alone", "\n", "assert", "(", "ev", ".", "vi", "(", "result", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", "<", "\n", "ev", ".", "vi", "(", "frag", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", ")", "\n", "# test 2: make sure ID service worked: starting ID should be as above", "\n", "# should be equal but boundary ID messes things up", "\n", "assert", "np", ".", "min", "(", "result", ")", ">", "starting_id", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_server.data": [[155, 159], ["map", "sorted", "os.listdir", "os.listdir"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "data", "(", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "pr", "=", "map", "(", "io", ".", "imread", ",", "sorted", "(", "os", ".", "listdir", "(", "'.'", ")", ")", ")", "\n", "return", "frag", ",", "gt", ",", "pr", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_server.test_server_long": [[161, 177], ["pytest.mark.skipif", "gala.serve.Solver", "threading.Thread", "threading.Thread.start", "gala.serve.proofread", "threading.Thread.join", "numpy.array", "gala.evaluate.vi", "gala.evaluate.vi"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.iterprogress.NoProgressBar.start", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.serve.proofread", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "'GALA_TEST_FULL'", "not", "in", "os", ".", "environ", ",", "\n", "reason", "=", "(", "\"Test takes too long; \"", "\n", "\"set GALA_TEST_FULL env variable to run this.\"", ")", ")", "\n", "def", "test_server_long", "(", "data", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "pr", "=", "data", "\n", "host", ",", "port", "=", "'tcp://localhost'", ",", "5590", "\n", "solver", "=", "serve", ".", "Solver", "(", "frag", ",", "pr", ",", "port", "=", "port", ",", "host", "=", "'tcp://*'", ")", "\n", "thread", "=", "threading", ".", "Thread", "(", "target", "=", "solver", ".", "listen", ",", "name", "=", "'solver'", ")", "\n", "thread", ".", "start", "(", ")", "\n", "_", ",", "dst", "=", "serve", ".", "proofread", "(", "frag", ",", "gt", ",", "host", "=", "host", ",", "port", "=", "port", ",", "\n", "stop_when_finished", "=", "True", ",", "random_state", "=", "0", ")", "\n", "result", "=", "np", ".", "array", "(", "dst", ")", "[", "frag", "]", "\n", "# test: resulting segmentation should be improvement over fragments alone", "\n", "assert", "(", "ev", ".", "vi", "(", "result", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", "<", "\n", "ev", ".", "vi", "(", "frag", ",", "gt", ",", "ignore_x", "=", "[", "]", ",", "ignore_y", "=", "[", "]", ")", ")", "\n", "thread", ".", "join", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.tar_extract": [[19, 27], ["subprocess.call", "os.path.basename", "os.remove", "glob.glob", "os.remove"], "function", ["None"], ["@", "contextmanager", "\n", "def", "tar_extract", "(", "fn", ")", ":", "\n", "    ", "sp", ".", "call", "(", "[", "'tar'", ",", "'-xzf'", ",", "fn", "+", "'.tar.gz'", "]", ")", "\n", "ext_fn", "=", "os", ".", "path", ".", "basename", "(", "fn", ")", "\n", "yield", "ext_fn", "\n", "os", ".", "remove", "(", "ext_fn", ")", "\n", "for", "sub_fn", "in", "glob", ".", "glob", "(", "ext_fn", "+", "'_*'", ")", ":", "\n", "        ", "os", ".", "remove", "(", "sub_fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.dummy_data_source": [[33, 39], ["numpy.arange().reshape", "numpy.array", "gala.features.base.Mock", "gala.agglo.Rag", "numpy.arange"], "function", ["None"], ["def", "dummy_data_source", "(", ")", ":", "\n", "    ", "frag", "=", "np", ".", "arange", "(", "1", ",", "17", ",", "dtype", "=", "int", ")", ".", "reshape", "(", "(", "4", ",", "4", ")", ")", "\n", "gt", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "2", ",", "2", "]", ",", "[", "1", ",", "1", ",", "2", ",", "2", "]", ",", "[", "3", "]", "*", "4", ",", "[", "3", "]", "*", "4", "]", ",", "dtype", "=", "int", ")", "\n", "fman", "=", "features", ".", "base", ".", "Mock", "(", "frag", ",", "gt", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "frag", ",", "feature_manager", "=", "fman", ",", "use_slow", "=", "True", ")", "\n", "return", "frag", ",", "gt", ",", "g", ",", "fman", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.dummy_data": [[41, 44], ["test_gala.dummy_data_source"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.dummy_data_source"], ["", "@", "pytest", ".", "fixture", "\n", "def", "dummy_data", "(", ")", ":", "\n", "    ", "return", "dummy_data_source", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.dummy_data_fast": [[46, 53], ["scipy.ndimage.zoom", "scipy.ndimage.zoom", "gala.agglo.Rag"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "dummy_data_fast", "(", "dummy_data", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "_", ",", "fman", "=", "dummy_data", "\n", "frag", "=", "ndi", ".", "zoom", "(", "frag", ",", "2", ",", "order", "=", "0", ")", "\n", "gt", "=", "ndi", ".", "zoom", "(", "gt", ",", "2", ",", "order", "=", "0", ")", "\n", "g", "=", "agglo", ".", "Rag", "(", "frag", ",", "feature_manager", "=", "fman", ")", "\n", "return", "frag", ",", "gt", ",", "g", ",", "fman", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.test_generate_flat_learning_edges": [[57, 65], ["g.learn_flat", "tuple", "tuple", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_flat"], ["", "def", "test_generate_flat_learning_edges", "(", "dummy_data", ")", ":", "\n", "    ", "\"\"\"Run a flat epoch and ensure all edges are correctly represented.\"\"\"", "\n", "frag", ",", "gt", ",", "g", ",", "fman", "=", "dummy_data", "\n", "feat", ",", "target", ",", "weights", ",", "edges", "=", "g", ".", "learn_flat", "(", "gt", ",", "fman", ")", "\n", "assert", "feat", ".", "shape", "==", "(", "24", ",", "2", ")", "\n", "assert", "tuple", "(", "edges", "[", "0", "]", ")", "==", "(", "1", ",", "2", ")", "\n", "assert", "tuple", "(", "edges", "[", "-", "1", "]", ")", "==", "(", "15", ",", "16", ")", "\n", "assert", "np", ".", "sum", "(", "target", "[", ":", ",", "0", "]", "==", "1", ")", "==", "6", "# number of non-merge edges", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.test_generate_flat_learning_edges_fast": [[67, 75], ["g.learn_flat", "tuple", "tuple", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_flat"], ["", "def", "test_generate_flat_learning_edges_fast", "(", "dummy_data_fast", ")", ":", "\n", "    ", "\"\"\"Run a flat epoch and ensure all edges are correctly represented.\"\"\"", "\n", "frag", ",", "gt", ",", "g", ",", "fman", "=", "dummy_data_fast", "\n", "feat", ",", "target", ",", "weights", ",", "edges", "=", "g", ".", "learn_flat", "(", "gt", ",", "fman", ")", "\n", "assert", "feat", ".", "shape", "==", "(", "24", ",", "2", ")", "\n", "assert", "tuple", "(", "edges", "[", "0", "]", ")", "==", "(", "1", ",", "2", ")", "\n", "assert", "tuple", "(", "edges", "[", "-", "1", "]", ")", "==", "(", "15", ",", "16", ")", "\n", "assert", "np", ".", "sum", "(", "target", "[", ":", ",", "0", "]", "==", "1", ")", "==", "6", "# number of non-merge edges", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.test_generate_lash_examples": [[77, 115], ["numpy.random.seed", "g.learn_agglomerate", "LR().fit", "LR().fit", "print", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "len", "test_gala.test_generate_lash_examples.fpred"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit"], ["", "def", "test_generate_lash_examples", "(", "dummy_data", ")", ":", "\n", "    ", "\"\"\"Run a flat epoch and an active epoch of learning, compare learned sets.\n\n    The mock feature manager places all merge examples at (0, 0) in feature\n    space, and all non-merge examples at (1, 0), *in flat learning*. During\n    agglomeration, non-merge examples go to (0, 1), which confuses the flat\n    classifier (which has only learned the difference along the first feature\n    dimension).\n\n    This test checks for those differences in learning using a simple\n    logistic regression.\n    \"\"\"", "\n", "frag", ",", "gt", ",", "g", ",", "fman", "=", "dummy_data", "\n", "np", ".", "random", ".", "seed", "(", "99", ")", "\n", "summary", ",", "allepochs", "=", "g", ".", "learn_agglomerate", "(", "gt", ",", "fman", ",", "\n", "learning_mode", "=", "'permissive'", ",", "\n", "classifier", "=", "'logistic regression'", ",", "\n", "min_num_epochs", "=", "5", ")", "\n", "feat", ",", "target", ",", "weights", ",", "edges", "=", "summary", "\n", "ffeat", ",", "ftarget", ",", "fweights", ",", "fedges", "=", "allepochs", "[", "0", "]", "# flat", "\n", "lr", "=", "LR", "(", ")", ".", "fit", "(", "feat", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "flr", "=", "LR", "(", ")", ".", "fit", "(", "ffeat", ",", "ftarget", "[", ":", ",", "0", "]", ")", "\n", "def", "pred", "(", "v", ")", ":", "\n", "        ", "return", "lr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "def", "fpred", "(", "v", ")", ":", "\n", "        ", "return", "flr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "assert", "len", "(", "allepochs", "[", "1", "]", "[", "0", "]", ")", "==", "15", "# number of merges is |nodes| - 1", "\n", "\n", "# approx. same learning results at (0., 0.) and (1., 0.)", "\n", "print", "(", "[", "(", "fpred", "(", "i", ")", ",", "pred", "(", "i", ")", ")", "for", "i", "in", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "0", "]", ",", "[", "0", ",", "1", "]", "]", "]", ")", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "fpred", "(", "[", "1", ",", "0", "]", ")", ",", "0.65", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "1", ",", "0", "]", ")", ",", "0.65", ",", "atol", "=", "0.1", ")", "\n", "\n", "# difference between agglomerative and flat learning in point (0., 1.)", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "1", "]", ")", ",", "0.2", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "1", "]", ")", ",", "0.6", ",", "atol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.test_generate_lash_examples_fast": [[117, 155], ["numpy.random.seed", "g.learn_agglomerate", "LR().fit", "LR().fit", "print", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "len", "test_gala.test_generate_lash_examples.fpred"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit"], ["", "def", "test_generate_lash_examples_fast", "(", "dummy_data_fast", ")", ":", "\n", "    ", "\"\"\"Run a flat epoch and an active epoch of learning, compare learned sets.\n\n    The mock feature manager places all merge examples at (0, 0) in feature\n    space, and all non-merge examples at (1, 0), *in flat learning*. During\n    agglomeration, non-merge examples go to (0, 1), which confuses the flat\n    classifier (which has only learned the difference along the first feature\n    dimension).\n\n    This test checks for those differences in learning using a simple\n    logistic regression.\n    \"\"\"", "\n", "frag", ",", "gt", ",", "g", ",", "fman", "=", "dummy_data_fast", "\n", "np", ".", "random", ".", "seed", "(", "99", ")", "\n", "summary", ",", "allepochs", "=", "g", ".", "learn_agglomerate", "(", "gt", ",", "fman", ",", "\n", "learning_mode", "=", "'permissive'", ",", "\n", "classifier", "=", "'logistic regression'", ",", "\n", "min_num_epochs", "=", "5", ")", "\n", "feat", ",", "target", ",", "weights", ",", "edges", "=", "summary", "\n", "ffeat", ",", "ftarget", ",", "fweights", ",", "fedges", "=", "allepochs", "[", "0", "]", "# flat", "\n", "lr", "=", "LR", "(", ")", ".", "fit", "(", "feat", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "flr", "=", "LR", "(", ")", ".", "fit", "(", "ffeat", ",", "ftarget", "[", ":", ",", "0", "]", ")", "\n", "def", "pred", "(", "v", ")", ":", "\n", "        ", "return", "lr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "def", "fpred", "(", "v", ")", ":", "\n", "        ", "return", "flr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "assert", "len", "(", "allepochs", "[", "1", "]", "[", "0", "]", ")", "==", "15", "# number of merges is |nodes| - 1", "\n", "\n", "# approx. same learning results at (0., 0.) and (1., 0.)", "\n", "print", "(", "[", "(", "fpred", "(", "i", ")", ",", "pred", "(", "i", ")", ")", "for", "i", "in", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "0", "]", ",", "[", "0", ",", "1", "]", "]", "]", ")", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.2", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.2", ")", "\n", "assert_allclose", "(", "fpred", "(", "[", "1", ",", "0", "]", ")", ",", "0.65", ",", "atol", "=", "0.15", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "1", ",", "0", "]", ")", ",", "0.65", ",", "atol", "=", "0.15", ")", "\n", "\n", "# difference between agglomerative and flat learning in point (0., 1.)", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "1", "]", ")", ",", "0.2", ",", "atol", "=", "0.2", ")", "# < 0.4", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "1", "]", ")", ",", "0.65", ",", "atol", "=", "0.2", ")", "# > 0.45", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.test_generate_gala_examples": [[157, 185], ["numpy.random.seed", "g.learn_agglomerate", "LR().fit", "LR().fit", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "len", "test_gala.test_generate_lash_examples.fpred"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit"], ["", "def", "test_generate_gala_examples", "(", "dummy_data", ")", ":", "\n", "    ", "\"\"\"As `test_generate_lash_examples`, but using strict learning. \"\"\"", "\n", "frag", ",", "gt", ",", "g", ",", "fman", "=", "dummy_data", "\n", "np", ".", "random", ".", "seed", "(", "99", ")", "\n", "summary", ",", "allepochs", "=", "g", ".", "learn_agglomerate", "(", "gt", ",", "fman", ",", "\n", "learning_mode", "=", "'strict'", ",", "\n", "classifier", "=", "'logistic regression'", ",", "\n", "min_num_epochs", "=", "5", ")", "\n", "feat", ",", "target", ",", "weights", ",", "edges", "=", "summary", "\n", "ffeat", ",", "ftarget", ",", "fweights", ",", "fedges", "=", "allepochs", "[", "0", "]", "# flat", "\n", "lr", "=", "LR", "(", ")", ".", "fit", "(", "feat", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "flr", "=", "LR", "(", ")", ".", "fit", "(", "ffeat", ",", "ftarget", "[", ":", ",", "0", "]", ")", "\n", "def", "pred", "(", "v", ")", ":", "\n", "        ", "return", "lr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "def", "fpred", "(", "v", ")", ":", "\n", "        ", "return", "flr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "assert", "len", "(", "allepochs", "[", "1", "]", "[", "0", "]", ")", ">", "15", "# number of merges is more than LASH", "\n", "\n", "# approx. same learning results at (0., 0.) and (1., 0.)", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "fpred", "(", "[", "1", ",", "0", "]", ")", ",", "0.64", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "1", ",", "0", "]", ")", ",", "0.64", ",", "atol", "=", "0.1", ")", "\n", "\n", "# difference between agglomerative and flat learning in point (0., 1.);", "\n", "# greater separation than with LASH", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "1", "]", ")", ",", "0.2", ",", "atol", "=", "0.1", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "1", "]", ")", ",", "0.7", ",", "atol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.test_generate_gala_examples_fast_updateedges": [[187, 215], ["gala.agglo.Rag", "numpy.random.seed", "agglo.Rag.learn_agglomerate", "LR().fit", "LR().fit", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "len", "test_gala.test_generate_lash_examples.fpred"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit"], ["", "def", "test_generate_gala_examples_fast_updateedges", "(", "dummy_data_fast", ")", ":", "\n", "    ", "\"\"\"As `test_generate_lash_examples`, but using strict learning. \"\"\"", "\n", "frag", ",", "gt", ",", "g", ",", "fman", "=", "dummy_data_fast", "\n", "g", "=", "agglo", ".", "Rag", "(", "frag", ",", "feature_manager", "=", "fman", ",", "update_unchanged_edges", "=", "True", ")", "\n", "np", ".", "random", ".", "seed", "(", "99", ")", "\n", "summary", ",", "allepochs", "=", "g", ".", "learn_agglomerate", "(", "gt", ",", "fman", ",", "\n", "learning_mode", "=", "'strict'", ",", "\n", "classifier", "=", "'logistic regression'", ")", "\n", "feat", ",", "target", ",", "weights", ",", "edges", "=", "summary", "\n", "ffeat", ",", "ftarget", ",", "fweights", ",", "fedges", "=", "allepochs", "[", "0", "]", "# flat", "\n", "lr", "=", "LR", "(", ")", ".", "fit", "(", "feat", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "flr", "=", "LR", "(", ")", ".", "fit", "(", "ffeat", ",", "ftarget", "[", ":", ",", "0", "]", ")", "\n", "def", "pred", "(", "v", ")", ":", "\n", "        ", "return", "lr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "def", "fpred", "(", "v", ")", ":", "\n", "        ", "return", "flr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "assert", "len", "(", "allepochs", "[", "1", "]", "[", "0", "]", ")", ">", "15", "# number of merges is more than LASH", "\n", "\n", "# approx. same learning results at (0., 0.) and (1., 0.)", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.2", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.2", ")", "\n", "assert_allclose", "(", "fpred", "(", "[", "1", ",", "0", "]", ")", ",", "0.65", ",", "atol", "=", "0.15", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "1", ",", "0", "]", ")", ",", "0.65", ",", "atol", "=", "0.15", ")", "\n", "\n", "# difference between agglomerative and flat learning in point (0., 1.);", "\n", "# greater separation than with LASH", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "1", "]", ")", ",", "0.2", ",", "atol", "=", "0.15", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "1", "]", ")", ",", "0.7", ",", "atol", "=", "0.15", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.test_generate_gala_examples_fast": [[217, 245], ["numpy.random.seed", "g.learn_agglomerate", "LR().fit", "LR().fit", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "len", "test_gala.test_generate_lash_examples.fpred"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit"], ["", "def", "test_generate_gala_examples_fast", "(", "dummy_data_fast", ")", ":", "\n", "    ", "\"\"\"As `test_generate_lash_examples`, but using strict learning. \"\"\"", "\n", "frag", ",", "gt", ",", "g", ",", "fman", "=", "dummy_data_fast", "\n", "np", ".", "random", ".", "seed", "(", "99", ")", "\n", "summary", ",", "allepochs", "=", "g", ".", "learn_agglomerate", "(", "gt", ",", "fman", ",", "\n", "learning_mode", "=", "'strict'", ",", "\n", "classifier", "=", "'logistic regression'", ",", "\n", "min_num_epochs", "=", "5", ")", "\n", "feat", ",", "target", ",", "weights", ",", "edges", "=", "summary", "\n", "ffeat", ",", "ftarget", ",", "fweights", ",", "fedges", "=", "allepochs", "[", "0", "]", "# flat", "\n", "lr", "=", "LR", "(", ")", ".", "fit", "(", "feat", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "flr", "=", "LR", "(", ")", ".", "fit", "(", "ffeat", ",", "ftarget", "[", ":", ",", "0", "]", ")", "\n", "def", "pred", "(", "v", ")", ":", "\n", "        ", "return", "lr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "def", "fpred", "(", "v", ")", ":", "\n", "        ", "return", "flr", ".", "predict_proba", "(", "[", "v", "]", ")", "[", "0", ",", "1", "]", "\n", "", "assert", "len", "(", "allepochs", "[", "1", "]", "[", "0", "]", ")", ">", "15", "# number of merges is more than LASH", "\n", "\n", "# approx. same learning results at (0., 0.) and (1., 0.)", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.2", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "0", "]", ")", ",", "0.2", ",", "atol", "=", "0.2", ")", "\n", "assert_allclose", "(", "fpred", "(", "[", "1", ",", "0", "]", ")", ",", "0.65", ",", "atol", "=", "0.15", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "1", ",", "0", "]", ")", ",", "0.65", ",", "atol", "=", "0.15", ")", "\n", "\n", "# difference between agglomerative and flat learning in point (0., 1.);", "\n", "# greater separation than with LASH", "\n", "assert_allclose", "(", "fpred", "(", "[", "0", ",", "1", "]", ")", ",", "0.2", ",", "atol", "=", "0.15", ")", "\n", "assert_allclose", "(", "pred", "(", "[", "0", ",", "1", "]", ")", ",", "0.7", ",", "atol", "=", "0.15", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.test_segment_with_gala_classifer": [[247, 268], ["numpy.random.seed", "g.learn_agglomerate", "LR().fit", "gala.agglo.classifier_probability", "LR().fit", "gala.agglo.classifier_probability", "gala.agglo.Rag", "agglo.Rag.agglomerate", "gala.agglo.Rag", "gala.evaluate.vi", "gala.evaluate.vi", "LR", "LR", "agglo.Rag.get_segmentation", "agglo.Rag.get_segmentation"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.learn_agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.classifier_probability", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.classify.VigraRandomForest.fit", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.classifier_probability", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.agglomerate", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.evaluate.vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.get_segmentation"], ["", "def", "test_segment_with_gala_classifer", "(", "dummy_data_fast", ")", ":", "\n", "    ", "frag", ",", "gt", ",", "g", ",", "fman", "=", "dummy_data_fast", "\n", "np", ".", "random", ".", "seed", "(", "5", ")", "\n", "summary", ",", "allepochs", "=", "g", ".", "learn_agglomerate", "(", "gt", ",", "fman", ",", "\n", "learning_mode", "=", "'strict'", ",", "\n", "classifier", "=", "'logistic regression'", ",", "\n", "min_num_epochs", "=", "5", ")", "\n", "feat", ",", "target", ",", "weights", ",", "edges", "=", "summary", "\n", "ffeat", ",", "ftarget", ",", "fweights", ",", "fedges", "=", "allepochs", "[", "0", "]", "# flat", "\n", "lr", "=", "LR", "(", ")", ".", "fit", "(", "feat", ",", "target", "[", ":", ",", "0", "]", ")", "\n", "gala_policy", "=", "agglo", ".", "classifier_probability", "(", "fman", ",", "lr", ")", "\n", "flr", "=", "LR", "(", ")", ".", "fit", "(", "ffeat", ",", "ftarget", "[", ":", ",", "0", "]", ")", "\n", "flat_policy", "=", "agglo", ".", "classifier_probability", "(", "fman", ",", "flr", ")", "\n", "\n", "gtest", "=", "agglo", ".", "Rag", "(", "frag", ",", "feature_manager", "=", "fman", ",", "\n", "merge_priority_function", "=", "gala_policy", ")", "\n", "gtest", ".", "agglomerate", "(", "0.5", ")", "\n", "assert", "ev", ".", "vi", "(", "gtest", ".", "get_segmentation", "(", ")", ",", "gt", ")", "==", "0", "\n", "gtest_flat", "=", "agglo", ".", "Rag", "(", "frag", ",", "feature_manager", "=", "fman", ",", "\n", "merge_priority_function", "=", "flat_policy", ")", "\n", "assert", "ev", ".", "vi", "(", "gtest_flat", ".", "get_segmentation", "(", "0.5", ")", ",", "gt", ")", "==", "1.5", "\n", "\n"]], "home.repos.pwc.inspect_result.janelia-flyem_gala.tests.test_gala.test_split_vi": [[270, 286], ["gala.imio.read_h5_stack", "gala.imio.read_h5_stack", "gala.imio.read_h5_stack", "gala.imio.read_h5_stack", "numpy.vstack", "numpy.load", "numpy.testing.assert_allclose", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "gala.evaluate.split_vi", "gala.evaluate.split_vi", "gala.evaluate.split_vi"], "function", ["home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.imio.read_h5_stack", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi", "home.repos.pwc.inspect_result.janelia-flyem_gala.gala.agglo.Rag.split_vi"], ["", "def", "test_split_vi", "(", ")", ":", "\n", "    ", "ws_test", "=", "imio", ".", "read_h5_stack", "(", "\n", "os", ".", "path", ".", "join", "(", "rundir", ",", "'example-data/test-ws.lzf.h5'", ")", ")", "\n", "gt_test", "=", "imio", ".", "read_h5_stack", "(", "\n", "os", ".", "path", ".", "join", "(", "rundir", ",", "'example-data/test-gt.lzf.h5'", ")", ")", "\n", "seg_test1", "=", "imio", ".", "read_h5_stack", "(", "\n", "os", ".", "path", ".", "join", "(", "rundir", ",", "'example-data/test-seg1.lzf.h5'", ")", ")", "\n", "seg_test4", "=", "imio", ".", "read_h5_stack", "(", "\n", "os", ".", "path", ".", "join", "(", "rundir", ",", "'example-data/test-seg4.lzf.h5'", ")", ")", "\n", "result", "=", "np", ".", "vstack", "(", "(", "\n", "ev", ".", "split_vi", "(", "ws_test", ",", "gt_test", ")", ",", "\n", "ev", ".", "split_vi", "(", "seg_test1", ",", "gt_test", ")", ",", "\n", "ev", ".", "split_vi", "(", "seg_test4", ",", "gt_test", ")", "\n", ")", ")", "\n", "expected", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "rundir", ",", "'example-data/vi-results.npy'", ")", ")", "\n", "assert_allclose", "(", "result", ",", "expected", ",", "atol", "=", "1e-6", ")", "\n", "\n"]]}