{"home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.__init__": [[30, 79], ["os.exists", "time.time", "dict", "nuscenes.utils.color_map.get_colormap", "print", "nuimages.NuImages.__load_table__", "nuimages.NuImages.__load_table__", "nuimages.NuImages.__load_table__", "nuimages.NuImages.__load_table__", "nuimages.NuImages.__load_table__", "nuimages.NuImages.__load_table__", "nuimages.NuImages.__load_table__", "nuimages.NuImages.__load_table__", "nuimages.NuImages.__load_table__", "nuimages.NuImages.__load_table__", "print", "time.time"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.color_map.get_colormap", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__"], ["def", "__init__", "(", "self", ",", "\n", "version", ":", "str", "=", "'v1.0-mini'", ",", "\n", "dataroot", ":", "str", "=", "'/data/sets/nuimages'", ",", "\n", "lazy", ":", "bool", "=", "True", ",", "\n", "verbose", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Loads database and creates reverse indexes and shortcuts.\n        :param version: Version to load (e.g. \"v1.0-train\", \"v1.0-val\", \"v1.0-test\", \"v1.0-mini\").\n        :param dataroot: Path to the tables and data.\n        :param lazy: Whether to use lazy loading for the database tables.\n        :param verbose: Whether to print status messages during load.\n        \"\"\"", "\n", "self", ".", "version", "=", "version", "\n", "self", ".", "dataroot", "=", "dataroot", "\n", "self", ".", "lazy", "=", "lazy", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "table_names", "=", "[", "'attribute'", ",", "'calibrated_sensor'", ",", "'category'", ",", "'ego_pose'", ",", "'log'", ",", "'object_ann'", ",", "'sample'", ",", "\n", "'sample_data'", ",", "'sensor'", ",", "'surface_ann'", "]", "\n", "\n", "assert", "osp", ".", "exists", "(", "self", ".", "table_root", ")", ",", "'Database version not found: {}'", ".", "format", "(", "self", ".", "table_root", ")", "\n", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"======\\nLoading nuImages tables for version {}...\"", ".", "format", "(", "self", ".", "version", ")", ")", "\n", "\n", "# Init reverse indexing.", "\n", "", "self", ".", "_token2ind", ":", "Dict", "[", "str", ",", "Optional", "[", "dict", "]", "]", "=", "dict", "(", ")", "\n", "for", "table", "in", "self", ".", "table_names", ":", "\n", "            ", "self", ".", "_token2ind", "[", "table", "]", "=", "None", "\n", "\n", "# Load tables directly if requested.", "\n", "", "if", "not", "self", ".", "lazy", ":", "\n", "# Explicitly init tables to help the IDE determine valid class members.", "\n", "            ", "self", ".", "attribute", "=", "self", ".", "__load_table__", "(", "'attribute'", ")", "\n", "self", ".", "calibrated_sensor", "=", "self", ".", "__load_table__", "(", "'calibrated_sensor'", ")", "\n", "self", ".", "category", "=", "self", ".", "__load_table__", "(", "'category'", ")", "\n", "self", ".", "ego_pose", "=", "self", ".", "__load_table__", "(", "'ego_pose'", ")", "\n", "self", ".", "log", "=", "self", ".", "__load_table__", "(", "'log'", ")", "\n", "self", ".", "object_ann", "=", "self", ".", "__load_table__", "(", "'object_ann'", ")", "\n", "self", ".", "sample", "=", "self", ".", "__load_table__", "(", "'sample'", ")", "\n", "self", ".", "sample_data", "=", "self", ".", "__load_table__", "(", "'sample_data'", ")", "\n", "self", ".", "sensor", "=", "self", ".", "__load_table__", "(", "'sensor'", ")", "\n", "self", ".", "surface_ann", "=", "self", ".", "__load_table__", "(", "'surface_ann'", ")", "\n", "\n", "", "self", ".", "color_map", "=", "get_colormap", "(", ")", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Done loading in {:.3f} seconds (lazy={}).\\n======\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time", ",", "self", ".", "lazy", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.__getattr__": [[82, 92], ["nuimages.NuImages._load_lazy", "AttributeError", "nuimages.NuImages.__load_table__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages._load_lazy", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__"], ["", "", "def", "__getattr__", "(", "self", ",", "attr_name", ":", "str", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Implement lazy loading for the database tables. Otherwise throw the default error.\n        :param attr_name: The name of the variable to look for.\n        :return: The dictionary that represents that table.\n        \"\"\"", "\n", "if", "attr_name", "in", "self", ".", "table_names", ":", "\n", "            ", "return", "self", ".", "_load_lazy", "(", "attr_name", ",", "lambda", "tab_name", ":", "self", ".", "__load_table__", "(", "tab_name", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Error: %r object has no attribute %r\"", "%", "(", "self", ".", "__class__", ".", "__name__", ",", "attr_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get": [[93, 103], ["getattr", "nuimages.NuImages.getind"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.getind"], ["", "", "def", "get", "(", "self", ",", "table_name", ":", "str", ",", "token", ":", "str", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Returns a record from table in constant runtime.\n        :param table_name: Table name.\n        :param token: Token of the record.\n        :return: Table record. See README.md for record details for each table.\n        \"\"\"", "\n", "assert", "table_name", "in", "self", ".", "table_names", ",", "\"Table {} not found\"", ".", "format", "(", "table_name", ")", "\n", "\n", "return", "getattr", "(", "self", ",", "table_name", ")", "[", "self", ".", "getind", "(", "table_name", ",", "token", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.getind": [[104, 118], ["dict", "enumerate", "getattr"], "methods", ["None"], ["", "def", "getind", "(", "self", ",", "table_name", ":", "str", ",", "token", ":", "str", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        This returns the index of the record in a table in constant runtime.\n        :param table_name: Table name.\n        :param token: Token of the record.\n        :return: The index of the record in table, table is an array.\n        \"\"\"", "\n", "# Lazy loading: Compute reverse indices.", "\n", "if", "self", ".", "_token2ind", "[", "table_name", "]", "is", "None", ":", "\n", "            ", "self", ".", "_token2ind", "[", "table_name", "]", "=", "dict", "(", ")", "\n", "for", "ind", ",", "member", "in", "enumerate", "(", "getattr", "(", "self", ",", "table_name", ")", ")", ":", "\n", "                ", "self", ".", "_token2ind", "[", "table_name", "]", "[", "member", "[", "'token'", "]", "]", "=", "ind", "\n", "\n", "", "", "return", "self", ".", "_token2ind", "[", "table_name", "]", "[", "token", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.table_root": [[119, 125], ["os.join"], "methods", ["None"], ["", "@", "property", "\n", "def", "table_root", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"\n        Returns the folder where the tables are stored for the relevant version.\n        \"\"\"", "\n", "return", "osp", ".", "join", "(", "self", ".", "dataroot", ",", "self", ".", "version", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.load_tables": [[126, 133], ["nuimages.NuImages._load_lazy", "nuimages.NuImages.__load_table__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages._load_lazy", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__"], ["", "def", "load_tables", "(", "self", ",", "table_names", ":", "List", "[", "str", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Load tables and add them to self, if not already loaded.\n        :param table_names: The names of the nuImages tables to be loaded.\n        \"\"\"", "\n", "for", "table_name", "in", "table_names", ":", "\n", "            ", "self", ".", "_load_lazy", "(", "table_name", ",", "lambda", "tab_name", ":", "self", ".", "__load_table__", "(", "tab_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages._load_lazy": [[134, 147], ["nuimages.NuImages.__dict__.keys", "nuimages.NuImages.__getattribute__", "loading_func", "nuimages.NuImages.__setattr__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.__setattr__"], ["", "", "def", "_load_lazy", "(", "self", ",", "attr_name", ":", "str", ",", "loading_func", ":", "Callable", ")", "->", "Any", ":", "\n", "        ", "\"\"\"\n        Load an attribute and add it to self, if it isn't already loaded.\n        :param attr_name: The name of the attribute to be loaded.\n        :param loading_func: The function used to load it if necessary.\n        :return: The loaded attribute.\n        \"\"\"", "\n", "if", "attr_name", "in", "self", ".", "__dict__", ".", "keys", "(", ")", ":", "\n", "            ", "return", "self", ".", "__getattribute__", "(", "attr_name", ")", "\n", "", "else", ":", "\n", "            ", "attr", "=", "loading_func", "(", "attr_name", ")", "\n", "self", ".", "__setattr__", "(", "attr_name", ",", "attr", ")", "\n", "return", "attr", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.__load_table__": [[148, 166], ["time.time", "os.join", "os.exists", "time.time", "open", "json.load", "print", "len"], "methods", ["None"], ["", "", "def", "__load_table__", "(", "self", ",", "table_name", ")", "->", "List", "[", "dict", "]", ":", "\n", "        ", "\"\"\"\n        Load a table and return it.\n        :param table_name: The name of the table to load.\n        :return: The table dictionary.\n        \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "table_path", "=", "osp", ".", "join", "(", "self", ".", "table_root", ",", "'{}.json'", ".", "format", "(", "table_name", ")", ")", "\n", "assert", "osp", ".", "exists", "(", "table_path", ")", ",", "'Error: Table %s does not exist!'", "%", "table_name", "\n", "with", "open", "(", "table_path", ")", "as", "f", ":", "\n", "            ", "table", "=", "json", ".", "load", "(", "f", ")", "\n", "", "end_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# Print a message to stdout.", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"Loaded {} {}(s) in {:.3f}s,\"", ".", "format", "(", "len", "(", "table", ")", ",", "table_name", ",", "end_time", "-", "start_time", ")", ")", "\n", "\n", "", "return", "table", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.shortcut": [[167, 190], ["nuimages.NuImages.get", "nuimages.NuImages.get", "nuimages.NuImages.get", "nuimages.NuImages.get", "nuimages.NuImages.get", "nuimages.NuImages.get", "Exception"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "shortcut", "(", "self", ",", "src_table", ":", "str", ",", "tgt_table", ":", "str", ",", "src_token", ":", "str", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Convenience function to navigate between different tables that have one-to-one relations.\n        E.g. we can use this function to conveniently retrieve the sensor for a sample_data.\n        :param src_table: The name of the source table.\n        :param tgt_table: The name of the target table.\n        :param src_token: The source token.\n        :return: The entry of the destination table corresponding to the source token.\n        \"\"\"", "\n", "if", "src_table", "==", "'sample_data'", "and", "tgt_table", "==", "'sensor'", ":", "\n", "            ", "sample_data", "=", "self", ".", "get", "(", "'sample_data'", ",", "src_token", ")", "\n", "calibrated_sensor", "=", "self", ".", "get", "(", "'calibrated_sensor'", ",", "sample_data", "[", "'calibrated_sensor_token'", "]", ")", "\n", "sensor", "=", "self", ".", "get", "(", "'sensor'", ",", "calibrated_sensor", "[", "'sensor_token'", "]", ")", "\n", "\n", "return", "sensor", "\n", "", "elif", "(", "src_table", "==", "'object_ann'", "or", "src_table", "==", "'surface_ann'", ")", "and", "tgt_table", "==", "'sample'", ":", "\n", "            ", "src", "=", "self", ".", "get", "(", "src_table", ",", "src_token", ")", "\n", "sample_data", "=", "self", ".", "get", "(", "'sample_data'", ",", "src", "[", "'sample_data_token'", "]", ")", "\n", "sample", "=", "self", ".", "get", "(", "'sample'", ",", "sample_data", "[", "'sample_token'", "]", ")", "\n", "\n", "return", "sample", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Error: Shortcut from %s to %s not implemented!'", "%", "(", "src_table", ",", "tgt_table", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.check_sweeps": [[191, 205], ["filename.startswith", "filename.startswith", "os.join", "os.isdir", "Exception"], "methods", ["None"], ["", "", "def", "check_sweeps", "(", "self", ",", "filename", ":", "str", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Check that the sweeps folder was downloaded if required.\n        :param filename: The filename of the sample_data.\n        \"\"\"", "\n", "assert", "filename", ".", "startswith", "(", "'samples'", ")", "or", "filename", ".", "startswith", "(", "'sweeps'", ")", ",", "'Error: You passed an incorrect filename to check_sweeps(). Please use sample_data['", "'filename'", "'].'", "\n", "\n", "if", "'sweeps'", "in", "filename", ":", "\n", "            ", "sweeps_dir", "=", "osp", ".", "join", "(", "self", ".", "dataroot", ",", "'sweeps'", ")", "\n", "if", "not", "osp", ".", "isdir", "(", "sweeps_dir", ")", ":", "\n", "                ", "raise", "Exception", "(", "'Error: You are missing the \"%s\" directory! The devkit generally works without this '", "\n", "'directory, but you cannot call methods that use non-keyframe sample_datas.'", "\n", "%", "sweeps_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.list_attributes": [[208, 241], ["collections.defaultdict", "print", "print", "nuimages.NuImages.load_tables", "format_str.format", "print", "Exception", "format_str.format", "sorted", "enumerate", "sorted", "enumerate"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.load_tables"], ["", "", "", "def", "list_attributes", "(", "self", ",", "sort_by", ":", "str", "=", "'freq'", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        List all attributes and the number of annotations with each attribute.\n        :param sort_by: Sorting criteria, e.g. \"name\", \"freq\".\n        \"\"\"", "\n", "# Preload data if in lazy load to avoid confusing outputs.", "\n", "if", "self", ".", "lazy", ":", "\n", "            ", "self", ".", "load_tables", "(", "[", "'attribute'", ",", "'object_ann'", "]", ")", "\n", "\n", "# Count attributes.", "\n", "", "attribute_freqs", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "for", "object_ann", "in", "self", ".", "object_ann", ":", "\n", "            ", "for", "attribute_token", "in", "object_ann", "[", "'attribute_tokens'", "]", ":", "\n", "                ", "attribute_freqs", "[", "attribute_token", "]", "+=", "1", "\n", "\n", "# Sort entries.", "\n", "", "", "if", "sort_by", "==", "'name'", ":", "\n", "            ", "sort_order", "=", "[", "i", "for", "(", "i", ",", "_", ")", "in", "sorted", "(", "enumerate", "(", "self", ".", "attribute", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", "[", "'name'", "]", ")", "]", "\n", "", "elif", "sort_by", "==", "'freq'", ":", "\n", "            ", "attribute_freqs_order", "=", "[", "attribute_freqs", "[", "c", "[", "'token'", "]", "]", "for", "c", "in", "self", ".", "attribute", "]", "\n", "sort_order", "=", "[", "i", "for", "(", "i", ",", "_", ")", "in", "\n", "sorted", "(", "enumerate", "(", "attribute_freqs_order", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", "]", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Error: Invalid sorting criterion %s!'", "%", "sort_by", ")", "\n", "\n", "# Print to stdout.", "\n", "", "format_str", "=", "'{:11} {:24.24} {:48.48}'", "\n", "print", "(", ")", "\n", "print", "(", "format_str", ".", "format", "(", "'Annotations'", ",", "'Name'", ",", "'Description'", ")", ")", "\n", "for", "s", "in", "sort_order", ":", "\n", "            ", "attribute", "=", "self", ".", "attribute", "[", "s", "]", "\n", "print", "(", "format_str", ".", "format", "(", "\n", "attribute_freqs", "[", "attribute", "[", "'token'", "]", "]", ",", "attribute", "[", "'name'", "]", ",", "attribute", "[", "'description'", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.list_cameras": [[242, 270], ["collections.defaultdict", "collections.defaultdict", "print", "print", "collections.defaultdict.keys", "nuimages.NuImages.load_tables", "nuimages.NuImages.get", "format_str.format", "print", "nuimages.NuImages.shortcut", "format_str.format"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.load_tables", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.shortcut"], ["", "", "def", "list_cameras", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        List all cameras and the number of samples for each.\n        \"\"\"", "\n", "# Preload data if in lazy load to avoid confusing outputs.", "\n", "if", "self", ".", "lazy", ":", "\n", "            ", "self", ".", "load_tables", "(", "[", "'sample'", ",", "'sample_data'", ",", "'calibrated_sensor'", ",", "'sensor'", "]", ")", "\n", "\n", "# Count cameras.", "\n", "", "cs_freqs", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "channel_freqs", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "for", "calibrated_sensor", "in", "self", ".", "calibrated_sensor", ":", "\n", "            ", "sensor", "=", "self", ".", "get", "(", "'sensor'", ",", "calibrated_sensor", "[", "'sensor_token'", "]", ")", "\n", "cs_freqs", "[", "sensor", "[", "'channel'", "]", "]", "+=", "1", "\n", "", "for", "sample_data", "in", "self", ".", "sample_data", ":", "\n", "            ", "if", "sample_data", "[", "'is_key_frame'", "]", ":", "# Only use keyframes (samples).", "\n", "                ", "sensor", "=", "self", ".", "shortcut", "(", "'sample_data'", ",", "'sensor'", ",", "sample_data", "[", "'token'", "]", ")", "\n", "channel_freqs", "[", "sensor", "[", "'channel'", "]", "]", "+=", "1", "\n", "\n", "# Print to stdout.", "\n", "", "", "format_str", "=", "'{:15} {:7} {:25}'", "\n", "print", "(", ")", "\n", "print", "(", "format_str", ".", "format", "(", "'Calibr. sensors'", ",", "'Samples'", ",", "'Channel'", ")", ")", "\n", "for", "channel", "in", "cs_freqs", ".", "keys", "(", ")", ":", "\n", "            ", "cs_freq", "=", "cs_freqs", "[", "channel", "]", "\n", "channel_freq", "=", "channel_freqs", "[", "channel", "]", "\n", "print", "(", "format_str", ".", "format", "(", "\n", "cs_freq", ",", "channel_freq", ",", "channel", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.list_categories": [[271, 327], ["collections.defaultdict", "collections.defaultdict", "print", "print", "nuimages.NuImages.load_tables", "set", "nuimages.NuImages.shortcut", "nuimages.NuImages.shortcut", "format_str.format", "print", "format_str.format", "sorted", "Exception", "enumerate", "sorted", "enumerate", "sorted", "enumerate"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.load_tables", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.shortcut", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.shortcut"], ["", "", "def", "list_categories", "(", "self", ",", "sample_tokens", ":", "List", "[", "str", "]", "=", "None", ",", "sort_by", ":", "str", "=", "'object_freq'", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        List all categories and the number of object_anns and surface_anns for them.\n        :param sample_tokens: A list of sample tokens for which category stats will be shown.\n        :param sort_by: Sorting criteria, e.g. \"name\", \"object_freq\", \"surface_freq\".\n        \"\"\"", "\n", "# Preload data if in lazy load to avoid confusing outputs.", "\n", "if", "self", ".", "lazy", ":", "\n", "            ", "self", ".", "load_tables", "(", "[", "'sample'", ",", "'object_ann'", ",", "'surface_ann'", ",", "'category'", "]", ")", "\n", "\n", "# Count object_anns and surface_anns.", "\n", "", "object_freqs", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "surface_freqs", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "if", "sample_tokens", "is", "not", "None", ":", "\n", "            ", "sample_tokens", "=", "set", "(", "sample_tokens", ")", "\n", "\n", "", "for", "object_ann", "in", "self", ".", "object_ann", ":", "\n", "            ", "sample", "=", "self", ".", "shortcut", "(", "'object_ann'", ",", "'sample'", ",", "object_ann", "[", "'token'", "]", ")", "\n", "if", "sample_tokens", "is", "None", "or", "sample", "[", "'token'", "]", "in", "sample_tokens", ":", "\n", "                ", "object_freqs", "[", "object_ann", "[", "'category_token'", "]", "]", "+=", "1", "\n", "\n", "", "", "for", "surface_ann", "in", "self", ".", "surface_ann", ":", "\n", "            ", "sample", "=", "self", ".", "shortcut", "(", "'surface_ann'", ",", "'sample'", ",", "surface_ann", "[", "'token'", "]", ")", "\n", "if", "sample_tokens", "is", "None", "or", "sample", "[", "'token'", "]", "in", "sample_tokens", ":", "\n", "                ", "surface_freqs", "[", "surface_ann", "[", "'category_token'", "]", "]", "+=", "1", "\n", "\n", "# Sort entries.", "\n", "", "", "if", "sort_by", "==", "'name'", ":", "\n", "            ", "sort_order", "=", "[", "i", "for", "(", "i", ",", "_", ")", "in", "sorted", "(", "enumerate", "(", "self", ".", "category", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", "[", "'name'", "]", ")", "]", "\n", "", "elif", "sort_by", "==", "'object_freq'", ":", "\n", "            ", "object_freqs_order", "=", "[", "object_freqs", "[", "c", "[", "'token'", "]", "]", "for", "c", "in", "self", ".", "category", "]", "\n", "sort_order", "=", "[", "i", "for", "(", "i", ",", "_", ")", "in", "sorted", "(", "enumerate", "(", "object_freqs_order", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", "]", "\n", "", "elif", "sort_by", "==", "'surface_freq'", ":", "\n", "            ", "surface_freqs_order", "=", "[", "surface_freqs", "[", "c", "[", "'token'", "]", "]", "for", "c", "in", "self", ".", "category", "]", "\n", "sort_order", "=", "[", "i", "for", "(", "i", ",", "_", ")", "in", "sorted", "(", "enumerate", "(", "surface_freqs_order", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", "]", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Error: Invalid sorting criterion %s!'", "%", "sort_by", ")", "\n", "\n", "# Print to stdout.", "\n", "", "format_str", "=", "'{:11} {:12} {:24.24} {:48.48}'", "\n", "print", "(", ")", "\n", "print", "(", "format_str", ".", "format", "(", "'Object_anns'", ",", "'Surface_anns'", ",", "'Name'", ",", "'Description'", ")", ")", "\n", "for", "s", "in", "sort_order", ":", "\n", "            ", "category", "=", "self", ".", "category", "[", "s", "]", "\n", "category_token", "=", "category", "[", "'token'", "]", "\n", "object_freq", "=", "object_freqs", "[", "category_token", "]", "\n", "surface_freq", "=", "surface_freqs", "[", "category_token", "]", "\n", "\n", "# Skip empty categories.", "\n", "if", "object_freq", "==", "0", "and", "surface_freq", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "name", "=", "category", "[", "'name'", "]", "\n", "description", "=", "category", "[", "'description'", "]", "\n", "print", "(", "format_str", ".", "format", "(", "\n", "object_freq", ",", "surface_freq", ",", "name", ",", "description", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.list_anns": [[328, 359], ["nuimages.NuImages.get", "nuimages.NuImages.load_tables", "print", "print", "nuimages.NuImages.get", "print", "nuimages.NuImages.get", "print", "nuimages.NuImages.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.load_tables", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "list_anns", "(", "self", ",", "sample_token", ":", "str", ",", "verbose", ":", "bool", "=", "True", ")", "->", "Tuple", "[", "List", "[", "str", "]", ",", "List", "[", "str", "]", "]", ":", "\n", "        ", "\"\"\"\n        List all the annotations of a sample.\n        :param sample_token: Sample token.\n        :param verbose: Whether to print to stdout.\n        :return: The object and surface annotation tokens in this sample.\n        \"\"\"", "\n", "# Preload data if in lazy load to avoid confusing outputs.", "\n", "if", "self", ".", "lazy", ":", "\n", "            ", "self", ".", "load_tables", "(", "[", "'sample'", ",", "'object_ann'", ",", "'surface_ann'", ",", "'category'", "]", ")", "\n", "\n", "", "sample", "=", "self", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "key_camera_token", "=", "sample", "[", "'key_camera_token'", "]", "\n", "object_anns", "=", "[", "o", "for", "o", "in", "self", ".", "object_ann", "if", "o", "[", "'sample_data_token'", "]", "==", "key_camera_token", "]", "\n", "surface_anns", "=", "[", "o", "for", "o", "in", "self", ".", "surface_ann", "if", "o", "[", "'sample_data_token'", "]", "==", "key_camera_token", "]", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Printing object annotations:'", ")", "\n", "for", "object_ann", "in", "object_anns", ":", "\n", "                ", "category", "=", "self", ".", "get", "(", "'category'", ",", "object_ann", "[", "'category_token'", "]", ")", "\n", "attribute_names", "=", "[", "self", ".", "get", "(", "'attribute'", ",", "at", ")", "[", "'name'", "]", "for", "at", "in", "object_ann", "[", "'attribute_tokens'", "]", "]", "\n", "print", "(", "'{} {} {}'", ".", "format", "(", "object_ann", "[", "'token'", "]", ",", "category", "[", "'name'", "]", ",", "attribute_names", ")", ")", "\n", "\n", "", "print", "(", "'\\nPrinting surface annotations:'", ")", "\n", "for", "surface_ann", "in", "surface_anns", ":", "\n", "                ", "category", "=", "self", ".", "get", "(", "'category'", ",", "surface_ann", "[", "'category_token'", "]", ")", "\n", "print", "(", "surface_ann", "[", "'token'", "]", ",", "category", "[", "'name'", "]", ")", "\n", "\n", "", "", "object_tokens", "=", "[", "o", "[", "'token'", "]", "for", "o", "in", "object_anns", "]", "\n", "surface_tokens", "=", "[", "s", "[", "'token'", "]", "for", "s", "in", "surface_anns", "]", "\n", "return", "object_tokens", ",", "surface_tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.list_logs": [[360, 383], ["collections.defaultdict", "print", "print", "nuimages.NuImages.load_tables", "format_str.format", "print", "format_str.format"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.load_tables"], ["", "def", "list_logs", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        List all logs and the number of samples per log.\n        \"\"\"", "\n", "# Preload data if in lazy load to avoid confusing outputs.", "\n", "if", "self", ".", "lazy", ":", "\n", "            ", "self", ".", "load_tables", "(", "[", "'sample'", ",", "'log'", "]", ")", "\n", "\n", "# Count samples.", "\n", "", "sample_freqs", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "for", "sample", "in", "self", ".", "sample", ":", "\n", "            ", "sample_freqs", "[", "sample", "[", "'log_token'", "]", "]", "+=", "1", "\n", "\n", "# Print to stdout.", "\n", "", "format_str", "=", "'{:6} {:29} {:24}'", "\n", "print", "(", ")", "\n", "print", "(", "format_str", ".", "format", "(", "'Samples'", ",", "'Log'", ",", "'Location'", ")", ")", "\n", "for", "log", "in", "self", ".", "log", ":", "\n", "            ", "sample_freq", "=", "sample_freqs", "[", "log", "[", "'token'", "]", "]", "\n", "logfile", "=", "log", "[", "'logfile'", "]", "\n", "location", "=", "log", "[", "'location'", "]", "\n", "print", "(", "format_str", ".", "format", "(", "\n", "sample_freq", ",", "logfile", ",", "location", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.list_sample_content": [[384, 403], ["nuimages.NuImages.get", "nuimages.NuImages.get_sample_content", "numpy.array", "print", "print", "zip", "nuimages.NuImages.load_tables", "print", "nuimages.NuImages.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_sample_content", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.load_tables", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "list_sample_content", "(", "self", ",", "sample_token", ":", "str", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        List the sample_datas for a given sample.\n        :param sample_token: Sample token.\n        \"\"\"", "\n", "# Preload data if in lazy load to avoid confusing outputs.", "\n", "if", "self", ".", "lazy", ":", "\n", "            ", "self", ".", "load_tables", "(", "[", "'sample'", ",", "'sample_data'", "]", ")", "\n", "\n", "# Print content for each modality.", "\n", "", "sample", "=", "self", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "sample_data_tokens", "=", "self", ".", "get_sample_content", "(", "sample_token", ")", "\n", "timestamps", "=", "np", ".", "array", "(", "[", "self", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "[", "'timestamp'", "]", "for", "sd_token", "in", "sample_data_tokens", "]", ")", "\n", "rel_times", "=", "(", "timestamps", "-", "sample", "[", "'timestamp'", "]", ")", "/", "1e6", "\n", "\n", "print", "(", "'\\nListing sample content...'", ")", "\n", "print", "(", "'Rel. time\\tSample_data token'", ")", "\n", "for", "rel_time", ",", "sample_data_token", "in", "zip", "(", "rel_times", ",", "sample_data_tokens", ")", ":", "\n", "            ", "print", "(", "'{:>9.1f}\\t{}'", ".", "format", "(", "rel_time", ",", "sample_data_token", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.list_sample_data_histogram": [[404, 432], ["collections.defaultdict", "numpy.array", "print", "print", "zip", "nuimages.NuImages.load_tables", "list", "numpy.max", "numpy.min", "numpy.histogram", "print", "collections.defaultdict.values", "len", "int", "int"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.load_tables"], ["", "", "def", "list_sample_data_histogram", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Show a histogram of the number of sample_datas per sample.\n        \"\"\"", "\n", "# Preload data if in lazy load to avoid confusing outputs.", "\n", "if", "self", ".", "lazy", ":", "\n", "            ", "self", ".", "load_tables", "(", "[", "'sample_data'", "]", ")", "\n", "\n", "# Count sample_datas for each sample.", "\n", "", "sample_counts", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "for", "sample_data", "in", "self", ".", "sample_data", ":", "\n", "            ", "sample_counts", "[", "sample_data", "[", "'sample_token'", "]", "]", "+=", "1", "\n", "\n", "# Compute histogram.", "\n", "", "sample_counts_list", "=", "np", ".", "array", "(", "list", "(", "sample_counts", ".", "values", "(", ")", ")", ")", "\n", "bin_range", "=", "np", ".", "max", "(", "sample_counts_list", ")", "-", "np", ".", "min", "(", "sample_counts_list", ")", "\n", "if", "bin_range", "==", "0", ":", "\n", "            ", "values", "=", "[", "len", "(", "sample_counts_list", ")", "]", "\n", "freqs", "=", "[", "sample_counts_list", "[", "0", "]", "]", "\n", "", "else", ":", "\n", "            ", "values", ",", "bins", "=", "np", ".", "histogram", "(", "sample_counts_list", ",", "bin_range", ")", "\n", "freqs", "=", "bins", "[", "1", ":", "]", "# To get the frequency we need to use the right side of the bin.", "\n", "\n", "# Print statistics.", "\n", "", "print", "(", "'\\nListing sample_data frequencies..'", ")", "\n", "print", "(", "'# images\\t# samples'", ")", "\n", "for", "freq", ",", "val", "in", "zip", "(", "freqs", ",", "values", ")", ":", "\n", "            ", "print", "(", "'{:>8d}\\t{:d}'", ".", "format", "(", "int", "(", "freq", ")", ",", "int", "(", "val", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_sample_content": [[435, 463], ["nuimages.NuImages.get", "nuimages.NuImages.get", "nuimages.NuImages.get", "forward.append", "nuimages.NuImages.get", "backward.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "get_sample_content", "(", "self", ",", "\n", "sample_token", ":", "str", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"\n        For a given sample, return all the sample_datas in chronological order.\n        :param sample_token: Sample token.\n        :return: A list of sample_data tokens sorted by their timestamp.\n        \"\"\"", "\n", "sample", "=", "self", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "key_sd", "=", "self", ".", "get", "(", "'sample_data'", ",", "sample", "[", "'key_camera_token'", "]", ")", "\n", "\n", "# Go forward.", "\n", "cur_sd", "=", "key_sd", "\n", "forward", "=", "[", "]", "\n", "while", "cur_sd", "[", "'next'", "]", "!=", "''", ":", "\n", "            ", "cur_sd", "=", "self", ".", "get", "(", "'sample_data'", ",", "cur_sd", "[", "'next'", "]", ")", "\n", "forward", ".", "append", "(", "cur_sd", "[", "'token'", "]", ")", "\n", "\n", "# Go backward.", "\n", "", "cur_sd", "=", "key_sd", "\n", "backward", "=", "[", "]", "\n", "while", "cur_sd", "[", "'prev'", "]", "!=", "''", ":", "\n", "            ", "cur_sd", "=", "self", ".", "get", "(", "'sample_data'", ",", "cur_sd", "[", "'prev'", "]", ")", "\n", "backward", ".", "append", "(", "cur_sd", "[", "'token'", "]", ")", "\n", "\n", "# Combine.", "\n", "", "result", "=", "backward", "[", ":", ":", "-", "1", "]", "+", "[", "key_sd", "[", "'token'", "]", "]", "+", "forward", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_ego_pose_data": [[464, 501], ["nuimages.NuImages.get_sample_content", "numpy.zeros", "numpy.zeros", "enumerate", "len", "nuimages.NuImages.get", "nuimages.NuImages.get", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_sample_content", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_ego_pose_data", "(", "self", ",", "\n", "sample_token", ":", "str", ",", "\n", "attribute_name", ":", "str", "=", "'translation'", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return the ego pose data of the <= 13 sample_datas associated with this sample.\n        The method return translation, rotation, rotation_rate, acceleration and speed.\n        :param sample_token: Sample token.\n        :param attribute_name: The ego_pose field to extract, e.g. \"translation\", \"acceleration\" or \"speed\".\n        :return: (\n            timestamps: The timestamp of each ego_pose.\n            attributes: A matrix with sample_datas x len(attribute) number of fields.\n        )\n        \"\"\"", "\n", "assert", "attribute_name", "in", "[", "'translation'", ",", "'rotation'", ",", "'rotation_rate'", ",", "'acceleration'", ",", "'speed'", "]", ",", "'Error: The attribute_name %s is not a valid option!'", "%", "attribute_name", "\n", "\n", "if", "attribute_name", "==", "'speed'", ":", "\n", "            ", "attribute_len", "=", "1", "\n", "", "elif", "attribute_name", "==", "'rotation'", ":", "\n", "            ", "attribute_len", "=", "4", "\n", "", "else", ":", "\n", "            ", "attribute_len", "=", "3", "\n", "\n", "", "sd_tokens", "=", "self", ".", "get_sample_content", "(", "sample_token", ")", "\n", "attributes", "=", "np", ".", "zeros", "(", "(", "len", "(", "sd_tokens", ")", ",", "attribute_len", ")", ")", "\n", "timestamps", "=", "np", ".", "zeros", "(", "(", "len", "(", "sd_tokens", ")", ")", ")", "\n", "for", "i", ",", "sd_token", "in", "enumerate", "(", "sd_tokens", ")", ":", "\n", "# Get attribute.", "\n", "            ", "sample_data", "=", "self", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "\n", "ego_pose", "=", "self", ".", "get", "(", "'ego_pose'", ",", "sample_data", "[", "'ego_pose_token'", "]", ")", "\n", "attribute", "=", "ego_pose", "[", "attribute_name", "]", "\n", "\n", "# Store results.", "\n", "attributes", "[", "i", ",", ":", "]", "=", "attribute", "\n", "timestamps", "[", "i", "]", "=", "ego_pose", "[", "'timestamp'", "]", "\n", "\n", "", "return", "timestamps", ",", "attributes", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_trajectory": [[502, 540], ["nuimages.NuImages.get_ego_pose_data", "nuimages.NuImages.get", "nuimages.NuImages.get", "nuimages.NuImages.get", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "numpy.dot", "enumerate"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_ego_pose_data", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_trajectory", "(", "self", ",", "\n", "sample_token", ":", "str", ",", "\n", "rotation_yaw", ":", "float", "=", "0.0", ",", "\n", "center_key_pose", ":", "bool", "=", "True", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "int", "]", ":", "\n", "        ", "\"\"\"\n        Get the trajectory of the ego vehicle and optionally rotate and center it.\n        :param sample_token: Sample token.\n        :param rotation_yaw: Rotation of the ego vehicle in the plot.\n            Set to None to use lat/lon coordinates.\n            Set to 0 to point in the driving direction at the time of the keyframe.\n            Set to any other value to rotate relative to the driving direction (in radians).\n        :param center_key_pose: Whether to center the trajectory on the key pose.\n        :return: (\n            translations: A matrix with sample_datas x 3 values of the translations at each timestamp.\n            key_index: The index of the translations corresponding to the keyframe (usually 6).\n        )\n        \"\"\"", "\n", "# Get trajectory data.", "\n", "timestamps", ",", "translations", "=", "self", ".", "get_ego_pose_data", "(", "sample_token", ")", "\n", "\n", "# Find keyframe translation and rotation.", "\n", "sample", "=", "self", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "sample_data", "=", "self", ".", "get", "(", "'sample_data'", ",", "sample", "[", "'key_camera_token'", "]", ")", "\n", "ego_pose", "=", "self", ".", "get", "(", "'ego_pose'", ",", "sample_data", "[", "'ego_pose_token'", "]", ")", "\n", "key_rotation", "=", "Quaternion", "(", "ego_pose", "[", "'rotation'", "]", ")", "\n", "key_timestamp", "=", "ego_pose", "[", "'timestamp'", "]", "\n", "key_index", "=", "[", "i", "for", "i", ",", "t", "in", "enumerate", "(", "timestamps", ")", "if", "t", "==", "key_timestamp", "]", "[", "0", "]", "\n", "\n", "# Rotate points such that the initial driving direction points upwards.", "\n", "if", "rotation_yaw", "is", "not", "None", ":", "\n", "            ", "rotation", "=", "key_rotation", ".", "inverse", "*", "Quaternion", "(", "axis", "=", "[", "0", ",", "0", ",", "1", "]", ",", "angle", "=", "np", ".", "pi", "/", "2", "-", "rotation_yaw", ")", "\n", "translations", "=", "np", ".", "dot", "(", "rotation", ".", "rotation_matrix", ",", "translations", ".", "T", ")", ".", "T", "\n", "\n", "# Subtract origin to have lower numbers on the axes.", "\n", "", "if", "center_key_pose", ":", "\n", "            ", "translations", "-=", "translations", "[", "key_index", ",", ":", "]", "\n", "\n", "", "return", "translations", ",", "key_index", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_segmentation": [[541, 606], ["nuimages.NuImages.get", "nuimages.utils.utils.name_to_index_mapping", "nuimages.NuImages.check_sweeps", "os.join", "PIL.Image.open", "numpy.zeros().astype", "numpy.zeros().astype", "sorted", "enumerate", "nuimages.utils.utils.mask_decode", "nuimages.utils.utils.mask_decode", "numpy.zeros", "numpy.zeros", "nuimages.NuImages.get", "nuimages.NuImages.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.name_to_index_mapping", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.check_sweeps", "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.mask_decode", "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.mask_decode", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_segmentation", "(", "self", ",", "\n", "sd_token", ":", "str", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Produces two segmentation masks as numpy arrays of size H x W each, where H and W are the height and width\n        of the camera image respectively:\n            - semantic mask: A mask in which each pixel is an integer value between 0 to C (inclusive),\n                             where C is the number of categories in nuImages. Each integer corresponds to\n                             the index of the class in the category.json.\n            - instance mask: A mask in which each pixel is an integer value between 0 to N, where N is the\n                             number of objects in a given camera sample_data. Each integer corresponds to\n                             the order in which the object was drawn into the mask.\n        :param sd_token: The token of the sample_data to be rendered.\n        :return: Two 2D numpy arrays (one semantic mask <int32: H, W>, and one instance mask <int32: H, W>).\n        \"\"\"", "\n", "# Validate inputs.", "\n", "sample_data", "=", "self", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "\n", "assert", "sample_data", "[", "'is_key_frame'", "]", ",", "'Error: Cannot render annotations for non keyframes!'", "\n", "\n", "name_to_index", "=", "name_to_index_mapping", "(", "self", ".", "category", ")", "\n", "\n", "# Get image data.", "\n", "self", ".", "check_sweeps", "(", "sample_data", "[", "'filename'", "]", ")", "\n", "im_path", "=", "osp", ".", "join", "(", "self", ".", "dataroot", ",", "sample_data", "[", "'filename'", "]", ")", "\n", "im", "=", "Image", ".", "open", "(", "im_path", ")", "\n", "\n", "(", "width", ",", "height", ")", "=", "im", ".", "size", "\n", "semseg_mask", "=", "np", ".", "zeros", "(", "(", "height", ",", "width", ")", ")", ".", "astype", "(", "'int32'", ")", "\n", "instanceseg_mask", "=", "np", ".", "zeros", "(", "(", "height", ",", "width", ")", ")", ".", "astype", "(", "'int32'", ")", "\n", "\n", "# Load stuff / surface regions.", "\n", "surface_anns", "=", "[", "o", "for", "o", "in", "self", ".", "surface_ann", "if", "o", "[", "'sample_data_token'", "]", "==", "sd_token", "]", "\n", "\n", "# Draw stuff / surface regions.", "\n", "for", "ann", "in", "surface_anns", ":", "\n", "# Get color and mask.", "\n", "            ", "category_token", "=", "ann", "[", "'category_token'", "]", "\n", "category_name", "=", "self", ".", "get", "(", "'category'", ",", "category_token", ")", "[", "'name'", "]", "\n", "if", "ann", "[", "'mask'", "]", "is", "None", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "mask_decode", "(", "ann", "[", "'mask'", "]", ")", "\n", "\n", "# Draw mask for semantic segmentation.", "\n", "semseg_mask", "[", "mask", "==", "1", "]", "=", "name_to_index", "[", "category_name", "]", "\n", "\n", "# Load object instances.", "\n", "", "object_anns", "=", "[", "o", "for", "o", "in", "self", ".", "object_ann", "if", "o", "[", "'sample_data_token'", "]", "==", "sd_token", "]", "\n", "\n", "# Sort by token to ensure that objects always appear in the instance mask in the same order.", "\n", "object_anns", "=", "sorted", "(", "object_anns", ",", "key", "=", "lambda", "k", ":", "k", "[", "'token'", "]", ")", "\n", "\n", "# Draw object instances.", "\n", "# The 0 index is reserved for background; thus, the instances should start from index 1.", "\n", "for", "i", ",", "ann", "in", "enumerate", "(", "object_anns", ",", "start", "=", "1", ")", ":", "\n", "# Get color, box, mask and name.", "\n", "            ", "category_token", "=", "ann", "[", "'category_token'", "]", "\n", "category_name", "=", "self", ".", "get", "(", "'category'", ",", "category_token", ")", "[", "'name'", "]", "\n", "if", "ann", "[", "'mask'", "]", "is", "None", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "mask_decode", "(", "ann", "[", "'mask'", "]", ")", "\n", "\n", "# Draw masks for semantic segmentation and instance segmentation.", "\n", "semseg_mask", "[", "mask", "==", "1", "]", "=", "name_to_index", "[", "category_name", "]", "\n", "instanceseg_mask", "[", "mask", "==", "1", "]", "=", "i", "\n", "\n", "", "return", "semseg_mask", ",", "instanceseg_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.render_image": [[609, 731], ["nuimages.NuImages.get", "nuimages.NuImages.check_sweeps", "os.join", "PIL.Image.open", "im.convert.convert.convert", "PIL.ImageDraw.Draw", "matplotlib.figure", "matplotlib.axis", "matplotlib.imshow", "type", "int", "nuimages.utils.utils.get_font", "matplotlib.savefig", "matplotlib.close", "round", "set", "set().issubset", "nuimages.utils.utils.mask_decode", "PIL.ImageDraw.Draw.bitmap", "set", "set().issubset", "nuimages.utils.utils.annotation_name", "nuimages.NuImages.get", "PIL.Image.fromarray", "nuimages.NuImages.get", "nuimages.NuImages.get", "nuimages.utils.utils.mask_decode", "PIL.ImageDraw.Draw.bitmap", "PIL.ImageDraw.Draw.rectangle", "set", "tuple", "set", "PIL.Image.fromarray", "PIL.ImageDraw.Draw.text", "tuple"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.check_sweeps", "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.get_font", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.mask_decode", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.annotation_name", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.mask_decode", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["", "def", "render_image", "(", "self", ",", "\n", "sd_token", ":", "str", ",", "\n", "annotation_type", ":", "str", "=", "'all'", ",", "\n", "with_category", ":", "bool", "=", "False", ",", "\n", "with_attributes", ":", "bool", "=", "False", ",", "\n", "object_tokens", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "surface_tokens", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "render_scale", ":", "float", "=", "1.0", ",", "\n", "box_line_width", ":", "int", "=", "-", "1", ",", "\n", "font_size", ":", "int", "=", "None", ",", "\n", "out_path", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders an image (sample_data), optionally with annotations overlaid.\n        :param sd_token: The token of the sample_data to be rendered.\n        :param annotation_type: The types of annotations to draw on the image; there are four options:\n            'all': Draw surfaces and objects, subject to any filtering done by object_tokens and surface_tokens.\n            'surfaces': Draw only surfaces, subject to any filtering done by surface_tokens.\n            'objects': Draw objects, subject to any filtering done by object_tokens.\n            'none': Neither surfaces nor objects will be drawn.\n        :param with_category: Whether to include the category name at the top of a box.\n        :param with_attributes: Whether to include attributes in the label tags. Note that with_attributes=True\n            will only work if with_category=True.\n        :param object_tokens: List of object annotation tokens. If given, only these annotations are drawn.\n        :param surface_tokens: List of surface annotation tokens. If given, only these annotations are drawn.\n        :param render_scale: The scale at which the image will be rendered. Use 1.0 for the original image size.\n        :param box_line_width: The box line width in pixels. The default is -1.\n            If set to -1, box_line_width equals render_scale (rounded) to be larger in larger images.\n        :param font_size: Size of the text in the rendered image. Use None for the default size.\n        :param out_path: The path where we save the rendered image, or otherwise None.\n            If a path is provided, the plot is not shown to the user.\n        \"\"\"", "\n", "# Validate inputs.", "\n", "sample_data", "=", "self", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "\n", "if", "not", "sample_data", "[", "'is_key_frame'", "]", ":", "\n", "            ", "assert", "annotation_type", "==", "'none'", ",", "'Error: Cannot render annotations for non keyframes!'", "\n", "assert", "not", "with_attributes", ",", "'Error: Cannot render attributes for non keyframes!'", "\n", "", "if", "with_attributes", ":", "\n", "            ", "assert", "with_category", ",", "'In order to set with_attributes=True, with_category must be True.'", "\n", "", "assert", "type", "(", "box_line_width", ")", "==", "int", ",", "'Error: box_line_width must be an integer!'", "\n", "if", "box_line_width", "==", "-", "1", ":", "\n", "            ", "box_line_width", "=", "int", "(", "round", "(", "render_scale", ")", ")", "\n", "\n", "# Get image data.", "\n", "", "self", ".", "check_sweeps", "(", "sample_data", "[", "'filename'", "]", ")", "\n", "im_path", "=", "osp", ".", "join", "(", "self", ".", "dataroot", ",", "sample_data", "[", "'filename'", "]", ")", "\n", "im", "=", "Image", ".", "open", "(", "im_path", ")", "\n", "\n", "# Initialize drawing.", "\n", "if", "with_category", "and", "font_size", "is", "not", "None", ":", "\n", "            ", "font", "=", "get_font", "(", "font_size", "=", "font_size", ")", "\n", "", "else", ":", "\n", "            ", "font", "=", "None", "\n", "", "im", "=", "im", ".", "convert", "(", "'RGBA'", ")", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "im", ",", "'RGBA'", ")", "\n", "\n", "annotations_types", "=", "[", "'all'", ",", "'surfaces'", ",", "'objects'", ",", "'none'", "]", "\n", "assert", "annotation_type", "in", "annotations_types", ",", "'Error: {} is not a valid option for annotation_type. '", "'Only {} are allowed.'", ".", "format", "(", "annotation_type", ",", "annotations_types", ")", "\n", "if", "annotation_type", "is", "not", "'none'", ":", "\n", "            ", "if", "annotation_type", "==", "'all'", "or", "annotation_type", "==", "'surfaces'", ":", "\n", "# Load stuff / surface regions.", "\n", "                ", "surface_anns", "=", "[", "o", "for", "o", "in", "self", ".", "surface_ann", "if", "o", "[", "'sample_data_token'", "]", "==", "sd_token", "]", "\n", "if", "surface_tokens", "is", "not", "None", ":", "\n", "                    ", "sd_surface_tokens", "=", "set", "(", "[", "s", "[", "'token'", "]", "for", "s", "in", "surface_anns", "if", "s", "[", "'token'", "]", "]", ")", "\n", "assert", "set", "(", "surface_tokens", ")", ".", "issubset", "(", "sd_surface_tokens", ")", ",", "'Error: The provided surface_tokens do not belong to the sd_token!'", "\n", "surface_anns", "=", "[", "o", "for", "o", "in", "surface_anns", "if", "o", "[", "'token'", "]", "in", "surface_tokens", "]", "\n", "\n", "# Draw stuff / surface regions.", "\n", "", "for", "ann", "in", "surface_anns", ":", "\n", "# Get color and mask.", "\n", "                    ", "category_token", "=", "ann", "[", "'category_token'", "]", "\n", "category_name", "=", "self", ".", "get", "(", "'category'", ",", "category_token", ")", "[", "'name'", "]", "\n", "color", "=", "self", ".", "color_map", "[", "category_name", "]", "\n", "if", "ann", "[", "'mask'", "]", "is", "None", ":", "\n", "                        ", "continue", "\n", "", "mask", "=", "mask_decode", "(", "ann", "[", "'mask'", "]", ")", "\n", "\n", "# Draw mask. The label is obvious from the color.", "\n", "draw", ".", "bitmap", "(", "(", "0", ",", "0", ")", ",", "Image", ".", "fromarray", "(", "mask", "*", "128", ")", ",", "fill", "=", "tuple", "(", "color", "+", "(", "128", ",", ")", ")", ")", "\n", "\n", "", "", "if", "annotation_type", "==", "'all'", "or", "annotation_type", "==", "'objects'", ":", "\n", "# Load object instances.", "\n", "                ", "object_anns", "=", "[", "o", "for", "o", "in", "self", ".", "object_ann", "if", "o", "[", "'sample_data_token'", "]", "==", "sd_token", "]", "\n", "if", "object_tokens", "is", "not", "None", ":", "\n", "                    ", "sd_object_tokens", "=", "set", "(", "[", "o", "[", "'token'", "]", "for", "o", "in", "object_anns", "if", "o", "[", "'token'", "]", "]", ")", "\n", "assert", "set", "(", "object_tokens", ")", ".", "issubset", "(", "sd_object_tokens", ")", ",", "'Error: The provided object_tokens do not belong to the sd_token!'", "\n", "object_anns", "=", "[", "o", "for", "o", "in", "object_anns", "if", "o", "[", "'token'", "]", "in", "object_tokens", "]", "\n", "\n", "# Draw object instances.", "\n", "", "for", "ann", "in", "object_anns", ":", "\n", "# Get color, box, mask and name.", "\n", "                    ", "category_token", "=", "ann", "[", "'category_token'", "]", "\n", "category_name", "=", "self", ".", "get", "(", "'category'", ",", "category_token", ")", "[", "'name'", "]", "\n", "color", "=", "self", ".", "color_map", "[", "category_name", "]", "\n", "bbox", "=", "ann", "[", "'bbox'", "]", "\n", "attr_tokens", "=", "ann", "[", "'attribute_tokens'", "]", "\n", "attributes", "=", "[", "self", ".", "get", "(", "'attribute'", ",", "at", ")", "for", "at", "in", "attr_tokens", "]", "\n", "name", "=", "annotation_name", "(", "attributes", ",", "category_name", ",", "with_attributes", "=", "with_attributes", ")", "\n", "if", "ann", "[", "'mask'", "]", "is", "not", "None", ":", "\n", "                        ", "mask", "=", "mask_decode", "(", "ann", "[", "'mask'", "]", ")", "\n", "\n", "# Draw mask, rectangle and text.", "\n", "draw", ".", "bitmap", "(", "(", "0", ",", "0", ")", ",", "Image", ".", "fromarray", "(", "mask", "*", "128", ")", ",", "fill", "=", "tuple", "(", "color", "+", "(", "128", ",", ")", ")", ")", "\n", "draw", ".", "rectangle", "(", "bbox", ",", "outline", "=", "color", ",", "width", "=", "box_line_width", ")", "\n", "if", "with_category", ":", "\n", "                            ", "draw", ".", "text", "(", "(", "bbox", "[", "0", "]", ",", "bbox", "[", "1", "]", ")", ",", "name", ",", "font", "=", "font", ")", "\n", "\n", "# Plot the image.", "\n", "", "", "", "", "", "(", "width", ",", "height", ")", "=", "im", ".", "size", "\n", "pix_to_inch", "=", "100", "/", "render_scale", "\n", "figsize", "=", "(", "height", "/", "pix_to_inch", ",", "width", "/", "pix_to_inch", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "imshow", "(", "im", ")", "\n", "\n", "# Save to disk.", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "2.295", "*", "pix_to_inch", ",", "pad_inches", "=", "0", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.render_trajectory": [[732, 770], ["nuimages.NuImages.get_trajectory", "matplotlib.figure", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "numpy.ceil", "numpy.maximum", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.savefig", "matplotlib.close", "numpy.max", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_trajectory"], ["", "", "def", "render_trajectory", "(", "self", ",", "\n", "sample_token", ":", "str", ",", "\n", "rotation_yaw", ":", "float", "=", "0.0", ",", "\n", "center_key_pose", ":", "bool", "=", "True", ",", "\n", "out_path", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Render a plot of the trajectory for the clip surrounding the annotated keyframe.\n        A red cross indicates the starting point, a green dot the ego pose of the annotated keyframe.\n        :param sample_token: Sample token.\n        :param rotation_yaw: Rotation of the ego vehicle in the plot.\n            Set to None to use lat/lon coordinates.\n            Set to 0 to point in the driving direction at the time of the keyframe.\n            Set to any other value to rotate relative to the driving direction (in radians).\n        :param center_key_pose: Whether to center the trajectory on the key pose.\n        :param out_path: Optional path to save the rendered figure to disk.\n            If a path is provided, the plot is not shown to the user.\n        \"\"\"", "\n", "# Get the translations or poses.", "\n", "translations", ",", "key_index", "=", "self", ".", "get_trajectory", "(", "sample_token", ",", "rotation_yaw", "=", "rotation_yaw", ",", "\n", "center_key_pose", "=", "center_key_pose", ")", "\n", "\n", "# Render translations.", "\n", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "plot", "(", "translations", "[", ":", ",", "0", "]", ",", "translations", "[", ":", ",", "1", "]", ")", "\n", "plt", ".", "plot", "(", "translations", "[", "key_index", ",", "0", "]", ",", "translations", "[", "key_index", ",", "1", "]", ",", "'go'", ",", "markersize", "=", "10", ")", "# Key image.", "\n", "plt", ".", "plot", "(", "translations", "[", "0", ",", "0", "]", ",", "translations", "[", "0", ",", "1", "]", ",", "'rx'", ",", "markersize", "=", "10", ")", "# Start point.", "\n", "max_dist", "=", "translations", "-", "translations", "[", "key_index", ",", ":", "]", "\n", "max_dist", "=", "np", ".", "ceil", "(", "np", ".", "max", "(", "np", ".", "abs", "(", "max_dist", ")", ")", "*", "1.05", ")", "# Leave some margin.", "\n", "max_dist", "=", "np", ".", "maximum", "(", "10", ",", "max_dist", ")", "\n", "plt", ".", "xlim", "(", "[", "translations", "[", "key_index", ",", "0", "]", "-", "max_dist", ",", "translations", "[", "key_index", ",", "0", "]", "+", "max_dist", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "translations", "[", "key_index", ",", "1", "]", "-", "max_dist", ",", "translations", "[", "key_index", ",", "1", "]", "+", "max_dist", "]", ")", "\n", "plt", ".", "xlabel", "(", "'x in meters'", ")", "\n", "plt", ".", "ylabel", "(", "'y in meters'", ")", "\n", "\n", "# Save to disk.", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "150", ",", "pad_inches", "=", "0", ")", "\n", "plt", ".", "close", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.annotation_name": [[15, 33], ["len"], "function", ["None"], ["def", "annotation_name", "(", "attributes", ":", "List", "[", "dict", "]", ",", "\n", "category_name", ":", "str", ",", "\n", "with_attributes", ":", "bool", "=", "False", ")", "->", "str", ":", "\n", "    ", "\"\"\"\n    Returns the \"name\" of an annotation, optionally including the attributes.\n    :param attributes: The attribute dictionary.\n    :param category_name: Name of the object category.\n    :param with_attributes: Whether to print the attributes alongside the category name.\n    :return: A human readable string describing the annotation.\n    \"\"\"", "\n", "outstr", "=", "category_name", "\n", "\n", "if", "with_attributes", ":", "\n", "        ", "atts", "=", "[", "attribute", "[", "'name'", "]", "for", "attribute", "in", "attributes", "]", "\n", "if", "len", "(", "atts", ")", ">", "0", ":", "\n", "            ", "outstr", "=", "outstr", "+", "\"--\"", "+", "'.'", ".", "join", "(", "atts", ")", "\n", "\n", "", "", "return", "outstr", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.mask_decode": [[35, 46], ["pycocotools.mask.copy", "base64.b64decode", "pycocotools.mask.decode"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.decode"], ["", "def", "mask_decode", "(", "mask", ":", "dict", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Decode the mask from base64 string to binary string, then feed it to the external pycocotools library to get a mask.\n    :param mask: The mask dictionary with fields `size` and `counts`.\n    :return: A numpy array representing the binary mask for this class.\n    \"\"\"", "\n", "# Note that it is essential to copy the mask here. If we use the same variable we will overwrite the NuImage class", "\n", "# and cause the Jupyter Notebook to crash on some systems.", "\n", "new_mask", "=", "mask", ".", "copy", "(", ")", "\n", "new_mask", "[", "'counts'", "]", "=", "base64", ".", "b64decode", "(", "mask", "[", "'counts'", "]", ")", "\n", "return", "cocomask", ".", "decode", "(", "new_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.get_font": [[48, 74], ["matplotlib.font_manager.findSystemFonts", "sorted", "warnings.warn", "PIL.ImageFont.load_default", "any", "PIL.ImageFont.truetype", "os.path.basename"], "function", ["None"], ["", "def", "get_font", "(", "fonts_valid", ":", "List", "[", "str", "]", "=", "None", ",", "font_size", ":", "int", "=", "15", ")", "->", "ImageFont", ":", "\n", "    ", "\"\"\"\n    Check if there is a desired font present in the user's system. If there is, use that font; otherwise, use a default\n    font.\n    :param fonts_valid: A list of fonts which are desirable.\n    :param font_size: The size of the font to set. Note that if the default font is used, then the font size\n        cannot be set.\n    :return: An ImageFont object to use as the font in a PIL image.\n    \"\"\"", "\n", "# If there are no desired fonts supplied, use a hardcoded list of fonts which are desirable.", "\n", "if", "fonts_valid", "is", "None", ":", "\n", "        ", "fonts_valid", "=", "[", "'FreeSerif.ttf'", ",", "'FreeSans.ttf'", ",", "'Century.ttf'", ",", "'Calibri.ttf'", ",", "'arial.ttf'", "]", "\n", "\n", "# Find a list of fonts within the user's system.", "\n", "", "fonts_in_sys", "=", "matplotlib", ".", "font_manager", ".", "findSystemFonts", "(", "fontpaths", "=", "None", ",", "fontext", "=", "'ttf'", ")", "\n", "# Sort the list of fonts to ensure that the desired fonts are always found in the same order.", "\n", "fonts_in_sys", "=", "sorted", "(", "fonts_in_sys", ")", "\n", "# Of all the fonts found in the user's system, check if any of them are desired.", "\n", "for", "font_in_sys", "in", "fonts_in_sys", ":", "\n", "        ", "if", "any", "(", "os", ".", "path", ".", "basename", "(", "font_in_sys", ")", "in", "s", "for", "s", "in", "fonts_valid", ")", ":", "\n", "            ", "return", "ImageFont", ".", "truetype", "(", "font_in_sys", ",", "font_size", ")", "\n", "\n", "# If none of the fonts in the user's system are desirable, then use the default font.", "\n", "", "", "warnings", ".", "warn", "(", "'No suitable fonts were found in your system. '", "\n", "'A default font will be used instead (the font size will not be adjustable).'", ")", "\n", "return", "ImageFont", ".", "load_default", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.utils.name_to_index_mapping": [[76, 107], ["dict", "sorted", "category.copy", "max", "max", "len", "len", "len", "len", "dict.values", "dict.values", "set", "set", "dict.values", "dict.values"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["", "def", "name_to_index_mapping", "(", "category", ":", "List", "[", "dict", "]", ")", "->", "Dict", "[", "str", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Build a mapping from name to index to look up index in O(1) time.\n    :param category: The nuImages category table.\n    :return: The mapping from category name to category index.\n    \"\"\"", "\n", "# The 0 index is reserved for non-labelled background; thus, the categories should start from index 1.", "\n", "# Also, sort the categories before looping so that the order is always the same (alphabetical).", "\n", "name_to_index", "=", "dict", "(", ")", "\n", "i", "=", "1", "\n", "sorted_category", ":", "List", "=", "sorted", "(", "category", ".", "copy", "(", ")", ",", "key", "=", "lambda", "k", ":", "k", "[", "'name'", "]", ")", "\n", "for", "c", "in", "sorted_category", ":", "\n", "# Ignore the vehicle.ego and flat.driveable_surface classes first; they will be mapped later.", "\n", "        ", "if", "c", "[", "'name'", "]", "!=", "'vehicle.ego'", "and", "c", "[", "'name'", "]", "!=", "'flat.driveable_surface'", ":", "\n", "            ", "name_to_index", "[", "c", "[", "'name'", "]", "]", "=", "i", "\n", "i", "+=", "1", "\n", "\n", "", "", "assert", "max", "(", "name_to_index", ".", "values", "(", ")", ")", "<", "24", ",", "'Error: There are {} classes (excluding vehicle.ego and flat.driveable_surface), '", "'but there should be 23. Please check your category.json'", ".", "format", "(", "max", "(", "name_to_index", ".", "values", "(", ")", ")", ")", "\n", "\n", "# Now map the vehicle.ego and flat.driveable_surface classes.", "\n", "name_to_index", "[", "'flat.driveable_surface'", "]", "=", "24", "\n", "name_to_index", "[", "'vehicle.ego'", "]", "=", "31", "\n", "\n", "# Ensure that each class name is uniquely paired with a class index, and vice versa.", "\n", "assert", "len", "(", "name_to_index", ")", "==", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ",", "'Error: There are {} class names but {} class indices'", ".", "format", "(", "len", "(", "name_to_index", ")", ",", "\n", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ")", "\n", "\n", "return", "name_to_index", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.test_nuimages.TestNuImages.test_load": [[12, 23], ["nuimages.NuImages", "test_nuimages.TestNuImages.assertEqual", "os.path.join"], "methods", ["None"], ["    ", "def", "test_load", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Loads up NuImages.\n        This is intended to simply run the NuImages class to check for import errors, typos, etc.\n        \"\"\"", "\n", "\n", "assert", "'NUIMAGES'", "in", "os", ".", "environ", ",", "'Set NUIMAGES env. variable to enable tests.'", "\n", "nuim", "=", "NuImages", "(", "version", "=", "'v1.0-mini'", ",", "dataroot", "=", "os", ".", "environ", "[", "'NUIMAGES'", "]", ",", "verbose", "=", "False", ")", "\n", "\n", "# Trivial assert statement", "\n", "self", ".", "assertEqual", "(", "nuim", ".", "table_root", ",", "os", ".", "path", ".", "join", "(", "os", ".", "environ", "[", "'NUIMAGES'", "]", ",", "'v1.0-mini'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.__init__": [[13, 21], ["None"], "methods", ["None"], ["from", "matplotlib", ".", "axes", "import", "Axes", "\n", "from", "pyquaternion", "import", "Quaternion", "\n", "import", "sys", "\n", "sys", ".", "path", ".", "append", "(", "\"..\"", ")", "\n", "from", "lidarseg", ".", "lidarseg_utils", "import", "colormap_to_colors", ",", "create_lidarseg_legend", "\n", "from", "utils", ".", "data_io", "import", "load_bin_file", "\n", "from", "utils", ".", "geometry_utils", "import", "view_points", ",", "transform_matrix", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.nbr_dims": [[39, 47], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "abstractmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns the number of dimensions.\n        :return: Number of dimensions.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.from_file": [[33, 49], ["file_name.endswith", "cls", "cls.load_pcd_bin", "file_name.endswith", "numpy.load", "ValueError"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.load_pcd_bin"], ["\n", "assert", "points", ".", "shape", "[", "0", "]", "==", "self", ".", "nbr_dims", "(", ")", ",", "'Error: Pointcloud points must have format: %d x n'", "%", "self", ".", "nbr_dims", "(", ")", "\n", "self", ".", "points", "=", "points", "\n", "\n", "", "@", "staticmethod", "\n", "@", "abstractmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns the number of dimensions.\n        :return: Number of dimensions.\n        \"\"\"", "\n", "pass", "\n", "\n", "", "@", "classmethod", "\n", "@", "abstractmethod", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.from_file_multisweep": [[58, 134], ["numpy.zeros", "cls", "numpy.zeros", "nusc.get", "nusc.get", "nusc.get", "utils.geometry_utils.transform_matrix", "utils.geometry_utils.transform_matrix", "nusc.get", "range", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "cls.from_file", "cls.from_file.remove_close", "nusc.get", "utils.geometry_utils.transform_matrix", "nusc.get", "utils.geometry_utils.transform_matrix", "functools.reduce", "cls.from_file.transform", "numpy.hstack", "numpy.hstack", "cls.nbr_dims", "os.join", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "numpy.ones", "nusc.get", "cls.from_file.nbr_points"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.transform_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.transform_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.remove_close", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.transform_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.transform_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.transform", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.nbr_dims", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.nbr_points"], ["", "@", "classmethod", "\n", "def", "from_file_multisweep", "(", "cls", ",", "\n", "nusc", ":", "'NuScenes'", ",", "\n", "sample_rec", ":", "Dict", ",", "\n", "chan", ":", "str", ",", "\n", "ref_chan", ":", "str", ",", "\n", "nsweeps", ":", "int", "=", "5", ",", "\n", "min_distance", ":", "float", "=", "1.0", ")", "->", "Tuple", "[", "'PointCloud'", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return a point cloud that aggregates multiple sweeps.\n        As every sweep is in a different coordinate frame, we need to map the coordinates to a single reference frame.\n        As every sweep has a different timestamp, we need to account for that in the transformations and timestamps.\n        :param nusc: A NuScenes instance.\n        :param sample_rec: The current sample.\n        :param chan: The lidar/radar channel from which we track back n sweeps to aggregate the point cloud.\n        :param ref_chan: The reference channel of the current sample_rec that the point clouds are mapped to.\n        :param nsweeps: Number of sweeps to aggregated.\n        :param min_distance: Distance below which points are discarded.\n        :return: (all_pc, all_times). The aggregated point cloud and timestamps.\n        \"\"\"", "\n", "# Init.", "\n", "points", "=", "np", ".", "zeros", "(", "(", "cls", ".", "nbr_dims", "(", ")", ",", "0", ")", ",", "dtype", "=", "np", ".", "float32", "if", "cls", "==", "LidarPointCloud", "else", "np", ".", "float64", ")", "\n", "all_pc", "=", "cls", "(", "points", ")", "\n", "all_times", "=", "np", ".", "zeros", "(", "(", "1", ",", "0", ")", ")", "\n", "\n", "# Get reference pose and timestamp.", "\n", "ref_sd_token", "=", "sample_rec", "[", "'data'", "]", "[", "ref_chan", "]", "\n", "ref_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "ref_sd_token", ")", "\n", "ref_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "ref_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "ref_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "ref_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "ref_time", "=", "1e-6", "*", "ref_sd_rec", "[", "'timestamp'", "]", "\n", "\n", "# Homogeneous transform from ego car frame to reference frame.", "\n", "ref_from_car", "=", "transform_matrix", "(", "ref_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_cs_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "True", ")", "\n", "\n", "# Homogeneous transformation matrix from global to _current_ ego car frame.", "\n", "car_from_global", "=", "transform_matrix", "(", "ref_pose_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_pose_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "True", ")", "\n", "\n", "# Aggregate current and previous sweeps.", "\n", "sample_data_token", "=", "sample_rec", "[", "'data'", "]", "[", "chan", "]", "\n", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "for", "_", "in", "range", "(", "nsweeps", ")", ":", "\n", "# Load up the pointcloud and remove points close to the sensor.", "\n", "            ", "current_pc", "=", "cls", ".", "from_file", "(", "osp", ".", "join", "(", "nusc", ".", "dataroot", ",", "current_sd_rec", "[", "'filename'", "]", ")", ")", "\n", "current_pc", ".", "remove_close", "(", "min_distance", ")", "\n", "\n", "# Get past pose.", "\n", "current_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "current_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "global_from_car", "=", "transform_matrix", "(", "current_pose_rec", "[", "'translation'", "]", ",", "\n", "Quaternion", "(", "current_pose_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "False", ")", "\n", "\n", "# Homogeneous transformation matrix from sensor coordinate frame to ego car frame.", "\n", "current_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "current_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "car_from_current", "=", "transform_matrix", "(", "current_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "current_cs_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "False", ")", "\n", "\n", "# Fuse four transformation matrices into one and perform transform.", "\n", "trans_matrix", "=", "reduce", "(", "np", ".", "dot", ",", "[", "ref_from_car", ",", "car_from_global", ",", "global_from_car", ",", "car_from_current", "]", ")", "\n", "current_pc", ".", "transform", "(", "trans_matrix", ")", "\n", "\n", "# Add time vector which can be used as a temporal feature.", "\n", "time_lag", "=", "ref_time", "-", "1e-6", "*", "current_sd_rec", "[", "'timestamp'", "]", "# Positive difference.", "\n", "times", "=", "time_lag", "*", "np", ".", "ones", "(", "(", "1", ",", "current_pc", ".", "nbr_points", "(", ")", ")", ")", "\n", "all_times", "=", "np", ".", "hstack", "(", "(", "all_times", ",", "times", ")", ")", "\n", "\n", "# Merge with key pc.", "\n", "all_pc", ".", "points", "=", "np", ".", "hstack", "(", "(", "all_pc", ".", "points", ",", "current_pc", ".", "points", ")", ")", "\n", "\n", "# Abort if there are no previous sweeps.", "\n", "if", "current_sd_rec", "[", "'prev'", "]", "==", "''", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "current_sd_rec", "[", "'prev'", "]", ")", "\n", "\n", "", "", "return", "all_pc", ",", "all_times", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.nbr_points": [[50, 56], ["None"], "methods", ["None"], ["def", "from_file", "(", "cls", ",", "file_name", ":", "str", ")", "->", "'PointCloud'", ":", "\n", "        ", "\"\"\"\n        Loads point cloud from disk.\n        :param file_name: Path of the pointcloud file on disk.\n        :return: PointCloud instance.\n        \"\"\"", "\n", "pass", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.subsample": [[57, 66], ["numpy.random.choice", "numpy.arange", "data_classes.PointCloud.nbr_points", "int", "data_classes.PointCloud.nbr_points"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.nbr_points", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.nbr_points"], ["\n", "", "@", "classmethod", "\n", "def", "from_file_multisweep", "(", "cls", ",", "\n", "nusc", ":", "'NuScenes'", ",", "\n", "sample_rec", ":", "Dict", ",", "\n", "chan", ":", "str", ",", "\n", "ref_chan", ":", "str", ",", "\n", "nsweeps", ":", "int", "=", "5", ",", "\n", "min_distance", ":", "float", "=", "1.0", ")", "->", "Tuple", "[", "'PointCloud'", ",", "np", ".", "ndarray", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.remove_close": [[67, 78], ["numpy.logical_not", "numpy.abs", "numpy.abs", "numpy.logical_and"], "methods", ["None"], ["\n", "# Init.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.translate": [[79, 87], ["range"], "methods", ["None"], ["points", "=", "np", ".", "zeros", "(", "(", "cls", ".", "nbr_dims", "(", ")", ",", "0", ")", ",", "dtype", "=", "np", ".", "float32", "if", "cls", "==", "LidarPointCloud", "else", "np", ".", "float64", ")", "\n", "all_pc", "=", "cls", "(", "points", ")", "\n", "all_times", "=", "np", ".", "zeros", "(", "(", "1", ",", "0", ")", ")", "\n", "\n", "# Get reference pose and timestamp.", "\n", "ref_sd_token", "=", "sample_rec", "[", "'data'", "]", "[", "ref_chan", "]", "\n", "ref_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "ref_sd_token", ")", "\n", "ref_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "ref_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "ref_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "ref_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.rotate": [[88, 95], ["numpy.dot"], "methods", ["None"], ["ref_time", "=", "1e-6", "*", "ref_sd_rec", "[", "'timestamp'", "]", "\n", "\n", "# Homogeneous transform from ego car frame to reference frame.", "\n", "ref_from_car", "=", "transform_matrix", "(", "ref_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_cs_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "True", ")", "\n", "\n", "# Homogeneous transformation matrix from global to _current_ ego car frame.", "\n", "car_from_global", "=", "transform_matrix", "(", "ref_pose_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_pose_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "True", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.transform": [[96, 104], ["transf_matrix.dot", "numpy.vstack", "numpy.ones", "data_classes.PointCloud.nbr_points"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.nbr_points"], ["\n", "# Aggregate current and previous sweeps.", "\n", "sample_data_token", "=", "sample_rec", "[", "'data'", "]", "[", "chan", "]", "\n", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "for", "_", "in", "range", "(", "nsweeps", ")", ":", "\n", "# Load up the pointcloud and remove points close to the sensor.", "\n", "            ", "current_pc", "=", "cls", ".", "from_file", "(", "osp", ".", "join", "(", "nusc", ".", "dataroot", ",", "current_sd_rec", "[", "'filename'", "]", ")", ")", "\n", "current_pc", ".", "remove_close", "(", "min_distance", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.render_height": [[183, 198], ["numpy.eye", "data_classes.PointCloud._render_helper"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud._render_helper"], ["", "def", "render_height", "(", "self", ",", "\n", "ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "y_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "marker_size", ":", "float", "=", "1", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Very simple method that applies a transformation and then scatter plots the points colored by height (z-value).\n        :param ax: Axes on which to render the points.\n        :param view: <np.float: n, n>. Defines an arbitrary projection (n <= 4).\n        :param x_lim: (min, max). x range for plotting.\n        :param y_lim: (min, max). y range for plotting.\n        :param marker_size: Marker size.\n        \"\"\"", "\n", "self", ".", "_render_helper", "(", "2", ",", "ax", ",", "view", ",", "x_lim", ",", "y_lim", ",", "marker_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.render_intensity": [[199, 214], ["numpy.eye", "data_classes.PointCloud._render_helper"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud._render_helper"], ["", "def", "render_intensity", "(", "self", ",", "\n", "ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "y_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "marker_size", ":", "float", "=", "1", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Very simple method that applies a transformation and then scatter plots the points colored by intensity.\n        :param ax: Axes on which to render the points.\n        :param view: <np.float: n, n>. Defines an arbitrary projection (n <= 4).\n        :param x_lim: (min, max).\n        :param y_lim: (min, max).\n        :param marker_size: Marker size.\n        \"\"\"", "\n", "self", ".", "_render_helper", "(", "3", ",", "ax", ",", "view", ",", "x_lim", ",", "y_lim", ",", "marker_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud._render_helper": [[215, 235], ["utils.geometry_utils.view_points", "ax.scatter", "ax.set_xlim", "ax.set_ylim"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points"], ["", "def", "_render_helper", "(", "self", ",", "\n", "color_channel", ":", "int", ",", "\n", "ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "y_lim", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "marker_size", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Helper function for rendering.\n        :param color_channel: Point channel to use as color.\n        :param ax: Axes on which to render the points.\n        :param view: <np.float: n, n>. Defines an arbitrary projection (n <= 4).\n        :param x_lim: (min, max).\n        :param y_lim: (min, max).\n        :param marker_size: Marker size.\n        \"\"\"", "\n", "points", "=", "view_points", "(", "self", ".", "points", "[", ":", "3", ",", ":", "]", ",", "view", ",", "normalize", "=", "False", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "self", ".", "points", "[", "color_channel", ",", ":", "]", ",", "s", "=", "marker_size", ")", "\n", "ax", ".", "set_xlim", "(", "x_lim", "[", "0", "]", ",", "x_lim", "[", "1", "]", ")", "\n", "ax", ".", "set_ylim", "(", "y_lim", "[", "0", "]", ",", "y_lim", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.LidarPointCloud.nbr_dims": [[239, 246], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns the number of dimensions.\n        :return: Number of dimensions.\n        \"\"\"", "\n", "return", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.LidarPointCloud.from_file": [[247, 260], ["file_name.endswith", "numpy.fromfile", "cls", "numpy.fromfile.reshape", "cls.nbr_dims"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.nbr_dims"], ["", "@", "classmethod", "\n", "def", "from_file", "(", "cls", ",", "file_name", ":", "str", ")", "->", "'LidarPointCloud'", ":", "\n", "        ", "\"\"\"\n        Loads LIDAR data from binary numpy format. Data is stored as (x, y, z, intensity, ring index).\n        :param file_name: Path of the pointcloud file on disk.\n        :return: LidarPointCloud instance (x, y, z, intensity).\n        \"\"\"", "\n", "\n", "assert", "file_name", ".", "endswith", "(", "'.bin'", ")", ",", "'Unsupported filetype {}'", ".", "format", "(", "file_name", ")", "\n", "\n", "scan", "=", "np", ".", "fromfile", "(", "file_name", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "points", "=", "scan", ".", "reshape", "(", "(", "-", "1", ",", "5", ")", ")", "[", ":", ",", ":", "cls", ".", "nbr_dims", "(", ")", "]", "\n", "return", "cls", "(", "points", ".", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.disable_filters": [[269, 279], ["list", "list", "list", "range", "range", "range"], "methods", ["None"], ["@", "classmethod", "\n", "def", "disable_filters", "(", "cls", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Disable all radar filter settings.\n        Use this method to plot all radar returns.\n        Note that this method affects the global settings.\n        \"\"\"", "\n", "cls", ".", "invalid_states", "=", "list", "(", "range", "(", "18", ")", ")", "\n", "cls", ".", "dynprop_states", "=", "list", "(", "range", "(", "8", ")", ")", "\n", "cls", ".", "ambig_states", "=", "list", "(", "range", "(", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.default_filters": [[280, 289], ["range"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "default_filters", "(", "cls", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Set the defaults for all radar filter settings.\n        Note that this method affects the global settings.\n        \"\"\"", "\n", "cls", ".", "invalid_states", "=", "[", "0", "]", "\n", "cls", ".", "dynprop_states", "=", "range", "(", "7", ")", "\n", "cls", ".", "ambig_states", "=", "[", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.nbr_dims": [[290, 297], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns the number of dimensions.\n        :return: Number of dimensions.\n        \"\"\"", "\n", "return", "18", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file": [[298, 458], ["file_name.endswith", "meta[].startswith", "meta[].startswith", "int", "int", "len", "range", "numpy.array", "numpy.any", "numpy.array().transpose", "cls", "open", "f.read", "meta[].split", "meta[].split", "meta[].split", "meta[].split", "len", "range", "numpy.array().transpose.append", "numpy.isnan", "cls", "line.strip().decode.strip().decode.strip().decode", "meta.append", "line.strip().decode.strip().decode.startswith", "meta[].split", "meta[].split", "numpy.array.append", "numpy.zeros", "numpy.array", "zip", "int", "len", "struct.unpack", "line.strip().decode.strip().decode.strip", "int"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.decode"], ["", "@", "classmethod", "\n", "def", "from_file", "(", "cls", ",", "\n", "file_name", ":", "str", ",", "\n", "invalid_states", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "dynprop_states", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "ambig_states", ":", "List", "[", "int", "]", "=", "None", ")", "->", "'RadarPointCloud'", ":", "\n", "        ", "\"\"\"\n        Loads RADAR data from a Point Cloud Data file. See details below.\n        :param file_name: The path of the pointcloud file.\n        :param invalid_states: Radar states to be kept. See details below.\n        :param dynprop_states: Radar states to be kept. Use [0, 2, 6] for moving objects only. See details below.\n        :param ambig_states: Radar states to be kept. See details below.\n        To keep all radar returns, set each state filter to range(18).\n        :return: <np.float: d, n>. Point cloud matrix with d dimensions and n points.\n\n        Example of the header fields:\n        # .PCD v0.7 - Point Cloud Data file format\n        VERSION 0.7\n        FIELDS x y z dyn_prop id rcs vx vy vx_comp vy_comp is_quality_valid ambig_state x_rms y_rms invalid_state pdh0 vx_rms vy_rms\n        SIZE 4 4 4 1 2 4 4 4 4 4 1 1 1 1 1 1 1 1\n        TYPE F F F I I F F F F F I I I I I I I I\n        COUNT 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n        WIDTH 125\n        HEIGHT 1\n        VIEWPOINT 0 0 0 1 0 0 0\n        POINTS 125\n        DATA binary\n\n        Below some of the fields are explained in more detail:\n\n        x is front, y is left\n\n        vx, vy are the velocities in m/s.\n        vx_comp, vy_comp are the velocities in m/s compensated by the ego motion.\n        We recommend using the compensated velocities.\n\n        invalid_state: state of Cluster validity state.\n        (Invalid states)\n        0x01\tinvalid due to low RCS\n        0x02\tinvalid due to near-field artefact\n        0x03\tinvalid far range cluster because not confirmed in near range\n        0x05\treserved\n        0x06\tinvalid cluster due to high mirror probability\n        0x07\tInvalid cluster because outside sensor field of view\n        0x0d\treserved\n        0x0e\tinvalid cluster because it is a harmonics\n        (Valid states)\n        0x00\tvalid\n        0x04\tvalid cluster with low RCS\n        0x08\tvalid cluster with azimuth correction due to elevation\n        0x09\tvalid cluster with high child probability\n        0x0a\tvalid cluster with high probability of being a 50 deg artefact\n        0x0b\tvalid cluster but no local maximum\n        0x0c\tvalid cluster with high artefact probability\n        0x0f\tvalid cluster with above 95m in near range\n        0x10\tvalid cluster with high multi-target probability\n        0x11\tvalid cluster with suspicious angle\n\n        dynProp: Dynamic property of cluster to indicate if is moving or not.\n        0: moving\n        1: stationary\n        2: oncoming\n        3: stationary candidate\n        4: unknown\n        5: crossing stationary\n        6: crossing moving\n        7: stopped\n\n        ambig_state: State of Doppler (radial velocity) ambiguity solution.\n        0: invalid\n        1: ambiguous\n        2: staggered ramp\n        3: unambiguous\n        4: stationary candidates\n\n        pdh0: False alarm probability of cluster (i.e. probability of being an artefact caused by multipath or similar).\n        0: invalid\n        1: <25%\n        2: 50%\n        3: 75%\n        4: 90%\n        5: 99%\n        6: 99.9%\n        7: <=100%\n        \"\"\"", "\n", "\n", "assert", "file_name", ".", "endswith", "(", "'.pcd'", ")", ",", "'Unsupported filetype {}'", ".", "format", "(", "file_name", ")", "\n", "\n", "meta", "=", "[", "]", "\n", "with", "open", "(", "file_name", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "line", "=", "line", ".", "strip", "(", ")", ".", "decode", "(", "'utf-8'", ")", "\n", "meta", ".", "append", "(", "line", ")", "\n", "if", "line", ".", "startswith", "(", "'DATA'", ")", ":", "\n", "                    ", "break", "\n", "\n", "", "", "data_binary", "=", "f", ".", "read", "(", ")", "\n", "\n", "# Get the header rows and check if they appear as expected.", "\n", "", "assert", "meta", "[", "0", "]", ".", "startswith", "(", "'#'", ")", ",", "'First line must be comment'", "\n", "assert", "meta", "[", "1", "]", ".", "startswith", "(", "'VERSION'", ")", ",", "'Second line must be VERSION'", "\n", "sizes", "=", "meta", "[", "3", "]", ".", "split", "(", "' '", ")", "[", "1", ":", "]", "\n", "types", "=", "meta", "[", "4", "]", ".", "split", "(", "' '", ")", "[", "1", ":", "]", "\n", "counts", "=", "meta", "[", "5", "]", ".", "split", "(", "' '", ")", "[", "1", ":", "]", "\n", "width", "=", "int", "(", "meta", "[", "6", "]", ".", "split", "(", "' '", ")", "[", "1", "]", ")", "\n", "height", "=", "int", "(", "meta", "[", "7", "]", ".", "split", "(", "' '", ")", "[", "1", "]", ")", "\n", "data", "=", "meta", "[", "10", "]", ".", "split", "(", "' '", ")", "[", "1", "]", "\n", "feature_count", "=", "len", "(", "types", ")", "\n", "assert", "width", ">", "0", "\n", "assert", "len", "(", "[", "c", "for", "c", "in", "counts", "if", "c", "!=", "c", "]", ")", "==", "0", ",", "'Error: COUNT not supported!'", "\n", "assert", "height", "==", "1", ",", "'Error: height != 0 not supported!'", "\n", "assert", "data", "==", "'binary'", "\n", "\n", "# Lookup table for how to decode the binaries.", "\n", "unpacking_lut", "=", "{", "'F'", ":", "{", "2", ":", "'e'", ",", "4", ":", "'f'", ",", "8", ":", "'d'", "}", ",", "\n", "'I'", ":", "{", "1", ":", "'b'", ",", "2", ":", "'h'", ",", "4", ":", "'i'", ",", "8", ":", "'q'", "}", ",", "\n", "'U'", ":", "{", "1", ":", "'B'", ",", "2", ":", "'H'", ",", "4", ":", "'I'", ",", "8", ":", "'Q'", "}", "}", "\n", "types_str", "=", "''", ".", "join", "(", "[", "unpacking_lut", "[", "t", "]", "[", "int", "(", "s", ")", "]", "for", "t", ",", "s", "in", "zip", "(", "types", ",", "sizes", ")", "]", ")", "\n", "\n", "# Decode each point.", "\n", "offset", "=", "0", "\n", "point_count", "=", "width", "\n", "points", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "point_count", ")", ":", "\n", "            ", "point", "=", "[", "]", "\n", "for", "p", "in", "range", "(", "feature_count", ")", ":", "\n", "                ", "start_p", "=", "offset", "\n", "end_p", "=", "start_p", "+", "int", "(", "sizes", "[", "p", "]", ")", "\n", "assert", "end_p", "<", "len", "(", "data_binary", ")", "\n", "point_p", "=", "struct", ".", "unpack", "(", "types_str", "[", "p", "]", ",", "data_binary", "[", "start_p", ":", "end_p", "]", ")", "[", "0", "]", "\n", "point", ".", "append", "(", "point_p", ")", "\n", "offset", "=", "end_p", "\n", "", "points", ".", "append", "(", "point", ")", "\n", "\n", "# A NaN in the first point indicates an empty pointcloud.", "\n", "", "point", "=", "np", ".", "array", "(", "points", "[", "0", "]", ")", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "point", ")", ")", ":", "\n", "            ", "return", "cls", "(", "np", ".", "zeros", "(", "(", "feature_count", ",", "0", ")", ")", ")", "\n", "\n", "# Convert to numpy matrix.", "\n", "", "points", "=", "np", ".", "array", "(", "points", ")", ".", "transpose", "(", ")", "\n", "\n", "# If no parameters are provided, use default settings.", "\n", "invalid_states", "=", "cls", ".", "invalid_states", "if", "invalid_states", "is", "None", "else", "invalid_states", "\n", "dynprop_states", "=", "cls", ".", "dynprop_states", "if", "dynprop_states", "is", "None", "else", "dynprop_states", "\n", "ambig_states", "=", "cls", ".", "ambig_states", "if", "ambig_states", "is", "None", "else", "ambig_states", "\n", "\n", "# Filter points with an invalid state.", "\n", "valid", "=", "[", "p", "in", "invalid_states", "for", "p", "in", "points", "[", "-", "4", ",", ":", "]", "]", "\n", "points", "=", "points", "[", ":", ",", "valid", "]", "\n", "\n", "# Filter by dynProp.", "\n", "valid", "=", "[", "p", "in", "dynprop_states", "for", "p", "in", "points", "[", "3", ",", ":", "]", "]", "\n", "points", "=", "points", "[", ":", ",", "valid", "]", "\n", "\n", "# Filter by ambig_state.", "\n", "valid", "=", "[", "p", "in", "ambig_states", "for", "p", "in", "points", "[", "11", ",", ":", "]", "]", "\n", "points", "=", "points", "[", ":", ",", "valid", "]", "\n", "\n", "return", "cls", "(", "points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.LidarSegPointCloud.__init__": [[464, 475], ["data_classes.LidarSegPointCloud.load_points", "data_classes.LidarSegPointCloud.load_labels"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.LidarSegPointCloud.load_points", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.LidarSegPointCloud.load_labels"], ["def", "__init__", "(", "self", ",", "points_path", ":", "str", "=", "None", ",", "labels_path", ":", "str", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a LidarSegPointCloud object.\n        :param points_path: Path to the bin file containing the x, y, z and intensity of the points in the point cloud.\n        :param labels_path: Path to the bin file containing the labels of the points in the point cloud.\n        \"\"\"", "\n", "self", ".", "points", ",", "self", ".", "labels", "=", "None", ",", "None", "\n", "if", "points_path", ":", "\n", "            ", "self", ".", "load_points", "(", "points_path", ")", "\n", "", "if", "labels_path", ":", "\n", "            ", "self", ".", "load_labels", "(", "labels_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.LidarSegPointCloud.load_points": [[476, 485], ["data_classes.LidarPointCloud.from_file", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file"], ["", "", "def", "load_points", "(", "self", ",", "path", ":", "str", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Loads the x, y, z and intensity of the points in the point cloud.\n        :param path: Path to the bin file containing the x, y, z and intensity of the points in the point cloud.\n        \"\"\"", "\n", "self", ".", "points", "=", "LidarPointCloud", ".", "from_file", "(", "path", ")", ".", "points", ".", "T", "# [N, 4], where N is the number of points.", "\n", "if", "self", ".", "labels", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "self", ".", "points", ")", "==", "len", "(", "self", ".", "labels", ")", ",", "'Error: There are {} points in the point cloud, '", "'but {} labels'", ".", "format", "(", "len", "(", "self", ".", "points", ")", ",", "len", "(", "self", ".", "labels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.LidarSegPointCloud.load_labels": [[486, 495], ["utils.data_io.load_bin_file", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file"], ["", "", "def", "load_labels", "(", "self", ",", "path", ":", "str", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Loads the labels of the points in the point cloud.\n        :param path: Path to the bin file containing the labels of the points in the point cloud.\n        \"\"\"", "\n", "self", ".", "labels", "=", "load_bin_file", "(", "path", ")", "\n", "if", "self", ".", "points", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "self", ".", "points", ")", "==", "len", "(", "self", ".", "labels", ")", ",", "'Error: There are {} points in the point cloud, '", "'but {} labels'", ".", "format", "(", "len", "(", "self", ".", "points", ")", ",", "len", "(", "self", ".", "labels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.LidarSegPointCloud.render": [[496, 520], ["lidarseg.lidarseg_utils.colormap_to_colors", "ax.scatter", "lidarseg.lidarseg_utils.create_lidarseg_legend", "ax.set_title", "name2id.items"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.colormap_to_colors", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.create_lidarseg_legend"], ["", "", "def", "render", "(", "self", ",", "name2color", ":", "Dict", "[", "str", ",", "Tuple", "[", "int", "]", "]", ",", "\n", "name2id", ":", "Dict", "[", "str", ",", "int", "]", ",", "\n", "ax", ":", "Axes", ",", "\n", "title", ":", "str", "=", "None", ",", "\n", "dot_size", ":", "int", "=", "5", ")", "->", "Axes", ":", "\n", "        ", "\"\"\"\n        Renders a point cloud onto an axes.\n        :param name2color: The mapping from class name to class color.\n        :param name2id: A dictionary containing the mapping from class names to class indices.\n        :param ax: Axes onto which to render.\n        :param title: Title of the plot.\n        :param dot_size: Scatter plot dot size.\n        :return: The axes onto which the point cloud has been rendered.\n        \"\"\"", "\n", "colors", "=", "colormap_to_colors", "(", "name2color", ",", "name2id", ")", "\n", "ax", ".", "scatter", "(", "self", ".", "points", "[", ":", ",", "0", "]", ",", "self", ".", "points", "[", ":", ",", "1", "]", ",", "c", "=", "colors", "[", "self", ".", "labels", "]", ",", "s", "=", "dot_size", ")", "\n", "\n", "id2name", "=", "{", "idx", ":", "name", "for", "name", ",", "idx", "in", "name2id", ".", "items", "(", ")", "}", "\n", "create_lidarseg_legend", "(", "self", ".", "labels", ",", "id2name", ",", "name2color", ",", "ax", "=", "ax", ")", "\n", "\n", "if", "title", ":", "\n", "            ", "ax", ".", "set_title", "(", "title", ")", "\n", "\n", "", "return", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.__init__": [[525, 559], ["numpy.array", "numpy.array", "numpy.array", "numpy.any", "numpy.any", "len", "len", "type", "int", "float", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "center", ":", "List", "[", "float", "]", ",", "\n", "size", ":", "List", "[", "float", "]", ",", "\n", "orientation", ":", "Quaternion", ",", "\n", "label", ":", "int", "=", "np", ".", "nan", ",", "\n", "score", ":", "float", "=", "np", ".", "nan", ",", "\n", "velocity", ":", "Tuple", "=", "(", "np", ".", "nan", ",", "np", ".", "nan", ",", "np", ".", "nan", ")", ",", "\n", "name", ":", "str", "=", "None", ",", "\n", "token", ":", "str", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param center: Center of box given as x, y, z.\n        :param size: Size of box in width, length, height.\n        :param orientation: Box orientation.\n        :param label: Integer label, optional.\n        :param score: Classification score, optional.\n        :param velocity: Box velocity in x, y, z direction.\n        :param name: Box name, optional. Can be used e.g. for denote category name.\n        :param token: Unique string identifier from DB.\n        \"\"\"", "\n", "assert", "not", "np", ".", "any", "(", "np", ".", "isnan", "(", "center", ")", ")", "\n", "assert", "not", "np", ".", "any", "(", "np", ".", "isnan", "(", "size", ")", ")", "\n", "assert", "len", "(", "center", ")", "==", "3", "\n", "assert", "len", "(", "size", ")", "==", "3", "\n", "assert", "type", "(", "orientation", ")", "==", "Quaternion", "\n", "\n", "self", ".", "center", "=", "np", ".", "array", "(", "center", ")", "\n", "self", ".", "wlh", "=", "np", ".", "array", "(", "size", ")", "\n", "self", ".", "orientation", "=", "orientation", "\n", "self", ".", "label", "=", "int", "(", "label", ")", "if", "not", "np", ".", "isnan", "(", "label", ")", "else", "label", "\n", "self", ".", "score", "=", "float", "(", "score", ")", "if", "not", "np", ".", "isnan", "(", "score", ")", "else", "score", "\n", "self", ".", "velocity", "=", "np", ".", "array", "(", "velocity", ")", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "token", "=", "token", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.__eq__": [[560, 570], ["numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.all", "numpy.all", "numpy.isnan", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "center", "=", "np", ".", "allclose", "(", "self", ".", "center", ",", "other", ".", "center", ")", "\n", "wlh", "=", "np", ".", "allclose", "(", "self", ".", "wlh", ",", "other", ".", "wlh", ")", "\n", "orientation", "=", "np", ".", "allclose", "(", "self", ".", "orientation", ".", "elements", ",", "other", ".", "orientation", ".", "elements", ")", "\n", "label", "=", "(", "self", ".", "label", "==", "other", ".", "label", ")", "or", "(", "np", ".", "isnan", "(", "self", ".", "label", ")", "and", "np", ".", "isnan", "(", "other", ".", "label", ")", ")", "\n", "score", "=", "(", "self", ".", "score", "==", "other", ".", "score", ")", "or", "(", "np", ".", "isnan", "(", "self", ".", "score", ")", "and", "np", ".", "isnan", "(", "other", ".", "score", ")", ")", "\n", "vel", "=", "(", "np", ".", "allclose", "(", "self", ".", "velocity", ",", "other", ".", "velocity", ")", "or", "\n", "(", "np", ".", "all", "(", "np", ".", "isnan", "(", "self", ".", "velocity", ")", ")", "and", "np", ".", "all", "(", "np", ".", "isnan", "(", "other", ".", "velocity", ")", ")", ")", ")", "\n", "\n", "return", "center", "and", "wlh", "and", "orientation", "and", "label", "and", "score", "and", "vel", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.__repr__": [[571, 580], ["repr_str.format"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "'label: {}, score: {:.2f}, xyz: [{:.2f}, {:.2f}, {:.2f}], wlh: [{:.2f}, {:.2f}, {:.2f}], '", "'rot axis: [{:.2f}, {:.2f}, {:.2f}], ang(degrees): {:.2f}, ang(rad): {:.2f}, '", "'vel: {:.2f}, {:.2f}, {:.2f}, name: {}, token: {}'", "\n", "\n", "return", "repr_str", ".", "format", "(", "self", ".", "label", ",", "self", ".", "score", ",", "self", ".", "center", "[", "0", "]", ",", "self", ".", "center", "[", "1", "]", ",", "self", ".", "center", "[", "2", "]", ",", "self", ".", "wlh", "[", "0", "]", ",", "\n", "self", ".", "wlh", "[", "1", "]", ",", "self", ".", "wlh", "[", "2", "]", ",", "self", ".", "orientation", ".", "axis", "[", "0", "]", ",", "self", ".", "orientation", ".", "axis", "[", "1", "]", ",", "\n", "self", ".", "orientation", ".", "axis", "[", "2", "]", ",", "self", ".", "orientation", ".", "degrees", ",", "self", ".", "orientation", ".", "radians", ",", "\n", "self", ".", "velocity", "[", "0", "]", ",", "self", ".", "velocity", "[", "1", "]", ",", "self", ".", "velocity", "[", "2", "]", ",", "self", ".", "name", ",", "self", ".", "token", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.rotation_matrix": [[581, 588], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "rotation_matrix", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Return a rotation matrix.\n        :return: <np.float: 3, 3>. The box's rotation matrix.\n        \"\"\"", "\n", "return", "self", ".", "orientation", ".", "rotation_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.translate": [[589, 595], ["None"], "methods", ["None"], ["", "def", "translate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Applies a translation.\n        :param x: <np.float: 3, 1>. Translation in x, y, z direction.\n        \"\"\"", "\n", "self", ".", "center", "+=", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.rotate": [[596, 604], ["numpy.dot", "numpy.dot"], "methods", ["None"], ["", "def", "rotate", "(", "self", ",", "quaternion", ":", "Quaternion", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Rotates box.\n        :param quaternion: Rotation to apply.\n        \"\"\"", "\n", "self", ".", "center", "=", "np", ".", "dot", "(", "quaternion", ".", "rotation_matrix", ",", "self", ".", "center", ")", "\n", "self", ".", "orientation", "=", "quaternion", "*", "self", ".", "orientation", "\n", "self", ".", "velocity", "=", "np", ".", "dot", "(", "quaternion", ".", "rotation_matrix", ",", "self", ".", "velocity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.corners": [[605, 630], ["numpy.vstack", "numpy.dot", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "corners", "(", "self", ",", "wlh_factor", ":", "float", "=", "1.0", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Returns the bounding box corners.\n        :param wlh_factor: Multiply w, l, h by a factor to scale the box.\n        :return: <np.float: 3, 8>. First four corners are the ones facing forward.\n            The last four are the ones facing backwards.\n        \"\"\"", "\n", "w", ",", "l", ",", "h", "=", "self", ".", "wlh", "*", "wlh_factor", "\n", "\n", "# 3D bounding box corners. (Convention: x points forward, y to the left, z up.)", "\n", "x_corners", "=", "l", "/", "2", "*", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", ",", "-", "1", "]", ")", "\n", "y_corners", "=", "w", "/", "2", "*", "np", ".", "array", "(", "[", "1", ",", "-", "1", ",", "-", "1", ",", "1", ",", "1", ",", "-", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "z_corners", "=", "h", "/", "2", "*", "np", ".", "array", "(", "[", "1", ",", "1", ",", "-", "1", ",", "-", "1", ",", "1", ",", "1", ",", "-", "1", ",", "-", "1", "]", ")", "\n", "corners", "=", "np", ".", "vstack", "(", "(", "x_corners", ",", "y_corners", ",", "z_corners", ")", ")", "\n", "\n", "# Rotate", "\n", "corners", "=", "np", ".", "dot", "(", "self", ".", "orientation", ".", "rotation_matrix", ",", "corners", ")", "\n", "\n", "# Translate", "\n", "x", ",", "y", ",", "z", "=", "self", ".", "center", "\n", "corners", "[", "0", ",", ":", "]", "=", "corners", "[", "0", ",", ":", "]", "+", "x", "\n", "corners", "[", "1", ",", ":", "]", "=", "corners", "[", "1", ",", ":", "]", "+", "y", "\n", "corners", "[", "2", ",", ":", "]", "=", "corners", "[", "2", ",", ":", "]", "+", "z", "\n", "\n", "return", "corners", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.bottom_corners": [[631, 637], ["data_classes.Box.corners"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["", "def", "bottom_corners", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Returns the four bottom corners.\n        :return: <np.float: 3, 4>. Bottom corners. First two face forward, last two face backwards.\n        \"\"\"", "\n", "return", "self", ".", "corners", "(", ")", "[", ":", ",", "[", "2", ",", "3", ",", "7", ",", "6", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.render": [[638, 677], ["numpy.eye", "range", "data_classes.Box.render.draw_rect"], "methods", ["None"], ["", "def", "render", "(", "self", ",", "\n", "axis", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "3", ")", ",", "\n", "normalize", ":", "bool", "=", "False", ",", "\n", "colors", ":", "Tuple", "=", "(", "'b'", ",", "'r'", ",", "'k'", ")", ",", "\n", "linewidth", ":", "float", "=", "2", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders the box in the provided Matplotlib axis.\n        :param axis: Axis onto which the box should be drawn.\n        :param view: <np.array: 3, 3>. Define a projection in needed (e.g. for drawing projection in an image).\n        :param normalize: Whether to normalize the remaining coordinate.\n        :param colors: (<Matplotlib.colors>: 3). Valid Matplotlib colors (<str> or normalized RGB tuple) for front,\n            back and sides.\n        :param linewidth: Width in pixel of the box sides.\n        \"\"\"", "\n", "corners", "=", "view_points", "(", "self", ".", "corners", "(", ")", ",", "view", ",", "normalize", "=", "normalize", ")", "[", ":", "2", ",", ":", "]", "\n", "\n", "def", "draw_rect", "(", "selected_corners", ",", "color", ")", ":", "\n", "            ", "prev", "=", "selected_corners", "[", "-", "1", "]", "\n", "for", "corner", "in", "selected_corners", ":", "\n", "                ", "axis", ".", "plot", "(", "[", "prev", "[", "0", "]", ",", "corner", "[", "0", "]", "]", ",", "[", "prev", "[", "1", "]", ",", "corner", "[", "1", "]", "]", ",", "color", "=", "color", ",", "linewidth", "=", "linewidth", ")", "\n", "prev", "=", "corner", "\n", "\n", "# Draw the sides", "\n", "", "", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "axis", ".", "plot", "(", "[", "corners", ".", "T", "[", "i", "]", "[", "0", "]", ",", "corners", ".", "T", "[", "i", "+", "4", "]", "[", "0", "]", "]", ",", "\n", "[", "corners", ".", "T", "[", "i", "]", "[", "1", "]", ",", "corners", ".", "T", "[", "i", "+", "4", "]", "[", "1", "]", "]", ",", "\n", "color", "=", "colors", "[", "2", "]", ",", "linewidth", "=", "linewidth", ")", "\n", "\n", "# Draw front (first 4 corners) and rear (last 4 corners) rectangles(3d)/lines(2d)", "\n", "", "draw_rect", "(", "corners", ".", "T", "[", ":", "4", "]", ",", "colors", "[", "0", "]", ")", "\n", "draw_rect", "(", "corners", ".", "T", "[", "4", ":", "]", ",", "colors", "[", "1", "]", ")", "\n", "\n", "# Draw line indicating the front", "\n", "center_bottom_forward", "=", "np", ".", "mean", "(", "corners", ".", "T", "[", "2", ":", "4", "]", ",", "axis", "=", "0", ")", "\n", "center_bottom", "=", "np", ".", "mean", "(", "corners", ".", "T", "[", "[", "2", ",", "3", ",", "7", ",", "6", "]", "]", ",", "axis", "=", "0", ")", "\n", "axis", ".", "plot", "(", "[", "center_bottom", "[", "0", "]", ",", "center_bottom_forward", "[", "0", "]", "]", ",", "\n", "[", "center_bottom", "[", "1", "]", ",", "center_bottom_forward", "[", "1", "]", "]", ",", "\n", "color", "=", "colors", "[", "0", "]", ",", "linewidth", "=", "linewidth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.render_cv2": [[678, 721], ["numpy.eye", "range", "data_classes.Box.render.draw_rect"], "methods", ["None"], ["", "def", "render_cv2", "(", "self", ",", "\n", "im", ":", "np", ".", "ndarray", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "3", ")", ",", "\n", "normalize", ":", "bool", "=", "False", ",", "\n", "colors", ":", "Tuple", "=", "(", "(", "0", ",", "0", ",", "255", ")", ",", "(", "255", ",", "0", ",", "0", ")", ",", "(", "155", ",", "155", ",", "155", ")", ")", ",", "\n", "linewidth", ":", "int", "=", "2", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders box using OpenCV2.\n        :param im: <np.array: width, height, 3>. Image array. Channels are in BGR order.\n        :param view: <np.array: 3, 3>. Define a projection if needed (e.g. for drawing projection in an image).\n        :param normalize: Whether to normalize the remaining coordinate.\n        :param colors: ((R, G, B), (R, G, B), (R, G, B)). Colors for front, side & rear.\n        :param linewidth: Linewidth for plot.\n        \"\"\"", "\n", "corners", "=", "view_points", "(", "self", ".", "corners", "(", ")", ",", "view", ",", "normalize", "=", "normalize", ")", "[", ":", "2", ",", ":", "]", "\n", "\n", "def", "draw_rect", "(", "selected_corners", ",", "color", ")", ":", "\n", "            ", "prev", "=", "selected_corners", "[", "-", "1", "]", "\n", "for", "corner", "in", "selected_corners", ":", "\n", "                ", "cv2", ".", "line", "(", "im", ",", "\n", "(", "int", "(", "prev", "[", "0", "]", ")", ",", "int", "(", "prev", "[", "1", "]", ")", ")", ",", "\n", "(", "int", "(", "corner", "[", "0", "]", ")", ",", "int", "(", "corner", "[", "1", "]", ")", ")", ",", "\n", "color", ",", "linewidth", ")", "\n", "prev", "=", "corner", "\n", "\n", "# Draw the sides", "\n", "", "", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "cv2", ".", "line", "(", "im", ",", "\n", "(", "int", "(", "corners", ".", "T", "[", "i", "]", "[", "0", "]", ")", ",", "int", "(", "corners", ".", "T", "[", "i", "]", "[", "1", "]", ")", ")", ",", "\n", "(", "int", "(", "corners", ".", "T", "[", "i", "+", "4", "]", "[", "0", "]", ")", ",", "int", "(", "corners", ".", "T", "[", "i", "+", "4", "]", "[", "1", "]", ")", ")", ",", "\n", "colors", "[", "2", "]", "[", ":", ":", "-", "1", "]", ",", "linewidth", ")", "\n", "\n", "# Draw front (first 4 corners) and rear (last 4 corners) rectangles(3d)/lines(2d)", "\n", "", "draw_rect", "(", "corners", ".", "T", "[", ":", "4", "]", ",", "colors", "[", "0", "]", "[", ":", ":", "-", "1", "]", ")", "\n", "draw_rect", "(", "corners", ".", "T", "[", "4", ":", "]", ",", "colors", "[", "1", "]", "[", ":", ":", "-", "1", "]", ")", "\n", "\n", "# Draw line indicating the front", "\n", "center_bottom_forward", "=", "np", ".", "mean", "(", "corners", ".", "T", "[", "2", ":", "4", "]", ",", "axis", "=", "0", ")", "\n", "center_bottom", "=", "np", ".", "mean", "(", "corners", ".", "T", "[", "[", "2", ",", "3", ",", "7", ",", "6", "]", "]", ",", "axis", "=", "0", ")", "\n", "cv2", ".", "line", "(", "im", ",", "\n", "(", "int", "(", "center_bottom", "[", "0", "]", ")", ",", "int", "(", "center_bottom", "[", "1", "]", ")", ")", ",", "\n", "(", "int", "(", "center_bottom_forward", "[", "0", "]", ")", ",", "int", "(", "center_bottom_forward", "[", "1", "]", ")", ")", ",", "\n", "colors", "[", "0", "]", "[", ":", ":", "-", "1", "]", ",", "linewidth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy": [[722, 728], ["copy.deepcopy"], "methods", ["None"], ["", "def", "copy", "(", "self", ")", "->", "'Box'", ":", "\n", "        ", "\"\"\"\n        Create a copy of self.\n        :return: A copy.\n        \"\"\"", "\n", "return", "copy", ".", "deepcopy", "(", "self", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points": [[18, 55], ["numpy.eye", "numpy.concatenate", "numpy.dot", "numpy.ones", "points[].repeat().reshape", "points[].repeat"], "function", ["None"], ["", "def", "view_points", "(", "points", ":", "np", ".", "ndarray", ",", "view", ":", "np", ".", "ndarray", ",", "normalize", ":", "bool", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    This is a helper class that maps 3d points to a 2d plane. It can be used to implement both perspective and\n    orthographic projections. It first applies the dot product between the points and the view. By convention,\n    the view should be such that the data is projected onto the first 2 axis. It then optionally applies a\n    normalization along the third dimension.\n\n    For a perspective projection the view should be a 3x3 camera matrix, and normalize=True\n    For an orthographic projection with translation the view is a 3x4 matrix and normalize=False\n    For an orthographic projection without translation the view is a 3x3 matrix (optionally 3x4 with last columns\n     all zeros) and normalize=False\n\n    :param points: <np.float32: 3, n> Matrix of points, where each point (x, y, z) is along each column.\n    :param view: <np.float32: n, n>. Defines an arbitrary projection (n <= 4).\n        The projection should be such that the corners are projected onto the first 2 axis.\n    :param normalize: Whether to normalize the remaining coordinate (along the third axis).\n    :return: <np.float32: 3, n>. Mapped point. If normalize=False, the third coordinate is the height.\n    \"\"\"", "\n", "\n", "assert", "view", ".", "shape", "[", "0", "]", "<=", "4", "\n", "assert", "view", ".", "shape", "[", "1", "]", "<=", "4", "\n", "assert", "points", ".", "shape", "[", "0", "]", "==", "3", "\n", "\n", "viewpad", "=", "np", ".", "eye", "(", "4", ")", "\n", "viewpad", "[", ":", "view", ".", "shape", "[", "0", "]", ",", ":", "view", ".", "shape", "[", "1", "]", "]", "=", "view", "\n", "\n", "nbr_points", "=", "points", ".", "shape", "[", "1", "]", "\n", "\n", "# Do operation in homogenous coordinates.", "\n", "points", "=", "np", ".", "concatenate", "(", "(", "points", ",", "np", ".", "ones", "(", "(", "1", ",", "nbr_points", ")", ")", ")", ")", "\n", "points", "=", "np", ".", "dot", "(", "viewpad", ",", "points", ")", "\n", "points", "=", "points", "[", ":", "3", ",", ":", "]", "\n", "\n", "if", "normalize", ":", "\n", "        ", "points", "=", "points", "/", "points", "[", "2", ":", "3", ",", ":", "]", ".", "repeat", "(", "3", ",", "0", ")", ".", "reshape", "(", "3", ",", "nbr_points", ")", "\n", "\n", "", "return", "points", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.box_in_image": [[57, 85], ["box.corners", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "geometry_utils.view_points", "all", "all", "any", "all", "ValueError"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "def", "box_in_image", "(", "box", ",", "intrinsic", ":", "np", ".", "ndarray", ",", "imsize", ":", "Tuple", "[", "int", ",", "int", "]", ",", "vis_level", ":", "int", "=", "BoxVisibility", ".", "ANY", ")", "->", "bool", ":", "\n", "    ", "\"\"\"\n    Check if a box is visible inside an image without accounting for occlusions.\n    :param box: The box to be checked.\n    :param intrinsic: <float: 3, 3>. Intrinsic camera matrix.\n    :param imsize: (width, height).\n    :param vis_level: One of the enumerations of <BoxVisibility>.\n    :return True if visibility condition is satisfied.\n    \"\"\"", "\n", "\n", "corners_3d", "=", "box", ".", "corners", "(", ")", "\n", "corners_img", "=", "view_points", "(", "corners_3d", ",", "intrinsic", ",", "normalize", "=", "True", ")", "[", ":", "2", ",", ":", "]", "\n", "\n", "visible", "=", "np", ".", "logical_and", "(", "corners_img", "[", "0", ",", ":", "]", ">", "0", ",", "corners_img", "[", "0", ",", ":", "]", "<", "imsize", "[", "0", "]", ")", "\n", "visible", "=", "np", ".", "logical_and", "(", "visible", ",", "corners_img", "[", "1", ",", ":", "]", "<", "imsize", "[", "1", "]", ")", "\n", "visible", "=", "np", ".", "logical_and", "(", "visible", ",", "corners_img", "[", "1", ",", ":", "]", ">", "0", ")", "\n", "visible", "=", "np", ".", "logical_and", "(", "visible", ",", "corners_3d", "[", "2", ",", ":", "]", ">", "1", ")", "\n", "\n", "in_front", "=", "corners_3d", "[", "2", ",", ":", "]", ">", "0.1", "# True if a corner is at least 0.1 meter in front of the camera.", "\n", "\n", "if", "vis_level", "==", "BoxVisibility", ".", "ALL", ":", "\n", "        ", "return", "all", "(", "visible", ")", "and", "all", "(", "in_front", ")", "\n", "", "elif", "vis_level", "==", "BoxVisibility", ".", "ANY", ":", "\n", "        ", "return", "any", "(", "visible", ")", "and", "all", "(", "in_front", ")", "\n", "", "elif", "vis_level", "==", "BoxVisibility", ".", "NONE", ":", "\n", "        ", "return", "True", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"vis_level: {} not valid\"", ".", "format", "(", "vis_level", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.transform_matrix": [[87, 109], ["numpy.array", "pyquaternion.Quaternion", "numpy.eye", "numpy.transpose", "rot_inv.dot", "numpy.transpose", "numpy.array", "numpy.array"], "function", ["None"], ["", "", "def", "transform_matrix", "(", "translation", ":", "np", ".", "ndarray", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", ",", "\n", "rotation", ":", "Quaternion", "=", "Quaternion", "(", "[", "1", ",", "0", ",", "0", ",", "0", "]", ")", ",", "\n", "inverse", ":", "bool", "=", "False", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Convert pose to transformation matrix.\n    :param translation: <np.float32: 3>. Translation in x, y, z.\n    :param rotation: Rotation in quaternions (w ri rj rk).\n    :param inverse: Whether to compute inverse transform matrix.\n    :return: <np.float32: 4, 4>. Transformation matrix.\n    \"\"\"", "\n", "tm", "=", "np", ".", "eye", "(", "4", ")", "\n", "\n", "if", "inverse", ":", "\n", "        ", "rot_inv", "=", "rotation", ".", "rotation_matrix", ".", "T", "\n", "trans", "=", "np", ".", "transpose", "(", "-", "np", ".", "array", "(", "translation", ")", ")", "\n", "tm", "[", ":", "3", ",", ":", "3", "]", "=", "rot_inv", "\n", "tm", "[", ":", "3", ",", "3", "]", "=", "rot_inv", ".", "dot", "(", "trans", ")", "\n", "", "else", ":", "\n", "        ", "tm", "[", ":", "3", ",", ":", "3", "]", "=", "rotation", ".", "rotation_matrix", "\n", "tm", "[", ":", "3", ",", "3", "]", "=", "np", ".", "transpose", "(", "np", ".", "array", "(", "translation", ")", ")", "\n", "\n", "", "return", "tm", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.points_in_box": [[111, 146], ["box.corners", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "p1.reshape", "numpy.logical_and", "numpy.dot", "numpy.dot", "numpy.dot"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["", "def", "points_in_box", "(", "box", ":", "'Box'", ",", "points", ":", "np", ".", "ndarray", ",", "wlh_factor", ":", "float", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"\n    Checks whether points are inside the box.\n\n    Picks one corner as reference (p1) and computes the vector to a target point (v).\n    Then for each of the 3 axes, project v onto the axis and compare the length.\n    Inspired by: https://math.stackexchange.com/a/1552579\n    :param box: <Box>.\n    :param points: <np.float: 3, n>.\n    :param wlh_factor: Inflates or deflates the box.\n    :return: <np.bool: n, >.\n    \"\"\"", "\n", "corners", "=", "box", ".", "corners", "(", "wlh_factor", "=", "wlh_factor", ")", "\n", "\n", "p1", "=", "corners", "[", ":", ",", "0", "]", "\n", "p_x", "=", "corners", "[", ":", ",", "4", "]", "\n", "p_y", "=", "corners", "[", ":", ",", "1", "]", "\n", "p_z", "=", "corners", "[", ":", ",", "3", "]", "\n", "\n", "i", "=", "p_x", "-", "p1", "\n", "j", "=", "p_y", "-", "p1", "\n", "k", "=", "p_z", "-", "p1", "\n", "\n", "v", "=", "points", "-", "p1", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "iv", "=", "np", ".", "dot", "(", "i", ",", "v", ")", "\n", "jv", "=", "np", ".", "dot", "(", "j", ",", "v", ")", "\n", "kv", "=", "np", ".", "dot", "(", "k", ",", "v", ")", "\n", "\n", "mask_x", "=", "np", ".", "logical_and", "(", "0", "<=", "iv", ",", "iv", "<=", "np", ".", "dot", "(", "i", ",", "i", ")", ")", "\n", "mask_y", "=", "np", ".", "logical_and", "(", "0", "<=", "jv", ",", "jv", "<=", "np", ".", "dot", "(", "j", ",", "j", ")", ")", "\n", "mask_z", "=", "np", ".", "logical_and", "(", "0", "<=", "kv", ",", "kv", "<=", "np", ".", "dot", "(", "k", ",", "k", ")", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "np", ".", "logical_and", "(", "mask_x", ",", "mask_y", ")", ",", "mask_z", ")", "\n", "\n", "return", "mask", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file": [[5, 22], ["os.path.exists", "numpy.fromfile", "len", "TypeError", "numpy.load"], "function", ["None"], ["def", "load_bin_file", "(", "bin_path", ":", "str", ",", "type", ":", "str", "=", "'lidarseg'", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Loads a .bin file containing the lidarseg or lidar panoptic labels.\n    :param bin_path: Path to the .bin file.\n    :param type: semantic type, 'lidarseg': stored in 8-bit format, 'panoptic': store in 32-bit format.\n    :return: An array containing the labels, with dtype of np.uint8 for lidarseg and np.int32 for panoptic.\n    \"\"\"", "\n", "assert", "os", ".", "path", ".", "exists", "(", "bin_path", ")", ",", "'Error: Unable to find {}.'", ".", "format", "(", "bin_path", ")", "\n", "if", "type", "==", "'lidarseg'", ":", "\n", "        ", "bin_content", "=", "np", ".", "fromfile", "(", "bin_path", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "elif", "type", "==", "'panoptic'", ":", "\n", "        ", "bin_content", "=", "np", ".", "load", "(", "bin_path", ")", "[", "'data'", "]", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "f\"Only lidarseg/panoptic type is supported, received {type}\"", ")", "\n", "", "assert", "len", "(", "bin_content", ")", ">", "0", ",", "'Error: {} is empty.'", ".", "format", "(", "bin_path", ")", "\n", "\n", "return", "bin_content", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.panoptic_to_lidarseg": [[24, 32], ["None"], "function", ["None"], ["", "def", "panoptic_to_lidarseg", "(", "panoptic_labels", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Convert panoptic label array to lidarseg label array\n    :param panoptic_labels: <np.array, HxW, np.uint16>, encoded in (instance_id + 1000 * category_idx), note instance_id\n    for stuff points is 0.\n    :return: lidarseg semantic labels, <np.array, HxW, np.uint8>.\n    \"\"\"", "\n", "return", "(", "panoptic_labels", "//", "1000", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.color_map.get_colormap": [[4, 46], ["None"], "function", ["None"], ["def", "get_colormap", "(", ")", "->", "Dict", "[", "str", ",", "Tuple", "[", "int", ",", "int", ",", "int", "]", "]", ":", "\n", "    ", "\"\"\"\n    Get the defined colormap.\n    :return: A mapping from the class names to the respective RGB values.\n    \"\"\"", "\n", "\n", "classname_to_color", "=", "{", "# RGB.", "\n", "\"noise\"", ":", "(", "0", ",", "0", ",", "0", ")", ",", "# Black.", "\n", "\"animal\"", ":", "(", "70", ",", "130", ",", "180", ")", ",", "# Steelblue", "\n", "\"human.pedestrian.adult\"", ":", "(", "0", ",", "0", ",", "230", ")", ",", "# Blue", "\n", "\"human.pedestrian.child\"", ":", "(", "135", ",", "206", ",", "235", ")", ",", "# Skyblue,", "\n", "\"human.pedestrian.construction_worker\"", ":", "(", "100", ",", "149", ",", "237", ")", ",", "# Cornflowerblue", "\n", "\"human.pedestrian.personal_mobility\"", ":", "(", "219", ",", "112", ",", "147", ")", ",", "# Palevioletred", "\n", "\"human.pedestrian.police_officer\"", ":", "(", "0", ",", "0", ",", "128", ")", ",", "# Navy,", "\n", "\"human.pedestrian.stroller\"", ":", "(", "240", ",", "128", ",", "128", ")", ",", "# Lightcoral", "\n", "\"human.pedestrian.wheelchair\"", ":", "(", "138", ",", "43", ",", "226", ")", ",", "# Blueviolet", "\n", "\"movable_object.barrier\"", ":", "(", "112", ",", "128", ",", "144", ")", ",", "# Slategrey", "\n", "\"movable_object.debris\"", ":", "(", "210", ",", "105", ",", "30", ")", ",", "# Chocolate", "\n", "\"movable_object.pushable_pullable\"", ":", "(", "105", ",", "105", ",", "105", ")", ",", "# Dimgrey", "\n", "\"movable_object.trafficcone\"", ":", "(", "47", ",", "79", ",", "79", ")", ",", "# Darkslategrey", "\n", "\"static_object.bicycle_rack\"", ":", "(", "188", ",", "143", ",", "143", ")", ",", "# Rosybrown", "\n", "\"vehicle.bicycle\"", ":", "(", "220", ",", "20", ",", "60", ")", ",", "# Crimson", "\n", "\"vehicle.bus.bendy\"", ":", "(", "255", ",", "127", ",", "80", ")", ",", "# Coral", "\n", "\"vehicle.bus.rigid\"", ":", "(", "255", ",", "69", ",", "0", ")", ",", "# Orangered", "\n", "\"vehicle.car\"", ":", "(", "255", ",", "158", ",", "0", ")", ",", "# Orange", "\n", "\"vehicle.construction\"", ":", "(", "233", ",", "150", ",", "70", ")", ",", "# Darksalmon", "\n", "\"vehicle.emergency.ambulance\"", ":", "(", "255", ",", "83", ",", "0", ")", ",", "\n", "\"vehicle.emergency.police\"", ":", "(", "255", ",", "215", ",", "0", ")", ",", "# Gold", "\n", "\"vehicle.motorcycle\"", ":", "(", "255", ",", "61", ",", "99", ")", ",", "# Red", "\n", "\"vehicle.trailer\"", ":", "(", "255", ",", "140", ",", "0", ")", ",", "# Darkorange", "\n", "\"vehicle.truck\"", ":", "(", "255", ",", "99", ",", "71", ")", ",", "# Tomato", "\n", "\"flat.driveable_surface\"", ":", "(", "0", ",", "207", ",", "191", ")", ",", "# nuTonomy green", "\n", "\"flat.other\"", ":", "(", "175", ",", "0", ",", "75", ")", ",", "\n", "\"flat.sidewalk\"", ":", "(", "75", ",", "0", ",", "75", ")", ",", "\n", "\"flat.terrain\"", ":", "(", "112", ",", "180", ",", "60", ")", ",", "\n", "\"static.manmade\"", ":", "(", "222", ",", "184", ",", "135", ")", ",", "# Burlywood", "\n", "\"static.other\"", ":", "(", "255", ",", "228", ",", "196", ")", ",", "# Bisque", "\n", "\"static.vegetation\"", ":", "(", "0", ",", "175", ",", "0", ")", ",", "# Green", "\n", "\"vehicle.ego\"", ":", "(", "255", ",", "240", ",", "245", ")", "\n", "}", "\n", "\n", "return", "classname_to_color", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.__init__": [[48, 79], ["kitti.KittiDB._kitti_tokens.items", "pyquaternion.Quaternion", "os.path.join", "os.listdir", "os.listdir.sort", "pyquaternion.Quaternion", "t.replace"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "root", ":", "str", "=", "'/data/sets/kitti'", ",", "\n", "splits", ":", "Tuple", "[", "str", ",", "...", "]", "=", "(", "'train'", ",", ")", ")", ":", "\n", "        ", "\"\"\"\n        :param root: Base folder for all KITTI data.\n        :param splits: Which splits to load.\n        \"\"\"", "\n", "self", ".", "root", "=", "root", "\n", "self", ".", "tables", "=", "(", "'calib'", ",", "'image_2'", ",", "'label_2'", ",", "'velodyne'", ")", "\n", "self", ".", "_kitti_fileext", "=", "{", "'calib'", ":", "'txt'", ",", "'image_2'", ":", "'png'", ",", "'label_2'", ":", "'txt'", ",", "'velodyne'", ":", "'bin'", "}", "\n", "\n", "# Grab all the expected tokens.", "\n", "self", ".", "_kitti_tokens", "=", "{", "}", "\n", "for", "split", "in", "splits", ":", "\n", "            ", "split_dir", "=", "osp", ".", "join", "(", "self", ".", "root", ",", "split", ",", "'image_2'", ")", "\n", "_tokens", "=", "os", ".", "listdir", "(", "split_dir", ")", "\n", "_tokens", "=", "[", "t", ".", "replace", "(", "'.png'", ",", "''", ")", "for", "t", "in", "_tokens", "]", "\n", "_tokens", ".", "sort", "(", ")", "\n", "self", ".", "_kitti_tokens", "[", "split", "]", "=", "_tokens", "\n", "\n", "# Creating the tokens.", "\n", "", "self", ".", "tokens", "=", "[", "]", "\n", "for", "split", ",", "tokens", "in", "self", ".", "_kitti_tokens", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "tokens", "+=", "[", "'{}_{}'", ".", "format", "(", "split", ",", "token", ")", "for", "token", "in", "tokens", "]", "\n", "\n", "# KITTI LIDAR has the x-axis pointing forward, but our LIDAR points to the right. So we need to apply a", "\n", "# 90 degree rotation around to yaw (z-axis) in order to align.", "\n", "# The quaternions will be used a lot of time. We store them as instance variables so that we don't have", "\n", "# to create a new one every single time.", "\n", "", "self", ".", "kitti_to_nu_lidar", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "np", ".", "pi", "/", "2", ")", "\n", "self", ".", "kitti_to_nu_lidar_inv", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "np", ".", "pi", "/", "2", ")", ".", "inverse", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.standardize_sample_token": [[80, 91], ["token.split"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "standardize_sample_token", "(", "token", ":", "str", ")", "->", "Tuple", "[", "str", ",", "str", "]", ":", "\n", "        ", "\"\"\"\n        Convert sample token into standard KITTI folder and local filename format.\n        :param token: KittiDB unique id.\n        :return: folder (ex. train, val, test), filename (ex. 000001)\n        \"\"\"", "\n", "splits", "=", "token", ".", "split", "(", "'_'", ")", "\n", "folder", "=", "'_'", ".", "join", "(", "splits", "[", ":", "-", "1", "]", ")", "\n", "filename", "=", "splits", "[", "-", "1", "]", "\n", "return", "folder", ",", "filename", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.parse_label_line": [[92, 120], ["label_line.split", "parts[].strip", "float", "float", "float", "float", "len", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float", "float"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "parse_label_line", "(", "label_line", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Parses single line from label file into a dict. Boxes are in camera frame. See KITTI devkit for details and\n        http://www.cvlibs.net/datasets/kitti/setup.php for visualizations of the setup.\n        :param label_line: Single line from KittiDB label file.\n        :return: Dictionary with all the line details.\n        \"\"\"", "\n", "\n", "parts", "=", "label_line", ".", "split", "(", "' '", ")", "\n", "output", "=", "{", "\n", "'name'", ":", "parts", "[", "0", "]", ".", "strip", "(", ")", ",", "\n", "'xyz_camera'", ":", "(", "float", "(", "parts", "[", "11", "]", ")", ",", "float", "(", "parts", "[", "12", "]", ")", ",", "float", "(", "parts", "[", "13", "]", ")", ")", ",", "\n", "'wlh'", ":", "(", "float", "(", "parts", "[", "9", "]", ")", ",", "float", "(", "parts", "[", "10", "]", ")", ",", "float", "(", "parts", "[", "8", "]", ")", ")", ",", "\n", "'yaw_camera'", ":", "float", "(", "parts", "[", "14", "]", ")", ",", "\n", "'bbox_camera'", ":", "(", "float", "(", "parts", "[", "4", "]", ")", ",", "float", "(", "parts", "[", "5", "]", ")", ",", "float", "(", "parts", "[", "6", "]", ")", ",", "float", "(", "parts", "[", "7", "]", ")", ")", ",", "\n", "'truncation'", ":", "float", "(", "parts", "[", "1", "]", ")", ",", "\n", "'occlusion'", ":", "float", "(", "parts", "[", "2", "]", ")", ",", "\n", "'alpha'", ":", "float", "(", "parts", "[", "3", "]", ")", "\n", "}", "\n", "\n", "# Add score if specified", "\n", "if", "len", "(", "parts", ")", ">", "15", ":", "\n", "            ", "output", "[", "'score'", "]", "=", "float", "(", "parts", "[", "15", "]", ")", "\n", "", "else", ":", "\n", "            ", "output", "[", "'score'", "]", "=", "np", ".", "nan", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.box_nuscenes_to_kitti": [[121, 154], ["box.copy.copy.copy", "box.copy.copy.rotate", "box.copy.copy.rotate", "box.copy.copy.translate", "box.copy.copy.rotate", "box.copy.copy.translate", "pyquaternion.Quaternion", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate"], ["", "@", "staticmethod", "\n", "def", "box_nuscenes_to_kitti", "(", "box", ":", "Box", ",", "velo_to_cam_rot", ":", "Quaternion", ",", "\n", "velo_to_cam_trans", ":", "np", ".", "ndarray", ",", "\n", "r0_rect", ":", "Quaternion", ",", "\n", "kitti_to_nu_lidar_inv", ":", "Quaternion", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "np", ".", "pi", "/", "2", ")", ".", "inverse", ")", "->", "Box", ":", "\n", "        ", "\"\"\"\n        Transform from nuScenes lidar frame to KITTI reference frame.\n        :param box: Instance in nuScenes lidar frame.\n        :param velo_to_cam_rot: Quaternion to rotate from lidar to camera frame.\n        :param velo_to_cam_trans: <np.float: 3>. Translate from lidar to camera frame.\n        :param r0_rect: Quaternion to rectify camera frame.\n        :param kitti_to_nu_lidar_inv: Quaternion to rotate nuScenes to KITTI LIDAR.\n        :return: Box instance in KITTI reference frame.\n        \"\"\"", "\n", "# Copy box to avoid side-effects.", "\n", "box", "=", "box", ".", "copy", "(", ")", "\n", "\n", "# Rotate to KITTI lidar.", "\n", "box", ".", "rotate", "(", "kitti_to_nu_lidar_inv", ")", "\n", "\n", "# Transform to KITTI camera.", "\n", "box", ".", "rotate", "(", "velo_to_cam_rot", ")", "\n", "box", ".", "translate", "(", "velo_to_cam_trans", ")", "\n", "\n", "# Rotate to KITTI rectified camera.", "\n", "box", ".", "rotate", "(", "r0_rect", ")", "\n", "\n", "# KITTI defines the box center as the bottom center of the object.", "\n", "# We use the true center, so we need to adjust half height in y direction.", "\n", "box", ".", "translate", "(", "np", ".", "array", "(", "[", "0", ",", "box", ".", "wlh", "[", "2", "]", "/", "2", ",", "0", "]", ")", ")", "\n", "\n", "return", "box", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.project_kitti_box_to_image": [[155, 194], ["box.copy.copy.copy", "box.copy.copy.translate", "tuple", "numpy.array", "numpy.array", "len", "utils.geometry_utils.view_points", "numpy.min", "numpy.min", "numpy.max", "numpy.max", "min", "min", "min", "min", "max", "box.copy.copy.corners"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["", "@", "staticmethod", "\n", "def", "project_kitti_box_to_image", "(", "box", ":", "Box", ",", "p_left", ":", "np", ".", "ndarray", ",", "imsize", ":", "Tuple", "[", "int", ",", "int", "]", ")", "->", "Union", "[", "None", ",", "Tuple", "[", "int", ",", "int", ",", "int", ",", "int", "]", "]", ":", "\n", "        ", "\"\"\"\n        Projects 3D box into KITTI image FOV.\n        :param box: 3D box in KITTI reference frame.\n        :param p_left: <np.float: 3, 4>. Projection matrix.\n        :param imsize: (width, height). Image size.\n        :return: (xmin, ymin, xmax, ymax). Bounding box in image plane or None if box is not in the image.\n        \"\"\"", "\n", "\n", "# Create a new box.", "\n", "box", "=", "box", ".", "copy", "(", ")", "\n", "\n", "# KITTI defines the box center as the bottom center of the object.", "\n", "# We use the true center, so we need to adjust half height in negative y direction.", "\n", "box", ".", "translate", "(", "np", ".", "array", "(", "[", "0", ",", "-", "box", ".", "wlh", "[", "2", "]", "/", "2", ",", "0", "]", ")", ")", "\n", "\n", "# Check that some corners are inside the image.", "\n", "corners", "=", "np", ".", "array", "(", "[", "corner", "for", "corner", "in", "box", ".", "corners", "(", ")", ".", "T", "if", "corner", "[", "2", "]", ">", "0", "]", ")", ".", "T", "\n", "if", "len", "(", "corners", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "# Project corners that are in front of the camera to 2d to get bbox in pixel coords.", "\n", "", "imcorners", "=", "view_points", "(", "corners", ",", "p_left", ",", "normalize", "=", "True", ")", "[", ":", "2", "]", "\n", "bbox", "=", "(", "np", ".", "min", "(", "imcorners", "[", "0", "]", ")", ",", "np", ".", "min", "(", "imcorners", "[", "1", "]", ")", ",", "np", ".", "max", "(", "imcorners", "[", "0", "]", ")", ",", "np", ".", "max", "(", "imcorners", "[", "1", "]", ")", ")", "\n", "\n", "# Crop bbox to prevent it extending outside image.", "\n", "bbox_crop", "=", "tuple", "(", "max", "(", "0", ",", "b", ")", "for", "b", "in", "bbox", ")", "\n", "bbox_crop", "=", "(", "min", "(", "imsize", "[", "0", "]", ",", "bbox_crop", "[", "0", "]", ")", ",", "\n", "min", "(", "imsize", "[", "0", "]", ",", "bbox_crop", "[", "1", "]", ")", ",", "\n", "min", "(", "imsize", "[", "0", "]", ",", "bbox_crop", "[", "2", "]", ")", ",", "\n", "min", "(", "imsize", "[", "1", "]", ",", "bbox_crop", "[", "3", "]", ")", ")", "\n", "\n", "# Detect if a cropped box is empty.", "\n", "if", "bbox_crop", "[", "0", "]", ">=", "bbox_crop", "[", "2", "]", "or", "bbox_crop", "[", "1", "]", ">=", "bbox_crop", "[", "3", "]", ":", "\n", "            ", "return", "None", "\n", "\n", "", "return", "bbox_crop", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_filepath": [[195, 216], ["kitti.KittiDB.standardize_sample_token", "token.startswith", "print", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.standardize_sample_token"], ["", "@", "staticmethod", "\n", "def", "get_filepath", "(", "token", ":", "str", ",", "table", ":", "str", ",", "root", ":", "str", "=", "'/data/sets/kitti'", ")", "->", "str", ":", "\n", "        ", "\"\"\"\n        For a token and table, get the filepath to the associated data.\n        :param token: KittiDB unique id.\n        :param table: Type of table, for example image or velodyne.\n        :param root: Base folder for all KITTI data.\n        :return: Full get_filepath to desired data.\n        \"\"\"", "\n", "folder", ",", "filename", "=", "KittiDB", ".", "standardize_sample_token", "(", "token", ")", "\n", "kitti_fileext", "=", "{", "'calib'", ":", "'txt'", ",", "'image_2'", ":", "'png'", ",", "'label_2'", ":", "'txt'", ",", "'velodyne'", ":", "'bin'", "}", "\n", "\n", "ending", "=", "kitti_fileext", "[", "table", "]", "\n", "\n", "if", "token", ".", "startswith", "(", "'test_'", ")", "and", "table", "==", "'label_2'", ":", "\n", "            ", "filepath", "=", "None", "\n", "print", "(", "'No cheating! The test set has no labels.'", ")", "\n", "", "else", ":", "\n", "            ", "filepath", "=", "osp", ".", "join", "(", "root", ",", "folder", ",", "table", ",", "'{}.{}'", ".", "format", "(", "filename", ",", "ending", ")", ")", "\n", "\n", "", "return", "filepath", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_transforms": [[217, 253], ["kitti.KittiDB.get_filepath", "numpy.array", "numpy.array.resize", "numpy.array", "numpy.array.resize", "numpy.array", "numpy.array.resize", "numpy.eye", "numpy.dot", "line.rstrip", "open", "lines[].strip().split", "lines[].strip().split", "lines[].strip().split", "lines[].strip", "lines[].strip", "lines[].strip"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_filepath"], ["", "@", "staticmethod", "\n", "def", "get_transforms", "(", "token", ":", "str", ",", "root", ":", "str", "=", "'/data/sets/kitti'", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Returns transforms for the input token.\n        :param token: KittiDB unique id.\n        :param root: Base folder for all KITTI data.\n        :return: {\n            'velo_to_cam': {'R': <np.float: 3, 3>, 'T': <np.float: 3, 1>}. Lidar to camera transformation matrix.\n            'r0_rect': <np.float: 3, 3>. Rectification matrix.\n            'p_left': <np.float: 3, 4>. Projection matrix.\n            'p_combined': <np.float: 4, 4>. Combined rectification and projection matrix.\n        }. Returns the transformation matrices. For details refer to the KITTI devkit.\n        \"\"\"", "\n", "calib_filename", "=", "KittiDB", ".", "get_filepath", "(", "token", ",", "'calib'", ",", "root", "=", "root", ")", "\n", "\n", "lines", "=", "[", "line", ".", "rstrip", "(", ")", "for", "line", "in", "open", "(", "calib_filename", ")", "]", "\n", "velo_to_cam", "=", "np", ".", "array", "(", "lines", "[", "5", "]", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "[", "1", ":", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "velo_to_cam", ".", "resize", "(", "(", "3", ",", "4", ")", ")", "\n", "\n", "r0_rect", "=", "np", ".", "array", "(", "lines", "[", "4", "]", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "[", "1", ":", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "r0_rect", ".", "resize", "(", "(", "3", ",", "3", ")", ")", "\n", "p_left", "=", "np", ".", "array", "(", "lines", "[", "2", "]", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "[", "1", ":", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "p_left", ".", "resize", "(", "(", "3", ",", "4", ")", ")", "\n", "\n", "# Merge rectification and projection into one matrix.", "\n", "p_combined", "=", "np", ".", "eye", "(", "4", ")", "\n", "p_combined", "[", ":", "3", ",", ":", "3", "]", "=", "r0_rect", "\n", "p_combined", "=", "np", ".", "dot", "(", "p_left", ",", "p_combined", ")", "\n", "return", "{", "\n", "'velo_to_cam'", ":", "{", "\n", "'R'", ":", "velo_to_cam", "[", ":", ",", ":", "3", "]", ",", "\n", "'T'", ":", "velo_to_cam", "[", ":", ",", "3", "]", "\n", "}", ",", "\n", "'r0_rect'", ":", "r0_rect", ",", "\n", "'p_left'", ":", "p_left", ",", "\n", "'p_combined'", ":", "p_combined", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_pointcloud": [[255, 269], ["kitti.KittiDB.get_filepath", "utils.data_classes.LidarPointCloud", "numpy.fromfile().reshape", "numpy.fromfile"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_filepath"], ["", "@", "staticmethod", "\n", "def", "get_pointcloud", "(", "token", ":", "str", ",", "root", ":", "str", "=", "'/data/sets/kitti'", ")", "->", "LidarPointCloud", ":", "\n", "        ", "\"\"\"\n        Load up the pointcloud for a sample.\n        :param token: KittiDB unique id.\n        :param root: Base folder for all KITTI data.\n        :return: LidarPointCloud for the sample in the KITTI Lidar frame.\n        \"\"\"", "\n", "pc_filename", "=", "KittiDB", ".", "get_filepath", "(", "token", ",", "'velodyne'", ",", "root", "=", "root", ")", "\n", "\n", "# The lidar PC is stored in the KITTI LIDAR coord system.", "\n", "pc", "=", "LidarPointCloud", "(", "np", ".", "fromfile", "(", "pc_filename", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", ".", "T", ")", "\n", "\n", "return", "pc", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_boxes": [[270, 347], ["kitti.KittiDB.get_transforms", "token.startswith", "open", "kitti.KittiDB.get_filepath", "kitti.KittiDB.parse_label_line", "utils.data_classes.Box", "utils.data_classes.Box.translate", "utils.data_classes.Box.rotate", "utils.data_classes.Box.translate", "utils.data_classes.Box.rotate", "utils.data_classes.Box.rotate", "numpy.array", "boxes.append", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "numpy.sqrt", "numpy.array", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_transforms", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_filepath", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.parse_label_line", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], ["", "def", "get_boxes", "(", "self", ",", "\n", "token", ":", "str", ",", "\n", "filter_classes", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "max_dist", ":", "float", "=", "None", ")", "->", "List", "[", "Box", "]", ":", "\n", "        ", "\"\"\"\n        Load up all the boxes associated with a sample.\n        Boxes are in nuScenes lidar frame.\n        :param token: KittiDB unique id.\n        :param filter_classes: List of Kitti classes to use or None to use all.\n        :param max_dist: Maximum distance in m to still draw a box.\n        :return: Boxes in nuScenes lidar reference frame.\n        \"\"\"", "\n", "# Get transforms for this sample", "\n", "transforms", "=", "self", ".", "get_transforms", "(", "token", ",", "root", "=", "self", ".", "root", ")", "\n", "\n", "boxes", "=", "[", "]", "\n", "if", "token", ".", "startswith", "(", "'test_'", ")", ":", "\n", "# No boxes to return for the test set.", "\n", "            ", "return", "boxes", "\n", "\n", "", "with", "open", "(", "KittiDB", ".", "get_filepath", "(", "token", ",", "'label_2'", ",", "root", "=", "self", ".", "root", ")", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "# Parse this line into box information.", "\n", "                ", "parsed_line", "=", "self", ".", "parse_label_line", "(", "line", ")", "\n", "\n", "if", "parsed_line", "[", "'name'", "]", "in", "{", "'DontCare'", ",", "'Misc'", "}", ":", "\n", "                    ", "continue", "\n", "\n", "", "center", "=", "parsed_line", "[", "'xyz_camera'", "]", "\n", "wlh", "=", "parsed_line", "[", "'wlh'", "]", "\n", "yaw_camera", "=", "parsed_line", "[", "'yaw_camera'", "]", "\n", "name", "=", "parsed_line", "[", "'name'", "]", "\n", "score", "=", "parsed_line", "[", "'score'", "]", "\n", "\n", "# Optional: Filter classes.", "\n", "if", "filter_classes", "is", "not", "None", "and", "name", "not", "in", "filter_classes", ":", "\n", "                    ", "continue", "\n", "\n", "# The Box class coord system is oriented the same way as as KITTI LIDAR: x forward, y left, z up.", "\n", "# For orientation confer: http://www.cvlibs.net/datasets/kitti/setup.php.", "\n", "\n", "# 1: Create box in Box coordinate system with center at origin.", "\n", "# The second quaternion in yaw_box transforms the coordinate frame from the object frame", "\n", "# to KITTI camera frame. The equivalent cannot be naively done afterwards, as it's a rotation", "\n", "# around the local object coordinate frame, rather than the camera frame.", "\n", "", "quat_box", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "1", ",", "0", ")", ",", "angle", "=", "yaw_camera", ")", "*", "Quaternion", "(", "axis", "=", "(", "1", ",", "0", ",", "0", ")", ",", "angle", "=", "np", ".", "pi", "/", "2", ")", "\n", "box", "=", "Box", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "wlh", ",", "quat_box", ",", "name", "=", "name", ")", "\n", "\n", "# 2: Translate: KITTI defines the box center as the bottom center of the vehicle. We use true center,", "\n", "# so we need to add half height in negative y direction, (since y points downwards), to adjust. The", "\n", "# center is already given in camera coord system.", "\n", "box", ".", "translate", "(", "center", "+", "np", ".", "array", "(", "[", "0", ",", "-", "wlh", "[", "2", "]", "/", "2", ",", "0", "]", ")", ")", "\n", "\n", "# 3: Transform to KITTI LIDAR coord system. First transform from rectified camera to camera, then", "\n", "# camera to KITTI lidar.", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "transforms", "[", "'r0_rect'", "]", ")", ".", "inverse", ")", "\n", "box", ".", "translate", "(", "-", "transforms", "[", "'velo_to_cam'", "]", "[", "'T'", "]", ")", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "transforms", "[", "'velo_to_cam'", "]", "[", "'R'", "]", ")", ".", "inverse", ")", "\n", "\n", "# 4: Transform to nuScenes LIDAR coord system.", "\n", "box", ".", "rotate", "(", "self", ".", "kitti_to_nu_lidar", ")", "\n", "\n", "# Set score or NaN.", "\n", "box", ".", "score", "=", "score", "\n", "\n", "# Set dummy velocity.", "\n", "box", ".", "velocity", "=", "np", ".", "array", "(", "(", "0.0", ",", "0.0", ",", "0.0", ")", ")", "\n", "\n", "# Optional: Filter by max_dist", "\n", "if", "max_dist", "is", "not", "None", ":", "\n", "                    ", "dist", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "box", ".", "center", "[", ":", "2", "]", "**", "2", ")", ")", "\n", "if", "dist", ">", "max_dist", ":", "\n", "                        ", "continue", "\n", "\n", "", "", "boxes", ".", "append", "(", "box", ")", "\n", "\n", "", "", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_boxes_2d": [[348, 378], ["open", "kitti.KittiDB.get_filepath", "kitti.KittiDB.parse_label_line", "boxes.append", "names.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_filepath", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.parse_label_line"], ["", "def", "get_boxes_2d", "(", "self", ",", "\n", "token", ":", "str", ",", "\n", "filter_classes", ":", "List", "[", "str", "]", "=", "None", ")", "->", "Tuple", "[", "\n", "List", "[", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", "]", ",", "\n", "List", "[", "str", "]", "\n", "]", ":", "\n", "        ", "\"\"\"\n        Get the 2d boxes associated with a sample.\n        :return: A list of boxes in KITTI format (xmin, ymin, xmax, ymax) and a list of the class names.\n        \"\"\"", "\n", "boxes", "=", "[", "]", "\n", "names", "=", "[", "]", "\n", "with", "open", "(", "KittiDB", ".", "get_filepath", "(", "token", ",", "'label_2'", ",", "root", "=", "self", ".", "root", ")", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "# Parse this line into box information.", "\n", "                ", "parsed_line", "=", "self", ".", "parse_label_line", "(", "line", ")", "\n", "\n", "if", "parsed_line", "[", "'name'", "]", "in", "{", "'DontCare'", ",", "'Misc'", "}", ":", "\n", "                    ", "continue", "\n", "\n", "", "bbox_2d", "=", "parsed_line", "[", "'bbox_camera'", "]", "\n", "name", "=", "parsed_line", "[", "'name'", "]", "\n", "\n", "# Optional: Filter classes.", "\n", "if", "filter_classes", "is", "not", "None", "and", "name", "not", "in", "filter_classes", ":", "\n", "                    ", "continue", "\n", "\n", "", "boxes", ".", "append", "(", "bbox_2d", ")", "\n", "names", ".", "append", "(", "name", ")", "\n", "", "", "return", "boxes", ",", "names", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.box_to_string": [[380, 428], ["numpy.dot", "numpy.array", "numpy.arctan2", "int", "numpy.isnan"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "box_to_string", "(", "frame", ":", "str", ",", "\n", "track_id", ",", "\n", "name", ":", "str", ",", "\n", "box", ":", "Box", ",", "\n", "bbox_2d", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", "=", "(", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", ")", ",", "\n", "truncation", ":", "float", "=", "-", "1.0", ",", "\n", "occlusion", ":", "int", "=", "-", "1", ",", "\n", "alpha", ":", "float", "=", "-", "10.0", ",", "\n", "is_key_frame", ":", "bool", "=", "False", ",", "\n", "num_lidar_pts", ":", "bool", "=", "0", ")", "->", "str", ":", "\n", "        ", "\"\"\"\n        Convert box in KITTI image frame to official label string fromat.\n        :param name: KITTI name of the box.\n        :param box: Box class in KITTI image frame.\n        :param bbox_2d: Optional, 2D bounding box obtained by projected Box into image (xmin, ymin, xmax, ymax).\n            Otherwise set to KITTI default.\n        :param truncation: Optional truncation, otherwise set to KITTI default.\n        :param occlusion: Optional occlusion, otherwise set to KITTI default.\n        :param alpha: Optional alpha, otherwise set to KITTI default.\n        :return: KITTI string representation of box.\n        \"\"\"", "\n", "# Convert quaternion to yaw angle.", "\n", "v", "=", "np", ".", "dot", "(", "box", ".", "rotation_matrix", ",", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", ")", "\n", "yaw", "=", "-", "np", ".", "arctan2", "(", "v", "[", "2", "]", ",", "v", "[", "0", "]", ")", "\n", "\n", "# Prepare output.", "\n", "frame", "=", "'{:d} '", ".", "format", "(", "frame", ")", "\n", "track_id", "=", "'{:d} '", ".", "format", "(", "track_id", ")", "\n", "name", "+=", "' '", "\n", "trunc", "=", "'{:d} '", ".", "format", "(", "int", "(", "truncation", ")", ")", "\n", "occ", "=", "'{:d} '", ".", "format", "(", "occlusion", ")", "\n", "a", "=", "'{:.6f} '", ".", "format", "(", "alpha", ")", "\n", "bb", "=", "'{:.6f} {:.6f} {:.6f} {:.6f} '", ".", "format", "(", "bbox_2d", "[", "0", "]", ",", "bbox_2d", "[", "1", "]", ",", "bbox_2d", "[", "2", "]", ",", "bbox_2d", "[", "3", "]", ")", "\n", "hwl", "=", "'{:.6f} {:.6f} {:.6f} '", ".", "format", "(", "box", ".", "wlh", "[", "2", "]", ",", "box", ".", "wlh", "[", "0", "]", ",", "box", ".", "wlh", "[", "1", "]", ")", "# height, width, length.", "\n", "xyz", "=", "'{:.6f} {:.6f} {:.6f} '", ".", "format", "(", "box", ".", "center", "[", "0", "]", ",", "box", ".", "center", "[", "1", "]", ",", "box", ".", "center", "[", "2", "]", ")", "# x, y, z.", "\n", "y", "=", "'{:.6f}'", ".", "format", "(", "yaw", ")", "# Yaw angle.", "\n", "s", "=", "' {:.6f}'", ".", "format", "(", "box", ".", "score", ")", "# Classification score.", "\n", "num_lidar_pts", "=", "' {:d}'", ".", "format", "(", "num_lidar_pts", ")", "\n", "output", "=", "frame", "+", "track_id", "+", "name", "+", "trunc", "+", "occ", "+", "a", "+", "bb", "+", "hwl", "+", "xyz", "+", "y", "\n", "if", "~", "np", ".", "isnan", "(", "box", ".", "score", ")", ":", "\n", "            ", "output", "+=", "s", "\n", "", "output", "+=", "num_lidar_pts", "\n", "if", "is_key_frame", ":", "\n", "            ", "output", "+=", "' 1'", "\n", "", "else", ":", "\n", "            ", "output", "+=", "' 0'", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.project_pts_to_image": [[429, 452], ["utils.data_classes.LidarPointCloud", "utils.data_classes.LidarPointCloud.rotate", "kitti.KittiDB.get_transforms", "utils.data_classes.LidarPointCloud.rotate", "utils.data_classes.LidarPointCloud.translate", "utils.geometry_utils.view_points", "pointcloud.points.copy"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_transforms", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["", "def", "project_pts_to_image", "(", "self", ",", "pointcloud", ":", "LidarPointCloud", ",", "token", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Project lidar points into image.\n        :param pointcloud: The LidarPointCloud in nuScenes lidar frame.\n        :param token: Unique KITTI token.\n        :return: <np.float: N, 3.> X, Y are points in image pixel coordinates. Z is depth in image.\n        \"\"\"", "\n", "\n", "# Copy and convert pointcloud.", "\n", "pc_image", "=", "LidarPointCloud", "(", "points", "=", "pointcloud", ".", "points", ".", "copy", "(", ")", ")", "\n", "pc_image", ".", "rotate", "(", "self", ".", "kitti_to_nu_lidar_inv", ")", "# Rotate to KITTI lidar.", "\n", "\n", "# Transform pointcloud to camera frame.", "\n", "transforms", "=", "self", ".", "get_transforms", "(", "token", ",", "root", "=", "self", ".", "root", ")", "\n", "pc_image", ".", "rotate", "(", "transforms", "[", "'velo_to_cam'", "]", "[", "'R'", "]", ")", "\n", "pc_image", ".", "translate", "(", "transforms", "[", "'velo_to_cam'", "]", "[", "'T'", "]", ")", "\n", "\n", "# Project to image.", "\n", "depth", "=", "pc_image", ".", "points", "[", "2", ",", ":", "]", "\n", "points_fov", "=", "view_points", "(", "pc_image", ".", "points", "[", ":", "3", ",", ":", "]", ",", "transforms", "[", "'p_combined'", "]", ",", "normalize", "=", "True", ")", "\n", "points_fov", "[", "2", ",", ":", "]", "=", "depth", "\n", "\n", "return", "points_fov", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.render_sample_data": [[453, 566], ["numpy.eye", "kitti.KittiDB.get_boxes", "ax.axis", "ax.set_title", "ax.set_aspect", "matplotlib.tight_layout", "kitti.KittiDB.get_pointcloud", "kitti.KittiDB.rotate", "utils.geometry_utils.view_points", "matplotlib.savefig", "matplotlib.subplots", "ax.scatter", "ax.set_xlim", "ax.set_ylim", "kitti.KittiDB.get_filepath", "PIL.Image.open", "ValueError", "box.render", "matplotlib.subplots", "ax.imshow", "ax.set_xlim", "ax.set_ylim", "numpy.array", "kitti.KittiDB.get_boxes_2d", "zip", "kitti.KittiDB.get_transforms", "color_func", "ax.plot", "ax.plot", "ax.plot", "ax.plot", "box.rotate", "box.rotate", "box.translate", "box.rotate", "box.render", "numpy.array", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "utils.geometry_utils.box_in_image", "numpy.array", "color_func", "color_func"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_pointcloud", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_filepath", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_boxes_2d", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.get_transforms", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.box_in_image"], ["", "def", "render_sample_data", "(", "self", ",", "\n", "token", ":", "str", ",", "\n", "sensor_modality", ":", "str", "=", "'lidar'", ",", "\n", "with_anns", ":", "bool", "=", "True", ",", "\n", "axes_limit", ":", "float", "=", "30", ",", "\n", "ax", ":", "Axes", "=", "None", ",", "\n", "view_3d", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "color_func", ":", "Any", "=", "None", ",", "\n", "augment_previous", ":", "bool", "=", "False", ",", "\n", "box_linewidth", ":", "int", "=", "2", ",", "\n", "filter_classes", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "max_dist", ":", "float", "=", "None", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "render_2d", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Render sample data onto axis. Visualizes lidar in nuScenes lidar frame and camera in camera frame.\n        :param token: KITTI token.\n        :param sensor_modality: The modality to visualize, e.g. lidar or camera.\n        :param with_anns: Whether to draw annotations.\n        :param axes_limit: Axes limit for lidar data (measured in meters).\n        :param ax: Axes onto which to render.\n        :param view_3d: 4x4 view matrix for 3d views.\n        :param color_func: Optional function that defines the render color given the class name.\n        :param augment_previous: Whether to augment an existing plot (does not redraw pointcloud/image).\n        :param box_linewidth: Width of the box lines.\n        :param filter_classes: Optionally filter the classes to render.\n        :param max_dist: Maximum distance in m to still draw a box.\n        :param out_path: Optional path to save the rendered figure to disk.\n        :param render_2d: Whether to render 2d boxes (only works for camera data).\n        \"\"\"", "\n", "# Default settings.", "\n", "if", "color_func", "is", "None", ":", "\n", "            ", "color_func", "=", "NuScenesExplorer", ".", "get_color", "\n", "\n", "", "boxes", "=", "self", ".", "get_boxes", "(", "token", ",", "filter_classes", "=", "filter_classes", ",", "max_dist", "=", "max_dist", ")", "# In nuScenes lidar frame.", "\n", "\n", "if", "sensor_modality", "==", "'lidar'", ":", "\n", "# Load pointcloud.", "\n", "            ", "pc", "=", "self", ".", "get_pointcloud", "(", "token", ",", "self", ".", "root", ")", "# In KITTI lidar frame.", "\n", "pc", ".", "rotate", "(", "self", ".", "kitti_to_nu_lidar", ".", "rotation_matrix", ")", "# In nuScenes lidar frame.", "\n", "# Alternative options:", "\n", "# depth = pc.points[1, :]", "\n", "# height = pc.points[2, :]", "\n", "intensity", "=", "pc", ".", "points", "[", "3", ",", ":", "]", "\n", "\n", "# Project points to view.", "\n", "points", "=", "view_points", "(", "pc", ".", "points", "[", ":", "3", ",", ":", "]", ",", "view_3d", ",", "normalize", "=", "False", ")", "\n", "coloring", "=", "intensity", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "                ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "9", ")", ")", "\n", "\n", "", "if", "not", "augment_previous", ":", "\n", "                ", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "coloring", ",", "s", "=", "1", ")", "\n", "ax", ".", "set_xlim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "ax", ".", "set_ylim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "\n", "", "if", "with_anns", ":", "\n", "                ", "for", "box", "in", "boxes", ":", "\n", "                    ", "color", "=", "np", ".", "array", "(", "color_func", "(", "box", ".", "name", ")", ")", "/", "255", "\n", "box", ".", "render", "(", "ax", ",", "view", "=", "view_3d", ",", "colors", "=", "(", "color", ",", "color", ",", "'k'", ")", ",", "linewidth", "=", "box_linewidth", ")", "\n", "\n", "", "", "", "elif", "sensor_modality", "==", "'camera'", ":", "\n", "            ", "im_path", "=", "KittiDB", ".", "get_filepath", "(", "token", ",", "'image_2'", ",", "root", "=", "self", ".", "root", ")", "\n", "im", "=", "Image", ".", "open", "(", "im_path", ")", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "                ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "16", ")", ")", "\n", "\n", "", "if", "not", "augment_previous", ":", "\n", "                ", "ax", ".", "imshow", "(", "im", ")", "\n", "ax", ".", "set_xlim", "(", "0", ",", "im", ".", "size", "[", "0", "]", ")", "\n", "ax", ".", "set_ylim", "(", "im", ".", "size", "[", "1", "]", ",", "0", ")", "\n", "\n", "", "if", "with_anns", ":", "\n", "                ", "if", "render_2d", ":", "\n", "# Use KITTI's 2d boxes.", "\n", "                    ", "boxes_2d", ",", "names", "=", "self", ".", "get_boxes_2d", "(", "token", ",", "filter_classes", "=", "filter_classes", ")", "\n", "for", "box", ",", "name", "in", "zip", "(", "boxes_2d", ",", "names", ")", ":", "\n", "                        ", "color", "=", "np", ".", "array", "(", "color_func", "(", "name", ")", ")", "/", "255", "\n", "ax", ".", "plot", "(", "[", "box", "[", "0", "]", ",", "box", "[", "0", "]", "]", ",", "[", "box", "[", "1", "]", ",", "box", "[", "3", "]", "]", ",", "color", "=", "color", ",", "linewidth", "=", "box_linewidth", ")", "\n", "ax", ".", "plot", "(", "[", "box", "[", "2", "]", ",", "box", "[", "2", "]", "]", ",", "[", "box", "[", "1", "]", ",", "box", "[", "3", "]", "]", ",", "color", "=", "color", ",", "linewidth", "=", "box_linewidth", ")", "\n", "ax", ".", "plot", "(", "[", "box", "[", "0", "]", ",", "box", "[", "2", "]", "]", ",", "[", "box", "[", "1", "]", ",", "box", "[", "1", "]", "]", ",", "color", "=", "color", ",", "linewidth", "=", "box_linewidth", ")", "\n", "ax", ".", "plot", "(", "[", "box", "[", "0", "]", ",", "box", "[", "2", "]", "]", ",", "[", "box", "[", "3", "]", ",", "box", "[", "3", "]", "]", ",", "color", "=", "color", ",", "linewidth", "=", "box_linewidth", ")", "\n", "", "", "else", ":", "\n", "# Project 3d boxes to 2d.", "\n", "                    ", "transforms", "=", "self", ".", "get_transforms", "(", "token", ",", "self", ".", "root", ")", "\n", "for", "box", "in", "boxes", ":", "\n", "# Undo the transformations in get_boxes() to get back to the camera frame.", "\n", "                        ", "box", ".", "rotate", "(", "self", ".", "kitti_to_nu_lidar_inv", ")", "# In KITTI lidar frame.", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "transforms", "[", "'velo_to_cam'", "]", "[", "'R'", "]", ")", ")", "\n", "box", ".", "translate", "(", "transforms", "[", "'velo_to_cam'", "]", "[", "'T'", "]", ")", "# In KITTI camera frame, un-rectified.", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "transforms", "[", "'r0_rect'", "]", ")", ")", "# In KITTI camera frame, rectified.", "\n", "\n", "# Filter boxes outside the image (relevant when visualizing nuScenes data in KITTI format).", "\n", "if", "not", "box_in_image", "(", "box", ",", "transforms", "[", "'p_left'", "]", "[", ":", "3", ",", ":", "3", "]", ",", "im", ".", "size", ",", "vis_level", "=", "BoxVisibility", ".", "ANY", ")", ":", "\n", "                            ", "continue", "\n", "\n", "# Render.", "\n", "", "color", "=", "np", ".", "array", "(", "color_func", "(", "box", ".", "name", ")", ")", "/", "255", "\n", "box", ".", "render", "(", "ax", ",", "view", "=", "transforms", "[", "'p_left'", "]", "[", ":", "3", ",", ":", "3", "]", ",", "normalize", "=", "True", ",", "colors", "=", "(", "color", ",", "color", ",", "'k'", ")", ",", "\n", "linewidth", "=", "box_linewidth", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unrecognized modality {}.\"", ".", "format", "(", "sensor_modality", ")", ")", "\n", "\n", "", "ax", ".", "axis", "(", "'off'", ")", "\n", "ax", ".", "set_title", "(", "token", ")", "\n", "ax", ".", "set_aspect", "(", "'equal'", ")", "\n", "\n", "# Render to disk.", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_logs": [[151, 188], ["splits.create_splits_scenes", "set", "create_splits_scenes.keys", "version.endswith", "set.add", "list", "version.endswith", "nusc.get", "version.endswith", "ValueError"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_scenes", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["def", "create_splits_logs", "(", "split", ":", "str", ",", "nusc", ":", "'NuScenes'", ")", "->", "List", "[", "str", "]", ":", "\n", "    ", "\"\"\"\n    Returns the logs in each dataset split of nuScenes.\n    Note: Previously this script included the teaser dataset splits. Since new scenes from those logs were added and\n          others removed in the full dataset, that code is incompatible and was removed.\n    :param split: NuScenes split.\n    :param nusc: NuScenes instance.\n    :return: A list of logs in that split.\n    \"\"\"", "\n", "# Load splits on a scene-level.", "\n", "scene_splits", "=", "create_splits_scenes", "(", "verbose", "=", "False", ")", "\n", "\n", "assert", "split", "in", "scene_splits", ".", "keys", "(", ")", ",", "'Requested split {} which is not a known nuScenes split.'", ".", "format", "(", "split", ")", "\n", "\n", "# Check compatibility of split with nusc_version.", "\n", "version", "=", "nusc", ".", "version", "\n", "if", "split", "in", "{", "'train'", ",", "'val'", ",", "'train_detect'", ",", "'train_track'", "}", ":", "\n", "        ", "assert", "version", ".", "endswith", "(", "'trainval'", ")", ",", "'Requested split {} which is not compatible with NuScenes version {}'", ".", "format", "(", "split", ",", "version", ")", "\n", "", "elif", "split", "in", "{", "'mini_train'", ",", "'mini_val'", "}", ":", "\n", "        ", "assert", "version", ".", "endswith", "(", "'mini'", ")", ",", "'Requested split {} which is not compatible with NuScenes version {}'", ".", "format", "(", "split", ",", "version", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "assert", "version", ".", "endswith", "(", "'test'", ")", ",", "'Requested split {} which is not compatible with NuScenes version {}'", ".", "format", "(", "split", ",", "version", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Requested split {} which this function cannot map to logs.'", ".", "format", "(", "split", ")", ")", "\n", "\n", "# Get logs for this split.", "\n", "", "scene_to_log", "=", "{", "scene", "[", "'name'", "]", ":", "nusc", ".", "get", "(", "'log'", ",", "scene", "[", "'log_token'", "]", ")", "[", "'logfile'", "]", "for", "scene", "in", "nusc", ".", "scene", "}", "\n", "logs", "=", "set", "(", ")", "\n", "scenes", "=", "scene_splits", "[", "split", "]", "\n", "scenes_token", "=", "[", "scene", "[", "'token'", "]", "for", "scene", "in", "nusc", ".", "scene", "if", "scene", "[", "'name'", "]", "in", "scenes", "]", "\n", "for", "scene", "in", "scenes", ":", "\n", "        ", "logs", ".", "add", "(", "scene_to_log", "[", "scene", "]", ")", "\n", "\n", "", "return", "list", "(", "logs", ")", ",", "scenes_token", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_scenes": [[190, 215], ["scene_splits.items", "len", "len", "print", "print", "set", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["", "def", "create_splits_scenes", "(", "verbose", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "List", "[", "str", "]", "]", ":", "\n", "    ", "\"\"\"\n    Similar to create_splits_logs, but returns a mapping from split to scene names, rather than log names.\n    The splits are as follows:\n    - train/val/test: The standard splits of the nuScenes dataset (700/150/150 scenes).\n    - mini_train/mini_val: Train and val splits of the mini subset used for visualization and debugging (8/2 scenes).\n    - train_detect/train_track: Two halves of the train split used for separating the training sets of detector and\n        tracker if required.\n    :param verbose: Whether to print out statistics on a scene level.\n    :return: A mapping from split name to a list of scenes names in that split.\n    \"\"\"", "\n", "# Use hard-coded splits.", "\n", "all_scenes", "=", "train", "+", "val", "+", "test", "\n", "assert", "len", "(", "all_scenes", ")", "==", "1000", "and", "len", "(", "set", "(", "all_scenes", ")", ")", "==", "1000", ",", "'Error: Splits incomplete!'", "\n", "scene_splits", "=", "{", "'train'", ":", "train", ",", "'val'", ":", "val", ",", "'test'", ":", "test", ",", "\n", "'mini_train'", ":", "mini_train", ",", "'mini_val'", ":", "mini_val", ",", "\n", "'train_detect'", ":", "train_detect", ",", "'train_track'", ":", "train_track", "}", "\n", "\n", "# Optional: Print scene-level stats.", "\n", "if", "verbose", ":", "\n", "        ", "for", "split", ",", "scenes", "in", "scene_splits", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'%s: %d'", "%", "(", "split", ",", "len", "(", "scenes", ")", ")", ")", "\n", "print", "(", "'%s'", "%", "scenes", ")", "\n", "\n", "", "", "return", "scene_splits", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.__init__": [[17, 29], ["os.exists"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "img_file", ":", "str", ",", "resolution", ":", "float", "=", "0.1", ")", ":", "\n", "        ", "\"\"\"\n        Init a map mask object that contains the semantic prior (driveable surface and sidewalks) mask.\n        :param img_file: File path to map png file.\n        :param resolution: Map resolution in meters.\n        \"\"\"", "\n", "assert", "osp", ".", "exists", "(", "img_file", ")", ",", "'map mask {} does not exist'", ".", "format", "(", "img_file", ")", "\n", "assert", "resolution", ">=", "0.1", ",", "\"Only supports down to 0.1 meter resolution.\"", "\n", "self", ".", "img_file", "=", "img_file", "\n", "self", ".", "resolution", "=", "resolution", "\n", "self", ".", "foreground", "=", "255", "\n", "self", ".", "background", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.mask": [[30, 43], ["cachetools.cached", "cv2.distanceTransform", "cachetools.LRUCache"], "methods", ["None"], ["", "@", "cached", "(", "cache", "=", "LRUCache", "(", "maxsize", "=", "3", ")", ")", "\n", "def", "mask", "(", "self", ",", "dilation", ":", "float", "=", "0.0", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Returns the map mask, optionally dilated.\n        :param dilation: Dilation in meters.\n        :return: Dilated map mask.\n        \"\"\"", "\n", "if", "dilation", "==", "0", ":", "\n", "            ", "return", "self", ".", "_base_mask", "\n", "", "else", ":", "\n", "            ", "distance_mask", "=", "cv2", ".", "distanceTransform", "(", "(", "self", ".", "foreground", "-", "self", ".", "_base_mask", ")", ".", "astype", "(", "np", ".", "uint8", ")", ",", "cv2", ".", "DIST_L2", ",", "5", ")", "\n", "distance_mask", "=", "(", "distance_mask", "*", "self", ".", "resolution", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "return", "(", "distance_mask", "<=", "dilation", ")", ".", "astype", "(", "np", ".", "uint8", ")", "*", "self", ".", "foreground", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.transform_matrix": [[44, 53], ["numpy.array"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "transform_matrix", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Generate transform matrix for this map mask.\n        :return: <np.array: 4, 4>. The transformation matrix.\n        \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "[", "1.0", "/", "self", ".", "resolution", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "-", "1.0", "/", "self", ".", "resolution", ",", "0", ",", "self", ".", "_base_mask", ".", "shape", "[", "0", "]", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask": [[54, 75], ["map_mask.MapMask.to_pixel_coords", "numpy.ones", "map_mask.MapMask.mask"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.to_pixel_coords", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.mask"], ["", "def", "is_on_mask", "(", "self", ",", "x", ":", "Any", ",", "y", ":", "Any", ",", "dilation", ":", "float", "=", "0", ")", "->", "np", ".", "array", ":", "\n", "        ", "\"\"\"\n        Determine whether the given coordinates are on the (optionally dilated) map mask.\n        :param x: Global x coordinates. Can be a scalar, list or a numpy array of x coordinates.\n        :param y: Global y coordinates. Can be a scalar, list or a numpy array of x coordinates.\n        :param dilation: Optional dilation of map mask.\n        :return: <np.bool: x.shape>. Whether the points are on the mask.\n        \"\"\"", "\n", "px", ",", "py", "=", "self", ".", "to_pixel_coords", "(", "x", ",", "y", ")", "\n", "\n", "on_mask", "=", "np", ".", "ones", "(", "px", ".", "size", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "this_mask", "=", "self", ".", "mask", "(", "dilation", ")", "\n", "\n", "on_mask", "[", "px", "<", "0", "]", "=", "False", "\n", "on_mask", "[", "px", ">=", "this_mask", ".", "shape", "[", "1", "]", "]", "=", "False", "\n", "on_mask", "[", "py", "<", "0", "]", "=", "False", "\n", "on_mask", "[", "py", ">=", "this_mask", ".", "shape", "[", "0", "]", "]", "=", "False", "\n", "\n", "on_mask", "[", "on_mask", "]", "=", "this_mask", "[", "py", "[", "on_mask", "]", ",", "px", "[", "on_mask", "]", "]", "==", "self", ".", "foreground", "\n", "\n", "return", "on_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.to_pixel_coords": [[76, 95], ["numpy.array", "numpy.array", "numpy.atleast_1d", "numpy.atleast_1d", "numpy.stack", "numpy.round().astype", "numpy.zeros", "numpy.ones", "numpy.round", "numpy.dot"], "methods", ["None"], ["", "def", "to_pixel_coords", "(", "self", ",", "x", ":", "Any", ",", "y", ":", "Any", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Maps x, y location in global map coordinates to the map image coordinates.\n        :param x: Global x coordinates. Can be a scalar, list or a numpy array of x coordinates.\n        :param y: Global y coordinates. Can be a scalar, list or a numpy array of x coordinates.\n        :return: (px <np.uint8: x.shape>, py <np.uint8: y.shape>). Pixel coordinates in map.\n        \"\"\"", "\n", "x", "=", "np", ".", "array", "(", "x", ")", "\n", "y", "=", "np", ".", "array", "(", "y", ")", "\n", "x", "=", "np", ".", "atleast_1d", "(", "x", ")", "\n", "y", "=", "np", ".", "atleast_1d", "(", "y", ")", "\n", "\n", "assert", "x", ".", "shape", "==", "y", ".", "shape", "\n", "assert", "x", ".", "ndim", "==", "y", ".", "ndim", "==", "1", "\n", "\n", "pts", "=", "np", ".", "stack", "(", "[", "x", ",", "y", ",", "np", ".", "zeros", "(", "x", ".", "shape", ")", ",", "np", ".", "ones", "(", "x", ".", "shape", ")", "]", ")", "\n", "pixel_coords", "=", "np", ".", "round", "(", "np", ".", "dot", "(", "self", ".", "transform_matrix", ",", "pts", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "return", "pixel_coords", "[", "0", ",", ":", "]", ",", "pixel_coords", "[", "1", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask._base_mask": [[96, 115], ["cachetools.cached", "PIL.Image.open", "int", "int", "img.resize.resize.resize", "numpy.array", "cachetools.LRUCache"], "methods", ["None"], ["", "@", "property", "\n", "@", "cached", "(", "cache", "=", "LRUCache", "(", "maxsize", "=", "1", ")", ")", "\n", "def", "_base_mask", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Returns the original binary mask stored in map png file.\n        :return: <np.int8: image.height, image.width>. The binary mask.\n        \"\"\"", "\n", "# Pillow allows us to specify the maximum image size above, whereas this is more difficult in OpenCV.", "\n", "img", "=", "Image", ".", "open", "(", "self", ".", "img_file", ")", "\n", "\n", "# Resize map mask to desired resolution.", "\n", "native_resolution", "=", "0.1", "\n", "size_x", "=", "int", "(", "img", ".", "size", "[", "0", "]", "/", "self", ".", "resolution", "*", "native_resolution", ")", "\n", "size_y", "=", "int", "(", "img", ".", "size", "[", "1", "]", "/", "self", ".", "resolution", "*", "native_resolution", ")", "\n", "img", "=", "img", ".", "resize", "(", "(", "size_x", ",", "size_y", ")", ",", "resample", "=", "Image", ".", "NEAREST", ")", "\n", "\n", "# Convert to numpy.", "\n", "raw_mask", "=", "np", ".", "array", "(", "img", ")", "\n", "return", "raw_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.SearchSpace.reset": [[8, 10], ["None"], "methods", ["None"], ["    ", "def", "reset", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.SearchSpace.sample": [[11, 13], ["None"], "methods", ["None"], ["", "def", "sample", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.SearchSpace.addData": [[14, 16], ["None"], "methods", ["None"], ["", "def", "addData", "(", "self", ",", "data", ",", "score", ")", ":", "\n", "        ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.ExhaustiveSearch.__init__": [[20, 41], ["numpy.linspace", "numpy.linspace", "numpy.linspace", "numpy.meshgrid", "searchspace.ExhaustiveSearch.reset", "numpy.array", "X.flatten", "Y.flatten", "A.flatten"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset"], ["    ", "def", "__init__", "(", "self", ",", "\n", "search_space", "=", "[", "[", "-", "3.0", ",", "3.0", "]", ",", "[", "-", "3.0", ",", "3.0", "]", ",", "[", "-", "10.0", ",", "10.0", "]", "]", ",", "\n", "search_dims", "=", "[", "7", ",", "7", ",", "3", "]", ")", ":", "\n", "\n", "        ", "x_space", "=", "np", ".", "linspace", "(", "\n", "search_space", "[", "0", "]", "[", "0", "]", ",", "search_space", "[", "0", "]", "[", "1", "]", ",", "\n", "search_dims", "[", "0", "]", ")", "\n", "\n", "y_space", "=", "np", ".", "linspace", "(", "\n", "search_space", "[", "1", "]", "[", "0", "]", ",", "search_space", "[", "1", "]", "[", "1", "]", ",", "\n", "search_dims", "[", "1", "]", ")", "\n", "\n", "a_space", "=", "np", ".", "linspace", "(", "\n", "search_space", "[", "2", "]", "[", "0", "]", ",", "search_space", "[", "2", "]", "[", "1", "]", ",", "\n", "search_dims", "[", "2", "]", ")", "\n", "\n", "X", ",", "Y", ",", "A", "=", "np", ".", "meshgrid", "(", "x_space", ",", "y_space", ",", "a_space", ")", "# create mesh grid", "\n", "\n", "self", ".", "search_grid", "=", "np", ".", "array", "(", "[", "X", ".", "flatten", "(", ")", ",", "Y", ".", "flatten", "(", ")", ",", "A", ".", "flatten", "(", ")", "]", ")", ".", "T", "\n", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.ExhaustiveSearch.reset": [[42, 44], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.ExhaustiveSearch.sample": [[45, 47], ["None"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "n", "=", "0", ")", ":", "\n", "        ", "return", "self", ".", "search_grid", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.ParticleFiltering.__init__": [[50, 53], ["searchspace.ParticleFiltering.reset"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset"], ["    ", "def", "__init__", "(", "self", ",", "bnd", "=", "[", "1", ",", "1", ",", "10", "]", ")", ":", "\n", "        ", "self", ".", "bnd", "=", "bnd", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.ParticleFiltering.sample": [[54, 70], ["range", "numpy.array", "samples.append", "len", "numpy.random.choice", "numpy.random.multivariate_normal", "numpy.random.multivariate_normal", "list", "range", "numpy.diag", "numpy.zeros", "numpy.diag", "len", "numpy.linalg.norm", "numpy.array", "len", "numpy.array"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "n", "=", "10", ")", ":", "\n", "        ", "samples", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "if", "len", "(", "self", ".", "data", ")", ">", "0", ":", "\n", "                ", "i_mean", "=", "np", ".", "random", ".", "choice", "(", "\n", "list", "(", "range", "(", "len", "(", "self", ".", "data", ")", ")", ")", ",", "\n", "p", "=", "self", ".", "score", "/", "np", ".", "linalg", ".", "norm", "(", "self", ".", "score", ",", "ord", "=", "1", ")", ")", "\n", "sample", "=", "np", ".", "random", ".", "multivariate_normal", "(", "\n", "mean", "=", "self", ".", "data", "[", "i_mean", "]", ",", "cov", "=", "np", ".", "diag", "(", "np", ".", "array", "(", "self", ".", "bnd", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "sample", "=", "np", ".", "random", ".", "multivariate_normal", "(", "\n", "mean", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "bnd", ")", ")", ",", "\n", "cov", "=", "np", ".", "diag", "(", "np", ".", "array", "(", "self", ".", "bnd", ")", "*", "3", ")", ")", "\n", "\n", "", "samples", ".", "append", "(", "sample", ")", "\n", "", "return", "np", ".", "array", "(", "samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.ParticleFiltering.addData": [[71, 75], ["score.clip.clip.clip"], "methods", ["None"], ["", "def", "addData", "(", "self", ",", "data", ",", "score", ")", ":", "\n", "        ", "score", "=", "score", ".", "clip", "(", "min", "=", "1e-5", ")", "# prevent sum=0 in case of bad scores", "\n", "self", ".", "data", "=", "data", "\n", "self", ".", "score", "=", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.ParticleFiltering.reset": [[76, 83], ["numpy.ones", "len", "numpy.linalg.norm", "numpy.array", "numpy.array", "numpy.shape"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.shape"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "bnd", ")", "==", "2", ":", "\n", "            ", "self", ".", "data", "=", "np", ".", "array", "(", "[", "[", "]", ",", "[", "]", "]", ")", ".", "T", "\n", "", "else", ":", "\n", "            ", "self", ".", "data", "=", "np", ".", "array", "(", "[", "[", "]", ",", "[", "]", ",", "[", "]", "]", ")", ".", "T", "\n", "", "self", ".", "score", "=", "np", ".", "ones", "(", "np", ".", "shape", "(", "self", ".", "data", ")", "[", "0", "]", ")", "\n", "self", ".", "score", "=", "self", ".", "score", "/", "np", ".", "linalg", ".", "norm", "(", "self", ".", "score", ",", "ord", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.KalmanFiltering.__init__": [[86, 89], ["searchspace.KalmanFiltering.reset"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset"], ["    ", "def", "__init__", "(", "self", ",", "bnd", "=", "[", "1", ",", "1", ",", "10", "]", ")", ":", "\n", "        ", "self", ".", "bnd", "=", "bnd", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.KalmanFiltering.sample": [[90, 92], ["numpy.random.multivariate_normal"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "n", "=", "10", ")", ":", "\n", "        ", "return", "np", ".", "random", ".", "multivariate_normal", "(", "self", ".", "mean", ",", "self", ".", "cov", ",", "size", "=", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.KalmanFiltering.addData": [[93, 99], ["score.clip.clip.clip", "numpy.concatenate", "numpy.concatenate", "numpy.average", "numpy.cov"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.average"], ["", "def", "addData", "(", "self", ",", "data", ",", "score", ")", ":", "\n", "        ", "score", "=", "score", ".", "clip", "(", "min", "=", "1e-5", ")", "# prevent sum=0 in case of bad scores", "\n", "self", ".", "data", "=", "np", ".", "concatenate", "(", "(", "self", ".", "data", ",", "data", ")", ")", "\n", "self", ".", "score", "=", "np", ".", "concatenate", "(", "(", "self", ".", "score", ",", "score", ")", ")", "\n", "self", ".", "mean", "=", "np", ".", "average", "(", "self", ".", "data", ",", "weights", "=", "self", ".", "score", ",", "axis", "=", "0", ")", "\n", "self", ".", "cov", "=", "np", ".", "cov", "(", "self", ".", "data", ".", "T", ",", "ddof", "=", "0", ",", "aweights", "=", "self", ".", "score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.KalmanFiltering.reset": [[100, 108], ["numpy.zeros", "numpy.diag", "numpy.array", "len", "len", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "mean", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "bnd", ")", ")", "\n", "self", ".", "cov", "=", "np", ".", "diag", "(", "self", ".", "bnd", ")", "\n", "if", "len", "(", "self", ".", "bnd", ")", "==", "2", ":", "\n", "            ", "self", ".", "data", "=", "np", ".", "array", "(", "[", "[", "]", ",", "[", "]", "]", ")", ".", "T", "\n", "", "else", ":", "\n", "            ", "self", ".", "data", "=", "np", ".", "array", "(", "[", "[", "]", ",", "[", "]", ",", "[", "]", "]", ")", ".", "T", "\n", "", "self", ".", "score", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.__init__": [[112, 115], ["searchspace.GaussianMixtureModel.reset"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset"], ["    ", "def", "__init__", "(", "self", ",", "n_comp", "=", "5", ",", "dim", "=", "3", ")", ":", "\n", "        ", "self", ".", "dim", "=", "dim", "\n", "self", ".", "reset", "(", "n_comp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.sample": [[116, 156], ["numpy.stack", "numpy.concatenate", "searchspace.GaussianMixtureModel.model.sample", "numpy.mean", "numpy.diag", "pomegranate.MultivariateGaussianDistribution", "numpy.stack", "numpy.mean", "numpy.diag", "pomegranate.MultivariateGaussianDistribution", "numpy.stack", "numpy.mean", "numpy.diag", "pomegranate.MultivariateGaussianDistribution", "numpy.stack", "numpy.mean", "numpy.diag", "pomegranate.MultivariateGaussianDistribution", "numpy.stack", "print", "int", "pomegranate.MultivariateGaussianDistribution.sample", "pomegranate.MultivariateGaussianDistribution.sample", "pomegranate.MultivariateGaussianDistribution.sample", "pomegranate.MultivariateGaussianDistribution.sample", "numpy.zeros", "numpy.diag", "pomegranate.MultivariateGaussianDistribution", "pomegranate.MultivariateGaussianDistribution.sample", "numpy.zeros", "numpy.diag", "pomegranate.MultivariateGaussianDistribution", "pomegranate.MultivariateGaussianDistribution.sample", "numpy.round", "int", "int", "int", "int", "int", "int", "numpy.round", "numpy.round", "numpy.round", "numpy.round"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.sample", "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.sample", "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.sample", "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.sample", "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.sample", "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.sample", "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.sample"], ["", "def", "sample", "(", "self", ",", "n", "=", "10", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "X1", "=", "np", ".", "stack", "(", "self", ".", "model", ".", "sample", "(", "int", "(", "np", ".", "round", "(", "0.8", "*", "n", ")", ")", ")", ")", "\n", "if", "self", ".", "dim", "==", "2", ":", "\n", "                ", "mean", "=", "np", ".", "mean", "(", "X1", ",", "axis", "=", "0", ")", "\n", "std", "=", "np", ".", "diag", "(", "[", "1.0", ",", "1.0", "]", ")", "\n", "gmm", "=", "MultivariateGaussianDistribution", "(", "mean", ",", "std", ")", "\n", "X2", "=", "np", ".", "stack", "(", "gmm", ".", "sample", "(", "int", "(", "np", ".", "round", "(", "0.1", "*", "n", ")", ")", ")", ")", "\n", "\n", "mean", "=", "np", ".", "mean", "(", "X1", ",", "axis", "=", "0", ")", "\n", "std", "=", "np", ".", "diag", "(", "[", "1e-3", ",", "1e-3", "]", ")", "\n", "gmm", "=", "MultivariateGaussianDistribution", "(", "mean", ",", "std", ")", "\n", "X3", "=", "np", ".", "stack", "(", "gmm", ".", "sample", "(", "int", "(", "np", ".", "round", "(", "0.1", "*", "n", ")", ")", ")", ")", "\n", "\n", "", "else", ":", "\n", "                ", "mean", "=", "np", ".", "mean", "(", "X1", ",", "axis", "=", "0", ")", "\n", "std", "=", "np", ".", "diag", "(", "[", "1.0", ",", "1.0", ",", "1e-3", "]", ")", "\n", "gmm", "=", "MultivariateGaussianDistribution", "(", "mean", ",", "std", ")", "\n", "X2", "=", "np", ".", "stack", "(", "gmm", ".", "sample", "(", "int", "(", "np", ".", "round", "(", "0.1", "*", "n", ")", ")", ")", ")", "\n", "\n", "mean", "=", "np", ".", "mean", "(", "X1", ",", "axis", "=", "0", ")", "\n", "std", "=", "np", ".", "diag", "(", "[", "1e-3", ",", "1e-3", ",", "10.0", "]", ")", "\n", "gmm", "=", "MultivariateGaussianDistribution", "(", "mean", ",", "std", ")", "\n", "X3", "=", "np", ".", "stack", "(", "gmm", ".", "sample", "(", "int", "(", "np", ".", "round", "(", "0.1", "*", "n", ")", ")", ")", ")", "\n", "\n", "", "X", "=", "np", ".", "concatenate", "(", "(", "X1", ",", "X2", ",", "X3", ")", ")", "\n", "\n", "", "except", "ValueError", ":", "\n", "            ", "print", "(", "\"exception caught on sampling\"", ")", "\n", "if", "self", ".", "dim", "==", "2", ":", "\n", "                ", "mean", "=", "np", ".", "zeros", "(", "self", ".", "dim", ")", "\n", "std", "=", "np", ".", "diag", "(", "[", "1.0", ",", "1.0", "]", ")", "\n", "gmm", "=", "MultivariateGaussianDistribution", "(", "mean", ",", "std", ")", "\n", "X", "=", "gmm", ".", "sample", "(", "int", "(", "n", ")", ")", "\n", "", "else", ":", "\n", "                ", "mean", "=", "np", ".", "zeros", "(", "self", ".", "dim", ")", "\n", "std", "=", "np", ".", "diag", "(", "[", "1.0", ",", "1.0", ",", "5.0", "]", ")", "\n", "gmm", "=", "MultivariateGaussianDistribution", "(", "mean", ",", "std", ")", "\n", "X", "=", "gmm", ".", "sample", "(", "int", "(", "n", ")", ")", "\n", "", "", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.addData": [[157, 172], ["score.clip.clip.clip", "numpy.linalg.norm", "pomegranate.GeneralMixtureModel.from_samples", "logging.info"], "methods", ["None"], ["", "def", "addData", "(", "self", ",", "data", ",", "score", ")", ":", "\n", "        ", "score", "=", "score", ".", "clip", "(", "min", "=", "1e-5", ")", "\n", "self", ".", "data", "=", "data", "\n", "self", ".", "score", "=", "score", "\n", "\n", "score_normed", "=", "self", ".", "score", "/", "np", ".", "linalg", ".", "norm", "(", "self", ".", "score", ",", "ord", "=", "1", ")", "\n", "try", ":", "\n", "            ", "model", "=", "GeneralMixtureModel", ".", "from_samples", "(", "\n", "MultivariateGaussianDistribution", ",", "\n", "n_components", "=", "self", ".", "n_comp", ",", "\n", "X", "=", "self", ".", "data", ",", "\n", "weights", "=", "score_normed", ")", "\n", "self", ".", "model", "=", "model", "\n", "", "except", ":", "\n", "            ", "logging", ".", "info", "(", "\"catched an exception\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.reset": [[173, 188], ["numpy.ones", "numpy.linalg.norm", "pomegranate.MultivariateGaussianDistribution", "pomegranate.MultivariateGaussianDistribution", "numpy.array", "numpy.array", "numpy.shape", "numpy.zeros", "numpy.diag", "numpy.zeros", "numpy.diag"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.shape"], ["", "", "def", "reset", "(", "self", ",", "n_comp", "=", "5", ")", ":", "\n", "        ", "self", ".", "n_comp", "=", "n_comp", "\n", "\n", "if", "self", ".", "dim", "==", "2", ":", "\n", "            ", "self", ".", "data", "=", "np", ".", "array", "(", "[", "[", "]", ",", "[", "]", "]", ")", ".", "T", "\n", "", "else", ":", "\n", "            ", "self", ".", "data", "=", "np", ".", "array", "(", "[", "[", "]", ",", "[", "]", ",", "[", "]", "]", ")", ".", "T", "\n", "", "self", ".", "score", "=", "np", ".", "ones", "(", "np", ".", "shape", "(", "self", ".", "data", ")", "[", "0", "]", ")", "\n", "self", ".", "score", "=", "self", ".", "score", "/", "np", ".", "linalg", ".", "norm", "(", "self", ".", "score", ",", "ord", "=", "1", ")", "\n", "if", "self", ".", "dim", "==", "2", ":", "\n", "            ", "self", ".", "model", "=", "MultivariateGaussianDistribution", "(", "\n", "np", ".", "zeros", "(", "self", ".", "dim", ")", ",", "np", ".", "diag", "(", "[", "1.0", ",", "1.0", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "model", "=", "MultivariateGaussianDistribution", "(", "\n", "np", ".", "zeros", "(", "self", ".", "dim", ")", ",", "np", ".", "diag", "(", "[", "1.0", ",", "1.0", ",", "5.0", "]", ")", ")", "\n", "", "", "", "if", "__name__", "==", "'__main__'", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.load_pcd_bin": [[22, 32], ["numpy.fromfile", "numpy.fromfile.reshape"], "methods", ["None"], ["class", "PointCloud", "(", "ABC", ")", ":", "\n", "    ", "\"\"\"\n    Abstract class for manipulating and viewing point clouds.\n    Every point cloud (lidar and radar) consists of points where:\n    - Dimensions 0, 1, 2 represent x, y, z coordinates.\n        These are modified when the point cloud is rotated or translated.\n    - All other dimensions are optional. Hence these have to be manually modified if the reference frame changes.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "points", ":", "np", ".", "ndarray", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.convertToPytorch": [[105, 111], ["torch.from_numpy"], "methods", ["None"], ["# Get past pose.", "\n", "current_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "current_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "global_from_car", "=", "transform_matrix", "(", "current_pose_rec", "[", "'translation'", "]", ",", "\n", "Quaternion", "(", "current_pose_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "False", ")", "\n", "\n", "# Homogeneous transformation matrix from sensor coordinate frame to ego car frame.", "\n", "current_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "current_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.fromPytorch": [[112, 122], ["pytorchTensor.numpy", "cls"], "methods", ["None"], ["car_from_current", "=", "transform_matrix", "(", "current_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "current_cs_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "False", ")", "\n", "\n", "# Fuse four transformation matrices into one and perform transform.", "\n", "trans_matrix", "=", "reduce", "(", "np", ".", "dot", ",", "[", "ref_from_car", ",", "car_from_global", ",", "global_from_car", ",", "car_from_current", "]", ")", "\n", "current_pc", ".", "transform", "(", "trans_matrix", ")", "\n", "\n", "# Add time vector which can be used as a temporal feature.", "\n", "time_lag", "=", "ref_time", "-", "1e-6", "*", "current_sd_rec", "[", "'timestamp'", "]", "# Positive difference.", "\n", "times", "=", "time_lag", "*", "np", ".", "ones", "(", "(", "1", ",", "current_pc", ".", "nbr_points", "(", ")", ")", ")", "\n", "all_times", "=", "np", ".", "hstack", "(", "(", "all_times", ",", "times", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.normalize": [[123, 126], ["numpy.atleast_2d"], "methods", ["None"], ["\n", "# Merge with key pc.", "\n", "all_pc", ".", "points", "=", "np", ".", "hstack", "(", "(", "all_pc", ".", "points", ",", "current_pc", ".", "points", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.__init__": [[131, 155], ["numpy.array", "numpy.array", "numpy.array", "numpy.any", "numpy.any", "len", "len", "int", "float", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan"], "methods", ["None"], ["                ", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "current_sd_rec", "[", "'prev'", "]", ")", "\n", "\n", "", "", "return", "all_pc", ",", "all_times", "\n", "\n", "", "def", "nbr_points", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns the number of points.\n        :return: Number of points.\n        \"\"\"", "\n", "return", "self", ".", "points", ".", "shape", "[", "1", "]", "\n", "\n", "", "def", "subsample", "(", "self", ",", "ratio", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Sub-samples the pointcloud.\n        :param ratio: Fraction to keep.\n        \"\"\"", "\n", "selected_ind", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "0", ",", "self", ".", "nbr_points", "(", ")", ")", ",", "size", "=", "int", "(", "self", ".", "nbr_points", "(", ")", "*", "ratio", ")", ")", "\n", "self", ".", "points", "=", "self", ".", "points", "[", ":", ",", "selected_ind", "]", "\n", "\n", "", "def", "remove_close", "(", "self", ",", "radius", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Removes point too close within a certain radius from origin.\n        :param radius: Radius below which points are removed.\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.__eq__": [[156, 166], ["numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.all", "numpy.all", "numpy.isnan", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["x_filt", "=", "np", ".", "abs", "(", "self", ".", "points", "[", "0", ",", ":", "]", ")", "<", "radius", "\n", "y_filt", "=", "np", ".", "abs", "(", "self", ".", "points", "[", "1", ",", ":", "]", ")", "<", "radius", "\n", "not_close", "=", "np", ".", "logical_not", "(", "np", ".", "logical_and", "(", "x_filt", ",", "y_filt", ")", ")", "\n", "self", ".", "points", "=", "self", ".", "points", "[", ":", ",", "not_close", "]", "\n", "\n", "", "def", "translate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Applies a translation to the point cloud.\n        :param x: <np.float: 3, 1>. Translation in x, y, z.\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.__repr__": [[167, 176], ["repr_str.format"], "methods", ["None"], ["            ", "self", ".", "points", "[", "i", ",", ":", "]", "=", "self", ".", "points", "[", "i", ",", ":", "]", "+", "x", "[", "i", "]", "\n", "\n", "", "", "def", "rotate", "(", "self", ",", "rot_matrix", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Applies a rotation.\n        :param rot_matrix: <np.float: 3, 3>. Rotation matrix.\n        \"\"\"", "\n", "self", ".", "points", "[", ":", "3", ",", ":", "]", "=", "np", ".", "dot", "(", "rot_matrix", ",", "self", ".", "points", "[", ":", "3", ",", ":", "]", ")", "\n", "\n", "", "def", "transform", "(", "self", ",", "transf_matrix", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.encode": [[177, 183], ["data_classes.BoundingBox.velocity.tolist", "data_classes.BoundingBox.orientation.elements.tolist", "data_classes.BoundingBox.center.tolist", "data_classes.BoundingBox.wlh.tolist"], "methods", ["None"], ["        ", "\"\"\"\n        Applies a homogeneous transform.\n        :param transf_matrix: <np.float: 4, 4>. Homogenous transformation matrix.\n        \"\"\"", "\n", "self", ".", "points", "[", ":", "3", ",", ":", "]", "=", "transf_matrix", ".", "dot", "(", "np", ".", "vstack", "(", "(", "self", ".", "points", "[", ":", "3", ",", ":", "]", ",", "np", ".", "ones", "(", "self", ".", "nbr_points", "(", ")", ")", ")", ")", ")", "[", ":", "3", ",", ":", "]", "\n", "\n", "", "def", "render_height", "(", "self", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.decode": [[184, 193], ["Box", "pyquaternion.Quaternion"], "methods", ["None"], ["ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "y_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "marker_size", ":", "float", "=", "1", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotation_matrix": [[194, 201], ["None"], "methods", ["None"], ["\n", "self", ".", "_render_helper", "(", "2", ",", "ax", ",", "view", ",", "x_lim", ",", "y_lim", ",", "marker_size", ")", "\n", "\n", "", "def", "render_intensity", "(", "self", ",", "\n", "ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate": [[202, 209], ["None"], "methods", ["None"], ["x_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "y_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "marker_size", ":", "float", "=", "1", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate": [[210, 219], ["numpy.dot", "numpy.dot"], "methods", ["None"], ["\n", "self", ".", "_render_helper", "(", "3", ",", "ax", ",", "view", ",", "x_lim", ",", "y_lim", ",", "marker_size", ")", "\n", "\n", "", "def", "_render_helper", "(", "self", ",", "\n", "color_channel", ":", "int", ",", "\n", "ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.transform": [[220, 225], ["numpy.dot", "numpy.dot", "pyquaternion.Quaternion"], "methods", ["None"], ["y_lim", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "marker_size", ":", "float", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners": [[226, 251], ["numpy.vstack", "numpy.dot", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["\n", "points", "=", "view_points", "(", "self", ".", "points", "[", ":", "3", ",", ":", "]", ",", "view", ",", "normalize", "=", "False", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "self", ".", "points", "[", "color_channel", ",", ":", "]", ",", "s", "=", "marker_size", ")", "\n", "ax", ".", "set_xlim", "(", "x_lim", "[", "0", "]", ",", "x_lim", "[", "1", "]", ")", "\n", "ax", ".", "set_ylim", "(", "y_lim", "[", "0", "]", ",", "y_lim", "[", "1", "]", ")", "\n", "\n", "\n", "", "", "class", "LidarPointCloud", "(", "PointCloud", ")", ":", "\n", "\n", "    ", "@", "staticmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns the number of dimensions.\n        :return: Number of dimensions.\n        \"\"\"", "\n", "return", "4", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_file", "(", "cls", ",", "file_name", ":", "str", ")", "->", "'LidarPointCloud'", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.bottom_corners": [[252, 258], ["data_classes.BoundingBox.corners"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["\n", "\n", "assert", "file_name", ".", "endswith", "(", "'.bin'", ")", ",", "'Unsupported filetype {}'", ".", "format", "(", "file_name", ")", "\n", "\n", "scan", "=", "np", ".", "fromfile", "(", "file_name", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "points", "=", "scan", ".", "reshape", "(", "(", "-", "1", ",", "5", ")", ")", "[", ":", ",", ":", "cls", ".", "nbr_dims", "(", ")", "]", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.attr_dict.AttrDict.__init__": [[3, 5], ["dict.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "AttrDict", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.attr_dict.AttrDict.__getattr__": [[6, 10], ["key.startswith", "attr_dict.AttrDict.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "__getattr__", "(", "self", ",", "key", ")", ":", "\n", "        ", "if", "key", ".", "startswith", "(", "'__'", ")", ":", "\n", "            ", "raise", "AttributeError", "\n", "", "return", "self", ".", "get", "(", "key", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.attr_dict.AttrDict.__setattr__": [[11, 15], ["key.startswith", "AttributeError"], "methods", ["None"], ["", "def", "__setattr__", "(", "self", ",", "key", ",", "value", ")", ":", "\n", "        ", "if", "key", ".", "startswith", "(", "'__'", ")", ":", "\n", "            ", "raise", "AttributeError", "(", "\"Cannot set magic attribute '{}'\"", ".", "format", "(", "key", ")", ")", "\n", "", "self", "[", "key", "]", "=", "value", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.decode._nms": [[9, 16], ["torch.functional.max_pool2d"], "function", ["None"], ["def", "_nms", "(", "heat", ",", "kernel", "=", "3", ")", ":", "\n", "    ", "pad", "=", "(", "kernel", "-", "1", ")", "//", "2", "\n", "\n", "hmax", "=", "nn", ".", "functional", ".", "max_pool2d", "(", "\n", "heat", ",", "(", "kernel", ",", "kernel", ")", ",", "stride", "=", "1", ",", "padding", "=", "pad", ")", "\n", "keep", "=", "(", "hmax", "==", "heat", ")", ".", "float", "(", ")", "\n", "return", "heat", "*", "keep", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.decode._topk_channel": [[18, 28], ["scores.size", "torch.topk", "torch.topk", "scores.view"], "function", ["None"], ["", "def", "_topk_channel", "(", "scores", ",", "K", "=", "40", ")", ":", "\n", "      ", "batch", ",", "cat", ",", "height", ",", "width", "=", "scores", ".", "size", "(", ")", "\n", "\n", "topk_scores", ",", "topk_inds", "=", "torch", ".", "topk", "(", "scores", ".", "view", "(", "batch", ",", "cat", ",", "-", "1", ")", ",", "K", ")", "\n", "\n", "topk_inds", "=", "topk_inds", "%", "(", "height", "*", "width", ")", "\n", "topk_ys", "=", "(", "topk_inds", "/", "width", ")", ".", "int", "(", ")", ".", "float", "(", ")", "\n", "topk_xs", "=", "(", "topk_inds", "%", "width", ")", ".", "int", "(", ")", ".", "float", "(", ")", "\n", "\n", "return", "topk_scores", ",", "topk_inds", ",", "topk_ys", ",", "topk_xs", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.decode._topk": [[29, 40], ["scores.size", "torch.topk", "torch.topk", "scores.view"], "function", ["None"], ["", "def", "_topk", "(", "scores", ",", "K", "=", "40", ")", ":", "\n", "    ", "batch", ",", "cat", ",", "height", ",", "width", "=", "scores", ".", "size", "(", ")", "\n", "\n", "topk_scores", ",", "topk_inds", "=", "torch", ".", "topk", "(", "scores", ".", "view", "(", "batch", ",", "-", "1", ")", ",", "K", ")", "\n", "\n", "topk_inds", "=", "topk_inds", "%", "(", "height", "*", "width", ")", "\n", "topk_ys", "=", "(", "topk_inds", "/", "width", ")", ".", "int", "(", ")", ".", "float", "(", ")", "\n", "topk_xs", "=", "(", "topk_inds", "%", "width", ")", ".", "int", "(", ")", ".", "float", "(", ")", "\n", "\n", "\n", "return", "topk_scores", ",", "topk_inds", ",", "topk_ys", ",", "topk_xs", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.decode.mot_decode": [[42, 65], ["heat.size", "decode._topk", "utils.loss.utils._tranpose_and_gather_feat", "scores.view.view", "torch.cat", "torch.cat", "utils.loss.utils._tranpose_and_gather_feat", "reg.view.view", "reg[].unsqueeze", "xs.view", "ys.view", "xs.view", "ys.view"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.decode._topk", "home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._tranpose_and_gather_feat", "home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._tranpose_and_gather_feat"], ["", "def", "mot_decode", "(", "heat", ",", "reg", "=", "None", ",", "z", "=", "None", ",", "K", "=", "5", ")", ":", "\n", "    ", "batch", ",", "cat", ",", "height", ",", "width", "=", "heat", ".", "size", "(", ")", "\n", "\n", "# heat = torch.sigmoid(heat)", "\n", "# perform nms on heatmaps", "\n", "# heat = _nms(heat)", "\n", "\n", "scores", ",", "inds", ",", "ys", ",", "xs", "=", "_topk", "(", "heat", ",", "K", "=", "K", ")", "\n", "if", "reg", "is", "not", "None", ":", "\n", "        ", "reg", "=", "_tranpose_and_gather_feat", "(", "reg", ",", "inds", ")", "\n", "reg", "=", "reg", ".", "view", "(", "batch", ",", "K", ",", "3", ")", "\n", "xs", "=", "xs", ".", "view", "(", "batch", ",", "K", ",", "1", ")", "+", "reg", "[", ":", ",", ":", ",", "0", ":", "1", "]", "\n", "ys", "=", "ys", ".", "view", "(", "batch", ",", "K", ",", "1", ")", "+", "reg", "[", ":", ",", ":", ",", "1", ":", "2", "]", "\n", "ry", "=", "reg", "[", ":", ",", ":", ",", "2", "]", ".", "unsqueeze", "(", "dim", "=", "2", ")", "\n", "", "else", ":", "\n", "        ", "xs", "=", "xs", ".", "view", "(", "batch", ",", "K", ",", "1", ")", "+", "0.5", "\n", "ys", "=", "ys", ".", "view", "(", "batch", ",", "K", ",", "1", ")", "+", "0.5", "\n", "", "z", "=", "_tranpose_and_gather_feat", "(", "z", ",", "inds", ")", "\n", "\n", "scores", "=", "scores", ".", "view", "(", "batch", ",", "K", ",", "1", ")", "\n", "xy_img_z", "=", "torch", ".", "cat", "(", "[", "xs", ",", "ys", ",", "z", ",", "ry", ",", "scores", "]", ",", "dim", "=", "2", ")", "\n", "\n", "return", "xy_img_z", "\n", "", "if", "__name__", "==", "'__main__'", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.AverageMeter.__init__": [[8, 10], ["metrics.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset"], ["from", "scipy", "import", "interpolate", "\n", "\n", "from", "nuscenes", ".", "eval", ".", "prediction", ".", "data_classes", "import", "Prediction", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.AverageMeter.reset": [[11, 16], ["None"], "methods", ["None"], ["from", "nuscenes", ".", "map_expansion", ".", "map_api", "import", "NuScenesMap", "\n", "from", "nuscenes", ".", "prediction", "import", "PredictHelper", "\n", "from", "nuscenes", ".", "prediction", ".", "input_representation", ".", "static_layers", "import", "load_all_maps", "\n", "\n", "\n", "def", "returns_2d_array", "(", "function", ")", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.AverageMeter.update": [[17, 22], ["None"], "methods", ["None"], ["    ", "\"\"\" Makes sure that the metric returns an array of shape [batch_size, num_modes]. \"\"\"", "\n", "\n", "def", "_returns_array", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "result", "=", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "if", "isinstance", "(", "result", ",", "(", "int", ",", "float", ")", ")", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.__init__": [[73, 77], ["numpy.linspace", "metrics.Success.reset"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset"], ["    "]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.reset": [[78, 80], ["None"], "methods", ["None"], ["\n", "return", "max_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ")", ">=", "tolerance", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.add_overlap": [[81, 83], ["metrics.Success.overlaps.append"], "methods", ["None"], ["\n", "\n", "", "@", "returns_2d_array", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.count": [[84, 87], ["len"], "methods", ["None"], ["def", "rank_metric_over_top_k_modes", "(", "metric_results", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ",", "\n", "ranking_func", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.value": [[88, 96], ["numpy.array", "numpy.sum().astype", "numpy.sum"], "methods", ["None"], ["\n", "\n", "if", "ranking_func", "==", "\"min\"", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.average": [[97, 102], ["len", "numpy.trapz"], "methods", ["None"], ["        ", "func", "=", "np", ".", "minimum", ".", "accumulate", "\n", "", "elif", "ranking_func", "==", "\"max\"", ":", "\n", "        ", "func", "=", "np", ".", "maximum", ".", "accumulate", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Parameter ranking_func must be one of min or max. Received {ranking_func}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.__init__": [[107, 111], ["numpy.linspace", "metrics.Precision.reset"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset"], ["\n", "return", "func", "(", "sorted_metrics", ",", "axis", "=", "-", "1", ")", "\n", "\n", "\n", "", "def", "miss_rate_top_k", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.reset": [[112, 114], ["None"], "methods", ["None"], ["mode_probabilities", ":", "np", ".", "ndarray", ",", "\n", "tolerance", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Compute the miss rate over the top k modes. \"\"\"", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.add_accuracy": [[115, 117], ["metrics.Precision.accuracies.append"], "methods", ["None"], ["\n", "miss_rate", "=", "miss_max_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ",", "tolerance", ")", "\n", "return", "rank_metric_over_top_k_modes", "(", "miss_rate", ",", "mode_probabilities", ",", "\"min\"", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.count": [[118, 121], ["len"], "methods", ["None"], ["\n", "\n", "", "def", "min_ade_k", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.value": [[122, 130], ["numpy.array", "numpy.sum().astype", "numpy.sum"], "methods", ["None"], ["    ", "\"\"\" Compute the min ade over the top k modes. \"\"\"", "\n", "\n", "ade", "=", "mean_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ")", "\n", "return", "rank_metric_over_top_k_modes", "(", "ade", ",", "mode_probabilities", ",", "\"min\"", ")", "\n", "\n", "\n", "", "def", "min_fde_k", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Compute the min fde over the top k modes. \"\"\"", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.average": [[131, 136], ["len", "numpy.trapz"], "methods", ["None"], ["\n", "fde", "=", "final_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ")", "\n", "return", "rank_metric_over_top_k_modes", "(", "fde", ",", "mode_probabilities", ",", "\"min\"", ")", "\n", "\n", "\n", "", "def", "stack_ground_truth", "(", "ground_truth", ":", "np", ".", "ndarray", ",", "num_modes", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.estimateAccuracy": [[24, 30], ["numpy.linalg.norm", "numpy.linalg.norm"], "function", ["None"], ["\n", "", "elif", "result", ".", "ndim", "==", "1", ":", "\n", "            ", "result", "=", "np", ".", "expand_dims", "(", "result", ",", "0", ")", "\n", "\n", "", "return", "result", "\n", "\n", "", "return", "_returns_array", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.fromBoxToPoly": [[32, 34], ["shapely.geometry.Polygon", "tuple", "box.corners"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["\n", "", "@", "returns_2d_array", "\n", "def", "mean_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.fromBoxToPoly_waymo": [[35, 37], ["shapely.geometry.Polygon", "tuple", "box.corners"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["stacked_ground_truth", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.estimateOverlap": [[39, 68], ["fromBoxToPoly.intersection", "fromBoxToPoly.union", "dataset_type.upper", "metrics.fromBoxToPoly_waymo", "metrics.fromBoxToPoly_waymo", "metrics.fromBoxToPoly", "metrics.fromBoxToPoly", "min", "max", "max"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.fromBoxToPoly_waymo", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.fromBoxToPoly_waymo", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.fromBoxToPoly", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.fromBoxToPoly"], ["\n", "return", "np", ".", "mean", "(", "np", ".", "linalg", ".", "norm", "(", "stacked_trajs", "-", "stacked_ground_truth", ",", "axis", "=", "-", "1", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "\n", "", "@", "returns_2d_array", "\n", "def", "max_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Efficiently compute max L2 norm between trajectories and ground truths (pairwise over states).\n    :pram stacked_trajs: Array of shape [num_modes, horizon_length, state_dim].\n    :pram stacked_ground_truth: Array of [num_modes, horizon_length, state_dim].\n    :return: Array of max L2 norms as [num_modes].\n    \"\"\"", "\n", "return", "np", ".", "max", "(", "np", ".", "linalg", ".", "norm", "(", "stacked_trajs", "-", "stacked_ground_truth", ",", "axis", "=", "-", "1", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "\n", "", "@", "returns_2d_array", "\n", "def", "final_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Efficiently compute the L2 norm between the last points in the trajectory.\n    :param stacked_trajs: Array of shape [num_modes, horizon_length, state_dim].\n    :param stacked_ground_truth: Array of shape [num_modes, horizon_length, state_dim].\n    :return: mean L2 norms between final points. Array of shape [num_modes].\n    \"\"\"", "\n", "# We use take to index the elements in the last dimension so that we can also", "\n", "# apply this function for a batch", "\n", "diff_of_last", "=", "np", ".", "take", "(", "stacked_trajs", ",", "[", "-", "1", "]", ",", "-", "2", ")", ".", "squeeze", "(", ")", "-", "np", ".", "take", "(", "stacked_ground_truth", ",", "[", "-", "1", "]", ",", "-", "2", ")", ".", "squeeze", "(", ")", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "diff_of_last", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getlabelPC": [[9, 43], ["copy.deepcopy", "utils.data_classes.PointCloud", "numpy.transpose", "utils.data_classes.PointCloud.translate", "copy.deepcopy.translate", "utils.data_classes.PointCloud.rotate", "copy.deepcopy.rotate", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.zeros", "PC.points.copy", "pyquaternion.Quaternion", "numpy.max", "numpy.min", "copy.deepcopy.corners", "copy.deepcopy.corners"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["def", "getlabelPC", "(", "PC", ",", "box", ",", "offset", "=", "0", ",", "scale", "=", "1.0", ")", ":", "\n", "    ", "box_tmp", "=", "copy", ".", "deepcopy", "(", "box", ")", "\n", "new_PC", "=", "PointCloud", "(", "PC", ".", "points", ".", "copy", "(", ")", ")", "\n", "\n", "rot_mat", "=", "np", ".", "transpose", "(", "box_tmp", ".", "rotation_matrix", ")", "\n", "trans", "=", "-", "box_tmp", ".", "center", "\n", "\n", "# align data", "\n", "new_PC", ".", "translate", "(", "trans", ")", "\n", "box_tmp", ".", "translate", "(", "trans", ")", "\n", "new_PC", ".", "rotate", "(", "(", "rot_mat", ")", ")", "\n", "box_tmp", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "(", "rot_mat", ")", ")", ")", "\n", "\n", "box_tmp", ".", "wlh", "=", "box_tmp", ".", "wlh", "*", "scale", "\n", "maxi", "=", "np", ".", "max", "(", "box_tmp", ".", "corners", "(", ")", ",", "1", ")", "+", "offset", "\n", "mini", "=", "np", ".", "min", "(", "box_tmp", ".", "corners", "(", ")", ",", "1", ")", "-", "offset", "\n", "\n", "x_filt_max", "=", "new_PC", ".", "points", "[", "0", ",", ":", "]", "<", "maxi", "[", "0", "]", "\n", "x_filt_min", "=", "new_PC", ".", "points", "[", "0", ",", ":", "]", ">", "mini", "[", "0", "]", "\n", "y_filt_max", "=", "new_PC", ".", "points", "[", "1", ",", ":", "]", "<", "maxi", "[", "1", "]", "\n", "y_filt_min", "=", "new_PC", ".", "points", "[", "1", ",", ":", "]", ">", "mini", "[", "1", "]", "\n", "z_filt_max", "=", "new_PC", ".", "points", "[", "2", ",", ":", "]", "<", "maxi", "[", "2", "]", "\n", "z_filt_min", "=", "new_PC", ".", "points", "[", "2", ",", ":", "]", ">", "mini", "[", "2", "]", "\n", "\n", "close", "=", "np", ".", "logical_and", "(", "x_filt_min", ",", "x_filt_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_filt_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_filt_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_filt_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_filt_max", ")", "\n", "\n", "new_label", "=", "np", ".", "zeros", "(", "new_PC", ".", "points", ".", "shape", "[", "1", "]", ")", "\n", "new_label", "[", "close", "]", "=", "1", "\n", "\n", "return", "new_label", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropPC": [[44, 83], ["copy.deepcopy", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "utils.data_classes.PointCloud", "numpy.max", "numpy.min", "numpy.max", "numpy.min", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "copy.deepcopy.corners", "copy.deepcopy.corners"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["", "def", "cropPC", "(", "PC", ",", "box", ",", "offset", ",", "scale", ",", "limit_area", "=", "None", ")", ":", "\n", "    ", "boxTemp", "=", "copy", ".", "deepcopy", "(", "box", ")", "\n", "boxTemp", ".", "wlh", "=", "boxTemp", ".", "wlh", "*", "scale", "\n", "\n", "maxi", "=", "np", ".", "max", "(", "boxTemp", ".", "corners", "(", ")", ",", "1", ")", "+", "offset", "\n", "mini", "=", "np", ".", "min", "(", "boxTemp", ".", "corners", "(", ")", ",", "1", ")", "-", "offset", "\n", "\n", "x_filt_max", "=", "PC", ".", "points", "[", "0", ",", ":", "]", "<", "maxi", "[", "0", "]", "\n", "x_filt_min", "=", "PC", ".", "points", "[", "0", ",", ":", "]", ">", "mini", "[", "0", "]", "\n", "y_filt_max", "=", "PC", ".", "points", "[", "1", ",", ":", "]", "<", "maxi", "[", "1", "]", "\n", "y_filt_min", "=", "PC", ".", "points", "[", "1", ",", ":", "]", ">", "mini", "[", "1", "]", "\n", "z_filt_max", "=", "PC", ".", "points", "[", "2", ",", ":", "]", "<", "maxi", "[", "2", "]", "\n", "z_filt_min", "=", "PC", ".", "points", "[", "2", ",", ":", "]", ">", "mini", "[", "2", "]", "\n", "\n", "close", "=", "np", ".", "logical_and", "(", "x_filt_min", ",", "x_filt_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_filt_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_filt_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_filt_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_filt_max", ")", "\n", "\n", "if", "limit_area", "is", "not", "None", ":", "\n", "        ", "max_area", "=", "np", ".", "max", "(", "limit_area", ",", "1", ")", "\n", "min_area", "=", "np", ".", "min", "(", "limit_area", ",", "1", ")", "\n", "x_area_max", "=", "PC", ".", "points", "[", "0", ",", ":", "]", "<", "max_area", "[", "0", "]", "\n", "x_area_min", "=", "PC", ".", "points", "[", "0", ",", ":", "]", ">", "min_area", "[", "0", "]", "\n", "y_area_max", "=", "PC", ".", "points", "[", "1", ",", ":", "]", "<", "max_area", "[", "1", "]", "\n", "y_area_min", "=", "PC", ".", "points", "[", "1", ",", ":", "]", ">", "min_area", "[", "1", "]", "\n", "z_area_max", "=", "PC", ".", "points", "[", "2", ",", ":", "]", "<", "max_area", "[", "2", "]", "\n", "z_area_min", "=", "PC", ".", "points", "[", "2", ",", ":", "]", ">", "min_area", "[", "2", "]", "\n", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "x_area_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "x_area_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_area_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_area_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_area_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_area_max", ")", "\n", "\n", "", "afterCropPC", "=", "PointCloud", "(", "PC", ".", "points", "[", ":", ",", "close", "]", ")", "\n", "return", "afterCropPC", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropPCwithlabel": [[84, 124], ["copy.deepcopy", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "utils.data_classes.PointCloud", "numpy.max", "numpy.min", "numpy.max", "numpy.min", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "copy.deepcopy.corners", "copy.deepcopy.corners"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["", "def", "cropPCwithlabel", "(", "PC", ",", "box", ",", "label", ",", "offset", "=", "0", ",", "scale", "=", "1.0", ",", "limit_area", "=", "None", ")", ":", "\n", "    ", "box_tmp", "=", "copy", ".", "deepcopy", "(", "box", ")", "\n", "box_tmp", ".", "wlh", "=", "box_tmp", ".", "wlh", "*", "scale", "\n", "maxi", "=", "np", ".", "max", "(", "box_tmp", ".", "corners", "(", ")", ",", "1", ")", "+", "offset", "\n", "mini", "=", "np", ".", "min", "(", "box_tmp", ".", "corners", "(", ")", ",", "1", ")", "-", "offset", "\n", "\n", "x_filt_max", "=", "PC", ".", "points", "[", "0", ",", ":", "]", "<", "maxi", "[", "0", "]", "\n", "x_filt_min", "=", "PC", ".", "points", "[", "0", ",", ":", "]", ">", "mini", "[", "0", "]", "\n", "y_filt_max", "=", "PC", ".", "points", "[", "1", ",", ":", "]", "<", "maxi", "[", "1", "]", "\n", "y_filt_min", "=", "PC", ".", "points", "[", "1", ",", ":", "]", ">", "mini", "[", "1", "]", "\n", "z_filt_max", "=", "PC", ".", "points", "[", "2", ",", ":", "]", "<", "maxi", "[", "2", "]", "\n", "z_filt_min", "=", "PC", ".", "points", "[", "2", ",", ":", "]", ">", "mini", "[", "2", "]", "\n", "\n", "close", "=", "np", ".", "logical_and", "(", "x_filt_min", ",", "x_filt_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_filt_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_filt_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_filt_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_filt_max", ")", "\n", "\n", "if", "limit_area", "is", "not", "None", ":", "\n", "        ", "max_area", "=", "np", ".", "max", "(", "limit_area", ",", "1", ")", "\n", "min_area", "=", "np", ".", "min", "(", "limit_area", ",", "1", ")", "\n", "x_area_max", "=", "PC", ".", "points", "[", "0", ",", ":", "]", "<", "max_area", "[", "0", "]", "\n", "x_area_min", "=", "PC", ".", "points", "[", "0", ",", ":", "]", ">", "min_area", "[", "0", "]", "\n", "y_area_max", "=", "PC", ".", "points", "[", "1", ",", ":", "]", "<", "max_area", "[", "1", "]", "\n", "y_area_min", "=", "PC", ".", "points", "[", "1", ",", ":", "]", ">", "min_area", "[", "1", "]", "\n", "z_area_max", "=", "PC", ".", "points", "[", "2", ",", ":", "]", "<", "max_area", "[", "2", "]", "\n", "z_area_min", "=", "PC", ".", "points", "[", "2", ",", ":", "]", ">", "min_area", "[", "2", "]", "\n", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "x_area_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "x_area_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_area_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "y_area_max", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_area_min", ")", "\n", "close", "=", "np", ".", "logical_and", "(", "close", ",", "z_area_max", ")", "\n", "\n", "", "new_PC", "=", "PointCloud", "(", "PC", ".", "points", "[", ":", ",", "close", "]", ")", "\n", "new_label", "=", "label", "[", "close", "]", "\n", "\n", "return", "new_PC", ",", "new_label", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropAndCenterPC": [[125, 145], ["kitti_utils.cropPC", "copy.deepcopy", "numpy.transpose", "cropPC.translate", "copy.deepcopy.translate", "cropPC.rotate", "copy.deepcopy.rotate", "kitti_utils.cropPC", "pyquaternion.Quaternion", "cropPC.normalize"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropPC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropPC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.normalize"], ["", "def", "cropAndCenterPC", "(", "PC", ",", "box", ",", "offset", ",", "scale", ",", "normalize", "=", "False", ",", "limit_area", "=", "None", ")", ":", "\n", "    ", "new_PC", "=", "cropPC", "(", "PC", ",", "box", ",", "offset", "=", "2", "*", "offset", ",", "scale", "=", "4", "*", "scale", ")", "\n", "new_box", "=", "copy", ".", "deepcopy", "(", "box", ")", "\n", "\n", "rot_mat", "=", "np", ".", "transpose", "(", "new_box", ".", "rotation_matrix", ")", "\n", "\n", "# align data", "\n", "trans", "=", "-", "new_box", ".", "center", "\n", "new_PC", ".", "translate", "(", "trans", ")", "\n", "new_box", ".", "translate", "(", "trans", ")", "\n", "\n", "new_PC", ".", "rotate", "(", "(", "rot_mat", ")", ")", "\n", "new_box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "(", "rot_mat", ")", ")", ")", "\n", "\n", "# crop around box", "\n", "new_PC", "=", "cropPC", "(", "new_PC", ",", "new_box", ",", "offset", "=", "offset", ",", "scale", "=", "scale", ",", "limit_area", "=", "limit_area", ")", "\n", "\n", "if", "normalize", ":", "\n", "        ", "new_PC", ".", "normalize", "(", "box", ".", "wlh", ")", "\n", "", "return", "new_PC", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropAndCenterPC_withClaAndOff": [[146, 172], ["kitti_utils.cropPC", "copy.deepcopy", "copy.deepcopy", "kitti_utils.getlabelPC", "numpy.transpose", "cropPC.translate", "copy.deepcopy.translate", "copy.deepcopy.translate", "cropPC.rotate", "copy.deepcopy.rotate", "copy.deepcopy.rotate", "kitti_utils.cropPCwithlabel", "numpy.array", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "numpy.array"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropPC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getlabelPC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropPCwithlabel"], ["", "def", "cropAndCenterPC_withClaAndOff", "(", "PC", ",", "cut_box", ",", "gt_box", ",", "offset", ",", "scale", ",", "limit_area", "=", "None", ")", ":", "\n", "    ", "new_PC", "=", "cropPC", "(", "PC", ",", "cut_box", ",", "offset", "=", "2", "*", "offset", ",", "scale", "=", "4", "*", "scale", ")", "\n", "\n", "new_box_cut", "=", "copy", ".", "deepcopy", "(", "cut_box", ")", "\n", "new_box_gt", "=", "copy", ".", "deepcopy", "(", "gt_box", ")", "\n", "\n", "class_label", "=", "getlabelPC", "(", "new_PC", ",", "gt_box", ",", "scale", "=", "np", ".", "array", "(", "[", "1.10", ",", "1.05", ",", "1.025", "]", ")", ")", "\n", "\n", "rot_mat", "=", "np", ".", "transpose", "(", "new_box_cut", ".", "rotation_matrix", ")", "\n", "trans", "=", "-", "new_box_cut", ".", "center", "\n", "\n", "# align data", "\n", "new_PC", ".", "translate", "(", "trans", ")", "\n", "new_box_cut", ".", "translate", "(", "trans", ")", "\n", "new_box_gt", ".", "translate", "(", "trans", ")", "\n", "new_PC", ".", "rotate", "(", "(", "rot_mat", ")", ")", "\n", "new_box_cut", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "(", "rot_mat", ")", ")", ")", "\n", "new_box_gt", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "(", "rot_mat", ")", ")", ")", "\n", "\n", "# crop around box", "\n", "new_PC", ",", "class_label", "=", "cropPCwithlabel", "(", "new_PC", ",", "new_box_cut", ",", "class_label", ",", "offset", "=", "offset", ",", "scale", "=", "scale", ",", "limit_area", "=", "limit_area", ")", "\n", "\n", "# get offset(center & rotation)", "\n", "offcenter", "=", "np", ".", "array", "(", "[", "new_box_gt", ".", "center", "[", "0", "]", ",", "new_box_gt", ".", "center", "[", "1", "]", ",", "new_box_gt", ".", "center", "[", "2", "]", ",", "new_box_gt", ".", "orientation", ".", "degrees", "*", "new_box_gt", ".", "orientation", ".", "axis", "[", "2", "]", "]", ")", "\n", "\n", "return", "new_PC", ",", "class_label", ",", "offcenter", ",", "new_box_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getOffsetBBtest": [[173, 203], ["pyquaternion.Quaternion", "numpy.array", "copy.deepcopy", "copy.deepcopy.translate", "copy.deepcopy.rotate", "copy.deepcopy.rotate", "copy.deepcopy.translate", "len", "copy.deepcopy.rotate", "numpy.random.uniform", "min", "numpy.random.uniform", "len", "copy.deepcopy.translate", "copy.deepcopy.translate", "pyquaternion.Quaternion", "len", "copy.deepcopy.rotate", "min", "numpy.random.uniform", "numpy.array", "numpy.array", "pyquaternion.Quaternion"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], ["", "def", "getOffsetBBtest", "(", "box", ",", "offset", ")", ":", "\n", "    ", "rot_quat", "=", "Quaternion", "(", "matrix", "=", "box", ".", "rotation_matrix", ")", "\n", "trans", "=", "np", ".", "array", "(", "box", ".", "center", ")", "\n", "\n", "new_box", "=", "copy", ".", "deepcopy", "(", "box", ")", "\n", "\n", "new_box", ".", "translate", "(", "-", "trans", ")", "\n", "new_box", ".", "rotate", "(", "rot_quat", ".", "inverse", ")", "\n", "\n", "# REMOVE TRANSfORM", "\n", "if", "len", "(", "offset", ")", "==", "3", ":", "\n", "        ", "new_box", ".", "rotate", "(", "\n", "Quaternion", "(", "axis", "=", "[", "0", ",", "0", ",", "1", "]", ",", "angle", "=", "offset", "[", "2", "]", "*", "np", ".", "pi", "/", "180", ")", ")", "\n", "", "elif", "len", "(", "offset", ")", "==", "4", ":", "\n", "        ", "new_box", ".", "rotate", "(", "\n", "Quaternion", "(", "axis", "=", "[", "0", ",", "0", ",", "1", "]", ",", "angle", "=", "offset", "[", "3", "]", "*", "np", ".", "pi", "/", "180", ")", ")", "\n", "", "if", "offset", "[", "0", "]", ">", "new_box", ".", "wlh", "[", "0", "]", ":", "\n", "        ", "offset", "[", "0", "]", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ")", "\n", "", "if", "offset", "[", "1", "]", ">", "min", "(", "new_box", ".", "wlh", "[", "1", "]", ",", "2", ")", ":", "\n", "        ", "offset", "[", "1", "]", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ")", "\n", "", "if", "len", "(", "offset", ")", "==", "4", ":", "\n", "        ", "if", "offset", "[", "2", "]", ">", "min", "(", "new_box", ".", "wlh", "[", "2", "]", ",", "0.5", ")", ":", "\n", "            ", "offset", "[", "2", "]", "=", "np", ".", "random", ".", "uniform", "(", "-", "0.5", ",", "0.5", ")", "\n", "", "new_box", ".", "translate", "(", "np", ".", "array", "(", "[", "offset", "[", "0", "]", ",", "offset", "[", "1", "]", ",", "offset", "[", "2", "]", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "new_box", ".", "translate", "(", "np", ".", "array", "(", "[", "offset", "[", "0", "]", ",", "offset", "[", "1", "]", ",", "0", "]", ")", ")", "\n", "# APPLY PREVIOUS TRANSFORMATION", "\n", "", "new_box", ".", "rotate", "(", "rot_quat", ")", "\n", "new_box", ".", "translate", "(", "trans", ")", "\n", "return", "new_box", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getOffsetBB_data": [[204, 234], ["pyquaternion.Quaternion", "numpy.array", "copy.deepcopy", "copy.deepcopy.translate", "copy.deepcopy.rotate", "copy.deepcopy.rotate", "copy.deepcopy.translate", "len", "copy.deepcopy.rotate", "numpy.abs", "min", "numpy.random.uniform", "numpy.abs", "min", "numpy.random.uniform", "len", "copy.deepcopy.translate", "copy.deepcopy.translate", "pyquaternion.Quaternion", "len", "copy.deepcopy.rotate", "numpy.abs", "min", "numpy.random.uniform", "numpy.array", "numpy.array", "pyquaternion.Quaternion"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], ["", "def", "getOffsetBB_data", "(", "box", ",", "offset", ")", ":", "\n", "    ", "rot_quat", "=", "Quaternion", "(", "matrix", "=", "box", ".", "rotation_matrix", ")", "\n", "trans", "=", "np", ".", "array", "(", "box", ".", "center", ")", "\n", "\n", "new_box", "=", "copy", ".", "deepcopy", "(", "box", ")", "\n", "\n", "new_box", ".", "translate", "(", "-", "trans", ")", "\n", "new_box", ".", "rotate", "(", "rot_quat", ".", "inverse", ")", "\n", "\n", "# REMOVE TRANSfORM", "\n", "if", "len", "(", "offset", ")", "==", "3", ":", "\n", "        ", "new_box", ".", "rotate", "(", "\n", "Quaternion", "(", "axis", "=", "[", "0", ",", "0", ",", "1", "]", ",", "angle", "=", "offset", "[", "2", "]", "*", "np", ".", "pi", "/", "180", ")", ")", "\n", "", "elif", "len", "(", "offset", ")", "==", "4", ":", "\n", "        ", "new_box", ".", "rotate", "(", "\n", "Quaternion", "(", "axis", "=", "[", "0", ",", "0", ",", "1", "]", ",", "angle", "=", "offset", "[", "3", "]", "*", "np", ".", "pi", "/", "180", ")", ")", "\n", "", "if", "np", ".", "abs", "(", "offset", "[", "0", "]", ")", ">", "min", "(", "new_box", ".", "wlh", "[", "1", "]", ",", "2", ")", ":", "\n", "        ", "offset", "[", "0", "]", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ")", "\n", "", "if", "np", ".", "abs", "(", "offset", "[", "1", "]", ")", ">", "min", "(", "new_box", ".", "wlh", "[", "0", "]", ",", "2", ")", ":", "\n", "        ", "offset", "[", "1", "]", "=", "np", ".", "random", ".", "uniform", "(", "-", "1", ",", "1", ")", "\n", "", "if", "len", "(", "offset", ")", "==", "4", ":", "\n", "        ", "if", "np", ".", "abs", "(", "offset", "[", "2", "]", ")", ">", "min", "(", "new_box", ".", "wlh", "[", "2", "]", ",", "0.5", ")", ":", "\n", "            ", "offset", "[", "2", "]", "=", "np", ".", "random", ".", "uniform", "(", "-", "0.5", ",", "0.5", ")", "\n", "", "new_box", ".", "translate", "(", "np", ".", "array", "(", "[", "offset", "[", "0", "]", ",", "offset", "[", "1", "]", ",", "offset", "[", "2", "]", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "new_box", ".", "translate", "(", "np", ".", "array", "(", "[", "offset", "[", "0", "]", ",", "offset", "[", "1", "]", ",", "0", "]", ")", ")", "\n", "# APPLY PREVIOUS TRANSFORMATION", "\n", "", "new_box", ".", "rotate", "(", "rot_quat", ")", "\n", "new_box", ".", "translate", "(", "trans", ")", "\n", "return", "new_box", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.box_local": [[235, 247], ["utils.data_classes.PointCloud", "copy.deepcopy", "kitti_utils.getlabelPC", "kitti_utils.getlabelPC", "numpy.arange", "torch.from_numpy", "torch.from_numpy", "numpy.array"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getlabelPC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getlabelPC"], ["", "def", "box_local", "(", "PC", ",", "box", ",", "offset", ",", "scale", ")", ":", "\n", "    ", "new_PC", "=", "PointCloud", "(", "PC", ")", "\n", "new_box", "=", "copy", ".", "deepcopy", "(", "box", ")", "\n", "\n", "# crop around box", "\n", "class_label", "=", "getlabelPC", "(", "new_PC", ",", "new_box", ",", "offset", ",", "scale", ")", "\n", "\n", "local_idxs", "=", "np", ".", "arange", "(", "class_label", ".", "shape", "[", "0", "]", ")", "[", "class_label", "==", "1", "]", "\n", "\n", "surf_class_label", "=", "getlabelPC", "(", "new_PC", ",", "new_box", ",", "scale", "=", "np", ".", "array", "(", "[", "1.10", ",", "1.05", ",", "1.025", "]", ")", ")", "\n", "\n", "return", "torch", ".", "from_numpy", "(", "surf_class_label", ")", ",", "torch", ".", "from_numpy", "(", "local_idxs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.get_PC_offset": [[248, 270], ["copy.deepcopy", "copy.deepcopy", "numpy.transpose", "copy.deepcopy.translate", "copy.deepcopy.rotate", "copy.deepcopy.translate", "copy.deepcopy.rotate", "numpy.hstack", "numpy.vstack", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "torch.from_numpy().float", "torch.from_numpy().float", "center_offset.reshape", "numpy.array", "torch.from_numpy", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], ["", "def", "get_PC_offset", "(", "cur_BB", ",", "pre_BB", ")", ":", "\n", "    ", "new_cur_box", "=", "copy", ".", "deepcopy", "(", "cur_BB", ")", "\n", "new_pre_box", "=", "copy", ".", "deepcopy", "(", "pre_BB", ")", "\n", "\n", "rot_mat", "=", "np", ".", "transpose", "(", "new_pre_box", ".", "rotation_matrix", ")", "\n", "trans", "=", "-", "new_pre_box", ".", "center", "\n", "\n", "# rotate and translate to pre_BB center", "\n", "new_pre_box", ".", "translate", "(", "trans", ")", "\n", "new_pre_box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "(", "rot_mat", ")", ")", ")", "\n", "new_cur_box", ".", "translate", "(", "trans", ")", "\n", "new_cur_box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "(", "rot_mat", ")", ")", ")", "\n", "\n", "# center offset", "\n", "center_offset", "=", "new_cur_box", ".", "center", "\n", "# rotate radians offset", "\n", "degrees_offset", "=", "new_cur_box", ".", "orientation", ".", "rotation_matrix", "\n", "\n", "rot_mat", "=", "np", ".", "hstack", "(", "(", "degrees_offset", ",", "center_offset", ".", "reshape", "(", "3", ",", "1", ")", ")", ")", "#3*4", "\n", "transf_mat", "=", "np", ".", "vstack", "(", "(", "rot_mat", ",", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "1", "]", ")", ")", ")", "\n", "\n", "return", "torch", ".", "from_numpy", "(", "degrees_offset", ")", ".", "float", "(", ")", ",", "torch", ".", "from_numpy", "(", "center_offset", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.get_sample_PC_offset": [[271, 300], ["copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "numpy.transpose", "copy.deepcopy.translate", "copy.deepcopy.rotate", "copy.deepcopy.translate", "copy.deepcopy.rotate", "copy.deepcopy.translate", "copy.deepcopy.rotate", "numpy.transpose", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "torch.from_numpy().float", "torch.from_numpy().float", "numpy.dot", "torch.from_numpy", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], ["", "def", "get_sample_PC_offset", "(", "cur_BB", ",", "pre_BB", ",", "sample_pre_BB", ")", ":", "\n", "    ", "new_cur_box", "=", "copy", ".", "deepcopy", "(", "cur_BB", ")", "\n", "new_pre_box", "=", "copy", ".", "deepcopy", "(", "pre_BB", ")", "\n", "new_sample_pre_box", "=", "copy", ".", "deepcopy", "(", "sample_pre_BB", ")", "\n", "\n", "rot_mat", "=", "np", ".", "transpose", "(", "new_sample_pre_box", ".", "rotation_matrix", ")", "\n", "trans", "=", "-", "new_sample_pre_box", ".", "center", "\n", "\n", "# rotate and translate to pre_BB center", "\n", "new_pre_box", ".", "translate", "(", "trans", ")", "\n", "new_pre_box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "(", "rot_mat", ")", ")", ")", "\n", "new_cur_box", ".", "translate", "(", "trans", ")", "\n", "new_cur_box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "(", "rot_mat", ")", ")", ")", "\n", "new_sample_pre_box", ".", "translate", "(", "trans", ")", "\n", "new_sample_pre_box", ".", "rotate", "(", "Quaternion", "(", "matrix", "=", "(", "rot_mat", ")", ")", ")", "\n", "\n", "# center offset", "\n", "center_offset", "=", "new_cur_box", ".", "center", "-", "new_pre_box", ".", "center", "\n", "# rotate radians offset", "\n", "pre_BB_rotmat", "=", "np", ".", "transpose", "(", "new_pre_box", ".", "rotation_matrix", ")", "\n", "degrees_offset", "=", "Quaternion", "(", "matrix", "=", "np", ".", "dot", "(", "new_cur_box", ".", "rotation_matrix", ",", "pre_BB_rotmat", ")", ")", ".", "rotation_matrix", "\n", "\n", "# rot_mat = np.transpose(new_pre_box.rotation_matrix)", "\n", "# trans = -new_pre_box.center", "\n", "# new_cur_box.translate(trans)", "\n", "# new_cur_box.rotate(Quaternion(matrix=(rot_mat)))", "\n", "# center_offset = new_cur_box.center", "\n", "\n", "return", "torch", ".", "from_numpy", "(", "degrees_offset", ")", ".", "float", "(", ")", ",", "torch", ".", "from_numpy", "(", "center_offset", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.subsamplePC": [[301, 317], ["torch.from_numpy().float().t", "np.zeros.reshape", "numpy.zeros", "torch.from_numpy().float", "numpy.random.randint", "torch.from_numpy"], "function", ["None"], ["", "def", "subsamplePC", "(", "PC", ",", "subsample_number", ")", ":", "\n", "\n", "    ", "if", "subsample_number", "==", "0", ":", "\n", "        ", "pass", "\n", "", "elif", "PC", ".", "shape", "[", "1", "]", ">", "2", ":", "\n", "        ", "if", "PC", ".", "shape", "[", "0", "]", ">", "3", ":", "\n", "            ", "PC", "=", "PC", "[", "0", ":", "3", ",", ":", "]", "\n", "", "if", "PC", ".", "shape", "[", "1", "]", "!=", "subsample_number", ":", "\n", "# subsample", "\n", "            ", "new_pts_idx", "=", "np", ".", "random", ".", "randint", "(", "low", "=", "0", ",", "high", "=", "PC", ".", "shape", "[", "1", "]", ",", "size", "=", "subsample_number", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "PC", "=", "PC", "[", ":", ",", "new_pts_idx", "]", "\n", "", "PC", "=", "PC", ".", "reshape", "(", "3", ",", "subsample_number", ")", "\n", "", "else", ":", "\n", "        ", "PC", "=", "np", ".", "zeros", "(", "(", "3", ",", "subsample_number", ")", ")", "\n", "\n", "", "return", "torch", ".", "from_numpy", "(", "PC", ")", ".", "float", "(", ")", ".", "t", "(", ")", "#(N, 3)", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.subsamplePC_withClaAndOff": [[318, 341], ["np.zeros.reshape", "numpy.tile", "numpy.zeros", "numpy.zeros", "numpy.tile", "torch.from_numpy().float().t", "torch.from_numpy().float", "torch.from_numpy().float", "numpy.shape", "numpy.random.randint", "numpy.random.seed", "numpy.size", "numpy.size", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.shape"], ["", "def", "subsamplePC_withClaAndOff", "(", "PC", ",", "class_label", ",", "offcenter", ",", "subsample_number", ",", "cut", "=", "False", ",", "istrain", "=", "True", ")", ":", "\n", "    ", "if", "np", ".", "shape", "(", "PC", ")", "[", "1", "]", ">", "2", ":", "\n", "        ", "if", "PC", ".", "shape", "[", "0", "]", ">", "3", ":", "\n", "            ", "PC", "=", "PC", "[", "0", ":", "3", ",", ":", "]", "\n", "", "if", "PC", ".", "shape", "[", "1", "]", "!=", "subsample_number", ":", "\n", "            ", "if", "not", "istrain", ":", "\n", "                ", "np", ".", "random", ".", "seed", "(", "1", ")", "\n", "", "new_pts_idx", "=", "np", ".", "random", ".", "randint", "(", "low", "=", "0", ",", "high", "=", "PC", ".", "shape", "[", "1", "]", ",", "size", "=", "subsample_number", ",", "dtype", "=", "np", ".", "int64", ")", "# random sample", "\n", "PC", "=", "PC", "[", ":", ",", "new_pts_idx", "]", "\n", "class_label", "=", "class_label", "[", "new_pts_idx", "]", "\n", "", "PC", "=", "PC", ".", "reshape", "(", "(", "3", ",", "subsample_number", ")", ")", "\n", "offcenter", "=", "np", ".", "tile", "(", "offcenter", ",", "[", "np", ".", "size", "(", "class_label", ")", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "PC", "=", "np", ".", "zeros", "(", "(", "3", ",", "subsample_number", ")", ")", "\n", "class_label", "=", "np", ".", "zeros", "(", "subsample_number", ")", "\n", "offcenter", "=", "np", ".", "tile", "(", "offcenter", ",", "[", "np", ".", "size", "(", "class_label", ")", ",", "1", "]", ")", "\n", "\n", "", "if", "cut", ":", "\n", "        ", "cut_num", "=", "PC", ".", "shape", "[", "-", "1", "]", "//", "8", "\n", "class_label", "=", "class_label", "[", ":", "cut_num", "]", "\n", "offcenter", "=", "offcenter", "[", ":", "cut_num", "]", "\n", "\n", "", "return", "torch", ".", "from_numpy", "(", "PC", ")", ".", "float", "(", ")", ".", "t", "(", ")", ",", "torch", ".", "from_numpy", "(", "class_label", ")", ".", "float", "(", ")", ",", "torch", ".", "from_numpy", "(", "offcenter", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getModel": [[342, 358], ["numpy.ones", "zip", "utils.data_classes.PointCloud", "len", "utils.data_classes.PointCloud", "kitti_utils.cropAndCenterPC", "numpy.ones", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropAndCenterPC"], ["", "def", "getModel", "(", "PCs", ",", "boxes", ",", "offset", "=", "0", ",", "scale", "=", "1.0", ",", "normalize", "=", "False", ")", ":", "\n", "\n", "    ", "if", "len", "(", "PCs", ")", "==", "0", ":", "\n", "        ", "return", "PointCloud", "(", "np", ".", "ones", "(", "(", "3", ",", "0", ")", ")", ")", "\n", "", "points", "=", "np", ".", "ones", "(", "(", "PCs", "[", "0", "]", ".", "points", ".", "shape", "[", "0", "]", ",", "0", ")", ")", "\n", "\n", "for", "PC", ",", "box", "in", "zip", "(", "PCs", ",", "boxes", ")", ":", "\n", "        ", "cropped_PC", "=", "cropAndCenterPC", "(", "\n", "PC", ",", "box", ",", "offset", "=", "offset", ",", "scale", "=", "scale", ",", "normalize", "=", "normalize", ")", "\n", "# try:", "\n", "if", "cropped_PC", ".", "points", ".", "shape", "[", "1", "]", ">", "0", ":", "\n", "            ", "points", "=", "np", ".", "concatenate", "(", "[", "points", ",", "cropped_PC", ".", "points", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "", "PC", "=", "PointCloud", "(", "points", ")", "\n", "\n", "return", "PC", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info": [[4, 11], ["len", "print", "print", "print", "int", "int"], "function", ["None"], ["def", "print_info", "(", "ncols", ",", "info", ",", "placeholder", "=", "'='", ")", ":", "\n", "    ", "info_len", "=", "len", "(", "info", ")", "\n", "placeholder_len", "=", "ncols", "-", "info_len", "\n", "\n", "print", "(", "(", "int", "(", "placeholder_len", "/", "2", ")", "-", "1", ")", "*", "placeholder", ",", "end", "=", "' '", ")", "\n", "print", "(", "info", ",", "end", "=", "' '", ")", "\n", "print", "(", "(", "int", "(", "(", "placeholder_len", "+", "1", ")", "/", "2", ")", "-", "1", ")", "*", "placeholder", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.pointnet2_modules._PointNet2SAModuleBase.__init__": [[13, 18], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "groupers", "=", "None", "\n", "self", ".", "mlps", "=", "None", "\n", "self", ".", "use_edge", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.pointnet2_modules._PointNet2SAModuleBase.forward": [[19, 63], ["xyz.transpose().contiguous", "range", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "lib.pointops.functions.pointops.gathering().transpose().contiguous", "idx.long.long.long", "[].transpose().contiguous", "len", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "torch.cat.squeeze", "torch.cat.squeeze", "torch.cat.squeeze", "new_features_list.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "xyz.transpose", "center_features.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "lib.pointops.functions.pointops.gathering().transpose", "[].transpose", "center_features.unsqueeze().expand.unsqueeze().expand.unsqueeze", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "lib.pointops.functions.pointops.gathering", "xyz.size", "features.transpose", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange().repeat().transpose", "torch.arange().repeat().transpose", "torch.arange().repeat().transpose", "torch.arange().repeat().transpose", "torch.arange().repeat().transpose", "torch.arange().repeat().transpose", "torch.arange().repeat().transpose", "torch.arange().repeat().transpose", "torch.arange().repeat().transpose", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "xyz.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "xyz", ":", "torch", ".", "Tensor", ",", "features", ":", "torch", ".", "Tensor", "=", "None", ",", "npoint", ":", "int", "=", "None", ")", "->", "(", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "r\"\"\"\n        Parameters\n        ----------\n        xyz : torch.Tensor\n            (B, N, 3) tensor of the xyz coordinates of the features\n        features : torch.Tensor\n            (B, C, N) tensor of the descriptors of the the features\n        Returns\n        -------\n        new_xyz : torch.Tensor\n            (B, npoint, 3) tensor of the new features' xyz\n        new_features : torch.Tensor\n            (B, npoint, \\sum_k(mlps[k][-1])) tensor of the new_features descriptors\n        \"\"\"", "\n", "self", ".", "npoint", "=", "npoint", "\n", "new_features_list", "=", "[", "]", "\n", "xyz_trans", "=", "xyz", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "if", "self", ".", "npoint", "is", "not", "None", ":", "\n", "            ", "idx", "=", "torch", ".", "arange", "(", "self", ".", "npoint", ")", ".", "repeat", "(", "xyz", ".", "size", "(", "0", ")", ",", "1", ")", ".", "int", "(", ")", ".", "cuda", "(", ")", "\n", "new_xyz", "=", "pointops", ".", "gathering", "(", "\n", "xyz_trans", ",", "\n", "idx", "\n", "# pointops.furthestsampling(xyz, self.npoint)", "\n", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "", "else", ":", "\n", "            ", "new_xyz", "=", "None", "\n", "idx", "=", "None", "\n", "", "if", "self", ".", "use_edge", "and", "features", "is", "not", "None", ":", "\n", "# (B, C, npoint)", "\n", "            ", "idx", "=", "idx", ".", "long", "(", ")", "\n", "center_features", "=", "features", ".", "transpose", "(", "1", ",", "2", ")", "[", "torch", ".", "arange", "(", "xyz", ".", "size", "(", "0", ")", ")", ".", "repeat", "(", "self", ".", "npoint", ",", "1", ")", ".", "transpose", "(", "0", ",", "1", ")", ",", "idx", ",", ":", "]", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "groupers", ")", ")", ":", "\n", "            ", "new_features", "=", "self", ".", "groupers", "[", "i", "]", "(", "xyz", ",", "new_xyz", ",", "features", ")", "# (B, 3+C, npoint, nsample)", "\n", "if", "self", ".", "use_edge", "and", "features", "is", "not", "None", ":", "\n", "#(B, C, npoint, nsample)", "\n", "                ", "center_features", "=", "center_features", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "-", "1", ",", "self", ".", "groupers", "[", "i", "]", ".", "nsample", ")", "\n", "# (B, 3+2c, npoint, nsample)", "\n", "new_features", "=", "torch", ".", "cat", "(", "[", "new_features", "[", ":", ",", "0", ":", "3", ",", ":", ",", ":", "]", ",", "new_features", "[", ":", ",", "3", ":", ",", ":", ",", ":", "]", "-", "center_features", ",", "center_features", "]", ",", "dim", "=", "1", ")", "\n", "", "new_features", "=", "self", ".", "mlps", "[", "i", "]", "(", "new_features", ")", "# (B, mlp[-1], npoint, nsample)", "\n", "new_features", "=", "F", ".", "max_pool2d", "(", "new_features", ",", "kernel_size", "=", "[", "1", ",", "new_features", ".", "size", "(", "3", ")", "]", ")", "# (B, mlp[-1], npoint, 1)", "\n", "new_features", "=", "new_features", ".", "squeeze", "(", "-", "1", ")", "# (B, mlp[-1], npoint)", "\n", "new_features_list", ".", "append", "(", "new_features", ")", "\n", "", "return", "new_xyz", ",", "torch", ".", "cat", "(", "new_features_list", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.pointnet2_modules.PointNet2SAModuleMSG.__init__": [[80, 110], ["pointnet2_modules._PointNet2SAModuleBase.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "len", "len", "len", "len", "pointnet2_modules.PointNet2SAModuleMSG.groupers.append", "pointnet2_modules.PointNet2SAModuleMSG.mlps.append", "lib.pointops.functions.pointops.QueryAndGroup", "etw_pytorch_utils.SharedMLP"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ",", "*", ",", "radii", ":", "List", "[", "float", "]", ",", "nsamples", ":", "List", "[", "int", "]", ",", "mlps", ":", "List", "[", "List", "[", "int", "]", "]", ",", "bn", ":", "bool", "=", "True", ",", "use_xyz", ":", "bool", "=", "True", ",", "use_edge", ":", "bool", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "use_edge", "=", "use_edge", "\n", "assert", "len", "(", "radii", ")", "==", "len", "(", "nsamples", ")", "==", "len", "(", "mlps", ")", "\n", "self", ".", "groupers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "mlps", "=", "nn", ".", "ModuleList", "(", ")", "\n", "# if use_edge:", "\n", "#     self.edge=nn.ModuleList()", "\n", "for", "i", "in", "range", "(", "len", "(", "radii", ")", ")", ":", "\n", "            ", "radius", "=", "radii", "[", "i", "]", "\n", "nsample", "=", "nsamples", "[", "i", "]", "\n", "self", ".", "groupers", ".", "append", "(", "\n", "pointops", ".", "QueryAndGroup", "(", "radius", ",", "nsample", ",", "use_xyz", "=", "use_xyz", ")", "\n", "# if npoint is not None else pointops.GroupAll(use_xyz)", "\n", ")", "\n", "mlp_spec", "=", "mlps", "[", "i", "]", "\n", "if", "use_edge", ":", "\n", "# self.edge.append(", "\n", "#     nn.Sequential(*[nn.Conv2d(2 * mlp_spec[-1], mlp_spec[-1], kernel_size=(1, 1), bias=False),", "\n", "#                     nn.BatchNorm2d(mlp_spec[-1]),", "\n", "#                     nn.ReLU(),", "\n", "#                     nn.Conv2d(mlp_spec[-1], mlp_spec[-1], kernel_size=(1, 1), bias=False),", "\n", "#                     nn.BatchNorm2d(mlp_spec[-1]),", "\n", "#                     nn.ReLU()],", "\n", "#                   ))", "\n", "                ", "mlp_spec", "[", "0", "]", "*=", "2", "\n", "", "if", "use_xyz", ":", "\n", "                ", "mlp_spec", "[", "0", "]", "+=", "3", "\n", "\n", "", "self", ".", "mlps", ".", "append", "(", "pt_util", ".", "SharedMLP", "(", "mlp_spec", ",", "bn", "=", "bn", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.pointnet2_modules.PointNet2SAModule.__init__": [[127, 129], ["pointnet2_modules.PointNet2SAModuleMSG.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ",", "*", ",", "mlp", ":", "List", "[", "int", "]", ",", "radius", ":", "float", "=", "None", ",", "nsample", ":", "int", "=", "None", ",", "bn", ":", "bool", "=", "True", ",", "use_xyz", ":", "bool", "=", "True", ",", "use_edge", ":", "bool", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "mlps", "=", "[", "mlp", "]", ",", "radii", "=", "[", "radius", "]", ",", "nsamples", "=", "[", "nsample", "]", ",", "bn", "=", "bn", ",", "use_xyz", "=", "use_xyz", ",", "use_edge", "=", "use_edge", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.pointnet2_modules.PointnetProposalModule.__init__": [[148, 159], ["pointnet2_modules.PointNet2SAModuleMSG.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "\n", "self", ",", "mlp", ",", "radius", "=", "None", ",", "nsample", "=", "None", ",", "bn", "=", "True", ",", "use_xyz", "=", "True", ",", "vote", "=", "True", "\n", ")", ":", "\n", "# type: (PointnetSAModule, List[int], int, float, int, bool, bool) -> None", "\n", "        ", "super", "(", "PointnetProposalModule", ",", "self", ")", ".", "__init__", "(", "\n", "mlps", "=", "[", "mlp", "]", ",", "\n", "radii", "=", "[", "radius", "]", ",", "\n", "nsamples", "=", "[", "nsample", "]", ",", "\n", "bn", "=", "bn", ",", "\n", "use_xyz", "=", "use_xyz", ",", "\n", "vote", "=", "vote", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.pointnet2_modules.PointnetProposalModule.forward": [[161, 219], ["xyz.transpose().contiguous", "lib.pointops.functions.pointops.gathering().transpose().contiguous", "range", "len", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "new_features.squeeze().squeeze.squeeze().squeeze.unsqueeze", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "new_features.squeeze().squeeze.squeeze().squeeze.squeeze().squeeze", "new_features_list.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "xyz.transpose", "lib.pointops.functions.pointops.gathering().transpose", "new_features.squeeze().squeeze.squeeze().squeeze.size", "new_features.squeeze().squeeze.squeeze().squeeze.squeeze", "lib.pointops.functions.pointops.gathering", "new_features.squeeze().squeeze.squeeze().squeeze.size", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int().cuda", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat().int", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "torch.arange().repeat", "xyz.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "xyz", ",", "features", ",", "npoint", ",", "score", ")", ":", "\n", "# type: (_PointnetSAModuleBase, torch.Tensor, torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]", "\n", "        ", "r\"\"\"\n        Parameters\n        ----------\n        xyz : torch.Tensor\n            (B, N, 3) tensor of the xyz coordinates of the features\n        features : torch.Tensor\n            (B, N, C) tensor of the descriptors of the the features\n\n        Returns\n        -------\n        new_xyz : torch.Tensor\n            (B, npoint, 3) tensor of the new features' xyz\n        new_features : torch.Tensor\n            (B,  \\sum_k(mlps[k][-1]), npoint) tensor of the new_features descriptors\n        \"\"\"", "\n", "\n", "self", ".", "npoint", "=", "npoint", "\n", "new_features_list", "=", "[", "]", "\n", "\n", "xyz_flipped", "=", "xyz", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "\n", "new_xyz", "=", "(", "\n", "pointops", ".", "gathering", "(", "\n", "# xyz_flipped, pointops.furthest_point_sample(xyz, self.npoint)", "\n", "xyz_flipped", ",", "torch", ".", "arange", "(", "self", ".", "npoint", ")", ".", "repeat", "(", "xyz", ".", "size", "(", "0", ")", ",", "1", ")", ".", "int", "(", ")", ".", "cuda", "(", ")", "\n", ")", "\n", ".", "transpose", "(", "1", ",", "2", ")", "\n", ".", "contiguous", "(", ")", "\n", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "groupers", ")", ")", ":", "\n", "            ", "new_features", ",", "score_id", "=", "self", ".", "groupers", "[", "i", "]", "(", "\n", "xyz", ",", "new_xyz", ",", "score", ",", "features", "\n", ")", "# (B, C, npoint, nsample)", "\n", "# score_id = new_features[:,3,:,:].sum(dim = 2).argmax(dim = 1)", "\n", "\n", "# B", "\n", "# new_features_cpu = new_features.squeeze(0).detach().cpu().numpy()", "\n", "# np.savetxt('vote4.txt',new_features_cpu[0:4,i,:])", "\n", "idx", "=", "torch", ".", "arange", "(", "new_features", ".", "size", "(", "0", ")", ")", "\n", "new_features", "=", "new_features", "[", "idx", ",", ":", ",", "score_id", ",", ":", "]", "\n", "# B*C*nsample", "\n", "new_features", "=", "new_features", ".", "unsqueeze", "(", "2", ")", "\n", "# B*C*1*nsample", "\n", "new_xyz", "=", "new_xyz", "[", "idx", ",", "score_id", ",", ":", "]", "\n", "# B*3", "\n", "\n", "new_features", "=", "self", ".", "mlps", "[", "i", "]", "(", "new_features", ")", "# (B, mlp[-1], npoint, nsample)", "\n", "new_features", "=", "F", ".", "max_pool2d", "(", "\n", "new_features", ",", "kernel_size", "=", "[", "1", ",", "new_features", ".", "size", "(", "3", ")", "]", "\n", ")", "# (B, mlp[-1], npoint, 1)", "\n", "new_features", "=", "new_features", ".", "squeeze", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", "# (B, mlp[-1])", "\n", "\n", "new_features_list", ".", "append", "(", "new_features", ")", "\n", "\n", "", "return", "new_xyz", ",", "torch", ".", "cat", "(", "new_features_list", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.pointnet2_modules.PointNet2FPModule.__init__": [[229, 232], ["torch.Module.__init__", "etw_pytorch_utils.SharedMLP"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ",", "*", ",", "mlp", ":", "List", "[", "int", "]", ",", "bn", ":", "bool", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mlp", "=", "pt_util", ".", "SharedMLP", "(", "mlp", ",", "bn", "=", "bn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.pointnet2_modules.PointNet2FPModule.forward": [[233, 265], ["pointnet2_modules.PointNet2FPModule.mlp().squeeze", "lib.pointops.functions.pointops.nearestneighbor", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "lib.pointops.functions.pointops.interpolation", "known_feats.expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "unknown.size", "pointnet2_modules.PointNet2FPModule.mlp", "torch.cat.unsqueeze", "torch.cat.unsqueeze", "torch.cat.unsqueeze", "known_feats.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "unknown", ":", "torch", ".", "Tensor", ",", "known", ":", "torch", ".", "Tensor", ",", "unknow_feats", ":", "torch", ".", "Tensor", ",", "known_feats", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "r\"\"\"\n        Parameters\n        ----------\n        unknown : torch.Tensor\n            (B, n, 3) tensor of the xyz positions of the unknown features\n        known : torch.Tensor\n            (B, m, 3) tensor of the xyz positions of the known features\n        unknow_feats : torch.Tensor\n            (B, C1, n) tensor of the features to be propigated to\n        known_feats : torch.Tensor\n            (B, C2, m) tensor of features to be propigated\n        Returns\n        -------\n        new_features : torch.Tensor\n            (B, mlp[-1], n) tensor of the features of the unknown features\n        \"\"\"", "\n", "\n", "if", "known", "is", "not", "None", ":", "\n", "            ", "dist", ",", "idx", "=", "pointops", ".", "nearestneighbor", "(", "unknown", ",", "known", ")", "\n", "dist_recip", "=", "1.0", "/", "(", "dist", "+", "1e-8", ")", "\n", "norm", "=", "torch", ".", "sum", "(", "dist_recip", ",", "dim", "=", "2", ",", "keepdim", "=", "True", ")", "\n", "weight", "=", "dist_recip", "/", "norm", "\n", "interpolated_feats", "=", "pointops", ".", "interpolation", "(", "known_feats", ",", "idx", ",", "weight", ")", "\n", "", "else", ":", "\n", "            ", "interpolated_feats", "=", "known_feats", ".", "expand", "(", "*", "known_feats", ".", "size", "(", ")", "[", "0", ":", "2", "]", ",", "unknown", ".", "size", "(", "1", ")", ")", "\n", "\n", "", "if", "unknow_feats", "is", "not", "None", ":", "\n", "            ", "new_features", "=", "torch", ".", "cat", "(", "[", "interpolated_feats", ",", "unknow_feats", "]", ",", "dim", "=", "1", ")", "# (B, C2 + C1, n)", "\n", "", "else", ":", "\n", "            ", "new_features", "=", "interpolated_feats", "\n", "", "return", "self", ".", "mlp", "(", "new_features", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.linalg_utils.pdist2": [[15, 64], ["torch.abs().squeeze", "X.unsqueeze.dim", "X.unsqueeze.unsqueeze", "numpy.matmul", "R.transpose.transpose", "numpy.matmul", "X.unsqueeze.dim", "X.unsqueeze.unsqueeze", "numpy.matmul", "S.transpose.transpose", "numpy.matmul", "torch.abs", "Z.unsqueeze.transpose", "Z.unsqueeze.dim", "Z.unsqueeze.unsqueeze", "Z.unsqueeze.transpose", "X.unsqueeze.transpose", "Z.unsqueeze.dim", "Z.unsqueeze.unsqueeze", "X.unsqueeze.transpose"], "function", ["None"], ["def", "pdist2", "(", "X", ",", "Z", "=", "None", ",", "order", "=", "PDist2Order", ".", "d_second", ")", ":", "\n", "# type: (torch.Tensor, torch.Tensor, PDist2Order) -> torch.Tensor", "\n", "    ", "r\"\"\" Calculates the pairwise distance between X and Z\n\n    D[b, i, j] = l2 distance X[b, i] and Z[b, j]\n\n    Parameters\n    ---------\n    X : torch.Tensor\n        X is a (B, N, d) tensor.  There are B batches, and N vectors of dimension d\n    Z: torch.Tensor\n        Z is a (B, M, d) tensor.  If Z is None, then Z = X\n\n    Returns\n    -------\n    torch.Tensor\n        Distance matrix is size (B, N, M)\n    \"\"\"", "\n", "\n", "if", "order", "==", "PDist2Order", ".", "d_second", ":", "\n", "        ", "if", "X", ".", "dim", "(", ")", "==", "2", ":", "\n", "            ", "X", "=", "X", ".", "unsqueeze", "(", "0", ")", "\n", "", "if", "Z", "is", "None", ":", "\n", "            ", "Z", "=", "X", "\n", "G", "=", "np", ".", "matmul", "(", "X", ",", "Z", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ")", "\n", "S", "=", "(", "X", "*", "X", ")", ".", "sum", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "R", "=", "S", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "if", "Z", ".", "dim", "(", ")", "==", "2", ":", "\n", "                ", "Z", "=", "Z", ".", "unsqueeze", "(", "0", ")", "\n", "", "G", "=", "np", ".", "matmul", "(", "X", ",", "Z", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ")", "\n", "S", "=", "(", "X", "*", "X", ")", ".", "sum", "(", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "R", "=", "(", "Z", "*", "Z", ")", ".", "sum", "(", "-", "1", ",", "keepdim", "=", "True", ")", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "X", ".", "dim", "(", ")", "==", "2", ":", "\n", "            ", "X", "=", "X", ".", "unsqueeze", "(", "0", ")", "\n", "", "if", "Z", "is", "None", ":", "\n", "            ", "Z", "=", "X", "\n", "G", "=", "np", ".", "matmul", "(", "X", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ",", "Z", ")", "\n", "R", "=", "(", "X", "*", "X", ")", ".", "sum", "(", "-", "2", ",", "keepdim", "=", "True", ")", "\n", "S", "=", "R", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "if", "Z", ".", "dim", "(", ")", "==", "2", ":", "\n", "                ", "Z", "=", "Z", ".", "unsqueeze", "(", "0", ")", "\n", "", "G", "=", "np", ".", "matmul", "(", "X", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ",", "Z", ")", "\n", "S", "=", "(", "X", "*", "X", ")", ".", "sum", "(", "-", "2", ",", "keepdim", "=", "True", ")", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", "\n", "R", "=", "(", "Z", "*", "Z", ")", ".", "sum", "(", "-", "2", ",", "keepdim", "=", "True", ")", "\n", "\n", "", "", "return", "torch", ".", "abs", "(", "R", "+", "S", "-", "2", "*", "G", ")", ".", "squeeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.utils.linalg_utils.pdist2_slow": [[66, 76], ["torch.zeros", "range", "X.size", "X.size", "Z.size", "torch.zeros.size", "range", "torch.zeros.size", "range", "torch.zeros.size", "torch.dist"], "function", ["None"], ["", "def", "pdist2_slow", "(", "X", ",", "Z", "=", "None", ")", ":", "\n", "    ", "if", "Z", "is", "None", ":", "\n", "        ", "Z", "=", "X", "\n", "", "D", "=", "torch", ".", "zeros", "(", "X", ".", "size", "(", "0", ")", ",", "X", ".", "size", "(", "2", ")", ",", "Z", ".", "size", "(", "2", ")", ")", "\n", "\n", "for", "b", "in", "range", "(", "D", ".", "size", "(", "0", ")", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "D", ".", "size", "(", "1", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "D", ".", "size", "(", "2", ")", ")", ":", "\n", "                ", "D", "[", "b", ",", "i", ",", "j", "]", "=", "torch", ".", "dist", "(", "X", "[", "b", ",", ":", ",", "i", "]", ",", "Z", "[", "b", ",", ":", ",", "j", "]", ")", "\n", "", "", "", "return", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.render_images.render_images": [[17, 139], ["os.path.expanduser", "random.shuffle", "print", "tqdm.tqdm", "os.path.isdir", "os.makedirs", "collections.defaultdict", "nuim.get", "nuim.get", "nuim.shortcut", "nuim.get_sample_content", "nuim.get", "nuim.shortcut", "nuim.get", "nuim.get", "nuim.get", "sd_to_object_cat_names[].add", "nuim.get", "any", "print", "os.path.join", "Exception", "sample_tokens_cam.append", "sample_tokens_cleaned.append", "set", "sample_tokens_cleaned.append", "len", "render_images.write_image", "render_images.write_video"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.shortcut", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_sample_content", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.shortcut", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.render_images.write_image", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.render_images.write_video"], ["def", "render_images", "(", "nuim", ":", "NuImages", ",", "\n", "mode", ":", "str", "=", "'all'", ",", "\n", "cam_name", ":", "str", "=", "None", ",", "\n", "log_name", ":", "str", "=", "None", ",", "\n", "sample_limit", ":", "int", "=", "50", ",", "\n", "filter_categories", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "out_type", ":", "str", "=", "'image'", ",", "\n", "out_dir", ":", "str", "=", "'~/Downloads/nuImages'", ",", "\n", "cleanup", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Render a random selection of images and save them to disk.\n    Note: The images rendered here are keyframes only.\n    :param nuim: NuImages instance.\n    :param mode: What to render:\n      \"image\" for the image without annotations,\n      \"annotated\" for the image with annotations,\n      \"trajectory\" for a rendering of the trajectory of the vehice,\n      \"all\" to render all of the above separately.\n    :param cam_name: Only render images from a particular camera, e.g. \"CAM_BACK'.\n    :param log_name: Only render images from a particular log, e.g. \"n013-2018-09-04-13-30-50+0800\".\n    :param sample_limit: Maximum number of samples (images) to render. Note that the mini split only includes 50 images.\n    :param filter_categories: Specify a list of object_ann category names. Every sample that is rendered must\n        contain annotations of any of those categories.\n    :param out_type: The output type as one of the following:\n        'image': Renders a single image for the image keyframe of each sample.\n        'video': Renders a video for all images/pcls in the clip associated with each sample.\n    :param out_dir: Folder to render the images to.\n    :param cleanup: Whether to delete images after rendering the video. Not relevant for out_type == 'image'.\n    \"\"\"", "\n", "# Check and convert inputs.", "\n", "assert", "out_type", "in", "[", "'image'", ",", "'video'", "]", ",", "' Error: Unknown out_type %s!'", "%", "out_type", "\n", "all_modes", "=", "[", "'image'", ",", "'annotated'", ",", "'trajectory'", "]", "\n", "assert", "mode", "in", "all_modes", "+", "[", "'all'", "]", ",", "'Error: Unknown mode %s!'", "%", "mode", "\n", "assert", "not", "(", "out_type", "==", "'video'", "and", "mode", "==", "'trajectory'", ")", ",", "'Error: Cannot render \"trajectory\" for videos!'", "\n", "\n", "if", "mode", "==", "'all'", ":", "\n", "        ", "if", "out_type", "==", "'image'", ":", "\n", "            ", "modes", "=", "all_modes", "\n", "", "elif", "out_type", "==", "'video'", ":", "\n", "            ", "modes", "=", "[", "m", "for", "m", "in", "all_modes", "if", "m", "not", "in", "[", "'annotated'", ",", "'trajectory'", "]", "]", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Error\" Unknown mode %s!'", "%", "mode", ")", "\n", "", "", "else", ":", "\n", "        ", "modes", "=", "[", "mode", "]", "\n", "\n", "", "if", "filter_categories", "is", "not", "None", ":", "\n", "        ", "category_names", "=", "[", "c", "[", "'name'", "]", "for", "c", "in", "nuim", ".", "category", "]", "\n", "for", "category_name", "in", "filter_categories", ":", "\n", "            ", "assert", "category_name", "in", "category_names", ",", "'Error: Invalid object_ann category %s!'", "%", "category_name", "\n", "\n", "# Create output folder.", "\n", "", "", "out_dir", "=", "os", ".", "path", ".", "expanduser", "(", "out_dir", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "out_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "\n", "# Filter by camera.", "\n", "", "sample_tokens", "=", "[", "s", "[", "'token'", "]", "for", "s", "in", "nuim", ".", "sample", "]", "\n", "if", "cam_name", "is", "not", "None", ":", "\n", "        ", "sample_tokens_cam", "=", "[", "]", "\n", "for", "sample_token", "in", "sample_tokens", ":", "\n", "            ", "sample", "=", "nuim", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "key_camera_token", "=", "sample", "[", "'key_camera_token'", "]", "\n", "sensor", "=", "nuim", ".", "shortcut", "(", "'sample_data'", ",", "'sensor'", ",", "key_camera_token", ")", "\n", "if", "sensor", "[", "'channel'", "]", "==", "cam_name", ":", "\n", "                ", "sample_tokens_cam", ".", "append", "(", "sample_token", ")", "\n", "", "", "sample_tokens", "=", "sample_tokens_cam", "\n", "\n", "# Filter by log.", "\n", "", "if", "log_name", "is", "not", "None", ":", "\n", "        ", "sample_tokens_cleaned", "=", "[", "]", "\n", "for", "sample_token", "in", "sample_tokens", ":", "\n", "            ", "sample", "=", "nuim", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "log", "=", "nuim", ".", "get", "(", "'log'", ",", "sample", "[", "'log_token'", "]", ")", "\n", "if", "log", "[", "'logfile'", "]", "==", "log_name", ":", "\n", "                ", "sample_tokens_cleaned", ".", "append", "(", "sample_token", ")", "\n", "", "", "sample_tokens", "=", "sample_tokens_cleaned", "\n", "\n", "# Filter samples by category.", "\n", "", "if", "filter_categories", "is", "not", "None", ":", "\n", "# Get categories in each sample.", "\n", "        ", "sd_to_object_cat_names", "=", "defaultdict", "(", "lambda", ":", "set", "(", ")", ")", "\n", "for", "object_ann", "in", "nuim", ".", "object_ann", ":", "\n", "            ", "category", "=", "nuim", ".", "get", "(", "'category'", ",", "object_ann", "[", "'category_token'", "]", ")", "\n", "sd_to_object_cat_names", "[", "object_ann", "[", "'sample_data_token'", "]", "]", ".", "add", "(", "category", "[", "'name'", "]", ")", "\n", "\n", "# Filter samples.", "\n", "", "sample_tokens_cleaned", "=", "[", "]", "\n", "for", "sample_token", "in", "sample_tokens", ":", "\n", "            ", "sample", "=", "nuim", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "key_camera_token", "=", "sample", "[", "'key_camera_token'", "]", "\n", "category_names", "=", "sd_to_object_cat_names", "[", "key_camera_token", "]", "\n", "if", "any", "(", "[", "c", "in", "category_names", "for", "c", "in", "filter_categories", "]", ")", ":", "\n", "                ", "sample_tokens_cleaned", ".", "append", "(", "sample_token", ")", "\n", "", "", "sample_tokens", "=", "sample_tokens_cleaned", "\n", "\n", "# Get a random selection of samples.", "\n", "", "random", ".", "shuffle", "(", "sample_tokens", ")", "\n", "\n", "# Limit number of samples.", "\n", "sample_tokens", "=", "sample_tokens", "[", ":", "sample_limit", "]", "\n", "\n", "print", "(", "'Rendering %s for mode %s to folder %s...'", "%", "(", "out_type", ",", "mode", ",", "out_dir", ")", ")", "\n", "for", "sample_token", "in", "tqdm", ".", "tqdm", "(", "sample_tokens", ")", ":", "\n", "        ", "sample", "=", "nuim", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "log", "=", "nuim", ".", "get", "(", "'log'", ",", "sample", "[", "'log_token'", "]", ")", "\n", "log_name", "=", "log", "[", "'logfile'", "]", "\n", "key_camera_token", "=", "sample", "[", "'key_camera_token'", "]", "\n", "sensor", "=", "nuim", ".", "shortcut", "(", "'sample_data'", ",", "'sensor'", ",", "key_camera_token", ")", "\n", "sample_cam_name", "=", "sensor", "[", "'channel'", "]", "\n", "sd_tokens", "=", "nuim", ".", "get_sample_content", "(", "sample_token", ")", "\n", "\n", "# We cannot render a video if there are missing camera sample_datas.", "\n", "if", "len", "(", "sd_tokens", ")", "<", "13", "and", "out_type", "==", "'video'", ":", "\n", "            ", "print", "(", "'Warning: Skipping video for sample token %s, as not all 13 frames exist!'", "%", "sample_token", ")", "\n", "continue", "\n", "\n", "", "for", "mode", "in", "modes", ":", "\n", "            ", "out_path_prefix", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "'%s_%s_%s_%s'", "%", "(", "log_name", ",", "sample_token", ",", "sample_cam_name", ",", "mode", ")", ")", "\n", "if", "out_type", "==", "'image'", ":", "\n", "                ", "write_image", "(", "nuim", ",", "key_camera_token", ",", "mode", ",", "'%s.jpg'", "%", "out_path_prefix", ")", "\n", "", "elif", "out_type", "==", "'video'", ":", "\n", "                ", "write_video", "(", "nuim", ",", "sd_tokens", ",", "mode", ",", "out_path_prefix", ",", "cleanup", "=", "cleanup", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.render_images.write_video": [[141, 179], ["enumerate", "cv2.imread", "cv2.VideoWriter_fourcc", "cv2.VideoWriter", "cv2.VideoWriter.release", "out_paths.append", "render_images.write_image", "cv2.imread", "cv2.VideoWriter.write", "os.remove"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.scripts.render_images.write_image"], ["", "", "", "", "def", "write_video", "(", "nuim", ":", "NuImages", ",", "\n", "sd_tokens", ":", "List", "[", "str", "]", ",", "\n", "mode", ":", "str", ",", "\n", "out_path_prefix", ":", "str", ",", "\n", "cleanup", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Render a video by combining all the images of type mode for each sample_data.\n    :param nuim: NuImages instance.\n    :param sd_tokens: All sample_data tokens in chronological order.\n    :param mode: The mode - see render_images().\n    :param out_path_prefix: The file prefix used for the images and video.\n    :param cleanup: Whether to delete images after rendering the video.\n    \"\"\"", "\n", "# Loop through each frame to create the video.", "\n", "out_paths", "=", "[", "]", "\n", "for", "i", ",", "sd_token", "in", "enumerate", "(", "sd_tokens", ")", ":", "\n", "        ", "out_path", "=", "'%s_%d.jpg'", "%", "(", "out_path_prefix", ",", "i", ")", "\n", "out_paths", ".", "append", "(", "out_path", ")", "\n", "write_image", "(", "nuim", ",", "sd_token", ",", "mode", ",", "out_path", ")", "\n", "\n", "# Create video.", "\n", "", "first_im", "=", "cv2", ".", "imread", "(", "out_paths", "[", "0", "]", ")", "\n", "freq", "=", "2", "# Display frequency (Hz).", "\n", "fourcc", "=", "cv2", ".", "VideoWriter_fourcc", "(", "*", "'MJPG'", ")", "\n", "video_path", "=", "'%s.avi'", "%", "out_path_prefix", "\n", "out", "=", "cv2", ".", "VideoWriter", "(", "video_path", ",", "fourcc", ",", "freq", ",", "first_im", ".", "shape", "[", "1", ":", ":", "-", "1", "]", ")", "\n", "\n", "# Load each image and add to the video.", "\n", "for", "out_path", "in", "out_paths", ":", "\n", "        ", "im", "=", "cv2", ".", "imread", "(", "out_path", ")", "\n", "out", ".", "write", "(", "im", ")", "\n", "\n", "# Delete temporary image if requested.", "\n", "if", "cleanup", ":", "\n", "            ", "os", ".", "remove", "(", "out_path", ")", "\n", "\n", "# Finalize video.", "\n", "", "", "out", ".", "release", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.render_images.write_image": [[181, 201], ["gc.collect", "nuim.render_image", "nuim.render_image", "nuim.get", "nuim.render_trajectory", "Exception"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.render_image", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.render_image", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.render_trajectory"], ["", "def", "write_image", "(", "nuim", ":", "NuImages", ",", "sd_token", ":", "str", ",", "mode", ":", "str", ",", "out_path", ":", "str", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Render a single image of type mode for the given sample_data.\n    :param nuim: NuImages instance.\n    :param sd_token: The sample_data token.\n    :param mode: The mode - see render_images().\n    :param out_path: The file to write the image to.\n    \"\"\"", "\n", "if", "mode", "==", "'annotated'", ":", "\n", "        ", "nuim", ".", "render_image", "(", "sd_token", ",", "annotation_type", "=", "'all'", ",", "out_path", "=", "out_path", ")", "\n", "", "elif", "mode", "==", "'image'", ":", "\n", "        ", "nuim", ".", "render_image", "(", "sd_token", ",", "annotation_type", "=", "'none'", ",", "out_path", "=", "out_path", ")", "\n", "", "elif", "mode", "==", "'trajectory'", ":", "\n", "        ", "sample_data", "=", "nuim", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "\n", "nuim", ".", "render_trajectory", "(", "sample_data", "[", "'sample_token'", "]", ",", "out_path", "=", "out_path", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Error: Unknown mode %s!'", "%", "mode", ")", "\n", "\n", "# Trigger garbage collection to avoid memory overflow from the render functions.", "\n", "", "gc", ".", "collect", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.render_rare_classes.render_rare_classes": [[13, 54], ["collections.defaultdict", "len", "sorted", "print", "nuimages.scripts.render_images.render_images", "render_args.keys", "nuim.get", "len", "list", "set().intersection", "len", "collections.defaultdict.items", "set", "set"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.scripts.render_images.render_images", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["def", "render_rare_classes", "(", "nuim", ":", "NuImages", ",", "\n", "render_args", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "filter_categories", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "max_frequency", ":", "float", "=", "0.1", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Wrapper around render_images() that renders images with rare classes.\n    :param nuim: NuImages instance.\n    :param render_args: The render arguments passed on to the render function. See render_images().\n    :param filter_categories: Specify a list of object_ann category names.\n        Every sample that is rendered must contain annotations of any of those categories.\n        Filter_categories are a applied on top of the frequency filering.\n    :param max_frequency: The maximum relative frequency of the categories, at least one of which is required to be\n        present in the image. E.g. 0.1 indicates that one of the classes that account for at most 10% of the annotations\n        is present.\n    \"\"\"", "\n", "# Checks.", "\n", "assert", "'filter_categories'", "not", "in", "render_args", ".", "keys", "(", ")", ",", "'Error: filter_categories is a separate argument and should not be part of render_args!'", "\n", "assert", "0", "<=", "max_frequency", "<=", "1", ",", "'Error: max_frequency must be a ratio between 0 and 1!'", "\n", "\n", "# Compute object class frequencies.", "\n", "object_freqs", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "for", "object_ann", "in", "nuim", ".", "object_ann", ":", "\n", "        ", "category", "=", "nuim", ".", "get", "(", "'category'", ",", "object_ann", "[", "'category_token'", "]", ")", "\n", "object_freqs", "[", "category", "[", "'name'", "]", "]", "+=", "1", "\n", "\n", "# Find rare classes.", "\n", "", "total_freqs", "=", "len", "(", "nuim", ".", "object_ann", ")", "\n", "filter_categories_freq", "=", "sorted", "(", "[", "k", "for", "(", "k", ",", "v", ")", "in", "object_freqs", ".", "items", "(", ")", "if", "v", "/", "total_freqs", "<=", "max_frequency", "]", ")", "\n", "assert", "len", "(", "filter_categories_freq", ")", ">", "0", ",", "'Error: No classes found with the specified max_frequency!'", "\n", "print", "(", "'The rare classes are: %s'", "%", "filter_categories_freq", ")", "\n", "\n", "# If specified, additionally filter these categories by what was requested.", "\n", "if", "filter_categories", "is", "None", ":", "\n", "        ", "filter_categories", "=", "filter_categories_freq", "\n", "", "else", ":", "\n", "        ", "filter_categories", "=", "list", "(", "set", "(", "filter_categories_freq", ")", ".", "intersection", "(", "set", "(", "filter_categories", ")", ")", ")", "\n", "assert", "len", "(", "filter_categories", ")", ">", "0", ",", "'Error: No categories left after applying filter_categories!'", "\n", "\n", "# Call render function.", "\n", "", "render_images", "(", "nuim", ",", "filter_categories", "=", "filter_categories", ",", "**", "render_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_pointclouds_as_obj.export_scene_pointcloud": [[24, 111], ["nusc.get", "nusc.get", "nusc.get", "nusc.get", "sd_tokens.append", "open", "f.write", "tqdm.tqdm", "nusc.get", "nusc.get", "nusc.get", "nuscenes.utils.data_classes.LidarPointCloud.from_file", "nusc.get", "LidarPointCloud.from_file.rotate", "LidarPointCloud.from_file.translate", "numpy.sqrt", "numpy.logical_and", "nusc.get", "LidarPointCloud.from_file.rotate", "LidarPointCloud.from_file.translate", "zip", "print", "os.join", "numpy.ones", "export_pointclouds_as_obj.pointcloud_color_from_image", "numpy.array", "numpy.sum", "print", "numpy.array", "LidarPointCloud.from_file.points.transpose", "coloring.transpose", "nusc.get", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "f.write", "np.logical_and.sum", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_pointclouds_as_obj.pointcloud_color_from_image", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["def", "export_scene_pointcloud", "(", "nusc", ":", "NuScenes", ",", "\n", "out_path", ":", "str", ",", "\n", "scene_token", ":", "str", ",", "\n", "channel", ":", "str", "=", "'LIDAR_TOP'", ",", "\n", "min_dist", ":", "float", "=", "3.0", ",", "\n", "max_dist", ":", "float", "=", "30.0", ",", "\n", "verbose", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Export fused point clouds of a scene to a Wavefront OBJ file.\n    This pointcloud can be viewed in your favorite 3D rendering tool, e.g. Meshlab or Maya.\n    :param nusc: NuScenes instance.\n    :param out_path: Output path to write the pointcloud to.\n    :param scene_token: Unique identifier of scene to render.\n    :param channel: Channel to render.\n    :param min_dist: Minimum distance to ego vehicle below which points are dropped.\n    :param max_dist: Maximum distance to ego vehicle above which points are dropped.\n    :param verbose: Whether to print messages to stdout.\n    \"\"\"", "\n", "\n", "# Check inputs.", "\n", "valid_channels", "=", "[", "'LIDAR_TOP'", ",", "'RADAR_FRONT'", ",", "'RADAR_FRONT_RIGHT'", ",", "'RADAR_FRONT_LEFT'", ",", "'RADAR_BACK_LEFT'", ",", "\n", "'RADAR_BACK_RIGHT'", "]", "\n", "camera_channels", "=", "[", "'CAM_FRONT_LEFT'", ",", "'CAM_FRONT'", ",", "'CAM_FRONT_RIGHT'", ",", "'CAM_BACK_LEFT'", ",", "'CAM_BACK'", ",", "'CAM_BACK_RIGHT'", "]", "\n", "assert", "channel", "in", "valid_channels", ",", "'Input channel {} not valid.'", ".", "format", "(", "channel", ")", "\n", "\n", "# Get records from DB.", "\n", "scene_rec", "=", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "start_sample_rec", "=", "nusc", ".", "get", "(", "'sample'", ",", "scene_rec", "[", "'first_sample_token'", "]", ")", "\n", "sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "start_sample_rec", "[", "'data'", "]", "[", "channel", "]", ")", "\n", "\n", "# Make list of frames", "\n", "cur_sd_rec", "=", "sd_rec", "\n", "sd_tokens", "=", "[", "]", "\n", "while", "cur_sd_rec", "[", "'next'", "]", "!=", "''", ":", "\n", "        ", "cur_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "cur_sd_rec", "[", "'next'", "]", ")", "\n", "sd_tokens", ".", "append", "(", "cur_sd_rec", "[", "'token'", "]", ")", "\n", "\n", "# Write pointcloud.", "\n", "", "with", "open", "(", "out_path", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "\"OBJ File:\\n\"", ")", "\n", "\n", "for", "sd_token", "in", "tqdm", "(", "sd_tokens", ")", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "'Processing {}'", ".", "format", "(", "sd_rec", "[", "'filename'", "]", ")", ")", "\n", "", "sc_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "\n", "sample_rec", "=", "nusc", ".", "get", "(", "'sample'", ",", "sc_rec", "[", "'sample_token'", "]", ")", "\n", "lidar_token", "=", "sd_rec", "[", "'token'", "]", "\n", "lidar_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "lidar_token", ")", "\n", "pc", "=", "LidarPointCloud", ".", "from_file", "(", "osp", ".", "join", "(", "nusc", ".", "dataroot", ",", "lidar_rec", "[", "'filename'", "]", ")", ")", "\n", "\n", "# Get point cloud colors.", "\n", "coloring", "=", "np", ".", "ones", "(", "(", "3", ",", "pc", ".", "points", ".", "shape", "[", "1", "]", ")", ")", "*", "-", "1", "\n", "for", "channel", "in", "camera_channels", ":", "\n", "                ", "camera_token", "=", "sample_rec", "[", "'data'", "]", "[", "channel", "]", "\n", "cam_coloring", ",", "cam_mask", "=", "pointcloud_color_from_image", "(", "nusc", ",", "lidar_token", ",", "camera_token", ")", "\n", "coloring", "[", ":", ",", "cam_mask", "]", "=", "cam_coloring", "\n", "\n", "# Points live in their own reference frame. So they need to be transformed via global to the image plane.", "\n", "# First step: transform the point cloud to the ego vehicle frame for the timestamp of the sweep.", "\n", "", "cs_record", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "lidar_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "cs_record", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ")", "\n", "pc", ".", "translate", "(", "np", ".", "array", "(", "cs_record", "[", "'translation'", "]", ")", ")", "\n", "\n", "# Optional Filter by distance to remove the ego vehicle.", "\n", "dists_origin", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "pc", ".", "points", "[", ":", "3", ",", ":", "]", "**", "2", ",", "axis", "=", "0", ")", ")", "\n", "keep", "=", "np", ".", "logical_and", "(", "min_dist", "<=", "dists_origin", ",", "dists_origin", "<=", "max_dist", ")", "\n", "pc", ".", "points", "=", "pc", ".", "points", "[", ":", ",", "keep", "]", "\n", "coloring", "=", "coloring", "[", ":", ",", "keep", "]", "\n", "if", "verbose", ":", "\n", "                ", "print", "(", "'Distance filter: Keeping %d of %d points...'", "%", "(", "keep", ".", "sum", "(", ")", ",", "len", "(", "keep", ")", ")", ")", "\n", "\n", "# Second step: transform to the global frame.", "\n", "", "poserecord", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "lidar_rec", "[", "'ego_pose_token'", "]", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "poserecord", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ")", "\n", "pc", ".", "translate", "(", "np", ".", "array", "(", "poserecord", "[", "'translation'", "]", ")", ")", "\n", "\n", "# Write points to file", "\n", "for", "(", "v", ",", "c", ")", "in", "zip", "(", "pc", ".", "points", ".", "transpose", "(", ")", ",", "coloring", ".", "transpose", "(", ")", ")", ":", "\n", "                ", "if", "(", "c", "==", "-", "1", ")", ".", "any", "(", ")", ":", "\n", "# Ignore points without a color.", "\n", "                    ", "pass", "\n", "", "else", ":", "\n", "                    ", "f", ".", "write", "(", "\"v {v[0]:.8f} {v[1]:.8f} {v[2]:.8f} {c[0]:.4f} {c[1]:.4f} {c[2]:.4f}\\n\"", "\n", ".", "format", "(", "v", "=", "v", ",", "c", "=", "c", "/", "255.0", ")", ")", "\n", "\n", "", "", "if", "not", "sd_rec", "[", "'next'", "]", "==", "\"\"", ":", "\n", "                ", "sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sd_rec", "[", "'next'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_pointclouds_as_obj.pointcloud_color_from_image": [[113, 177], ["nusc.get", "nusc.get", "nuscenes.utils.data_classes.LidarPointCloud.from_file", "PIL.Image.open", "nusc.get", "LidarPointCloud.from_file.rotate", "LidarPointCloud.from_file.translate", "nusc.get", "LidarPointCloud.from_file.rotate", "LidarPointCloud.from_file.translate", "nusc.get", "LidarPointCloud.from_file.translate", "LidarPointCloud.from_file.rotate", "nusc.get", "LidarPointCloud.from_file.translate", "LidarPointCloud.from_file.rotate", "nuscenes.utils.geometry_utils.view_points", "numpy.ones", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.array", "numpy.zeros", "enumerate", "os.join", "os.join", "numpy.array", "numpy.array", "numpy.array", "nuscenes.utils.geometry_utils.view_points.transpose", "p[].round().astype", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "numpy.array", "numpy.array", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "p[].round"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points"], ["", "", "", "", "def", "pointcloud_color_from_image", "(", "nusc", ":", "NuScenes", ",", "\n", "pointsensor_token", ":", "str", ",", "\n", "camera_token", ":", "str", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "    ", "\"\"\"\n    Given a point sensor (lidar/radar) token and camera sample_data token, load pointcloud and map it to the image\n    plane, then retrieve the colors of the closest image pixels.\n    :param nusc: NuScenes instance.\n    :param pointsensor_token: Lidar/radar sample_data token.\n    :param camera_token: Camera sample data token.\n    :return (coloring <np.float: 3, n>, mask <np.bool: m>). Returns the colors for n points that reproject into the\n        image out of m total points. The mask indicates which points are selected.\n    \"\"\"", "\n", "\n", "cam", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "camera_token", ")", "\n", "pointsensor", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "pointsensor_token", ")", "\n", "\n", "pc", "=", "LidarPointCloud", ".", "from_file", "(", "osp", ".", "join", "(", "nusc", ".", "dataroot", ",", "pointsensor", "[", "'filename'", "]", ")", ")", "\n", "im", "=", "Image", ".", "open", "(", "osp", ".", "join", "(", "nusc", ".", "dataroot", ",", "cam", "[", "'filename'", "]", ")", ")", "\n", "\n", "# Points live in the point sensor frame. So they need to be transformed via global to the image plane.", "\n", "# First step: transform the pointcloud to the ego vehicle frame for the timestamp of the sweep.", "\n", "cs_record", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "pointsensor", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "cs_record", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ")", "\n", "pc", ".", "translate", "(", "np", ".", "array", "(", "cs_record", "[", "'translation'", "]", ")", ")", "\n", "\n", "# Second step: transform to the global frame.", "\n", "poserecord", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "pointsensor", "[", "'ego_pose_token'", "]", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "poserecord", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ")", "\n", "pc", ".", "translate", "(", "np", ".", "array", "(", "poserecord", "[", "'translation'", "]", ")", ")", "\n", "\n", "# Third step: transform into the ego vehicle frame for the timestamp of the image.", "\n", "poserecord", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "cam", "[", "'ego_pose_token'", "]", ")", "\n", "pc", ".", "translate", "(", "-", "np", ".", "array", "(", "poserecord", "[", "'translation'", "]", ")", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "poserecord", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ".", "T", ")", "\n", "\n", "# Fourth step: transform into the camera.", "\n", "cs_record", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "cam", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pc", ".", "translate", "(", "-", "np", ".", "array", "(", "cs_record", "[", "'translation'", "]", ")", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "cs_record", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ".", "T", ")", "\n", "\n", "# Fifth step: actually take a \"picture\" of the point cloud.", "\n", "# Grab the depths (camera frame z axis points away from the camera).", "\n", "depths", "=", "pc", ".", "points", "[", "2", ",", ":", "]", "\n", "\n", "# Take the actual picture (matrix multiplication with camera-matrix + renormalization).", "\n", "points", "=", "view_points", "(", "pc", ".", "points", "[", ":", "3", ",", ":", "]", ",", "np", ".", "array", "(", "cs_record", "[", "'camera_intrinsic'", "]", ")", ",", "normalize", "=", "True", ")", "\n", "\n", "# Remove points that are either outside or behind the camera. Leave a margin of 1 pixel for aesthetic reasons.", "\n", "mask", "=", "np", ".", "ones", "(", "depths", ".", "shape", "[", "0", "]", ",", "dtype", "=", "bool", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "depths", ">", "0", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "points", "[", "0", ",", ":", "]", ">", "1", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "points", "[", "0", ",", ":", "]", "<", "im", ".", "size", "[", "0", "]", "-", "1", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "points", "[", "1", ",", ":", "]", ">", "1", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "points", "[", "1", ",", ":", "]", "<", "im", ".", "size", "[", "1", "]", "-", "1", ")", "\n", "points", "=", "points", "[", ":", ",", "mask", "]", "\n", "\n", "# Pick the colors of the points", "\n", "im_data", "=", "np", ".", "array", "(", "im", ")", "\n", "coloring", "=", "np", ".", "zeros", "(", "points", ".", "shape", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "points", ".", "transpose", "(", ")", ")", ":", "\n", "        ", "point", "=", "p", "[", ":", "2", "]", ".", "round", "(", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "coloring", "[", ":", ",", "i", "]", "=", "im_data", "[", "point", "[", "1", "]", ",", "point", "[", "0", "]", ",", ":", "]", "\n", "\n", "", "return", "coloring", ",", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_kitti.KittiConverter.__init__": [[61, 90], ["os.path.expanduser", "nuscenes.NuScenes", "os.path.isdir", "os.makedirs"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "nusc_dir", ":", "str", "=", "'/opt/data/common/datasets/nuScenes'", ",", "\n", "nusc_kitti_dir", ":", "str", "=", "'./nusc_kitti_all/'", ",", "\n", "cam_name", ":", "str", "=", "'CAM_FRONT'", ",", "\n", "lidar_name", ":", "str", "=", "'LIDAR_TOP'", ",", "\n", "image_count", ":", "int", "=", "10", ",", "\n", "nusc_version", ":", "str", "=", "'v1.0-trainval'", ",", "\n", "split", ":", "str", "=", "'train_track'", ")", ":", "\n", "        ", "\"\"\"\n        :param nusc_kitti_dir: Where to write the KITTI-style annotations.\n        :param cam_name: Name of the camera to export. Note that only one camera is allowed in KITTI.\n        :param lidar_name: Name of the lidar sensor.\n        :param image_count: Number of images to convert.\n        :param nusc_version: nuScenes version to use.\n        :param split: Dataset split to use.\n        \"\"\"", "\n", "self", ".", "nusc_kitti_dir", "=", "os", ".", "path", ".", "expanduser", "(", "nusc_kitti_dir", ")", "\n", "self", ".", "cam_name", "=", "cam_name", "\n", "self", ".", "lidar_name", "=", "lidar_name", "\n", "self", ".", "image_count", "=", "image_count", "\n", "self", ".", "nusc_version", "=", "nusc_version", "\n", "self", ".", "split", "=", "split", "\n", "\n", "# Create nusc_kitti_dir.", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "nusc_kitti_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "nusc_kitti_dir", ")", "\n", "\n", "# Select subset of the data to look at.", "\n", "", "self", ".", "nusc", "=", "NuScenes", "(", "version", "=", "nusc_version", ",", "dataroot", "=", "nusc_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_kitti.KittiConverter.nuscenes_gt_to_kitti": [[91, 268], ["pyquaternion.Quaternion", "utils.splits.create_splits_logs", "dict", "enumerate", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "export_kitti.KittiConverter.nusc.get", "export_kitti.KittiConverter.nusc.get", "os.path.isdir", "os.makedirs", "export_kitti.KittiConverter.nusc.get", "export_kitti.KittiConverter.nusc.get", "export_kitti.KittiConverter.nusc.get", "export_kitti.KittiConverter.nusc.get", "export_kitti.KittiConverter.nusc.get", "export_kitti.KittiConverter.nusc.get", "utils.geometry_utils.transform_matrix", "utils.geometry_utils.transform_matrix", "numpy.dot", "numpy.dot", "numpy.zeros", "pyquaternion.Quaternion", "numpy.zeros", "os.path.join", "os.path.join", "utils.data_classes.LidarPointCloud.from_file", "utils.data_classes.LidarPointCloud.from_file.rotate", "dict", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.hstack", "os.path.join", "os.path.join", "os.path.isdir", "os.makedirs", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "os.path.join.endswith", "open", "utils.data_classes.LidarPointCloud.from_file.points.T.tofile", "os.path.exists", "os.path.exists", "print", "open", "export_kitti.KittiConverter.nusc.get_sample_data", "velo_to_cam_trans.reshape", "open", "dict.items", "export_kitti.KittiConverter.nusc.get", "export_kitti.KittiConverter.nusc.getind", "eval.detection.utils.category_to_detection_name", "utils.kitti.KittiDB.box_nuscenes_to_kitti", "utils.kitti.KittiDB.project_kitti_box_to_image", "utils.kitti.KittiDB.box_to_string", "label_file.write", "velo_to_cam_rot.round", "numpy.array", "val.flatten.flatten.flatten", "calib_file.write", "pyquaternion.Quaternion"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_logs", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.transform_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.transform_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.getind", "home.repos.pwc.inspect_result.fpthink_v2b.detection.utils.category_to_detection_name", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.box_nuscenes_to_kitti", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.project_kitti_box_to_image", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti.KittiDB.box_to_string"], ["", "def", "nuscenes_gt_to_kitti", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Converts nuScenes GT annotations to KITTI format.\n        \"\"\"", "\n", "kitti_to_nu_lidar", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "np", ".", "pi", "/", "2", ")", "\n", "kitti_to_nu_lidar_inv", "=", "kitti_to_nu_lidar", ".", "inverse", "\n", "imsize", "=", "(", "1600", ",", "900", ")", "\n", "\n", "token_idx", "=", "0", "# Start tokens from 0.", "\n", "\n", "# Get assignment of scenes to splits.", "\n", "split_logs", ",", "split_scenes_token", "=", "create_splits_logs", "(", "self", ".", "split", ",", "self", ".", "nusc", ")", "\n", "\n", "self", ".", "split_scene_token2ind", "=", "dict", "(", ")", "\n", "\n", "for", "ind", ",", "member", "in", "enumerate", "(", "split_scenes_token", ")", ":", "\n", "            ", "self", ".", "split_scene_token2ind", "[", "member", "]", "=", "ind", "\n", "\n", "# Create output folders.", "\n", "", "label_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "nusc_kitti_dir", ",", "self", ".", "split", ",", "'label_02'", ")", "\n", "calib_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "nusc_kitti_dir", ",", "self", ".", "split", ",", "'calib'", ")", "\n", "image_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "nusc_kitti_dir", ",", "self", ".", "split", ",", "'image_02'", ")", "\n", "lidar_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "nusc_kitti_dir", ",", "self", ".", "split", ",", "'velodyne'", ")", "\n", "for", "folder", "in", "[", "label_folder", ",", "calib_folder", ",", "image_folder", ",", "lidar_folder", "]", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "isdir", "(", "folder", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "folder", ")", "\n", "\n", "", "", "for", "scene", "in", "split_scenes_token", ":", "\n", "\n", "            ", "image_folder_scene", "=", "os", ".", "path", ".", "join", "(", "image_folder", ",", "'{:04}'", ".", "format", "(", "self", ".", "split_scene_token2ind", "[", "scene", "]", ")", ")", "\n", "lidar_folder_scene", "=", "os", ".", "path", ".", "join", "(", "lidar_folder", ",", "'{:04}'", ".", "format", "(", "self", ".", "split_scene_token2ind", "[", "scene", "]", ")", ")", "\n", "for", "folder", "in", "[", "image_folder_scene", ",", "lidar_folder_scene", "]", ":", "\n", "                ", "if", "not", "os", ".", "path", ".", "isdir", "(", "folder", ")", ":", "\n", "                    ", "os", ".", "makedirs", "(", "folder", ")", "\n", "", "", "sample_token", "=", "self", ".", "nusc", ".", "get", "(", "'scene'", ",", "scene", ")", "[", "'first_sample_token'", "]", "\n", "sample_last_token", "=", "self", ".", "nusc", ".", "get", "(", "'scene'", ",", "scene", ")", "[", "'last_sample_token'", "]", "\n", "frame", "=", "0", "\n", "sample", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "last_sample", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "sample_last_token", ")", "\n", "cam_front_token", "=", "sample", "[", "'data'", "]", "[", "self", ".", "cam_name", "]", "\n", "lidar_token", "=", "sample", "[", "'data'", "]", "[", "self", ".", "lidar_name", "]", "\n", "last_lidar_token", "=", "last_sample", "[", "'data'", "]", "[", "self", ".", "lidar_name", "]", "\n", "while", "lidar_token", "!=", "''", ":", "#and cam_front_token!=''", "\n", "\n", "# Retrieve sensor records.", "\n", "                ", "sd_record_cam", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "cam_front_token", ")", "\n", "sd_record_lid", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "lidar_token", ")", "\n", "cs_record_cam", "=", "self", ".", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "sd_record_cam", "[", "'calibrated_sensor_token'", "]", ")", "\n", "cs_record_lid", "=", "self", ".", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "sd_record_lid", "[", "'calibrated_sensor_token'", "]", ")", "\n", "\n", "# Combine transformations and convert to KITTI format.", "\n", "# Note: cam uses same conventions in KITTI and nuScenes.", "\n", "lid_to_ego", "=", "transform_matrix", "(", "cs_record_lid", "[", "'translation'", "]", ",", "Quaternion", "(", "cs_record_lid", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "False", ")", "\n", "ego_to_cam", "=", "transform_matrix", "(", "cs_record_cam", "[", "'translation'", "]", ",", "Quaternion", "(", "cs_record_cam", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "True", ")", "\n", "velo_to_cam", "=", "np", ".", "dot", "(", "ego_to_cam", ",", "lid_to_ego", ")", "\n", "\n", "# Convert from KITTI to nuScenes LIDAR coordinates, where we apply velo_to_cam.", "\n", "velo_to_cam_kitti", "=", "np", ".", "dot", "(", "velo_to_cam", ",", "kitti_to_nu_lidar", ".", "transformation_matrix", ")", "\n", "\n", "# Currently not used.", "\n", "imu_to_velo_kitti", "=", "np", ".", "zeros", "(", "(", "3", ",", "4", ")", ")", "# Dummy values.", "\n", "r0_rect", "=", "Quaternion", "(", "axis", "=", "[", "1", ",", "0", ",", "0", "]", ",", "angle", "=", "0", ")", "# Dummy values.", "\n", "\n", "# Projection matrix.", "\n", "p_left_kitti", "=", "np", ".", "zeros", "(", "(", "3", ",", "4", ")", ")", "\n", "p_left_kitti", "[", ":", "3", ",", ":", "3", "]", "=", "cs_record_cam", "[", "'camera_intrinsic'", "]", "# Cameras are always rectified.", "\n", "\n", "# Create KITTI style transforms.", "\n", "velo_to_cam_rot", "=", "velo_to_cam_kitti", "[", ":", "3", ",", ":", "3", "]", "\n", "velo_to_cam_trans", "=", "velo_to_cam_kitti", "[", ":", "3", ",", "3", "]", "\n", "\n", "# Check that the rotation has the same format as in KITTI.", "\n", "assert", "(", "velo_to_cam_rot", ".", "round", "(", "0", ")", "==", "np", ".", "array", "(", "[", "[", "0", ",", "-", "1", ",", "0", "]", ",", "[", "0", ",", "0", ",", "-", "1", "]", ",", "[", "1", ",", "0", ",", "0", "]", "]", ")", ")", ".", "all", "(", ")", "\n", "assert", "(", "velo_to_cam_trans", "[", "1", ":", "3", "]", "<", "0", ")", ".", "all", "(", ")", "\n", "\n", "# Retrieve the token from the lidar.", "\n", "# Note that this may be confusing as the filename of the camera will include the timestamp of the lidar,", "\n", "# not the camera.", "\n", "# filename_cam_full = sd_record_cam['filename']", "\n", "filename_lid_full", "=", "sd_record_lid", "[", "'filename'", "]", "\n", "# token = '%06d' % token_idx # Alternative to use KITTI names.", "\n", "\n", "# Convert image (jpg to png).", "\n", "# src_im_path = os.path.join(self.nusc.dataroot, filename_cam_full)", "\n", "# dst_im_path = os.path.join(image_folder_scene, '{:06}.png'.format(frame))", "\n", "# if not os.path.exists(dst_im_path) and os.path.exists(src_im_path):", "\n", "#     im = Image.open(src_im_path)", "\n", "#     im.save(dst_im_path, \"PNG\")", "\n", "\n", "# Convert lidar.", "\n", "# Note that we are only using a single sweep, instead of the commonly used n sweeps.", "\n", "src_lid_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "nusc", ".", "dataroot", ",", "filename_lid_full", ")", "\n", "dst_lid_path", "=", "os", ".", "path", ".", "join", "(", "lidar_folder_scene", ",", "'{:06}.bin'", ".", "format", "(", "frame", ")", ")", "\n", "assert", "not", "dst_lid_path", ".", "endswith", "(", "'.pcd.bin'", ")", "\n", "pcl", "=", "LidarPointCloud", ".", "from_file", "(", "src_lid_path", ")", "\n", "pcl", ".", "rotate", "(", "kitti_to_nu_lidar_inv", ".", "rotation_matrix", ")", "# In KITTI lidar frame.", "\n", "with", "open", "(", "dst_lid_path", ",", "\"w\"", ")", "as", "lid_file", ":", "\n", "                    ", "pcl", ".", "points", ".", "T", ".", "tofile", "(", "lid_file", ")", "\n", "\n", "# Add to tokens.", "\n", "\n", "# Create calibration file.", "\n", "", "kitti_transforms", "=", "dict", "(", ")", "\n", "kitti_transforms", "[", "'P0'", "]", "=", "np", ".", "zeros", "(", "(", "3", ",", "4", ")", ")", "# Dummy values.", "\n", "kitti_transforms", "[", "'P1'", "]", "=", "np", ".", "zeros", "(", "(", "3", ",", "4", ")", ")", "# Dummy values.", "\n", "kitti_transforms", "[", "'P2'", "]", "=", "p_left_kitti", "# Left camera transform.", "\n", "kitti_transforms", "[", "'P3'", "]", "=", "np", ".", "zeros", "(", "(", "3", ",", "4", ")", ")", "# Dummy values.", "\n", "kitti_transforms", "[", "'R_rect'", "]", "=", "r0_rect", ".", "rotation_matrix", "# Cameras are already rectified.", "\n", "kitti_transforms", "[", "'Tr_velo_cam'", "]", "=", "np", ".", "hstack", "(", "(", "velo_to_cam_rot", ",", "velo_to_cam_trans", ".", "reshape", "(", "3", ",", "1", ")", ")", ")", "\n", "kitti_transforms", "[", "'Tr_imu_velo'", "]", "=", "imu_to_velo_kitti", "\n", "calib_path", "=", "os", ".", "path", ".", "join", "(", "calib_folder", ",", "'{:04}.txt'", ".", "format", "(", "self", ".", "split_scene_token2ind", "[", "scene", "]", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "calib_path", ")", ":", "\n", "                    ", "with", "open", "(", "calib_path", ",", "\"w\"", ")", "as", "calib_file", ":", "\n", "                        ", "for", "(", "key", ",", "val", ")", "in", "kitti_transforms", ".", "items", "(", ")", ":", "\n", "                            ", "val", "=", "val", ".", "flatten", "(", ")", "\n", "val_str", "=", "'%.12e'", "%", "val", "[", "0", "]", "\n", "for", "v", "in", "val", "[", "1", ":", "]", ":", "\n", "                                ", "val_str", "+=", "' %.12e'", "%", "v", "\n", "", "calib_file", ".", "write", "(", "'%s: %s\\n'", "%", "(", "key", ",", "val_str", ")", ")", "\n", "\n", "# Write label file.", "\n", "", "", "", "label_path", "=", "os", ".", "path", ".", "join", "(", "label_folder", ",", "'{:04}.txt'", ".", "format", "(", "self", ".", "split_scene_token2ind", "[", "scene", "]", ")", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "label_path", ")", ":", "\n", "                    ", "print", "(", "'Writing file: %s'", "%", "label_path", ")", "\n", "\n", "", "with", "open", "(", "label_path", ",", "\"a+\"", ")", "as", "label_file", ":", "\n", "# Get boxes in LIDAR frame.", "\n", "\n", "                    ", "_", ",", "boxes_lidar_nusc", ",", "_", "=", "self", ".", "nusc", ".", "get_sample_data", "(", "lidar_token", ",", "box_vis_level", "=", "BoxVisibility", ".", "NONE", ")", "\n", "for", "box_lidar_nusc", "in", "boxes_lidar_nusc", ":", "\n", "\n", "                        ", "sample_annotation", "=", "self", ".", "nusc", ".", "get", "(", "'sample_annotation'", ",", "box_lidar_nusc", ".", "token", ")", "\n", "track_id", "=", "self", ".", "nusc", ".", "getind", "(", "'instance'", ",", "sample_annotation", "[", "'instance_token'", "]", ")", "\n", "\n", "# Truncated: Set all objects to 0 which means untruncated.", "\n", "truncated", "=", "0.0", "\n", "\n", "# Occluded: Set all objects to full visibility as this information is not available in nuScenes.", "\n", "occluded", "=", "0", "\n", "\n", "# Convert nuScenes category to nuScenes detection challenge category.", "\n", "detection_name", "=", "category_to_detection_name", "(", "sample_annotation", "[", "'category_name'", "]", ")", "\n", "\n", "# Skip categories that are not part of the nuScenes detection challenge.", "\n", "if", "detection_name", "is", "None", ":", "\n", "# print(sample_annotation['category_name'])", "\n", "                            ", "continue", "\n", "\n", "# Convert from nuScenes to KITTI box format.", "\n", "", "box_cam_kitti", "=", "KittiDB", ".", "box_nuscenes_to_kitti", "(", "\n", "box_lidar_nusc", ",", "Quaternion", "(", "matrix", "=", "velo_to_cam_rot", ")", ",", "velo_to_cam_trans", ",", "r0_rect", ")", "\n", "\n", "# Project 3d box to 2d box in image, ignore box if it does not fall inside.", "\n", "bbox_2d", "=", "KittiDB", ".", "project_kitti_box_to_image", "(", "box_cam_kitti", ",", "p_left_kitti", ",", "imsize", "=", "imsize", ")", "\n", "if", "bbox_2d", "is", "None", ":", "\n", "                            ", "continue", "\n", "\n", "# Set dummy score so we can use this file as result.", "\n", "", "box_cam_kitti", ".", "score", "=", "0", "\n", "\n", "# Convert box to output string format.", "\n", "output", "=", "KittiDB", ".", "box_to_string", "(", "frame", "=", "frame", ",", "track_id", "=", "track_id", ",", "name", "=", "detection_name", ",", "\n", "box", "=", "box_cam_kitti", ",", "bbox_2d", "=", "bbox_2d", ",", "\n", "truncation", "=", "truncated", ",", "occlusion", "=", "occluded", ",", "\n", "is_key_frame", "=", "sd_record_lid", "[", "'is_key_frame'", "]", ",", "\n", "num_lidar_pts", "=", "sample_annotation", "[", "'num_lidar_pts'", "]", ")", "\n", "\n", "# Write to disk.", "\n", "label_file", ".", "write", "(", "output", "+", "'\\n'", ")", "\n", "", "", "frame", "+=", "1", "\n", "# cam_front_token=sd_record_cam['next']", "\n", "if", "lidar_token", "==", "last_lidar_token", ":", "\n", "                    ", "break", "\n", "", "lidar_token", "=", "sd_record_lid", "[", "'next'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_kitti.KittiConverter.render_kitti": [[269, 294], ["utils.kitti.KittiDB", "os.path.join", "print", "print", "os.path.isdir", "os.mkdir", "os.path.join", "print", "utils.kitti.KittiDB.render_sample_data", "matplotlib.close", "matplotlib.close"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_sample_data"], ["", "", "", "def", "render_kitti", "(", "self", ",", "render_2d", ":", "bool", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders the annotations in the KITTI dataset from a lidar and a camera view.\n        :param render_2d: Whether to render 2d boxes (only works for camera data).\n        \"\"\"", "\n", "if", "render_2d", ":", "\n", "            ", "print", "(", "'Rendering 2d boxes from KITTI format'", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'Rendering 3d boxes projected from 3d KITTI format'", ")", "\n", "\n", "# Load the KITTI dataset.", "\n", "", "kitti", "=", "KittiDB", "(", "root", "=", "self", ".", "nusc_kitti_dir", ",", "splits", "=", "(", "self", ".", "split", ",", ")", ")", "\n", "\n", "# Create output folder.", "\n", "render_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "nusc_kitti_dir", ",", "'render'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "render_dir", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "render_dir", ")", "\n", "\n", "# Render each image.", "\n", "", "for", "token", "in", "kitti", ".", "tokens", "[", ":", "self", ".", "image_count", "]", ":", "\n", "            ", "for", "sensor", "in", "[", "'lidar'", ",", "'camera'", "]", ":", "\n", "                ", "out_path", "=", "os", ".", "path", ".", "join", "(", "render_dir", ",", "'%s_%s.png'", "%", "(", "token", ",", "sensor", ")", ")", "\n", "print", "(", "'Rendering file to disk: %s'", "%", "out_path", ")", "\n", "kitti", ".", "render_sample_data", "(", "token", ",", "sensor_modality", "=", "sensor", ",", "out_path", "=", "out_path", ",", "render_2d", "=", "render_2d", ")", "\n", "plt", ".", "close", "(", ")", "# Close the windows to avoid a warning of too many open windows.", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_kitti.KittiConverter.kitti_res_to_nuscenes": [[295, 343], ["utils.kitti.KittiDB", "utils.splits.create_splits_logs", "export_kitti.KittiConverter._split_to_samples", "os.path.join", "print", "utils.kitti.KittiDB.get_boxes", "open", "json.dump", "export_kitti.KittiConverter._box_to_sample_result"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_logs", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_kitti.KittiConverter._split_to_samples", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_kitti.KittiConverter._box_to_sample_result"], ["", "", "", "def", "kitti_res_to_nuscenes", "(", "self", ",", "meta", ":", "Dict", "[", "str", ",", "bool", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Converts a KITTI detection result to the nuScenes detection results format.\n        :param meta: Meta data describing the method used to generate the result. See nuscenes.org/object-detection.\n        \"\"\"", "\n", "# Dummy meta data, please adjust accordingly.", "\n", "if", "meta", "is", "None", ":", "\n", "            ", "meta", "=", "{", "\n", "'use_camera'", ":", "False", ",", "\n", "'use_lidar'", ":", "True", ",", "\n", "'use_radar'", ":", "False", ",", "\n", "'use_map'", ":", "False", ",", "\n", "'use_external'", ":", "False", ",", "\n", "}", "\n", "\n", "# Init.", "\n", "", "results", "=", "{", "}", "\n", "\n", "# Load the KITTI dataset.", "\n", "kitti", "=", "KittiDB", "(", "root", "=", "self", ".", "nusc_kitti_dir", ",", "splits", "=", "(", "self", ".", "split", ",", ")", ")", "\n", "\n", "# Get assignment of scenes to splits.", "\n", "split_logs", "=", "create_splits_logs", "(", "self", ".", "split", ",", "self", ".", "nusc", ")", "\n", "\n", "# Use only the samples from the current split.", "\n", "sample_tokens", "=", "self", ".", "_split_to_samples", "(", "split_logs", ")", "\n", "sample_tokens", "=", "sample_tokens", "[", ":", "self", ".", "image_count", "]", "\n", "\n", "for", "sample_token", "in", "sample_tokens", ":", "\n", "# Get the KITTI boxes we just generated in LIDAR frame.", "\n", "            ", "kitti_token", "=", "'%s_%s'", "%", "(", "self", ".", "split", ",", "sample_token", ")", "\n", "boxes", "=", "kitti", ".", "get_boxes", "(", "token", "=", "kitti_token", ")", "\n", "\n", "# Convert KITTI boxes to nuScenes detection challenge result format.", "\n", "sample_results", "=", "[", "self", ".", "_box_to_sample_result", "(", "sample_token", ",", "box", ")", "for", "box", "in", "boxes", "]", "\n", "\n", "# Store all results for this image.", "\n", "results", "[", "sample_token", "]", "=", "sample_results", "\n", "\n", "# Store submission file to disk.", "\n", "", "submission", "=", "{", "\n", "'meta'", ":", "meta", ",", "\n", "'results'", ":", "results", "\n", "}", "\n", "submission_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "nusc_kitti_dir", ",", "'submission.json'", ")", "\n", "print", "(", "'Writing submission to: %s'", "%", "submission_path", ")", "\n", "with", "open", "(", "submission_path", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "submission", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_kitti.KittiConverter._box_to_sample_result": [[344, 365], ["dict", "translation.tolist", "size.tolist", "rotation.tolist", "velocity.tolist"], "methods", ["None"], ["", "", "def", "_box_to_sample_result", "(", "self", ",", "sample_token", ":", "str", ",", "box", ":", "Box", ",", "attribute_name", ":", "str", "=", "''", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "# Prepare data", "\n", "        ", "translation", "=", "box", ".", "center", "\n", "size", "=", "box", ".", "wlh", "\n", "rotation", "=", "box", ".", "orientation", ".", "q", "\n", "velocity", "=", "box", ".", "velocity", "\n", "detection_name", "=", "box", ".", "name", "\n", "detection_score", "=", "box", ".", "score", "\n", "\n", "# Create result dict", "\n", "sample_result", "=", "dict", "(", ")", "\n", "sample_result", "[", "'sample_token'", "]", "=", "sample_token", "\n", "sample_result", "[", "'translation'", "]", "=", "translation", ".", "tolist", "(", ")", "\n", "sample_result", "[", "'size'", "]", "=", "size", ".", "tolist", "(", ")", "\n", "sample_result", "[", "'rotation'", "]", "=", "rotation", ".", "tolist", "(", ")", "\n", "sample_result", "[", "'velocity'", "]", "=", "velocity", ".", "tolist", "(", ")", "[", ":", "2", "]", "# Only need vx, vy.", "\n", "sample_result", "[", "'detection_name'", "]", "=", "detection_name", "\n", "sample_result", "[", "'detection_score'", "]", "=", "detection_score", "\n", "sample_result", "[", "'attribute_name'", "]", "=", "attribute_name", "\n", "\n", "return", "sample_result", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_kitti.KittiConverter._split_to_samples": [[366, 380], ["export_kitti.KittiConverter.nusc.get", "export_kitti.KittiConverter.nusc.get", "samples.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "_split_to_samples", "(", "self", ",", "split_logs", ":", "List", "[", "str", "]", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"\n        Convenience function to get the samples in a particular split.\n        :param split_logs: A list of the log names in this split.\n        :return: The list of samples.\n        \"\"\"", "\n", "samples", "=", "[", "]", "\n", "for", "sample", "in", "self", ".", "nusc", ".", "sample", ":", "\n", "            ", "scene", "=", "self", ".", "nusc", ".", "get", "(", "'scene'", ",", "sample", "[", "'scene_token'", "]", ")", "\n", "log", "=", "self", ".", "nusc", ".", "get", "(", "'log'", ",", "scene", "[", "'log_token'", "]", ")", "\n", "logfile", "=", "log", "[", "'logfile'", "]", "\n", "if", "logfile", "in", "split_logs", ":", "\n", "                ", "samples", ".", "append", "(", "sample", "[", "'token'", "]", ")", "\n", "", "", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_poses.get_poses": [[29, 50], ["nusc.get", "nusc.get", "nusc.get", "nusc.get", "pose_list.append", "nusc.get", "nusc.get", "pose_list.append"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["def", "get_poses", "(", "nusc", ":", "NuScenes", ",", "scene_token", ":", "str", ")", "->", "List", "[", "dict", "]", ":", "\n", "    ", "\"\"\"\n    Return all ego poses for the current scene.\n    :param nusc: The NuScenes instance to load the ego poses from.\n    :param scene_token: The token of the scene.\n    :return: A list of the ego pose dicts.\n    \"\"\"", "\n", "pose_list", "=", "[", "]", "\n", "scene_rec", "=", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "sample_rec", "=", "nusc", ".", "get", "(", "'sample'", ",", "scene_rec", "[", "'first_sample_token'", "]", ")", "\n", "sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "\n", "\n", "ego_pose", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "sd_rec", "[", "'token'", "]", ")", "\n", "pose_list", ".", "append", "(", "ego_pose", ")", "\n", "\n", "while", "sd_rec", "[", "'next'", "]", "!=", "''", ":", "\n", "        ", "sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sd_rec", "[", "'next'", "]", ")", "\n", "ego_pose", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "sd_rec", "[", "'token'", "]", ")", "\n", "pose_list", ".", "append", "(", "ego_pose", ")", "\n", "\n", "", "return", "pose_list", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_poses.get_coordinate": [[52, 74], ["math.asin", "math.radians", "math.radians", "math.atan2", "math.degrees", "math.degrees", "math.sin", "math.cos", "math.cos", "math.cos", "math.cos", "math.cos", "math.sin", "math.sin", "math.sin", "math.sin", "math.sin"], "function", ["None"], ["", "def", "get_coordinate", "(", "ref_lat", ":", "float", ",", "ref_lon", ":", "float", ",", "bearing", ":", "float", ",", "dist", ":", "float", ")", "->", "Tuple", "[", "float", ",", "float", "]", ":", "\n", "    ", "\"\"\"\n    Using a reference coordinate, extract the coordinates of another point in space given its distance and bearing\n    to the reference coordinate. For reference, please see: https://www.movable-type.co.uk/scripts/latlong.html.\n    :param ref_lat: Latitude of the reference coordinate in degrees, ie: 42.3368.\n    :param ref_lon: Longitude of the reference coordinate in degrees, ie: 71.0578.\n    :param bearing: The clockwise angle in radians between target point, reference point and the axis pointing north.\n    :param dist: The distance in meters from the reference point to the target point.\n    :return: A tuple of lat and lon.\n    \"\"\"", "\n", "lat", ",", "lon", "=", "math", ".", "radians", "(", "ref_lat", ")", ",", "math", ".", "radians", "(", "ref_lon", ")", "\n", "angular_distance", "=", "dist", "/", "EARTH_RADIUS_METERS", "\n", "\n", "target_lat", "=", "math", ".", "asin", "(", "\n", "math", ".", "sin", "(", "lat", ")", "*", "math", ".", "cos", "(", "angular_distance", ")", "+", "\n", "math", ".", "cos", "(", "lat", ")", "*", "math", ".", "sin", "(", "angular_distance", ")", "*", "math", ".", "cos", "(", "bearing", ")", "\n", ")", "\n", "target_lon", "=", "lon", "+", "math", ".", "atan2", "(", "\n", "math", ".", "sin", "(", "bearing", ")", "*", "math", ".", "sin", "(", "angular_distance", ")", "*", "math", ".", "cos", "(", "lat", ")", ",", "\n", "math", ".", "cos", "(", "angular_distance", ")", "-", "math", ".", "sin", "(", "lat", ")", "*", "math", ".", "sin", "(", "target_lat", ")", "\n", ")", "\n", "return", "math", ".", "degrees", "(", "target_lat", ")", ",", "math", ".", "degrees", "(", "target_lon", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_poses.derive_latlon": [[76, 101], ["REFERENCE_COORDINATES.keys", "math.atan", "math.sqrt", "export_poses.get_coordinate", "coordinates.append"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_poses.get_coordinate"], ["", "def", "derive_latlon", "(", "location", ":", "str", ",", "poses", ":", "List", "[", "Dict", "[", "str", ",", "float", "]", "]", ")", "->", "List", "[", "Dict", "[", "str", ",", "float", "]", "]", ":", "\n", "    ", "\"\"\"\n    For each pose value, extract its respective lat/lon coordinate and timestamp.\n    \n    This makes the following two assumptions in order to work:\n        1. The reference coordinate for each map is in the south-western corner.\n        2. The origin of the global poses is also in the south-western corner (and identical to 1).\n\n    :param location: The name of the map the poses correspond to, ie: 'boston-seaport'.\n    :param poses: All nuScenes egopose dictionaries of a scene.\n    :return: A list of dicts (lat/lon coordinates and timestamps) for each pose.\n    \"\"\"", "\n", "assert", "location", "in", "REFERENCE_COORDINATES", ".", "keys", "(", ")", ",", "f'Error: The given location: {location}, has no available reference.'", "\n", "\n", "coordinates", "=", "[", "]", "\n", "reference_lat", ",", "reference_lon", "=", "REFERENCE_COORDINATES", "[", "location", "]", "\n", "for", "p", "in", "poses", ":", "\n", "        ", "ts", "=", "p", "[", "'timestamp'", "]", "\n", "x", ",", "y", "=", "p", "[", "'translation'", "]", "[", ":", "2", "]", "\n", "bearing", "=", "math", ".", "atan", "(", "x", "/", "y", ")", "\n", "distance", "=", "math", ".", "sqrt", "(", "x", "**", "2", "+", "y", "**", "2", ")", "\n", "lat", ",", "lon", "=", "get_coordinate", "(", "reference_lat", ",", "reference_lon", ",", "bearing", ",", "distance", ")", "\n", "coordinates", ".", "append", "(", "{", "'timestamp'", ":", "ts", ",", "'latitude'", ":", "lat", ",", "'longitude'", ":", "lon", "}", ")", "\n", "", "return", "coordinates", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_poses.export_kml": [[103, 150], ["coordinates_per_location.items", "coordinates_per_scene.items", "open", "f.write"], "function", ["None"], ["", "def", "export_kml", "(", "coordinates_per_location", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "List", "[", "Dict", "[", "str", ",", "float", "]", "]", "]", "]", ",", "output_path", ":", "str", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Export the coordinates of a scene to .kml file.\n    :param coordinates_per_location: A dict of lat/lon coordinate dicts for each scene.\n    :param output_path: Path of the kml file to write to disk.\n    \"\"\"", "\n", "# Opening lines.", "\n", "result", "=", "f'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'", "f'<kml xmlns=\"http://www.opengis.net/kml/2.2\">\\n'", "f'  <Document>\\n'", "f'    <name>nuScenes ego poses</name>\\n'", "\n", "\n", "# Export each scene as a separate placemark to be able to view them independently.", "\n", "for", "location", ",", "coordinates_per_scene", "in", "coordinates_per_location", ".", "items", "(", ")", ":", "\n", "        ", "result", "+=", "f'    <Folder>\\n'", "f'    <name>{location}</name>\\n'", "\n", "\n", "for", "scene_name", ",", "coordinates", "in", "coordinates_per_scene", ".", "items", "(", ")", ":", "\n", "            ", "result", "+=", "f'        <Placemark>\\n'", "f'          <name>{scene_name}</name>\\n'", "f'          <LineString>\\n'", "f'            <tessellate>1</tessellate>\\n'", "f'            <coordinates>\\n'", "\n", "\n", "for", "coordinate", "in", "coordinates", ":", "\n", "                ", "coordinates_str", "=", "'%.10f,%.10f,%d'", "%", "(", "coordinate", "[", "'longitude'", "]", ",", "coordinate", "[", "'latitude'", "]", ",", "0", ")", "\n", "result", "+=", "f'              {coordinates_str}\\n'", "\n", "\n", "", "result", "+=", "f'            </coordinates>\\n'", "f'          </LineString>\\n'", "f'        </Placemark>\\n'", "\n", "\n", "", "result", "+=", "f'    </Folder>\\n'", "\n", "\n", "# Closing lines.", "\n", "", "result", "+=", "f'  </Document>\\n'", "f'</kml>'", "\n", "\n", "# Write to disk.", "\n", "with", "open", "(", "output_path", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_poses.main": [[152, 196], ["nuscenes.nuscenes.NuScenes", "print", "tqdm.tqdm", "os.path.dirname", "print", "export_poses.get_poses", "export_poses.derive_latlon", "os.makedirs", "nuscenes.nuscenes.NuScenes.get", "os.path.exists", "open", "json.dump", "export_poses.export_kml", "Exception"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_poses.get_poses", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_poses.derive_latlon", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_poses.export_kml"], ["", "", "def", "main", "(", "dataroot", ":", "str", ",", "version", ":", "str", ",", "output_prefix", ":", "str", ",", "output_format", ":", "str", "=", "'kml'", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Extract the latlon coordinates for each available pose and write the results to a file.\n    The file is organized by location and scene_name.\n    :param dataroot: Path of the nuScenes dataset.\n    :param version: NuScenes version.\n    :param output_format: The output file format, kml or json.\n    :param output_prefix: Where to save the output file (without the file extension).\n    \"\"\"", "\n", "# Init nuScenes.", "\n", "nusc", "=", "NuScenes", "(", "dataroot", "=", "dataroot", ",", "version", "=", "version", ",", "verbose", "=", "False", ")", "\n", "\n", "coordinates_per_location", "=", "{", "}", "\n", "print", "(", "f'Extracting coordinates...'", ")", "\n", "for", "scene", "in", "tqdm", "(", "nusc", ".", "scene", ")", ":", "\n", "# Retrieve nuScenes poses.", "\n", "        ", "scene_name", "=", "scene", "[", "'name'", "]", "\n", "scene_token", "=", "scene", "[", "'token'", "]", "\n", "location", "=", "nusc", ".", "get", "(", "'log'", ",", "scene", "[", "'log_token'", "]", ")", "[", "'location'", "]", "# Needed to extract the reference coordinate.", "\n", "poses", "=", "get_poses", "(", "nusc", ",", "scene_token", ")", "# For each pose, we will extract the corresponding coordinate.", "\n", "\n", "# Compute and store coordinates.", "\n", "coordinates", "=", "derive_latlon", "(", "location", ",", "poses", ")", "\n", "if", "location", "not", "in", "coordinates_per_location", ":", "\n", "            ", "coordinates_per_location", "[", "location", "]", "=", "{", "}", "\n", "", "coordinates_per_location", "[", "location", "]", "[", "scene_name", "]", "=", "coordinates", "\n", "\n", "# Create output directory if necessary.", "\n", "", "dest_dir", "=", "os", ".", "path", ".", "dirname", "(", "output_prefix", ")", "\n", "if", "dest_dir", "!=", "''", "and", "not", "os", ".", "path", ".", "exists", "(", "dest_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "dest_dir", ")", "\n", "\n", "# Write to json.", "\n", "", "output_path", "=", "f'{output_prefix}_{version}.{output_format}'", "\n", "if", "output_format", "==", "'json'", ":", "\n", "        ", "with", "open", "(", "output_path", ",", "'w'", ")", "as", "fh", ":", "\n", "            ", "json", ".", "dump", "(", "coordinates_per_location", ",", "fh", ",", "sort_keys", "=", "True", ",", "indent", "=", "4", ")", "\n", "", "", "elif", "output_format", "==", "'kml'", ":", "\n", "# Write to kml.", "\n", "        ", "export_kml", "(", "coordinates_per_location", ",", "output_path", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Error: Invalid output format: %s'", "%", "output_format", ")", "\n", "\n", "", "print", "(", "f\"Saved the coordinates in {output_path}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.convert_annotation_list_to_dict": [[27, 94], ["collections.defaultdict", "export_instance_videos.extract_camera_key_from_filename", "export_instance_videos.calculate_bb_area", "collections.defaultdict", "print"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.extract_camera_key_from_filename", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.calculate_bb_area"], ["def", "convert_annotation_list_to_dict", "(", "annotation_list", ":", "List", "[", "dict", "]", ",", "\n", "categories", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "visibilities", ":", "List", "[", "str", "]", "=", "None", ")", "->", "defaultdict", ":", "\n", "    ", "\"\"\"\n    Save the list of sample_annotations in a format suitable for instance videos.\n\n    When saving the list of annotations to a dictionary, special attention must be paid to the\n    correct keys to use.\n\n    For example, you will have bounding boxes with the same instance_token and sample_annotation_token\n    because there are multiple cameras on the car, so you can have the same object appearing across\n    multiple sensors. Each sensor's data is identified with a sample_data_token.\n    {'attribute_tokens': ['58aa28b1c2a54dc88e169808c07331e3'], 'bbox_corners': [1370.3079971217335, 446.66394956158524, 1600.0, 607.4567037983365], 'category_name': 'vehicle.car', 'filename': 'samples/CAM_FRONT/n008-2018-08-27-11-48-51-0400__CAM_FRONT__1535385095912404.jpg', 'instance_token': '0f8696c5e7284236b29a806d3d6f3513', 'next': '624a662244a241529e9f4d42fe75d2bd', 'num_lidar_pts': 4, 'num_radar_pts': 2, 'prev': '8291db1bc2704230867275bad5f42297', 'sample_annotation_token': 'ee04de72a30e4517a366ddad89d64fef', 'sample_data_token': '60ade2dececb46c69b114ce4c8a0bd3e', 'visibility_token': '1'}\n    {'attribute_tokens': ['58aa28b1c2a54dc88e169808c07331e3'], 'bbox_corners': [0.0, 446.3944232196225, 387.13952090477727, 618.0310593208171], 'category_name': 'vehicle.car', 'filename': 'samples/CAM_FRONT_RIGHT/n008-2018-08-27-11-48-51-0400__CAM_FRONT_RIGHT__1535385095920482.jpg', 'instance_token': '0f8696c5e7284236b29a806d3d6f3513', 'next': '624a662244a241529e9f4d42fe75d2bd', 'num_lidar_pts': 4, 'num_radar_pts': 2, 'prev': '8291db1bc2704230867275bad5f42297', 'sample_annotation_token': 'ee04de72a30e4517a366ddad89d64fef', 'sample_data_token': '92d49452e5804d0a9724ab4161a26147', 'visibility_token': '1'}\n\n    A combination of [instance_token][sample_data_token] can be used to uniquely identify\n    the bounding boxes. You can enumerate through [instance_token][x] to find all the different\n    views of a single bounding box.\n\n    :param annotation_list: A list of annotations.\n    :param categories: The list of categories to filter annotations by.\n    :param visibilities: The list of visibilities to filter annotations by.\n    :return: A nested dict of annotations indexed by [instance_token][sample_token][camera_name].\n    \"\"\"", "\n", "\n", "# Default arguments.", "\n", "if", "visibilities", "is", "None", ":", "\n", "        ", "visibilities", "=", "[", "''", ",", "'1'", ",", "'2'", ",", "'3'", ",", "'4'", "]", "\n", "\n", "# Convert the list of instance to a dictionary that uses the", "\n", "# instance_token -> sample_annotation_token -> camera", "\n", "# to look up the instance.", "\n", "", "bbox_2d_annotations", "=", "defaultdict", "(", "lambda", ":", "defaultdict", "(", "dict", ")", ")", "\n", "\n", "num_dups", "=", "0", "\n", "for", "instance", "in", "annotation_list", ":", "\n", "        ", "instance_token", "=", "instance", "[", "'instance_token'", "]", "\n", "\n", "# 3. `sample` - An annotated snapshot of a scene at a particular timestamp.", "\n", "#               This is identified by `sample_annotation_token`.", "\n", "# 4. `sample_data` - Data collected from a particular sensor.", "\n", "\n", "# sample_data refers to the picture captured by a single sensor at a single timestamp.", "\n", "# sample_annotation_token refers to a single bounding box, which might exist in multiple", "\n", "# sample_data (across the different cameras)", "\n", "sample_token", "=", "instance", "[", "'sample_annotation_token'", "]", "\n", "category", "=", "instance", "[", "'category_name'", "]", "\n", "visibility", "=", "instance", "[", "'visibility_token'", "]", "\n", "camera_name", "=", "extract_camera_key_from_filename", "(", "instance", "[", "'filename'", "]", ")", "\n", "\n", "# Append additional information.", "\n", "instance", "[", "'camera_name'", "]", "=", "camera_name", "\n", "instance", "[", "'bbox_area'", "]", "=", "calculate_bb_area", "(", "instance", "[", "'bbox_corners'", "]", ")", "\n", "\n", "if", "(", "categories", "is", "not", "None", "and", "category", "not", "in", "categories", ")", "or", "visibility", "not", "in", "visibilities", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "instance_token", "in", "bbox_2d_annotations", "and", "sample_token", "in", "bbox_2d_annotations", "[", "instance_token", "]", "and", "camera_name", "in", "bbox_2d_annotations", "[", "instance_token", "]", "[", "sample_token", "]", ":", "\n", "            ", "num_dups", "+=", "1", "\n", "print", "(", "'Duplicate instance {}, sample {}, and camera {}'", ".", "format", "(", "\n", "instance_token", ",", "sample_token", ",", "camera_name", ")", ")", "\n", "\n", "", "bbox_2d_annotations", "[", "instance_token", "]", "[", "sample_token", "]", "[", "camera_name", "]", "=", "instance", "\n", "assert", "num_dups", "==", "0", ",", "'Error: Number of duplicates (should be zero)!'", "\n", "\n", "", "return", "bbox_2d_annotations", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.extract_camera_key_from_filename": [[96, 113], ["filename.split"], "function", ["None"], ["", "def", "extract_camera_key_from_filename", "(", "filename", ":", "str", ")", "->", "str", ":", "\n", "    ", "\"\"\"\n    Extract the camera name from the filename.\n    :param filename: the name of the file where the samples image is stored.\n                Ex: 'samples/CAM_BACK/n015-2018-10-02-10-50-40+0800__CAM_BACK__1538448750037525.jpg',\n    :return: The camera name.\n    \"\"\"", "\n", "\n", "camera_name", "=", "filename", ".", "split", "(", "'/'", ")", "[", "1", "]", "\n", "\n", "# Validate the camera name is valid.", "\n", "camera_names", "=", "[", "'CAM_BACK'", ",", "'CAM_BACK_LEFT'", ",", "'CAM_BACK_RIGHT'", ",", "\n", "'CAM_FRONT'", ",", "'CAM_FRONT_LEFT'", ",", "'CAM_FRONT_RIGHT'", "]", "\n", "assert", "(", "camera_name", "in", "camera_names", ")", ",", "\"Invalid camera name: {} from path: {}\"", ".", "format", "(", "\n", "camera_name", ",", "filename", ")", "\n", "\n", "return", "camera_name", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.calculate_bb_area": [[115, 123], ["None"], "function", ["None"], ["", "def", "calculate_bb_area", "(", "bounding_box", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Calculates area of a 2D bounding box.\n    :param bounding_box: np.array of length 4 (x min, y min, x max, y max).\n    :return: The area.\n    \"\"\"", "\n", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", "=", "bounding_box", "\n", "return", "(", "x_max", "-", "x_min", ")", "*", "(", "y_max", "-", "y_min", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.get_most_visible_camera_annotation": [[125, 173], ["print"], "function", ["None"], ["", "def", "get_most_visible_camera_annotation", "(", "camera_data_dict", ":", "dict", ")", "->", "dict", ":", "\n", "    ", "\"\"\"\n    Get the most visibile camera's annotation.\n    :param camera_data_dict: Dictionary of form:\n      {\n        'CAM_BACK': {'attribute_tokens': ['cb5118da1ab342aa947717dc53544259'],\n          'bbox_corners': [600.8315617945755,\n          426.38901275036744,\n          643.6756536789582,\n          476.66593163100237],\n          'category_name': 'vehicle.bus.rigid',\n          'filename': 'samples/CAM_BACK/n015-2018-10-02-10-50-40+0800__CAM_BACK__1538448750037525.jpg',\n          'instance_token': '9cba9cd8af85487fb010652c90d845b5',\n          'next': 'ef90c2e525244b7d9eeb759837cf2277',\n          'num_lidar_pts': 0,\n          'num_radar_pts': 0,\n          'prev': '6628e81912584a72bd448a44931afb42',\n          'sample_annotation_token': '06b4886e79d2435c80bd23e7ac60c618',\n          'sample_data_token': '0008443755a14b3ca483f1489c767040',\n          'visibility_token': '4'},\n        'CAM_FRONT': ...\n        ...\n      }\n    :return: The camera annotation with highest visibility.\n    \"\"\"", "\n", "\n", "# Loop through all the camera views to find the best view of this instance", "\n", "# Each of the cameras will have a corresponding bounding box and visibility.", "\n", "# We want the largest bounding box and highest visibility.", "\n", "best_visibility", "=", "''", "\n", "largest_area", "=", "-", "1", "\n", "best_camera_token", "=", "None", "\n", "\n", "for", "camera_token", "in", "camera_data_dict", ":", "\n", "        ", "visibility", "=", "camera_data_dict", "[", "camera_token", "]", "[", "'visibility_token'", "]", "\n", "bbox_area", "=", "camera_data_dict", "[", "camera_token", "]", "[", "'bbox_area'", "]", "\n", "\n", "if", "visibility", ">", "best_visibility", "or", "(", "visibility", "==", "best_visibility", "and", "bbox_area", ">", "largest_area", ")", ":", "\n", "            ", "best_camera_token", "=", "camera_token", "\n", "largest_area", "=", "bbox_area", "\n", "best_visibility", "=", "visibility", "\n", "\n", "", "", "if", "not", "best_camera_token", ":", "\n", "        ", "print", "(", "'Unable to find any good views for camera data dict: {}'", ".", "format", "(", "\n", "camera_data_dict", ")", ")", "\n", "\n", "", "best_instance_data", "=", "camera_data_dict", "[", "best_camera_token", "]", "\n", "return", "best_instance_data", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.get_cropped_image_for_annotation": [[175, 210], ["os.path.join", "PIL.Image.open", "Image.open.crop", "im1.resize.resize", "numpy.asarray"], "function", ["None"], ["", "def", "get_cropped_image_for_annotation", "(", "sample_data_annotation", ":", "dict", ",", "\n", "dataroot", ":", "str", ",", "\n", "output_size", ":", "Tuple", "[", "int", ",", "int", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Crop the annotation of a given imgae.\n    :param sample_data_annotation: Dict of form:\n      ```\n      {'attribute_tokens': ['cb5118da1ab342aa947717dc53544259'],\n      'bbox_corners': [600.8315617945755,\n      426.38901275036744,\n      643.6756536789582,\n      476.66593163100237],\n      'category_name': 'vehicle.bus.rigid',\n      'filename': 'samples/CAM_BACK/n015-2018-10-02-10-50-40+0800__CAM_BACK__1538448750037525.jpg',\n      'instance_token': '9cba9cd8af85487fb010652c90d845b5',\n      'next': 'ef90c2e525244b7d9eeb759837cf2277',\n      'num_lidar_pts': 0,\n      'num_radar_pts': 0,\n      'prev': '6628e81912584a72bd448a44931afb42',\n      'sample_annotation_token': '06b4886e79d2435c80bd23e7ac60c618',\n      'sample_data_token': '0008443755a14b3ca483f1489c767040',\n      'visibility_token': '4'},\n      ```\n    :param dataroot: The nuScenes dataroot.\n    :param output_size: A tuple for the image size.\n    :return: The cropped image.\n    \"\"\"", "\n", "data_path", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "\n", "sample_data_annotation", "[", "'filename'", "]", ")", "\n", "bbox", "=", "sample_data_annotation", "[", "'bbox_corners'", "]", "\n", "im", "=", "Image", ".", "open", "(", "data_path", ")", "\n", "im1", "=", "im", ".", "crop", "(", "bbox", ")", "\n", "im1", "=", "im1", ".", "resize", "(", "output_size", ")", "\n", "np_img", "=", "np", ".", "asarray", "(", "im1", ")", "\n", "return", "np_img", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.sort_sample_annotations_chronologically": [[212, 248], ["print", "sequential_sample_tokens.append", "print"], "function", ["None"], ["", "def", "sort_sample_annotations_chronologically", "(", "instance_dict", ":", "dict", ")", "->", "List", "[", "str", "]", ":", "\n", "    ", "\"\"\"\n    Sort the sample_annotations chronologically.\n    :param instance_dict: Taken by indexing bbox_2d_annotations[instance_token]\n    :return: A list of chronologically sorted annotations.\n\n    Uses [sample_token][sample_annotation_token]['best_annotation'] to find the correct sequence.\n    \"\"\"", "\n", "\n", "# Find the first sample token", "\n", "first_sample_token", "=", "None", "\n", "\n", "for", "sample_token", "in", "instance_dict", ":", "\n", "        ", "if", "instance_dict", "[", "sample_token", "]", "[", "'best_annotation'", "]", "[", "'prev'", "]", "==", "''", ":", "\n", "            ", "first_sample_token", "=", "sample_token", "\n", "break", "\n", "\n", "", "", "if", "first_sample_token", "is", "None", ":", "\n", "        ", "print", "(", "\"Unable to find a start token\"", ")", "\n", "\n", "# Now iterate and find a list of the sample_tokens in order", "\n", "", "sequential_sample_tokens", "=", "[", "first_sample_token", "]", "\n", "\n", "while", "True", ":", "\n", "        ", "try", ":", "\n", "            ", "next_sample_token", "=", "instance_dict", "[", "sequential_sample_tokens", "[", "-", "1", "]", "]", "[", "'best_annotation'", "]", "[", "'next'", "]", "\n", "", "except", ":", "\n", "            ", "print", "(", "\"Unrecognized sample annotaton token: {}\"", ",", "sequential_sample_tokens", ")", "\n", "break", "\n", "\n", "", "if", "next_sample_token", "==", "''", ":", "\n", "            ", "break", "\n", "\n", "", "sequential_sample_tokens", ".", "append", "(", "next_sample_token", ")", "\n", "\n", "", "return", "sequential_sample_tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.remove_bad_samples": [[250, 273], ["cleaned.append"], "function", ["None"], ["", "def", "remove_bad_samples", "(", "instance_annotation", ":", "dict", ",", "\n", "minimum_bb_area", ":", "float", ",", "\n", "minimum_visibility", ":", "str", ",", "\n", "image_area", ":", "int", "=", "1600", "*", "900", ")", "->", "List", ":", "\n", "    ", "\"\"\"\n    Removes bad samples from an instance annotation's sample sequence\n\n    :param instance_annotation: an instance annotation\n    :param minimum_bb_area: The minimum fraction of a frame a bounding box take up to be used (0, 1)\n    :param minimum_visibility: The minimum visibility a frame is allowed to haev ('', '1', '2', '3', '4')\n    :param image_area: The area of an image frame. Defaults to 1600*900.\n    :return: A cleaned list of sample annotation tokens that meet requirements\n    \"\"\"", "\n", "sample_token_sequence", "=", "instance_annotation", "[", "'sample_annotation_sequence'", "]", "\n", "cleaned", "=", "[", "]", "\n", "\n", "for", "sample_token", "in", "sample_token_sequence", ":", "\n", "        ", "area", "=", "instance_annotation", "[", "sample_token", "]", "[", "'best_annotation'", "]", "[", "'bbox_area'", "]", "\n", "visibility", "=", "instance_annotation", "[", "sample_token", "]", "[", "'best_annotation'", "]", "[", "'visibility_token'", "]", "\n", "if", "area", "/", "image_area", ">", "minimum_bb_area", "and", "visibility", ">=", "minimum_visibility", ":", "\n", "            ", "cleaned", ".", "append", "(", "sample_token", ")", "\n", "\n", "", "", "return", "cleaned", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.main": [[275, 395], ["print", "print", "print", "print", "print", "print", "print", "os.path.join", "export_instance_videos.convert_annotation_list_to_dict", "print", "shutil.rmtree", "pathlib.Path().mkdir", "print", "tqdm.tqdm", "print", "print", "os.path.exists", "Exception", "open", "json.load", "export_instance_videos.sort_sample_annotations_chronologically", "export_instance_videos.remove_bad_samples", "os.path.join", "cv2.VideoWriter", "cv2.VideoWriter.release", "len", "export_instance_videos.get_most_visible_camera_annotation", "pathlib.Path", "len", "cv2.VideoWriter_fourcc", "export_instance_videos.get_cropped_image_for_annotation", "cv2.VideoWriter.write", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.convert_annotation_list_to_dict", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.sort_sample_annotations_chronologically", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.remove_bad_samples", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.get_most_visible_camera_annotation", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_instance_videos.get_cropped_image_for_annotation"], ["", "def", "main", "(", "version", ":", "str", ",", "\n", "dataroot", ":", "str", ",", "\n", "output", ":", "str", ",", "\n", "object_categories", ":", "List", "[", "str", "]", ",", "\n", "fps", ":", "int", ",", "\n", "output_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "\n", "minimum_frames", ":", "int", ",", "\n", "minimum_bb_area", ":", "float", ",", "\n", "visibility", ":", "str", ",", "\n", "codec", ":", "str", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Generates video sequences of nuScenes object instances over time.\n\n    Expects the data to be organized as:\n\n    ```\n    \"$dataroot\"/\n        samples\t-\tSensor data for keyframes.\n        sweeps\t-\tSensor data for intermediate frames.\n        maps\t-\tFolder for all map files: rasterized .png images and vectorized .json files.\n        v1.0-*\t-\tJSON tables that include all the meta data and annotations.\n                    Each split (trainval, test, mini) is provided in a separate folder.\n                    Note that image_annotations.json should be inside this directory.\n    ```\n    \n    :param version: The nuScenes data version.\n    :param dataroot: The path to the data root directory.\n    :param output: The path to the output video directory.\n    :param object_categories: The categories to extract videos for.\n    :param fps: Frames per second to use for the video.\n    :param output_size: The output dimension to resize every cropped bounding box to. Defaults to (112, 112).\n    :param minimum_frames: The minimum number of frames an instance must have.\n    :param minimum_bb_area: The minimum fraction of a frame a bounding box take up to be used (0, 1).\n    :param visibility: The minimum visibility a frame is allowed to haev ('', '1', '2', '3', '4').\n    :param codec: Which codec to use to generate the video, e.g. MJPG or vp09.\n                  Some data annotation platforms require vp09.\n    \"\"\"", "\n", "print", "(", "'='", "*", "20", ")", "\n", "print", "(", "'Generating video sequences:'", ")", "\n", "print", "(", "'\\t* Size: {}'", ".", "format", "(", "output_size", ")", ")", "\n", "print", "(", "'\\t* FPS: {}'", ".", "format", "(", "fps", ")", ")", "\n", "print", "(", "'\\t* Minimum frame count: {}'", ".", "format", "(", "minimum_frames", ")", ")", "\n", "print", "(", "'\\t* Minimum BB area: {}'", ".", "format", "(", "minimum_bb_area", ")", ")", "\n", "print", "(", "'\\t* Minimum visibility: {}'", ".", "format", "(", "visibility", ")", ")", "\n", "\n", "# ================================ Load image annotations. ========================================", "\n", "image_annotations_file", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "version", ",", "'image_annotations.json'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "image_annotations_file", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"Error: Missing image_annotations.json. \"", "\n", "\"Please run the export_2d_annotations_as_json.py script.\"", ")", "\n", "", "with", "open", "(", "image_annotations_file", ")", "as", "f", ":", "\n", "# A list of dictionaries", "\n", "        ", "bbox_2d_annotations_list", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "# These can be indexed with [instance_token][sample_annotation_token][camera_name] -> data about the annotation", "\n", "# You can use the sample_annotation_token with the nuScenes helper in order to get the sample tokens.", "\n", "", "bbox_2d_annotations", "=", "convert_annotation_list_to_dict", "(", "\n", "bbox_2d_annotations_list", ",", "categories", "=", "object_categories", ")", "\n", "print", "(", "'Number of unique vehicle instances: {}'", ".", "format", "(", "len", "(", "bbox_2d_annotations", ")", ")", ")", "\n", "# ==============================================================================================", "\n", "\n", "#  ===== For each instance and each sample annotation, find the best camera sensor to use. ======", "\n", "# Get sorted sample annotation tokens per instance per camera.", "\n", "for", "instance_token", "in", "bbox_2d_annotations", ":", "\n", "        ", "for", "sample_annotation_token", "in", "bbox_2d_annotations", "[", "instance_token", "]", ":", "\n", "            ", "bbox_2d_annotations", "[", "instance_token", "]", "[", "sample_annotation_token", "]", "[", "\n", "'best_annotation'", "]", "=", "get_most_visible_camera_annotation", "(", "\n", "bbox_2d_annotations", "[", "instance_token", "]", "[", "sample_annotation_token", "]", ")", "\n", "# ==============================================================================================", "\n", "\n", "# ====== For each instance, find the correct sequence of sample annotations. ====================", "\n", "# Get sorted sample annotation tokens per instance per camera.", "\n", "", "", "for", "instance_token", "in", "bbox_2d_annotations", ":", "\n", "        ", "bbox_2d_annotations", "[", "instance_token", "]", "[", "'sample_annotation_sequence'", "]", "=", "sort_sample_annotations_chronologically", "(", "\n", "bbox_2d_annotations", "[", "instance_token", "]", ")", "\n", "# ==============================================================================================", "\n", "\n", "# ====== Remove samples from sequence that don't meet requirements. ====================", "\n", "", "for", "instance_token", "in", "bbox_2d_annotations", ":", "\n", "        ", "bbox_2d_annotations", "[", "instance_token", "]", "[", "'sample_annotation_sequence'", "]", "=", "remove_bad_samples", "(", "\n", "bbox_2d_annotations", "[", "instance_token", "]", ",", "minimum_bb_area", ",", "visibility", ")", "\n", "# ==============================================================================================", "\n", "\n", "# ====== Create videos for every instance. ======================================================", "\n", "\n", "# Remove the directory if it already exists and create new one.", "\n", "", "rmtree", "(", "output", ",", "ignore_errors", "=", "True", ")", "\n", "pathlib", ".", "Path", "(", "output", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "print", "(", "\"Creating videos and storing in '{}'...\"", ".", "format", "(", "output", ")", ")", "\n", "total_videos", "=", "0", "\n", "for", "instance_token", "in", "tqdm", "(", "bbox_2d_annotations", ")", ":", "\n", "        ", "sample_annotation_tokens", "=", "bbox_2d_annotations", "[", "instance_token", "]", "[", "'sample_annotation_sequence'", "]", "\n", "\n", "if", "len", "(", "sample_annotation_tokens", ")", "<", "minimum_frames", ":", "\n", "            ", "continue", "\n", "\n", "# Define codec and file extension.", "\n", "", "file_ext", "=", "'mp4'", "if", "codec", "==", "'vp09'", "else", "'avi'", "\n", "video_path", "=", "os", ".", "path", ".", "join", "(", "\n", "output", ",", "'{}.{}'", ".", "format", "(", "instance_token", ",", "file_ext", ")", ")", "\n", "out", "=", "cv2", ".", "VideoWriter", "(", "\n", "video_path", ",", "cv2", ".", "VideoWriter_fourcc", "(", "*", "codec", ")", ",", "fps", ",", "output_size", ")", "\n", "\n", "for", "sample_annotation_token", "in", "sample_annotation_tokens", ":", "\n", "            ", "best_annotation", "=", "bbox_2d_annotations", "[", "instance_token", "]", "[", "sample_annotation_token", "]", "[", "'best_annotation'", "]", "\n", "cropped_img", "=", "get_cropped_image_for_annotation", "(", "\n", "best_annotation", ",", "dataroot", ",", "output_size", ")", "\n", "\n", "# Convert from PIL's RGB to cv2 BGR", "\n", "out", ".", "write", "(", "cropped_img", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "\n", "", "out", ".", "release", "(", ")", "\n", "\n", "total_videos", "+=", "1", "\n", "\n", "", "print", "(", "'Created {} videos ({} did not meet requirements).'", ".", "format", "(", "\n", "total_videos", ",", "len", "(", "bbox_2d_annotations", ")", "-", "total_videos", ",", "minimum_frames", ")", ")", "\n", "# ==============================================================================================", "\n", "print", "(", "'='", "*", "20", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_2d_annotations_as_json.post_process_coords": [[28, 52], ["shapely.geometry.box", "polygon_from_2d_box.intersects", "shapely.geometry.MultiPoint", "polygon_from_2d_box.intersection", "numpy.array", "min", "min", "max", "max"], "function", ["None"], ["def", "post_process_coords", "(", "corner_coords", ":", "List", ",", "\n", "imsize", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "1600", ",", "900", ")", ")", "->", "Union", "[", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "None", "]", ":", "\n", "    ", "\"\"\"\n    Get the intersection of the convex hull of the reprojected bbox corners and the image canvas, return None if no\n    intersection.\n    :param corner_coords: Corner coordinates of reprojected bounding box.\n    :param imsize: Size of the image canvas.\n    :return: Intersection of the convex hull of the 2D box corners and the image canvas.\n    \"\"\"", "\n", "polygon_from_2d_box", "=", "MultiPoint", "(", "corner_coords", ")", ".", "convex_hull", "\n", "img_canvas", "=", "box", "(", "0", ",", "0", ",", "imsize", "[", "0", "]", ",", "imsize", "[", "1", "]", ")", "\n", "\n", "if", "polygon_from_2d_box", ".", "intersects", "(", "img_canvas", ")", ":", "\n", "        ", "img_intersection", "=", "polygon_from_2d_box", ".", "intersection", "(", "img_canvas", ")", "\n", "intersection_coords", "=", "np", ".", "array", "(", "[", "coord", "for", "coord", "in", "img_intersection", ".", "exterior", ".", "coords", "]", ")", "\n", "\n", "min_x", "=", "min", "(", "intersection_coords", "[", ":", ",", "0", "]", ")", "\n", "min_y", "=", "min", "(", "intersection_coords", "[", ":", ",", "1", "]", ")", "\n", "max_x", "=", "max", "(", "intersection_coords", "[", ":", ",", "0", "]", ")", "\n", "max_y", "=", "max", "(", "intersection_coords", "[", ":", ",", "1", "]", ")", "\n", "\n", "return", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "\n", "", "else", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_2d_annotations_as_json.generate_record": [[54, 96], ["collections.OrderedDict", "ann_rec.items"], "function", ["None"], ["", "", "def", "generate_record", "(", "ann_rec", ":", "dict", ",", "\n", "x1", ":", "float", ",", "\n", "y1", ":", "float", ",", "\n", "x2", ":", "float", ",", "\n", "y2", ":", "float", ",", "\n", "sample_data_token", ":", "str", ",", "\n", "filename", ":", "str", ")", "->", "OrderedDict", ":", "\n", "    ", "\"\"\"\n    Generate one 2D annotation record given various informations on top of the 2D bounding box coordinates.\n    :param ann_rec: Original 3d annotation record.\n    :param x1: Minimum value of the x coordinate.\n    :param y1: Minimum value of the y coordinate.\n    :param x2: Maximum value of the x coordinate.\n    :param y2: Maximum value of the y coordinate.\n    :param sample_data_token: Sample data token.\n    :param filename:The corresponding image file where the annotation is present.\n    :return: A sample 2D annotation record.\n    \"\"\"", "\n", "repro_rec", "=", "OrderedDict", "(", ")", "\n", "repro_rec", "[", "'sample_data_token'", "]", "=", "sample_data_token", "\n", "\n", "relevant_keys", "=", "[", "\n", "'attribute_tokens'", ",", "\n", "'category_name'", ",", "\n", "'instance_token'", ",", "\n", "'next'", ",", "\n", "'num_lidar_pts'", ",", "\n", "'num_radar_pts'", ",", "\n", "'prev'", ",", "\n", "'sample_annotation_token'", ",", "\n", "'sample_data_token'", ",", "\n", "'visibility_token'", ",", "\n", "]", "\n", "\n", "for", "key", ",", "value", "in", "ann_rec", ".", "items", "(", ")", ":", "\n", "        ", "if", "key", "in", "relevant_keys", ":", "\n", "            ", "repro_rec", "[", "key", "]", "=", "value", "\n", "\n", "", "", "repro_rec", "[", "'bbox_corners'", "]", "=", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", "\n", "repro_rec", "[", "'filename'", "]", "=", "filename", "\n", "\n", "return", "repro_rec", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_2d_annotations_as_json.get_2d_boxes": [[98, 164], ["nusc.get", "nusc.get", "nusc.get", "nusc.get", "numpy.array", "ValueError", "nusc.get", "nusc.get_box", "nusc.get_box.translate", "nusc.get_box.rotate", "nusc.get_box.translate", "nusc.get_box.rotate", "nusc.get_box.corners", "numpy.argwhere().flatten", "nuscenes.utils.geometry_utils.view_points().T[].tolist", "export_2d_annotations_as_json.post_process_coords", "export_2d_annotations_as_json.generate_record", "repro_recs.append", "numpy.array", "pyquaternion.quaternion.Quaternion", "numpy.array", "pyquaternion.quaternion.Quaternion", "numpy.argwhere", "nuscenes.utils.geometry_utils.view_points"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_box", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_2d_annotations_as_json.post_process_coords", "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_2d_annotations_as_json.generate_record", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points"], ["", "def", "get_2d_boxes", "(", "sample_data_token", ":", "str", ",", "visibilities", ":", "List", "[", "str", "]", ")", "->", "List", "[", "OrderedDict", "]", ":", "\n", "    ", "\"\"\"\n    Get the 2D annotation records for a given `sample_data_token`.\n    :param sample_data_token: Sample data token belonging to a camera keyframe.\n    :param visibilities: Visibility filter.\n    :return: List of 2D annotation record that belongs to the input `sample_data_token`\n    \"\"\"", "\n", "\n", "# Get the sample data and the sample corresponding to that sample data.", "\n", "sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "\n", "assert", "sd_rec", "[", "'sensor_modality'", "]", "==", "'camera'", ",", "'Error: get_2d_boxes only works for camera sample_data!'", "\n", "if", "not", "sd_rec", "[", "'is_key_frame'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "'The 2D re-projections are available only for keyframes.'", ")", "\n", "\n", "", "s_rec", "=", "nusc", ".", "get", "(", "'sample'", ",", "sd_rec", "[", "'sample_token'", "]", ")", "\n", "\n", "# Get the calibrated sensor and ego pose record to get the transformation matrices.", "\n", "cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "camera_intrinsic", "=", "np", ".", "array", "(", "cs_rec", "[", "'camera_intrinsic'", "]", ")", "\n", "\n", "# Get all the annotation with the specified visibilties.", "\n", "ann_recs", "=", "[", "nusc", ".", "get", "(", "'sample_annotation'", ",", "token", ")", "for", "token", "in", "s_rec", "[", "'anns'", "]", "]", "\n", "ann_recs", "=", "[", "ann_rec", "for", "ann_rec", "in", "ann_recs", "if", "(", "ann_rec", "[", "'visibility_token'", "]", "in", "visibilities", ")", "]", "\n", "\n", "repro_recs", "=", "[", "]", "\n", "\n", "for", "ann_rec", "in", "ann_recs", ":", "\n", "# Augment sample_annotation with token information.", "\n", "        ", "ann_rec", "[", "'sample_annotation_token'", "]", "=", "ann_rec", "[", "'token'", "]", "\n", "ann_rec", "[", "'sample_data_token'", "]", "=", "sample_data_token", "\n", "\n", "# Get the box in global coordinates.", "\n", "box", "=", "nusc", ".", "get_box", "(", "ann_rec", "[", "'token'", "]", ")", "\n", "\n", "# Move them to the ego-pose frame.", "\n", "box", ".", "translate", "(", "-", "np", ".", "array", "(", "pose_rec", "[", "'translation'", "]", ")", ")", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "pose_rec", "[", "'rotation'", "]", ")", ".", "inverse", ")", "\n", "\n", "# Move them to the calibrated sensor frame.", "\n", "box", ".", "translate", "(", "-", "np", ".", "array", "(", "cs_rec", "[", "'translation'", "]", ")", ")", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "cs_rec", "[", "'rotation'", "]", ")", ".", "inverse", ")", "\n", "\n", "# Filter out the corners that are not in front of the calibrated sensor.", "\n", "corners_3d", "=", "box", ".", "corners", "(", ")", "\n", "in_front", "=", "np", ".", "argwhere", "(", "corners_3d", "[", "2", ",", ":", "]", ">", "0", ")", ".", "flatten", "(", ")", "\n", "corners_3d", "=", "corners_3d", "[", ":", ",", "in_front", "]", "\n", "\n", "# Project 3d box to 2d.", "\n", "corner_coords", "=", "view_points", "(", "corners_3d", ",", "camera_intrinsic", ",", "True", ")", ".", "T", "[", ":", ",", ":", "2", "]", ".", "tolist", "(", ")", "\n", "\n", "# Keep only corners that fall within the image.", "\n", "final_coords", "=", "post_process_coords", "(", "corner_coords", ")", "\n", "\n", "# Skip if the convex hull of the re-projected corners does not intersect the image canvas.", "\n", "if", "final_coords", "is", "None", ":", "\n", "            ", "continue", "\n", "", "else", ":", "\n", "            ", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "=", "final_coords", "\n", "\n", "# Generate dictionary record to be included in the .json file.", "\n", "", "repro_rec", "=", "generate_record", "(", "ann_rec", ",", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", ",", "sample_data_token", ",", "sd_rec", "[", "'filename'", "]", ")", "\n", "repro_recs", ".", "append", "(", "repro_rec", ")", "\n", "\n", "", "return", "repro_recs", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_2d_annotations_as_json.main": [[166, 193], ["print", "tqdm.tqdm", "os.path.join", "print", "export_2d_annotations_as_json.get_2d_boxes", "reprojections.extend", "os.path.exists", "os.makedirs", "open", "json.dump", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_2d_annotations_as_json.get_2d_boxes"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "\"\"\"Generates 2D re-projections of the 3D bounding boxes present in the dataset.\"\"\"", "\n", "\n", "print", "(", "\"Generating 2D reprojections of the nuScenes dataset\"", ")", "\n", "\n", "# Get tokens for all camera images.", "\n", "sample_data_camera_tokens", "=", "[", "s", "[", "'token'", "]", "for", "s", "in", "nusc", ".", "sample_data", "if", "(", "s", "[", "'sensor_modality'", "]", "==", "'camera'", ")", "and", "\n", "s", "[", "'is_key_frame'", "]", "]", "\n", "\n", "# For debugging purposes: Only produce the first n images.", "\n", "if", "args", ".", "image_limit", "!=", "-", "1", ":", "\n", "        ", "sample_data_camera_tokens", "=", "sample_data_camera_tokens", "[", ":", "args", ".", "image_limit", "]", "\n", "\n", "# Loop through the records and apply the re-projection algorithm.", "\n", "", "reprojections", "=", "[", "]", "\n", "for", "token", "in", "tqdm", "(", "sample_data_camera_tokens", ")", ":", "\n", "        ", "reprojection_records", "=", "get_2d_boxes", "(", "token", ",", "args", ".", "visibilities", ")", "\n", "reprojections", ".", "extend", "(", "reprojection_records", ")", "\n", "\n", "# Save to a .json file.", "\n", "", "dest_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "dataroot", ",", "args", ".", "version", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dest_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "dest_path", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "args", ".", "dataroot", ",", "args", ".", "version", ",", "args", ".", "filename", ")", ",", "'w'", ")", "as", "fh", ":", "\n", "        ", "json", ".", "dump", "(", "reprojections", ",", "fh", ",", "sort_keys", "=", "True", ",", "indent", "=", "4", ")", "\n", "\n", "", "print", "(", "\"Saved the 2D re-projections under {}\"", ".", "format", "(", "os", ".", "path", ".", "join", "(", "args", ".", "dataroot", ",", "args", ".", "version", ",", "args", ".", "filename", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_egoposes_on_map.export_ego_poses": [[17, 33], ["numpy.unique", "os.path.isdir", "os.makedirs", "print", "nusc.render_egoposes_on_map", "os.path.join", "matplotlib.tight_layout", "matplotlib.savefig"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_egoposes_on_map"], ["def", "export_ego_poses", "(", "nusc", ":", "NuScenes", ",", "out_dir", ":", "str", ")", ":", "\n", "    ", "\"\"\" Script to render where ego vehicle drives on the maps \"\"\"", "\n", "\n", "# Load NuScenes locations", "\n", "locations", "=", "np", ".", "unique", "(", "[", "log", "[", "'location'", "]", "for", "log", "in", "nusc", ".", "log", "]", ")", "\n", "\n", "# Create output directory", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "out_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "\n", "", "for", "location", "in", "locations", ":", "\n", "        ", "print", "(", "'Rendering map {}...'", ".", "format", "(", "location", ")", ")", "\n", "nusc", ".", "render_egoposes_on_map", "(", "location", ")", "\n", "out_path", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "'egoposes-{}.png'", ".", "format", "(", "location", ")", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.scripts.export_scene_videos.export_videos": [[14, 31], ["os.path.isdir", "os.makedirs", "nusc.get", "print", "os.path.join", "os.path.exists", "nusc.render_scene"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_scene"], ["def", "export_videos", "(", "nusc", ":", "NuScenes", ",", "out_dir", ":", "str", ")", ":", "\n", "    ", "\"\"\" Export videos of the images displayed in the images. \"\"\"", "\n", "\n", "# Load NuScenes class", "\n", "scene_tokens", "=", "[", "s", "[", "'token'", "]", "for", "s", "in", "nusc", ".", "scene", "]", "\n", "\n", "# Create output directory", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "out_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "\n", "# Write videos to disk", "\n", "", "for", "scene_token", "in", "scene_tokens", ":", "\n", "        ", "scene", "=", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "print", "(", "'Writing scene %s'", "%", "scene", "[", "'name'", "]", ")", "\n", "out_path", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "scene", "[", "'name'", "]", ")", "+", "'.avi'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_path", ")", ":", "\n", "            ", "nusc", ".", "render_scene", "(", "scene", "[", "'token'", "]", ",", "out_path", "=", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_attributes.TestAttributes.__init__": [[13, 53], ["unittest.TestCase.__init__", "nuimages.nuimages.NuImages"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "_", ":", "Any", "=", "None", ",", "version", ":", "str", "=", "'v1.0-mini'", ",", "dataroot", ":", "str", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Initialize TestAttributes.\n        Note: The second parameter is a dummy parameter required by the TestCase class.\n        :param version: The NuImages version.\n        :param dataroot: The root folder where the dataset is installed.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "version", "=", "version", "\n", "if", "dataroot", "is", "None", ":", "\n", "            ", "self", ".", "dataroot", "=", "os", ".", "environ", "[", "'NUIMAGES'", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "dataroot", "=", "dataroot", "\n", "", "self", ".", "nuim", "=", "NuImages", "(", "version", "=", "self", ".", "version", ",", "dataroot", "=", "self", ".", "dataroot", ",", "verbose", "=", "False", ")", "\n", "self", ".", "valid_attributes", "=", "{", "\n", "'animal'", ":", "[", "'pedestrian'", ",", "'vertical_position'", "]", ",", "\n", "'human.pedestrian.adult'", ":", "[", "'pedestrian'", "]", ",", "\n", "'human.pedestrian.child'", ":", "[", "'pedestrian'", "]", ",", "\n", "'human.pedestrian.construction_worker'", ":", "[", "'pedestrian'", "]", ",", "\n", "'human.pedestrian.personal_mobility'", ":", "[", "'cycle'", "]", ",", "\n", "'human.pedestrian.police_officer'", ":", "[", "'pedestrian'", "]", ",", "\n", "'human.pedestrian.stroller'", ":", "[", "]", ",", "\n", "'human.pedestrian.wheelchair'", ":", "[", "]", ",", "\n", "'movable_object.barrier'", ":", "[", "]", ",", "\n", "'movable_object.debris'", ":", "[", "]", ",", "\n", "'movable_object.pushable_pullable'", ":", "[", "]", ",", "\n", "'movable_object.trafficcone'", ":", "[", "]", ",", "\n", "'static_object.bicycle_rack'", ":", "[", "]", ",", "\n", "'vehicle.bicycle'", ":", "[", "'cycle'", "]", ",", "\n", "'vehicle.bus.bendy'", ":", "[", "'vehicle'", "]", ",", "\n", "'vehicle.bus.rigid'", ":", "[", "'vehicle'", "]", ",", "\n", "'vehicle.car'", ":", "[", "'vehicle'", "]", ",", "\n", "'vehicle.construction'", ":", "[", "'vehicle'", "]", ",", "\n", "'vehicle.ego'", ":", "[", "]", ",", "\n", "'vehicle.emergency.ambulance'", ":", "[", "'vehicle'", ",", "'vehicle_light.emergency'", "]", ",", "\n", "'vehicle.emergency.police'", ":", "[", "'vehicle'", ",", "'vehicle_light.emergency'", "]", ",", "\n", "'vehicle.motorcycle'", ":", "[", "'cycle'", "]", ",", "\n", "'vehicle.trailer'", ":", "[", "'vehicle'", "]", ",", "\n", "'vehicle.truck'", ":", "[", "'vehicle'", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_attributes.TestAttributes.runTest": [[55, 60], ["None"], "methods", ["None"], ["", "def", "runTest", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Dummy function required by the TestCase class.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_attributes.TestAttributes.test_object_anns": [[61, 108], ["test_attributes.TestAttributes.nuim.get", "cur_att_names.append", "len", "len", "any", "str", "print", "test_attributes.TestAttributes.assertTrue", "cur.startswith", "print", "test_attributes.TestAttributes.assertTrue"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "test_object_anns", "(", "self", ",", "print_only", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        For every object_ann, check that all the required attributes for that class are present.\n        :param print_only: Whether to throw assertion errors or just print a warning message.\n        \"\"\"", "\n", "att_token_to_name", "=", "{", "att", "[", "'token'", "]", ":", "att", "[", "'name'", "]", "for", "att", "in", "self", ".", "nuim", ".", "attribute", "}", "\n", "cat_token_to_name", "=", "{", "cat", "[", "'token'", "]", ":", "cat", "[", "'name'", "]", "for", "cat", "in", "self", ".", "nuim", ".", "category", "}", "\n", "for", "object_ann", "in", "self", ".", "nuim", ".", "object_ann", ":", "\n", "# Collect the attribute names used here.", "\n", "            ", "category_name", "=", "cat_token_to_name", "[", "object_ann", "[", "'category_token'", "]", "]", "\n", "sample_token", "=", "self", ".", "nuim", ".", "get", "(", "'sample_data'", ",", "object_ann", "[", "'sample_data_token'", "]", ")", "[", "'sample_token'", "]", "\n", "\n", "cur_att_names", "=", "[", "]", "\n", "for", "attribute_token", "in", "object_ann", "[", "'attribute_tokens'", "]", ":", "\n", "                ", "attribute_name", "=", "att_token_to_name", "[", "attribute_token", "]", "\n", "cur_att_names", ".", "append", "(", "attribute_name", ")", "\n", "\n", "# Compare to the required attribute name prefixes.", "\n", "# Check that the length is correct.", "\n", "", "required_att_names", "=", "self", ".", "valid_attributes", "[", "category_name", "]", "\n", "condition", "=", "len", "(", "cur_att_names", ")", "==", "len", "(", "required_att_names", ")", "\n", "if", "not", "condition", ":", "\n", "                ", "debug_output", "=", "{", "\n", "'sample_token'", ":", "sample_token", ",", "\n", "'category_name'", ":", "category_name", ",", "\n", "'cur_att_names'", ":", "cur_att_names", ",", "\n", "'required_att_names'", ":", "required_att_names", "\n", "}", "\n", "error_msg", "=", "'Error: '", "+", "str", "(", "debug_output", ")", "\n", "if", "print_only", ":", "\n", "                    ", "print", "(", "error_msg", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "assertTrue", "(", "condition", ",", "error_msg", ")", "\n", "\n", "# Skip next check if we already saw an error.", "\n", "", "continue", "\n", "\n", "# Check that they are really the same.", "\n", "", "for", "required", "in", "required_att_names", ":", "\n", "                ", "condition", "=", "any", "(", "[", "cur", ".", "startswith", "(", "required", "+", "'.'", ")", "for", "cur", "in", "cur_att_names", "]", ")", "\n", "if", "not", "condition", ":", "\n", "                    ", "error_msg", "=", "'Errors: Required attribute '", "'%s'", "' not in %s for class %s! (sample %s)'", "%", "(", "required", ",", "cur_att_names", ",", "category_name", ",", "sample_token", ")", "\n", "if", "print_only", ":", "\n", "                        ", "print", "(", "error_msg", ")", "\n", "", "else", ":", "\n", "                        ", "self", ".", "assertTrue", "(", "condition", ",", "error_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.assert_download.verify_setup": [[12, 28], ["print", "tqdm.tqdm", "print", "tqdm.tqdm", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists"], "function", ["None"], ["def", "verify_setup", "(", "nuim", ":", "NuImages", ")", ":", "\n", "    ", "\"\"\"\n    Script to verify that the nuImages installation is complete.\n    Note that this may take several minutes or hours.\n    \"\"\"", "\n", "\n", "# Check that each sample_data file exists.", "\n", "print", "(", "'Checking that sample_data files are complete...'", ")", "\n", "for", "sd", "in", "tqdm", "(", "nuim", ".", "sample_data", ")", ":", "\n", "        ", "file_path", "=", "os", ".", "path", ".", "join", "(", "nuim", ".", "dataroot", ",", "sd", "[", "'filename'", "]", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "file_path", ")", ",", "'Error: Missing sample_data at: %s'", "%", "file_path", "\n", "\n", "\n", "", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "\n", "# Settings.", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Test that the installed dataset is complete.'", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_foreign_keys.TestForeignKeys.__init__": [[14, 29], ["unittest.TestCase.__init__", "nuimages.nuimages.NuImages"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "_", ":", "Any", "=", "None", ",", "version", ":", "str", "=", "'v1.0-mini'", ",", "dataroot", ":", "str", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Initialize TestForeignKeys.\n        Note: The second parameter is a dummy parameter required by the TestCase class.\n        :param version: The NuImages version.\n        :param dataroot: The root folder where the dataset is installed.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "version", "=", "version", "\n", "if", "dataroot", "is", "None", ":", "\n", "            ", "self", ".", "dataroot", "=", "os", ".", "environ", "[", "'NUIMAGES'", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "dataroot", "=", "dataroot", "\n", "", "self", ".", "nuim", "=", "NuImages", "(", "version", "=", "self", ".", "version", ",", "dataroot", "=", "self", ".", "dataroot", ",", "verbose", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_foreign_keys.TestForeignKeys.runTest": [[30, 35], ["None"], "methods", ["None"], ["", "def", "runTest", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Dummy function required by the TestCase class.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_foreign_keys.TestForeignKeys.test_foreign_keys": [[36, 115], ["dict", "print", "test_foreign_keys.TestForeignKeys.nuim.__getattr__", "set", "test_foreign_keys.TestForeignKeys.nuim.__getattr__", "table[].keys", "test_foreign_keys.TestForeignKeys.version.endswith", "print", "foreign_key_name.replace", "set", "test_foreign_keys.TestForeignKeys.assertTrue", "print", "foreign_key_name.replace", "set", "test_foreign_keys.TestForeignKeys.assertTrue", "print", "set", "test_foreign_keys.TestForeignKeys.assertTrue", "len", "test_foreign_keys.TestForeignKeys.version.endswith", "set.issubset", "test_foreign_keys.TestForeignKeys.assertEqual", "k.endswith", "itertools.chain", "set.issubset", "test_foreign_keys.TestForeignKeys.version.endswith", "test_foreign_keys.TestForeignKeys.assertEqual", "set.issubset", "k.endswith", "set", "foreign_index.difference.difference.difference", "k.startswith", "set", "foreign_index.difference.difference.difference", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.attr_dict.AttrDict.__getattr__", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.utils.attr_dict.AttrDict.__getattr__", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["", "def", "test_foreign_keys", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Test that every foreign key points to a valid token.\n        \"\"\"", "\n", "# Index the tokens of all tables.", "\n", "index", "=", "dict", "(", ")", "\n", "for", "table_name", "in", "self", ".", "nuim", ".", "table_names", ":", "\n", "            ", "print", "(", "'Indexing table %s...'", "%", "table_name", ")", "\n", "table", ":", "list", "=", "self", ".", "nuim", ".", "__getattr__", "(", "table_name", ")", "\n", "tokens", "=", "[", "row", "[", "'token'", "]", "for", "row", "in", "table", "]", "\n", "index", "[", "table_name", "]", "=", "set", "(", "tokens", ")", "\n", "\n", "# Go through each table and check the foreign_keys.", "\n", "", "for", "table_name", "in", "self", ".", "nuim", ".", "table_names", ":", "\n", "            ", "table", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "self", ".", "nuim", ".", "__getattr__", "(", "table_name", ")", "\n", "if", "self", ".", "version", ".", "endswith", "(", "'-test'", ")", "and", "len", "(", "table", ")", "==", "0", ":", "# Skip test annotations.", "\n", "                ", "continue", "\n", "", "keys", "=", "table", "[", "0", "]", ".", "keys", "(", ")", "\n", "\n", "# Check 1-to-1 link.", "\n", "one_to_one_names", "=", "[", "k", "for", "k", "in", "keys", "if", "k", ".", "endswith", "(", "'_token'", ")", "and", "not", "k", ".", "startswith", "(", "'key_'", ")", "]", "\n", "for", "foreign_key_name", "in", "one_to_one_names", ":", "\n", "                ", "print", "(", "'Checking one-to-one key %s in table %s...'", "%", "(", "foreign_key_name", ",", "table_name", ")", ")", "\n", "foreign_table_name", "=", "foreign_key_name", ".", "replace", "(", "'_token'", ",", "''", ")", "\n", "foreign_tokens", "=", "set", "(", "[", "row", "[", "foreign_key_name", "]", "for", "row", "in", "table", "]", ")", "\n", "\n", "# Check all tokens are valid.", "\n", "if", "self", ".", "version", ".", "endswith", "(", "'-mini'", ")", "and", "foreign_table_name", "==", "'category'", ":", "\n", "                    ", "continue", "# Mini does not cover all categories.", "\n", "", "foreign_index", "=", "index", "[", "foreign_table_name", "]", "\n", "self", ".", "assertTrue", "(", "foreign_tokens", ".", "issubset", "(", "foreign_index", ")", ")", "\n", "\n", "# Check all tokens are covered.", "\n", "# By default we check that all tokens are covered. Exceptions are listed below.", "\n", "if", "table_name", "==", "'object_ann'", ":", "\n", "                    ", "if", "foreign_table_name", "==", "'category'", ":", "\n", "                        ", "remove", "=", "set", "(", "[", "cat", "[", "'token'", "]", "for", "cat", "in", "self", ".", "nuim", ".", "category", "if", "cat", "[", "'name'", "]", "\n", "in", "[", "'vehicle.ego'", ",", "'flat.driveable_surface'", "]", "]", ")", "\n", "foreign_index", "=", "foreign_index", ".", "difference", "(", "remove", ")", "\n", "", "elif", "foreign_table_name", "==", "'sample_data'", ":", "\n", "                        ", "foreign_index", "=", "None", "# Skip as sample_datas may have no object_ann.", "\n", "", "", "elif", "table_name", "==", "'surface_ann'", ":", "\n", "                    ", "if", "foreign_table_name", "==", "'category'", ":", "\n", "                        ", "remove", "=", "set", "(", "[", "cat", "[", "'token'", "]", "for", "cat", "in", "self", ".", "nuim", ".", "category", "if", "cat", "[", "'name'", "]", "\n", "not", "in", "[", "'vehicle.ego'", ",", "'flat.driveable_surface'", "]", "]", ")", "\n", "foreign_index", "=", "foreign_index", ".", "difference", "(", "remove", ")", "\n", "", "elif", "foreign_table_name", "==", "'sample_data'", ":", "\n", "                        ", "foreign_index", "=", "None", "# Skip as sample_datas may have no surface_ann.", "\n", "", "", "if", "foreign_index", "is", "not", "None", ":", "\n", "                    ", "self", ".", "assertEqual", "(", "foreign_tokens", ",", "foreign_index", ")", "\n", "\n", "# Check 1-to-many link.", "\n", "", "", "one_to_many_names", "=", "[", "k", "for", "k", "in", "keys", "if", "k", ".", "endswith", "(", "'_tokens'", ")", "]", "\n", "for", "foreign_key_name", "in", "one_to_many_names", ":", "\n", "                ", "print", "(", "'Checking one-to-many key %s in table %s...'", "%", "(", "foreign_key_name", ",", "table_name", ")", ")", "\n", "foreign_table_name", "=", "foreign_key_name", ".", "replace", "(", "'_tokens'", ",", "''", ")", "\n", "foreign_tokens_nested", "=", "[", "row", "[", "foreign_key_name", "]", "for", "row", "in", "table", "]", "\n", "foreign_tokens", "=", "set", "(", "itertools", ".", "chain", "(", "*", "foreign_tokens_nested", ")", ")", "\n", "\n", "# Check that all tokens are valid.", "\n", "foreign_index", "=", "index", "[", "foreign_table_name", "]", "\n", "self", ".", "assertTrue", "(", "foreign_tokens", ".", "issubset", "(", "foreign_index", ")", ")", "\n", "\n", "# Check all tokens are covered.", "\n", "if", "self", ".", "version", ".", "endswith", "(", "'-mini'", ")", "and", "foreign_table_name", "==", "'attribute'", ":", "\n", "                    ", "continue", "# Mini does not cover all categories.", "\n", "", "if", "foreign_index", "is", "not", "None", ":", "\n", "                    ", "self", ".", "assertEqual", "(", "foreign_tokens", ",", "foreign_index", ")", "\n", "\n", "# Check prev and next.", "\n", "", "", "prev_next_names", "=", "[", "k", "for", "k", "in", "keys", "if", "k", "in", "[", "'previous'", ",", "'next'", "]", "]", "\n", "for", "foreign_key_name", "in", "prev_next_names", ":", "\n", "                ", "print", "(", "'Checking prev-next key %s in table %s...'", "%", "(", "foreign_key_name", ",", "table_name", ")", ")", "\n", "foreign_table_name", "=", "table_name", "\n", "foreign_tokens", "=", "set", "(", "[", "row", "[", "foreign_key_name", "]", "for", "row", "in", "table", "if", "len", "(", "row", "[", "foreign_key_name", "]", ")", ">", "0", "]", ")", "\n", "\n", "# Check that all tokens are valid.", "\n", "foreign_index", "=", "index", "[", "foreign_table_name", "]", "\n", "self", ".", "assertTrue", "(", "foreign_tokens", ".", "issubset", "(", "foreign_index", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_foreign_keys.TestForeignKeys.test_prev_next": [[116, 138], ["collections.defaultdict", "print", "sample_to_sample_datas[].append", "test_foreign_keys.TestForeignKeys.nuim.get_sample_content", "test_foreign_keys.TestForeignKeys.assertTrue", "test_foreign_keys.TestForeignKeys.assertTrue", "test_foreign_keys.TestForeignKeys.nuim.get", "timestamps.append", "set", "set", "sorted"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuimages.nuimages.NuImages.get_sample_content", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["", "", "", "def", "test_prev_next", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Test that the prev and next points in sample_data cover all entries and have the correct ordering.\n        \"\"\"", "\n", "# Register all sample_datas.", "\n", "sample_to_sample_datas", "=", "defaultdict", "(", "lambda", ":", "[", "]", ")", "\n", "for", "sample_data", "in", "self", ".", "nuim", ".", "sample_data", ":", "\n", "            ", "sample_to_sample_datas", "[", "sample_data", "[", "'sample_token'", "]", "]", ".", "append", "(", "sample_data", "[", "'token'", "]", ")", "\n", "\n", "", "print", "(", "'Checking prev-next pointers for completeness and correct ordering...'", ")", "\n", "for", "sample", "in", "self", ".", "nuim", ".", "sample", ":", "\n", "# Compare the above sample_datas against those retrieved by using prev and next pointers.", "\n", "            ", "sd_tokens_pointers", "=", "self", ".", "nuim", ".", "get_sample_content", "(", "sample", "[", "'token'", "]", ")", "\n", "sd_tokens_all", "=", "sample_to_sample_datas", "[", "sample", "[", "'token'", "]", "]", "\n", "self", ".", "assertTrue", "(", "set", "(", "sd_tokens_pointers", ")", "==", "set", "(", "sd_tokens_all", ")", ",", "\n", "'Error: Inconsistency in prev/next pointers!'", ")", "\n", "\n", "timestamps", "=", "[", "]", "\n", "for", "sd_token", "in", "sd_tokens_pointers", ":", "\n", "                ", "sample_data", "=", "self", ".", "nuim", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "\n", "timestamps", ".", "append", "(", "sample_data", "[", "'timestamp'", "]", ")", "\n", "", "self", ".", "assertTrue", "(", "sorted", "(", "timestamps", ")", "==", "timestamps", ",", "'Error: Timestamps not properly sorted!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_map_mask.TestLoad.setUp": [[22, 33], ["numpy.zeros", "cv2.imwrite"], "methods", ["None"], ["def", "setUp", "(", "self", ")", ":", "\n", "\n", "# Build a test map. 5 x 4 meters. All background except one pixel.", "\n", "        ", "mask", "=", "np", ".", "zeros", "(", "(", "50", ",", "40", ")", ")", "\n", "\n", "# Native resolution is 0.1", "\n", "# Transformation in y is defined as y_pixel = nrows - y_meters /  resolution", "\n", "# Transformation in x is defined as x_pixel = x_meters /  resolution", "\n", "# The global map location x=2, y=2 becomes row 30, column 20 in image map coords.", "\n", "mask", "[", "30", ",", "20", "]", "=", "self", ".", "foreground", "\n", "cv2", ".", "imwrite", "(", "filename", "=", "self", ".", "fixture", ",", "img", "=", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_map_mask.TestLoad.tearDown": [[34, 36], ["os.remove"], "methods", ["None"], ["", "def", "tearDown", "(", "self", ")", ":", "\n", "        ", "os", ".", "remove", "(", "self", ".", "fixture", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_map_mask.TestLoad.test_native_resolution": [[37, 57], ["nuscenes.utils.map_mask.MapMask", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertFalse", "test_map_mask.TestLoad.assertFalse", "test_map_mask.TestLoad.assertFalse", "test_map_mask.TestLoad.assertFalse", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask"], ["", "def", "test_native_resolution", "(", "self", ")", ":", "\n", "\n", "# Load mask and assert that the", "\n", "        ", "map_mask", "=", "MapMask", "(", "self", ".", "fixture", ",", "resolution", "=", "0.1", ")", "\n", "\n", "# This is where we put the foreground in the fixture, so this should be true by design.", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "2", ")", ")", "\n", "\n", "# Each pixel is 10 x 10 cm, so if we step less than 5 cm in either direction we are still on foreground.", "\n", "# Note that we add / subtract a \"small number\" to break numerical ambiguities along the edges.", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", "+", "self", ".", "half_lt", ",", "2", ")", ")", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", "-", "self", ".", "half_lt", ",", "2", ")", ")", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "2", "+", "self", ".", "half_lt", ")", ")", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "2", "-", "self", ".", "half_lt", ")", ")", "\n", "\n", "# But if we step outside this range, we should get false", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "2", "+", "self", ".", "half_gt", ",", "2", ")", ")", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "2", "+", "self", ".", "half_gt", ",", "2", ")", ")", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "2", "+", "self", ".", "half_gt", ")", ")", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "2", "+", "self", ".", "half_gt", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_map_mask.TestLoad.test_edges": [[58, 79], ["cv2.imwrite", "nuscenes.utils.map_mask.MapMask", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertFalse", "test_map_mask.TestLoad.assertFalse", "test_map_mask.TestLoad.assertFalse", "test_map_mask.TestLoad.assertFalse", "numpy.ones", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask"], ["", "def", "test_edges", "(", "self", ")", ":", "\n", "\n", "# Add foreground pixels in the corners for this test.", "\n", "        ", "mask", "=", "np", ".", "ones", "(", "(", "50", ",", "40", ")", ")", "*", "self", ".", "foreground", "\n", "\n", "# Just over-write the fixture", "\n", "cv2", ".", "imwrite", "(", "filename", "=", "self", ".", "fixture", ",", "img", "=", "mask", ")", "\n", "\n", "map_mask", "=", "MapMask", "(", "self", ".", "fixture", ",", "resolution", "=", "0.1", ")", "\n", "\n", "# Asssert that corners are indeed drivable as encoded in map.", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "0", ",", "0.1", ")", ")", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "0", ",", "5", ")", ")", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "3.9", ",", "0.1", ")", ")", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "3.9", ",", "5", ")", ")", "\n", "\n", "# Not go juuuust outside the map. This should no longer be drivable.", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "3.9", "+", "self", ".", "half_gt", ",", "0.1", ")", ")", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "3.9", "+", "self", ".", "half_gt", ",", "5", ")", ")", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "0", "-", "self", ".", "half_gt", ",", "0.1", ")", ")", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "0", "-", "self", ".", "half_gt", ",", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_map_mask.TestLoad.test_dilation": [[80, 97], ["nuscenes.utils.map_mask.MapMask", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertFalse", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertFalse", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask"], ["", "def", "test_dilation", "(", "self", ")", ":", "\n", "\n", "        ", "map_mask", "=", "MapMask", "(", "self", ".", "fixture", ",", "resolution", "=", "0.1", ")", "\n", "\n", "# This is where we put the foreground in the fixture, so this should be true by design.", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "2", ")", ")", "\n", "\n", "# Go 1 meter to the right. Obviously not on the mask.", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "3", ")", ")", "\n", "\n", "# But if we dilate by 1 meters, we are on the dilated mask.", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "3", ",", "dilation", "=", "1", ")", ")", "# x direction", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "3", ",", "2", ",", "dilation", "=", "1", ")", ")", "# y direction", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", "+", "np", ".", "sqrt", "(", "1", "/", "2", ")", ",", "2", "+", "np", ".", "sqrt", "(", "1", "/", "2", ")", ",", "dilation", "=", "1", ")", ")", "# diagonal", "\n", "\n", "# If we dilate by 0.9 meter, it is not enough.", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "3", ",", "dilation", "=", "0.9", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_map_mask.TestLoad.test_coarse_resolution": [[98, 123], ["numpy.zeros", "cv2.imwrite", "nuscenes.utils.map_mask.MapMask", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertFalse", "test_map_mask.TestLoad.assertTrue", "test_map_mask.TestLoad.assertFalse", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask", "nuscenes.utils.map_mask.MapMask.is_on_mask"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.is_on_mask"], ["", "def", "test_coarse_resolution", "(", "self", ")", ":", "\n", "\n", "# Due to resize that happens on load we need to inflate the fixture.", "\n", "        ", "mask", "=", "np", ".", "zeros", "(", "(", "50", ",", "40", ")", ")", "\n", "mask", "[", "30", ",", "20", "]", "=", "self", ".", "foreground", "\n", "mask", "[", "31", ",", "20", "]", "=", "self", ".", "foreground", "\n", "mask", "[", "30", ",", "21", "]", "=", "self", ".", "foreground", "\n", "mask", "[", "31", ",", "21", "]", "=", "self", ".", "foreground", "\n", "\n", "# Just over-write the fixture", "\n", "cv2", ".", "imwrite", "(", "filename", "=", "self", ".", "fixture", ",", "img", "=", "mask", ")", "\n", "\n", "map_mask", "=", "MapMask", "(", "self", ".", "fixture", ",", "resolution", "=", "0.2", ")", "\n", "\n", "# This is where we put the foreground in the fixture, so this should be true by design.", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "2", ")", ")", "\n", "\n", "# Go two meters to the right. Obviously not on the mask.", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "4", ")", ")", "\n", "\n", "# But if we dilate by two meters, we are on the dilated mask.", "\n", "self", ".", "assertTrue", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "4", ",", "dilation", "=", "2", ")", ")", "\n", "\n", "# And if we dilate by 1.9 meter, we are off the dilated mask.", "\n", "self", ".", "assertFalse", "(", "map_mask", ".", "is_on_mask", "(", "2", ",", "4", ",", "dilation", "=", "1.9", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_geometry_utils.TestGeometryUtils.test_quaternion_yaw": [[16, 57], ["numpy.linspace", "pyquaternion.Quaternion", "nuscenes.eval.common.utils.quaternion_yaw", "test_geometry_utils.TestGeometryUtils.assertAlmostEqual", "pyquaternion.Quaternion", "test_geometry_utils.TestGeometryUtils.assertAlmostEqual", "pyquaternion.Quaternion", "nuscenes.eval.common.utils.quaternion_yaw", "test_geometry_utils.TestGeometryUtils.assertAlmostEqual", "pyquaternion.Quaternion", "nuscenes.eval.common.utils.quaternion_yaw", "test_geometry_utils.TestGeometryUtils.assertAlmostEqual", "nuscenes.eval.common.utils.quaternion_yaw", "test_geometry_utils.TestGeometryUtils.assertAlmostEqual", "pyquaternion.Quaternion", "nuscenes.eval.common.utils.quaternion_yaw", "test_geometry_utils.TestGeometryUtils.assertAlmostEqual", "nuscenes.eval.common.utils.quaternion_yaw", "pyquaternion.Quaternion", "pyquaternion.Quaternion"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw"], ["    ", "def", "test_quaternion_yaw", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test valid and invalid inputs for quaternion_yaw().\"\"\"", "\n", "\n", "# Misc yaws.", "\n", "for", "yaw_in", "in", "np", ".", "linspace", "(", "-", "10", ",", "10", ",", "100", ")", ":", "\n", "            ", "q", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "yaw_in", ")", "\n", "yaw_true", "=", "yaw_in", "%", "(", "2", "*", "np", ".", "pi", ")", "\n", "if", "yaw_true", ">", "np", ".", "pi", ":", "\n", "                ", "yaw_true", "-=", "2", "*", "np", ".", "pi", "\n", "", "yaw_test", "=", "quaternion_yaw", "(", "q", ")", "\n", "self", ".", "assertAlmostEqual", "(", "yaw_true", ",", "yaw_test", ")", "\n", "\n", "# Non unit axis vector.", "\n", "", "yaw_in", "=", "np", ".", "pi", "/", "4", "\n", "q", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "0.5", ")", ",", "angle", "=", "yaw_in", ")", "\n", "yaw_test", "=", "quaternion_yaw", "(", "q", ")", "\n", "self", ".", "assertAlmostEqual", "(", "yaw_in", ",", "yaw_test", ")", "\n", "\n", "# Inverted axis vector.", "\n", "yaw_in", "=", "np", ".", "pi", "/", "4", "\n", "q", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "-", "1", ")", ",", "angle", "=", "yaw_in", ")", "\n", "yaw_test", "=", "-", "quaternion_yaw", "(", "q", ")", "\n", "self", ".", "assertAlmostEqual", "(", "yaw_in", ",", "yaw_test", ")", "\n", "\n", "# Rotate around another axis.", "\n", "yaw_in", "=", "np", ".", "pi", "/", "4", "\n", "q", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "1", ",", "0", ")", ",", "angle", "=", "yaw_in", ")", "\n", "yaw_test", "=", "quaternion_yaw", "(", "q", ")", "\n", "self", ".", "assertAlmostEqual", "(", "0", ",", "yaw_test", ")", "\n", "\n", "# Rotate around two axes jointly.", "\n", "yaw_in", "=", "np", ".", "pi", "/", "2", "\n", "q", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "1", ",", "1", ")", ",", "angle", "=", "yaw_in", ")", "\n", "yaw_test", "=", "quaternion_yaw", "(", "q", ")", "\n", "self", ".", "assertAlmostEqual", "(", "yaw_in", ",", "yaw_test", ")", "\n", "\n", "# Rotate around two axes separately.", "\n", "yaw_in", "=", "np", ".", "pi", "/", "2", "\n", "q", "=", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "yaw_in", ")", "*", "Quaternion", "(", "axis", "=", "(", "0", ",", "1", ",", "0", ")", ",", "angle", "=", "0.5821", ")", "\n", "yaw_test", "=", "quaternion_yaw", "(", "q", ")", "\n", "self", ".", "assertAlmostEqual", "(", "yaw_in", ",", "yaw_test", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_geometry_utils.TestGeometryUtils.test_points_in_box": [[58, 112], ["nuscenes.utils.data_classes.Box", "numpy.array().transpose", "nuscenes.utils.geometry_utils.points_in_box", "test_geometry_utils.TestGeometryUtils.assertEqual", "nuscenes.utils.data_classes.Box", "numpy.array().transpose", "nuscenes.utils.geometry_utils.points_in_box", "test_geometry_utils.TestGeometryUtils.assertEqual", "nuscenes.utils.data_classes.Box", "numpy.array().transpose", "nuscenes.utils.geometry_utils.points_in_box", "test_geometry_utils.TestGeometryUtils.assertEqual", "nuscenes.utils.data_classes.Box", "numpy.array().transpose", "nuscenes.utils.geometry_utils.points_in_box", "test_geometry_utils.TestGeometryUtils.assertEqual", "test_geometry_utils.TestGeometryUtils.assertEqual", "nuscenes.utils.data_classes.Box", "numpy.array().transpose", "nuscenes.utils.geometry_utils.points_in_box", "test_geometry_utils.TestGeometryUtils.assertEqual", "pyquaternion.Quaternion", "test_geometry_utils.TestGeometryUtils.test_points_in_box.qyaw"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.points_in_box", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.points_in_box", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.points_in_box", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.points_in_box", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.points_in_box"], ["", "def", "test_points_in_box", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test the box.in_box method. \"\"\"", "\n", "\n", "vel", "=", "(", "np", ".", "nan", ",", "np", ".", "nan", ",", "np", ".", "nan", ")", "\n", "\n", "def", "qyaw", "(", "yaw", ")", ":", "\n", "            ", "return", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "yaw", ")", "\n", "\n", "# Check points inside box", "\n", "", "box", "=", "Box", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "2.0", ",", "2.0", ",", "0.0", "]", ",", "qyaw", "(", "0.0", ")", ",", "1", ",", "2.0", ",", "vel", ")", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.5", ",", "0.5", ",", "0.0", "]", "]", ")", ".", "transpose", "(", ")", "\n", "mask", "=", "points_in_box", "(", "box", ",", "points", ",", "wlh_factor", "=", "1.0", ")", "\n", "self", ".", "assertEqual", "(", "mask", ".", "all", "(", ")", ",", "True", ")", "\n", "\n", "# Check points outside box", "\n", "box", "=", "Box", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "2.0", ",", "2.0", ",", "0.0", "]", ",", "qyaw", "(", "0.0", ")", ",", "1", ",", "2.0", ",", "vel", ")", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "0.1", ",", "0.0", ",", "0.0", "]", ",", "[", "0.5", ",", "-", "1.1", ",", "0.0", "]", "]", ")", ".", "transpose", "(", ")", "\n", "mask", "=", "points_in_box", "(", "box", ",", "points", ",", "wlh_factor", "=", "1.0", ")", "\n", "self", ".", "assertEqual", "(", "mask", ".", "all", "(", ")", ",", "False", ")", "\n", "\n", "# Check corner cases", "\n", "box", "=", "Box", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "2.0", ",", "2.0", ",", "0.0", "]", ",", "qyaw", "(", "0.0", ")", ",", "1", ",", "2.0", ",", "vel", ")", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "-", "1.0", ",", "-", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "0.0", "]", "]", ")", ".", "transpose", "(", ")", "\n", "mask", "=", "points_in_box", "(", "box", ",", "points", ",", "wlh_factor", "=", "1.0", ")", "\n", "self", ".", "assertEqual", "(", "mask", ".", "all", "(", ")", ",", "True", ")", "\n", "\n", "# Check rotation (45 degs) and translation (by [1,1])", "\n", "rot", "=", "45", "\n", "trans", "=", "[", "1.0", ",", "1.0", "]", "\n", "box", "=", "Box", "(", "[", "0.0", "+", "trans", "[", "0", "]", ",", "0.0", "+", "trans", "[", "1", "]", ",", "0.0", "]", ",", "[", "2.0", ",", "2.0", ",", "0.0", "]", ",", "qyaw", "(", "rot", "/", "180.0", "*", "np", ".", "pi", ")", ",", "1", ",", "2.0", ",", "vel", ")", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "0.70", "+", "trans", "[", "0", "]", ",", "0.70", "+", "trans", "[", "1", "]", ",", "0.0", "]", ",", "[", "0.71", "+", "1.0", ",", "0.71", "+", "1.0", ",", "0.0", "]", "]", ")", ".", "transpose", "(", ")", "\n", "mask", "=", "points_in_box", "(", "box", ",", "points", ",", "wlh_factor", "=", "1.0", ")", "\n", "self", ".", "assertEqual", "(", "mask", "[", "0", "]", ",", "True", ")", "\n", "self", ".", "assertEqual", "(", "mask", "[", "1", "]", ",", "False", ")", "\n", "\n", "# Check 3d box", "\n", "box", "=", "Box", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "2.0", ",", "2.0", ",", "2.0", "]", ",", "qyaw", "(", "0.0", ")", ",", "1", ",", "2.0", ",", "vel", ")", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.5", ",", "0.5", ",", "0.5", "]", "]", ")", ".", "transpose", "(", ")", "\n", "mask", "=", "points_in_box", "(", "box", ",", "points", ",", "wlh_factor", "=", "1.0", ")", "\n", "self", ".", "assertEqual", "(", "mask", ".", "all", "(", ")", ",", "True", ")", "\n", "\n", "# Check wlh factor", "\n", "for", "wlh_factor", "in", "[", "0.5", ",", "1.0", ",", "1.5", ",", "10.0", "]", ":", "\n", "            ", "box", "=", "Box", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "2.0", ",", "2.0", ",", "0.0", "]", ",", "qyaw", "(", "0.0", ")", ",", "1", ",", "2.0", ",", "vel", ")", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.5", ",", "0.5", ",", "0.0", "]", "]", ")", ".", "transpose", "(", ")", "\n", "mask", "=", "points_in_box", "(", "box", ",", "points", ",", "wlh_factor", "=", "wlh_factor", ")", "\n", "self", ".", "assertEqual", "(", "mask", ".", "all", "(", ")", ",", "True", ")", "\n", "\n", "", "for", "wlh_factor", "in", "[", "0.1", ",", "0.49", "]", ":", "\n", "            ", "box", "=", "Box", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "2.0", ",", "2.0", ",", "0.0", "]", ",", "qyaw", "(", "0.0", ")", ",", "1", ",", "2.0", ",", "vel", ")", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.5", ",", "0.5", ",", "0.0", "]", "]", ")", ".", "transpose", "(", ")", "\n", "mask", "=", "points_in_box", "(", "box", ",", "points", ",", "wlh_factor", "=", "wlh_factor", ")", "\n", "self", ".", "assertEqual", "(", "mask", "[", "0", "]", ",", "True", ")", "\n", "self", ".", "assertEqual", "(", "mask", "[", "1", "]", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_data_classes.TestDataClasses.test_load_pointclouds": [[13, 35], ["nuscenes.NuScenes", "os.path.join", "os.path.join", "nuscenes.utils.data_classes.LidarPointCloud.from_file", "nuscenes.utils.data_classes.RadarPointCloud.from_file", "nuscenes.utils.data_classes.LidarPointCloud.from_file_multisweep", "nuscenes.utils.data_classes.RadarPointCloud.from_file_multisweep", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.from_file_multisweep", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.from_file_multisweep", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["    ", "def", "test_load_pointclouds", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Loads up lidar and radar pointclouds.\n        \"\"\"", "\n", "assert", "'NUSCENES'", "in", "os", ".", "environ", ",", "'Set NUSCENES env. variable to enable tests.'", "\n", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "'v1.0-mini'", ",", "dataroot", "=", "dataroot", ",", "verbose", "=", "False", ")", "\n", "sample_rec", "=", "nusc", ".", "sample", "[", "0", "]", "\n", "lidar_name", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "[", "'filename'", "]", "\n", "radar_name", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "'RADAR_FRONT'", "]", ")", "[", "'filename'", "]", "\n", "lidar_path", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "lidar_name", ")", "\n", "radar_path", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "radar_name", ")", "\n", "pc1", "=", "LidarPointCloud", ".", "from_file", "(", "lidar_path", ")", "\n", "pc2", "=", "RadarPointCloud", ".", "from_file", "(", "radar_path", ")", "\n", "pc3", ",", "_", "=", "LidarPointCloud", ".", "from_file_multisweep", "(", "nusc", ",", "sample_rec", ",", "'LIDAR_TOP'", ",", "'LIDAR_TOP'", ",", "nsweeps", "=", "2", ")", "\n", "pc4", ",", "_", "=", "RadarPointCloud", ".", "from_file_multisweep", "(", "nusc", ",", "sample_rec", ",", "'RADAR_FRONT'", ",", "'RADAR_FRONT'", ",", "nsweeps", "=", "2", ")", "\n", "\n", "# Check for valid dimensions.", "\n", "assert", "pc1", ".", "points", ".", "shape", "[", "0", "]", "==", "pc3", ".", "points", ".", "shape", "[", "0", "]", "==", "4", ",", "'Error: Invalid dimension for lidar pointcloud!'", "\n", "assert", "pc2", ".", "points", ".", "shape", "[", "0", "]", "==", "pc4", ".", "points", ".", "shape", "[", "0", "]", "==", "18", ",", "'Error: Invalid dimension for radar pointcloud!'", "\n", "assert", "pc1", ".", "points", ".", "dtype", "==", "pc3", ".", "points", ".", "dtype", ",", "'Error: Invalid dtype for lidar pointcloud!'", "\n", "assert", "pc2", ".", "points", ".", "dtype", "==", "pc4", ".", "points", ".", "dtype", ",", "'Error: Invalid dtype for radar pointcloud!'", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_all_maps.TestAllMaps.setUp": [[17, 31], ["dict", "nuscenes.map_expansion.map_api.NuScenesMap", "nuscenes.map_expansion.map_api.NuScenesMap.render_layers", "matplotlib.show"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_layers"], ["def", "setUp", "(", "self", ")", ":", "\n", "        ", "\"\"\" Initialize the map for each location. \"\"\"", "\n", "\n", "self", ".", "nusc_maps", "=", "dict", "(", ")", "\n", "for", "map_name", "in", "locations", ":", "\n", "# Load map.", "\n", "            ", "nusc_map", "=", "NuScenesMap", "(", "map_name", "=", "map_name", ",", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", ")", "\n", "\n", "# Render for debugging.", "\n", "if", "self", ".", "render", ":", "\n", "                ", "nusc_map", ".", "render_layers", "(", "[", "'lane'", "]", ",", "figsize", "=", "1", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "self", ".", "nusc_maps", "[", "map_name", "]", "=", "nusc_map", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_all_maps.TestAllMaps.test_layer_stats": [[32, 51], ["collections.defaultdict", "layer_counts[].append", "len"], "methods", ["None"], ["", "", "def", "test_layer_stats", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test if each layer has the right number of instances. This is useful to compare between map versions. \"\"\"", "\n", "layer_counts", "=", "defaultdict", "(", "lambda", ":", "[", "]", ")", "\n", "ref_counts", "=", "{", "\n", "'singapore-onenorth'", ":", "[", "1", ",", "783", ",", "645", ",", "936", ",", "120", ",", "838", ",", "451", ",", "39", ",", "152", ",", "357", ",", "127", "]", ",", "\n", "'singapore-hollandvillage'", ":", "[", "426", ",", "167", ",", "387", ",", "601", ",", "28", ",", "498", ",", "300", ",", "0", ",", "107", ",", "220", ",", "119", "]", ",", "\n", "'singapore-queenstown'", ":", "[", "219", ",", "260", ",", "676", ",", "910", ",", "75", ",", "457", ",", "437", ",", "40", ",", "172", ",", "257", ",", "81", "]", ",", "\n", "'boston-seaport'", ":", "[", "2", ",", "928", ",", "969", ",", "1215", ",", "340", ",", "301", ",", "775", ",", "275", ",", "377", ",", "671", ",", "307", "]", "\n", "}", "\n", "\n", "for", "map_name", "in", "locations", ":", "\n", "            ", "nusc_map", "=", "self", ".", "nusc_maps", "[", "map_name", "]", "\n", "for", "layer_name", "in", "nusc_map", ".", "non_geometric_layers", ":", "\n", "                ", "layer_objs", "=", "nusc_map", ".", "json_obj", "[", "layer_name", "]", "\n", "layer_counts", "[", "map_name", "]", ".", "append", "(", "len", "(", "layer_objs", ")", ")", "\n", "\n", "", "assert", "ref_counts", "[", "map_name", "]", "==", "layer_counts", "[", "map_name", "]", ",", "'Error: Map %s has a different number of layers: \\n%s vs. \\n%s'", "%", "(", "map_name", ",", "ref_counts", "[", "map_name", "]", ",", "layer_counts", "[", "map_name", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_all_maps.TestAllMaps.test_disconnected_lanes": [[52, 64], ["test_all_maps.TestAllMaps.assertFalse", "nuscenes.map_expansion.utils.get_disconnected_lanes", "len", "print", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.utils.get_disconnected_lanes"], ["", "", "@", "unittest", ".", "skip", "# This test is known to fail on dozens of disconnected lanes.", "\n", "def", "test_disconnected_lanes", "(", "self", ")", ":", "\n", "        ", "\"\"\" Check if any lanes are disconnected. \"\"\"", "\n", "found_error", "=", "False", "\n", "for", "map_name", "in", "locations", ":", "\n", "            ", "nusc_map", "=", "self", ".", "nusc_maps", "[", "map_name", "]", "\n", "disconnected", "=", "get_disconnected_lanes", "(", "nusc_map", ")", "\n", "if", "len", "(", "disconnected", ")", ">", "0", ":", "\n", "                ", "print", "(", "'Error: Missing connectivity in map %s for %d lanes: \\n%s'", "\n", "%", "(", "map_name", ",", "len", "(", "disconnected", ")", ",", "disconnected", ")", ")", "\n", "found_error", "=", "True", "\n", "", "", "self", ".", "assertFalse", "(", "found_error", ",", "'Error: Found missing connectivity. See messages above!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_all_maps.TestAllMaps.test_egoposes_on_map": [[65, 85], ["nuscenes.nuscenes.NuScenes", "tqdm.tqdm", "test_all_maps.TestAllMaps.assertEqual", "nuscenes.nuscenes.NuScenes.get", "nuscenes.map_expansion.utils.get_egoposes_on_drivable_ratio", "len", "print", "invalid_scenes.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.utils.get_egoposes_on_drivable_ratio"], ["", "def", "test_egoposes_on_map", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test that all ego poses land on \"\"\"", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "self", ".", "version", ",", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", ",", "verbose", "=", "False", ")", "\n", "whitelist", "=", "[", "'scene-0499'", ",", "'scene-0501'", ",", "'scene-0502'", ",", "'scene-0515'", ",", "'scene-0517'", "]", "\n", "\n", "invalid_scenes", "=", "[", "]", "\n", "for", "scene", "in", "tqdm", ".", "tqdm", "(", "nusc", ".", "scene", ",", "leave", "=", "False", ")", ":", "\n", "            ", "if", "scene", "[", "'name'", "]", "in", "whitelist", ":", "\n", "                ", "continue", "\n", "\n", "", "log", "=", "nusc", ".", "get", "(", "'log'", ",", "scene", "[", "'log_token'", "]", ")", "\n", "map_name", "=", "log", "[", "'location'", "]", "\n", "nusc_map", "=", "self", ".", "nusc_maps", "[", "map_name", "]", "\n", "ratio_valid", "=", "get_egoposes_on_drivable_ratio", "(", "nusc", ",", "nusc_map", ",", "scene", "[", "'token'", "]", ")", "\n", "if", "ratio_valid", "!=", "1.0", ":", "\n", "                ", "print", "(", "'Error: Scene %s has a ratio of %f ego poses on the driveable area!'", "\n", "%", "(", "scene", "[", "'name'", "]", ",", "ratio_valid", ")", ")", "\n", "invalid_scenes", ".", "append", "(", "scene", "[", "'name'", "]", ")", "\n", "\n", "", "", "self", ".", "assertEqual", "(", "len", "(", "invalid_scenes", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.setUp": [[11, 31], ["None"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "straight_path", "=", "{", "'start_pose'", ":", "[", "421.2419602954602", ",", "1087.9127960414617", ",", "2.739593514975998", "]", ",", "\n", "'end_pose'", ":", "[", "391.7142849867393", ",", "1100.464077182952", ",", "2.7365754617298705", "]", ",", "\n", "'shape'", ":", "'LSR'", ",", "\n", "'radius'", ":", "999.999", ",", "\n", "'segment_length'", ":", "[", "0.23651121617864976", ",", "28.593481378991886", ",", "3.254561444252876", "]", "}", "\n", "self", ".", "left_path", "=", "{", "'start_pose'", ":", "[", "391.7142849867393", ",", "1100.464077182952", ",", "2.7365754617298705", "]", ",", "\n", "'end_pose'", ":", "[", "372.7733659833846", ",", "1093.0160135871615", ",", "-", "2.000208580915862", "]", ",", "\n", "'shape'", ":", "'LSL'", ",", "\n", "'radius'", ":", "14.473414516079979", ",", "\n", "'segment_length'", ":", "[", "22.380622583127813", ",", "0.18854612175175053", ",", "0.0010839266609007578", "]", "}", "\n", "self", ".", "right_path", "=", "{", "'start_pose'", ":", "[", "367.53376358458553", ",", "1097.5300417399676", ",", "1.1738120532326812", "]", ",", "\n", "'end_pose'", ":", "[", "392.24904359636037", ",", "1112.5206834496375", ",", "-", "0.4033046016493182", "]", ",", "\n", "'shape'", ":", "'RSR'", ",", "\n", "'radius'", ":", "16.890467008945414", ",", "\n", "'segment_length'", ":", "[", "4.423187697943063e-05", ",", "6.490596454713637", ",", "26.63819259666578", "]", "}", "\n", "\n", "self", ".", "straight_lane", "=", "[", "self", ".", "straight_path", "]", "\n", "self", ".", "curved_lane", "=", "[", "self", ".", "straight_path", ",", "self", ".", "left_path", "]", "\n", "self", ".", "right_lane", "=", "[", "self", ".", "right_path", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.test_discretize_straight_path": [[32, 42], ["nuscenes.map_expansion.arcline_path_utils.discretize", "numpy.array", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.discretize"], ["", "def", "test_discretize_straight_path", "(", "self", ")", ":", "\n", "\n", "        ", "discrete_path", "=", "arcline_path_utils", ".", "discretize", "(", "self", ".", "straight_path", ",", "10", ")", "\n", "answer", "=", "np", ".", "array", "(", "[", "(", "421.2419602954602", ",", "1087.9127960414617", ",", "2.739593514975998", ")", ",", "\n", "(", "413.85953060356087", ",", "1091.049417600379", ",", "2.739830026428688", ")", ",", "\n", "(", "406.4770899726762", ",", "1094.1860134184205", ",", "2.739830026428688", ")", ",", "\n", "(", "399.0946493417915", ",", "1097.322609236462", ",", "2.739830026428688", ")", ",", "\n", "(", "391.71428498673856", ",", "1100.4640771829522", ",", "2.7365754617298705", ")", "]", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "discrete_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.test_discretize_curved_path": [[43, 61], ["nuscenes.map_expansion.arcline_path_utils.discretize", "numpy.array", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.discretize"], ["", "def", "test_discretize_curved_path", "(", "self", ")", ":", "\n", "\n", "        ", "discrete_path", "=", "arcline_path_utils", ".", "discretize", "(", "self", ".", "left_path", ",", "2", ")", "\n", "answer", "=", "np", ".", "array", "(", "[", "(", "391.7142849867393", ",", "1100.464077182952", ",", "2.7365754617298705", ")", ",", "\n", "(", "389.94237388555354", ",", "1101.0909492468568", ",", "2.8665278225823894", ")", ",", "\n", "(", "388.10416900705434", ",", "1101.4829190922167", ",", "2.996480183434908", ")", ",", "\n", "(", "386.23066958739906", ",", "1101.633376593063", ",", "3.126432544287426", ")", ",", "\n", "(", "384.3534700650694", ",", "1101.539784454639", ",", "-", "3.026800402039642", ")", ",", "\n", "(", "382.50422727657343", ",", "1101.2037210019917", ",", "-", "2.8968480411871234", ")", ",", "\n", "(", "380.714126599876", ",", "1100.630853563314", ",", "-", "2.7668956803346045", ")", ",", "\n", "(", "379.01335604844144", ",", "1099.830842896896", ",", "-", "2.6369433194820857", ")", ",", "\n", "(", "377.4305971846951", ",", "1098.8171802734153", ",", "-", "2.506990958629568", ")", ",", "\n", "(", "375.99254143806974", ",", "1097.6069599609898", ",", "-", "2.377038597777049", ")", ",", "\n", "(", "374.7234399843828", ",", "1096.220590949774", ",", "-", "2.24708623692453", ")", ",", "\n", "(", "373.64469477731785", ",", "1094.6814527775348", ",", "-", "2.117133876072012", ")", ",", "\n", "(", "372.7733659833847", ",", "1093.0160135871613", ",", "-", "2.0002085809158623", ")", "]", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "discrete_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.test_discretize_curved_lane": [[62, 80], ["nuscenes.map_expansion.arcline_path_utils.discretize_lane", "numpy.array", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.discretize_lane"], ["", "def", "test_discretize_curved_lane", "(", "self", ")", ":", "\n", "\n", "        ", "discrete_path", "=", "arcline_path_utils", ".", "discretize_lane", "(", "self", ".", "curved_lane", ",", "5", ")", "\n", "answer", "=", "np", ".", "array", "(", "[", "(", "421.2419602954602", ",", "1087.9127960414617", ",", "2.739593514975998", ")", ",", "\n", "(", "417.0234337310829", ",", "1089.7051622497897", ",", "2.739830026428688", ")", ",", "\n", "(", "412.80489622772023", ",", "1091.497502717242", ",", "2.739830026428688", ")", ",", "\n", "(", "408.5863587243576", ",", "1093.2898431846943", ",", "2.739830026428688", ")", ",", "\n", "(", "404.3678212209949", ",", "1095.0821836521468", ",", "2.739830026428688", ")", ",", "\n", "(", "400.1492837176322", ",", "1096.874524119599", ",", "2.739830026428688", ")", ",", "\n", "(", "395.93074621426956", ",", "1098.6668645870514", ",", "2.739830026428688", ")", ",", "\n", "(", "391.71428498673856", ",", "1100.4640771829522", ",", "2.7365754617298705", ")", ",", "\n", "(", "391.7142849867393", ",", "1100.464077182952", ",", "2.7365754617298705", ")", ",", "\n", "(", "387.35724292592613", ",", "1101.5723176767192", ",", "3.048461127775915", ")", ",", "\n", "(", "382.87033132963325", ",", "1101.2901176788932", ",", "-", "2.922838513357627", ")", ",", "\n", "(", "378.6864775951582", ",", "1099.6447057425564", ",", "-", "2.610952847311582", ")", ",", "\n", "(", "375.20936805976606", ",", "1096.7948422737907", ",", "-", "2.2990671812655377", ")", ",", "\n", "(", "372.7733659833847", ",", "1093.0160135871613", ",", "-", "2.0002085809158623", ")", "]", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "discrete_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.test_length_of_lane": [[81, 91], ["test_arcline_path_utils.TestUtils.assertEqual", "test_arcline_path_utils.TestUtils.assertEqual", "test_arcline_path_utils.TestUtils.assertEqual", "nuscenes.map_expansion.arcline_path_utils.length_of_lane", "sum", "nuscenes.map_expansion.arcline_path_utils.length_of_lane", "sum", "nuscenes.map_expansion.arcline_path_utils.length_of_lane", "sum", "sum"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.length_of_lane", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.length_of_lane", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.length_of_lane"], ["", "def", "test_length_of_lane", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "assertEqual", "(", "arcline_path_utils", ".", "length_of_lane", "(", "self", ".", "straight_lane", ")", ",", "\n", "sum", "(", "self", ".", "straight_path", "[", "'segment_length'", "]", ")", ")", "\n", "\n", "self", ".", "assertEqual", "(", "arcline_path_utils", ".", "length_of_lane", "(", "self", ".", "right_lane", ")", ",", "\n", "sum", "(", "self", ".", "right_path", "[", "'segment_length'", "]", ")", ")", "\n", "\n", "self", ".", "assertEqual", "(", "arcline_path_utils", ".", "length_of_lane", "(", "self", ".", "curved_lane", ")", ",", "\n", "sum", "(", "self", ".", "straight_path", "[", "'segment_length'", "]", ")", "+", "sum", "(", "self", ".", "left_path", "[", "'segment_length'", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.test_project_pose_to_straight_lane": [[92, 101], ["nuscenes.map_expansion.arcline_path_utils.project_pose_to_lane", "numpy.testing.assert_allclose", "test_arcline_path_utils.TestUtils.assertTrue", "numpy.array().astype", "numpy.array().astype", "abs", "math.cos", "math.sin", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.project_pose_to_lane"], ["", "def", "test_project_pose_to_straight_lane", "(", "self", ")", ":", "\n", "\n", "        ", "theta", "=", "2.739593514975998", "\n", "end_pose", "=", "421.2419602954602", "+", "10", "*", "math", ".", "cos", "(", "theta", ")", ",", "1087.9127960414617", "+", "10", "*", "math", ".", "sin", "(", "theta", ")", ",", "theta", "\n", "\n", "pose", ",", "s", "=", "arcline_path_utils", ".", "project_pose_to_lane", "(", "end_pose", ",", "self", ".", "straight_lane", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "np", ".", "array", "(", "pose", ")", ".", "astype", "(", "'int'", ")", ",", "np", ".", "array", "(", "end_pose", ")", ".", "astype", "(", "'int'", ")", ")", "\n", "self", ".", "assertTrue", "(", "abs", "(", "s", "-", "10", ")", "<=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.test_project_pose_not_close_to_lane": [[102, 109], ["nuscenes.map_expansion.arcline_path_utils.project_pose_to_lane", "test_arcline_path_utils.TestUtils.assertListEqual", "test_arcline_path_utils.TestUtils.assertEqual", "list"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.project_pose_to_lane"], ["", "def", "test_project_pose_not_close_to_lane", "(", "self", ")", ":", "\n", "\n", "        ", "pose", "=", "362", ",", "1092", ",", "1.15", "\n", "\n", "pose_on_lane", ",", "s", "=", "arcline_path_utils", ".", "project_pose_to_lane", "(", "pose", ",", "self", ".", "right_lane", ")", "\n", "self", ".", "assertListEqual", "(", "list", "(", "pose_on_lane", ")", ",", "self", ".", "right_path", "[", "'start_pose'", "]", ")", "\n", "self", ".", "assertEqual", "(", "s", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.test_project_pose_to_curved_lane": [[110, 124], ["nuscenes.map_expansion.arcline_path_utils.project_pose_to_lane", "numpy.testing.assert_allclose", "test_arcline_path_utils.TestUtils.assertTrue", "nuscenes.map_expansion.arcline_path_utils.project_pose_to_lane", "numpy.testing.assert_allclose", "test_arcline_path_utils.TestUtils.assertTrue", "numpy.array().astype", "numpy.array().astype", "numpy.array().astype", "numpy.array", "abs", "abs", "math.cos", "math.sin", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.project_pose_to_lane", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.project_pose_to_lane"], ["", "def", "test_project_pose_to_curved_lane", "(", "self", ")", ":", "\n", "\n", "        ", "theta", "=", "2.739593514975998", "\n", "end_pose_1", "=", "421.2419602954602", "+", "10", "*", "math", ".", "cos", "(", "theta", ")", ",", "1087.9127960414617", "+", "10", "*", "math", ".", "sin", "(", "theta", ")", ",", "theta", "\n", "\n", "end_pose_2", "=", "381", ",", "1100", ",", "-", "2.76", "\n", "\n", "pose", ",", "s", "=", "arcline_path_utils", ".", "project_pose_to_lane", "(", "end_pose_1", ",", "self", ".", "curved_lane", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "np", ".", "array", "(", "pose", ")", ".", "astype", "(", "'int'", ")", ",", "np", ".", "array", "(", "end_pose_1", ")", ".", "astype", "(", "'int'", ")", ")", "\n", "self", ".", "assertTrue", "(", "abs", "(", "s", "-", "10", ")", "<=", "0.5", ")", "\n", "\n", "pose_2", ",", "s_2", "=", "arcline_path_utils", ".", "project_pose_to_lane", "(", "end_pose_2", ",", "self", ".", "curved_lane", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "np", ".", "array", "(", "pose_2", "[", ":", "2", "]", ")", ".", "astype", "(", "'int'", ")", ",", "np", ".", "array", "(", "[", "380", ",", "1100", "]", ")", ")", "\n", "self", ".", "assertTrue", "(", "abs", "(", "s_2", "-", "44", ")", "<=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.test_get_curvature_straight_lane": [[125, 129], ["nuscenes.map_expansion.arcline_path_utils.get_curvature_at_distance_along_lane", "test_arcline_path_utils.TestUtils.assertEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.get_curvature_at_distance_along_lane"], ["", "def", "test_get_curvature_straight_lane", "(", "self", ")", ":", "\n", "\n", "        ", "curvature", "=", "arcline_path_utils", ".", "get_curvature_at_distance_along_lane", "(", "15", ",", "self", ".", "straight_lane", ")", "\n", "self", ".", "assertEqual", "(", "curvature", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_arcline_path_utils.TestUtils.test_curvature_curved_lane": [[130, 134], ["nuscenes.map_expansion.arcline_path_utils.get_curvature_at_distance_along_lane", "test_arcline_path_utils.TestUtils.assertEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.get_curvature_at_distance_along_lane"], ["", "def", "test_curvature_curved_lane", "(", "self", ")", ":", "\n", "\n", "        ", "curvature", "=", "arcline_path_utils", ".", "get_curvature_at_distance_along_lane", "(", "53", ",", "self", ".", "curved_lane", ")", "\n", "self", ".", "assertEqual", "(", "curvature", ",", "1", "/", "self", ".", "left_path", "[", "'radius'", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_combinators.TestRasterizer.test": [[14, 33], ["numpy.zeros", "cv2.boxPoints", "cv2.fillPoly", "numpy.zeros", "cv2.boxPoints", "cv2.fillPoly", "nuscenes.prediction.input_representation.combinators.Rasterizer", "nuscenes.prediction.input_representation.combinators.Rasterizer.combine", "numpy.zeros", "cv2.fillPoly", "cv2.fillPoly", "answer.astype.astype.astype", "numpy.testing.assert_allclose", "cv2.fillPoly.astype", "cv2.fillPoly.astype", "numpy.int0", "numpy.int0", "numpy.int0", "numpy.int0"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.combinators.Rasterizer.combine"], ["    ", "def", "test", "(", "self", ")", ":", "\n", "\n", "        ", "layer_1", "=", "np", ".", "zeros", "(", "(", "100", ",", "100", ",", "3", ")", ")", "\n", "box_1", "=", "cv2", ".", "boxPoints", "(", "(", "(", "50", ",", "50", ")", ",", "(", "20", ",", "20", ")", ",", "0", ")", ")", "\n", "layer_1", "=", "cv2", ".", "fillPoly", "(", "layer_1", ",", "pts", "=", "[", "np", ".", "int0", "(", "box_1", ")", "]", ",", "color", "=", "(", "255", ",", "255", ",", "255", ")", ")", "\n", "\n", "layer_2", "=", "np", ".", "zeros", "(", "(", "100", ",", "100", ",", "3", ")", ")", "\n", "box_2", "=", "cv2", ".", "boxPoints", "(", "(", "(", "70", ",", "30", ")", ",", "(", "10", ",", "10", ")", ",", "0", ")", ")", "\n", "layer_2", "=", "cv2", ".", "fillPoly", "(", "layer_2", ",", "pts", "=", "[", "np", ".", "int0", "(", "box_2", ")", "]", ",", "color", "=", "(", "0", ",", "0", ",", "255", ")", ")", "\n", "\n", "rasterizer", "=", "Rasterizer", "(", ")", "\n", "image", "=", "rasterizer", ".", "combine", "(", "[", "layer_1", ".", "astype", "(", "'uint8'", ")", ",", "layer_2", ".", "astype", "(", "'uint8'", ")", "]", ")", "\n", "\n", "answer", "=", "np", ".", "zeros", "(", "(", "100", ",", "100", ",", "3", ")", ")", "\n", "answer", "=", "cv2", ".", "fillPoly", "(", "answer", ",", "pts", "=", "[", "np", ".", "int0", "(", "box_1", ")", "]", ",", "color", "=", "(", "255", ",", "255", ",", "255", ")", ")", "\n", "answer", "=", "cv2", ".", "fillPoly", "(", "answer", ",", "pts", "=", "[", "np", ".", "int0", "(", "box_2", ")", "]", ",", "color", "=", "(", "0", ",", "0", ",", "255", ")", ")", "\n", "answer", "=", "answer", ".", "astype", "(", "'uint8'", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "image", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_agents.Test_get_track_box.test_heading_positive_30": [[18, 37], ["nuscenes.prediction.input_representation.agents.get_track_box", "nuscenes.prediction.helper.make_2d_rotation_matrix", "numpy.array", "numpy.testing.assert_allclose", "numpy.sort", "numpy.sort", "numpy.cos", "numpy.sin", "nuscenes.prediction.helper.make_2d_rotation_matrix.dot"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.get_track_box", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.make_2d_rotation_matrix"], ["    ", "def", "test_heading_positive_30", "(", "self", ")", ":", "\n", "\n", "        ", "annotation", "=", "{", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "'rotation'", ":", "[", "np", ".", "cos", "(", "np", ".", "pi", "/", "12", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "np", ".", "pi", "/", "12", ")", "]", ",", "\n", "'size'", ":", "[", "4", ",", "2", "]", "}", "\n", "\n", "ego_center", "=", "(", "0", ",", "0", ")", "\n", "ego_pixels", "=", "(", "50", ",", "50", ")", "\n", "\n", "pi_over_six", "=", "np", ".", "pi", "/", "6", "\n", "\n", "box", "=", "agents", ".", "get_track_box", "(", "annotation", ",", "ego_center", ",", "ego_pixels", ",", "resolution", "=", "1.", ")", "\n", "\n", "mat", "=", "make_2d_rotation_matrix", "(", "pi_over_six", ")", "\n", "coordinates", "=", "np", ".", "array", "(", "[", "[", "-", "2", ",", "1", "]", ",", "[", "-", "2", ",", "-", "1", "]", ",", "[", "2", ",", "-", "1", "]", ",", "[", "2", ",", "1", "]", "]", ")", "\n", "answer", "=", "mat", ".", "dot", "(", "coordinates", ".", "T", ")", ".", "T", "+", "ego_pixels", "\n", "answer", "=", "answer", "[", ":", ",", "[", "1", ",", "0", "]", "]", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "np", ".", "sort", "(", "answer", ",", "axis", "=", "0", ")", ",", "np", ".", "sort", "(", "box", ",", "axis", "=", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_agents.Test_get_track_box.test_heading_neg_30": [[39, 58], ["nuscenes.prediction.input_representation.agents.get_track_box", "nuscenes.prediction.helper.make_2d_rotation_matrix", "numpy.array", "numpy.testing.assert_allclose", "numpy.sort", "numpy.sort", "numpy.cos", "numpy.sin", "nuscenes.prediction.helper.make_2d_rotation_matrix.dot"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.get_track_box", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.make_2d_rotation_matrix"], ["", "def", "test_heading_neg_30", "(", "self", ")", ":", "\n", "\n", "        ", "annotation", "=", "{", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "'rotation'", ":", "[", "np", ".", "cos", "(", "-", "np", ".", "pi", "/", "12", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "-", "np", ".", "pi", "/", "12", ")", "]", ",", "\n", "'size'", ":", "[", "4", ",", "2", "]", "}", "\n", "\n", "ego_center", "=", "(", "0", ",", "0", ")", "\n", "ego_pixels", "=", "(", "50", ",", "50", ")", "\n", "\n", "pi_over_six", "=", "-", "np", ".", "pi", "/", "6", "\n", "\n", "box", "=", "agents", ".", "get_track_box", "(", "annotation", ",", "ego_center", ",", "ego_pixels", ",", "resolution", "=", "1.", ")", "\n", "\n", "mat", "=", "make_2d_rotation_matrix", "(", "pi_over_six", ")", "\n", "coordinates", "=", "np", ".", "array", "(", "[", "[", "-", "2", ",", "1", "]", ",", "[", "-", "2", ",", "-", "1", "]", ",", "[", "2", ",", "-", "1", "]", ",", "[", "2", ",", "1", "]", "]", ")", "\n", "answer", "=", "mat", ".", "dot", "(", "coordinates", ".", "T", ")", ".", "T", "+", "ego_pixels", "\n", "answer", "=", "answer", "[", ":", ",", "[", "1", ",", "0", "]", "]", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "np", ".", "sort", "(", "answer", ",", "axis", "=", "0", ")", ",", "np", ".", "sort", "(", "box", ",", "axis", "=", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_agents.Test_reverse_history.test": [[62, 75], ["nuscenes.prediction.input_representation.agents.reverse_history", "test_agents.Test_reverse_history.assertDictEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.reverse_history"], ["    ", "def", "test", "(", "self", ")", ":", "\n", "\n", "        ", "history", "=", "{", "'instance_1'", ":", "[", "{", "'time'", ":", "0", "}", ",", "{", "'time'", ":", "-", "1", "}", ",", "{", "'time'", ":", "-", "2", "}", "]", ",", "\n", "'instance_2'", ":", "[", "{", "'time'", ":", "-", "1", "}", ",", "{", "'time'", ":", "-", "2", "}", "]", ",", "\n", "'instance_3'", ":", "[", "{", "'time'", ":", "0", "}", "]", "}", "\n", "\n", "agent_history", "=", "agents", ".", "reverse_history", "(", "history", ")", "\n", "\n", "answer", "=", "{", "'instance_1'", ":", "[", "{", "'time'", ":", "-", "2", "}", ",", "{", "'time'", ":", "-", "1", "}", ",", "{", "'time'", ":", "0", "}", "]", ",", "\n", "'instance_2'", ":", "[", "{", "'time'", ":", "-", "2", "}", ",", "{", "'time'", ":", "-", "1", "}", "]", ",", "\n", "'instance_3'", ":", "[", "{", "'time'", ":", "0", "}", "]", "}", "\n", "\n", "self", ".", "assertDictEqual", "(", "answer", ",", "agent_history", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_agents.Test_add_present_time_to_history.test": [[79, 99], ["nuscenes.prediction.input_representation.agents.add_present_time_to_history", "test_agents.Test_add_present_time_to_history.assertDictEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.add_present_time_to_history"], ["    ", "def", "test", "(", "self", ")", ":", "\n", "\n", "        ", "current_time", "=", "[", "{", "'instance_token'", ":", "0", ",", "'time'", ":", "3", "}", ",", "\n", "{", "'instance_token'", ":", "1", ",", "'time'", ":", "3", "}", ",", "\n", "{", "'instance_token'", ":", "2", ",", "'time'", ":", "3", "}", "]", "\n", "\n", "history", "=", "{", "0", ":", "[", "{", "'instance_token'", ":", "0", ",", "'time'", ":", "1", "}", ",", "\n", "{", "'instance_token'", ":", "0", ",", "'time'", ":", "2", "}", "]", ",", "\n", "1", ":", "[", "{", "'instance_token'", ":", "1", ",", "'time'", ":", "2", "}", "]", "}", "\n", "\n", "history", "=", "agents", ".", "add_present_time_to_history", "(", "current_time", ",", "history", ")", "\n", "\n", "answer", "=", "{", "0", ":", "[", "{", "'instance_token'", ":", "0", ",", "'time'", ":", "1", "}", ",", "\n", "{", "'instance_token'", ":", "0", ",", "'time'", ":", "2", "}", ",", "\n", "{", "'instance_token'", ":", "0", ",", "'time'", ":", "3", "}", "]", ",", "\n", "1", ":", "[", "{", "'instance_token'", ":", "1", ",", "'time'", ":", "2", "}", ",", "\n", "{", "'instance_token'", ":", "1", ",", "'time'", ":", "3", "}", "]", ",", "\n", "2", ":", "[", "{", "'instance_token'", ":", "2", ",", "'time'", ":", "3", "}", "]", "}", "\n", "\n", "self", ".", "assertDictEqual", "(", "answer", ",", "history", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_agents.Test_fade_color.test_dont_fade_last": [[103, 107], ["nuscenes.prediction.input_representation.agents.fade_color", "test_agents.Test_fade_color.assertTupleEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.fade_color"], ["    ", "def", "test_dont_fade_last", "(", "self", ")", ":", "\n", "\n", "        ", "color", "=", "agents", ".", "fade_color", "(", "(", "200", ",", "0", ",", "0", ")", ",", "10", ",", "10", ")", "\n", "self", ".", "assertTupleEqual", "(", "color", ",", "(", "200", ",", "0", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_agents.Test_fade_color.test_first_is_darkest": [[108, 112], ["nuscenes.prediction.input_representation.agents.fade_color", "test_agents.Test_fade_color.assertTupleEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.fade_color"], ["", "def", "test_first_is_darkest", "(", "self", ")", ":", "\n", "\n", "        ", "color", "=", "agents", ".", "fade_color", "(", "(", "200", ",", "200", ",", "0", ")", ",", "0", ",", "10", ")", "\n", "self", ".", "assertTupleEqual", "(", "color", ",", "(", "102", ",", "102", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_agents.TestAgentBoxesWithFadedHistory.test_make_representation": [[116, 162], ["unittest.mock.MagicMock", "nuscenes.prediction.input_representation.agents.AgentBoxesWithFadedHistory", "nuscenes.prediction.input_representation.agents.AgentBoxesWithFadedHistory.make_representation", "numpy.zeros", "cv2.boxPoints", "cv2.boxPoints", "cv2.boxPoints", "cv2.boxPoints", "cv2.fillPoly", "cv2.fillPoly", "cv2.fillPoly", "cv2.fillPoly", "numpy.testing.assert_allclose", "numpy.int0", "numpy.int0", "numpy.int0", "numpy.int0"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.AgentBoxesWithFadedHistory.make_representation"], ["    ", "def", "test_make_representation", "(", "self", ")", ":", "\n", "\n", "        ", "mock_helper", "=", "MagicMock", "(", "spec", "=", "PredictHelper", ")", "\n", "\n", "mock_helper", ".", "get_past_for_sample", ".", "return_value", "=", "{", "0", ":", "[", "{", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "'translation'", ":", "[", "-", "5", ",", "0", ",", "0", "]", ",", "\n", "'size'", ":", "[", "2", ",", "4", ",", "0", "]", ",", "'instance_token'", ":", "0", ",", "\n", "'category_name'", ":", "'vehicle'", "}", "]", ",", "\n", "1", ":", "[", "{", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "'translation'", ":", "[", "5", ",", "-", "5", ",", "0", "]", ",", "\n", "'size'", ":", "[", "3", ",", "3", ",", "0", "]", ",", "'instance_token'", ":", "1", ",", "\n", "'category_name'", ":", "'human'", "}", "]", "}", "\n", "mock_helper", ".", "get_annotations_for_sample", ".", "return_value", "=", "[", "{", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "'size'", ":", "[", "2", ",", "4", ",", "0", "]", ",", "'instance_token'", ":", "0", ",", "\n", "'category_name'", ":", "'vehicle'", "}", ",", "\n", "{", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "'translation'", ":", "[", "10", ",", "-", "5", ",", "0", "]", ",", "\n", "'size'", ":", "[", "3", ",", "3", ",", "0", "]", ",", "'instance_token'", ":", "1", ",", "\n", "'category_name'", ":", "'human'", "}", "]", "\n", "\n", "mock_helper", ".", "get_sample_annotation", ".", "return_value", "=", "{", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "'size'", ":", "[", "2", ",", "4", ",", "0", "]", ",", "'instance_token'", ":", "0", ",", "\n", "'category_name'", ":", "'vehicle'", "}", "\n", "\n", "def", "get_colors", "(", "name", ")", ":", "\n", "            ", "if", "'vehicle'", "in", "name", ":", "\n", "                ", "return", "(", "255", ",", "0", ",", "0", ")", "\n", "", "else", ":", "\n", "                ", "return", "(", "255", ",", "255", ",", "0", ")", "\n", "\n", "", "", "agent_rasterizer", "=", "agents", ".", "AgentBoxesWithFadedHistory", "(", "mock_helper", ",", "\n", "color_mapping", "=", "get_colors", ")", "\n", "\n", "img", "=", "agent_rasterizer", ".", "make_representation", "(", "0", ",", "'foo_sample'", ")", "\n", "\n", "answer", "=", "np", ".", "zeros", "(", "(", "500", ",", "500", ",", "3", ")", ")", "\n", "\n", "agent_0_ts_0", "=", "cv2", ".", "boxPoints", "(", "(", "(", "250", ",", "450", ")", ",", "(", "40", ",", "20", ")", ",", "-", "90", ")", ")", "\n", "angent_0_ts_1", "=", "cv2", ".", "boxPoints", "(", "(", "(", "250", ",", "400", ")", ",", "(", "40", ",", "20", ")", ",", "-", "90", ")", ")", "\n", "\n", "agent_1_ts_0", "=", "cv2", ".", "boxPoints", "(", "(", "(", "300", ",", "350", ")", ",", "(", "30", ",", "30", ")", ",", "-", "90", ")", ")", "\n", "agent_1_ts_1", "=", "cv2", ".", "boxPoints", "(", "(", "(", "300", ",", "300", ")", ",", "(", "30", ",", "30", ")", ",", "-", "90", ")", ")", "\n", "\n", "answer", "=", "cv2", ".", "fillPoly", "(", "answer", ",", "pts", "=", "[", "np", ".", "int0", "(", "agent_0_ts_0", ")", "]", ",", "color", "=", "(", "102", ",", "0", ",", "0", ")", ")", "\n", "answer", "=", "cv2", ".", "fillPoly", "(", "answer", ",", "pts", "=", "[", "np", ".", "int0", "(", "angent_0_ts_1", ")", "]", ",", "color", "=", "(", "255", ",", "0", ",", "0", ")", ")", "\n", "answer", "=", "cv2", ".", "fillPoly", "(", "answer", ",", "pts", "=", "[", "np", ".", "int0", "(", "agent_1_ts_0", ")", "]", ",", "color", "=", "(", "102", ",", "102", ",", "0", ")", ")", "\n", "answer", "=", "cv2", ".", "fillPoly", "(", "answer", ",", "pts", "=", "[", "np", ".", "int0", "(", "agent_1_ts_1", ")", "]", ",", "color", "=", "(", "255", ",", "255", ",", "0", ")", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "img", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.Test_convert_to_pixel_coords.test_above_and_to_the_right": [[8, 27], ["nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "test_utils.Test_convert_to_pixel_coords.assertTupleEqual", "nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "test_utils.Test_convert_to_pixel_coords.assertTupleEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords"], ["    ", "def", "test_above_and_to_the_right", "(", "self", ")", ":", "\n", "\n", "        ", "location", "=", "(", "55", ",", "60", ")", "\n", "center_of_image_in_global", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_pixels", "=", "(", "400", ",", "250", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "\n", "center_of_image_in_global", ",", "\n", "center_of_image_in_pixels", ")", "\n", "\n", "answer", "=", "(", "300", ",", "300", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "\n", "center_of_image_in_global", ",", "\n", "center_of_image_in_pixels", ",", "\n", "resolution", "=", "0.2", ")", "\n", "answer", "=", "(", "350", ",", "275", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.Test_convert_to_pixel_coords.test_above_and_to_the_left": [[28, 43], ["nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "test_utils.Test_convert_to_pixel_coords.assertTupleEqual", "nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "test_utils.Test_convert_to_pixel_coords.assertTupleEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords"], ["", "def", "test_above_and_to_the_left", "(", "self", ")", ":", "\n", "\n", "        ", "location", "=", "(", "40", ",", "70", ")", "\n", "center_of_image_in_global", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_pixels", "=", "(", "300", ",", "300", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "\n", "center_of_image_in_pixels", ")", "\n", "answer", "=", "(", "100", ",", "200", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "\n", "center_of_image_in_pixels", ",", "resolution", "=", "0.2", ")", "\n", "answer", "=", "(", "200", ",", "250", ")", "\n", "self", ".", "assertTupleEqual", "(", "answer", ",", "pixels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.Test_convert_to_pixel_coords.test_below_and_to_the_right": [[44, 53], ["nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "test_utils.Test_convert_to_pixel_coords.assertTupleEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords"], ["", "def", "test_below_and_to_the_right", "(", "self", ")", ":", "\n", "\n", "        ", "location", "=", "(", "60", ",", "45", ")", "\n", "center_of_image_in_global", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_pixels", "=", "(", "400", ",", "250", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "center_of_image_in_pixels", ")", "\n", "answer", "=", "(", "450", ",", "350", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.Test_convert_to_pixel_coords.test_below_and_to_the_left": [[54, 63], ["nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "test_utils.Test_convert_to_pixel_coords.assertTupleEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords"], ["", "def", "test_below_and_to_the_left", "(", "self", ")", ":", "\n", "\n", "        ", "location", "=", "(", "30", ",", "40", ")", "\n", "center_of_image_in_global", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_pixels", "=", "(", "400", ",", "250", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "center_of_image_in_pixels", ")", "\n", "answer", "=", "(", "500", ",", "50", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.Test_convert_to_pixel_coords.test_same_location": [[64, 72], ["nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "test_utils.Test_convert_to_pixel_coords.assertTupleEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords"], ["", "def", "test_same_location", "(", "self", ")", ":", "\n", "\n", "        ", "location", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_global", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_pixels", "=", "(", "400", ",", "250", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "center_of_image_in_pixels", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "(", "400", ",", "250", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.Test_get_crops.test": [[75, 81], ["nuscenes.prediction.input_representation.utils.get_crops", "test_utils.Test_get_crops.assertEqual", "test_utils.Test_get_crops.assertEqual", "slice", "slice"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.get_crops"], ["    ", "def", "test", "(", "self", ")", ":", "\n", "\n", "        ", "row_crop", ",", "col_crop", "=", "utils", ".", "get_crops", "(", "40", ",", "10", ",", "25", ",", "25", ",", "0.1", ",", "800", ")", "\n", "\n", "self", ".", "assertEqual", "(", "row_crop", ",", "slice", "(", "0", ",", "500", ")", ")", "\n", "self", ".", "assertEqual", "(", "col_crop", ",", "slice", "(", "150", ",", "650", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_static_layers.TestStaticLayerRasterizer.get_layer_mocks": [[18, 31], ["numpy.zeros", "cv2.boxPoints", "cv2.fillPoly", "numpy.zeros", "cv2.line", "numpy.int0"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "get_layer_mocks", "(", ")", ":", "\n", "\n", "        ", "layer_1", "=", "np", ".", "zeros", "(", "(", "100", ",", "100", ",", "3", ")", ")", "\n", "box", "=", "cv2", ".", "boxPoints", "(", "(", "(", "50", ",", "50", ")", ",", "(", "20", ",", "10", ")", ",", "-", "90", ")", ")", "\n", "layer_1", "=", "cv2", ".", "fillPoly", "(", "layer_1", ",", "pts", "=", "[", "np", ".", "int0", "(", "box", ")", "]", ",", "color", "=", "(", "1", ",", "1", ",", "1", ")", ")", "\n", "layer_1", "=", "layer_1", "[", ":", ":", "-", "1", ",", ":", ",", "0", "]", "\n", "\n", "layer_2", "=", "np", ".", "zeros", "(", "(", "100", ",", "100", ",", "3", ")", ")", "\n", "layer_2", "=", "cv2", ".", "line", "(", "layer_2", ",", "(", "50", ",", "50", ")", ",", "(", "50", ",", "40", ")", ",", "color", "=", "(", "1", ",", "0", ",", "0", ")", ",", "thickness", "=", "2", ")", "\n", "layer_2", "=", "layer_2", "[", ":", ":", "-", "1", ",", ":", ",", "0", "]", "\n", "\n", "return", "[", "layer_1", ",", "layer_2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_static_layers.TestStaticLayerRasterizer.test_draw_lanes_on_image": [[32, 48], ["numpy.zeros", "nuscenes.prediction.input_representation.static_layers.draw_lanes_on_image", "numpy.zeros", "cv2.line", "cv2.line", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.draw_lanes_on_image"], ["", "def", "test_draw_lanes_on_image", "(", "self", ")", ":", "\n", "\n", "        ", "image", "=", "np", ".", "zeros", "(", "(", "200", ",", "200", ",", "3", ")", ")", "\n", "lanes", "=", "{", "'lane_1'", ":", "[", "(", "15", ",", "0", ",", "0", ")", ",", "(", "15", ",", "10", ",", "0", ")", ",", "(", "15", ",", "20", ",", "0", ")", "]", ",", "\n", "'lane_2'", ":", "[", "(", "0", ",", "15", ",", "0", ")", ",", "(", "10", ",", "15", ",", "0", ")", ",", "(", "20", ",", "15", ",", "0", ")", "]", "}", "\n", "\n", "def", "color_function", "(", "heading_1", ",", "heading_2", ")", ":", "\n", "            ", "return", "0", ",", "200", ",", "200", "\n", "\n", "", "img", "=", "draw_lanes_on_image", "(", "image", ",", "lanes", ",", "(", "10", ",", "10", ")", ",", "0", ",", "(", "100", ",", "100", ")", ",", "0.1", ",", "color_function", ")", "\n", "\n", "answer", "=", "np", ".", "zeros", "(", "(", "200", ",", "200", ",", "3", ")", ")", "\n", "cv2", ".", "line", "(", "answer", ",", "(", "150", ",", "0", ")", ",", "(", "150", ",", "200", ")", ",", "[", "0", ",", "200", ",", "200", "]", ",", "thickness", "=", "5", ")", "\n", "cv2", ".", "line", "(", "answer", ",", "(", "0", ",", "50", ")", ",", "(", "200", ",", "50", ")", ",", "[", "0", ",", "200", ",", "200", "]", ",", "thickness", "=", "5", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_static_layers.TestStaticLayerRasterizer.test_make_rasterization": [[49, 89], ["unittest.mock.patch", "unittest.mock.patch", "numpy.zeros().astype", "cv2.boxPoints", "cv2.fillPoly", "test_static_layers.TestStaticLayerRasterizer.get_layer_mocks", "unittest.mock.MagicMock", "unittest.mock.MagicMock", "nuscenes.prediction.input_representation.static_layers.StaticLayerRasterizer", "nuscenes.prediction.input_representation.static_layers.StaticLayerRasterizer.make_representation", "numpy.zeros", "cv2.boxPoints", "cv2.fillPoly", "cv2.line", "cv2.fillPoly", "numpy.testing.assert_allclose", "PATH.format", "PATH.format", "numpy.zeros", "numpy.int0", "numpy.int0", "numpy.int0"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_static_layers.TestStaticLayerRasterizer.get_layer_mocks", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.AgentBoxesWithFadedHistory.make_representation"], ["", "@", "patch", "(", "PATH", ".", "format", "(", "'load_all_maps'", ")", ")", "\n", "@", "patch", "(", "PATH", ".", "format", "(", "'draw_lanes_in_agent_frame'", ")", ")", "\n", "def", "test_make_rasterization", "(", "self", ",", "mock_draw_lanes", ",", "mock_load_maps", ")", ":", "\n", "        ", "\"\"\"\n        Mainly a smoke test since most of the logic is handled under-the-hood\n        by get_map_mask method of nuScenes map API.\n        \"\"\"", "\n", "\n", "lanes", "=", "np", ".", "zeros", "(", "(", "100", ",", "100", ",", "3", ")", ")", ".", "astype", "(", "'uint8'", ")", "\n", "lane_box", "=", "cv2", ".", "boxPoints", "(", "(", "(", "25", ",", "75", ")", ",", "(", "5", ",", "5", ")", ",", "-", "90", ")", ")", "\n", "lanes", "=", "cv2", ".", "fillPoly", "(", "lanes", ",", "pts", "=", "[", "np", ".", "int0", "(", "lane_box", ")", "]", ",", "color", "=", "(", "255", ",", "0", ",", "0", ")", ")", "\n", "mock_draw_lanes", ".", "return_value", "=", "lanes", "\n", "\n", "layers", "=", "self", ".", "get_layer_mocks", "(", ")", "\n", "mock_map_api", "=", "MagicMock", "(", ")", "\n", "mock_map_api", ".", "get_map_mask", ".", "return_value", "=", "layers", "\n", "\n", "mock_maps", "=", "{", "'mock_map_version'", ":", "mock_map_api", "}", "\n", "\n", "mock_load_maps", ".", "return_value", "=", "mock_maps", "\n", "\n", "mock_helper", "=", "MagicMock", "(", "spec", "=", "PredictHelper", ")", "\n", "mock_helper", ".", "get_map_name_from_sample_token", ".", "return_value", "=", "'mock_map_version'", "\n", "mock_helper", ".", "get_sample_annotation", ".", "return_value", "=", "{", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "'rotation'", ":", "[", "-", "np", ".", "pi", "/", "8", ",", "0", ",", "0", ",", "-", "np", ".", "pi", "/", "8", "]", "}", "\n", "\n", "static_layers", "=", "StaticLayerRasterizer", "(", "mock_helper", ",", "[", "'layer_1'", ",", "'layer_2'", "]", ",", "\n", "[", "(", "255", ",", "255", ",", "255", ")", ",", "(", "255", ",", "0", ",", "0", ")", "]", ",", "\n", "resolution", "=", "0.1", ",", "meters_ahead", "=", "5", ",", "meters_behind", "=", "5", ",", "\n", "meters_left", "=", "5", ",", "meters_right", "=", "5", ")", "\n", "\n", "image", "=", "static_layers", ".", "make_representation", "(", "'foo_instance'", ",", "'foo_sample'", ")", "\n", "\n", "answer", "=", "np", ".", "zeros", "(", "(", "100", ",", "100", ",", "3", ")", ")", "\n", "box", "=", "cv2", ".", "boxPoints", "(", "(", "(", "50", ",", "50", ")", ",", "(", "20", ",", "10", ")", ",", "-", "90", ")", ")", "\n", "answer", "=", "cv2", ".", "fillPoly", "(", "answer", ",", "pts", "=", "[", "np", ".", "int0", "(", "box", ")", "]", ",", "color", "=", "(", "255", ",", "255", ",", "255", ")", ")", "\n", "answer", "=", "cv2", ".", "line", "(", "answer", ",", "(", "50", ",", "50", ")", ",", "(", "50", ",", "40", ")", ",", "color", "=", "(", "255", ",", "0", ",", "0", ")", ",", "thickness", "=", "2", ")", "\n", "answer", "=", "cv2", ".", "fillPoly", "(", "answer", ",", "pts", "=", "[", "np", ".", "int0", "(", "lane_box", ")", "]", ",", "color", "=", "(", "255", ",", "0", ",", "0", ")", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "image", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_backbone.TestBackBones.count_layers": [[14, 23], ["isinstance", "isinstance", "ValueError", "sum", "len", "range"], "methods", ["None"], ["    ", "def", "count_layers", "(", "self", ",", "model", ")", ":", "\n", "        ", "if", "isinstance", "(", "model", "[", "4", "]", "[", "0", "]", ",", "BasicBlock", ")", ":", "\n", "            ", "n_convs", "=", "2", "\n", "", "elif", "isinstance", "(", "model", "[", "4", "]", "[", "0", "]", ",", "Bottleneck", ")", ":", "\n", "            ", "n_convs", "=", "3", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Backbone layer block not supported!\"", ")", "\n", "\n", "", "return", "sum", "(", "[", "len", "(", "model", "[", "i", "]", ")", "for", "i", "in", "range", "(", "4", ",", "8", ")", "]", ")", "*", "n_convs", "+", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_backbone.TestBackBones.test_resnet": [[24, 48], ["nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.backbone.ResNetBackbone", "torch.ones", "test_backbone.TestBackBones.assertEqual", "test_backbone.TestBackBones.assertEqual", "test_backbone.TestBackBones.assertEqual", "test_backbone.TestBackBones.assertEqual", "test_backbone.TestBackBones.assertAlmostEqual", "test_backbone.TestBackBones.assertEqual", "test_backbone.TestBackBones.assertEqual", "test_backbone.TestBackBones.assertEqual", "test_backbone.TestBackBones.assertEqual", "test_backbone.TestBackBones.assertEqual", "test_backbone.TestBackBones.count_layers", "test_backbone.TestBackBones.count_layers", "test_backbone.TestBackBones.count_layers", "test_backbone.TestBackBones.count_layers", "test_backbone.TestBackBones.count_layers", "test_backbone.TestBackBones.assertRaises", "nuscenes.prediction.models.backbone.ResNetBackbone", "list", "list", "list", "list", "list", "nuscenes.prediction.models.backbone.ResNetBackbone.", "nuscenes.prediction.models.backbone.ResNetBackbone.", "nuscenes.prediction.models.backbone.ResNetBackbone.", "nuscenes.prediction.models.backbone.ResNetBackbone.", "nuscenes.prediction.models.backbone.ResNetBackbone.", "nuscenes.prediction.models.backbone.ResNetBackbone.backbone.children", "nuscenes.prediction.models.backbone.ResNetBackbone.backbone.children", "nuscenes.prediction.models.backbone.ResNetBackbone.backbone.children", "nuscenes.prediction.models.backbone.ResNetBackbone.backbone.children", "nuscenes.prediction.models.backbone.ResNetBackbone.backbone.children"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_backbone.TestBackBones.count_layers", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_backbone.TestBackBones.count_layers", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_backbone.TestBackBones.count_layers", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_backbone.TestBackBones.count_layers", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_backbone.TestBackBones.count_layers"], ["", "def", "test_resnet", "(", "self", ")", ":", "\n", "\n", "        ", "rn_18", "=", "ResNetBackbone", "(", "'resnet18'", ")", "\n", "rn_34", "=", "ResNetBackbone", "(", "'resnet34'", ")", "\n", "rn_50", "=", "ResNetBackbone", "(", "'resnet50'", ")", "\n", "rn_101", "=", "ResNetBackbone", "(", "'resnet101'", ")", "\n", "rn_152", "=", "ResNetBackbone", "(", "'resnet152'", ")", "\n", "\n", "tensor", "=", "torch", ".", "ones", "(", "(", "1", ",", "3", ",", "100", ",", "100", ")", ")", "\n", "\n", "self", ".", "assertEqual", "(", "rn_18", "(", "tensor", ")", ".", "shape", "[", "1", "]", ",", "512", ")", "\n", "self", ".", "assertEqual", "(", "rn_34", "(", "tensor", ")", ".", "shape", "[", "1", "]", ",", "512", ")", "\n", "self", ".", "assertEqual", "(", "rn_50", "(", "tensor", ")", ".", "shape", "[", "1", "]", ",", "2048", ")", "\n", "self", ".", "assertEqual", "(", "rn_101", "(", "tensor", ")", ".", "shape", "[", "1", "]", ",", "2048", ")", "\n", "self", ".", "assertAlmostEqual", "(", "rn_152", "(", "tensor", ")", ".", "shape", "[", "1", "]", ",", "2048", ")", "\n", "\n", "self", ".", "assertEqual", "(", "self", ".", "count_layers", "(", "list", "(", "rn_18", ".", "backbone", ".", "children", "(", ")", ")", ")", ",", "18", ")", "\n", "self", ".", "assertEqual", "(", "self", ".", "count_layers", "(", "list", "(", "rn_34", ".", "backbone", ".", "children", "(", ")", ")", ")", ",", "34", ")", "\n", "self", ".", "assertEqual", "(", "self", ".", "count_layers", "(", "list", "(", "rn_50", ".", "backbone", ".", "children", "(", ")", ")", ")", ",", "50", ")", "\n", "self", ".", "assertEqual", "(", "self", ".", "count_layers", "(", "list", "(", "rn_101", ".", "backbone", ".", "children", "(", ")", ")", ")", ",", "101", ")", "\n", "self", ".", "assertEqual", "(", "self", ".", "count_layers", "(", "list", "(", "rn_152", ".", "backbone", ".", "children", "(", ")", ")", ")", ",", "152", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "ResNetBackbone", "(", "'resnet51'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_backbone.TestBackBones.test_mobilenet": [[49, 56], ["nuscenes.prediction.models.backbone.MobileNetBackbone", "torch.ones", "test_backbone.TestBackBones.assertEqual", "nuscenes.prediction.models.backbone.MobileNetBackbone."], "methods", ["None"], ["", "", "def", "test_mobilenet", "(", "self", ")", ":", "\n", "\n", "        ", "mobilenet", "=", "MobileNetBackbone", "(", "'mobilenet_v2'", ")", "\n", "\n", "tensor", "=", "torch", ".", "ones", "(", "(", "1", ",", "3", ",", "100", ",", "100", ")", ")", "\n", "\n", "self", ".", "assertEqual", "(", "mobilenet", "(", "tensor", ")", ".", "shape", "[", "1", "]", ",", "1280", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.MockNuScenes.__init__": [[16, 21], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "sample_annotations", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", ",", "\n", "samples", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.MockNuScenes.sample_annotation": [[22, 25], ["list", "test_predict_helper.MockNuScenes._sample_annotation.values"], "methods", ["None"], ["\n", "self", ".", "_sample_annotation", "=", "{", "r", "[", "'token'", "]", ":", "r", "for", "r", "in", "sample_annotations", "}", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.MockNuScenes.get": [[26, 29], ["getattr"], "methods", ["None"], ["self", ".", "_sample", "=", "{", "r", "[", "'token'", "]", ":", "r", "for", "r", "in", "samples", "}", "\n", "\n", "", "@", "property", "\n", "def", "sample_annotation", "(", "self", ")", "->", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertGlobalCoordsToLocal.setUp": [[39, 60], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.arange", "numpy.arange", "numpy.zeros", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", "->", "None", ":", "\n", "# Creating 5 different trajectories to be shared by", "\n", "# coordinate frame rotation unit tests.", "\n", "# These trajectories go along each of the axes in", "\n", "# the x-y plane as well as the line y=x", "\n", "        ", "along_pos_x", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "along_pos_y", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "along_neg_x", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "along_neg_y", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "\n", "along_pos_x", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "along_pos_y", "[", ":", ",", "1", "]", "=", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "along_neg_x", "[", ":", ",", "0", "]", "=", "-", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "along_neg_y", "[", ":", ",", "1", "]", "=", "-", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "self", ".", "along_pos_x", ",", "self", ".", "along_pos_y", "=", "along_pos_x", ",", "along_pos_y", "\n", "self", ".", "along_neg_x", ",", "self", ".", "along_neg_y", "=", "along_neg_x", ",", "along_neg_y", "\n", "\n", "y_equals_x", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "y_equals_x", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "y_equals_x", "[", ":", ",", "1", "]", "=", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "self", ".", "y_equals_x", "=", "y_equals_x", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertGlobalCoordsToLocal._run": [[61, 100], ["nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local"], ["", "def", "_run", "(", "self", ",", "\n", "rotation", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "origin", ":", "Tuple", "[", "float", ",", "float", ",", "float", "]", ",", "\n", "offset", ":", "Tuple", "[", "float", ",", "float", ",", "float", "]", ",", "\n", "along_pos_x_answer", ":", "np", ".", "ndarray", ",", "\n", "along_pos_y_answer", ":", "np", ".", "ndarray", ",", "\n", "along_neg_x_answer", ":", "np", ".", "ndarray", ",", "\n", "along_neg_y_answer", ":", "np", ".", "ndarray", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "offset_as_list", "=", "[", "[", "offset", "[", "0", "]", ",", "offset", "[", "1", "]", "]", "]", "\n", "\n", "# Testing path along pos x direction", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_pos_x", ",", "origin", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_pos_x_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_pos_x", "+", "offset_as_list", ",", "offset", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_pos_x_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "# Testing path along pos y direction", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_pos_y", ",", "origin", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_pos_y_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_pos_y", "+", "offset_as_list", ",", "offset", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_pos_y_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "# Testing path along neg x direction", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_neg_x", ",", "origin", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_neg_x_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_neg_x", "+", "offset_as_list", ",", "offset", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_neg_x_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "# Testing path along neg y direction", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_neg_y", ",", "origin", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_neg_y_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_neg_y", "+", "offset_as_list", ",", "offset", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_neg_y_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertGlobalCoordsToLocal.test_heading_0": [[101, 109], ["test_predict_helper.TestConvertGlobalCoordsToLocal._run"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_heading_0", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "1", ",", "0", ",", "0", ",", "0", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "along_pos_y", ",", "\n", "along_pos_y_answer", "=", "self", ".", "along_neg_x", ",", "\n", "along_neg_x_answer", "=", "self", ".", "along_neg_y", ",", "\n", "along_neg_y_answer", "=", "self", ".", "along_pos_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertGlobalCoordsToLocal.test_heading_pi_over_4": [[110, 118], ["test_predict_helper.TestConvertGlobalCoordsToLocal._run", "numpy.cos", "numpy.sin", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_heading_pi_over_4", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "np", ".", "pi", "/", "8", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "np", ".", "pi", "/", "8", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "y_equals_x", "*", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "\n", "along_pos_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertGlobalCoordsToLocal.test_heading_pi_over_2": [[119, 127], ["test_predict_helper.TestConvertGlobalCoordsToLocal._run", "numpy.cos", "numpy.sin"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_heading_pi_over_2", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "np", ".", "pi", "/", "4", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "np", ".", "pi", "/", "4", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "along_pos_x", ",", "\n", "along_pos_y_answer", "=", "self", ".", "along_pos_y", ",", "\n", "along_neg_x_answer", "=", "self", ".", "along_neg_x", ",", "\n", "along_neg_y_answer", "=", "self", ".", "along_neg_y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertGlobalCoordsToLocal.test_heading_3pi_over_4": [[128, 136], ["test_predict_helper.TestConvertGlobalCoordsToLocal._run", "numpy.cos", "numpy.sin", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_heading_3pi_over_4", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "3", "*", "np", ".", "pi", "/", "8", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "3", "*", "np", ".", "pi", "/", "8", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_pos_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertGlobalCoordsToLocal.test_heading_pi": [[137, 145], ["test_predict_helper.TestConvertGlobalCoordsToLocal._run", "numpy.cos", "numpy.sin"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_heading_pi", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "np", ".", "pi", "/", "2", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "np", ".", "pi", "/", "2", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "along_neg_y", ",", "\n", "along_pos_y_answer", "=", "self", ".", "along_pos_x", ",", "\n", "along_neg_x_answer", "=", "self", ".", "along_pos_y", ",", "\n", "along_neg_y_answer", "=", "self", ".", "along_neg_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertGlobalCoordsToLocal.test_heading_neg_pi_over_4": [[146, 154], ["test_predict_helper.TestConvertGlobalCoordsToLocal._run", "numpy.cos", "numpy.sin", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_heading_neg_pi_over_4", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "-", "np", ".", "pi", "/", "8", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "-", "np", ".", "pi", "/", "8", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_pos_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.setUp": [[348, 376], ["numpy.sqrt", "numpy.sqrt"], "methods", ["None"], ["{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "2e6", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "3e6", "}", ",", "\n", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "4e6", "}", "]", "\n", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "multiagent_mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "future", "=", "helper", ".", "get_future_for_sample", "(", "'1'", ",", "3", ",", "False", ")", "\n", "\n", "answer", "=", "{", "'1'", ":", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", "]", ")", ",", "\n", "'2'", ":", "np", ".", "array", "(", "[", "[", "7", ",", "7", "]", ",", "[", "8", ",", "8", "]", ",", "[", "9", ",", "9", "]", "]", ")", "}", "\n", "\n", "for", "k", "in", "answer", ":", "\n", "            ", "np", ".", "testing", ".", "assert_equal", "(", "answer", "[", "k", "]", ",", "future", "[", "k", "]", ")", "\n", "\n", "", "future_in_sample", "=", "helper", ".", "get_future_for_sample", "(", "'1'", ",", "3", ",", "True", ")", "\n", "\n", "answer_in_sample", "=", "{", "'1'", ":", "np", ".", "array", "(", "[", "[", "-", "1", ",", "1", "]", ",", "[", "-", "2", ",", "2", "]", ",", "[", "-", "3", ",", "3", "]", "]", ")", ",", "\n", "'2'", ":", "np", ".", "array", "(", "[", "[", "-", "1", ",", "1", "]", ",", "[", "-", "2", ",", "2", "]", ",", "[", "-", "3", ",", "3", "]", "]", ")", "}", "\n", "\n", "for", "k", "in", "answer_in_sample", ":", "\n", "            ", "np", ".", "testing", ".", "assert_allclose", "(", "answer_in_sample", "[", "k", "]", ",", "future_in_sample", "[", "k", "]", ")", "\n", "\n", "", "", "def", "test_get_past_for_sample", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "0", ",", "'anns'", ":", "[", "'5'", ",", "'5b'", "]", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "-", "1e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "-", "2e6", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "-", "3e6", "}", ",", "\n", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "-", "4e6", "}", "]", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_sample_annotation": [[377, 387], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertDictEqual", "nuscenes.prediction.PredictHelper.get_sample_annotation"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_sample_annotation"], ["\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "multiagent_mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "past", "=", "helper", ".", "get_past_for_sample", "(", "'5'", ",", "3", ",", "True", ")", "\n", "\n", "answer", "=", "{", "'1'", ":", "np", ".", "array", "(", "[", "[", "1", ",", "-", "1", "]", ",", "[", "2", ",", "-", "2", "]", ",", "[", "3", ",", "-", "3", "]", "]", ")", ",", "\n", "'2'", ":", "np", ".", "array", "(", "[", "[", "1", ",", "-", "1", "]", ",", "[", "2", ",", "-", "2", "]", ",", "[", "3", ",", "-", "3", "]", "]", ")", "}", "\n", "\n", "for", "k", "in", "answer", ":", "\n", "            ", "np", ".", "testing", ".", "assert_allclose", "(", "past", "[", "k", "]", ",", "answer", "[", "k", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_future_for_agent_exact_amount": [[388, 401], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_future_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent"], ["\n", "", "", "def", "test_velocity", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "0.5e6", "}", "]", "\n", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "\n", "self", ".", "assertEqual", "(", "helper", ".", "get_velocity_for_agent", "(", "\"1\"", ",", "\"2\"", ")", ",", "np", ".", "sqrt", "(", "8", ")", ")", "\n", "\n", "", "def", "test_velocity_return_nan_one_obs", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", "]", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_future_for_agent_in_agent_frame": [[402, 413], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_future_for_agent", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent"], ["nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "\n", "self", ".", "assertTrue", "(", "np", ".", "isnan", "(", "helper", ".", "get_velocity_for_agent", "(", "'1'", ",", "'1'", ")", ")", ")", "\n", "\n", "", "def", "test_velocity_return_nan_big_diff", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "2.5e6", "}", "]", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "isnan", "(", "helper", ".", "get_velocity_for_agent", "(", "'1'", ",", "'2'", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_future_for_agent_less_amount": [[414, 427], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_future_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent"], ["", "def", "test_heading_change_rate", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "0.5e6", "}", "]", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "self", ".", "assertEqual", "(", "helper", ".", "get_heading_change_rate_for_agent", "(", "'1'", ",", "'2'", ")", ",", "np", ".", "pi", ")", "\n", "\n", "", "def", "test_heading_change_rate_near_pi", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "0.5e6", "}", "]", "\n", "mock_annotations", "=", "copy", ".", "copy", "(", "self", ".", "mock_annotations", ")", "\n", "mock_annotations", "[", "0", "]", "[", "'rotation'", "]", "=", "[", "np", ".", "cos", "(", "(", "np", ".", "pi", "-", "0.05", ")", "/", "2", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "(", "np", ".", "pi", "-", "0.05", ")", "/", "2", ")", "]", "\n", "mock_annotations", "[", "1", "]", "[", "'rotation'", "]", "=", "[", "np", ".", "cos", "(", "(", "-", "np", ".", "pi", "+", "0.05", ")", "/", "2", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "(", "-", "np", ".", "pi", "+", "0.05", ")", "/", "2", ")", "]", "\n", "nusc", "=", "MockNuScenes", "(", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "self", ".", "assertAlmostEqual", "(", "helper", ".", "get_heading_change_rate_for_agent", "(", "'1'", ",", "'2'", ")", ",", "0.2", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_future_for_agent_within_buffer": [[428, 441], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_future_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent"], ["\n", "", "def", "test_acceleration_zero", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "0.5e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "1e6", "}", "]", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "self", ".", "assertEqual", "(", "helper", ".", "get_acceleration_for_agent", "(", "'1'", ",", "'3'", ")", ",", "0", ")", "\n", "\n", "", "def", "test_acceleration_nonzero", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "0.5e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "1e6", "}", "]", "\n", "mock_annotations", "=", "copy", ".", "copy", "(", "self", ".", "mock_annotations", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_future_for_agent_no_data_to_get": [[442, 451], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_future_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent"], ["mock_annotations", "[", "2", "]", "[", "'translation'", "]", "=", "[", "3", ",", "3", ",", "3", "]", "\n", "nusc", "=", "MockNuScenes", "(", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "self", ".", "assertAlmostEqual", "(", "helper", ".", "get_acceleration_for_agent", "(", "'1'", ",", "'3'", ")", ",", "2", "*", "(", "np", ".", "sqrt", "(", "32", ")", "-", "np", ".", "sqrt", "(", "8", ")", ")", ")", "\n", "\n", "", "def", "test_acceleration_nan_not_enough_data", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "0.5e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "1e6", "}", "]", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_future_for_last_returns_nothing": [[452, 460], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_future_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent"], ["helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "isnan", "(", "helper", ".", "get_acceleration_for_agent", "(", "'1'", ",", "'2'", ")", ")", ")", "\n", "\n", "", "def", "test_get_no_data_when_seconds_0", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", ",", "'anns'", ":", "[", "'1'", "]", "}", "]", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "helper", ".", "get_future_for_agent", "(", "'1'", ",", "'1'", ",", "0", ",", "False", ")", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_past_for_agent_exact_amount": [[461, 474], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_past_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_agent"], ["np", ".", "testing", ".", "assert_equal", "(", "helper", ".", "get_past_for_agent", "(", "'1'", ",", "'1'", ",", "0", ",", "False", ")", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "helper", ".", "get_future_for_sample", "(", "'1'", ",", "0", ",", "False", ")", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "helper", ".", "get_past_for_sample", "(", "'1'", ",", "0", ",", "False", ")", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n", "\n", "", "def", "test_raises_error_when_seconds_negative", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", ",", "'anns'", ":", "[", "'1'", ",", "'1b'", "]", "}", "]", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "helper", ".", "get_future_for_agent", "(", "'1'", ",", "'1'", ",", "-", "1", ",", "False", ")", "\n", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "helper", ".", "get_past_for_agent", "(", "'1'", ",", "'1'", ",", "-", "1", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_past_for_agent_in_frame": [[475, 488], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_past_for_agent", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_agent"], ["", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "helper", ".", "get_past_for_sample", "(", "'1'", ",", "-", "1", ",", "False", ")", "\n", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "            ", "helper", ".", "get_future_for_sample", "(", "'1'", ",", "-", "1", ",", "False", ")", "\n", "\n", "", "", "def", "test_get_annotations_for_sample", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "-", "4e6", ",", "'anns'", ":", "[", "'1'", ",", "'1b'", "]", "}", "]", "\n", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "multiagent_mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "annotations", "=", "helper", ".", "get_annotations_for_sample", "(", "'1'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_past_for_agent_less_amount": [[489, 502], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_past_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_agent"], ["answer", "=", "[", "{", "'token'", ":", "'1'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'1'", ",", "\n", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "''", ",", "'next'", ":", "'2'", "}", ",", "\n", "{", "'token'", ":", "'1b'", ",", "'instance_token'", ":", "'2'", ",", "'sample_token'", ":", "'1'", ",", "\n", "'translation'", ":", "[", "6", ",", "6", ",", "6", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "''", ",", "'next'", ":", "'2b'", "}", "]", "\n", "\n", "self", ".", "assertListEqual", "(", "annotations", ",", "answer", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_past_for_agent_within_buffer": [[503, 515], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_past_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_past_for_agent_no_data_to_get": [[516, 525], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_past_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_past_for_last_returns_nothing": [[526, 534], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_past_for_agent", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_future_for_sample": [[535, 560], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_future_for_sample", "nuscenes.prediction.PredictHelper.get_future_for_sample", "numpy.array", "numpy.array", "numpy.testing.assert_equal", "numpy.array", "numpy.array", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_sample", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_sample"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_past_for_sample": [[561, 578], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_past_for_sample", "numpy.array", "numpy.array", "numpy.testing.assert_equal"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_sample"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_velocity": [[579, 588], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertEqual", "nuscenes.prediction.PredictHelper.get_velocity_for_agent", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_velocity_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_velocity_return_nan_one_obs": [[589, 596], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertTrue", "numpy.isnan", "nuscenes.prediction.PredictHelper.get_velocity_for_agent"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_velocity_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_velocity_return_nan_big_diff": [[597, 603], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertTrue", "numpy.isnan", "nuscenes.prediction.PredictHelper.get_velocity_for_agent"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_velocity_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_heading_change_rate": [[604, 609], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertEqual", "nuscenes.prediction.PredictHelper.get_heading_change_rate_for_agent"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_heading_change_rate_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_heading_change_rate_near_pi": [[610, 618], ["copy.copy", "test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertAlmostEqual", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin", "nuscenes.prediction.PredictHelper.get_heading_change_rate_for_agent"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_heading_change_rate_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_acceleration_zero": [[619, 626], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertEqual", "nuscenes.prediction.PredictHelper.get_acceleration_for_agent"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_acceleration_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_acceleration_nonzero": [[627, 636], ["copy.copy", "test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertAlmostEqual", "nuscenes.prediction.PredictHelper.get_acceleration_for_agent", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_acceleration_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_acceleration_nan_not_enough_data": [[637, 644], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertTrue", "numpy.isnan", "nuscenes.prediction.PredictHelper.get_acceleration_for_agent"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_acceleration_for_agent"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_no_data_when_seconds_0": [[645, 654], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "nuscenes.prediction.PredictHelper.get_future_for_agent", "numpy.array", "nuscenes.prediction.PredictHelper.get_past_for_agent", "numpy.array", "nuscenes.prediction.PredictHelper.get_future_for_sample", "numpy.array", "nuscenes.prediction.PredictHelper.get_past_for_sample", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_agent", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_sample", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_sample"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_raises_error_when_seconds_negative": [[655, 670], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "test_predict_helper.TestPredictHelper.assertRaises", "nuscenes.prediction.PredictHelper.get_future_for_agent", "test_predict_helper.TestPredictHelper.assertRaises", "nuscenes.prediction.PredictHelper.get_past_for_agent", "test_predict_helper.TestPredictHelper.assertRaises", "nuscenes.prediction.PredictHelper.get_past_for_sample", "test_predict_helper.TestPredictHelper.assertRaises", "nuscenes.prediction.PredictHelper.get_future_for_sample"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_agent", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_sample", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_sample"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestPredictHelper.test_get_annotations_for_sample": [[481, 497], ["test_predict_helper.MockNuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.prediction.PredictHelper.get_annotations_for_sample", "test_predict_helper.TestPredictHelper.assertListEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_annotations_for_sample"], ["", "", "def", "test_get_annotations_for_sample", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "-", "4e6", ",", "'anns'", ":", "[", "'1'", ",", "'1b'", "]", "}", "]", "\n", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "multiagent_mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "annotations", "=", "helper", ".", "get_annotations_for_sample", "(", "'1'", ")", "\n", "\n", "answer", "=", "[", "{", "'token'", ":", "'1'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'1'", ",", "\n", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "''", ",", "'next'", ":", "'2'", "}", ",", "\n", "{", "'token'", ":", "'1b'", ",", "'instance_token'", ":", "'2'", ",", "'sample_token'", ":", "'1'", ",", "\n", "'translation'", ":", "[", "6", ",", "6", ",", "6", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "''", ",", "'next'", ":", "'2b'", "}", "]", "\n", "\n", "self", ".", "assertListEqual", "(", "annotations", ",", "answer", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.run_covernet.Dataset.__iter__": [[30, 38], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "run_covernet.generate_trajectory", "generate_trajectory.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.run_covernet.generate_trajectory"], ["def", "__iter__", "(", "self", ",", ")", ":", "\n", "\n", "        ", "while", "True", ":", "\n", "            ", "image", "=", "torch", ".", "zeros", "(", "(", "3", ",", "100", ",", "100", ")", ")", "\n", "agent_state_vector", "=", "torch", ".", "ones", "(", "3", ")", "\n", "ground_truth", "=", "generate_trajectory", "(", "math", ".", "pi", "/", "2", ")", "\n", "\n", "yield", "image", ",", "agent_state_vector", ",", "ground_truth", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.run_covernet.generate_trajectory": [[20, 25], ["torch.zeros", "torch.zeros", "torch.arange", "torch.arange", "math.cos", "torch.arange", "torch.arange", "math.sin"], "function", ["None"], ["def", "generate_trajectory", "(", "theta", ":", "float", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "trajectory", "=", "torch", ".", "zeros", "(", "6", ",", "2", ")", "\n", "trajectory", "[", ":", ",", "0", "]", "=", "torch", ".", "arange", "(", "6", ")", "*", "math", ".", "cos", "(", "theta", ")", "\n", "trajectory", "[", ":", ",", "1", "]", "=", "torch", ".", "arange", "(", "6", ")", "*", "math", ".", "sin", "(", "theta", ")", "\n", "return", "trajectory", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP.setUp": [[14, 19], ["torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "image", "=", "torch", ".", "ones", "(", "(", "1", ",", "3", ",", "100", ",", "100", ")", ")", "\n", "self", ".", "agent_state_vector", "=", "torch", ".", "ones", "(", "(", "1", ",", "3", ")", ")", "\n", "self", ".", "image_5", "=", "torch", ".", "ones", "(", "(", "5", ",", "3", ",", "100", ",", "100", ")", ")", "\n", "self", ".", "agent_state_vector_5", "=", "torch", ".", "ones", "(", "(", "5", ",", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run": [[20, 30], ["model", "model", "test_mtp.TestMTP.assertTupleEqual", "test_mtp.TestMTP.assertTupleEqual", "model", "test_mtp.TestMTP.assertTrue", "torch.allclose", "pred[].sum", "torch.ones"], "methods", ["None"], ["", "def", "_run", "(", "self", ",", "model", ")", ":", "\n", "        ", "pred", "=", "model", "(", "self", ".", "image", ",", "self", ".", "agent_state_vector", ")", "\n", "pred_5", "=", "model", "(", "self", ".", "image_5", ",", "self", ".", "agent_state_vector_5", ")", "\n", "\n", "self", ".", "assertTupleEqual", "(", "pred", ".", "shape", ",", "(", "1", ",", "75", ")", ")", "\n", "self", ".", "assertTupleEqual", "(", "pred_5", ".", "shape", ",", "(", "5", ",", "75", ")", ")", "\n", "\n", "model", ".", "training", "=", "False", "\n", "pred", "=", "model", "(", "self", ".", "image", ",", "self", ".", "agent_state_vector", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "pred", "[", ":", ",", "-", "3", ":", "]", ".", "sum", "(", "axis", "=", "1", ")", ",", "torch", ".", "ones", "(", "pred", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP.test_works_with_resnet_18": [[31, 35], ["nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.mtp.MTP", "test_mtp.TestMTP._run"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_works_with_resnet_18", "(", "self", ",", ")", ":", "\n", "        ", "rn_18", "=", "backbone", ".", "ResNetBackbone", "(", "'resnet18'", ")", "\n", "model", "=", "mtp", ".", "MTP", "(", "rn_18", ",", "3", ",", "6", ",", "2", ",", "input_shape", "=", "(", "3", ",", "100", ",", "100", ")", ")", "\n", "self", ".", "_run", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP.test_works_with_resnet_34": [[36, 40], ["nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.mtp.MTP", "test_mtp.TestMTP._run"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_works_with_resnet_34", "(", "self", ",", ")", ":", "\n", "        ", "rn_34", "=", "backbone", ".", "ResNetBackbone", "(", "'resnet34'", ")", "\n", "model", "=", "mtp", ".", "MTP", "(", "rn_34", ",", "3", ",", "6", ",", "2", ",", "input_shape", "=", "(", "3", ",", "100", ",", "100", ")", ")", "\n", "self", ".", "_run", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP.test_works_with_resnet_50": [[41, 45], ["nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.mtp.MTP", "test_mtp.TestMTP._run"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_works_with_resnet_50", "(", "self", ",", ")", ":", "\n", "        ", "rn_50", "=", "backbone", ".", "ResNetBackbone", "(", "'resnet50'", ")", "\n", "model", "=", "mtp", ".", "MTP", "(", "rn_50", ",", "3", ",", "6", ",", "2", ",", "input_shape", "=", "(", "3", ",", "100", ",", "100", ")", ")", "\n", "self", ".", "_run", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP.test_works_with_resnet_101": [[46, 50], ["nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.mtp.MTP", "test_mtp.TestMTP._run"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_works_with_resnet_101", "(", "self", ",", ")", ":", "\n", "        ", "rn_101", "=", "backbone", ".", "ResNetBackbone", "(", "'resnet101'", ")", "\n", "model", "=", "mtp", ".", "MTP", "(", "rn_101", ",", "3", ",", "6", ",", "2", ",", "input_shape", "=", "(", "3", ",", "100", ",", "100", ")", ")", "\n", "self", ".", "_run", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP.test_works_with_resnet_152": [[51, 55], ["nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.mtp.MTP", "test_mtp.TestMTP._run"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_works_with_resnet_152", "(", "self", ",", ")", ":", "\n", "        ", "rn_152", "=", "backbone", ".", "ResNetBackbone", "(", "'resnet152'", ")", "\n", "model", "=", "mtp", ".", "MTP", "(", "rn_152", ",", "3", ",", "6", ",", "2", ",", "input_shape", "=", "(", "3", ",", "100", ",", "100", ")", ")", "\n", "self", ".", "_run", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP.test_works_with_mobilenet_v2": [[56, 60], ["nuscenes.prediction.models.backbone.MobileNetBackbone", "nuscenes.prediction.models.mtp.MTP", "test_mtp.TestMTP._run"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp.TestMTP._run"], ["", "def", "test_works_with_mobilenet_v2", "(", "self", ",", ")", ":", "\n", "        ", "mobilenet", "=", "backbone", ".", "MobileNetBackbone", "(", "'mobilenet_v2'", ")", "\n", "model", "=", "mtp", ".", "MTP", "(", "mobilenet", ",", "3", ",", "6", ",", "2", ",", "input_shape", "=", "(", "3", ",", "100", ",", "100", ")", ")", "\n", "self", ".", "_run", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_physics_models.TestPhysicsBaselines.test_Baselines_raise_error_when_sec_from_now_bad": [[12, 22], ["nuscenes.prediction.models.physics.PhysicsOracle", "nuscenes.prediction.models.physics.ConstantVelocityHeading", "test_physics_models.TestPhysicsBaselines.assertRaises", "nuscenes.prediction.models.physics.ConstantVelocityHeading", "test_physics_models.TestPhysicsBaselines.assertRaises", "nuscenes.prediction.models.physics.PhysicsOracle"], "methods", ["None"], ["    ", "def", "test_Baselines_raise_error_when_sec_from_now_bad", "(", "self", ")", ":", "\n", "\n", "        ", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "ConstantVelocityHeading", "(", "2.23", ",", "None", ")", "\n", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "PhysicsOracle", "(", "2.25", ",", "None", ")", "\n", "\n", "", "PhysicsOracle", "(", "5.5", ",", "None", ")", "\n", "ConstantVelocityHeading", "(", "3", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_physics_models.TestPhysicsBaselines.test_ConstantVelocityHeading": [[23, 39], ["unittest.mock.patch", "unittest.mock.MagicMock", "nuscenes.prediction.models.physics.ConstantVelocityHeading", "nuscenes.prediction.models.physics.ConstantVelocityHeading.", "numpy.array", "numpy.testing.assert_allclose", "numpy.round"], "methods", ["None"], ["", "@", "patch", "(", "'nuscenes.prediction.models.physics._kinematics_from_tokens'", ")", "\n", "def", "test_ConstantVelocityHeading", "(", "self", ",", "mock_kinematics", ")", ":", "\n", "\n", "        ", "mock_helper", "=", "MagicMock", "(", "spec", "=", "PredictHelper", ")", "\n", "mock_helper", ".", "get_sample_annotation", ".", "return_value", "=", "{", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", "}", "\n", "\n", "# x, y, vx, vy, ax, ay, velocity, yaw_rate, acceleration, yaw", "\n", "mock_kinematics", ".", "return_value", "=", "0", ",", "0", ",", "1", ",", "0", ",", "2", ",", "0", ",", "1", ",", "0", ",", "2", ",", "0", "\n", "\n", "cv_model", "=", "ConstantVelocityHeading", "(", "6", ",", "mock_helper", ")", "\n", "prediction", "=", "cv_model", "(", "'foo-instance_bar-sample'", ")", "\n", "\n", "answer", "=", "np", ".", "array", "(", "[", "[", "[", "0.5", ",", "0", "]", ",", "[", "1", ",", "0", "]", ",", "[", "1.5", ",", "0", "]", ",", "[", "2.0", ",", "0", "]", ",", "[", "2.5", ",", "0", "]", ",", "[", "3.0", ",", "0", "]", ",", "\n", "[", "3.5", ",", "0.0", "]", ",", "[", "4.0", ",", "0", "]", ",", "[", "4.5", ",", "0", "]", ",", "[", "5.0", ",", "0", "]", ",", "[", "5.5", ",", "0", "]", ",", "[", "6.0", ",", "0", "]", "]", "]", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "np", ".", "round", "(", "prediction", ".", "prediction", ",", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_physics_models.TestPhysicsBaselines.test_PhysicsOracle": [[40, 61], ["unittest.mock.patch", "unittest.mock.MagicMock", "numpy.array", "nuscenes.prediction.models.physics.PhysicsOracle", "nuscenes.prediction.models.physics.PhysicsOracle.", "numpy.array", "numpy.testing.assert_allclose", "numpy.round"], "methods", ["None"], ["", "@", "patch", "(", "'nuscenes.prediction.models.physics._kinematics_from_tokens'", ")", "\n", "def", "test_PhysicsOracle", "(", "self", ",", "mock_kinematics", ")", ":", "\n", "\n", "        ", "mock_helper", "=", "MagicMock", "(", "spec", "=", "PredictHelper", ")", "\n", "mock_helper", ".", "get_sample_annotation", ".", "return_value", "=", "{", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", "}", "\n", "\n", "# Made to look like constant acceleration and heading", "\n", "mock_helper", ".", "get_future_for_agent", ".", "return_value", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1.3", "]", ",", "[", "0", ",", "2.9", "]", ",", "[", "0", ",", "5.2", "]", ",", "[", "0", ",", "8.3", "]", ",", "[", "0", ",", "11.3", "]", ",", "\n", "[", "0", ",", "14.6", "]", ",", "[", "0", ",", "19.29", "]", ",", "[", "0", ",", "23.7", "]", ",", "[", "0", ",", "29.19", "]", ",", "\n", "[", "0", ",", "33.", "]", ",", "[", "0", ",", "41.3", "]", ",", "[", "0", ",", "48.2", "]", "]", ")", "\n", "\n", "# x, y, vx, vy, ax, ay, velocity, yaw_rate, acceleration, yaw", "\n", "mock_kinematics", ".", "return_value", "=", "0", ",", "0", ",", "0", ",", "2", ",", "0", ",", "2", ",", "2", ",", "0.05", ",", "2", ",", "0", "\n", "\n", "oracle", "=", "PhysicsOracle", "(", "6", ",", "mock_helper", ")", "\n", "prediction", "=", "oracle", "(", "'foo-instance_bar-sample'", ")", "\n", "\n", "answer", "=", "np", ".", "array", "(", "[", "[", "[", "0.", ",", "1.25", "]", ",", "[", "0.", ",", "3.", "]", ",", "[", "0.", ",", "5.25", "]", ",", "[", "0.", ",", "8.", "]", ",", "[", "0.", ",", "11.25", "]", ",", "[", "0.", ",", "15.", "]", ",", "\n", "[", "0.", ",", "19.25", "]", ",", "[", "0.", ",", "24.", "]", ",", "[", "0.", ",", "29.25", "]", ",", "[", "0.", ",", "35.", "]", ",", "[", "0.", ",", "41.25", "]", ",", "[", "0.", ",", "48.", "]", "]", "]", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "np", ".", "round", "(", "prediction", ".", "prediction", ",", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_physics_models.TestPhysicsBaselines.test_PhysicsOracle_raises_error_when_not_enough_gt": [[62, 79], ["unittest.mock.patch", "unittest.mock.MagicMock", "numpy.array", "nuscenes.prediction.models.physics.PhysicsOracle", "test_physics_models.TestPhysicsBaselines.assertRaises", "nuscenes.prediction.models.physics.PhysicsOracle."], "methods", ["None"], ["", "@", "patch", "(", "'nuscenes.prediction.models.physics._kinematics_from_tokens'", ")", "\n", "def", "test_PhysicsOracle_raises_error_when_not_enough_gt", "(", "self", ",", "mock_kinematics", ")", ":", "\n", "\n", "        ", "mock_helper", "=", "MagicMock", "(", "spec", "=", "PredictHelper", ")", "\n", "mock_helper", ".", "get_sample_annotation", ".", "return_value", "=", "{", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", "}", "\n", "\n", "# Made to look like constant acceleration and heading", "\n", "mock_helper", ".", "get_future_for_agent", ".", "return_value", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1.3", "]", ",", "[", "0", ",", "2.9", "]", ",", "[", "0", ",", "5.2", "]", ",", "[", "0", ",", "8.3", "]", ",", "[", "0", ",", "11.3", "]", ",", "\n", "[", "0", ",", "14.6", "]", ",", "[", "0", ",", "19.29", "]", ",", "[", "0", ",", "23.7", "]", ",", "[", "0", ",", "29.19", "]", ",", "\n", "[", "0", ",", "33.", "]", "]", ")", "\n", "\n", "# x, y, vx, vy, ax, ay, velocity, yaw_rate, acceleration, yaw", "\n", "mock_kinematics", ".", "return_value", "=", "0", ",", "0", ",", "0", ",", "2", ",", "0", ",", "2", ",", "2", ",", "0.05", ",", "2", ",", "0", "\n", "\n", "oracle", "=", "PhysicsOracle", "(", "6", ",", "mock_helper", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "oracle", "(", "'foo-instance_bar-sample'", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp_loss.TestMTPLoss.test_get_trajectories_and_modes": [[19, 55], ["nuscenes.prediction.models.mtp.MTPLoss", "nuscenes.prediction.models.mtp.MTPLoss", "torch.arange().view().repeat().view", "torch.arange().view", "torch.cat", "torch.cat.repeat", "nuscenes.prediction.models.mtp.MTPLoss._get_trajectory_and_modes", "test_mtp_loss.TestMTPLoss.assertTrue", "test_mtp_loss.TestMTPLoss.assertTrue", "nuscenes.prediction.models.mtp.MTPLoss._get_trajectory_and_modes", "test_mtp_loss.TestMTPLoss.assertTrue", "test_mtp_loss.TestMTPLoss.assertTrue", "torch.arange().view().repeat().view", "torch.arange().view", "torch.cat", "torch.cat.repeat", "nuscenes.prediction.models.mtp.MTPLoss._get_trajectory_and_modes", "test_mtp_loss.TestMTPLoss.assertTrue", "test_mtp_loss.TestMTPLoss.assertTrue", "nuscenes.prediction.models.mtp.MTPLoss._get_trajectory_and_modes", "test_mtp_loss.TestMTPLoss.assertTrue", "test_mtp_loss.TestMTPLoss.assertTrue", "torch.allclose", "torch.allclose", "torch.allclose", "torch.allclose", "torch.allclose", "torch.allclose", "torch.allclose", "torch.allclose", "torch.arange().view().repeat", "torch.arange", "torch.arange().view().repeat().view.reshape", "torch.arange().view().repeat().view.unsqueeze().reshape", "torch.arange().view().repeat().view.repeat().unsqueeze().reshape", "torch.arange().view.repeat", "torch.arange().view().repeat", "torch.arange", "torch.arange().view().repeat().view.reshape", "torch.arange().view().repeat().view.unsqueeze().reshape", "torch.arange().view().repeat().view.repeat().unsqueeze().reshape", "torch.arange().view.repeat", "torch.arange().view", "torch.arange().view().repeat().view.unsqueeze", "torch.arange().view().repeat().view.repeat().unsqueeze", "torch.arange().view", "torch.arange().view().repeat().view.unsqueeze", "torch.arange().view().repeat().view.repeat().unsqueeze", "torch.arange", "torch.arange().view().repeat().view.repeat", "torch.arange", "torch.arange().view().repeat().view.repeat"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._get_trajectory_and_modes", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._get_trajectory_and_modes", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._get_trajectory_and_modes", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._get_trajectory_and_modes"], ["def", "test_get_trajectories_and_modes", "(", "self", ")", ":", "\n", "\n", "        ", "loss_n_modes_5", "=", "mtp", ".", "MTPLoss", "(", "5", ",", "0", ",", "0", ")", "\n", "loss_n_modes_1", "=", "mtp", ".", "MTPLoss", "(", "1", ",", "0", ",", "0", ")", "\n", "\n", "xy_pred", "=", "torch", ".", "arange", "(", "60", ")", ".", "view", "(", "1", ",", "-", "1", ")", ".", "repeat", "(", "1", ",", "5", ")", ".", "view", "(", "-", "1", ",", "60", ")", "\n", "mode_pred", "=", "torch", ".", "arange", "(", "5", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "\n", "prediction_bs_1", "=", "torch", ".", "cat", "(", "[", "xy_pred", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "mode_pred", "]", ",", "dim", "=", "1", ")", "\n", "prediction_bs_2", "=", "prediction_bs_1", ".", "repeat", "(", "2", ",", "1", ")", "\n", "\n", "# Testing many modes with batch size 1.", "\n", "traj", ",", "modes", "=", "loss_n_modes_5", ".", "_get_trajectory_and_modes", "(", "prediction_bs_1", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "traj", ",", "xy_pred", ".", "unsqueeze", "(", "0", ")", ".", "reshape", "(", "1", ",", "5", ",", "30", ",", "2", ")", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "modes", ",", "mode_pred", ")", ")", "\n", "\n", "# Testing many modes with batch size > 1.", "\n", "traj", ",", "modes", "=", "loss_n_modes_5", ".", "_get_trajectory_and_modes", "(", "prediction_bs_2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "traj", ",", "xy_pred", ".", "repeat", "(", "1", ",", "2", ")", ".", "unsqueeze", "(", "0", ")", ".", "reshape", "(", "2", ",", "5", ",", "30", ",", "2", ")", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "modes", ",", "mode_pred", ".", "repeat", "(", "2", ",", "1", ")", ")", ")", "\n", "\n", "xy_pred", "=", "torch", ".", "arange", "(", "60", ")", ".", "view", "(", "1", ",", "-", "1", ")", ".", "repeat", "(", "1", ",", "1", ")", ".", "view", "(", "-", "1", ",", "60", ")", "\n", "mode_pred", "=", "torch", ".", "arange", "(", "1", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "\n", "prediction_bs_1", "=", "torch", ".", "cat", "(", "[", "xy_pred", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "mode_pred", "]", ",", "dim", "=", "1", ")", "\n", "prediction_bs_2", "=", "prediction_bs_1", ".", "repeat", "(", "2", ",", "1", ")", "\n", "\n", "# Testing one mode with batch size 1.", "\n", "traj", ",", "modes", "=", "loss_n_modes_1", ".", "_get_trajectory_and_modes", "(", "prediction_bs_1", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "traj", ",", "xy_pred", ".", "unsqueeze", "(", "0", ")", ".", "reshape", "(", "1", ",", "1", ",", "30", ",", "2", ")", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "modes", ",", "mode_pred", ")", ")", "\n", "\n", "# Testing one mode with batch size > 1.", "\n", "traj", ",", "modes", "=", "loss_n_modes_1", ".", "_get_trajectory_and_modes", "(", "prediction_bs_2", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "traj", ",", "xy_pred", ".", "repeat", "(", "1", ",", "2", ")", ".", "unsqueeze", "(", "0", ")", ".", "reshape", "(", "2", ",", "1", ",", "30", ",", "2", ")", ")", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "allclose", "(", "modes", ",", "mode_pred", ".", "repeat", "(", "2", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp_loss.TestMTPLoss.test_angle_between_trajectories": [[56, 94], ["nuscenes.prediction.models.mtp.MTPLoss", "test_mtp_loss.TestMTPLoss.assertEqual", "test_mtp_loss.TestMTPLoss.assertEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "torch.zeros", "torch.Tensor", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "nuscenes.prediction.models.mtp.MTPLoss._angle_between", "test_mtp_loss.TestMTPLoss.test_angle_between_trajectories.make_trajectory"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between"], ["", "def", "test_angle_between_trajectories", "(", "self", ")", ":", "\n", "\n", "        ", "def", "make_trajectory", "(", "last_point", ")", ":", "\n", "            ", "traj", "=", "torch", ".", "zeros", "(", "(", "12", ",", "2", ")", ")", "\n", "traj", "[", "-", "1", "]", "=", "torch", ".", "Tensor", "(", "last_point", ")", "\n", "return", "traj", "\n", "\n", "", "loss", "=", "mtp", ".", "MTPLoss", "(", "0", ",", "0", ",", "0", ")", "\n", "\n", "# test angle is 0.", "\n", "self", ".", "assertEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "0", ",", "0", "]", ")", ",", "make_trajectory", "(", "[", "0", ",", "0", "]", ")", ")", ",", "0.", ")", "\n", "self", ".", "assertEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "15", ",", "15", "]", ")", ",", "make_trajectory", "(", "[", "15", ",", "15", "]", ")", ")", ",", "0.", ")", "\n", "\n", "# test angle is 15.", "\n", "self", ".", "assertAlmostEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "1", ",", "1", "]", ")", ",", "\n", "make_trajectory", "(", "[", "math", ".", "sqrt", "(", "3", ")", "/", "2", ",", "0.5", "]", ")", ")", ",", "15.", ",", "places", "=", "4", ")", "\n", "\n", "# test angle is 30.", "\n", "self", ".", "assertAlmostEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "1", ",", "0", "]", ")", ",", "\n", "make_trajectory", "(", "[", "math", ".", "sqrt", "(", "3", ")", "/", "2", ",", "0.5", "]", ")", ")", ",", "30.", ",", "places", "=", "4", ")", "\n", "\n", "# test angle is 45.", "\n", "self", ".", "assertAlmostEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "1", ",", "1", "]", ")", ",", "\n", "make_trajectory", "(", "[", "0", ",", "1", "]", ")", ")", ",", "45.", ",", "places", "=", "4", ")", "\n", "\n", "# test angle is 90.", "\n", "self", ".", "assertAlmostEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "1", ",", "1", "]", ")", ",", "\n", "make_trajectory", "(", "[", "-", "1", ",", "1", "]", ")", ")", ",", "90.", ",", "places", "=", "4", ")", "\n", "self", ".", "assertAlmostEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "1", ",", "0", "]", ")", ",", "\n", "make_trajectory", "(", "[", "0", ",", "1", "]", ")", ")", ",", "90.", ",", "places", "=", "4", ")", "\n", "\n", "# test angle is 180.", "\n", "self", ".", "assertAlmostEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "1", ",", "0", "]", ")", ",", "\n", "make_trajectory", "(", "[", "-", "1", ",", "0", "]", ")", ")", ",", "180.", ",", "places", "=", "4", ")", "\n", "self", ".", "assertAlmostEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "0", ",", "1", "]", ")", ",", "\n", "make_trajectory", "(", "[", "0", ",", "-", "1", "]", ")", ")", ",", "180.", ",", "places", "=", "4", ")", "\n", "self", ".", "assertAlmostEqual", "(", "loss", ".", "_angle_between", "(", "make_trajectory", "(", "[", "3", ",", "1", "]", ")", ",", "\n", "make_trajectory", "(", "[", "-", "3", ",", "-", "1", "]", ")", ")", ",", "180.", ",", "places", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp_loss.TestMTPLoss.test_compute_best_mode_nothing_below_threshold": [[95, 105], ["nuscenes.prediction.models.mtp.MTPLoss", "test_mtp_loss.TestMTPLoss.assertTrue", "nuscenes.prediction.models.mtp.MTPLoss", "test_mtp_loss.TestMTPLoss.assertTrue", "nuscenes.prediction.models.mtp.MTPLoss._compute_best_mode", "nuscenes.prediction.models.mtp.MTPLoss._compute_best_mode"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_best_mode", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_best_mode"], ["", "def", "test_compute_best_mode_nothing_below_threshold", "(", "self", ")", ":", "\n", "        ", "angles", "=", "[", "(", "90", ",", "0", ")", ",", "(", "80", ",", "1", ")", ",", "(", "70", ",", "2", ")", "]", "\n", "target", "=", "None", "\n", "traj", "=", "None", "\n", "\n", "loss", "=", "mtp", ".", "MTPLoss", "(", "3", ",", "0", ",", "5", ")", "\n", "self", ".", "assertTrue", "(", "loss", ".", "_compute_best_mode", "(", "angles", ",", "target", ",", "traj", ")", "in", "{", "0", ",", "1", ",", "2", "}", ")", "\n", "\n", "loss", "=", "mtp", ".", "MTPLoss", "(", "3", ",", "0", ",", "65", ")", "\n", "self", ".", "assertTrue", "(", "loss", ".", "_compute_best_mode", "(", "angles", ",", "target", ",", "traj", ")", "in", "{", "0", ",", "1", ",", "2", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp_loss.TestMTPLoss.test_compute_best_mode_only_one_below_threshold": [[106, 114], ["torch.ones", "torch.zeros", "nuscenes.prediction.models.mtp.MTPLoss", "test_mtp_loss.TestMTPLoss.assertEqual", "nuscenes.prediction.models.mtp.MTPLoss._compute_best_mode"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_best_mode"], ["", "def", "test_compute_best_mode_only_one_below_threshold", "(", "self", ")", ":", "\n", "        ", "angles", "=", "[", "(", "30", ",", "1", ")", ",", "(", "3", ",", "0", ")", ",", "(", "25", ",", "2", ")", "]", "\n", "\n", "target", "=", "torch", ".", "ones", "(", "(", "1", ",", "6", ",", "2", ")", ")", "\n", "trajectory", "=", "torch", ".", "zeros", "(", "(", "3", ",", "6", ",", "2", ")", ")", "\n", "\n", "loss", "=", "mtp", ".", "MTPLoss", "(", "3", ",", "0", ",", "5", ")", "\n", "self", ".", "assertEqual", "(", "loss", ".", "_compute_best_mode", "(", "angles", ",", "target", ",", "trajectory", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp_loss.TestMTPLoss.test_compute_best_mode_multiple_below_threshold": [[115, 123], ["torch.ones", "torch.zeros", "nuscenes.prediction.models.mtp.MTPLoss", "test_mtp_loss.TestMTPLoss.assertEqual", "nuscenes.prediction.models.mtp.MTPLoss._compute_best_mode"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_best_mode"], ["", "def", "test_compute_best_mode_multiple_below_threshold", "(", "self", ")", ":", "\n", "        ", "angles", "=", "[", "(", "2", ",", "2", ")", ",", "(", "4", ",", "1", ")", ",", "(", "10", ",", "0", ")", "]", "\n", "target", "=", "torch", ".", "ones", "(", "(", "1", ",", "6", ",", "2", ")", ")", "\n", "trajectory", "=", "torch", ".", "zeros", "(", "(", "3", ",", "6", ",", "2", ")", ")", "\n", "trajectory", "[", "1", "]", "=", "1", "\n", "\n", "loss", "=", "mtp", ".", "MTPLoss", "(", "3", ",", "0", ",", "5", ")", "\n", "self", ".", "assertEqual", "(", "loss", ".", "_compute_best_mode", "(", "angles", ",", "target", ",", "trajectory", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp_loss.TestMTPLoss.test_compute_best_mode_only_one_mode": [[124, 134], ["torch.ones", "torch.zeros", "nuscenes.prediction.models.mtp.MTPLoss", "test_mtp_loss.TestMTPLoss.assertEqual", "test_mtp_loss.TestMTPLoss.assertEqual", "nuscenes.prediction.models.mtp.MTPLoss._compute_best_mode", "nuscenes.prediction.models.mtp.MTPLoss._compute_best_mode"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_best_mode", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_best_mode"], ["", "def", "test_compute_best_mode_only_one_mode", "(", "self", ")", ":", "\n", "        ", "angles", "=", "[", "(", "25", ",", "0", ")", "]", "\n", "target", "=", "torch", ".", "ones", "(", "(", "1", ",", "6", ",", "2", ")", ")", "\n", "trajectory", "=", "torch", ".", "zeros", "(", "(", "1", ",", "6", ",", "2", ")", ")", "\n", "\n", "loss", "=", "mtp", ".", "MTPLoss", "(", "1", ",", "0", ",", "5", ")", "\n", "self", ".", "assertEqual", "(", "loss", ".", "_compute_best_mode", "(", "angles", ",", "target", ",", "trajectory", ")", ",", "0", ")", "\n", "\n", "trajectory", "[", "0", "]", "=", "1", "\n", "self", ".", "assertEqual", "(", "loss", ".", "_compute_best_mode", "(", "angles", ",", "target", ",", "trajectory", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp_loss.TestMTPLoss.test_loss_single_mode": [[135, 160], ["torch.zeros", "torch.arange", "torch.ones", "targets[].reshape", "nuscenes.prediction.models.mtp.MTPLoss", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "float", "float", "float", "nuscenes.prediction.models.mtp.MTPLoss.detach().numpy", "nuscenes.prediction.models.mtp.MTPLoss.detach().numpy", "nuscenes.prediction.models.mtp.MTPLoss.detach().numpy", "nuscenes.prediction.models.mtp.MTPLoss.detach", "nuscenes.prediction.models.mtp.MTPLoss.detach", "nuscenes.prediction.models.mtp.MTPLoss.detach", "nuscenes.prediction.models.mtp.MTPLoss.", "nuscenes.prediction.models.mtp.MTPLoss.", "nuscenes.prediction.models.mtp.MTPLoss."], "methods", ["None"], ["", "def", "test_loss_single_mode", "(", "self", ")", ":", "\n", "        ", "targets", "=", "torch", ".", "zeros", "(", "(", "16", ",", "1", ",", "30", ",", "2", ")", ")", "\n", "targets", "[", ":", ",", ":", ",", ":", ",", "1", "]", "=", "torch", ".", "arange", "(", "start", "=", "0", ",", "end", "=", "3", ",", "step", "=", "0.1", ")", "\n", "\n", "predictions", "=", "torch", ".", "ones", "(", "(", "16", ",", "61", ")", ")", "\n", "predictions", "[", ":", ",", ":", "60", "]", "=", "targets", "[", "0", ",", "0", ",", ":", ",", ":", "]", ".", "reshape", "(", "-", "1", ",", "60", ")", "\n", "predictions", "[", ":", ",", "60", "]", "=", "1", "/", "10", "\n", "\n", "loss", "=", "mtp", ".", "MTPLoss", "(", "1", ",", "1", ",", "angle_threshold_degrees", "=", "20", ")", "\n", "\n", "# Only regression loss in single mode case.", "\n", "self", ".", "assertAlmostEqual", "(", "float", "(", "loss", "(", "predictions", ",", "targets", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "0", ",", "places", "=", "4", ")", "\n", "\n", "# Now the best mode differs by 1 from the ground truth.", "\n", "# Smooth l1 loss subtracts 0.5 from l1 norm if diff >= 1.", "\n", "predictions", "[", ":", ",", ":", "60", "]", "+=", "1", "\n", "self", ".", "assertAlmostEqual", "(", "float", "(", "loss", "(", "predictions", ",", "targets", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "0.5", ",", "\n", "places", "=", "4", ")", "\n", "\n", "# In this case, one element has perfect regression, the others are off by 1.", "\n", "predictions", "[", "1", ",", ":", "60", "]", "-=", "1", "\n", "self", ".", "assertAlmostEqual", "(", "float", "(", "loss", "(", "predictions", ",", "targets", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "(", "15", "/", "16", ")", "*", "0.5", ",", "\n", "places", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_mtp_loss.TestMTPLoss.test_loss_many_modes": [[161, 187], ["torch.zeros", "torch.arange", "torch.ones", "targets[].reshape", "nuscenes.prediction.models.mtp.MTPLoss", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "test_mtp_loss.TestMTPLoss.assertAlmostEqual", "float", "float", "float", "nuscenes.prediction.models.mtp.MTPLoss.detach().numpy", "math.log", "nuscenes.prediction.models.mtp.MTPLoss.detach().numpy", "nuscenes.prediction.models.mtp.MTPLoss.detach().numpy", "math.log", "math.log", "nuscenes.prediction.models.mtp.MTPLoss.detach", "nuscenes.prediction.models.mtp.MTPLoss.detach", "nuscenes.prediction.models.mtp.MTPLoss.detach", "nuscenes.prediction.models.mtp.MTPLoss.", "nuscenes.prediction.models.mtp.MTPLoss.", "nuscenes.prediction.models.mtp.MTPLoss."], "methods", ["None"], ["", "def", "test_loss_many_modes", "(", "self", ")", ":", "\n", "        ", "targets", "=", "torch", ".", "zeros", "(", "(", "16", ",", "1", ",", "30", ",", "2", ")", ")", "\n", "targets", "[", ":", ",", ":", ",", ":", ",", "1", "]", "=", "torch", ".", "arange", "(", "start", "=", "0", ",", "end", "=", "3", ",", "step", "=", "0.1", ")", "\n", "\n", "predictions", "=", "torch", ".", "ones", "(", "(", "16", ",", "610", ")", ")", "\n", "predictions", "[", ":", ",", "540", ":", "600", "]", "=", "targets", "[", "0", ",", "0", ",", ":", ",", ":", "]", ".", "reshape", "(", "-", "1", ",", "60", ")", "\n", "predictions", "[", ":", ",", "-", "10", ":", "]", "=", "1", "/", "10", "\n", "\n", "loss", "=", "mtp", ".", "MTPLoss", "(", "10", ",", "1", ",", "angle_threshold_degrees", "=", "20", ")", "\n", "\n", "# Since one mode exactly matches gt, loss should only be classification error.", "\n", "self", ".", "assertAlmostEqual", "(", "float", "(", "loss", "(", "predictions", ",", "targets", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "-", "math", ".", "log", "(", "1", "/", "10", ")", ",", "places", "=", "4", ")", "\n", "\n", "# Now the best mode differs by 1 from the ground truth.", "\n", "# Smooth l1 loss subtracts 0.5 from l1 norm if diff >= 1.", "\n", "predictions", "[", ":", ",", "540", ":", "600", "]", "+=", "1", "\n", "self", ".", "assertAlmostEqual", "(", "float", "(", "loss", "(", "predictions", ",", "targets", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "-", "math", ".", "log", "(", "1", "/", "10", ")", "+", "0.5", ",", "\n", "places", "=", "4", ")", "\n", "\n", "# In this case, one element has perfect regression, the others are off by 1.", "\n", "predictions", "[", "1", ",", "540", ":", "600", "]", "-=", "1", "\n", "self", ".", "assertAlmostEqual", "(", "float", "(", "loss", "(", "predictions", ",", "targets", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "-", "math", ".", "log", "(", "1", "/", "10", ")", "+", "(", "15", "/", "16", ")", "*", "0.5", ",", "\n", "places", "=", "4", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_covernet.TestCoverNet.test_shapes_in_forward_pass_correct": [[19, 29], ["nuscenes.prediction.models.backbone.ResNetBackbone", "nuscenes.prediction.models.covernet.CoverNet", "torch.zeros", "torch.empty().random_", "nuscenes.prediction.models.covernet.CoverNet.", "test_covernet.TestCoverNet.assertTupleEqual", "torch.empty"], "methods", ["None"], ["    ", "def", "test_shapes_in_forward_pass_correct", "(", "self", ")", ":", "\n", "        ", "resnet", "=", "ResNetBackbone", "(", "'resnet50'", ")", "\n", "\n", "covernet", "=", "CoverNet", "(", "resnet", ",", "5", ",", "n_hidden_layers", "=", "[", "4096", "]", ",", "input_shape", "=", "(", "3", ",", "100", ",", "100", ")", ")", "\n", "\n", "image", "=", "torch", ".", "zeros", "(", "4", ",", "3", ",", "100", ",", "100", ")", "\n", "asv", "=", "torch", ".", "empty", "(", "4", ",", "3", ")", ".", "random_", "(", "12", ")", "\n", "\n", "logits", "=", "covernet", "(", "image", ",", "asv", ")", "\n", "self", ".", "assertTupleEqual", "(", "logits", ".", "shape", ",", "(", "4", ",", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_covernet.TestConstantLatticeLoss.test_l1_distance": [[33, 51], ["torch.zeros", "torch.arange().reshape", "test_covernet.TestConstantLatticeLoss.assertEqual", "test_covernet.TestConstantLatticeLoss.assertEqual", "test_covernet.TestConstantLatticeLoss.assertEqual", "torch.arange().reshape", "torch.arange().reshape", "torch.arange().reshape().unsqueeze", "nuscenes.prediction.models.covernet.mean_pointwise_l2_distance", "nuscenes.prediction.models.covernet.mean_pointwise_l2_distance", "nuscenes.prediction.models.covernet.mean_pointwise_l2_distance", "torch.arange", "torch.arange().reshape().unsqueeze", "torch.arange().reshape().unsqueeze", "torch.arange", "torch.arange", "torch.arange().reshape", "torch.arange().reshape", "torch.arange().reshape", "torch.arange", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.covernet.mean_pointwise_l2_distance", "home.repos.pwc.inspect_result.fpthink_v2b.models.covernet.mean_pointwise_l2_distance", "home.repos.pwc.inspect_result.fpthink_v2b.models.covernet.mean_pointwise_l2_distance"], ["    ", "def", "test_l1_distance", "(", "self", ")", ":", "\n", "\n", "        ", "lattice", "=", "torch", ".", "zeros", "(", "3", ",", "6", ",", "2", ")", "\n", "lattice", "[", "0", "]", "=", "torch", ".", "arange", "(", "1", ",", "13", ")", ".", "reshape", "(", "6", ",", "2", ")", "\n", "lattice", "[", "1", "]", "=", "torch", ".", "arange", "(", "1", ",", "13", ")", ".", "reshape", "(", "6", ",", "2", ")", "*", "3", "\n", "lattice", "[", "2", "]", "=", "torch", ".", "arange", "(", "1", ",", "13", ")", ".", "reshape", "(", "6", ",", "2", ")", "*", "6", "\n", "\n", "# Should select the first mode", "\n", "ground_truth", "=", "torch", ".", "arange", "(", "1", ",", "13", ",", "dtype", "=", "torch", ".", "float", ")", ".", "reshape", "(", "6", ",", "2", ")", ".", "unsqueeze", "(", "0", ")", "+", "2", "\n", "self", ".", "assertEqual", "(", "mean_pointwise_l2_distance", "(", "lattice", ",", "ground_truth", ")", ",", "0", ")", "\n", "\n", "# Should select the second mode", "\n", "ground_truth", "=", "torch", ".", "arange", "(", "1", ",", "13", ",", "dtype", "=", "torch", ".", "float", ")", ".", "reshape", "(", "6", ",", "2", ")", ".", "unsqueeze", "(", "0", ")", "*", "3", "+", "4", "\n", "self", ".", "assertEqual", "(", "mean_pointwise_l2_distance", "(", "lattice", ",", "ground_truth", ")", ",", "1", ")", "\n", "\n", "# Should select the third mode", "\n", "ground_truth", "=", "torch", ".", "arange", "(", "1", ",", "13", ",", "dtype", "=", "torch", ".", "float", ")", ".", "reshape", "(", "6", ",", "2", ")", ".", "unsqueeze", "(", "0", ")", "*", "6", "+", "10", "\n", "self", ".", "assertEqual", "(", "mean_pointwise_l2_distance", "(", "lattice", ",", "ground_truth", ")", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_covernet.TestConstantLatticeLoss.test_constant_lattice_loss": [[52, 85], ["torch.zeros", "test_covernet.TestConstantLatticeLoss.test_constant_lattice_loss.generate_trajectory"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.run_covernet.generate_trajectory"], ["", "def", "test_constant_lattice_loss", "(", "self", ")", ":", "\n", "\n", "\n", "        ", "def", "generate_trajectory", "(", "theta", ":", "float", ")", "->", "torch", ".", "Tensor", ":", "\n", "            ", "trajectory", "=", "torch", ".", "zeros", "(", "6", ",", "2", ")", "\n", "trajectory", "[", ":", ",", "0", "]", "=", "torch", ".", "arange", "(", "6", ",", "dtype", "=", "torch", ".", "float", ")", "*", "math", ".", "cos", "(", "theta", ")", "\n", "trajectory", "[", ":", ",", "1", "]", "=", "torch", ".", "arange", "(", "6", ",", "dtype", "=", "torch", ".", "float", ")", "*", "math", ".", "sin", "(", "theta", ")", "\n", "return", "trajectory", "\n", "\n", "", "lattice", "=", "torch", ".", "zeros", "(", "3", ",", "6", ",", "2", ")", "\n", "lattice", "[", "0", "]", "=", "generate_trajectory", "(", "math", ".", "pi", "/", "2", ")", "\n", "lattice", "[", "1", "]", "=", "generate_trajectory", "(", "math", ".", "pi", "/", "4", ")", "\n", "lattice", "[", "2", "]", "=", "generate_trajectory", "(", "3", "*", "math", ".", "pi", "/", "4", ")", "\n", "\n", "ground_truth", "=", "torch", ".", "zeros", "(", "5", ",", "1", ",", "6", ",", "2", ")", "\n", "ground_truth", "[", "0", ",", "0", "]", "=", "generate_trajectory", "(", "0.2", ")", "\n", "ground_truth", "[", "1", ",", "0", "]", "=", "generate_trajectory", "(", "math", ".", "pi", "/", "3", ")", "\n", "ground_truth", "[", "2", ",", "0", "]", "=", "generate_trajectory", "(", "5", "*", "math", ".", "pi", "/", "6", ")", "\n", "ground_truth", "[", "3", ",", "0", "]", "=", "generate_trajectory", "(", "6", "*", "math", ".", "pi", "/", "11", ")", "\n", "ground_truth", "[", "4", ",", "0", "]", "=", "generate_trajectory", "(", "4", "*", "math", ".", "pi", "/", "9", ")", "\n", "\n", "logits", "=", "torch", ".", "Tensor", "(", "[", "[", "2", ",", "10", ",", "5", "]", ",", "\n", "[", "-", "3", ",", "4", ",", "5", "]", ",", "\n", "[", "-", "4", ",", "2", ",", "7", "]", ",", "\n", "[", "8", ",", "-", "2", ",", "3", "]", ",", "\n", "[", "10", ",", "3", ",", "6", "]", "]", ")", "\n", "\n", "answer", "=", "cross_entropy", "(", "logits", ",", "torch", ".", "LongTensor", "(", "[", "1", ",", "1", ",", "2", ",", "0", ",", "0", "]", ")", ")", "\n", "\n", "loss", "=", "ConstantLatticeLoss", "(", "lattice", ",", "mean_pointwise_l2_distance", ")", "\n", "loss_value", "=", "loss", "(", "logits", ",", "ground_truth", ")", "\n", "\n", "self", ".", "assertAlmostEqual", "(", "float", "(", "loss_value", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "float", "(", "answer", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.run_mtp.Dataset.__init__": [[27, 29], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_modes", ":", "int", "=", "1", ")", ":", "\n", "        ", "self", ".", "num_modes", "=", "num_modes", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.run_mtp.Dataset.__iter__": [[30, 48], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "numpy.random.rand", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ",", ")", ":", "\n", "\n", "        ", "while", "True", ":", "\n", "            ", "image", "=", "torch", ".", "zeros", "(", "(", "3", ",", "100", ",", "100", ")", ")", "\n", "agent_state_vector", "=", "torch", ".", "ones", "(", "3", ")", "\n", "ground_truth", "=", "torch", ".", "ones", "(", "(", "1", ",", "12", ",", "2", ")", ")", "\n", "\n", "if", "self", ".", "num_modes", "==", "1", ":", "\n", "                ", "going_forward", "=", "True", "\n", "", "else", ":", "\n", "                ", "going_forward", "=", "np", ".", "random", ".", "rand", "(", ")", ">", "0.25", "\n", "\n", "", "if", "going_forward", ":", "\n", "                ", "ground_truth", "[", ":", ",", ":", ",", "1", "]", "=", "torch", ".", "arange", "(", "0", ",", "6", ",", "step", "=", "0.5", ")", "\n", "", "else", ":", "\n", "                ", "ground_truth", "[", ":", ",", ":", ",", "1", "]", "=", "-", "torch", ".", "arange", "(", "0", ",", "6", ",", "step", "=", "0.5", ")", "\n", "\n", "", "yield", "image", ",", "agent_state_vector", ",", "ground_truth", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.run_image_generation.TestDataset.__init__": [[17, 20], ["nuscenes.prediction.input_representation.static_layers.StaticLayerRasterizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "tokens", ":", "List", "[", "str", "]", ",", "helper", ":", "PredictHelper", ")", ":", "\n", "        ", "self", ".", "tokens", "=", "tokens", "\n", "self", ".", "static_layer_representation", "=", "StaticLayerRasterizer", "(", "helper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.run_image_generation.TestDataset.__len__": [[21, 23], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "tokens", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.run_image_generation.TestDataset.__getitem__": [[24, 37], ["token.split", "run_image_generation.TestDataset.static_layer_representation.make_representation", "torch.Tensor().permute", "torch.Tensor().permute", "torch.Tensor().permute", "torch.Tensor().permute", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.AgentBoxesWithFadedHistory.make_representation"], ["", "def", "__getitem__", "(", "self", ",", "index", ":", "int", ")", ":", "\n", "\n", "        ", "token", "=", "self", ".", "tokens", "[", "index", "]", "\n", "instance_token", ",", "sample_token", "=", "token", ".", "split", "(", "\"_\"", ")", "\n", "\n", "image", "=", "self", ".", "static_layer_representation", ".", "make_representation", "(", "instance_token", ",", "sample_token", ")", "\n", "image", "=", "torch", ".", "Tensor", "(", "image", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "agent_state_vector", "=", "torch", ".", "ones", "(", "(", "3", ")", ")", "\n", "ground_truth", "=", "torch", ".", "ones", "(", "(", "1", ",", "12", ",", "2", ")", ")", "\n", "\n", "ground_truth", "[", ":", ",", ":", ",", "1", "]", "=", "torch", ".", "arange", "(", "0", ",", "6", ",", "step", "=", "0.5", ")", "\n", "\n", "return", "image", ",", "agent_state_vector", ",", "ground_truth", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain.tearDown": [[27, 32], ["os.path.exists", "os.path.exists", "os.remove", "shutil.rmtree"], "methods", ["None"], ["        ", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "res_mockup", ")", ":", "\n", "            ", "os", ".", "remove", "(", "self", ".", "res_mockup", ")", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "self", ".", "res_eval_folder", ")", ":", "\n", "            ", "shutil", ".", "rmtree", "(", "self", ".", "res_eval_folder", ")", "\n", "\n", "", "", "@", "staticmethod", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain._mock_submission": [[33, 135], ["nuscenes.utils.splits.create_splits_scenes", "dict", "tqdm.tqdm.tqdm", "sorted", "nuscenes.eval.tracking.utils.category_to_tracking_name", "str", "val_samples.append", "nusc.get", "numpy.array", "numpy.array", "numpy.array", "test_evaluate.TestMain._mock_submission.random_id"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_scenes", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.category_to_tracking_name", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["def", "_mock_submission", "(", "nusc", ":", "NuScenes", ",", "split", ":", "str", ")", "->", "Dict", "[", "str", ",", "dict", "]", ":", "\n", "        ", "\"\"\"\n        Creates \"reasonable\" submission (results and metadata) by looping through the mini-val set, adding 1 GT\n        prediction per sample. Predictions will be permuted randomly along all axes.\n        \"\"\"", "\n", "\n", "def", "random_class", "(", "category_name", ":", "str", ")", "->", "str", ":", "\n", "# Alter 10% of the valid labels.", "\n", "            ", "class_names", "=", "sorted", "(", "DETECTION_NAMES", ")", "\n", "tmp", "=", "category_to_detection_name", "(", "category_name", ")", "\n", "if", "tmp", "is", "not", "None", "and", "np", ".", "random", ".", "rand", "(", ")", "<", ".9", ":", "\n", "                ", "return", "tmp", "\n", "", "else", ":", "\n", "                ", "return", "class_names", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "class_names", ")", "-", "1", ")", "]", "\n", "\n", "", "", "def", "random_attr", "(", "name", ":", "str", ")", "->", "str", ":", "\n", "            ", "\"\"\"\n            This is the most straight-forward way to generate a random attribute.\n            Not currently used b/c we want the test fixture to be back-wards compatible.\n            \"\"\"", "\n", "# Get relevant attributes.", "\n", "rel_attributes", "=", "detection_name_to_rel_attributes", "(", "name", ")", "\n", "\n", "if", "len", "(", "rel_attributes", ")", "==", "0", ":", "\n", "# Empty string for classes without attributes.", "\n", "                ", "return", "''", "\n", "", "else", ":", "\n", "# Pick a random attribute otherwise.", "\n", "                ", "return", "rel_attributes", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "rel_attributes", ")", ")", "]", "\n", "\n", "", "", "mock_meta", "=", "{", "\n", "'use_camera'", ":", "False", ",", "\n", "'use_lidar'", ":", "True", ",", "\n", "'use_radar'", ":", "False", ",", "\n", "'use_map'", ":", "False", ",", "\n", "'use_external'", ":", "False", ",", "\n", "}", "\n", "mock_results", "=", "{", "}", "\n", "splits", "=", "create_splits_scenes", "(", ")", "\n", "val_samples", "=", "[", "]", "\n", "for", "sample", "in", "nusc", ".", "sample", ":", "\n", "            ", "if", "nusc", ".", "get", "(", "'scene'", ",", "sample", "[", "'scene_token'", "]", ")", "[", "'name'", "]", "in", "splits", "[", "split", "]", ":", "\n", "                ", "val_samples", ".", "append", "(", "sample", ")", "\n", "\n", "", "", "for", "sample", "in", "tqdm", "(", "val_samples", ",", "leave", "=", "False", ")", ":", "\n", "            ", "sample_res", "=", "[", "]", "\n", "for", "ann_token", "in", "sample", "[", "'anns'", "]", ":", "\n", "                ", "ann", "=", "nusc", ".", "get", "(", "'sample_annotation'", ",", "ann_token", ")", "\n", "detection_name", "=", "random_class", "(", "ann", "[", "'category_name'", "]", ")", "\n", "sample_res", ".", "append", "(", "\n", "{", "\n", "'sample_token'", ":", "sample", "[", "'token'", "]", ",", "\n", "'translation'", ":", "list", "(", "np", ".", "array", "(", "ann", "[", "'translation'", "]", ")", "+", "5", "*", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "-", "0.5", ")", ")", ",", "\n", "'size'", ":", "list", "(", "np", ".", "array", "(", "ann", "[", "'size'", "]", ")", "*", "2", "*", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "+", "0.5", ")", ")", ",", "\n", "'rotation'", ":", "list", "(", "np", ".", "array", "(", "ann", "[", "'rotation'", "]", ")", "+", "(", "(", "np", ".", "random", ".", "rand", "(", "4", ")", "-", "0.5", ")", "*", ".1", ")", ")", ",", "\n", "'velocity'", ":", "list", "(", "nusc", ".", "box_velocity", "(", "ann_token", ")", "[", ":", "2", "]", "*", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "[", ":", "2", "]", "+", "0.5", ")", ")", ",", "\n", "'detection_name'", ":", "detection_name", ",", "\n", "'detection_score'", ":", "random", ".", "random", "(", ")", ",", "\n", "'attribute_name'", ":", "random_attr", "(", "detection_name", ")", "\n", "}", ")", "\n", "", "mock_results", "[", "sample", "[", "'token'", "]", "]", "=", "sample_res", "\n", "", "mock_submission", "=", "{", "\n", "'meta'", ":", "mock_meta", ",", "\n", "'results'", ":", "mock_results", "\n", "}", "\n", "return", "mock_submission", "\n", "\n", "", "def", "test_delta", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        This tests runs the evaluation for an arbitrary random set of predictions.\n        This score is then captured in this very test such that if we change the eval code,\n        this test will trigger if the results changed.\n        \"\"\"", "\n", "random", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "assert", "'NUSCENES'", "in", "os", ".", "environ", ",", "'Set NUSCENES env. variable to enable tests.'", "\n", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "'v1.0-mini'", ",", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", ",", "verbose", "=", "False", ")", "\n", "\n", "with", "open", "(", "self", ".", "res_mockup", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "self", ".", "_mock_submission", "(", "nusc", ",", "'mini_val'", ")", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "", "cfg", "=", "config_factory", "(", "'detection_cvpr_2019'", ")", "\n", "nusc_eval", "=", "DetectionEval", "(", "nusc", ",", "cfg", ",", "self", ".", "res_mockup", ",", "eval_set", "=", "'mini_val'", ",", "output_dir", "=", "self", ".", "res_eval_folder", ",", "\n", "verbose", "=", "False", ")", "\n", "metrics", ",", "md_list", "=", "nusc_eval", ".", "evaluate", "(", ")", "\n", "\n", "# 1. Score = 0.22082865720221012. Measured on the branch \"release_v0.2\" on March 7 2019.", "\n", "# 2. Score = 0.2199307290627096. Changed to measure center distance from the ego-vehicle.", "\n", "# 3. Score = 0.24954451673961747. Changed to 1.0-mini and cleaned up build script.", "\n", "# 4. Score = 0.20478832626986893. Updated treatment of cones, barriers, and other algo tunings.", "\n", "# 5. Score = 0.2043569666105005. AP calculation area is changed from >=min_recall to >min_recall.", "\n", "# 6. Score = 0.20636954644294506. After bike-rack filtering.", "\n", "# 7. Score = 0.20237925145690996. After TP reversion bug.", "\n", "# 8. Score = 0.24047129251302665. After bike racks bug.", "\n", "# 9. Score = 0.24104572227466886. After bug fix in calc_tp. Include the max recall and exclude the min recall.", "\n", "# 10. Score = 0.19449091580477748. Changed to use v1.0 mini_val split.", "\n", "self", ".", "assertAlmostEqual", "(", "metrics", ".", "nd_score", ",", "0.19449091580477748", ")", "\n", "\n", "\n", "", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "unittest", ".", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain.test_delta": [[100, 131], ["random.seed", "numpy.random.seed", "nuscenes.NuScenes", "nuscenes.eval.common.config.config_factory", "nuscenes.eval.detection.evaluate.DetectionEval", "nuscenes.eval.detection.evaluate.DetectionEval.evaluate", "test_evaluate.TestMain.assertAlmostEqual", "open", "json.dump", "test_evaluate.TestMain._mock_submission"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.evaluate", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain._mock_submission"], ["", "def", "test_delta", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        This tests runs the evaluation for an arbitrary random set of predictions.\n        This score is then captured in this very test such that if we change the eval code,\n        this test will trigger if the results changed.\n        \"\"\"", "\n", "random", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "assert", "'NUSCENES'", "in", "os", ".", "environ", ",", "'Set NUSCENES env. variable to enable tests.'", "\n", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "'v1.0-mini'", ",", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", ",", "verbose", "=", "False", ")", "\n", "\n", "with", "open", "(", "self", ".", "res_mockup", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "self", ".", "_mock_submission", "(", "nusc", ",", "'mini_val'", ")", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "", "cfg", "=", "config_factory", "(", "'detection_cvpr_2019'", ")", "\n", "nusc_eval", "=", "DetectionEval", "(", "nusc", ",", "cfg", ",", "self", ".", "res_mockup", ",", "eval_set", "=", "'mini_val'", ",", "output_dir", "=", "self", ".", "res_eval_folder", ",", "\n", "verbose", "=", "False", ")", "\n", "metrics", ",", "md_list", "=", "nusc_eval", ".", "evaluate", "(", ")", "\n", "\n", "# 1. Score = 0.22082865720221012. Measured on the branch \"release_v0.2\" on March 7 2019.", "\n", "# 2. Score = 0.2199307290627096. Changed to measure center distance from the ego-vehicle.", "\n", "# 3. Score = 0.24954451673961747. Changed to 1.0-mini and cleaned up build script.", "\n", "# 4. Score = 0.20478832626986893. Updated treatment of cones, barriers, and other algo tunings.", "\n", "# 5. Score = 0.2043569666105005. AP calculation area is changed from >=min_recall to >min_recall.", "\n", "# 6. Score = 0.20636954644294506. After bike-rack filtering.", "\n", "# 7. Score = 0.20237925145690996. After TP reversion bug.", "\n", "# 8. Score = 0.24047129251302665. After bike racks bug.", "\n", "# 9. Score = 0.24104572227466886. After bug fix in calc_tp. Include the max recall and exclude the min recall.", "\n", "# 10. Score = 0.19449091580477748. Changed to use v1.0 mini_val split.", "\n", "self", ".", "assertAlmostEqual", "(", "metrics", ".", "nd_score", ",", "0.19449091580477748", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo._mock_results": [[25, 85], ["nuscenes.eval.common.data_classes.EvalBoxes", "nuscenes.eval.common.data_classes.EvalBoxes", "range", "range", "nuscenes.eval.detection.utils.detection_name_to_rel_attributes", "range", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "range", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "len", "tuple", "this_gt.append", "str", "tuple", "this_pred.append", "str", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "numpy.random.randint", "numpy.random.rand", "numpy.random.rand", "len", "str", "tuple", "tuple", "tuple", "random.random", "test_algo.TestAlgo._mock_results.random_attr"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.detection.utils.detection_name_to_rel_attributes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes"], ["@", "staticmethod", "\n", "def", "_mock_results", "(", "nsamples", ",", "ngt", ",", "npred", ",", "detection_name", ")", ":", "\n", "\n", "        ", "def", "random_attr", "(", ")", ":", "\n", "            ", "\"\"\"\n            This is the most straight-forward way to generate a random attribute.\n            Not currently used b/c we want the test fixture to be back-wards compatible.\n            \"\"\"", "\n", "# Get relevant attributes.", "\n", "rel_attributes", "=", "detection_name_to_rel_attributes", "(", "detection_name", ")", "\n", "\n", "if", "len", "(", "rel_attributes", ")", "==", "0", ":", "\n", "# Empty string for classes without attributes.", "\n", "                ", "return", "''", "\n", "", "else", ":", "\n", "# Pick a random attribute otherwise.", "\n", "                ", "return", "rel_attributes", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "rel_attributes", ")", ")", "]", "\n", "\n", "", "", "pred", "=", "EvalBoxes", "(", ")", "\n", "gt", "=", "EvalBoxes", "(", ")", "\n", "\n", "for", "sample_itt", "in", "range", "(", "nsamples", ")", ":", "\n", "\n", "            ", "this_gt", "=", "[", "]", "\n", "\n", "for", "box_itt", "in", "range", "(", "ngt", ")", ":", "\n", "                ", "translation_xy", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "2", ")", "*", "15", ")", "\n", "this_gt", ".", "append", "(", "DetectionBox", "(", "\n", "sample_token", "=", "str", "(", "sample_itt", ")", ",", "\n", "translation", "=", "(", "translation_xy", "[", "0", "]", ",", "translation_xy", "[", "1", "]", ",", "0.0", ")", ",", "\n", "size", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "*", "4", ")", ",", "\n", "rotation", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "4", ")", ")", ",", "\n", "velocity", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "[", ":", "2", "]", "*", "4", ")", ",", "\n", "detection_name", "=", "detection_name", ",", "\n", "detection_score", "=", "random", ".", "random", "(", ")", ",", "\n", "attribute_name", "=", "random_attr", "(", ")", ",", "\n", "ego_translation", "=", "(", "random", ".", "random", "(", ")", "*", "10", ",", "0", ",", "0", ")", ",", "\n", ")", ")", "\n", "", "gt", ".", "add_boxes", "(", "str", "(", "sample_itt", ")", ",", "this_gt", ")", "\n", "\n", "", "for", "sample_itt", "in", "range", "(", "nsamples", ")", ":", "\n", "            ", "this_pred", "=", "[", "]", "\n", "\n", "for", "box_itt", "in", "range", "(", "npred", ")", ":", "\n", "                ", "translation_xy", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "2", ")", "*", "10", ")", "\n", "this_pred", ".", "append", "(", "DetectionBox", "(", "\n", "sample_token", "=", "str", "(", "sample_itt", ")", ",", "\n", "translation", "=", "(", "translation_xy", "[", "0", "]", ",", "translation_xy", "[", "1", "]", ",", "0.0", ")", ",", "\n", "size", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "*", "4", ")", ",", "\n", "rotation", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "4", ")", ")", ",", "\n", "velocity", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "[", ":", "2", "]", "*", "4", ")", ",", "\n", "detection_name", "=", "detection_name", ",", "\n", "detection_score", "=", "random", ".", "random", "(", ")", ",", "\n", "attribute_name", "=", "random_attr", "(", ")", ",", "\n", "ego_translation", "=", "(", "random", ".", "random", "(", ")", "*", "10", ",", "0", ",", "0", ")", ",", "\n", ")", ")", "\n", "\n", "", "pred", ".", "add_boxes", "(", "str", "(", "sample_itt", ")", ",", "this_pred", ")", "\n", "\n", "", "return", "gt", ",", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_nd_score": [[86, 117], ["random.seed", "numpy.random.seed", "nuscenes.eval.detection.data_classes.DetectionMetricDataList", "nuscenes.eval.detection.data_classes.DetectionMetrics", "test_algo.TestAlgo.assertEqual", "test_algo.TestAlgo._mock_results", "nuscenes.eval.detection.data_classes.DetectionMetricDataList.set", "nuscenes.eval.detection.algo.calc_ap", "nuscenes.eval.detection.data_classes.DetectionMetrics.add_label_ap", "nuscenes.eval.detection.data_classes.DetectionMetrics.add_label_tp", "nuscenes.eval.detection.algo.accumulate", "nuscenes.eval.detection.algo.calc_tp"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo._mock_results", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.calc_ap", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_ap", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.calc_tp"], ["", "def", "test_nd_score", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        This tests runs the full evaluation for an arbitrary random set of predictions.\n        \"\"\"", "\n", "\n", "random", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "\n", "mdl", "=", "DetectionMetricDataList", "(", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "gt", ",", "pred", "=", "self", ".", "_mock_results", "(", "30", ",", "3", ",", "25", ",", "class_name", ")", "\n", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "mdl", ".", "set", "(", "class_name", ",", "dist_th", ",", "accumulate", "(", "gt", ",", "pred", ",", "class_name", ",", "center_distance", ",", "2", ")", ")", "\n", "\n", "", "", "metrics", "=", "DetectionMetrics", "(", "self", ".", "cfg", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "ap", "=", "calc_ap", "(", "mdl", "[", "(", "class_name", ",", "dist_th", ")", "]", ",", "self", ".", "cfg", ".", "min_recall", ",", "self", ".", "cfg", ".", "min_precision", ")", "\n", "metrics", ".", "add_label_ap", "(", "class_name", ",", "dist_th", ",", "ap", ")", "\n", "\n", "", "for", "metric_name", "in", "TP_METRICS", ":", "\n", "                ", "metric_data", "=", "mdl", "[", "(", "class_name", ",", "self", ".", "cfg", ".", "dist_th_tp", ")", "]", "\n", "if", "class_name", "in", "[", "'traffic_cone'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", ",", "'orient_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "elif", "class_name", "in", "[", "'barrier'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "else", ":", "\n", "                    ", "tp", "=", "calc_tp", "(", "metric_data", ",", "self", ".", "cfg", ".", "min_recall", ",", "metric_name", ")", "\n", "", "metrics", ".", "add_label_tp", "(", "class_name", ",", "metric_name", ",", "tp", ")", "\n", "\n", "", "", "self", ".", "assertEqual", "(", "0.08606662159639042", ",", "metrics", ".", "nd_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_calc_tp": [[118, 128], ["random.seed", "numpy.random.seed", "nuscenes.eval.detection.data_classes.DetectionMetricData.random_md", "test_algo.TestAlgo.assertEqual", "nuscenes.eval.detection.algo.calc_tp"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.random_md", "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.calc_tp"], ["", "def", "test_calc_tp", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test for calc_tp().\"\"\"", "\n", "\n", "random", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "\n", "md", "=", "DetectionMetricData", ".", "random_md", "(", ")", "\n", "\n", "# min_recall greater than 1.", "\n", "self", ".", "assertEqual", "(", "1.0", ",", "calc_tp", "(", "md", ",", "min_recall", "=", "1", ",", "metric_name", "=", "'trans_err'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_calc_ap": [[129, 144], ["random.seed", "numpy.random.seed", "nuscenes.eval.detection.data_classes.DetectionMetricData.random_md", "test_algo.TestAlgo.assertRaises", "test_algo.TestAlgo.assertRaises", "test_algo.TestAlgo.assertRaises", "test_algo.TestAlgo.assertRaises"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.random_md"], ["", "def", "test_calc_ap", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test for calc_ap().\"\"\"", "\n", "\n", "random", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "\n", "md", "=", "DetectionMetricData", ".", "random_md", "(", ")", "\n", "\n", "# Negative min_recall and min_precision", "\n", "self", ".", "assertRaises", "(", "AssertionError", ",", "calc_ap", ",", "md", ",", "-", "0.5", ",", "0.4", ")", "\n", "self", ".", "assertRaises", "(", "AssertionError", ",", "calc_ap", ",", "md", ",", "0.5", ",", "-", "0.8", ")", "\n", "\n", "# More than 1 min_precision/min_recall", "\n", "self", ".", "assertRaises", "(", "AssertionError", ",", "calc_ap", ",", "md", ",", "0.7", ",", "1", ")", "\n", "self", ".", "assertRaises", "(", "AssertionError", ",", "calc_ap", ",", "md", ",", "1.2", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.setUp": [[195, 200], ["None"], "methods", ["None"], ["def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "car1", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'name'", ":", "'car'", ",", "'score'", ":", "1.0", ",", "}", "\n", "self", ".", "car2", "=", "{", "'trans'", ":", "(", "3", ",", "3", ",", "1", ")", ",", "'name'", ":", "'car'", ",", "'score'", ":", "0.7", "}", "\n", "self", ".", "bicycle1", "=", "{", "'trans'", ":", "(", "5", ",", "5", ",", "1", ")", ",", "'name'", ":", "'bicycle'", ",", "'score'", ":", "1.0", "}", "\n", "self", ".", "bicycle2", "=", "{", "'trans'", ":", "(", "7", ",", "7", ",", "1", ")", ",", "'name'", ":", "'bicycle'", ",", "'score'", ":", "0.7", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap": [[201, 223], ["test_algo.get_metric_data", "nuscenes.eval.detection.algo.calc_ap", "test_algo.TestAPSimple.assertGreaterEqual", "abs"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.get_metric_data", "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.calc_ap"], ["", "def", "check_ap", "(", "self", ",", "gts", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "preds", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "target_ap", ":", "float", ",", "\n", "detection_name", ":", "str", "=", "'car'", ",", "\n", "dist_th", ":", "float", "=", "2.0", ",", "\n", "min_precision", ":", "float", "=", "0.1", ",", "\n", "min_recall", ":", "float", "=", "0.1", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Calculate and check the AP value.\n        :param gts: Ground truth data.\n        :param preds: Predictions.\n        :param target_ap: Expected Average Precision value.\n        :param detection_name: Name of the class we are interested in.\n        :param dist_th: Distance threshold for matching.\n        :param min_precision: Minimum precision value.\n        :param min_recall: Minimum recall value.\n        \"\"\"", "\n", "metric_data", "=", "get_metric_data", "(", "gts", ",", "preds", ",", "detection_name", ",", "dist_th", ")", "\n", "ap", "=", "calc_ap", "(", "metric_data", ",", "min_precision", "=", "min_precision", ",", "min_recall", "=", "min_recall", ")", "\n", "\n", "# We quantize the curve into 100 bins to calculate integral so the AP is accurate up to 1%.", "\n", "self", ".", "assertGreaterEqual", "(", "0.01", ",", "abs", "(", "ap", "-", "target_ap", ")", ",", "msg", "=", "'Incorrect AP'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.test_no_data": [[224, 239], ["test_algo.TestAPSimple.check_ap", "test_algo.TestAPSimple.check_ap", "test_algo.TestAPSimple.check_ap"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap"], ["", "def", "test_no_data", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test empty ground truth and/or predictions. \"\"\"", "\n", "\n", "gts", "=", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", "\n", "preds", "=", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", "\n", "empty", "=", "{", "'sample1'", ":", "[", "]", "}", "\n", "\n", "# No ground truth objects (all False positives)", "\n", "self", ".", "check_ap", "(", "empty", ",", "preds", ",", "target_ap", "=", "0.0", ")", "\n", "\n", "# No predictions (all False negatives)", "\n", "self", ".", "check_ap", "(", "gts", ",", "empty", ",", "target_ap", "=", "0.0", ")", "\n", "\n", "# No predictions and no ground truth objects.", "\n", "self", ".", "check_ap", "(", "empty", ",", "empty", ",", "target_ap", "=", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.test_one_sample": [[240, 266], ["test_algo.TestAPSimple.check_ap", "test_algo.TestAPSimple.check_ap", "test_algo.TestAPSimple.check_ap", "test_algo.TestAPSimple.check_ap", "test_algo.TestAPSimple.check_ap"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap"], ["", "def", "test_one_sample", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test the single sample case. \"\"\"", "\n", "# Perfect detection.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# Detect one of the two objects", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", ",", "self", ".", "car2", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "target_ap", "=", "0.4", "/", "0.9", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# One detection and one FP. FP score is less than TP score.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", ",", "self", ".", "car2", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# One detection and one FP. FP score is more than TP score.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car2", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", ",", "self", ".", "car2", "]", "}", ",", "\n", "target_ap", "=", "(", "(", "0.8", "*", "0.4", ")", "/", "2", ")", "/", "(", "0.9", "*", "0.9", ")", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# FP but different class.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", ",", "self", ".", "bicycle1", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.test_two_samples": [[267, 283], ["test_algo.TestAPSimple.check_ap", "test_algo.TestAPSimple.check_ap", "test_algo.TestAPSimple.check_ap"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAPSimple.check_ap"], ["", "def", "test_two_samples", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test more than one sample case. \"\"\"", "\n", "# Objects in both samples are detected.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "self", ".", "car2", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "self", ".", "car2", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# Object in first sample is detected, second sample is empty.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# Perfect detection in one image, FN in other.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "self", ".", "car2", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "]", "}", ",", "\n", "target_ap", "=", "0.4", "/", "0.9", ",", "detection_name", "=", "'car'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.setUp": [[288, 292], ["pyquaternion.Quaternion", "pyquaternion.Quaternion"], "methods", ["None"], ["def", "setUp", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "car3", "=", "{", "'trans'", ":", "(", "3", ",", "3", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "4", ",", "2", ")", ",", "'rot'", ":", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "0", ")", ",", "'score'", ":", "1.0", "}", "\n", "self", ".", "car4", "=", "{", "'trans'", ":", "(", "3", ",", "3", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "4", ",", "2", ")", ",", "'rot'", ":", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "0", ")", ",", "'score'", ":", "1.0", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp": [[293, 313], ["test_algo.get_metric_data", "nuscenes.eval.detection.algo.calc_tp", "test_algo.TestTPSimple.assertGreaterEqual", "abs"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.get_metric_data", "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.calc_tp"], ["", "def", "check_tp", "(", "self", ",", "gts", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "preds", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "target_error", ":", "float", ",", "\n", "metric_name", ":", "str", ",", "\n", "detection_name", ":", "str", "=", "'car'", ",", "\n", "min_recall", ":", "float", "=", "0.1", ")", ":", "\n", "        ", "\"\"\"\n        Calculate and check the AP value.\n        :param gts: Ground truth data.\n        :param preds: Predictions.\n        :param target_error: Expected error value.\n        :param metric_name: Name of the TP metric.\n        :param detection_name: Name of the class we are interested in.\n        :param min_recall: Minimum recall value.\n        \"\"\"", "\n", "\n", "metric_data", "=", "get_metric_data", "(", "gts", ",", "preds", ",", "detection_name", ",", "2.0", ")", "# Distance threshold for TP metrics is 2.0", "\n", "tp_error", "=", "calc_tp", "(", "metric_data", ",", "min_recall", "=", "min_recall", ",", "metric_name", "=", "metric_name", ")", "\n", "# We quantize the error curve into 100 bins to calculate the metric so it is only accurate up to 1%.", "\n", "self", ".", "assertGreaterEqual", "(", "0.01", ",", "abs", "(", "tp_error", "-", "target_error", ")", ",", "msg", "=", "'Incorrect {} value'", ".", "format", "(", "metric_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.test_no_positives": [[314, 327], ["test_algo.TestTPSimple.check_tp", "test_algo.TestTPSimple.check_tp"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp"], ["", "def", "test_no_positives", "(", "self", ")", ":", "\n", "        ", "\"\"\" Tests the error if there are no matches. The expected behaviour is to return error of 1.0. \"\"\"", "\n", "\n", "# Same type of objects but are more than 2m away.", "\n", "car1", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'score'", ":", "1.0", "}", "\n", "car2", "=", "{", "'trans'", ":", "(", "3", ",", "3", ",", "1", ")", ",", "'score'", ":", "1.0", "}", "\n", "bike1", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'score'", ":", "1.0", ",", "'name'", ":", "'bicycle'", ",", "'attr'", ":", "'cycle.with_rider'", "}", "\n", "for", "metric_name", "in", "TP_METRICS", ":", "\n", "            ", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "car1", "]", "}", ",", "{", "'sample1'", ":", "[", "car2", "]", "}", ",", "target_error", "=", "1.0", ",", "metric_name", "=", "metric_name", ")", "\n", "\n", "# Within distance threshold away but different classes.", "\n", "", "for", "metric_name", "in", "TP_METRICS", ":", "\n", "            ", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "car1", "]", "}", ",", "{", "'sample1'", ":", "[", "bike1", "]", "}", ",", "target_error", "=", "1.0", ",", "metric_name", "=", "metric_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.test_perfect": [[328, 339], ["test_algo.TestTPSimple.check_tp", "test_algo.TestTPSimple.check_tp"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp"], ["", "", "def", "test_perfect", "(", "self", ")", ":", "\n", "        ", "\"\"\" Tests when everything is estimated perfectly. \"\"\"", "\n", "\n", "car1", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'score'", ":", "1.0", "}", "\n", "car2", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'score'", ":", "0.3", "}", "\n", "for", "metric_name", "in", "TP_METRICS", ":", "\n", "# Detected with perfect score.", "\n", "            ", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "car1", "]", "}", ",", "{", "'sample1'", ":", "[", "car1", "]", "}", ",", "target_error", "=", "0.0", ",", "metric_name", "=", "metric_name", ")", "\n", "\n", "# Detected with low score.", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "car1", "]", "}", ",", "{", "'sample1'", ":", "[", "car2", "]", "}", ",", "target_error", "=", "0.0", ",", "metric_name", "=", "metric_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.test_one_img": [[340, 392], ["test_algo.TestTPSimple.check_tp", "test_algo.TestTPSimple.check_tp", "test_algo.TestTPSimple.check_tp", "test_algo.TestTPSimple.check_tp", "test_algo.TestTPSimple.check_tp"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp"], ["", "", "def", "test_one_img", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test single sample case. \"\"\"", "\n", "\n", "# Note all the following unit tests can be repeated to other metrics, but they are not needed.", "\n", "# The intention of these tests is to measure the calc_tp function which is common for all metrics.", "\n", "\n", "gt1", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", "}", "\n", "gt2", "=", "{", "'trans'", ":", "(", "10", ",", "10", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "2", ",", "2", ")", "}", "\n", "gt3", "=", "{", "'trans'", ":", "(", "20", ",", "20", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "4", ",", "2", ")", "}", "\n", "\n", "pred1", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'score'", ":", "1.0", "}", "\n", "pred2", "=", "{", "'trans'", ":", "(", "11", ",", "10", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "2", ",", "2", ")", ",", "'score'", ":", "0.9", "}", "\n", "pred3", "=", "{", "'trans'", ":", "(", "100", ",", "10", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "2", ",", "2", ")", ",", "'score'", ":", "0.8", "}", "\n", "pred4", "=", "{", "'trans'", ":", "(", "20", ",", "20", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "4", ",", "2", ")", ",", "'score'", ":", "0.7", "}", "\n", "pred5", "=", "{", "'trans'", ":", "(", "21", ",", "20", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "4", ",", "2", ")", ",", "'score'", ":", "0.7", "}", "\n", "\n", "# one GT and one matching prediction. Object location is off by 1 meter, so error 1.", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "gt2", "]", "}", ",", "{", "'sample1'", ":", "[", "pred2", "]", "}", ",", "target_error", "=", "1", ",", "metric_name", "=", "'trans_err'", ")", "\n", "\n", "# Two GT's and two detections.", "\n", "# The target is the average value of the recall vs. Error curve.", "\n", "# In this case there will three points on the curve. (0.1, 0), (0.5, 0), (1.0, 0.5).", "\n", "# (0.1, 0): Minimum recall we start from.", "\n", "# (0.5, 0): Detection with highest score has no translation error, and one of out of two objects recalled.", "\n", "# (1.0, 0.5): The last object is recalled but with 1m translation error, the cumulative mean gets to 0.5m error.", "\n", "# Error value of first segment of curve starts at 0 and ends at 0, so the average of this segment is 0.", "\n", "# Next segment of the curve starts at 0 and ends at 0.5, so the average is 0.25.", "\n", "# Then we take average of all segments and normalize it with the recall values we averaged over.", "\n", "target_error", "=", "(", "(", "0", "+", "0", ")", "/", "2", "+", "(", "0", "+", "0.5", ")", "/", "2", ")", "/", "(", "2", "*", "0.9", ")", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "gt1", ",", "gt2", "]", "}", ",", "{", "'sample1'", ":", "[", "pred1", ",", "pred2", "]", "}", ",", "target_error", "=", "target_error", ",", "\n", "metric_name", "=", "'trans_err'", ")", "\n", "\n", "# Adding a false positive with smaller detection score should not affect the true positive metric.", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "gt1", ",", "gt2", "]", "}", ",", "{", "'sample1'", ":", "[", "pred1", ",", "pred2", ",", "pred3", "]", "}", ",", "target_error", "=", "target_error", ",", "\n", "metric_name", "=", "'trans_err'", ")", "\n", "\n", "# In this case there will four points on the curve. (0.1, 0), (0.33, 0), (0.66, 0.5) (1.0, 0.33).", "\n", "# (0.1, 0): Minimum recall we start from.", "\n", "# (0.33, 0): One of out of three objects recalled with no error.", "\n", "# (0.66, 0.5): Second object is recalled but with 1m error. Cumulative error becomes 0.5m.", "\n", "# (1.0, 0.33): Third object recalled with no error. Cumulative error becomes 0.33m.", "\n", "# First segment starts at 0 and ends at 0: average error 0.", "\n", "# Next segment starts at 0 and ends at 0.5: average error is 0.25.", "\n", "# Next segment starts at 0.5 and ends at 0.33: average error is 0.416", "\n", "# Then we take average of all segments and normalize it with the recall values we averaged over.", "\n", "target_error", "=", "(", "(", "0", "+", "0", ")", "/", "2", "+", "(", "0", "+", "0.5", ")", "/", "2", "+", "(", "0.5", "+", "0.33", ")", "/", "2", ")", "/", "(", "3", "*", "0.9", ")", "# It is a piecewise linear with 3 segments", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "gt1", ",", "gt2", ",", "gt3", "]", "}", ",", "{", "'sample1'", ":", "[", "pred1", ",", "pred2", ",", "pred4", "]", "}", ",", "target_error", "=", "target_error", ",", "\n", "metric_name", "=", "'trans_err'", ")", "\n", "\n", "# Both matches have same translational error (1 meter), so the overall error is also 1 meter", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "gt2", ",", "gt3", "]", "}", ",", "{", "'sample1'", ":", "[", "pred2", ",", "pred5", "]", "}", ",", "target_error", "=", "1.0", ",", "\n", "metric_name", "=", "'trans_err'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.test_two_imgs": [[393, 425], ["test_algo.TestTPSimple.check_tp", "test_algo.TestTPSimple.check_tp", "test_algo.TestTPSimple.check_tp", "test_algo.TestTPSimple.check_tp"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestTPSimple.check_tp"], ["", "def", "test_two_imgs", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test the more than one sample case. \"\"\"", "\n", "\n", "# Note all the following unit tests can be repeated to other metrics, but they are not needed.", "\n", "# The intention of these tests is to measure the calc_tp function which is common for all metrics.", "\n", "\n", "gt1", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", "}", "\n", "gt2", "=", "{", "'trans'", ":", "(", "10", ",", "10", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "2", ",", "2", ")", "}", "\n", "gt3", "=", "{", "'trans'", ":", "(", "20", ",", "20", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "4", ",", "2", ")", "}", "\n", "\n", "pred1", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'score'", ":", "1.0", "}", "\n", "pred2", "=", "{", "'trans'", ":", "(", "11", ",", "10", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "2", ",", "2", ")", ",", "'score'", ":", "0.9", "}", "\n", "pred3", "=", "{", "'trans'", ":", "(", "100", ",", "10", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "2", ",", "2", ")", ",", "'score'", ":", "0.8", "}", "\n", "pred4", "=", "{", "'trans'", ":", "(", "21", ",", "20", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "4", ",", "2", ")", ",", "'score'", ":", "0.7", "}", "\n", "\n", "# One GT and one detection", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "gt2", "]", "}", ",", "{", "'sample1'", ":", "[", "pred2", "]", "}", ",", "target_error", "=", "1", ",", "metric_name", "=", "'trans_err'", ")", "\n", "\n", "# Two GT's and two detections.", "\n", "# The target is the average value of the recall vs. Error curve.", "\n", "target_error", "=", "(", "(", "0", "+", "0", ")", "/", "2", "+", "(", "0", "+", "0.5", ")", "/", "2", ")", "/", "(", "2", "*", "0.9", ")", "# It is a piecewise linear with 2 segments.", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "gt1", "]", ",", "'sample2'", ":", "[", "gt2", "]", "}", ",", "{", "'sample1'", ":", "[", "pred1", "]", ",", "'sample2'", ":", "[", "pred2", "]", "}", ",", "\n", "target_error", "=", "target_error", ",", "metric_name", "=", "'trans_err'", ")", "\n", "\n", "# Adding a false positive and/or an empty sample should not affect the score", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "gt1", "]", ",", "'sample2'", ":", "[", "gt2", "]", ",", "'sample3'", ":", "[", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "pred1", "]", ",", "'sample2'", ":", "[", "pred2", ",", "pred3", "]", ",", "'sample3'", ":", "[", "]", "}", ",", "\n", "target_error", "=", "target_error", ",", "metric_name", "=", "'trans_err'", ")", "\n", "\n", "# All the detections does have same error, so the overall error is also same.", "\n", "self", ".", "check_tp", "(", "{", "'sample1'", ":", "[", "gt2", ",", "gt3", "]", ",", "'sample2'", ":", "[", "gt3", "]", "}", ",", "{", "'sample1'", ":", "[", "pred2", "]", ",", "'sample2'", ":", "[", "pred4", "]", "}", ",", "\n", "target_error", "=", "1.0", ",", "metric_name", "=", "'trans_err'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.get_metric_data": [[146, 190], ["nuscenes.eval.common.data_classes.EvalBoxes", "gts.items", "nuscenes.eval.common.data_classes.EvalBoxes", "preds.items", "nuscenes.eval.detection.algo.accumulate", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.detection.data_classes.DetectionBox", "gt_boxes.append", "nuscenes.eval.detection.data_classes.DetectionBox", "pred_boxes.append"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes"], ["", "", "def", "get_metric_data", "(", "gts", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "preds", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "detection_name", ":", "str", ",", "\n", "dist_th", ":", "float", ")", "->", "DetectionMetricData", ":", "\n", "        ", "\"\"\"\n        Calculate and check the AP value.\n        :param gts: Ground truth data.\n        :param preds: Predictions.\n        :param detection_name: Name of the class we are interested in.\n        :param dist_th: Distance threshold for matching.\n        \"\"\"", "\n", "\n", "# Some or all of the defaults will be replaced by if given.", "\n", "defaults", "=", "{", "'trans'", ":", "(", "0", ",", "0", ",", "0", ")", ",", "'size'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'rot'", ":", "(", "0", ",", "0", ",", "0", ",", "0", ")", ",", "\n", "'vel'", ":", "(", "0", ",", "0", ")", ",", "'attr'", ":", "'vehicle.parked'", ",", "'score'", ":", "-", "1.0", ",", "'name'", ":", "'car'", "}", "\n", "# Create GT EvalBoxes instance.", "\n", "gt_eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "for", "sample_token", ",", "data", "in", "gts", ".", "items", "(", ")", ":", "\n", "            ", "gt_boxes", "=", "[", "]", "\n", "for", "gt", "in", "data", ":", "\n", "                ", "gt", "=", "{", "**", "defaults", ",", "**", "gt", "}", "# The defaults will be replaced by gt if given.", "\n", "eb", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "translation", "=", "gt", "[", "'trans'", "]", ",", "size", "=", "gt", "[", "'size'", "]", ",", "\n", "rotation", "=", "gt", "[", "'rot'", "]", ",", "detection_name", "=", "gt", "[", "'name'", "]", ",", "attribute_name", "=", "gt", "[", "'attr'", "]", ",", "\n", "velocity", "=", "gt", "[", "'vel'", "]", ")", "\n", "gt_boxes", ".", "append", "(", "eb", ")", "\n", "\n", "", "gt_eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "gt_boxes", ")", "\n", "\n", "# Create Predictions EvalBoxes instance.", "\n", "", "pred_eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "for", "sample_token", ",", "data", "in", "preds", ".", "items", "(", ")", ":", "\n", "            ", "pred_boxes", "=", "[", "]", "\n", "for", "pred", "in", "data", ":", "\n", "                ", "pred", "=", "{", "**", "defaults", ",", "**", "pred", "}", "\n", "eb", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "translation", "=", "pred", "[", "'trans'", "]", ",", "size", "=", "pred", "[", "'size'", "]", ",", "\n", "rotation", "=", "pred", "[", "'rot'", "]", ",", "detection_name", "=", "pred", "[", "'name'", "]", ",", "detection_score", "=", "pred", "[", "'score'", "]", ",", "\n", "velocity", "=", "pred", "[", "'vel'", "]", ",", "attribute_name", "=", "pred", "[", "'attr'", "]", ")", "\n", "pred_boxes", ".", "append", "(", "eb", ")", "\n", "", "pred_eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "pred_boxes", ")", "\n", "\n", "", "metric_data", "=", "accumulate", "(", "gt_eval_boxes", ",", "pred_eval_boxes", ",", "class_name", "=", "detection_name", ",", "\n", "dist_fcn", "=", "center_distance", ",", "dist_th", "=", "dist_th", ")", "\n", "\n", "return", "metric_data", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.TestEval.test_scale_iou": [[16, 57], ["nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.utils.scale_iou", "test_utils.TestEval.assertEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.utils.scale_iou", "test_utils.TestEval.assertEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.utils.scale_iou", "test_utils.TestEval.assertEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.utils.scale_iou", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertRaises", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertRaises", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertRaises"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.scale_iou", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.scale_iou", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.scale_iou", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.scale_iou"], ["center_of_image_in_pixels", ")", "\n", "\n", "answer", "=", "(", "300", ",", "300", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "\n", "center_of_image_in_global", ",", "\n", "center_of_image_in_pixels", ",", "\n", "resolution", "=", "0.2", ")", "\n", "answer", "=", "(", "350", ",", "275", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n", "", "def", "test_above_and_to_the_left", "(", "self", ")", ":", "\n", "\n", "        ", "location", "=", "(", "40", ",", "70", ")", "\n", "center_of_image_in_global", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_pixels", "=", "(", "300", ",", "300", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "\n", "center_of_image_in_pixels", ")", "\n", "answer", "=", "(", "100", ",", "200", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "\n", "center_of_image_in_pixels", ",", "resolution", "=", "0.2", ")", "\n", "answer", "=", "(", "200", ",", "250", ")", "\n", "self", ".", "assertTupleEqual", "(", "answer", ",", "pixels", ")", "\n", "\n", "", "def", "test_below_and_to_the_right", "(", "self", ")", ":", "\n", "\n", "        ", "location", "=", "(", "60", ",", "45", ")", "\n", "center_of_image_in_global", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_pixels", "=", "(", "400", ",", "250", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "center_of_image_in_pixels", ")", "\n", "answer", "=", "(", "450", ",", "350", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n", "", "def", "test_below_and_to_the_left", "(", "self", ")", ":", "\n", "\n", "        ", "location", "=", "(", "30", ",", "40", ")", "\n", "center_of_image_in_global", "=", "(", "50", ",", "50", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.TestEval.test_yaw_diff": [[58, 90], ["nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.utils.yaw_diff", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.utils.yaw_diff", "test_utils.TestEval.assertAlmostEqual", "pyquaternion.Quaternion", "nuscenes.eval.detection.data_classes.DetectionBox", "numpy.linspace", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.utils.yaw_diff", "test_utils.TestEval.assertAlmostEqual", "pyquaternion.Quaternion", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.utils.yaw_diff", "test_utils.TestEval.assertAlmostEqual", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.yaw_diff", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.yaw_diff", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.yaw_diff", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.yaw_diff"], ["center_of_image_in_pixels", "=", "(", "400", ",", "250", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "center_of_image_in_pixels", ")", "\n", "answer", "=", "(", "500", ",", "50", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "answer", ")", "\n", "\n", "", "def", "test_same_location", "(", "self", ")", ":", "\n", "\n", "        ", "location", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_global", "=", "(", "50", ",", "50", ")", "\n", "center_of_image_in_pixels", "=", "(", "400", ",", "250", ")", "\n", "\n", "pixels", "=", "utils", ".", "convert_to_pixel_coords", "(", "location", ",", "center_of_image_in_global", ",", "center_of_image_in_pixels", ")", "\n", "self", ".", "assertTupleEqual", "(", "pixels", ",", "(", "400", ",", "250", ")", ")", "\n", "\n", "", "", "class", "Test_get_crops", "(", "unittest", ".", "TestCase", ")", ":", "\n", "\n", "    ", "def", "test", "(", "self", ")", ":", "\n", "\n", "        ", "row_crop", ",", "col_crop", "=", "utils", ".", "get_crops", "(", "40", ",", "10", ",", "25", ",", "25", ",", "0.1", ",", "800", ")", "\n", "\n", "self", ".", "assertEqual", "(", "row_crop", ",", "slice", "(", "0", ",", "500", ")", ")", "\n", "self", ".", "assertEqual", "(", "col_crop", ",", "slice", "(", "150", ",", "650", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.TestEval.test_angle_diff": [[91, 130], ["test_utils.TestEval.assertAlmostEqual", "test_utils.TestEval.assertAlmostEqual", "test_utils.TestEval.assertAlmostEqual", "test_utils.TestEval.assertAlmostEqual", "test_utils.TestEval.assertAlmostEqual", "test_utils.TestEval.assertAlmostEqual", "test_utils.TestEval.assertAlmostEqual", "test_utils.TestEval.test_angle_diff.rad"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.TestEval.test_center_distance": [[131, 158], ["nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.common.utils.center_distance", "nuscenes.eval.common.utils.center_distance", "nuscenes.eval.common.utils.center_distance", "numpy.sqrt", "nuscenes.eval.common.utils.center_distance", "numpy.sqrt", "nuscenes.eval.common.utils.center_distance", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.center_distance", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.center_distance", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.center_distance", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.center_distance", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.center_distance"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.TestEval.test_velocity_l2": [[159, 176], ["nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.common.utils.velocity_l2", "nuscenes.eval.common.utils.velocity_l2", "numpy.sqrt", "nuscenes.eval.common.utils.velocity_l2", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.velocity_l2", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.velocity_l2", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.velocity_l2"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.TestEval.test_cummean": [[177, 204], ["numpy.array", "numpy.testing.assert_array_almost_equal", "numpy.array", "numpy.testing.assert_array_almost_equal", "numpy.array", "numpy.testing.assert_array_almost_equal", "numpy.array", "numpy.testing.assert_array_almost_equal", "numpy.array", "numpy.testing.assert_array_almost_equal", "numpy.array", "numpy.testing.assert_array_almost_equal", "numpy.array", "numpy.testing.assert_array_almost_equal", "nuscenes.eval.common.utils.cummean", "numpy.array", "nuscenes.eval.common.utils.cummean", "numpy.array", "nuscenes.eval.common.utils.cummean", "numpy.array", "nuscenes.eval.common.utils.cummean", "numpy.array", "nuscenes.eval.common.utils.cummean", "numpy.array", "nuscenes.eval.common.utils.cummean", "numpy.array", "nuscenes.eval.common.utils.cummean", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.cummean", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.cummean", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.cummean", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.cummean", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.cummean", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.cummean", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.cummean"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_utils.TestEval.test_attr_acc": [[205, 222], ["nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertAlmostEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "test_utils.TestEval.assertIs", "nuscenes.eval.common.utils.attr_acc", "nuscenes.eval.common.utils.attr_acc", "nuscenes.eval.common.utils.attr_acc"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.attr_acc", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.attr_acc", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.attr_acc"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_loader.TestLoader.test_filter_eval_boxes": [[16, 172], ["nuscenes.eval.common.config.config_factory", "nuscenes.NuScenes", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.data_classes.EvalBoxes", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.loaders.filter_eval_boxes", "test_loader.TestLoader.assertEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.data_classes.EvalBoxes", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.loaders.filter_eval_boxes", "test_loader.TestLoader.assertEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.data_classes.EvalBoxes", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.loaders.filter_eval_boxes", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.data_classes.EvalBoxes", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.loaders.filter_eval_boxes", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.data_classes.EvalBoxes", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.loaders.filter_eval_boxes", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.data_classes.EvalBoxes", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.loaders.filter_eval_boxes", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.data_classes.EvalBoxes", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.loaders.filter_eval_boxes", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "test_loader.TestLoader.assertEqual", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes"], ["    ", "def", "test_filter_eval_boxes", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        This tests runs the evaluation for an arbitrary random set of predictions.\n        This score is then captured in this very test such that if we change the eval code,\n        this test will trigger if the results changed.\n        \"\"\"", "\n", "# Get the maximum distance from the config", "\n", "cfg", "=", "config_factory", "(", "'detection_cvpr_2019'", ")", "\n", "max_dist", "=", "cfg", ".", "class_range", "\n", "\n", "assert", "'NUSCENES'", "in", "os", ".", "environ", ",", "'Set NUSCENES env. variable to enable tests.'", "\n", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "'v1.0-mini'", ",", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", ",", "verbose", "=", "False", ")", "\n", "\n", "sample_token", "=", "'0af0feb5b1394b928dd13d648de898f5'", "\n", "# This sample has a bike rack instance 'bfe685042aa34ab7b2b2f24ee0f1645f' with these parameters", "\n", "# 'translation': [683.681, 1592.002, 0.809],", "\n", "# 'size': [1.641, 14.465, 1.4],", "\n", "# 'rotation': [0.3473693995546558, 0.0, 0.0, 0.9377283723195315]", "\n", "\n", "# Test bicycle filtering by creating a box at the same position as the bike rack.", "\n", "box1", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'bicycle'", ")", "\n", "\n", "eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "[", "box1", "]", ")", "\n", "\n", "filtered_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "eval_boxes", ",", "max_dist", ")", "\n", "\n", "self", ".", "assertEqual", "(", "len", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", ")", ",", "0", ")", "# box1 should be filtered.", "\n", "\n", "# Test motorcycle filtering by creating a box at the same position as the bike rack.", "\n", "box2", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'motorcycle'", ")", "\n", "\n", "eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "[", "box1", ",", "box2", "]", ")", "\n", "\n", "filtered_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "eval_boxes", ",", "max_dist", ")", "\n", "\n", "self", ".", "assertEqual", "(", "len", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", ")", ",", "0", ")", "# both box1 and box2 should be filtered.", "\n", "\n", "# Now create a car at the same position as the bike rack.", "\n", "box3", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'car'", ")", "\n", "\n", "eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "[", "box1", ",", "box2", ",", "box3", "]", ")", "\n", "\n", "filtered_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "eval_boxes", ",", "max_dist", ")", "\n", "\n", "self", ".", "assertEqual", "(", "len", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", ")", ",", "1", ")", "# box1 and box2 to be filtered. box3 to stay.", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "0", "]", ".", "detection_name", ",", "'car'", ")", "\n", "\n", "# Now add a bike outside the bike rack.", "\n", "box4", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "68.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'bicycle'", ")", "\n", "\n", "eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "[", "box1", ",", "box2", ",", "box3", ",", "box4", "]", ")", "\n", "\n", "filtered_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "eval_boxes", ",", "max_dist", ")", "\n", "\n", "self", ".", "assertEqual", "(", "len", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", ")", ",", "2", ")", "# box1, box2 to be filtered. box3, box4 to stay.", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "0", "]", ".", "detection_name", ",", "'car'", ")", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "1", "]", ".", "detection_name", ",", "'bicycle'", ")", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "1", "]", ".", "translation", "[", "0", "]", ",", "68.681", ")", "\n", "\n", "# Add another bike on the bike rack center,", "\n", "# but set the ego_dist (derived from ego_translation) higher than what's defined in max_dist", "\n", "box5", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'bicycle'", ",", "\n", "ego_translation", "=", "(", "100.0", ",", "0.0", ",", "0.0", ")", ")", "\n", "\n", "eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "[", "box1", ",", "box2", ",", "box3", ",", "box4", ",", "box5", "]", ")", "\n", "\n", "filtered_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "eval_boxes", ",", "max_dist", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", ")", ",", "2", ")", "# box1, box2, box5 filtered. box3, box4 to stay.", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "0", "]", ".", "detection_name", ",", "'car'", ")", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "1", "]", ".", "detection_name", ",", "'bicycle'", ")", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "1", "]", ".", "translation", "[", "0", "]", ",", "68.681", ")", "\n", "\n", "# Add another bike on the bike rack center but set the num_pts to be zero so that it gets filtered.", "\n", "box6", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'bicycle'", ",", "\n", "num_pts", "=", "0", ")", "\n", "\n", "eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "[", "box1", ",", "box2", ",", "box3", ",", "box4", ",", "box5", ",", "box6", "]", ")", "\n", "\n", "filtered_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "eval_boxes", ",", "max_dist", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", ")", ",", "2", ")", "# box1, box2, box5, box6 filtered. box3, box4 stay", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "0", "]", ".", "detection_name", ",", "'car'", ")", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "1", "]", ".", "detection_name", ",", "'bicycle'", ")", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "1", "]", ".", "translation", "[", "0", "]", ",", "68.681", ")", "\n", "\n", "# Check for a sample where there are no bike racks. Everything should be filtered correctly.", "\n", "sample_token", "=", "'ca9a282c9e77460f8360f564131a8af5'", "# This sample has no bike-racks.", "\n", "\n", "box1", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'bicycle'", ",", "\n", "ego_translation", "=", "(", "25.0", ",", "0.0", ",", "0.0", ")", ")", "\n", "\n", "box2", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'motorcycle'", ",", "\n", "ego_translation", "=", "(", "45.0", ",", "0.0", ",", "0.0", ")", ")", "\n", "\n", "box3", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'car'", ",", "\n", "ego_translation", "=", "(", "45.0", ",", "0.0", ",", "0.0", ")", ")", "\n", "\n", "box4", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'car'", ",", "\n", "ego_translation", "=", "(", "55.0", ",", "0.0", ",", "0.0", ")", ")", "\n", "\n", "box5", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'bicycle'", ",", "\n", "num_pts", "=", "1", ")", "\n", "\n", "box6", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'bicycle'", ",", "\n", "num_pts", "=", "0", ")", "\n", "\n", "eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "[", "box1", ",", "box2", ",", "box3", ",", "box4", ",", "box5", ",", "box6", "]", ")", "\n", "\n", "filtered_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "eval_boxes", ",", "max_dist", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", ")", ",", "3", ")", "# box2, box4, box6 filtered. box1, box3, box5 stay", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "0", "]", ".", "ego_dist", ",", "25.0", ")", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "1", "]", ".", "ego_dist", ",", "45.0", ")", "\n", "self", ".", "assertEqual", "(", "filtered_boxes", ".", "boxes", "[", "sample_token", "]", "[", "2", "]", ".", "num_pts", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_loader.TestLoader.test_get_box_class_field": [[173, 191], ["nuscenes.eval.common.data_classes.EvalBoxes", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "nuscenes.eval.common.loaders._get_box_class_field", "test_loader.TestLoader.assertEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders._get_box_class_field"], ["", "def", "test_get_box_class_field", "(", "self", ")", ":", "\n", "        ", "eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "box1", "=", "DetectionBox", "(", "sample_token", "=", "'box1'", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'bicycle'", ",", "\n", "ego_translation", "=", "(", "25.0", ",", "0.0", ",", "0.0", ")", ")", "\n", "\n", "box2", "=", "DetectionBox", "(", "sample_token", "=", "'box2'", ",", "\n", "translation", "=", "(", "683.681", ",", "1592.002", ",", "0.809", ")", ",", "\n", "size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "detection_name", "=", "'motorcycle'", ",", "\n", "ego_translation", "=", "(", "45.0", ",", "0.0", ",", "0.0", ")", ")", "\n", "eval_boxes", ".", "add_boxes", "(", "'sample1'", ",", "[", "]", ")", "\n", "eval_boxes", ".", "add_boxes", "(", "'sample2'", ",", "[", "box1", ",", "box2", "]", ")", "\n", "\n", "class_field", "=", "_get_box_class_field", "(", "eval_boxes", ")", "\n", "self", ".", "assertEqual", "(", "class_field", ",", "'detection_name'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_data_classes.TestDetectionConfig.test_serialization": [[16, 32], ["os.path.dirname", "os.path.join", "nuscenes.eval.detection.data_classes.DetectionConfig.deserialize", "test_data_classes.TestDetectionConfig.assertEqual", "nuscenes.eval.detection.data_classes.DetectionConfig.deserialize", "test_data_classes.TestDetectionConfig.assertEqual", "os.path.abspath", "open", "json.load", "nuscenes.eval.detection.data_classes.DetectionConfig.deserialize.serialize", "json.loads", "json.dumps", "nuscenes.eval.detection.data_classes.DetectionConfig.deserialize.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["\n", "assert", "'NUSCENES'", "in", "os", ".", "environ", ",", "'Set NUSCENES env. variable to enable tests.'", "\n", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "'v1.0-mini'", ",", "dataroot", "=", "dataroot", ",", "verbose", "=", "False", ")", "\n", "sample_rec", "=", "nusc", ".", "sample", "[", "0", "]", "\n", "lidar_name", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "[", "'filename'", "]", "\n", "radar_name", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "'RADAR_FRONT'", "]", ")", "[", "'filename'", "]", "\n", "lidar_path", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "lidar_name", ")", "\n", "radar_path", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "radar_name", ")", "\n", "pc1", "=", "LidarPointCloud", ".", "from_file", "(", "lidar_path", ")", "\n", "pc2", "=", "RadarPointCloud", ".", "from_file", "(", "radar_path", ")", "\n", "pc3", ",", "_", "=", "LidarPointCloud", ".", "from_file_multisweep", "(", "nusc", ",", "sample_rec", ",", "'LIDAR_TOP'", ",", "'LIDAR_TOP'", ",", "nsweeps", "=", "2", ")", "\n", "pc4", ",", "_", "=", "RadarPointCloud", ".", "from_file_multisweep", "(", "nusc", ",", "sample_rec", ",", "'RADAR_FRONT'", ",", "'RADAR_FRONT'", ",", "nsweeps", "=", "2", ")", "\n", "\n", "# Check for valid dimensions.", "\n", "assert", "pc1", ".", "points", ".", "shape", "[", "0", "]", "==", "pc3", ".", "points", ".", "shape", "[", "0", "]", "==", "4", ",", "'Error: Invalid dimension for lidar pointcloud!'", "\n", "assert", "pc2", ".", "points", ".", "shape", "[", "0", "]", "==", "pc4", ".", "points", ".", "shape", "[", "0", "]", "==", "18", ",", "'Error: Invalid dimension for radar pointcloud!'", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_data_classes.TestDetectionBox.test_serialization": [[36, 41], ["nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox.deserialize", "test_data_classes.TestDetectionBox.assertEqual", "json.loads", "json.dumps", "nuscenes.eval.detection.data_classes.DetectionBox.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["\n", "", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "unittest", ".", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_data_classes.TestEvalBoxes.test_serialization": [[45, 53], ["nuscenes.eval.common.data_classes.EvalBoxes", "range", "nuscenes.eval.common.data_classes.EvalBoxes.deserialize", "test_data_classes.TestEvalBoxes.assertEqual", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "json.loads", "str", "json.dumps", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.detection.data_classes.DetectionBox", "nuscenes.eval.common.data_classes.EvalBoxes.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_data_classes.TestMetricData.test_serialization": [[57, 62], ["nuscenes.eval.detection.data_classes.DetectionMetricData.random_md", "nuscenes.eval.detection.data_classes.DetectionMetricData.deserialize", "test_data_classes.TestMetricData.assertEqual", "json.loads", "json.dumps", "nuscenes.eval.detection.data_classes.DetectionMetricData.random_md.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.random_md", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_data_classes.TestDetectionMetricDataList.test_serialization": [[66, 73], ["nuscenes.eval.detection.data_classes.DetectionMetricDataList", "range", "nuscenes.eval.detection.data_classes.DetectionMetricDataList.deserialize", "test_data_classes.TestDetectionMetricDataList.assertEqual", "nuscenes.eval.detection.data_classes.DetectionMetricDataList.set", "json.loads", "nuscenes.eval.detection.data_classes.DetectionMetricData.random_md", "json.dumps", "nuscenes.eval.detection.data_classes.DetectionMetricDataList.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.random_md", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_data_classes.TestDetectionMetrics.test_serialization": [[77, 114], ["nuscenes.eval.detection.data_classes.DetectionConfig.deserialize", "nuscenes.eval.detection.data_classes.DetectionMetrics", "enumerate", "json.dumps", "nuscenes.eval.detection.data_classes.DetectionMetrics.deserialize", "test_data_classes.TestDetectionMetrics.assertEqual", "cfg[].keys", "nuscenes.eval.detection.data_classes.DetectionMetrics.add_label_ap", "enumerate", "nuscenes.eval.detection.data_classes.DetectionMetrics.serialize", "json.loads", "float", "nuscenes.eval.detection.data_classes.DetectionMetrics.add_label_tp", "float"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_ap", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_tp"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_dataclasses.TestPrediction.test": [[10, 19], ["nuscenes.eval.prediction.data_classes.Prediction", "test_dataclasses.TestPrediction.assertEqual", "test_dataclasses.TestPrediction.assertDictEqual", "numpy.ones", "numpy.zeros", "nuscenes.eval.prediction.data_classes.Prediction.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["    ", "def", "test", "(", "self", ")", ":", "\n", "        ", "prediction", "=", "Prediction", "(", "'instance'", ",", "'sample'", ",", "np", ".", "ones", "(", "(", "2", ",", "2", ",", "2", ")", ")", ",", "np", ".", "zeros", "(", "2", ")", ")", "\n", "\n", "self", ".", "assertEqual", "(", "prediction", ".", "number_of_modes", ",", "2", ")", "\n", "self", ".", "assertDictEqual", "(", "prediction", ".", "serialize", "(", ")", ",", "{", "'instance'", ":", "'instance'", ",", "\n", "'sample'", ":", "'sample'", ",", "\n", "'prediction'", ":", "[", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", ",", "\n", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", "]", ",", "\n", "'probabilities'", ":", "[", "0", ",", "0", "]", "}", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.setUp": [[15, 34], ["numpy.ones", "numpy.expand_dims", "numpy.array", "numpy.repeat", "numpy.repeat", "numpy.array", "numpy.repeat", "numpy.repeat", "numpy.array", "numpy.arange().reshape", "numpy.expand_dims", "numpy.expand_dims", "numpy.arange"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "x_one_mode", "=", "np", ".", "ones", "(", "(", "1", ",", "5", ",", "2", ")", ")", "\n", "self", ".", "y_one_mode", "=", "np", ".", "expand_dims", "(", "np", ".", "arange", "(", "10", ")", ".", "reshape", "(", "5", ",", "2", ")", ",", "0", ")", "\n", "self", ".", "p_one_mode", "=", "np", ".", "array", "(", "[", "[", "1.", "]", "]", ")", "\n", "\n", "x_many_modes", "=", "np", ".", "repeat", "(", "self", ".", "x_one_mode", ",", "3", ",", "axis", "=", "0", ")", "\n", "x_many_modes", "[", "0", ",", ":", "]", "=", "0", "\n", "x_many_modes", "[", "2", ",", ":", "]", "=", "2", "\n", "self", ".", "x_many_modes", "=", "x_many_modes", "\n", "self", ".", "y_many_modes", "=", "np", ".", "repeat", "(", "self", ".", "y_one_mode", ",", "3", ",", "axis", "=", "0", ")", "\n", "self", ".", "p_many_modes", "=", "np", ".", "array", "(", "[", "[", "0.2", ",", "0.5", ",", "0.3", "]", "]", ")", "\n", "\n", "self", ".", "x_many_batches_and_modes", "=", "np", ".", "repeat", "(", "np", ".", "expand_dims", "(", "self", ".", "x_many_modes", ",", "0", ")", ",", "5", ",", "axis", "=", "0", ")", "\n", "self", ".", "y_many_batches_and_modes", "=", "np", ".", "repeat", "(", "np", ".", "expand_dims", "(", "self", ".", "y_many_modes", ",", "0", ")", ",", "5", ",", "axis", "=", "0", ")", "\n", "self", ".", "p_many_batches_and_modes", "=", "np", ".", "array", "(", "[", "[", "0.2", ",", "0.5", ",", "0.3", "]", ",", "\n", "[", "0.5", ",", "0.3", ",", "0.2", "]", ",", "\n", "[", "0.2", ",", "0.3", ",", "0.5", "]", ",", "\n", "[", "0.3", ",", "0.2", ",", "0.5", "]", ",", "\n", "[", "0.3", ",", "0.5", ",", "0.2", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_returns_2d_array_float": [[35, 44], ["numpy.testing.assert_equal", "numpy.testing.assert_equal", "nuscenes.eval.prediction.metrics.returns_2d_array", "numpy.array", "nuscenes.eval.prediction.metrics.returns_2d_array", "numpy.ones", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.returns_2d_array", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.returns_2d_array"], ["", "def", "test_returns_2d_array_float", "(", "self", ")", ":", "\n", "\n", "        ", "func", "=", "lambda", "x", ":", "2", "\n", "value", "=", "metrics", ".", "returns_2d_array", "(", "func", ")", "(", "2", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "2", "]", "]", ")", ")", "\n", "\n", "func", "=", "lambda", "x", ":", "3.", "\n", "value", "=", "metrics", ".", "returns_2d_array", "(", "func", ")", "(", "np", ".", "ones", "(", "(", "10", ",", "1", ")", ")", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "3", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_returns_2d_array_one_dim": [[45, 50], ["numpy.testing.assert_equal", "numpy.ones", "nuscenes.eval.prediction.metrics.returns_2d_array", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.returns_2d_array"], ["", "def", "test_returns_2d_array_one_dim", "(", "self", ")", ":", "\n", "\n", "        ", "func", "=", "lambda", "x", ":", "np", ".", "ones", "(", "10", ")", "\n", "value", "=", "metrics", ".", "returns_2d_array", "(", "func", ")", "(", "1", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "ones", "(", "(", "1", ",", "10", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_mean_distances_one_mode": [[51, 55], ["nuscenes.eval.prediction.metrics.mean_distances", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.mean_distances"], ["", "def", "test_mean_distances_one_mode", "(", "self", ")", ":", "\n", "\n", "        ", "value", "=", "metrics", ".", "mean_distances", "(", "self", ".", "x_one_mode", ",", "self", ".", "y_one_mode", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "5.33529", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_mean_distances_many_modes": [[56, 59], ["nuscenes.eval.prediction.metrics.mean_distances", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.mean_distances"], ["", "def", "test_mean_distances_many_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "mean_distances", "(", "self", ".", "x_many_modes", ",", "self", ".", "y_many_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "6.45396", ",", "5.33529", ",", "4.49286", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_mean_distances_many_batches_and_modes": [[60, 63], ["nuscenes.eval.prediction.metrics.mean_distances", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.mean_distances"], ["", "def", "test_mean_distances_many_batches_and_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "mean_distances", "(", "self", ".", "x_many_batches_and_modes", ",", "self", ".", "y_many_batches_and_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "5", "*", "[", "[", "6.45396", ",", "5.33529", ",", "4.49286", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_max_distances_one_mode": [[64, 67], ["nuscenes.eval.prediction.metrics.max_distances", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.max_distances"], ["", "def", "test_max_distances_one_mode", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "max_distances", "(", "self", ".", "x_one_mode", ",", "self", ".", "y_one_mode", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "10.63014", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_max_distances_many_modes": [[68, 71], ["nuscenes.eval.prediction.metrics.max_distances", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.max_distances"], ["", "def", "test_max_distances_many_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "max_distances", "(", "self", ".", "x_many_modes", ",", "self", ".", "y_many_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "12.04159", ",", "10.63014", ",", "9.21954", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_max_distances_many_batches_and_modes": [[72, 75], ["nuscenes.eval.prediction.metrics.max_distances", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.max_distances"], ["", "def", "test_max_distances_many_batches_and_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "max_distances", "(", "self", ".", "x_many_batches_and_modes", ",", "self", ".", "y_many_batches_and_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "5", "*", "[", "[", "12.04159", ",", "10.63014", ",", "9.21954", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_final_distances_one_mode": [[76, 79], ["nuscenes.eval.prediction.metrics.max_distances", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.max_distances"], ["", "def", "test_final_distances_one_mode", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "max_distances", "(", "self", ".", "x_one_mode", ",", "self", ".", "y_one_mode", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "10.63014", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_final_distances_many_modes": [[80, 83], ["nuscenes.eval.prediction.metrics.max_distances", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.max_distances"], ["", "def", "test_final_distances_many_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "max_distances", "(", "self", ".", "x_many_modes", ",", "self", ".", "y_many_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "12.04159", ",", "10.63014", ",", "9.21954", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_final_distances_many_batches_and_modes": [[84, 87], ["nuscenes.eval.prediction.metrics.max_distances", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.max_distances"], ["", "def", "test_final_distances_many_batches_and_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "max_distances", "(", "self", ".", "x_many_batches_and_modes", ",", "self", ".", "y_many_batches_and_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "5", "*", "[", "[", "12.04159", ",", "10.63014", ",", "9.21954", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_miss_max_distance_one_mode": [[88, 94], ["nuscenes.eval.prediction.metrics.miss_max_distances", "numpy.testing.assert_equal", "nuscenes.eval.prediction.metrics.miss_max_distances", "numpy.testing.assert_equal", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_max_distances", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_max_distances"], ["", "def", "test_miss_max_distance_one_mode", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "miss_max_distances", "(", "self", ".", "x_one_mode", ",", "self", ".", "y_one_mode", ",", "1", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "True", "]", "]", ")", ")", "\n", "\n", "value", "=", "metrics", ".", "miss_max_distances", "(", "self", ".", "x_one_mode", ",", "self", ".", "y_one_mode", ",", "15", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "False", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_miss_max_distances_many_modes": [[95, 98], ["nuscenes.eval.prediction.metrics.miss_max_distances", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_max_distances"], ["", "def", "test_miss_max_distances_many_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "miss_max_distances", "(", "self", ".", "x_many_modes", ",", "self", ".", "y_many_modes", ",", "10", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "True", ",", "True", ",", "False", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_miss_max_distances_many_batches_and_modes": [[99, 102], ["nuscenes.eval.prediction.metrics.miss_max_distances", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_max_distances"], ["", "def", "test_miss_max_distances_many_batches_and_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "miss_max_distances", "(", "self", ".", "x_many_batches_and_modes", ",", "self", ".", "y_many_batches_and_modes", ",", "10", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "5", "*", "[", "[", "True", ",", "True", ",", "False", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_miss_rate_top_k_one_mode": [[103, 106], ["nuscenes.eval.prediction.metrics.miss_rate_top_k", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_rate_top_k"], ["", "def", "test_miss_rate_top_k_one_mode", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "miss_rate_top_k", "(", "self", ".", "x_one_mode", ",", "self", ".", "y_one_mode", ",", "self", ".", "p_one_mode", ",", "2", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "True", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_miss_rate_top_k_many_modes": [[107, 110], ["nuscenes.eval.prediction.metrics.miss_rate_top_k", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_rate_top_k"], ["", "def", "test_miss_rate_top_k_many_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "miss_rate_top_k", "(", "self", ".", "x_many_modes", ",", "self", ".", "y_many_modes", ",", "self", ".", "p_many_modes", ",", "10", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "True", ",", "False", ",", "False", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_miss_rate_top_k_many_batches_and_modes": [[111, 119], ["nuscenes.eval.prediction.metrics.miss_rate_top_k", "numpy.testing.assert_equal", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_rate_top_k"], ["", "def", "test_miss_rate_top_k_many_batches_and_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "miss_rate_top_k", "(", "self", ".", "x_many_batches_and_modes", ",", "\n", "self", ".", "y_many_batches_and_modes", ",", "self", ".", "p_many_batches_and_modes", ",", "10", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "True", ",", "False", ",", "False", "]", ",", "\n", "[", "True", ",", "True", ",", "False", "]", ",", "\n", "[", "False", ",", "False", ",", "False", "]", ",", "\n", "[", "False", ",", "False", ",", "False", "]", ",", "\n", "[", "True", ",", "True", ",", "False", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_min_ade_k_one_mode": [[120, 123], ["nuscenes.eval.prediction.metrics.min_ade_k", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_ade_k"], ["", "def", "test_min_ade_k_one_mode", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "min_ade_k", "(", "self", ".", "x_one_mode", ",", "self", ".", "y_one_mode", ",", "self", ".", "p_one_mode", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "5.33529", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_min_ade_k_many_modes": [[124, 127], ["nuscenes.eval.prediction.metrics.min_ade_k", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_ade_k"], ["", "def", "test_min_ade_k_many_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "min_ade_k", "(", "self", ".", "x_many_modes", ",", "self", ".", "y_many_modes", ",", "self", ".", "p_many_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "5.33529", ",", "4.49286", ",", "4.49286", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_min_ade_k_many_batches_and_modes": [[128, 137], ["nuscenes.eval.prediction.metrics.min_ade_k", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_ade_k"], ["", "def", "test_min_ade_k_many_batches_and_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "min_ade_k", "(", "self", ".", "x_many_batches_and_modes", ",", "self", ".", "y_many_batches_and_modes", ",", "\n", "self", ".", "p_many_batches_and_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "5.33529", ",", "4.49286", ",", "4.49286", "]", ",", "\n", "[", "6.45396", ",", "5.33529", ",", "4.49286", "]", ",", "\n", "[", "4.49286", ",", "4.49286", ",", "4.49286", "]", ",", "\n", "[", "4.49286", ",", "4.49286", ",", "4.49286", "]", ",", "\n", "[", "5.33529", ",", "5.33529", ",", "4.49286", "]", "\n", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_min_fde_k_one_mode": [[138, 141], ["nuscenes.eval.prediction.metrics.min_fde_k", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_fde_k"], ["", "def", "test_min_fde_k_one_mode", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "min_fde_k", "(", "self", ".", "x_one_mode", ",", "self", ".", "y_one_mode", ",", "self", ".", "p_one_mode", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "10.63014", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_min_fde_k_many_modes": [[142, 145], ["nuscenes.eval.prediction.metrics.min_fde_k", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_fde_k"], ["", "def", "test_min_fde_k_many_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "min_fde_k", "(", "self", ".", "x_many_modes", ",", "self", ".", "y_many_modes", ",", "self", ".", "p_many_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "10.63014", ",", "9.21954", ",", "9.21954", "]", "]", ")", ",", "atol", "=", "1e-4", ",", "rtol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_min_fde_k_many_batches_and_modes": [[146, 154], ["nuscenes.eval.prediction.metrics.min_fde_k", "numpy.testing.assert_allclose", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_fde_k"], ["", "def", "test_min_fde_k_many_batches_and_modes", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "min_fde_k", "(", "self", ".", "x_many_batches_and_modes", ",", "self", ".", "y_many_batches_and_modes", ",", "\n", "self", ".", "p_many_batches_and_modes", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "value", ",", "np", ".", "array", "(", "[", "[", "10.63014", ",", "9.21954", ",", "9.21954", "]", ",", "\n", "[", "12.04159", ",", "10.63014", ",", "9.21954", "]", ",", "\n", "[", "9.21954", ",", "9.21954", ",", "9.21954", "]", ",", "\n", "[", "9.21954", ",", "9.21954", ",", "9.21954", "]", ",", "\n", "[", "10.63014", ",", "10.64014", ",", "9.21954", "]", "]", ")", ",", "atol", "=", "1e-3", ",", "rtol", "=", "1e-3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_stack_ground_truth": [[155, 158], ["nuscenes.eval.prediction.metrics.stack_ground_truth", "numpy.testing.assert_equal", "numpy.ones", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.stack_ground_truth"], ["", "def", "test_stack_ground_truth", "(", "self", ")", ":", "\n", "        ", "value", "=", "metrics", ".", "stack_ground_truth", "(", "np", ".", "ones", "(", "(", "5", ",", "2", ")", ")", ",", "10", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "ones", "(", "(", "10", ",", "5", ",", "2", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_desired_number_of_modes_one_mode": [[159, 163], ["numpy.ones", "nuscenes.eval.prediction.metrics.desired_number_of_modes", "numpy.testing.assert_equal", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.desired_number_of_modes"], ["", "def", "test_desired_number_of_modes_one_mode", "(", "self", ")", ":", "\n", "        ", "results", "=", "np", ".", "ones", "(", "(", "10", ",", "1", ")", ")", "\n", "value", "=", "metrics", ".", "desired_number_of_modes", "(", "results", ",", "[", "1", ",", "5", ",", "15", ",", "25", "]", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "ones", "(", "(", "10", ",", "4", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_desired_number_of_modes_enough_data": [[164, 170], ["numpy.arange().reshape", "nuscenes.eval.prediction.metrics.desired_number_of_modes", "numpy.testing.assert_equal", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.desired_number_of_modes"], ["", "def", "test_desired_number_of_modes_enough_data", "(", "self", ")", ":", "\n", "        ", "results", "=", "np", ".", "arange", "(", "75", ")", ".", "reshape", "(", "3", ",", "25", ")", "\n", "value", "=", "metrics", ".", "desired_number_of_modes", "(", "results", ",", "[", "1", ",", "5", ",", "15", ",", "25", "]", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "0", ",", "4", ",", "14", ",", "24", "]", ",", "\n", "[", "25", ",", "29", ",", "39", ",", "49", "]", ",", "\n", "[", "50", ",", "54", ",", "64", ",", "74", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestFunctions.test_desired_number_of_modes_not_enough": [[171, 176], ["numpy.arange().reshape", "nuscenes.eval.prediction.metrics.desired_number_of_modes", "numpy.testing.assert_equal", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.desired_number_of_modes"], ["", "def", "test_desired_number_of_modes_not_enough", "(", "self", ")", ":", "\n", "        ", "results", "=", "np", ".", "arange", "(", "30", ")", ".", "reshape", "(", "2", ",", "15", ")", "\n", "value", "=", "metrics", ".", "desired_number_of_modes", "(", "results", ",", "[", "1", ",", "5", ",", "15", ",", "25", "]", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "value", ",", "np", ".", "array", "(", "[", "[", "0", ",", "4", ",", "14", ",", "14", "]", ",", "\n", "[", "15", ",", "19", ",", "29", ",", "29", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestAggregators.test_RowMean": [[180, 186], ["nuscenes.eval.prediction.metrics.RowMean", "nuscenes.eval.prediction.metrics.RowMean.", "test_metrics.TestAggregators.assertListEqual", "test_metrics.TestAggregators.assertDictEqual", "numpy.arange().reshape", "list", "nuscenes.eval.prediction.metrics.RowMean.serialize", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["    ", "def", "test_RowMean", "(", "self", ")", ":", "\n", "        ", "rm", "=", "metrics", ".", "RowMean", "(", ")", "\n", "value", "=", "rm", "(", "np", ".", "arange", "(", "20", ")", ".", "reshape", "(", "2", ",", "10", ")", ")", "\n", "self", ".", "assertListEqual", "(", "list", "(", "value", ")", ",", "[", "5", ",", "6", ",", "7", ",", "8", ",", "9", ",", "10", ",", "11", ",", "12", ",", "13", ",", "14", "]", ")", "\n", "\n", "self", ".", "assertDictEqual", "(", "rm", ".", "serialize", "(", ")", ",", "{", "'name'", ":", "'RowMean'", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestMetrics.test_MinADEK": [[190, 195], ["nuscenes.eval.prediction.metrics.MinADEK", "test_metrics.TestMetrics.assertDictEqual", "nuscenes.eval.prediction.metrics.MinADEK.serialize", "nuscenes.eval.prediction.metrics.RowMean"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["    ", "def", "test_MinADEK", "(", "self", ")", ":", "\n", "        ", "min_ade", "=", "metrics", ".", "MinADEK", "(", "[", "1", ",", "5", ",", "10", "]", ",", "[", "metrics", ".", "RowMean", "(", ")", "]", ")", "\n", "self", ".", "assertDictEqual", "(", "min_ade", ".", "serialize", "(", ")", ",", "{", "'name'", ":", "'MinADEK'", ",", "\n", "'k_to_report'", ":", "[", "1", ",", "5", ",", "10", "]", ",", "\n", "'aggregators'", ":", "[", "{", "'name'", ":", "'RowMean'", "}", "]", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestMetrics.test_MinFDEK": [[196, 201], ["nuscenes.eval.prediction.metrics.MinFDEK", "test_metrics.TestMetrics.assertDictEqual", "nuscenes.eval.prediction.metrics.MinFDEK.serialize", "nuscenes.eval.prediction.metrics.RowMean"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "def", "test_MinFDEK", "(", "self", ")", ":", "\n", "        ", "min_fde", "=", "metrics", ".", "MinFDEK", "(", "[", "1", ",", "5", ",", "10", "]", ",", "[", "metrics", ".", "RowMean", "(", ")", "]", ")", "\n", "self", ".", "assertDictEqual", "(", "min_fde", ".", "serialize", "(", ")", ",", "{", "'name'", ":", "'MinFDEK'", ",", "\n", "'k_to_report'", ":", "[", "1", ",", "5", ",", "10", "]", ",", "\n", "'aggregators'", ":", "[", "{", "'name'", ":", "'RowMean'", "}", "]", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestMetrics.test_MissRateTopK": [[202, 208], ["nuscenes.eval.prediction.metrics.MissRateTopK", "test_metrics.TestMetrics.assertDictEqual", "nuscenes.eval.prediction.metrics.MissRateTopK.serialize", "nuscenes.eval.prediction.metrics.RowMean"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "def", "test_MissRateTopK", "(", "self", ")", ":", "\n", "        ", "hit_rate", "=", "metrics", ".", "MissRateTopK", "(", "[", "1", ",", "5", ",", "10", "]", ",", "[", "metrics", ".", "RowMean", "(", ")", "]", ",", "2", ")", "\n", "self", ".", "assertDictEqual", "(", "hit_rate", ".", "serialize", "(", ")", ",", "{", "'k_to_report'", ":", "[", "1", ",", "5", ",", "10", "]", ",", "\n", "'name'", ":", "'MissRateTopK'", ",", "\n", "'aggregators'", ":", "[", "{", "'name'", ":", "'RowMean'", "}", "]", ",", "\n", "'tolerance'", ":", "2", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestMetrics.test_OffRoadRate": [[209, 215], ["unittest.mock.patch.object", "unittest.mock.MagicMock", "nuscenes.eval.prediction.metrics.OffRoadRate", "test_metrics.TestMetrics.assertDictEqual", "nuscenes.eval.prediction.metrics.OffRoadRate.serialize", "nuscenes.eval.prediction.metrics.RowMean"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "def", "test_OffRoadRate", "(", "self", ")", ":", "\n", "        ", "with", "patch", ".", "object", "(", "metrics", ".", "OffRoadRate", ",", "'load_drivable_area_masks'", ")", ":", "\n", "            ", "helper", "=", "MagicMock", "(", "spec", "=", "PredictHelper", ")", "\n", "off_road_rate", "=", "metrics", ".", "OffRoadRate", "(", "helper", ",", "[", "metrics", ".", "RowMean", "(", ")", "]", ")", "\n", "self", ".", "assertDictEqual", "(", "off_road_rate", ".", "serialize", "(", ")", ",", "{", "'name'", ":", "'OffRoadRate'", ",", "\n", "'aggregators'", ":", "[", "{", "'name'", ":", "'RowMean'", "}", "]", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestMetrics.test_deserialize_metric": [[216, 254], ["unittest.mock.MagicMock", "nuscenes.eval.prediction.metrics.deserialize_metric", "test_metrics.TestMetrics.assertEqual", "test_metrics.TestMetrics.assertListEqual", "test_metrics.TestMetrics.assertEqual", "nuscenes.eval.prediction.metrics.deserialize_metric", "test_metrics.TestMetrics.assertEqual", "test_metrics.TestMetrics.assertListEqual", "test_metrics.TestMetrics.assertEqual", "nuscenes.eval.prediction.metrics.deserialize_metric", "test_metrics.TestMetrics.assertEqual", "test_metrics.TestMetrics.assertListEqual", "test_metrics.TestMetrics.assertEqual", "unittest.mock.patch.object", "nuscenes.eval.prediction.metrics.deserialize_metric", "test_metrics.TestMetrics.assertEqual", "test_metrics.TestMetrics.assertEqual"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_metric", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_metric", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_metric", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_metric"], ["", "", "def", "test_deserialize_metric", "(", "self", ")", ":", "\n", "\n", "        ", "config", "=", "{", "'name'", ":", "'MinADEK'", ",", "\n", "'k_to_report'", ":", "[", "1", ",", "5", ",", "10", "]", ",", "\n", "'aggregators'", ":", "[", "{", "'name'", ":", "'RowMean'", "}", "]", "}", "\n", "\n", "helper", "=", "MagicMock", "(", "spec", "=", "PredictHelper", ")", "\n", "m", "=", "metrics", ".", "deserialize_metric", "(", "config", ",", "helper", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "name", ",", "'MinADEK'", ")", "\n", "self", ".", "assertListEqual", "(", "m", ".", "k_to_report", ",", "[", "1", ",", "5", ",", "10", "]", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "aggregators", "[", "0", "]", ".", "name", ",", "'RowMean'", ")", "\n", "\n", "config", "=", "{", "'name'", ":", "'MinFDEK'", ",", "\n", "'k_to_report'", ":", "[", "1", ",", "5", ",", "10", "]", ",", "\n", "'aggregators'", ":", "[", "{", "'name'", ":", "'RowMean'", "}", "]", "}", "\n", "\n", "m", "=", "metrics", ".", "deserialize_metric", "(", "config", ",", "helper", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "name", ",", "'MinFDEK'", ")", "\n", "self", ".", "assertListEqual", "(", "m", ".", "k_to_report", ",", "[", "1", ",", "5", ",", "10", "]", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "aggregators", "[", "0", "]", ".", "name", ",", "'RowMean'", ")", "\n", "\n", "config", "=", "{", "'name'", ":", "'MissRateTopK'", ",", "\n", "'k_to_report'", ":", "[", "1", ",", "5", ",", "10", "]", ",", "\n", "'tolerance'", ":", "2", ",", "\n", "'aggregators'", ":", "[", "{", "'name'", ":", "'RowMean'", "}", "]", "}", "\n", "\n", "m", "=", "metrics", ".", "deserialize_metric", "(", "config", ",", "helper", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "name", ",", "'MissRateTopK_2'", ")", "\n", "self", ".", "assertListEqual", "(", "m", ".", "k_to_report", ",", "[", "1", ",", "5", ",", "10", "]", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "aggregators", "[", "0", "]", ".", "name", ",", "'RowMean'", ")", "\n", "\n", "with", "patch", ".", "object", "(", "metrics", ".", "OffRoadRate", ",", "'load_drivable_area_masks'", ")", ":", "\n", "            ", "config", "=", "{", "'name'", ":", "'OffRoadRate'", ",", "\n", "'aggregators'", ":", "[", "{", "'name'", ":", "'RowMean'", "}", "]", "}", "\n", "\n", "m", "=", "metrics", ".", "deserialize_metric", "(", "config", ",", "helper", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "name", ",", "'OffRoadRate'", ")", "\n", "self", ".", "assertEqual", "(", "m", ".", "aggregators", "[", "0", "]", ".", "name", ",", "'RowMean'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestMetrics.test_flatten_metrics": [[255, 271], ["nuscenes.eval.prediction.metrics.flatten_metrics", "test_metrics.TestMetrics.assertDictEqual", "nuscenes.eval.prediction.metrics.MinFDEK", "nuscenes.eval.prediction.metrics.MinADEK", "nuscenes.eval.prediction.metrics.MissRateTopK", "nuscenes.eval.prediction.metrics.RowMean", "nuscenes.eval.prediction.metrics.RowMean", "nuscenes.eval.prediction.metrics.RowMean"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.flatten_metrics"], ["", "", "def", "test_flatten_metrics", "(", "self", ")", ":", "\n", "        ", "results", "=", "{", "\"MinFDEK\"", ":", "{", "\"RowMean\"", ":", "[", "5.92", ",", "6.1", ",", "7.2", "]", "}", ",", "\n", "\"MinADEK\"", ":", "{", "\"RowMean\"", ":", "[", "2.48", ",", "3.29", ",", "3.79", "]", "}", ",", "\n", "\"MissRateTopK_2\"", ":", "{", "\"RowMean\"", ":", "[", "0.37", ",", "0.45", ",", "0.55", "]", "}", "}", "\n", "\n", "metric_functions", "=", "[", "metrics", ".", "MinFDEK", "(", "[", "1", ",", "5", ",", "10", "]", ",", "aggregators", "=", "[", "metrics", ".", "RowMean", "(", ")", "]", ")", ",", "\n", "metrics", ".", "MinADEK", "(", "[", "1", ",", "5", ",", "10", "]", ",", "aggregators", "=", "[", "metrics", ".", "RowMean", "(", ")", "]", ")", ",", "\n", "metrics", ".", "MissRateTopK", "(", "[", "1", ",", "5", ",", "10", "]", ",", "tolerance", "=", "2", ",", "aggregators", "=", "[", "metrics", ".", "RowMean", "(", ")", "]", ")", "]", "\n", "\n", "flattened", "=", "metrics", ".", "flatten_metrics", "(", "results", ",", "metric_functions", ")", "\n", "\n", "answer", "=", "{", "'MinFDEK_1'", ":", "5.92", ",", "'MinFDEK_5'", ":", "6.1", ",", "'MinFDEK_10'", ":", "7.2", ",", "\n", "'MinADEK_1'", ":", "2.48", ",", "'MinADEK_5'", ":", "3.29", ",", "'MinADEK_10'", ":", "3.79", ",", "\n", "'MissRateTopK_2_1'", ":", "0.37", ",", "'MissRateTopK_2_5'", ":", "0.45", ",", "'MissRateTopK_2_10'", ":", "0.55", "}", "\n", "\n", "self", ".", "assertDictEqual", "(", "flattened", ",", "answer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestOffRoadRate._do_test": [[275, 288], ["unittest.mock.patch.object", "nuscenes.NuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.eval.prediction.metrics.OffRoadRate", "numpy.array", "nuscenes.eval.prediction.data_classes.Prediction", "numpy.testing.assert_allclose", "nuscenes.eval.prediction.metrics.OffRoadRate.", "numpy.array", "nuscenes.eval.prediction.metrics.RowMean", "numpy.array"], "methods", ["None"], ["    ", "def", "_do_test", "(", "self", ",", "map_name", ",", "predictions", ",", "answer", ")", ":", "\n", "        ", "with", "patch", ".", "object", "(", "PredictHelper", ",", "'get_map_name_from_sample_token'", ")", "as", "get_map_name", ":", "\n", "            ", "get_map_name", ".", "return_value", "=", "map_name", "\n", "nusc", "=", "NuScenes", "(", "'v1.0-mini'", ",", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", ",", "verbose", "=", "False", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "\n", "off_road_rate", "=", "metrics", ".", "OffRoadRate", "(", "helper", ",", "[", "metrics", ".", "RowMean", "(", ")", "]", ")", "\n", "\n", "probabilities", "=", "np", ".", "array", "(", "[", "1", "/", "3", "]", "*", "predictions", ".", "shape", "[", "0", "]", ")", "\n", "prediction", "=", "Prediction", "(", "'foo-instance'", ",", "'foo-sample'", ",", "predictions", ",", "probabilities", ")", "\n", "\n", "# Two violations out of three trajectories", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "off_road_rate", "(", "np", ".", "array", "(", "[", "]", ")", ",", "prediction", ")", ",", "np", ".", "array", "(", "[", "answer", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestOffRoadRate.test_boston": [[289, 300], ["numpy.array", "test_metrics.TestOffRoadRate._do_test"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestOffRoadRate._do_test"], ["", "", "def", "test_boston", "(", "self", ")", ":", "\n", "        ", "predictions", "=", "np", ".", "array", "(", "[", "[", "(", "486.91778944573264", ",", "812.8782745377198", ")", ",", "\n", "(", "487.3648565923963", ",", "813.7269620253566", ")", ",", "\n", "(", "487.811923719944", ",", "814.5756495230632", ")", ",", "\n", "(", "488.2589908474917", ",", "815.4243370207698", ")", "]", ",", "\n", "[", "(", "486.91778944573264", ",", "812.8782745377198", ")", ",", "\n", "(", "487.3648565923963", ",", "813.7269620253566", ")", ",", "\n", "(", "487.811923719944", ",", "814.5756495230632", ")", ",", "\n", "(", "0", ",", "0", ")", "]", ",", "\n", "[", "(", "0", ",", "0", ")", ",", "(", "0", ",", "1", ")", ",", "(", "0", ",", "2", ")", ",", "(", "0", ",", "3", ")", "]", "]", ")", "\n", "self", ".", "_do_test", "(", "'boston-seaport'", ",", "predictions", ",", "2", "/", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestOffRoadRate.test_one_north": [[302, 313], ["numpy.array", "test_metrics.TestOffRoadRate._do_test"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestOffRoadRate._do_test"], ["", "def", "test_one_north", "(", "self", ")", ":", "\n", "        ", "predictions", "=", "np", ".", "array", "(", "[", "[", "[", "965.8515334916171", ",", "535.711518726687", "]", ",", "\n", "[", "963.6475430050381", ",", "532.9713854167148", "]", ",", "\n", "[", "961.4435525191437", ",", "530.231252106192", "]", ",", "\n", "[", "959.239560587773", ",", "527.4911199583674", "]", "]", ",", "\n", "[", "[", "508.8742570078554", ",", "875.3458194583762", "]", ",", "\n", "[", "505.2029816111618", ",", "877.7929160023881", "]", ",", "\n", "[", "501.5317062144682", ",", "880.2400125464", "]", ",", "\n", "[", "497.86043081777467", ",", "882.6871090904118", "]", "]", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "2", "]", ",", "[", "0", ",", "3", "]", "]", "]", ")", "\n", "self", ".", "_do_test", "(", "'singapore-onenorth'", ",", "predictions", ",", "1", "/", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestOffRoadRate.test_queenstown": [[314, 321], ["numpy.array", "test_metrics.TestOffRoadRate._do_test"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestOffRoadRate._do_test"], ["", "def", "test_queenstown", "(", "self", ")", ":", "\n", "        ", "predictions", "=", "np", ".", "array", "(", "[", "[", "[", "744.8769428947988", ",", "2508.398411382534", "]", ",", "\n", "[", "747.7808552527478", ",", "2507.131371270205", "]", ",", "\n", "[", "750.7893530020073", ",", "2506.1385301483474", "]", ",", "\n", "[", "751", ",", "2506", "]", "]", ",", "\n", "[", "[", "-", "100", ",", "0", "]", ",", "[", "-", "10", ",", "100", "]", ",", "[", "0", ",", "2", "]", ",", "[", "-", "20", ",", "70", "]", "]", "]", ")", "\n", "self", ".", "_do_test", "(", "'singapore-queenstown'", ",", "predictions", ",", "1", "/", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestOffRoadRate.test_hollandvillage": [[322, 332], ["numpy.array", "test_metrics.TestOffRoadRate._do_test"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_metrics.TestOffRoadRate._do_test"], ["", "def", "test_hollandvillage", "(", "self", ")", ":", "\n", "        ", "predictions", "=", "np", ".", "array", "(", "[", "[", "(", "1150.811356677105", ",", "1598.0397224872172", ")", ",", "\n", "(", "1158.783061670897", ",", "1595.5210995059333", ")", ",", "\n", "(", "1166.7543904812692", ",", "1593.0012894706226", ")", ",", "\n", "(", "1174.6895821186222", ",", "1590.3704726754975", ")", "]", ",", "\n", "[", "(", "1263.841977478558", ",", "943.4546342496925", ")", ",", "\n", "(", "1262.3235250519404", ",", "944.6782247770625", ")", ",", "\n", "(", "1260.8163412684773", ",", "945.9156425437817", ")", ",", "\n", "(", "1259.3272449205788", ",", "947.1747683330505", ")", "]", "]", ")", "\n", "self", ".", "_do_test", "(", "'singapore-hollandvillage'", ",", "predictions", ",", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain.basic_test": [[136, 171], ["random.seed", "numpy.random.seed", "eval_set.startswith", "nuscenes.NuScenes", "nuscenes.eval.common.config.config_factory", "nuscenes.eval.tracking.evaluate.TrackingEval", "nuscenes.eval.tracking.evaluate.TrackingEval.main", "open", "test_evaluate.TestMain._mock_submission", "json.dump"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.generate_panoptic_labels.main", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain._mock_submission"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain.test_delta_mock": [[172, 195], ["test_evaluate.TestMain.basic_test", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "print"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain.basic_test"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain.test_delta_gt": [[196, 231], ["test_evaluate.TestMain.basic_test", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "test_evaluate.TestMain.assertAlmostEqual", "print"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tests.test_evaluate.TestMain.basic_test"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.single_scene": [[17, 35], ["nuscenes.eval.tracking.data_classes.TrackingBox", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy"], "methods", ["None"], ["DetectionMetricDataList", "\n", "from", "nuscenes", ".", "eval", ".", "detection", ".", "utils", "import", "detection_name_to_rel_attributes", "\n", "\n", "\n", "class", "TestAlgo", "(", "unittest", ".", "TestCase", ")", ":", "\n", "\n", "    ", "cfg", "=", "config_factory", "(", "'detection_cvpr_2019'", ")", "\n", "\n", "@", "staticmethod", "\n", "def", "_mock_results", "(", "nsamples", ",", "ngt", ",", "npred", ",", "detection_name", ")", ":", "\n", "\n", "        ", "def", "random_attr", "(", ")", ":", "\n", "            ", "\"\"\"\n            This is the most straight-forward way to generate a random attribute.\n            Not currently used b/c we want the test fixture to be back-wards compatible.\n            \"\"\"", "\n", "# Get relevant attributes.", "\n", "rel_attributes", "=", "detection_name_to_rel_attributes", "(", "detection_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_gt_submission": [[36, 64], ["nuscenes.eval.common.config.config_factory", "test_algo.TestAlgo.single_scene", "copy.deepcopy", "nuscenes.eval.tracking.algo.TrackingEvaluation", "nuscenes.eval.tracking.algo.TrackingEvaluation.accumulate", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.single_scene", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["if", "len", "(", "rel_attributes", ")", "==", "0", ":", "\n", "# Empty string for classes without attributes.", "\n", "                ", "return", "''", "\n", "", "else", ":", "\n", "# Pick a random attribute otherwise.", "\n", "                ", "return", "rel_attributes", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "rel_attributes", ")", ")", "]", "\n", "\n", "", "", "pred", "=", "EvalBoxes", "(", ")", "\n", "gt", "=", "EvalBoxes", "(", ")", "\n", "\n", "for", "sample_itt", "in", "range", "(", "nsamples", ")", ":", "\n", "\n", "            ", "this_gt", "=", "[", "]", "\n", "\n", "for", "box_itt", "in", "range", "(", "ngt", ")", ":", "\n", "                ", "translation_xy", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "2", ")", "*", "15", ")", "\n", "this_gt", ".", "append", "(", "DetectionBox", "(", "\n", "sample_token", "=", "str", "(", "sample_itt", ")", ",", "\n", "translation", "=", "(", "translation_xy", "[", "0", "]", ",", "translation_xy", "[", "1", "]", ",", "0.0", ")", ",", "\n", "size", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "*", "4", ")", ",", "\n", "rotation", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "4", ")", ")", ",", "\n", "velocity", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "[", ":", "2", "]", "*", "4", ")", ",", "\n", "detection_name", "=", "detection_name", ",", "\n", "detection_score", "=", "random", ".", "random", "(", ")", ",", "\n", "attribute_name", "=", "random_attr", "(", ")", ",", "\n", "ego_translation", "=", "(", "random", ".", "random", "(", ")", "*", "10", ",", "0", ",", "0", ")", ",", "\n", ")", ")", "\n", "", "gt", ".", "add_boxes", "(", "str", "(", "sample_itt", ")", ",", "this_gt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_empty_submission": [[65, 98], ["nuscenes.eval.common.config.config_factory", "test_algo.TestAlgo.single_scene", "copy.deepcopy", "copy.deepcopy.items", "nuscenes.eval.tracking.algo.TrackingEvaluation", "nuscenes.eval.tracking.algo.TrackingEvaluation.accumulate", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.single_scene", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "for", "sample_itt", "in", "range", "(", "nsamples", ")", ":", "\n", "            ", "this_pred", "=", "[", "]", "\n", "\n", "for", "box_itt", "in", "range", "(", "npred", ")", ":", "\n", "                ", "translation_xy", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "2", ")", "*", "10", ")", "\n", "this_pred", ".", "append", "(", "DetectionBox", "(", "\n", "sample_token", "=", "str", "(", "sample_itt", ")", ",", "\n", "translation", "=", "(", "translation_xy", "[", "0", "]", ",", "translation_xy", "[", "1", "]", ",", "0.0", ")", ",", "\n", "size", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "*", "4", ")", ",", "\n", "rotation", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "4", ")", ")", ",", "\n", "velocity", "=", "tuple", "(", "np", ".", "random", ".", "rand", "(", "3", ")", "[", ":", "2", "]", "*", "4", ")", ",", "\n", "detection_name", "=", "detection_name", ",", "\n", "detection_score", "=", "random", ".", "random", "(", ")", ",", "\n", "attribute_name", "=", "random_attr", "(", ")", ",", "\n", "ego_translation", "=", "(", "random", ".", "random", "(", ")", "*", "10", ",", "0", ",", "0", ")", ",", "\n", ")", ")", "\n", "\n", "", "pred", ".", "add_boxes", "(", "str", "(", "sample_itt", ")", ",", "this_pred", ")", "\n", "\n", "", "return", "gt", ",", "pred", "\n", "\n", "", "def", "test_nd_score", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        This tests runs the full evaluation for an arbitrary random set of predictions.\n        \"\"\"", "\n", "\n", "random", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "\n", "mdl", "=", "DetectionMetricDataList", "(", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "gt", ",", "pred", "=", "self", ".", "_mock_results", "(", "30", ",", "3", ",", "25", ",", "class_name", ")", "\n", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "mdl", ".", "set", "(", "class_name", ",", "dist_th", ",", "accumulate", "(", "gt", ",", "pred", ",", "class_name", ",", "center_distance", ",", "2", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_drop_prediction": [[99, 131], ["nuscenes.eval.common.config.config_factory", "test_algo.TestAlgo.single_scene", "copy.deepcopy", "nuscenes.eval.tracking.algo.TrackingEvaluation", "nuscenes.eval.tracking.algo.TrackingEvaluation.accumulate", "numpy.all", "numpy.isnan", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.single_scene", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["\n", "", "", "metrics", "=", "DetectionMetrics", "(", "self", ".", "cfg", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "ap", "=", "calc_ap", "(", "mdl", "[", "(", "class_name", ",", "dist_th", ")", "]", ",", "self", ".", "cfg", ".", "min_recall", ",", "self", ".", "cfg", ".", "min_precision", ")", "\n", "metrics", ".", "add_label_ap", "(", "class_name", ",", "dist_th", ",", "ap", ")", "\n", "\n", "", "for", "metric_name", "in", "TP_METRICS", ":", "\n", "                ", "metric_data", "=", "mdl", "[", "(", "class_name", ",", "self", ".", "cfg", ".", "dist_th_tp", ")", "]", "\n", "if", "class_name", "in", "[", "'traffic_cone'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", ",", "'orient_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "elif", "class_name", "in", "[", "'barrier'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "else", ":", "\n", "                    ", "tp", "=", "calc_tp", "(", "metric_data", ",", "self", ".", "cfg", ".", "min_recall", ",", "metric_name", ")", "\n", "", "metrics", ".", "add_label_tp", "(", "class_name", ",", "metric_name", ",", "tp", ")", "\n", "\n", "", "", "self", ".", "assertEqual", "(", "0.08606662159639042", ",", "metrics", ".", "nd_score", ")", "\n", "\n", "", "def", "test_calc_tp", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test for calc_tp().\"\"\"", "\n", "\n", "random", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "\n", "md", "=", "DetectionMetricData", ".", "random_md", "(", ")", "\n", "\n", "# min_recall greater than 1.", "\n", "self", ".", "assertEqual", "(", "1.0", ",", "calc_tp", "(", "md", ",", "min_recall", "=", "1", ",", "metric_name", "=", "'trans_err'", ")", ")", "\n", "\n", "", "def", "test_calc_ap", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test for calc_ap().\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_drop_prediction_multiple": [[132, 166], ["nuscenes.eval.common.config.config_factory", "test_algo.TestAlgo.single_scene", "copy.deepcopy", "nuscenes.eval.tracking.algo.TrackingEvaluation", "nuscenes.eval.tracking.algo.TrackingEvaluation.accumulate", "numpy.all", "numpy.isnan", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.single_scene", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["random", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "\n", "md", "=", "DetectionMetricData", ".", "random_md", "(", ")", "\n", "\n", "# Negative min_recall and min_precision", "\n", "self", ".", "assertRaises", "(", "AssertionError", ",", "calc_ap", ",", "md", ",", "-", "0.5", ",", "0.4", ")", "\n", "self", ".", "assertRaises", "(", "AssertionError", ",", "calc_ap", ",", "md", ",", "0.5", ",", "-", "0.8", ")", "\n", "\n", "# More than 1 min_precision/min_recall", "\n", "self", ".", "assertRaises", "(", "AssertionError", ",", "calc_ap", ",", "md", ",", "0.7", ",", "1", ")", "\n", "self", ".", "assertRaises", "(", "AssertionError", ",", "calc_ap", ",", "md", ",", "1.2", ",", "0", ")", "\n", "\n", "\n", "", "", "def", "get_metric_data", "(", "gts", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "preds", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "detection_name", ":", "str", ",", "\n", "dist_th", ":", "float", ")", "->", "DetectionMetricData", ":", "\n", "        ", "\"\"\"\n        Calculate and check the AP value.\n        :param gts: Ground truth data.\n        :param preds: Predictions.\n        :param detection_name: Name of the class we are interested in.\n        :param dist_th: Distance threshold for matching.\n        \"\"\"", "\n", "\n", "# Some or all of the defaults will be replaced by if given.", "\n", "defaults", "=", "{", "'trans'", ":", "(", "0", ",", "0", ",", "0", ")", ",", "'size'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'rot'", ":", "(", "0", ",", "0", ",", "0", ",", "0", ")", ",", "\n", "'vel'", ":", "(", "0", ",", "0", ")", ",", "'attr'", ":", "'vehicle.parked'", ",", "'score'", ":", "-", "1.0", ",", "'name'", ":", "'car'", "}", "\n", "# Create GT EvalBoxes instance.", "\n", "gt_eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "for", "sample_token", ",", "data", "in", "gts", ".", "items", "(", ")", ":", "\n", "            ", "gt_boxes", "=", "[", "]", "\n", "for", "gt", "in", "data", ":", "\n", "                ", "gt", "=", "{", "**", "defaults", ",", "**", "gt", "}", "# The defaults will be replaced by gt if given.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_identity_switch": [[167, 197], ["nuscenes.eval.common.config.config_factory", "test_algo.TestAlgo.single_scene", "copy.deepcopy", "nuscenes.eval.tracking.algo.TrackingEvaluation", "nuscenes.eval.tracking.algo.TrackingEvaluation.accumulate", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.single_scene", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate"], ["eb", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "translation", "=", "gt", "[", "'trans'", "]", ",", "size", "=", "gt", "[", "'size'", "]", ",", "\n", "rotation", "=", "gt", "[", "'rot'", "]", ",", "detection_name", "=", "gt", "[", "'name'", "]", ",", "attribute_name", "=", "gt", "[", "'attr'", "]", ",", "\n", "velocity", "=", "gt", "[", "'vel'", "]", ")", "\n", "gt_boxes", ".", "append", "(", "eb", ")", "\n", "\n", "", "gt_eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "gt_boxes", ")", "\n", "\n", "# Create Predictions EvalBoxes instance.", "\n", "", "pred_eval_boxes", "=", "EvalBoxes", "(", ")", "\n", "for", "sample_token", ",", "data", "in", "preds", ".", "items", "(", ")", ":", "\n", "            ", "pred_boxes", "=", "[", "]", "\n", "for", "pred", "in", "data", ":", "\n", "                ", "pred", "=", "{", "**", "defaults", ",", "**", "pred", "}", "\n", "eb", "=", "DetectionBox", "(", "sample_token", "=", "sample_token", ",", "translation", "=", "pred", "[", "'trans'", "]", ",", "size", "=", "pred", "[", "'size'", "]", ",", "\n", "rotation", "=", "pred", "[", "'rot'", "]", ",", "detection_name", "=", "pred", "[", "'name'", "]", ",", "detection_score", "=", "pred", "[", "'score'", "]", ",", "\n", "velocity", "=", "pred", "[", "'vel'", "]", ",", "attribute_name", "=", "pred", "[", "'attr'", "]", ")", "\n", "pred_boxes", ".", "append", "(", "eb", ")", "\n", "", "pred_eval_boxes", ".", "add_boxes", "(", "sample_token", ",", "pred_boxes", ")", "\n", "\n", "", "metric_data", "=", "accumulate", "(", "gt_eval_boxes", ",", "pred_eval_boxes", ",", "class_name", "=", "detection_name", ",", "\n", "dist_fcn", "=", "center_distance", ",", "dist_th", "=", "dist_th", ")", "\n", "\n", "return", "metric_data", "\n", "\n", "\n", "", "class", "TestAPSimple", "(", "unittest", ".", "TestCase", ")", ":", "\n", "    ", "\"\"\" Tests the correctness of AP calculation for simple cases. \"\"\"", "\n", "\n", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "self", ".", "car1", "=", "{", "'trans'", ":", "(", "1", ",", "1", ",", "1", ")", ",", "'name'", ":", "'car'", ",", "'score'", ":", "1.0", ",", "}", "\n", "self", ".", "car2", "=", "{", "'trans'", ":", "(", "3", ",", "3", ",", "1", ")", ",", "'name'", ":", "'car'", ",", "'score'", ":", "0.7", "}", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_drop_gt": [[198, 227], ["nuscenes.eval.common.config.config_factory", "test_algo.TestAlgo.single_scene", "copy.deepcopy", "nuscenes.eval.tracking.algo.TrackingEvaluation", "nuscenes.eval.tracking.algo.TrackingEvaluation.accumulate", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.single_scene", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["self", ".", "bicycle1", "=", "{", "'trans'", ":", "(", "5", ",", "5", ",", "1", ")", ",", "'name'", ":", "'bicycle'", ",", "'score'", ":", "1.0", "}", "\n", "self", ".", "bicycle2", "=", "{", "'trans'", ":", "(", "7", ",", "7", ",", "1", ")", ",", "'name'", ":", "'bicycle'", ",", "'score'", ":", "0.7", "}", "\n", "\n", "", "def", "check_ap", "(", "self", ",", "gts", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "preds", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "target_ap", ":", "float", ",", "\n", "detection_name", ":", "str", "=", "'car'", ",", "\n", "dist_th", ":", "float", "=", "2.0", ",", "\n", "min_precision", ":", "float", "=", "0.1", ",", "\n", "min_recall", ":", "float", "=", "0.1", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Calculate and check the AP value.\n        :param gts: Ground truth data.\n        :param preds: Predictions.\n        :param target_ap: Expected Average Precision value.\n        :param detection_name: Name of the class we are interested in.\n        :param dist_th: Distance threshold for matching.\n        :param min_precision: Minimum precision value.\n        :param min_recall: Minimum recall value.\n        \"\"\"", "\n", "metric_data", "=", "get_metric_data", "(", "gts", ",", "preds", ",", "detection_name", ",", "dist_th", ")", "\n", "ap", "=", "calc_ap", "(", "metric_data", ",", "min_precision", "=", "min_precision", ",", "min_recall", "=", "min_recall", ")", "\n", "\n", "# We quantize the curve into 100 bins to calculate integral so the AP is accurate up to 1%.", "\n", "self", ".", "assertGreaterEqual", "(", "0.01", ",", "abs", "(", "ap", "-", "target_ap", ")", ",", "msg", "=", "'Incorrect AP'", ")", "\n", "\n", "", "def", "test_no_data", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test empty ground truth and/or predictions. \"\"\"", "\n", "\n", "gts", "=", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_drop_gt_interpolate": [[228, 260], ["nuscenes.eval.common.config.config_factory", "test_algo.TestAlgo.single_scene", "copy.deepcopy", "nuscenes.eval.tracking.loaders.interpolate_tracks", "nuscenes.eval.tracking.algo.TrackingEvaluation", "nuscenes.eval.tracking.algo.TrackingEvaluation.accumulate", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "collections.defaultdict"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.single_scene", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.loaders.interpolate_tracks", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["preds", "=", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", "\n", "empty", "=", "{", "'sample1'", ":", "[", "]", "}", "\n", "\n", "# No ground truth objects (all False positives)", "\n", "self", ".", "check_ap", "(", "empty", ",", "preds", ",", "target_ap", "=", "0.0", ")", "\n", "\n", "# No predictions (all False negatives)", "\n", "self", ".", "check_ap", "(", "gts", ",", "empty", ",", "target_ap", "=", "0.0", ")", "\n", "\n", "# No predictions and no ground truth objects.", "\n", "self", ".", "check_ap", "(", "empty", ",", "empty", ",", "target_ap", "=", "0.0", ")", "\n", "\n", "", "def", "test_one_sample", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test the single sample case. \"\"\"", "\n", "# Perfect detection.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# Detect one of the two objects", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", ",", "self", ".", "car2", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "target_ap", "=", "0.4", "/", "0.9", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# One detection and one FP. FP score is less than TP score.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", ",", "self", ".", "car2", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# One detection and one FP. FP score is more than TP score.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car2", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", ",", "self", ".", "car2", "]", "}", ",", "\n", "target_ap", "=", "(", "(", "0.8", "*", "0.4", ")", "/", "2", ")", "/", "(", "0.9", "*", "0.9", ")", ",", "detection_name", "=", "'car'", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_algo.TestAlgo.test_scenarios": [[261, 294], ["nuscenes.eval.common.config.config_factory", "nuscenes.eval.tracking.tests.scenarios.get_scenarios", "enumerate", "nuscenes.eval.tracking.algo.TrackingEvaluation", "nuscenes.eval.tracking.algo.TrackingEvaluation.accumulate", "scenario[].items", "enumerate", "test_algo.TestAlgo.test_scenarios.create_tracks"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory", "home.repos.pwc.inspect_result.fpthink_v2b.tests.scenarios.get_scenarios", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.loaders.create_tracks"], ["\n", "# FP but different class.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", ",", "self", ".", "bicycle1", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "", "def", "test_two_samples", "(", "self", ")", ":", "\n", "        ", "\"\"\" Test more than one sample case. \"\"\"", "\n", "# Objects in both samples are detected.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "self", ".", "car2", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "self", ".", "car2", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# Object in first sample is detected, second sample is empty.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "]", "}", ",", "\n", "target_ap", "=", "1.0", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "# Perfect detection in one image, FN in other.", "\n", "self", ".", "check_ap", "(", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "self", ".", "car2", "]", "}", ",", "\n", "{", "'sample1'", ":", "[", "self", ".", "car1", "]", ",", "'sample2'", ":", "[", "]", "}", ",", "\n", "target_ap", "=", "0.4", "/", "0.9", ",", "detection_name", "=", "'car'", ")", "\n", "\n", "\n", "", "", "class", "TestTPSimple", "(", "unittest", ".", "TestCase", ")", ":", "\n", "    ", "\"\"\" Tests the correctness of true positives metrics calculation for simple cases. \"\"\"", "\n", "\n", "def", "setUp", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "car3", "=", "{", "'trans'", ":", "(", "3", ",", "3", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "4", ",", "2", ")", ",", "'rot'", ":", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "0", ")", ",", "'score'", ":", "1.0", "}", "\n", "self", ".", "car4", "=", "{", "'trans'", ":", "(", "3", ",", "3", ",", "1", ")", ",", "'size'", ":", "(", "2", ",", "4", ",", "2", ")", ",", "'rot'", ":", "Quaternion", "(", "axis", "=", "(", "0", ",", "0", ",", "1", ")", ",", "angle", "=", "0", ")", ",", "'score'", ":", "1.0", "}", "\n", "\n", "", "def", "check_tp", "(", "self", ",", "gts", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n", "preds", ":", "Dict", "[", "str", ",", "List", "[", "Dict", "]", "]", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.scenarios.get_scenarios": [[6, 94], ["numpy.array().astype", "scenarios.append", "numpy.array().astype", "scenarios.append", "numpy.array().astype", "scenarios.append", "numpy.array().astype", "scenarios.append", "numpy.array().astype", "numpy.array().astype", "scenarios.append", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["def", "get_scenarios", "(", ")", "->", "List", "[", "Dict", "[", "str", ",", "dict", "]", "]", ":", "\n", "    ", "\"\"\" \"\"\"", "\n", "\n", "scenarios", "=", "[", "]", "\n", "\n", "# Scenario 1.", "\n", "# Parallel motion 1 meter distance.", "\n", "pos_gt", "=", "np", ".", "array", "(", "[", "[", "(", "1", ",", "-", "3", ")", ",", "(", "1", ",", "-", "2", ")", ",", "(", "1", ",", "-", "1", ")", ",", "(", "1", ",", "-", "0", ")", "]", ",", "\n", "[", "(", "0", ",", "-", "3", ")", ",", "(", "0", ",", "-", "2", ")", ",", "(", "0", ",", "-", "1", ")", ",", "(", "0", ",", "-", "0", ")", "]", ",", "]", ")", ".", "astype", "(", "float", ")", "\n", "pos_pred", "=", "pos_gt", "\n", "sigma", "=", "0.1", "\n", "pos_pred", "+=", "sigma", "*", "np", ".", "random", ".", "randn", "(", "*", "pos_pred", ".", "shape", ")", "\n", "\n", "input_data", "=", "{", "'pos_gt'", ":", "pos_gt", ",", "\n", "'pos_pred'", ":", "pos_pred", "}", "\n", "output_data", "=", "{", "'ids'", ":", "0.0", "}", "\n", "\n", "scenarios", ".", "append", "(", "{", "'input'", ":", "input_data", ",", "'output'", ":", "output_data", "}", ")", "\n", "\n", "# Scenario 2.", "\n", "# Parallel motion bring closer predictions.", "\n", "pos_gt", "=", "np", ".", "array", "(", "[", "[", "(", "1", ",", "-", "3", ")", ",", "(", "1", ",", "-", "2", ")", ",", "(", "1", ",", "-", "1", ")", ",", "(", "1", ",", "-", "0", ")", "]", ",", "\n", "[", "(", "0", ",", "-", "3", ")", ",", "(", "0", ",", "-", "2", ")", ",", "(", "0", ",", "-", "1", ")", ",", "(", "0", ",", "-", "0", ")", "]", ",", "]", ")", ".", "astype", "(", "float", ")", "\n", "pos_pred", "=", "pos_gt", "\n", "\n", "pos_pred", "[", "0", ",", ":", ",", "0", "]", "-=", "0.3", "\n", "pos_pred", "[", "1", ",", ":", ",", "0", "]", "+=", "0.3", "\n", "sigma", "=", "0.1", "\n", "pos_pred", "+=", "sigma", "*", "np", ".", "random", ".", "randn", "(", "*", "pos_pred", ".", "shape", ")", "\n", "\n", "input_data", "=", "{", "'pos_gt'", ":", "pos_gt", ",", "\n", "'pos_pred'", ":", "pos_pred", "}", "\n", "output_data", "=", "{", "'ids'", ":", "0.0", "}", "\n", "\n", "scenarios", ".", "append", "(", "{", "'input'", ":", "input_data", ",", "'output'", ":", "output_data", "}", ")", "\n", "\n", "# Scenario 3.", "\n", "# Parallel motion bring closer both ground truth and predictions.", "\n", "pos_gt", "=", "np", ".", "array", "(", "[", "[", "(", "1", ",", "-", "3", ")", ",", "(", "1", ",", "-", "2", ")", ",", "(", "1", ",", "-", "1", ")", ",", "(", "1", ",", "-", "0", ")", "]", ",", "\n", "[", "(", "0", ",", "-", "3", ")", ",", "(", "0", ",", "-", "2", ")", ",", "(", "0", ",", "-", "1", ")", ",", "(", "0", ",", "-", "0", ")", "]", ",", "]", ")", ".", "astype", "(", "float", ")", "\n", "pos_pred", "=", "pos_gt", "\n", "\n", "pos_gt", "[", "0", ",", ":", ",", "0", "]", "-=", "0.3", "\n", "pos_gt", "[", "1", ",", ":", ",", "0", "]", "+=", "0.3", "\n", "pos_pred", "[", "0", ",", ":", ",", "0", "]", "-=", "0.3", "\n", "pos_pred", "[", "1", ",", ":", ",", "0", "]", "+=", "0.3", "\n", "sigma", "=", "0.1", "\n", "pos_pred", "+=", "sigma", "*", "np", ".", "random", ".", "randn", "(", "*", "pos_pred", ".", "shape", ")", "\n", "\n", "input_data", "=", "{", "'pos_gt'", ":", "pos_gt", ",", "\n", "'pos_pred'", ":", "pos_pred", "}", "\n", "output_data", "=", "{", "'ids'", ":", "0.0", "}", "\n", "\n", "scenarios", ".", "append", "(", "{", "'input'", ":", "input_data", ",", "'output'", ":", "output_data", "}", ")", "\n", "\n", "# Scenario 4.", "\n", "# Crossing motion.", "\n", "pos_gt", "=", "np", ".", "array", "(", "[", "[", "(", "2", ",", "-", "3", ")", ",", "(", "1", ",", "-", "2", ")", ",", "(", "0", ",", "-", "1", ")", ",", "(", "-", "1", ",", "-", "0", ")", "]", ",", "\n", "[", "(", "-", "2", ",", "-", "3", ")", ",", "(", "-", "1", ",", "-", "2", ")", ",", "(", "0", ",", "-", "1", ")", ",", "(", "1", ",", "-", "0", ")", "]", ",", "]", ")", ".", "astype", "(", "float", ")", "\n", "pos_pred", "=", "pos_gt", "\n", "sigma", "=", "0.1", "\n", "pos_pred", "+=", "sigma", "*", "np", ".", "random", ".", "randn", "(", "*", "pos_pred", ".", "shape", ")", "\n", "\n", "input_data", "=", "{", "'pos_gt'", ":", "pos_gt", ",", "\n", "'pos_pred'", ":", "pos_pred", "}", "\n", "output_data", "=", "{", "'ids'", ":", "0.0", "}", "\n", "\n", "scenarios", ".", "append", "(", "{", "'input'", ":", "input_data", ",", "'output'", ":", "output_data", "}", ")", "\n", "\n", "# Scenario 5.", "\n", "# Identity switch due to a single misdetection (3rd timestamp).", "\n", "pos_pred", "=", "np", ".", "array", "(", "[", "\n", "[", "(", "0", ",", "-", "2", ")", ",", "(", "0", ",", "-", "1", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "1", ")", ",", "(", "0", ",", "2", ")", "]", ",", "\n", "[", "(", "-", "2", ",", "0", ")", ",", "(", "-", "1", ",", "0", ")", ",", "(", "3", ",", "0", ")", ",", "(", "1", ",", "0", ")", ",", "(", "2", ",", "0", ")", "]", ",", "\n", "]", ")", ".", "astype", "(", "float", ")", "\n", "pos_gt", "=", "np", ".", "array", "(", "[", "\n", "[", "(", "-", "2", ",", "0", ")", ",", "(", "-", "1", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "1", ",", "0", ")", ",", "(", "2", ",", "0", ")", "]", ",", "\n", "]", ")", ".", "astype", "(", "float", ")", "\n", "sigma", "=", "0.1", "\n", "pos_pred", "+=", "sigma", "*", "np", ".", "random", ".", "randn", "(", "*", "pos_pred", ".", "shape", ")", "\n", "\n", "input_data", "=", "{", "'pos_gt'", ":", "pos_gt", ",", "\n", "'pos_pred'", ":", "pos_pred", "}", "\n", "output_data", "=", "{", "'ids'", ":", "2", "}", "\n", "\n", "scenarios", ".", "append", "(", "{", "'input'", ":", "input_data", ",", "'output'", ":", "output_data", "}", ")", "\n", "\n", "return", "scenarios", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertCoords.setUp": [[33, 50], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.arange", "numpy.arange", "numpy.zeros", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange"], "methods", ["None"], ["        ", "assert", "table_name", "in", "{", "'sample_annotation'", ",", "'sample'", "}", "\n", "return", "getattr", "(", "self", ",", "\"_\"", "+", "table_name", ")", "[", "token", "]", "\n", "\n", "\n", "", "", "class", "TestConvertGlobalCoordsToLocal", "(", "unittest", ".", "TestCase", ")", ":", "\n", "\n", "    ", "def", "setUp", "(", "self", ")", "->", "None", ":", "\n", "# Creating 5 different trajectories to be shared by", "\n", "# coordinate frame rotation unit tests.", "\n", "# These trajectories go along each of the axes in", "\n", "# the x-y plane as well as the line y=x", "\n", "        ", "along_pos_x", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "along_pos_y", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "along_neg_x", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "along_neg_y", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "\n", "along_pos_x", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "along_pos_y", "[", ":", ",", "1", "]", "=", "np", ".", "arange", "(", "1", ",", "6", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertCoords.test_heading_0": [[51, 99], ["nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global"], ["along_neg_x", "[", ":", ",", "0", "]", "=", "-", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "along_neg_y", "[", ":", ",", "1", "]", "=", "-", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "self", ".", "along_pos_x", ",", "self", ".", "along_pos_y", "=", "along_pos_x", ",", "along_pos_y", "\n", "self", ".", "along_neg_x", ",", "self", ".", "along_neg_y", "=", "along_neg_x", ",", "along_neg_y", "\n", "\n", "y_equals_x", "=", "np", ".", "zeros", "(", "(", "5", ",", "2", ")", ")", "\n", "y_equals_x", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "y_equals_x", "[", ":", ",", "1", "]", "=", "np", ".", "arange", "(", "1", ",", "6", ")", "\n", "self", ".", "y_equals_x", "=", "y_equals_x", "\n", "\n", "", "def", "_run", "(", "self", ",", "\n", "rotation", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "origin", ":", "Tuple", "[", "float", ",", "float", ",", "float", "]", ",", "\n", "offset", ":", "Tuple", "[", "float", ",", "float", ",", "float", "]", ",", "\n", "along_pos_x_answer", ":", "np", ".", "ndarray", ",", "\n", "along_pos_y_answer", ":", "np", ".", "ndarray", ",", "\n", "along_neg_x_answer", ":", "np", ".", "ndarray", ",", "\n", "along_neg_y_answer", ":", "np", ".", "ndarray", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "offset_as_list", "=", "[", "[", "offset", "[", "0", "]", ",", "offset", "[", "1", "]", "]", "]", "\n", "\n", "# Testing path along pos x direction", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_pos_x", ",", "origin", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_pos_x_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_pos_x", "+", "offset_as_list", ",", "offset", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_pos_x_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "# Testing path along pos y direction", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_pos_y", ",", "origin", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_pos_y_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_pos_y", "+", "offset_as_list", ",", "offset", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_pos_y_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "# Testing path along neg x direction", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_neg_x", ",", "origin", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_neg_x_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_neg_x", "+", "offset_as_list", ",", "offset", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_neg_x_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "# Testing path along neg y direction", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_neg_y", ",", "origin", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_neg_y_answer", ",", "atol", "=", "1e-4", ")", "\n", "\n", "answer", "=", "convert_global_coords_to_local", "(", "self", ".", "along_neg_y", "+", "offset_as_list", ",", "offset", ",", "rotation", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "answer", ",", "along_neg_y_answer", ",", "atol", "=", "1e-4", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertCoords.test_heading_pi_over_4": [[100, 148], ["nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.cos", "numpy.sin", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global"], ["\n", "", "def", "test_heading_0", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "1", ",", "0", ",", "0", ",", "0", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "along_pos_y", ",", "\n", "along_pos_y_answer", "=", "self", ".", "along_neg_x", ",", "\n", "along_neg_x_answer", "=", "self", ".", "along_neg_y", ",", "\n", "along_neg_y_answer", "=", "self", ".", "along_pos_x", ")", "\n", "\n", "", "def", "test_heading_pi_over_4", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "np", ".", "pi", "/", "8", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "np", ".", "pi", "/", "8", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "y_equals_x", "*", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "\n", "along_pos_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ")", "\n", "\n", "", "def", "test_heading_pi_over_2", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "np", ".", "pi", "/", "4", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "np", ".", "pi", "/", "4", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "along_pos_x", ",", "\n", "along_pos_y_answer", "=", "self", ".", "along_pos_y", ",", "\n", "along_neg_x_answer", "=", "self", ".", "along_neg_x", ",", "\n", "along_neg_y_answer", "=", "self", ".", "along_neg_y", ")", "\n", "\n", "", "def", "test_heading_3pi_over_4", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "3", "*", "np", ".", "pi", "/", "8", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "3", "*", "np", ".", "pi", "/", "8", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_pos_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ")", "\n", "\n", "", "def", "test_heading_pi", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "np", ".", "pi", "/", "2", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "np", ".", "pi", "/", "2", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n", "offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "along_neg_y", ",", "\n", "along_pos_y_answer", "=", "self", ".", "along_pos_x", ",", "\n", "along_neg_x_answer", "=", "self", ".", "along_pos_y", ",", "\n", "along_neg_y_answer", "=", "self", ".", "along_neg_x", ")", "\n", "\n", "", "def", "test_heading_neg_pi_over_4", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_run", "(", "rotation", "=", "(", "np", ".", "cos", "(", "-", "np", ".", "pi", "/", "8", ")", ",", "0", ",", "0", ",", "np", ".", "sin", "(", "-", "np", ".", "pi", "/", "8", ")", ")", ",", "\n", "origin", "=", "(", "0", ",", "0", ",", "0", ")", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertCoords.test_heading_pi_over_2": [[149, 197], ["nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.cos", "numpy.sin", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global"], ["offset", "=", "(", "50", ",", "25", ",", "0", ")", ",", "\n", "along_pos_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_pos_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_x_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "-", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ",", "\n", "along_neg_y_answer", "=", "self", ".", "y_equals_x", "*", "[", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", "]", ")", "\n", "\n", "\n", "", "", "class", "TestPredictHelper", "(", "unittest", ".", "TestCase", ")", ":", "\n", "\n", "    ", "def", "setUp", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "self", ".", "mock_annotations", "=", "[", "{", "'token'", ":", "'1'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'1'", ",", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "''", ",", "'next'", ":", "'2'", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'2'", ",", "'translation'", ":", "[", "1", ",", "1", ",", "1", "]", ",", "'rotation'", ":", "[", "np", ".", "sqrt", "(", "2", ")", "/", "2", ",", "0", ",", "0", ",", "np", ".", "sqrt", "(", "2", ")", "/", "2", "]", ",", "\n", "'prev'", ":", "'1'", ",", "'next'", ":", "'3'", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'3'", ",", "'translation'", ":", "[", "2", ",", "2", ",", "2", "]", ",", "'prev'", ":", "'2'", ",", "'next'", ":", "'4'", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'4'", ",", "'translation'", ":", "[", "3", ",", "3", ",", "3", "]", ",", "'prev'", ":", "'3'", ",", "'next'", ":", "'5'", "}", ",", "\n", "{", "'token'", ":", "'5'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'5'", ",", "'translation'", ":", "[", "4", ",", "4", ",", "4", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "'4'", ",", "'next'", ":", "'6'", "}", ",", "\n", "{", "'token'", ":", "'6'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'6'", ",", "'translation'", ":", "[", "5", ",", "5", ",", "5", "]", ",", "'prev'", ":", "'5'", ",", "'next'", ":", "''", "}", "]", "\n", "\n", "self", ".", "multiagent_mock_annotations", "=", "[", "{", "'token'", ":", "'1'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'1'", ",", "'translation'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "''", ",", "'next'", ":", "'2'", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'2'", ",", "'translation'", ":", "[", "1", ",", "1", ",", "1", "]", ",", "'prev'", ":", "'1'", ",", "'next'", ":", "'3'", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'3'", ",", "'translation'", ":", "[", "2", ",", "2", ",", "2", "]", ",", "'prev'", ":", "'2'", ",", "'next'", ":", "'4'", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'4'", ",", "'translation'", ":", "[", "3", ",", "3", ",", "3", "]", ",", "'prev'", ":", "'3'", ",", "'next'", ":", "'5'", "}", ",", "\n", "{", "'token'", ":", "'5'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'5'", ",", "'translation'", ":", "[", "4", ",", "4", ",", "4", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "'4'", ",", "'next'", ":", "'6'", "}", ",", "\n", "{", "'token'", ":", "'6'", ",", "'instance_token'", ":", "'1'", ",", "'sample_token'", ":", "'6'", ",", "'translation'", ":", "[", "5", ",", "5", ",", "5", "]", ",", "'prev'", ":", "'5'", ",", "'next'", ":", "''", "}", ",", "\n", "{", "'token'", ":", "'1b'", ",", "'instance_token'", ":", "'2'", ",", "'sample_token'", ":", "'1'", ",", "'translation'", ":", "[", "6", ",", "6", ",", "6", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "''", ",", "'next'", ":", "'2b'", "}", ",", "\n", "{", "'token'", ":", "'2b'", ",", "'instance_token'", ":", "'2'", ",", "'sample_token'", ":", "'2'", ",", "'translation'", ":", "[", "7", ",", "7", ",", "7", "]", ",", "'prev'", ":", "'1b'", ",", "'next'", ":", "'3b'", "}", ",", "\n", "{", "'token'", ":", "'3b'", ",", "'instance_token'", ":", "'2'", ",", "'sample_token'", ":", "'3'", ",", "'translation'", ":", "[", "8", ",", "8", ",", "8", "]", ",", "'prev'", ":", "'2b'", ",", "'next'", ":", "'4b'", "}", ",", "\n", "{", "'token'", ":", "'4b'", ",", "'instance_token'", ":", "'2'", ",", "'sample_token'", ":", "'4'", ",", "'translation'", ":", "[", "9", ",", "9", ",", "9", "]", ",", "'prev'", ":", "'3b'", ",", "'next'", ":", "'5b'", "}", ",", "\n", "{", "'token'", ":", "'5b'", ",", "'instance_token'", ":", "'2'", ",", "'sample_token'", ":", "'5'", ",", "'translation'", ":", "[", "10", ",", "10", ",", "10", "]", ",", "'rotation'", ":", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "'prev'", ":", "'4b'", ",", "'next'", ":", "'6b'", "}", ",", "\n", "{", "'token'", ":", "'6b'", ",", "'instance_token'", ":", "'2'", ",", "'sample_token'", ":", "'6'", ",", "'translation'", ":", "[", "11", ",", "11", ",", "11", "]", ",", "'prev'", ":", "'5b'", ",", "'next'", ":", "''", "}", "]", "\n", "\n", "", "def", "test_get_sample_annotation", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_annotation", "=", "{", "'token'", ":", "'1'", ",", "'instance_token'", ":", "'instance_1'", ",", "'sample_token'", ":", "'sample_1'", "}", "\n", "mock_sample", "=", "{", "'token'", ":", "'sample_1'", ",", "'timestamp'", ":", "0", "}", "\n", "\n", "nusc", "=", "MockNuScenes", "(", "[", "mock_annotation", "]", ",", "[", "mock_sample", "]", ")", "\n", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "self", ".", "assertDictEqual", "(", "mock_annotation", ",", "helper", ".", "get_sample_annotation", "(", "'instance_1'", ",", "'sample_1'", ")", ")", "\n", "\n", "", "def", "test_get_future_for_agent_exact_amount", "(", "self", ")", "->", "None", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertCoords.test_heading_3pi_over_4": [[198, 246], ["nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.cos", "numpy.sin", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global"], ["\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "1e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "2e6", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "3e6", "}", ",", "\n", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "4e6", "}", "]", "\n", "\n", "# Testing we can get the exact amount of future seconds available", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "future", "=", "helper", ".", "get_future_for_agent", "(", "'1'", ",", "'1'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "future", ",", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", "]", ")", ")", "\n", "\n", "", "def", "test_get_future_for_agent_in_agent_frame", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "1e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "2e6", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "3e6", "}", ",", "\n", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "4e6", "}", "]", "\n", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "future", "=", "helper", ".", "get_future_for_agent", "(", "'1'", ",", "'1'", ",", "3", ",", "True", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "future", ",", "np", ".", "array", "(", "[", "[", "-", "1", ",", "1", "]", ",", "[", "-", "2", ",", "2", "]", ",", "[", "-", "3", ",", "3", "]", "]", ")", ")", "\n", "\n", "", "def", "test_get_future_for_agent_less_amount", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "1e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "2.6e6", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "4e6", "}", ",", "\n", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "5.5e6", "}", "]", "\n", "\n", "# Testing we do not include data after the future seconds", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "future", "=", "helper", ".", "get_future_for_agent", "(", "'1'", ",", "'1'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "future", ",", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "2", ",", "2", "]", "]", ")", ")", "\n", "\n", "", "def", "test_get_future_for_agent_within_buffer", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "1e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "2.6e6", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "3.05e6", "}", ",", "\n", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "3.5e6", "}", "]", "\n", "\n", "# Testing we get data if it is after future seconds but within buffer", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertCoords.test_heading_pi": [[247, 295], ["nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.cos", "numpy.sin", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global"], ["helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "future", "=", "helper", ".", "get_future_for_agent", "(", "'1'", ",", "'1'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "future", ",", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", "]", ")", ")", "\n", "\n", "", "def", "test_get_future_for_agent_no_data_to_get", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "3.5e6", "}", "]", "\n", "\n", "# Testing we get nothing if the first sample annotation is past our threshold", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "future", "=", "helper", ".", "get_future_for_agent", "(", "'1'", ",", "'1'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "future", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n", "\n", "", "def", "test_get_future_for_last_returns_nothing", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'6'", ",", "'timestamp'", ":", "0", "}", "]", "\n", "\n", "# Testing we get nothing if we're at the last annotation", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "future", "=", "helper", ".", "get_future_for_agent", "(", "'1'", ",", "'6'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "future", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n", "\n", "", "def", "test_get_past_for_agent_exact_amount", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "-", "1e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "-", "2e6", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "-", "3e6", "}", ",", "\n", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "-", "4e6", "}", "]", "\n", "\n", "# Testing we can get the exact amount of past seconds available", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "past", "=", "helper", ".", "get_past_for_agent", "(", "'1'", ",", "'5'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "past", ",", "np", ".", "array", "(", "[", "[", "3", ",", "3", "]", ",", "[", "2", ",", "2", "]", ",", "[", "1", ",", "1", "]", "]", ")", ")", "\n", "\n", "", "def", "test_get_past_for_agent_in_frame", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "-", "1e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "-", "2e6", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "-", "3e6", "}", ",", "\n", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "-", "4e6", "}", "]", "\n", "\n", "# Testing we can get the exact amount of past seconds available", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "past", "=", "helper", ".", "get_past_for_agent", "(", "'1'", ",", "'5'", ",", "3", ",", "True", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_predict_helper.TestConvertCoords.test_heading_neg_pi_over_4": [[296, 344], ["nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "nuscenes.prediction.convert_global_coords_to_local", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.cos", "numpy.sin", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "nuscenes.prediction.convert_local_coords_to_global", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global"], ["np", ".", "testing", ".", "assert_allclose", "(", "past", ",", "np", ".", "array", "(", "[", "[", "1.", ",", "-", "1.", "]", ",", "[", "2.", ",", "-", "2.", "]", ",", "[", "3.", ",", "-", "3.", "]", "]", ")", ")", "\n", "\n", "", "def", "test_get_past_for_agent_less_amount", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "-", "1e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "-", "2.6e6", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "-", "4e6", "}", ",", "\n", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "-", "5.5e6", "}", "]", "\n", "\n", "# Testing we do not include data after the past seconds", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "past", "=", "helper", ".", "get_past_for_agent", "(", "'1'", ",", "'5'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "past", ",", "np", ".", "array", "(", "[", "[", "3", ",", "3", "]", ",", "[", "2", ",", "2", "]", "]", ")", ")", "\n", "\n", "", "def", "test_get_past_for_agent_within_buffer", "(", "self", ")", "->", "None", ":", "\n", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "-", "1e6", "}", ",", "\n", "{", "'token'", ":", "'3'", ",", "'timestamp'", ":", "-", "3.05e6", "}", ",", "\n", "{", "'token'", ":", "'2'", ",", "'timestamp'", ":", "-", "3.2e6", "}", "]", "\n", "\n", "# Testing we get data if it is after future seconds but within buffer", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "past", "=", "helper", ".", "get_past_for_agent", "(", "'1'", ",", "'5'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "past", ",", "np", ".", "array", "(", "[", "[", "3", ",", "3", "]", ",", "[", "2", ",", "2", "]", "]", ")", ")", "\n", "\n", "", "def", "test_get_past_for_agent_no_data_to_get", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'5'", ",", "'timestamp'", ":", "0", "}", ",", "\n", "{", "'token'", ":", "'4'", ",", "'timestamp'", ":", "-", "3.5e6", "}", "]", "\n", "\n", "# Testing we get nothing if the first sample annotation is past our threshold", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "past", "=", "helper", ".", "get_past_for_agent", "(", "'1'", ",", "'5'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "past", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n", "\n", "", "def", "test_get_past_for_last_returns_nothing", "(", "self", ")", "->", "None", ":", "\n", "        ", "mock_samples", "=", "[", "{", "'token'", ":", "'1'", ",", "'timestamp'", ":", "0", "}", "]", "\n", "\n", "# Testing we get nothing if we're at the last annotation", "\n", "nusc", "=", "MockNuScenes", "(", "self", ".", "mock_annotations", ",", "mock_samples", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "past", "=", "helper", ".", "get_past_for_agent", "(", "'1'", ",", "'1'", ",", "3", ",", "False", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "past", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n", "\n", "", "def", "test_get_future_for_sample", "(", "self", ")", "->", "None", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_lidarseg.TestNuScenesLidarseg.setUp": [[8, 11], ["nuscenes.NuScenes"], "methods", ["None"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "assert", "'NUSCENES'", "in", "os", ".", "environ", ",", "'Set NUSCENES env. variable to enable tests.'", "\n", "self", ".", "nusc", "=", "NuScenes", "(", "version", "=", "'v1.0-mini'", ",", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", ",", "verbose", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_lidarseg.TestNuScenesLidarseg.test_num_classes": [[12, 17], ["test_lidarseg.TestNuScenesLidarseg.assertEqual", "len"], "methods", ["None"], ["", "def", "test_num_classes", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Check that the correct number of classes (32 classes) are loaded.\n        \"\"\"", "\n", "self", ".", "assertEqual", "(", "len", "(", "self", ".", "nusc", ".", "lidarseg_idx2name_mapping", ")", ",", "32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_lidarseg.TestNuScenesLidarseg.test_num_colors": [[18, 25], ["len", "len", "test_lidarseg.TestNuScenesLidarseg.assertEqual"], "methods", ["None"], ["", "def", "test_num_colors", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Check that the number of colors in the colormap matches the number of classes.\n        \"\"\"", "\n", "num_classes", "=", "len", "(", "self", ".", "nusc", ".", "lidarseg_idx2name_mapping", ")", "\n", "num_colors", "=", "len", "(", "self", ".", "nusc", ".", "colormap", ")", "\n", "self", ".", "assertEqual", "(", "num_colors", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_lidarseg.TestNuScenesLidarseg.test_classes": [[26, 33], ["list", "test_lidarseg.TestNuScenesLidarseg.nusc.lidarseg_name2idx_mapping.items", "test_lidarseg.TestNuScenesLidarseg.nusc.colormap.keys", "test_lidarseg.TestNuScenesLidarseg.assertEqual"], "methods", ["None"], ["", "def", "test_classes", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Check that the class names match the ones in the colormap, and are in the same order.\n        \"\"\"", "\n", "classes_in_colormap", "=", "list", "(", "self", ".", "nusc", ".", "colormap", ".", "keys", "(", ")", ")", "\n", "for", "name", ",", "idx", "in", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "name", ",", "classes_in_colormap", "[", "idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tests.test_nuscenes.TestNuScenes.test_load": [[12, 23], ["nuscenes.NuScenes", "test_nuscenes.TestNuScenes.assertEqual", "os.path.join"], "methods", ["None"], ["    ", "def", "test_load", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Loads up NuScenes.\n        This is intended to simply run the NuScenes class to check for import errors, typos, etc.\n        \"\"\"", "\n", "\n", "assert", "'NUSCENES'", "in", "os", ".", "environ", ",", "'Set NUSCENES env. variable to enable tests.'", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "'v1.0-mini'", ",", "dataroot", "=", "os", ".", "environ", "[", "'NUSCENES'", "]", ",", "verbose", "=", "False", ")", "\n", "\n", "# Trivial assert statement", "\n", "self", ".", "assertEqual", "(", "nusc", ".", "table_root", ",", "os", ".", "path", ".", "join", "(", "os", ".", "environ", "[", "'NUSCENES'", "]", ",", "'v1.0-mini'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.export.export_release.export_release": [[11, 49], ["os.path.join", "os.path.join", "archives.items", "os.path.isdir", "os.makedirs", "open", "json.load", "os.path.join", "os.path.exists", "print", "export_release.pack_folder", "os.path.join", "print"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.export.export_release.pack_folder"], ["def", "export_release", "(", "dataroot", "=", "'/data/sets/nuimages'", ",", "version", ":", "str", "=", "'v1.0'", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    This script tars the image and metadata files for release on https://www.nuscenes.org/download.\n    :param dataroot: The nuImages folder.\n    :param version: The nuImages dataset version.\n    \"\"\"", "\n", "# Create export folder.", "\n", "export_dir", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "'export'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "export_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "export_dir", ")", "\n", "\n", "# Determine the images from the mini split.", "\n", "", "mini_src", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "version", "+", "'-mini'", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "mini_src", ",", "'sample_data.json'", ")", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "sample_data", "=", "json", ".", "load", "(", "f", ")", "\n", "", "file_names", "=", "[", "sd", "[", "'filename'", "]", "for", "sd", "in", "sample_data", "]", "\n", "\n", "# Hard-code the mapping from archive names to their relative folder paths.", "\n", "archives", "=", "{", "\n", "'all-metadata'", ":", "[", "version", "+", "'-train'", ",", "version", "+", "'-val'", ",", "version", "+", "'-test'", ",", "version", "+", "'-mini'", "]", ",", "\n", "'all-samples'", ":", "[", "'samples'", "]", ",", "\n", "'all-sweeps-cam-back'", ":", "[", "'sweeps/CAM_BACK'", "]", ",", "\n", "'all-sweeps-cam-back-left'", ":", "[", "'sweeps/CAM_BACK_LEFT'", "]", ",", "\n", "'all-sweeps-cam-back-right'", ":", "[", "'sweeps/CAM_BACK_RIGHT'", "]", ",", "\n", "'all-sweeps-cam-front'", ":", "[", "'sweeps/CAM_FRONT'", "]", ",", "\n", "'all-sweeps-cam-front-left'", ":", "[", "'sweeps/CAM_FRONT_LEFT'", "]", ",", "\n", "'all-sweeps-cam-front-right'", ":", "[", "'sweeps/CAM_FRONT_RIGHT'", "]", ",", "\n", "'mini'", ":", "[", "version", "+", "'-mini'", "]", "+", "file_names", "\n", "}", "\n", "\n", "# Pack each folder.", "\n", "for", "key", ",", "folder_list", "in", "archives", ".", "items", "(", ")", ":", "\n", "        ", "out_path", "=", "os", ".", "path", ".", "join", "(", "export_dir", ",", "'nuimages-%s-%s.tgz'", "%", "(", "version", ",", "key", ")", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "out_path", ")", ":", "\n", "            ", "print", "(", "'Warning: Skipping export for file as it already exists: %s'", "%", "out_path", ")", "\n", "continue", "\n", "", "print", "(", "'Compressing archive %s...'", "%", "out_path", ")", "\n", "pack_folder", "(", "out_path", ",", "dataroot", ",", "folder_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.export.export_release.pack_folder": [[51, 63], ["tarfile.open", "tarfile.open.close", "os.path.join", "tarfile.open.add"], "function", ["None"], ["", "", "def", "pack_folder", "(", "out_path", ":", "str", ",", "dataroot", ":", "str", ",", "folder_list", ":", "List", "[", "str", "]", ",", "tar_format", ":", "str", "=", "'w:gz'", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    :param out_path: The output path where we write the tar file.\n    :param dataroot: The nuImages folder.\n    :param folder_list: List of files or folders to include in the archive.\n    :param tar_format: The compression format to use. See tarfile package for more options.\n    \"\"\"", "\n", "tar", "=", "tarfile", ".", "open", "(", "out_path", ",", "tar_format", ")", "\n", "for", "name", "in", "folder_list", ":", "\n", "        ", "folder_path", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "name", ")", "\n", "tar", ".", "add", "(", "folder_path", ",", "arcname", "=", "name", ")", "\n", "", "tar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__init__": [[44, 128], ["os.exists", "os.exists", "time.time", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "utils.color_map.get_colormap", "enumerate", "os.exists", "os.exists", "nuscenes.NuScenes.__make_reverse_index__", "nuscenes.NuScenesExplorer", "print", "len", "dict", "dict", "nuscenes.NuScenes.load_lidarseg_cat_name_mapping", "setattr", "os.listdir", "os.listdir", "os.listdir", "os.listdir", "len", "len", "nuscenes.NuScenes.table_names.append", "dict", "os.join", "os.join", "nuscenes.NuScenes.__load_table__", "utils.map_mask.MapMask", "print", "os.exists", "os.exists", "print", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "nuscenes.NuScenes.__load_table__", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "getattr", "os.join", "os.join", "print", "os.join", "os.join", "sorted", "len", "time.time", "name.endswith", "name.endswith", "getattr"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.utils.color_map.get_colormap", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__make_reverse_index__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.load_lidarseg_cat_name_mapping", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__"], ["def", "__init__", "(", "self", ",", "\n", "version", ":", "str", "=", "'v1.0-mini'", ",", "\n", "dataroot", ":", "str", "=", "'/opt/data/common/datasets/nuScenes'", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "map_resolution", ":", "float", "=", "0.1", ")", ":", "\n", "        ", "\"\"\"\n        Loads database and creates reverse indexes and shortcuts.\n        :param version: Version to load (e.g. \"v1.0\", ...).\n        :param dataroot: Path to the tables and data.\n        :param verbose: Whether to print status messages during load.\n        :param map_resolution: Resolution of maps (meters).\n        \"\"\"", "\n", "self", ".", "version", "=", "version", "\n", "self", ".", "dataroot", "=", "dataroot", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "table_names", "=", "[", "'category'", ",", "'attribute'", ",", "'visibility'", ",", "'instance'", ",", "'sensor'", ",", "'calibrated_sensor'", ",", "\n", "'ego_pose'", ",", "'log'", ",", "'scene'", ",", "'sample'", ",", "'sample_data'", ",", "'sample_annotation'", ",", "'map'", "]", "\n", "\n", "assert", "osp", ".", "exists", "(", "self", ".", "table_root", ")", ",", "'Database version not found: {}'", ".", "format", "(", "self", ".", "table_root", ")", "\n", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"======\\nLoading NuScenes tables for version {}...\"", ".", "format", "(", "self", ".", "version", ")", ")", "\n", "\n", "# Explicitly assign tables to help the IDE determine valid class members.", "\n", "", "self", ".", "category", "=", "self", ".", "__load_table__", "(", "'category'", ")", "\n", "self", ".", "attribute", "=", "self", ".", "__load_table__", "(", "'attribute'", ")", "\n", "self", ".", "visibility", "=", "self", ".", "__load_table__", "(", "'visibility'", ")", "\n", "self", ".", "instance", "=", "self", ".", "__load_table__", "(", "'instance'", ")", "\n", "self", ".", "sensor", "=", "self", ".", "__load_table__", "(", "'sensor'", ")", "\n", "self", ".", "calibrated_sensor", "=", "self", ".", "__load_table__", "(", "'calibrated_sensor'", ")", "\n", "self", ".", "ego_pose", "=", "self", ".", "__load_table__", "(", "'ego_pose'", ")", "\n", "self", ".", "log", "=", "self", ".", "__load_table__", "(", "'log'", ")", "\n", "self", ".", "scene", "=", "self", ".", "__load_table__", "(", "'scene'", ")", "\n", "self", ".", "sample", "=", "self", ".", "__load_table__", "(", "'sample'", ")", "\n", "self", ".", "sample_data", "=", "self", ".", "__load_table__", "(", "'sample_data'", ")", "\n", "self", ".", "sample_annotation", "=", "self", ".", "__load_table__", "(", "'sample_annotation'", ")", "\n", "self", ".", "map", "=", "self", ".", "__load_table__", "(", "'map'", ")", "\n", "\n", "# Initialize the colormap which maps from class names to RGB values.", "\n", "self", ".", "colormap", "=", "get_colormap", "(", ")", "\n", "\n", "lidar_tasks", "=", "[", "t", "for", "t", "in", "[", "'lidarseg'", ",", "'panoptic'", "]", "if", "osp", ".", "exists", "(", "osp", ".", "join", "(", "self", ".", "table_root", ",", "t", "+", "'.json'", ")", ")", "]", "\n", "if", "len", "(", "lidar_tasks", ")", ">", "0", ":", "\n", "            ", "self", ".", "lidarseg_idx2name_mapping", "=", "dict", "(", ")", "\n", "self", ".", "lidarseg_name2idx_mapping", "=", "dict", "(", ")", "\n", "self", ".", "load_lidarseg_cat_name_mapping", "(", ")", "\n", "", "for", "i", ",", "lidar_task", "in", "enumerate", "(", "lidar_tasks", ")", ":", "\n", "            ", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f'Loading nuScenes-{lidar_task}...'", ")", "\n", "", "if", "lidar_task", "==", "'lidarseg'", ":", "\n", "                ", "self", ".", "lidarseg", "=", "self", ".", "__load_table__", "(", "lidar_task", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "panoptic", "=", "self", ".", "__load_table__", "(", "lidar_task", ")", "\n", "\n", "", "setattr", "(", "self", ",", "lidar_task", ",", "self", ".", "__load_table__", "(", "lidar_task", ")", ")", "\n", "label_files", "=", "os", ".", "listdir", "(", "os", ".", "path", ".", "join", "(", "self", ".", "dataroot", ",", "lidar_task", ",", "self", ".", "version", ")", ")", "\n", "num_label_files", "=", "len", "(", "[", "name", "for", "name", "in", "label_files", "if", "(", "name", ".", "endswith", "(", "'.bin'", ")", "or", "name", ".", "endswith", "(", "'.npz'", ")", ")", "]", ")", "\n", "num_lidarseg_recs", "=", "len", "(", "getattr", "(", "self", ",", "lidar_task", ")", ")", "\n", "assert", "num_lidarseg_recs", "==", "num_label_files", ",", "f'Error: there are {num_label_files} label files but {num_lidarseg_recs} {lidar_task} records.'", "\n", "self", ".", "table_names", ".", "append", "(", "lidar_task", ")", "\n", "# Sort the colormap to ensure that it is ordered according to the indices in self.category.", "\n", "self", ".", "colormap", "=", "dict", "(", "{", "c", "[", "'name'", "]", ":", "self", ".", "colormap", "[", "c", "[", "'name'", "]", "]", "\n", "for", "c", "in", "sorted", "(", "self", ".", "category", ",", "key", "=", "lambda", "k", ":", "k", "[", "'index'", "]", ")", "}", ")", "\n", "\n", "# If available, also load the image_annotations table created by export_2d_annotations_as_json().", "\n", "", "if", "osp", ".", "exists", "(", "osp", ".", "join", "(", "self", ".", "table_root", ",", "'image_annotations.json'", ")", ")", ":", "\n", "            ", "self", ".", "image_annotations", "=", "self", ".", "__load_table__", "(", "'image_annotations'", ")", "\n", "\n", "# Initialize map mask for each map record.", "\n", "", "for", "map_record", "in", "self", ".", "map", ":", "\n", "            ", "map_record", "[", "'mask'", "]", "=", "MapMask", "(", "osp", ".", "join", "(", "self", ".", "dataroot", ",", "map_record", "[", "'filename'", "]", ")", ",", "resolution", "=", "map_resolution", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "            ", "for", "table", "in", "self", ".", "table_names", ":", "\n", "                ", "print", "(", "\"{} {},\"", ".", "format", "(", "len", "(", "getattr", "(", "self", ",", "table", ")", ")", ",", "table", ")", ")", "\n", "", "print", "(", "\"Done loading in {:.3f} seconds.\\n======\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ")", "\n", "\n", "# Make reverse indexes for common lookups.", "\n", "", "self", ".", "__make_reverse_index__", "(", "verbose", ")", "\n", "\n", "# Initialize NuScenesExplorer class.", "\n", "self", ".", "explorer", "=", "NuScenesExplorer", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.table_root": [[129, 133], ["os.join", "os.join"], "methods", ["None"], ["", "@", "property", "\n", "def", "table_root", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\" Returns the folder where the tables are stored for the relevant version. \"\"\"", "\n", "return", "osp", ".", "join", "(", "self", ".", "dataroot", ",", "self", ".", "version", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__load_table__": [[134, 139], ["open", "json.load", "os.join", "os.join"], "methods", ["None"], ["", "def", "__load_table__", "(", "self", ",", "table_name", ")", "->", "dict", ":", "\n", "        ", "\"\"\" Loads a table. \"\"\"", "\n", "with", "open", "(", "osp", ".", "join", "(", "self", ".", "table_root", ",", "'{}.json'", ".", "format", "(", "table_name", ")", ")", ")", "as", "f", ":", "\n", "            ", "table", "=", "json", ".", "load", "(", "f", ")", "\n", "", "return", "table", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.load_lidarseg_cat_name_mapping": [[140, 149], ["lidarseg_category.keys"], "methods", ["None"], ["", "def", "load_lidarseg_cat_name_mapping", "(", "self", ")", ":", "\n", "        ", "\"\"\" Create mapping from class index to class name, and vice versa, for easy lookup later on \"\"\"", "\n", "for", "lidarseg_category", "in", "self", ".", "category", ":", "\n", "# Check that the category records contain both the keys 'name' and 'index'.", "\n", "            ", "assert", "'index'", "in", "lidarseg_category", ".", "keys", "(", ")", ",", "'Please use the category.json that comes with nuScenes-lidarseg, and not the old category.json.'", "\n", "\n", "self", ".", "lidarseg_idx2name_mapping", "[", "lidarseg_category", "[", "'index'", "]", "]", "=", "lidarseg_category", "[", "'name'", "]", "\n", "self", ".", "lidarseg_name2idx_mapping", "[", "lidarseg_category", "[", "'name'", "]", "]", "=", "lidarseg_category", "[", "'index'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.__make_reverse_index__": [[150, 213], ["time.time", "dict", "dict", "print", "dict", "enumerate", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "sample_record[].append", "nuscenes.NuScenes.map[].keys", "Exception", "print", "getattr", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "time.time"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "__make_reverse_index__", "(", "self", ",", "verbose", ":", "bool", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        De-normalizes database to create reverse indices for common cases.\n        :param verbose: Whether to print outputs.\n        \"\"\"", "\n", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Reverse indexing ...\"", ")", "\n", "\n", "# Store the mapping from token to table index for each table.", "\n", "", "self", ".", "_token2ind", "=", "dict", "(", ")", "\n", "for", "table", "in", "self", ".", "table_names", ":", "\n", "            ", "self", ".", "_token2ind", "[", "table", "]", "=", "dict", "(", ")", "\n", "\n", "for", "ind", ",", "member", "in", "enumerate", "(", "getattr", "(", "self", ",", "table", ")", ")", ":", "\n", "                ", "self", ".", "_token2ind", "[", "table", "]", "[", "member", "[", "'token'", "]", "]", "=", "ind", "\n", "\n", "# Decorate (adds short-cut) sample_annotation table with for category name.", "\n", "", "", "for", "record", "in", "self", ".", "sample_annotation", ":", "\n", "            ", "inst", "=", "self", ".", "get", "(", "'instance'", ",", "record", "[", "'instance_token'", "]", ")", "\n", "record", "[", "'category_name'", "]", "=", "self", ".", "get", "(", "'category'", ",", "inst", "[", "'category_token'", "]", ")", "[", "'name'", "]", "\n", "\n", "# Decorate (adds short-cut) sample_data with sensor information.", "\n", "", "for", "record", "in", "self", ".", "sample_data", ":", "\n", "            ", "cs_record", "=", "self", ".", "get", "(", "'calibrated_sensor'", ",", "record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "sensor_record", "=", "self", ".", "get", "(", "'sensor'", ",", "cs_record", "[", "'sensor_token'", "]", ")", "\n", "record", "[", "'sensor_modality'", "]", "=", "sensor_record", "[", "'modality'", "]", "\n", "record", "[", "'channel'", "]", "=", "sensor_record", "[", "'channel'", "]", "\n", "\n", "# Reverse-index samples with sample_data and annotations.", "\n", "", "for", "record", "in", "self", ".", "sample", ":", "\n", "            ", "record", "[", "'data'", "]", "=", "{", "}", "\n", "record", "[", "'anns'", "]", "=", "[", "]", "\n", "# record['next'] = collections.OrderedDict()", "\n", "\n", "", "for", "record", "in", "self", ".", "sample_data", ":", "\n", "            ", "if", "record", "[", "'is_key_frame'", "]", ":", "\n", "                ", "sample_record", "=", "self", ".", "get", "(", "'sample'", ",", "record", "[", "'sample_token'", "]", ")", "\n", "sample_record", "[", "'data'", "]", "[", "record", "[", "'channel'", "]", "]", "=", "record", "[", "'token'", "]", "\n", "# else:", "\n", "#     sample_record = self.get('sample', record['sample_token'])", "\n", "#", "\n", "#     if record['channel']=='LIDAR_TOP':", "\n", "#         sample_record['next'][record['timestamp']] = record['token']", "\n", "\n", "\n", "", "", "for", "ann_record", "in", "self", ".", "sample_annotation", ":", "\n", "            ", "sample_record", "=", "self", ".", "get", "(", "'sample'", ",", "ann_record", "[", "'sample_token'", "]", ")", "\n", "sample_record", "[", "'anns'", "]", ".", "append", "(", "ann_record", "[", "'token'", "]", ")", "\n", "\n", "# Add reverse indices from log records to map records.", "\n", "", "if", "'log_tokens'", "not", "in", "self", ".", "map", "[", "0", "]", ".", "keys", "(", ")", ":", "\n", "            ", "raise", "Exception", "(", "'Error: log_tokens not in map table. This code is not compatible with the teaser dataset.'", ")", "\n", "", "log_to_map", "=", "dict", "(", ")", "\n", "for", "map_record", "in", "self", ".", "map", ":", "\n", "            ", "for", "log_token", "in", "map_record", "[", "'log_tokens'", "]", ":", "\n", "                ", "log_to_map", "[", "log_token", "]", "=", "map_record", "[", "'token'", "]", "\n", "", "", "for", "log_record", "in", "self", ".", "log", ":", "\n", "            ", "log_record", "[", "'map_token'", "]", "=", "log_to_map", "[", "log_record", "[", "'token'", "]", "]", "\n", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Done reverse indexing in {:.1f} seconds.\\n======\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get": [[214, 224], ["getattr", "nuscenes.NuScenes.getind"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.getind"], ["", "", "def", "get", "(", "self", ",", "table_name", ":", "str", ",", "token", ":", "str", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Returns a record from table in constant runtime.\n        :param table_name: Table name.\n        :param token: Token of the record.\n        :return: Table record. See README.md for record details for each table.\n        \"\"\"", "\n", "assert", "table_name", "in", "self", ".", "table_names", ",", "\"Table {} not found\"", ".", "format", "(", "table_name", ")", "\n", "\n", "return", "getattr", "(", "self", ",", "table_name", ")", "[", "self", ".", "getind", "(", "table_name", ",", "token", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.getind": [[225, 233], ["None"], "methods", ["None"], ["", "def", "getind", "(", "self", ",", "table_name", ":", "str", ",", "token", ":", "str", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        This returns the index of the record in a table in constant runtime.\n        :param table_name: Table name.\n        :param token: Token of the record.\n        :return: The index of the record in table, table is an array.\n        \"\"\"", "\n", "return", "self", ".", "_token2ind", "[", "table_name", "]", "[", "token", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.field2token": [[234, 248], ["getattr", "matches.append"], "methods", ["None"], ["", "def", "field2token", "(", "self", ",", "table_name", ":", "str", ",", "field", ":", "str", ",", "query", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"\n        This function queries all records for a certain field value, and returns the tokens for the matching records.\n        Warning: this runs in linear time.\n        :param table_name: Table name.\n        :param field: Field name. See README.md for details.\n        :param query: Query to match against. Needs to type match the content of the query field.\n        :return: List of tokens for the matching records.\n        \"\"\"", "\n", "matches", "=", "[", "]", "\n", "for", "member", "in", "getattr", "(", "self", ",", "table_name", ")", ":", "\n", "            ", "if", "member", "[", "field", "]", "==", "query", ":", "\n", "                ", "matches", ".", "append", "(", "member", "[", "'token'", "]", ")", "\n", "", "", "return", "matches", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data_path": [[249, 254], ["nuscenes.NuScenes.get", "os.join", "os.join"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_sample_data_path", "(", "self", ",", "sample_data_token", ":", "str", ")", "->", "str", ":", "\n", "        ", "\"\"\" Returns the path to a sample_data. \"\"\"", "\n", "\n", "sd_record", "=", "self", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "return", "osp", ".", "join", "(", "self", ".", "dataroot", ",", "sd_record", "[", "'filename'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data": [[255, 316], ["nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get_sample_data_path", "numpy.array", "list", "nuscenes.NuScenes.get_boxes", "box_list.append", "map", "box.translate", "box.rotate", "box.translate", "box.rotate", "box.translate", "box.rotate", "utils.geometry_utils.box_in_image", "pyquaternion.Quaternion", "numpy.array", "pyquaternion.Quaternion", "numpy.array", "pyquaternion.Quaternion", "numpy.array", "pyquaternion.Quaternion", "numpy.cos", "numpy.sin"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data_path", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.box_in_image"], ["", "def", "get_sample_data", "(", "self", ",", "sample_data_token", ":", "str", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "\n", "selected_anntokens", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "use_flat_vehicle_coordinates", ":", "bool", "=", "False", ")", "->", "Tuple", "[", "str", ",", "List", "[", "Box", "]", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Returns the data path as well as all annotations related to that sample_data.\n        Note that the boxes are transformed into the current sensor's coordinate frame.\n        :param sample_data_token: Sample_data token.\n        :param box_vis_level: If sample_data is an image, this sets required visibility for boxes.\n        :param selected_anntokens: If provided only return the selected annotation.\n        :param use_flat_vehicle_coordinates: Instead of the current sensor's coordinate frame, use ego frame which is\n                                             aligned to z-plane in the world.\n        :return: (data_path, boxes, camera_intrinsic <np.array: 3, 3>)\n        \"\"\"", "\n", "\n", "# Retrieve sensor & pose records", "\n", "sd_record", "=", "self", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "cs_record", "=", "self", ".", "get", "(", "'calibrated_sensor'", ",", "sd_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "sensor_record", "=", "self", ".", "get", "(", "'sensor'", ",", "cs_record", "[", "'sensor_token'", "]", ")", "\n", "pose_record", "=", "self", ".", "get", "(", "'ego_pose'", ",", "sd_record", "[", "'ego_pose_token'", "]", ")", "\n", "\n", "data_path", "=", "self", ".", "get_sample_data_path", "(", "sample_data_token", ")", "\n", "\n", "if", "sensor_record", "[", "'modality'", "]", "==", "'camera'", ":", "\n", "            ", "cam_intrinsic", "=", "np", ".", "array", "(", "cs_record", "[", "'camera_intrinsic'", "]", ")", "\n", "imsize", "=", "(", "sd_record", "[", "'width'", "]", ",", "sd_record", "[", "'height'", "]", ")", "\n", "", "else", ":", "\n", "            ", "cam_intrinsic", "=", "None", "\n", "imsize", "=", "None", "\n", "\n", "# Retrieve all sample annotations and map to sensor coordinate system.", "\n", "", "if", "selected_anntokens", "is", "not", "None", ":", "\n", "            ", "boxes", "=", "list", "(", "map", "(", "self", ".", "get_box", ",", "selected_anntokens", ")", ")", "\n", "", "else", ":", "\n", "            ", "boxes", "=", "self", ".", "get_boxes", "(", "sample_data_token", ")", "\n", "\n", "# Make list of Box objects including coord system transforms.", "\n", "", "box_list", "=", "[", "]", "\n", "for", "box", "in", "boxes", ":", "\n", "            ", "if", "use_flat_vehicle_coordinates", ":", "\n", "# Move box to ego vehicle coord system parallel to world z plane.", "\n", "                ", "yaw", "=", "Quaternion", "(", "pose_record", "[", "'rotation'", "]", ")", ".", "yaw_pitch_roll", "[", "0", "]", "\n", "box", ".", "translate", "(", "-", "np", ".", "array", "(", "pose_record", "[", "'translation'", "]", ")", ")", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "scalar", "=", "np", ".", "cos", "(", "yaw", "/", "2", ")", ",", "vector", "=", "[", "0", ",", "0", ",", "np", ".", "sin", "(", "yaw", "/", "2", ")", "]", ")", ".", "inverse", ")", "\n", "", "else", ":", "\n", "# Move box to ego vehicle coord system.", "\n", "                ", "box", ".", "translate", "(", "-", "np", ".", "array", "(", "pose_record", "[", "'translation'", "]", ")", ")", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "pose_record", "[", "'rotation'", "]", ")", ".", "inverse", ")", "\n", "\n", "#  Move box to sensor coord system.", "\n", "box", ".", "translate", "(", "-", "np", ".", "array", "(", "cs_record", "[", "'translation'", "]", ")", ")", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "cs_record", "[", "'rotation'", "]", ")", ".", "inverse", ")", "\n", "\n", "", "if", "sensor_record", "[", "'modality'", "]", "==", "'camera'", "and", "not", "box_in_image", "(", "box", ",", "cam_intrinsic", ",", "imsize", ",", "vis_level", "=", "box_vis_level", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "box_list", ".", "append", "(", "box", ")", "\n", "\n", "", "return", "data_path", ",", "box_list", ",", "cam_intrinsic", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data_with_id": [[317, 378], ["nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get_sample_data_path", "numpy.array", "list", "nuscenes.NuScenes.get_boxes", "box_list.append", "map", "box.translate", "box.rotate", "box.translate", "box.rotate", "box.translate", "box.rotate", "utils.geometry_utils.box_in_image", "pyquaternion.Quaternion", "numpy.array", "pyquaternion.Quaternion", "numpy.array", "pyquaternion.Quaternion", "numpy.array", "pyquaternion.Quaternion", "numpy.cos", "numpy.sin"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data_path", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.box_in_image"], ["", "def", "get_sample_data_with_id", "(", "self", ",", "sample_data_token", ":", "str", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "\n", "selected_anntokens", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "use_flat_vehicle_coordinates", ":", "bool", "=", "False", ")", "->", "Tuple", "[", "str", ",", "List", "[", "Box", "]", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Returns the data path as well as all annotations related to that sample_data.\n        Note that the boxes are transformed into the current sensor's coordinate frame.\n        :param sample_data_token: Sample_data token.\n        :param box_vis_level: If sample_data is an image, this sets required visibility for boxes.\n        :param selected_anntokens: If provided only return the selected annotation.\n        :param use_flat_vehicle_coordinates: Instead of the current sensor's coordinate frame, use ego frame which is\n                                             aligned to z-plane in the world.\n        :return: (data_path, boxes, camera_intrinsic <np.array: 3, 3>)\n        \"\"\"", "\n", "\n", "# Retrieve sensor & pose records", "\n", "sd_record", "=", "self", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "cs_record", "=", "self", ".", "get", "(", "'calibrated_sensor'", ",", "sd_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "sensor_record", "=", "self", ".", "get", "(", "'sensor'", ",", "cs_record", "[", "'sensor_token'", "]", ")", "\n", "pose_record", "=", "self", ".", "get", "(", "'ego_pose'", ",", "sd_record", "[", "'ego_pose_token'", "]", ")", "\n", "\n", "data_path", "=", "self", ".", "get_sample_data_path", "(", "sample_data_token", ")", "\n", "\n", "if", "sensor_record", "[", "'modality'", "]", "==", "'camera'", ":", "\n", "            ", "cam_intrinsic", "=", "np", ".", "array", "(", "cs_record", "[", "'camera_intrinsic'", "]", ")", "\n", "imsize", "=", "(", "sd_record", "[", "'width'", "]", ",", "sd_record", "[", "'height'", "]", ")", "\n", "", "else", ":", "\n", "            ", "cam_intrinsic", "=", "None", "\n", "imsize", "=", "None", "\n", "\n", "# Retrieve all sample annotations and map to sensor coordinate system.", "\n", "", "if", "selected_anntokens", "is", "not", "None", ":", "\n", "            ", "boxes", "=", "list", "(", "map", "(", "self", ".", "get_box", ",", "selected_anntokens", ")", ")", "\n", "", "else", ":", "\n", "            ", "boxes", "=", "self", ".", "get_boxes", "(", "sample_data_token", ")", "\n", "\n", "# Make list of Box objects including coord system transforms.", "\n", "", "box_list", "=", "[", "]", "\n", "for", "box", "in", "boxes", ":", "\n", "            ", "if", "use_flat_vehicle_coordinates", ":", "\n", "# Move box to ego vehicle coord system parallel to world z plane.", "\n", "                ", "yaw", "=", "Quaternion", "(", "pose_record", "[", "'rotation'", "]", ")", ".", "yaw_pitch_roll", "[", "0", "]", "\n", "box", ".", "translate", "(", "-", "np", ".", "array", "(", "pose_record", "[", "'translation'", "]", ")", ")", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "scalar", "=", "np", ".", "cos", "(", "yaw", "/", "2", ")", ",", "vector", "=", "[", "0", ",", "0", ",", "np", ".", "sin", "(", "yaw", "/", "2", ")", "]", ")", ".", "inverse", ")", "\n", "", "else", ":", "\n", "# Move box to ego vehicle coord system.", "\n", "                ", "box", ".", "translate", "(", "-", "np", ".", "array", "(", "pose_record", "[", "'translation'", "]", ")", ")", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "pose_record", "[", "'rotation'", "]", ")", ".", "inverse", ")", "\n", "\n", "#  Move box to sensor coord system.", "\n", "box", ".", "translate", "(", "-", "np", ".", "array", "(", "cs_record", "[", "'translation'", "]", ")", ")", "\n", "box", ".", "rotate", "(", "Quaternion", "(", "cs_record", "[", "'rotation'", "]", ")", ".", "inverse", ")", "\n", "\n", "", "if", "sensor_record", "[", "'modality'", "]", "==", "'camera'", "and", "not", "box_in_image", "(", "box", ",", "cam_intrinsic", ",", "imsize", ",", "vis_level", "=", "box_vis_level", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "box_list", ".", "append", "(", "box", ")", "\n", "\n", "", "return", "data_path", ",", "box_list", ",", "cam_intrinsic", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_box": [[379, 387], ["nuscenes.NuScenes.get", "utils.data_classes.Box", "pyquaternion.Quaternion"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_box", "(", "self", ",", "sample_annotation_token", ":", "str", ")", "->", "Box", ":", "\n", "        ", "\"\"\"\n        Instantiates a Box class from a sample annotation record.\n        :param sample_annotation_token: Unique sample_annotation identifier.\n        \"\"\"", "\n", "record", "=", "self", ".", "get", "(", "'sample_annotation'", ",", "sample_annotation_token", ")", "\n", "return", "Box", "(", "record", "[", "'translation'", "]", ",", "record", "[", "'size'", "]", ",", "Quaternion", "(", "record", "[", "'rotation'", "]", ")", ",", "\n", "name", "=", "record", "[", "'category_name'", "]", ",", "token", "=", "record", "[", "'token'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_boxes": [[388, 446], ["nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "list", "nuscenes.NuScenes.get", "max", "map", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "min", "list.append", "pyquaternion.Quaternion.slerp", "utils.data_classes.Box", "numpy.interp", "zip", "pyquaternion.Quaternion", "pyquaternion.Quaternion"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_boxes", "(", "self", ",", "sample_data_token", ":", "str", ")", "->", "List", "[", "Box", "]", ":", "\n", "        ", "\"\"\"\n        Instantiates Boxes for all annotation for a particular sample_data record. If the sample_data is a\n        keyframe, this returns the annotations for that sample. But if the sample_data is an intermediate\n        sample_data, a linear interpolation is applied to estimate the location of the boxes at the time the\n        sample_data was captured.\n        :param sample_data_token: Unique sample_data identifier.\n        \"\"\"", "\n", "\n", "# Retrieve sensor & pose records", "\n", "sd_record", "=", "self", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "curr_sample_record", "=", "self", ".", "get", "(", "'sample'", ",", "sd_record", "[", "'sample_token'", "]", ")", "\n", "\n", "if", "curr_sample_record", "[", "'prev'", "]", "==", "\"\"", "or", "sd_record", "[", "'is_key_frame'", "]", ":", "\n", "# If no previous annotations available, or if sample_data is keyframe just return the current ones.", "\n", "            ", "boxes", "=", "list", "(", "map", "(", "self", ".", "get_box", ",", "curr_sample_record", "[", "'anns'", "]", ")", ")", "\n", "\n", "", "else", ":", "\n", "            ", "prev_sample_record", "=", "self", ".", "get", "(", "'sample'", ",", "curr_sample_record", "[", "'prev'", "]", ")", "\n", "\n", "curr_ann_recs", "=", "[", "self", ".", "get", "(", "'sample_annotation'", ",", "token", ")", "for", "token", "in", "curr_sample_record", "[", "'anns'", "]", "]", "\n", "prev_ann_recs", "=", "[", "self", ".", "get", "(", "'sample_annotation'", ",", "token", ")", "for", "token", "in", "prev_sample_record", "[", "'anns'", "]", "]", "\n", "\n", "# Maps instance tokens to prev_ann records", "\n", "prev_inst_map", "=", "{", "entry", "[", "'instance_token'", "]", ":", "entry", "for", "entry", "in", "prev_ann_recs", "}", "\n", "\n", "t0", "=", "prev_sample_record", "[", "'timestamp'", "]", "\n", "t1", "=", "curr_sample_record", "[", "'timestamp'", "]", "\n", "t", "=", "sd_record", "[", "'timestamp'", "]", "\n", "\n", "# There are rare situations where the timestamps in the DB are off so ensure that t0 < t < t1.", "\n", "t", "=", "max", "(", "t0", ",", "min", "(", "t1", ",", "t", ")", ")", "\n", "\n", "boxes", "=", "[", "]", "\n", "for", "curr_ann_rec", "in", "curr_ann_recs", ":", "\n", "\n", "                ", "if", "curr_ann_rec", "[", "'instance_token'", "]", "in", "prev_inst_map", ":", "\n", "# If the annotated instance existed in the previous frame, interpolate center & orientation.", "\n", "                    ", "prev_ann_rec", "=", "prev_inst_map", "[", "curr_ann_rec", "[", "'instance_token'", "]", "]", "\n", "\n", "# Interpolate center.", "\n", "center", "=", "[", "np", ".", "interp", "(", "t", ",", "[", "t0", ",", "t1", "]", ",", "[", "c0", ",", "c1", "]", ")", "for", "c0", ",", "c1", "in", "zip", "(", "prev_ann_rec", "[", "'translation'", "]", ",", "\n", "curr_ann_rec", "[", "'translation'", "]", ")", "]", "\n", "\n", "# Interpolate orientation.", "\n", "rotation", "=", "Quaternion", ".", "slerp", "(", "q0", "=", "Quaternion", "(", "prev_ann_rec", "[", "'rotation'", "]", ")", ",", "\n", "q1", "=", "Quaternion", "(", "curr_ann_rec", "[", "'rotation'", "]", ")", ",", "\n", "amount", "=", "(", "t", "-", "t0", ")", "/", "(", "t1", "-", "t0", ")", ")", "\n", "\n", "box", "=", "Box", "(", "center", ",", "curr_ann_rec", "[", "'size'", "]", ",", "rotation", ",", "name", "=", "curr_ann_rec", "[", "'category_name'", "]", ",", "\n", "token", "=", "curr_ann_rec", "[", "'token'", "]", ")", "\n", "", "else", ":", "\n", "# If not, simply grab the current annotation.", "\n", "                    ", "continue", "\n", "# box = self.get_box(curr_ann_rec['token'])", "\n", "\n", "", "boxes", ".", "append", "(", "box", ")", "\n", "", "", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.box_velocity": [[447, 493], ["nuscenes.NuScenes.get", "numpy.array", "numpy.array", "numpy.array", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "numpy.array", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "box_velocity", "(", "self", ",", "sample_annotation_token", ":", "str", ",", "max_time_diff", ":", "float", "=", "1.5", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Estimate the velocity for an annotation.\n        If possible, we compute the centered difference between the previous and next frame.\n        Otherwise we use the difference between the current and previous/next frame.\n        If the velocity cannot be estimated, values are set to np.nan.\n        :param sample_annotation_token: Unique sample_annotation identifier.\n        :param max_time_diff: Max allowed time diff between consecutive samples that are used to estimate velocities.\n        :return: <np.float: 3>. Velocity in x/y/z direction in m/s.\n        \"\"\"", "\n", "\n", "current", "=", "self", ".", "get", "(", "'sample_annotation'", ",", "sample_annotation_token", ")", "\n", "has_prev", "=", "current", "[", "'prev'", "]", "!=", "''", "\n", "has_next", "=", "current", "[", "'next'", "]", "!=", "''", "\n", "\n", "# Cannot estimate velocity for a single annotation.", "\n", "if", "not", "has_prev", "and", "not", "has_next", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "np", ".", "nan", ",", "np", ".", "nan", ",", "np", ".", "nan", "]", ")", "\n", "\n", "", "if", "has_prev", ":", "\n", "            ", "first", "=", "self", ".", "get", "(", "'sample_annotation'", ",", "current", "[", "'prev'", "]", ")", "\n", "", "else", ":", "\n", "            ", "first", "=", "current", "\n", "\n", "", "if", "has_next", ":", "\n", "            ", "last", "=", "self", ".", "get", "(", "'sample_annotation'", ",", "current", "[", "'next'", "]", ")", "\n", "", "else", ":", "\n", "            ", "last", "=", "current", "\n", "\n", "", "pos_last", "=", "np", ".", "array", "(", "last", "[", "'translation'", "]", ")", "\n", "pos_first", "=", "np", ".", "array", "(", "first", "[", "'translation'", "]", ")", "\n", "pos_diff", "=", "pos_last", "-", "pos_first", "\n", "\n", "time_last", "=", "1e-6", "*", "self", ".", "get", "(", "'sample'", ",", "last", "[", "'sample_token'", "]", ")", "[", "'timestamp'", "]", "\n", "time_first", "=", "1e-6", "*", "self", ".", "get", "(", "'sample'", ",", "first", "[", "'sample_token'", "]", ")", "[", "'timestamp'", "]", "\n", "time_diff", "=", "time_last", "-", "time_first", "\n", "\n", "if", "has_next", "and", "has_prev", ":", "\n", "# If doing centered difference, allow for up to double the max_time_diff.", "\n", "            ", "max_time_diff", "*=", "2", "\n", "\n", "", "if", "time_diff", ">", "max_time_diff", ":", "\n", "# If time_diff is too big, don't return an estimate.", "\n", "            ", "return", "np", ".", "array", "(", "[", "np", ".", "nan", ",", "np", ".", "nan", ",", "np", ".", "nan", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "pos_diff", "/", "time_diff", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_lidarseg_stats": [[494, 566], ["hasattr", "getattr", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "print", "utils.data_io.load_bin_file", "lidarseg.lidarseg_utils.get_stats", "dict", "range", "print", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "utils.data_io.panoptic_to_lidarseg", "len", "len", "sorted", "len", "dict.items", "sorted", "dict.items", "print", "len", "nuscenes.NuScenes.get", "nuscenes.NuScenes.get", "dict.items"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.get_stats", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.panoptic_to_lidarseg", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "get_sample_lidarseg_stats", "(", "self", ",", "\n", "sample_token", ":", "str", ",", "\n", "sort_by", ":", "str", "=", "'count'", ",", "\n", "lidarseg_preds_bin_path", ":", "str", "=", "None", ",", "\n", "gt_from", ":", "str", "=", "'lidarseg'", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Print the number of points for each class in the lidar pointcloud of a sample. Classes with have no\n        points in the pointcloud will not be printed.\n        :param sample_token: Sample token.\n        :param sort_by: One of three options: count / name / index. If 'count`, the stats will be printed in\n                        ascending order of frequency; if `name`, the stats will be printed alphabetically\n                        according to class name; if `index`, the stats will be printed in ascending order of\n                        class index.\n        :param lidarseg_preds_bin_path: A path to the .bin file which contains the user's lidar segmentation\n                                        predictions for the sample.\n        :param gt_from: 'lidarseg' or 'panoptic', ground truth source of point semantic labels.\n        \"\"\"", "\n", "assert", "gt_from", "in", "[", "'lidarseg'", ",", "'panoptic'", "]", ",", "f'gt_from can only be lidarseg or panoptic, get {gt_from}'", "\n", "assert", "hasattr", "(", "self", ",", "gt_from", ")", ",", "f'Error: You have no {gt_from} data; unable to get '", "'statistics for segmentation of the point cloud.'", "\n", "assert", "sort_by", "in", "[", "'count'", ",", "'name'", ",", "'index'", "]", ",", "'Error: sort_by can only be one of the following: '", "'count / name / index.'", "\n", "semantic_table", "=", "getattr", "(", "self", ",", "gt_from", ")", "\n", "sample_rec", "=", "self", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "ref_sd_token", "=", "sample_rec", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", "\n", "ref_sd_record", "=", "self", ".", "get", "(", "'sample_data'", ",", "ref_sd_token", ")", "\n", "\n", "# Ensure that lidar pointcloud is from a keyframe.", "\n", "assert", "ref_sd_record", "[", "'is_key_frame'", "]", ",", "'Error: Only pointclouds which are keyframes have '", "'lidar segmentation labels. Rendering aborted.'", "\n", "\n", "if", "lidarseg_preds_bin_path", ":", "\n", "            ", "lidarseg_labels_filename", "=", "lidarseg_preds_bin_path", "\n", "assert", "os", ".", "path", ".", "exists", "(", "lidarseg_labels_filename", ")", ",", "'Error: Unable to find {} to load the predictions for sample token {} '", "'(lidar sample data token {}) from.'", ".", "format", "(", "lidarseg_labels_filename", ",", "sample_token", ",", "ref_sd_token", ")", "\n", "\n", "header", "=", "'===== Statistics for '", "+", "sample_token", "+", "' (predictions) ====='", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "semantic_table", ")", ">", "0", ",", "'Error: There are no ground truth labels found for nuScenes-{} for {}.'", "'Are you loading the test set? \\nIf you want to see the sample statistics'", "' for your predictions, pass a path to the appropriate .bin/npz file using'", "' the lidarseg_preds_bin_path argument.'", ".", "format", "(", "gt_from", ",", "self", ".", "version", ")", "\n", "lidar_sd_token", "=", "self", ".", "get", "(", "'sample'", ",", "sample_token", ")", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", "\n", "lidarseg_labels_filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "dataroot", ",", "\n", "self", ".", "get", "(", "gt_from", ",", "lidar_sd_token", ")", "[", "'filename'", "]", ")", "\n", "\n", "header", "=", "'===== Statistics for '", "+", "sample_token", "+", "' ====='", "\n", "", "print", "(", "header", ")", "\n", "\n", "points_label", "=", "load_bin_file", "(", "lidarseg_labels_filename", ",", "type", "=", "gt_from", ")", "\n", "if", "gt_from", "==", "'panoptic'", ":", "\n", "            ", "points_label", "=", "panoptic_to_lidarseg", "(", "points_label", ")", "\n", "", "lidarseg_counts", "=", "get_stats", "(", "points_label", ",", "len", "(", "self", ".", "lidarseg_idx2name_mapping", ")", ")", "\n", "\n", "lidarseg_counts_dict", "=", "dict", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "lidarseg_counts", ")", ")", ":", "\n", "            ", "lidarseg_counts_dict", "[", "self", ".", "lidarseg_idx2name_mapping", "[", "i", "]", "]", "=", "lidarseg_counts", "[", "i", "]", "\n", "\n", "", "if", "sort_by", "==", "'count'", ":", "\n", "            ", "out", "=", "sorted", "(", "lidarseg_counts_dict", ".", "items", "(", ")", ",", "key", "=", "lambda", "item", ":", "item", "[", "1", "]", ")", "\n", "", "elif", "sort_by", "==", "'name'", ":", "\n", "            ", "out", "=", "sorted", "(", "lidarseg_counts_dict", ".", "items", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "lidarseg_counts_dict", ".", "items", "(", ")", "\n", "\n", "", "for", "class_name", ",", "count", "in", "out", ":", "\n", "            ", "if", "count", ">", "0", ":", "\n", "                ", "idx", "=", "self", ".", "lidarseg_name2idx_mapping", "[", "class_name", "]", "\n", "print", "(", "'{:3}  {:40} n={:12,}'", ".", "format", "(", "idx", ",", "class_name", ",", "count", ")", ")", "\n", "\n", "", "", "print", "(", "'='", "*", "len", "(", "header", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.list_categories": [[567, 569], ["nuscenes.NuScenes.explorer.list_categories"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_categories"], ["", "def", "list_categories", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "list_categories", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.list_lidarseg_categories": [[570, 572], ["nuscenes.NuScenes.explorer.list_lidarseg_categories"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_lidarseg_categories"], ["", "def", "list_lidarseg_categories", "(", "self", ",", "sort_by", ":", "str", "=", "'count'", ",", "gt_from", ":", "str", "=", "'lidarseg'", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "list_lidarseg_categories", "(", "sort_by", "=", "sort_by", ",", "gt_from", "=", "gt_from", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.list_panoptic_instances": [[573, 575], ["nuscenes.NuScenes.explorer.list_panoptic_instances"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_panoptic_instances"], ["", "def", "list_panoptic_instances", "(", "self", ",", "sort_by", ":", "str", "=", "'count'", ",", "get_hist", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "list_panoptic_instances", "(", "sort_by", "=", "sort_by", ",", "get_hist", "=", "get_hist", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.list_attributes": [[576, 578], ["nuscenes.NuScenes.explorer.list_attributes"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_attributes"], ["", "def", "list_attributes", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "list_attributes", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.list_scenes": [[579, 581], ["nuscenes.NuScenes.explorer.list_scenes"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_scenes"], ["", "def", "list_scenes", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "list_scenes", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.list_sample": [[582, 584], ["nuscenes.NuScenes.explorer.list_sample"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_sample"], ["", "def", "list_sample", "(", "self", ",", "sample_token", ":", "str", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "list_sample", "(", "sample_token", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_pointcloud_in_image": [[585, 603], ["nuscenes.NuScenes.explorer.render_pointcloud_in_image"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_pointcloud_in_image"], ["", "def", "render_pointcloud_in_image", "(", "self", ",", "sample_token", ":", "str", ",", "dot_size", ":", "int", "=", "5", ",", "pointsensor_channel", ":", "str", "=", "'LIDAR_TOP'", ",", "\n", "camera_channel", ":", "str", "=", "'CAM_FRONT'", ",", "out_path", ":", "str", "=", "None", ",", "\n", "render_intensity", ":", "bool", "=", "False", ",", "\n", "show_lidarseg", ":", "bool", "=", "False", ",", "\n", "filter_lidarseg_labels", ":", "List", "=", "None", ",", "\n", "show_lidarseg_legend", ":", "bool", "=", "False", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "lidarseg_preds_bin_path", ":", "str", "=", "None", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_pointcloud_in_image", "(", "sample_token", ",", "dot_size", ",", "pointsensor_channel", "=", "pointsensor_channel", ",", "\n", "camera_channel", "=", "camera_channel", ",", "out_path", "=", "out_path", ",", "\n", "render_intensity", "=", "render_intensity", ",", "\n", "show_lidarseg", "=", "show_lidarseg", ",", "\n", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "show_lidarseg_legend", "=", "show_lidarseg_legend", ",", "\n", "verbose", "=", "verbose", ",", "\n", "lidarseg_preds_bin_path", "=", "lidarseg_preds_bin_path", ",", "\n", "show_panoptic", "=", "show_panoptic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_sample": [[604, 617], ["nuscenes.NuScenes.explorer.render_sample"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_sample"], ["", "def", "render_sample", "(", "self", ",", "sample_token", ":", "str", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "\n", "nsweeps", ":", "int", "=", "1", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "show_lidarseg", ":", "bool", "=", "False", ",", "\n", "filter_lidarseg_labels", ":", "List", "=", "None", ",", "\n", "lidarseg_preds_bin_path", ":", "str", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_sample", "(", "sample_token", ",", "box_vis_level", ",", "nsweeps", "=", "nsweeps", ",", "out_path", "=", "out_path", ",", "\n", "show_lidarseg", "=", "show_lidarseg", ",", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "lidarseg_preds_bin_path", "=", "lidarseg_preds_bin_path", ",", "verbose", "=", "verbose", ",", "\n", "show_panoptic", "=", "show_panoptic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_sample_data": [[618, 637], ["nuscenes.NuScenes.explorer.render_sample_data"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_sample_data"], ["", "def", "render_sample_data", "(", "self", ",", "sample_data_token", ":", "str", ",", "with_anns", ":", "bool", "=", "True", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "axes_limit", ":", "float", "=", "40", ",", "ax", ":", "Axes", "=", "None", ",", "\n", "nsweeps", ":", "int", "=", "1", ",", "out_path", ":", "str", "=", "None", ",", "underlay_map", ":", "bool", "=", "True", ",", "\n", "use_flat_vehicle_coordinates", ":", "bool", "=", "True", ",", "\n", "show_lidarseg", ":", "bool", "=", "False", ",", "\n", "show_lidarseg_legend", ":", "bool", "=", "False", ",", "\n", "filter_lidarseg_labels", ":", "List", "=", "None", ",", "\n", "lidarseg_preds_bin_path", ":", "str", "=", "None", ",", "verbose", ":", "bool", "=", "True", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_sample_data", "(", "sample_data_token", ",", "with_anns", ",", "box_vis_level", ",", "axes_limit", ",", "ax", ",", "nsweeps", "=", "nsweeps", ",", "\n", "out_path", "=", "out_path", ",", "\n", "underlay_map", "=", "underlay_map", ",", "\n", "use_flat_vehicle_coordinates", "=", "use_flat_vehicle_coordinates", ",", "\n", "show_lidarseg", "=", "show_lidarseg", ",", "\n", "show_lidarseg_legend", "=", "show_lidarseg_legend", ",", "\n", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "lidarseg_preds_bin_path", "=", "lidarseg_preds_bin_path", ",", "\n", "verbose", "=", "verbose", ",", "\n", "show_panoptic", "=", "show_panoptic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_annotation": [[638, 642], ["numpy.eye", "nuscenes.NuScenes.explorer.render_annotation"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_annotation"], ["", "def", "render_annotation", "(", "self", ",", "sample_annotation_token", ":", "str", ",", "margin", ":", "float", "=", "10", ",", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "out_path", ":", "str", "=", "None", ",", "\n", "extra_info", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_annotation", "(", "sample_annotation_token", ",", "margin", ",", "view", ",", "box_vis_level", ",", "out_path", ",", "extra_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_instance": [[643, 647], ["numpy.eye", "nuscenes.NuScenes.explorer.render_instance"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_instance"], ["", "def", "render_instance", "(", "self", ",", "instance_token", ":", "str", ",", "margin", ":", "float", "=", "10", ",", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "out_path", ":", "str", "=", "None", ",", "\n", "extra_info", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_instance", "(", "instance_token", ",", "margin", ",", "view", ",", "box_vis_level", ",", "out_path", ",", "extra_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_scene": [[648, 651], ["nuscenes.NuScenes.explorer.render_scene"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_scene"], ["", "def", "render_scene", "(", "self", ",", "scene_token", ":", "str", ",", "freq", ":", "float", "=", "10", ",", "imsize", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "640", ",", "360", ")", ",", "\n", "out_path", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_scene", "(", "scene_token", ",", "freq", ",", "imsize", ",", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_scene_channel": [[652, 655], ["nuscenes.NuScenes.explorer.render_scene_channel"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_scene_channel"], ["", "def", "render_scene_channel", "(", "self", ",", "scene_token", ":", "str", ",", "channel", ":", "str", "=", "'CAM_FRONT'", ",", "freq", ":", "float", "=", "10", ",", "\n", "imsize", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "640", ",", "360", ")", ",", "out_path", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_scene_channel", "(", "scene_token", ",", "channel", "=", "channel", ",", "freq", "=", "freq", ",", "imsize", "=", "imsize", ",", "out_path", "=", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_egoposes_on_map": [[656, 658], ["nuscenes.NuScenes.explorer.render_egoposes_on_map"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_egoposes_on_map"], ["", "def", "render_egoposes_on_map", "(", "self", ",", "log_location", ":", "str", ",", "scene_tokens", ":", "List", "=", "None", ",", "out_path", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_egoposes_on_map", "(", "log_location", ",", "scene_tokens", ",", "out_path", "=", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_scene_channel_lidarseg": [[659, 683], ["nuscenes.NuScenes.explorer.render_scene_channel_lidarseg"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_scene_channel_lidarseg"], ["", "def", "render_scene_channel_lidarseg", "(", "self", ",", "scene_token", ":", "str", ",", "\n", "channel", ":", "str", ",", "\n", "out_folder", ":", "str", "=", "None", ",", "\n", "filter_lidarseg_labels", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "with_anns", ":", "bool", "=", "False", ",", "\n", "render_mode", ":", "str", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "imsize", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "640", ",", "360", ")", ",", "\n", "freq", ":", "float", "=", "2", ",", "\n", "dpi", ":", "int", "=", "150", ",", "\n", "lidarseg_preds_folder", ":", "str", "=", "None", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_scene_channel_lidarseg", "(", "scene_token", ",", "\n", "channel", ",", "\n", "out_folder", "=", "out_folder", ",", "\n", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "with_anns", "=", "with_anns", ",", "\n", "render_mode", "=", "render_mode", ",", "\n", "verbose", "=", "verbose", ",", "\n", "imsize", "=", "imsize", ",", "\n", "freq", "=", "freq", ",", "\n", "dpi", "=", "dpi", ",", "\n", "lidarseg_preds_folder", "=", "lidarseg_preds_folder", ",", "\n", "show_panoptic", "=", "show_panoptic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.render_scene_lidarseg": [[684, 704], ["nuscenes.NuScenes.explorer.render_scene_lidarseg"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_scene_lidarseg"], ["", "def", "render_scene_lidarseg", "(", "self", ",", "scene_token", ":", "str", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "filter_lidarseg_labels", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "with_anns", ":", "bool", "=", "False", ",", "\n", "imsize", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "640", ",", "360", ")", ",", "\n", "freq", ":", "float", "=", "2", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "dpi", ":", "int", "=", "200", ",", "\n", "lidarseg_preds_folder", ":", "str", "=", "None", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "explorer", ".", "render_scene_lidarseg", "(", "scene_token", ",", "\n", "out_path", "=", "out_path", ",", "\n", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "with_anns", "=", "with_anns", ",", "\n", "imsize", "=", "imsize", ",", "\n", "freq", "=", "freq", ",", "\n", "verbose", "=", "verbose", ",", "\n", "dpi", "=", "dpi", ",", "\n", "lidarseg_preds_folder", "=", "lidarseg_preds_folder", ",", "\n", "show_panoptic", "=", "show_panoptic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.__init__": [[710, 712], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "nusc", ":", "NuScenes", ")", ":", "\n", "        ", "self", ".", "nusc", "=", "nusc", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.get_color": [[713, 720], ["None"], "methods", ["None"], ["", "def", "get_color", "(", "self", ",", "category_name", ":", "str", ")", "->", "Tuple", "[", "int", ",", "int", ",", "int", "]", ":", "\n", "        ", "\"\"\"\n        Provides the default colors based on the category names.\n        This method works for the general nuScenes categories, as well as the nuScenes detection categories.\n        \"\"\"", "\n", "\n", "return", "self", ".", "nusc", ".", "colormap", "[", "category_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_categories": [[721, 741], ["print", "dict", "sorted", "categories[].append", "dict.items", "numpy.array", "print", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std"], "methods", ["None"], ["", "def", "list_categories", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\" Print categories, counts and stats. These stats only cover the split specified in nusc.version. \"\"\"", "\n", "print", "(", "'Category stats for split %s:'", "%", "self", ".", "nusc", ".", "version", ")", "\n", "\n", "# Add all annotations.", "\n", "categories", "=", "dict", "(", ")", "\n", "for", "record", "in", "self", ".", "nusc", ".", "sample_annotation", ":", "\n", "            ", "if", "record", "[", "'category_name'", "]", "not", "in", "categories", ":", "\n", "                ", "categories", "[", "record", "[", "'category_name'", "]", "]", "=", "[", "]", "\n", "", "categories", "[", "record", "[", "'category_name'", "]", "]", ".", "append", "(", "record", "[", "'size'", "]", "+", "[", "record", "[", "'size'", "]", "[", "1", "]", "/", "record", "[", "'size'", "]", "[", "0", "]", "]", ")", "\n", "\n", "# Print stats.", "\n", "", "for", "name", ",", "stats", "in", "sorted", "(", "categories", ".", "items", "(", ")", ")", ":", "\n", "            ", "stats", "=", "np", ".", "array", "(", "stats", ")", "\n", "print", "(", "'{:27} n={:5}, width={:5.2f}\\u00B1{:.2f}, len={:5.2f}\\u00B1{:.2f}, height={:5.2f}\\u00B1{:.2f}, '", "\n", "'lw_aspect={:5.2f}\\u00B1{:.2f}'", ".", "format", "(", "name", "[", ":", "27", "]", ",", "stats", ".", "shape", "[", "0", "]", ",", "\n", "np", ".", "mean", "(", "stats", "[", ":", ",", "0", "]", ")", ",", "np", ".", "std", "(", "stats", "[", ":", ",", "0", "]", ")", ",", "\n", "np", ".", "mean", "(", "stats", "[", ":", ",", "1", "]", ")", ",", "np", ".", "std", "(", "stats", "[", ":", ",", "1", "]", ")", ",", "\n", "np", ".", "mean", "(", "stats", "[", ":", ",", "2", "]", ")", ",", "np", ".", "std", "(", "stats", "[", ":", ",", "2", "]", ")", ",", "\n", "np", ".", "mean", "(", "stats", "[", ":", ",", "3", "]", ")", ",", "np", ".", "std", "(", "stats", "[", ":", ",", "3", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_lidarseg_categories": [[742, 794], ["hasattr", "print", "getattr", "time.time", "dict", "range", "print", "len", "os.join", "os.join", "utils.data_io.load_bin_file", "numpy.bincount", "zip", "len", "sorted", "print", "utils.data_io.panoptic_to_lidarseg", "numpy.nonzero", "dict.items", "sorted", "dict.items", "len", "dict.items", "time.time"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.panoptic_to_lidarseg"], ["", "", "def", "list_lidarseg_categories", "(", "self", ",", "sort_by", ":", "str", "=", "'count'", ",", "gt_from", ":", "str", "=", "'lidarseg'", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Print categories and counts of the lidarseg data. These stats only cover\n        the split specified in nusc.version.\n        :param sort_by: One of three options: count / name / index. If 'count`, the stats will be printed in\n                        ascending order of frequency; if `name`, the stats will be printed alphabetically\n                        according to class name; if `index`, the stats will be printed in ascending order of\n                        class index.\n        :param gt_from: 'lidarseg' or 'panoptic', ground truth source of point semantic labels.\n        \"\"\"", "\n", "assert", "gt_from", "in", "[", "'lidarseg'", ",", "'panoptic'", "]", ",", "f'gt_from can only be lidarseg or panoptic, get {gt_from}'", "\n", "assert", "hasattr", "(", "self", ".", "nusc", ",", "gt_from", ")", ",", "f'Error: nuScenes-{gt_from} not installed!'", "\n", "assert", "sort_by", "in", "[", "'count'", ",", "'name'", ",", "'index'", "]", ",", "'Error: sort_by can only be one of the following: '", "'count / name / index.'", "\n", "\n", "print", "(", "f'Calculating semantic point stats for nuScenes-{gt_from}...'", ")", "\n", "semantic_table", "=", "getattr", "(", "self", ".", "nusc", ",", "gt_from", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# Initialize an array of zeroes, one for each class name.", "\n", "lidarseg_counts", "=", "[", "0", "]", "*", "len", "(", "self", ".", "nusc", ".", "lidarseg_idx2name_mapping", ")", "\n", "\n", "for", "record_lidarseg", "in", "semantic_table", ":", "\n", "            ", "lidarseg_labels_filename", "=", "osp", ".", "join", "(", "self", ".", "nusc", ".", "dataroot", ",", "record_lidarseg", "[", "'filename'", "]", ")", "\n", "points_label", "=", "load_bin_file", "(", "lidarseg_labels_filename", ",", "type", "=", "gt_from", ")", "\n", "if", "gt_from", "==", "'panoptic'", ":", "\n", "                ", "points_label", "=", "panoptic_to_lidarseg", "(", "points_label", ")", "\n", "\n", "", "indices", "=", "np", ".", "bincount", "(", "points_label", ")", "\n", "ii", "=", "np", ".", "nonzero", "(", "indices", ")", "[", "0", "]", "\n", "for", "class_idx", ",", "class_count", "in", "zip", "(", "ii", ",", "indices", "[", "ii", "]", ")", ":", "\n", "                ", "lidarseg_counts", "[", "class_idx", "]", "+=", "class_count", "\n", "\n", "", "", "lidarseg_counts_dict", "=", "dict", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "lidarseg_counts", ")", ")", ":", "\n", "            ", "lidarseg_counts_dict", "[", "self", ".", "nusc", ".", "lidarseg_idx2name_mapping", "[", "i", "]", "]", "=", "lidarseg_counts", "[", "i", "]", "\n", "\n", "", "if", "sort_by", "==", "'count'", ":", "\n", "            ", "out", "=", "sorted", "(", "lidarseg_counts_dict", ".", "items", "(", ")", ",", "key", "=", "lambda", "item", ":", "item", "[", "1", "]", ")", "\n", "", "elif", "sort_by", "==", "'name'", ":", "\n", "            ", "out", "=", "sorted", "(", "lidarseg_counts_dict", ".", "items", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "lidarseg_counts_dict", ".", "items", "(", ")", "\n", "\n", "# Print frequency counts of each class in the lidarseg dataset.", "\n", "", "total_count", "=", "0", "\n", "for", "class_name", ",", "count", "in", "out", ":", "\n", "            ", "idx", "=", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", "[", "class_name", "]", "\n", "print", "(", "'{:3}  {:40} nbr_points={:12,}'", ".", "format", "(", "idx", ",", "class_name", ",", "count", ")", ")", "\n", "total_count", "+=", "count", "\n", "", "print", "(", "'Calculated stats for {} point clouds in {:.1f} seconds, total {} points.\\n====='", ".", "format", "(", "\n", "len", "(", "semantic_table", ")", ",", "time", ".", "time", "(", ")", "-", "start_time", ",", "total_count", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_panoptic_instances": [[795, 848], ["hasattr", "getattr", "print", "time.time", "dict", "enumerate", "panoptic.panoptic_utils.get_panoptic_instances_stats", "print", "panoptic_stats[].copy", "print", "print", "os.join", "os.join", "utils.data_io.load_bin_file", "panoptic.panoptic_utils.get_frame_panoptic_instances", "numpy.append", "sorted", "print", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "numpy.empty", "list.items", "sorted", "list", "len", "list.items", "list.items", "time.time"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.get_panoptic_instances_stats", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.get_frame_panoptic_instances", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "list_panoptic_instances", "(", "self", ",", "sort_by", ":", "str", "=", "'count'", ",", "get_hist", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Print categories and counts of the lidarseg data. These stats only cover\n        the split specified in nusc.version.\n        :param sort_by: One of three options: count / name / index. If 'count`, the stats will be printed in\n                        ascending order of frequency; if `name`, the stats will be printed alphabetically\n                        according to class name; if `index`, the stats will be printed in ascending order of\n                        class index.\n        :param get_hist: True to return each frame' instance counts and per-category instance' number of frames, and\n            number of points.\n        \"\"\"", "\n", "assert", "hasattr", "(", "self", ".", "nusc", ",", "'panoptic'", ")", ",", "f'Error: nuScenes-panoptic not installed!'", "\n", "assert", "sort_by", "in", "[", "'count'", ",", "'name'", ",", "'index'", "]", ",", "'Error: sort_by can only be one of the following: '", "'count / name / index.'", "\n", "nusc_panoptic", "=", "getattr", "(", "self", ".", "nusc", ",", "'panoptic'", ")", "\n", "\n", "print", "(", "f'Calculating instance stats for nuScenes-panoptic ...'", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# {scene_token: np.ndarray((n, 5), np.int32)}, each row: (scene_id, frame_id, category_id, inst_id, num_points).", "\n", "scene_inst_stats", "=", "dict", "(", ")", "\n", "for", "frame_id", ",", "record_panoptic", "in", "enumerate", "(", "nusc_panoptic", ")", ":", "\n", "            ", "panoptic_label_filename", "=", "osp", ".", "join", "(", "self", ".", "nusc", ".", "dataroot", ",", "record_panoptic", "[", "'filename'", "]", ")", "\n", "panoptic_label", "=", "load_bin_file", "(", "panoptic_label_filename", ",", "type", "=", "'panoptic'", ")", "\n", "sample_token", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "record_panoptic", "[", "'sample_data_token'", "]", ")", "[", "'sample_token'", "]", "\n", "scene_token", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "[", "'scene_token'", "]", "\n", "if", "scene_token", "not", "in", "scene_inst_stats", ":", "\n", "                ", "scene_inst_stats", "[", "scene_token", "]", "=", "np", ".", "empty", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "", "frame_cat_inst_count", "=", "get_frame_panoptic_instances", "(", "panoptic_label", "=", "panoptic_label", ",", "frame_id", "=", "frame_id", ")", "\n", "scene_inst_stats", "[", "scene_token", "]", "=", "np", ".", "append", "(", "scene_inst_stats", "[", "scene_token", "]", ",", "frame_cat_inst_count", ",", "axis", "=", "0", ")", "\n", "\n", "", "panoptic_stats", "=", "get_panoptic_instances_stats", "(", "scene_inst_stats", ",", "self", ".", "nusc", ".", "lidarseg_idx2name_mapping", ",", "get_hist", ")", "\n", "pm", "=", "u\"\\u00B1\"", "\n", "frame_num_insts", "=", "panoptic_stats", "[", "'per_frame_panoptic_stats'", "]", "[", "'per_frame_num_instances'", "]", "\n", "print", "(", "'Per-frame number of instances: {:.0f}{}{:.0f}'", ".", "format", "(", "frame_num_insts", "[", "0", "]", ",", "pm", ",", "frame_num_insts", "[", "1", "]", ")", ")", "\n", "\n", "instance_counts", "=", "panoptic_stats", "[", "'per_category_panoptic_stats'", "]", ".", "copy", "(", ")", "\n", "if", "sort_by", "==", "'count'", ":", "\n", "            ", "instance_counts", "=", "sorted", "(", "instance_counts", ".", "items", "(", ")", ",", "key", "=", "lambda", "item", ":", "item", "[", "1", "]", "[", "'num_instances'", "]", ",", "reverse", "=", "True", ")", "\n", "", "elif", "sort_by", "==", "'name'", ":", "\n", "            ", "instance_counts", "=", "sorted", "(", "instance_counts", ".", "items", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "instance_counts", "=", "list", "(", "instance_counts", ".", "items", "(", ")", ")", "\n", "\n", "", "print", "(", "'Per-category instance stats:'", ")", "\n", "for", "cat_name", ",", "s", "in", "instance_counts", ":", "\n", "            ", "print", "(", "'{}: {} instances, each instance spans to {:.0f}{}{:.0f} frames, with {:.0f}{}{:.0f} points'", ".", "format", "(", "\n", "cat_name", ",", "s", "[", "'num_instances'", "]", ",", "s", "[", "'num_frames_per_instance'", "]", "[", "0", "]", ",", "pm", ",", "s", "[", "'num_frames_per_instance'", "]", "[", "1", "]", ",", "\n", "s", "[", "'num_points_per_instance'", "]", "[", "0", "]", ",", "pm", ",", "s", "[", "'num_points_per_instance'", "]", "[", "1", "]", ")", ")", "\n", "\n", "", "num_instances", ",", "num_sample_annos", "=", "panoptic_stats", "[", "'num_instances'", "]", ",", "panoptic_stats", "[", "'num_sample_annotations'", "]", "\n", "print", "(", "'\\nCalculated stats for {} point clouds in {:.1f} seconds, total {} instances, {} sample annotations.'", "\n", "'\\n====='", ".", "format", "(", "len", "(", "nusc_panoptic", ")", ",", "time", ".", "time", "(", ")", "-", "start_time", ",", "num_instances", ",", "num_sample_annos", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_attributes": [[849, 861], ["dict", "sorted", "dict.items", "print", "nuscenes.NuScenesExplorer.nusc.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "list_attributes", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\" Prints attributes and counts. \"\"\"", "\n", "attribute_counts", "=", "dict", "(", ")", "\n", "for", "record", "in", "self", ".", "nusc", ".", "sample_annotation", ":", "\n", "            ", "for", "attribute_token", "in", "record", "[", "'attribute_tokens'", "]", ":", "\n", "                ", "att_name", "=", "self", ".", "nusc", ".", "get", "(", "'attribute'", ",", "attribute_token", ")", "[", "'name'", "]", "\n", "if", "att_name", "not", "in", "attribute_counts", ":", "\n", "                    ", "attribute_counts", "[", "att_name", "]", "=", "0", "\n", "", "attribute_counts", "[", "att_name", "]", "+=", "1", "\n", "\n", "", "", "for", "name", ",", "count", "in", "sorted", "(", "attribute_counts", ".", "items", "(", ")", ")", ":", "\n", "            ", "print", "(", "'{}: {}'", ".", "format", "(", "name", ",", "count", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_scenes": [[862, 889], ["sorted", "nuscenes.NuScenesExplorer.nusc.get", "print", "len", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "len", "len", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "datetime.datetime.datetime.utcfromtimestamp().strftime", "nuscenes.NuScenesExplorer.list_scenes.ann_count"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "list_scenes", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\" Lists all scenes with some meta data. \"\"\"", "\n", "\n", "def", "ann_count", "(", "record", ")", ":", "\n", "            ", "count", "=", "0", "\n", "sample", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "record", "[", "'first_sample_token'", "]", ")", "\n", "while", "not", "sample", "[", "'next'", "]", "==", "\"\"", ":", "\n", "                ", "count", "+=", "len", "(", "sample", "[", "'anns'", "]", ")", "\n", "sample", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "sample", "[", "'next'", "]", ")", "\n", "", "return", "count", "\n", "\n", "", "recs", "=", "[", "(", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "record", "[", "'first_sample_token'", "]", ")", "[", "'timestamp'", "]", ",", "record", ")", "for", "record", "in", "\n", "self", ".", "nusc", ".", "scene", "]", "\n", "\n", "for", "start_time", ",", "record", "in", "sorted", "(", "recs", ")", ":", "\n", "            ", "start_time", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "record", "[", "'first_sample_token'", "]", ")", "[", "'timestamp'", "]", "/", "1000000", "\n", "length_time", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "record", "[", "'last_sample_token'", "]", ")", "[", "'timestamp'", "]", "/", "1000000", "-", "start_time", "\n", "location", "=", "self", ".", "nusc", ".", "get", "(", "'log'", ",", "record", "[", "'log_token'", "]", ")", "[", "'location'", "]", "\n", "desc", "=", "record", "[", "'name'", "]", "+", "', '", "+", "record", "[", "'description'", "]", "\n", "if", "len", "(", "desc", ")", ">", "55", ":", "\n", "                ", "desc", "=", "desc", "[", ":", "51", "]", "+", "\"...\"", "\n", "", "if", "len", "(", "location", ")", ">", "18", ":", "\n", "                ", "location", "=", "location", "[", ":", "18", "]", "\n", "\n", "", "print", "(", "'{:16} [{}] {:4.0f}s, {}, #anns:{}'", ".", "format", "(", "\n", "desc", ",", "datetime", ".", "utcfromtimestamp", "(", "start_time", ")", ".", "strftime", "(", "'%y-%m-%d %H:%M:%S'", ")", ",", "\n", "length_time", ",", "location", ",", "ann_count", "(", "record", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.list_sample": [[890, 903], ["nuscenes.NuScenesExplorer.nusc.get", "print", "sample_record[].values", "print", "nuscenes.NuScenesExplorer.nusc.get", "print", "nuscenes.NuScenesExplorer.nusc.get", "print"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "list_sample", "(", "self", ",", "sample_token", ":", "str", ")", "->", "None", ":", "\n", "        ", "\"\"\" Prints sample_data tokens and sample_annotation tokens related to the sample_token. \"\"\"", "\n", "\n", "sample_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "print", "(", "'Sample: {}\\n'", ".", "format", "(", "sample_record", "[", "'token'", "]", ")", ")", "\n", "for", "sd_token", "in", "sample_record", "[", "'data'", "]", ".", "values", "(", ")", ":", "\n", "            ", "sd_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "\n", "print", "(", "'sample_data_token: {}, mod: {}, channel: {}'", ".", "format", "(", "sd_token", ",", "sd_record", "[", "'sensor_modality'", "]", ",", "\n", "sd_record", "[", "'channel'", "]", ")", ")", "\n", "", "print", "(", "''", ")", "\n", "for", "ann_token", "in", "sample_record", "[", "'anns'", "]", ":", "\n", "            ", "ann_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_annotation'", ",", "ann_token", ")", "\n", "print", "(", "'sample_annotation_token: {}, category: {}'", ".", "format", "(", "ann_record", "[", "'token'", "]", ",", "ann_record", "[", "'category_name'", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.map_pointcloud_to_image": [[904, 1043], ["nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "os.join", "os.join", "PIL.Image.open", "nuscenes.NuScenesExplorer.nusc.get", "utils.data_classes.RadarPointCloud.from_file.rotate", "utils.data_classes.RadarPointCloud.from_file.translate", "nuscenes.NuScenesExplorer.nusc.get", "utils.data_classes.RadarPointCloud.from_file.rotate", "utils.data_classes.RadarPointCloud.from_file.translate", "nuscenes.NuScenesExplorer.nusc.get", "utils.data_classes.RadarPointCloud.from_file.translate", "utils.data_classes.RadarPointCloud.from_file.rotate", "nuscenes.NuScenesExplorer.nusc.get", "utils.data_classes.RadarPointCloud.from_file.translate", "utils.data_classes.RadarPointCloud.from_file.rotate", "utils.geometry_utils.view_points", "numpy.ones", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "utils.data_classes.LidarPointCloud.from_file", "utils.data_classes.RadarPointCloud.from_file", "os.join", "os.join", "numpy.array", "numpy.array", "numpy.maximum", "numpy.array", "hasattr", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "numpy.array", "numpy.array", "getattr", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "numpy.min", "numpy.max", "numpy.min", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "print", "nuscenes.NuScenesExplorer.nusc.get", "len", "os.join", "os.join", "lidarseg.lidarseg_utils.paint_points_label", "panoptic.panoptic_utils.paint_panop_points_label", "nuscenes.NuScenesExplorer.nusc.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.paint_points_label", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.paint_panop_points_label", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "map_pointcloud_to_image", "(", "self", ",", "\n", "pointsensor_token", ":", "str", ",", "\n", "camera_token", ":", "str", ",", "\n", "min_dist", ":", "float", "=", "1.0", ",", "\n", "render_intensity", ":", "bool", "=", "False", ",", "\n", "show_lidarseg", ":", "bool", "=", "False", ",", "\n", "filter_lidarseg_labels", ":", "List", "=", "None", ",", "\n", "lidarseg_preds_bin_path", ":", "str", "=", "None", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "Tuple", ":", "\n", "        ", "\"\"\"\n        Given a point sensor (lidar/radar) token and camera sample_data token, load pointcloud and map it to the image\n        plane.\n        :param pointsensor_token: Lidar/radar sample_data token.\n        :param camera_token: Camera sample_data token.\n        :param min_dist: Distance from the camera below which points are discarded.\n        :param render_intensity: Whether to render lidar intensity instead of point depth.\n        :param show_lidarseg: Whether to render lidar intensity instead of point depth.\n        :param filter_lidarseg_labels: Only show lidar points which belong to the given list of classes. If None\n            or the list is empty, all classes will be displayed.\n        :param lidarseg_preds_bin_path: A path to the .bin file which contains the user's lidar segmentation\n                                        predictions for the sample.\n        :param show_panoptic: When set to True, the lidar data is colored with the panoptic labels. When set\n            to False, the colors of the lidar data represent the distance from the center of the ego vehicle.\n            If show_lidarseg is True, show_panoptic will be set to False.\n        :return (pointcloud <np.float: 2, n)>, coloring <np.float: n>, image <Image>).\n        \"\"\"", "\n", "\n", "cam", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "camera_token", ")", "\n", "pointsensor", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "pointsensor_token", ")", "\n", "pcl_path", "=", "osp", ".", "join", "(", "self", ".", "nusc", ".", "dataroot", ",", "pointsensor", "[", "'filename'", "]", ")", "\n", "if", "pointsensor", "[", "'sensor_modality'", "]", "==", "'lidar'", ":", "\n", "            ", "if", "show_lidarseg", "or", "show_panoptic", ":", "\n", "                ", "gt_from", "=", "'lidarseg'", "if", "show_lidarseg", "else", "'panoptic'", "\n", "assert", "hasattr", "(", "self", ".", "nusc", ",", "gt_from", ")", ",", "f'Error: nuScenes-{gt_from} not installed!'", "\n", "\n", "# Ensure that lidar pointcloud is from a keyframe.", "\n", "assert", "pointsensor", "[", "'is_key_frame'", "]", ",", "'Error: Only pointclouds which are keyframes have lidar segmentation labels. Rendering aborted.'", "\n", "\n", "assert", "not", "render_intensity", ",", "'Error: Invalid options selected. You can only select either '", "'render_intensity or show_lidarseg, not both.'", "\n", "\n", "", "pc", "=", "LidarPointCloud", ".", "from_file", "(", "pcl_path", ")", "\n", "", "else", ":", "\n", "            ", "pc", "=", "RadarPointCloud", ".", "from_file", "(", "pcl_path", ")", "\n", "", "im", "=", "Image", ".", "open", "(", "osp", ".", "join", "(", "self", ".", "nusc", ".", "dataroot", ",", "cam", "[", "'filename'", "]", ")", ")", "\n", "\n", "# Points live in the point sensor frame. So they need to be transformed via global to the image plane.", "\n", "# First step: transform the pointcloud to the ego vehicle frame for the timestamp of the sweep.", "\n", "cs_record", "=", "self", ".", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "pointsensor", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "cs_record", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ")", "\n", "pc", ".", "translate", "(", "np", ".", "array", "(", "cs_record", "[", "'translation'", "]", ")", ")", "\n", "\n", "# Second step: transform from ego to the global frame.", "\n", "poserecord", "=", "self", ".", "nusc", ".", "get", "(", "'ego_pose'", ",", "pointsensor", "[", "'ego_pose_token'", "]", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "poserecord", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ")", "\n", "pc", ".", "translate", "(", "np", ".", "array", "(", "poserecord", "[", "'translation'", "]", ")", ")", "\n", "\n", "# Third step: transform from global into the ego vehicle frame for the timestamp of the image.", "\n", "poserecord", "=", "self", ".", "nusc", ".", "get", "(", "'ego_pose'", ",", "cam", "[", "'ego_pose_token'", "]", ")", "\n", "pc", ".", "translate", "(", "-", "np", ".", "array", "(", "poserecord", "[", "'translation'", "]", ")", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "poserecord", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ".", "T", ")", "\n", "\n", "# Fourth step: transform from ego into the camera.", "\n", "cs_record", "=", "self", ".", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "cam", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pc", ".", "translate", "(", "-", "np", ".", "array", "(", "cs_record", "[", "'translation'", "]", ")", ")", "\n", "pc", ".", "rotate", "(", "Quaternion", "(", "cs_record", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ".", "T", ")", "\n", "\n", "# Fifth step: actually take a \"picture\" of the point cloud.", "\n", "# Grab the depths (camera frame z axis points away from the camera).", "\n", "depths", "=", "pc", ".", "points", "[", "2", ",", ":", "]", "\n", "\n", "if", "render_intensity", ":", "\n", "            ", "assert", "pointsensor", "[", "'sensor_modality'", "]", "==", "'lidar'", ",", "'Error: Can only render intensity for lidar, '", "'not %s!'", "%", "pointsensor", "[", "'sensor_modality'", "]", "\n", "# Retrieve the color from the intensities.", "\n", "# Performs arbitary scaling to achieve more visually pleasing results.", "\n", "intensities", "=", "pc", ".", "points", "[", "3", ",", ":", "]", "\n", "intensities", "=", "(", "intensities", "-", "np", ".", "min", "(", "intensities", ")", ")", "/", "(", "np", ".", "max", "(", "intensities", ")", "-", "np", ".", "min", "(", "intensities", ")", ")", "\n", "intensities", "=", "intensities", "**", "0.1", "\n", "intensities", "=", "np", ".", "maximum", "(", "0", ",", "intensities", "-", "0.5", ")", "\n", "coloring", "=", "intensities", "\n", "", "elif", "show_lidarseg", "or", "show_panoptic", ":", "\n", "            ", "assert", "pointsensor", "[", "'sensor_modality'", "]", "==", "'lidar'", ",", "'Error: Can only render lidarseg labels for lidar, '", "'not %s!'", "%", "pointsensor", "[", "'sensor_modality'", "]", "\n", "\n", "gt_from", "=", "'lidarseg'", "if", "show_lidarseg", "else", "'panoptic'", "\n", "semantic_table", "=", "getattr", "(", "self", ".", "nusc", ",", "gt_from", ")", "\n", "\n", "if", "lidarseg_preds_bin_path", ":", "\n", "                ", "sample_token", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "pointsensor_token", ")", "[", "'sample_token'", "]", "\n", "lidarseg_labels_filename", "=", "lidarseg_preds_bin_path", "\n", "assert", "os", ".", "path", ".", "exists", "(", "lidarseg_labels_filename", ")", ",", "'Error: Unable to find {} to load the predictions for sample token {} (lidar '", "'sample data token {}) from.'", ".", "format", "(", "lidarseg_labels_filename", ",", "sample_token", ",", "pointsensor_token", ")", "\n", "", "else", ":", "\n", "                ", "if", "len", "(", "semantic_table", ")", ">", "0", ":", "# Ensure {lidarseg/panoptic}.json is not empty (e.g. in case of v1.0-test).", "\n", "                    ", "lidarseg_labels_filename", "=", "osp", ".", "join", "(", "self", ".", "nusc", ".", "dataroot", ",", "\n", "self", ".", "nusc", ".", "get", "(", "gt_from", ",", "pointsensor_token", ")", "[", "'filename'", "]", ")", "\n", "", "else", ":", "\n", "                    ", "lidarseg_labels_filename", "=", "None", "\n", "\n", "", "", "if", "lidarseg_labels_filename", ":", "\n", "# Paint each label in the pointcloud with a RGBA value.", "\n", "                ", "if", "show_lidarseg", ":", "\n", "                    ", "coloring", "=", "paint_points_label", "(", "lidarseg_labels_filename", ",", "\n", "filter_lidarseg_labels", ",", "\n", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ",", "\n", "self", ".", "nusc", ".", "colormap", ")", "\n", "", "else", ":", "\n", "                    ", "coloring", "=", "paint_panop_points_label", "(", "lidarseg_labels_filename", ",", "\n", "filter_lidarseg_labels", ",", "\n", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ",", "\n", "self", ".", "nusc", ".", "colormap", ")", "\n", "\n", "", "", "else", ":", "\n", "                ", "coloring", "=", "depths", "\n", "print", "(", "f'Warning: There are no lidarseg labels in {self.nusc.version}. Points will be colored according '", "\n", "f'to distance from the ego vehicle instead.'", ")", "\n", "", "", "else", ":", "\n", "# Retrieve the color from the depth.", "\n", "            ", "coloring", "=", "depths", "\n", "\n", "# Take the actual picture (matrix multiplication with camera-matrix + renormalization).", "\n", "", "points", "=", "view_points", "(", "pc", ".", "points", "[", ":", "3", ",", ":", "]", ",", "np", ".", "array", "(", "cs_record", "[", "'camera_intrinsic'", "]", ")", ",", "normalize", "=", "True", ")", "\n", "\n", "# Remove points that are either outside or behind the camera. Leave a margin of 1 pixel for aesthetic reasons.", "\n", "# Also make sure points are at least 1m in front of the camera to avoid seeing the lidar points on the camera", "\n", "# casing for non-keyframes which are slightly out of sync.", "\n", "mask", "=", "np", ".", "ones", "(", "depths", ".", "shape", "[", "0", "]", ",", "dtype", "=", "bool", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "depths", ">", "min_dist", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "points", "[", "0", ",", ":", "]", ">", "1", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "points", "[", "0", ",", ":", "]", "<", "im", ".", "size", "[", "0", "]", "-", "1", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "points", "[", "1", ",", ":", "]", ">", "1", ")", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "points", "[", "1", ",", ":", "]", "<", "im", ".", "size", "[", "1", "]", "-", "1", ")", "\n", "points", "=", "points", "[", ":", ",", "mask", "]", "\n", "coloring", "=", "coloring", "[", "mask", "]", "\n", "\n", "return", "points", ",", "coloring", ",", "im", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_pointcloud_in_image": [[1044, 1133], ["nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.map_pointcloud_to_image", "ax.imshow", "ax.scatter", "ax.axis", "matplotlib.subplots", "ax.set_title", "lidarseg.lidarseg_utils.create_lidarseg_legend", "matplotlib.savefig", "matplotlib.show", "fig.canvas.set_window_title", "fig.canvas.set_window_title", "set", "list", "lidarseg.lidarseg_utils.colormap_to_colors", "lidarseg.lidarseg_utils.get_labels_in_coloring", "panoptic.panoptic_utils.stuff_cat_ids", "panoptic.panoptic_utils.stuff_cat_ids", "set.intersection", "len", "len", "set"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.map_pointcloud_to_image", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.create_lidarseg_legend", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.colormap_to_colors", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.get_labels_in_coloring", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.stuff_cat_ids", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.stuff_cat_ids", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["", "def", "render_pointcloud_in_image", "(", "self", ",", "\n", "sample_token", ":", "str", ",", "\n", "dot_size", ":", "int", "=", "5", ",", "\n", "pointsensor_channel", ":", "str", "=", "'LIDAR_TOP'", ",", "\n", "camera_channel", ":", "str", "=", "'CAM_FRONT'", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "render_intensity", ":", "bool", "=", "False", ",", "\n", "show_lidarseg", ":", "bool", "=", "False", ",", "\n", "filter_lidarseg_labels", ":", "List", "=", "None", ",", "\n", "ax", ":", "Axes", "=", "None", ",", "\n", "show_lidarseg_legend", ":", "bool", "=", "False", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "lidarseg_preds_bin_path", ":", "str", "=", "None", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Scatter-plots a pointcloud on top of image.\n        :param sample_token: Sample token.\n        :param dot_size: Scatter plot dot size.\n        :param pointsensor_channel: RADAR or LIDAR channel name, e.g. 'LIDAR_TOP'.\n        :param camera_channel: Camera channel name, e.g. 'CAM_FRONT'.\n        :param out_path: Optional path to save the rendered figure to disk.\n        :param render_intensity: Whether to render lidar intensity instead of point depth.\n        :param show_lidarseg: Whether to render lidarseg labels instead of point depth.\n        :param filter_lidarseg_labels: Only show lidar points which belong to the given list of classes.\n        :param ax: Axes onto which to render.\n        :param show_lidarseg_legend: Whether to display the legend for the lidarseg labels in the frame.\n        :param verbose: Whether to display the image in a window.\n        :param lidarseg_preds_bin_path: A path to the .bin file which contains the user's lidar segmentation\n                                        predictions for the sample.\n        :param show_panoptic: When set to True, the lidar data is colored with the panoptic labels. When set\n            to False, the colors of the lidar data represent the distance from the center of the ego vehicle.\n            If show_lidarseg is True, show_panoptic will be set to False.\n        \"\"\"", "\n", "if", "show_lidarseg", ":", "\n", "            ", "show_panoptic", "=", "False", "\n", "", "sample_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "\n", "# Here we just grab the front camera and the point sensor.", "\n", "pointsensor_token", "=", "sample_record", "[", "'data'", "]", "[", "pointsensor_channel", "]", "\n", "camera_token", "=", "sample_record", "[", "'data'", "]", "[", "camera_channel", "]", "\n", "\n", "points", ",", "coloring", ",", "im", "=", "self", ".", "map_pointcloud_to_image", "(", "pointsensor_token", ",", "camera_token", ",", "\n", "render_intensity", "=", "render_intensity", ",", "\n", "show_lidarseg", "=", "show_lidarseg", ",", "\n", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "lidarseg_preds_bin_path", "=", "lidarseg_preds_bin_path", ",", "\n", "show_panoptic", "=", "show_panoptic", ")", "\n", "\n", "# Init axes.", "\n", "if", "ax", "is", "None", ":", "\n", "            ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "16", ")", ")", "\n", "if", "lidarseg_preds_bin_path", ":", "\n", "                ", "fig", ".", "canvas", ".", "set_window_title", "(", "sample_token", "+", "'(predictions)'", ")", "\n", "", "else", ":", "\n", "                ", "fig", ".", "canvas", ".", "set_window_title", "(", "sample_token", ")", "\n", "", "", "else", ":", "# Set title on if rendering as part of render_sample.", "\n", "            ", "ax", ".", "set_title", "(", "camera_channel", ")", "\n", "", "ax", ".", "imshow", "(", "im", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "coloring", ",", "s", "=", "dot_size", ")", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "\n", "# Produce a legend with the unique colors from the scatter.", "\n", "if", "pointsensor_channel", "==", "'LIDAR_TOP'", "and", "(", "show_lidarseg", "or", "show_panoptic", ")", "and", "show_lidarseg_legend", ":", "\n", "# If user does not specify a filter, then set the filter to contain the classes present in the pointcloud", "\n", "# after it has been projected onto the image; this will allow displaying the legend only for classes which", "\n", "# are present in the image (instead of all the classes).", "\n", "            ", "if", "filter_lidarseg_labels", "is", "None", ":", "\n", "                ", "if", "show_lidarseg", ":", "\n", "# Since the labels are stored as class indices, we get the RGB colors from the", "\n", "# colormap in an array where the position of the RGB color corresponds to the index", "\n", "# of the class it represents.", "\n", "                    ", "color_legend", "=", "colormap_to_colors", "(", "self", ".", "nusc", ".", "colormap", ",", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ")", "\n", "filter_lidarseg_labels", "=", "get_labels_in_coloring", "(", "color_legend", ",", "coloring", ")", "\n", "", "else", ":", "\n", "# Only show legends for all stuff categories for panoptic.", "\n", "                    ", "filter_lidarseg_labels", "=", "stuff_cat_ids", "(", "len", "(", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ")", ")", "\n", "\n", "", "", "if", "filter_lidarseg_labels", "and", "show_panoptic", ":", "\n", "# Only show legends for filtered stuff categories for panoptic.", "\n", "                ", "stuff_labels", "=", "set", "(", "stuff_cat_ids", "(", "len", "(", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ")", ")", ")", "\n", "filter_lidarseg_labels", "=", "list", "(", "stuff_labels", ".", "intersection", "(", "set", "(", "filter_lidarseg_labels", ")", ")", ")", "\n", "\n", "", "create_lidarseg_legend", "(", "filter_lidarseg_labels", ",", "self", ".", "nusc", ".", "lidarseg_idx2name_mapping", ",", "self", ".", "nusc", ".", "colormap", ",", "\n", "loc", "=", "'upper left'", ",", "ncol", "=", "1", ",", "bbox_to_anchor", "=", "(", "1.05", ",", "1.0", ")", ")", "\n", "\n", "", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ",", "dpi", "=", "200", ")", "\n", "", "if", "verbose", ":", "\n", "            ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_sample": [[1134, 1230], ["nuscenes.NuScenesExplorer.nusc.get", "record[].items", "matplotlib.subplots", "zip", "[].axis", "matplotlib.tight_layout", "fig.subplots_adjust", "nuscenes.NuScenesExplorer.nusc.get", "int", "len", "enumerate", "ax.set_title", "len", "zip", "camera_data.items", "matplotlib.savefig", "matplotlib.show", "len", "len", "len", "numpy.ceil", "radar_data.items", "nuscenes.NuScenesExplorer.render_sample_data", "lidar_data.items", "nuscenes.NuScenesExplorer.render_sample_data", "axes.flatten", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.render_pointcloud_in_image", "nuscenes.NuScenesExplorer.render_sample_data", "axes.flatten", "axes.flatten"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_pointcloud_in_image", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_sample_data"], ["", "", "def", "render_sample", "(", "self", ",", "\n", "token", ":", "str", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "\n", "nsweeps", ":", "int", "=", "1", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "show_lidarseg", ":", "bool", "=", "False", ",", "\n", "filter_lidarseg_labels", ":", "List", "=", "None", ",", "\n", "lidarseg_preds_bin_path", ":", "str", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Render all LIDAR and camera sample_data in sample along with annotations.\n        :param token: Sample token.\n        :param box_vis_level: If sample_data is an image, this sets required visibility for boxes.\n        :param nsweeps: Number of sweeps for lidar and radar.\n        :param out_path: Optional path to save the rendered figure to disk.\n        :param show_lidarseg: Whether to show lidar segmentations labels or not.\n        :param filter_lidarseg_labels: Only show lidar points which belong to the given list of classes.\n        :param lidarseg_preds_bin_path: A path to the .bin file which contains the user's lidar segmentation\n                                        predictions for the sample.\n        :param verbose: Whether to show the rendered sample in a window or not.\n        :param show_panoptic: When set to True, the lidar data is colored with the panoptic labels. When set\n            to False, the colors of the lidar data represent the distance from the center of the ego vehicle.\n            If show_lidarseg is True, show_panoptic will be set to False.\n        \"\"\"", "\n", "record", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "token", ")", "\n", "\n", "# Separate RADAR from LIDAR and vision.", "\n", "radar_data", "=", "{", "}", "\n", "camera_data", "=", "{", "}", "\n", "lidar_data", "=", "{", "}", "\n", "for", "channel", ",", "token", "in", "record", "[", "'data'", "]", ".", "items", "(", ")", ":", "\n", "            ", "sd_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "token", ")", "\n", "sensor_modality", "=", "sd_record", "[", "'sensor_modality'", "]", "\n", "\n", "if", "sensor_modality", "==", "'camera'", ":", "\n", "                ", "camera_data", "[", "channel", "]", "=", "token", "\n", "", "elif", "sensor_modality", "==", "'lidar'", ":", "\n", "                ", "lidar_data", "[", "channel", "]", "=", "token", "\n", "", "else", ":", "\n", "                ", "radar_data", "[", "channel", "]", "=", "token", "\n", "\n", "# Create plots.", "\n", "", "", "num_radar_plots", "=", "1", "if", "len", "(", "radar_data", ")", ">", "0", "else", "0", "\n", "num_lidar_plots", "=", "1", "if", "len", "(", "lidar_data", ")", ">", "0", "else", "0", "\n", "n", "=", "num_radar_plots", "+", "len", "(", "camera_data", ")", "+", "num_lidar_plots", "\n", "cols", "=", "2", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "int", "(", "np", ".", "ceil", "(", "n", "/", "cols", ")", ")", ",", "cols", ",", "figsize", "=", "(", "16", ",", "24", ")", ")", "\n", "\n", "# Plot radars into a single subplot.", "\n", "if", "len", "(", "radar_data", ")", ">", "0", ":", "\n", "            ", "ax", "=", "axes", "[", "0", ",", "0", "]", "\n", "for", "i", ",", "(", "_", ",", "sd_token", ")", "in", "enumerate", "(", "radar_data", ".", "items", "(", ")", ")", ":", "\n", "                ", "self", ".", "render_sample_data", "(", "sd_token", ",", "with_anns", "=", "i", "==", "0", ",", "box_vis_level", "=", "box_vis_level", ",", "ax", "=", "ax", ",", "nsweeps", "=", "nsweeps", ",", "\n", "verbose", "=", "False", ")", "\n", "", "ax", ".", "set_title", "(", "'Fused RADARs'", ")", "\n", "\n", "# Plot lidar into a single subplot.", "\n", "", "if", "len", "(", "lidar_data", ")", ">", "0", ":", "\n", "            ", "for", "(", "_", ",", "sd_token", ")", ",", "ax", "in", "zip", "(", "lidar_data", ".", "items", "(", ")", ",", "axes", ".", "flatten", "(", ")", "[", "num_radar_plots", ":", "]", ")", ":", "\n", "                ", "self", ".", "render_sample_data", "(", "sd_token", ",", "box_vis_level", "=", "box_vis_level", ",", "ax", "=", "ax", ",", "nsweeps", "=", "nsweeps", ",", "\n", "show_lidarseg", "=", "show_lidarseg", ",", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "lidarseg_preds_bin_path", "=", "lidarseg_preds_bin_path", ",", "verbose", "=", "False", ",", "\n", "show_panoptic", "=", "show_panoptic", ")", "\n", "\n", "# Plot cameras in separate subplots.", "\n", "", "", "for", "(", "_", ",", "sd_token", ")", ",", "ax", "in", "zip", "(", "camera_data", ".", "items", "(", ")", ",", "axes", ".", "flatten", "(", ")", "[", "num_radar_plots", "+", "num_lidar_plots", ":", "]", ")", ":", "\n", "            ", "if", "show_lidarseg", "or", "show_panoptic", ":", "\n", "                ", "sd_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "\n", "sensor_channel", "=", "sd_record", "[", "'channel'", "]", "\n", "valid_channels", "=", "[", "'CAM_FRONT_LEFT'", ",", "'CAM_FRONT'", ",", "'CAM_FRONT_RIGHT'", ",", "\n", "'CAM_BACK_LEFT'", ",", "'CAM_BACK'", ",", "'CAM_BACK_RIGHT'", "]", "\n", "assert", "sensor_channel", "in", "valid_channels", ",", "'Input camera channel {} not valid.'", ".", "format", "(", "sensor_channel", ")", "\n", "\n", "self", ".", "render_pointcloud_in_image", "(", "record", "[", "'token'", "]", ",", "\n", "pointsensor_channel", "=", "'LIDAR_TOP'", ",", "\n", "camera_channel", "=", "sensor_channel", ",", "\n", "show_lidarseg", "=", "show_lidarseg", ",", "\n", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "ax", "=", "ax", ",", "verbose", "=", "False", ",", "\n", "lidarseg_preds_bin_path", "=", "lidarseg_preds_bin_path", ",", "\n", "show_panoptic", "=", "show_panoptic", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "render_sample_data", "(", "sd_token", ",", "box_vis_level", "=", "box_vis_level", ",", "ax", "=", "ax", ",", "nsweeps", "=", "nsweeps", ",", "\n", "show_lidarseg", "=", "False", ",", "verbose", "=", "False", ")", "\n", "\n", "# Change plot settings and write to disk.", "\n", "", "", "axes", ".", "flatten", "(", ")", "[", "-", "1", "]", ".", "axis", "(", "'off'", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "fig", ".", "subplots_adjust", "(", "wspace", "=", "0", ",", "hspace", "=", "0", ")", "\n", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "            ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_ego_centric_map": [[1231, 1289], ["nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "map_mask.to_pixel_coords", "int", "map_mask.mask", "nuscenes.NuScenesExplorer.render_ego_centric_map.crop_image"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.to_pixel_coords", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.mask"], ["", "", "def", "render_ego_centric_map", "(", "self", ",", "\n", "sample_data_token", ":", "str", ",", "\n", "axes_limit", ":", "float", "=", "40", ",", "\n", "ax", ":", "Axes", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Render map centered around the associated ego pose.\n        :param sample_data_token: Sample_data token.\n        :param axes_limit: Axes limit measured in meters.\n        :param ax: Axes onto which to render.\n        \"\"\"", "\n", "\n", "def", "crop_image", "(", "image", ":", "np", ".", "array", ",", "\n", "x_px", ":", "int", ",", "\n", "y_px", ":", "int", ",", "\n", "axes_limit_px", ":", "int", ")", "->", "np", ".", "array", ":", "\n", "            ", "x_min", "=", "int", "(", "x_px", "-", "axes_limit_px", ")", "\n", "x_max", "=", "int", "(", "x_px", "+", "axes_limit_px", ")", "\n", "y_min", "=", "int", "(", "y_px", "-", "axes_limit_px", ")", "\n", "y_max", "=", "int", "(", "y_px", "+", "axes_limit_px", ")", "\n", "\n", "cropped_image", "=", "image", "[", "y_min", ":", "y_max", ",", "x_min", ":", "x_max", "]", "\n", "\n", "return", "cropped_image", "\n", "\n", "# Get data.", "\n", "", "sd_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "sample", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "sd_record", "[", "'sample_token'", "]", ")", "\n", "scene", "=", "self", ".", "nusc", ".", "get", "(", "'scene'", ",", "sample", "[", "'scene_token'", "]", ")", "\n", "log", "=", "self", ".", "nusc", ".", "get", "(", "'log'", ",", "scene", "[", "'log_token'", "]", ")", "\n", "map_", "=", "self", ".", "nusc", ".", "get", "(", "'map'", ",", "log", "[", "'map_token'", "]", ")", "\n", "map_mask", "=", "map_", "[", "'mask'", "]", "\n", "pose", "=", "self", ".", "nusc", ".", "get", "(", "'ego_pose'", ",", "sd_record", "[", "'ego_pose_token'", "]", ")", "\n", "\n", "# Retrieve and crop mask.", "\n", "pixel_coords", "=", "map_mask", ".", "to_pixel_coords", "(", "pose", "[", "'translation'", "]", "[", "0", "]", ",", "pose", "[", "'translation'", "]", "[", "1", "]", ")", "\n", "scaled_limit_px", "=", "int", "(", "axes_limit", "*", "(", "1.0", "/", "map_mask", ".", "resolution", ")", ")", "\n", "mask_raster", "=", "map_mask", ".", "mask", "(", ")", "\n", "cropped", "=", "crop_image", "(", "mask_raster", ",", "pixel_coords", "[", "0", "]", ",", "pixel_coords", "[", "1", "]", ",", "int", "(", "scaled_limit_px", "*", "math", ".", "sqrt", "(", "2", ")", ")", ")", "\n", "\n", "# Rotate image.", "\n", "ypr_rad", "=", "Quaternion", "(", "pose", "[", "'rotation'", "]", ")", ".", "yaw_pitch_roll", "\n", "yaw_deg", "=", "-", "math", ".", "degrees", "(", "ypr_rad", "[", "0", "]", ")", "\n", "rotated_cropped", "=", "np", ".", "array", "(", "Image", ".", "fromarray", "(", "cropped", ")", ".", "rotate", "(", "yaw_deg", ")", ")", "\n", "\n", "# Crop image.", "\n", "ego_centric_map", "=", "crop_image", "(", "rotated_cropped", ",", "\n", "int", "(", "rotated_cropped", ".", "shape", "[", "1", "]", "/", "2", ")", ",", "\n", "int", "(", "rotated_cropped", ".", "shape", "[", "0", "]", "/", "2", ")", ",", "\n", "scaled_limit_px", ")", "\n", "\n", "# Init axes and show image.", "\n", "# Set background to white and foreground (semantic prior) to gray.", "\n", "if", "ax", "is", "None", ":", "\n", "            ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "9", ")", ")", "\n", "", "ego_centric_map", "[", "ego_centric_map", "==", "map_mask", ".", "foreground", "]", "=", "125", "\n", "ego_centric_map", "[", "ego_centric_map", "==", "map_mask", ".", "background", "]", "=", "255", "\n", "ax", ".", "imshow", "(", "ego_centric_map", ",", "extent", "=", "[", "-", "axes_limit", ",", "axes_limit", ",", "-", "axes_limit", ",", "axes_limit", "]", ",", "\n", "cmap", "=", "'gray'", ",", "vmin", "=", "0", ",", "vmax", "=", "255", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_sample_data": [[1290, 1542], ["nuscenes.NuScenesExplorer.nusc.get", "ax.axis", "ax.set_title", "ax.set_aspect", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "utils.geometry_utils.view_points", "numpy.sqrt", "numpy.minimum", "ax.scatter", "ax.plot", "nuscenes.NuScenesExplorer.nusc.get_sample_data", "ax.set_xlim", "ax.set_ylim", "matplotlib.savefig", "matplotlib.show", "utils.data_classes.RadarPointCloud.from_file_multisweep", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "numpy.vstack", "numpy.dot", "numpy.dot", "numpy.zeros", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "utils.geometry_utils.transform_matrix", "numpy.dot", "numpy.eye", "numpy.dot", "numpy.eye", "matplotlib.subplots", "nuscenes.NuScenesExplorer.render_ego_centric_map", "numpy.sum", "getattr", "utils.geometry_utils.view_points", "numpy.clip", "ax.scatter.to_rgba", "range", "nuscenes.NuScenesExplorer.nusc.get_sample_data", "PIL.Image.open", "ax.imshow", "ax.set_xlim", "ax.set_ylim", "ValueError", "hasattr", "os.join", "os.join", "utils.data_classes.LidarPointCloud.from_file", "utils.data_classes.LidarPointCloud.from_file_multisweep", "numpy.sqrt", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "print", "ax.arrow", "box.render", "matplotlib.subplots", "numpy.zeros", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "nuscenes.NuScenesExplorer.nusc.get", "len", "os.join", "os.join", "numpy.array", "box.render", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "lidarseg.lidarseg_utils.paint_points_label", "panoptic.panoptic_utils.paint_panop_points_label", "lidarseg.lidarseg_utils.create_lidarseg_legend", "nuscenes.NuScenesExplorer.get_color", "numpy.eye", "numpy.array", "numpy.cos", "nuscenes.NuScenesExplorer.nusc.get", "set", "list", "nuscenes.NuScenesExplorer.get_color", "numpy.sin", "lidarseg.lidarseg_utils.colormap_to_colors", "lidarseg.lidarseg_utils.get_labels_in_coloring", "panoptic.panoptic_utils.stuff_cat_ids", "panoptic.panoptic_utils.stuff_cat_ids", "set.intersection", "len", "len", "set"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.from_file_multisweep", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.transform_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_ego_centric_map", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.from_file_multisweep", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.paint_points_label", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.paint_panop_points_label", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.create_lidarseg_legend", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.get_color", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.get_color", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.colormap_to_colors", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.get_labels_in_coloring", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.stuff_cat_ids", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.stuff_cat_ids", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["", "def", "render_sample_data", "(", "self", ",", "\n", "sample_data_token", ":", "str", ",", "\n", "with_anns", ":", "bool", "=", "True", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "\n", "axes_limit", ":", "float", "=", "40", ",", "\n", "ax", ":", "Axes", "=", "None", ",", "\n", "nsweeps", ":", "int", "=", "1", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "underlay_map", ":", "bool", "=", "True", ",", "\n", "use_flat_vehicle_coordinates", ":", "bool", "=", "True", ",", "\n", "show_lidarseg", ":", "bool", "=", "False", ",", "\n", "show_lidarseg_legend", ":", "bool", "=", "False", ",", "\n", "filter_lidarseg_labels", ":", "List", "=", "None", ",", "\n", "lidarseg_preds_bin_path", ":", "str", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Render sample data onto axis.\n        :param sample_data_token: Sample_data token.\n        :param with_anns: Whether to draw box annotations.\n        :param box_vis_level: If sample_data is an image, this sets required visibility for boxes.\n        :param axes_limit: Axes limit for lidar and radar (measured in meters).\n        :param ax: Axes onto which to render.\n        :param nsweeps: Number of sweeps for lidar and radar.\n        :param out_path: Optional path to save the rendered figure to disk.\n        :param underlay_map: When set to true, lidar data is plotted onto the map. This can be slow.\n        :param use_flat_vehicle_coordinates: Instead of the current sensor's coordinate frame, use ego frame which is\n            aligned to z-plane in the world. Note: Previously this method did not use flat vehicle coordinates, which\n            can lead to small errors when the vertical axis of the global frame and lidar are not aligned. The new\n            setting is more correct and rotates the plot by ~90 degrees.\n        :param show_lidarseg: When set to True, the lidar data is colored with the segmentation labels. When set\n            to False, the colors of the lidar data represent the distance from the center of the ego vehicle.\n        :param show_lidarseg_legend: Whether to display the legend for the lidarseg labels in the frame.\n        :param filter_lidarseg_labels: Only show lidar points which belong to the given list of classes. If None\n            or the list is empty, all classes will be displayed.\n        :param lidarseg_preds_bin_path: A path to the .bin file which contains the user's lidar segmentation\n                                        predictions for the sample.\n        :param verbose: Whether to display the image after it is rendered.\n        :param show_panoptic: When set to True, the lidar data is colored with the panoptic labels. When set\n            to False, the colors of the lidar data represent the distance from the center of the ego vehicle.\n            If show_lidarseg is True, show_panoptic will be set to False.\n        \"\"\"", "\n", "if", "show_lidarseg", ":", "\n", "            ", "show_panoptic", "=", "False", "\n", "# Get sensor modality.", "\n", "", "sd_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "sensor_modality", "=", "sd_record", "[", "'sensor_modality'", "]", "\n", "\n", "if", "sensor_modality", "in", "[", "'lidar'", ",", "'radar'", "]", ":", "\n", "            ", "sample_rec", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "sd_record", "[", "'sample_token'", "]", ")", "\n", "chan", "=", "sd_record", "[", "'channel'", "]", "\n", "ref_chan", "=", "'LIDAR_TOP'", "\n", "ref_sd_token", "=", "sample_rec", "[", "'data'", "]", "[", "ref_chan", "]", "\n", "ref_sd_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "ref_sd_token", ")", "\n", "\n", "if", "sensor_modality", "==", "'lidar'", ":", "\n", "                ", "if", "show_lidarseg", "or", "show_panoptic", ":", "\n", "                    ", "gt_from", "=", "'lidarseg'", "if", "show_lidarseg", "else", "'panoptic'", "\n", "assert", "hasattr", "(", "self", ".", "nusc", ",", "gt_from", ")", ",", "f'Error: nuScenes-{gt_from} not installed!'", "\n", "\n", "# Ensure that lidar pointcloud is from a keyframe.", "\n", "assert", "sd_record", "[", "'is_key_frame'", "]", ",", "'Error: Only pointclouds which are keyframes have lidar segmentation labels. Rendering aborted.'", "\n", "\n", "assert", "nsweeps", "==", "1", ",", "'Error: Only pointclouds which are keyframes have lidar segmentation labels; nsweeps should '", "'be set to 1.'", "\n", "\n", "# Load a single lidar point cloud.", "\n", "pcl_path", "=", "osp", ".", "join", "(", "self", ".", "nusc", ".", "dataroot", ",", "ref_sd_record", "[", "'filename'", "]", ")", "\n", "pc", "=", "LidarPointCloud", ".", "from_file", "(", "pcl_path", ")", "\n", "", "else", ":", "\n", "# Get aggregated lidar point cloud in lidar frame.", "\n", "                    ", "pc", ",", "times", "=", "LidarPointCloud", ".", "from_file_multisweep", "(", "self", ".", "nusc", ",", "sample_rec", ",", "chan", ",", "ref_chan", ",", "\n", "nsweeps", "=", "nsweeps", ")", "\n", "", "velocities", "=", "None", "\n", "", "else", ":", "\n", "# Get aggregated radar point cloud in reference frame.", "\n", "# The point cloud is transformed to the reference frame for visualization purposes.", "\n", "                ", "pc", ",", "times", "=", "RadarPointCloud", ".", "from_file_multisweep", "(", "self", ".", "nusc", ",", "sample_rec", ",", "chan", ",", "ref_chan", ",", "nsweeps", "=", "nsweeps", ")", "\n", "\n", "# Transform radar velocities (x is front, y is left), as these are not transformed when loading the", "\n", "# point cloud.", "\n", "radar_cs_record", "=", "self", ".", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "sd_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "ref_cs_record", "=", "self", ".", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "ref_sd_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "velocities", "=", "pc", ".", "points", "[", "8", ":", "10", ",", ":", "]", "# Compensated velocity", "\n", "velocities", "=", "np", ".", "vstack", "(", "(", "velocities", ",", "np", ".", "zeros", "(", "pc", ".", "points", ".", "shape", "[", "1", "]", ")", ")", ")", "\n", "velocities", "=", "np", ".", "dot", "(", "Quaternion", "(", "radar_cs_record", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ",", "velocities", ")", "\n", "velocities", "=", "np", ".", "dot", "(", "Quaternion", "(", "ref_cs_record", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ".", "T", ",", "velocities", ")", "\n", "velocities", "[", "2", ",", ":", "]", "=", "np", ".", "zeros", "(", "pc", ".", "points", ".", "shape", "[", "1", "]", ")", "\n", "\n", "# By default we render the sample_data top down in the sensor frame.", "\n", "# This is slightly inaccurate when rendering the map as the sensor frame may not be perfectly upright.", "\n", "# Using use_flat_vehicle_coordinates we can render the map in the ego frame instead.", "\n", "", "if", "use_flat_vehicle_coordinates", ":", "\n", "# Retrieve transformation matrices for reference point cloud.", "\n", "                ", "cs_record", "=", "self", ".", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "ref_sd_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pose_record", "=", "self", ".", "nusc", ".", "get", "(", "'ego_pose'", ",", "ref_sd_record", "[", "'ego_pose_token'", "]", ")", "\n", "ref_to_ego", "=", "transform_matrix", "(", "translation", "=", "cs_record", "[", "'translation'", "]", ",", "\n", "rotation", "=", "Quaternion", "(", "cs_record", "[", "\"rotation\"", "]", ")", ")", "\n", "\n", "# Compute rotation between 3D vehicle pose and \"flat\" vehicle pose (parallel to global z plane).", "\n", "ego_yaw", "=", "Quaternion", "(", "pose_record", "[", "'rotation'", "]", ")", ".", "yaw_pitch_roll", "[", "0", "]", "\n", "rotation_vehicle_flat_from_vehicle", "=", "np", ".", "dot", "(", "\n", "Quaternion", "(", "scalar", "=", "np", ".", "cos", "(", "ego_yaw", "/", "2", ")", ",", "vector", "=", "[", "0", ",", "0", ",", "np", ".", "sin", "(", "ego_yaw", "/", "2", ")", "]", ")", ".", "rotation_matrix", ",", "\n", "Quaternion", "(", "pose_record", "[", "'rotation'", "]", ")", ".", "inverse", ".", "rotation_matrix", ")", "\n", "vehicle_flat_from_vehicle", "=", "np", ".", "eye", "(", "4", ")", "\n", "vehicle_flat_from_vehicle", "[", ":", "3", ",", ":", "3", "]", "=", "rotation_vehicle_flat_from_vehicle", "\n", "viewpoint", "=", "np", ".", "dot", "(", "vehicle_flat_from_vehicle", ",", "ref_to_ego", ")", "\n", "", "else", ":", "\n", "                ", "viewpoint", "=", "np", ".", "eye", "(", "4", ")", "\n", "\n", "# Init axes.", "\n", "", "if", "ax", "is", "None", ":", "\n", "                ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "9", ")", ")", "\n", "\n", "# Render map if requested.", "\n", "", "if", "underlay_map", ":", "\n", "                ", "assert", "use_flat_vehicle_coordinates", ",", "'Error: underlay_map requires use_flat_vehicle_coordinates, as '", "'otherwise the location does not correspond to the map!'", "\n", "self", ".", "render_ego_centric_map", "(", "sample_data_token", "=", "sample_data_token", ",", "axes_limit", "=", "axes_limit", ",", "ax", "=", "ax", ")", "\n", "\n", "# Show point cloud.", "\n", "", "points", "=", "view_points", "(", "pc", ".", "points", "[", ":", "3", ",", ":", "]", ",", "viewpoint", ",", "normalize", "=", "False", ")", "\n", "dists", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "pc", ".", "points", "[", ":", "2", ",", ":", "]", "**", "2", ",", "axis", "=", "0", ")", ")", "\n", "colors", "=", "np", ".", "minimum", "(", "1", ",", "dists", "/", "axes_limit", "/", "np", ".", "sqrt", "(", "2", ")", ")", "\n", "if", "sensor_modality", "==", "'lidar'", "and", "(", "show_lidarseg", "or", "show_panoptic", ")", ":", "\n", "                ", "gt_from", "=", "'lidarseg'", "if", "show_lidarseg", "else", "'panoptic'", "\n", "semantic_table", "=", "getattr", "(", "self", ".", "nusc", ",", "gt_from", ")", "\n", "# Load labels for pointcloud.", "\n", "if", "lidarseg_preds_bin_path", ":", "\n", "                    ", "sample_token", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "[", "'sample_token'", "]", "\n", "lidarseg_labels_filename", "=", "lidarseg_preds_bin_path", "\n", "assert", "os", ".", "path", ".", "exists", "(", "lidarseg_labels_filename", ")", ",", "'Error: Unable to find {} to load the predictions for sample token {} (lidar '", "'sample data token {}) from.'", ".", "format", "(", "lidarseg_labels_filename", ",", "sample_token", ",", "sample_data_token", ")", "\n", "", "else", ":", "\n", "                    ", "if", "len", "(", "semantic_table", ")", ">", "0", ":", "\n", "# Ensure {lidarseg/panoptic}.json is not empty (e.g. in case of v1.0-test).", "\n", "                        ", "lidarseg_labels_filename", "=", "osp", ".", "join", "(", "self", ".", "nusc", ".", "dataroot", ",", "\n", "self", ".", "nusc", ".", "get", "(", "gt_from", ",", "sample_data_token", ")", "[", "'filename'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "lidarseg_labels_filename", "=", "None", "\n", "\n", "", "", "if", "lidarseg_labels_filename", ":", "\n", "# Paint each label in the pointcloud with a RGBA value.", "\n", "                    ", "if", "show_lidarseg", "or", "show_panoptic", ":", "\n", "                        ", "if", "show_lidarseg", ":", "\n", "                            ", "colors", "=", "paint_points_label", "(", "lidarseg_labels_filename", ",", "filter_lidarseg_labels", ",", "\n", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ",", "self", ".", "nusc", ".", "colormap", ")", "\n", "", "else", ":", "\n", "                            ", "colors", "=", "paint_panop_points_label", "(", "lidarseg_labels_filename", ",", "filter_lidarseg_labels", ",", "\n", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ",", "self", ".", "nusc", ".", "colormap", ")", "\n", "\n", "", "if", "show_lidarseg_legend", ":", "\n", "\n", "# If user does not specify a filter, then set the filter to contain the classes present in", "\n", "# the pointcloud after it has been projected onto the image; this will allow displaying the", "\n", "# legend only for classes which are present in the image (instead of all the classes).", "\n", "                            ", "if", "filter_lidarseg_labels", "is", "None", ":", "\n", "                                ", "if", "show_lidarseg", ":", "\n", "# Since the labels are stored as class indices, we get the RGB colors from the", "\n", "# colormap in an array where the position of the RGB color corresponds to the index", "\n", "# of the class it represents.", "\n", "                                    ", "color_legend", "=", "colormap_to_colors", "(", "self", ".", "nusc", ".", "colormap", ",", "\n", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ")", "\n", "filter_lidarseg_labels", "=", "get_labels_in_coloring", "(", "color_legend", ",", "colors", ")", "\n", "", "else", ":", "\n", "# Only show legends for stuff categories for panoptic.", "\n", "                                    ", "filter_lidarseg_labels", "=", "stuff_cat_ids", "(", "len", "(", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ")", ")", "\n", "\n", "", "", "if", "filter_lidarseg_labels", "and", "show_panoptic", ":", "\n", "# Only show legends for filtered stuff categories for panoptic.", "\n", "                                ", "stuff_labels", "=", "set", "(", "stuff_cat_ids", "(", "len", "(", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", ")", ")", ")", "\n", "filter_lidarseg_labels", "=", "list", "(", "stuff_labels", ".", "intersection", "(", "set", "(", "filter_lidarseg_labels", ")", ")", ")", "\n", "\n", "", "create_lidarseg_legend", "(", "filter_lidarseg_labels", ",", "\n", "self", ".", "nusc", ".", "lidarseg_idx2name_mapping", ",", "\n", "self", ".", "nusc", ".", "colormap", ",", "\n", "loc", "=", "'upper left'", ",", "\n", "ncol", "=", "1", ",", "\n", "bbox_to_anchor", "=", "(", "1.05", ",", "1.0", ")", ")", "\n", "", "", "", "else", ":", "\n", "                    ", "print", "(", "'Warning: There are no lidarseg labels in {}. Points will be colored according to distance '", "\n", "'from the ego vehicle instead.'", ".", "format", "(", "self", ".", "nusc", ".", "version", ")", ")", "\n", "\n", "", "", "point_scale", "=", "0.2", "if", "sensor_modality", "==", "'lidar'", "else", "3.0", "\n", "scatter", "=", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "colors", ",", "s", "=", "point_scale", ")", "\n", "\n", "# Show velocities.", "\n", "if", "sensor_modality", "==", "'radar'", ":", "\n", "                ", "points_vel", "=", "view_points", "(", "pc", ".", "points", "[", ":", "3", ",", ":", "]", "+", "velocities", ",", "viewpoint", ",", "normalize", "=", "False", ")", "\n", "deltas_vel", "=", "points_vel", "-", "points", "\n", "deltas_vel", "=", "6", "*", "deltas_vel", "# Arbitrary scaling", "\n", "max_delta", "=", "20", "\n", "deltas_vel", "=", "np", ".", "clip", "(", "deltas_vel", ",", "-", "max_delta", ",", "max_delta", ")", "# Arbitrary clipping", "\n", "colors_rgba", "=", "scatter", ".", "to_rgba", "(", "colors", ")", "\n", "for", "i", "in", "range", "(", "points", ".", "shape", "[", "1", "]", ")", ":", "\n", "                    ", "ax", ".", "arrow", "(", "points", "[", "0", ",", "i", "]", ",", "points", "[", "1", ",", "i", "]", ",", "deltas_vel", "[", "0", ",", "i", "]", ",", "deltas_vel", "[", "1", ",", "i", "]", ",", "color", "=", "colors_rgba", "[", "i", "]", ")", "\n", "\n", "# Show ego vehicle.", "\n", "", "", "ax", ".", "plot", "(", "0", ",", "0", ",", "'x'", ",", "color", "=", "'red'", ")", "\n", "\n", "# Get boxes in lidar frame.", "\n", "_", ",", "boxes", ",", "_", "=", "self", ".", "nusc", ".", "get_sample_data", "(", "ref_sd_token", ",", "box_vis_level", "=", "box_vis_level", ",", "\n", "use_flat_vehicle_coordinates", "=", "use_flat_vehicle_coordinates", ")", "\n", "\n", "# Show boxes.", "\n", "if", "with_anns", ":", "\n", "                ", "for", "box", "in", "boxes", ":", "\n", "                    ", "c", "=", "np", ".", "array", "(", "self", ".", "get_color", "(", "box", ".", "name", ")", ")", "/", "255.0", "\n", "box", ".", "render", "(", "ax", ",", "view", "=", "np", ".", "eye", "(", "4", ")", ",", "colors", "=", "(", "c", ",", "c", ",", "c", ")", ")", "\n", "\n", "# Limit visible range.", "\n", "", "", "ax", ".", "set_xlim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "ax", ".", "set_ylim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "", "elif", "sensor_modality", "==", "'camera'", ":", "\n", "# Load boxes and image.", "\n", "            ", "data_path", ",", "boxes", ",", "camera_intrinsic", "=", "self", ".", "nusc", ".", "get_sample_data", "(", "sample_data_token", ",", "\n", "box_vis_level", "=", "box_vis_level", ")", "\n", "data", "=", "Image", ".", "open", "(", "data_path", ")", "\n", "\n", "# Init axes.", "\n", "if", "ax", "is", "None", ":", "\n", "                ", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "16", ")", ")", "\n", "\n", "# Show image.", "\n", "", "ax", ".", "imshow", "(", "data", ")", "\n", "\n", "# Show boxes.", "\n", "if", "with_anns", ":", "\n", "                ", "for", "box", "in", "boxes", ":", "\n", "                    ", "c", "=", "np", ".", "array", "(", "self", ".", "get_color", "(", "box", ".", "name", ")", ")", "/", "255.0", "\n", "box", ".", "render", "(", "ax", ",", "view", "=", "camera_intrinsic", ",", "normalize", "=", "True", ",", "colors", "=", "(", "c", ",", "c", ",", "c", ")", ")", "\n", "\n", "# Limit visible range.", "\n", "", "", "ax", ".", "set_xlim", "(", "0", ",", "data", ".", "size", "[", "0", "]", ")", "\n", "ax", ".", "set_ylim", "(", "data", ".", "size", "[", "1", "]", ",", "0", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Error: Unknown sensor modality!\"", ")", "\n", "\n", "", "ax", ".", "axis", "(", "'off'", ")", "\n", "ax", ".", "set_title", "(", "'{} {labels_type}'", ".", "format", "(", "\n", "sd_record", "[", "'channel'", "]", ",", "labels_type", "=", "'(predictions)'", "if", "lidarseg_preds_bin_path", "else", "''", ")", ")", "\n", "ax", ".", "set_aspect", "(", "'equal'", ")", "\n", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ",", "dpi", "=", "200", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "            ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_annotation": [[1543, 1631], ["numpy.eye", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "matplotlib.subplots", "nuscenes.NuScenesExplorer.nusc.get_sample_data", "utils.data_classes.LidarPointCloud.from_file().render_height", "nuscenes.NuScenesExplorer.nusc.get_sample_data", "PIL.Image.open", "axes[].imshow", "axes[].set_title", "axes[].axis", "axes[].set_aspect", "sample_record[].keys", "nuscenes.NuScenesExplorer.nusc.get_sample_data", "len", "len", "box.render", "axes[].set_xlim", "axes[].set_ylim", "axes[].axis", "axes[].set_aspect", "box.render", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "numpy.linalg.norm", "matplotlib.annotate", "matplotlib.savefig", "sample_record[].keys", "len", "utils.data_classes.LidarPointCloud.from_file", "numpy.array", "utils.geometry_utils.view_points", "nuscenes.NuScenesExplorer.nusc.get", "numpy.array", "nuscenes.NuScenesExplorer.get_color", "boxes[].corners", "nuscenes.NuScenesExplorer.get_color", "numpy.array", "numpy.array", "numpy.min", "numpy.max", "numpy.min", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.render_height", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.get_color", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.get_color"], ["", "", "def", "render_annotation", "(", "self", ",", "\n", "anntoken", ":", "str", ",", "\n", "margin", ":", "float", "=", "10", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "extra_info", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Render selected annotation.\n        :param anntoken: Sample_annotation token.\n        :param margin: How many meters in each direction to include in LIDAR view.\n        :param view: LIDAR view point.\n        :param box_vis_level: If sample_data is an image, this sets required visibility for boxes.\n        :param out_path: Optional path to save the rendered figure to disk.\n        :param extra_info: Whether to render extra information below camera view.\n        \"\"\"", "\n", "ann_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_annotation'", ",", "anntoken", ")", "\n", "sample_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "ann_record", "[", "'sample_token'", "]", ")", "\n", "assert", "'LIDAR_TOP'", "in", "sample_record", "[", "'data'", "]", ".", "keys", "(", ")", ",", "'Error: No LIDAR_TOP in data, unable to render.'", "\n", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "1", ",", "2", ",", "figsize", "=", "(", "18", ",", "9", ")", ")", "\n", "\n", "# Figure out which camera the object is fully visible in (this may return nothing).", "\n", "boxes", ",", "cam", "=", "[", "]", ",", "[", "]", "\n", "cams", "=", "[", "key", "for", "key", "in", "sample_record", "[", "'data'", "]", ".", "keys", "(", ")", "if", "'CAM'", "in", "key", "]", "\n", "for", "cam", "in", "cams", ":", "\n", "            ", "_", ",", "boxes", ",", "_", "=", "self", ".", "nusc", ".", "get_sample_data", "(", "sample_record", "[", "'data'", "]", "[", "cam", "]", ",", "box_vis_level", "=", "box_vis_level", ",", "\n", "selected_anntokens", "=", "[", "anntoken", "]", ")", "\n", "if", "len", "(", "boxes", ")", ">", "0", ":", "\n", "                ", "break", "# We found an image that matches. Let's abort.", "\n", "", "", "assert", "len", "(", "boxes", ")", ">", "0", ",", "'Error: Could not find image where annotation is visible. '", "'Try using e.g. BoxVisibility.ANY.'", "\n", "assert", "len", "(", "boxes", ")", "<", "2", ",", "'Error: Found multiple annotations. Something is wrong!'", "\n", "\n", "cam", "=", "sample_record", "[", "'data'", "]", "[", "cam", "]", "\n", "\n", "# Plot LIDAR view.", "\n", "lidar", "=", "sample_record", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", "\n", "data_path", ",", "boxes", ",", "camera_intrinsic", "=", "self", ".", "nusc", ".", "get_sample_data", "(", "lidar", ",", "selected_anntokens", "=", "[", "anntoken", "]", ")", "\n", "LidarPointCloud", ".", "from_file", "(", "data_path", ")", ".", "render_height", "(", "axes", "[", "0", "]", ",", "view", "=", "view", ")", "\n", "for", "box", "in", "boxes", ":", "\n", "            ", "c", "=", "np", ".", "array", "(", "self", ".", "get_color", "(", "box", ".", "name", ")", ")", "/", "255.0", "\n", "box", ".", "render", "(", "axes", "[", "0", "]", ",", "view", "=", "view", ",", "colors", "=", "(", "c", ",", "c", ",", "c", ")", ")", "\n", "corners", "=", "view_points", "(", "boxes", "[", "0", "]", ".", "corners", "(", ")", ",", "view", ",", "False", ")", "[", ":", "2", ",", ":", "]", "\n", "axes", "[", "0", "]", ".", "set_xlim", "(", "[", "np", ".", "min", "(", "corners", "[", "0", ",", ":", "]", ")", "-", "margin", ",", "np", ".", "max", "(", "corners", "[", "0", ",", ":", "]", ")", "+", "margin", "]", ")", "\n", "axes", "[", "0", "]", ".", "set_ylim", "(", "[", "np", ".", "min", "(", "corners", "[", "1", ",", ":", "]", ")", "-", "margin", ",", "np", ".", "max", "(", "corners", "[", "1", ",", ":", "]", ")", "+", "margin", "]", ")", "\n", "axes", "[", "0", "]", ".", "axis", "(", "'off'", ")", "\n", "axes", "[", "0", "]", ".", "set_aspect", "(", "'equal'", ")", "\n", "\n", "# Plot CAMERA view.", "\n", "", "data_path", ",", "boxes", ",", "camera_intrinsic", "=", "self", ".", "nusc", ".", "get_sample_data", "(", "cam", ",", "selected_anntokens", "=", "[", "anntoken", "]", ")", "\n", "im", "=", "Image", ".", "open", "(", "data_path", ")", "\n", "axes", "[", "1", "]", ".", "imshow", "(", "im", ")", "\n", "axes", "[", "1", "]", ".", "set_title", "(", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "cam", ")", "[", "'channel'", "]", ")", "\n", "axes", "[", "1", "]", ".", "axis", "(", "'off'", ")", "\n", "axes", "[", "1", "]", ".", "set_aspect", "(", "'equal'", ")", "\n", "for", "box", "in", "boxes", ":", "\n", "            ", "c", "=", "np", ".", "array", "(", "self", ".", "get_color", "(", "box", ".", "name", ")", ")", "/", "255.0", "\n", "box", ".", "render", "(", "axes", "[", "1", "]", ",", "view", "=", "camera_intrinsic", ",", "normalize", "=", "True", ",", "colors", "=", "(", "c", ",", "c", ",", "c", ")", ")", "\n", "\n", "# Print extra information about the annotation below the camera view.", "\n", "", "if", "extra_info", ":", "\n", "            ", "rcParams", "[", "'font.family'", "]", "=", "'monospace'", "\n", "\n", "w", ",", "l", ",", "h", "=", "ann_record", "[", "'size'", "]", "\n", "category", "=", "ann_record", "[", "'category_name'", "]", "\n", "lidar_points", "=", "ann_record", "[", "'num_lidar_pts'", "]", "\n", "radar_points", "=", "ann_record", "[", "'num_radar_pts'", "]", "\n", "\n", "sample_data_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_record", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "\n", "pose_record", "=", "self", ".", "nusc", ".", "get", "(", "'ego_pose'", ",", "sample_data_record", "[", "'ego_pose_token'", "]", ")", "\n", "dist", "=", "np", ".", "linalg", ".", "norm", "(", "np", ".", "array", "(", "pose_record", "[", "'translation'", "]", ")", "-", "np", ".", "array", "(", "ann_record", "[", "'translation'", "]", ")", ")", "\n", "\n", "information", "=", "' \\n'", ".", "join", "(", "[", "'category: {}'", ".", "format", "(", "category", ")", ",", "\n", "''", ",", "\n", "'# lidar points: {0:>4}'", ".", "format", "(", "lidar_points", ")", ",", "\n", "'# radar points: {0:>4}'", ".", "format", "(", "radar_points", ")", ",", "\n", "''", ",", "\n", "'distance: {:>7.3f}m'", ".", "format", "(", "dist", ")", ",", "\n", "''", ",", "\n", "'width:  {:>7.3f}m'", ".", "format", "(", "w", ")", ",", "\n", "'length: {:>7.3f}m'", ".", "format", "(", "l", ")", ",", "\n", "'height: {:>7.3f}m'", ".", "format", "(", "h", ")", "]", ")", "\n", "\n", "plt", ".", "annotate", "(", "information", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "-", "20", ")", ",", "xycoords", "=", "'axes fraction'", ",", "textcoords", "=", "'offset points'", ",", "va", "=", "'top'", ")", "\n", "\n", "", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_instance": [[1632, 1661], ["numpy.eye", "nuscenes.NuScenesExplorer.nusc.field2token", "nuscenes.NuScenesExplorer.render_annotation", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "numpy.linalg.norm", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.field2token", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_annotation", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "render_instance", "(", "self", ",", "\n", "instance_token", ":", "str", ",", "\n", "margin", ":", "float", "=", "10", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "box_vis_level", ":", "BoxVisibility", "=", "BoxVisibility", ".", "ANY", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "extra_info", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Finds the annotation of the given instance that is closest to the vehicle, and then renders it.\n        :param instance_token: The instance token.\n        :param margin: How many meters in each direction to include in LIDAR view.\n        :param view: LIDAR view point.\n        :param box_vis_level: If sample_data is an image, this sets required visibility for boxes.\n        :param out_path: Optional path to save the rendered figure to disk.\n        :param extra_info: Whether to render extra information below camera view.\n        \"\"\"", "\n", "ann_tokens", "=", "self", ".", "nusc", ".", "field2token", "(", "'sample_annotation'", ",", "'instance_token'", ",", "instance_token", ")", "\n", "closest", "=", "[", "np", ".", "inf", ",", "None", "]", "\n", "for", "ann_token", "in", "ann_tokens", ":", "\n", "            ", "ann_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_annotation'", ",", "ann_token", ")", "\n", "sample_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "ann_record", "[", "'sample_token'", "]", ")", "\n", "sample_data_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_record", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "\n", "pose_record", "=", "self", ".", "nusc", ".", "get", "(", "'ego_pose'", ",", "sample_data_record", "[", "'ego_pose_token'", "]", ")", "\n", "dist", "=", "np", ".", "linalg", ".", "norm", "(", "np", ".", "array", "(", "pose_record", "[", "'translation'", "]", ")", "-", "np", ".", "array", "(", "ann_record", "[", "'translation'", "]", ")", ")", "\n", "if", "dist", "<", "closest", "[", "0", "]", ":", "\n", "                ", "closest", "[", "0", "]", "=", "dist", "\n", "closest", "[", "1", "]", "=", "ann_token", "\n", "\n", "", "", "self", ".", "render_annotation", "(", "closest", "[", "1", "]", ",", "margin", ",", "view", ",", "box_vis_level", ",", "out_path", ",", "extra_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_scene": [[1662, 1775], ["nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "cv2.namedWindow", "cv2.moveWindow", "numpy.ones", "cv2.destroyAllWindows", "cv2.VideoWriter_fourcc", "cv2.VideoWriter", "nuscenes.NuScenesExplorer.nusc.get", "current_recs.items", "current_recs.items", "cv2.imshow", "cv2.waitKey", "cv2.VideoWriter.release", "cv2.VideoWriter.write", "cv2.waitKey", "cv2.destroyAllWindows", "os.splitext", "os.splitext", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get_sample_data", "cv2.imread", "cv2.resize", "os.exists", "os.exists", "Exception", "nuscenes.NuScenesExplorer.get_color", "box.render_cv2"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.get_color", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.render_cv2"], ["", "def", "render_scene", "(", "self", ",", "\n", "scene_token", ":", "str", ",", "\n", "freq", ":", "float", "=", "10", ",", "\n", "imsize", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "640", ",", "360", ")", ",", "\n", "out_path", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders a full scene with all camera channels.\n        :param scene_token: Unique identifier of scene to render.\n        :param freq: Display frequency (Hz).\n        :param imsize: Size of image to render. The larger the slower this will run.\n        :param out_path: Optional path to write a video file of the rendered frames.\n        \"\"\"", "\n", "\n", "assert", "imsize", "[", "0", "]", "/", "imsize", "[", "1", "]", "==", "16", "/", "9", ",", "\"Aspect ratio should be 16/9.\"", "\n", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "assert", "osp", ".", "splitext", "(", "out_path", ")", "[", "-", "1", "]", "==", "'.avi'", "\n", "\n", "# Get records from DB.", "\n", "", "scene_rec", "=", "self", ".", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "first_sample_rec", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "scene_rec", "[", "'first_sample_token'", "]", ")", "\n", "last_sample_rec", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "scene_rec", "[", "'last_sample_token'", "]", ")", "\n", "\n", "# Set some display parameters.", "\n", "layout", "=", "{", "\n", "'CAM_FRONT_LEFT'", ":", "(", "0", ",", "0", ")", ",", "\n", "'CAM_FRONT'", ":", "(", "imsize", "[", "0", "]", ",", "0", ")", ",", "\n", "'CAM_FRONT_RIGHT'", ":", "(", "2", "*", "imsize", "[", "0", "]", ",", "0", ")", ",", "\n", "'CAM_BACK_LEFT'", ":", "(", "0", ",", "imsize", "[", "1", "]", ")", ",", "\n", "'CAM_BACK'", ":", "(", "imsize", "[", "0", "]", ",", "imsize", "[", "1", "]", ")", ",", "\n", "'CAM_BACK_RIGHT'", ":", "(", "2", "*", "imsize", "[", "0", "]", ",", "imsize", "[", "1", "]", ")", ",", "\n", "}", "\n", "\n", "horizontal_flip", "=", "[", "'CAM_BACK_LEFT'", ",", "'CAM_BACK'", ",", "'CAM_BACK_RIGHT'", "]", "# Flip these for aesthetic reasons.", "\n", "\n", "time_step", "=", "1", "/", "freq", "*", "1e6", "# Time-stamps are measured in micro-seconds.", "\n", "\n", "window_name", "=", "'{}'", ".", "format", "(", "scene_rec", "[", "'name'", "]", ")", "\n", "cv2", ".", "namedWindow", "(", "window_name", ")", "\n", "cv2", ".", "moveWindow", "(", "window_name", ",", "0", ",", "0", ")", "\n", "\n", "canvas", "=", "np", ".", "ones", "(", "(", "2", "*", "imsize", "[", "1", "]", ",", "3", "*", "imsize", "[", "0", "]", ",", "3", ")", ",", "np", ".", "uint8", ")", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "fourcc", "=", "cv2", ".", "VideoWriter_fourcc", "(", "*", "'MJPG'", ")", "\n", "out", "=", "cv2", ".", "VideoWriter", "(", "out_path", ",", "fourcc", ",", "freq", ",", "canvas", ".", "shape", "[", "1", ":", ":", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "None", "\n", "\n", "# Load first sample_data record for each channel.", "\n", "", "current_recs", "=", "{", "}", "# Holds the current record to be displayed by channel.", "\n", "prev_recs", "=", "{", "}", "# Hold the previous displayed record by channel.", "\n", "for", "channel", "in", "layout", ":", "\n", "            ", "current_recs", "[", "channel", "]", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "first_sample_rec", "[", "'data'", "]", "[", "channel", "]", ")", "\n", "prev_recs", "[", "channel", "]", "=", "None", "\n", "\n", "", "current_time", "=", "first_sample_rec", "[", "'timestamp'", "]", "\n", "\n", "while", "current_time", "<", "last_sample_rec", "[", "'timestamp'", "]", ":", "\n", "\n", "            ", "current_time", "+=", "time_step", "\n", "\n", "# For each channel, find first sample that has time > current_time.", "\n", "for", "channel", ",", "sd_rec", "in", "current_recs", ".", "items", "(", ")", ":", "\n", "                ", "while", "sd_rec", "[", "'timestamp'", "]", "<", "current_time", "and", "sd_rec", "[", "'next'", "]", "!=", "''", ":", "\n", "                    ", "sd_rec", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sd_rec", "[", "'next'", "]", ")", "\n", "current_recs", "[", "channel", "]", "=", "sd_rec", "\n", "\n", "# Now add to canvas", "\n", "", "", "for", "channel", ",", "sd_rec", "in", "current_recs", ".", "items", "(", ")", ":", "\n", "\n", "# Only update canvas if we have not already rendered this one.", "\n", "                ", "if", "not", "sd_rec", "==", "prev_recs", "[", "channel", "]", ":", "\n", "\n", "# Get annotations and params from DB.", "\n", "                    ", "impath", ",", "boxes", ",", "camera_intrinsic", "=", "self", ".", "nusc", ".", "get_sample_data", "(", "sd_rec", "[", "'token'", "]", ",", "\n", "box_vis_level", "=", "BoxVisibility", ".", "ANY", ")", "\n", "\n", "# Load and render.", "\n", "if", "not", "osp", ".", "exists", "(", "impath", ")", ":", "\n", "                        ", "raise", "Exception", "(", "'Error: Missing image %s'", "%", "impath", ")", "\n", "", "im", "=", "cv2", ".", "imread", "(", "impath", ")", "\n", "for", "box", "in", "boxes", ":", "\n", "                        ", "c", "=", "self", ".", "get_color", "(", "box", ".", "name", ")", "\n", "box", ".", "render_cv2", "(", "im", ",", "view", "=", "camera_intrinsic", ",", "normalize", "=", "True", ",", "colors", "=", "(", "c", ",", "c", ",", "c", ")", ")", "\n", "\n", "", "im", "=", "cv2", ".", "resize", "(", "im", ",", "imsize", ")", "\n", "if", "channel", "in", "horizontal_flip", ":", "\n", "                        ", "im", "=", "im", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "\n", "", "canvas", "[", "\n", "layout", "[", "channel", "]", "[", "1", "]", ":", "layout", "[", "channel", "]", "[", "1", "]", "+", "imsize", "[", "1", "]", ",", "\n", "layout", "[", "channel", "]", "[", "0", "]", ":", "layout", "[", "channel", "]", "[", "0", "]", "+", "imsize", "[", "0", "]", ",", ":", "\n", "]", "=", "im", "\n", "\n", "prev_recs", "[", "channel", "]", "=", "sd_rec", "# Store here so we don't render the same image twice.", "\n", "\n", "# Show updated canvas.", "\n", "", "", "cv2", ".", "imshow", "(", "window_name", ",", "canvas", ")", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "                ", "out", ".", "write", "(", "canvas", ")", "\n", "\n", "", "key", "=", "cv2", ".", "waitKey", "(", "1", ")", "# Wait a very short time (1 ms).", "\n", "\n", "if", "key", "==", "32", ":", "# if space is pressed, pause.", "\n", "                ", "key", "=", "cv2", ".", "waitKey", "(", ")", "\n", "\n", "", "if", "key", "==", "27", ":", "# if ESC is pressed, exit.", "\n", "                ", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "break", "\n", "\n", "", "", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "out", ".", "release", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_scene_channel": [[1776, 1852], ["nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "cv2.namedWindow", "cv2.moveWindow", "cv2.destroyAllWindows", "cv2.VideoWriter_fourcc", "cv2.VideoWriter", "nuscenes.NuScenesExplorer.nusc.get_sample_data", "cv2.imread", "cv2.resize", "cv2.imshow", "cv2.waitKey", "cv2.VideoWriter.release", "os.exists", "os.exists", "Exception", "nuscenes.NuScenesExplorer.get_color", "box.render_cv2", "cv2.VideoWriter.write", "cv2.waitKey", "cv2.destroyAllWindows", "nuscenes.NuScenesExplorer.nusc.get", "os.splitext", "os.splitext"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.get_color", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.render_cv2", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "render_scene_channel", "(", "self", ",", "\n", "scene_token", ":", "str", ",", "\n", "channel", ":", "str", "=", "'CAM_FRONT'", ",", "\n", "freq", ":", "float", "=", "10", ",", "\n", "imsize", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "640", ",", "360", ")", ",", "\n", "out_path", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders a full scene for a particular camera channel.\n        :param scene_token: Unique identifier of scene to render.\n        :param channel: Channel to render.\n        :param freq: Display frequency (Hz).\n        :param imsize: Size of image to render. The larger the slower this will run.\n        :param out_path: Optional path to write a video file of the rendered frames.\n        \"\"\"", "\n", "valid_channels", "=", "[", "'CAM_FRONT_LEFT'", ",", "'CAM_FRONT'", ",", "'CAM_FRONT_RIGHT'", ",", "\n", "'CAM_BACK_LEFT'", ",", "'CAM_BACK'", ",", "'CAM_BACK_RIGHT'", "]", "\n", "\n", "assert", "imsize", "[", "0", "]", "/", "imsize", "[", "1", "]", "==", "16", "/", "9", ",", "\"Error: Aspect ratio should be 16/9.\"", "\n", "assert", "channel", "in", "valid_channels", ",", "'Error: Input channel {} not valid.'", ".", "format", "(", "channel", ")", "\n", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "assert", "osp", ".", "splitext", "(", "out_path", ")", "[", "-", "1", "]", "==", "'.avi'", "\n", "\n", "# Get records from DB.", "\n", "", "scene_rec", "=", "self", ".", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "sample_rec", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "scene_rec", "[", "'first_sample_token'", "]", ")", "\n", "sd_rec", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "channel", "]", ")", "\n", "\n", "# Open CV init.", "\n", "name", "=", "'{}: {} (Space to pause, ESC to exit)'", ".", "format", "(", "scene_rec", "[", "'name'", "]", ",", "channel", ")", "\n", "cv2", ".", "namedWindow", "(", "name", ")", "\n", "cv2", ".", "moveWindow", "(", "name", ",", "0", ",", "0", ")", "\n", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "fourcc", "=", "cv2", ".", "VideoWriter_fourcc", "(", "*", "'MJPG'", ")", "\n", "out", "=", "cv2", ".", "VideoWriter", "(", "out_path", ",", "fourcc", ",", "freq", ",", "imsize", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "None", "\n", "\n", "", "has_more_frames", "=", "True", "\n", "while", "has_more_frames", ":", "\n", "\n", "# Get data from DB.", "\n", "            ", "impath", ",", "boxes", ",", "camera_intrinsic", "=", "self", ".", "nusc", ".", "get_sample_data", "(", "sd_rec", "[", "'token'", "]", ",", "\n", "box_vis_level", "=", "BoxVisibility", ".", "ANY", ")", "\n", "\n", "# Load and render.", "\n", "if", "not", "osp", ".", "exists", "(", "impath", ")", ":", "\n", "                ", "raise", "Exception", "(", "'Error: Missing image %s'", "%", "impath", ")", "\n", "", "im", "=", "cv2", ".", "imread", "(", "impath", ")", "\n", "for", "box", "in", "boxes", ":", "\n", "                ", "c", "=", "self", ".", "get_color", "(", "box", ".", "name", ")", "\n", "box", ".", "render_cv2", "(", "im", ",", "view", "=", "camera_intrinsic", ",", "normalize", "=", "True", ",", "colors", "=", "(", "c", ",", "c", ",", "c", ")", ")", "\n", "\n", "# Render.", "\n", "", "im", "=", "cv2", ".", "resize", "(", "im", ",", "imsize", ")", "\n", "cv2", ".", "imshow", "(", "name", ",", "im", ")", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "                ", "out", ".", "write", "(", "im", ")", "\n", "\n", "", "key", "=", "cv2", ".", "waitKey", "(", "10", ")", "# Images stored at approx 10 Hz, so wait 10 ms.", "\n", "if", "key", "==", "32", ":", "# If space is pressed, pause.", "\n", "                ", "key", "=", "cv2", ".", "waitKey", "(", ")", "\n", "\n", "", "if", "key", "==", "27", ":", "# If ESC is pressed, exit.", "\n", "                ", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "break", "\n", "\n", "", "if", "not", "sd_rec", "[", "'next'", "]", "==", "\"\"", ":", "\n", "                ", "sd_rec", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sd_rec", "[", "'next'", "]", ")", "\n", "", "else", ":", "\n", "                ", "has_more_frames", "=", "False", "\n", "\n", "", "", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "out", ".", "release", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_egoposes_on_map": [[1853, 1945], ["print", "tqdm.tqdm.tqdm", "print", "numpy.vstack", "sklearn.metrics.pairwise.euclidean_distances", "numpy.sum", "matplotlib.subplots", "ax.imshow", "ax.set_title", "ax.scatter", "matplotlib.colorbar", "matplotlib.getp", "matplotlib.setp", "len", "len", "print", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.field2token", "map_mask.mask", "PIL.Image.fromarray", "numpy.array", "numpy.concatenate", "matplotlib.savefig", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "numpy.vstack.append", "len", "map_mask.mask", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.concatenate", "numpy.shape", "numpy.shape", "numpy.shape", "numpy.expand_dims", "numpy.expand_dims", "numpy.expand_dims", "map_mask.to_pixel_coords", "numpy.array", "numpy.array", "map_mask.mask", "map_mask.mask"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.field2token", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.mask", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.mask", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.shape", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.shape", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.shape", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.to_pixel_coords", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.mask", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.mask"], ["", "", "def", "render_egoposes_on_map", "(", "self", ",", "\n", "log_location", ":", "str", ",", "\n", "scene_tokens", ":", "List", "=", "None", ",", "\n", "close_dist", ":", "float", "=", "100", ",", "\n", "color_fg", ":", "Tuple", "[", "int", ",", "int", ",", "int", "]", "=", "(", "167", ",", "174", ",", "186", ")", ",", "\n", "color_bg", ":", "Tuple", "[", "int", ",", "int", ",", "int", "]", "=", "(", "255", ",", "255", ",", "255", ")", ",", "\n", "out_path", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders ego poses a the map. These can be filtered by location or scene.\n        :param log_location: Name of the location, e.g. \"singapore-onenorth\", \"singapore-hollandvillage\",\n                             \"singapore-queenstown' and \"boston-seaport\".\n        :param scene_tokens: Optional list of scene tokens.\n        :param close_dist: Distance in meters for an ego pose to be considered within range of another ego pose.\n        :param color_fg: Color of the semantic prior in RGB format (ignored if map is RGB).\n        :param color_bg: Color of the non-semantic prior in RGB format (ignored if map is RGB).\n        :param out_path: Optional path to save the rendered figure to disk.\n        \"\"\"", "\n", "# Get logs by location.", "\n", "log_tokens", "=", "[", "log", "[", "'token'", "]", "for", "log", "in", "self", ".", "nusc", ".", "log", "if", "log", "[", "'location'", "]", "==", "log_location", "]", "\n", "assert", "len", "(", "log_tokens", ")", ">", "0", ",", "'Error: This split has 0 scenes for location %s!'", "%", "log_location", "\n", "\n", "# Filter scenes.", "\n", "scene_tokens_location", "=", "[", "e", "[", "'token'", "]", "for", "e", "in", "self", ".", "nusc", ".", "scene", "if", "e", "[", "'log_token'", "]", "in", "log_tokens", "]", "\n", "if", "scene_tokens", "is", "not", "None", ":", "\n", "            ", "scene_tokens_location", "=", "[", "t", "for", "t", "in", "scene_tokens_location", "if", "t", "in", "scene_tokens", "]", "\n", "", "if", "len", "(", "scene_tokens_location", ")", "==", "0", ":", "\n", "            ", "print", "(", "'Warning: Found 0 valid scenes for location %s!'", "%", "log_location", ")", "\n", "\n", "", "map_poses", "=", "[", "]", "\n", "map_mask", "=", "None", "\n", "\n", "print", "(", "'Adding ego poses to map...'", ")", "\n", "for", "scene_token", "in", "tqdm", "(", "scene_tokens_location", ")", ":", "\n", "\n", "# Get records from the database.", "\n", "            ", "scene_record", "=", "self", ".", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "log_record", "=", "self", ".", "nusc", ".", "get", "(", "'log'", ",", "scene_record", "[", "'log_token'", "]", ")", "\n", "map_record", "=", "self", ".", "nusc", ".", "get", "(", "'map'", ",", "log_record", "[", "'map_token'", "]", ")", "\n", "map_mask", "=", "map_record", "[", "'mask'", "]", "\n", "\n", "# For each sample in the scene, store the ego pose.", "\n", "sample_tokens", "=", "self", ".", "nusc", ".", "field2token", "(", "'sample'", ",", "'scene_token'", ",", "scene_token", ")", "\n", "for", "sample_token", "in", "sample_tokens", ":", "\n", "                ", "sample_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "\n", "# Poses are associated with the sample_data. Here we use the lidar sample_data.", "\n", "sample_data_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_record", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "\n", "pose_record", "=", "self", ".", "nusc", ".", "get", "(", "'ego_pose'", ",", "sample_data_record", "[", "'ego_pose_token'", "]", ")", "\n", "\n", "# Calculate the pose on the map and append.", "\n", "map_poses", ".", "append", "(", "np", ".", "concatenate", "(", "\n", "map_mask", ".", "to_pixel_coords", "(", "pose_record", "[", "'translation'", "]", "[", "0", "]", ",", "pose_record", "[", "'translation'", "]", "[", "1", "]", ")", ")", ")", "\n", "\n", "# Compute number of close ego poses.", "\n", "", "", "print", "(", "'Creating plot...'", ")", "\n", "map_poses", "=", "np", ".", "vstack", "(", "map_poses", ")", "\n", "dists", "=", "sklearn", ".", "metrics", ".", "pairwise", ".", "euclidean_distances", "(", "map_poses", "*", "map_mask", ".", "resolution", ")", "\n", "close_poses", "=", "np", ".", "sum", "(", "dists", "<", "close_dist", ",", "axis", "=", "0", ")", "\n", "\n", "if", "len", "(", "np", ".", "array", "(", "map_mask", ".", "mask", "(", ")", ")", ".", "shape", ")", "==", "3", "and", "np", ".", "array", "(", "map_mask", ".", "mask", "(", ")", ")", ".", "shape", "[", "2", "]", "==", "3", ":", "\n", "# RGB Colour maps.", "\n", "            ", "mask", "=", "map_mask", ".", "mask", "(", ")", "\n", "", "else", ":", "\n", "# Monochrome maps.", "\n", "# Set the colors for the mask.", "\n", "            ", "mask", "=", "Image", ".", "fromarray", "(", "map_mask", ".", "mask", "(", ")", ")", "\n", "mask", "=", "np", ".", "array", "(", "mask", ")", "\n", "\n", "maskr", "=", "color_fg", "[", "0", "]", "*", "np", ".", "ones", "(", "np", ".", "shape", "(", "mask", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "maskr", "[", "mask", "==", "0", "]", "=", "color_bg", "[", "0", "]", "\n", "maskg", "=", "color_fg", "[", "1", "]", "*", "np", ".", "ones", "(", "np", ".", "shape", "(", "mask", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "maskg", "[", "mask", "==", "0", "]", "=", "color_bg", "[", "1", "]", "\n", "maskb", "=", "color_fg", "[", "2", "]", "*", "np", ".", "ones", "(", "np", ".", "shape", "(", "mask", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "maskb", "[", "mask", "==", "0", "]", "=", "color_bg", "[", "2", "]", "\n", "mask", "=", "np", ".", "concatenate", "(", "(", "np", ".", "expand_dims", "(", "maskr", ",", "axis", "=", "2", ")", ",", "\n", "np", ".", "expand_dims", "(", "maskg", ",", "axis", "=", "2", ")", ",", "\n", "np", ".", "expand_dims", "(", "maskb", ",", "axis", "=", "2", ")", ")", ",", "axis", "=", "2", ")", "\n", "\n", "# Plot.", "\n", "", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "10", ",", "10", ")", ")", "\n", "ax", ".", "imshow", "(", "mask", ")", "\n", "title", "=", "'Number of ego poses within {}m in {}'", ".", "format", "(", "close_dist", ",", "log_location", ")", "\n", "ax", ".", "set_title", "(", "title", ",", "color", "=", "'k'", ")", "\n", "sc", "=", "ax", ".", "scatter", "(", "map_poses", "[", ":", ",", "0", "]", ",", "map_poses", "[", ":", ",", "1", "]", ",", "s", "=", "10", ",", "c", "=", "close_poses", ")", "\n", "color_bar", "=", "plt", ".", "colorbar", "(", "sc", ",", "fraction", "=", "0.025", ",", "pad", "=", "0.04", ")", "\n", "plt", ".", "rcParams", "[", "'figure.facecolor'", "]", "=", "'black'", "\n", "color_bar_ticklabels", "=", "plt", ".", "getp", "(", "color_bar", ".", "ax", ".", "axes", ",", "'yticklabels'", ")", "\n", "plt", ".", "setp", "(", "color_bar_ticklabels", ",", "color", "=", "'k'", ")", "\n", "plt", ".", "rcParams", "[", "'figure.facecolor'", "]", "=", "'white'", "# Reset for future plots.", "\n", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer._plot_points_and_bboxes": [[1946, 2017], ["nuscenes.NuScenesExplorer.map_pointcloud_to_image", "nuscenes.NuScenesExplorer.nusc.get_sample_data", "lidarseg.lidarseg_utils.plt_to_cv2", "cv2.resize", "lidarseg.lidarseg_utils.plt_to_cv2", "cv2.imread", "nuscenes.NuScenesExplorer.get_color", "box.render_cv2", "coloring.any"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.map_pointcloud_to_image", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.plt_to_cv2", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.plt_to_cv2", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.get_color", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.render_cv2"], ["", "", "def", "_plot_points_and_bboxes", "(", "self", ",", "\n", "pointsensor_token", ":", "str", ",", "\n", "camera_token", ":", "str", ",", "\n", "filter_lidarseg_labels", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "lidarseg_preds_bin_path", ":", "str", "=", "None", ",", "\n", "with_anns", ":", "bool", "=", "False", ",", "\n", "imsize", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "640", ",", "360", ")", ",", "\n", "dpi", ":", "int", "=", "100", ",", "\n", "line_width", ":", "int", "=", "5", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "bool", "]", ":", "\n", "        ", "\"\"\"\n        Projects a pointcloud into a camera image along with the lidarseg labels. There is an option to plot the\n        bounding boxes as well.\n        :param pointsensor_token: Token of lidar sensor to render points from and lidarseg labels.\n        :param camera_token: Token of camera to render image from.\n        :param filter_lidarseg_labels: Only show lidar points which belong to the given list of classes. If None\n                                       or the list is empty, all classes will be displayed.\n        :param lidarseg_preds_bin_path: A path to the .bin file which contains the user's lidar segmentation\n                                        predictions for the sample.\n        :param with_anns: Whether to draw box annotations.\n        :param imsize: Size of image to render. The larger the slower this will run.\n        :param dpi: Resolution of the output figure.\n        :param line_width: Line width of bounding boxes.\n        :param show_panoptic: When set to True, the lidar data is colored with the panoptic labels.\n        :return: An image with the projected pointcloud, lidarseg labels and (if applicable) the bounding boxes. Also,\n                 whether there are any lidarseg points (after the filter has been applied) in the image.\n        \"\"\"", "\n", "points", ",", "coloring", ",", "im", "=", "self", ".", "map_pointcloud_to_image", "(", "pointsensor_token", ",", "camera_token", ",", "\n", "render_intensity", "=", "False", ",", "\n", "show_lidarseg", "=", "not", "show_panoptic", ",", "\n", "show_panoptic", "=", "show_panoptic", ",", "\n", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "lidarseg_preds_bin_path", "=", "lidarseg_preds_bin_path", ")", "\n", "\n", "# Prevent rendering images which have no lidarseg labels in them (e.g. the classes in the filter chosen by", "\n", "# the users do not appear within the image). To check if there are no lidarseg labels belonging to the desired", "\n", "# classes in an image, we check if any column in the coloring is all zeros (the alpha column will be all", "\n", "# zeroes if so).", "\n", "if", "(", "~", "coloring", ".", "any", "(", "axis", "=", "0", ")", ")", ".", "any", "(", ")", ":", "\n", "            ", "no_points_in_im", "=", "True", "\n", "", "else", ":", "\n", "            ", "no_points_in_im", "=", "False", "\n", "\n", "", "if", "with_anns", ":", "\n", "# Get annotations and params from DB.", "\n", "            ", "impath", ",", "boxes", ",", "camera_intrinsic", "=", "self", ".", "nusc", ".", "get_sample_data", "(", "camera_token", ",", "box_vis_level", "=", "BoxVisibility", ".", "ANY", ")", "\n", "\n", "# We need to get the image's original height and width as the boxes returned by get_sample_data", "\n", "# are scaled wrt to that.", "\n", "h", ",", "w", ",", "c", "=", "cv2", ".", "imread", "(", "impath", ")", ".", "shape", "\n", "\n", "# Place the projected pointcloud and lidarseg labels onto the image.", "\n", "mat", "=", "plt_to_cv2", "(", "points", ",", "coloring", ",", "im", ",", "(", "w", ",", "h", ")", ",", "dpi", "=", "dpi", ")", "\n", "\n", "# Plot each box onto the image.", "\n", "for", "box", "in", "boxes", ":", "\n", "# If a filter is set, and the class of the box is not among the classes that the user wants to see,", "\n", "# then we skip plotting the box.", "\n", "                ", "if", "filter_lidarseg_labels", "is", "not", "None", "and", "self", ".", "nusc", ".", "lidarseg_name2idx_mapping", "[", "box", ".", "name", "]", "not", "in", "filter_lidarseg_labels", ":", "\n", "                    ", "continue", "\n", "", "c", "=", "self", ".", "get_color", "(", "box", ".", "name", ")", "\n", "box", ".", "render_cv2", "(", "mat", ",", "view", "=", "camera_intrinsic", ",", "normalize", "=", "True", ",", "colors", "=", "(", "c", ",", "c", ",", "c", ")", ",", "linewidth", "=", "line_width", ")", "\n", "\n", "# Only after points and boxes have been placed in the image, then we resize (this is to prevent", "\n", "# weird scaling issues where the dots and boxes are not of the same scale).", "\n", "", "mat", "=", "cv2", ".", "resize", "(", "mat", ",", "imsize", ")", "\n", "", "else", ":", "\n", "            ", "mat", "=", "plt_to_cv2", "(", "points", ",", "coloring", ",", "im", ",", "imsize", ",", "dpi", "=", "dpi", ")", "\n", "\n", "", "return", "mat", ",", "no_points_in_im", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_scene_channel_lidarseg": [[2018, 2166], ["hasattr", "nuscenes.NuScenesExplorer.nusc.get", "cv2.destroyAllWindows", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isdir", "cv2.namedWindow", "cv2.moveWindow", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "cv2.VideoWriter_fourcc", "cv2.VideoWriter", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer.nusc.get", "nuscenes.NuScenesExplorer._plot_points_and_bboxes", "cv2.VideoWriter.release", "os.path.basename", "os.path.basename", "os.path.basename", "os.path.basename", "cv2.imshow", "cv2.waitKey", "matplotlib.close", "cv2.VideoWriter.write", "os.join", "os.join", "os.join", "os.join", "cv2.waitKey", "matplotlib.close", "cv2.destroyAllWindows", "cv2.imwrite", "cv2.VideoWriter.write", "cv2.VideoWriter.release", "os.path.join", "os.path.join", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer._plot_points_and_bboxes"], ["", "def", "render_scene_channel_lidarseg", "(", "self", ",", "\n", "scene_token", ":", "str", ",", "\n", "channel", ":", "str", ",", "\n", "out_folder", ":", "str", "=", "None", ",", "\n", "filter_lidarseg_labels", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "render_mode", ":", "str", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "imsize", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "640", ",", "360", ")", ",", "\n", "with_anns", ":", "bool", "=", "False", ",", "\n", "freq", ":", "float", "=", "2", ",", "\n", "dpi", ":", "int", "=", "150", ",", "\n", "lidarseg_preds_folder", ":", "str", "=", "None", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders a full scene with labelled lidar pointclouds for a particular camera channel.\n        The scene can be rendered either to a video or to a set of images.\n        :param scene_token: Unique identifier of scene to render.\n        :param channel: Camera channel to render.\n        :param out_folder: Optional path to save the rendered frames to disk, either as a video or as individual images.\n        :param filter_lidarseg_labels: Only show lidar points which belong to the given list of classes. If None\n                                       or the list is empty, all classes will be displayed.\n        :param render_mode: Either 'video' or 'image'. 'video' will render the frames into a video (the name of the\n                            video will follow this format: <scene_number>_<camera_channel>.avi) while 'image' will\n                            render the frames into individual images (each image name wil follow this format:\n                            <scene_name>_<camera_channel>_<original_file_name>.jpg). 'out_folder' must be specified\n                            to save the video / images.\n        :param verbose: Whether to show the frames as they are being rendered.\n        :param imsize: Size of image to render. The larger the slower this will run.\n        :param with_anns: Whether to draw box annotations.\n        :param freq: Display frequency (Hz).\n        :param dpi: Resolution of the output dots.\n        :param lidarseg_preds_folder: A path to the folder which contains the user's lidar segmentation predictions for\n            the scene. The naming convention of each .bin file in the folder should be named in this format:\n            <lidar_sample_data_token>_lidarseg.bin. When show_panoptic is True, the path points to panoptic predictions,\n            and the naming format <lidar_sample_data_token>_panoptic.npz.\n        :param show_panoptic: When set to True, the lidar data is colored with the panoptic labels.\n        \"\"\"", "\n", "gt_from", "=", "'panoptic'", "if", "show_panoptic", "else", "'lidarseg'", "\n", "\n", "assert", "hasattr", "(", "self", ".", "nusc", ",", "gt_from", ")", ",", "f'Error: nuScenes-{gt_from} not installed!'", "\n", "\n", "valid_channels", "=", "[", "'CAM_FRONT_LEFT'", ",", "'CAM_FRONT'", ",", "'CAM_FRONT_RIGHT'", ",", "\n", "'CAM_BACK_LEFT'", ",", "'CAM_BACK'", ",", "'CAM_BACK_RIGHT'", "]", "\n", "assert", "channel", "in", "valid_channels", ",", "'Error: Input camera channel {} not valid.'", ".", "format", "(", "channel", ")", "\n", "assert", "imsize", "[", "0", "]", "/", "imsize", "[", "1", "]", "==", "16", "/", "9", ",", "'Error: Aspect ratio should be 16/9.'", "\n", "\n", "if", "lidarseg_preds_folder", ":", "\n", "            ", "assert", "(", "os", ".", "path", ".", "isdir", "(", "lidarseg_preds_folder", ")", ")", ",", "'Error:  The lidarseg predictions folder ({}) does not exist.'", ".", "format", "(", "lidarseg_preds_folder", ")", "\n", "\n", "", "save_as_vid", "=", "False", "\n", "if", "out_folder", ":", "\n", "            ", "assert", "render_mode", "in", "[", "'video'", ",", "'image'", "]", ",", "'Error: For the renderings to be saved to {}, either `video` '", "'or `image` must be specified for render_mode. {} is '", "'not a valid mode.'", ".", "format", "(", "out_folder", ",", "render_mode", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "out_folder", ")", ",", "'Error: {} does not exist.'", ".", "format", "(", "out_folder", ")", "\n", "if", "render_mode", "==", "'video'", ":", "\n", "                ", "save_as_vid", "=", "True", "\n", "\n", "", "", "scene_record", "=", "self", ".", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "\n", "total_num_samples", "=", "scene_record", "[", "'nbr_samples'", "]", "\n", "first_sample_token", "=", "scene_record", "[", "'first_sample_token'", "]", "\n", "last_sample_token", "=", "scene_record", "[", "'last_sample_token'", "]", "\n", "\n", "current_token", "=", "first_sample_token", "\n", "keep_looping", "=", "True", "\n", "i", "=", "0", "\n", "\n", "# Open CV init.", "\n", "if", "verbose", ":", "\n", "            ", "name", "=", "'{}: {} {labels_type} (Space to pause, ESC to exit)'", ".", "format", "(", "\n", "scene_record", "[", "'name'", "]", ",", "channel", ",", "labels_type", "=", "\"(predictions)\"", "if", "lidarseg_preds_folder", "else", "\"\"", ")", "\n", "cv2", ".", "namedWindow", "(", "name", ")", "\n", "cv2", ".", "moveWindow", "(", "name", ",", "0", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "name", "=", "None", "\n", "\n", "", "if", "save_as_vid", ":", "\n", "            ", "out_path", "=", "os", ".", "path", ".", "join", "(", "out_folder", ",", "scene_record", "[", "'name'", "]", "+", "'_'", "+", "channel", "+", "'.avi'", ")", "\n", "fourcc", "=", "cv2", ".", "VideoWriter_fourcc", "(", "*", "'MJPG'", ")", "\n", "out", "=", "cv2", ".", "VideoWriter", "(", "out_path", ",", "fourcc", ",", "freq", ",", "imsize", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "None", "\n", "\n", "", "while", "keep_looping", ":", "\n", "            ", "if", "current_token", "==", "last_sample_token", ":", "\n", "                ", "keep_looping", "=", "False", "\n", "\n", "", "sample_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "current_token", ")", "\n", "\n", "# Set filename of the image.", "\n", "camera_token", "=", "sample_record", "[", "'data'", "]", "[", "channel", "]", "\n", "cam", "=", "self", ".", "nusc", ".", "get", "(", "'sample_data'", ",", "camera_token", ")", "\n", "filename", "=", "scene_record", "[", "'name'", "]", "+", "'_'", "+", "channel", "+", "'_'", "+", "os", ".", "path", ".", "basename", "(", "cam", "[", "'filename'", "]", ")", "\n", "\n", "# Determine whether to render lidarseg points from ground truth or predictions.", "\n", "pointsensor_token", "=", "sample_record", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", "\n", "if", "lidarseg_preds_folder", ":", "\n", "                ", "if", "show_panoptic", ":", "\n", "                    ", "lidarseg_preds_bin_path", "=", "osp", ".", "join", "(", "lidarseg_preds_folder", ",", "pointsensor_token", "+", "'_panoptic.npz'", ")", "\n", "", "else", ":", "\n", "                    ", "lidarseg_preds_bin_path", "=", "osp", ".", "join", "(", "lidarseg_preds_folder", ",", "pointsensor_token", "+", "'_lidarseg.bin'", ")", "\n", "", "", "else", ":", "\n", "                ", "lidarseg_preds_bin_path", "=", "None", "\n", "\n", "", "mat", ",", "no_points_in_mat", "=", "self", ".", "_plot_points_and_bboxes", "(", "pointsensor_token", ",", "camera_token", ",", "\n", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "lidarseg_preds_bin_path", "=", "lidarseg_preds_bin_path", ",", "\n", "with_anns", "=", "with_anns", ",", "imsize", "=", "imsize", ",", "\n", "dpi", "=", "dpi", ",", "line_width", "=", "2", ",", "show_panoptic", "=", "show_panoptic", ")", "\n", "\n", "if", "verbose", ":", "\n", "                ", "cv2", ".", "imshow", "(", "name", ",", "mat", ")", "\n", "\n", "key", "=", "cv2", ".", "waitKey", "(", "1", ")", "\n", "if", "key", "==", "32", ":", "# If space is pressed, pause.", "\n", "                    ", "key", "=", "cv2", ".", "waitKey", "(", ")", "\n", "\n", "", "if", "key", "==", "27", ":", "# if ESC is pressed, exit.", "\n", "                    ", "plt", ".", "close", "(", "'all'", ")", "# To prevent figures from accumulating in memory.", "\n", "# If rendering is stopped halfway, save whatever has been rendered so far into a video", "\n", "# (if save_as_vid = True).", "\n", "if", "save_as_vid", ":", "\n", "                        ", "out", ".", "write", "(", "mat", ")", "\n", "out", ".", "release", "(", ")", "\n", "", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "break", "\n", "\n", "", "plt", ".", "close", "(", "'all'", ")", "# To prevent figures from accumulating in memory.", "\n", "\n", "", "if", "save_as_vid", ":", "\n", "                ", "out", ".", "write", "(", "mat", ")", "\n", "", "elif", "not", "no_points_in_mat", "and", "out_folder", ":", "\n", "                ", "cv2", ".", "imwrite", "(", "os", ".", "path", ".", "join", "(", "out_folder", ",", "filename", ")", ",", "mat", ")", "\n", "", "else", ":", "\n", "                ", "pass", "\n", "\n", "", "next_token", "=", "sample_record", "[", "'next'", "]", "\n", "current_token", "=", "next_token", "\n", "i", "+=", "1", "\n", "\n", "", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "\n", "if", "save_as_vid", ":", "\n", "            ", "assert", "total_num_samples", "==", "i", ",", "'Error: There were supposed to be {} keyframes, '", "'but only {} keyframes were processed'", ".", "format", "(", "total_num_samples", ",", "i", ")", "\n", "out", ".", "release", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.render_scene_lidarseg": [[2167, 2317], ["hasattr", "nuscenes.NuScenesExplorer.nusc.get", "numpy.ones", "cv2.destroyAllWindows", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isdir", "cv2.namedWindow", "cv2.moveWindow", "os.path.split", "os.path.split", "os.path.split", "os.path.split", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isdir", "cv2.VideoWriter_fourcc", "cv2.VideoWriter", "nuscenes.NuScenesExplorer.nusc.get", "matplotlib.close", "cv2.VideoWriter.release", "nuscenes.NuScenesExplorer._plot_points_and_bboxes", "cv2.imshow", "cv2.waitKey", "cv2.VideoWriter.write", "os.path.splitext", "os.path.splitext", "os.path.splitext", "os.path.splitext", "cv2.flip", "cv2.waitKey", "matplotlib.close", "cv2.destroyAllWindows", "os.join", "os.join", "os.join", "os.join", "cv2.VideoWriter.write", "cv2.VideoWriter.release"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer._plot_points_and_bboxes"], ["", "", "def", "render_scene_lidarseg", "(", "self", ",", "\n", "scene_token", ":", "str", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "filter_lidarseg_labels", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "with_anns", ":", "bool", "=", "False", ",", "\n", "imsize", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "640", ",", "360", ")", ",", "\n", "freq", ":", "float", "=", "2", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "dpi", ":", "int", "=", "200", ",", "\n", "lidarseg_preds_folder", ":", "str", "=", "None", ",", "\n", "show_panoptic", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders a full scene with all camera channels and the lidar segmentation labels for each camera.\n        The scene can be rendered either to a video or to a set of images.\n        :param scene_token: Unique identifier of scene to render.\n        :param out_path: Optional path to write a video file (must be .avi) of the rendered frames\n                         (e.g. '~/Desktop/my_rendered_scene.avi),\n        :param filter_lidarseg_labels: Only show lidar points which belong to the given list of classes. If None\n                                       or the list is empty, all classes will be displayed.\n        :param with_anns: Whether to draw box annotations.\n        :param freq: Display frequency (Hz).\n        :param imsize: Size of image to render. The larger the slower this will run.\n        :param verbose: Whether to show the frames as they are being rendered.\n        :param dpi: Resolution of the output dots.\n        :param lidarseg_preds_folder: A path to the folder which contains the user's lidar segmentation predictions for\n            the scene. The naming convention of each .bin file in the folder should be named in this format:\n            <lidar_sample_data_token>_lidarseg.bin. When show_panoptic is True, the path points to panoptic predictions,\n            and the naming format <lidar_sample_data_token>_panoptic.npz.\n        :param show_panoptic: When set to True, the lidar data is colored with the panoptic labels.\n        \"\"\"", "\n", "gt_from", "=", "'panoptic'", "if", "show_panoptic", "else", "'lidarseg'", "\n", "assert", "hasattr", "(", "self", ".", "nusc", ",", "gt_from", ")", ",", "f'Error: nuScenes-{gt_from} not installed!'", "\n", "\n", "assert", "imsize", "[", "0", "]", "/", "imsize", "[", "1", "]", "==", "16", "/", "9", ",", "\"Aspect ratio should be 16/9.\"", "\n", "\n", "if", "lidarseg_preds_folder", ":", "\n", "            ", "assert", "(", "os", ".", "path", ".", "isdir", "(", "lidarseg_preds_folder", ")", ")", ",", "'Error: The lidarseg predictions folder ({}) does not exist.'", ".", "format", "(", "lidarseg_preds_folder", ")", "\n", "\n", "# Get records from DB.", "\n", "", "scene_record", "=", "self", ".", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "\n", "total_num_samples", "=", "scene_record", "[", "'nbr_samples'", "]", "\n", "first_sample_token", "=", "scene_record", "[", "'first_sample_token'", "]", "\n", "last_sample_token", "=", "scene_record", "[", "'last_sample_token'", "]", "\n", "\n", "current_token", "=", "first_sample_token", "\n", "\n", "# Set some display parameters.", "\n", "layout", "=", "{", "\n", "'CAM_FRONT_LEFT'", ":", "(", "0", ",", "0", ")", ",", "\n", "'CAM_FRONT'", ":", "(", "imsize", "[", "0", "]", ",", "0", ")", ",", "\n", "'CAM_FRONT_RIGHT'", ":", "(", "2", "*", "imsize", "[", "0", "]", ",", "0", ")", ",", "\n", "'CAM_BACK_LEFT'", ":", "(", "0", ",", "imsize", "[", "1", "]", ")", ",", "\n", "'CAM_BACK'", ":", "(", "imsize", "[", "0", "]", ",", "imsize", "[", "1", "]", ")", ",", "\n", "'CAM_BACK_RIGHT'", ":", "(", "2", "*", "imsize", "[", "0", "]", ",", "imsize", "[", "1", "]", ")", ",", "\n", "}", "\n", "\n", "horizontal_flip", "=", "[", "'CAM_BACK_LEFT'", ",", "'CAM_BACK'", ",", "'CAM_BACK_RIGHT'", "]", "# Flip these for aesthetic reasons.", "\n", "\n", "if", "verbose", ":", "\n", "            ", "window_name", "=", "'{} {labels_type} (Space to pause, ESC to exit)'", ".", "format", "(", "\n", "scene_record", "[", "'name'", "]", ",", "labels_type", "=", "\"(predictions)\"", "if", "lidarseg_preds_folder", "else", "\"\"", ")", "\n", "cv2", ".", "namedWindow", "(", "window_name", ")", "\n", "cv2", ".", "moveWindow", "(", "window_name", ",", "0", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "window_name", "=", "None", "\n", "\n", "", "slate", "=", "np", ".", "ones", "(", "(", "2", "*", "imsize", "[", "1", "]", ",", "3", "*", "imsize", "[", "0", "]", ",", "3", ")", ",", "np", ".", "uint8", ")", "\n", "\n", "if", "out_path", ":", "\n", "            ", "path_to_file", ",", "filename", "=", "os", ".", "path", ".", "split", "(", "out_path", ")", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "path_to_file", ")", ",", "'Error: {} does not exist.'", ".", "format", "(", "path_to_file", ")", "\n", "assert", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "-", "1", "]", "==", "'.avi'", ",", "'Error: Video can only be saved in .avi format.'", "\n", "fourcc", "=", "cv2", ".", "VideoWriter_fourcc", "(", "*", "'MJPG'", ")", "\n", "out", "=", "cv2", ".", "VideoWriter", "(", "out_path", ",", "fourcc", ",", "freq", ",", "slate", ".", "shape", "[", "1", ":", ":", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "None", "\n", "\n", "", "keep_looping", "=", "True", "\n", "i", "=", "0", "\n", "while", "keep_looping", ":", "\n", "            ", "if", "current_token", "==", "last_sample_token", ":", "\n", "                ", "keep_looping", "=", "False", "\n", "\n", "", "sample_record", "=", "self", ".", "nusc", ".", "get", "(", "'sample'", ",", "current_token", ")", "\n", "\n", "for", "camera_channel", "in", "layout", ":", "\n", "                ", "pointsensor_token", "=", "sample_record", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", "\n", "camera_token", "=", "sample_record", "[", "'data'", "]", "[", "camera_channel", "]", "\n", "\n", "# Determine whether to render lidarseg points from ground truth or predictions.", "\n", "if", "lidarseg_preds_folder", ":", "\n", "                    ", "if", "show_panoptic", ":", "\n", "                        ", "lidarseg_preds_bin_path", "=", "osp", ".", "join", "(", "lidarseg_preds_folder", ",", "pointsensor_token", "+", "'_panoptic.npz'", ")", "\n", "", "else", ":", "\n", "                        ", "lidarseg_preds_bin_path", "=", "osp", ".", "join", "(", "lidarseg_preds_folder", ",", "pointsensor_token", "+", "'_lidarseg.bin'", ")", "\n", "", "", "else", ":", "\n", "                    ", "lidarseg_preds_bin_path", "=", "None", "\n", "\n", "", "mat", ",", "_", "=", "self", ".", "_plot_points_and_bboxes", "(", "pointsensor_token", ",", "camera_token", ",", "\n", "filter_lidarseg_labels", "=", "filter_lidarseg_labels", ",", "\n", "lidarseg_preds_bin_path", "=", "lidarseg_preds_bin_path", ",", "\n", "with_anns", "=", "with_anns", ",", "imsize", "=", "imsize", ",", "dpi", "=", "dpi", ",", "line_width", "=", "3", ",", "\n", "show_panoptic", "=", "show_panoptic", ")", "\n", "\n", "if", "camera_channel", "in", "horizontal_flip", ":", "\n", "# Flip image horizontally.", "\n", "                    ", "mat", "=", "cv2", ".", "flip", "(", "mat", ",", "1", ")", "\n", "\n", "", "slate", "[", "\n", "layout", "[", "camera_channel", "]", "[", "1", "]", ":", "layout", "[", "camera_channel", "]", "[", "1", "]", "+", "imsize", "[", "1", "]", ",", "\n", "layout", "[", "camera_channel", "]", "[", "0", "]", ":", "layout", "[", "camera_channel", "]", "[", "0", "]", "+", "imsize", "[", "0", "]", ",", ":", "\n", "]", "=", "mat", "\n", "\n", "", "if", "verbose", ":", "\n", "                ", "cv2", ".", "imshow", "(", "window_name", ",", "slate", ")", "\n", "\n", "key", "=", "cv2", ".", "waitKey", "(", "1", ")", "\n", "if", "key", "==", "32", ":", "# If space is pressed, pause.", "\n", "                    ", "key", "=", "cv2", ".", "waitKey", "(", ")", "\n", "\n", "", "if", "key", "==", "27", ":", "# if ESC is pressed, exit.", "\n", "                    ", "plt", ".", "close", "(", "'all'", ")", "# To prevent figures from accumulating in memory.", "\n", "# If rendering is stopped halfway, save whatever has been rendered so far into a video", "\n", "# (if save_as_vid = True).", "\n", "if", "out_path", ":", "\n", "                        ", "out", ".", "write", "(", "slate", ")", "\n", "out", ".", "release", "(", ")", "\n", "", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "break", "\n", "\n", "", "", "plt", ".", "close", "(", "'all'", ")", "# To prevent figures from accumulating in memory.", "\n", "\n", "if", "out_path", ":", "\n", "                ", "out", ".", "write", "(", "slate", ")", "\n", "", "else", ":", "\n", "                ", "pass", "\n", "\n", "", "next_token", "=", "sample_record", "[", "'next'", "]", "\n", "current_token", "=", "next_token", "\n", "\n", "i", "+=", "1", "\n", "\n", "", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "\n", "if", "out_path", ":", "\n", "            ", "assert", "total_num_samples", "==", "i", ",", "'Error: There were supposed to be {} keyframes, '", "'but only {} keyframes were processed'", ".", "format", "(", "total_num_samples", ",", "i", ")", "\n", "out", ".", "release", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.bitmap.BitMap.__init__": [[13, 29], ["bitmap.BitMap.load_bitmap"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.bitmap.BitMap.load_bitmap"], ["    ", "def", "__init__", "(", "self", ",", "dataroot", ":", "str", ",", "map_name", ":", "str", ",", "layer_name", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        This class is used to render bitmap map layers. Currently these are:\n        - semantic_prior: The semantic prior (driveable surface and sidewalks) mask from nuScenes 1.0.\n        - basemap: The HD lidar basemap used for localization and as general context.\n\n        :param dataroot: Path of the nuScenes dataset.\n        :param map_name: Which map out of `singapore-onenorth`, `singepore-hollandvillage`, `singapore-queenstown` and\n            'boston-seaport'.\n        :param layer_name: The type of bitmap map, `semanitc_prior` or `basemap.\n        \"\"\"", "\n", "self", ".", "dataroot", "=", "dataroot", "\n", "self", ".", "map_name", "=", "map_name", "\n", "self", ".", "layer_name", "=", "layer_name", "\n", "\n", "self", ".", "image", "=", "self", ".", "load_bitmap", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.bitmap.BitMap.load_bitmap": [[30, 61], ["os.path.exists", "os.path.join", "numpy.array", "Exception", "os.path.join", "Exception", "PIL.Image.open", "numpy.array.max"], "methods", ["None"], ["", "def", "load_bitmap", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Load the specified bitmap.\n        \"\"\"", "\n", "# Load bitmap.", "\n", "if", "self", ".", "layer_name", "==", "'basemap'", ":", "\n", "            ", "map_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "dataroot", ",", "'maps'", ",", "'basemap'", ",", "self", ".", "map_name", "+", "'.png'", ")", "\n", "", "elif", "self", ".", "layer_name", "==", "'semantic_prior'", ":", "\n", "            ", "map_hashes", "=", "{", "\n", "'singapore-onenorth'", ":", "'53992ee3023e5494b90c316c183be829'", ",", "\n", "'singapore-hollandvillage'", ":", "'37819e65e09e5547b8a3ceaefba56bb2'", ",", "\n", "'singapore-queenstown'", ":", "'93406b464a165eaba6d9de76ca09f5da'", ",", "\n", "'boston-seaport'", ":", "'36092f0b03a857c6a3403e25b4b7aab3'", "\n", "}", "\n", "map_hash", "=", "map_hashes", "[", "self", ".", "map_name", "]", "\n", "map_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "dataroot", ",", "'maps'", ",", "map_hash", "+", "'.png'", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Error: Invalid bitmap layer: %s'", "%", "self", ".", "layer_name", ")", "\n", "\n", "# Convert to numpy.", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "map_path", ")", ":", "\n", "            ", "image", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "map_path", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Error: Cannot find %s %s! Please make sure that the map is correctly installed.'", "\n", "%", "(", "self", ".", "layer_name", ",", "map_path", ")", ")", "\n", "\n", "# Invert semantic prior colors.", "\n", "", "if", "self", ".", "layer_name", "==", "'semantic_prior'", ":", "\n", "            ", "image", "=", "image", ".", "max", "(", ")", "-", "image", "\n", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.bitmap.BitMap.render": [[62, 76], ["matplotlib.subplot", "len", "matplotlib.subplot.imshow", "matplotlib.subplot.imshow"], "methods", ["None"], ["", "def", "render", "(", "self", ",", "canvas_edge", ":", "Tuple", "[", "float", ",", "float", "]", ",", "ax", ":", "Axis", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Render the bitmap.\n        Note: Regardless of the image dimensions, the image will be rendered to occupy the entire map.\n        :param canvas_edge: The dimension of the current map in meters (width, height).\n        :param ax: Optional axis to render to.\n        \"\"\"", "\n", "if", "ax", "is", "None", ":", "\n", "            ", "ax", "=", "plt", ".", "subplot", "(", ")", "\n", "", "x", ",", "y", "=", "canvas_edge", "\n", "if", "len", "(", "self", ".", "image", ".", "shape", ")", "==", "2", ":", "\n", "            ", "ax", ".", "imshow", "(", "self", ".", "image", ",", "extent", "=", "[", "0", ",", "x", ",", "0", ",", "y", "]", ",", "cmap", "=", "'gray'", ")", "\n", "", "else", ":", "\n", "            ", "ax", ".", "imshow", "(", "self", ".", "image", ",", "extent", "=", "[", "0", ",", "x", ",", "0", ",", "y", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.principal_value": [[15, 26], ["None"], "function", ["None"], ["def", "principal_value", "(", "angle_in_radians", ":", "float", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Ensures the angle is within [-pi, pi).\n    :param angle_in_radians: Angle in radians.\n    :return: Scaled angle in radians.\n    \"\"\"", "\n", "\n", "interval_min", "=", "-", "math", ".", "pi", "\n", "two_pi", "=", "2", "*", "math", ".", "pi", "\n", "scaled_angle", "=", "(", "angle_in_radians", "-", "interval_min", ")", "%", "two_pi", "+", "interval_min", "\n", "return", "scaled_angle", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.compute_segment_sign": [[28, 56], ["None"], "function", ["None"], ["", "def", "compute_segment_sign", "(", "arcline_path", ":", "ArcLinePath", ")", "->", "Tuple", "[", "int", ",", "int", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Compute the sign of an arcline path based on its shape.\n    :param arcline_path: arcline path record.\n    :return: Tuple of signs for all three parts of the path. 0 if straight, -1 if right,\n        1 if left.\n    \"\"\"", "\n", "shape", "=", "arcline_path", "[", "'shape'", "]", "\n", "segment_sign", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "\n", "if", "shape", "in", "(", "\"LRL\"", ",", "\"LSL\"", ",", "\"LSR\"", ")", ":", "\n", "        ", "segment_sign", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "        ", "segment_sign", "[", "0", "]", "=", "-", "1", "\n", "\n", "", "if", "shape", "==", "\"RLR\"", ":", "\n", "        ", "segment_sign", "[", "1", "]", "=", "1", "\n", "", "elif", "shape", "==", "\"LRL\"", ":", "\n", "        ", "segment_sign", "[", "1", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "        ", "segment_sign", "[", "1", "]", "=", "0", "\n", "\n", "", "if", "shape", "in", "(", "\"LRL\"", ",", "\"LSL\"", ",", "\"RSL\"", ")", ":", "\n", "        ", "segment_sign", "[", "2", "]", "=", "1", "\n", "", "else", ":", "\n", "        ", "segment_sign", "[", "2", "]", "=", "-", "1", "\n", "\n", "", "return", "segment_sign", "[", "0", "]", ",", "segment_sign", "[", "1", "]", ",", "segment_sign", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.get_transformation_at_step": [[58, 77], ["math.cos", "math.sin", "abs"], "function", ["None"], ["", "def", "get_transformation_at_step", "(", "pose", ":", "Pose", ",", "\n", "step", ":", "float", ")", "->", "Pose", ":", "\n", "    ", "\"\"\"\n    Get the affine transformation at s meters along the path.\n    :param pose: Pose represented as tuple (x, y, yaw).\n    :param step: Length along the arcline path in range (0, length_of_arcline_path].\n    :return: Transformation represented as pose tuple.\n    \"\"\"", "\n", "\n", "theta", "=", "pose", "[", "2", "]", "*", "step", "\n", "ctheta", "=", "math", ".", "cos", "(", "theta", ")", "\n", "stheta", "=", "math", ".", "sin", "(", "theta", ")", "\n", "\n", "if", "abs", "(", "pose", "[", "2", "]", ")", "<", "1e-6", ":", "\n", "        ", "return", "pose", "[", "0", "]", "*", "step", ",", "pose", "[", "1", "]", "*", "step", ",", "theta", "\n", "", "else", ":", "\n", "        ", "new_x", "=", "(", "pose", "[", "1", "]", "*", "(", "ctheta", "-", "1.0", ")", "+", "pose", "[", "0", "]", "*", "stheta", ")", "/", "pose", "[", "2", "]", "\n", "new_y", "=", "(", "pose", "[", "0", "]", "*", "(", "1.0", "-", "ctheta", ")", "+", "pose", "[", "1", "]", "*", "stheta", ")", "/", "pose", "[", "2", "]", "\n", "return", "new_x", ",", "new_y", ",", "theta", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.apply_affine_transformation": [[79, 93], ["arcline_path_utils.principal_value", "math.cos", "math.sin", "math.sin", "math.cos"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.principal_value"], ["", "", "def", "apply_affine_transformation", "(", "pose", ":", "Pose", ",", "\n", "transformation", ":", "Pose", ")", "->", "Pose", ":", "\n", "    ", "\"\"\"\n    Apply affine transformation to pose.\n    :param pose: Starting pose.\n    :param transformation: Affine transformation represented as a pose tuple.\n    :return: Pose tuple - the result of applying the transformation to the starting pose.\n    \"\"\"", "\n", "\n", "new_x", "=", "math", ".", "cos", "(", "pose", "[", "2", "]", ")", "*", "transformation", "[", "0", "]", "-", "math", ".", "sin", "(", "pose", "[", "2", "]", ")", "*", "transformation", "[", "1", "]", "+", "pose", "[", "0", "]", "\n", "new_y", "=", "math", ".", "sin", "(", "pose", "[", "2", "]", ")", "*", "transformation", "[", "0", "]", "+", "math", ".", "cos", "(", "pose", "[", "2", "]", ")", "*", "transformation", "[", "1", "]", "+", "pose", "[", "1", "]", "\n", "new_yaw", "=", "principal_value", "(", "pose", "[", "2", "]", "+", "transformation", "[", "2", "]", ")", "\n", "\n", "return", "new_x", ",", "new_y", ",", "new_yaw", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils._get_lie_algebra": [[95, 107], ["None"], "function", ["None"], ["", "def", "_get_lie_algebra", "(", "segment_sign", ":", "Tuple", "[", "int", ",", "int", ",", "int", "]", ",", "\n", "radius", ":", "float", ")", "->", "List", "[", "Tuple", "[", "float", ",", "float", ",", "float", "]", "]", ":", "\n", "    ", "\"\"\"\n    Gets the Lie algebra for an arcline path.\n    :param segment_sign: Tuple of signs for each segment in the arcline path.\n    :param radius: Radius of curvature of the arcline path.\n    :return: List of lie algebra poses.\n    \"\"\"", "\n", "\n", "return", "[", "(", "1.0", ",", "0.0", ",", "segment_sign", "[", "0", "]", "/", "radius", ")", ",", "\n", "(", "1.0", ",", "0.0", ",", "segment_sign", "[", "1", "]", "/", "radius", ")", ",", "\n", "(", "1.0", ",", "0.0", ",", "segment_sign", "[", "2", "]", "/", "radius", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.pose_at_length": [[109, 143], ["sum", "max", "arcline_path_utils.compute_segment_sign", "arcline_path_utils._get_lie_algebra", "range", "min", "len", "arcline_path_utils.get_transformation_at_step", "arcline_path_utils.apply_affine_transformation", "arcline_path_utils.get_transformation_at_step", "arcline_path_utils.apply_affine_transformation"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.compute_segment_sign", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils._get_lie_algebra", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.get_transformation_at_step", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.apply_affine_transformation", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.get_transformation_at_step", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.apply_affine_transformation"], ["", "def", "pose_at_length", "(", "arcline_path", ":", "ArcLinePath", ",", "\n", "pos", ":", "float", ")", "->", "Tuple", "[", "float", ",", "float", ",", "float", "]", ":", "\n", "    ", "\"\"\"\n    Retrieves pose at l meters along the arcline path.\n    :param arcline_path: Arcline path object.\n    :param pos: Get the pose this many meters along the path.\n    :return: Pose tuple.\n    \"\"\"", "\n", "\n", "path_length", "=", "sum", "(", "arcline_path", "[", "'segment_length'", "]", ")", "\n", "\n", "assert", "1e-6", "<=", "pos", "\n", "\n", "pos", "=", "max", "(", "0.0", ",", "min", "(", "pos", ",", "path_length", ")", ")", "\n", "\n", "result", "=", "arcline_path", "[", "'start_pose'", "]", "\n", "segment_sign", "=", "compute_segment_sign", "(", "arcline_path", ")", "\n", "\n", "break_points", "=", "_get_lie_algebra", "(", "segment_sign", ",", "arcline_path", "[", "'radius'", "]", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "break_points", ")", ")", ":", "\n", "\n", "        ", "length", "=", "arcline_path", "[", "'segment_length'", "]", "[", "i", "]", "\n", "\n", "if", "pos", "<=", "length", ":", "\n", "            ", "transformation", "=", "get_transformation_at_step", "(", "break_points", "[", "i", "]", ",", "pos", ")", "\n", "result", "=", "apply_affine_transformation", "(", "result", ",", "transformation", ")", "\n", "break", "\n", "\n", "", "transformation", "=", "get_transformation_at_step", "(", "break_points", "[", "i", "]", ",", "length", ")", "\n", "result", "=", "apply_affine_transformation", "(", "result", ",", "transformation", ")", "\n", "pos", "-=", "length", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.discretize": [[145, 190], ["sum", "int", "arcline_path_utils.compute_segment_sign", "arcline_path_utils._get_lie_algebra", "range", "max", "arcline_path_utils.get_transformation_at_step", "arcline_path_utils.apply_affine_transformation", "discretization.append", "arcline_path_utils.pose_at_length", "math.ceil"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.compute_segment_sign", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils._get_lie_algebra", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.get_transformation_at_step", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.apply_affine_transformation", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.pose_at_length"], ["", "def", "discretize", "(", "arcline_path", ":", "ArcLinePath", ",", "\n", "resolution_meters", ":", "float", ")", "->", "List", "[", "Pose", "]", ":", "\n", "    ", "\"\"\"\n    Discretize an arcline path.\n    :param arcline_path: Arcline path record.\n    :param resolution_meters: How finely to discretize the path.\n    :return: List of pose tuples.\n    \"\"\"", "\n", "\n", "path_length", "=", "sum", "(", "arcline_path", "[", "'segment_length'", "]", ")", "\n", "radius", "=", "arcline_path", "[", "'radius'", "]", "\n", "\n", "n_points", "=", "int", "(", "max", "(", "math", ".", "ceil", "(", "path_length", "/", "resolution_meters", ")", "+", "1.5", ",", "2", ")", ")", "\n", "\n", "resolution_meters", "=", "path_length", "/", "(", "n_points", "-", "1", ")", "\n", "\n", "discretization", "=", "[", "]", "\n", "\n", "cumulative_length", "=", "[", "arcline_path", "[", "'segment_length'", "]", "[", "0", "]", ",", "\n", "arcline_path", "[", "'segment_length'", "]", "[", "0", "]", "+", "arcline_path", "[", "'segment_length'", "]", "[", "1", "]", ",", "\n", "path_length", "+", "resolution_meters", "]", "\n", "\n", "segment_sign", "=", "compute_segment_sign", "(", "arcline_path", ")", "\n", "\n", "poses", "=", "_get_lie_algebra", "(", "segment_sign", ",", "radius", ")", "\n", "\n", "temp_pose", "=", "arcline_path", "[", "'start_pose'", "]", "\n", "\n", "g_i", "=", "0", "\n", "g_s", "=", "0.0", "\n", "\n", "for", "step", "in", "range", "(", "n_points", ")", ":", "\n", "\n", "        ", "step_along_path", "=", "step", "*", "resolution_meters", "\n", "\n", "if", "step_along_path", ">", "cumulative_length", "[", "g_i", "]", ":", "\n", "            ", "temp_pose", "=", "pose_at_length", "(", "arcline_path", ",", "step_along_path", ")", "\n", "g_s", "=", "step_along_path", "\n", "g_i", "+=", "1", "\n", "\n", "", "transformation", "=", "get_transformation_at_step", "(", "poses", "[", "g_i", "]", ",", "step_along_path", "-", "g_s", ")", "\n", "new_pose", "=", "apply_affine_transformation", "(", "temp_pose", ",", "transformation", ")", "\n", "discretization", ".", "append", "(", "new_pose", ")", "\n", "\n", "", "return", "discretization", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.discretize_lane": [[192, 208], ["arcline_path_utils.discretize", "pose_list.append"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.discretize"], ["", "def", "discretize_lane", "(", "lane", ":", "List", "[", "ArcLinePath", "]", ",", "\n", "resolution_meters", ":", "float", ")", "->", "List", "[", "Pose", "]", ":", "\n", "    ", "\"\"\"\n    Discretizes a lane and returns list of all the poses alone the lane.\n    :param lane: Lanes are represented as a list of arcline paths.\n    :param resolution_meters: How finely to discretize the lane. Smaller values ensure curved\n        lanes are properly represented.\n    :return: List of pose tuples along the lane.\n    \"\"\"", "\n", "\n", "pose_list", "=", "[", "]", "\n", "for", "path", "in", "lane", ":", "\n", "        ", "poses", "=", "discretize", "(", "path", ",", "resolution_meters", ")", "\n", "for", "pose", "in", "poses", ":", "\n", "            ", "pose_list", ".", "append", "(", "pose", ")", "\n", "", "", "return", "pose_list", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.length_of_lane": [[210, 219], ["sum", "sum"], "function", ["None"], ["", "def", "length_of_lane", "(", "lane", ":", "List", "[", "ArcLinePath", "]", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Calculates the length of a lane in meters.\n    :param lane: Lane.\n    :return: Length of lane in meters.\n    \"\"\"", "\n", "\n", "# Meters", "\n", "return", "sum", "(", "sum", "(", "path", "[", "'segment_length'", "]", ")", "for", "path", "in", "lane", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.project_pose_to_lane": [[221, 240], ["arcline_path_utils.discretize_lane", "numpy.linalg.norm().argmin", "numpy.array", "numpy.linalg.norm"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.discretize_lane"], ["", "def", "project_pose_to_lane", "(", "pose", ":", "Pose", ",", "lane", ":", "List", "[", "ArcLinePath", "]", ",", "resolution_meters", ":", "float", "=", "0.5", ")", "->", "Tuple", "[", "Pose", ",", "float", "]", ":", "\n", "    ", "\"\"\"\n    Find the closest pose on a lane to a query pose and additionally return the\n    distance along the lane for this pose. Note that this function does\n    not take the heading of the query pose into account.\n    :param pose: Query pose.\n    :param lane: Will find the closest pose on this lane.\n    :param resolution_meters: How finely to discretize the lane.\n    :return: Tuple of the closest pose and the distance along the lane\n    \"\"\"", "\n", "\n", "discretized_lane", "=", "discretize_lane", "(", "lane", ",", "resolution_meters", "=", "resolution_meters", ")", "\n", "\n", "xy_points", "=", "np", ".", "array", "(", "discretized_lane", ")", "[", ":", ",", ":", "2", "]", "\n", "closest_pose_index", "=", "np", ".", "linalg", ".", "norm", "(", "xy_points", "-", "pose", "[", ":", "2", "]", ",", "axis", "=", "1", ")", ".", "argmin", "(", ")", "\n", "\n", "closest_pose", "=", "discretized_lane", "[", "closest_pose_index", "]", "\n", "distance_along_lane", "=", "closest_pose_index", "*", "0.5", "\n", "return", "closest_pose", ",", "distance_along_lane", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils._find_index": [[242, 254], ["len", "min", "enumerate"], "function", ["None"], ["", "def", "_find_index", "(", "distance_along_lane", ":", "float", ",", "lengths", ":", "List", "[", "float", "]", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Helper function for finding of path along lane corresponding to the distance_along_lane.\n    :param distance_along_lane: Distance along the lane (in meters).\n    :param lengths: Cumulative distance at each end point along the paths in the lane.\n    :return: Index of path.\n    \"\"\"", "\n", "\n", "if", "len", "(", "lengths", ")", "==", "1", ":", "\n", "        ", "return", "0", "\n", "", "else", ":", "\n", "        ", "return", "min", "(", "index", "for", "index", ",", "length", "in", "enumerate", "(", "lengths", ")", "if", "distance_along_lane", "<=", "length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.get_curvature_at_distance_along_lane": [[256, 284], ["numpy.cumsum", "arcline_path_utils._find_index", "arcline_path_utils._find_index", "numpy.cumsum", "sum"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils._find_index", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils._find_index"], ["", "", "def", "get_curvature_at_distance_along_lane", "(", "distance_along_lane", ":", "float", ",", "lane", ":", "List", "[", "ArcLinePath", "]", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Computes the unsigned curvature (1 / meters) at a distance along a lane.\n    :param distance_along_lane: Distance along the lane to calculate the curvature at.\n    :param lane: Lane to query.\n    :return: Curvature, always non negative.\n    \"\"\"", "\n", "\n", "total_length_at_segments", "=", "np", ".", "cumsum", "(", "[", "sum", "(", "path", "[", "'segment_length'", "]", ")", "for", "path", "in", "lane", "]", ")", "\n", "segment_index", "=", "_find_index", "(", "distance_along_lane", ",", "total_length_at_segments", ")", "\n", "\n", "path", "=", "lane", "[", "segment_index", "]", "\n", "path_length", "=", "path", "[", "'segment_length'", "]", "\n", "\n", "if", "segment_index", ">", "0", ":", "\n", "        ", "distance_along_path", "=", "distance_along_lane", "-", "total_length_at_segments", "[", "segment_index", "-", "1", "]", "\n", "", "else", ":", "\n", "        ", "distance_along_path", "=", "distance_along_lane", "\n", "\n", "", "segment_index", "=", "_find_index", "(", "distance_along_path", ",", "np", ".", "cumsum", "(", "path_length", ")", ")", "\n", "\n", "segment_shape", "=", "path", "[", "'shape'", "]", "[", "segment_index", "]", "\n", "\n", "# Straight lanes have no curvature", "\n", "if", "segment_shape", "==", "'S'", ":", "\n", "        ", "return", "0", "\n", "", "else", ":", "\n", "        ", "return", "1", "/", "path", "[", "'radius'", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.__init__": [[61, 109], ["os.path.join", "map_api.NuScenesMap._load_layers", "map_api.NuScenesMap._make_token2ind", "map_api.NuScenesMap._make_shortcuts", "map_api.NuScenesMapExplorer", "open", "json.load", "Exception"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layers", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._make_token2ind", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._make_shortcuts"], ["def", "__init__", "(", "self", ",", "\n", "dataroot", ":", "str", "=", "'/data/sets/nuscenes'", ",", "\n", "map_name", ":", "str", "=", "'singapore-onenorth'", ")", ":", "\n", "        ", "\"\"\"\n        Loads the layers, create reverse indices and shortcuts, initializes the explorer class.\n        :param dataroot: Path to the layers in the form of a .json file.\n        :param map_name: Which map out of `singapore-onenorth`, `singepore-hollandvillage`, `singapore-queenstown`,\n        `boston-seaport` that we want to load.\n        \"\"\"", "\n", "assert", "map_name", "in", "locations", ",", "'Error: Unknown map name %s!'", "%", "map_name", "\n", "\n", "self", ".", "dataroot", "=", "dataroot", "\n", "self", ".", "map_name", "=", "map_name", "\n", "\n", "self", ".", "geometric_layers", "=", "[", "'polygon'", ",", "'line'", ",", "'node'", "]", "\n", "\n", "# These are the non-geometric layers which have polygons as the geometric descriptors.", "\n", "self", ".", "non_geometric_polygon_layers", "=", "[", "'drivable_area'", ",", "'road_segment'", ",", "'road_block'", ",", "'lane'", ",", "'ped_crossing'", ",", "\n", "'walkway'", ",", "'stop_line'", ",", "'carpark_area'", "]", "\n", "\n", "# We want to be able to search for lane connectors, but not render them.", "\n", "self", ".", "lookup_polygon_layers", "=", "self", ".", "non_geometric_polygon_layers", "+", "[", "'lane_connector'", "]", "\n", "\n", "# These are the non-geometric layers which have line strings as the geometric descriptors.", "\n", "self", ".", "non_geometric_line_layers", "=", "[", "'road_divider'", ",", "'lane_divider'", ",", "'traffic_light'", "]", "\n", "self", ".", "non_geometric_layers", "=", "self", ".", "non_geometric_polygon_layers", "+", "self", ".", "non_geometric_line_layers", "\n", "self", ".", "layer_names", "=", "self", ".", "geometric_layers", "+", "self", ".", "lookup_polygon_layers", "+", "self", ".", "non_geometric_line_layers", "\n", "\n", "# Load the selected map.", "\n", "self", ".", "json_fname", "=", "os", ".", "path", ".", "join", "(", "self", ".", "dataroot", ",", "'maps'", ",", "'expansion'", ",", "'{}.json'", ".", "format", "(", "self", ".", "map_name", ")", ")", "\n", "with", "open", "(", "self", ".", "json_fname", ",", "'r'", ")", "as", "fh", ":", "\n", "            ", "self", ".", "json_obj", "=", "json", ".", "load", "(", "fh", ")", "\n", "\n", "# Parse the map version and print an error for deprecated maps.", "\n", "", "if", "'version'", "in", "self", ".", "json_obj", ":", "\n", "            ", "self", ".", "version", "=", "self", ".", "json_obj", "[", "'version'", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "version", "=", "'1.0'", "\n", "", "if", "self", ".", "version", "<", "'1.3'", ":", "\n", "            ", "raise", "Exception", "(", "'Error: You are using an outdated map version (%s)! '", "\n", "'Please go to https://www.nuscenes.org/download to download the latest map!'", ")", "\n", "\n", "", "self", ".", "canvas_edge", "=", "self", ".", "json_obj", "[", "'canvas_edge'", "]", "\n", "self", ".", "_load_layers", "(", ")", "\n", "self", ".", "_make_token2ind", "(", ")", "\n", "self", ".", "_make_shortcuts", "(", ")", "\n", "\n", "self", ".", "explorer", "=", "NuScenesMapExplorer", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer": [[110, 117], ["None"], "methods", ["None"], ["", "def", "_load_layer", "(", "self", ",", "layer_name", ":", "str", ")", "->", "List", "[", "dict", "]", ":", "\n", "        ", "\"\"\"\n        Returns a list of records corresponding to the layer name.\n        :param layer_name: Name of the layer that will be loaded.\n        :return: A list of records corresponding to a layer.\n        \"\"\"", "\n", "return", "self", ".", "json_obj", "[", "layer_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer_dict": [[118, 125], ["None"], "methods", ["None"], ["", "def", "_load_layer_dict", "(", "self", ",", "layer_name", ":", "str", ")", "->", "Dict", "[", "str", ",", "Union", "[", "dict", ",", "list", "]", "]", ":", "\n", "        ", "\"\"\"\n        Returns a dict of records corresponding to the layer name.\n        :param layer_name: Name of the layer that will be loaded.\n        :return: A dict of records corresponding to a layer.\n        \"\"\"", "\n", "return", "self", ".", "json_obj", "[", "layer_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layers": [[126, 148], ["map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer", "map_api.NuScenesMap._load_layer_dict", "map_api.NuScenesMap._load_layer_dict", "map_api.NuScenesMap._load_layer"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer_dict", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer_dict", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._load_layer"], ["", "def", "_load_layers", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\" Loads each available layer. \"\"\"", "\n", "\n", "# Explicit assignment of layers are necessary to help the IDE determine valid class members.", "\n", "self", ".", "polygon", "=", "self", ".", "_load_layer", "(", "'polygon'", ")", "\n", "self", ".", "line", "=", "self", ".", "_load_layer", "(", "'line'", ")", "\n", "self", ".", "node", "=", "self", ".", "_load_layer", "(", "'node'", ")", "\n", "self", ".", "drivable_area", "=", "self", ".", "_load_layer", "(", "'drivable_area'", ")", "\n", "self", ".", "road_segment", "=", "self", ".", "_load_layer", "(", "'road_segment'", ")", "\n", "self", ".", "road_block", "=", "self", ".", "_load_layer", "(", "'road_block'", ")", "\n", "self", ".", "lane", "=", "self", ".", "_load_layer", "(", "'lane'", ")", "\n", "self", ".", "ped_crossing", "=", "self", ".", "_load_layer", "(", "'ped_crossing'", ")", "\n", "self", ".", "walkway", "=", "self", ".", "_load_layer", "(", "'walkway'", ")", "\n", "self", ".", "stop_line", "=", "self", ".", "_load_layer", "(", "'stop_line'", ")", "\n", "self", ".", "carpark_area", "=", "self", ".", "_load_layer", "(", "'carpark_area'", ")", "\n", "self", ".", "road_divider", "=", "self", ".", "_load_layer", "(", "'road_divider'", ")", "\n", "self", ".", "lane_divider", "=", "self", ".", "_load_layer", "(", "'lane_divider'", ")", "\n", "self", ".", "traffic_light", "=", "self", ".", "_load_layer", "(", "'traffic_light'", ")", "\n", "\n", "self", ".", "arcline_path_3", ":", "Dict", "[", "str", ",", "List", "[", "dict", "]", "]", "=", "self", ".", "_load_layer_dict", "(", "'arcline_path_3'", ")", "\n", "self", ".", "connectivity", ":", "Dict", "[", "str", ",", "dict", "]", "=", "self", ".", "_load_layer_dict", "(", "'connectivity'", ")", "\n", "self", ".", "lane_connector", "=", "self", ".", "_load_layer", "(", "'lane_connector'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._make_token2ind": [[149, 157], ["dict", "dict", "enumerate", "getattr"], "methods", ["None"], ["", "def", "_make_token2ind", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\" Store the mapping from token to layer index for each layer. \"\"\"", "\n", "self", ".", "_token2ind", "=", "dict", "(", ")", "\n", "for", "layer_name", "in", "self", ".", "layer_names", ":", "\n", "            ", "self", ".", "_token2ind", "[", "layer_name", "]", "=", "dict", "(", ")", "\n", "\n", "for", "ind", ",", "member", "in", "enumerate", "(", "getattr", "(", "self", ",", "layer_name", ")", ")", ":", "\n", "                ", "self", ".", "_token2ind", "[", "layer_name", "]", "[", "member", "[", "'token'", "]", "]", "=", "ind", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._make_shortcuts": [[158, 187], ["map_api.NuScenesMap._get_stop_line_cue", "map_api.NuScenesMap.get", "map_api.NuScenesMap.get", "map_api.NuScenesMap.get", "map_api.NuScenesMap.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._get_stop_line_cue", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "", "def", "_make_shortcuts", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\" Makes the record shortcuts. \"\"\"", "\n", "\n", "# Makes a shortcut between non geometric records to their nodes.", "\n", "for", "layer_name", "in", "self", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "if", "layer_name", "==", "'drivable_area'", ":", "# Drivable area has more than one geometric representation.", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "for", "record", "in", "self", ".", "__dict__", "[", "layer_name", "]", ":", "\n", "                    ", "polygon_obj", "=", "self", ".", "get", "(", "'polygon'", ",", "record", "[", "'polygon_token'", "]", ")", "\n", "record", "[", "'exterior_node_tokens'", "]", "=", "polygon_obj", "[", "'exterior_node_tokens'", "]", "\n", "record", "[", "'holes'", "]", "=", "polygon_obj", "[", "'holes'", "]", "\n", "\n", "", "", "", "for", "layer_name", "in", "self", ".", "non_geometric_line_layers", ":", "\n", "            ", "for", "record", "in", "self", ".", "__dict__", "[", "layer_name", "]", ":", "\n", "                ", "record", "[", "'node_tokens'", "]", "=", "self", ".", "get", "(", "'line'", ",", "record", "[", "'line_token'", "]", ")", "[", "'node_tokens'", "]", "\n", "\n", "# Makes a shortcut between stop lines to their cues, there's different cues for different types of stop line.", "\n", "# Refer to `_get_stop_line_cue()` for details.", "\n", "", "", "for", "record", "in", "self", ".", "stop_line", ":", "\n", "            ", "cue", "=", "self", ".", "_get_stop_line_cue", "(", "record", ")", "\n", "record", "[", "'cue'", "]", "=", "cue", "\n", "\n", "# Makes a shortcut between lanes to their lane divider segment nodes.", "\n", "", "for", "record", "in", "self", ".", "lane", ":", "\n", "            ", "record", "[", "'left_lane_divider_segment_nodes'", "]", "=", "[", "self", ".", "get", "(", "'node'", ",", "segment", "[", "'node_token'", "]", ")", "for", "segment", "in", "\n", "record", "[", "'left_lane_divider_segments'", "]", "]", "\n", "record", "[", "'right_lane_divider_segment_nodes'", "]", "=", "[", "self", ".", "get", "(", "'node'", ",", "segment", "[", "'node_token'", "]", ")", "for", "segment", "in", "\n", "record", "[", "'right_lane_divider_segments'", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._get_stop_line_cue": [[188, 200], ["map_api.NuScenesMap.get", "map_api.NuScenesMap.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "_get_stop_line_cue", "(", "self", ",", "stop_line_record", ":", "dict", ")", "->", "List", "[", "dict", "]", ":", "\n", "        ", "\"\"\"\n        Get the different cues for different types of stop lines.\n        :param stop_line_record: A single stop line record.\n        :return: The cue for that stop line.\n        \"\"\"", "\n", "if", "stop_line_record", "[", "'stop_line_type'", "]", "in", "[", "'PED_CROSSING'", ",", "'TURN_STOP'", "]", ":", "\n", "            ", "return", "[", "self", ".", "get", "(", "'ped_crossing'", ",", "token", ")", "for", "token", "in", "stop_line_record", "[", "'ped_crossing_tokens'", "]", "]", "\n", "", "elif", "stop_line_record", "[", "'stop_line_type'", "]", "in", "[", "'STOP_SIGN'", ",", "'YIELD'", "]", ":", "\n", "            ", "return", "[", "]", "\n", "", "elif", "stop_line_record", "[", "'stop_line_type'", "]", "==", "'TRAFFIC_LIGHT'", ":", "\n", "            ", "return", "[", "self", ".", "get", "(", "'traffic_light'", ",", "token", ")", "for", "token", "in", "stop_line_record", "[", "'traffic_light_tokens'", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get": [[201, 211], ["getattr", "map_api.NuScenesMap.getind"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.getind"], ["", "", "def", "get", "(", "self", ",", "layer_name", ":", "str", ",", "token", ":", "str", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Returns a record from the layer in constant runtime.\n        :param layer_name: Name of the layer that we are interested in.\n        :param token: Token of the record.\n        :return: A single layer record.\n        \"\"\"", "\n", "assert", "layer_name", "in", "self", ".", "layer_names", ",", "\"Layer {} not found\"", ".", "format", "(", "layer_name", ")", "\n", "\n", "return", "getattr", "(", "self", ",", "layer_name", ")", "[", "self", ".", "getind", "(", "layer_name", ",", "token", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.getind": [[212, 220], ["None"], "methods", ["None"], ["", "def", "getind", "(", "self", ",", "layer_name", ":", "str", ",", "token", ":", "str", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        This returns the index of the record in a layer in constant runtime.\n        :param layer_name: Name of the layer we are interested in.\n        :param token: Token of the record.\n        :return: The index of the record in the layer, layer is an array.\n        \"\"\"", "\n", "return", "self", ".", "_token2ind", "[", "layer_name", "]", "[", "token", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.render_record": [[221, 241], ["map_api.NuScenesMap.explorer.render_record"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_record"], ["", "def", "render_record", "(", "self", ",", "\n", "layer_name", ":", "str", ",", "\n", "token", ":", "str", ",", "\n", "alpha", ":", "float", "=", "0.5", ",", "\n", "figsize", ":", "Tuple", "[", "float", ",", "float", "]", "=", "None", ",", "\n", "other_layers", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Tuple", "[", "Axes", ",", "Axes", "]", "]", ":", "\n", "        ", "\"\"\"\n         Render a single map record. By default will also render 3 layers which are `drivable_area`, `lane`,\n         and `walkway` unless specified by `other_layers`.\n         :param layer_name: Name of the layer that we are interested in.\n         :param token: Token of the record that you want to render.\n         :param alpha: The opacity of each layer that gets rendered.\n         :param figsize: Size of the whole figure.\n         :param other_layers: What other layers to render aside from the one specified in `layer_name`.\n         :param bitmap: Optional BitMap object to render below the other map layers.\n         :return: The matplotlib figure and axes of the rendered layers.\n         \"\"\"", "\n", "return", "self", ".", "explorer", ".", "render_record", "(", "layer_name", ",", "token", ",", "alpha", ",", "\n", "figsize", "=", "figsize", ",", "other_layers", "=", "other_layers", ",", "bitmap", "=", "bitmap", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.render_layers": [[242, 259], ["map_api.NuScenesMap.explorer.render_layers"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_layers"], ["", "def", "render_layers", "(", "self", ",", "\n", "layer_names", ":", "List", "[", "str", "]", ",", "\n", "alpha", ":", "float", "=", "0.5", ",", "\n", "figsize", ":", "Union", "[", "None", ",", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "tokens", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Render a list of layer names.\n        :param layer_names: A list of layer names.\n        :param alpha: The opacity of each layer that gets rendered.\n        :param figsize: Size of the whole figure.\n        :param tokens: Optional list of tokens to render. None means all tokens are rendered.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        :return: The matplotlib figure and axes of the rendered layers.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "render_layers", "(", "layer_names", ",", "alpha", ",", "\n", "figsize", "=", "figsize", ",", "tokens", "=", "tokens", ",", "bitmap", "=", "bitmap", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.render_map_patch": [[260, 282], ["map_api.NuScenesMap.explorer.render_map_patch"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_map_patch"], ["", "def", "render_map_patch", "(", "self", ",", "\n", "box_coords", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "alpha", ":", "float", "=", "0.5", ",", "\n", "figsize", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "15", ",", "15", ")", ",", "\n", "render_egoposes_range", ":", "bool", "=", "True", ",", "\n", "render_legend", ":", "bool", "=", "True", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Renders a rectangular patch specified by `box_coords`. By default renders all layers.\n        :param box_coords: The rectangular patch coordinates (x_min, y_min, x_max, y_max).\n        :param layer_names: All the non geometric layers that we want to render.\n        :param alpha: The opacity of each layer.\n        :param figsize: Size of the whole figure.\n        :param render_egoposes_range: Whether to render a rectangle around all ego poses.\n        :param render_legend: Whether to render the legend of map layers.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        :return: The matplotlib figure and axes of the rendered layers.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "render_map_patch", "(", "box_coords", ",", "layer_names", "=", "layer_names", ",", "alpha", "=", "alpha", ",", "figsize", "=", "figsize", ",", "\n", "render_egoposes_range", "=", "render_egoposes_range", ",", "\n", "render_legend", "=", "render_legend", ",", "bitmap", "=", "bitmap", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.render_map_in_image": [[283, 316], ["map_api.NuScenesMap.explorer.render_map_in_image"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_map_in_image"], ["", "def", "render_map_in_image", "(", "self", ",", "\n", "nusc", ":", "NuScenes", ",", "\n", "sample_token", ":", "str", ",", "\n", "camera_channel", ":", "str", "=", "'CAM_FRONT'", ",", "\n", "alpha", ":", "float", "=", "0.3", ",", "\n", "patch_radius", ":", "float", "=", "10000", ",", "\n", "min_polygon_area", ":", "float", "=", "1000", ",", "\n", "render_behind_cam", ":", "bool", "=", "True", ",", "\n", "render_outside_im", ":", "bool", "=", "True", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "out_path", ":", "str", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Render a nuScenes camera image and overlay the polygons for the specified map layers.\n        Note that the projections are not always accurate as the localization is in 2d.\n        :param nusc: The NuScenes instance to load the image from.\n        :param sample_token: The image's corresponding sample_token.\n        :param camera_channel: Camera channel name, e.g. 'CAM_FRONT'.\n        :param alpha: The transparency value of the layers to render in [0, 1].\n        :param patch_radius: The radius in meters around the ego car in which to select map records.\n        :param min_polygon_area: Minimum area a polygon needs to have to be rendered.\n        :param render_behind_cam: Whether to render polygons where any point is behind the camera.\n        :param render_outside_im: Whether to render polygons where any point is outside the image.\n        :param layer_names: The names of the layers to render, e.g. ['lane'].\n            If set to None, the recommended setting will be used.\n        :param verbose: Whether to print to stdout.\n        :param out_path: Optional path to save the rendered figure to disk.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "render_map_in_image", "(", "\n", "nusc", ",", "sample_token", ",", "camera_channel", "=", "camera_channel", ",", "alpha", "=", "alpha", ",", "\n", "patch_radius", "=", "patch_radius", ",", "min_polygon_area", "=", "min_polygon_area", ",", "\n", "render_behind_cam", "=", "render_behind_cam", ",", "render_outside_im", "=", "render_outside_im", ",", "\n", "layer_names", "=", "layer_names", ",", "verbose", "=", "verbose", ",", "out_path", "=", "out_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.render_egoposes_on_fancy_map": [[317, 344], ["map_api.NuScenesMap.explorer.render_egoposes_on_fancy_map"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_egoposes_on_fancy_map"], ["", "def", "render_egoposes_on_fancy_map", "(", "self", ",", "\n", "nusc", ":", "NuScenes", ",", "\n", "scene_tokens", ":", "List", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "render_egoposes", ":", "bool", "=", "True", ",", "\n", "render_egoposes_range", ":", "bool", "=", "True", ",", "\n", "render_legend", ":", "bool", "=", "True", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Renders each ego pose of a list of scenes on the map (around 40 poses per scene).\n        This method is heavily inspired by NuScenes.render_egoposes_on_map(), but uses the map expansion pack maps.\n        :param nusc: The NuScenes instance to load the ego poses from.\n        :param scene_tokens: Optional list of scene tokens corresponding to the current map location.\n        :param verbose: Whether to show status messages and progress bar.\n        :param out_path: Optional path to save the rendered figure to disk.\n        :param render_egoposes: Whether to render ego poses.\n        :param render_egoposes_range: Whether to render a rectangle around all ego poses.\n        :param render_legend: Whether to render the legend of map layers.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        :return: <np.float32: n, 2>. Returns a matrix with n ego poses in global map coordinates.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "render_egoposes_on_fancy_map", "(", "nusc", ",", "scene_tokens", "=", "scene_tokens", ",", "\n", "verbose", "=", "verbose", ",", "out_path", "=", "out_path", ",", "\n", "render_egoposes", "=", "render_egoposes", ",", "\n", "render_egoposes_range", "=", "render_egoposes_range", ",", "\n", "render_legend", "=", "render_legend", ",", "bitmap", "=", "bitmap", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.render_centerlines": [[345, 357], ["map_api.NuScenesMap.explorer.render_centerlines"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_centerlines"], ["", "def", "render_centerlines", "(", "self", ",", "\n", "resolution_meters", ":", "float", "=", "0.5", ",", "\n", "figsize", ":", "Union", "[", "None", ",", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Render the centerlines of all lanes and lane connectors.\n        :param resolution_meters: How finely to discretize the lane. Smaller values ensure curved\n            lanes are properly represented.\n        :param figsize: Size of the figure.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "render_centerlines", "(", "resolution_meters", "=", "resolution_meters", ",", "figsize", "=", "figsize", ",", "bitmap", "=", "bitmap", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.render_map_mask": [[358, 378], ["map_api.NuScenesMap.explorer.render_map_mask"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_map_mask"], ["", "def", "render_map_mask", "(", "self", ",", "\n", "patch_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "patch_angle", ":", "float", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "canvas_size", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "100", ",", "100", ")", ",", "\n", "figsize", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "15", ",", "15", ")", ",", "\n", "n_row", ":", "int", "=", "2", ")", "->", "Tuple", "[", "Figure", ",", "List", "[", "Axes", "]", "]", ":", "\n", "        ", "\"\"\"\n        Render map mask of the patch specified by patch_box and patch_angle.\n        :param patch_box: Patch box defined as [x_center, y_center, height, width].\n        :param patch_angle: Patch orientation in degrees.\n        :param layer_names: A list of layer names to be returned.\n        :param canvas_size: Size of the output mask (h, w).\n        :param figsize: Size of the figure.\n        :param n_row: Number of rows with plots.\n        :return: The matplotlib figure and a list of axes of the rendered layers.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "render_map_mask", "(", "patch_box", ",", "patch_angle", ",", "\n", "layer_names", "=", "layer_names", ",", "canvas_size", "=", "canvas_size", ",", "\n", "figsize", "=", "figsize", ",", "n_row", "=", "n_row", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_map_mask": [[379, 393], ["map_api.NuScenesMap.explorer.get_map_mask"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_map_mask"], ["", "def", "get_map_mask", "(", "self", ",", "\n", "patch_box", ":", "Optional", "[", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", "]", ",", "\n", "patch_angle", ":", "float", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "canvas_size", ":", "Optional", "[", "Tuple", "[", "int", ",", "int", "]", "]", "=", "(", "100", ",", "100", ")", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Return list of map mask layers of the specified patch.\n        :param patch_box: Patch box defined as [x_center, y_center, height, width]. If None, this plots the entire map.\n        :param patch_angle: Patch orientation in degrees. North-facing corresponds to 0.\n        :param layer_names: A list of layer names to be extracted, or None for all non-geometric layers.\n        :param canvas_size: Size of the output mask (h, w). If None, we use the default resolution of 10px/m.\n        :return: Stacked numpy array of size [c x h x w] with c channels and the same width/height as the canvas.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "get_map_mask", "(", "patch_box", ",", "patch_angle", ",", "layer_names", "=", "layer_names", ",", "canvas_size", "=", "canvas_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_map_geom": [[394, 408], ["map_api.NuScenesMap.explorer.get_map_geom"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_map_geom"], ["", "def", "get_map_geom", "(", "self", ",", "\n", "patch_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "patch_angle", ":", "float", ",", "\n", "layer_names", ":", "List", "[", "str", "]", ")", "->", "List", "[", "Tuple", "[", "str", ",", "List", "[", "Geometry", "]", "]", "]", ":", "\n", "        ", "\"\"\"\n        Returns a list of geometries in the specified patch_box.\n        These are unscaled, but aligned with the patch angle.\n        :param patch_box: Patch box defined as [x_center, y_center, height, width].\n        :param patch_angle: Patch orientation in degrees.\n                            North-facing corresponds to 0.\n        :param layer_names: A list of layer names to be extracted, or None for all non-geometric layers.\n        :return: List of layer names and their corresponding geometries.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "get_map_geom", "(", "patch_box", ",", "patch_angle", ",", "layer_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_records_in_patch": [[409, 423], ["map_api.NuScenesMap.explorer.get_records_in_patch"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_records_in_patch"], ["", "def", "get_records_in_patch", "(", "self", ",", "\n", "box_coords", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "mode", ":", "str", "=", "'intersect'", ")", "->", "Dict", "[", "str", ",", "List", "[", "str", "]", "]", ":", "\n", "        ", "\"\"\"\n        Get all the record token that intersects or is within a particular rectangular patch.\n        :param box_coords: The rectangular patch coordinates (x_min, y_min, x_max, y_max).\n        :param layer_names: Names of the layers that we want to retrieve in a particular patch. By default will always\n        look at the all non geometric layers.\n        :param mode: \"intersect\" will return all non geometric records that intersects the patch, \"within\" will return\n        all non geometric records that are within the patch.\n        :return: Dictionary of layer_name - tokens pairs.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "get_records_in_patch", "(", "box_coords", ",", "layer_names", "=", "layer_names", ",", "mode", "=", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.is_record_in_patch": [[424, 439], ["map_api.NuScenesMap.explorer.is_record_in_patch"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.is_record_in_patch"], ["", "def", "is_record_in_patch", "(", "self", ",", "\n", "layer_name", ":", "str", ",", "\n", "token", ":", "str", ",", "\n", "box_coords", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "mode", ":", "str", "=", "'intersect'", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Query whether a particular record is in a rectangular patch\n        :param layer_name: The layer name of the record.\n        :param token: The record token.\n        :param box_coords: The rectangular patch coordinates (x_min, y_min, x_max, y_max).\n        :param mode: \"intersect\" means it will return True if the geometric object intersects the patch, \"within\" will\n                     return True if the geometric object is within the patch.\n        :return: Boolean value on whether a particular record intersects or within a particular patch.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "is_record_in_patch", "(", "layer_name", ",", "token", ",", "box_coords", ",", "mode", "=", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.layers_on_point": [[440, 449], ["map_api.NuScenesMap.explorer.layers_on_point"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.layers_on_point"], ["", "def", "layers_on_point", "(", "self", ",", "x", ":", "float", ",", "y", ":", "float", ",", "layer_names", ":", "List", "[", "str", "]", "=", "None", ")", "->", "Dict", "[", "str", ",", "str", "]", ":", "\n", "        ", "\"\"\"\n        Returns all the polygonal layers that a particular point is on.\n        :param x: x coordinate of the point of interest.\n        :param y: y coordinate of the point of interest.\n        :param layer_names: The names of the layers to search for.\n        :return: All the polygonal layers that a particular point is on. {<layer name>: <list of tokens>}\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "layers_on_point", "(", "x", ",", "y", ",", "layer_names", "=", "layer_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.record_on_point": [[450, 459], ["map_api.NuScenesMap.explorer.record_on_point"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.record_on_point"], ["", "def", "record_on_point", "(", "self", ",", "x", ":", "float", ",", "y", ":", "float", ",", "layer_name", ":", "str", ")", "->", "str", ":", "\n", "        ", "\"\"\"\n        Query what record of a layer a particular point is on.\n        :param x: x coordinate of the point of interest.\n        :param y: y coordinate of the point of interest.\n        :param layer_name: The non geometric polygonal layer name that we are interested in.\n        :return: The first token of a layer a particular point is on or '' if no layer is found.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "record_on_point", "(", "x", ",", "y", ",", "layer_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.extract_polygon": [[460, 467], ["map_api.NuScenesMap.explorer.extract_polygon"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon"], ["", "def", "extract_polygon", "(", "self", ",", "polygon_token", ":", "str", ")", "->", "Polygon", ":", "\n", "        ", "\"\"\"\n        Construct a shapely Polygon object out of a polygon token.\n        :param polygon_token: The token of the polygon record.\n        :return: The polygon wrapped in a shapely Polygon object.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "extract_polygon", "(", "polygon_token", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.extract_line": [[468, 475], ["map_api.NuScenesMap.explorer.extract_line"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_line"], ["", "def", "extract_line", "(", "self", ",", "line_token", ":", "str", ")", "->", "LineString", ":", "\n", "        ", "\"\"\"\n        Construct a shapely LineString object out of a line token.\n        :param line_token: The token of the line record.\n        :return: The line wrapped in a LineString object.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "extract_line", "(", "line_token", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_bounds": [[476, 484], ["map_api.NuScenesMap.explorer.get_bounds"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_bounds"], ["", "def", "get_bounds", "(", "self", ",", "layer_name", ":", "str", ",", "token", ":", "str", ")", "->", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ":", "\n", "        ", "\"\"\"\n        Get the bounds of the geometric object that corresponds to a non geometric record.\n        :param layer_name: Name of the layer that we are interested in.\n        :param token: Token of the record.\n        :return: min_x, min_y, max_x, max_y of of the line representation.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "get_bounds", "(", "layer_name", ",", "token", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_records_in_radius": [[485, 501], ["map_api.NuScenesMap.explorer.get_records_in_patch"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_records_in_patch"], ["", "def", "get_records_in_radius", "(", "self", ",", "x", ":", "float", ",", "y", ":", "float", ",", "radius", ":", "float", ",", "\n", "layer_names", ":", "List", "[", "str", "]", ",", "mode", ":", "str", "=", "'intersect'", ")", "->", "Dict", "[", "str", ",", "List", "[", "str", "]", "]", ":", "\n", "        ", "\"\"\"\n        Get all the record tokens that intersect a square patch of side length 2*radius centered on (x,y).\n        :param x: X-coordinate in global frame.\n        :param y: y-coordinate in global frame.\n        :param radius: All records within radius meters of point (x, y) will be returned.\n        :param layer_names: Names of the layers that we want to retrieve. By default will always\n        look at the all non geometric layers.\n        :param mode: \"intersect\" will return all non geometric records that intersects the patch, \"within\" will return\n        all non geometric records that are within the patch.\n        :return: Dictionary of layer_name - tokens pairs.\n        \"\"\"", "\n", "\n", "patch", "=", "(", "x", "-", "radius", ",", "y", "-", "radius", ",", "x", "+", "radius", ",", "y", "+", "radius", ")", "\n", "return", "self", ".", "explorer", ".", "get_records_in_patch", "(", "patch", ",", "layer_names", ",", "mode", "=", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.discretize_centerlines": [[502, 516], ["map_api.NuScenesMap.arcline_path_3.get", "numpy.array", "pose_lists.append", "nuscenes.map_expansion.arcline_path_utils.discretize_lane"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.discretize_lane"], ["", "def", "discretize_centerlines", "(", "self", ",", "resolution_meters", ":", "float", ")", "->", "List", "[", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Discretize the centerlines of lanes and lane connectors.\n        :param resolution_meters: How finely to discretize the lane. Smaller values ensure curved\n            lanes are properly represented.\n        :return: A list of np.arrays with x, y and z values for each point.\n        \"\"\"", "\n", "pose_lists", "=", "[", "]", "\n", "for", "lane", "in", "self", ".", "lane", "+", "self", ".", "lane_connector", ":", "\n", "            ", "my_lane", "=", "self", ".", "arcline_path_3", ".", "get", "(", "lane", "[", "'token'", "]", ",", "[", "]", ")", "\n", "discretized", "=", "np", ".", "array", "(", "discretize_lane", "(", "my_lane", ",", "resolution_meters", ")", ")", "\n", "pose_lists", ".", "append", "(", "discretized", ")", "\n", "\n", "", "return", "pose_lists", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.discretize_lanes": [[517, 528], ["nuscenes.map_expansion.arcline_path_utils.discretize_lane", "map_api.NuScenesMap.arcline_path_3.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.arcline_path_utils.discretize_lane", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "discretize_lanes", "(", "self", ",", "tokens", ":", "List", "[", "str", "]", ",", "\n", "resolution_meters", ":", "float", ")", "->", "Dict", "[", "str", ",", "List", "[", "Tuple", "[", "float", ",", "float", ",", "float", "]", "]", "]", ":", "\n", "        ", "\"\"\"\n        Discretizes a list of lane/lane connector tokens.\n        :param tokens: List of lane and/or lane connector record tokens. Can be retrieved with\n            get_records_in_radius or get_records_in_patch.\n        :param resolution_meters: How finely to discretize the splines.\n        :return: Mapping from lane/lane connector token to sequence of poses along the lane.\n        \"\"\"", "\n", "\n", "return", "{", "ID", ":", "discretize_lane", "(", "self", ".", "arcline_path_3", ".", "get", "(", "ID", ",", "[", "]", ")", ",", "resolution_meters", ")", "for", "ID", "in", "tokens", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._get_connected_lanes": [[529, 541], ["ValueError"], "methods", ["None"], ["", "def", "_get_connected_lanes", "(", "self", ",", "lane_token", ":", "str", ",", "incoming_outgoing", ":", "str", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"\n        Helper for getting the lanes connected to a given lane\n        :param lane_token: Token for the lane.\n        :param incoming_outgoing: Whether to get incoming or outgoing lanes\n        :return: List of lane tokens this lane is connected to.\n        \"\"\"", "\n", "\n", "if", "lane_token", "not", "in", "self", ".", "connectivity", ":", "\n", "            ", "raise", "ValueError", "(", "f\"{lane_token} is not a valid lane.\"", ")", "\n", "\n", "", "return", "self", ".", "connectivity", "[", "lane_token", "]", "[", "incoming_outgoing", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_outgoing_lane_ids": [[542, 550], ["map_api.NuScenesMap._get_connected_lanes"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._get_connected_lanes"], ["", "def", "get_outgoing_lane_ids", "(", "self", ",", "lane_token", ":", "str", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"\n        Get the out-going lanes.\n        :param lane_token: Token for the lane.\n        :return: List of lane tokens that start at the end of this lane.\n        \"\"\"", "\n", "\n", "return", "self", ".", "_get_connected_lanes", "(", "lane_token", ",", "'outgoing'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_incoming_lane_ids": [[551, 559], ["map_api.NuScenesMap._get_connected_lanes"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._get_connected_lanes"], ["", "def", "get_incoming_lane_ids", "(", "self", ",", "lane_token", ":", "str", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"\n        Get the incoming lanes.\n        :param lane_token: Token for the lane.\n        :return: List of lane tokens that end at the start of this lane.\n        \"\"\"", "\n", "\n", "return", "self", ".", "_get_connected_lanes", "(", "lane_token", ",", "'incoming'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_arcline_path": [[560, 574], ["map_api.NuScenesMap.arcline_path_3.get", "ValueError"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_arcline_path", "(", "self", ",", "lane_token", ":", "str", ")", "->", "List", "[", "ArcLinePath", "]", ":", "\n", "        ", "\"\"\"\n        Get the arcline path representation for a lane.\n        Note: This function was previously called `get_lane()`, but renamed to avoid confusion between lanes and\n              arcline paths.\n        :param lane_token: Token for the lane.\n        :return: Arc line path representation of the lane.\n        \"\"\"", "\n", "\n", "arcline_path", "=", "self", ".", "arcline_path_3", ".", "get", "(", "lane_token", ")", "\n", "if", "not", "arcline_path", ":", "\n", "            ", "raise", "ValueError", "(", "f'Error: Lane with token {lane_token} does not have a valid arcline path!'", ")", "\n", "\n", "", "return", "arcline_path", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_closest_lane": [[575, 601], ["map_api.NuScenesMap.get_records_in_radius", "map_api.NuScenesMap.discretize_lanes", "map_api.NuScenesMap.items", "numpy.linalg.norm().min", "numpy.linalg.norm", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_records_in_radius", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.discretize_lanes"], ["", "def", "get_closest_lane", "(", "self", ",", "x", ":", "float", ",", "y", ":", "float", ",", "radius", ":", "float", "=", "5", ")", "->", "str", ":", "\n", "        ", "\"\"\"\n        Get closest lane id within a radius of query point. The distance from a point (x, y) to a lane is\n        the minimum l2 distance from (x, y) to a point on the lane.\n        :param x: X coordinate in global coordinate frame.\n        :param y: Y Coordinate in global coordinate frame.\n        :param radius: Radius around point to consider.\n        :return: Lane id of closest lane within radius.\n        \"\"\"", "\n", "\n", "lanes", "=", "self", ".", "get_records_in_radius", "(", "x", ",", "y", ",", "radius", ",", "[", "'lane'", ",", "'lane_connector'", "]", ")", "\n", "lanes", "=", "lanes", "[", "'lane'", "]", "+", "lanes", "[", "'lane_connector'", "]", "\n", "\n", "discrete_points", "=", "self", ".", "discretize_lanes", "(", "lanes", ",", "0.5", ")", "\n", "\n", "current_min", "=", "np", ".", "inf", "\n", "\n", "min_id", "=", "\"\"", "\n", "for", "lane_id", ",", "points", "in", "discrete_points", ".", "items", "(", ")", ":", "\n", "\n", "            ", "distance", "=", "np", ".", "linalg", ".", "norm", "(", "np", ".", "array", "(", "points", ")", "[", ":", ",", ":", "2", "]", "-", "[", "x", ",", "y", "]", ",", "axis", "=", "1", ")", ".", "min", "(", ")", "\n", "if", "distance", "<=", "current_min", ":", "\n", "                ", "current_min", "=", "distance", "\n", "min_id", "=", "lane_id", "\n", "\n", "", "", "return", "min_id", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.render_next_roads": [[602, 617], ["map_api.NuScenesMap.explorer.render_next_roads"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_next_roads"], ["", "def", "render_next_roads", "(", "self", ",", "\n", "x", ":", "float", ",", "\n", "y", ":", "float", ",", "\n", "alpha", ":", "float", "=", "0.5", ",", "\n", "figsize", ":", "Union", "[", "None", ",", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Renders the possible next roads from a point of interest.\n        :param x: x coordinate of the point of interest.\n        :param y: y coordinate of the point of interest.\n        :param alpha: The opacity of each layer that gets rendered.\n        :param figsize: Size of the whole figure.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        \"\"\"", "\n", "return", "self", ".", "explorer", ".", "render_next_roads", "(", "x", ",", "y", ",", "alpha", ",", "figsize", "=", "figsize", ",", "bitmap", "=", "bitmap", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_next_roads": [[618, 669], ["map_api.NuScenesMap.explorer.layers_on_point", "map_api.NuScenesMap.explorer.get_bounds", "map_api.NuScenesMap.explorer.get_records_in_patch", "map_api.NuScenesMap.get", "map_api.NuScenesMap.get", "map_api.NuScenesMap.get", "map_api.NuScenesMap.get", "any", "result[].append", "map_api.NuScenesMap.get", "all", "result[].append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.layers_on_point", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_bounds", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_records_in_patch", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "def", "get_next_roads", "(", "self", ",", "x", ":", "float", ",", "y", ":", "float", ")", "->", "Dict", "[", "str", ",", "List", "[", "str", "]", "]", ":", "\n", "        ", "\"\"\"\n        Get the possible next roads from a point of interest.\n        Returns road_segment, road_block and lane.\n        :param x: x coordinate of the point of interest.\n        :param y: y coordinate of the point of interest.\n        :return: Dictionary of layer_name - tokens pairs.\n        \"\"\"", "\n", "# Filter out irrelevant layers.", "\n", "road_layers", "=", "[", "'road_segment'", ",", "'road_block'", ",", "'lane'", "]", "\n", "layers", "=", "self", ".", "explorer", ".", "layers_on_point", "(", "x", ",", "y", ")", "\n", "rel_layers", "=", "{", "layer", ":", "layers", "[", "layer", "]", "for", "layer", "in", "road_layers", "}", "\n", "\n", "# Pick most fine-grained road layer (lane, road_block, road_segment) object that contains the point.", "\n", "rel_layer", "=", "None", "\n", "rel_token", "=", "None", "\n", "for", "layer", "in", "road_layers", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "if", "rel_layers", "[", "layer", "]", "!=", "''", ":", "\n", "                ", "rel_layer", "=", "layer", "\n", "rel_token", "=", "rel_layers", "[", "layer", "]", "\n", "break", "\n", "", "", "assert", "rel_layer", "is", "not", "None", ",", "'Error: No suitable layer in the specified point location!'", "\n", "\n", "# Get all records that overlap with the bounding box of the selected road.", "\n", "box_coords", "=", "self", ".", "explorer", ".", "get_bounds", "(", "rel_layer", ",", "rel_token", ")", "\n", "intersect", "=", "self", ".", "explorer", ".", "get_records_in_patch", "(", "box_coords", ",", "road_layers", ",", "mode", "=", "'intersect'", ")", "\n", "\n", "# Go through all objects within the bounding box.", "\n", "result", "=", "{", "layer", ":", "[", "]", "for", "layer", "in", "road_layers", "}", "\n", "if", "rel_layer", "==", "'road_segment'", ":", "\n", "# For road segments, we do not have a direction.", "\n", "# Return objects that have ANY exterior points in common with the relevant layer.", "\n", "            ", "rel_exterior_nodes", "=", "self", ".", "get", "(", "rel_layer", ",", "rel_token", ")", "[", "'exterior_node_tokens'", "]", "\n", "for", "layer", "in", "road_layers", ":", "\n", "                ", "for", "token", "in", "intersect", "[", "layer", "]", ":", "\n", "                    ", "exterior_nodes", "=", "self", ".", "get", "(", "layer", ",", "token", ")", "[", "'exterior_node_tokens'", "]", "\n", "if", "any", "(", "n", "in", "exterior_nodes", "for", "n", "in", "rel_exterior_nodes", ")", "and", "token", "!=", "rel_layers", "[", "layer", "]", ":", "\n", "                        ", "result", "[", "layer", "]", ".", "append", "(", "token", ")", "\n", "", "", "", "", "else", ":", "\n", "# For lanes and road blocks, the next road is indicated by the edge line.", "\n", "# Return objects where ALL edge line nodes are included in the exterior nodes.", "\n", "            ", "to_edge_line", "=", "self", ".", "get", "(", "rel_layer", ",", "rel_token", ")", "[", "'to_edge_line_token'", "]", "\n", "to_edge_nodes", "=", "self", ".", "get", "(", "'line'", ",", "to_edge_line", ")", "[", "'node_tokens'", "]", "\n", "for", "layer", "in", "road_layers", ":", "\n", "                ", "for", "token", "in", "intersect", "[", "layer", "]", ":", "\n", "                    ", "exterior_nodes", "=", "self", ".", "get", "(", "layer", ",", "token", ")", "[", "'exterior_node_tokens'", "]", "\n", "if", "all", "(", "n", "in", "exterior_nodes", "for", "n", "in", "to_edge_nodes", ")", "and", "token", "!=", "rel_layers", "[", "layer", "]", ":", "\n", "                        ", "result", "[", "layer", "]", ".", "append", "(", "token", ")", "\n", "", "", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.__init__": [[673, 705], ["dict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "map_api", ":", "NuScenesMap", ",", "\n", "representative_layers", ":", "Tuple", "[", "str", "]", "=", "(", "'drivable_area'", ",", "'lane'", ",", "'walkway'", ")", ",", "\n", "color_map", ":", "dict", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param map_api: NuScenesMap database class.\n        :param representative_layers: These are the layers that we feel are representative of the whole mapping data.\n        :param color_map: Color map.\n        \"\"\"", "\n", "# Mutable default argument.", "\n", "if", "color_map", "is", "None", ":", "\n", "            ", "color_map", "=", "dict", "(", "drivable_area", "=", "'#a6cee3'", ",", "\n", "road_segment", "=", "'#1f78b4'", ",", "\n", "road_block", "=", "'#b2df8a'", ",", "\n", "lane", "=", "'#33a02c'", ",", "\n", "ped_crossing", "=", "'#fb9a99'", ",", "\n", "walkway", "=", "'#e31a1c'", ",", "\n", "stop_line", "=", "'#fdbf6f'", ",", "\n", "carpark_area", "=", "'#ff7f00'", ",", "\n", "road_divider", "=", "'#cab2d6'", ",", "\n", "lane_divider", "=", "'#6a3d9a'", ",", "\n", "traffic_light", "=", "'#7e772e'", ")", "\n", "\n", "", "self", ".", "map_api", "=", "map_api", "\n", "self", ".", "representative_layers", "=", "representative_layers", "\n", "self", ".", "color_map", "=", "color_map", "\n", "\n", "self", ".", "canvas_max_x", "=", "self", ".", "map_api", ".", "canvas_edge", "[", "0", "]", "\n", "self", ".", "canvas_min_x", "=", "0", "\n", "self", ".", "canvas_max_y", "=", "self", ".", "map_api", ".", "canvas_edge", "[", "1", "]", "\n", "self", ".", "canvas_min_y", "=", "0", "\n", "self", ".", "canvas_aspect_ratio", "=", "(", "self", ".", "canvas_max_x", "-", "self", ".", "canvas_min_x", ")", "/", "(", "self", ".", "canvas_max_y", "-", "self", ".", "canvas_min_y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_centerlines": [[706, 732], ["map_api.NuScenesMapExplorer.map_api.discretize_centerlines", "matplotlib.figure", "matplotlib.figure", "matplotlib.figure.add_axes", "bitmap.render", "map_api.NuScenesMapExplorer._get_figsize", "len", "matplotlib.plot", "matplotlib.plot"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.discretize_centerlines", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_figsize"], ["", "def", "render_centerlines", "(", "self", ",", "\n", "resolution_meters", ":", "float", ",", "\n", "figsize", ":", "Union", "[", "None", ",", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Render the centerlines of all lanes and lane connectors.\n        :param resolution_meters: How finely to discretize the lane. Smaller values ensure curved\n            lanes are properly represented.\n        :param figsize: Size of the figure.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        \"\"\"", "\n", "# Discretize all lanes and lane connectors.", "\n", "pose_lists", "=", "self", ".", "map_api", ".", "discretize_centerlines", "(", "resolution_meters", ")", "\n", "\n", "# Render connectivity lines.", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "self", ".", "_get_figsize", "(", "figsize", ")", ")", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "0", ",", "0", ",", "1", ",", "1", "/", "self", ".", "canvas_aspect_ratio", "]", ")", "\n", "\n", "if", "bitmap", "is", "not", "None", ":", "\n", "            ", "bitmap", ".", "render", "(", "self", ".", "map_api", ".", "canvas_edge", ",", "ax", ")", "\n", "\n", "", "for", "pose_list", "in", "pose_lists", ":", "\n", "            ", "if", "len", "(", "pose_list", ")", ">", "0", ":", "\n", "                ", "plt", ".", "plot", "(", "pose_list", "[", ":", ",", "0", "]", ",", "pose_list", "[", ":", ",", "1", "]", ")", "\n", "\n", "", "", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_map_mask": [[733, 776], ["map_api.NuScenesMapExplorer.get_map_mask", "matplotlib.figure", "matplotlib.figure", "matplotlib.figure.add_axes", "plt.figure.add_axes.set_xlim", "plt.figure.add_axes.set_ylim", "matplotlib.GridSpec", "matplotlib.GridSpec", "matplotlib.GridSpec.update", "range", "len", "len", "matplotlib.subplot", "matplotlib.subplot", "matplotlib.subplot.imshow", "matplotlib.subplot.text", "matplotlib.subplot.grid"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_map_mask", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update"], ["", "def", "render_map_mask", "(", "self", ",", "\n", "patch_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "patch_angle", ":", "float", ",", "\n", "layer_names", ":", "List", "[", "str", "]", ",", "\n", "canvas_size", ":", "Tuple", "[", "int", ",", "int", "]", ",", "\n", "figsize", ":", "Tuple", "[", "int", ",", "int", "]", ",", "\n", "n_row", ":", "int", "=", "2", ")", "->", "Tuple", "[", "Figure", ",", "List", "[", "Axes", "]", "]", ":", "\n", "        ", "\"\"\"\n        Render map mask of the patch specified by patch_box and patch_angle.\n        :param patch_box: Patch box defined as [x_center, y_center, height, width].\n        :param patch_angle: Patch orientation in degrees.\n        :param layer_names: A list of layer names to be extracted.\n        :param canvas_size: Size of the output mask (h, w).\n        :param figsize: Size of the figure.\n        :param n_row: Number of rows with plots.\n        :return: The matplotlib figure and a list of axes of the rendered layers.\n        \"\"\"", "\n", "if", "layer_names", "is", "None", ":", "\n", "            ", "layer_names", "=", "self", ".", "map_api", ".", "non_geometric_layers", "\n", "\n", "", "map_mask", "=", "self", ".", "get_map_mask", "(", "patch_box", ",", "patch_angle", ",", "layer_names", ",", "canvas_size", ")", "\n", "\n", "# If no canvas_size is specified, retrieve the default from the output of get_map_mask.", "\n", "if", "canvas_size", "is", "None", ":", "\n", "            ", "canvas_size", "=", "map_mask", ".", "shape", "[", "1", ":", "]", "\n", "\n", "", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "0", ",", "0", ",", "1", ",", "1", "]", ")", "\n", "ax", ".", "set_xlim", "(", "0", ",", "canvas_size", "[", "1", "]", ")", "\n", "ax", ".", "set_ylim", "(", "0", ",", "canvas_size", "[", "0", "]", ")", "\n", "\n", "n_col", "=", "len", "(", "map_mask", ")", "//", "n_row", "\n", "gs", "=", "gridspec", ".", "GridSpec", "(", "n_row", ",", "n_col", ")", "\n", "gs", ".", "update", "(", "wspace", "=", "0.025", ",", "hspace", "=", "0.05", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "map_mask", ")", ")", ":", "\n", "            ", "r", "=", "i", "//", "n_col", "\n", "c", "=", "i", "-", "r", "*", "n_col", "\n", "subax", "=", "plt", ".", "subplot", "(", "gs", "[", "r", ",", "c", "]", ")", "\n", "subax", ".", "imshow", "(", "map_mask", "[", "i", "]", ",", "origin", "=", "'lower'", ")", "\n", "subax", ".", "text", "(", "canvas_size", "[", "0", "]", "*", "0.5", ",", "canvas_size", "[", "1", "]", "*", "1.1", ",", "layer_names", "[", "i", "]", ")", "\n", "subax", ".", "grid", "(", "False", ")", "\n", "\n", "", "return", "fig", ",", "fig", ".", "axes", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_map_geom": [[777, 803], ["map_api.NuScenesMapExplorer._get_layer_geom", "map_geom.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_layer_geom"], ["", "def", "get_map_geom", "(", "self", ",", "\n", "patch_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "patch_angle", ":", "float", ",", "\n", "layer_names", ":", "List", "[", "str", "]", ")", "->", "List", "[", "Tuple", "[", "str", ",", "List", "[", "Geometry", "]", "]", "]", ":", "\n", "        ", "\"\"\"\n        Returns a list of geometries in the specified patch_box.\n        These are unscaled, but aligned with the patch angle.\n        :param patch_box: Patch box defined as [x_center, y_center, height, width].\n        :param patch_angle: Patch orientation in degrees.\n                            North-facing corresponds to 0.\n        :param layer_names: A list of layer names to be extracted, or None for all non-geometric layers.\n        :return: List of layer names and their corresponding geometries.\n        \"\"\"", "\n", "# If None, return all geometric layers.", "\n", "if", "layer_names", "is", "None", ":", "\n", "            ", "layer_names", "=", "self", ".", "map_api", ".", "non_geometric_layers", "\n", "\n", "# Get each layer name and geometry and store them in a list.", "\n", "", "map_geom", "=", "[", "]", "\n", "for", "layer_name", "in", "layer_names", ":", "\n", "            ", "layer_geom", "=", "self", ".", "_get_layer_geom", "(", "patch_box", ",", "patch_angle", ",", "layer_name", ")", "\n", "if", "layer_geom", "is", "None", ":", "\n", "                ", "continue", "\n", "", "map_geom", ".", "append", "(", "(", "layer_name", ",", "layer_geom", ")", ")", "\n", "\n", "", "return", "map_geom", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.map_geom_to_mask": [[804, 824], ["numpy.array", "map_api.NuScenesMapExplorer._layer_geom_to_mask", "map_mask.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._layer_geom_to_mask"], ["", "def", "map_geom_to_mask", "(", "self", ",", "\n", "map_geom", ":", "List", "[", "Tuple", "[", "str", ",", "List", "[", "Geometry", "]", "]", "]", ",", "\n", "local_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "canvas_size", ":", "Tuple", "[", "int", ",", "int", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Return list of map mask layers of the specified patch.\n        :param map_geom: List of layer names and their corresponding geometries.\n        :param local_box: The local patch box defined as (x_center, y_center, height, width), where typically\n            x_center = y_center = 0.\n        :param canvas_size: Size of the output mask (h, w).\n        :return: Stacked numpy array of size [c x h x w] with c channels and the same height/width as the canvas.\n        \"\"\"", "\n", "# Get each layer mask and stack them into a numpy tensor.", "\n", "map_mask", "=", "[", "]", "\n", "for", "layer_name", ",", "layer_geom", "in", "map_geom", ":", "\n", "            ", "layer_mask", "=", "self", ".", "_layer_geom_to_mask", "(", "layer_name", ",", "layer_geom", ",", "local_box", ",", "canvas_size", ")", "\n", "if", "layer_mask", "is", "not", "None", ":", "\n", "                ", "map_mask", ".", "append", "(", "layer_mask", ")", "\n", "\n", "", "", "return", "np", ".", "array", "(", "map_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_map_mask": [[825, 874], ["map_api.NuScenesMapExplorer.get_map_geom", "map_api.NuScenesMapExplorer.map_geom_to_mask", "numpy.all", "tuple", "numpy.array", "numpy.round().astype", "Exception", "numpy.round"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_map_geom", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.map_geom_to_mask", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "def", "get_map_mask", "(", "self", ",", "\n", "patch_box", ":", "Optional", "[", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", "]", ",", "\n", "patch_angle", ":", "float", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "canvas_size", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "100", ",", "100", ")", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Return list of map mask layers of the specified patch.\n        :param patch_box: Patch box defined as [x_center, y_center, height, width]. If None, this plots the entire map.\n        :param patch_angle: Patch orientation in degrees. North-facing corresponds to 0.\n        :param layer_names: A list of layer names to be extracted, or None for all non-geometric layers.\n        :param canvas_size: Size of the output mask (h, w). If None, we use the default resolution of 10px/m.\n        :return: Stacked numpy array of size [c x h x w] with c channels and the same width/height as the canvas.\n        \"\"\"", "\n", "# For some combination of parameters, we need to know the size of the current map.", "\n", "if", "self", ".", "map_api", ".", "map_name", "==", "'singapore-onenorth'", ":", "\n", "            ", "map_dims", "=", "[", "1585.6", ",", "2025.0", "]", "\n", "", "elif", "self", ".", "map_api", ".", "map_name", "==", "'singapore-hollandvillage'", ":", "\n", "            ", "map_dims", "=", "[", "2808.3", ",", "2922.9", "]", "\n", "", "elif", "self", ".", "map_api", ".", "map_name", "==", "'singapore-queenstown'", ":", "\n", "            ", "map_dims", "=", "[", "3228.6", ",", "3687.1", "]", "\n", "", "elif", "self", ".", "map_api", ".", "map_name", "==", "'boston-seaport'", ":", "\n", "            ", "map_dims", "=", "[", "2979.5", ",", "2118.1", "]", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Error: Invalid map!'", ")", "\n", "\n", "# If None, return the entire map.", "\n", "", "if", "patch_box", "is", "None", ":", "\n", "            ", "patch_box", "=", "[", "map_dims", "[", "0", "]", "/", "2", ",", "map_dims", "[", "1", "]", "/", "2", ",", "map_dims", "[", "1", "]", ",", "map_dims", "[", "0", "]", "]", "\n", "\n", "# If None, return all geometric layers.", "\n", "", "if", "layer_names", "is", "None", ":", "\n", "            ", "layer_names", "=", "self", ".", "map_api", ".", "non_geometric_layers", "\n", "\n", "# If None, return the specified patch in the original scale of 10px/m.", "\n", "", "if", "canvas_size", "is", "None", ":", "\n", "            ", "map_scale", "=", "10", "\n", "canvas_size", "=", "np", ".", "array", "(", "(", "patch_box", "[", "2", "]", ",", "patch_box", "[", "3", "]", ")", ")", "*", "map_scale", "\n", "canvas_size", "=", "tuple", "(", "np", ".", "round", "(", "canvas_size", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "\n", "# Get geometry of each layer.", "\n", "", "map_geom", "=", "self", ".", "get_map_geom", "(", "patch_box", ",", "patch_angle", ",", "layer_names", ")", "\n", "\n", "# Convert geometry of each layer into mask and stack them into a numpy tensor.", "\n", "# Convert the patch box from global coordinates to local coordinates by setting the center to (0, 0).", "\n", "local_box", "=", "(", "0.0", ",", "0.0", ",", "patch_box", "[", "2", "]", ",", "patch_box", "[", "3", "]", ")", "\n", "map_mask", "=", "self", ".", "map_geom_to_mask", "(", "map_geom", ",", "local_box", ",", "canvas_size", ")", "\n", "assert", "np", ".", "all", "(", "map_mask", ".", "shape", "[", "1", ":", "]", "==", "canvas_size", ")", "\n", "\n", "return", "map_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_record": [[875, 955], ["map_api.NuScenesMapExplorer.map_api.get_bounds", "matplotlib.figure", "matplotlib.figure", "matplotlib.figure.add_axes", "matplotlib.figure.add_axes", "random.seed", "list", "plt.figure.add_axes.set_xlim", "plt.figure.add_axes.set_ylim", "plt.figure.add_axes.set_title", "plt.figure.add_axes.set_xlim", "plt.figure.add_axes.set_ylim", "plt.figure.add_axes.set_title", "plt.figure.add_axes.legend", "mpl_toolkits.axes_grid1.inset_locator.mark_inset", "list", "bitmap.render", "bitmap.render", "set", "map_api.NuScenesMapExplorer._render_layer", "map_api.NuScenesMapExplorer._render_layer", "plt.figure.add_axes.add_patch", "ValueError", "map_api.NuScenesMapExplorer._get_figsize", "matplotlib.patches.Rectangle", "matplotlib.patches.Rectangle"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_bounds", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._render_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._render_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_figsize"], ["", "def", "render_record", "(", "self", ",", "\n", "layer_name", ":", "str", ",", "\n", "token", ":", "str", ",", "\n", "alpha", ":", "float", "=", "0.5", ",", "\n", "figsize", ":", "Union", "[", "None", ",", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "other_layers", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Tuple", "[", "Axes", ",", "Axes", "]", "]", ":", "\n", "        ", "\"\"\"\n        Render a single map record.\n        By default will also render 3 layers which are `drivable_area`, `lane`, and `walkway` unless specified by\n        `other_layers`.\n        :param layer_name: Name of the layer that we are interested in.\n        :param token: Token of the record that you want to render.\n        :param alpha: The opacity of each layer that gets rendered.\n        :param figsize: Size of the whole figure.\n        :param other_layers: What other layers to render aside from the one specified in `layer_name`.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        :return: The matplotlib figure and axes of the rendered layers.\n        \"\"\"", "\n", "if", "other_layers", "is", "None", ":", "\n", "            ", "other_layers", "=", "list", "(", "self", ".", "representative_layers", ")", "\n", "\n", "", "for", "other_layer", "in", "other_layers", ":", "\n", "            ", "if", "other_layer", "not", "in", "self", ".", "map_api", ".", "non_geometric_layers", ":", "\n", "                ", "raise", "ValueError", "(", "\"{} is not a non geometric layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "self", ".", "map_api", ".", "get_bounds", "(", "layer_name", ",", "token", ")", "\n", "\n", "local_width", "=", "x2", "-", "x1", "\n", "local_height", "=", "y2", "-", "y1", "\n", "assert", "local_height", ">", "0", ",", "'Error: Map has 0 height!'", "\n", "local_aspect_ratio", "=", "local_width", "/", "local_height", "\n", "\n", "# We obtained the values 0.65 and 0.66 by trials.", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "self", ".", "_get_figsize", "(", "figsize", ")", ")", "\n", "global_ax", "=", "fig", ".", "add_axes", "(", "[", "0", ",", "0", ",", "0.65", ",", "0.65", "/", "self", ".", "canvas_aspect_ratio", "]", ")", "\n", "local_ax", "=", "fig", ".", "add_axes", "(", "[", "0.66", ",", "0.66", "/", "self", ".", "canvas_aspect_ratio", ",", "0.34", ",", "0.34", "/", "local_aspect_ratio", "]", ")", "\n", "\n", "# To make sure the sequence of the layer overlays is always consistent after typesetting set().", "\n", "random", ".", "seed", "(", "'nutonomy'", ")", "\n", "\n", "if", "bitmap", "is", "not", "None", ":", "\n", "            ", "bitmap", ".", "render", "(", "self", ".", "map_api", ".", "canvas_edge", ",", "global_ax", ")", "\n", "bitmap", ".", "render", "(", "self", ".", "map_api", ".", "canvas_edge", ",", "local_ax", ")", "\n", "\n", "", "layer_names", "=", "other_layers", "+", "[", "layer_name", "]", "\n", "layer_names", "=", "list", "(", "set", "(", "layer_names", ")", ")", "\n", "\n", "for", "layer", "in", "layer_names", ":", "\n", "            ", "self", ".", "_render_layer", "(", "global_ax", ",", "layer", ",", "alpha", ")", "\n", "\n", "", "for", "layer", "in", "layer_names", ":", "\n", "            ", "self", ".", "_render_layer", "(", "local_ax", ",", "layer", ",", "alpha", ")", "\n", "\n", "", "if", "layer_name", "==", "'drivable_area'", ":", "\n", "# Bad output aesthetically if we add spacing between the objects and the axes for drivable area.", "\n", "            ", "local_ax_xlim", "=", "(", "x1", ",", "x2", ")", "\n", "local_ax_ylim", "=", "(", "y1", ",", "y2", ")", "\n", "", "else", ":", "\n", "# Add some spacing between the object and the axes.", "\n", "            ", "local_ax_xlim", "=", "(", "x1", "-", "local_width", "/", "3", ",", "x2", "+", "local_width", "/", "3", ")", "\n", "local_ax_ylim", "=", "(", "y1", "-", "local_height", "/", "3", ",", "y2", "+", "local_height", "/", "3", ")", "\n", "\n", "# Draws the rectangular patch on the local_ax.", "\n", "local_ax", ".", "add_patch", "(", "Rectangle", "(", "(", "x1", ",", "y1", ")", ",", "local_width", ",", "local_height", ",", "linestyle", "=", "'-.'", ",", "color", "=", "'red'", ",", "fill", "=", "False", ",", "\n", "lw", "=", "2", ")", ")", "\n", "\n", "", "local_ax", ".", "set_xlim", "(", "*", "local_ax_xlim", ")", "\n", "local_ax", ".", "set_ylim", "(", "*", "local_ax_ylim", ")", "\n", "local_ax", ".", "set_title", "(", "'Local View'", ")", "\n", "\n", "global_ax", ".", "set_xlim", "(", "self", ".", "canvas_min_x", ",", "self", ".", "canvas_max_x", ")", "\n", "global_ax", ".", "set_ylim", "(", "self", ".", "canvas_min_y", ",", "self", ".", "canvas_max_y", ")", "\n", "global_ax", ".", "set_title", "(", "'Global View'", ")", "\n", "global_ax", ".", "legend", "(", ")", "\n", "\n", "# Adds the zoomed in effect to the plot.", "\n", "mark_inset", "(", "global_ax", ",", "local_ax", ",", "loc1", "=", "2", ",", "loc2", "=", "4", ")", "\n", "\n", "return", "fig", ",", "(", "global_ax", ",", "local_ax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_layers": [[956, 987], ["matplotlib.figure", "matplotlib.figure", "matplotlib.figure.add_axes", "plt.figure.add_axes.set_xlim", "plt.figure.add_axes.set_ylim", "list", "plt.figure.add_axes.legend", "bitmap.render", "set", "map_api.NuScenesMapExplorer._render_layer", "map_api.NuScenesMapExplorer._get_figsize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._render_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_figsize"], ["", "def", "render_layers", "(", "self", ",", "\n", "layer_names", ":", "List", "[", "str", "]", ",", "\n", "alpha", ":", "float", ",", "\n", "figsize", ":", "Union", "[", "None", ",", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", ",", "\n", "tokens", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Render a list of layers.\n        :param layer_names: A list of layer names.\n        :param alpha: The opacity of each layer.\n        :param figsize: Size of the whole figure.\n        :param tokens: Optional list of tokens to render. None means all tokens are rendered.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        :return: The matplotlib figure and axes of the rendered layers.\n        \"\"\"", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "self", ".", "_get_figsize", "(", "figsize", ")", ")", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "0", ",", "0", ",", "1", ",", "1", "/", "self", ".", "canvas_aspect_ratio", "]", ")", "\n", "\n", "ax", ".", "set_xlim", "(", "self", ".", "canvas_min_x", ",", "self", ".", "canvas_max_x", ")", "\n", "ax", ".", "set_ylim", "(", "self", ".", "canvas_min_y", ",", "self", ".", "canvas_max_y", ")", "\n", "\n", "if", "bitmap", "is", "not", "None", ":", "\n", "            ", "bitmap", ".", "render", "(", "self", ".", "map_api", ".", "canvas_edge", ",", "ax", ")", "\n", "\n", "", "layer_names", "=", "list", "(", "set", "(", "layer_names", ")", ")", "\n", "for", "layer_name", "in", "layer_names", ":", "\n", "            ", "self", ".", "_render_layer", "(", "ax", ",", "layer_name", ",", "alpha", ",", "tokens", ")", "\n", "\n", "", "ax", ".", "legend", "(", ")", "\n", "\n", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_map_patch": [[988, 1044], ["matplotlib.figure", "matplotlib.figure", "matplotlib.figure.add_axes", "numpy.minimum", "numpy.minimum", "plt.figure.add_axes.set_xlim", "plt.figure.add_axes.set_ylim", "bitmap.render", "map_api.NuScenesMapExplorer._render_layer", "plt.figure.add_axes.add_patch", "plt.figure.add_axes.text", "plt.figure.add_axes.text", "plt.figure.add_axes.legend", "matplotlib.patches.Rectangle", "matplotlib.patches.Rectangle"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._render_layer"], ["", "def", "render_map_patch", "(", "self", ",", "\n", "box_coords", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "alpha", ":", "float", "=", "0.5", ",", "\n", "figsize", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "15", ",", "15", ")", ",", "\n", "render_egoposes_range", ":", "bool", "=", "True", ",", "\n", "render_legend", ":", "bool", "=", "True", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Renders a rectangular patch specified by `box_coords`. By default renders all layers.\n        :param box_coords: The rectangular patch coordinates (x_min, y_min, x_max, y_max).\n        :param layer_names: All the non geometric layers that we want to render.\n        :param alpha: The opacity of each layer.\n        :param figsize: Size of the whole figure.\n        :param render_egoposes_range: Whether to render a rectangle around all ego poses.\n        :param render_legend: Whether to render the legend of map layers.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        :return: The matplotlib figure and axes of the rendered layers.\n        \"\"\"", "\n", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", "=", "box_coords", "\n", "\n", "if", "layer_names", "is", "None", ":", "\n", "            ", "layer_names", "=", "self", ".", "map_api", ".", "non_geometric_layers", "\n", "\n", "", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "\n", "local_width", "=", "x_max", "-", "x_min", "\n", "local_height", "=", "y_max", "-", "y_min", "\n", "assert", "local_height", ">", "0", ",", "'Error: Map patch has 0 height!'", "\n", "local_aspect_ratio", "=", "local_width", "/", "local_height", "\n", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "0", ",", "0", ",", "1", ",", "1", "/", "local_aspect_ratio", "]", ")", "\n", "\n", "if", "bitmap", "is", "not", "None", ":", "\n", "            ", "bitmap", ".", "render", "(", "self", ".", "map_api", ".", "canvas_edge", ",", "ax", ")", "\n", "\n", "", "for", "layer_name", "in", "layer_names", ":", "\n", "            ", "self", ".", "_render_layer", "(", "ax", ",", "layer_name", ",", "alpha", ")", "\n", "\n", "", "x_margin", "=", "np", ".", "minimum", "(", "local_width", "/", "4", ",", "50", ")", "\n", "y_margin", "=", "np", ".", "minimum", "(", "local_height", "/", "4", ",", "10", ")", "\n", "ax", ".", "set_xlim", "(", "x_min", "-", "x_margin", ",", "x_max", "+", "x_margin", ")", "\n", "ax", ".", "set_ylim", "(", "y_min", "-", "y_margin", ",", "y_max", "+", "y_margin", ")", "\n", "\n", "if", "render_egoposes_range", ":", "\n", "            ", "ax", ".", "add_patch", "(", "Rectangle", "(", "(", "x_min", ",", "y_min", ")", ",", "local_width", ",", "local_height", ",", "fill", "=", "False", ",", "linestyle", "=", "'-.'", ",", "color", "=", "'red'", ",", "\n", "lw", "=", "2", ")", ")", "\n", "ax", ".", "text", "(", "x_min", "+", "local_width", "/", "100", ",", "y_min", "+", "local_height", "/", "2", ",", "\"%g m\"", "%", "local_height", ",", "\n", "fontsize", "=", "14", ",", "weight", "=", "'bold'", ")", "\n", "ax", ".", "text", "(", "x_min", "+", "local_width", "/", "2", ",", "y_min", "+", "local_height", "/", "100", ",", "\"%g m\"", "%", "local_width", ",", "\n", "fontsize", "=", "14", ",", "weight", "=", "'bold'", ")", "\n", "\n", "", "if", "render_legend", ":", "\n", "            ", "ax", ".", "legend", "(", "frameon", "=", "True", ",", "loc", "=", "'upper right'", ")", "\n", "\n", "", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_map_in_image": [[1045, 1201], ["nusc.get", "nusc.get", "nusc.get", "nusc.get", "nusc.get_sample_data_path", "PIL.Image.open", "nusc.get", "numpy.array", "nusc.get", "map_api.NuScenesMapExplorer.get_records_in_patch", "matplotlib.figure", "matplotlib.figure", "matplotlib.figure.add_axes", "plt.figure.add_axes.set_xlim", "plt.figure.add_axes.set_ylim", "plt.figure.add_axes.imshow", "matplotlib.axis", "matplotlib.axis", "plt.figure.add_axes.invert_yaxis", "print", "matplotlib.tight_layout", "matplotlib.tight_layout", "matplotlib.savefig", "matplotlib.savefig", "map_api.NuScenesMapExplorer.map_api.get", "map_api.NuScenesMapExplorer.map_api.extract_polygon", "numpy.array", "numpy.vstack", "numpy.dot", "numpy.dot", "numpy.all", "nuscenes.utils.geometry_utils.view_points", "numpy.ones", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "shapely.geometry.Polygon", "plt.figure.add_axes.add_patch", "numpy.array().reshape", "numpy.array().reshape", "map_api.NuScenesMapExplorer._clip_points_behind_camera", "numpy.any", "numpy.all", "numpy.any", "descartes.PolygonPatch", "numpy.zeros", "len", "numpy.logical_not", "numpy.logical_not", "zip", "numpy.array", "pyquaternion.Quaternion", "numpy.array", "pyquaternion.Quaternion"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data_path", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_records_in_patch", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._clip_points_behind_camera", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "def", "render_map_in_image", "(", "self", ",", "\n", "nusc", ":", "NuScenes", ",", "\n", "sample_token", ":", "str", ",", "\n", "camera_channel", ":", "str", "=", "'CAM_FRONT'", ",", "\n", "alpha", ":", "float", "=", "0.3", ",", "\n", "patch_radius", ":", "float", "=", "10000", ",", "\n", "min_polygon_area", ":", "float", "=", "1000", ",", "\n", "render_behind_cam", ":", "bool", "=", "True", ",", "\n", "render_outside_im", ":", "bool", "=", "True", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "out_path", ":", "str", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Render a nuScenes camera image and overlay the polygons for the specified map layers.\n        Note that the projections are not always accurate as the localization is in 2d.\n        :param nusc: The NuScenes instance to load the image from.\n        :param sample_token: The image's corresponding sample_token.\n        :param camera_channel: Camera channel name, e.g. 'CAM_FRONT'.\n        :param alpha: The transparency value of the layers to render in [0, 1].\n        :param patch_radius: The radius in meters around the ego car in which to select map records.\n        :param min_polygon_area: Minimum area a polygon needs to have to be rendered.\n        :param render_behind_cam: Whether to render polygons where any point is behind the camera.\n        :param render_outside_im: Whether to render polygons where any point is outside the image.\n        :param layer_names: The names of the layers to render, e.g. ['lane'].\n            If set to None, the recommended setting will be used.\n        :param verbose: Whether to print to stdout.\n        :param out_path: Optional path to save the rendered figure to disk.\n        \"\"\"", "\n", "near_plane", "=", "1e-8", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Warning: Note that the projections are not always accurate as the localization is in 2d.'", ")", "\n", "\n", "# Default layers.", "\n", "", "if", "layer_names", "is", "None", ":", "\n", "            ", "layer_names", "=", "[", "'road_segment'", ",", "'lane'", ",", "'ped_crossing'", ",", "'walkway'", ",", "'stop_line'", ",", "'carpark_area'", "]", "\n", "\n", "# Check layers whether we can render them.", "\n", "", "for", "layer_name", "in", "layer_names", ":", "\n", "            ", "assert", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ",", "'Error: Can only render non-geometry polygons: %s'", "%", "layer_names", "\n", "\n", "# Check that NuScenesMap was loaded for the correct location.", "\n", "", "sample_record", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "scene_record", "=", "nusc", ".", "get", "(", "'scene'", ",", "sample_record", "[", "'scene_token'", "]", ")", "\n", "log_record", "=", "nusc", ".", "get", "(", "'log'", ",", "scene_record", "[", "'log_token'", "]", ")", "\n", "log_location", "=", "log_record", "[", "'location'", "]", "\n", "assert", "self", ".", "map_api", ".", "map_name", "==", "log_location", ",", "'Error: NuScenesMap loaded for location %s, should be %s!'", "%", "(", "self", ".", "map_api", ".", "map_name", ",", "log_location", ")", "\n", "\n", "# Grab the front camera image and intrinsics.", "\n", "cam_token", "=", "sample_record", "[", "'data'", "]", "[", "camera_channel", "]", "\n", "cam_record", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "cam_token", ")", "\n", "cam_path", "=", "nusc", ".", "get_sample_data_path", "(", "cam_token", ")", "\n", "im", "=", "Image", ".", "open", "(", "cam_path", ")", "\n", "im_size", "=", "im", ".", "size", "\n", "cs_record", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "cam_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "cam_intrinsic", "=", "np", ".", "array", "(", "cs_record", "[", "'camera_intrinsic'", "]", ")", "\n", "\n", "# Retrieve the current map.", "\n", "poserecord", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "cam_record", "[", "'ego_pose_token'", "]", ")", "\n", "ego_pose", "=", "poserecord", "[", "'translation'", "]", "\n", "box_coords", "=", "(", "\n", "ego_pose", "[", "0", "]", "-", "patch_radius", ",", "\n", "ego_pose", "[", "1", "]", "-", "patch_radius", ",", "\n", "ego_pose", "[", "0", "]", "+", "patch_radius", ",", "\n", "ego_pose", "[", "1", "]", "+", "patch_radius", ",", "\n", ")", "\n", "records_in_patch", "=", "self", ".", "get_records_in_patch", "(", "box_coords", ",", "layer_names", ",", "'intersect'", ")", "\n", "\n", "# Init axes.", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "9", ",", "16", ")", ")", "\n", "ax", "=", "fig", ".", "add_axes", "(", "[", "0", ",", "0", ",", "1", ",", "1", "]", ")", "\n", "ax", ".", "set_xlim", "(", "0", ",", "im_size", "[", "0", "]", ")", "\n", "ax", ".", "set_ylim", "(", "0", ",", "im_size", "[", "1", "]", ")", "\n", "ax", ".", "imshow", "(", "im", ")", "\n", "\n", "# Retrieve and render each record.", "\n", "for", "layer_name", "in", "layer_names", ":", "\n", "            ", "for", "token", "in", "records_in_patch", "[", "layer_name", "]", ":", "\n", "                ", "record", "=", "self", ".", "map_api", ".", "get", "(", "layer_name", ",", "token", ")", "\n", "if", "layer_name", "==", "'drivable_area'", ":", "\n", "                    ", "polygon_tokens", "=", "record", "[", "'polygon_tokens'", "]", "\n", "", "else", ":", "\n", "                    ", "polygon_tokens", "=", "[", "record", "[", "'polygon_token'", "]", "]", "\n", "\n", "", "for", "polygon_token", "in", "polygon_tokens", ":", "\n", "                    ", "polygon", "=", "self", ".", "map_api", ".", "extract_polygon", "(", "polygon_token", ")", "\n", "\n", "# Convert polygon nodes to pointcloud with 0 height.", "\n", "points", "=", "np", ".", "array", "(", "polygon", ".", "exterior", ".", "xy", ")", "\n", "points", "=", "np", ".", "vstack", "(", "(", "points", ",", "np", ".", "zeros", "(", "(", "1", ",", "points", ".", "shape", "[", "1", "]", ")", ")", ")", ")", "\n", "\n", "# Transform into the ego vehicle frame for the timestamp of the image.", "\n", "points", "=", "points", "-", "np", ".", "array", "(", "poserecord", "[", "'translation'", "]", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "points", "=", "np", ".", "dot", "(", "Quaternion", "(", "poserecord", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ".", "T", ",", "points", ")", "\n", "\n", "# Transform into the camera.", "\n", "points", "=", "points", "-", "np", ".", "array", "(", "cs_record", "[", "'translation'", "]", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "points", "=", "np", ".", "dot", "(", "Quaternion", "(", "cs_record", "[", "'rotation'", "]", ")", ".", "rotation_matrix", ".", "T", ",", "points", ")", "\n", "\n", "# Remove points that are partially behind the camera.", "\n", "depths", "=", "points", "[", "2", ",", ":", "]", "\n", "behind", "=", "depths", "<", "near_plane", "\n", "if", "np", ".", "all", "(", "behind", ")", ":", "\n", "                        ", "continue", "\n", "\n", "", "if", "render_behind_cam", ":", "\n", "# Perform clipping on polygons that are partially behind the camera.", "\n", "                        ", "points", "=", "NuScenesMapExplorer", ".", "_clip_points_behind_camera", "(", "points", ",", "near_plane", ")", "\n", "", "elif", "np", ".", "any", "(", "behind", ")", ":", "\n", "# Otherwise ignore any polygon that is partially behind the camera.", "\n", "                        ", "continue", "\n", "\n", "# Ignore polygons with less than 3 points after clipping.", "\n", "", "if", "len", "(", "points", ")", "==", "0", "or", "points", ".", "shape", "[", "1", "]", "<", "3", ":", "\n", "                        ", "continue", "\n", "\n", "# Take the actual picture (matrix multiplication with camera-matrix + renormalization).", "\n", "", "points", "=", "view_points", "(", "points", ",", "cam_intrinsic", ",", "normalize", "=", "True", ")", "\n", "\n", "# Skip polygons where all points are outside the image.", "\n", "# Leave a margin of 1 pixel for aesthetic reasons.", "\n", "inside", "=", "np", ".", "ones", "(", "points", ".", "shape", "[", "1", "]", ",", "dtype", "=", "bool", ")", "\n", "inside", "=", "np", ".", "logical_and", "(", "inside", ",", "points", "[", "0", ",", ":", "]", ">", "1", ")", "\n", "inside", "=", "np", ".", "logical_and", "(", "inside", ",", "points", "[", "0", ",", ":", "]", "<", "im", ".", "size", "[", "0", "]", "-", "1", ")", "\n", "inside", "=", "np", ".", "logical_and", "(", "inside", ",", "points", "[", "1", ",", ":", "]", ">", "1", ")", "\n", "inside", "=", "np", ".", "logical_and", "(", "inside", ",", "points", "[", "1", ",", ":", "]", "<", "im", ".", "size", "[", "1", "]", "-", "1", ")", "\n", "if", "render_outside_im", ":", "\n", "                        ", "if", "np", ".", "all", "(", "np", ".", "logical_not", "(", "inside", ")", ")", ":", "\n", "                            ", "continue", "\n", "", "", "else", ":", "\n", "                        ", "if", "np", ".", "any", "(", "np", ".", "logical_not", "(", "inside", ")", ")", ":", "\n", "                            ", "continue", "\n", "\n", "", "", "points", "=", "points", "[", ":", "2", ",", ":", "]", "\n", "points", "=", "[", "(", "p0", ",", "p1", ")", "for", "(", "p0", ",", "p1", ")", "in", "zip", "(", "points", "[", "0", "]", ",", "points", "[", "1", "]", ")", "]", "\n", "polygon_proj", "=", "Polygon", "(", "points", ")", "\n", "\n", "# Filter small polygons", "\n", "if", "polygon_proj", ".", "area", "<", "min_polygon_area", ":", "\n", "                        ", "continue", "\n", "\n", "", "label", "=", "layer_name", "\n", "ax", ".", "add_patch", "(", "descartes", ".", "PolygonPatch", "(", "polygon_proj", ",", "fc", "=", "self", ".", "color_map", "[", "layer_name", "]", ",", "alpha", "=", "alpha", ",", "\n", "label", "=", "label", ")", ")", "\n", "\n", "# Display the image.", "\n", "", "", "", "plt", ".", "axis", "(", "'off'", ")", "\n", "ax", ".", "invert_yaxis", "(", ")", "\n", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "out_path", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ")", "\n", "\n", "", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_egoposes_on_fancy_map": [[1202, 1304], ["tqdm.tqdm.tqdm", "numpy.floor", "numpy.ceil", "any", "map_api.NuScenesMapExplorer.render_map_patch", "matplotlib.axis", "matplotlib.axis", "len", "len", "print", "nusc.get", "int", "nusc.get", "nusc.field2token", "len", "print", "numpy.vstack", "numpy.maximum", "ax.scatter", "matplotlib.savefig", "matplotlib.savefig", "scene_name.replace", "print", "nusc.get", "nusc.get", "nusc.get", "map_poses.append", "map_poses.min", "map_poses.max"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_map_patch", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.field2token", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "render_egoposes_on_fancy_map", "(", "self", ",", "\n", "nusc", ":", "NuScenes", ",", "\n", "scene_tokens", ":", "List", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "render_egoposes", ":", "bool", "=", "True", ",", "\n", "render_egoposes_range", ":", "bool", "=", "True", ",", "\n", "render_legend", ":", "bool", "=", "True", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Renders each ego pose of a list of scenes on the map (around 40 poses per scene).\n        This method is heavily inspired by NuScenes.render_egoposes_on_map(), but uses the map expansion pack maps.\n        Note that the maps are constantly evolving, whereas we only released a single snapshot of the data.\n        Therefore for some scenes there is a bad fit between ego poses and maps.\n        :param nusc: The NuScenes instance to load the ego poses from.\n        :param scene_tokens: Optional list of scene tokens corresponding to the current map location.\n        :param verbose: Whether to show status messages and progress bar.\n        :param out_path: Optional path to save the rendered figure to disk.\n        :param render_egoposes: Whether to render ego poses.\n        :param render_egoposes_range: Whether to render a rectangle around all ego poses.\n        :param render_legend: Whether to render the legend of map layers.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        :return: <np.float32: n, 2>. Returns a matrix with n ego poses in global map coordinates.\n        \"\"\"", "\n", "# Settings", "\n", "patch_margin", "=", "2", "\n", "min_diff_patch", "=", "30", "\n", "\n", "# Ids of scenes with a bad match between localization and map.", "\n", "scene_blacklist", "=", "[", "499", ",", "515", ",", "517", "]", "\n", "\n", "# Get logs by location.", "\n", "log_location", "=", "self", ".", "map_api", ".", "map_name", "\n", "log_tokens", "=", "[", "log", "[", "'token'", "]", "for", "log", "in", "nusc", ".", "log", "if", "log", "[", "'location'", "]", "==", "log_location", "]", "\n", "assert", "len", "(", "log_tokens", ")", ">", "0", ",", "'Error: This split has 0 scenes for location %s!'", "%", "log_location", "\n", "\n", "# Filter scenes.", "\n", "scene_tokens_location", "=", "[", "e", "[", "'token'", "]", "for", "e", "in", "nusc", ".", "scene", "if", "e", "[", "'log_token'", "]", "in", "log_tokens", "]", "\n", "if", "scene_tokens", "is", "not", "None", ":", "\n", "            ", "scene_tokens_location", "=", "[", "t", "for", "t", "in", "scene_tokens_location", "if", "t", "in", "scene_tokens", "]", "\n", "", "assert", "len", "(", "scene_tokens_location", ")", ">", "0", ",", "'Error: Found 0 valid scenes for location %s!'", "%", "log_location", "\n", "\n", "map_poses", "=", "[", "]", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Adding ego poses to map...'", ")", "\n", "", "for", "scene_token", "in", "tqdm", "(", "scene_tokens_location", ",", "disable", "=", "not", "verbose", ")", ":", "\n", "# Check that the scene is from the correct location.", "\n", "            ", "scene_record", "=", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "scene_name", "=", "scene_record", "[", "'name'", "]", "\n", "scene_id", "=", "int", "(", "scene_name", ".", "replace", "(", "'scene-'", ",", "''", ")", ")", "\n", "log_record", "=", "nusc", ".", "get", "(", "'log'", ",", "scene_record", "[", "'log_token'", "]", ")", "\n", "assert", "log_record", "[", "'location'", "]", "==", "log_location", ",", "'Error: The provided scene_tokens do not correspond to the provided map location!'", "\n", "\n", "# Print a warning if the localization is known to be bad.", "\n", "if", "verbose", "and", "scene_id", "in", "scene_blacklist", ":", "\n", "                ", "print", "(", "'Warning: %s is known to have a bad fit between ego pose and map.'", "%", "scene_name", ")", "\n", "\n", "# For each sample in the scene, store the ego pose.", "\n", "", "sample_tokens", "=", "nusc", ".", "field2token", "(", "'sample'", ",", "'scene_token'", ",", "scene_token", ")", "\n", "for", "sample_token", "in", "sample_tokens", ":", "\n", "                ", "sample_record", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "\n", "# Poses are associated with the sample_data. Here we use the lidar sample_data.", "\n", "sample_data_record", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_record", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "\n", "pose_record", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "sample_data_record", "[", "'ego_pose_token'", "]", ")", "\n", "\n", "# Calculate the pose on the map and append.", "\n", "map_poses", ".", "append", "(", "pose_record", "[", "'translation'", "]", ")", "\n", "\n", "# Check that ego poses aren't empty.", "\n", "", "", "assert", "len", "(", "map_poses", ")", ">", "0", ",", "'Error: Found 0 ego poses. Please check the inputs.'", "\n", "\n", "# Compute number of close ego poses.", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Creating plot...'", ")", "\n", "", "map_poses", "=", "np", ".", "vstack", "(", "map_poses", ")", "[", ":", ",", ":", "2", "]", "\n", "\n", "# Render the map patch with the current ego poses.", "\n", "min_patch", "=", "np", ".", "floor", "(", "map_poses", ".", "min", "(", "axis", "=", "0", ")", "-", "patch_margin", ")", "\n", "max_patch", "=", "np", ".", "ceil", "(", "map_poses", ".", "max", "(", "axis", "=", "0", ")", "+", "patch_margin", ")", "\n", "diff_patch", "=", "max_patch", "-", "min_patch", "\n", "if", "any", "(", "diff_patch", "<", "min_diff_patch", ")", ":", "\n", "            ", "center_patch", "=", "(", "min_patch", "+", "max_patch", ")", "/", "2", "\n", "diff_patch", "=", "np", ".", "maximum", "(", "diff_patch", ",", "min_diff_patch", ")", "\n", "min_patch", "=", "center_patch", "-", "diff_patch", "/", "2", "\n", "max_patch", "=", "center_patch", "+", "diff_patch", "/", "2", "\n", "", "my_patch", "=", "(", "min_patch", "[", "0", "]", ",", "min_patch", "[", "1", "]", ",", "max_patch", "[", "0", "]", ",", "max_patch", "[", "1", "]", ")", "\n", "fig", ",", "ax", "=", "self", ".", "render_map_patch", "(", "my_patch", ",", "self", ".", "map_api", ".", "non_geometric_layers", ",", "figsize", "=", "(", "10", ",", "10", ")", ",", "\n", "render_egoposes_range", "=", "render_egoposes_range", ",", "\n", "render_legend", "=", "render_legend", ",", "bitmap", "=", "bitmap", ")", "\n", "\n", "# Plot in the same axis as the map.", "\n", "# Make sure these are plotted \"on top\".", "\n", "if", "render_egoposes", ":", "\n", "            ", "ax", ".", "scatter", "(", "map_poses", "[", ":", ",", "0", "]", ",", "map_poses", "[", ":", ",", "1", "]", ",", "s", "=", "20", ",", "c", "=", "'k'", ",", "alpha", "=", "1.0", ",", "zorder", "=", "2", ")", "\n", "", "plt", ".", "axis", "(", "'off'", ")", "\n", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ")", "\n", "\n", "", "return", "map_poses", ",", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_next_roads": [[1305, 1335], ["map_api.NuScenesMapExplorer.map_api.get_next_roads", "map_api.NuScenesMapExplorer.items", "map_api.NuScenesMapExplorer.render_layers", "ax.plot", "len", "layer_names.append", "tokens.extend"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_next_roads", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.render_layers"], ["", "def", "render_next_roads", "(", "self", ",", "\n", "x", ":", "float", ",", "\n", "y", ":", "float", ",", "\n", "alpha", ":", "float", "=", "0.5", ",", "\n", "figsize", ":", "Union", "[", "None", ",", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", "=", "None", ",", "\n", "bitmap", ":", "Optional", "[", "BitMap", "]", "=", "None", ")", "->", "Tuple", "[", "Figure", ",", "Axes", "]", ":", "\n", "        ", "\"\"\"\n        Renders the possible next roads from a point of interest.\n        :param x: x coordinate of the point of interest.\n        :param y: y coordinate of the point of interest.\n        :param alpha: The opacity of each layer that gets rendered.\n        :param figsize: Size of the whole figure.\n        :param bitmap: Optional BitMap object to render below the other map layers.\n        \"\"\"", "\n", "# Get next roads.", "\n", "next_roads", "=", "self", ".", "map_api", ".", "get_next_roads", "(", "x", ",", "y", ")", "\n", "layer_names", "=", "[", "]", "\n", "tokens", "=", "[", "]", "\n", "for", "layer_name", ",", "layer_tokens", "in", "next_roads", ".", "items", "(", ")", ":", "\n", "            ", "if", "len", "(", "layer_tokens", ")", ">", "0", ":", "\n", "                ", "layer_names", ".", "append", "(", "layer_name", ")", "\n", "tokens", ".", "extend", "(", "layer_tokens", ")", "\n", "\n", "# Render them.", "\n", "", "", "fig", ",", "ax", "=", "self", ".", "render_layers", "(", "layer_names", ",", "alpha", ",", "figsize", ",", "tokens", "=", "tokens", ",", "bitmap", "=", "bitmap", ")", "\n", "\n", "# Render current location with an x.", "\n", "ax", ".", "plot", "(", "x", ",", "y", ",", "'x'", ",", "markersize", "=", "12", ",", "color", "=", "'red'", ")", "\n", "\n", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._clip_points_behind_camera": [[1336, 1399], ["range", "numpy.array().transpose", "numpy.array().transpose.append", "numpy.array", "all", "numpy.array().transpose.append", "numpy.array().transpose.append", "len", "numpy.abs", "numpy.array().transpose.append", "numpy.array().transpose.append", "all", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "@", "staticmethod", "\n", "def", "_clip_points_behind_camera", "(", "points", ",", "near_plane", ":", "float", ")", ":", "\n", "        ", "\"\"\"\n        Perform clipping on polygons that are partially behind the camera.\n        This method is necessary as the projection does not work for points behind the camera.\n        Hence we compute the line between the point and the camera and follow that line until we hit the near plane of\n        the camera. Then we use that point.\n        :param points: <np.float32: 3, n> Matrix of points, where each point (x, y, z) is along each column.\n        :param near_plane: If we set the near_plane distance of the camera to 0 then some points will project to\n            infinity. Therefore we need to clip these points at the near plane.\n        :return: The clipped version of the polygon. This may have fewer points than the original polygon if some lines\n            were entirely behind the polygon.\n        \"\"\"", "\n", "points_clipped", "=", "[", "]", "\n", "# Loop through each line on the polygon.", "\n", "# For each line where exactly 1 endpoints is behind the camera, move the point along the line until", "\n", "# it hits the near plane of the camera (clipping).", "\n", "assert", "points", ".", "shape", "[", "0", "]", "==", "3", "\n", "point_count", "=", "points", ".", "shape", "[", "1", "]", "\n", "for", "line_1", "in", "range", "(", "point_count", ")", ":", "\n", "            ", "line_2", "=", "(", "line_1", "+", "1", ")", "%", "point_count", "\n", "point_1", "=", "points", "[", ":", ",", "line_1", "]", "\n", "point_2", "=", "points", "[", ":", ",", "line_2", "]", "\n", "z_1", "=", "point_1", "[", "2", "]", "\n", "z_2", "=", "point_2", "[", "2", "]", "\n", "\n", "if", "z_1", ">=", "near_plane", "and", "z_2", ">=", "near_plane", ":", "\n", "# Both points are in front.", "\n", "# Add both points unless the first is already added.", "\n", "                ", "if", "len", "(", "points_clipped", ")", "==", "0", "or", "all", "(", "points_clipped", "[", "-", "1", "]", "!=", "point_1", ")", ":", "\n", "                    ", "points_clipped", ".", "append", "(", "point_1", ")", "\n", "", "points_clipped", ".", "append", "(", "point_2", ")", "\n", "", "elif", "z_1", "<", "near_plane", "and", "z_2", "<", "near_plane", ":", "\n", "# Both points are in behind.", "\n", "# Don't add anything.", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "# One point is in front, one behind.", "\n", "# By convention pointA is behind the camera and pointB in front.", "\n", "                ", "if", "z_1", "<=", "z_2", ":", "\n", "                    ", "point_a", "=", "points", "[", ":", ",", "line_1", "]", "\n", "point_b", "=", "points", "[", ":", ",", "line_2", "]", "\n", "", "else", ":", "\n", "                    ", "point_a", "=", "points", "[", ":", ",", "line_2", "]", "\n", "point_b", "=", "points", "[", ":", ",", "line_1", "]", "\n", "", "z_a", "=", "point_a", "[", "2", "]", "\n", "z_b", "=", "point_b", "[", "2", "]", "\n", "\n", "# Clip line along near plane.", "\n", "pointdiff", "=", "point_b", "-", "point_a", "\n", "alpha", "=", "(", "near_plane", "-", "z_b", ")", "/", "(", "z_a", "-", "z_b", ")", "\n", "clipped", "=", "point_a", "+", "(", "1", "-", "alpha", ")", "*", "pointdiff", "\n", "assert", "np", ".", "abs", "(", "clipped", "[", "2", "]", "-", "near_plane", ")", "<", "1e-6", "\n", "\n", "# Add the first point (if valid and not duplicate), the clipped point and the second point (if valid).", "\n", "if", "z_1", ">=", "near_plane", "and", "(", "len", "(", "points_clipped", ")", "==", "0", "or", "all", "(", "points_clipped", "[", "-", "1", "]", "!=", "point_1", ")", ")", ":", "\n", "                    ", "points_clipped", ".", "append", "(", "point_1", ")", "\n", "", "points_clipped", ".", "append", "(", "clipped", ")", "\n", "if", "z_2", ">=", "near_plane", ":", "\n", "                    ", "points_clipped", ".", "append", "(", "point_2", ")", "\n", "\n", "", "", "", "points_clipped", "=", "np", ".", "array", "(", "points_clipped", ")", ".", "transpose", "(", ")", "\n", "return", "points_clipped", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_records_in_patch": [[1400, 1430], ["dict", "ValueError", "getattr", "dict.update", "map_api.NuScenesMapExplorer.is_record_in_patch", "layer_records.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.is_record_in_patch"], ["", "def", "get_records_in_patch", "(", "self", ",", "\n", "box_coords", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "mode", ":", "str", "=", "'intersect'", ")", "->", "Dict", "[", "str", ",", "List", "[", "str", "]", "]", ":", "\n", "        ", "\"\"\"\n        Get all the record token that intersects or within a particular rectangular patch.\n        :param box_coords: The rectangular patch coordinates (x_min, y_min, x_max, y_max).\n        :param layer_names: Names of the layers that we want to retrieve in a particular patch.\n            By default will always look for all non geometric layers.\n        :param mode: \"intersect\" will return all non geometric records that intersects the patch,\n            \"within\" will return all non geometric records that are within the patch.\n        :return: Dictionary of layer_name - tokens pairs.\n        \"\"\"", "\n", "if", "mode", "not", "in", "[", "'intersect'", ",", "'within'", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Mode {} is not valid, choice=('intersect', 'within')\"", ".", "format", "(", "mode", ")", ")", "\n", "\n", "", "if", "layer_names", "is", "None", ":", "\n", "            ", "layer_names", "=", "self", ".", "map_api", ".", "non_geometric_layers", "\n", "\n", "", "records_in_patch", "=", "dict", "(", ")", "\n", "for", "layer_name", "in", "layer_names", ":", "\n", "            ", "layer_records", "=", "[", "]", "\n", "for", "record", "in", "getattr", "(", "self", ".", "map_api", ",", "layer_name", ")", ":", "\n", "                ", "token", "=", "record", "[", "'token'", "]", "\n", "if", "self", ".", "is_record_in_patch", "(", "layer_name", ",", "token", ",", "box_coords", ",", "mode", ")", ":", "\n", "                    ", "layer_records", ".", "append", "(", "token", ")", "\n", "\n", "", "", "records_in_patch", ".", "update", "(", "{", "layer_name", ":", "layer_records", "}", ")", "\n", "\n", "", "return", "records_in_patch", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.is_record_in_patch": [[1431, 1454], ["ValueError", "map_api.NuScenesMapExplorer._is_polygon_record_in_patch", "map_api.NuScenesMapExplorer._is_line_record_in_patch", "ValueError"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._is_polygon_record_in_patch", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._is_line_record_in_patch"], ["", "def", "is_record_in_patch", "(", "self", ",", "\n", "layer_name", ":", "str", ",", "\n", "token", ":", "str", ",", "\n", "box_coords", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "mode", ":", "str", "=", "'intersect'", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Query whether a particular record is in a rectangular patch.\n        :param layer_name: The layer name of the record.\n        :param token: The record token.\n        :param box_coords: The rectangular patch coordinates (x_min, y_min, x_max, y_max).\n        :param mode: \"intersect\" means it will return True if the geometric object intersects the patch and False\n        otherwise, \"within\" will return True if the geometric object is within the patch and False otherwise.\n        :return: Boolean value on whether a particular record intersects or is within a particular patch.\n        \"\"\"", "\n", "if", "mode", "not", "in", "[", "'intersect'", ",", "'within'", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Mode {} is not valid, choice=('intersect', 'within')\"", ".", "format", "(", "mode", ")", ")", "\n", "\n", "", "if", "layer_name", "in", "self", ".", "map_api", ".", "lookup_polygon_layers", ":", "\n", "            ", "return", "self", ".", "_is_polygon_record_in_patch", "(", "token", ",", "layer_name", ",", "box_coords", ",", "mode", ")", "\n", "", "elif", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "return", "self", ".", "_is_line_record_in_patch", "(", "token", ",", "layer_name", ",", "box_coords", ",", "mode", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a valid layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.layers_on_point": [[1455, 1472], ["dict", "dict.update", "map_api.NuScenesMapExplorer.record_on_point"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.record_on_point"], ["", "", "def", "layers_on_point", "(", "self", ",", "x", ":", "float", ",", "y", ":", "float", ",", "layer_names", ":", "List", "[", "str", "]", "=", "None", ")", "->", "Dict", "[", "str", ",", "str", "]", ":", "\n", "        ", "\"\"\"\n        Returns all the polygonal layers that a particular point is on.\n        :param x: x coordinate of the point of interest.\n        :param y: y coordinate of the point of interest.\n        :param layer_names: The names of the layers to search for.\n        :return: All the polygonal layers that a particular point is on.\n        \"\"\"", "\n", "# Default option.", "\n", "if", "layer_names", "is", "None", ":", "\n", "            ", "layer_names", "=", "self", ".", "map_api", ".", "non_geometric_polygon_layers", "\n", "\n", "", "layers_on_point", "=", "dict", "(", ")", "\n", "for", "layer_name", "in", "layer_names", ":", "\n", "            ", "layers_on_point", ".", "update", "(", "{", "layer_name", ":", "self", ".", "record_on_point", "(", "x", ",", "y", ",", "layer_name", ")", "}", ")", "\n", "\n", "", "return", "layers_on_point", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.record_on_point": [[1473, 1505], ["shapely.geometry.Point", "getattr", "ValueError", "map_api.NuScenesMapExplorer.map_api.extract_polygon", "shapely.geometry.Point.within", "map_api.NuScenesMapExplorer.map_api.extract_polygon", "shapely.geometry.Point.within"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon"], ["", "def", "record_on_point", "(", "self", ",", "x", ":", "float", ",", "y", ":", "float", ",", "layer_name", ":", "str", ")", "->", "str", ":", "\n", "        ", "\"\"\"\n        Query what record of a layer a particular point is on.\n        :param x: x coordinate of the point of interest.\n        :param y: y coordinate of the point of interest.\n        :param layer_name: The non geometric polygonal layer name that we are interested in.\n        :return: The first token of a layer a particular point is on or '' if no layer is found.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a polygon layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "point", "=", "Point", "(", "x", ",", "y", ")", "\n", "records", "=", "getattr", "(", "self", ".", "map_api", ",", "layer_name", ")", "\n", "\n", "if", "layer_name", "==", "'drivable_area'", ":", "\n", "            ", "for", "record", "in", "records", ":", "\n", "                ", "polygons", "=", "[", "self", ".", "map_api", ".", "extract_polygon", "(", "polygon_token", ")", "for", "polygon_token", "in", "record", "[", "'polygon_tokens'", "]", "]", "\n", "for", "polygon", "in", "polygons", ":", "\n", "                    ", "if", "point", ".", "within", "(", "polygon", ")", ":", "\n", "                        ", "return", "record", "[", "'token'", "]", "\n", "", "else", ":", "\n", "                        ", "pass", "\n", "", "", "", "", "else", ":", "\n", "            ", "for", "record", "in", "records", ":", "\n", "                ", "polygon", "=", "self", ".", "map_api", ".", "extract_polygon", "(", "record", "[", "'polygon_token'", "]", ")", "\n", "if", "point", ".", "within", "(", "polygon", ")", ":", "\n", "                    ", "return", "record", "[", "'token'", "]", "\n", "", "else", ":", "\n", "                    ", "pass", "\n", "\n", "# If nothing is found, return an empty string.", "\n", "", "", "", "return", "''", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon": [[1506, 1525], ["map_api.NuScenesMapExplorer.map_api.get", "shapely.geometry.Polygon", "len", "interiors.append", "map_api.NuScenesMapExplorer.map_api.get", "map_api.NuScenesMapExplorer.map_api.get", "map_api.NuScenesMapExplorer.map_api.get", "map_api.NuScenesMapExplorer.map_api.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "extract_polygon", "(", "self", ",", "polygon_token", ":", "str", ")", "->", "Polygon", ":", "\n", "        ", "\"\"\"\n        Construct a shapely Polygon object out of a polygon token.\n        :param polygon_token: The token of the polygon record.\n        :return: The polygon wrapped in a shapely Polygon object.\n        \"\"\"", "\n", "polygon_record", "=", "self", ".", "map_api", ".", "get", "(", "'polygon'", ",", "polygon_token", ")", "\n", "\n", "exterior_coords", "=", "[", "(", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "token", ")", "[", "'x'", "]", ",", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "token", ")", "[", "'y'", "]", ")", "\n", "for", "token", "in", "polygon_record", "[", "'exterior_node_tokens'", "]", "]", "\n", "\n", "interiors", "=", "[", "]", "\n", "for", "hole", "in", "polygon_record", "[", "'holes'", "]", ":", "\n", "            ", "interior_coords", "=", "[", "(", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "token", ")", "[", "'x'", "]", ",", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "token", ")", "[", "'y'", "]", ")", "\n", "for", "token", "in", "hole", "[", "'node_tokens'", "]", "]", "\n", "if", "len", "(", "interior_coords", ")", ">", "0", ":", "# Add only non-empty holes.", "\n", "                ", "interiors", ".", "append", "(", "interior_coords", ")", "\n", "\n", "", "", "return", "Polygon", "(", "exterior_coords", ",", "interiors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_line": [[1526, 1537], ["map_api.NuScenesMapExplorer.map_api.get", "shapely.geometry.LineString", "map_api.NuScenesMapExplorer.map_api.get", "map_api.NuScenesMapExplorer.map_api.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "extract_line", "(", "self", ",", "line_token", ":", "str", ")", "->", "LineString", ":", "\n", "        ", "\"\"\"\n        Construct a shapely LineString object out of a line token.\n        :param line_token: The token of the line record.\n        :return: The line wrapped in a LineString object.\n        \"\"\"", "\n", "line_record", "=", "self", ".", "map_api", ".", "get", "(", "'line'", ",", "line_token", ")", "\n", "line_nodes", "=", "[", "(", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "token", ")", "[", "'x'", "]", ",", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "token", ")", "[", "'y'", "]", ")", "\n", "for", "token", "in", "line_record", "[", "'node_tokens'", "]", "]", "\n", "\n", "return", "LineString", "(", "line_nodes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_bounds": [[1538, 1551], ["map_api.NuScenesMapExplorer._get_polygon_bounds", "map_api.NuScenesMapExplorer._get_line_bounds", "ValueError"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_polygon_bounds", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_line_bounds"], ["", "def", "get_bounds", "(", "self", ",", "layer_name", ":", "str", ",", "token", ":", "str", ")", "->", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ":", "\n", "        ", "\"\"\"\n        Get the bounds of the geometric object that corresponds to a non geometric record.\n        :param layer_name: Name of the layer that we are interested in.\n        :param token: Token of the record.\n        :return: min_x, min_y, max_x, max_y of the line representation.\n        \"\"\"", "\n", "if", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "return", "self", ".", "_get_polygon_bounds", "(", "layer_name", ",", "token", ")", "\n", "", "elif", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "return", "self", ".", "_get_line_bounds", "(", "layer_name", ",", "token", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a valid layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_polygon_bounds": [[1552, 1587], ["map_api.NuScenesMapExplorer.map_api.get", "xs.max", "xs.min", "ys.max", "ys.min", "ValueError", "numpy.array", "numpy.array", "map_api.NuScenesMapExplorer.map_api.get", "numpy.array.extend", "map_api.NuScenesMapExplorer.map_api.get", "map_api.NuScenesMapExplorer.map_api.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "", "def", "_get_polygon_bounds", "(", "self", ",", "layer_name", ":", "str", ",", "token", ":", "str", ")", "->", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ":", "\n", "        ", "\"\"\"\n        Get the extremities of the polygon object that corresponds to a non geometric record.\n        :param layer_name: Name of the layer that we are interested in.\n        :param token: Token of the record.\n        :return: min_x, min_y, max_x, max_y of of the polygon or polygons (for drivable_area) representation.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a record with polygon representation\"", ".", "format", "(", "token", ")", ")", "\n", "\n", "", "record", "=", "self", ".", "map_api", ".", "get", "(", "layer_name", ",", "token", ")", "\n", "\n", "if", "layer_name", "==", "'drivable_area'", ":", "\n", "            ", "polygons", "=", "[", "self", ".", "map_api", ".", "get", "(", "'polygon'", ",", "polygon_token", ")", "for", "polygon_token", "in", "record", "[", "'polygon_tokens'", "]", "]", "\n", "exterior_node_coords", "=", "[", "]", "\n", "\n", "for", "polygon", "in", "polygons", ":", "\n", "                ", "nodes", "=", "[", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "node_token", ")", "for", "node_token", "in", "polygon", "[", "'exterior_node_tokens'", "]", "]", "\n", "node_coords", "=", "[", "(", "node", "[", "'x'", "]", ",", "node", "[", "'y'", "]", ")", "for", "node", "in", "nodes", "]", "\n", "exterior_node_coords", ".", "extend", "(", "node_coords", ")", "\n", "\n", "", "exterior_node_coords", "=", "np", ".", "array", "(", "exterior_node_coords", ")", "\n", "", "else", ":", "\n", "            ", "exterior_nodes", "=", "[", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "token", ")", "for", "token", "in", "record", "[", "'exterior_node_tokens'", "]", "]", "\n", "exterior_node_coords", "=", "np", ".", "array", "(", "[", "(", "node", "[", "'x'", "]", ",", "node", "[", "'y'", "]", ")", "for", "node", "in", "exterior_nodes", "]", ")", "\n", "\n", "", "xs", "=", "exterior_node_coords", "[", ":", ",", "0", "]", "\n", "ys", "=", "exterior_node_coords", "[", ":", ",", "1", "]", "\n", "\n", "x2", "=", "xs", ".", "max", "(", ")", "\n", "x1", "=", "xs", ".", "min", "(", ")", "\n", "y2", "=", "ys", ".", "max", "(", ")", "\n", "y1", "=", "ys", ".", "min", "(", ")", "\n", "\n", "return", "x1", ",", "y1", ",", "x2", ",", "y2", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_line_bounds": [[1588, 1612], ["map_api.NuScenesMapExplorer.map_api.get", "numpy.array", "xs.max", "xs.min", "ys.max", "ys.min", "ValueError", "map_api.NuScenesMapExplorer.map_api.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "_get_line_bounds", "(", "self", ",", "layer_name", ":", "str", ",", "token", ":", "str", ")", "->", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ":", "\n", "        ", "\"\"\"\n        Get the bounds of the line object that corresponds to a non geometric record.\n        :param layer_name: Name of the layer that we are interested in.\n        :param token: Token of the record.\n        :return: min_x, min_y, max_x, max_y of of the line representation.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a record with line representation\"", ".", "format", "(", "token", ")", ")", "\n", "\n", "", "record", "=", "self", ".", "map_api", ".", "get", "(", "layer_name", ",", "token", ")", "\n", "nodes", "=", "[", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "node_token", ")", "for", "node_token", "in", "record", "[", "'node_tokens'", "]", "]", "\n", "node_coords", "=", "[", "(", "node", "[", "'x'", "]", ",", "node", "[", "'y'", "]", ")", "for", "node", "in", "nodes", "]", "\n", "node_coords", "=", "np", ".", "array", "(", "node_coords", ")", "\n", "\n", "xs", "=", "node_coords", "[", ":", ",", "0", "]", "\n", "ys", "=", "node_coords", "[", ":", ",", "1", "]", "\n", "\n", "x2", "=", "xs", ".", "max", "(", ")", "\n", "x1", "=", "xs", ".", "min", "(", ")", "\n", "y2", "=", "ys", ".", "max", "(", ")", "\n", "y1", "=", "ys", ".", "min", "(", ")", "\n", "\n", "return", "x1", ",", "y1", ",", "x2", ",", "y2", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._is_polygon_record_in_patch": [[1613, 1644], ["map_api.NuScenesMapExplorer.map_api.get", "shapely.geometry.box", "ValueError", "shapely.geometry.MultiPolygon", "map_api.NuScenesMapExplorer.map_api.extract_polygon", "map_api.NuScenesMapExplorer.intersects", "map_api.NuScenesMapExplorer.map_api.extract_polygon", "map_api.NuScenesMapExplorer.within"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon"], ["", "def", "_is_polygon_record_in_patch", "(", "self", ",", "\n", "token", ":", "str", ",", "\n", "layer_name", ":", "str", ",", "\n", "box_coords", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "mode", ":", "str", "=", "'intersect'", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Query whether a particular polygon record is in a rectangular patch.\n        :param layer_name: The layer name of the record.\n        :param token: The record token.\n        :param box_coords: The rectangular patch coordinates (x_min, y_min, x_max, y_max).\n        :param mode: \"intersect\" means it will return True if the geometric object intersects the patch and False\n        otherwise, \"within\" will return True if the geometric object is within the patch and False otherwise.\n        :return: Boolean value on whether a particular polygon record intersects or is within a particular patch.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "lookup_polygon_layers", ":", "\n", "            ", "raise", "ValueError", "(", "'{} is not a polygonal layer'", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", "=", "box_coords", "\n", "record", "=", "self", ".", "map_api", ".", "get", "(", "layer_name", ",", "token", ")", "\n", "rectangular_patch", "=", "box", "(", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", ")", "\n", "\n", "if", "layer_name", "==", "'drivable_area'", ":", "\n", "            ", "polygons", "=", "[", "self", ".", "map_api", ".", "extract_polygon", "(", "polygon_token", ")", "for", "polygon_token", "in", "record", "[", "'polygon_tokens'", "]", "]", "\n", "geom", "=", "MultiPolygon", "(", "polygons", ")", "\n", "", "else", ":", "\n", "            ", "geom", "=", "self", ".", "map_api", ".", "extract_polygon", "(", "record", "[", "'polygon_token'", "]", ")", "\n", "\n", "", "if", "mode", "==", "'intersect'", ":", "\n", "            ", "return", "geom", ".", "intersects", "(", "rectangular_patch", ")", "\n", "", "elif", "mode", "==", "'within'", ":", "\n", "            ", "return", "geom", ".", "within", "(", "rectangular_patch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._is_line_record_in_patch": [[1645, 1681], ["map_api.NuScenesMapExplorer.map_api.get", "numpy.array", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "ValueError", "map_api.NuScenesMapExplorer.map_api.get", "len", "numpy.any", "numpy.all"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "", "def", "_is_line_record_in_patch", "(", "self", ",", "\n", "token", ":", "str", ",", "\n", "layer_name", ":", "str", ",", "\n", "box_coords", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "mode", ":", "str", "=", "'intersect'", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Query whether a particular line record is in a rectangular patch.\n        :param layer_name: The layer name of the record.\n        :param token: The record token.\n        :param box_coords: The rectangular patch coordinates (x_min, y_min, x_max, y_max).\n        :param mode: \"intersect\" means it will return True if the geometric object intersects the patch and False\n        otherwise, \"within\" will return True if the geometric object is within the patch and False otherwise.\n        :return: Boolean value on whether a particular line  record intersects or is within a particular patch.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a line layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "# Retrieve nodes of this line.", "\n", "", "record", "=", "self", ".", "map_api", ".", "get", "(", "layer_name", ",", "token", ")", "\n", "node_recs", "=", "[", "self", ".", "map_api", ".", "get", "(", "'node'", ",", "node_token", ")", "for", "node_token", "in", "record", "[", "'node_tokens'", "]", "]", "\n", "node_coords", "=", "[", "[", "node", "[", "'x'", "]", ",", "node", "[", "'y'", "]", "]", "for", "node", "in", "node_recs", "]", "\n", "node_coords", "=", "np", ".", "array", "(", "node_coords", ")", "\n", "\n", "# A few lines in Queenstown have zero nodes. In this case we return False.", "\n", "if", "len", "(", "node_coords", ")", "==", "0", ":", "\n", "            ", "return", "False", "\n", "\n", "# Check that nodes fall inside the path.", "\n", "", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", "=", "box_coords", "\n", "cond_x", "=", "np", ".", "logical_and", "(", "node_coords", "[", ":", ",", "0", "]", "<", "x_max", ",", "node_coords", "[", ":", ",", "0", "]", ">", "x_min", ")", "\n", "cond_y", "=", "np", ".", "logical_and", "(", "node_coords", "[", ":", ",", "1", "]", "<", "y_max", ",", "node_coords", "[", ":", ",", "1", "]", ">", "y_min", ")", "\n", "cond", "=", "np", ".", "logical_and", "(", "cond_x", ",", "cond_y", ")", "\n", "if", "mode", "==", "'intersect'", ":", "\n", "            ", "return", "np", ".", "any", "(", "cond", ")", "\n", "", "elif", "mode", "==", "'within'", ":", "\n", "            ", "return", "np", ".", "all", "(", "cond", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._render_layer": [[1682, 1696], ["map_api.NuScenesMapExplorer._render_polygon_layer", "map_api.NuScenesMapExplorer._render_line_layer", "ValueError"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._render_polygon_layer", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._render_line_layer"], ["", "", "def", "_render_layer", "(", "self", ",", "ax", ":", "Axes", ",", "layer_name", ":", "str", ",", "alpha", ":", "float", ",", "tokens", ":", "List", "[", "str", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Wrapper method that renders individual layers on an axis.\n        :param ax: The matplotlib axes where the layer will get rendered.\n        :param layer_name: Name of the layer that we are interested in.\n        :param alpha: The opacity of the layer to be rendered.\n        :param tokens: Optional list of tokens to render. None means all tokens are rendered.\n        \"\"\"", "\n", "if", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "self", ".", "_render_polygon_layer", "(", "ax", ",", "layer_name", ",", "alpha", ",", "tokens", ")", "\n", "", "elif", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "self", ".", "_render_line_layer", "(", "ax", ",", "layer_name", ",", "alpha", ",", "tokens", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a valid layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._render_polygon_layer": [[1697, 1736], ["getattr", "ValueError", "map_api.NuScenesMapExplorer.map_api.extract_polygon", "ax.add_patch", "map_api.NuScenesMapExplorer.map_api.extract_polygon", "ax.add_patch", "descartes.PolygonPatch", "descartes.PolygonPatch"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon"], ["", "", "def", "_render_polygon_layer", "(", "self", ",", "ax", ":", "Axes", ",", "layer_name", ":", "str", ",", "alpha", ":", "float", ",", "tokens", ":", "List", "[", "str", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders an individual non-geometric polygon layer on an axis.\n        :param ax: The matplotlib axes where the layer will get rendered.\n        :param layer_name: Name of the layer that we are interested in.\n        :param alpha: The opacity of the layer to be rendered.\n        :param tokens: Optional list of tokens to render. None means all tokens are rendered.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "raise", "ValueError", "(", "'{} is not a polygonal layer'", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "first_time", "=", "True", "\n", "records", "=", "getattr", "(", "self", ".", "map_api", ",", "layer_name", ")", "\n", "if", "tokens", "is", "not", "None", ":", "\n", "            ", "records", "=", "[", "r", "for", "r", "in", "records", "if", "r", "[", "'token'", "]", "in", "tokens", "]", "\n", "", "if", "layer_name", "==", "'drivable_area'", ":", "\n", "            ", "for", "record", "in", "records", ":", "\n", "                ", "polygons", "=", "[", "self", ".", "map_api", ".", "extract_polygon", "(", "polygon_token", ")", "for", "polygon_token", "in", "record", "[", "'polygon_tokens'", "]", "]", "\n", "\n", "for", "polygon", "in", "polygons", ":", "\n", "                    ", "if", "first_time", ":", "\n", "                        ", "label", "=", "layer_name", "\n", "first_time", "=", "False", "\n", "", "else", ":", "\n", "                        ", "label", "=", "None", "\n", "", "ax", ".", "add_patch", "(", "descartes", ".", "PolygonPatch", "(", "polygon", ",", "fc", "=", "self", ".", "color_map", "[", "layer_name", "]", ",", "alpha", "=", "alpha", ",", "\n", "label", "=", "label", ")", ")", "\n", "", "", "", "else", ":", "\n", "            ", "for", "record", "in", "records", ":", "\n", "                ", "polygon", "=", "self", ".", "map_api", ".", "extract_polygon", "(", "record", "[", "'polygon_token'", "]", ")", "\n", "\n", "if", "first_time", ":", "\n", "                    ", "label", "=", "layer_name", "\n", "first_time", "=", "False", "\n", "", "else", ":", "\n", "                    ", "label", "=", "None", "\n", "\n", "", "ax", ".", "add_patch", "(", "descartes", ".", "PolygonPatch", "(", "polygon", ",", "fc", "=", "self", ".", "color_map", "[", "layer_name", "]", ",", "alpha", "=", "alpha", ",", "\n", "label", "=", "label", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._render_line_layer": [[1737, 1770], ["getattr", "ValueError", "map_api.NuScenesMapExplorer.map_api.extract_line", "ax.add_patch", "ax.plot", "matplotlib.patches.Arrow", "matplotlib.patches.Arrow"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_line"], ["", "", "", "def", "_render_line_layer", "(", "self", ",", "ax", ":", "Axes", ",", "layer_name", ":", "str", ",", "alpha", ":", "float", ",", "tokens", ":", "List", "[", "str", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders an individual non-geometric line layer on an axis.\n        :param ax: The matplotlib axes where the layer will get rendered.\n        :param layer_name: Name of the layer that we are interested in.\n        :param alpha: The opacity of the layer to be rendered.\n        :param tokens: Optional list of tokens to render. None means all tokens are rendered.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a line layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "first_time", "=", "True", "\n", "records", "=", "getattr", "(", "self", ".", "map_api", ",", "layer_name", ")", "\n", "if", "tokens", "is", "not", "None", ":", "\n", "            ", "records", "=", "[", "r", "for", "r", "in", "records", "if", "r", "[", "'token'", "]", "in", "tokens", "]", "\n", "", "for", "record", "in", "records", ":", "\n", "            ", "if", "first_time", ":", "\n", "                ", "label", "=", "layer_name", "\n", "first_time", "=", "False", "\n", "", "else", ":", "\n", "                ", "label", "=", "None", "\n", "", "line", "=", "self", ".", "map_api", ".", "extract_line", "(", "record", "[", "'line_token'", "]", ")", "\n", "if", "line", ".", "is_empty", ":", "# Skip lines without nodes", "\n", "                ", "continue", "\n", "", "xs", ",", "ys", "=", "line", ".", "xy", "\n", "\n", "if", "layer_name", "==", "'traffic_light'", ":", "\n", "# Draws an arrow with the physical traffic light as the starting point, pointing to the direction on", "\n", "# where the traffic light points.", "\n", "                ", "ax", ".", "add_patch", "(", "Arrow", "(", "xs", "[", "0", "]", ",", "ys", "[", "0", "]", ",", "xs", "[", "1", "]", "-", "xs", "[", "0", "]", ",", "ys", "[", "1", "]", "-", "ys", "[", "0", "]", ",", "color", "=", "self", ".", "color_map", "[", "layer_name", "]", ",", "\n", "label", "=", "label", ")", ")", "\n", "", "else", ":", "\n", "                ", "ax", ".", "plot", "(", "xs", ",", "ys", ",", "color", "=", "self", ".", "color_map", "[", "layer_name", "]", ",", "alpha", "=", "alpha", ",", "label", "=", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_layer_geom": [[1771, 1788], ["map_api.NuScenesMapExplorer._get_layer_polygon", "map_api.NuScenesMapExplorer._get_layer_line", "ValueError"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_layer_polygon", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_layer_line"], ["", "", "", "def", "_get_layer_geom", "(", "self", ",", "\n", "patch_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "patch_angle", ":", "float", ",", "\n", "layer_name", ":", "str", ")", "->", "List", "[", "Geometry", "]", ":", "\n", "        ", "\"\"\"\n        Wrapper method that gets the geometries for each layer.\n        :param patch_box: Patch box defined as [x_center, y_center, height, width].\n        :param patch_angle: Patch orientation in degrees.\n        :param layer_name: Name of map layer to be converted to binary map mask patch.\n        :return: List of geometries for the given layer.\n        \"\"\"", "\n", "if", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "return", "self", ".", "_get_layer_polygon", "(", "patch_box", ",", "patch_angle", ",", "layer_name", ")", "\n", "", "elif", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "return", "self", ".", "_get_layer_line", "(", "patch_box", ",", "patch_angle", ",", "layer_name", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a valid layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._layer_geom_to_mask": [[1789, 1808], ["map_api.NuScenesMapExplorer._polygon_geom_to_mask", "map_api.NuScenesMapExplorer._line_geom_to_mask", "ValueError"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._polygon_geom_to_mask", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._line_geom_to_mask"], ["", "", "def", "_layer_geom_to_mask", "(", "self", ",", "\n", "layer_name", ":", "str", ",", "\n", "layer_geom", ":", "List", "[", "Geometry", "]", ",", "\n", "local_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "canvas_size", ":", "Tuple", "[", "int", ",", "int", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Wrapper method that gets the mask for each layer's geometries.\n        :param layer_name: The name of the layer for which we get the masks.\n        :param layer_geom: List of the geometries of the layer specified in layer_name.\n        :param local_box: The local patch box defined as (x_center, y_center, height, width), where typically\n            x_center = y_center = 0.\n        :param canvas_size: Size of the output mask (h, w).\n        \"\"\"", "\n", "if", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "return", "self", ".", "_polygon_geom_to_mask", "(", "layer_geom", ",", "local_box", ",", "layer_name", ",", "canvas_size", ")", "\n", "", "elif", "layer_name", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "return", "self", ".", "_line_geom_to_mask", "(", "layer_geom", ",", "local_box", ",", "layer_name", ",", "canvas_size", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a valid layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.mask_for_polygons": [[1809, 1828], ["cv2.fillPoly", "cv2.fillPoly", "numpy.array().round().astype", "map_api.NuScenesMapExplorer.mask_for_polygons.int_coords"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "mask_for_polygons", "(", "polygons", ":", "MultiPolygon", ",", "mask", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Convert a polygon or multipolygon list to an image mask ndarray.\n        :param polygons: List of Shapely polygons to be converted to numpy array.\n        :param mask: Canvas where mask will be generated.\n        :return: Numpy ndarray polygon mask.\n        \"\"\"", "\n", "if", "not", "polygons", ":", "\n", "            ", "return", "mask", "\n", "\n", "", "def", "int_coords", "(", "x", ")", ":", "\n", "# function to round and convert to int", "\n", "            ", "return", "np", ".", "array", "(", "x", ")", ".", "round", "(", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "", "exteriors", "=", "[", "int_coords", "(", "poly", ".", "exterior", ".", "coords", ")", "for", "poly", "in", "polygons", "]", "\n", "interiors", "=", "[", "int_coords", "(", "pi", ".", "coords", ")", "for", "poly", "in", "polygons", "for", "pi", "in", "poly", ".", "interiors", "]", "\n", "cv2", ".", "fillPoly", "(", "mask", ",", "exteriors", ",", "1", ")", "\n", "cv2", ".", "fillPoly", "(", "mask", ",", "interiors", ",", "0", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.mask_for_lines": [[1829, 1848], ["numpy.asarray", "coords.reshape.reshape.reshape", "cv2.polylines", "numpy.asarray", "coords.reshape.reshape.reshape", "cv2.polylines", "list", "list"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "mask_for_lines", "(", "lines", ":", "LineString", ",", "mask", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Convert a Shapely LineString back to an image mask ndarray.\n        :param lines: List of shapely LineStrings to be converted to a numpy array.\n        :param mask: Canvas where mask will be generated.\n        :return: Numpy ndarray line mask.\n        \"\"\"", "\n", "if", "lines", ".", "geom_type", "==", "'MultiLineString'", ":", "\n", "            ", "for", "line", "in", "lines", ":", "\n", "                ", "coords", "=", "np", ".", "asarray", "(", "list", "(", "line", ".", "coords", ")", ",", "np", ".", "int32", ")", "\n", "coords", "=", "coords", ".", "reshape", "(", "(", "-", "1", ",", "2", ")", ")", "\n", "cv2", ".", "polylines", "(", "mask", ",", "[", "coords", "]", ",", "False", ",", "1", ",", "2", ")", "\n", "", "", "else", ":", "\n", "            ", "coords", "=", "np", ".", "asarray", "(", "list", "(", "lines", ".", "coords", ")", ",", "np", ".", "int32", ")", "\n", "coords", "=", "coords", ".", "reshape", "(", "(", "-", "1", ",", "2", ")", ")", "\n", "cv2", ".", "polylines", "(", "mask", ",", "[", "coords", "]", ",", "False", ",", "1", ",", "2", ")", "\n", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._polygon_geom_to_mask": [[1849, 1893], ["map_api.NuScenesMapExplorer.get_patch_coord", "numpy.zeros", "ValueError", "polygon.intersection", "shapely.affinity.affine_transform", "shapely.affinity.scale", "map_api.NuScenesMapExplorer.mask_for_polygons", "shapely.geometry.MultiPolygon"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_patch_coord", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.mask_for_polygons"], ["", "def", "_polygon_geom_to_mask", "(", "self", ",", "\n", "layer_geom", ":", "List", "[", "Polygon", "]", ",", "\n", "local_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "layer_name", ":", "str", ",", "\n", "canvas_size", ":", "Tuple", "[", "int", ",", "int", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Convert polygon inside patch to binary mask and return the map patch.\n        :param layer_geom: list of polygons for each map layer\n        :param local_box: The local patch box defined as (x_center, y_center, height, width), where typically\n            x_center = y_center = 0.\n        :param layer_name: name of map layer to be converted to binary map mask patch.\n        :param canvas_size: Size of the output mask (h, w).\n        :return: Binary map mask patch with the size canvas_size.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "raise", "ValueError", "(", "'{} is not a polygonal layer'", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "patch_x", ",", "patch_y", ",", "patch_h", ",", "patch_w", "=", "local_box", "\n", "\n", "patch", "=", "self", ".", "get_patch_coord", "(", "local_box", ")", "\n", "\n", "canvas_h", "=", "canvas_size", "[", "0", "]", "\n", "canvas_w", "=", "canvas_size", "[", "1", "]", "\n", "\n", "scale_height", "=", "canvas_h", "/", "patch_h", "\n", "scale_width", "=", "canvas_w", "/", "patch_w", "\n", "\n", "trans_x", "=", "-", "patch_x", "+", "patch_w", "/", "2.0", "\n", "trans_y", "=", "-", "patch_y", "+", "patch_h", "/", "2.0", "\n", "\n", "map_mask", "=", "np", ".", "zeros", "(", "canvas_size", ",", "np", ".", "uint8", ")", "\n", "\n", "for", "polygon", "in", "layer_geom", ":", "\n", "            ", "new_polygon", "=", "polygon", ".", "intersection", "(", "patch", ")", "\n", "if", "not", "new_polygon", ".", "is_empty", ":", "\n", "                ", "new_polygon", "=", "affinity", ".", "affine_transform", "(", "new_polygon", ",", "\n", "[", "1.0", ",", "0.0", ",", "0.0", ",", "1.0", ",", "trans_x", ",", "trans_y", "]", ")", "\n", "new_polygon", "=", "affinity", ".", "scale", "(", "new_polygon", ",", "xfact", "=", "scale_width", ",", "yfact", "=", "scale_height", ",", "origin", "=", "(", "0", ",", "0", ")", ")", "\n", "\n", "if", "new_polygon", ".", "geom_type", "is", "'Polygon'", ":", "\n", "                    ", "new_polygon", "=", "MultiPolygon", "(", "[", "new_polygon", "]", ")", "\n", "", "map_mask", "=", "self", ".", "mask_for_polygons", "(", "new_polygon", ",", "map_mask", ")", "\n", "\n", "", "", "return", "map_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._line_geom_to_mask": [[1894, 1937], ["map_api.NuScenesMapExplorer.get_patch_coord", "numpy.zeros", "ValueError", "line.intersection", "shapely.affinity.affine_transform", "shapely.affinity.scale", "map_api.NuScenesMapExplorer.mask_for_lines"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_patch_coord", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.mask_for_lines"], ["", "def", "_line_geom_to_mask", "(", "self", ",", "\n", "layer_geom", ":", "List", "[", "LineString", "]", ",", "\n", "local_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "layer_name", ":", "str", ",", "\n", "canvas_size", ":", "Tuple", "[", "int", ",", "int", "]", ")", "->", "Optional", "[", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Convert line inside patch to binary mask and return the map patch.\n        :param layer_geom: list of LineStrings for each map layer\n        :param local_box: The local patch box defined as (x_center, y_center, height, width), where typically\n            x_center = y_center = 0.\n        :param layer_name: name of map layer to be converted to binary map mask patch.\n        :param canvas_size: Size of the output mask (h, w).\n        :return: Binary map mask patch in a canvas size.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a line layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "patch_x", ",", "patch_y", ",", "patch_h", ",", "patch_w", "=", "local_box", "\n", "\n", "patch", "=", "self", ".", "get_patch_coord", "(", "local_box", ")", "\n", "\n", "canvas_h", "=", "canvas_size", "[", "0", "]", "\n", "canvas_w", "=", "canvas_size", "[", "1", "]", "\n", "scale_height", "=", "canvas_h", "/", "patch_h", "\n", "scale_width", "=", "canvas_w", "/", "patch_w", "\n", "\n", "trans_x", "=", "-", "patch_x", "+", "patch_w", "/", "2.0", "\n", "trans_y", "=", "-", "patch_y", "+", "patch_h", "/", "2.0", "\n", "\n", "map_mask", "=", "np", ".", "zeros", "(", "canvas_size", ",", "np", ".", "uint8", ")", "\n", "\n", "if", "layer_name", "is", "'traffic_light'", ":", "\n", "            ", "return", "None", "\n", "\n", "", "for", "line", "in", "layer_geom", ":", "\n", "            ", "new_line", "=", "line", ".", "intersection", "(", "patch", ")", "\n", "if", "not", "new_line", ".", "is_empty", ":", "\n", "                ", "new_line", "=", "affinity", ".", "affine_transform", "(", "new_line", ",", "\n", "[", "1.0", ",", "0.0", ",", "0.0", ",", "1.0", ",", "trans_x", ",", "trans_y", "]", ")", "\n", "new_line", "=", "affinity", ".", "scale", "(", "new_line", ",", "xfact", "=", "scale_width", ",", "yfact", "=", "scale_height", ",", "origin", "=", "(", "0", ",", "0", ")", ")", "\n", "\n", "map_mask", "=", "self", ".", "mask_for_lines", "(", "new_line", ",", "map_mask", ")", "\n", "", "", "return", "map_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_layer_polygon": [[1938, 1991], ["map_api.NuScenesMapExplorer.get_patch_coord", "getattr", "ValueError", "map_api.NuScenesMapExplorer.map_api.extract_polygon", "map_api.NuScenesMapExplorer.map_api.extract_polygon", "map_api.NuScenesMapExplorer.intersection", "map_api.NuScenesMapExplorer.intersection", "shapely.affinity.rotate", "shapely.affinity.affine_transform", "polygon_list.append", "shapely.affinity.rotate", "shapely.affinity.affine_transform", "polygon_list.append", "shapely.geometry.MultiPolygon", "shapely.geometry.MultiPolygon"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_patch_coord", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_polygon", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], ["", "def", "_get_layer_polygon", "(", "self", ",", "\n", "patch_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "patch_angle", ":", "float", ",", "\n", "layer_name", ":", "str", ")", "->", "List", "[", "Polygon", "]", ":", "\n", "        ", "\"\"\"\n         Retrieve the polygons of a particular layer within the specified patch.\n         :param patch_box: Patch box defined as [x_center, y_center, height, width].\n         :param patch_angle: Patch orientation in degrees.\n         :param layer_name: name of map layer to be extracted.\n         :return: List of Polygon in a patch box.\n         \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_polygon_layers", ":", "\n", "            ", "raise", "ValueError", "(", "'{} is not a polygonal layer'", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "patch_x", "=", "patch_box", "[", "0", "]", "\n", "patch_y", "=", "patch_box", "[", "1", "]", "\n", "\n", "patch", "=", "self", ".", "get_patch_coord", "(", "patch_box", ",", "patch_angle", ")", "\n", "\n", "records", "=", "getattr", "(", "self", ".", "map_api", ",", "layer_name", ")", "\n", "\n", "polygon_list", "=", "[", "]", "\n", "if", "layer_name", "==", "'drivable_area'", ":", "\n", "            ", "for", "record", "in", "records", ":", "\n", "                ", "polygons", "=", "[", "self", ".", "map_api", ".", "extract_polygon", "(", "polygon_token", ")", "for", "polygon_token", "in", "record", "[", "'polygon_tokens'", "]", "]", "\n", "\n", "for", "polygon", "in", "polygons", ":", "\n", "                    ", "new_polygon", "=", "polygon", ".", "intersection", "(", "patch", ")", "\n", "if", "not", "new_polygon", ".", "is_empty", ":", "\n", "                        ", "new_polygon", "=", "affinity", ".", "rotate", "(", "new_polygon", ",", "-", "patch_angle", ",", "\n", "origin", "=", "(", "patch_x", ",", "patch_y", ")", ",", "use_radians", "=", "False", ")", "\n", "new_polygon", "=", "affinity", ".", "affine_transform", "(", "new_polygon", ",", "\n", "[", "1.0", ",", "0.0", ",", "0.0", ",", "1.0", ",", "-", "patch_x", ",", "-", "patch_y", "]", ")", "\n", "if", "new_polygon", ".", "geom_type", "is", "'Polygon'", ":", "\n", "                            ", "new_polygon", "=", "MultiPolygon", "(", "[", "new_polygon", "]", ")", "\n", "", "polygon_list", ".", "append", "(", "new_polygon", ")", "\n", "\n", "", "", "", "", "else", ":", "\n", "            ", "for", "record", "in", "records", ":", "\n", "                ", "polygon", "=", "self", ".", "map_api", ".", "extract_polygon", "(", "record", "[", "'polygon_token'", "]", ")", "\n", "\n", "if", "polygon", ".", "is_valid", ":", "\n", "                    ", "new_polygon", "=", "polygon", ".", "intersection", "(", "patch", ")", "\n", "if", "not", "new_polygon", ".", "is_empty", ":", "\n", "                        ", "new_polygon", "=", "affinity", ".", "rotate", "(", "new_polygon", ",", "-", "patch_angle", ",", "\n", "origin", "=", "(", "patch_x", ",", "patch_y", ")", ",", "use_radians", "=", "False", ")", "\n", "new_polygon", "=", "affinity", ".", "affine_transform", "(", "new_polygon", ",", "\n", "[", "1.0", ",", "0.0", ",", "0.0", ",", "1.0", ",", "-", "patch_x", ",", "-", "patch_y", "]", ")", "\n", "if", "new_polygon", ".", "geom_type", "is", "'Polygon'", ":", "\n", "                            ", "new_polygon", "=", "MultiPolygon", "(", "[", "new_polygon", "]", ")", "\n", "", "polygon_list", ".", "append", "(", "new_polygon", ")", "\n", "\n", "", "", "", "", "return", "polygon_list", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_layer_line": [[1992, 2029], ["map_api.NuScenesMapExplorer.get_patch_coord", "getattr", "ValueError", "map_api.NuScenesMapExplorer.map_api.extract_line", "map_api.NuScenesMapExplorer.intersection", "shapely.affinity.rotate", "shapely.affinity.affine_transform", "line_list.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_patch_coord", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.extract_line", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], ["", "def", "_get_layer_line", "(", "self", ",", "\n", "patch_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "patch_angle", ":", "float", ",", "\n", "layer_name", ":", "str", ")", "->", "Optional", "[", "List", "[", "LineString", "]", "]", ":", "\n", "        ", "\"\"\"\n        Retrieve the lines of a particular layer within the specified patch.\n        :param patch_box: Patch box defined as [x_center, y_center, height, width].\n        :param patch_angle: Patch orientation in degrees.\n        :param layer_name: name of map layer to be converted to binary map mask patch.\n        :return: List of LineString in a patch box.\n        \"\"\"", "\n", "if", "layer_name", "not", "in", "self", ".", "map_api", ".", "non_geometric_line_layers", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a line layer\"", ".", "format", "(", "layer_name", ")", ")", "\n", "\n", "", "if", "layer_name", "is", "'traffic_light'", ":", "\n", "            ", "return", "None", "\n", "\n", "", "patch_x", "=", "patch_box", "[", "0", "]", "\n", "patch_y", "=", "patch_box", "[", "1", "]", "\n", "\n", "patch", "=", "self", ".", "get_patch_coord", "(", "patch_box", ",", "patch_angle", ")", "\n", "\n", "line_list", "=", "[", "]", "\n", "records", "=", "getattr", "(", "self", ".", "map_api", ",", "layer_name", ")", "\n", "for", "record", "in", "records", ":", "\n", "            ", "line", "=", "self", ".", "map_api", ".", "extract_line", "(", "record", "[", "'line_token'", "]", ")", "\n", "if", "line", ".", "is_empty", ":", "# Skip lines without nodes.", "\n", "                ", "continue", "\n", "\n", "", "new_line", "=", "line", ".", "intersection", "(", "patch", ")", "\n", "if", "not", "new_line", ".", "is_empty", ":", "\n", "                ", "new_line", "=", "affinity", ".", "rotate", "(", "new_line", ",", "-", "patch_angle", ",", "origin", "=", "(", "patch_x", ",", "patch_y", ")", ",", "use_radians", "=", "False", ")", "\n", "new_line", "=", "affinity", ".", "affine_transform", "(", "new_line", ",", "\n", "[", "1.0", ",", "0.0", ",", "0.0", ",", "1.0", ",", "-", "patch_x", ",", "-", "patch_y", "]", ")", "\n", "line_list", ".", "append", "(", "new_line", ")", "\n", "\n", "", "", "return", "line_list", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_patch_coord": [[2030, 2050], ["shapely.geometry.box", "shapely.affinity.rotate"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], ["", "@", "staticmethod", "\n", "def", "get_patch_coord", "(", "patch_box", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ",", "\n", "patch_angle", ":", "float", "=", "0.0", ")", "->", "Polygon", ":", "\n", "        ", "\"\"\"\n        Convert patch_box to shapely Polygon coordinates.\n        :param patch_box: Patch box defined as [x_center, y_center, height, width].\n        :param patch_angle: Patch orientation in degrees.\n        :return: Box Polygon for patch_box.\n        \"\"\"", "\n", "patch_x", ",", "patch_y", ",", "patch_h", ",", "patch_w", "=", "patch_box", "\n", "\n", "x_min", "=", "patch_x", "-", "patch_w", "/", "2.0", "\n", "y_min", "=", "patch_y", "-", "patch_h", "/", "2.0", "\n", "x_max", "=", "patch_x", "+", "patch_w", "/", "2.0", "\n", "y_max", "=", "patch_y", "+", "patch_h", "/", "2.0", "\n", "\n", "patch", "=", "box", "(", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", ")", "\n", "patch", "=", "affinity", ".", "rotate", "(", "patch", ",", "patch_angle", ",", "origin", "=", "(", "patch_x", ",", "patch_y", ")", ",", "use_radians", "=", "False", ")", "\n", "\n", "return", "patch", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer._get_figsize": [[2051, 2072], ["tuple", "numpy.array", "type", "tuple", "Exception", "type", "len"], "methods", ["None"], ["", "def", "_get_figsize", "(", "self", ",", "figsize", ":", "Union", "[", "None", ",", "float", ",", "Tuple", "[", "float", ",", "float", "]", "]", ")", "->", "Tuple", "[", "float", ",", "float", "]", ":", "\n", "        ", "\"\"\"\n        Utility function that scales the figure size by the map canvas size.\n        If figsize is:\n        - None      => Return default scale.\n        - Scalar    => Scale canvas size.\n        - Two-tuple => Use the specified figure size.\n        :param figsize: The input figure size.\n        :return: The output figure size.\n        \"\"\"", "\n", "# Divide canvas size by arbitrary scalar to get into cm range.", "\n", "canvas_size", "=", "np", ".", "array", "(", "self", ".", "map_api", ".", "canvas_edge", ")", "[", ":", ":", "-", "1", "]", "/", "200", "\n", "\n", "if", "figsize", "is", "None", ":", "\n", "            ", "return", "tuple", "(", "canvas_size", ")", "\n", "", "elif", "type", "(", "figsize", ")", "in", "[", "int", ",", "float", "]", ":", "\n", "            ", "return", "tuple", "(", "canvas_size", "*", "figsize", ")", "\n", "", "elif", "type", "(", "figsize", ")", "==", "tuple", "and", "len", "(", "figsize", ")", "==", "2", ":", "\n", "            ", "return", "figsize", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Error: Invalid figsize: %s'", "%", "figsize", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.utils.get_egoposes_on_drivable_ratio": [[7, 36], ["nusc.field2token", "nusc.get", "nusc.get", "nusc.get", "nusc_map.record_on_point", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.field2token", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.record_on_point"], ["import", "warnings", "\n", "\n", "import", "matplotlib", ".", "font_manager", "\n", "from", "PIL", "import", "ImageFont", "\n", "import", "numpy", "as", "np", "\n", "from", "pycocotools", "import", "mask", "as", "cocomask", "\n", "\n", "\n", "def", "annotation_name", "(", "attributes", ":", "List", "[", "dict", "]", ",", "\n", "category_name", ":", "str", ",", "\n", "with_attributes", ":", "bool", "=", "False", ")", "->", "str", ":", "\n", "    ", "\"\"\"\n    Returns the \"name\" of an annotation, optionally including the attributes.\n    :param attributes: The attribute dictionary.\n    :param category_name: Name of the object category.\n    :param with_attributes: Whether to print the attributes alongside the category name.\n    :return: A human readable string describing the annotation.\n    \"\"\"", "\n", "outstr", "=", "category_name", "\n", "\n", "if", "with_attributes", ":", "\n", "        ", "atts", "=", "[", "attribute", "[", "'name'", "]", "for", "attribute", "in", "attributes", "]", "\n", "if", "len", "(", "atts", ")", ">", "0", ":", "\n", "            ", "outstr", "=", "outstr", "+", "\"--\"", "+", "'.'", ".", "join", "(", "atts", ")", "\n", "\n", "", "", "return", "outstr", "\n", "\n", "\n", "", "def", "mask_decode", "(", "mask", ":", "dict", ")", "->", "np", ".", "ndarray", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.utils.get_disconnected_subtrees": [[38, 71], ["set", "set", "list", "set", "set.add", "connectivity.keys", "len", "set.pop", "set.add", "len", "len", "set", "set.add"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["\n", "# Note that it is essential to copy the mask here. If we use the same variable we will overwrite the NuImage class", "\n", "# and cause the Jupyter Notebook to crash on some systems.", "\n", "new_mask", "=", "mask", ".", "copy", "(", ")", "\n", "new_mask", "[", "'counts'", "]", "=", "base64", ".", "b64decode", "(", "mask", "[", "'counts'", "]", ")", "\n", "return", "cocomask", ".", "decode", "(", "new_mask", ")", "\n", "\n", "\n", "", "def", "get_font", "(", "fonts_valid", ":", "List", "[", "str", "]", "=", "None", ",", "font_size", ":", "int", "=", "15", ")", "->", "ImageFont", ":", "\n", "    ", "\"\"\"\n    Check if there is a desired font present in the user's system. If there is, use that font; otherwise, use a default\n    font.\n    :param fonts_valid: A list of fonts which are desirable.\n    :param font_size: The size of the font to set. Note that if the default font is used, then the font size\n        cannot be set.\n    :return: An ImageFont object to use as the font in a PIL image.\n    \"\"\"", "\n", "# If there are no desired fonts supplied, use a hardcoded list of fonts which are desirable.", "\n", "if", "fonts_valid", "is", "None", ":", "\n", "        ", "fonts_valid", "=", "[", "'FreeSerif.ttf'", ",", "'FreeSans.ttf'", ",", "'Century.ttf'", ",", "'Calibri.ttf'", ",", "'arial.ttf'", "]", "\n", "\n", "# Find a list of fonts within the user's system.", "\n", "", "fonts_in_sys", "=", "matplotlib", ".", "font_manager", ".", "findSystemFonts", "(", "fontpaths", "=", "None", ",", "fontext", "=", "'ttf'", ")", "\n", "# Sort the list of fonts to ensure that the desired fonts are always found in the same order.", "\n", "fonts_in_sys", "=", "sorted", "(", "fonts_in_sys", ")", "\n", "# Of all the fonts found in the user's system, check if any of them are desired.", "\n", "for", "font_in_sys", "in", "fonts_in_sys", ":", "\n", "        ", "if", "any", "(", "os", ".", "path", ".", "basename", "(", "font_in_sys", ")", "in", "s", "for", "s", "in", "fonts_valid", ")", ":", "\n", "            ", "return", "ImageFont", ".", "truetype", "(", "font_in_sys", ",", "font_size", ")", "\n", "\n", "# If none of the fonts in the user's system are desirable, then use the default font.", "\n", "", "", "warnings", ".", "warn", "(", "'No suitable fonts were found in your system. '", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.utils.drop_disconnected_lanes": [[73, 116], ["utils.get_disconnected_lanes", "nusc_map.connectivity.items", "nusc_map._make_token2ind", "empty_connectivity.append", "len", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.utils.get_disconnected_lanes", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap._make_token2ind"], ["return", "ImageFont", ".", "load_default", "(", ")", "\n", "\n", "\n", "", "def", "name_to_index_mapping", "(", "category", ":", "List", "[", "dict", "]", ")", "->", "Dict", "[", "str", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Build a mapping from name to index to look up index in O(1) time.\n    :param category: The nuImages category table.\n    :return: The mapping from category name to category index.\n    \"\"\"", "\n", "# The 0 index is reserved for non-labelled background; thus, the categories should start from index 1.", "\n", "# Also, sort the categories before looping so that the order is always the same (alphabetical).", "\n", "name_to_index", "=", "dict", "(", ")", "\n", "i", "=", "1", "\n", "sorted_category", ":", "List", "=", "sorted", "(", "category", ".", "copy", "(", ")", ",", "key", "=", "lambda", "k", ":", "k", "[", "'name'", "]", ")", "\n", "for", "c", "in", "sorted_category", ":", "\n", "# Ignore the vehicle.ego and flat.driveable_surface classes first; they will be mapped later.", "\n", "        ", "if", "c", "[", "'name'", "]", "!=", "'vehicle.ego'", "and", "c", "[", "'name'", "]", "!=", "'flat.driveable_surface'", ":", "\n", "            ", "name_to_index", "[", "c", "[", "'name'", "]", "]", "=", "i", "\n", "i", "+=", "1", "\n", "\n", "", "", "assert", "max", "(", "name_to_index", ".", "values", "(", ")", ")", "<", "24", ",", "'Error: There are {} classes (excluding vehicle.ego and flat.driveable_surface), '", "'but there should be 23. Please check your category.json'", ".", "format", "(", "max", "(", "name_to_index", ".", "values", "(", ")", ")", ")", "\n", "\n", "# Now map the vehicle.ego and flat.driveable_surface classes.", "\n", "name_to_index", "[", "'flat.driveable_surface'", "]", "=", "24", "\n", "name_to_index", "[", "'vehicle.ego'", "]", "=", "31", "\n", "\n", "# Ensure that each class name is uniquely paired with a class index, and vice versa.", "\n", "assert", "len", "(", "name_to_index", ")", "==", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ",", "'Error: There are {} class names but {} class indices'", ".", "format", "(", "len", "(", "name_to_index", ")", ",", "\n", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ")", "\n", "\n", "return", "name_to_index", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.utils.get_disconnected_lanes": [[118, 143], ["set", "nusc_map.connectivity.items", "utils.get_disconnected_subtrees", "disconnected.union.union", "sorted", "list", "len", "disconnected.union.add", "disconnected.union.add"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.utils.get_disconnected_subtrees"], []], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.__init__": [[79, 86], ["helper.PredictHelper._map_sample_and_instance_to_annotation"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._map_sample_and_instance_to_annotation"], ["def", "__init__", "(", "self", ",", "nusc", ":", "NuScenes", ")", ":", "\n", "        ", "\"\"\"\n        Inits PredictHelper\n        :param nusc: Instance of NuScenes class.\n        \"\"\"", "\n", "self", ".", "data", "=", "nusc", "\n", "self", ".", "inst_sample_to_ann", "=", "self", ".", "_map_sample_and_instance_to_annotation", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._map_sample_and_instance_to_annotation": [[87, 98], ["None"], "methods", ["None"], ["", "def", "_map_sample_and_instance_to_annotation", "(", "self", ")", "->", "Dict", "[", "Tuple", "[", "str", ",", "str", "]", ",", "str", "]", ":", "\n", "        ", "\"\"\"\n        Creates mapping to look up an annotation given a sample and instance in constant time.\n        :return: Mapping from (sample_token, instance_token) -> sample_annotation_token.\n        \"\"\"", "\n", "mapping", "=", "{", "}", "\n", "\n", "for", "record", "in", "self", ".", "data", ".", "sample_annotation", ":", "\n", "            ", "mapping", "[", "(", "record", "[", "'sample_token'", "]", ",", "record", "[", "'instance_token'", "]", ")", "]", "=", "record", "[", "'token'", "]", "\n", "\n", "", "return", "mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._timestamp_for_sample": [[99, 106], ["helper.PredictHelper.data.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "_timestamp_for_sample", "(", "self", ",", "sample_token", ":", "str", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Gets timestamp from sample token.\n        :param sample_token: Get the timestamp for this sample.\n        :return: Timestamp (microseconds).\n        \"\"\"", "\n", "return", "self", ".", "data", ".", "get", "(", "'sample'", ",", "sample_token", ")", "[", "'timestamp'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._absolute_time_diff": [[107, 115], ["abs"], "methods", ["None"], ["", "def", "_absolute_time_diff", "(", "self", ",", "time1", ":", "float", ",", "time2", ":", "float", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Helper to compute how much time has elapsed in _iterate method.\n        :param time1: First timestamp (microseconds since unix epoch).\n        :param time2: Second timestamp (microseconds since unix epoch).\n        :return: Absolute Time difference in floats.\n        \"\"\"", "\n", "return", "abs", "(", "time1", "-", "time2", ")", "/", "MICROSECONDS_PER_SECOND", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._iterate": [[116, 157], ["helper.PredictHelper._timestamp_for_sample", "int", "ValueError", "helper.PredictHelper.data.get", "helper.PredictHelper._timestamp_for_sample", "helper.PredictHelper._absolute_time_diff", "len", "annotations.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._timestamp_for_sample", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._timestamp_for_sample", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._absolute_time_diff"], ["", "def", "_iterate", "(", "self", ",", "starting_annotation", ":", "Dict", "[", "str", ",", "Any", "]", ",", "seconds", ":", "float", ",", "direction", ":", "str", ")", "->", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", ":", "\n", "        ", "\"\"\"\n        Iterates forwards or backwards in time through the annotations for a given amount of seconds.\n        :param starting_annotation: Sample annotation record to start from.\n        :param seconds: Number of seconds to iterate.\n        :param direction: 'prev' for past and 'next' for future.\n        :return: List of annotations ordered by time.\n        \"\"\"", "\n", "if", "seconds", "<", "0", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Parameter seconds must be non-negative. Received {seconds}.\"", ")", "\n", "\n", "# Need to exit early because we technically _could_ return data in this case if", "\n", "# the first observation is within the BUFFER.", "\n", "", "if", "seconds", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "seconds_with_buffer", "=", "seconds", "+", "BUFFER", "\n", "starting_time", "=", "self", ".", "_timestamp_for_sample", "(", "starting_annotation", "[", "'sample_token'", "]", ")", "\n", "\n", "next_annotation", "=", "starting_annotation", "\n", "\n", "time_elapsed", "=", "0.", "\n", "\n", "annotations", "=", "[", "]", "\n", "\n", "expected_samples_per_sec", "=", "2", "\n", "max_annotations", "=", "int", "(", "expected_samples_per_sec", "*", "seconds", ")", "\n", "while", "time_elapsed", "<=", "seconds_with_buffer", "and", "len", "(", "annotations", ")", "<", "max_annotations", ":", "\n", "\n", "            ", "if", "next_annotation", "[", "direction", "]", "==", "''", ":", "\n", "                ", "break", "\n", "\n", "", "next_annotation", "=", "self", ".", "data", ".", "get", "(", "'sample_annotation'", ",", "next_annotation", "[", "direction", "]", ")", "\n", "current_time", "=", "self", ".", "_timestamp_for_sample", "(", "next_annotation", "[", "'sample_token'", "]", ")", "\n", "\n", "time_elapsed", "=", "self", ".", "_absolute_time_diff", "(", "current_time", ",", "starting_time", ")", "\n", "\n", "if", "time_elapsed", "<", "seconds_with_buffer", ":", "\n", "                ", "annotations", ".", "append", "(", "next_annotation", ")", "\n", "\n", "", "", "return", "annotations", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_sample_annotation": [[158, 166], ["helper.PredictHelper.data.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_sample_annotation", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ")", "->", "Record", ":", "\n", "        ", "\"\"\"\n        Retrieves an annotation given an instance token and its sample.\n        :param instance_token: Instance token.\n        :param sample_token: Sample token for instance.\n        :return: Sample annotation record.\n        \"\"\"", "\n", "return", "self", ".", "data", ".", "get", "(", "'sample_annotation'", ",", "self", ".", "inst_sample_to_ann", "[", "(", "sample_token", ",", "instance_token", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_annotations_for_sample": [[167, 181], ["helper.PredictHelper.data.get", "helper.PredictHelper.data.get", "annotations.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_annotations_for_sample", "(", "self", ",", "sample_token", ":", "str", ")", "->", "List", "[", "Record", "]", ":", "\n", "        ", "\"\"\"\n        Gets a list of sample annotation records for a sample.\n        :param sample_token: Sample token.\n        \"\"\"", "\n", "\n", "sample_record", "=", "self", ".", "data", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "annotations", "=", "[", "]", "\n", "\n", "for", "annotation_token", "in", "sample_record", "[", "'anns'", "]", ":", "\n", "            ", "annotation_record", "=", "self", ".", "data", ".", "get", "(", "'sample_annotation'", ",", "annotation_token", ")", "\n", "annotations", ".", "append", "(", "annotation_record", ")", "\n", "\n", "", "return", "annotations", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._get_past_or_future_for_agent": [[182, 213], ["helper.PredictHelper.get_sample_annotation", "helper.PredictHelper._iterate", "numpy.array", "helper.convert_global_coords_to_local"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_sample_annotation", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._iterate", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local"], ["", "def", "_get_past_or_future_for_agent", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ",", "\n", "seconds", ":", "float", ",", "in_agent_frame", ":", "bool", ",", "\n", "direction", ":", "str", ",", "\n", "just_xy", ":", "bool", "=", "True", ")", "->", "Union", "[", "List", "[", "Record", "]", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Helper function to reduce code duplication between get_future and get_past for agent.\n        :param instance_token: Instance of token.\n        :param sample_token: Sample token for instance.\n        :param seconds: How many seconds of data to retrieve.\n        :param in_agent_frame: Whether to rotate the coordinates so the\n            heading is aligned with the y-axis.\n        :param direction: 'next' for future or 'prev' for past.\n        :return: array of shape [n_timesteps, 2].\n        \"\"\"", "\n", "starting_annotation", "=", "self", ".", "get_sample_annotation", "(", "instance_token", ",", "sample_token", ")", "\n", "sequence", "=", "self", ".", "_iterate", "(", "starting_annotation", ",", "seconds", ",", "direction", ")", "\n", "\n", "if", "not", "just_xy", ":", "\n", "            ", "return", "sequence", "\n", "\n", "", "coords", "=", "np", ".", "array", "(", "[", "r", "[", "'translation'", "]", "[", ":", "2", "]", "for", "r", "in", "sequence", "]", ")", "\n", "\n", "if", "coords", ".", "size", "==", "0", ":", "\n", "            ", "return", "coords", "\n", "\n", "", "if", "in_agent_frame", ":", "\n", "            ", "coords", "=", "convert_global_coords_to_local", "(", "coords", ",", "\n", "starting_annotation", "[", "'translation'", "]", ",", "\n", "starting_annotation", "[", "'rotation'", "]", ")", "\n", "\n", "", "return", "coords", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent": [[214, 230], ["helper.PredictHelper._get_past_or_future_for_agent"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._get_past_or_future_for_agent"], ["", "def", "get_future_for_agent", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ",", "\n", "seconds", ":", "float", ",", "in_agent_frame", ":", "bool", ",", "\n", "just_xy", ":", "bool", "=", "True", ")", "->", "Union", "[", "List", "[", "Record", "]", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Retrieves the agent's future x,y locations.\n        :param instance_token: Instance token.\n        :param sample_token: Sample token.\n        :param seconds: How much future data to retrieve.\n        :param in_agent_frame: If true, locations are rotated to the agent frame.\n        :param just_xy: If true, returns an np.array of x,y locations as opposed to the\n            entire record.\n        :return: If just_xy, np.ndarray. Else, List of records.\n            The rows increate with time, i.e the last row occurs the farthest in the future.\n        \"\"\"", "\n", "return", "self", ".", "_get_past_or_future_for_agent", "(", "instance_token", ",", "sample_token", ",", "seconds", ",", "\n", "in_agent_frame", ",", "direction", "=", "'next'", ",", "just_xy", "=", "just_xy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_agent": [[231, 248], ["helper.PredictHelper._get_past_or_future_for_agent"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._get_past_or_future_for_agent"], ["", "def", "get_past_for_agent", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ",", "\n", "seconds", ":", "float", ",", "in_agent_frame", ":", "bool", ",", "\n", "just_xy", ":", "bool", "=", "True", ")", "->", "Union", "[", "List", "[", "Record", "]", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Retrieves the agent's past sample annotation records.\n        :param instance_token: Instance token.\n        :param sample_token: Sample token.\n        :param seconds: How much past data to retrieve.\n        :param in_agent_frame: If true, locations are rotated to the agent frame.\n            Only relevant if just_xy = True.\n        :param just_xy: If true, returns an np.array of x,y locations as opposed to the\n            entire record.\n        :return: If just_xy, np.ndarray. Else, List of records.\n            The rows decrease with time, i.e the last row occurs the farthest in the past.\n        \"\"\"", "\n", "return", "self", ".", "_get_past_or_future_for_agent", "(", "instance_token", ",", "sample_token", ",", "seconds", ",", "\n", "in_agent_frame", ",", "direction", "=", "'prev'", ",", "just_xy", "=", "just_xy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._get_past_or_future_for_sample": [[249, 274], ["helper.PredictHelper.data.get", "helper.PredictHelper.data.get", "function"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "_get_past_or_future_for_sample", "(", "self", ",", "sample_token", ":", "str", ",", "seconds", ":", "float", ",", "in_agent_frame", ":", "bool", ",", "\n", "direction", ":", "str", ",", "just_xy", ":", "bool", ",", "\n", "function", ":", "Callable", "[", "[", "str", ",", "str", ",", "float", ",", "bool", ",", "str", ",", "bool", "]", ",", "np", ".", "ndarray", "]", ")", "->", "Union", "[", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ",", "Dict", "[", "str", ",", "List", "[", "Record", "]", "]", "]", ":", "\n", "        ", "\"\"\"\n        Helper function to reduce code duplication between get_future and get_past for sample.\n        :param sample_token: Sample token.\n        :param seconds: How much past or future data to retrieve.\n        :param in_agent_frame: Whether to rotate each agent future.\n            Only relevant if just_xy = True.\n        :param just_xy: If true, returns an np.array of x,y locations as opposed to the\n            entire record.\n        :param function: _get_past_or_future_for_agent.\n        :return: Dictionary mapping instance token to np.array or list of records.\n        \"\"\"", "\n", "sample_record", "=", "self", ".", "data", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "sequences", "=", "{", "}", "\n", "for", "annotation", "in", "sample_record", "[", "'anns'", "]", ":", "\n", "            ", "annotation_record", "=", "self", ".", "data", ".", "get", "(", "'sample_annotation'", ",", "annotation", ")", "\n", "sequence", "=", "function", "(", "annotation_record", "[", "'instance_token'", "]", ",", "\n", "annotation_record", "[", "'sample_token'", "]", ",", "\n", "seconds", ",", "in_agent_frame", ",", "direction", ",", "just_xy", "=", "just_xy", ")", "\n", "\n", "sequences", "[", "annotation_record", "[", "'instance_token'", "]", "]", "=", "sequence", "\n", "\n", "", "return", "sequences", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_sample": [[275, 292], ["helper.PredictHelper._get_past_or_future_for_sample"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._get_past_or_future_for_sample"], ["", "def", "get_future_for_sample", "(", "self", ",", "sample_token", ":", "str", ",", "seconds", ":", "float", ",", "in_agent_frame", ":", "bool", ",", "\n", "just_xy", ":", "bool", "=", "True", ")", "->", "Union", "[", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ",", "Dict", "[", "str", ",", "List", "[", "Record", "]", "]", "]", ":", "\n", "        ", "\"\"\"\n        Retrieves the the future x,y locations of all agents in the sample.\n        :param sample_token: Sample token.\n        :param seconds: How much future data to retrieve.\n        :param in_agent_frame: If true, locations are rotated to the agent frame.\n            Only relevant if just_xy = True.\n        :param just_xy: If true, returns an np.array of x,y locations as opposed to the\n            entire record.\n        :return: If just_xy, Mapping of instance token to np.ndarray.\n            Else, the mapping is from instance token to list of records.\n            The rows increase with time, i.e the last row occurs the farthest in the future.\n        \"\"\"", "\n", "return", "self", ".", "_get_past_or_future_for_sample", "(", "sample_token", ",", "seconds", ",", "in_agent_frame", ",", "'next'", ",", "\n", "just_xy", ",", "\n", "function", "=", "self", ".", "_get_past_or_future_for_agent", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_sample": [[293, 310], ["helper.PredictHelper._get_past_or_future_for_sample"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._get_past_or_future_for_sample"], ["", "def", "get_past_for_sample", "(", "self", ",", "sample_token", ":", "str", ",", "seconds", ":", "float", ",", "in_agent_frame", ":", "bool", ",", "\n", "just_xy", ":", "bool", "=", "True", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Retrieves the the past x,y locations of all agents in the sample.\n        :param sample_token: Sample token.\n        :param seconds: How much past data to retrieve.\n        :param in_agent_frame: If true, locations are rotated to the agent frame.\n                Only relevant if just_xy = True.\n        :param just_xy: If true, returns an np.array of x,y locations as opposed to the\n            entire record.\n        :return: If just_xy, Mapping of instance token to np.ndarray.\n            Else, the mapping is from instance token to list of records.\n            The rows decrease with time, i.e the last row occurs the farthest in the past.\n        \"\"\"", "\n", "return", "self", ".", "_get_past_or_future_for_sample", "(", "sample_token", ",", "seconds", ",", "in_agent_frame", ",", "'prev'", ",", "\n", "just_xy", ",", "\n", "function", "=", "self", ".", "_get_past_or_future_for_agent", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._compute_diff_between_sample_annotations": [[311, 341], ["helper.PredictHelper.get_sample_annotation", "helper.PredictHelper.data.get", "with_function", "helper.PredictHelper.data.get", "helper.PredictHelper.data.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_sample_annotation", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "_compute_diff_between_sample_annotations", "(", "self", ",", "instance_token", ":", "str", ",", "\n", "sample_token", ":", "str", ",", "max_time_diff", ":", "float", ",", "\n", "with_function", ",", "**", "kwargs", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Grabs current and previous annotation and computes a float from them.\n        :param instance_token: Instance token.\n        :param sample_token: Sample token.\n        :param max_time_diff: If the time difference between now and the most recent annotation is larger\n            than this param, function will return np.nan.\n        :param with_function: Function to apply to the annotations.\n        :param **kwargs: Keyword arguments to give to with_function.\n\n        \"\"\"", "\n", "annotation", "=", "self", ".", "get_sample_annotation", "(", "instance_token", ",", "sample_token", ")", "\n", "\n", "if", "annotation", "[", "'prev'", "]", "==", "''", ":", "\n", "            ", "return", "np", ".", "nan", "\n", "\n", "", "prev", "=", "self", ".", "data", ".", "get", "(", "'sample_annotation'", ",", "annotation", "[", "'prev'", "]", ")", "\n", "\n", "current_time", "=", "1e-6", "*", "self", ".", "data", ".", "get", "(", "'sample'", ",", "sample_token", ")", "[", "'timestamp'", "]", "\n", "prev_time", "=", "1e-6", "*", "self", ".", "data", ".", "get", "(", "'sample'", ",", "prev", "[", "'sample_token'", "]", ")", "[", "'timestamp'", "]", "\n", "time_diff", "=", "current_time", "-", "prev_time", "\n", "\n", "if", "time_diff", "<=", "max_time_diff", ":", "\n", "\n", "            ", "return", "with_function", "(", "annotation", ",", "prev", ",", "time_diff", ",", "**", "kwargs", ")", "\n", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "nan", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_velocity_for_agent": [[342, 352], ["helper.PredictHelper._compute_diff_between_sample_annotations"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._compute_diff_between_sample_annotations"], ["", "", "def", "get_velocity_for_agent", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ",", "max_time_diff", ":", "float", "=", "1.5", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Computes velocity based on the difference between the current and previous annotation.\n        :param instance_token: Instance token.\n        :param sample_token: Sample token.\n        :param max_time_diff: If the time difference between now and the most recent annotation is larger\n            than this param, function will return np.nan.\n        \"\"\"", "\n", "return", "self", ".", "_compute_diff_between_sample_annotations", "(", "instance_token", ",", "sample_token", ",", "max_time_diff", ",", "\n", "with_function", "=", "velocity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_heading_change_rate_for_agent": [[353, 364], ["helper.PredictHelper._compute_diff_between_sample_annotations"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._compute_diff_between_sample_annotations"], ["", "def", "get_heading_change_rate_for_agent", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ",", "\n", "max_time_diff", ":", "float", "=", "1.5", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Computes heading change rate based on the difference between the current and previous annotation.\n        :param instance_token: Instance token.\n        :param sample_token: Sample token.\n        :param max_time_diff: If the time difference between now and the most recent annotation is larger\n            than this param, function will return np.nan.\n        \"\"\"", "\n", "return", "self", ".", "_compute_diff_between_sample_annotations", "(", "instance_token", ",", "sample_token", ",", "max_time_diff", ",", "\n", "with_function", "=", "heading_change_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_acceleration_for_agent": [[365, 378], ["helper.PredictHelper._compute_diff_between_sample_annotations"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper._compute_diff_between_sample_annotations"], ["", "def", "get_acceleration_for_agent", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ",", "max_time_diff", ":", "float", "=", "1.5", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Computes heading change rate based on the difference between the current and previous annotation.\n        :param instance_token: Instance token.\n        :param sample_token: Sample token.\n        :param max_time_diff: If the time difference between now and the most recent annotation is larger\n            than this param, function will return np.nan.\n        \"\"\"", "\n", "return", "self", ".", "_compute_diff_between_sample_annotations", "(", "instance_token", ",", "sample_token", ",", "\n", "max_time_diff", ",", "\n", "with_function", "=", "acceleration", ",", "\n", "instance_token_for_velocity", "=", "instance_token", ",", "\n", "helper", "=", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_map_name_from_sample_token": [[379, 385], ["helper.PredictHelper.data.get", "helper.PredictHelper.data.get", "helper.PredictHelper.data.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "get_map_name_from_sample_token", "(", "self", ",", "sample_token", ":", "str", ")", "->", "str", ":", "\n", "\n", "        ", "sample", "=", "self", ".", "data", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "scene", "=", "self", ".", "data", ".", "get", "(", "'scene'", ",", "sample", "[", "'scene_token'", "]", ")", "\n", "log", "=", "self", ".", "data", ".", "get", "(", "'log'", ",", "scene", "[", "'log_token'", "]", ")", "\n", "return", "log", "[", "'location'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.angle_of_rotation": [[17, 25], ["numpy.sign", "numpy.abs"], "function", ["None"], ["def", "angle_of_rotation", "(", "yaw", ":", "float", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Given a yaw angle (measured from x axis), find the angle needed to rotate by so that\n    the yaw is aligned with the y axis (pi / 2).\n    :param yaw: Radians. Output of quaternion_yaw function.\n    :return: Angle in radians.\n    \"\"\"", "\n", "return", "(", "np", ".", "pi", "/", "2", ")", "+", "np", ".", "sign", "(", "-", "yaw", ")", "*", "np", ".", "abs", "(", "yaw", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.make_2d_rotation_matrix": [[27, 35], ["numpy.array", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin"], "function", ["None"], ["", "def", "make_2d_rotation_matrix", "(", "angle_in_radians", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Makes rotation matrix to rotate point in x-y plane counterclockwise\n    by angle_in_radians.\n    \"\"\"", "\n", "\n", "return", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "angle_in_radians", ")", ",", "-", "np", ".", "sin", "(", "angle_in_radians", ")", "]", ",", "\n", "[", "np", ".", "sin", "(", "angle_in_radians", ")", ",", "np", ".", "cos", "(", "angle_in_radians", ")", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_global_coords_to_local": [[37, 56], ["helper.angle_of_rotation", "helper.make_2d_rotation_matrix", "nuscenes.eval.common.utils.quaternion_yaw", "pyquaternion.Quaternion", "numpy.atleast_2d", "numpy.dot", "numpy.array"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.angle_of_rotation", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.make_2d_rotation_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw"], ["", "def", "convert_global_coords_to_local", "(", "coordinates", ":", "np", ".", "ndarray", ",", "\n", "translation", ":", "Tuple", "[", "float", ",", "float", ",", "float", "]", ",", "\n", "rotation", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Converts global coordinates to coordinates in the frame given by the rotation quaternion and\n    centered at the translation vector. The rotation is meant to be a z-axis rotation.\n    :param coordinates: x,y locations. array of shape [n_steps, 2].\n    :param translation: Tuple of (x, y, z) location that is the center of the new frame.\n    :param rotation: Tuple representation of quaternion of new frame.\n        Representation - cos(theta / 2) + (xi + yi + zi)sin(theta / 2).\n    :return: x,y locations in frame stored in array of share [n_times, 2].\n    \"\"\"", "\n", "yaw", "=", "angle_of_rotation", "(", "quaternion_yaw", "(", "Quaternion", "(", "rotation", ")", ")", ")", "\n", "\n", "transform", "=", "make_2d_rotation_matrix", "(", "angle_in_radians", "=", "yaw", ")", "\n", "\n", "coords", "=", "(", "coordinates", "-", "np", ".", "atleast_2d", "(", "np", ".", "array", "(", "translation", ")", "[", ":", "2", "]", ")", ")", ".", "T", "\n", "\n", "return", "np", ".", "dot", "(", "transform", ",", "coords", ")", ".", "T", "[", ":", ",", ":", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.convert_local_coords_to_global": [[58, 74], ["helper.angle_of_rotation", "helper.make_2d_rotation_matrix", "nuscenes.eval.common.utils.quaternion_yaw", "numpy.atleast_2d", "pyquaternion.Quaternion", "numpy.dot", "numpy.array"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.angle_of_rotation", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.make_2d_rotation_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw"], ["", "def", "convert_local_coords_to_global", "(", "coordinates", ":", "np", ".", "ndarray", ",", "\n", "translation", ":", "Tuple", "[", "float", ",", "float", ",", "float", "]", ",", "\n", "rotation", ":", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Converts local coordinates to global coordinates.\n    :param coordinates: x,y locations. array of shape [n_steps, 2]\n    :param translation: Tuple of (x, y, z) location that is the center of the new frame\n    :param rotation: Tuple representation of quaternion of new frame.\n        Representation - cos(theta / 2) + (xi + yi + zi)sin(theta / 2).\n    :return: x,y locations stored in array of share [n_times, 2].\n    \"\"\"", "\n", "yaw", "=", "angle_of_rotation", "(", "quaternion_yaw", "(", "Quaternion", "(", "rotation", ")", ")", ")", "\n", "\n", "transform", "=", "make_2d_rotation_matrix", "(", "angle_in_radians", "=", "-", "yaw", ")", "\n", "\n", "return", "np", ".", "dot", "(", "transform", ",", "coordinates", ".", "T", ")", ".", "T", "[", ":", ",", ":", "2", "]", "+", "np", ".", "atleast_2d", "(", "np", ".", "array", "(", "translation", ")", "[", ":", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.velocity": [[387, 396], ["numpy.linalg.norm", "numpy.array", "numpy.array"], "function", ["None"], ["", "", "def", "velocity", "(", "current", ":", "Dict", "[", "str", ",", "Any", "]", ",", "prev", ":", "Dict", "[", "str", ",", "Any", "]", ",", "time_diff", ":", "float", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Helper function to compute velocity between sample annotations.\n    :param current: Sample annotation record for the current timestamp.\n    :param prev: Sample annotation record for the previous time stamp.\n    :param time_diff: How much time has elapsed between the records.\n    \"\"\"", "\n", "diff", "=", "(", "np", ".", "array", "(", "current", "[", "'translation'", "]", ")", "-", "np", ".", "array", "(", "prev", "[", "'translation'", "]", ")", ")", "/", "time_diff", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "diff", "[", ":", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.heading_change_rate": [[398, 409], ["nuscenes.eval.common.utils.quaternion_yaw", "nuscenes.eval.common.utils.quaternion_yaw", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "nuscenes.eval.common.utils.angle_diff"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.angle_diff"], ["", "def", "heading_change_rate", "(", "current", ":", "Dict", "[", "str", ",", "Any", "]", ",", "prev", ":", "Dict", "[", "str", ",", "Any", "]", ",", "time_diff", ":", "float", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Helper function to compute heading change rate between sample annotations.\n    :param current: Sample annotation record for the current timestamp.\n    :param prev: Sample annotation record for the previous time stamp.\n    :param time_diff: How much time has elapsed between the records.\n    \"\"\"", "\n", "current_yaw", "=", "quaternion_yaw", "(", "Quaternion", "(", "current", "[", "'rotation'", "]", ")", ")", "\n", "prev_yaw", "=", "quaternion_yaw", "(", "Quaternion", "(", "prev", "[", "'rotation'", "]", ")", ")", "\n", "\n", "return", "angle_diff", "(", "current_yaw", ",", "prev_yaw", ",", "period", "=", "2", "*", "np", ".", "pi", ")", "/", "time_diff", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.acceleration": [[411, 425], ["helper.get_velocity_for_agent", "helper.get_velocity_for_agent"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_velocity_for_agent", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_velocity_for_agent"], ["", "def", "acceleration", "(", "current", ":", "Dict", "[", "str", ",", "Any", "]", ",", "prev", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "time_diff", ":", "float", ",", "instance_token_for_velocity", ":", "str", ",", "helper", ":", "PredictHelper", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Helper function to compute acceleration between sample annotations.\n    :param current: Sample annotation record for the current timestamp.\n    :param prev: Sample annotation record for the previous time stamp.\n    :param time_diff: How much time has elapsed between the records.\n    :param instance_token_for_velocity: Instance token to compute velocity.\n    :param helper: Instance of PredictHelper.\n    \"\"\"", "\n", "current_velocity", "=", "helper", ".", "get_velocity_for_agent", "(", "instance_token_for_velocity", ",", "current", "[", "'sample_token'", "]", ")", "\n", "prev_velocity", "=", "helper", ".", "get_velocity_for_agent", "(", "instance_token_for_velocity", ",", "prev", "[", "'sample_token'", "]", ")", "\n", "\n", "return", "(", "current_velocity", "-", "prev_velocity", ")", "/", "time_diff", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.data_classes.Prediction.__init__": [[23, 31], ["data_classes.Prediction.is_valid"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.data_classes.Prediction.is_valid"], ["    ", "\"\"\"\n    Abstract class for manipulating and viewing point clouds.\n    Every point cloud (lidar and radar) consists of points where:\n    - Dimensions 0, 1, 2 represent x, y, z coordinates.\n        These are modified when the point cloud is rotated or translated.\n    - All other dimensions are optional. Hence these have to be manually modified if the reference frame changes.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "points", ":", "np", ".", "ndarray", ")", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.data_classes.Prediction.number_of_modes": [[32, 35], ["None"], "methods", ["None"], ["        ", "\"\"\"\n        Initialize a point cloud and check it has the correct dimensions.\n        :param points: <np.float: d, n>. d-dimensional input point cloud matrix.\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.data_classes.Prediction.serialize": [[36, 42], ["data_classes.Prediction.prediction.tolist", "data_classes.Prediction.probabilities.tolist"], "methods", ["None"], ["assert", "points", ".", "shape", "[", "0", "]", "==", "self", ".", "nbr_dims", "(", ")", ",", "'Error: Pointcloud points must have format: %d x n'", "%", "self", ".", "nbr_dims", "(", ")", "\n", "self", ".", "points", "=", "points", "\n", "\n", "", "@", "staticmethod", "\n", "@", "abstractmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.data_classes.Prediction.deserialize": [[43, 50], ["cls", "numpy.array", "numpy.array"], "methods", ["None"], ["\n", "pass", "\n", "\n", "", "@", "classmethod", "\n", "@", "abstractmethod", "\n", "def", "from_file", "(", "cls", ",", "file_name", ":", "str", ")", "->", "'PointCloud'", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.data_classes.Prediction.is_valid": [[51, 71], ["isinstance", "ValueError", "isinstance", "ValueError", "isinstance", "ValueError", "isinstance", "ValueError", "ValueError", "ValueError", "len", "ValueError", "ValueError", "str", "type", "type", "type", "len", "type"], "methods", ["None"], ["        ", "\"\"\"\n        Loads point cloud from disk.\n        :param file_name: Path of the pointcloud file on disk.\n        :return: PointCloud instance.\n        \"\"\"", "\n", "pass", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_file_multisweep", "(", "cls", ",", "\n", "nusc", ":", "'NuScenes'", ",", "\n", "sample_rec", ":", "Dict", ",", "\n", "chan", ":", "str", ",", "\n", "ref_chan", ":", "str", ",", "\n", "nsweeps", ":", "int", "=", "5", ",", "\n", "min_distance", ":", "float", "=", "1.0", ")", "->", "Tuple", "[", "'PointCloud'", ",", "np", ".", "ndarray", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.data_classes.Prediction.__repr__": [[72, 74], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.config.PredictionConfig.__init__": [[13, 27], ["None"], "methods", ["None"], ["\n", "\n", "# Check if config exists.", "\n", "this_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "cfg_path", "=", "os", ".", "path", ".", "join", "(", "this_dir", ",", "'configs'", ",", "'%s.json'", "%", "configuration_name", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "cfg_path", ")", ",", "'Requested unknown configuration {}'", ".", "format", "(", "configuration_name", ")", "\n", "\n", "# Load config file and deserialize it.", "\n", "with", "open", "(", "cfg_path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "f", ")", "\n", "", "cfg", "=", "DetectionConfig", ".", "deserialize", "(", "data", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.config.PredictionConfig.serialize": [[28, 33], ["metric.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["\n", "return", "cfg", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.config.PredictionConfig.deserialize": [[34, 39], ["cls", "nuscenes.eval.prediction.metrics.deserialize_metric"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_metric"], []], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.config.load_prediction_config": [[41, 57], ["os.path.dirname", "os.path.join", "os.path.exists", "config.PredictionConfig.deserialize", "os.path.abspath", "open", "json.load"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize"], []], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.SerializableFunction.serialize": [[150, 153], ["None"], "methods", ["None"], ["@", "abc", ".", "abstractmethod", "\n", "def", "serialize", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.SerializableFunction.name": [[154, 158], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "name", "(", "self", ",", ")", "->", "str", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.Aggregator.__call__": [[163, 166], ["None"], "methods", ["None"], ["@", "abc", ".", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "array", ":", "np", ".", "ndarray", ",", "**", "kwargs", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.RowMean.__call__": [[170, 172], ["array.mean().tolist", "array.mean"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "array", ":", "np", ".", "ndarray", ",", "**", "kwargs", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "array", ".", "mean", "(", "axis", "=", "0", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.RowMean.serialize": [[173, 175], ["None"], "methods", ["None"], ["", "def", "serialize", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "return", "{", "'name'", ":", "self", ".", "name", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.RowMean.name": [[176, 179], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "name", "(", "self", ",", ")", "->", "str", ":", "\n", "        ", "return", "'RowMean'", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.Metric.__call__": [[183, 186], ["None"], "methods", ["None"], ["    ", "@", "abc", ".", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "ground_truth", ":", "np", ".", "ndarray", ",", "prediction", ":", "Prediction", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.Metric.aggregators": [[187, 191], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "aggregators", "(", "self", ",", ")", "->", "List", "[", "Aggregator", "]", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.Metric.shape": [[192, 196], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "shape", "(", "self", ",", ")", "->", "str", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinADEK.__init__": [[206, 215], ["abc.ABC.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "k_to_report", ":", "List", "[", "int", "]", ",", "aggregators", ":", "List", "[", "Aggregator", "]", ")", ":", "\n", "        ", "\"\"\"\n        Computes the minimum average displacement error over the top k predictions.\n        :param k_to_report:  Will report the top k result for the k in this list.\n        :param aggregators: How to aggregate the results across the dataset.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "k_to_report", "=", "k_to_report", "\n", "self", ".", "_aggregators", "=", "aggregators", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinADEK.__call__": [[216, 220], ["metrics.stack_ground_truth", "metrics.min_ade_k", "metrics.desired_number_of_modes"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.stack_ground_truth", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_ade_k", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.desired_number_of_modes"], ["", "def", "__call__", "(", "self", ",", "ground_truth", ":", "np", ".", "ndarray", ",", "prediction", ":", "Prediction", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "ground_truth", "=", "stack_ground_truth", "(", "ground_truth", ",", "prediction", ".", "number_of_modes", ")", "\n", "results", "=", "min_ade_k", "(", "prediction", ".", "prediction", ",", "ground_truth", ",", "prediction", ".", "probabilities", ")", "\n", "return", "desired_number_of_modes", "(", "results", ",", "self", ".", "k_to_report", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinADEK.serialize": [[221, 225], ["agg.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "def", "serialize", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "return", "{", "'k_to_report'", ":", "self", ".", "k_to_report", ",", "\n", "'name'", ":", "self", ".", "name", ",", "\n", "'aggregators'", ":", "[", "agg", ".", "serialize", "(", ")", "for", "agg", "in", "self", ".", "aggregators", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinADEK.aggregators": [[226, 229], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "aggregators", "(", "self", ",", ")", "->", "List", "[", "Aggregator", "]", ":", "\n", "        ", "return", "self", ".", "_aggregators", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinADEK.name": [[230, 233], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "name", "(", "self", ")", ":", "\n", "        ", "return", "'MinADEK'", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinADEK.shape": [[234, 237], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "k_to_report", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinFDEK.__init__": [[241, 250], ["abc.ABC.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "k_to_report", ",", "aggregators", ":", "List", "[", "Aggregator", "]", ")", ":", "\n", "        ", "\"\"\"\n        Computes the minimum final displacement error over the top k predictions.\n        :param k_to_report:  Will report the top k result for the k in this list.\n        :param aggregators: How to aggregate the results across the dataset.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "k_to_report", "=", "k_to_report", "\n", "self", ".", "_aggregators", "=", "aggregators", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinFDEK.__call__": [[251, 255], ["metrics.stack_ground_truth", "metrics.min_fde_k", "metrics.desired_number_of_modes"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.stack_ground_truth", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_fde_k", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.desired_number_of_modes"], ["", "def", "__call__", "(", "self", ",", "ground_truth", ":", "np", ".", "ndarray", ",", "prediction", ":", "Prediction", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "ground_truth", "=", "stack_ground_truth", "(", "ground_truth", ",", "prediction", ".", "number_of_modes", ")", "\n", "results", "=", "min_fde_k", "(", "prediction", ".", "prediction", ",", "ground_truth", ",", "prediction", ".", "probabilities", ")", "\n", "return", "desired_number_of_modes", "(", "results", ",", "self", ".", "k_to_report", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinFDEK.serialize": [[256, 260], ["agg.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "def", "serialize", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "return", "{", "'k_to_report'", ":", "self", ".", "k_to_report", ",", "\n", "'name'", ":", "self", ".", "name", ",", "\n", "'aggregators'", ":", "[", "agg", ".", "serialize", "(", ")", "for", "agg", "in", "self", ".", "aggregators", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinFDEK.aggregators": [[261, 264], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "aggregators", "(", "self", ",", ")", "->", "List", "[", "Aggregator", "]", ":", "\n", "        ", "return", "self", ".", "_aggregators", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinFDEK.name": [[265, 268], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "name", "(", "self", ")", ":", "\n", "        ", "return", "\"MinFDEK\"", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MinFDEK.shape": [[269, 272], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "k_to_report", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MissRateTopK.__init__": [[276, 288], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "k_to_report", ":", "List", "[", "int", "]", ",", "aggregators", ":", "List", "[", "Aggregator", "]", ",", "\n", "tolerance", ":", "float", "=", "2.", ")", ":", "\n", "        ", "\"\"\"\n        If any point in the prediction is more than tolerance meters from the ground truth, it is a miss.\n        This metric computes the fraction of predictions that are misses over the top k most likely predictions.\n        :param k_to_report: Will report the top k result for the k in this list.\n        :param aggregators: How to aggregate the results across the dataset.\n        :param tolerance: Threshold to consider if a prediction is a hit or not.\n        \"\"\"", "\n", "self", ".", "k_to_report", "=", "k_to_report", "\n", "self", ".", "_aggregators", "=", "aggregators", "\n", "self", ".", "tolerance", "=", "tolerance", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MissRateTopK.__call__": [[289, 294], ["metrics.stack_ground_truth", "metrics.miss_rate_top_k", "metrics.desired_number_of_modes"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.stack_ground_truth", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_rate_top_k", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.desired_number_of_modes"], ["", "def", "__call__", "(", "self", ",", "ground_truth", ":", "np", ".", "ndarray", ",", "prediction", ":", "Prediction", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "ground_truth", "=", "stack_ground_truth", "(", "ground_truth", ",", "prediction", ".", "number_of_modes", ")", "\n", "results", "=", "miss_rate_top_k", "(", "prediction", ".", "prediction", ",", "ground_truth", ",", "\n", "prediction", ".", "probabilities", ",", "self", ".", "tolerance", ")", "\n", "return", "desired_number_of_modes", "(", "results", ",", "self", ".", "k_to_report", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MissRateTopK.serialize": [[295, 300], ["agg.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "def", "serialize", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "return", "{", "'k_to_report'", ":", "self", ".", "k_to_report", ",", "\n", "'name'", ":", "'MissRateTopK'", ",", "\n", "'aggregators'", ":", "[", "agg", ".", "serialize", "(", ")", "for", "agg", "in", "self", ".", "aggregators", "]", ",", "\n", "'tolerance'", ":", "self", ".", "tolerance", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MissRateTopK.aggregators": [[301, 304], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "aggregators", "(", "self", ",", ")", "->", "List", "[", "Aggregator", "]", ":", "\n", "        ", "return", "self", ".", "_aggregators", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MissRateTopK.name": [[305, 308], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "name", "(", "self", ")", ":", "\n", "        ", "return", "f\"MissRateTopK_{self.tolerance}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.MissRateTopK.shape": [[309, 312], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "k_to_report", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.__init__": [[316, 328], ["metrics.OffRoadRate.load_drivable_area_masks"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.load_drivable_area_masks"], ["    ", "def", "__init__", "(", "self", ",", "helper", ":", "PredictHelper", ",", "aggregators", ":", "List", "[", "Aggregator", "]", ")", ":", "\n", "        ", "\"\"\"\n        The OffRoadRate is defined as the fraction of trajectories that are not entirely contained\n        in the drivable area of the map.\n        :param helper: Instance of PredictHelper. Used to determine the map version for each prediction.\n        :param aggregators: How to aggregate the results across the dataset.\n        \"\"\"", "\n", "self", ".", "_aggregators", "=", "aggregators", "\n", "self", ".", "helper", "=", "helper", "\n", "self", ".", "drivable_area_polygons", "=", "self", ".", "load_drivable_area_masks", "(", "helper", ")", "\n", "self", ".", "pixels_per_meter", "=", "10", "\n", "self", ".", "number_of_points", "=", "200", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.load_drivable_area_masks": [[329, 346], ["nuscenes.prediction.input_representation.static_layers.load_all_maps", "maps.items", "map_api.get_map_mask"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.load_all_maps", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_map_mask"], ["", "@", "staticmethod", "\n", "def", "load_drivable_area_masks", "(", "helper", ":", "PredictHelper", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Loads the polygon representation of the drivable area for each map.\n        :param helper: Instance of PredictHelper.\n        :return: Mapping from map_name to drivable area polygon.\n        \"\"\"", "\n", "\n", "maps", ":", "Dict", "[", "str", ",", "NuScenesMap", "]", "=", "load_all_maps", "(", "helper", ")", "\n", "\n", "masks", "=", "{", "}", "\n", "for", "map_name", ",", "map_api", "in", "maps", ".", "items", "(", ")", ":", "\n", "\n", "            ", "masks", "[", "map_name", "]", "=", "map_api", ".", "get_map_mask", "(", "patch_box", "=", "None", ",", "patch_angle", "=", "0", ",", "layer_names", "=", "[", "'drivable_area'", "]", ",", "\n", "canvas_size", "=", "None", ")", "[", "0", "]", "\n", "\n", "", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.interpolate_path": [[347, 372], ["set", "numpy.array", "numpy.atleast_2d", "tuple", "scipy.interpolate.splprep", "scipy.interpolate.splev", "set.add", "ordered_array.append", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["", "@", "staticmethod", "\n", "def", "interpolate_path", "(", "mode", ":", "np", ".", "ndarray", ",", "number_of_points", ":", "int", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\" Interpolate trajectory with a cubic spline if there are enough points. \"\"\"", "\n", "\n", "# interpolate.splprep needs unique points.", "\n", "# We use a loop as opposed to np.unique because", "\n", "# the order of the points must be the same", "\n", "seen", "=", "set", "(", ")", "\n", "ordered_array", "=", "[", "]", "\n", "for", "row", "in", "mode", ":", "\n", "            ", "row_tuple", "=", "tuple", "(", "row", ")", "\n", "if", "row_tuple", "not", "in", "seen", ":", "\n", "                ", "seen", ".", "add", "(", "row_tuple", ")", "\n", "ordered_array", ".", "append", "(", "row_tuple", ")", "\n", "\n", "", "", "new_array", "=", "np", ".", "array", "(", "ordered_array", ")", "\n", "\n", "unique_points", "=", "np", ".", "atleast_2d", "(", "new_array", ")", "\n", "\n", "if", "unique_points", ".", "shape", "[", "0", "]", "<=", "3", ":", "\n", "            ", "return", "unique_points", "[", ":", ",", "0", "]", ",", "unique_points", "[", ":", ",", "1", "]", "\n", "", "else", ":", "\n", "            ", "knots", ",", "_", "=", "interpolate", ".", "splprep", "(", "[", "unique_points", "[", ":", ",", "0", "]", ",", "unique_points", "[", ":", ",", "1", "]", "]", ",", "k", "=", "3", ",", "s", "=", "0.1", ")", "\n", "x_interpolated", ",", "y_interpolated", "=", "interpolate", ".", "splev", "(", "np", ".", "linspace", "(", "0", ",", "1", ",", "number_of_points", ")", ",", "knots", ")", "\n", "return", "x_interpolated", ",", "y_interpolated", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.__call__": [[373, 404], ["metrics.OffRoadRate.helper.get_map_name_from_sample_token", "numpy.array", "metrics.OffRoadRate.interpolate_path", "numpy.any", "numpy.any", "numpy.any", "numpy.any", "numpy.all"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_map_name_from_sample_token", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.interpolate_path", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "", "def", "__call__", "(", "self", ",", "ground_truth", ":", "np", ".", "ndarray", ",", "prediction", ":", "Prediction", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Computes the fraction of modes in prediction that are not entirely contained in the drivable area.\n        :param ground_truth: Not used. Included signature to adhere to Metric API.\n        :param prediction: Model prediction.\n        :return: Array of shape (1, ) containing the fraction of modes that are not entirely contained in the\n            drivable area.\n        \"\"\"", "\n", "map_name", "=", "self", ".", "helper", ".", "get_map_name_from_sample_token", "(", "prediction", ".", "sample", ")", "\n", "drivable_area", "=", "self", ".", "drivable_area_polygons", "[", "map_name", "]", "\n", "max_row", ",", "max_col", "=", "drivable_area", ".", "shape", "\n", "\n", "n_violations", "=", "0", "\n", "for", "mode", "in", "prediction", ".", "prediction", ":", "\n", "\n", "# Fit a cubic spline to the trajectory and interpolate with 200 points", "\n", "            ", "x_interpolated", ",", "y_interpolated", "=", "self", ".", "interpolate_path", "(", "mode", ",", "self", ".", "number_of_points", ")", "\n", "\n", "# x coordinate -> col, y coordinate -> row", "\n", "# Mask has already been flipped over y-axis", "\n", "index_row", "=", "(", "y_interpolated", "*", "self", ".", "pixels_per_meter", ")", ".", "astype", "(", "\"int\"", ")", "\n", "index_col", "=", "(", "x_interpolated", "*", "self", ".", "pixels_per_meter", ")", ".", "astype", "(", "\"int\"", ")", "\n", "\n", "row_out_of_bounds", "=", "np", ".", "any", "(", "index_row", ">=", "max_row", ")", "or", "np", ".", "any", "(", "index_row", "<", "0", ")", "\n", "col_out_of_bounds", "=", "np", ".", "any", "(", "index_col", ">=", "max_col", ")", "or", "np", ".", "any", "(", "index_col", "<", "0", ")", "\n", "out_of_bounds", "=", "row_out_of_bounds", "or", "col_out_of_bounds", "\n", "\n", "if", "out_of_bounds", "or", "not", "np", ".", "all", "(", "drivable_area", "[", "index_row", ",", "index_col", "]", ")", ":", "\n", "                ", "n_violations", "+=", "1", "\n", "\n", "", "", "return", "np", ".", "array", "(", "[", "n_violations", "/", "prediction", ".", "prediction", ".", "shape", "[", "0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.serialize": [[405, 408], ["agg.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "def", "serialize", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "return", "{", "'name'", ":", "self", ".", "name", ",", "\n", "'aggregators'", ":", "[", "agg", ".", "serialize", "(", ")", "for", "agg", "in", "self", ".", "aggregators", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.aggregators": [[409, 412], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "aggregators", "(", "self", ",", ")", "->", "List", "[", "Aggregator", "]", ":", "\n", "        ", "return", "self", ".", "_aggregators", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.name": [[413, 416], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "name", "(", "self", ")", ":", "\n", "        ", "return", "'OffRoadRate'", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.OffRoadRate.shape": [[417, 420], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.returns_2d_array": [[16, 31], ["function", "isinstance", "numpy.array", "numpy.expand_dims"], "function", ["None"], ["def", "returns_2d_array", "(", "function", ")", ":", "\n", "    ", "\"\"\" Makes sure that the metric returns an array of shape [batch_size, num_modes]. \"\"\"", "\n", "\n", "def", "_returns_array", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "result", "=", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "if", "isinstance", "(", "result", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "result", "=", "np", ".", "array", "(", "[", "[", "result", "]", "]", ")", "\n", "\n", "", "elif", "result", ".", "ndim", "==", "1", ":", "\n", "            ", "result", "=", "np", ".", "expand_dims", "(", "result", ",", "0", ")", "\n", "\n", "", "return", "result", "\n", "\n", "", "return", "_returns_array", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.mean_distances": [[33, 43], ["numpy.mean", "numpy.linalg.norm"], "function", ["None"], ["", "@", "returns_2d_array", "\n", "def", "mean_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "\n", "stacked_ground_truth", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Efficiently compute mean L2 norm between trajectories and ground truths (pairwise over states).\n    :param stacked_trajs: Array of [batch_size, num_modes, horizon_length, state_dim].\n    :param stacked_ground_truth: Array of [batch_size, num_modes, horizon_length, state_dim].\n    :return: Array of mean L2 norms as [batch_size, num_modes].\n    \"\"\"", "\n", "return", "np", ".", "mean", "(", "np", ".", "linalg", ".", "norm", "(", "stacked_trajs", "-", "stacked_ground_truth", ",", "axis", "=", "-", "1", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.max_distances": [[45, 54], ["numpy.max", "numpy.linalg.norm"], "function", ["None"], ["", "@", "returns_2d_array", "\n", "def", "max_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Efficiently compute max L2 norm between trajectories and ground truths (pairwise over states).\n    :pram stacked_trajs: Array of shape [num_modes, horizon_length, state_dim].\n    :pram stacked_ground_truth: Array of [num_modes, horizon_length, state_dim].\n    :return: Array of max L2 norms as [num_modes].\n    \"\"\"", "\n", "return", "np", ".", "max", "(", "np", ".", "linalg", ".", "norm", "(", "stacked_trajs", "-", "stacked_ground_truth", ",", "axis", "=", "-", "1", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.final_distances": [[56, 68], ["numpy.linalg.norm", "numpy.take().squeeze", "numpy.take().squeeze", "numpy.take", "numpy.take"], "function", ["None"], ["", "@", "returns_2d_array", "\n", "def", "final_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Efficiently compute the L2 norm between the last points in the trajectory.\n    :param stacked_trajs: Array of shape [num_modes, horizon_length, state_dim].\n    :param stacked_ground_truth: Array of shape [num_modes, horizon_length, state_dim].\n    :return: mean L2 norms between final points. Array of shape [num_modes].\n    \"\"\"", "\n", "# We use take to index the elements in the last dimension so that we can also", "\n", "# apply this function for a batch", "\n", "diff_of_last", "=", "np", ".", "take", "(", "stacked_trajs", ",", "[", "-", "1", "]", ",", "-", "2", ")", ".", "squeeze", "(", ")", "-", "np", ".", "take", "(", "stacked_ground_truth", ",", "[", "-", "1", "]", ",", "-", "2", ")", ".", "squeeze", "(", ")", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "diff_of_last", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_max_distances": [[70, 81], ["metrics.max_distances"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.max_distances"], ["", "@", "returns_2d_array", "\n", "def", "miss_max_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "tolerance", ":", "float", ")", "->", "np", ".", "array", ":", "\n", "    ", "\"\"\"\n    Efficiently compute 'miss' metric between trajectories and ground truths.\n    :param stacked_trajs: Array of shape [num_modes, horizon_length, state_dim].\n    :param stacked_ground_truth: Array of shape [num_modes, horizon_length, state_dim].\n    :param tolerance: max distance (m) for a 'miss' to be True.\n    :return: True iff there was a 'miss.' Size [num_modes].\n    \"\"\"", "\n", "return", "max_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ")", ">=", "tolerance", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.rank_metric_over_top_k_modes": [[83, 109], ["numpy.flip", "numpy.indices", "func", "mode_probabilities.argsort", "ValueError"], "function", ["None"], ["", "@", "returns_2d_array", "\n", "def", "rank_metric_over_top_k_modes", "(", "metric_results", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ",", "\n", "ranking_func", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Compute a metric over all trajectories ranked by probability of each trajectory.\n    :param metric_results: 1-dimensional array of shape [batch_size, num_modes].\n    :param mode_probabilities: 1-dimensional array of shape [batch_size, num_modes].\n    :param ranking_func: Either 'min' or 'max'. How you want to metrics ranked over the top\n            k modes.\n    :return: Array of shape [num_modes].\n    \"\"\"", "\n", "\n", "if", "ranking_func", "==", "\"min\"", ":", "\n", "        ", "func", "=", "np", ".", "minimum", ".", "accumulate", "\n", "", "elif", "ranking_func", "==", "\"max\"", ":", "\n", "        ", "func", "=", "np", ".", "maximum", ".", "accumulate", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Parameter ranking_func must be one of min or max. Received {ranking_func}\"", ")", "\n", "\n", "", "p_sorted", "=", "np", ".", "flip", "(", "mode_probabilities", ".", "argsort", "(", "axis", "=", "-", "1", ")", ",", "axis", "=", "-", "1", ")", "\n", "indices", "=", "np", ".", "indices", "(", "metric_results", ".", "shape", ")", "\n", "\n", "sorted_metrics", "=", "metric_results", "[", "indices", "[", "0", "]", ",", "p_sorted", "]", "\n", "\n", "return", "func", "(", "sorted_metrics", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_rate_top_k": [[111, 118], ["metrics.miss_max_distances", "metrics.rank_metric_over_top_k_modes"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.miss_max_distances", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.rank_metric_over_top_k_modes"], ["", "def", "miss_rate_top_k", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ",", "\n", "tolerance", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Compute the miss rate over the top k modes. \"\"\"", "\n", "\n", "miss_rate", "=", "miss_max_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ",", "tolerance", ")", "\n", "return", "rank_metric_over_top_k_modes", "(", "miss_rate", ",", "mode_probabilities", ",", "\"min\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_ade_k": [[120, 126], ["metrics.mean_distances", "metrics.rank_metric_over_top_k_modes"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.mean_distances", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.rank_metric_over_top_k_modes"], ["", "def", "min_ade_k", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Compute the min ade over the top k modes. \"\"\"", "\n", "\n", "ade", "=", "mean_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ")", "\n", "return", "rank_metric_over_top_k_modes", "(", "ade", ",", "mode_probabilities", ",", "\"min\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.min_fde_k": [[128, 134], ["metrics.final_distances", "metrics.rank_metric_over_top_k_modes"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.final_distances", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.rank_metric_over_top_k_modes"], ["", "def", "min_fde_k", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Compute the min fde over the top k modes. \"\"\"", "\n", "\n", "fde", "=", "final_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ")", "\n", "return", "rank_metric_over_top_k_modes", "(", "fde", ",", "mode_probabilities", ",", "\"min\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.stack_ground_truth": [[136, 145], ["numpy.repeat", "numpy.expand_dims"], "function", ["None"], ["", "def", "stack_ground_truth", "(", "ground_truth", ":", "np", ".", "ndarray", ",", "num_modes", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Make k identical copies of the ground truth to make computing the metrics across modes\n    easier.\n    :param ground_truth: Array of shape [horizon_length, state_dim].\n    :param num_modes: number of modes in prediction.\n    :return: Array of shape [num_modes, horizon_length, state_dim].\n    \"\"\"", "\n", "return", "np", ".", "repeat", "(", "np", ".", "expand_dims", "(", "ground_truth", ",", "0", ")", ",", "num_modes", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.desired_number_of_modes": [[198, 202], ["min"], "function", ["None"], ["", "", "def", "desired_number_of_modes", "(", "results", ":", "np", ".", "ndarray", ",", "\n", "k_to_report", ":", "List", "[", "int", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Ensures we return len(k_to_report) values even when results has less modes than what we want. \"\"\"", "\n", "return", "results", "[", ":", ",", "[", "min", "(", "k", ",", "results", ".", "shape", "[", "1", "]", ")", "-", "1", "for", "k", "in", "k_to_report", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_aggregator": [[422, 428], ["metrics.RowMean", "ValueError"], "function", ["None"], ["", "", "def", "deserialize_aggregator", "(", "config", ":", "Dict", "[", "str", ",", "Any", "]", ")", "->", "Aggregator", ":", "\n", "    ", "\"\"\" Helper for deserializing Aggregators. \"\"\"", "\n", "if", "config", "[", "'name'", "]", "==", "'RowMean'", ":", "\n", "        ", "return", "RowMean", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Cannot deserialize Aggregator {config['name']}.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_metric": [[430, 443], ["metrics.MinADEK", "metrics.MinFDEK", "metrics.deserialize_aggregator", "metrics.MissRateTopK", "metrics.deserialize_aggregator", "metrics.OffRoadRate", "ValueError", "metrics.deserialize_aggregator", "metrics.deserialize_aggregator"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_aggregator", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_aggregator", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_aggregator", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.deserialize_aggregator"], ["", "", "def", "deserialize_metric", "(", "config", ":", "Dict", "[", "str", ",", "Any", "]", ",", "helper", ":", "PredictHelper", ")", "->", "Metric", ":", "\n", "    ", "\"\"\" Helper for deserializing Metrics. \"\"\"", "\n", "if", "config", "[", "'name'", "]", "==", "'MinADEK'", ":", "\n", "        ", "return", "MinADEK", "(", "config", "[", "'k_to_report'", "]", ",", "[", "deserialize_aggregator", "(", "agg", ")", "for", "agg", "in", "config", "[", "'aggregators'", "]", "]", ")", "\n", "", "elif", "config", "[", "'name'", "]", "==", "'MinFDEK'", ":", "\n", "        ", "return", "MinFDEK", "(", "config", "[", "'k_to_report'", "]", ",", "[", "deserialize_aggregator", "(", "agg", ")", "for", "agg", "in", "config", "[", "'aggregators'", "]", "]", ")", "\n", "", "elif", "config", "[", "'name'", "]", "==", "'MissRateTopK'", ":", "\n", "        ", "return", "MissRateTopK", "(", "config", "[", "'k_to_report'", "]", ",", "[", "deserialize_aggregator", "(", "agg", ")", "for", "agg", "in", "config", "[", "'aggregators'", "]", "]", ",", "\n", "tolerance", "=", "config", "[", "'tolerance'", "]", ")", "\n", "", "elif", "config", "[", "'name'", "]", "==", "'OffRoadRate'", ":", "\n", "        ", "return", "OffRoadRate", "(", "helper", ",", "[", "deserialize_aggregator", "(", "agg", ")", "for", "agg", "in", "config", "[", "'aggregators'", "]", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Cannot deserialize function {config['name']}.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.metrics.flatten_metrics": [[445, 469], ["results.items", "hasattr", "zip"], "function", ["None"], ["", "", "def", "flatten_metrics", "(", "results", ":", "Dict", "[", "str", ",", "Any", "]", ",", "metrics", ":", "List", "[", "Metric", "]", ")", "->", "Dict", "[", "str", ",", "List", "[", "float", "]", "]", ":", "\n", "    ", "\"\"\"\n    Collapses results into a 2D table represented by a dictionary mapping the metric name to\n    the metric values.\n    :param results: Mapping from metric function name to result of aggregators.\n    :param metrics: List of metrics in the results.\n    :return: Dictionary mapping metric name to the metric value.\n    \"\"\"", "\n", "\n", "metric_names", "=", "{", "metric", ".", "name", ":", "metric", "for", "metric", "in", "metrics", "}", "\n", "\n", "flattened_metrics", "=", "{", "}", "\n", "\n", "for", "metric_name", ",", "values", "in", "results", ".", "items", "(", ")", ":", "\n", "\n", "        ", "metric_class", "=", "metric_names", "[", "metric_name", "]", "\n", "\n", "if", "hasattr", "(", "metric_class", ",", "'k_to_report'", ")", ":", "\n", "            ", "for", "value", ",", "k", "in", "zip", "(", "values", "[", "'RowMean'", "]", ",", "metric_class", ".", "k_to_report", ")", ":", "\n", "                ", "flattened_metrics", "[", "f\"{metric_name}_{k}\"", "]", "=", "value", "\n", "", "", "else", ":", "\n", "            ", "flattened_metrics", "[", "metric_name", "]", "=", "values", "[", "'RowMean'", "]", "\n", "\n", "", "", "return", "flattened_metrics", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.baseline_model_inference.main": [[17, 43], ["nuscenes.NuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.eval.prediction.splits.get_prediction_challenge_split", "nuscenes.eval.prediction.config.load_prediction_config", "nuscenes.prediction.models.physics.PhysicsOracle", "nuscenes.prediction.models.physics.ConstantVelocityHeading", "json.dump", "json.dump", "cv_preds.append", "oracle_preds.append", "open", "open", "nuscenes.prediction.models.physics.ConstantVelocityHeading.serialize", "nuscenes.prediction.models.physics.PhysicsOracle.serialize", "os.path.join", "os.path.join", "nuscenes.prediction.models.physics.ConstantVelocityHeading.", "nuscenes.prediction.models.physics.PhysicsOracle."], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.splits.get_prediction_challenge_split", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.config.load_prediction_config", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["def", "main", "(", "version", ":", "str", ",", "data_root", ":", "str", ",", "\n", "split_name", ":", "str", ",", "output_dir", ":", "str", ",", "config_name", ":", "str", "=", "'predict_2020_icra.json'", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Performs inference for all of the baseline models defined in the physics model module.\n    :param version: nuScenes dataset version.\n    :param data_root: Directory where the NuScenes data is stored.\n    :param split_name: nuScenes data split name, e.g. train, val, mini_train, etc.\n    :param output_dir: Directory where predictions should be stored.\n    :param config_name: Name of config file.\n    \"\"\"", "\n", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "version", ",", "dataroot", "=", "data_root", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "dataset", "=", "get_prediction_challenge_split", "(", "split_name", ")", "\n", "config", "=", "load_prediction_config", "(", "helper", ",", "config_name", ")", "\n", "oracle", "=", "PhysicsOracle", "(", "config", ".", "seconds", ",", "helper", ")", "\n", "cv_heading", "=", "ConstantVelocityHeading", "(", "config", ".", "seconds", ",", "helper", ")", "\n", "\n", "cv_preds", "=", "[", "]", "\n", "oracle_preds", "=", "[", "]", "\n", "for", "token", "in", "dataset", ":", "\n", "        ", "cv_preds", ".", "append", "(", "cv_heading", "(", "token", ")", ".", "serialize", "(", ")", ")", "\n", "oracle_preds", ".", "append", "(", "oracle", "(", "token", ")", ".", "serialize", "(", ")", ")", "\n", "\n", "", "json", ".", "dump", "(", "cv_preds", ",", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"cv_preds.json\"", ")", ",", "\"w\"", ")", ")", "\n", "json", ".", "dump", "(", "oracle_preds", ",", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "\"oracle_preds.json\"", ")", ",", "\"w\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.splits.get_prediction_challenge_split": [[14, 42], ["os.path.join", "json.load", "nuscenes.utils.splits.create_splits_scenes", "map", "list", "ValueError", "open", "itertools.chain.from_iterable", "json.load.get"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_scenes", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["'scene-0163'", ",", "'scene-0164'", ",", "'scene-0165'", ",", "'scene-0166'", ",", "'scene-0167'", ",", "'scene-0168'", ",", "'scene-0170'", ",", "'scene-0171'", ",", "\n", "'scene-0172'", ",", "'scene-0173'", ",", "'scene-0174'", ",", "'scene-0175'", ",", "'scene-0176'", ",", "'scene-0190'", ",", "'scene-0191'", ",", "'scene-0192'", ",", "\n", "'scene-0193'", ",", "'scene-0194'", ",", "'scene-0195'", ",", "'scene-0196'", ",", "'scene-0199'", ",", "'scene-0200'", ",", "'scene-0202'", ",", "'scene-0203'", ",", "\n", "'scene-0204'", ",", "'scene-0206'", ",", "'scene-0207'", ",", "'scene-0208'", ",", "'scene-0209'", ",", "'scene-0210'", ",", "'scene-0211'", ",", "'scene-0212'", ",", "\n", "'scene-0213'", ",", "'scene-0214'", ",", "'scene-0254'", ",", "'scene-0255'", ",", "'scene-0256'", ",", "'scene-0257'", ",", "'scene-0258'", ",", "'scene-0259'", ",", "\n", "'scene-0260'", ",", "'scene-0261'", ",", "'scene-0262'", ",", "'scene-0263'", ",", "'scene-0264'", ",", "'scene-0283'", ",", "'scene-0284'", ",", "'scene-0285'", ",", "\n", "'scene-0286'", ",", "'scene-0287'", ",", "'scene-0288'", ",", "'scene-0289'", ",", "'scene-0290'", ",", "'scene-0291'", ",", "'scene-0292'", ",", "'scene-0293'", ",", "\n", "'scene-0294'", ",", "'scene-0295'", ",", "'scene-0296'", ",", "'scene-0297'", ",", "'scene-0298'", ",", "'scene-0299'", ",", "'scene-0300'", ",", "'scene-0301'", ",", "\n", "'scene-0302'", ",", "'scene-0303'", ",", "'scene-0304'", ",", "'scene-0305'", ",", "'scene-0306'", ",", "'scene-0315'", ",", "'scene-0316'", ",", "'scene-0317'", ",", "\n", "'scene-0318'", ",", "'scene-0321'", ",", "'scene-0323'", ",", "'scene-0324'", ",", "'scene-0347'", ",", "'scene-0348'", ",", "'scene-0349'", ",", "'scene-0350'", ",", "\n", "'scene-0351'", ",", "'scene-0352'", ",", "'scene-0353'", ",", "'scene-0354'", ",", "'scene-0355'", ",", "'scene-0356'", ",", "'scene-0357'", ",", "'scene-0358'", ",", "\n", "'scene-0359'", ",", "'scene-0360'", ",", "'scene-0361'", ",", "'scene-0362'", ",", "'scene-0363'", ",", "'scene-0364'", ",", "'scene-0365'", ",", "'scene-0366'", ",", "\n", "'scene-0367'", ",", "'scene-0368'", ",", "'scene-0369'", ",", "'scene-0370'", ",", "'scene-0371'", ",", "'scene-0372'", ",", "'scene-0373'", ",", "'scene-0374'", ",", "\n", "'scene-0375'", ",", "'scene-0382'", ",", "'scene-0420'", ",", "'scene-0421'", ",", "'scene-0422'", ",", "'scene-0423'", ",", "'scene-0424'", ",", "'scene-0425'", ",", "\n", "'scene-0426'", ",", "'scene-0427'", ",", "'scene-0428'", ",", "'scene-0429'", ",", "'scene-0430'", ",", "'scene-0431'", ",", "'scene-0432'", ",", "'scene-0433'", ",", "\n", "'scene-0434'", ",", "'scene-0435'", ",", "'scene-0436'", ",", "'scene-0437'", ",", "'scene-0438'", ",", "'scene-0439'", ",", "'scene-0457'", ",", "'scene-0458'", ",", "\n", "'scene-0459'", ",", "'scene-0461'", ",", "'scene-0462'", ",", "'scene-0463'", ",", "'scene-0464'", ",", "'scene-0465'", ",", "'scene-0467'", ",", "'scene-0468'", ",", "\n", "'scene-0469'", ",", "'scene-0471'", ",", "'scene-0472'", ",", "'scene-0474'", ",", "'scene-0475'", ",", "'scene-0476'", ",", "'scene-0477'", ",", "'scene-0478'", ",", "\n", "'scene-0479'", ",", "'scene-0480'", ",", "'scene-0566'", ",", "'scene-0568'", ",", "'scene-0570'", ",", "'scene-0571'", ",", "'scene-0572'", ",", "'scene-0573'", ",", "\n", "'scene-0574'", ",", "'scene-0575'", ",", "'scene-0576'", ",", "'scene-0577'", ",", "'scene-0578'", ",", "'scene-0580'", ",", "'scene-0582'", ",", "'scene-0583'", ",", "\n", "'scene-0665'", ",", "'scene-0666'", ",", "'scene-0667'", ",", "'scene-0668'", ",", "'scene-0669'", ",", "'scene-0670'", ",", "'scene-0671'", ",", "'scene-0672'", ",", "\n", "'scene-0673'", ",", "'scene-0674'", ",", "'scene-0675'", ",", "'scene-0676'", ",", "'scene-0677'", ",", "'scene-0678'", ",", "'scene-0679'", ",", "'scene-0681'", ",", "\n", "'scene-0683'", ",", "'scene-0684'", ",", "'scene-0685'", ",", "'scene-0686'", ",", "'scene-0687'", ",", "'scene-0688'", ",", "'scene-0689'", ",", "'scene-0739'", ",", "\n", "'scene-0740'", ",", "'scene-0741'", ",", "'scene-0744'", ",", "'scene-0746'", ",", "'scene-0747'", ",", "'scene-0749'", ",", "'scene-0750'", ",", "'scene-0751'", ",", "\n", "'scene-0752'", ",", "'scene-0757'", ",", "'scene-0758'", ",", "'scene-0759'", ",", "'scene-0760'", ",", "'scene-0761'", ",", "'scene-0762'", ",", "'scene-0763'", ",", "\n", "'scene-0764'", ",", "'scene-0765'", ",", "'scene-0767'", ",", "'scene-0768'", ",", "'scene-0769'", ",", "'scene-0868'", ",", "'scene-0869'", ",", "'scene-0870'", ",", "\n", "'scene-0871'", ",", "'scene-0872'", ",", "'scene-0873'", ",", "'scene-0875'", ",", "'scene-0876'", ",", "'scene-0877'", ",", "'scene-0878'", ",", "'scene-0880'", ",", "\n", "'scene-0882'", ",", "'scene-0883'", ",", "'scene-0884'", ",", "'scene-0885'", ",", "'scene-0886'", ",", "'scene-0887'", ",", "'scene-0888'", ",", "'scene-0889'", ",", "\n", "'scene-0890'", ",", "'scene-0891'", ",", "'scene-0892'", ",", "'scene-0893'", ",", "'scene-0894'", ",", "'scene-0895'", ",", "'scene-0896'", ",", "'scene-0897'", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.compute_metrics.compute_metrics": [[17, 40], ["len", "enumerate", "collections.defaultdict", "numpy.zeros", "nuscenes.eval.prediction.data_classes.Prediction.deserialize", "helper.get_future_for_agent", "metric", "agg"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent"], ["def", "compute_metrics", "(", "predictions", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", ",", "\n", "helper", ":", "PredictHelper", ",", "config", ":", "PredictionConfig", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "    ", "\"\"\"\n    Computes metrics from a set of predictions.\n    :param predictions: List of prediction JSON objects.\n    :param helper: Instance of PredictHelper that wraps the nuScenes val set.\n    :param config: Config file.\n    :return: Metrics. Nested dictionary where keys are metric names and value is a dictionary\n        mapping the Aggregator name to the results.\n    \"\"\"", "\n", "n_preds", "=", "len", "(", "predictions", ")", "\n", "containers", "=", "{", "metric", ".", "name", ":", "np", ".", "zeros", "(", "(", "n_preds", ",", "metric", ".", "shape", ")", ")", "for", "metric", "in", "config", ".", "metrics", "}", "\n", "for", "i", ",", "prediction_str", "in", "enumerate", "(", "predictions", ")", ":", "\n", "        ", "prediction", "=", "Prediction", ".", "deserialize", "(", "prediction_str", ")", "\n", "ground_truth", "=", "helper", ".", "get_future_for_agent", "(", "prediction", ".", "instance", ",", "prediction", ".", "sample", ",", "\n", "config", ".", "seconds", ",", "in_agent_frame", "=", "False", ")", "\n", "for", "metric", "in", "config", ".", "metrics", ":", "\n", "            ", "containers", "[", "metric", ".", "name", "]", "[", "i", "]", "=", "metric", "(", "ground_truth", ",", "prediction", ")", "\n", "", "", "aggregations", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "List", "[", "float", "]", "]", "]", "=", "defaultdict", "(", "dict", ")", "\n", "for", "metric", "in", "config", ".", "metrics", ":", "\n", "        ", "for", "agg", "in", "metric", ".", "aggregators", ":", "\n", "            ", "aggregations", "[", "metric", ".", "name", "]", "[", "agg", ".", "name", "]", "=", "agg", "(", "containers", "[", "metric", ".", "name", "]", ")", "\n", "", "", "return", "aggregations", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.prediction.compute_metrics.main": [[42, 58], ["json.load", "nuscenes.NuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.eval.prediction.config.load_prediction_config", "compute_metrics.compute_metrics", "json.dump", "open", "open", "submission_path.replace"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.config.load_prediction_config", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.compute_metrics.compute_metrics"], ["", "def", "main", "(", "version", ":", "str", ",", "data_root", ":", "str", ",", "submission_path", ":", "str", ",", "\n", "config_name", ":", "str", "=", "'predict_2020_icra.json'", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Computes metrics for a submission stored in submission_path with a given submission_name with the metrics\n    specified by the config_name.\n    :param version: nuScenes dataset version.\n    :param data_root: Directory storing NuScenes data.\n    :param submission_path: Directory storing submission.\n    :param config_name: Name of config file.\n    \"\"\"", "\n", "predictions", "=", "json", ".", "load", "(", "open", "(", "submission_path", ",", "\"r\"", ")", ")", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "version", ",", "dataroot", "=", "data_root", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "config", "=", "load_prediction_config", "(", "helper", ",", "config_name", ")", "\n", "results", "=", "compute_metrics", "(", "predictions", ",", "helper", ",", "config", ")", "\n", "json", ".", "dump", "(", "results", ",", "open", "(", "submission_path", ".", "replace", "(", "'.json'", ",", "'_metrics.json'", ")", ",", "\"w\"", ")", ",", "indent", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.StaticLayerRasterizer.__init__": [[220, 244], ["static_layers.load_all_maps", "nuscenes.prediction.input_representation.combinators.Rasterizer"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.load_all_maps"], ["def", "__init__", "(", "self", ",", "helper", ":", "PredictHelper", ",", "\n", "layer_names", ":", "List", "[", "str", "]", "=", "None", ",", "\n", "colors", ":", "List", "[", "Color", "]", "=", "None", ",", "\n", "resolution", ":", "float", "=", "0.1", ",", "# meters / pixel", "\n", "meters_ahead", ":", "float", "=", "40", ",", "meters_behind", ":", "float", "=", "10", ",", "\n", "meters_left", ":", "float", "=", "25", ",", "meters_right", ":", "float", "=", "25", ")", ":", "\n", "\n", "        ", "self", ".", "helper", "=", "helper", "\n", "self", ".", "maps", "=", "load_all_maps", "(", "helper", ")", "\n", "\n", "if", "not", "layer_names", ":", "\n", "            ", "layer_names", "=", "[", "'drivable_area'", ",", "'ped_crossing'", ",", "'walkway'", "]", "\n", "", "self", ".", "layer_names", "=", "layer_names", "\n", "\n", "if", "not", "colors", ":", "\n", "            ", "colors", "=", "[", "(", "255", ",", "255", ",", "255", ")", ",", "(", "119", ",", "136", ",", "153", ")", ",", "(", "0", ",", "0", ",", "255", ")", "]", "\n", "", "self", ".", "colors", "=", "colors", "\n", "\n", "self", ".", "resolution", "=", "resolution", "\n", "self", ".", "meters_ahead", "=", "meters_ahead", "\n", "self", ".", "meters_behind", "=", "meters_behind", "\n", "self", ".", "meters_left", "=", "meters_left", "\n", "self", ".", "meters_right", "=", "meters_right", "\n", "self", ".", "combinator", "=", "Rasterizer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.StaticLayerRasterizer.make_representation": [[245, 291], ["static_layers.StaticLayerRasterizer.helper.get_sample_annotation", "static_layers.StaticLayerRasterizer.helper.get_map_name_from_sample_token", "nuscenes.eval.common.utils.quaternion_yaw", "static_layers.correct_yaw", "int", "static_layers.get_patchbox", "static_layers.StaticLayerRasterizer.maps[].get_map_mask", "zip", "static_layers.draw_lanes_in_agent_frame", "images.append", "static_layers.StaticLayerRasterizer.combinator.combine", "nuscenes.prediction.input_representation.utils.get_crops", "pyquaternion.Quaternion", "max", "images.append", "int", "nuscenes.prediction.helper.angle_of_rotation", "static_layers.change_color_of_binary_mask", "numpy.repeat"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_sample_annotation", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_map_name_from_sample_token", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.correct_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.get_patchbox", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMapExplorer.get_map_mask", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.draw_lanes_in_agent_frame", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.combinators.Rasterizer.combine", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.get_crops", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.angle_of_rotation", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.change_color_of_binary_mask"], ["", "def", "make_representation", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Makes rasterized representation of static map layers.\n        :param instance_token: Token for instance.\n        :param sample_token: Token for sample.\n        :return: Three channel image.\n        \"\"\"", "\n", "\n", "sample_annotation", "=", "self", ".", "helper", ".", "get_sample_annotation", "(", "instance_token", ",", "sample_token", ")", "\n", "map_name", "=", "self", ".", "helper", ".", "get_map_name_from_sample_token", "(", "sample_token", ")", "\n", "\n", "x", ",", "y", "=", "sample_annotation", "[", "'translation'", "]", "[", ":", "2", "]", "\n", "\n", "yaw", "=", "quaternion_yaw", "(", "Quaternion", "(", "sample_annotation", "[", "'rotation'", "]", ")", ")", "\n", "\n", "yaw_corrected", "=", "correct_yaw", "(", "yaw", ")", "\n", "\n", "image_side_length", "=", "2", "*", "max", "(", "self", ".", "meters_ahead", ",", "self", ".", "meters_behind", ",", "\n", "self", ".", "meters_left", ",", "self", ".", "meters_right", ")", "\n", "image_side_length_pixels", "=", "int", "(", "image_side_length", "/", "self", ".", "resolution", ")", "\n", "\n", "patchbox", "=", "get_patchbox", "(", "x", ",", "y", ",", "image_side_length", ")", "\n", "\n", "angle_in_degrees", "=", "angle_of_rotation", "(", "yaw_corrected", ")", "*", "180", "/", "np", ".", "pi", "\n", "\n", "canvas_size", "=", "(", "image_side_length_pixels", ",", "image_side_length_pixels", ")", "\n", "\n", "masks", "=", "self", ".", "maps", "[", "map_name", "]", ".", "get_map_mask", "(", "patchbox", ",", "angle_in_degrees", ",", "self", ".", "layer_names", ",", "canvas_size", "=", "canvas_size", ")", "\n", "\n", "images", "=", "[", "]", "\n", "for", "mask", ",", "color", "in", "zip", "(", "masks", ",", "self", ".", "colors", ")", ":", "\n", "            ", "images", ".", "append", "(", "change_color_of_binary_mask", "(", "np", ".", "repeat", "(", "mask", "[", ":", ":", "-", "1", ",", ":", ",", "np", ".", "newaxis", "]", ",", "3", ",", "2", ")", ",", "color", ")", ")", "\n", "\n", "", "lanes", "=", "draw_lanes_in_agent_frame", "(", "image_side_length_pixels", ",", "x", ",", "y", ",", "yaw", ",", "radius", "=", "50", ",", "\n", "image_resolution", "=", "self", ".", "resolution", ",", "discretization_resolution_meters", "=", "1", ",", "\n", "map_api", "=", "self", ".", "maps", "[", "map_name", "]", ")", "\n", "\n", "images", ".", "append", "(", "lanes", ")", "\n", "\n", "image", "=", "self", ".", "combinator", ".", "combine", "(", "images", ")", "\n", "\n", "row_crop", ",", "col_crop", "=", "get_crops", "(", "self", ".", "meters_ahead", ",", "self", ".", "meters_behind", ",", "self", ".", "meters_left", ",", "\n", "self", ".", "meters_right", ",", "self", ".", "resolution", ",", "\n", "int", "(", "image_side_length", "/", "self", ".", "resolution", ")", ")", "\n", "\n", "return", "image", "[", "row_crop", ",", "col_crop", ",", ":", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.load_all_maps": [[23, 40], ["nuscenes.map_expansion.map_api.NuScenesMap", "print"], "function", ["None"], ["def", "load_all_maps", "(", "helper", ":", "PredictHelper", ",", "verbose", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "NuScenesMap", "]", ":", "\n", "    ", "\"\"\"\n    Loads all NuScenesMap instances for all available maps.\n    :param helper: Instance of PredictHelper.\n    :param verbose: Whether to print to stdout.\n    :return: Mapping from map-name to the NuScenesMap api instance.\n    \"\"\"", "\n", "dataroot", "=", "helper", ".", "data", ".", "dataroot", "\n", "maps", "=", "{", "}", "\n", "\n", "for", "map_name", "in", "locations", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "f'static_layers.py - Loading Map: {map_name}'", ")", "\n", "\n", "", "maps", "[", "map_name", "]", "=", "NuScenesMap", "(", "dataroot", ",", "map_name", "=", "map_name", ")", "\n", "\n", "", "return", "maps", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.get_patchbox": [[42, 55], ["None"], "function", ["None"], ["", "def", "get_patchbox", "(", "x_in_meters", ":", "float", ",", "y_in_meters", ":", "float", ",", "\n", "image_side_length", ":", "float", ")", "->", "Tuple", "[", "float", ",", "float", ",", "float", ",", "float", "]", ":", "\n", "    ", "\"\"\"\n    Gets the patchbox representing the area to crop the base image.\n    :param x_in_meters: X coordinate.\n    :param y_in_meters: Y coordiante.\n    :param image_side_length: Length of the image.\n    :return: Patch box tuple.\n    \"\"\"", "\n", "\n", "patch_box", "=", "(", "x_in_meters", ",", "y_in_meters", ",", "image_side_length", ",", "image_side_length", ")", "\n", "\n", "return", "patch_box", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.change_color_of_binary_mask": [[57, 71], ["image.astype.astype"], "function", ["None"], ["", "def", "change_color_of_binary_mask", "(", "image", ":", "np", ".", "ndarray", ",", "color", ":", "Color", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Changes color of binary mask. The image has values 0 or 1 but has three channels.\n    :param image: Image with either 0 or 1 values and three channels.\n    :param color: RGB color tuple.\n    :return: Image with color changed (type uint8).\n    \"\"\"", "\n", "\n", "image", "=", "image", "*", "color", "\n", "\n", "# Return as type int so cv2 can manipulate it later.", "\n", "image", "=", "image", ".", "astype", "(", "\"uint8\"", ")", "\n", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.correct_yaw": [[73, 86], ["None"], "function", ["None"], ["", "def", "correct_yaw", "(", "yaw", ":", "float", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    nuScenes maps were flipped over the y-axis, so we need to\n    add pi to the angle needed to rotate the heading.\n    :param yaw: Yaw angle to rotate the image.\n    :return: Yaw after correction.\n    \"\"\"", "\n", "if", "yaw", "<=", "0", ":", "\n", "        ", "yaw", "=", "-", "np", ".", "pi", "-", "yaw", "\n", "", "else", ":", "\n", "        ", "yaw", "=", "np", ".", "pi", "-", "yaw", "\n", "\n", "", "return", "yaw", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.get_lanes_in_radius": [[88, 108], ["map_api.get_records_in_radius", "map_api.discretize_lanes"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.get_records_in_radius", "home.repos.pwc.inspect_result.fpthink_v2b.map_expansion.map_api.NuScenesMap.discretize_lanes"], ["", "def", "get_lanes_in_radius", "(", "x", ":", "float", ",", "y", ":", "float", ",", "radius", ":", "float", ",", "\n", "discretization_meters", ":", "float", ",", "\n", "map_api", ":", "NuScenesMap", ")", "->", "Dict", "[", "str", ",", "List", "[", "Tuple", "[", "float", ",", "float", ",", "float", "]", "]", "]", ":", "\n", "    ", "\"\"\"\n    Retrieves all the lanes and lane connectors in a radius of the query point.\n    :param x: x-coordinate of point in global coordinates.\n    :param y: y-coordinate of point in global coordinates.\n    :param radius: Any lanes within radius meters of the (x, y) point will be returned.\n    :param discretization_meters: How finely to discretize the lane. If 1 is given, for example,\n        the lane will be discretized into a list of points such that the distances between points\n        is approximately 1 meter.\n    :param map_api: The NuScenesMap instance to query.\n    :return: Mapping from lane id to list of coordinate tuples in global coordinate system.\n    \"\"\"", "\n", "\n", "lanes", "=", "map_api", ".", "get_records_in_radius", "(", "x", ",", "y", ",", "radius", ",", "[", "'lane'", ",", "'lane_connector'", "]", ")", "\n", "lanes", "=", "lanes", "[", "'lane'", "]", "+", "lanes", "[", "'lane_connector'", "]", "\n", "lanes", "=", "map_api", ".", "discretize_lanes", "(", "lanes", ",", "discretization_meters", ")", "\n", "\n", "return", "lanes", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.color_by_yaw": [[110, 130], ["colorsys.hsv_to_rgb", "nuscenes.prediction.helper.angle_diff"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.angle_diff"], ["", "def", "color_by_yaw", "(", "agent_yaw_in_radians", ":", "float", ",", "\n", "lane_yaw_in_radians", ":", "float", ")", "->", "Color", ":", "\n", "    ", "\"\"\"\n    Color the pose one the lane based on its yaw difference to the agent yaw.\n    :param agent_yaw_in_radians: Yaw of the agent with respect to the global frame.\n    :param lane_yaw_in_radians: Yaw of the pose on the lane with respect to the global frame.\n    \"\"\"", "\n", "\n", "# By adding pi, lanes in the same direction as the agent are colored blue.", "\n", "angle", "=", "angle_diff", "(", "agent_yaw_in_radians", ",", "lane_yaw_in_radians", ",", "2", "*", "np", ".", "pi", ")", "+", "np", ".", "pi", "\n", "\n", "# Convert to degrees per colorsys requirement", "\n", "angle", "=", "angle", "*", "180", "/", "np", ".", "pi", "\n", "\n", "normalized_rgb_color", "=", "colorsys", ".", "hsv_to_rgb", "(", "angle", "/", "360", ",", "1.", ",", "1.", ")", "\n", "\n", "color", "=", "[", "color", "*", "255", "for", "color", "in", "normalized_rgb_color", "]", "\n", "\n", "# To make the return type consistent with Color definition", "\n", "return", "color", "[", "0", "]", ",", "color", "[", "1", "]", ",", "color", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.draw_lanes_on_image": [[132, 172], ["lanes.values", "zip", "nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "color_function", "cv2.line"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords"], ["", "def", "draw_lanes_on_image", "(", "image", ":", "np", ".", "ndarray", ",", "\n", "lanes", ":", "Dict", "[", "str", ",", "List", "[", "Tuple", "[", "float", ",", "float", ",", "float", "]", "]", "]", ",", "\n", "agent_global_coords", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "agent_yaw_in_radians", ":", "float", ",", "\n", "agent_pixels", ":", "Tuple", "[", "int", ",", "int", "]", ",", "\n", "resolution", ":", "float", ",", "\n", "color_function", ":", "Callable", "[", "[", "float", ",", "float", "]", ",", "Color", "]", "=", "color_by_yaw", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Draws lanes on image.\n    :param image: Image to draw lanes on. Preferably all-black or all-white image.\n    :param lanes: Mapping from lane id to list of coordinate tuples in global coordinate system.\n    :param agent_global_coords: Location of the agent in the global coordinate frame.\n    :param agent_yaw_in_radians: Yaw of agent in radians.\n    :param agent_pixels: Location of the agent in the image as (row_pixel, column_pixel).\n    :param resolution: Resolution in meters/pixel.\n    :param color_function: By default, lanes are colored by the yaw difference between the pose\n    on the lane and the agent yaw. However, you can supply your own function to color the lanes.\n    :return: Image (represented as np.ndarray) with lanes drawn.\n    \"\"\"", "\n", "\n", "for", "poses_along_lane", "in", "lanes", ".", "values", "(", ")", ":", "\n", "\n", "        ", "for", "start_pose", ",", "end_pose", "in", "zip", "(", "poses_along_lane", "[", ":", "-", "1", "]", ",", "poses_along_lane", "[", "1", ":", "]", ")", ":", "\n", "\n", "            ", "start_pixels", "=", "convert_to_pixel_coords", "(", "start_pose", "[", ":", "2", "]", ",", "agent_global_coords", ",", "\n", "agent_pixels", ",", "resolution", ")", "\n", "end_pixels", "=", "convert_to_pixel_coords", "(", "end_pose", "[", ":", "2", "]", ",", "agent_global_coords", ",", "\n", "agent_pixels", ",", "resolution", ")", "\n", "\n", "start_pixels", "=", "(", "start_pixels", "[", "1", "]", ",", "start_pixels", "[", "0", "]", ")", "\n", "end_pixels", "=", "(", "end_pixels", "[", "1", "]", ",", "end_pixels", "[", "0", "]", ")", "\n", "\n", "color", "=", "color_function", "(", "agent_yaw_in_radians", ",", "start_pose", "[", "2", "]", ")", "\n", "\n", "# Need to flip the row coordinate and the column coordinate", "\n", "# because of cv2 convention", "\n", "cv2", ".", "line", "(", "image", ",", "start_pixels", ",", "end_pixels", ",", "color", ",", "\n", "thickness", "=", "5", ")", "\n", "\n", "", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.draw_lanes_in_agent_frame": [[174, 211], ["numpy.zeros", "static_layers.get_lanes_in_radius", "static_layers.draw_lanes_on_image", "nuscenes.prediction.input_representation.utils.get_rotation_matrix", "cv2.warpAffine", "cv2.warpAffine.astype", "int", "int"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.get_lanes_in_radius", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.static_layers.draw_lanes_on_image", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.get_rotation_matrix"], ["", "def", "draw_lanes_in_agent_frame", "(", "image_side_length", ":", "int", ",", "\n", "agent_x", ":", "float", ",", "agent_y", ":", "float", ",", "\n", "agent_yaw", ":", "float", ",", "\n", "radius", ":", "float", ",", "\n", "image_resolution", ":", "float", ",", "\n", "discretization_resolution_meters", ":", "float", ",", "\n", "map_api", ":", "NuScenesMap", ",", "\n", "color_function", ":", "Callable", "[", "[", "float", ",", "float", "]", ",", "Color", "]", "=", "color_by_yaw", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Queries the map api for the nearest lanes, discretizes them, draws them on an image\n    and rotates the image so the agent heading is aligned with the postive y axis.\n    :param image_side_length: Length of the image.\n    :param agent_x: Agent X-coordinate in global frame.\n    :param agent_y: Agent Y-coordinate in global frame.\n    :param agent_yaw: Agent yaw, in radians.\n    :param radius: Draws the lanes that are within radius meters of the agent.\n    :param image_resolution: Image resolution in pixels / meter.\n    :param discretization_resolution_meters: How finely to discretize the lanes.\n    :param map_api: Instance of NuScenesMap.\n    :param color_function: By default, lanes are colored by the yaw difference between the pose\n        on the lane and the agent yaw. However, you can supply your own function to color the lanes.\n    :return: np array with lanes drawn.\n    \"\"\"", "\n", "\n", "agent_pixels", "=", "int", "(", "image_side_length", "/", "2", ")", ",", "int", "(", "image_side_length", "/", "2", ")", "\n", "base_image", "=", "np", ".", "zeros", "(", "(", "image_side_length", ",", "image_side_length", ",", "3", ")", ")", "\n", "\n", "lanes", "=", "get_lanes_in_radius", "(", "agent_x", ",", "agent_y", ",", "radius", ",", "discretization_resolution_meters", ",", "map_api", ")", "\n", "\n", "image_with_lanes", "=", "draw_lanes_on_image", "(", "base_image", ",", "lanes", ",", "(", "agent_x", ",", "agent_y", ")", ",", "agent_yaw", ",", "\n", "agent_pixels", ",", "image_resolution", ",", "color_function", ")", "\n", "\n", "rotation_mat", "=", "get_rotation_matrix", "(", "image_with_lanes", ".", "shape", ",", "agent_yaw", ")", "\n", "\n", "rotated_image", "=", "cv2", ".", "warpAffine", "(", "image_with_lanes", ",", "rotation_mat", ",", "image_with_lanes", ".", "shape", "[", ":", "2", "]", ")", "\n", "\n", "return", "rotated_image", ".", "astype", "(", "\"uint8\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.interface.StaticLayerRepresentation.make_representation": [[12, 15], ["NotImplementedError"], "methods", ["None"], ["@", "abc", ".", "abstractmethod", "\n", "def", "make_representation", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.interface.AgentRepresentation.make_representation": [[20, 23], ["NotImplementedError"], "methods", ["None"], ["@", "abc", ".", "abstractmethod", "\n", "def", "make_representation", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.interface.Combinator.combine": [[28, 31], ["NotImplementedError"], "methods", ["None"], ["@", "abc", ".", "abstractmethod", "\n", "def", "combine", "(", "self", ",", "data", ":", "List", "[", "np", ".", "ndarray", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.interface.InputRepresentation.__init__": [[41, 47], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "static_layer", ":", "StaticLayerRepresentation", ",", "agent", ":", "AgentRepresentation", ",", "\n", "combinator", ":", "Combinator", ")", ":", "\n", "\n", "        ", "self", ".", "static_layer_rasterizer", "=", "static_layer", "\n", "self", ".", "agent_rasterizer", "=", "agent", "\n", "self", ".", "combinator", "=", "combinator", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.interface.InputRepresentation.make_input_representation": [[48, 54], ["interface.InputRepresentation.static_layer_rasterizer.make_representation", "interface.InputRepresentation.agent_rasterizer.make_representation", "interface.InputRepresentation.combinator.combine"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.AgentBoxesWithFadedHistory.make_representation", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.AgentBoxesWithFadedHistory.make_representation", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.combinators.Rasterizer.combine"], ["", "def", "make_input_representation", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "\n", "        ", "static_layers", "=", "self", ".", "static_layer_rasterizer", ".", "make_representation", "(", "instance_token", ",", "sample_token", ")", "\n", "agents", "=", "self", ".", "agent_rasterizer", ".", "make_representation", "(", "instance_token", ",", "sample_token", ")", "\n", "\n", "return", "self", ".", "combinator", ".", "combine", "(", "[", "static_layers", ",", "agents", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.combinators.Rasterizer.combine": [[43, 54], ["numpy.zeros().astype", "functools.reduce", "numpy.zeros"], "methods", ["None"], ["def", "combine", "(", "self", ",", "data", ":", "List", "[", "np", ".", "ndarray", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Combine three channel images into a single image.\n        :param data: List of images to combine.\n        :return: Numpy array representing image (type 'uint8')\n        \"\"\"", "\n", "# All images in the dict are the same shape", "\n", "image_shape", "=", "data", "[", "0", "]", ".", "shape", "\n", "\n", "base_image", "=", "np", ".", "zeros", "(", "image_shape", ")", ".", "astype", "(", "\"uint8\"", ")", "\n", "return", "reduce", "(", "add_foreground_to_image", ",", "[", "base_image", "]", "+", "data", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.combinators.add_foreground_to_image": [[12, 36], ["cv2.cvtColor", "cv2.threshold", "cv2.bitwise_not", "cv2.bitwise_and", "cv2.bitwise_and", "cv2.add", "ValueError", "ValueError"], "function", ["None"], ["def", "add_foreground_to_image", "(", "base_image", ":", "np", ".", "ndarray", ",", "\n", "foreground_image", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Overlays a foreground image on top of a base image without mixing colors. Type uint8.\n    :param base_image: Image that will be the background. Type uint8.\n    :param foreground_image: Image that will be the foreground.\n    :return: Image Numpy array of type uint8.\n    \"\"\"", "\n", "\n", "if", "not", "base_image", ".", "shape", "==", "foreground_image", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "\"base_image and foreground image must have the same shape.\"", "\n", "\" Received {} and {}\"", ".", "format", "(", "base_image", ".", "shape", ",", "foreground_image", ".", "shape", ")", ")", "\n", "\n", "", "if", "not", "(", "base_image", ".", "dtype", "==", "\"uint8\"", "and", "foreground_image", ".", "dtype", "==", "\"uint8\"", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"base_image and foreground image must be of type 'uint8'.\"", "\n", "\" Received {} and {}\"", ".", "format", "(", "base_image", ".", "dtype", ",", "foreground_image", ".", "dtype", ")", ")", "\n", "\n", "", "img2gray", "=", "cv2", ".", "cvtColor", "(", "foreground_image", ",", "cv2", ".", "COLOR_BGR2GRAY", ")", "\n", "_", ",", "mask", "=", "cv2", ".", "threshold", "(", "img2gray", ",", "0", ",", "255", ",", "cv2", ".", "THRESH_BINARY", ")", "\n", "mask_inv", "=", "cv2", ".", "bitwise_not", "(", "mask", ")", "\n", "img1_bg", "=", "cv2", ".", "bitwise_and", "(", "base_image", ",", "base_image", ",", "mask", "=", "mask_inv", ")", "\n", "img2_fg", "=", "cv2", ".", "bitwise_and", "(", "foreground_image", ",", "foreground_image", ",", "mask", "=", "mask", ")", "\n", "combined_image", "=", "cv2", ".", "add", "(", "img1_bg", ",", "img2_fg", ")", "\n", "return", "combined_image", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.AgentBoxesWithFadedHistory.__init__": [[205, 231], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "helper", ":", "PredictHelper", ",", "\n", "seconds_of_history", ":", "float", "=", "2", ",", "\n", "frequency_in_hz", ":", "float", "=", "2", ",", "\n", "resolution", ":", "float", "=", "0.1", ",", "# meters / pixel", "\n", "meters_ahead", ":", "float", "=", "40", ",", "meters_behind", ":", "float", "=", "10", ",", "\n", "meters_left", ":", "float", "=", "25", ",", "meters_right", ":", "float", "=", "25", ",", "\n", "color_mapping", ":", "Callable", "[", "[", "str", "]", ",", "Tuple", "[", "int", ",", "int", ",", "int", "]", "]", "=", "None", ")", ":", "\n", "\n", "        ", "self", ".", "helper", "=", "helper", "\n", "self", ".", "seconds_of_history", "=", "seconds_of_history", "\n", "self", ".", "frequency_in_hz", "=", "frequency_in_hz", "\n", "\n", "if", "not", "resolution", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Resolution must be positive. Received {resolution}.\"", ")", "\n", "\n", "", "self", ".", "resolution", "=", "resolution", "\n", "\n", "self", ".", "meters_ahead", "=", "meters_ahead", "\n", "self", ".", "meters_behind", "=", "meters_behind", "\n", "self", ".", "meters_left", "=", "meters_left", "\n", "self", ".", "meters_right", "=", "meters_right", "\n", "\n", "if", "not", "color_mapping", ":", "\n", "            ", "color_mapping", "=", "default_colors", "\n", "\n", "", "self", ".", "color_mapping", "=", "color_mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.AgentBoxesWithFadedHistory.make_representation": [[232, 277], ["int", "numpy.zeros", "agents.AgentBoxesWithFadedHistory.helper.get_past_for_sample", "agents.reverse_history", "agents.AgentBoxesWithFadedHistory.helper.get_annotations_for_sample", "agents.add_present_time_to_history", "agents.AgentBoxesWithFadedHistory.helper.get_sample_annotation", "agents.draw_agent_boxes", "nuscenes.prediction.helper.quaternion_yaw", "nuscenes.prediction.input_representation.utils.get_rotation_matrix", "cv2.warpAffine", "nuscenes.prediction.input_representation.utils.get_crops", "rotated_image[].astype", "max", "pyquaternion.Quaternion"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_past_for_sample", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.reverse_history", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_annotations_for_sample", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.add_present_time_to_history", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_sample_annotation", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.draw_agent_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.get_rotation_matrix", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.get_crops"], ["", "def", "make_representation", "(", "self", ",", "instance_token", ":", "str", ",", "sample_token", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Draws agent boxes with faded history into a black background.\n        :param instance_token: Instance token.\n        :param sample_token: Sample token.\n        :return: np.ndarray representing a 3 channel image.\n        \"\"\"", "\n", "\n", "# Taking radius around track before to ensure all actors are in image", "\n", "buffer", "=", "max", "(", "[", "self", ".", "meters_ahead", ",", "self", ".", "meters_behind", ",", "\n", "self", ".", "meters_left", ",", "self", ".", "meters_right", "]", ")", "*", "2", "\n", "\n", "image_side_length", "=", "int", "(", "buffer", "/", "self", ".", "resolution", ")", "\n", "\n", "# We will center the track in the image", "\n", "central_track_pixels", "=", "(", "image_side_length", "/", "2", ",", "image_side_length", "/", "2", ")", "\n", "\n", "base_image", "=", "np", ".", "zeros", "(", "(", "image_side_length", ",", "image_side_length", ",", "3", ")", ")", "\n", "\n", "history", "=", "self", ".", "helper", ".", "get_past_for_sample", "(", "sample_token", ",", "\n", "self", ".", "seconds_of_history", ",", "\n", "in_agent_frame", "=", "False", ",", "\n", "just_xy", "=", "False", ")", "\n", "history", "=", "reverse_history", "(", "history", ")", "\n", "\n", "present_time", "=", "self", ".", "helper", ".", "get_annotations_for_sample", "(", "sample_token", ")", "\n", "\n", "history", "=", "add_present_time_to_history", "(", "present_time", ",", "history", ")", "\n", "\n", "center_agent_annotation", "=", "self", ".", "helper", ".", "get_sample_annotation", "(", "instance_token", ",", "sample_token", ")", "\n", "\n", "draw_agent_boxes", "(", "center_agent_annotation", ",", "central_track_pixels", ",", "\n", "history", ",", "base_image", ",", "resolution", "=", "self", ".", "resolution", ",", "get_color", "=", "self", ".", "color_mapping", ")", "\n", "\n", "center_agent_yaw", "=", "quaternion_yaw", "(", "Quaternion", "(", "center_agent_annotation", "[", "'rotation'", "]", ")", ")", "\n", "rotation_mat", "=", "get_rotation_matrix", "(", "base_image", ".", "shape", ",", "center_agent_yaw", ")", "\n", "\n", "rotated_image", "=", "cv2", ".", "warpAffine", "(", "base_image", ",", "rotation_mat", ",", "(", "base_image", ".", "shape", "[", "1", "]", ",", "\n", "base_image", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "row_crop", ",", "col_crop", "=", "get_crops", "(", "self", ".", "meters_ahead", ",", "self", ".", "meters_behind", ",", "\n", "self", ".", "meters_left", ",", "self", ".", "meters_right", ",", "self", ".", "resolution", ",", "\n", "image_side_length", ")", "\n", "\n", "return", "rotated_image", "[", "row_crop", ",", "col_crop", "]", ".", "astype", "(", "'uint8'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.pixels_to_box_corners": [[18, 43], ["cv2.boxPoints"], "function", ["None"], ["def", "pixels_to_box_corners", "(", "row_pixel", ":", "int", ",", "\n", "column_pixel", ":", "int", ",", "\n", "length_in_pixels", ":", "float", ",", "\n", "width_in_pixels", ":", "float", ",", "\n", "yaw_in_radians", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Computes four corners of 2d bounding box for agent.\n    The coordinates of the box are in pixels.\n    :param row_pixel: Row pixel of the agent.\n    :param column_pixel: Column pixel of the agent.\n    :param length_in_pixels: Length of the agent.\n    :param width_in_pixels: Width of the agent.\n    :param yaw_in_radians: Yaw of the agent (global coordinates).\n    :return: numpy array representing the four corners of the agent.\n    \"\"\"", "\n", "\n", "# cv2 has the convention where they flip rows and columns so it matches", "\n", "# the convention of x and y on a coordinate plane", "\n", "# Also, a positive angle is a clockwise rotation as opposed to counterclockwise", "\n", "# so that is why we negate the rotation angle", "\n", "coord_tuple", "=", "(", "(", "column_pixel", ",", "row_pixel", ")", ",", "(", "length_in_pixels", ",", "width_in_pixels", ")", ",", "-", "yaw_in_radians", "*", "180", "/", "np", ".", "pi", ")", "\n", "\n", "box", "=", "cv2", ".", "boxPoints", "(", "coord_tuple", ")", "\n", "\n", "return", "box", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.get_track_box": [[45, 74], ["nuscenes.prediction.helper.quaternion_yaw", "nuscenes.prediction.input_representation.utils.convert_to_pixel_coords", "agents.pixels_to_box_corners", "pyquaternion.Quaternion"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.pixels_to_box_corners"], ["", "def", "get_track_box", "(", "annotation", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "center_coordinates", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "center_pixels", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "resolution", ":", "float", "=", "0.1", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Get four corners of bounding box for agent in pixels.\n    :param annotation: The annotation record of the agent.\n    :param center_coordinates: (x, y) coordinates in global frame\n        of the center of the image.\n    :param center_pixels: (row_index, column_index) location of the center\n        of the image in pixel coordinates.\n    :param resolution: Resolution pixels/meter of the image.\n    \"\"\"", "\n", "\n", "assert", "resolution", ">", "0", "\n", "\n", "location", "=", "annotation", "[", "'translation'", "]", "[", ":", "2", "]", "\n", "yaw_in_radians", "=", "quaternion_yaw", "(", "Quaternion", "(", "annotation", "[", "'rotation'", "]", ")", ")", "\n", "\n", "row_pixel", ",", "column_pixel", "=", "convert_to_pixel_coords", "(", "location", ",", "\n", "center_coordinates", ",", "\n", "center_pixels", ",", "resolution", ")", "\n", "\n", "width", "=", "annotation", "[", "'size'", "]", "[", "0", "]", "/", "resolution", "\n", "length", "=", "annotation", "[", "'size'", "]", "[", "1", "]", "/", "resolution", "\n", "\n", "# Width and length are switched here so that we can draw them along the x-axis as", "\n", "# opposed to the y. This makes rotation easier.", "\n", "return", "pixels_to_box_corners", "(", "row_pixel", ",", "column_pixel", ",", "length", ",", "width", ",", "yaw_in_radians", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.reverse_history": [[76, 84], ["history.items"], "function", ["None"], ["", "def", "reverse_history", "(", "history", ":", "History", ")", "->", "History", ":", "\n", "    ", "\"\"\"\n    Reverse history so that most distant observations are first.\n    We do this because we want to draw more recent bounding boxes on top of older ones.\n    :param history: result of get_past_for_sample PredictHelper method.\n    :return: History with the values reversed.\n    \"\"\"", "\n", "return", "{", "token", ":", "anns", "[", ":", ":", "-", "1", "]", "for", "token", ",", "anns", "in", "history", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.add_present_time_to_history": [[86, 110], ["history[].append"], "function", ["None"], ["", "def", "add_present_time_to_history", "(", "current_time", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", ",", "\n", "history", ":", "History", ")", "->", "History", ":", "\n", "    ", "\"\"\"\n    Adds the sample annotation records from the current time to the\n    history object.\n    :param current_time: List of sample annotation records from the\n        current time. Result of get_annotations_for_sample method of\n        PredictHelper.\n    :param history: Result of get_past_for_sample method of PredictHelper.\n    :return: History with values from current_time appended.\n    \"\"\"", "\n", "\n", "for", "annotation", "in", "current_time", ":", "\n", "        ", "token", "=", "annotation", "[", "'instance_token'", "]", "\n", "\n", "if", "token", "in", "history", ":", "\n", "\n", "# We append because we've reversed the history", "\n", "            ", "history", "[", "token", "]", ".", "append", "(", "annotation", ")", "\n", "\n", "", "else", ":", "\n", "            ", "history", "[", "token", "]", "=", "[", "annotation", "]", "\n", "\n", "", "", "return", "history", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.fade_color": [[112, 139], ["colorsys.rgb_to_hsv", "colorsys.hsv_to_rgb", "float", "float", "float"], "function", ["None"], ["", "def", "fade_color", "(", "color", ":", "Tuple", "[", "int", ",", "int", ",", "int", "]", ",", "\n", "step", ":", "int", ",", "\n", "total_number_of_steps", ":", "int", ")", "->", "Tuple", "[", "int", ",", "int", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Fades a color so that past observations are darker in the image.\n    :param color: Tuple of ints describing an RGB color.\n    :param step: The current time step.\n    :param total_number_of_steps: The total number of time steps\n        the agent has in the image.\n    :return: Tuple representing faded rgb color.\n    \"\"\"", "\n", "\n", "LOWEST_VALUE", "=", "0.4", "\n", "\n", "if", "step", "==", "total_number_of_steps", ":", "\n", "        ", "return", "color", "\n", "\n", "", "hsv_color", "=", "colorsys", ".", "rgb_to_hsv", "(", "*", "color", ")", "\n", "\n", "increment", "=", "(", "float", "(", "hsv_color", "[", "2", "]", ")", "/", "255.", "-", "LOWEST_VALUE", ")", "/", "total_number_of_steps", "\n", "\n", "new_value", "=", "LOWEST_VALUE", "+", "step", "*", "increment", "\n", "\n", "new_rgb", "=", "colorsys", ".", "hsv_to_rgb", "(", "float", "(", "hsv_color", "[", "0", "]", ")", ",", "\n", "float", "(", "hsv_color", "[", "1", "]", ")", ",", "\n", "new_value", "*", "255.", ")", "\n", "return", "new_rgb", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.default_colors": [[141, 156], ["ValueError"], "function", ["None"], ["", "def", "default_colors", "(", "category_name", ":", "str", ")", "->", "Tuple", "[", "int", ",", "int", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Maps a category name to an rgb color (without fading).\n    :param category_name: Name of object category for the annotation.\n    :return: Tuple representing rgb color.\n    \"\"\"", "\n", "\n", "if", "'vehicle'", "in", "category_name", ":", "\n", "        ", "return", "255", ",", "255", ",", "0", "# yellow", "\n", "", "elif", "'object'", "in", "category_name", ":", "\n", "        ", "return", "204", ",", "0", ",", "204", "# violet", "\n", "", "elif", "'human'", "in", "category_name", "or", "'animal'", "in", "category_name", ":", "\n", "        ", "return", "255", ",", "153", ",", "51", "# orange", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Cannot map {category_name} to a color.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.draw_agent_boxes": [[158, 197], ["agent_history.items", "len", "enumerate", "agents.get_track_box", "cv2.fillPoly", "get_color", "agents.fade_color", "numpy.int0"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.get_track_box", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenesExplorer.get_color", "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.agents.fade_color"], ["", "", "def", "draw_agent_boxes", "(", "center_agent_annotation", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "center_agent_pixels", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "agent_history", ":", "History", ",", "\n", "base_image", ":", "np", ".", "ndarray", ",", "\n", "get_color", ":", "Callable", "[", "[", "str", "]", ",", "Tuple", "[", "int", ",", "int", ",", "int", "]", "]", ",", "\n", "resolution", ":", "float", "=", "0.1", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Draws past sequence of agent boxes on the image.\n    :param center_agent_annotation: Annotation record for the agent\n        that is in the center of the image.\n    :param center_agent_pixels: Pixel location of the agent in the\n        center of the image.\n    :param agent_history: History for all agents in the scene.\n    :param base_image: Image to draw the agents in.\n    :param get_color: Mapping from category_name to RGB tuple.\n    :param resolution: Size of the image in pixels / meter.\n    :return: None.\n    \"\"\"", "\n", "\n", "agent_x", ",", "agent_y", "=", "center_agent_annotation", "[", "'translation'", "]", "[", ":", "2", "]", "\n", "\n", "for", "instance_token", ",", "annotations", "in", "agent_history", ".", "items", "(", ")", ":", "\n", "\n", "        ", "num_points", "=", "len", "(", "annotations", ")", "\n", "\n", "for", "i", ",", "annotation", "in", "enumerate", "(", "annotations", ")", ":", "\n", "\n", "            ", "box", "=", "get_track_box", "(", "annotation", ",", "(", "agent_x", ",", "agent_y", ")", ",", "center_agent_pixels", ",", "resolution", ")", "\n", "\n", "if", "instance_token", "==", "center_agent_annotation", "[", "'instance_token'", "]", ":", "\n", "                ", "color", "=", "(", "255", ",", "0", ",", "0", ")", "\n", "", "else", ":", "\n", "                ", "color", "=", "get_color", "(", "annotation", "[", "'category_name'", "]", ")", "\n", "\n", "# Don't fade the colors if there is no history", "\n", "", "if", "num_points", ">", "1", ":", "\n", "                ", "color", "=", "fade_color", "(", "color", ",", "i", ",", "num_points", "-", "1", ")", "\n", "\n", "", "cv2", ".", "fillPoly", "(", "base_image", ",", "pts", "=", "[", "np", ".", "int0", "(", "box", ")", "]", ",", "color", "=", "color", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.convert_to_pixel_coords": [[11, 36], ["int", "int"], "function", ["None"], ["import", "numpy", "as", "np", "\n", "from", "pycocotools", "import", "mask", "as", "cocomask", "\n", "\n", "\n", "def", "annotation_name", "(", "attributes", ":", "List", "[", "dict", "]", ",", "\n", "category_name", ":", "str", ",", "\n", "with_attributes", ":", "bool", "=", "False", ")", "->", "str", ":", "\n", "    ", "\"\"\"\n    Returns the \"name\" of an annotation, optionally including the attributes.\n    :param attributes: The attribute dictionary.\n    :param category_name: Name of the object category.\n    :param with_attributes: Whether to print the attributes alongside the category name.\n    :return: A human readable string describing the annotation.\n    \"\"\"", "\n", "outstr", "=", "category_name", "\n", "\n", "if", "with_attributes", ":", "\n", "        ", "atts", "=", "[", "attribute", "[", "'name'", "]", "for", "attribute", "in", "attributes", "]", "\n", "if", "len", "(", "atts", ")", ">", "0", ":", "\n", "            ", "outstr", "=", "outstr", "+", "\"--\"", "+", "'.'", ".", "join", "(", "atts", ")", "\n", "\n", "", "", "return", "outstr", "\n", "\n", "\n", "", "def", "mask_decode", "(", "mask", ":", "dict", ")", "->", "np", ".", "ndarray", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.get_crops": [[38, 59], ["slice", "slice", "int", "int", "int"], "function", ["None"], ["\n", "# Note that it is essential to copy the mask here. If we use the same variable we will overwrite the NuImage class", "\n", "# and cause the Jupyter Notebook to crash on some systems.", "\n", "new_mask", "=", "mask", ".", "copy", "(", ")", "\n", "new_mask", "[", "'counts'", "]", "=", "base64", ".", "b64decode", "(", "mask", "[", "'counts'", "]", ")", "\n", "return", "cocomask", ".", "decode", "(", "new_mask", ")", "\n", "\n", "\n", "", "def", "get_font", "(", "fonts_valid", ":", "List", "[", "str", "]", "=", "None", ",", "font_size", ":", "int", "=", "15", ")", "->", "ImageFont", ":", "\n", "    ", "\"\"\"\n    Check if there is a desired font present in the user's system. If there is, use that font; otherwise, use a default\n    font.\n    :param fonts_valid: A list of fonts which are desirable.\n    :param font_size: The size of the font to set. Note that if the default font is used, then the font size\n        cannot be set.\n    :return: An ImageFont object to use as the font in a PIL image.\n    \"\"\"", "\n", "# If there are no desired fonts supplied, use a hardcoded list of fonts which are desirable.", "\n", "if", "fonts_valid", "is", "None", ":", "\n", "        ", "fonts_valid", "=", "[", "'FreeSerif.ttf'", ",", "'FreeSans.ttf'", ",", "'Century.ttf'", ",", "'Calibri.ttf'", ",", "'arial.ttf'", "]", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.input_representation.utils.get_rotation_matrix": [[61, 74], ["cv2.getRotationMatrix2D", "nuscenes.prediction.helper.angle_of_rotation"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.angle_of_rotation"], ["# Find a list of fonts within the user's system.", "\n", "", "fonts_in_sys", "=", "matplotlib", ".", "font_manager", ".", "findSystemFonts", "(", "fontpaths", "=", "None", ",", "fontext", "=", "'ttf'", ")", "\n", "# Sort the list of fonts to ensure that the desired fonts are always found in the same order.", "\n", "fonts_in_sys", "=", "sorted", "(", "fonts_in_sys", ")", "\n", "# Of all the fonts found in the user's system, check if any of them are desired.", "\n", "for", "font_in_sys", "in", "fonts_in_sys", ":", "\n", "        ", "if", "any", "(", "os", ".", "path", ".", "basename", "(", "font_in_sys", ")", "in", "s", "for", "s", "in", "fonts_valid", ")", ":", "\n", "            ", "return", "ImageFont", ".", "truetype", "(", "font_in_sys", ",", "font_size", ")", "\n", "\n", "# If none of the fonts in the user's system are desirable, then use the default font.", "\n", "", "", "warnings", ".", "warn", "(", "'No suitable fonts were found in your system. '", "\n", "'A default font will be used instead (the font size will not be adjustable).'", ")", "\n", "return", "ImageFont", ".", "load_default", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTP.__init__": [[24, 55], ["torch.nn.Module.__init__", "nuscenes.prediction.models.backbone.calculate_backbone_feature_dim", "torch.nn.Linear", "torch.nn.Linear", "int", "int"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__", "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.calculate_backbone_feature_dim"], ["def", "__init__", "(", "self", ",", "backbone", ":", "nn", ".", "Module", ",", "num_modes", ":", "int", ",", "\n", "seconds", ":", "float", "=", "6", ",", "frequency_in_hz", ":", "float", "=", "2", ",", "\n", "n_hidden_layers", ":", "int", "=", "4096", ",", "input_shape", ":", "Tuple", "[", "int", ",", "int", ",", "int", "]", "=", "(", "3", ",", "500", ",", "500", ")", ")", ":", "\n", "        ", "\"\"\"\n        Inits the MTP network.\n        :param backbone: CNN Backbone to use.\n        :param num_modes: Number of predicted paths to estimate for each agent.\n        :param seconds: Number of seconds into the future to predict.\n            Default for the challenge is 6.\n        :param frequency_in_hz: Frequency between timesteps in the prediction (in Hz).\n            Highest frequency is nuScenes is 2 Hz.\n        :param n_hidden_layers: Size of fully connected layer after the CNN\n            backbone processes the image.\n        :param input_shape: Shape of the input expected by the network.\n            This is needed because the size of the fully connected layer after\n            the backbone depends on the backbone and its version.\n\n        Note:\n            Although seconds and frequency_in_hz are typed as floats, their\n            product should be an int.\n        \"\"\"", "\n", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "backbone", "=", "backbone", "\n", "self", ".", "num_modes", "=", "num_modes", "\n", "backbone_feature_dim", "=", "calculate_backbone_feature_dim", "(", "backbone", ",", "input_shape", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "backbone_feature_dim", "+", "ASV_DIM", ",", "n_hidden_layers", ")", "\n", "predictions_per_mode", "=", "int", "(", "seconds", "*", "frequency_in_hz", ")", "*", "2", "\n", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "n_hidden_layers", ",", "int", "(", "num_modes", "*", "predictions_per_mode", "+", "num_modes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTP.forward": [[56, 82], ["mtp.MTP.backbone", "torch.cat", "mtp.MTP.fc2", "predictions[].clone", "torch.cat", "mtp.MTP.fc1", "torch.nn.functional.softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image_tensor", ":", "torch", ".", "Tensor", ",", "\n", "agent_state_vector", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Forward pass of the model.\n        :param image_tensor: Tensor of images shape [batch_size, n_channels, length, width].\n        :param agent_state_vector: Tensor of floats representing the agent state.\n            [batch_size, 3].\n        :return: Tensor of dimension [batch_size, number_of_modes * number_of_predictions_per_mode + number_of_modes]\n            storing the predicted trajectory and mode probabilities. Mode probabilities are normalized to sum\n            to 1 during inference.\n        \"\"\"", "\n", "\n", "backbone_features", "=", "self", ".", "backbone", "(", "image_tensor", ")", "\n", "\n", "features", "=", "torch", ".", "cat", "(", "[", "backbone_features", ",", "agent_state_vector", "]", ",", "dim", "=", "1", ")", "\n", "\n", "predictions", "=", "self", ".", "fc2", "(", "self", ".", "fc1", "(", "features", ")", ")", "\n", "\n", "# Normalize the probabilities to sum to 1 for inference.", "\n", "mode_probabilities", "=", "predictions", "[", ":", ",", "-", "self", ".", "num_modes", ":", "]", ".", "clone", "(", ")", "\n", "if", "not", "self", ".", "training", ":", "\n", "            ", "mode_probabilities", "=", "f", ".", "softmax", "(", "mode_probabilities", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "predictions", "=", "predictions", "[", ":", ",", ":", "-", "self", ".", "num_modes", "]", "\n", "\n", "return", "torch", ".", "cat", "(", "(", "predictions", ",", "mode_probabilities", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss.__init__": [[87, 103], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "num_modes", ":", "int", ",", "\n", "regression_loss_weight", ":", "float", "=", "1.", ",", "\n", "angle_threshold_degrees", ":", "float", "=", "5.", ")", ":", "\n", "        ", "\"\"\"\n        Inits MTP loss.\n        :param num_modes: How many modes are being predicted for each agent.\n        :param regression_loss_weight: Coefficient applied to the regression loss to\n            balance classification and regression performance.\n        :param angle_threshold_degrees: Minimum angle needed between a predicted trajectory\n            and the ground to consider it a match.\n        \"\"\"", "\n", "self", ".", "num_modes", "=", "num_modes", "\n", "self", ".", "num_location_coordinates_predicted", "=", "2", "# We predict x, y coordinates at each timestep.", "\n", "self", ".", "regression_loss_weight", "=", "regression_loss_weight", "\n", "self", ".", "angle_threshold", "=", "angle_threshold_degrees", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._get_trajectory_and_modes": [[104, 118], ["model_prediction[].clone", "model_prediction[].clone().reshape", "model_prediction[].clone"], "methods", ["None"], ["", "def", "_get_trajectory_and_modes", "(", "self", ",", "\n", "model_prediction", ":", "torch", ".", "Tensor", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Splits the predictions from the model into mode probabilities and trajectory.\n        :param model_prediction: Tensor of shape [batch_size, n_timesteps * n_modes * 2 + n_modes].\n        :return: Tuple of tensors. First item is the trajectories of shape [batch_size, n_modes, n_timesteps, 2].\n            Second item are the mode probabilities of shape [batch_size, num_modes].\n        \"\"\"", "\n", "mode_probabilities", "=", "model_prediction", "[", ":", ",", "-", "self", ".", "num_modes", ":", "]", ".", "clone", "(", ")", "\n", "\n", "desired_shape", "=", "(", "model_prediction", ".", "shape", "[", "0", "]", ",", "self", ".", "num_modes", ",", "-", "1", ",", "self", ".", "num_location_coordinates_predicted", ")", "\n", "trajectories_no_modes", "=", "model_prediction", "[", ":", ",", ":", "-", "self", ".", "num_modes", "]", ".", "clone", "(", ")", ".", "reshape", "(", "desired_shape", ")", "\n", "\n", "return", "trajectories_no_modes", ",", "mode_probabilities", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between": [[119, 156], ["float", "math.isclose", "float", "math.degrees", "ValueError", "torch.isnan().any", "torch.isnan().any", "ref_traj[].dot", "math.acos", "torch.norm", "torch.norm", "max", "torch.isnan", "torch.isnan", "min"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_angle_between", "(", "ref_traj", ":", "torch", ".", "Tensor", ",", "\n", "traj_to_compare", ":", "torch", ".", "Tensor", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Computes the angle between the last points of the two trajectories.\n        The resulting angle is in degrees and is an angle in the [0; 180) interval.\n        :param ref_traj: Tensor of shape [n_timesteps, 2].\n        :param traj_to_compare: Tensor of shape [n_timesteps, 2].\n        :return: Angle between the trajectories.\n        \"\"\"", "\n", "\n", "EPSILON", "=", "1e-5", "\n", "\n", "if", "(", "ref_traj", ".", "ndim", "!=", "2", "or", "traj_to_compare", ".", "ndim", "!=", "2", "or", "\n", "ref_traj", ".", "shape", "[", "1", "]", "!=", "2", "or", "traj_to_compare", ".", "shape", "[", "1", "]", "!=", "2", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Both tensors should have shapes (-1, 2).'", ")", "\n", "\n", "", "if", "torch", ".", "isnan", "(", "traj_to_compare", "[", "-", "1", "]", ")", ".", "any", "(", ")", "or", "torch", ".", "isnan", "(", "ref_traj", "[", "-", "1", "]", ")", ".", "any", "(", ")", ":", "\n", "            ", "return", "180.", "-", "EPSILON", "\n", "\n", "", "traj_norms_product", "=", "float", "(", "torch", ".", "norm", "(", "ref_traj", "[", "-", "1", "]", ")", "*", "torch", ".", "norm", "(", "traj_to_compare", "[", "-", "1", "]", ")", ")", "\n", "\n", "# If either of the vectors described in the docstring has norm 0, return 0 as the angle.", "\n", "if", "math", ".", "isclose", "(", "traj_norms_product", ",", "0", ")", ":", "\n", "            ", "return", "0.", "\n", "\n", "# We apply the max and min operations below to ensure there is no value", "\n", "# returned for cos_angle that is greater than 1 or less than -1.", "\n", "# This should never be the case, but the check is in place for cases where", "\n", "# we might encounter numerical instability.", "\n", "", "dot_product", "=", "float", "(", "ref_traj", "[", "-", "1", "]", ".", "dot", "(", "traj_to_compare", "[", "-", "1", "]", ")", ")", "\n", "angle", "=", "math", ".", "degrees", "(", "math", ".", "acos", "(", "max", "(", "min", "(", "dot_product", "/", "traj_norms_product", ",", "1", ")", ",", "-", "1", ")", ")", ")", "\n", "\n", "if", "angle", ">=", "180", ":", "\n", "            ", "return", "angle", "-", "EPSILON", "\n", "\n", "", "return", "angle", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_ave_l2_norms": [[157, 167], ["torch.norm", "torch.mean", "torch.mean.item"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_compute_ave_l2_norms", "(", "tensor", ":", "torch", ".", "Tensor", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Compute the average of l2 norms of each row in the tensor.\n        :param tensor: Shape [1, n_timesteps, 2].\n        :return: Average l2 norm. Float.\n        \"\"\"", "\n", "l2_norms", "=", "torch", ".", "norm", "(", "tensor", ",", "p", "=", "2", ",", "dim", "=", "2", ")", "\n", "avg_distance", "=", "torch", ".", "mean", "(", "l2_norms", ")", "\n", "return", "avg_distance", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_angles_from_ground_truth": [[168, 184], ["enumerate", "mtp.MTPLoss._angle_between", "angles_from_ground_truth.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._angle_between"], ["", "def", "_compute_angles_from_ground_truth", "(", "self", ",", "target", ":", "torch", ".", "Tensor", ",", "\n", "trajectories", ":", "torch", ".", "Tensor", ")", "->", "List", "[", "Tuple", "[", "float", ",", "int", "]", "]", ":", "\n", "        ", "\"\"\"\n        Compute angle between the target trajectory (ground truth) and the predicted trajectories.\n        :param target: Shape [1, n_timesteps, 2].\n        :param trajectories: Shape [n_modes, n_timesteps, 2].\n        :return: List of angle, index tuples.\n        \"\"\"", "\n", "angles_from_ground_truth", "=", "[", "]", "\n", "for", "mode", ",", "mode_trajectory", "in", "enumerate", "(", "trajectories", ")", ":", "\n", "# For each mode, we compute the angle between the last point of the predicted trajectory for that", "\n", "# mode and the last point of the ground truth trajectory.", "\n", "            ", "angle", "=", "self", ".", "_angle_between", "(", "target", "[", "0", "]", ",", "mode_trajectory", ")", "\n", "\n", "angles_from_ground_truth", ".", "append", "(", "(", "angle", ",", "mode", ")", ")", "\n", "", "return", "angles_from_ground_truth", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_best_mode": [[185, 227], ["sorted", "enumerate", "random.randint", "sorted", "mtp.MTPLoss._compute_ave_l2_norms", "sorted.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_ave_l2_norms"], ["", "def", "_compute_best_mode", "(", "self", ",", "\n", "angles_from_ground_truth", ":", "List", "[", "Tuple", "[", "float", ",", "int", "]", "]", ",", "\n", "target", ":", "torch", ".", "Tensor", ",", "trajectories", ":", "torch", ".", "Tensor", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Finds the index of the best mode given the angles from the ground truth.\n        :param angles_from_ground_truth: List of (angle, mode index) tuples.\n        :param target: Shape [1, n_timesteps, 2]\n        :param trajectories: Shape [n_modes, n_timesteps, 2]\n        :return: Integer index of best mode.\n        \"\"\"", "\n", "\n", "# We first sort the modes based on the angle to the ground truth (ascending order), and keep track of", "\n", "# the index corresponding to the biggest angle that is still smaller than a threshold value.", "\n", "angles_from_ground_truth", "=", "sorted", "(", "angles_from_ground_truth", ")", "\n", "max_angle_below_thresh_idx", "=", "-", "1", "\n", "for", "angle_idx", ",", "(", "angle", ",", "mode", ")", "in", "enumerate", "(", "angles_from_ground_truth", ")", ":", "\n", "            ", "if", "angle", "<=", "self", ".", "angle_threshold", ":", "\n", "                ", "max_angle_below_thresh_idx", "=", "angle_idx", "\n", "", "else", ":", "\n", "                ", "break", "\n", "\n", "# We choose the best mode at random IF there are no modes with an angle less than the threshold.", "\n", "", "", "if", "max_angle_below_thresh_idx", "==", "-", "1", ":", "\n", "            ", "best_mode", "=", "random", ".", "randint", "(", "0", ",", "self", ".", "num_modes", "-", "1", ")", "\n", "\n", "# We choose the best mode to be the one that provides the lowest ave of l2 norms between the", "\n", "# predicted trajectory and the ground truth, taking into account only the modes with an angle", "\n", "# less than the threshold IF there is at least one mode with an angle less than the threshold.", "\n", "", "else", ":", "\n", "# Out of the selected modes above, we choose the final best mode as that which returns the", "\n", "# smallest ave of l2 norms between the predicted and ground truth trajectories.", "\n", "            ", "distances_from_ground_truth", "=", "[", "]", "\n", "\n", "for", "angle", ",", "mode", "in", "angles_from_ground_truth", "[", ":", "max_angle_below_thresh_idx", "+", "1", "]", ":", "\n", "                ", "norm", "=", "self", ".", "_compute_ave_l2_norms", "(", "target", "-", "trajectories", "[", "mode", ",", ":", ",", ":", "]", ")", "\n", "\n", "distances_from_ground_truth", ".", "append", "(", "(", "norm", ",", "mode", ")", ")", "\n", "\n", "", "distances_from_ground_truth", "=", "sorted", "(", "distances_from_ground_truth", ")", "\n", "best_mode", "=", "distances_from_ground_truth", "[", "0", "]", "[", "1", "]", "\n", "\n", "", "return", "best_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss.__call__": [[228, 265], ["torch.Tensor().requires_grad_().to", "mtp.MTPLoss._get_trajectory_and_modes", "range", "torch.mean", "mtp.MTPLoss._compute_angles_from_ground_truth", "mtp.MTPLoss._compute_best_mode", "trajectories[].unsqueeze", "torch.nn.functional.smooth_l1_loss", "modes[].unsqueeze", "torch.tensor", "torch.nn.functional.cross_entropy", "torch.cat", "torch.Tensor().requires_grad_", "loss.unsqueeze", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._get_trajectory_and_modes", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_angles_from_ground_truth", "home.repos.pwc.inspect_result.fpthink_v2b.models.mtp.MTPLoss._compute_best_mode"], ["", "def", "__call__", "(", "self", ",", "predictions", ":", "torch", ".", "Tensor", ",", "targets", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Computes the MTP loss on a batch.\n        The predictions are of shape [batch_size, n_ouput_neurons of last linear layer]\n        and the targets are of shape [batch_size, 1, n_timesteps, 2]\n        :param predictions: Model predictions for batch.\n        :param targets: Targets for batch.\n        :return: zero-dim tensor representing the loss on the batch.\n        \"\"\"", "\n", "\n", "batch_losses", "=", "torch", ".", "Tensor", "(", ")", ".", "requires_grad_", "(", "True", ")", ".", "to", "(", "predictions", ".", "device", ")", "\n", "trajectories", ",", "modes", "=", "self", ".", "_get_trajectory_and_modes", "(", "predictions", ")", "\n", "\n", "for", "batch_idx", "in", "range", "(", "predictions", ".", "shape", "[", "0", "]", ")", ":", "\n", "\n", "            ", "angles", "=", "self", ".", "_compute_angles_from_ground_truth", "(", "target", "=", "targets", "[", "batch_idx", "]", ",", "\n", "trajectories", "=", "trajectories", "[", "batch_idx", "]", ")", "\n", "\n", "best_mode", "=", "self", ".", "_compute_best_mode", "(", "angles", ",", "\n", "target", "=", "targets", "[", "batch_idx", "]", ",", "\n", "trajectories", "=", "trajectories", "[", "batch_idx", "]", ")", "\n", "\n", "best_mode_trajectory", "=", "trajectories", "[", "batch_idx", ",", "best_mode", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "regression_loss", "=", "f", ".", "smooth_l1_loss", "(", "best_mode_trajectory", ",", "targets", "[", "batch_idx", "]", ")", "\n", "\n", "mode_probabilities", "=", "modes", "[", "batch_idx", "]", ".", "unsqueeze", "(", "0", ")", "\n", "best_mode_target", "=", "torch", ".", "tensor", "(", "[", "best_mode", "]", ",", "device", "=", "predictions", ".", "device", ")", "\n", "classification_loss", "=", "f", ".", "cross_entropy", "(", "mode_probabilities", ",", "best_mode_target", ")", "\n", "\n", "loss", "=", "classification_loss", "+", "self", ".", "regression_loss_weight", "*", "regression_loss", "\n", "\n", "batch_losses", "=", "torch", ".", "cat", "(", "(", "batch_losses", ",", "loss", ".", "unsqueeze", "(", "0", ")", ")", ",", "0", ")", "\n", "\n", "", "avg_loss", "=", "torch", ".", "mean", "(", "batch_losses", ")", "\n", "\n", "return", "avg_loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.models.covernet.CoverNet.__init__": [[19, 49], ["torch.nn.Module.__init__", "nuscenes.prediction.models.backbone.calculate_backbone_feature_dim", "torch.nn.ModuleList", "ValueError", "torch.nn.Linear", "isinstance", "zip", "type"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__", "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.calculate_backbone_feature_dim"], ["def", "__init__", "(", "self", ",", "backbone", ":", "nn", ".", "Module", ",", "num_modes", ":", "int", ",", "\n", "n_hidden_layers", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "input_shape", ":", "Tuple", "[", "int", ",", "int", ",", "int", "]", "=", "(", "3", ",", "500", ",", "500", ")", ")", ":", "\n", "        ", "\"\"\"\n        Inits Covernet.\n        :param backbone: Backbone model. Typically ResNetBackBone or MobileNetBackbone\n        :param num_modes: Number of modes in the lattice\n        :param n_hidden_layers: List of dimensions in the fully connected layers after the backbones.\n            If None, set to [4096]\n        :param input_shape: Shape of image input. Used to determine the dimensionality of the feature\n            vector after the CNN backbone.\n        \"\"\"", "\n", "\n", "if", "n_hidden_layers", "and", "not", "isinstance", "(", "n_hidden_layers", ",", "list", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Param n_hidden_layers must be a list. Received {type(n_hidden_layers)}\"", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "not", "n_hidden_layers", ":", "\n", "            ", "n_hidden_layers", "=", "[", "4096", "]", "\n", "\n", "", "self", ".", "backbone", "=", "backbone", "\n", "\n", "backbone_feature_dim", "=", "calculate_backbone_feature_dim", "(", "backbone", ",", "input_shape", ")", "\n", "n_hidden_layers", "=", "[", "backbone_feature_dim", "+", "ASV_DIM", "]", "+", "n_hidden_layers", "+", "[", "num_modes", "]", "\n", "\n", "linear_layers", "=", "[", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", "\n", "for", "in_dim", ",", "out_dim", "in", "zip", "(", "n_hidden_layers", "[", ":", "-", "1", "]", ",", "n_hidden_layers", "[", "1", ":", "]", ")", "]", "\n", "\n", "self", ".", "head", "=", "nn", ".", "ModuleList", "(", "linear_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.covernet.CoverNet.forward": [[50, 66], ["covernet.CoverNet.backbone", "torch.cat", "linear"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image_tensor", ":", "torch", ".", "Tensor", ",", "\n", "agent_state_vector", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        :param image_tensor: Tensor of images in the batch.\n        :param agent_state_vector: Tensor of agent state vectors in the batch\n        :return: Logits for the batch.\n        \"\"\"", "\n", "\n", "backbone_features", "=", "self", ".", "backbone", "(", "image_tensor", ")", "\n", "\n", "logits", "=", "torch", ".", "cat", "(", "[", "backbone_features", ",", "agent_state_vector", "]", ",", "dim", "=", "1", ")", "\n", "\n", "for", "linear", "in", "self", ".", "head", ":", "\n", "            ", "logits", "=", "linear", "(", "logits", ")", "\n", "\n", "", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.covernet.ConstantLatticeLoss.__init__": [[84, 95], ["torch.Tensor"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lattice", ":", "Union", "[", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", ",", "\n", "similarity_function", ":", "Callable", "[", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ",", "int", "]", "=", "mean_pointwise_l2_distance", ")", ":", "\n", "        ", "\"\"\"\n        Inits the loss.\n        :param lattice: numpy array of shape [n_modes, n_timesteps, state_dim]\n        :param similarity_function: Function that computes the index of the closest trajectory in the lattice\n            to the actual ground truth trajectory of the agent.\n        \"\"\"", "\n", "\n", "self", ".", "lattice", "=", "torch", ".", "Tensor", "(", "lattice", ")", "\n", "self", ".", "similarity_func", "=", "similarity_function", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.covernet.ConstantLatticeLoss.__call__": [[96, 121], ["torch.Tensor().requires_grad_().to", "zip", "torch.cat.mean", "covernet.ConstantLatticeLoss.lattice.to", "covernet.ConstantLatticeLoss.similarity_func", "torch.LongTensor().to", "torch.nn.functional.cross_entropy", "torch.cat", "torch.Tensor().requires_grad_", "logit.unsqueeze", "torch.LongTensor", "torch.nn.functional.cross_entropy.unsqueeze", "torch.Tensor"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "batch_logits", ":", "torch", ".", "Tensor", ",", "batch_ground_truth_trajectory", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Computes the loss on a batch.\n        :param batch_logits: Tensor of shape [batch_size, n_modes]. Output of a linear layer since this class\n            uses nn.functional.cross_entropy.\n        :param batch_ground_truth_trajectory: Tensor of shape [batch_size, 1, n_timesteps, state_dim]\n        :return: Average element-wise loss on the batch.\n        \"\"\"", "\n", "\n", "# If using GPU, need to copy the lattice to the GPU if haven't done so already", "\n", "# This ensures we only copy it once", "\n", "if", "self", ".", "lattice", ".", "device", "!=", "batch_logits", ".", "device", ":", "\n", "            ", "self", ".", "lattice", "=", "self", ".", "lattice", ".", "to", "(", "batch_logits", ".", "device", ")", "\n", "\n", "", "batch_losses", "=", "torch", ".", "Tensor", "(", ")", ".", "requires_grad_", "(", "True", ")", ".", "to", "(", "batch_logits", ".", "device", ")", "\n", "\n", "for", "logit", ",", "ground_truth", "in", "zip", "(", "batch_logits", ",", "batch_ground_truth_trajectory", ")", ":", "\n", "\n", "            ", "closest_lattice_trajectory", "=", "self", ".", "similarity_func", "(", "self", ".", "lattice", ",", "ground_truth", ")", "\n", "label", "=", "torch", ".", "LongTensor", "(", "[", "closest_lattice_trajectory", "]", ")", ".", "to", "(", "batch_logits", ".", "device", ")", "\n", "classification_loss", "=", "f", ".", "cross_entropy", "(", "logit", ".", "unsqueeze", "(", "0", ")", ",", "label", ")", "\n", "\n", "batch_losses", "=", "torch", ".", "cat", "(", "(", "batch_losses", ",", "classification_loss", ".", "unsqueeze", "(", "0", ")", ")", ",", "0", ")", "\n", "\n", "", "return", "batch_losses", ".", "mean", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.models.covernet.mean_pointwise_l2_distance": [[68, 77], ["ground_truth.repeat", "torch.pow().sum().sqrt().mean().argmin", "torch.pow().sum().sqrt().mean", "torch.pow().sum().sqrt", "torch.pow().sum", "torch.pow"], "function", ["None"], ["", "", "def", "mean_pointwise_l2_distance", "(", "lattice", ":", "torch", ".", "Tensor", ",", "ground_truth", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Computes the index of the closest trajectory in the lattice as measured by l1 distance.\n    :param lattice: Lattice of pre-generated trajectories. Shape [num_modes, n_timesteps, state_dim]\n    :param ground_truth: Ground truth trajectory of agent. Shape [1, n_timesteps, state_dim].\n    :return: Index of closest mode in the lattice.\n    \"\"\"", "\n", "stacked_ground_truth", "=", "ground_truth", ".", "repeat", "(", "lattice", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ")", "\n", "return", "torch", ".", "pow", "(", "lattice", "-", "stacked_ground_truth", ",", "2", ")", ".", "sum", "(", "dim", "=", "2", ")", ".", "sqrt", "(", ")", ".", "mean", "(", "dim", "=", "1", ")", ".", "argmin", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.physics.Baseline.__init__": [[136, 146], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "sec_from_now", ":", "float", ",", "helper", ":", "PredictHelper", ")", ":", "\n", "        ", "\"\"\"\n        Inits Baseline.\n        :param sec_from_now: How many seconds into the future to make the prediction.\n        :param helper: Instance of PredictHelper.\n        \"\"\"", "\n", "assert", "sec_from_now", "%", "0.5", "==", "0", ",", "f\"Parameter sec from now must be divisible by 0.5. Received {sec_from_now}.\"", "\n", "self", ".", "helper", "=", "helper", "\n", "self", ".", "sec_from_now", "=", "sec_from_now", "\n", "self", ".", "sampled_at", "=", "2", "# 2 Hz between annotations.", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.physics.Baseline.__call__": [[147, 150], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "token", ":", "str", ")", "->", "Prediction", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.physics.ConstantVelocityHeading.__call__": [[155, 166], ["token.split", "physics._kinematics_from_tokens", "physics._constant_velocity_heading_from_kinematics", "nuscenes.eval.prediction.data_classes.Prediction", "numpy.expand_dims", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.physics._kinematics_from_tokens", "home.repos.pwc.inspect_result.fpthink_v2b.models.physics._constant_velocity_heading_from_kinematics"], ["def", "__call__", "(", "self", ",", "token", ":", "str", ")", "->", "Prediction", ":", "\n", "        ", "\"\"\"\n        Makes prediction.\n        :param token: string of format {instance_token}_{sample_token}.\n        \"\"\"", "\n", "instance", ",", "sample", "=", "token", ".", "split", "(", "\"_\"", ")", "\n", "kinematics", "=", "_kinematics_from_tokens", "(", "self", ".", "helper", ",", "instance", ",", "sample", ")", "\n", "cv_heading", "=", "_constant_velocity_heading_from_kinematics", "(", "kinematics", ",", "self", ".", "sec_from_now", ",", "self", ".", "sampled_at", ")", "\n", "\n", "# Need the prediction to have 2d.", "\n", "return", "Prediction", "(", "instance", ",", "sample", ",", "np", ".", "expand_dims", "(", "cv_heading", ",", "0", ")", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.physics.PhysicsOracle.__call__": [[171, 200], ["token.split", "physics._kinematics_from_tokens", "physics.PhysicsOracle.helper.get_future_for_agent", "nuscenes.eval.prediction.data_classes.Prediction", "int", "path_fun", "sorted", "numpy.expand_dims", "numpy.array", "numpy.linalg.norm", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.models.physics._kinematics_from_tokens", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_future_for_agent"], ["def", "__call__", "(", "self", ",", "token", ")", "->", "Prediction", ":", "\n", "        ", "\"\"\"\n        Makes prediction.\n        :param token: string of format {instance_token}_{sample_token}.\n        \"\"\"", "\n", "instance", ",", "sample", "=", "token", ".", "split", "(", "\"_\"", ")", "\n", "kinematics", "=", "_kinematics_from_tokens", "(", "self", ".", "helper", ",", "instance", ",", "sample", ")", "\n", "ground_truth", "=", "self", ".", "helper", ".", "get_future_for_agent", "(", "instance", ",", "sample", ",", "self", ".", "sec_from_now", ",", "in_agent_frame", "=", "False", ")", "\n", "\n", "assert", "ground_truth", ".", "shape", "[", "0", "]", "==", "int", "(", "self", ".", "sec_from_now", "*", "self", ".", "sampled_at", ")", ",", "(", "\"Ground truth does not correspond \"", "\n", "f\"to {self.sec_from_now} seconds.\"", ")", "\n", "\n", "path_funs", "=", "[", "\n", "_constant_acceleration_and_heading", ",", "\n", "_constant_magnitude_accel_and_yaw_rate", ",", "\n", "_constant_speed_and_yaw_rate", ",", "\n", "_constant_velocity_heading_from_kinematics", "\n", "]", "\n", "\n", "paths", "=", "[", "path_fun", "(", "kinematics", ",", "self", ".", "sec_from_now", ",", "self", ".", "sampled_at", ")", "for", "path_fun", "in", "path_funs", "]", "\n", "\n", "# Select the one with the least l2 error, averaged (or equivalently, summed) over all", "\n", "# points of the path.  This is (proportional to) the Frobenius norm of the difference", "\n", "# between the path (as an n x 2 matrix) and the ground truth.", "\n", "oracle", "=", "sorted", "(", "paths", ",", "\n", "key", "=", "lambda", "path", ":", "np", ".", "linalg", ".", "norm", "(", "np", ".", "array", "(", "path", ")", "-", "ground_truth", ",", "ord", "=", "\"fro\"", ")", ")", "[", "0", "]", "\n", "\n", "# Need the prediction to have 2d.", "\n", "return", "Prediction", "(", "instance", ",", "sample", ",", "np", ".", "expand_dims", "(", "oracle", ",", "0", ")", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.models.physics._kinematics_from_tokens": [[16, 46], ["helper.get_sample_annotation", "nuscenes.eval.common.utils.quaternion_yaw", "helper.get_velocity_for_agent", "helper.get_acceleration_for_agent", "helper.get_heading_change_rate_for_agent", "numpy.isnan", "numpy.isnan", "numpy.isnan", "pyquaternion.Quaternion", "numpy.cos", "numpy.sin"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_sample_annotation", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_velocity_for_agent", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_acceleration_for_agent", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.helper.PredictHelper.get_heading_change_rate_for_agent"], ["def", "_kinematics_from_tokens", "(", "helper", ":", "PredictHelper", ",", "instance", ":", "str", ",", "sample", ":", "str", ")", "->", "KinematicsData", ":", "\n", "    ", "\"\"\"\n    Returns the 2D position, velocity and acceleration vectors from the given track records,\n    along with the speed, yaw rate, (scalar) acceleration (magnitude), and heading.\n    :param helper: Instance of PredictHelper.\n    :instance: Token of instance.\n    :sample: Token of sample.\n    :return: KinematicsData.\n    \"\"\"", "\n", "\n", "annotation", "=", "helper", ".", "get_sample_annotation", "(", "instance", ",", "sample", ")", "\n", "x", ",", "y", ",", "_", "=", "annotation", "[", "'translation'", "]", "\n", "yaw", "=", "quaternion_yaw", "(", "Quaternion", "(", "annotation", "[", "'rotation'", "]", ")", ")", "\n", "\n", "velocity", "=", "helper", ".", "get_velocity_for_agent", "(", "instance", ",", "sample", ")", "\n", "acceleration", "=", "helper", ".", "get_acceleration_for_agent", "(", "instance", ",", "sample", ")", "\n", "yaw_rate", "=", "helper", ".", "get_heading_change_rate_for_agent", "(", "instance", ",", "sample", ")", "\n", "\n", "if", "np", ".", "isnan", "(", "velocity", ")", ":", "\n", "        ", "velocity", "=", "0.0", "\n", "", "if", "np", ".", "isnan", "(", "acceleration", ")", ":", "\n", "        ", "acceleration", "=", "0.0", "\n", "", "if", "np", ".", "isnan", "(", "yaw_rate", ")", ":", "\n", "        ", "yaw_rate", "=", "0.0", "\n", "\n", "", "hx", ",", "hy", "=", "np", ".", "cos", "(", "yaw", ")", ",", "np", ".", "sin", "(", "yaw", ")", "\n", "vx", ",", "vy", "=", "velocity", "*", "hx", ",", "velocity", "*", "hy", "\n", "ax", ",", "ay", "=", "acceleration", "*", "hx", ",", "acceleration", "*", "hy", "\n", "\n", "return", "x", ",", "y", ",", "vx", ",", "vy", ",", "ax", ",", "ay", ",", "velocity", ",", "yaw_rate", ",", "acceleration", ",", "yaw", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.physics._constant_velocity_heading_from_kinematics": [[48, 64], ["numpy.arange", "numpy.array", "preds.append"], "function", ["None"], ["", "def", "_constant_velocity_heading_from_kinematics", "(", "kinematics_data", ":", "KinematicsData", ",", "\n", "sec_from_now", ":", "float", ",", "\n", "sampled_at", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Computes a constant velocity baseline for given kinematics data, time window\n    and frequency.\n    :param kinematics_data: KinematicsData for agent.\n    :param sec_from_now: How many future seconds to use.\n    :param sampled_at: Number of predictions to make per second.\n    \"\"\"", "\n", "x", ",", "y", ",", "vx", ",", "vy", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", "=", "kinematics_data", "\n", "preds", "=", "[", "]", "\n", "time_step", "=", "1.0", "/", "sampled_at", "\n", "for", "time", "in", "np", ".", "arange", "(", "time_step", ",", "sec_from_now", "+", "time_step", ",", "time_step", ")", ":", "\n", "        ", "preds", ".", "append", "(", "(", "x", "+", "time", "*", "vx", ",", "y", "+", "time", "*", "vy", ")", ")", "\n", "", "return", "np", ".", "array", "(", "preds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.physics._constant_acceleration_and_heading": [[66, 84], ["numpy.arange", "numpy.array", "preds.append"], "function", ["None"], ["", "def", "_constant_acceleration_and_heading", "(", "kinematics_data", ":", "KinematicsData", ",", "\n", "sec_from_now", ":", "float", ",", "sampled_at", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Computes a baseline prediction for the given time window and frequency, under\n    the assumption that the acceleration and heading are constant.\n    :param kinematics_data: KinematicsData for agent.\n    :param sec_from_now: How many future seconds to use.\n    :param sampled_at: Number of predictions to make per second.\n    \"\"\"", "\n", "x", ",", "y", ",", "vx", ",", "vy", ",", "ax", ",", "ay", ",", "_", ",", "_", ",", "_", ",", "_", "=", "kinematics_data", "\n", "\n", "preds", "=", "[", "]", "\n", "time_step", "=", "1.0", "/", "sampled_at", "\n", "for", "time", "in", "np", ".", "arange", "(", "time_step", ",", "sec_from_now", "+", "time_step", ",", "time_step", ")", ":", "\n", "        ", "half_time_squared", "=", "0.5", "*", "time", "*", "time", "\n", "preds", ".", "append", "(", "(", "x", "+", "time", "*", "vx", "+", "half_time_squared", "*", "ax", ",", "\n", "y", "+", "time", "*", "vy", "+", "half_time_squared", "*", "ay", ")", ")", "\n", "", "return", "np", ".", "array", "(", "preds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.physics._constant_speed_and_yaw_rate": [[86, 107], ["numpy.arange", "numpy.array", "preds.append", "numpy.cos", "numpy.sin"], "function", ["None"], ["", "def", "_constant_speed_and_yaw_rate", "(", "kinematics_data", ":", "KinematicsData", ",", "\n", "sec_from_now", ":", "float", ",", "sampled_at", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Computes a baseline prediction for the given time window and frequency, under\n    the assumption that the (scalar) speed and yaw rate are constant.\n    :param kinematics_data: KinematicsData for agent.\n    :param sec_from_now: How many future seconds to use.\n    :param sampled_at: Number of predictions to make per second.\n    \"\"\"", "\n", "x", ",", "y", ",", "vx", ",", "vy", ",", "_", ",", "_", ",", "speed", ",", "yaw_rate", ",", "_", ",", "yaw", "=", "kinematics_data", "\n", "\n", "preds", "=", "[", "]", "\n", "time_step", "=", "1.0", "/", "sampled_at", "\n", "distance_step", "=", "time_step", "*", "speed", "\n", "yaw_step", "=", "time_step", "*", "yaw_rate", "\n", "for", "_", "in", "np", ".", "arange", "(", "time_step", ",", "sec_from_now", "+", "time_step", ",", "time_step", ")", ":", "\n", "        ", "x", "+=", "distance_step", "*", "np", ".", "cos", "(", "yaw", ")", "\n", "y", "+=", "distance_step", "*", "np", ".", "sin", "(", "yaw", ")", "\n", "preds", ".", "append", "(", "(", "x", ",", "y", ")", ")", "\n", "yaw", "+=", "yaw_step", "\n", "", "return", "np", ".", "array", "(", "preds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.physics._constant_magnitude_accel_and_yaw_rate": [[109, 132], ["numpy.arange", "numpy.array", "preds.append", "numpy.cos", "numpy.sin"], "function", ["None"], ["", "def", "_constant_magnitude_accel_and_yaw_rate", "(", "kinematics_data", ":", "KinematicsData", ",", "\n", "sec_from_now", ":", "float", ",", "sampled_at", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Computes a baseline prediction for the given time window and frequency, under\n    the assumption that the rates of change of speed and yaw are constant.\n    :param kinematics_data: KinematicsData for agent.\n    :param sec_from_now: How many future seconds to use.\n    :param sampled_at: Number of predictions to make per second.\n    \"\"\"", "\n", "x", ",", "y", ",", "vx", ",", "vy", ",", "_", ",", "_", ",", "speed", ",", "yaw_rate", ",", "accel", ",", "yaw", "=", "kinematics_data", "\n", "\n", "preds", "=", "[", "]", "\n", "time_step", "=", "1.0", "/", "sampled_at", "\n", "speed_step", "=", "time_step", "*", "accel", "\n", "yaw_step", "=", "time_step", "*", "yaw_rate", "\n", "for", "_", "in", "np", ".", "arange", "(", "time_step", ",", "sec_from_now", "+", "time_step", ",", "time_step", ")", ":", "\n", "        ", "distance_step", "=", "time_step", "*", "speed", "\n", "x", "+=", "distance_step", "*", "np", ".", "cos", "(", "yaw", ")", "\n", "y", "+=", "distance_step", "*", "np", ".", "sin", "(", "yaw", ")", "\n", "preds", ".", "append", "(", "(", "x", ",", "y", ")", ")", "\n", "speed", "+=", "speed_step", "\n", "yaw", "+=", "yaw_step", "\n", "", "return", "np", ".", "array", "(", "preds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.ResNetBackbone.__init__": [[40, 52], ["torch.nn.Module.__init__", "backbone.trim_network_at_index", "ValueError", "list", "RESNET_VERSION_TO_MODEL.keys"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__", "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.trim_network_at_index"], ["def", "__init__", "(", "self", ",", "version", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Inits ResNetBackbone\n        :param version: resnet version to use.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "version", "not", "in", "RESNET_VERSION_TO_MODEL", ":", "\n", "            ", "raise", "ValueError", "(", "f'Parameter version must be one of {list(RESNET_VERSION_TO_MODEL.keys())}'", "\n", "f'. Received {version}.'", ")", "\n", "\n", "", "self", ".", "backbone", "=", "trim_network_at_index", "(", "RESNET_VERSION_TO_MODEL", "[", "version", "]", "(", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.ResNetBackbone.forward": [[53, 62], ["backbone.ResNetBackbone.backbone", "torch.flatten"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_tensor", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Outputs features after last convolution.\n        :param input_tensor:  Shape [batch_size, n_channels, length, width].\n        :return: Tensor of shape [batch_size, n_convolution_filters]. For resnet50,\n            the shape is [batch_size, 2048].\n        \"\"\"", "\n", "backbone_features", "=", "self", ".", "backbone", "(", "input_tensor", ")", "\n", "return", "torch", ".", "flatten", "(", "backbone_features", ",", "start_dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.MobileNetBackbone.__init__": [[71, 82], ["torch.nn.Module.__init__", "backbone.trim_network_at_index", "NotImplementedError", "torchvision.models.mobilenet_v2"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__", "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.trim_network_at_index"], ["def", "__init__", "(", "self", ",", "version", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Inits MobileNetBackbone.\n        :param version: mobilenet version to use.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "version", "!=", "'mobilenet_v2'", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f'Only mobilenet_v2 has been implemented. Received {version}.'", ")", "\n", "\n", "", "self", ".", "backbone", "=", "trim_network_at_index", "(", "mobilenet_v2", "(", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.MobileNetBackbone.forward": [[83, 92], ["backbone.MobileNetBackbone.backbone", "backbone.MobileNetBackbone.mean"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_tensor", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Outputs features after last convolution.\n        :param input_tensor:  Shape [batch_size, n_channels, length, width].\n        :return: Tensor of shape [batch_size, n_convolution_filters]. For mobilenet_v2,\n            the shape is [batch_size, 1280].\n        \"\"\"", "\n", "backbone_features", "=", "self", ".", "backbone", "(", "input_tensor", ")", "\n", "return", "backbone_features", ".", "mean", "(", "[", "2", ",", "3", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.trim_network_at_index": [[11, 19], ["torch.nn.Sequential", "list", "network.children"], "function", ["None"], ["def", "trim_network_at_index", "(", "network", ":", "nn", ".", "Module", ",", "index", ":", "int", "=", "-", "1", ")", "->", "nn", ".", "Module", ":", "\n", "    ", "\"\"\"\n    Returns a new network with all layers up to index from the back.\n    :param network: Module to trim.\n    :param index: Where to trim the network. Counted from the last layer.\n    \"\"\"", "\n", "assert", "index", "<", "0", ",", "f\"Param index must be negative. Received {index}.\"", "\n", "return", "nn", ".", "Sequential", "(", "*", "list", "(", "network", ".", "children", "(", ")", ")", "[", ":", "index", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.models.backbone.calculate_backbone_feature_dim": [[21, 26], ["torch.ones", "backbone.forward"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.functional.voxelization.fAvgVoxelization.forward"], ["", "def", "calculate_backbone_feature_dim", "(", "backbone", ",", "input_shape", ":", "Tuple", "[", "int", ",", "int", ",", "int", "]", ")", "->", "int", ":", "\n", "    ", "\"\"\" Helper to calculate the shape of the fully-connected regression layer. \"\"\"", "\n", "tensor", "=", "torch", ".", "ones", "(", "1", ",", "*", "input_shape", ")", "\n", "output_feat", "=", "backbone", ".", "forward", "(", "tensor", ")", "\n", "return", "output_feat", ".", "shape", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.accumulate": [[13, 166], ["len", "set", "numpy.cumsum().astype", "numpy.cumsum().astype", "numpy.array", "numpy.linspace", "numpy.interp", "numpy.interp", "match_data.keys", "nuscenes.eval.detection.data_classes.DetectionMetricData", "print", "nuscenes.eval.detection.data_classes.DetectionMetricData.no_predictions", "print", "enumerate", "len", "nuscenes.eval.detection.data_classes.DetectionMetricData.no_predictions", "float", "set.add", "np.cumsum().astype.append", "np.cumsum().astype.append", "np.interp.append", "match_data[].append", "match_data[].append", "match_data[].append", "match_data[].append", "match_data[].append", "match_data[].append", "np.cumsum().astype.append", "np.cumsum().astype.append", "np.interp.append", "numpy.cumsum", "numpy.cumsum", "nuscenes.eval.common.utils.cummean", "len", "len", "len", "len", "len", "sorted", "dist_fcn", "nuscenes.eval.common.utils.center_distance", "nuscenes.eval.common.utils.velocity_l2", "nuscenes.eval.common.utils.yaw_diff", "numpy.array", "numpy.interp", "nuscenes.eval.common.utils.scale_iou", "nuscenes.eval.common.utils.attr_acc", "enumerate"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.no_predictions", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.no_predictions", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.cummean", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.center_distance", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.velocity_l2", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.yaw_diff", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.scale_iou", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.attr_acc"], ["def", "accumulate", "(", "gt_boxes", ":", "EvalBoxes", ",", "\n", "pred_boxes", ":", "EvalBoxes", ",", "\n", "class_name", ":", "str", ",", "\n", "dist_fcn", ":", "Callable", ",", "\n", "dist_th", ":", "float", ",", "\n", "verbose", ":", "bool", "=", "False", ")", "->", "DetectionMetricData", ":", "\n", "    ", "\"\"\"\n    Average Precision over predefined different recall thresholds for a single distance threshold.\n    The recall/conf thresholds and other raw metrics will be used in secondary metrics.\n    :param gt_boxes: Maps every sample_token to a list of its sample_annotations.\n    :param pred_boxes: Maps every sample_token to a list of its sample_results.\n    :param class_name: Class to compute AP on.\n    :param dist_fcn: Distance function used to match detections and ground truths.\n    :param dist_th: Distance threshold for a match.\n    :param verbose: If true, print debug messages.\n    :return: (average_prec, metrics). The average precision value and raw data for a number of metrics.\n    \"\"\"", "\n", "# ---------------------------------------------", "\n", "# Organize input and initialize accumulators.", "\n", "# ---------------------------------------------", "\n", "\n", "# Count the positives.", "\n", "npos", "=", "len", "(", "[", "1", "for", "gt_box", "in", "gt_boxes", ".", "all", "if", "gt_box", ".", "detection_name", "==", "class_name", "]", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Found {} GT of class {} out of {} total across {} samples.\"", ".", "\n", "format", "(", "npos", ",", "class_name", ",", "len", "(", "gt_boxes", ".", "all", ")", ",", "len", "(", "gt_boxes", ".", "sample_tokens", ")", ")", ")", "\n", "\n", "# For missing classes in the GT, return a data structure corresponding to no predictions.", "\n", "", "if", "npos", "==", "0", ":", "\n", "        ", "return", "DetectionMetricData", ".", "no_predictions", "(", ")", "\n", "\n", "# Organize the predictions in a single list.", "\n", "", "pred_boxes_list", "=", "[", "box", "for", "box", "in", "pred_boxes", ".", "all", "if", "box", ".", "detection_name", "==", "class_name", "]", "\n", "pred_confs", "=", "[", "box", ".", "detection_score", "for", "box", "in", "pred_boxes_list", "]", "\n", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Found {} PRED of class {} out of {} total across {} samples.\"", ".", "\n", "format", "(", "len", "(", "pred_confs", ")", ",", "class_name", ",", "len", "(", "pred_boxes", ".", "all", ")", ",", "len", "(", "pred_boxes", ".", "sample_tokens", ")", ")", ")", "\n", "\n", "# Sort by confidence.", "\n", "", "sortind", "=", "[", "i", "for", "(", "v", ",", "i", ")", "in", "sorted", "(", "(", "v", ",", "i", ")", "for", "(", "i", ",", "v", ")", "in", "enumerate", "(", "pred_confs", ")", ")", "]", "[", ":", ":", "-", "1", "]", "\n", "\n", "# Do the actual matching.", "\n", "tp", "=", "[", "]", "# Accumulator of true positives.", "\n", "fp", "=", "[", "]", "# Accumulator of false positives.", "\n", "conf", "=", "[", "]", "# Accumulator of confidences.", "\n", "\n", "# match_data holds the extra metrics we calculate for each match.", "\n", "match_data", "=", "{", "'trans_err'", ":", "[", "]", ",", "\n", "'vel_err'", ":", "[", "]", ",", "\n", "'scale_err'", ":", "[", "]", ",", "\n", "'orient_err'", ":", "[", "]", ",", "\n", "'attr_err'", ":", "[", "]", ",", "\n", "'conf'", ":", "[", "]", "}", "\n", "\n", "# ---------------------------------------------", "\n", "# Match and accumulate match data.", "\n", "# ---------------------------------------------", "\n", "\n", "taken", "=", "set", "(", ")", "# Initially no gt bounding box is matched.", "\n", "for", "ind", "in", "sortind", ":", "\n", "        ", "pred_box", "=", "pred_boxes_list", "[", "ind", "]", "\n", "min_dist", "=", "np", ".", "inf", "\n", "match_gt_idx", "=", "None", "\n", "\n", "for", "gt_idx", ",", "gt_box", "in", "enumerate", "(", "gt_boxes", "[", "pred_box", ".", "sample_token", "]", ")", ":", "\n", "\n", "# Find closest match among ground truth boxes", "\n", "            ", "if", "gt_box", ".", "detection_name", "==", "class_name", "and", "not", "(", "pred_box", ".", "sample_token", ",", "gt_idx", ")", "in", "taken", ":", "\n", "                ", "this_distance", "=", "dist_fcn", "(", "gt_box", ",", "pred_box", ")", "\n", "if", "this_distance", "<", "min_dist", ":", "\n", "                    ", "min_dist", "=", "this_distance", "\n", "match_gt_idx", "=", "gt_idx", "\n", "\n", "# If the closest match is close enough according to threshold we have a match!", "\n", "", "", "", "is_match", "=", "min_dist", "<", "dist_th", "\n", "\n", "if", "is_match", ":", "\n", "            ", "taken", ".", "add", "(", "(", "pred_box", ".", "sample_token", ",", "match_gt_idx", ")", ")", "\n", "\n", "#  Update tp, fp and confs.", "\n", "tp", ".", "append", "(", "1", ")", "\n", "fp", ".", "append", "(", "0", ")", "\n", "conf", ".", "append", "(", "pred_box", ".", "detection_score", ")", "\n", "\n", "# Since it is a match, update match data also.", "\n", "gt_box_match", "=", "gt_boxes", "[", "pred_box", ".", "sample_token", "]", "[", "match_gt_idx", "]", "\n", "\n", "match_data", "[", "'trans_err'", "]", ".", "append", "(", "center_distance", "(", "gt_box_match", ",", "pred_box", ")", ")", "\n", "match_data", "[", "'vel_err'", "]", ".", "append", "(", "velocity_l2", "(", "gt_box_match", ",", "pred_box", ")", ")", "\n", "match_data", "[", "'scale_err'", "]", ".", "append", "(", "1", "-", "scale_iou", "(", "gt_box_match", ",", "pred_box", ")", ")", "\n", "\n", "# Barrier orientation is only determined up to 180 degree. (For cones orientation is discarded later)", "\n", "period", "=", "np", ".", "pi", "if", "class_name", "==", "'barrier'", "else", "2", "*", "np", ".", "pi", "\n", "match_data", "[", "'orient_err'", "]", ".", "append", "(", "yaw_diff", "(", "gt_box_match", ",", "pred_box", ",", "period", "=", "period", ")", ")", "\n", "\n", "match_data", "[", "'attr_err'", "]", ".", "append", "(", "1", "-", "attr_acc", "(", "gt_box_match", ",", "pred_box", ")", ")", "\n", "match_data", "[", "'conf'", "]", ".", "append", "(", "pred_box", ".", "detection_score", ")", "\n", "\n", "", "else", ":", "\n", "# No match. Mark this as a false positive.", "\n", "            ", "tp", ".", "append", "(", "0", ")", "\n", "fp", ".", "append", "(", "1", ")", "\n", "conf", ".", "append", "(", "pred_box", ".", "detection_score", ")", "\n", "\n", "# Check if we have any matches. If not, just return a \"no predictions\" array.", "\n", "", "", "if", "len", "(", "match_data", "[", "'trans_err'", "]", ")", "==", "0", ":", "\n", "        ", "return", "DetectionMetricData", ".", "no_predictions", "(", ")", "\n", "\n", "# ---------------------------------------------", "\n", "# Calculate and interpolate precision and recall", "\n", "# ---------------------------------------------", "\n", "\n", "# Accumulate.", "\n", "", "tp", "=", "np", ".", "cumsum", "(", "tp", ")", ".", "astype", "(", "float", ")", "\n", "fp", "=", "np", ".", "cumsum", "(", "fp", ")", ".", "astype", "(", "float", ")", "\n", "conf", "=", "np", ".", "array", "(", "conf", ")", "\n", "\n", "# Calculate precision and recall.", "\n", "prec", "=", "tp", "/", "(", "fp", "+", "tp", ")", "\n", "rec", "=", "tp", "/", "float", "(", "npos", ")", "\n", "\n", "rec_interp", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "DetectionMetricData", ".", "nelem", ")", "# 101 steps, from 0% to 100% recall.", "\n", "prec", "=", "np", ".", "interp", "(", "rec_interp", ",", "rec", ",", "prec", ",", "right", "=", "0", ")", "\n", "conf", "=", "np", ".", "interp", "(", "rec_interp", ",", "rec", ",", "conf", ",", "right", "=", "0", ")", "\n", "rec", "=", "rec_interp", "\n", "\n", "# ---------------------------------------------", "\n", "# Re-sample the match-data to match, prec, recall and conf.", "\n", "# ---------------------------------------------", "\n", "\n", "for", "key", "in", "match_data", ".", "keys", "(", ")", ":", "\n", "        ", "if", "key", "==", "\"conf\"", ":", "\n", "            ", "continue", "# Confidence is used as reference to align with fp and tp. So skip in this step.", "\n", "\n", "", "else", ":", "\n", "# For each match_data, we first calculate the accumulated mean.", "\n", "            ", "tmp", "=", "cummean", "(", "np", ".", "array", "(", "match_data", "[", "key", "]", ")", ")", "\n", "\n", "# Then interpolate based on the confidences. (Note reversing since np.interp needs increasing arrays)", "\n", "match_data", "[", "key", "]", "=", "np", ".", "interp", "(", "conf", "[", ":", ":", "-", "1", "]", ",", "match_data", "[", "'conf'", "]", "[", ":", ":", "-", "1", "]", ",", "tmp", "[", ":", ":", "-", "1", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "# ---------------------------------------------", "\n", "# Done. Instantiate MetricData and return", "\n", "# ---------------------------------------------", "\n", "", "", "return", "DetectionMetricData", "(", "recall", "=", "rec", ",", "\n", "precision", "=", "prec", ",", "\n", "confidence", "=", "conf", ",", "\n", "trans_err", "=", "match_data", "[", "'trans_err'", "]", ",", "\n", "vel_err", "=", "match_data", "[", "'vel_err'", "]", ",", "\n", "scale_err", "=", "match_data", "[", "'scale_err'", "]", ",", "\n", "orient_err", "=", "match_data", "[", "'orient_err'", "]", ",", "\n", "attr_err", "=", "match_data", "[", "'attr_err'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.calc_ap": [[168, 179], ["numpy.copy", "float", "numpy.mean", "round"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["", "def", "calc_ap", "(", "md", ":", "DetectionMetricData", ",", "min_recall", ":", "float", ",", "min_precision", ":", "float", ")", "->", "float", ":", "\n", "    ", "\"\"\" Calculated average precision. \"\"\"", "\n", "\n", "assert", "0", "<=", "min_precision", "<", "1", "\n", "assert", "0", "<=", "min_recall", "<=", "1", "\n", "\n", "prec", "=", "np", ".", "copy", "(", "md", ".", "precision", ")", "\n", "prec", "=", "prec", "[", "round", "(", "100", "*", "min_recall", ")", "+", "1", ":", "]", "# Clip low recalls. +1 to exclude the min recall bin.", "\n", "prec", "-=", "min_precision", "# Clip low precision", "\n", "prec", "[", "prec", "<", "0", "]", "=", "0", "\n", "return", "float", "(", "np", ".", "mean", "(", "prec", ")", ")", "/", "(", "1.0", "-", "min_precision", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.calc_tp": [[181, 190], ["round", "float", "numpy.mean", "getattr"], "function", ["None"], ["", "def", "calc_tp", "(", "md", ":", "DetectionMetricData", ",", "min_recall", ":", "float", ",", "metric_name", ":", "str", ")", "->", "float", ":", "\n", "    ", "\"\"\" Calculates true positive errors. \"\"\"", "\n", "\n", "first_ind", "=", "round", "(", "100", "*", "min_recall", ")", "+", "1", "# +1 to exclude the error at min recall.", "\n", "last_ind", "=", "md", ".", "max_recall_ind", "# First instance of confidence = 0 is index of max achieved recall.", "\n", "if", "last_ind", "<", "first_ind", ":", "\n", "        ", "return", "1.0", "# Assign 1 here. If this happens for all classes, the score for that TP metric will be 0.", "\n", "", "else", ":", "\n", "        ", "return", "float", "(", "np", ".", "mean", "(", "getattr", "(", "md", ",", "metric_name", ")", "[", "first_ind", ":", "last_ind", "+", "1", "]", ")", ")", "# +1 to include error at max recall.", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionConfig.__init__": [[17, 40], ["data_classes.DetectionConfig.class_range.keys", "set", "set", "class_range.keys"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["from", "lidarseg", ".", "lidarseg_utils", "import", "colormap_to_colors", ",", "create_lidarseg_legend", "\n", "from", "utils", ".", "data_io", "import", "load_bin_file", "\n", "from", "utils", ".", "geometry_utils", "import", "view_points", ",", "transform_matrix", "\n", "\n", "\n", "class", "PointCloud", "(", "ABC", ")", ":", "\n", "    ", "\"\"\"\n    Abstract class for manipulating and viewing point clouds.\n    Every point cloud (lidar and radar) consists of points where:\n    - Dimensions 0, 1, 2 represent x, y, z coordinates.\n        These are modified when the point cloud is rotated or translated.\n    - All other dimensions are optional. Hence these have to be manually modified if the reference frame changes.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "points", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a point cloud and check it has the correct dimensions.\n        :param points: <np.float: d, n>. d-dimensional input point cloud matrix.\n        \"\"\"", "\n", "assert", "points", ".", "shape", "[", "0", "]", "==", "self", ".", "nbr_dims", "(", ")", ",", "'Error: Pointcloud points must have format: %d x n'", "%", "self", ".", "nbr_dims", "(", ")", "\n", "self", ".", "points", "=", "points", "\n", "\n", "", "@", "staticmethod", "\n", "@", "abstractmethod", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionConfig.__eq__": [[41, 46], ["data_classes.DetectionConfig.serialize().keys", "data_classes.DetectionConfig.serialize", "numpy.array_equal", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns the number of dimensions.\n        :return: Number of dimensions.\n        \"\"\"", "\n", "pass", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionConfig.serialize": [[47, 58], ["None"], "methods", ["None"], ["\n", "", "@", "classmethod", "\n", "@", "abstractmethod", "\n", "def", "from_file", "(", "cls", ",", "file_name", ":", "str", ")", "->", "'PointCloud'", ":", "\n", "        ", "\"\"\"\n        Loads point cloud from disk.\n        :param file_name: Path of the pointcloud file on disk.\n        :return: PointCloud instance.\n        \"\"\"", "\n", "pass", "\n", "\n", "", "@", "classmethod", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionConfig.deserialize": [[60, 71], ["cls"], "methods", ["None"], ["nusc", ":", "'NuScenes'", ",", "\n", "sample_rec", ":", "Dict", ",", "\n", "chan", ":", "str", ",", "\n", "ref_chan", ":", "str", ",", "\n", "nsweeps", ":", "int", "=", "5", ",", "\n", "min_distance", ":", "float", "=", "1.0", ")", "->", "Tuple", "[", "'PointCloud'", ",", "np", ".", "ndarray", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionConfig.dist_fcn_callable": [[72, 79], ["Exception"], "methods", ["None"], ["\n", "# Init.", "\n", "points", "=", "np", ".", "zeros", "(", "(", "cls", ".", "nbr_dims", "(", ")", ",", "0", ")", ",", "dtype", "=", "np", ".", "float32", "if", "cls", "==", "LidarPointCloud", "else", "np", ".", "float64", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricData.__init__": [[86, 119], ["all", "all", "len", "len", "len", "len", "len", "len", "len", "len", "sorted", "sorted"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["ref_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "ref_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "ref_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "ref_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "ref_time", "=", "1e-6", "*", "ref_sd_rec", "[", "'timestamp'", "]", "\n", "\n", "# Homogeneous transform from ego car frame to reference frame.", "\n", "ref_from_car", "=", "transform_matrix", "(", "ref_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_cs_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "True", ")", "\n", "\n", "# Homogeneous transformation matrix from global to _current_ ego car frame.", "\n", "car_from_global", "=", "transform_matrix", "(", "ref_pose_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_pose_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "True", ")", "\n", "\n", "# Aggregate current and previous sweeps.", "\n", "sample_data_token", "=", "sample_rec", "[", "'data'", "]", "[", "chan", "]", "\n", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "for", "_", "in", "range", "(", "nsweeps", ")", ":", "\n", "# Load up the pointcloud and remove points close to the sensor.", "\n", "            ", "current_pc", "=", "cls", ".", "from_file", "(", "osp", ".", "join", "(", "nusc", ".", "dataroot", ",", "current_sd_rec", "[", "'filename'", "]", ")", ")", "\n", "current_pc", ".", "remove_close", "(", "min_distance", ")", "\n", "\n", "# Get past pose.", "\n", "current_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "current_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "global_from_car", "=", "transform_matrix", "(", "current_pose_rec", "[", "'translation'", "]", ",", "\n", "Quaternion", "(", "current_pose_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "False", ")", "\n", "\n", "# Homogeneous transformation matrix from sensor coordinate frame to ego car frame.", "\n", "current_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "current_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "car_from_current", "=", "transform_matrix", "(", "current_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "current_cs_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "False", ")", "\n", "\n", "# Fuse four transformation matrices into one and perform transform.", "\n", "trans_matrix", "=", "reduce", "(", "np", ".", "dot", ",", "[", "ref_from_car", ",", "car_from_global", ",", "global_from_car", ",", "car_from_current", "]", ")", "\n", "current_pc", ".", "transform", "(", "trans_matrix", ")", "\n", "\n", "# Add time vector which can be used as a temporal feature.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricData.__eq__": [[120, 125], ["data_classes.DetectionMetricData.serialize().keys", "data_classes.DetectionMetricData.serialize", "numpy.array_equal", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["time_lag", "=", "ref_time", "-", "1e-6", "*", "current_sd_rec", "[", "'timestamp'", "]", "# Positive difference.", "\n", "times", "=", "time_lag", "*", "np", ".", "ones", "(", "(", "1", ",", "current_pc", ".", "nbr_points", "(", ")", ")", ")", "\n", "all_times", "=", "np", ".", "hstack", "(", "(", "all_times", ",", "times", ")", ")", "\n", "\n", "# Merge with key pc.", "\n", "all_pc", ".", "points", "=", "np", ".", "hstack", "(", "(", "all_pc", ".", "points", ",", "current_pc", ".", "points", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricData.max_recall_ind": [[126, 138], ["numpy.nonzero", "len"], "methods", ["None"], ["\n", "# Abort if there are no previous sweeps.", "\n", "if", "current_sd_rec", "[", "'prev'", "]", "==", "''", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "current_sd_rec", "[", "'prev'", "]", ")", "\n", "\n", "", "", "return", "all_pc", ",", "all_times", "\n", "\n", "", "def", "nbr_points", "(", "self", ")", "->", "int", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricData.max_recall": [[139, 144], ["None"], "methods", ["None"], ["\n", "return", "self", ".", "points", ".", "shape", "[", "1", "]", "\n", "\n", "", "def", "subsample", "(", "self", ",", "ratio", ":", "float", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricData.serialize": [[145, 156], ["data_classes.DetectionMetricData.recall.tolist", "data_classes.DetectionMetricData.precision.tolist", "data_classes.DetectionMetricData.confidence.tolist", "data_classes.DetectionMetricData.trans_err.tolist", "data_classes.DetectionMetricData.vel_err.tolist", "data_classes.DetectionMetricData.scale_err.tolist", "data_classes.DetectionMetricData.orient_err.tolist", "data_classes.DetectionMetricData.attr_err.tolist"], "methods", ["None"], ["\n", "selected_ind", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "0", ",", "self", ".", "nbr_points", "(", ")", ")", ",", "size", "=", "int", "(", "self", ".", "nbr_points", "(", ")", "*", "ratio", ")", ")", "\n", "self", ".", "points", "=", "self", ".", "points", "[", ":", ",", "selected_ind", "]", "\n", "\n", "", "def", "remove_close", "(", "self", ",", "radius", ":", "float", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Removes point too close within a certain radius from origin.\n        :param radius: Radius below which points are removed.\n        \"\"\"", "\n", "\n", "x_filt", "=", "np", ".", "abs", "(", "self", ".", "points", "[", "0", ",", ":", "]", ")", "<", "radius", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricData.deserialize": [[158, 169], ["cls", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["not_close", "=", "np", ".", "logical_not", "(", "np", ".", "logical_and", "(", "x_filt", ",", "y_filt", ")", ")", "\n", "self", ".", "points", "=", "self", ".", "points", "[", ":", ",", "not_close", "]", "\n", "\n", "", "def", "translate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Applies a translation to the point cloud.\n        :param x: <np.float: 3, 1>. Translation in x, y, z.\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "self", ".", "points", "[", "i", ",", ":", "]", "=", "self", ".", "points", "[", "i", ",", ":", "]", "+", "x", "[", "i", "]", "\n", "\n", "", "", "def", "rotate", "(", "self", ",", "rot_matrix", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricData.no_predictions": [[170, 181], ["cls", "numpy.linspace", "numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones"], "methods", ["None"], ["        ", "\"\"\"\n        Applies a rotation.\n        :param rot_matrix: <np.float: 3, 3>. Rotation matrix.\n        \"\"\"", "\n", "self", ".", "points", "[", ":", "3", ",", ":", "]", "=", "np", ".", "dot", "(", "rot_matrix", ",", "self", ".", "points", "[", ":", "3", ",", ":", "]", ")", "\n", "\n", "", "def", "transform", "(", "self", ",", "transf_matrix", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Applies a homogeneous transform.\n        :param transf_matrix: <np.float: 4, 4>. Homogenous transformation matrix.\n        \"\"\"", "\n", "self", ".", "points", "[", ":", "3", ",", ":", "]", "=", "transf_matrix", ".", "dot", "(", "np", ".", "vstack", "(", "(", "self", ".", "points", "[", ":", "3", ",", ":", "]", ",", "np", ".", "ones", "(", "self", ".", "nbr_points", "(", ")", ")", ")", ")", ")", "[", ":", "3", ",", ":", "]", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricData.random_md": [[182, 193], ["cls", "numpy.linspace", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.linspace"], "methods", ["None"], ["\n", "", "def", "render_height", "(", "self", ",", "\n", "ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "y_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "marker_size", ":", "float", "=", "1", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.__init__": [[198, 204], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict"], "methods", ["None"], ["\n", "", "def", "render_intensity", "(", "self", ",", "\n", "ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "y_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "marker_size", ":", "float", "=", "1", ")", "->", "None", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_ap": [[205, 207], ["None"], "methods", ["None"], ["        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.get_label_ap": [[208, 210], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_tp": [[211, 213], ["None"], "methods", ["None"], ["\n", "self", ".", "_render_helper", "(", "3", ",", "ax", ",", "view", ",", "x_lim", ",", "y_lim", ",", "marker_size", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.get_label_tp": [[214, 216], ["None"], "methods", ["None"], ["\n", "", "def", "_render_helper", "(", "self", ",", "\n", "color_channel", ":", "int", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_runtime": [[217, 219], ["None"], "methods", ["None"], ["ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.mean_dist_aps": [[220, 224], ["numpy.mean", "list", "data_classes.DetectionMetrics._label_aps.items", "d.values"], "methods", ["None"], ["y_lim", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "marker_size", ":", "float", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.mean_ap": [[225, 229], ["float", "numpy.mean", "list", "data_classes.DetectionMetrics.mean_dist_aps.values"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.tp_errors": [[230, 242], ["float", "class_errors.append", "numpy.nanmean", "data_classes.DetectionMetrics.get_label_tp"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.get_label_tp"], ["\n", "points", "=", "view_points", "(", "self", ".", "points", "[", ":", "3", ",", ":", "]", ",", "view", ",", "normalize", "=", "False", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "self", ".", "points", "[", "color_channel", ",", ":", "]", ",", "s", "=", "marker_size", ")", "\n", "ax", ".", "set_xlim", "(", "x_lim", "[", "0", "]", ",", "x_lim", "[", "1", "]", ")", "\n", "ax", ".", "set_ylim", "(", "y_lim", "[", "0", "]", ",", "y_lim", "[", "1", "]", ")", "\n", "\n", "\n", "", "", "class", "LidarPointCloud", "(", "PointCloud", ")", ":", "\n", "\n", "    ", "@", "staticmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.tp_scores": [[243, 258], ["max"], "methods", ["None"], ["\n", "return", "4", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_file", "(", "cls", ",", "file_name", ":", "str", ")", "->", "'LidarPointCloud'", ":", "\n", "        ", "\"\"\"\n        Loads LIDAR data from binary numpy format. Data is stored as (x, y, z, intensity, ring index).\n        :param file_name: Path of the pointcloud file on disk.\n        :return: LidarPointCloud instance (x, y, z, intensity).\n        \"\"\"", "\n", "\n", "assert", "file_name", ".", "endswith", "(", "'.bin'", ")", ",", "'Unsupported filetype {}'", ".", "format", "(", "file_name", ")", "\n", "\n", "scan", "=", "np", ".", "fromfile", "(", "file_name", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "points", "=", "scan", ".", "reshape", "(", "(", "-", "1", ",", "5", ")", ")", "[", ":", ",", ":", "cls", ".", "nbr_dims", "(", ")", "]", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.nd_score": [[259, 272], ["float", "float", "numpy.sum", "list", "len", "data_classes.DetectionMetrics.tp_scores.values", "data_classes.DetectionMetrics.tp_scores.keys"], "methods", ["None"], ["return", "cls", "(", "points", ".", "T", ")", "\n", "\n", "\n", "", "", "class", "RadarPointCloud", "(", "PointCloud", ")", ":", "\n", "\n", "# Class-level settings for radar pointclouds, see from_file().", "\n", "    ", "invalid_states", "=", "[", "0", "]", "# type: List[int]", "\n", "dynprop_states", "=", "range", "(", "7", ")", "# type: List[int] # Use [0, 2, 6] for moving objects only.", "\n", "ambig_states", "=", "[", "3", "]", "# type: List[int]", "\n", "\n", "@", "classmethod", "\n", "def", "disable_filters", "(", "cls", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.serialize": [[273, 284], ["data_classes.DetectionMetrics.cfg.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["\n", "cls", ".", "invalid_states", "=", "list", "(", "range", "(", "18", ")", ")", "\n", "cls", ".", "dynprop_states", "=", "list", "(", "range", "(", "8", ")", ")", "\n", "cls", ".", "ambig_states", "=", "list", "(", "range", "(", "5", ")", ")", "\n", "\n", "", "@", "classmethod", "\n", "def", "default_filters", "(", "cls", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.deserialize": [[286, 304], ["data_classes.DetectionConfig.deserialize", "cls", "cls.add_runtime", "content[].items", "content[].items", "label_aps.items", "label_tps.items", "cls.add_label_ap", "cls.add_label_tp", "float", "float", "float"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.add_runtime", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_ap", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_tp"], ["cls", ".", "invalid_states", "=", "[", "0", "]", "\n", "cls", ".", "dynprop_states", "=", "range", "(", "7", ")", "\n", "cls", ".", "ambig_states", "=", "[", "3", "]", "\n", "\n", "", "@", "staticmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns the number of dimensions.\n        :return: Number of dimensions.\n        \"\"\"", "\n", "return", "18", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_file", "(", "cls", ",", "\n", "file_name", ":", "str", ",", "\n", "invalid_states", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "dynprop_states", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "ambig_states", ":", "List", "[", "int", "]", "=", "None", ")", "->", "'RadarPointCloud'", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.__eq__": [[305, 313], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionBox.__init__": [[318, 345], ["nuscenes.eval.common.data_classes.EvalBox.__init__", "type", "numpy.any", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], []], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionBox.__eq__": [[346, 357], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionBox.serialize": [[358, 371], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionBox.deserialize": [[373, 387], ["cls", "tuple", "tuple", "tuple", "tuple", "tuple", "int", "float"], "methods", ["None"], ["\n", "\n", "assert", "file_name", ".", "endswith", "(", "'.pcd'", ")", ",", "'Unsupported filetype {}'", ".", "format", "(", "file_name", ")", "\n", "\n", "meta", "=", "[", "]", "\n", "with", "open", "(", "file_name", ",", "'rb'", ")", "as", "f", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.__init__": [[392, 394], ["None"], "methods", ["None"], ["                    ", "break", "\n", "\n", "", "", "data_binary", "=", "f", ".", "read", "(", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.__getitem__": [[395, 397], ["None"], "methods", ["None"], ["\n", "# Get the header rows and check if they appear as expected.", "\n", "", "assert", "meta", "[", "0", "]", ".", "startswith", "(", "'#'", ")", ",", "'First line must be comment'", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.__eq__": [[398, 403], ["data_classes.DetectionMetricDataList.md.keys"], "methods", ["None"], ["assert", "meta", "[", "1", "]", ".", "startswith", "(", "'VERSION'", ")", ",", "'Second line must be VERSION'", "\n", "sizes", "=", "meta", "[", "3", "]", ".", "split", "(", "' '", ")", "[", "1", ":", "]", "\n", "types", "=", "meta", "[", "4", "]", ".", "split", "(", "' '", ")", "[", "1", ":", "]", "\n", "counts", "=", "meta", "[", "5", "]", ".", "split", "(", "' '", ")", "[", "1", ":", "]", "\n", "width", "=", "int", "(", "meta", "[", "6", "]", ".", "split", "(", "' '", ")", "[", "1", "]", ")", "\n", "height", "=", "int", "(", "meta", "[", "7", "]", ".", "split", "(", "' '", ")", "[", "1", "]", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.get_class_data": [[404, 407], ["data_classes.DetectionMetricDataList.md.items"], "methods", ["None"], ["data", "=", "meta", "[", "10", "]", ".", "split", "(", "' '", ")", "[", "1", "]", "\n", "feature_count", "=", "len", "(", "types", ")", "\n", "assert", "width", ">", "0", "\n", "assert", "len", "(", "[", "c", "for", "c", "in", "counts", "if", "c", "!=", "c", "]", ")", "==", "0", ",", "'Error: COUNT not supported!'", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.get_dist_data": [[408, 411], ["data_classes.DetectionMetricDataList.md.items"], "methods", ["None"], ["assert", "height", "==", "1", ",", "'Error: height != 0 not supported!'", "\n", "assert", "data", "==", "'binary'", "\n", "\n", "# Lookup table for how to decode the binaries.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.set": [[412, 415], ["None"], "methods", ["None"], ["unpacking_lut", "=", "{", "'F'", ":", "{", "2", ":", "'e'", ",", "4", ":", "'f'", ",", "8", ":", "'d'", "}", ",", "\n", "'I'", ":", "{", "1", ":", "'b'", ",", "2", ":", "'h'", ",", "4", ":", "'i'", ",", "8", ":", "'q'", "}", ",", "\n", "'U'", ":", "{", "1", ":", "'B'", ",", "2", ":", "'H'", ",", "4", ":", "'I'", ",", "8", ":", "'Q'", "}", "}", "\n", "types_str", "=", "''", ".", "join", "(", "[", "unpacking_lut", "[", "t", "]", "[", "int", "(", "s", ")", "]", "for", "t", ",", "s", "in", "zip", "(", "types", ",", "sizes", ")", "]", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.serialize": [[416, 418], ["value.serialize", "str", "data_classes.DetectionMetricDataList.md.items"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["\n", "# Decode each point.", "\n", "offset", "=", "0", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.deserialize": [[419, 426], ["cls", "content.items", "key.split", "cls.set", "float", "data_classes.DetectionMetricData.deserialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize"], ["point_count", "=", "width", "\n", "points", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "point_count", ")", ":", "\n", "            ", "point", "=", "[", "]", "\n", "for", "p", "in", "range", "(", "feature_count", ")", ":", "\n", "                ", "start_p", "=", "offset", "\n", "end_p", "=", "start_p", "+", "int", "(", "sizes", "[", "p", "]", ")", "\n", "assert", "end_p", "<", "len", "(", "data_binary", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.config.config_factory": [[10, 30], ["os.path.dirname", "os.path.join", "os.path.exists", "nuscenes.eval.detection.data_classes.DetectionConfig.deserialize", "os.path.abspath", "open", "json.load"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize"], ["def", "config_factory", "(", "configuration_name", ":", "str", ")", "->", "DetectionConfig", ":", "\n", "    ", "\"\"\"\n    Creates a DetectionConfig instance that can be used to initialize a NuScenesEval instance.\n    Note that this only works if the config file is located in the nuscenes/eval/detection/configs folder.\n    :param configuration_name: Name of desired configuration in eval_detection_configs.\n    :return: DetectionConfig instance.\n    \"\"\"", "\n", "\n", "# Check if config exists.", "\n", "this_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "cfg_path", "=", "os", ".", "path", ".", "join", "(", "this_dir", ",", "'configs'", ",", "'%s.json'", "%", "configuration_name", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "cfg_path", ")", ",", "'Requested unknown configuration {}'", ".", "format", "(", "configuration_name", ")", "\n", "\n", "# Load config file and deserialize it.", "\n", "with", "open", "(", "cfg_path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "f", ")", "\n", "", "cfg", "=", "DetectionConfig", ".", "deserialize", "(", "data", ")", "\n", "\n", "return", "cfg", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.evaluate.DetectionEval.__init__": [[44, 100], ["os.path.exists", "os.path.join", "nuscenes.eval.common.loaders.load_prediction", "nuscenes.eval.common.loaders.load_gt", "nuscenes.eval.common.loaders.add_center_dist", "nuscenes.eval.common.loaders.add_center_dist", "nuscenes.eval.common.loaders.filter_eval_boxes", "nuscenes.eval.common.loaders.filter_eval_boxes", "os.path.isdir", "os.makedirs", "os.path.isdir", "os.makedirs", "print", "set", "set", "print", "print"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.load_prediction", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.load_gt", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.add_center_dist", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.add_center_dist", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["def", "__init__", "(", "self", ",", "\n", "nusc", ":", "NuScenes", ",", "\n", "config", ":", "DetectionConfig", ",", "\n", "result_path", ":", "str", ",", "\n", "eval_set", ":", "str", ",", "\n", "output_dir", ":", "str", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a DetectionEval object.\n        :param nusc: A NuScenes object.\n        :param config: A DetectionConfig object.\n        :param result_path: Path of the nuScenes JSON result file.\n        :param eval_set: The dataset split to evaluate on, e.g. train, val or test.\n        :param output_dir: Folder to save plots and results to.\n        :param verbose: Whether to print to stdout.\n        \"\"\"", "\n", "self", ".", "nusc", "=", "nusc", "\n", "self", ".", "result_path", "=", "result_path", "\n", "self", ".", "eval_set", "=", "eval_set", "\n", "self", ".", "output_dir", "=", "output_dir", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "cfg", "=", "config", "\n", "\n", "# Check result file exists.", "\n", "assert", "os", ".", "path", ".", "exists", "(", "result_path", ")", ",", "'Error: The result file does not exist!'", "\n", "\n", "# Make dirs.", "\n", "self", ".", "plot_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'plots'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "output_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "output_dir", ")", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "plot_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "plot_dir", ")", "\n", "\n", "# Load data.", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'Initializing nuScenes detection evaluation'", ")", "\n", "", "self", ".", "pred_boxes", ",", "self", ".", "meta", "=", "load_prediction", "(", "self", ".", "result_path", ",", "self", ".", "cfg", ".", "max_boxes_per_sample", ",", "DetectionBox", ",", "\n", "verbose", "=", "verbose", ")", "\n", "self", ".", "gt_boxes", "=", "load_gt", "(", "self", ".", "nusc", ",", "self", ".", "eval_set", ",", "DetectionBox", ",", "verbose", "=", "verbose", ")", "\n", "\n", "assert", "set", "(", "self", ".", "pred_boxes", ".", "sample_tokens", ")", "==", "set", "(", "self", ".", "gt_boxes", ".", "sample_tokens", ")", ",", "\"Samples in split doesn't match samples in predictions.\"", "\n", "\n", "# Add center distances.", "\n", "self", ".", "pred_boxes", "=", "add_center_dist", "(", "nusc", ",", "self", ".", "pred_boxes", ")", "\n", "self", ".", "gt_boxes", "=", "add_center_dist", "(", "nusc", ",", "self", ".", "gt_boxes", ")", "\n", "\n", "# Filter boxes (distance, points per box, etc.).", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Filtering predictions'", ")", "\n", "", "self", ".", "pred_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "self", ".", "pred_boxes", ",", "self", ".", "cfg", ".", "class_range", ",", "verbose", "=", "verbose", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Filtering ground truth annotations'", ")", "\n", "", "self", ".", "gt_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "self", ".", "gt_boxes", ",", "self", ".", "cfg", ".", "class_range", ",", "verbose", "=", "verbose", ")", "\n", "\n", "self", ".", "sample_tokens", "=", "self", ".", "gt_boxes", ".", "sample_tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.evaluate.DetectionEval.evaluate": [[101, 147], ["time.time", "nuscenes.eval.detection.data_classes.DetectionMetricDataList", "nuscenes.eval.detection.data_classes.DetectionMetrics", "nuscenes.eval.detection.data_classes.DetectionMetrics.add_runtime", "print", "print", "nuscenes.eval.detection.algo.accumulate", "nuscenes.eval.detection.data_classes.DetectionMetricDataList.set", "nuscenes.eval.detection.algo.calc_ap", "nuscenes.eval.detection.data_classes.DetectionMetrics.add_label_ap", "nuscenes.eval.detection.data_classes.DetectionMetrics.add_label_tp", "time.time", "nuscenes.eval.detection.algo.calc_tp"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.add_runtime", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.calc_ap", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_ap", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.add_label_tp", "home.repos.pwc.inspect_result.fpthink_v2b.detection.algo.calc_tp"], ["", "def", "evaluate", "(", "self", ")", "->", "Tuple", "[", "DetectionMetrics", ",", "DetectionMetricDataList", "]", ":", "\n", "        ", "\"\"\"\n        Performs the actual evaluation.\n        :return: A tuple of high-level and the raw metric data.\n        \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# -----------------------------------", "\n", "# Step 1: Accumulate metric data for all classes and distance thresholds.", "\n", "# -----------------------------------", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Accumulating metric data...'", ")", "\n", "", "metric_data_list", "=", "DetectionMetricDataList", "(", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "md", "=", "accumulate", "(", "self", ".", "gt_boxes", ",", "self", ".", "pred_boxes", ",", "class_name", ",", "self", ".", "cfg", ".", "dist_fcn_callable", ",", "dist_th", ")", "\n", "metric_data_list", ".", "set", "(", "class_name", ",", "dist_th", ",", "md", ")", "\n", "\n", "# -----------------------------------", "\n", "# Step 2: Calculate metrics from the data.", "\n", "# -----------------------------------", "\n", "", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Calculating metrics...'", ")", "\n", "", "metrics", "=", "DetectionMetrics", "(", "self", ".", "cfg", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "# Compute APs.", "\n", "            ", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "metric_data", "=", "metric_data_list", "[", "(", "class_name", ",", "dist_th", ")", "]", "\n", "ap", "=", "calc_ap", "(", "metric_data", ",", "self", ".", "cfg", ".", "min_recall", ",", "self", ".", "cfg", ".", "min_precision", ")", "\n", "metrics", ".", "add_label_ap", "(", "class_name", ",", "dist_th", ",", "ap", ")", "\n", "\n", "# Compute TP metrics.", "\n", "", "for", "metric_name", "in", "TP_METRICS", ":", "\n", "                ", "metric_data", "=", "metric_data_list", "[", "(", "class_name", ",", "self", ".", "cfg", ".", "dist_th_tp", ")", "]", "\n", "if", "class_name", "in", "[", "'traffic_cone'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", ",", "'orient_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "elif", "class_name", "in", "[", "'barrier'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "else", ":", "\n", "                    ", "tp", "=", "calc_tp", "(", "metric_data", ",", "self", ".", "cfg", ".", "min_recall", ",", "metric_name", ")", "\n", "", "metrics", ".", "add_label_tp", "(", "class_name", ",", "metric_name", ",", "tp", ")", "\n", "\n", "# Compute evaluation time.", "\n", "", "", "metrics", ".", "add_runtime", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "\n", "return", "metrics", ",", "metric_data_list", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.evaluate.DetectionEval.render": [[148, 173], ["nuscenes.eval.detection.render.summary_plot", "print", "os.path.join", "nuscenes.eval.detection.render.class_pr_curve", "nuscenes.eval.detection.render.class_tp_curve", "nuscenes.eval.detection.render.dist_pr_curve", "evaluate.DetectionEval.render.savepath"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.summary_plot", "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.class_pr_curve", "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.class_tp_curve", "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.dist_pr_curve"], ["", "def", "render", "(", "self", ",", "metrics", ":", "DetectionMetrics", ",", "md_list", ":", "DetectionMetricDataList", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders various PR and TP curves.\n        :param metrics: DetectionMetrics instance.\n        :param md_list: DetectionMetricDataList instance.\n        \"\"\"", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Rendering PR and TP curves'", ")", "\n", "\n", "", "def", "savepath", "(", "name", ")", ":", "\n", "            ", "return", "os", ".", "path", ".", "join", "(", "self", ".", "plot_dir", ",", "name", "+", "'.pdf'", ")", "\n", "\n", "", "summary_plot", "(", "md_list", ",", "metrics", ",", "min_precision", "=", "self", ".", "cfg", ".", "min_precision", ",", "min_recall", "=", "self", ".", "cfg", ".", "min_recall", ",", "\n", "dist_th_tp", "=", "self", ".", "cfg", ".", "dist_th_tp", ",", "savepath", "=", "savepath", "(", "'summary'", ")", ")", "\n", "\n", "for", "detection_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "class_pr_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "self", ".", "cfg", ".", "min_precision", ",", "self", ".", "cfg", ".", "min_recall", ",", "\n", "savepath", "=", "savepath", "(", "detection_name", "+", "'_pr'", ")", ")", "\n", "\n", "class_tp_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "self", ".", "cfg", ".", "min_recall", ",", "self", ".", "cfg", ".", "dist_th_tp", ",", "\n", "savepath", "=", "savepath", "(", "detection_name", "+", "'_tp'", ")", ")", "\n", "\n", "", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "            ", "dist_pr_curve", "(", "md_list", ",", "metrics", ",", "dist_th", ",", "self", ".", "cfg", ".", "min_precision", ",", "self", ".", "cfg", ".", "min_recall", ",", "\n", "savepath", "=", "savepath", "(", "'dist_pr_'", "+", "str", "(", "dist_th", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.evaluate.DetectionEval.main": [[174, 250], ["evaluate.DetectionEval.evaluate", "metrics.serialize", "evaluate.DetectionEval.meta.copy", "print", "metrics_summary[].items", "print", "print", "print", "print", "print", "class_aps.keys", "random.seed", "list", "random.shuffle", "os.path.join", "evaluate.DetectionEval.render", "print", "open", "json.dump", "open", "json.dump", "print", "print", "os.path.isdir", "os.mkdir", "nuscenes.eval.detection.render.visualize_sample", "os.path.join", "os.path.join", "metric_data_list.serialize", "nuscenes.eval.common.data_classes.EvalBoxes", "max", "os.path.join", "evaluate.DetectionEval.cfg.class_range.values"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.evaluate", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.visualize_sample", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "", "def", "main", "(", "self", ",", "\n", "plot_examples", ":", "int", "=", "0", ",", "\n", "render_curves", ":", "bool", "=", "True", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Main function that loads the evaluation code, visualizes samples, runs the evaluation and renders stat plots.\n        :param plot_examples: How many example visualizations to write to disk.\n        :param render_curves: Whether to render PR and TP curves to disk.\n        :return: A dict that stores the high-level metrics and meta data.\n        \"\"\"", "\n", "if", "plot_examples", ">", "0", ":", "\n", "# Select a random but fixed subset to plot.", "\n", "            ", "random", ".", "seed", "(", "42", ")", "\n", "sample_tokens", "=", "list", "(", "self", ".", "sample_tokens", ")", "\n", "random", ".", "shuffle", "(", "sample_tokens", ")", "\n", "sample_tokens", "=", "sample_tokens", "[", ":", "plot_examples", "]", "\n", "\n", "# Visualize samples.", "\n", "example_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'examples'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "example_dir", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "example_dir", ")", "\n", "", "for", "sample_token", "in", "sample_tokens", ":", "\n", "                ", "visualize_sample", "(", "self", ".", "nusc", ",", "\n", "sample_token", ",", "\n", "self", ".", "gt_boxes", "if", "self", ".", "eval_set", "!=", "'test'", "else", "EvalBoxes", "(", ")", ",", "\n", "# Don't render test GT.", "\n", "self", ".", "pred_boxes", ",", "\n", "eval_range", "=", "max", "(", "self", ".", "cfg", ".", "class_range", ".", "values", "(", ")", ")", ",", "\n", "savepath", "=", "os", ".", "path", ".", "join", "(", "example_dir", ",", "'{}.png'", ".", "format", "(", "sample_token", ")", ")", ")", "\n", "\n", "# Run evaluation.", "\n", "", "", "metrics", ",", "metric_data_list", "=", "self", ".", "evaluate", "(", ")", "\n", "\n", "# Render PR and TP curves.", "\n", "if", "render_curves", ":", "\n", "            ", "self", ".", "render", "(", "metrics", ",", "metric_data_list", ")", "\n", "\n", "# Dump the metric data, meta and metrics to disk.", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Saving metrics to: %s'", "%", "self", ".", "output_dir", ")", "\n", "", "metrics_summary", "=", "metrics", ".", "serialize", "(", ")", "\n", "metrics_summary", "[", "'meta'", "]", "=", "self", ".", "meta", ".", "copy", "(", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'metrics_summary.json'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "metrics_summary", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'metrics_details.json'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "metric_data_list", ".", "serialize", "(", ")", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "# Print high-level metrics.", "\n", "", "print", "(", "'mAP: %.4f'", "%", "(", "metrics_summary", "[", "'mean_ap'", "]", ")", ")", "\n", "err_name_mapping", "=", "{", "\n", "'trans_err'", ":", "'mATE'", ",", "\n", "'scale_err'", ":", "'mASE'", ",", "\n", "'orient_err'", ":", "'mAOE'", ",", "\n", "'vel_err'", ":", "'mAVE'", ",", "\n", "'attr_err'", ":", "'mAAE'", "\n", "}", "\n", "for", "tp_name", ",", "tp_val", "in", "metrics_summary", "[", "'tp_errors'", "]", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'%s: %.4f'", "%", "(", "err_name_mapping", "[", "tp_name", "]", ",", "tp_val", ")", ")", "\n", "", "print", "(", "'NDS: %.4f'", "%", "(", "metrics_summary", "[", "'nd_score'", "]", ")", ")", "\n", "print", "(", "'Eval time: %.1fs'", "%", "metrics_summary", "[", "'eval_time'", "]", ")", "\n", "\n", "# Print per-class metrics.", "\n", "print", "(", ")", "\n", "print", "(", "'Per-class results:'", ")", "\n", "print", "(", "'Object Class\\tAP\\tATE\\tASE\\tAOE\\tAVE\\tAAE'", ")", "\n", "class_aps", "=", "metrics_summary", "[", "'mean_dist_aps'", "]", "\n", "class_tps", "=", "metrics_summary", "[", "'label_tp_errors'", "]", "\n", "for", "class_name", "in", "class_aps", ".", "keys", "(", ")", ":", "\n", "            ", "print", "(", "'%s\\t%.3f\\t%.3f\\t%.3f\\t%.3f\\t%.3f\\t%.3f'", "\n", "%", "(", "class_name", ",", "class_aps", "[", "class_name", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'trans_err'", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'scale_err'", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'orient_err'", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'vel_err'", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'attr_err'", "]", ")", ")", "\n", "\n", "", "return", "metrics_summary", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.visualize_sample": [[23, 104], ["nusc.get", "nusc.get", "nusc.get", "nusc.get", "nuscenes.eval.common.utils.boxes_to_sensor", "nuscenes.eval.common.utils.boxes_to_sensor", "zip", "nuscenes.utils.data_classes.LidarPointCloud.from_file_multisweep", "matplotlib.pyplot.subplots", "nuscenes.utils.geometry_utils.view_points", "numpy.sqrt", "numpy.minimum", "ax.scatter", "ax.plot", "ax.set_xlim", "ax.set_ylim", "matplotlib.pyplot.title", "numpy.eye", "numpy.sum", "box.render", "print", "matplotlib.pyplot.savefig", "matplotlib.pyplot.close", "matplotlib.pyplot.show", "numpy.isnan", "box.render", "numpy.eye", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.boxes_to_sensor", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.boxes_to_sensor", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.from_file_multisweep", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.view_points", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render"], ["def", "visualize_sample", "(", "nusc", ":", "NuScenes", ",", "\n", "sample_token", ":", "str", ",", "\n", "gt_boxes", ":", "EvalBoxes", ",", "\n", "pred_boxes", ":", "EvalBoxes", ",", "\n", "nsweeps", ":", "int", "=", "1", ",", "\n", "conf_th", ":", "float", "=", "0.15", ",", "\n", "eval_range", ":", "float", "=", "50", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "savepath", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Visualizes a sample from BEV with annotations and detection results.\n    :param nusc: NuScenes object.\n    :param sample_token: The nuScenes sample token.\n    :param gt_boxes: Ground truth boxes grouped by sample.\n    :param pred_boxes: Prediction grouped by sample.\n    :param nsweeps: Number of sweeps used for lidar visualization.\n    :param conf_th: The confidence threshold used to filter negatives.\n    :param eval_range: Range in meters beyond which boxes are ignored.\n    :param verbose: Whether to print to stdout.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    \"\"\"", "\n", "# Retrieve sensor & pose records.", "\n", "sample_rec", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "sd_record", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "\n", "cs_record", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "sd_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pose_record", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "sd_record", "[", "'ego_pose_token'", "]", ")", "\n", "\n", "# Get boxes.", "\n", "boxes_gt_global", "=", "gt_boxes", "[", "sample_token", "]", "\n", "boxes_est_global", "=", "pred_boxes", "[", "sample_token", "]", "\n", "\n", "# Map GT boxes to lidar.", "\n", "boxes_gt", "=", "boxes_to_sensor", "(", "boxes_gt_global", ",", "pose_record", ",", "cs_record", ")", "\n", "\n", "# Map EST boxes to lidar.", "\n", "boxes_est", "=", "boxes_to_sensor", "(", "boxes_est_global", ",", "pose_record", ",", "cs_record", ")", "\n", "\n", "# Add scores to EST boxes.", "\n", "for", "box_est", ",", "box_est_global", "in", "zip", "(", "boxes_est", ",", "boxes_est_global", ")", ":", "\n", "        ", "box_est", ".", "score", "=", "box_est_global", ".", "detection_score", "\n", "\n", "# Get point cloud in lidar frame.", "\n", "", "pc", ",", "_", "=", "LidarPointCloud", ".", "from_file_multisweep", "(", "nusc", ",", "sample_rec", ",", "'LIDAR_TOP'", ",", "'LIDAR_TOP'", ",", "nsweeps", "=", "nsweeps", ")", "\n", "\n", "# Init axes.", "\n", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "9", ")", ")", "\n", "\n", "# Show point cloud.", "\n", "points", "=", "view_points", "(", "pc", ".", "points", "[", ":", "3", ",", ":", "]", ",", "np", ".", "eye", "(", "4", ")", ",", "normalize", "=", "False", ")", "\n", "dists", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "pc", ".", "points", "[", ":", "2", ",", ":", "]", "**", "2", ",", "axis", "=", "0", ")", ")", "\n", "colors", "=", "np", ".", "minimum", "(", "1", ",", "dists", "/", "eval_range", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "colors", ",", "s", "=", "0.2", ")", "\n", "\n", "# Show ego vehicle.", "\n", "ax", ".", "plot", "(", "0", ",", "0", ",", "'x'", ",", "color", "=", "'black'", ")", "\n", "\n", "# Show GT boxes.", "\n", "for", "box", "in", "boxes_gt", ":", "\n", "        ", "box", ".", "render", "(", "ax", ",", "view", "=", "np", ".", "eye", "(", "4", ")", ",", "colors", "=", "(", "'g'", ",", "'g'", ",", "'g'", ")", ",", "linewidth", "=", "2", ")", "\n", "\n", "# Show EST boxes.", "\n", "", "for", "box", "in", "boxes_est", ":", "\n", "# Show only predictions with a high score.", "\n", "        ", "assert", "not", "np", ".", "isnan", "(", "box", ".", "score", ")", ",", "'Error: Box score cannot be NaN!'", "\n", "if", "box", ".", "score", ">=", "conf_th", ":", "\n", "            ", "box", ".", "render", "(", "ax", ",", "view", "=", "np", ".", "eye", "(", "4", ")", ",", "colors", "=", "(", "'b'", ",", "'b'", ",", "'b'", ")", ",", "linewidth", "=", "1", ")", "\n", "\n", "# Limit visible range.", "\n", "", "", "axes_limit", "=", "eval_range", "+", "3", "# Slightly bigger to include boxes that extend beyond the range.", "\n", "ax", ".", "set_xlim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "ax", ".", "set_ylim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "\n", "# Show / save plot.", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'Rendering sample token %s'", "%", "sample_token", ")", "\n", "", "plt", ".", "title", "(", "sample_token", ")", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.class_pr_curve": [[106, 141], ["md_list.get_class_data", "nuscenes.eval.common.render.setup_axis.legend", "nuscenes.eval.common.render.setup_axis", "metrics.get_label_ap", "nuscenes.eval.common.render.setup_axis.plot", "matplotlib.pyplot.savefig", "matplotlib.pyplot.close"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.get_class_data", "home.repos.pwc.inspect_result.fpthink_v2b.common.render.setup_axis", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.get_label_ap"], ["", "", "def", "class_pr_curve", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n", "metrics", ":", "DetectionMetrics", ",", "\n", "detection_name", ":", "str", ",", "\n", "min_precision", ":", "float", ",", "\n", "min_recall", ":", "float", ",", "\n", "savepath", ":", "str", "=", "None", ",", "\n", "ax", ":", "Axis", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Plot a precision recall curve for the specified class.\n    :param md_list: DetectionMetricDataList instance.\n    :param metrics: DetectionMetrics instance.\n    :param detection_name: The detection class.\n    :param min_precision:\n    :param min_recall: Minimum recall value.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    :param ax: Axes onto which to render.\n    \"\"\"", "\n", "# Prepare axis.", "\n", "if", "ax", "is", "None", ":", "\n", "        ", "ax", "=", "setup_axis", "(", "title", "=", "PRETTY_DETECTION_NAMES", "[", "detection_name", "]", ",", "xlabel", "=", "'Recall'", ",", "ylabel", "=", "'Precision'", ",", "xlim", "=", "1", ",", "\n", "ylim", "=", "1", ",", "min_precision", "=", "min_precision", ",", "min_recall", "=", "min_recall", ")", "\n", "\n", "# Get recall vs precision values of given class for each distance threshold.", "\n", "", "data", "=", "md_list", ".", "get_class_data", "(", "detection_name", ")", "\n", "\n", "# Plot the recall vs. precision curve for each distance threshold.", "\n", "for", "md", ",", "dist_th", "in", "data", ":", "\n", "        ", "md", ":", "DetectionMetricData", "\n", "ap", "=", "metrics", ".", "get_label_ap", "(", "detection_name", ",", "dist_th", ")", "\n", "ax", ".", "plot", "(", "md", ".", "recall", ",", "md", ".", "precision", ",", "label", "=", "'Dist. : {}, AP: {:.1f}'", ".", "format", "(", "dist_th", ",", "ap", "*", "100", ")", ")", "\n", "\n", "", "ax", ".", "legend", "(", "loc", "=", "'best'", ")", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.class_tp_curve": [[143, 200], ["round", "nuscenes.eval.common.render.setup_axis.set_ylim", "nuscenes.eval.common.render.setup_axis.axvline", "nuscenes.eval.common.render.setup_axis.legend", "nuscenes.eval.common.render.setup_axis", "metrics.get_label_tp", "nuscenes.eval.common.render.setup_axis.plot", "matplotlib.pyplot.savefig", "matplotlib.pyplot.close", "max", "numpy.isnan", "max", "getattr", "metrics.get_label_tp", "getattr"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.render.setup_axis", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.get_label_tp", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.get_label_tp"], ["", "", "def", "class_tp_curve", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n", "metrics", ":", "DetectionMetrics", ",", "\n", "detection_name", ":", "str", ",", "\n", "min_recall", ":", "float", ",", "\n", "dist_th_tp", ":", "float", ",", "\n", "savepath", ":", "str", "=", "None", ",", "\n", "ax", ":", "Axis", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Plot the true positive curve for the specified class.\n    :param md_list: DetectionMetricDataList instance.\n    :param metrics: DetectionMetrics instance.\n    :param detection_name:\n    :param min_recall: Minimum recall value.\n    :param dist_th_tp: The distance threshold used to determine matches.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    :param ax: Axes onto which to render.\n    \"\"\"", "\n", "# Get metric data for given detection class with tp distance threshold.", "\n", "md", "=", "md_list", "[", "(", "detection_name", ",", "dist_th_tp", ")", "]", "\n", "min_recall_ind", "=", "round", "(", "100", "*", "min_recall", ")", "\n", "if", "min_recall_ind", "<=", "md", ".", "max_recall_ind", ":", "\n", "# For traffic_cone and barrier only a subset of the metrics are plotted.", "\n", "        ", "rel_metrics", "=", "[", "m", "for", "m", "in", "TP_METRICS", "if", "not", "np", ".", "isnan", "(", "metrics", ".", "get_label_tp", "(", "detection_name", ",", "m", ")", ")", "]", "\n", "ylimit", "=", "max", "(", "[", "max", "(", "getattr", "(", "md", ",", "metric", ")", "[", "min_recall_ind", ":", "md", ".", "max_recall_ind", "+", "1", "]", ")", "for", "metric", "in", "rel_metrics", "]", ")", "*", "1.1", "\n", "", "else", ":", "\n", "        ", "ylimit", "=", "1.0", "\n", "\n", "# Prepare axis.", "\n", "", "if", "ax", "is", "None", ":", "\n", "        ", "ax", "=", "setup_axis", "(", "title", "=", "PRETTY_DETECTION_NAMES", "[", "detection_name", "]", ",", "xlabel", "=", "'Recall'", ",", "ylabel", "=", "'Error'", ",", "xlim", "=", "1", ",", "\n", "min_recall", "=", "min_recall", ")", "\n", "", "ax", ".", "set_ylim", "(", "0", ",", "ylimit", ")", "\n", "\n", "# Plot the recall vs. error curve for each tp metric.", "\n", "for", "metric", "in", "TP_METRICS", ":", "\n", "        ", "tp", "=", "metrics", ".", "get_label_tp", "(", "detection_name", ",", "metric", ")", "\n", "\n", "# Plot only if we have valid data.", "\n", "if", "tp", "is", "not", "np", ".", "nan", "and", "min_recall_ind", "<=", "md", ".", "max_recall_ind", ":", "\n", "            ", "recall", ",", "error", "=", "md", ".", "recall", "[", ":", "md", ".", "max_recall_ind", "+", "1", "]", ",", "getattr", "(", "md", ",", "metric", ")", "[", ":", "md", ".", "max_recall_ind", "+", "1", "]", "\n", "", "else", ":", "\n", "            ", "recall", ",", "error", "=", "[", "]", ",", "[", "]", "\n", "\n", "# Change legend based on tp value", "\n", "", "if", "tp", "is", "np", ".", "nan", ":", "\n", "            ", "label", "=", "'{}: n/a'", ".", "format", "(", "PRETTY_TP_METRICS", "[", "metric", "]", ")", "\n", "", "elif", "min_recall_ind", ">", "md", ".", "max_recall_ind", ":", "\n", "            ", "label", "=", "'{}: nan'", ".", "format", "(", "PRETTY_TP_METRICS", "[", "metric", "]", ")", "\n", "", "else", ":", "\n", "            ", "label", "=", "'{}: {:.2f} ({})'", ".", "format", "(", "PRETTY_TP_METRICS", "[", "metric", "]", ",", "tp", ",", "TP_METRICS_UNITS", "[", "metric", "]", ")", "\n", "", "ax", ".", "plot", "(", "recall", ",", "error", ",", "label", "=", "label", ")", "\n", "", "ax", ".", "axvline", "(", "x", "=", "md", ".", "max_recall", ",", "linestyle", "=", "'-.'", ",", "color", "=", "(", "0", ",", "0", ",", "0", ",", "0.3", ")", ")", "\n", "ax", ".", "legend", "(", "loc", "=", "'best'", ")", "\n", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.dist_pr_curve": [[202, 237], ["matplotlib.pyplot.subplots", "nuscenes.eval.common.render.setup_axis", "md_list.get_dist_data", "nuscenes.eval.common.render.setup_axis.get_legend_handles_labels", "lax.legend", "lax.axis", "matplotlib.pyplot.tight_layout", "metrics.get_label_ap", "nuscenes.eval.common.render.setup_axis.plot", "matplotlib.pyplot.savefig", "matplotlib.pyplot.close"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.render.setup_axis", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetricDataList.get_dist_data", "home.repos.pwc.inspect_result.fpthink_v2b.detection.data_classes.DetectionMetrics.get_label_ap"], ["", "", "def", "dist_pr_curve", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n", "metrics", ":", "DetectionMetrics", ",", "\n", "dist_th", ":", "float", ",", "\n", "min_precision", ":", "float", ",", "\n", "min_recall", ":", "float", ",", "\n", "savepath", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Plot the PR curves for different distance thresholds.\n    :param md_list: DetectionMetricDataList instance.\n    :param metrics: DetectionMetrics instance.\n    :param dist_th: Distance threshold for matching.\n    :param min_precision: Minimum precision value.\n    :param min_recall: Minimum recall value.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    \"\"\"", "\n", "# Prepare axis.", "\n", "fig", ",", "(", "ax", ",", "lax", ")", "=", "plt", ".", "subplots", "(", "ncols", "=", "2", ",", "gridspec_kw", "=", "{", "\"width_ratios\"", ":", "[", "4", ",", "1", "]", "}", ",", "\n", "figsize", "=", "(", "7.5", ",", "5", ")", ")", "\n", "ax", "=", "setup_axis", "(", "xlabel", "=", "'Recall'", ",", "ylabel", "=", "'Precision'", ",", "\n", "xlim", "=", "1", ",", "ylim", "=", "1", ",", "min_precision", "=", "min_precision", ",", "min_recall", "=", "min_recall", ",", "ax", "=", "ax", ")", "\n", "\n", "# Plot the recall vs. precision curve for each detection class.", "\n", "data", "=", "md_list", ".", "get_dist_data", "(", "dist_th", ")", "\n", "for", "md", ",", "detection_name", "in", "data", ":", "\n", "        ", "md", "=", "md_list", "[", "(", "detection_name", ",", "dist_th", ")", "]", "\n", "ap", "=", "metrics", ".", "get_label_ap", "(", "detection_name", ",", "dist_th", ")", "\n", "ax", ".", "plot", "(", "md", ".", "recall", ",", "md", ".", "precision", ",", "label", "=", "'{}: {:.1f}%'", ".", "format", "(", "PRETTY_DETECTION_NAMES", "[", "detection_name", "]", ",", "ap", "*", "100", ")", ",", "\n", "color", "=", "DETECTION_COLORS", "[", "detection_name", "]", ")", "\n", "", "hx", ",", "lx", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "lax", ".", "legend", "(", "hx", ",", "lx", ",", "borderaxespad", "=", "0", ")", "\n", "lax", ".", "axis", "(", "\"off\"", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.summary_plot": [[239, 276], ["len", "matplotlib.pyplot.subplots", "enumerate", "matplotlib.pyplot.tight_layout", "nuscenes.eval.common.render.setup_axis", "nuscenes.eval.common.render.setup_axis.set_ylabel", "nuscenes.eval.common.render.setup_axis", "render.class_pr_curve", "render.class_tp_curve", "matplotlib.pyplot.savefig", "matplotlib.pyplot.close", "nuscenes.eval.common.render.setup_axis.set_xlabel", "nuscenes.eval.common.render.setup_axis.set_xlabel"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.render.setup_axis", "home.repos.pwc.inspect_result.fpthink_v2b.common.render.setup_axis", "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.class_pr_curve", "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.class_tp_curve"], ["", "", "def", "summary_plot", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n", "metrics", ":", "DetectionMetrics", ",", "\n", "min_precision", ":", "float", ",", "\n", "min_recall", ":", "float", ",", "\n", "dist_th_tp", ":", "float", ",", "\n", "savepath", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Creates a summary plot with PR and TP curves for each class.\n    :param md_list: DetectionMetricDataList instance.\n    :param metrics: DetectionMetrics instance.\n    :param min_precision: Minimum precision value.\n    :param min_recall: Minimum recall value.\n    :param dist_th_tp: The distance threshold used to determine matches.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    \"\"\"", "\n", "n_classes", "=", "len", "(", "DETECTION_NAMES", ")", "\n", "_", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "n_classes", ",", "ncols", "=", "2", ",", "figsize", "=", "(", "15", ",", "5", "*", "n_classes", ")", ")", "\n", "for", "ind", ",", "detection_name", "in", "enumerate", "(", "DETECTION_NAMES", ")", ":", "\n", "        ", "title1", ",", "title2", "=", "(", "'Recall vs Precision'", ",", "'Recall vs Error'", ")", "if", "ind", "==", "0", "else", "(", "None", ",", "None", ")", "\n", "\n", "ax1", "=", "setup_axis", "(", "xlim", "=", "1", ",", "ylim", "=", "1", ",", "title", "=", "title1", ",", "min_precision", "=", "min_precision", ",", "\n", "min_recall", "=", "min_recall", ",", "ax", "=", "axes", "[", "ind", ",", "0", "]", ")", "\n", "ax1", ".", "set_ylabel", "(", "'{} \\n \\n Precision'", ".", "format", "(", "PRETTY_DETECTION_NAMES", "[", "detection_name", "]", ")", ",", "size", "=", "20", ")", "\n", "\n", "ax2", "=", "setup_axis", "(", "xlim", "=", "1", ",", "title", "=", "title2", ",", "min_recall", "=", "min_recall", ",", "ax", "=", "axes", "[", "ind", ",", "1", "]", ")", "\n", "if", "ind", "==", "n_classes", "-", "1", ":", "\n", "            ", "ax1", ".", "set_xlabel", "(", "'Recall'", ",", "size", "=", "20", ")", "\n", "ax2", ".", "set_xlabel", "(", "'Recall'", ",", "size", "=", "20", ")", "\n", "\n", "", "class_pr_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "min_precision", ",", "min_recall", ",", "ax", "=", "ax1", ")", "\n", "class_tp_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "min_recall", ",", "dist_th_tp", "=", "dist_th_tp", ",", "ax", "=", "ax2", ")", "\n", "\n", "", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.render.detailed_results_table_tex": [[278, 339], ["open", "json.load", "open", "f.write", "numpy.mean", "[].values"], "function", ["None"], ["", "", "def", "detailed_results_table_tex", "(", "metrics_path", ":", "str", ",", "output_path", ":", "str", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Renders a detailed results table in tex.\n    :param metrics_path: path to a serialized DetectionMetrics file.\n    :param output_path: path to the output file.\n    \"\"\"", "\n", "with", "open", "(", "metrics_path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "metrics", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "tex", "=", "''", "\n", "tex", "+=", "'\\\\begin{table}[]\\n'", "\n", "tex", "+=", "'\\\\small\\n'", "\n", "tex", "+=", "'\\\\begin{tabular}{| c | c | c | c | c | c | c |} \\\\hline\\n'", "\n", "tex", "+=", "'\\\\textbf{Class}    &   \\\\textbf{AP}  &   \\\\textbf{ATE} &   \\\\textbf{ASE} & \\\\textbf{AOE}   & '", "'\\\\textbf{AVE}   & '", "'\\\\textbf{AAE}   \\\\\\\\ \\\\hline '", "'\\\\hline\\n'", "\n", "for", "name", "in", "DETECTION_NAMES", ":", "\n", "        ", "ap", "=", "np", ".", "mean", "(", "metrics", "[", "'label_aps'", "]", "[", "name", "]", ".", "values", "(", ")", ")", "*", "100", "\n", "ate", "=", "metrics", "[", "'label_tp_errors'", "]", "[", "name", "]", "[", "'trans_err'", "]", "\n", "ase", "=", "metrics", "[", "'label_tp_errors'", "]", "[", "name", "]", "[", "'scale_err'", "]", "\n", "aoe", "=", "metrics", "[", "'label_tp_errors'", "]", "[", "name", "]", "[", "'orient_err'", "]", "\n", "ave", "=", "metrics", "[", "'label_tp_errors'", "]", "[", "name", "]", "[", "'vel_err'", "]", "\n", "aae", "=", "metrics", "[", "'label_tp_errors'", "]", "[", "name", "]", "[", "'attr_err'", "]", "\n", "tex_name", "=", "PRETTY_DETECTION_NAMES", "[", "name", "]", "\n", "if", "name", "==", "'traffic_cone'", ":", "\n", "            ", "tex", "+=", "'{}  &   {:.1f}  &   {:.2f}  &   {:.2f}  &   N/A  &   N/A  &   N/A  \\\\\\\\ \\\\hline\\n'", ".", "format", "(", "\n", "tex_name", ",", "ap", ",", "ate", ",", "ase", ")", "\n", "", "elif", "name", "==", "'barrier'", ":", "\n", "            ", "tex", "+=", "'{}  &   {:.1f}  &   {:.2f}  &   {:.2f}  &   {:.2f}  &   N/A  &   N/A  \\\\\\\\ \\\\hline\\n'", ".", "format", "(", "\n", "tex_name", ",", "ap", ",", "ate", ",", "ase", ",", "aoe", ")", "\n", "", "else", ":", "\n", "            ", "tex", "+=", "'{}  &   {:.1f}  &   {:.2f}  &   {:.2f}  &   {:.2f}  &   {:.2f}  &   {:.2f}  \\\\\\\\ '", "'\\\\hline\\n'", ".", "format", "(", "tex_name", ",", "ap", ",", "ate", ",", "ase", ",", "aoe", ",", "ave", ",", "aae", ")", "\n", "\n", "", "", "map_", "=", "metrics", "[", "'mean_ap'", "]", "\n", "mate", "=", "metrics", "[", "'tp_errors'", "]", "[", "'trans_err'", "]", "\n", "mase", "=", "metrics", "[", "'tp_errors'", "]", "[", "'scale_err'", "]", "\n", "maoe", "=", "metrics", "[", "'tp_errors'", "]", "[", "'orient_err'", "]", "\n", "mave", "=", "metrics", "[", "'tp_errors'", "]", "[", "'vel_err'", "]", "\n", "maae", "=", "metrics", "[", "'tp_errors'", "]", "[", "'attr_err'", "]", "\n", "tex", "+=", "'\\\\hline {} &   {:.1f}  &   {:.2f}  &   {:.2f}  &   {:.2f}  &   {:.2f}  &   {:.2f}  \\\\\\\\ '", "'\\\\hline\\n'", ".", "format", "(", "'\\\\textbf{Mean}'", ",", "map_", ",", "mate", ",", "mase", ",", "maoe", ",", "mave", ",", "maae", ")", "\n", "\n", "tex", "+=", "'\\\\end{tabular}\\n'", "\n", "\n", "# All one line", "\n", "tex", "+=", "'\\\\caption{Detailed detection performance on the val set. \\n'", "\n", "tex", "+=", "'AP: average precision averaged over distance thresholds (%), \\n'", "\n", "tex", "+=", "'ATE: average translation error (${}$), \\n'", ".", "format", "(", "TP_METRICS_UNITS", "[", "'trans_err'", "]", ")", "\n", "tex", "+=", "'ASE: average scale error (${}$), \\n'", ".", "format", "(", "TP_METRICS_UNITS", "[", "'scale_err'", "]", ")", "\n", "tex", "+=", "'AOE: average orientation error (${}$), \\n'", ".", "format", "(", "TP_METRICS_UNITS", "[", "'orient_err'", "]", ")", "\n", "tex", "+=", "'AVE: average velocity error (${}$), \\n'", ".", "format", "(", "TP_METRICS_UNITS", "[", "'vel_err'", "]", ")", "\n", "tex", "+=", "'AAE: average attribute error (${}$). \\n'", ".", "format", "(", "TP_METRICS_UNITS", "[", "'attr_err'", "]", ")", "\n", "tex", "+=", "'nuScenes Detection Score (NDS) = {:.1f} \\n'", ".", "format", "(", "metrics", "[", "'nd_score'", "]", "*", "100", ")", "\n", "tex", "+=", "'}\\n'", "\n", "\n", "tex", "+=", "'\\\\end{table}\\n'", "\n", "\n", "with", "open", "(", "output_path", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "tex", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.utils.category_to_detection_name": [[7, 35], ["None"], "function", ["None"], ["import", "warnings", "\n", "\n", "import", "matplotlib", ".", "font_manager", "\n", "from", "PIL", "import", "ImageFont", "\n", "import", "numpy", "as", "np", "\n", "from", "pycocotools", "import", "mask", "as", "cocomask", "\n", "\n", "\n", "def", "annotation_name", "(", "attributes", ":", "List", "[", "dict", "]", ",", "\n", "category_name", ":", "str", ",", "\n", "with_attributes", ":", "bool", "=", "False", ")", "->", "str", ":", "\n", "    ", "\"\"\"\n    Returns the \"name\" of an annotation, optionally including the attributes.\n    :param attributes: The attribute dictionary.\n    :param category_name: Name of the object category.\n    :param with_attributes: Whether to print the attributes alongside the category name.\n    :return: A human readable string describing the annotation.\n    \"\"\"", "\n", "outstr", "=", "category_name", "\n", "\n", "if", "with_attributes", ":", "\n", "        ", "atts", "=", "[", "attribute", "[", "'name'", "]", "for", "attribute", "in", "attributes", "]", "\n", "if", "len", "(", "atts", ")", ">", "0", ":", "\n", "            ", "outstr", "=", "outstr", "+", "\"--\"", "+", "'.'", ".", "join", "(", "atts", ")", "\n", "\n", "", "", "return", "outstr", "\n", "\n", "\n", "", "def", "mask_decode", "(", "mask", ":", "dict", ")", "->", "np", ".", "ndarray", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.detection.utils.detection_name_to_rel_attributes": [[37, 56], ["ValueError"], "function", ["None"], ["\n", "# Note that it is essential to copy the mask here. If we use the same variable we will overwrite the NuImage class", "\n", "# and cause the Jupyter Notebook to crash on some systems.", "\n", "new_mask", "=", "mask", ".", "copy", "(", ")", "\n", "new_mask", "[", "'counts'", "]", "=", "base64", ".", "b64decode", "(", "mask", "[", "'counts'", "]", ")", "\n", "return", "cocomask", ".", "decode", "(", "new_mask", ")", "\n", "\n", "\n", "", "def", "get_font", "(", "fonts_valid", ":", "List", "[", "str", "]", "=", "None", ",", "font_size", ":", "int", "=", "15", ")", "->", "ImageFont", ":", "\n", "    ", "\"\"\"\n    Check if there is a desired font present in the user's system. If there is, use that font; otherwise, use a default\n    font.\n    :param fonts_valid: A list of fonts which are desirable.\n    :param font_size: The size of the font to set. Note that if the default font is used, then the font size\n        cannot be set.\n    :return: An ImageFont object to use as the font in a PIL image.\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.submission.do_inference.load_model": [[18, 21], ["nuscenes.prediction.models.physics.ConstantVelocityHeading"], "function", ["None"], ["def", "load_model", "(", "helper", ":", "PredictHelper", ",", "config", ":", "PredictionConfig", ",", "path_to_model_weights", ":", "str", ")", "->", "Any", ":", "\n", "    ", "\"\"\" Loads model with desired weights. \"\"\"", "\n", "return", "ConstantVelocityHeading", "(", "config", ".", "seconds", ",", "helper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.submission.do_inference.do_inference_for_submission": [[23, 47], ["do_inference.load_model", "cv_preds.append", "load_model."], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.submission.do_inference.load_model"], ["", "def", "do_inference_for_submission", "(", "helper", ":", "PredictHelper", ",", "\n", "config", ":", "PredictionConfig", ",", "\n", "dataset_tokens", ":", "List", "[", "str", "]", ")", "->", "List", "[", "Prediction", "]", ":", "\n", "    ", "\"\"\"\n    Currently, this will make a submission with a constant velocity and heading model.\n    Fill in all the code needed to run your model on the test set here. You do not need to worry\n    about providing any of the parameters to this function since they are provided by the main function below.\n    You can test if your script works by evaluating on the val set.\n    :param helper: Instance of PredictHelper that wraps the nuScenes test set.\n    :param config: Instance of PredictionConfig.\n    :param dataset_tokens: Tokens of instance_sample pairs in the test set.\n    :return: List of predictions.\n    \"\"\"", "\n", "\n", "# User: Fill in the path to the model weights here.", "\n", "path_to_model_weights", "=", "\"\"", "\n", "\n", "cv_heading", "=", "load_model", "(", "helper", ",", "config", ",", "path_to_model_weights", ")", "\n", "\n", "cv_preds", "=", "[", "]", "\n", "for", "token", "in", "dataset_tokens", ":", "\n", "        ", "cv_preds", ".", "append", "(", "cv_heading", "(", "token", ")", ")", "\n", "\n", "", "return", "cv_preds", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.submission.do_inference.main": [[49, 68], ["nuscenes.NuScenes", "nuscenes.prediction.PredictHelper", "nuscenes.eval.prediction.splits.get_prediction_challenge_split", "nuscenes.eval.prediction.config.load_prediction_config", "do_inference.do_inference_for_submission", "json.dump", "prediction.serialize", "open", "os.path.join"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.prediction.splits.get_prediction_challenge_split", "home.repos.pwc.inspect_result.fpthink_v2b.prediction.config.load_prediction_config", "home.repos.pwc.inspect_result.fpthink_v2b.submission.do_inference.do_inference_for_submission", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "def", "main", "(", "version", ":", "str", ",", "data_root", ":", "str", ",", "split_name", ":", "str", ",", "output_dir", ":", "str", ",", "submission_name", ":", "str", ",", "config_name", ":", "str", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Makes predictions for a submission to the nuScenes prediction challenge.\n    :param version: NuScenes version.\n    :param data_root: Directory storing NuScenes data.\n    :param split_name: Data split to run inference on.\n    :param output_dir: Directory to store the output file.\n    :param submission_name: Name of the submission to use for the results file.\n    :param config_name: Name of config file to use.\n    \"\"\"", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "version", ",", "dataroot", "=", "data_root", ")", "\n", "helper", "=", "PredictHelper", "(", "nusc", ")", "\n", "dataset", "=", "get_prediction_challenge_split", "(", "split_name", ")", "\n", "config", "=", "load_prediction_config", "(", "helper", ",", "config_name", ")", "\n", "\n", "predictions", "=", "do_inference_for_submission", "(", "helper", ",", "config", ",", "dataset", ")", "\n", "predictions", "=", "[", "prediction", ".", "serialize", "(", ")", "for", "prediction", "in", "predictions", "]", "\n", "json", ".", "dump", "(", "predictions", ",", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "f\"{submission_name}_inference.json\"", ")", ",", "\"w\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.loaders.interpolate_tracking_boxes": [[17, 54], ["loaders.interpolate_tracking_boxes.interp_float"], "function", ["None"], ["def", "interpolate_tracking_boxes", "(", "left_box", ":", "TrackingBox", ",", "right_box", ":", "TrackingBox", ",", "right_ratio", ":", "float", ")", "->", "TrackingBox", ":", "\n", "    ", "\"\"\"\n    Linearly interpolate box parameters between two boxes.\n    :param left_box: A Trackingbox.\n    :param right_box: Another TrackingBox\n    :param right_ratio: Weight given to the right box.\n    :return: The interpolated TrackingBox.\n    \"\"\"", "\n", "def", "interp_list", "(", "left", ",", "right", ",", "rratio", ")", ":", "\n", "        ", "return", "tuple", "(", "\n", "(", "1.0", "-", "rratio", ")", "*", "np", ".", "array", "(", "left", ",", "dtype", "=", "float", ")", "\n", "+", "rratio", "*", "np", ".", "array", "(", "right", ",", "dtype", "=", "float", ")", "\n", ")", "\n", "\n", "", "def", "interp_float", "(", "left", ",", "right", ",", "rratio", ")", ":", "\n", "        ", "return", "(", "1.0", "-", "rratio", ")", "*", "float", "(", "left", ")", "+", "rratio", "*", "float", "(", "right", ")", "\n", "\n", "# Interpolate quaternion.", "\n", "", "rotation", "=", "Quaternion", ".", "slerp", "(", "\n", "q0", "=", "Quaternion", "(", "left_box", ".", "rotation", ")", ",", "\n", "q1", "=", "Quaternion", "(", "right_box", ".", "rotation", ")", ",", "\n", "amount", "=", "right_ratio", "\n", ")", ".", "elements", "\n", "\n", "# Score will remain -1 for GT.", "\n", "tracking_score", "=", "interp_float", "(", "left_box", ".", "tracking_score", ",", "right_box", ".", "tracking_score", ",", "right_ratio", ")", "\n", "\n", "return", "TrackingBox", "(", "sample_token", "=", "right_box", ".", "sample_token", ",", "\n", "translation", "=", "interp_list", "(", "left_box", ".", "translation", ",", "right_box", ".", "translation", ",", "right_ratio", ")", ",", "\n", "size", "=", "interp_list", "(", "left_box", ".", "size", ",", "right_box", ".", "size", ",", "right_ratio", ")", ",", "\n", "rotation", "=", "rotation", ",", "\n", "velocity", "=", "interp_list", "(", "left_box", ".", "velocity", ",", "right_box", ".", "velocity", ",", "right_ratio", ")", ",", "\n", "ego_translation", "=", "interp_list", "(", "left_box", ".", "ego_translation", ",", "right_box", ".", "ego_translation", ",", "\n", "right_ratio", ")", ",", "# May be inaccurate.", "\n", "tracking_id", "=", "right_box", ".", "tracking_id", ",", "\n", "tracking_name", "=", "right_box", ".", "tracking_name", ",", "\n", "tracking_score", "=", "tracking_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.loaders.interpolate_tracks": [[56, 94], ["collections.defaultdict", "collections.defaultdict", "tracks_by_timestamp.items", "tracks_by_timestamp.keys", "collections.defaultdict.items", "tracks_by_id[].append", "track_timestamps_by_id[].append", "bisect.bisect", "loaders.interpolate_tracking_boxes", "tracks_by_timestamp[].append", "float"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.loaders.interpolate_tracking_boxes"], ["", "def", "interpolate_tracks", "(", "tracks_by_timestamp", ":", "DefaultDict", "[", "int", ",", "List", "[", "TrackingBox", "]", "]", ")", "->", "DefaultDict", "[", "int", ",", "List", "[", "TrackingBox", "]", "]", ":", "\n", "    ", "\"\"\"\n    Interpolate the tracks to fill in holes, especially since GT boxes with 0 lidar points are removed.\n    This interpolation does not take into account visibility. It interpolates despite occlusion.\n    :param tracks_by_timestamp: The tracks.\n    :return: The interpolated tracks.\n    \"\"\"", "\n", "# Group tracks by id.", "\n", "tracks_by_id", "=", "defaultdict", "(", "list", ")", "\n", "track_timestamps_by_id", "=", "defaultdict", "(", "list", ")", "\n", "for", "timestamp", ",", "tracking_boxes", "in", "tracks_by_timestamp", ".", "items", "(", ")", ":", "\n", "        ", "for", "tracking_box", "in", "tracking_boxes", ":", "\n", "            ", "tracks_by_id", "[", "tracking_box", ".", "tracking_id", "]", ".", "append", "(", "tracking_box", ")", "\n", "track_timestamps_by_id", "[", "tracking_box", ".", "tracking_id", "]", ".", "append", "(", "timestamp", ")", "\n", "\n", "# Interpolate missing timestamps for each track.", "\n", "", "", "timestamps", "=", "tracks_by_timestamp", ".", "keys", "(", ")", "\n", "interpolate_count", "=", "0", "\n", "for", "timestamp", "in", "timestamps", ":", "\n", "        ", "for", "tracking_id", ",", "track", "in", "tracks_by_id", ".", "items", "(", ")", ":", "\n", "            ", "if", "track_timestamps_by_id", "[", "tracking_id", "]", "[", "0", "]", "<=", "timestamp", "<=", "track_timestamps_by_id", "[", "tracking_id", "]", "[", "-", "1", "]", "and", "timestamp", "not", "in", "track_timestamps_by_id", "[", "tracking_id", "]", ":", "\n", "\n", "# Find the closest boxes before and after this timestamp.", "\n", "                ", "right_ind", "=", "bisect", "(", "track_timestamps_by_id", "[", "tracking_id", "]", ",", "timestamp", ")", "\n", "left_ind", "=", "right_ind", "-", "1", "\n", "right_timestamp", "=", "track_timestamps_by_id", "[", "tracking_id", "]", "[", "right_ind", "]", "\n", "left_timestamp", "=", "track_timestamps_by_id", "[", "tracking_id", "]", "[", "left_ind", "]", "\n", "right_tracking_box", "=", "tracks_by_id", "[", "tracking_id", "]", "[", "right_ind", "]", "\n", "left_tracking_box", "=", "tracks_by_id", "[", "tracking_id", "]", "[", "left_ind", "]", "\n", "right_ratio", "=", "float", "(", "right_timestamp", "-", "timestamp", ")", "/", "(", "right_timestamp", "-", "left_timestamp", ")", "\n", "\n", "# Interpolate.", "\n", "tracking_box", "=", "interpolate_tracking_boxes", "(", "left_tracking_box", ",", "right_tracking_box", ",", "right_ratio", ")", "\n", "interpolate_count", "+=", "1", "\n", "tracks_by_timestamp", "[", "timestamp", "]", ".", "append", "(", "tracking_box", ")", "\n", "\n", "", "", "", "return", "tracks_by_timestamp", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.loaders.create_tracks": [[96, 171], ["nuscenes.utils.splits.create_splits_scenes", "set", "collections.defaultdict", "collections.defaultdict.keys", "nusc.get", "nusc.get", "nusc.get", "collections.defaultdict.items", "loaders.interpolate_tracks", "nusc.get", "set.add", "collections.defaultdict", "nusc.get", "collections.defaultdict", "scene_tracks.items", "collections.defaultdict.items", "scene_tracks.items", "collections.defaultdict", "numpy.mean", "sorted", "track_id_scores[].append", "tracks[].items"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_scenes", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.loaders.interpolate_tracks", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "create_tracks", "(", "all_boxes", ":", "EvalBoxes", ",", "nusc", ":", "NuScenes", ",", "eval_split", ":", "str", ",", "gt", ":", "bool", ")", "->", "Dict", "[", "str", ",", "Dict", "[", "int", ",", "List", "[", "TrackingBox", "]", "]", "]", ":", "\n", "    ", "\"\"\"\n    Returns all tracks for all scenes. Samples within a track are sorted in chronological order.\n    This can be applied either to GT or predictions.\n    :param all_boxes: Holds all GT or predicted boxes.\n    :param nusc: The NuScenes instance to load the sample information from.\n    :param eval_split: The evaluation split for which we create tracks.\n    :param gt: Whether we are creating tracks for GT or predictions\n    :return: The tracks.\n    \"\"\"", "\n", "# Only keep samples from this split.", "\n", "splits", "=", "create_splits_scenes", "(", ")", "\n", "scene_tokens", "=", "set", "(", ")", "\n", "for", "sample_token", "in", "all_boxes", ".", "sample_tokens", ":", "\n", "        ", "scene_token", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "[", "'scene_token'", "]", "\n", "scene", "=", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "if", "scene", "[", "'name'", "]", "in", "splits", "[", "eval_split", "]", ":", "\n", "            ", "scene_tokens", ".", "add", "(", "scene_token", ")", "\n", "\n", "# Tracks are stored as dict {scene_token: {timestamp: List[TrackingBox]}}.", "\n", "", "", "tracks", "=", "defaultdict", "(", "lambda", ":", "defaultdict", "(", "list", ")", ")", "\n", "\n", "# Init all scenes and timestamps to guarantee completeness.", "\n", "for", "scene_token", "in", "scene_tokens", ":", "\n", "# Init all timestamps in this scene.", "\n", "        ", "scene", "=", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "cur_sample_token", "=", "scene", "[", "'first_sample_token'", "]", "\n", "while", "True", ":", "\n", "# Initialize array for current timestamp.", "\n", "            ", "cur_sample", "=", "nusc", ".", "get", "(", "'sample'", ",", "cur_sample_token", ")", "\n", "tracks", "[", "scene_token", "]", "[", "cur_sample", "[", "'timestamp'", "]", "]", "=", "[", "]", "\n", "\n", "# Abort after the last sample.", "\n", "if", "cur_sample_token", "==", "scene", "[", "'last_sample_token'", "]", ":", "\n", "                ", "break", "\n", "\n", "# Move to next sample.", "\n", "", "cur_sample_token", "=", "cur_sample", "[", "'next'", "]", "\n", "\n", "# Group annotations wrt scene and timestamp.", "\n", "", "", "for", "sample_token", "in", "all_boxes", ".", "sample_tokens", ":", "\n", "        ", "sample_record", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "scene_token", "=", "sample_record", "[", "'scene_token'", "]", "\n", "tracks", "[", "scene_token", "]", "[", "sample_record", "[", "'timestamp'", "]", "]", "=", "all_boxes", ".", "boxes", "[", "sample_token", "]", "\n", "\n", "# Replace box scores with track score (average box score). This only affects the compute_thresholds method and", "\n", "# should be done before interpolation to avoid diluting the original scores with interpolated boxes.", "\n", "", "if", "not", "gt", ":", "\n", "        ", "for", "scene_id", ",", "scene_tracks", "in", "tracks", ".", "items", "(", ")", ":", "\n", "# For each track_id, collect the scores.", "\n", "            ", "track_id_scores", "=", "defaultdict", "(", "list", ")", "\n", "for", "timestamp", ",", "boxes", "in", "scene_tracks", ".", "items", "(", ")", ":", "\n", "                ", "for", "box", "in", "boxes", ":", "\n", "                    ", "track_id_scores", "[", "box", ".", "tracking_id", "]", ".", "append", "(", "box", ".", "tracking_score", ")", "\n", "\n", "# Compute average scores for each track.", "\n", "", "", "track_id_avg_scores", "=", "{", "}", "\n", "for", "tracking_id", ",", "scores", "in", "track_id_scores", ".", "items", "(", ")", ":", "\n", "                ", "track_id_avg_scores", "[", "tracking_id", "]", "=", "np", ".", "mean", "(", "scores", ")", "\n", "\n", "# Apply average score to each box.", "\n", "", "for", "timestamp", ",", "boxes", "in", "scene_tracks", ".", "items", "(", ")", ":", "\n", "                ", "for", "box", "in", "boxes", ":", "\n", "                    ", "box", ".", "tracking_score", "=", "track_id_avg_scores", "[", "box", ".", "tracking_id", "]", "\n", "\n", "# Interpolate GT and predicted tracks.", "\n", "", "", "", "", "for", "scene_token", "in", "tracks", ".", "keys", "(", ")", ":", "\n", "        ", "tracks", "[", "scene_token", "]", "=", "interpolate_tracks", "(", "tracks", "[", "scene_token", "]", ")", "\n", "\n", "if", "not", "gt", ":", "\n", "# Make sure predictions are sorted in in time. (Always true for GT).", "\n", "            ", "tracks", "[", "scene_token", "]", "=", "defaultdict", "(", "list", ",", "sorted", "(", "tracks", "[", "scene_token", "]", ".", "items", "(", ")", ",", "key", "=", "lambda", "kv", ":", "kv", "[", "0", "]", ")", ")", "\n", "\n", "", "", "return", "tracks", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.mot.MOTAccumulatorCustom.__init__": [[19, 21], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.mot.MOTAccumulatorCustom.new_event_dataframe_with_data": [[22, 39], ["pandas.MultiIndex.from_tuples", "pandas.DataFrame"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "new_event_dataframe_with_data", "(", "indices", ",", "events", ")", ":", "\n", "        ", "\"\"\"\n        Create a new DataFrame filled with data.\n        This version overwrites the original in MOTAccumulator achieves about 2x speedups.\n\n        Params\n        ------\n        indices: list\n            list of tuples (frameid, eventid)\n        events: list\n            list of events where each event is a list containing\n            'Type', 'OId', HId', 'D'\n        \"\"\"", "\n", "idx", "=", "pd", ".", "MultiIndex", ".", "from_tuples", "(", "indices", ",", "names", "=", "[", "'FrameId'", ",", "'Event'", "]", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "events", ",", "index", "=", "idx", ",", "columns", "=", "[", "'Type'", ",", "'OId'", ",", "'HId'", ",", "'D'", "]", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.mot.MOTAccumulatorCustom.new_event_dataframe": [[40, 57], ["pandas.MultiIndex", "pandas.Categorical", "pandas.DataFrame", "collections.OrderedDict", "pandas.Series", "pandas.Series", "pandas.Series", "pandas.Series"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "new_event_dataframe", "(", ")", ":", "\n", "        ", "\"\"\" Create a new DataFrame for event tracking. \"\"\"", "\n", "idx", "=", "pd", ".", "MultiIndex", "(", "levels", "=", "[", "[", "]", ",", "[", "]", "]", ",", "codes", "=", "[", "[", "]", ",", "[", "]", "]", ",", "names", "=", "[", "'FrameId'", ",", "'Event'", "]", ")", "\n", "cats", "=", "pd", ".", "Categorical", "(", "[", "]", ",", "categories", "=", "[", "'RAW'", ",", "'FP'", ",", "'MISS'", ",", "'SWITCH'", ",", "'MATCH'", "]", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "\n", "OrderedDict", "(", "[", "\n", "(", "'Type'", ",", "pd", ".", "Series", "(", "cats", ")", ")", ",", "# Type of event. One of FP (false positive), MISS, SWITCH, MATCH", "\n", "(", "'OId'", ",", "pd", ".", "Series", "(", "dtype", "=", "object", ")", ")", ",", "\n", "# Object ID or -1 if FP. Using float as missing values will be converted to NaN anyways.", "\n", "(", "'HId'", ",", "pd", ".", "Series", "(", "dtype", "=", "object", ")", ")", ",", "\n", "# Hypothesis ID or NaN if MISS. Using float as missing values will be converted to NaN anyways.", "\n", "(", "'D'", ",", "pd", ".", "Series", "(", "dtype", "=", "float", ")", ")", ",", "# Distance or NaN when FP or MISS", "\n", "]", ")", ",", "\n", "index", "=", "idx", "\n", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.mot.MOTAccumulatorCustom.events": [[58, 64], ["mot.MOTAccumulatorCustom.new_event_dataframe_with_data"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.mot.MOTAccumulatorCustom.new_event_dataframe_with_data"], ["", "@", "property", "\n", "def", "events", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "dirty_events", ":", "\n", "            ", "self", ".", "cached_events_df", "=", "MOTAccumulatorCustom", ".", "new_event_dataframe_with_data", "(", "self", ".", "_indices", ",", "self", ".", "_events", ")", "\n", "self", ".", "dirty_events", "=", "False", "\n", "", "return", "self", ".", "cached_events_df", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.mot.MOTAccumulatorCustom.merge_event_dataframes": [[65, 132], ["itertools.count", "itertools.count", "mot.MOTAccumulatorCustom.new_event_dataframe", "isinstance", "df.copy", "r.append.append.append", "mapping_infos.append", "max", "numpy.isnan", "df.copy.index.map", "dict", "copy[].map", "dict", "copy[].map", "r.append.append.index.get_level_values().max", "r.append.append.index.get_level_values().unique", "str", "copy[].dropna().unique", "str", "copy[].dropna().unique", "r.append.append.index.get_level_values", "next", "next", "r.append.append.index.get_level_values", "copy[].dropna", "copy[].dropna"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.count", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.count", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.mot.MOTAccumulatorCustom.new_event_dataframe", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["", "@", "staticmethod", "\n", "def", "merge_event_dataframes", "(", "dfs", ",", "update_frame_indices", "=", "True", ",", "update_oids", "=", "True", ",", "update_hids", "=", "True", ",", "\n", "return_mappings", "=", "False", ")", ":", "\n", "        ", "\"\"\"Merge dataframes.\n\n        Params\n        ------\n        dfs : list of pandas.DataFrame or MotAccumulator\n            A list of event containers to merge\n\n        Kwargs\n        ------\n        update_frame_indices : boolean, optional\n            Ensure that frame indices are unique in the merged container\n        update_oids : boolean, unique\n            Ensure that object ids are unique in the merged container\n        update_hids : boolean, unique\n            Ensure that hypothesis ids are unique in the merged container\n        return_mappings : boolean, unique\n            Whether or not to return mapping information\n\n        Returns\n        -------\n        df : pandas.DataFrame\n            Merged event data frame\n        \"\"\"", "\n", "\n", "mapping_infos", "=", "[", "]", "\n", "new_oid", "=", "count", "(", ")", "\n", "new_hid", "=", "count", "(", ")", "\n", "\n", "r", "=", "MOTAccumulatorCustom", ".", "new_event_dataframe", "(", ")", "\n", "for", "df", "in", "dfs", ":", "\n", "\n", "            ", "if", "isinstance", "(", "df", ",", "MOTAccumulatorCustom", ")", ":", "\n", "                ", "df", "=", "df", ".", "events", "\n", "\n", "", "copy", "=", "df", ".", "copy", "(", ")", "\n", "infos", "=", "{", "}", "\n", "\n", "# Update index", "\n", "if", "update_frame_indices", ":", "\n", "                ", "next_frame_id", "=", "max", "(", "r", ".", "index", ".", "get_level_values", "(", "0", ")", ".", "max", "(", ")", "+", "1", ",", "\n", "r", ".", "index", ".", "get_level_values", "(", "0", ")", ".", "unique", "(", ")", ".", "shape", "[", "0", "]", ")", "\n", "if", "np", ".", "isnan", "(", "next_frame_id", ")", ":", "\n", "                    ", "next_frame_id", "=", "0", "\n", "", "copy", ".", "index", "=", "copy", ".", "index", ".", "map", "(", "lambda", "x", ":", "(", "x", "[", "0", "]", "+", "next_frame_id", ",", "x", "[", "1", "]", ")", ")", "\n", "infos", "[", "'frame_offset'", "]", "=", "next_frame_id", "\n", "\n", "# Update object / hypothesis ids", "\n", "", "if", "update_oids", ":", "\n", "                ", "oid_map", "=", "dict", "(", "[", "oid", ",", "str", "(", "next", "(", "new_oid", ")", ")", "]", "for", "oid", "in", "copy", "[", "'OId'", "]", ".", "dropna", "(", ")", ".", "unique", "(", ")", ")", "\n", "copy", "[", "'OId'", "]", "=", "copy", "[", "'OId'", "]", ".", "map", "(", "lambda", "x", ":", "oid_map", "[", "x", "]", ",", "na_action", "=", "'ignore'", ")", "\n", "infos", "[", "'oid_map'", "]", "=", "oid_map", "\n", "\n", "", "if", "update_hids", ":", "\n", "                ", "hid_map", "=", "dict", "(", "[", "hid", ",", "str", "(", "next", "(", "new_hid", ")", ")", "]", "for", "hid", "in", "copy", "[", "'HId'", "]", ".", "dropna", "(", ")", ".", "unique", "(", ")", ")", "\n", "copy", "[", "'HId'", "]", "=", "copy", "[", "'HId'", "]", ".", "map", "(", "lambda", "x", ":", "hid_map", "[", "x", "]", ",", "na_action", "=", "'ignore'", ")", "\n", "infos", "[", "'hid_map'", "]", "=", "hid_map", "\n", "\n", "", "r", "=", "r", ".", "append", "(", "copy", ")", "\n", "mapping_infos", ".", "append", "(", "infos", ")", "\n", "\n", "", "if", "return_mappings", ":", "\n", "            ", "return", "r", ",", "mapping_infos", "\n", "", "else", ":", "\n", "            ", "return", "r", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.__init__": [[34, 91], ["len", "nuscenes.eval.tracking.constants.MOT_METRIC_MAP.values"], "methods", ["None"], ["# Count the positives.", "\n", "npos", "=", "len", "(", "[", "1", "for", "gt_box", "in", "gt_boxes", ".", "all", "if", "gt_box", ".", "detection_name", "==", "class_name", "]", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Found {} GT of class {} out of {} total across {} samples.\"", ".", "\n", "format", "(", "npos", ",", "class_name", ",", "len", "(", "gt_boxes", ".", "all", ")", ",", "len", "(", "gt_boxes", ".", "sample_tokens", ")", ")", ")", "\n", "\n", "# For missing classes in the GT, return a data structure corresponding to no predictions.", "\n", "", "if", "npos", "==", "0", ":", "\n", "        ", "return", "DetectionMetricData", ".", "no_predictions", "(", ")", "\n", "\n", "# Organize the predictions in a single list.", "\n", "", "pred_boxes_list", "=", "[", "box", "for", "box", "in", "pred_boxes", ".", "all", "if", "box", ".", "detection_name", "==", "class_name", "]", "\n", "pred_confs", "=", "[", "box", ".", "detection_score", "for", "box", "in", "pred_boxes_list", "]", "\n", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Found {} PRED of class {} out of {} total across {} samples.\"", ".", "\n", "format", "(", "len", "(", "pred_confs", ")", ",", "class_name", ",", "len", "(", "pred_boxes", ".", "all", ")", ",", "len", "(", "pred_boxes", ".", "sample_tokens", ")", ")", ")", "\n", "\n", "# Sort by confidence.", "\n", "", "sortind", "=", "[", "i", "for", "(", "v", ",", "i", ")", "in", "sorted", "(", "(", "v", ",", "i", ")", "for", "(", "i", ",", "v", ")", "in", "enumerate", "(", "pred_confs", ")", ")", "]", "[", ":", ":", "-", "1", "]", "\n", "\n", "# Do the actual matching.", "\n", "tp", "=", "[", "]", "# Accumulator of true positives.", "\n", "fp", "=", "[", "]", "# Accumulator of false positives.", "\n", "conf", "=", "[", "]", "# Accumulator of confidences.", "\n", "\n", "# match_data holds the extra metrics we calculate for each match.", "\n", "match_data", "=", "{", "'trans_err'", ":", "[", "]", ",", "\n", "'vel_err'", ":", "[", "]", ",", "\n", "'scale_err'", ":", "[", "]", ",", "\n", "'orient_err'", ":", "[", "]", ",", "\n", "'attr_err'", ":", "[", "]", ",", "\n", "'conf'", ":", "[", "]", "}", "\n", "\n", "# ---------------------------------------------", "\n", "# Match and accumulate match data.", "\n", "# ---------------------------------------------", "\n", "\n", "taken", "=", "set", "(", ")", "# Initially no gt bounding box is matched.", "\n", "for", "ind", "in", "sortind", ":", "\n", "        ", "pred_box", "=", "pred_boxes_list", "[", "ind", "]", "\n", "min_dist", "=", "np", ".", "inf", "\n", "match_gt_idx", "=", "None", "\n", "\n", "for", "gt_idx", ",", "gt_box", "in", "enumerate", "(", "gt_boxes", "[", "pred_box", ".", "sample_token", "]", ")", ":", "\n", "\n", "# Find closest match among ground truth boxes", "\n", "            ", "if", "gt_box", ".", "detection_name", "==", "class_name", "and", "not", "(", "pred_box", ".", "sample_token", ",", "gt_idx", ")", "in", "taken", ":", "\n", "                ", "this_distance", "=", "dist_fcn", "(", "gt_box", ",", "pred_box", ")", "\n", "if", "this_distance", "<", "min_dist", ":", "\n", "                    ", "min_dist", "=", "this_distance", "\n", "match_gt_idx", "=", "gt_idx", "\n", "\n", "# If the closest match is close enough according to threshold we have a match!", "\n", "", "", "", "is_match", "=", "min_dist", "<", "dist_th", "\n", "\n", "if", "is_match", ":", "\n", "            ", "taken", ".", "add", "(", "(", "pred_box", ".", "sample_token", ",", "match_gt_idx", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate": [[92, 205], ["nuscenes.eval.tracking.data_classes.TrackingMetricData", "set", "algo.TrackingEvaluation.tracks_gt.values", "nuscenes.eval.tracking.utils.create_motmetrics", "algo.TrackingEvaluation.compute_thresholds", "enumerate", "numpy.sum", "nuscenes.eval.tracking.constants.MOT_METRIC_MAP.items", "print", "scene_tracks_gt.values", "print", "numpy.isnan", "algo.TrackingEvaluation.accumulate_threshold", "accumulators.append", "algo.TrackingEvaluation.name_gen", "nuscenes.eval.tracking.utils.create_motmetrics.compute", "thresh_metrics.append", "len", "pandas.concat", "numpy.isnan", "len", "len", "sorted", "numpy.sum", "nuscenes.eval.tracking.data_classes.TrackingMetricData.set_metric", "nuscenes.eval.tracking.utils.print_threshold_metrics", "numpy.unique", "len", "numpy.unique", "len", "numpy.all", "numpy.concatenate", "all_values.extend", "len", "nuscenes.eval.tracking.constants.MOT_METRIC_MAP.keys", "nuscenes.eval.tracking.utils.create_motmetrics.compute.to_dict", "numpy.isnan", "pandas.concat.get", "len", "len", "set.add", "len", "zip", "numpy.logical_not", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.create_motmetrics", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.compute_thresholds", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate_threshold", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.set_metric", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.print_threshold_metrics", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["\n", "#  Update tp, fp and confs.", "\n", "tp", ".", "append", "(", "1", ")", "\n", "fp", ".", "append", "(", "0", ")", "\n", "conf", ".", "append", "(", "pred_box", ".", "detection_score", ")", "\n", "\n", "# Since it is a match, update match data also.", "\n", "gt_box_match", "=", "gt_boxes", "[", "pred_box", ".", "sample_token", "]", "[", "match_gt_idx", "]", "\n", "\n", "match_data", "[", "'trans_err'", "]", ".", "append", "(", "center_distance", "(", "gt_box_match", ",", "pred_box", ")", ")", "\n", "match_data", "[", "'vel_err'", "]", ".", "append", "(", "velocity_l2", "(", "gt_box_match", ",", "pred_box", ")", ")", "\n", "match_data", "[", "'scale_err'", "]", ".", "append", "(", "1", "-", "scale_iou", "(", "gt_box_match", ",", "pred_box", ")", ")", "\n", "\n", "# Barrier orientation is only determined up to 180 degree. (For cones orientation is discarded later)", "\n", "period", "=", "np", ".", "pi", "if", "class_name", "==", "'barrier'", "else", "2", "*", "np", ".", "pi", "\n", "match_data", "[", "'orient_err'", "]", ".", "append", "(", "yaw_diff", "(", "gt_box_match", ",", "pred_box", ",", "period", "=", "period", ")", ")", "\n", "\n", "match_data", "[", "'attr_err'", "]", ".", "append", "(", "1", "-", "attr_acc", "(", "gt_box_match", ",", "pred_box", ")", ")", "\n", "match_data", "[", "'conf'", "]", ".", "append", "(", "pred_box", ".", "detection_score", ")", "\n", "\n", "", "else", ":", "\n", "# No match. Mark this as a false positive.", "\n", "            ", "tp", ".", "append", "(", "0", ")", "\n", "fp", ".", "append", "(", "1", ")", "\n", "conf", ".", "append", "(", "pred_box", ".", "detection_score", ")", "\n", "\n", "# Check if we have any matches. If not, just return a \"no predictions\" array.", "\n", "", "", "if", "len", "(", "match_data", "[", "'trans_err'", "]", ")", "==", "0", ":", "\n", "        ", "return", "DetectionMetricData", ".", "no_predictions", "(", ")", "\n", "\n", "# ---------------------------------------------", "\n", "# Calculate and interpolate precision and recall", "\n", "# ---------------------------------------------", "\n", "\n", "# Accumulate.", "\n", "", "tp", "=", "np", ".", "cumsum", "(", "tp", ")", ".", "astype", "(", "float", ")", "\n", "fp", "=", "np", ".", "cumsum", "(", "fp", ")", ".", "astype", "(", "float", ")", "\n", "conf", "=", "np", ".", "array", "(", "conf", ")", "\n", "\n", "# Calculate precision and recall.", "\n", "prec", "=", "tp", "/", "(", "fp", "+", "tp", ")", "\n", "rec", "=", "tp", "/", "float", "(", "npos", ")", "\n", "\n", "rec_interp", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "DetectionMetricData", ".", "nelem", ")", "# 101 steps, from 0% to 100% recall.", "\n", "prec", "=", "np", ".", "interp", "(", "rec_interp", ",", "rec", ",", "prec", ",", "right", "=", "0", ")", "\n", "conf", "=", "np", ".", "interp", "(", "rec_interp", ",", "rec", ",", "conf", ",", "right", "=", "0", ")", "\n", "rec", "=", "rec_interp", "\n", "\n", "# ---------------------------------------------", "\n", "# Re-sample the match-data to match, prec, recall and conf.", "\n", "# ---------------------------------------------", "\n", "\n", "for", "key", "in", "match_data", ".", "keys", "(", ")", ":", "\n", "        ", "if", "key", "==", "\"conf\"", ":", "\n", "            ", "continue", "# Confidence is used as reference to align with fp and tp. So skip in this step.", "\n", "\n", "", "else", ":", "\n", "# For each match_data, we first calculate the accumulated mean.", "\n", "            ", "tmp", "=", "cummean", "(", "np", ".", "array", "(", "match_data", "[", "key", "]", ")", ")", "\n", "\n", "# Then interpolate based on the confidences. (Note reversing since np.interp needs increasing arrays)", "\n", "match_data", "[", "key", "]", "=", "np", ".", "interp", "(", "conf", "[", ":", ":", "-", "1", "]", ",", "match_data", "[", "'conf'", "]", "[", ":", ":", "-", "1", "]", ",", "tmp", "[", ":", ":", "-", "1", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "# ---------------------------------------------", "\n", "# Done. Instantiate MetricData and return", "\n", "# ---------------------------------------------", "\n", "", "", "return", "DetectionMetricData", "(", "recall", "=", "rec", ",", "\n", "precision", "=", "prec", ",", "\n", "confidence", "=", "conf", ",", "\n", "trans_err", "=", "match_data", "[", "'trans_err'", "]", ",", "\n", "vel_err", "=", "match_data", "[", "'vel_err'", "]", ",", "\n", "scale_err", "=", "match_data", "[", "'scale_err'", "]", ",", "\n", "orient_err", "=", "match_data", "[", "'orient_err'", "]", ",", "\n", "attr_err", "=", "match_data", "[", "'attr_err'", "]", ")", "\n", "\n", "\n", "", "def", "calc_ap", "(", "md", ":", "DetectionMetricData", ",", "min_recall", ":", "float", ",", "min_precision", ":", "float", ")", "->", "float", ":", "\n", "    ", "\"\"\" Calculated average precision. \"\"\"", "\n", "\n", "assert", "0", "<=", "min_precision", "<", "1", "\n", "assert", "0", "<=", "min_recall", "<=", "1", "\n", "\n", "prec", "=", "np", ".", "copy", "(", "md", ".", "precision", ")", "\n", "prec", "=", "prec", "[", "round", "(", "100", "*", "min_recall", ")", "+", "1", ":", "]", "# Clip low recalls. +1 to exclude the min recall bin.", "\n", "prec", "-=", "min_precision", "# Clip low precision", "\n", "prec", "[", "prec", "<", "0", "]", "=", "0", "\n", "return", "float", "(", "np", ".", "mean", "(", "prec", ")", ")", "/", "(", "1.0", "-", "min_precision", ")", "\n", "\n", "\n", "", "def", "calc_tp", "(", "md", ":", "DetectionMetricData", ",", "min_recall", ":", "float", ",", "metric_name", ":", "str", ")", "->", "float", ":", "\n", "    ", "\"\"\" Calculates true positive errors. \"\"\"", "\n", "\n", "first_ind", "=", "round", "(", "100", "*", "min_recall", ")", "+", "1", "# +1 to exclude the error at min recall.", "\n", "last_ind", "=", "md", ".", "max_recall_ind", "# First instance of confidence = 0 is index of max achieved recall.", "\n", "if", "last_ind", "<", "first_ind", ":", "\n", "        ", "return", "1.0", "# Assign 1 here. If this happens for all classes, the score for that TP metric will be 0.", "\n", "", "else", ":", "\n", "        ", "return", "float", "(", "np", ".", "mean", "(", "getattr", "(", "md", ",", "metric_name", ")", "[", "first_ind", ":", "last_ind", "+", "1", "]", ")", ")", "# +1 to include error at max recall.", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate_threshold": [[206, 294], ["tqdm.tqdm", "nuscenes.eval.tracking.mot.MOTAccumulatorCustom.merge_event_dataframes", "algo.TrackingEvaluation.tracks_gt.keys", "nuscenes.eval.tracking.mot.MOTAccumulatorCustom", "scene_tracks_gt.keys", "accs.append", "os.path.join", "os.makedirs", "nuscenes.eval.tracking.render.TrackingRenderer", "nuscenes.eval.tracking.mot.MOTAccumulatorCustom.update", "str", "numpy.ones", "numpy.array", "numpy.array", "sklearn.metrics.pairwise.euclidean_distances", "scores.extend", "nuscenes.eval.tracking.render.TrackingRenderer.render", "len", "len", "len", "len", "len", "numpy.all", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.mot.MOTAccumulatorCustom.merge_event_dataframes", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.compute_thresholds": [[295, 339], ["algo.TrackingEvaluation.accumulate_threshold", "numpy.array", "numpy.array.sort", "numpy.array", "numpy.max", "numpy.linspace().round", "numpy.interp", "list", "list", "list.reverse", "list.reverse", "len", "range", "list.tolist", "list.tolist", "len", "len", "len", "numpy.linspace", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate_threshold"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingConfig.__init__": [[16, 38], ["data_classes.TrackingMetricData.set_nelem", "sorted", "set", "set", "data_classes.TrackingConfig.class_range.keys", "class_range.keys"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.set_nelem", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["sys", ".", "path", ".", "append", "(", "\"..\"", ")", "\n", "from", "lidarseg", ".", "lidarseg_utils", "import", "colormap_to_colors", ",", "create_lidarseg_legend", "\n", "from", "utils", ".", "data_io", "import", "load_bin_file", "\n", "from", "utils", ".", "geometry_utils", "import", "view_points", ",", "transform_matrix", "\n", "\n", "\n", "class", "PointCloud", "(", "ABC", ")", ":", "\n", "    ", "\"\"\"\n    Abstract class for manipulating and viewing point clouds.\n    Every point cloud (lidar and radar) consists of points where:\n    - Dimensions 0, 1, 2 represent x, y, z coordinates.\n        These are modified when the point cloud is rotated or translated.\n    - All other dimensions are optional. Hence these have to be manually modified if the reference frame changes.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "points", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a point cloud and check it has the correct dimensions.\n        :param points: <np.float: d, n>. d-dimensional input point cloud matrix.\n        \"\"\"", "\n", "assert", "points", ".", "shape", "[", "0", "]", "==", "self", ".", "nbr_dims", "(", ")", ",", "'Error: Pointcloud points must have format: %d x n'", "%", "self", ".", "nbr_dims", "(", ")", "\n", "self", ".", "points", "=", "points", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingConfig.__eq__": [[39, 44], ["data_classes.TrackingConfig.serialize().keys", "data_classes.TrackingConfig.serialize", "numpy.array_equal", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "@", "staticmethod", "\n", "@", "abstractmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingConfig.serialize": [[45, 55], ["None"], "methods", ["None"], ["\n", "pass", "\n", "\n", "", "@", "classmethod", "\n", "@", "abstractmethod", "\n", "def", "from_file", "(", "cls", ",", "file_name", ":", "str", ")", "->", "'PointCloud'", ":", "\n", "        ", "\"\"\"\n        Loads point cloud from disk.\n        :param file_name: Path of the pointcloud file on disk.\n        :return: PointCloud instance.\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingConfig.deserialize": [[57, 67], ["cls"], "methods", ["None"], ["\n", "", "@", "classmethod", "\n", "def", "from_file_multisweep", "(", "cls", ",", "\n", "nusc", ":", "'NuScenes'", ",", "\n", "sample_rec", ":", "Dict", ",", "\n", "chan", ":", "str", ",", "\n", "ref_chan", ":", "str", ",", "\n", "nsweeps", ":", "int", "=", "5", ",", "\n", "min_distance", ":", "float", "=", "1.0", ")", "->", "Tuple", "[", "'PointCloud'", ",", "np", ".", "ndarray", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingConfig.dist_fcn_callable": [[68, 75], ["Exception"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.__init__": [[83, 104], ["numpy.full"], "methods", ["None"], ["# Get reference pose and timestamp.", "\n", "ref_sd_token", "=", "sample_rec", "[", "'data'", "]", "[", "ref_chan", "]", "\n", "ref_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "ref_sd_token", ")", "\n", "ref_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "ref_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "ref_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "ref_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "ref_time", "=", "1e-6", "*", "ref_sd_rec", "[", "'timestamp'", "]", "\n", "\n", "# Homogeneous transform from ego car frame to reference frame.", "\n", "ref_from_car", "=", "transform_matrix", "(", "ref_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_cs_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "True", ")", "\n", "\n", "# Homogeneous transformation matrix from global to _current_ ego car frame.", "\n", "car_from_global", "=", "transform_matrix", "(", "ref_pose_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_pose_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "True", ")", "\n", "\n", "# Aggregate current and previous sweeps.", "\n", "sample_data_token", "=", "sample_rec", "[", "'data'", "]", "[", "chan", "]", "\n", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n", "for", "_", "in", "range", "(", "nsweeps", ")", ":", "\n", "# Load up the pointcloud and remove points close to the sensor.", "\n", "            ", "current_pc", "=", "cls", ".", "from_file", "(", "osp", ".", "join", "(", "nusc", ".", "dataroot", ",", "current_sd_rec", "[", "'filename'", "]", ")", ")", "\n", "current_pc", ".", "remove_close", "(", "min_distance", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.__eq__": [[105, 110], ["data_classes.TrackingMetricData.serialize().keys", "data_classes.TrackingMetricData.serialize", "numpy.array_equal", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["# Get past pose.", "\n", "current_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "current_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "global_from_car", "=", "transform_matrix", "(", "current_pose_rec", "[", "'translation'", "]", ",", "\n", "Quaternion", "(", "current_pose_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "False", ")", "\n", "\n", "# Homogeneous transformation matrix from sensor coordinate frame to ego car frame.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.__setattr__": [[111, 117], ["numpy.array", "nuscenes.eval.common.data_classes.MetricData.__setattr__", "len", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.__setattr__"], ["current_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "current_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "car_from_current", "=", "transform_matrix", "(", "current_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "current_cs_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "False", ")", "\n", "\n", "# Fuse four transformation matrices into one and perform transform.", "\n", "trans_matrix", "=", "reduce", "(", "np", ".", "dot", ",", "[", "ref_from_car", ",", "car_from_global", ",", "global_from_car", ",", "car_from_current", "]", ")", "\n", "current_pc", ".", "transform", "(", "trans_matrix", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.set_metric": [[118, 121], ["data_classes.TrackingMetricData.__setattr__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.__setattr__"], ["\n", "# Add time vector which can be used as a temporal feature.", "\n", "time_lag", "=", "ref_time", "-", "1e-6", "*", "current_sd_rec", "[", "'timestamp'", "]", "# Positive difference.", "\n", "times", "=", "time_lag", "*", "np", ".", "ones", "(", "(", "1", ",", "current_pc", ".", "nbr_points", "(", ")", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.get_metric": [[122, 125], ["data_classes.TrackingMetricData.__getattribute__"], "methods", ["None"], ["all_times", "=", "np", ".", "hstack", "(", "(", "all_times", ",", "times", ")", ")", "\n", "\n", "# Merge with key pc.", "\n", "all_pc", ".", "points", "=", "np", ".", "hstack", "(", "(", "all_pc", ".", "points", ",", "current_pc", ".", "points", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.max_recall_ind": [[126, 138], ["numpy.nonzero", "len"], "methods", ["None"], ["\n", "# Abort if there are no previous sweeps.", "\n", "if", "current_sd_rec", "[", "'prev'", "]", "==", "''", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "current_sd_rec", "[", "'prev'", "]", ")", "\n", "\n", "", "", "return", "all_pc", ",", "all_times", "\n", "\n", "", "def", "nbr_points", "(", "self", ")", "->", "int", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.max_recall": [[139, 143], ["None"], "methods", ["None"], ["\n", "return", "self", ".", "points", ".", "shape", "[", "1", "]", "\n", "\n", "", "def", "subsample", "(", "self", ",", "ratio", ":", "float", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.serialize": [[144, 150], ["dict", "data_classes.TrackingMetricData.get_metric().tolist", "data_classes.TrackingMetricData.get_metric"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.get_metric"], ["\n", "selected_ind", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "0", ",", "self", ".", "nbr_points", "(", ")", ")", ",", "size", "=", "int", "(", "self", ".", "nbr_points", "(", ")", "*", "ratio", ")", ")", "\n", "self", ".", "points", "=", "self", ".", "points", "[", ":", ",", "selected_ind", "]", "\n", "\n", "", "def", "remove_close", "(", "self", ",", "radius", ":", "float", ")", "->", "None", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.set_nelem": [[151, 154], ["None"], "methods", ["None"], ["        ", "\"\"\"\n        Removes point too close within a certain radius from origin.\n        :param radius: Radius below which points are removed.\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.deserialize": [[155, 162], ["cls", "cls.set_metric"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.set_metric"], ["\n", "x_filt", "=", "np", ".", "abs", "(", "self", ".", "points", "[", "0", ",", ":", "]", ")", "<", "radius", "\n", "y_filt", "=", "np", ".", "abs", "(", "self", ".", "points", "[", "1", ",", ":", "]", ")", "<", "radius", "\n", "not_close", "=", "np", ".", "logical_not", "(", "np", ".", "logical_and", "(", "x_filt", ",", "y_filt", ")", ")", "\n", "self", ".", "points", "=", "self", ".", "points", "[", ":", ",", "not_close", "]", "\n", "\n", "", "def", "translate", "(", "self", ",", "x", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.no_predictions": [[163, 172], ["cls", "numpy.zeros", "numpy.linspace", "cls.set_metric", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.set_metric"], ["\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "self", ".", "points", "[", "i", ",", ":", "]", "=", "self", ".", "points", "[", "i", ",", ":", "]", "+", "x", "[", "i", "]", "\n", "\n", "", "", "def", "rotate", "(", "self", ",", "rot_matrix", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.random_md": [[173, 182], ["cls", "numpy.linspace", "numpy.linspace", "cls.set_metric", "numpy.random.random"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.set_metric"], ["\n", "self", ".", "points", "[", ":", "3", ",", ":", "]", "=", "np", ".", "dot", "(", "rot_matrix", ",", "self", ".", "points", "[", ":", "3", ",", ":", "]", ")", "\n", "\n", "", "def", "transform", "(", "self", ",", "transf_matrix", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Applies a homogeneous transform.\n        :param transf_matrix: <np.float: 4, 4>. Homogenous transformation matrix.\n        \"\"\"", "\n", "self", ".", "points", "[", ":", "3", ",", ":", "]", "=", "transf_matrix", ".", "dot", "(", "np", ".", "vstack", "(", "(", "self", ".", "points", "[", ":", "3", ",", ":", "]", ",", "np", ".", "ones", "(", "self", ".", "nbr_points", "(", ")", ")", ")", ")", ")", "[", ":", "3", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.__init__": [[187, 200], ["None"], "methods", ["None"], ["y_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "marker_size", ":", "float", "=", "1", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Very simple method that applies a transformation and then scatter plots the points colored by height (z-value).\n        :param ax: Axes on which to render the points.\n        :param view: <np.float: n, n>. Defines an arbitrary projection (n <= 4).\n        :param x_lim: (min, max). x range for plotting.\n        :param y_lim: (min, max). y range for plotting.\n        :param marker_size: Marker size.\n        \"\"\"", "\n", "self", ".", "_render_helper", "(", "2", ",", "ax", ",", "view", ",", "x_lim", ",", "y_lim", ",", "marker_size", ")", "\n", "\n", "", "def", "render_intensity", "(", "self", ",", "\n", "ax", ":", "Axes", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.add_label_metric": [[201, 204], ["float"], "methods", ["None"], ["view", ":", "np", ".", "ndarray", "=", "np", ".", "eye", "(", "4", ")", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "y_lim", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "-", "20", ",", "20", ")", ",", "\n", "marker_size", ":", "float", "=", "1", ")", "->", "None", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.add_runtime": [[205, 207], ["None"], "methods", ["None"], ["        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.compute_metric": [[208, 222], ["list", "float", "data_classes.TrackingMetrics.label_metrics[].values", "len", "float", "float", "numpy.nansum", "numpy.nanmean"], "methods", ["None"], ["\n", "self", ".", "_render_helper", "(", "3", ",", "ax", ",", "view", ",", "x_lim", ",", "y_lim", ",", "marker_size", ")", "\n", "\n", "", "def", "_render_helper", "(", "self", ",", "\n", "color_channel", ":", "int", ",", "\n", "ax", ":", "Axes", ",", "\n", "view", ":", "np", ".", "ndarray", ",", "\n", "x_lim", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "y_lim", ":", "Tuple", "[", "float", ",", "float", "]", ",", "\n", "marker_size", ":", "float", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.serialize": [[223, 232], ["dict", "data_classes.TrackingMetrics.cfg.serialize", "data_classes.TrackingMetrics.label_metrics.keys", "data_classes.TrackingMetrics.compute_metric"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.compute_metric"], ["\n", "points", "=", "view_points", "(", "self", ".", "points", "[", ":", "3", ",", ":", "]", ",", "view", ",", "normalize", "=", "False", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "self", ".", "points", "[", "color_channel", ",", ":", "]", ",", "s", "=", "marker_size", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.deserialize": [[233, 242], ["data_classes.TrackingConfig.deserialize", "cls", "cls.add_runtime"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.add_runtime"], ["ax", ".", "set_xlim", "(", "x_lim", "[", "0", "]", ",", "x_lim", "[", "1", "]", ")", "\n", "ax", ".", "set_ylim", "(", "y_lim", "[", "0", "]", ",", "y_lim", "[", "1", "]", ")", "\n", "\n", "\n", "", "", "class", "LidarPointCloud", "(", "PointCloud", ")", ":", "\n", "\n", "    ", "@", "staticmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.__eq__": [[243, 250], ["None"], "methods", ["None"], ["\n", "return", "4", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_file", "(", "cls", ",", "file_name", ":", "str", ")", "->", "'LidarPointCloud'", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingBox.__init__": [[255, 279], ["nuscenes.eval.common.data_classes.EvalBox.__init__", "type", "numpy.any", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["assert", "file_name", ".", "endswith", "(", "'.bin'", ")", ",", "'Unsupported filetype {}'", ".", "format", "(", "file_name", ")", "\n", "\n", "scan", "=", "np", ".", "fromfile", "(", "file_name", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "points", "=", "scan", ".", "reshape", "(", "(", "-", "1", ",", "5", ")", ")", "[", ":", ",", ":", "cls", ".", "nbr_dims", "(", ")", "]", "\n", "return", "cls", "(", "points", ".", "T", ")", "\n", "\n", "\n", "", "", "class", "RadarPointCloud", "(", "PointCloud", ")", ":", "\n", "\n", "# Class-level settings for radar pointclouds, see from_file().", "\n", "    ", "invalid_states", "=", "[", "0", "]", "# type: List[int]", "\n", "dynprop_states", "=", "range", "(", "7", ")", "# type: List[int] # Use [0, 2, 6] for moving objects only.", "\n", "ambig_states", "=", "[", "3", "]", "# type: List[int]", "\n", "\n", "@", "classmethod", "\n", "def", "disable_filters", "(", "cls", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Disable all radar filter settings.\n        Use this method to plot all radar returns.\n        Note that this method affects the global settings.\n        \"\"\"", "\n", "cls", ".", "invalid_states", "=", "list", "(", "range", "(", "18", ")", ")", "\n", "cls", ".", "dynprop_states", "=", "list", "(", "range", "(", "8", ")", ")", "\n", "cls", ".", "ambig_states", "=", "list", "(", "range", "(", "5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingBox.__eq__": [[280, 291], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "default_filters", "(", "cls", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Set the defaults for all radar filter settings.\n        Note that this method affects the global settings.\n        \"\"\"", "\n", "cls", ".", "invalid_states", "=", "[", "0", "]", "\n", "cls", ".", "dynprop_states", "=", "range", "(", "7", ")", "\n", "cls", ".", "ambig_states", "=", "[", "3", "]", "\n", "\n", "", "@", "staticmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingBox.serialize": [[292, 305], ["None"], "methods", ["None"], ["        ", "\"\"\"\n        Returns the number of dimensions.\n        :return: Number of dimensions.\n        \"\"\"", "\n", "return", "18", "\n", "\n", "", "@", "classmethod", "\n", "def", "from_file", "(", "cls", ",", "\n", "file_name", ":", "str", ",", "\n", "invalid_states", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "dynprop_states", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "ambig_states", ":", "List", "[", "int", "]", "=", "None", ")", "->", "'RadarPointCloud'", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingBox.deserialize": [[307, 321], ["cls", "tuple", "tuple", "tuple", "tuple", "tuple", "int", "float"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.__init__": [[326, 328], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.__getitem__": [[329, 331], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.__eq__": [[332, 337], ["data_classes.TrackingMetricDataList.md.keys"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set": [[338, 341], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.serialize": [[342, 344], ["value.serialize", "data_classes.TrackingMetricDataList.md.items"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.deserialize": [[345, 351], ["cls", "content.items", "cls.set", "metric_data_cls.deserialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize"], []], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.evaluate.TrackingEval.__init__": [[39, 107], ["os.path.exists", "os.path.join", "nuscenes.NuScenes", "nuscenes.eval.common.loaders.load_prediction", "nuscenes.eval.common.loaders.load_gt", "nuscenes.eval.common.loaders.add_center_dist", "nuscenes.eval.common.loaders.add_center_dist", "nuscenes.eval.common.loaders.filter_eval_boxes", "nuscenes.eval.common.loaders.filter_eval_boxes", "nuscenes.eval.tracking.loaders.create_tracks", "nuscenes.eval.tracking.loaders.create_tracks", "os.path.isdir", "os.makedirs", "os.path.isdir", "os.makedirs", "print", "set", "set", "print", "print"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.load_prediction", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.load_gt", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.add_center_dist", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.add_center_dist", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.loaders.create_tracks", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.loaders.create_tracks", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["\n", "def", "__init__", "(", "self", ",", "\n", "nusc", ":", "NuScenes", ",", "\n", "config", ":", "DetectionConfig", ",", "\n", "result_path", ":", "str", ",", "\n", "eval_set", ":", "str", ",", "\n", "output_dir", ":", "str", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a DetectionEval object.\n        :param nusc: A NuScenes object.\n        :param config: A DetectionConfig object.\n        :param result_path: Path of the nuScenes JSON result file.\n        :param eval_set: The dataset split to evaluate on, e.g. train, val or test.\n        :param output_dir: Folder to save plots and results to.\n        :param verbose: Whether to print to stdout.\n        \"\"\"", "\n", "self", ".", "nusc", "=", "nusc", "\n", "self", ".", "result_path", "=", "result_path", "\n", "self", ".", "eval_set", "=", "eval_set", "\n", "self", ".", "output_dir", "=", "output_dir", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "cfg", "=", "config", "\n", "\n", "# Check result file exists.", "\n", "assert", "os", ".", "path", ".", "exists", "(", "result_path", ")", ",", "'Error: The result file does not exist!'", "\n", "\n", "# Make dirs.", "\n", "self", ".", "plot_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'plots'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "output_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "output_dir", ")", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "plot_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "plot_dir", ")", "\n", "\n", "# Load data.", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'Initializing nuScenes detection evaluation'", ")", "\n", "", "self", ".", "pred_boxes", ",", "self", ".", "meta", "=", "load_prediction", "(", "self", ".", "result_path", ",", "self", ".", "cfg", ".", "max_boxes_per_sample", ",", "DetectionBox", ",", "\n", "verbose", "=", "verbose", ")", "\n", "self", ".", "gt_boxes", "=", "load_gt", "(", "self", ".", "nusc", ",", "self", ".", "eval_set", ",", "DetectionBox", ",", "verbose", "=", "verbose", ")", "\n", "\n", "assert", "set", "(", "self", ".", "pred_boxes", ".", "sample_tokens", ")", "==", "set", "(", "self", ".", "gt_boxes", ".", "sample_tokens", ")", ",", "\"Samples in split doesn't match samples in predictions.\"", "\n", "\n", "# Add center distances.", "\n", "self", ".", "pred_boxes", "=", "add_center_dist", "(", "nusc", ",", "self", ".", "pred_boxes", ")", "\n", "self", ".", "gt_boxes", "=", "add_center_dist", "(", "nusc", ",", "self", ".", "gt_boxes", ")", "\n", "\n", "# Filter boxes (distance, points per box, etc.).", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Filtering predictions'", ")", "\n", "", "self", ".", "pred_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "self", ".", "pred_boxes", ",", "self", ".", "cfg", ".", "class_range", ",", "verbose", "=", "verbose", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Filtering ground truth annotations'", ")", "\n", "", "self", ".", "gt_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "self", ".", "gt_boxes", ",", "self", ".", "cfg", ".", "class_range", ",", "verbose", "=", "verbose", ")", "\n", "\n", "self", ".", "sample_tokens", "=", "self", ".", "gt_boxes", ".", "sample_tokens", "\n", "\n", "", "def", "evaluate", "(", "self", ")", "->", "Tuple", "[", "DetectionMetrics", ",", "DetectionMetricDataList", "]", ":", "\n", "        ", "\"\"\"\n        Performs the actual evaluation.\n        :return: A tuple of high-level and the raw metric data.\n        \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.evaluate.TrackingEval.evaluate": [[108, 178], ["time.time", "nuscenes.eval.tracking.data_classes.TrackingMetrics", "nuscenes.eval.tracking.data_classes.TrackingMetricDataList", "nuscenes.eval.tracking.data_classes.TrackingMetrics.add_runtime", "print", "nuscenes.eval.tracking.algo.TrackingEvaluation", "nuscenes.eval.tracking.algo.TrackingEvaluation.accumulate", "nuscenes.eval.tracking.data_classes.TrackingMetricDataList.set", "evaluate.TrackingEval.evaluate.accumulate_class"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.add_runtime", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.algo.TrackingEvaluation.accumulate", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["# -----------------------------------", "\n", "# Step 1: Accumulate metric data for all classes and distance thresholds.", "\n", "# -----------------------------------", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Accumulating metric data...'", ")", "\n", "", "metric_data_list", "=", "DetectionMetricDataList", "(", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "md", "=", "accumulate", "(", "self", ".", "gt_boxes", ",", "self", ".", "pred_boxes", ",", "class_name", ",", "self", ".", "cfg", ".", "dist_fcn_callable", ",", "dist_th", ")", "\n", "metric_data_list", ".", "set", "(", "class_name", ",", "dist_th", ",", "md", ")", "\n", "\n", "# -----------------------------------", "\n", "# Step 2: Calculate metrics from the data.", "\n", "# -----------------------------------", "\n", "", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Calculating metrics...'", ")", "\n", "", "metrics", "=", "DetectionMetrics", "(", "self", ".", "cfg", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "# Compute APs.", "\n", "            ", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "metric_data", "=", "metric_data_list", "[", "(", "class_name", ",", "dist_th", ")", "]", "\n", "ap", "=", "calc_ap", "(", "metric_data", ",", "self", ".", "cfg", ".", "min_recall", ",", "self", ".", "cfg", ".", "min_precision", ")", "\n", "metrics", ".", "add_label_ap", "(", "class_name", ",", "dist_th", ",", "ap", ")", "\n", "\n", "# Compute TP metrics.", "\n", "", "for", "metric_name", "in", "TP_METRICS", ":", "\n", "                ", "metric_data", "=", "metric_data_list", "[", "(", "class_name", ",", "self", ".", "cfg", ".", "dist_th_tp", ")", "]", "\n", "if", "class_name", "in", "[", "'traffic_cone'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", ",", "'orient_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "elif", "class_name", "in", "[", "'barrier'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "else", ":", "\n", "                    ", "tp", "=", "calc_tp", "(", "metric_data", ",", "self", ".", "cfg", ".", "min_recall", ",", "metric_name", ")", "\n", "", "metrics", ".", "add_label_tp", "(", "class_name", ",", "metric_name", ",", "tp", ")", "\n", "\n", "# Compute evaluation time.", "\n", "", "", "metrics", ".", "add_runtime", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "\n", "return", "metrics", ",", "metric_data_list", "\n", "\n", "", "def", "render", "(", "self", ",", "metrics", ":", "DetectionMetrics", ",", "md_list", ":", "DetectionMetricDataList", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders various PR and TP curves.\n        :param metrics: DetectionMetrics instance.\n        :param md_list: DetectionMetricDataList instance.\n        \"\"\"", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Rendering PR and TP curves'", ")", "\n", "\n", "", "def", "savepath", "(", "name", ")", ":", "\n", "            ", "return", "os", ".", "path", ".", "join", "(", "self", ".", "plot_dir", ",", "name", "+", "'.pdf'", ")", "\n", "\n", "", "summary_plot", "(", "md_list", ",", "metrics", ",", "min_precision", "=", "self", ".", "cfg", ".", "min_precision", ",", "min_recall", "=", "self", ".", "cfg", ".", "min_recall", ",", "\n", "dist_th_tp", "=", "self", ".", "cfg", ".", "dist_th_tp", ",", "savepath", "=", "savepath", "(", "'summary'", ")", ")", "\n", "\n", "for", "detection_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "class_pr_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "self", ".", "cfg", ".", "min_precision", ",", "self", ".", "cfg", ".", "min_recall", ",", "\n", "savepath", "=", "savepath", "(", "detection_name", "+", "'_pr'", ")", ")", "\n", "\n", "class_tp_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "self", ".", "cfg", ".", "min_recall", ",", "self", ".", "cfg", ".", "dist_th_tp", ",", "\n", "savepath", "=", "savepath", "(", "detection_name", "+", "'_tp'", ")", ")", "\n", "\n", "", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "            ", "dist_pr_curve", "(", "md_list", ",", "metrics", ",", "dist_th", ",", "self", ".", "cfg", ".", "min_precision", ",", "self", ".", "cfg", ".", "min_recall", ",", "\n", "savepath", "=", "savepath", "(", "'dist_pr_'", "+", "str", "(", "dist_th", ")", ")", ")", "\n", "\n", "", "", "def", "main", "(", "self", ",", "\n", "plot_examples", ":", "int", "=", "0", ",", "\n", "render_curves", ":", "bool", "=", "True", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.evaluate.TrackingEval.render": [[179, 197], ["nuscenes.eval.tracking.render.summary_plot", "print", "os.path.join", "nuscenes.eval.tracking.render.recall_metric_curve", "evaluate.TrackingEval.render.savepath"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.summary_plot", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.recall_metric_curve"], ["\n", "if", "plot_examples", ">", "0", ":", "\n", "# Select a random but fixed subset to plot.", "\n", "            ", "random", ".", "seed", "(", "42", ")", "\n", "sample_tokens", "=", "list", "(", "self", ".", "sample_tokens", ")", "\n", "random", ".", "shuffle", "(", "sample_tokens", ")", "\n", "sample_tokens", "=", "sample_tokens", "[", ":", "plot_examples", "]", "\n", "\n", "# Visualize samples.", "\n", "example_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'examples'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "example_dir", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "example_dir", ")", "\n", "", "for", "sample_token", "in", "sample_tokens", ":", "\n", "                ", "visualize_sample", "(", "self", ".", "nusc", ",", "\n", "sample_token", ",", "\n", "self", ".", "gt_boxes", "if", "self", ".", "eval_set", "!=", "'test'", "else", "EvalBoxes", "(", ")", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.evaluate.TrackingEval.main": [[198, 226], ["evaluate.TrackingEval.evaluate", "metrics.serialize", "evaluate.TrackingEval.meta.copy", "print", "open", "json.dump", "open", "json.dump", "nuscenes.eval.tracking.utils.print_final_metrics", "evaluate.TrackingEval.render", "os.path.join", "os.path.join", "metric_data_list.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.evaluate", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.print_final_metrics", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["# Don't render test GT.", "\n", "self", ".", "pred_boxes", ",", "\n", "eval_range", "=", "max", "(", "self", ".", "cfg", ".", "class_range", ".", "values", "(", ")", ")", ",", "\n", "savepath", "=", "os", ".", "path", ".", "join", "(", "example_dir", ",", "'{}.png'", ".", "format", "(", "sample_token", ")", ")", ")", "\n", "\n", "# Run evaluation.", "\n", "", "", "metrics", ",", "metric_data_list", "=", "self", ".", "evaluate", "(", ")", "\n", "\n", "# Render PR and TP curves.", "\n", "if", "render_curves", ":", "\n", "            ", "self", ".", "render", "(", "metrics", ",", "metric_data_list", ")", "\n", "\n", "# Dump the metric data, meta and metrics to disk.", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Saving metrics to: %s'", "%", "self", ".", "output_dir", ")", "\n", "", "metrics_summary", "=", "metrics", ".", "serialize", "(", ")", "\n", "metrics_summary", "[", "'meta'", "]", "=", "self", ".", "meta", ".", "copy", "(", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'metrics_summary.json'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "metrics_summary", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'metrics_details.json'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "metric_data_list", ".", "serialize", "(", ")", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "# Print high-level metrics.", "\n", "", "print", "(", "'mAP: %.4f'", "%", "(", "metrics_summary", "[", "'mean_ap'", "]", ")", ")", "\n", "err_name_mapping", "=", "{", "\n", "'trans_err'", ":", "'mATE'", ",", "\n", "'scale_err'", ":", "'mASE'", ",", "\n", "'orient_err'", ":", "'mAOE'", ",", "\n", "'vel_err'", ":", "'mAVE'", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.__init__": [[112, 118], ["None"], "methods", ["None"], ["ax", ":", "Axis", "=", "None", ")", "->", "None", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render": [[119, 166], ["print", "matplotlib.subplots", "matplotlib.scatter", "matplotlib.xlim", "matplotlib.ylim", "fig.savefig", "matplotlib.close", "nuscenes.utils.data_classes.Box", "nuscenes.utils.data_classes.Box.render", "nuscenes.utils.data_classes.Box", "os.path.join", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "render.TrackingRenderer.id2color.keys", "nuscenes.utils.data_classes.Box.render", "nuscenes.utils.data_classes.Box.render", "numpy.eye", "float", "float", "float", "numpy.eye", "numpy.eye", "hash", "hash", "hash"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render"], ["\n", "# Prepare axis.", "\n", "if", "ax", "is", "None", ":", "\n", "        ", "ax", "=", "setup_axis", "(", "title", "=", "PRETTY_DETECTION_NAMES", "[", "detection_name", "]", ",", "xlabel", "=", "'Recall'", ",", "ylabel", "=", "'Precision'", ",", "xlim", "=", "1", ",", "\n", "ylim", "=", "1", ",", "min_precision", "=", "min_precision", ",", "min_recall", "=", "min_recall", ")", "\n", "\n", "# Get recall vs precision values of given class for each distance threshold.", "\n", "", "data", "=", "md_list", ".", "get_class_data", "(", "detection_name", ")", "\n", "\n", "# Plot the recall vs. precision curve for each distance threshold.", "\n", "for", "md", ",", "dist_th", "in", "data", ":", "\n", "        ", "md", ":", "DetectionMetricData", "\n", "ap", "=", "metrics", ".", "get_label_ap", "(", "detection_name", ",", "dist_th", ")", "\n", "ax", ".", "plot", "(", "md", ".", "recall", ",", "md", ".", "precision", ",", "label", "=", "'Dist. : {}, AP: {:.1f}'", ".", "format", "(", "dist_th", ",", "ap", "*", "100", ")", ")", "\n", "\n", "", "ax", ".", "legend", "(", "loc", "=", "'best'", ")", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "\n", "", "", "def", "class_tp_curve", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n", "metrics", ":", "DetectionMetrics", ",", "\n", "detection_name", ":", "str", ",", "\n", "min_recall", ":", "float", ",", "\n", "dist_th_tp", ":", "float", ",", "\n", "savepath", ":", "str", "=", "None", ",", "\n", "ax", ":", "Axis", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Plot the true positive curve for the specified class.\n    :param md_list: DetectionMetricDataList instance.\n    :param metrics: DetectionMetrics instance.\n    :param detection_name:\n    :param min_recall: Minimum recall value.\n    :param dist_th_tp: The distance threshold used to determine matches.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    :param ax: Axes onto which to render.\n    \"\"\"", "\n", "# Get metric data for given detection class with tp distance threshold.", "\n", "md", "=", "md_list", "[", "(", "detection_name", ",", "dist_th_tp", ")", "]", "\n", "min_recall_ind", "=", "round", "(", "100", "*", "min_recall", ")", "\n", "if", "min_recall_ind", "<=", "md", ".", "max_recall_ind", ":", "\n", "# For traffic_cone and barrier only a subset of the metrics are plotted.", "\n", "        ", "rel_metrics", "=", "[", "m", "for", "m", "in", "TP_METRICS", "if", "not", "np", ".", "isnan", "(", "metrics", ".", "get_label_tp", "(", "detection_name", ",", "m", ")", ")", "]", "\n", "ylimit", "=", "max", "(", "[", "max", "(", "getattr", "(", "md", ",", "metric", ")", "[", "min_recall_ind", ":", "md", ".", "max_recall_ind", "+", "1", "]", ")", "for", "metric", "in", "rel_metrics", "]", ")", "*", "1.1", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.summary_plot": [[20, 48], ["len", "int", "matplotlib.subplots", "enumerate", "matplotlib.tight_layout", "numpy.ceil", "numpy.mod", "render.recall_metric_curve", "matplotlib.savefig", "matplotlib.close"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.recall_metric_curve"], ["Axis", "=", "Any", "\n", "\n", "\n", "def", "visualize_sample", "(", "nusc", ":", "NuScenes", ",", "\n", "sample_token", ":", "str", ",", "\n", "gt_boxes", ":", "EvalBoxes", ",", "\n", "pred_boxes", ":", "EvalBoxes", ",", "\n", "nsweeps", ":", "int", "=", "1", ",", "\n", "conf_th", ":", "float", "=", "0.15", ",", "\n", "eval_range", ":", "float", "=", "50", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "savepath", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Visualizes a sample from BEV with annotations and detection results.\n    :param nusc: NuScenes object.\n    :param sample_token: The nuScenes sample token.\n    :param gt_boxes: Ground truth boxes grouped by sample.\n    :param pred_boxes: Prediction grouped by sample.\n    :param nsweeps: Number of sweeps used for lidar visualization.\n    :param conf_th: The confidence threshold used to filter negatives.\n    :param eval_range: Range in meters beyond which boxes are ignored.\n    :param verbose: Whether to print to stdout.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    \"\"\"", "\n", "# Retrieve sensor & pose records.", "\n", "sample_rec", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "sd_record", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "\n", "cs_record", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "sd_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pose_record", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "sd_record", "[", "'ego_pose_token'", "]", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.recall_metric_curve": [[50, 106], ["nuscenes.eval.common.render.setup_axis", "md_list.md.items", "nuscenes.eval.common.render.setup_axis.legend", "matplotlib.tight_layout", "matplotlib.subplots", "md.get_metric", "nuscenes.eval.common.render.setup_axis.plot", "nuscenes.eval.common.render.setup_axis.set_yscale", "nuscenes.eval.common.render.setup_axis.set_ylim", "matplotlib.savefig", "matplotlib.close", "metric_name.upper", "numpy.where", "len", "numpy.isnan", "nuscenes.eval.common.render.setup_axis.set_ylim", "numpy.logical_not", "numpy.isnan"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.render.setup_axis", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricData.get_metric"], ["# Get boxes.", "\n", "boxes_gt_global", "=", "gt_boxes", "[", "sample_token", "]", "\n", "boxes_est_global", "=", "pred_boxes", "[", "sample_token", "]", "\n", "\n", "# Map GT boxes to lidar.", "\n", "boxes_gt", "=", "boxes_to_sensor", "(", "boxes_gt_global", ",", "pose_record", ",", "cs_record", ")", "\n", "\n", "# Map EST boxes to lidar.", "\n", "boxes_est", "=", "boxes_to_sensor", "(", "boxes_est_global", ",", "pose_record", ",", "cs_record", ")", "\n", "\n", "# Add scores to EST boxes.", "\n", "for", "box_est", ",", "box_est_global", "in", "zip", "(", "boxes_est", ",", "boxes_est_global", ")", ":", "\n", "        ", "box_est", ".", "score", "=", "box_est_global", ".", "detection_score", "\n", "\n", "# Get point cloud in lidar frame.", "\n", "", "pc", ",", "_", "=", "LidarPointCloud", ".", "from_file_multisweep", "(", "nusc", ",", "sample_rec", ",", "'LIDAR_TOP'", ",", "'LIDAR_TOP'", ",", "nsweeps", "=", "nsweeps", ")", "\n", "\n", "# Init axes.", "\n", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "9", ")", ")", "\n", "\n", "# Show point cloud.", "\n", "points", "=", "view_points", "(", "pc", ".", "points", "[", ":", "3", ",", ":", "]", ",", "np", ".", "eye", "(", "4", ")", ",", "normalize", "=", "False", ")", "\n", "dists", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "pc", ".", "points", "[", ":", "2", ",", ":", "]", "**", "2", ",", "axis", "=", "0", ")", ")", "\n", "colors", "=", "np", ".", "minimum", "(", "1", ",", "dists", "/", "eval_range", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "colors", ",", "s", "=", "0.2", ")", "\n", "\n", "# Show ego vehicle.", "\n", "ax", ".", "plot", "(", "0", ",", "0", ",", "'x'", ",", "color", "=", "'black'", ")", "\n", "\n", "# Show GT boxes.", "\n", "for", "box", "in", "boxes_gt", ":", "\n", "        ", "box", ".", "render", "(", "ax", ",", "view", "=", "np", ".", "eye", "(", "4", ")", ",", "colors", "=", "(", "'g'", ",", "'g'", ",", "'g'", ")", ",", "linewidth", "=", "2", ")", "\n", "\n", "# Show EST boxes.", "\n", "", "for", "box", "in", "boxes_est", ":", "\n", "# Show only predictions with a high score.", "\n", "        ", "assert", "not", "np", ".", "isnan", "(", "box", ".", "score", ")", ",", "'Error: Box score cannot be NaN!'", "\n", "if", "box", ".", "score", ">=", "conf_th", ":", "\n", "            ", "box", ".", "render", "(", "ax", ",", "view", "=", "np", ".", "eye", "(", "4", ")", ",", "colors", "=", "(", "'b'", ",", "'b'", ",", "'b'", ")", ",", "linewidth", "=", "1", ")", "\n", "\n", "# Limit visible range.", "\n", "", "", "axes_limit", "=", "eval_range", "+", "3", "# Slightly bigger to include boxes that extend beyond the range.", "\n", "ax", ".", "set_xlim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "ax", ".", "set_ylim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "\n", "# Show / save plot.", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'Rendering sample token %s'", "%", "sample_token", ")", "\n", "", "plt", ".", "title", "(", "sample_token", ")", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n", "\n", "", "", "def", "class_pr_curve", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.metrics.track_initialization_duration": [[17, 52], ["len", "len"], "function", ["None"], ["    ", "\"\"\" Makes sure that the metric returns an array of shape [batch_size, num_modes]. \"\"\"", "\n", "\n", "def", "_returns_array", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "result", "=", "function", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "if", "isinstance", "(", "result", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "result", "=", "np", ".", "array", "(", "[", "[", "result", "]", "]", ")", "\n", "\n", "", "elif", "result", ".", "ndim", "==", "1", ":", "\n", "            ", "result", "=", "np", ".", "expand_dims", "(", "result", ",", "0", ")", "\n", "\n", "", "return", "result", "\n", "\n", "", "return", "_returns_array", "\n", "\n", "\n", "", "@", "returns_2d_array", "\n", "def", "mean_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "\n", "stacked_ground_truth", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Efficiently compute mean L2 norm between trajectories and ground truths (pairwise over states).\n    :param stacked_trajs: Array of [batch_size, num_modes, horizon_length, state_dim].\n    :param stacked_ground_truth: Array of [batch_size, num_modes, horizon_length, state_dim].\n    :return: Array of mean L2 norms as [batch_size, num_modes].\n    \"\"\"", "\n", "return", "np", ".", "mean", "(", "np", ".", "linalg", ".", "norm", "(", "stacked_trajs", "-", "stacked_ground_truth", ",", "axis", "=", "-", "1", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "\n", "", "@", "returns_2d_array", "\n", "def", "max_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Efficiently compute max L2 norm between trajectories and ground truths (pairwise over states).\n    :pram stacked_trajs: Array of shape [num_modes, horizon_length, state_dim].\n    :pram stacked_ground_truth: Array of [num_modes, horizon_length, state_dim].\n    :return: Array of max L2 norms as [num_modes].\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.metrics.longest_gap_duration": [[54, 109], ["len", "set", "len", "len", "range", "numpy.maximum", "dfo[].index.get_level_values", "numpy.maximum"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["\n", "\n", "", "@", "returns_2d_array", "\n", "def", "final_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Efficiently compute the L2 norm between the last points in the trajectory.\n    :param stacked_trajs: Array of shape [num_modes, horizon_length, state_dim].\n    :param stacked_ground_truth: Array of shape [num_modes, horizon_length, state_dim].\n    :return: mean L2 norms between final points. Array of shape [num_modes].\n    \"\"\"", "\n", "# We use take to index the elements in the last dimension so that we can also", "\n", "# apply this function for a batch", "\n", "diff_of_last", "=", "np", ".", "take", "(", "stacked_trajs", ",", "[", "-", "1", "]", ",", "-", "2", ")", ".", "squeeze", "(", ")", "-", "np", ".", "take", "(", "stacked_ground_truth", ",", "[", "-", "1", "]", ",", "-", "2", ")", ".", "squeeze", "(", ")", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "diff_of_last", ",", "axis", "=", "-", "1", ")", "\n", "\n", "\n", "", "@", "returns_2d_array", "\n", "def", "miss_max_distances", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "tolerance", ":", "float", ")", "->", "np", ".", "array", ":", "\n", "    ", "\"\"\"\n    Efficiently compute 'miss' metric between trajectories and ground truths.\n    :param stacked_trajs: Array of shape [num_modes, horizon_length, state_dim].\n    :param stacked_ground_truth: Array of shape [num_modes, horizon_length, state_dim].\n    :param tolerance: max distance (m) for a 'miss' to be True.\n    :return: True iff there was a 'miss.' Size [num_modes].\n    \"\"\"", "\n", "return", "max_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ")", ">=", "tolerance", "\n", "\n", "\n", "", "@", "returns_2d_array", "\n", "def", "rank_metric_over_top_k_modes", "(", "metric_results", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ",", "\n", "ranking_func", ":", "str", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Compute a metric over all trajectories ranked by probability of each trajectory.\n    :param metric_results: 1-dimensional array of shape [batch_size, num_modes].\n    :param mode_probabilities: 1-dimensional array of shape [batch_size, num_modes].\n    :param ranking_func: Either 'min' or 'max'. How you want to metrics ranked over the top\n            k modes.\n    :return: Array of shape [num_modes].\n    \"\"\"", "\n", "\n", "if", "ranking_func", "==", "\"min\"", ":", "\n", "        ", "func", "=", "np", ".", "minimum", ".", "accumulate", "\n", "", "elif", "ranking_func", "==", "\"max\"", ":", "\n", "        ", "func", "=", "np", ".", "maximum", ".", "accumulate", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Parameter ranking_func must be one of min or max. Received {ranking_func}\"", ")", "\n", "\n", "", "p_sorted", "=", "np", ".", "flip", "(", "mode_probabilities", ".", "argsort", "(", "axis", "=", "-", "1", ")", ",", "axis", "=", "-", "1", ")", "\n", "indices", "=", "np", ".", "indices", "(", "metric_results", ".", "shape", ")", "\n", "\n", "sorted_metrics", "=", "metric_results", "[", "indices", "[", "0", "]", ",", "p_sorted", "]", "\n", "\n", "return", "func", "(", "sorted_metrics", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.metrics.motar": [[111, 136], ["numpy.maximum"], "function", ["None"], ["", "def", "miss_rate_top_k", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ",", "\n", "tolerance", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Compute the miss rate over the top k modes. \"\"\"", "\n", "\n", "miss_rate", "=", "miss_max_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ",", "tolerance", ")", "\n", "return", "rank_metric_over_top_k_modes", "(", "miss_rate", ",", "mode_probabilities", ",", "\"min\"", ")", "\n", "\n", "\n", "", "def", "min_ade_k", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Compute the min ade over the top k modes. \"\"\"", "\n", "\n", "ade", "=", "mean_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ")", "\n", "return", "rank_metric_over_top_k_modes", "(", "ade", ",", "mode_probabilities", ",", "\"min\"", ")", "\n", "\n", "\n", "", "def", "min_fde_k", "(", "stacked_trajs", ":", "np", ".", "ndarray", ",", "stacked_ground_truth", ":", "np", ".", "ndarray", ",", "\n", "mode_probabilities", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Compute the min fde over the top k modes. \"\"\"", "\n", "\n", "fde", "=", "final_distances", "(", "stacked_trajs", ",", "stacked_ground_truth", ")", "\n", "return", "rank_metric_over_top_k_modes", "(", "fde", ",", "mode_probabilities", ",", "\"min\"", ")", "\n", "\n", "\n", "", "def", "stack_ground_truth", "(", "ground_truth", ":", "np", ".", "ndarray", ",", "num_modes", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.metrics.mota_custom": [[138, 153], ["numpy.maximum"], "function", ["None"], ["\n", "return", "np", ".", "repeat", "(", "np", ".", "expand_dims", "(", "ground_truth", ",", "0", ")", ",", "num_modes", ",", "axis", "=", "0", ")", "\n", "\n", "\n", "", "class", "SerializableFunction", "(", "abc", ".", "ABC", ")", ":", "\n", "    ", "\"\"\" Function that can be serialized/deserialized to/from json. \"\"\"", "\n", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "serialize", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.metrics.motp_custom": [[155, 168], ["df.noraw[].sum"], "function", ["None"], ["@", "abc", ".", "abstractmethod", "\n", "def", "name", "(", "self", ",", ")", "->", "str", ":", "\n", "        ", "pass", "\n", "\n", "\n", "", "", "class", "Aggregator", "(", "SerializableFunction", ")", ":", "\n", "    ", "\"\"\" Function that can aggregate many metrics across predictions. \"\"\"", "\n", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "array", ":", "np", ".", "ndarray", ",", "**", "kwargs", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "pass", "\n", "\n", "\n", "", "", "class", "RowMean", "(", "Aggregator", ")", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.metrics.faf": [[170, 179], ["None"], "function", ["None"], ["    ", "def", "__call__", "(", "self", ",", "array", ":", "np", ".", "ndarray", ",", "**", "kwargs", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "array", ".", "mean", "(", "axis", "=", "0", ")", ".", "tolist", "(", ")", "\n", "\n", "", "def", "serialize", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "return", "{", "'name'", ":", "self", ".", "name", "}", "\n", "\n", "", "@", "property", "\n", "def", "name", "(", "self", ",", ")", "->", "str", ":", "\n", "        ", "return", "'RowMean'", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.metrics.num_fragmentations_custom": [[181, 203], ["dfo.loc[].Type.apply().diff", "diffs[].count", "len", "dfo.loc[].Type.apply"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.count"], ["", "", "class", "Metric", "(", "SerializableFunction", ")", ":", "\n", "\n", "    ", "@", "abc", ".", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "ground_truth", ":", "np", ".", "ndarray", ",", "prediction", ":", "Prediction", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "pass", "\n", "\n", "", "@", "property", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "aggregators", "(", "self", ",", ")", "->", "List", "[", "Aggregator", "]", ":", "\n", "        ", "pass", "\n", "\n", "", "@", "property", "\n", "@", "abc", ".", "abstractmethod", "\n", "def", "shape", "(", "self", ",", ")", "->", "str", ":", "\n", "        ", "pass", "\n", "\n", "\n", "", "", "def", "desired_number_of_modes", "(", "results", ":", "np", ".", "ndarray", ",", "\n", "k_to_report", ":", "List", "[", "int", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\" Ensures we return len(k_to_report) values even when results has less modes than what we want. \"\"\"", "\n", "return", "results", "[", ":", ",", "[", "min", "(", "k", ",", "results", ".", "shape", "[", "1", "]", ")", "-", "1", "for", "k", "in", "k_to_report", "]", "]", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.category_to_tracking_name": [[21, 45], ["None"], "function", ["None"], ["\n", "outstr", "=", "category_name", "\n", "\n", "if", "with_attributes", ":", "\n", "        ", "atts", "=", "[", "attribute", "[", "'name'", "]", "for", "attribute", "in", "attributes", "]", "\n", "if", "len", "(", "atts", ")", ">", "0", ":", "\n", "            ", "outstr", "=", "outstr", "+", "\"--\"", "+", "'.'", ".", "join", "(", "atts", ")", "\n", "\n", "", "", "return", "outstr", "\n", "\n", "\n", "", "def", "mask_decode", "(", "mask", ":", "dict", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Decode the mask from base64 string to binary string, then feed it to the external pycocotools library to get a mask.\n    :param mask: The mask dictionary with fields `size` and `counts`.\n    :return: A numpy array representing the binary mask for this class.\n    \"\"\"", "\n", "# Note that it is essential to copy the mask here. If we use the same variable we will overwrite the NuImage class", "\n", "# and cause the Jupyter Notebook to crash on some systems.", "\n", "new_mask", "=", "mask", ".", "copy", "(", ")", "\n", "new_mask", "[", "'counts'", "]", "=", "base64", ".", "b64decode", "(", "mask", "[", "'counts'", "]", ")", "\n", "return", "cocomask", ".", "decode", "(", "new_mask", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.metric_name_to_print_format": [[47, 62], ["None"], "function", ["None"], ["\n", "", "def", "get_font", "(", "fonts_valid", ":", "List", "[", "str", "]", "=", "None", ",", "font_size", ":", "int", "=", "15", ")", "->", "ImageFont", ":", "\n", "    ", "\"\"\"\n    Check if there is a desired font present in the user's system. If there is, use that font; otherwise, use a default\n    font.\n    :param fonts_valid: A list of fonts which are desirable.\n    :param font_size: The size of the font to set. Note that if the default font is used, then the font size\n        cannot be set.\n    :return: An ImageFont object to use as the font in a PIL image.\n    \"\"\"", "\n", "# If there are no desired fonts supplied, use a hardcoded list of fonts which are desirable.", "\n", "if", "fonts_valid", "is", "None", ":", "\n", "        ", "fonts_valid", "=", "[", "'FreeSerif.ttf'", ",", "'FreeSans.ttf'", ",", "'Century.ttf'", ",", "'Calibri.ttf'", ",", "'arial.ttf'", "]", "\n", "\n", "# Find a list of fonts within the user's system.", "\n", "", "fonts_in_sys", "=", "matplotlib", ".", "font_manager", ".", "findSystemFonts", "(", "fontpaths", "=", "None", ",", "fontext", "=", "'ttf'", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.print_final_metrics": [[64, 99], ["print", "metrics.label_metrics.keys", "print", "print", "print", "print", "print", "print", "class_name[].ljust", "print", "print", "metrics.compute_metric", "utils.metric_name_to_print_format", "print", "print", "m.upper", "numpy.isnan", "utils.metric_name_to_print_format", "metric_name.upper"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetrics.compute_metric", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.metric_name_to_print_format", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.metric_name_to_print_format"], ["fonts_in_sys", "=", "sorted", "(", "fonts_in_sys", ")", "\n", "# Of all the fonts found in the user's system, check if any of them are desired.", "\n", "for", "font_in_sys", "in", "fonts_in_sys", ":", "\n", "        ", "if", "any", "(", "os", ".", "path", ".", "basename", "(", "font_in_sys", ")", "in", "s", "for", "s", "in", "fonts_valid", ")", ":", "\n", "            ", "return", "ImageFont", ".", "truetype", "(", "font_in_sys", ",", "font_size", ")", "\n", "\n", "# If none of the fonts in the user's system are desirable, then use the default font.", "\n", "", "", "warnings", ".", "warn", "(", "'No suitable fonts were found in your system. '", "\n", "'A default font will be used instead (the font size will not be adjustable).'", ")", "\n", "return", "ImageFont", ".", "load_default", "(", ")", "\n", "\n", "\n", "", "def", "name_to_index_mapping", "(", "category", ":", "List", "[", "dict", "]", ")", "->", "Dict", "[", "str", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Build a mapping from name to index to look up index in O(1) time.\n    :param category: The nuImages category table.\n    :return: The mapping from category name to category index.\n    \"\"\"", "\n", "# The 0 index is reserved for non-labelled background; thus, the categories should start from index 1.", "\n", "# Also, sort the categories before looping so that the order is always the same (alphabetical).", "\n", "name_to_index", "=", "dict", "(", ")", "\n", "i", "=", "1", "\n", "sorted_category", ":", "List", "=", "sorted", "(", "category", ".", "copy", "(", ")", ",", "key", "=", "lambda", "k", ":", "k", "[", "'name'", "]", ")", "\n", "for", "c", "in", "sorted_category", ":", "\n", "# Ignore the vehicle.ego and flat.driveable_surface classes first; they will be mapped later.", "\n", "        ", "if", "c", "[", "'name'", "]", "!=", "'vehicle.ego'", "and", "c", "[", "'name'", "]", "!=", "'flat.driveable_surface'", ":", "\n", "            ", "name_to_index", "[", "c", "[", "'name'", "]", "]", "=", "i", "\n", "i", "+=", "1", "\n", "\n", "", "", "assert", "max", "(", "name_to_index", ".", "values", "(", ")", ")", "<", "24", ",", "'Error: There are {} classes (excluding vehicle.ego and flat.driveable_surface), '", "'but there should be 23. Please check your category.json'", ".", "format", "(", "max", "(", "name_to_index", ".", "values", "(", ")", ")", ")", "\n", "\n", "# Now map the vehicle.ego and flat.driveable_surface classes.", "\n", "name_to_index", "[", "'flat.driveable_surface'", "]", "=", "24", "\n", "name_to_index", "[", "'vehicle.ego'", "]", "=", "31", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.print_threshold_metrics": [[101, 134], ["print", "print", "print", "len", "list", "metrics[].keys", "metrics[].keys"], "function", ["None"], ["# Ensure that each class name is uniquely paired with a class index, and vice versa.", "\n", "assert", "len", "(", "name_to_index", ")", "==", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ",", "'Error: There are {} class names but {} class indices'", ".", "format", "(", "len", "(", "name_to_index", ")", ",", "\n", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ")", "\n", "\n", "return", "name_to_index", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.create_motmetrics": [[136, 178], ["MetricsHost", "warnings.filterwarnings", "warnings.filterwarnings", "MetricsHost.register", "MetricsHost.register", "MetricsHost.register", "MetricsHost.register", "MetricsHost.register", "MetricsHost.register", "MetricsHost.register", "MetricsHost.register", "getattr"], "function", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.__init__": [[15, 58], ["nuscenes.eval.panoptic.panoptic_seg_evaluator.PanopticEval.__init__", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_classes", ":", "int", ",", "\n", "min_stuff_cls_id", ":", "int", ",", "\n", "ignore", ":", "List", "[", "int", "]", "=", "None", ",", "\n", "offset", ":", "int", "=", "2", "**", "32", ",", "\n", "min_points", ":", "int", "=", "30", ",", "\n", "iou_thr", ":", "float", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        :param n_classes: Number of classes.\n        :param min_stuff_cls_id: Minimum stuff class index, 11 for nuScenes-panoptic challenge classes.\n        :param ignore: List of ignored class index.\n        :param offset: Largest instance number in a frame.\n        :param min_points: minimal number of points to consider instances in GT.\n        :param iou_thr: IoU threshold to consider as a true positive. Note \"iou_thr > 0.5\" is required for Panoptic\n            Quality metric and its variants.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "n_classes", "=", "n_classes", ",", "ignore", "=", "ignore", ",", "offset", "=", "offset", ",", "min_points", "=", "min_points", ")", "\n", "self", ".", "iou_thr", "=", "iou_thr", "\n", "assert", "self", ".", "iou_thr", ">=", "0.5", ",", "f'IoU threshold mush be >= 0.5, but {self.iou_thr} is given.'", "\n", "\n", "self", ".", "min_stuff_cls_id", "=", "min_stuff_cls_id", "\n", "\n", "# IoU stuff.", "\n", "self", ".", "px_iou_conf_matrix", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_classes", ",", "self", ".", "n_classes", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "# Panoptic stuff.", "\n", "self", ".", "pan_ids", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "pan_soft_ids", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "double", ")", "\n", "self", ".", "pan_tp", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "pan_iou", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "double", ")", "\n", "self", ".", "pan_fp", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "pan_fn", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "# Tracking stuff.", "\n", "self", ".", "sequences", "=", "[", "]", "\n", "self", ".", "preds", "=", "{", "}", "\n", "self", ".", "gts", "=", "{", "}", "\n", "self", ".", "intersects", "=", "{", "}", "\n", "self", ".", "intersects_ovr", "=", "{", "}", "\n", "\n", "# Per-class association quality stuff.", "\n", "self", ".", "pan_aq", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "double", ")", "\n", "self", ".", "pan_aq_ovr", "=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.update_dict_stat": [[59, 72], ["zip"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "update_dict_stat", "(", "stat_dict", ":", "Dict", "[", "int", ",", "int", "]", ",", "unique_ids", ":", "np", ".", "ndarray", ",", "unique_cnts", ":", "np", ".", "ndarray", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Update stats dict with new combo of ids and counts.\n        :param stat_dict: {class_id: counts}, a dict of stats for the counts of each class.\n        :param unique_ids: <np.int64, <k,>>, an array of class IDs.\n        :param unique_cnts: <np.int64, <k,>>, an array of counts for corresponding class IDs.\n        \"\"\"", "\n", "for", "uniqueid", ",", "counts", "in", "zip", "(", "unique_ids", ",", "unique_cnts", ")", ":", "\n", "            ", "if", "uniqueid", "in", "stat_dict", ":", "\n", "                ", "stat_dict", "[", "uniqueid", "]", "+=", "counts", "\n", "", "else", ":", "\n", "                ", "stat_dict", "[", "uniqueid", "]", "=", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.get_panoptic_track_stats": [[73, 142], ["numpy.unique", "numpy.unique", "numpy.logical_and", "numpy.unique", "numpy.array", "numpy.array", "panoptic_track_evaluator.PanopticTrackingEval.update_dict_stat", "panoptic_track_evaluator.PanopticTrackingEval.update_dict_stat", "numpy.zeros_like", "numpy.logical_and", "numpy.unique", "panoptic_track_evaluator.PanopticTrackingEval.update_dict_stat", "intersections.astype", "unions.astype", "enumerate", "enumerate", "numpy.logical_or"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.update_dict_stat", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.update_dict_stat", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.update_dict_stat"], ["", "", "", "def", "get_panoptic_track_stats", "(", "self", ",", "\n", "x_inst_in_cl", ":", "np", ".", "ndarray", ",", "\n", "y_inst_in_cl", ":", "np", ".", "ndarray", ",", "\n", "x_inst_row", ":", "np", ".", "ndarray", "=", "None", ",", "\n", "scene", ":", "str", "=", "None", ",", "\n", "cl", ":", "int", "=", "None", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "Dict", "[", "int", ",", "int", "]", ",", "\n", "Dict", "[", "int", ",", "int", "]", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Calculate class-specific panoptic tracking stats given predicted instances and target instances.\n        :param x_inst_in_cl: <np.int64: num_points>, instance IDs of each point for predicted instances.\n        :param y_inst_in_cl: <np.int64: num_points>, instance IDs of each point for target instances.\n        :param x_inst_row: <np.int64: num_points>, class-agnostic instance IDs of each point for predicted instances.\n        :param scene: str, name of scene.\n        :param cl: int, semantic class id.\n        :return: A tuple of MOPT stats:\n            {\n              counts_pred, # <np.int64, num_instances>, point counts of each predicted instance.\n              counts_gt,  # <np.int64, num_instances>, point counts of each ground truth instance.\n              gt_labels,  # <np.int64, num_instances>, instance ID of each ground truth instance.\n              pred_labels, # <np.int64, num_instances>, instance ID of each predicted instance.\n              id2idx_gt, # {instance ID: array index}, instance ID to array index mapping for ground truth instances.\n              id2idx_pred, # {instance ID: array index}, instance ID to array index mapping for predicted instances.\n              ious, # <np.float32, num_instances>, IoU scores between prediction and ground truth instance pair.\n            }\n        \"\"\"", "\n", "# Generate the areas for each unique instance in prediction.", "\n", "unique_pred", ",", "counts_pred", "=", "np", ".", "unique", "(", "x_inst_in_cl", "[", "x_inst_in_cl", ">", "0", "]", ",", "return_counts", "=", "True", ")", "\n", "id2idx_pred", "=", "{", "inst_id", ":", "idx", "for", "idx", ",", "inst_id", "in", "enumerate", "(", "unique_pred", ")", "}", "\n", "\n", "# Generate the areas for each unique instance in ground truth.", "\n", "unique_gt", ",", "counts_gt", "=", "np", ".", "unique", "(", "y_inst_in_cl", "[", "y_inst_in_cl", ">", "0", "]", ",", "return_counts", "=", "True", ")", "\n", "id2idx_gt", "=", "{", "inst_id", ":", "idx", "for", "idx", ",", "inst_id", "in", "enumerate", "(", "unique_gt", ")", "}", "\n", "\n", "# Generate intersection using offset.", "\n", "valid_combos", "=", "np", ".", "logical_and", "(", "x_inst_in_cl", ">", "0", ",", "y_inst_in_cl", ">", "0", ")", "\n", "offset_combo", "=", "x_inst_in_cl", "[", "valid_combos", "]", "+", "self", ".", "offset", "*", "y_inst_in_cl", "[", "valid_combos", "]", "\n", "unique_combo", ",", "counts_combo", "=", "np", ".", "unique", "(", "offset_combo", ",", "return_counts", "=", "True", ")", "\n", "\n", "# Per-class accumulated stats.", "\n", "if", "scene", "is", "not", "None", "and", "cl", "<", "self", ".", "min_stuff_cls_id", ":", "\n", "            ", "cl_preds", "=", "self", ".", "preds", "[", "scene", "]", "\n", "cl_gts", "=", "self", ".", "gts", "[", "scene", "]", "[", "cl", "]", "\n", "cl_intersects", "=", "self", ".", "intersects", "[", "scene", "]", "[", "cl", "]", "\n", "self", ".", "update_dict_stat", "(", "cl_gts", ",", "\n", "unique_gt", "[", "counts_gt", ">", "self", ".", "min_points", "]", ",", "\n", "counts_gt", "[", "counts_gt", ">", "self", ".", "min_points", "]", ")", "\n", "self", ".", "update_dict_stat", "(", "cl_preds", ",", "\n", "unique_pred", "[", "counts_pred", ">", "self", ".", "min_points", "]", ",", "\n", "counts_pred", "[", "counts_pred", ">", "self", ".", "min_points", "]", ")", "\n", "valid_combos_min_point", "=", "np", ".", "zeros_like", "(", "y_inst_in_cl", ")", "# instances which have more than self.min points", "\n", "for", "valid_id", "in", "unique_gt", "[", "counts_gt", ">", "self", ".", "min_points", "]", ":", "\n", "                ", "valid_combos_min_point", "=", "np", ".", "logical_or", "(", "valid_combos_min_point", ",", "y_inst_in_cl", "==", "valid_id", ")", "\n", "", "y_inst_in_cl", "=", "y_inst_in_cl", "*", "valid_combos_min_point", "\n", "valid_combos_", "=", "np", ".", "logical_and", "(", "x_inst_row", ">", "0", ",", "y_inst_in_cl", ">", "0", ")", "\n", "offset_combo_", "=", "x_inst_row", "[", "valid_combos_", "]", "+", "self", ".", "offset", "*", "y_inst_in_cl", "[", "valid_combos_", "]", "\n", "unique_combo_", ",", "counts_combo_", "=", "np", ".", "unique", "(", "offset_combo_", ",", "return_counts", "=", "True", ")", "\n", "self", ".", "update_dict_stat", "(", "cl_intersects", ",", "unique_combo_", ",", "counts_combo_", ")", "\n", "\n", "# Generate an intersection map, count the intersections with over 0.5 IoU as TP.", "\n", "", "gt_labels", "=", "unique_combo", "//", "self", ".", "offset", "\n", "pred_labels", "=", "unique_combo", "%", "self", ".", "offset", "\n", "gt_areas", "=", "np", ".", "array", "(", "[", "counts_gt", "[", "id2idx_gt", "[", "g_id", "]", "]", "for", "g_id", "in", "gt_labels", "]", ")", "\n", "pred_areas", "=", "np", ".", "array", "(", "[", "counts_pred", "[", "id2idx_pred", "[", "p_id", "]", "]", "for", "p_id", "in", "pred_labels", "]", ")", "\n", "intersections", "=", "counts_combo", "\n", "unions", "=", "gt_areas", "+", "pred_areas", "-", "intersections", "\n", "ious", "=", "intersections", ".", "astype", "(", "np", ".", "float32", ")", "/", "unions", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "return", "counts_pred", ",", "counts_gt", ",", "gt_labels", ",", "pred_labels", ",", "id2idx_gt", ",", "id2idx_pred", ",", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.add_batch_panoptic": [[143, 244], ["panoptic_track_evaluator.PanopticTrackingEval.sequences.append", "panoptic_track_evaluator.PanopticTrackingEval.get_panoptic_track_stats", "numpy.sum", "numpy.sum", "numpy.array", "numpy.array", "numpy.sum", "numpy.sum", "panoptic_track_evaluator.PanopticTrackingEval.get_panoptic_track_stats", "x_inst_in_cl_mask.astype", "y_inst_in_cl_mask.astype", "numpy.logical_and", "numpy.logical_and", "numpy.intersect1d", "zip", "range", "range", "range", "x_inst_in_cl_mask.astype", "y_inst_in_cl_mask.astype", "len", "len", "numpy.logical_not", "numpy.logical_not"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.get_panoptic_track_stats", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.get_panoptic_track_stats"], ["", "def", "add_batch_panoptic", "(", "self", ",", "\n", "scene", ":", "str", ",", "\n", "x_sem_row", ":", "List", "[", "np", ".", "ndarray", "]", ",", "\n", "x_inst_row", ":", "List", "[", "np", ".", "ndarray", "]", ",", "\n", "y_sem_row", ":", "List", "[", "np", ".", "ndarray", "]", ",", "\n", "y_inst_row", ":", "List", "[", "np", ".", "ndarray", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Add panoptic tracking metrics for one frame/batch.\n        :param scene: str, name of scene.\n        :param x_sem_row: [None, <np.int64: num_points>], predicted semantics.\n        :param x_inst_row: [None, <np.uint64: num_points>], predicted instances.\n        :param y_sem_row: [None, <np.int64: num_points>], target semantics.\n        :param y_inst_row: [None, <np.uint64: num_points>], target instances.\n        \"\"\"", "\n", "if", "scene", "not", "in", "self", ".", "sequences", ":", "\n", "            ", "self", ".", "sequences", ".", "append", "(", "scene", ")", "\n", "self", ".", "preds", "[", "scene", "]", "=", "{", "}", "\n", "self", ".", "gts", "[", "scene", "]", "=", "[", "{", "}", "for", "_", "in", "range", "(", "self", ".", "n_classes", ")", "]", "\n", "self", ".", "intersects", "[", "scene", "]", "=", "[", "{", "}", "for", "_", "in", "range", "(", "self", ".", "n_classes", ")", "]", "\n", "self", ".", "intersects_ovr", "[", "scene", "]", "=", "[", "{", "}", "for", "_", "in", "range", "(", "self", ".", "n_classes", ")", "]", "\n", "# Make sure instance IDs are non-zeros. Otherwise, they will be ignored. Note in nuScenes-panoptic,", "\n", "# instance IDs start from 1 already, so the following 2 lines of code are actually not necessary, but to be", "\n", "# consistent with the PanopticEval class in panoptic_seg_evaluator.py from 3rd party. We keep these 2 lines. It", "\n", "# means the actual instance IDs will start from 2 during metrics evaluation.", "\n", "", "x_inst_row", "[", "1", "]", "=", "x_inst_row", "[", "1", "]", "+", "1", "\n", "y_inst_row", "[", "1", "]", "=", "y_inst_row", "[", "1", "]", "+", "1", "\n", "\n", "# Only interested in points that are outside the void area (not in excluded classes).", "\n", "for", "cl", "in", "self", ".", "ignore", ":", "\n", "# Current Frame.", "\n", "            ", "gt_not_in_excl_mask", "=", "y_sem_row", "[", "1", "]", "!=", "cl", "# make a mask for class cl.", "\n", "# Remove all other points.", "\n", "x_sem_row", "[", "1", "]", "=", "x_sem_row", "[", "1", "]", "[", "gt_not_in_excl_mask", "]", "\n", "y_sem_row", "[", "1", "]", "=", "y_sem_row", "[", "1", "]", "[", "gt_not_in_excl_mask", "]", "\n", "x_inst_row", "[", "1", "]", "=", "x_inst_row", "[", "1", "]", "[", "gt_not_in_excl_mask", "]", "\n", "y_inst_row", "[", "1", "]", "=", "y_inst_row", "[", "1", "]", "[", "gt_not_in_excl_mask", "]", "\n", "\n", "# Previous Frame.", "\n", "if", "x_sem_row", "[", "0", "]", "is", "not", "None", ":", "# First frame.", "\n", "                ", "gt_not_in_excl_mask", "=", "y_sem_row", "[", "0", "]", "!=", "cl", "\n", "# Remove all other points.", "\n", "x_sem_row", "[", "0", "]", "=", "x_sem_row", "[", "0", "]", "[", "gt_not_in_excl_mask", "]", "\n", "y_sem_row", "[", "0", "]", "=", "y_sem_row", "[", "0", "]", "[", "gt_not_in_excl_mask", "]", "\n", "x_inst_row", "[", "0", "]", "=", "x_inst_row", "[", "0", "]", "[", "gt_not_in_excl_mask", "]", "\n", "y_inst_row", "[", "0", "]", "=", "y_inst_row", "[", "0", "]", "[", "gt_not_in_excl_mask", "]", "\n", "\n", "# First step is to count intersections > 0.5 IoU for each class (except the ignored ones).", "\n", "", "", "for", "cl", "in", "self", ".", "include", ":", "\n", "# Previous Frame.", "\n", "            ", "inst_prev", ",", "gt_labels_prev", ",", "tp_indexes_prev", "=", "None", ",", "None", ",", "None", "\n", "if", "x_sem_row", "[", "0", "]", "is", "not", "None", ":", "# First frame.", "\n", "                ", "x_inst_in_cl_mask", "=", "x_sem_row", "[", "0", "]", "==", "cl", "\n", "y_inst_in_cl_mask", "=", "y_sem_row", "[", "0", "]", "==", "cl", "\n", "\n", "# Get instance points in class (makes outside stuff 0).", "\n", "x_inst_in_cl", "=", "x_inst_row", "[", "0", "]", "*", "x_inst_in_cl_mask", ".", "astype", "(", "np", ".", "int64", ")", "\n", "y_inst_in_cl", "=", "y_inst_row", "[", "0", "]", "*", "y_inst_in_cl_mask", ".", "astype", "(", "np", ".", "int64", ")", "\n", "_", ",", "_", ",", "gt_labels_prev", ",", "inst_prev", ",", "_", ",", "_", ",", "ious", "=", "self", ".", "get_panoptic_track_stats", "(", "x_inst_in_cl", ",", "y_inst_in_cl", ")", "\n", "tp_indexes_prev", "=", "ious", ">", "self", ".", "iou_thr", "\n", "\n", "# Current Frame: get a class mask.", "\n", "", "x_inst_in_cl_mask", "=", "x_sem_row", "[", "1", "]", "==", "cl", "\n", "y_inst_in_cl_mask", "=", "y_sem_row", "[", "1", "]", "==", "cl", "\n", "\n", "# Get instance points in class (makes outside stuff 0).", "\n", "x_inst_in_cl", "=", "x_inst_row", "[", "1", "]", "*", "x_inst_in_cl_mask", ".", "astype", "(", "np", ".", "int64", ")", "\n", "y_inst_in_cl", "=", "y_inst_row", "[", "1", "]", "*", "y_inst_in_cl_mask", ".", "astype", "(", "np", ".", "int64", ")", "\n", "\n", "counts_pred", ",", "counts_gt", ",", "gt_labels", ",", "pred_labels", ",", "id2idx_gt", ",", "id2idx_pred", ",", "ious", "=", "self", ".", "get_panoptic_track_stats", "(", "x_inst_in_cl", ",", "y_inst_in_cl", ",", "x_inst_row", "[", "1", "]", ",", "scene", ",", "cl", ")", "\n", "inst_cur", "=", "pred_labels", "\n", "tp_indexes", "=", "ious", ">", "0.5", "\n", "\n", "self", ".", "pan_tp", "[", "cl", "]", "+=", "np", ".", "sum", "(", "tp_indexes", ")", "\n", "self", ".", "pan_iou", "[", "cl", "]", "+=", "np", ".", "sum", "(", "ious", "[", "tp_indexes", "]", ")", "\n", "\n", "matched_gt", "=", "np", ".", "array", "(", "[", "False", "]", "*", "len", "(", "id2idx_gt", ")", ")", "\n", "matched_gt", "[", "[", "id2idx_gt", "[", "g_id", "]", "for", "g_id", "in", "gt_labels", "[", "tp_indexes", "]", "]", "]", "=", "True", "\n", "matched_pred", "=", "np", ".", "array", "(", "[", "False", "]", "*", "len", "(", "id2idx_pred", ")", ")", "\n", "matched_pred", "[", "[", "id2idx_pred", "[", "p_id", "]", "for", "p_id", "in", "pred_labels", "[", "tp_indexes", "]", "]", "]", "=", "True", "\n", "\n", "# Count the FN.", "\n", "self", ".", "pan_fn", "[", "cl", "]", "+=", "np", ".", "sum", "(", "np", ".", "logical_and", "(", "counts_gt", ">=", "self", ".", "min_points", ",", "np", ".", "logical_not", "(", "matched_gt", ")", ")", ")", "\n", "# Count the FP.", "\n", "self", ".", "pan_fp", "[", "cl", "]", "+=", "np", ".", "sum", "(", "np", ".", "logical_and", "(", "counts_pred", ">=", "self", ".", "min_points", ",", "np", ".", "logical_not", "(", "matched_pred", ")", ")", ")", "\n", "\n", "# Compute ID switches (IDS).", "\n", "if", "x_sem_row", "[", "0", "]", "is", "not", "None", "and", "cl", "<", "self", ".", "min_stuff_cls_id", ":", "# Skip first frame.", "\n", "                ", "gt_labels_prev", ",", "gt_labels", "=", "gt_labels_prev", "[", "tp_indexes_prev", "]", ",", "gt_labels", "[", "tp_indexes", "]", "\n", "inst_prev", ",", "inst_cur", "=", "inst_prev", "[", "tp_indexes_prev", "]", ",", "inst_cur", "[", "tp_indexes", "]", "\n", "ious", "=", "ious", "[", "tp_indexes", "]", "\n", "_", ",", "prev_ind", ",", "cur_ind", "=", "np", ".", "intersect1d", "(", "gt_labels_prev", ",", "gt_labels", ",", "return_indices", "=", "True", ")", "\n", "\n", "ids", ",", "soft_ids", "=", "0", ",", "0.0", "\n", "for", "prev_i", ",", "cur_i", "in", "zip", "(", "prev_ind", ",", "cur_ind", ")", ":", "\n", "                    ", "if", "inst_prev", "[", "prev_i", "]", "!=", "inst_cur", "[", "cur_i", "]", ":", "\n", "                        ", "ids", "+=", "1", "\n", "soft_ids", "+=", "ious", "[", "cur_i", "]", "\n", "\n", "", "", "self", ".", "pan_ids", "[", "cl", "]", "+=", "ids", "\n", "self", ".", "pan_soft_ids", "[", "cl", "]", "+=", "soft_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.get_ptq": [[245, 266], ["panoptic_track_evaluator.PanopticTrackingEval.pan_iou.astype", "numpy.maximum", "ptq_all[].mean", "soft_ptq_all[].mean", "panoptic_track_evaluator.PanopticTrackingEval.pan_ids.astype", "panoptic_track_evaluator.PanopticTrackingEval.pan_soft_ids.astype", "panoptic_track_evaluator.PanopticTrackingEval.pan_tp.astype", "panoptic_track_evaluator.PanopticTrackingEval.pan_fp.astype", "numpy.maximum", "panoptic_track_evaluator.PanopticTrackingEval.pan_fn.astype"], "methods", ["None"], ["", "", "", "def", "get_ptq", "(", "self", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Calculate PTQ metrics.\n        :return: (mean_PTQ, all_class_PTQ, mean_sPTQ, all_class_sPTQ).\n            mean_PTQ: <float64, 1>, mean PTQ score over all classes.\n            all_class_PTQ: <float64, num_classes,>, PTQ scores for all classes.\n            mean_sPTQ: <float64, 1>, mean soft-PTQ score over all classes.\n            all_class_sPTQ: <float64, num_classes,>, soft-PTQ scores for all classes.\n        \"\"\"", "\n", "iou", "=", "self", ".", "pan_iou", ".", "astype", "(", "np", ".", "double", ")", "\n", "ids", ",", "soft_ids", "=", "self", ".", "pan_ids", ".", "astype", "(", "np", ".", "double", ")", ",", "self", ".", "pan_soft_ids", ".", "astype", "(", "np", ".", "double", ")", "\n", "tp", ",", "fp", "=", "self", ".", "pan_tp", ".", "astype", "(", "np", ".", "double", ")", ",", "self", ".", "pan_fp", ".", "astype", "(", "np", ".", "double", ")", "\n", "tp_eps", ",", "fn", "=", "np", ".", "maximum", "(", "tp", ",", "self", ".", "eps", ")", ",", "self", ".", "pan_fn", ".", "astype", "(", "np", ".", "double", ")", "\n", "tp_half_fp_half_fn_eps", "=", "np", ".", "maximum", "(", "tp", "+", "0.5", "*", "fp", "+", "0.5", "*", "fn", ",", "self", ".", "eps", ")", "\n", "\n", "ptq_all", "=", "(", "(", "iou", "-", "ids", ")", "/", "tp_eps", ")", "*", "(", "tp", "/", "tp_half_fp_half_fn_eps", ")", "# Calculate PTQ of all classes.", "\n", "soft_ptq_all", "=", "(", "(", "iou", "-", "soft_ids", ")", "/", "tp_eps", ")", "*", "(", "tp", "/", "tp_half_fp_half_fn_eps", ")", "# Calculate soft-PTQ of all classes.", "\n", "mean_ptq", "=", "ptq_all", "[", "self", ".", "include", "]", ".", "mean", "(", ")", "# Mean PTQ over all classes except ignored classes.", "\n", "mean_soft_ptq", "=", "soft_ptq_all", "[", "self", ".", "include", "]", ".", "mean", "(", ")", "# Mean soft-PTQ over all classes except ignored classes.", "\n", "\n", "return", "mean_ptq", ",", "ptq_all", ",", "mean_soft_ptq", ",", "soft_ptq_all", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.get_lstq": [[267, 295], ["panoptic_track_evaluator.PanopticTrackingEval.getSemIoU", "numpy.sqrt", "numpy.sum", "numpy.sum", "len", "cl_gts.items", "cl_preds.items", "float"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getSemIoU"], ["", "def", "get_lstq", "(", "self", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Calculate Lidar Segmentation and Tracking Quality (LSTQ) metric. https://arxiv.org/pdf/2102.12472.pdf\n        :return: (LSTQ, S_assoc). LSTQ: <float64, 1>, LSTQ score over all classes. S_assoc: <float64, 1,>, S_assoc for\n            all classes.\n        \"\"\"", "\n", "num_tubes", "=", "[", "0", "]", "*", "self", ".", "n_classes", "\n", "for", "seq", "in", "self", ".", "sequences", ":", "\n", "            ", "for", "cl", "in", "self", ".", "include", ":", "\n", "                ", "cl_preds", "=", "self", ".", "preds", "[", "seq", "]", "\n", "cl_gts", "=", "self", ".", "gts", "[", "seq", "]", "[", "cl", "]", "\n", "cl_intersects", "=", "self", ".", "intersects", "[", "seq", "]", "[", "cl", "]", "\n", "outer_sum_iou", "=", "0.0", "\n", "num_tubes", "[", "cl", "]", "+=", "len", "(", "cl_gts", ")", "\n", "for", "gt_id", ",", "gt_size", "in", "cl_gts", ".", "items", "(", ")", ":", "\n", "                    ", "inner_sum_iou", "=", "0.0", "\n", "for", "pr_id", ",", "pr_size", "in", "cl_preds", ".", "items", "(", ")", ":", "\n", "                        ", "tpa_key", "=", "pr_id", "+", "self", ".", "offset", "*", "gt_id", "\n", "if", "tpa_key", "in", "cl_intersects", ":", "\n", "                            ", "tpa_ovr", "=", "cl_intersects", "[", "tpa_key", "]", "\n", "inner_sum_iou", "+=", "tpa_ovr", "*", "(", "tpa_ovr", "/", "(", "gt_size", "+", "pr_size", "-", "tpa_ovr", ")", ")", "\n", "", "", "outer_sum_iou", "+=", "inner_sum_iou", "/", "float", "(", "gt_size", ")", "\n", "", "self", ".", "pan_aq", "[", "cl", "]", "+=", "outer_sum_iou", "\n", "self", ".", "pan_aq_ovr", "+=", "outer_sum_iou", "\n", "", "", "s_assoc", "=", "np", ".", "sum", "(", "self", ".", "pan_aq", ")", "/", "np", ".", "sum", "(", "num_tubes", "[", "1", ":", "self", ".", "min_stuff_cls_id", "]", ")", "# num_things 1:11.", "\n", "s_cls", ",", "iou", "=", "self", ".", "getSemIoU", "(", ")", "\n", "lstq", "=", "np", ".", "sqrt", "(", "s_assoc", "*", "s_cls", ")", "\n", "return", "lstq", ",", "s_assoc", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.add_batch": [[296, 308], ["panoptic_track_evaluator.PanopticTrackingEval.addBatchSemIoU", "panoptic_track_evaluator.PanopticTrackingEval.add_batch_panoptic"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.addBatchSemIoU", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.add_batch_panoptic"], ["", "def", "add_batch", "(", "self", ",", "scene", ":", "str", ",", "x_sem", ":", "List", "[", "np", ".", "ndarray", "]", ",", "x_inst", ":", "List", "[", "np", ".", "ndarray", "]", ",", "y_sem", ":", "List", "[", "np", ".", "ndarray", "]", ",", "\n", "y_inst", ":", "List", "[", "np", ".", "ndarray", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Add semantic IoU and panoptic tracking metrics for one frame/batch.\n        :param scene: str, name of scene.\n        :param x_sem: [None, <np.int64: num_points>], predicted semantics.\n        :param x_inst: [None, <np.uint64: num_points>], predicted instances.\n        :param y_sem: [None, <np.int64: num_points>], target semantics.\n        :param y_inst: [None, <np.uint64: num_points>], target instances.\n        \"\"\"", "\n", "self", ".", "addBatchSemIoU", "(", "x_sem", "[", "1", "]", ",", "y_sem", "[", "1", "]", ")", "# Add to IoU calculation for checking purpose.", "\n", "self", ".", "add_batch_panoptic", "(", "scene", ",", "x_sem", ",", "x_inst", ",", "y_sem", ",", "y_inst", ")", "# Do panoptic tracking stuff.", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.__init__": [[47, 109], ["os.path.join", "os.path.exists", "nuscenes.eval.panoptic.utils.PanopticClassMapper", "len", "evaluate.NuScenesPanopticEval.mapper.things.keys", "evaluate.NuScenesPanopticEval.mapper.stuff.keys", "nuscenes.eval.panoptic.utils.get_samples_in_panoptic_eval_set", "dict", "os.path.join", "os.path.isfile", "hasattr", "ValueError", "print", "nuscenes.eval.panoptic.panoptic_track_evaluator.PanopticTrackingEval", "os.remove", "len", "evaluate.NuScenesPanopticEval.mapper.coarse_name_2_coarse_idx_mapping.items", "nuscenes.eval.panoptic.panoptic_seg_evaluator.PanopticEval", "getattr", "len", "len"], "methods", ["None"], ["result_path", ":", "str", ",", "\n", "eval_set", ":", "str", ",", "\n", "output_dir", ":", "str", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a DetectionEval object.\n        :param nusc: A NuScenes object.\n        :param config: A DetectionConfig object.\n        :param result_path: Path of the nuScenes JSON result file.\n        :param eval_set: The dataset split to evaluate on, e.g. train, val or test.\n        :param output_dir: Folder to save plots and results to.\n        :param verbose: Whether to print to stdout.\n        \"\"\"", "\n", "self", ".", "nusc", "=", "nusc", "\n", "self", ".", "result_path", "=", "result_path", "\n", "self", ".", "eval_set", "=", "eval_set", "\n", "self", ".", "output_dir", "=", "output_dir", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "cfg", "=", "config", "\n", "\n", "# Check result file exists.", "\n", "assert", "os", ".", "path", ".", "exists", "(", "result_path", ")", ",", "'Error: The result file does not exist!'", "\n", "\n", "# Make dirs.", "\n", "self", ".", "plot_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'plots'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "output_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "output_dir", ")", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "plot_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "plot_dir", ")", "\n", "\n", "# Load data.", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'Initializing nuScenes detection evaluation'", ")", "\n", "", "self", ".", "pred_boxes", ",", "self", ".", "meta", "=", "load_prediction", "(", "self", ".", "result_path", ",", "self", ".", "cfg", ".", "max_boxes_per_sample", ",", "DetectionBox", ",", "\n", "verbose", "=", "verbose", ")", "\n", "self", ".", "gt_boxes", "=", "load_gt", "(", "self", ".", "nusc", ",", "self", ".", "eval_set", ",", "DetectionBox", ",", "verbose", "=", "verbose", ")", "\n", "\n", "assert", "set", "(", "self", ".", "pred_boxes", ".", "sample_tokens", ")", "==", "set", "(", "self", ".", "gt_boxes", ".", "sample_tokens", ")", ",", "\"Samples in split doesn't match samples in predictions.\"", "\n", "\n", "# Add center distances.", "\n", "self", ".", "pred_boxes", "=", "add_center_dist", "(", "nusc", ",", "self", ".", "pred_boxes", ")", "\n", "self", ".", "gt_boxes", "=", "add_center_dist", "(", "nusc", ",", "self", ".", "gt_boxes", ")", "\n", "\n", "# Filter boxes (distance, points per box, etc.).", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Filtering predictions'", ")", "\n", "", "self", ".", "pred_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "self", ".", "pred_boxes", ",", "self", ".", "cfg", ".", "class_range", ",", "verbose", "=", "verbose", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Filtering ground truth annotations'", ")", "\n", "", "self", ".", "gt_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "self", ".", "gt_boxes", ",", "self", ".", "cfg", ".", "class_range", ",", "verbose", "=", "verbose", ")", "\n", "\n", "self", ".", "sample_tokens", "=", "self", ".", "gt_boxes", ".", "sample_tokens", "\n", "\n", "", "def", "evaluate", "(", "self", ")", "->", "Tuple", "[", "DetectionMetrics", ",", "DetectionMetricDataList", "]", ":", "\n", "        ", "\"\"\"\n        Performs the actual evaluation.\n        :return: A tuple of high-level and the raw metric data.\n        \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# -----------------------------------", "\n", "# Step 1: Accumulate metric data for all classes and distance thresholds.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.evaluate": [[110, 120], ["evaluate.NuScenesPanopticEval.save_result", "evaluate.NuScenesPanopticEval.evaluate_segmentation", "evaluate.NuScenesPanopticEval.evaluate_tracking"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.save_result", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.evaluate_segmentation", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.evaluate_tracking"], ["# -----------------------------------", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Accumulating metric data...'", ")", "\n", "", "metric_data_list", "=", "DetectionMetricDataList", "(", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "md", "=", "accumulate", "(", "self", ".", "gt_boxes", ",", "self", ".", "pred_boxes", ",", "class_name", ",", "self", ".", "cfg", ".", "dist_fcn_callable", ",", "dist_th", ")", "\n", "metric_data_list", ".", "set", "(", "class_name", ",", "dist_th", ",", "md", ")", "\n", "\n", "# -----------------------------------", "\n", "# Step 2: Calculate metrics from the data.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.evaluate_segmentation": [[121, 160], ["tqdm.tqdm.tqdm", "evaluate.NuScenesPanopticEval.evaluator[].getPQ", "evaluate.NuScenesPanopticEval.evaluator[].getSemIoU", "evaluate.NuScenesPanopticEval.wrap_result_segmentation", "evaluate.NuScenesPanopticEval.nusc.get", "os.path.join", "nuscenes.utils.data_io.load_bin_file", "evaluate.NuScenesPanopticEval.mapper.convert_label", "os.path.join", "nuscenes.utils.data_io.load_bin_file", "evaluate.NuScenesPanopticEval.evaluator[].addBatch", "evaluate.NuScenesPanopticEval.nusc.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getPQ", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getSemIoU", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.wrap_result_segmentation", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.convert_label", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.addBatch", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["# -----------------------------------", "\n", "", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Calculating metrics...'", ")", "\n", "", "metrics", "=", "DetectionMetrics", "(", "self", ".", "cfg", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "# Compute APs.", "\n", "            ", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "metric_data", "=", "metric_data_list", "[", "(", "class_name", ",", "dist_th", ")", "]", "\n", "ap", "=", "calc_ap", "(", "metric_data", ",", "self", ".", "cfg", ".", "min_recall", ",", "self", ".", "cfg", ".", "min_precision", ")", "\n", "metrics", ".", "add_label_ap", "(", "class_name", ",", "dist_th", ",", "ap", ")", "\n", "\n", "# Compute TP metrics.", "\n", "", "for", "metric_name", "in", "TP_METRICS", ":", "\n", "                ", "metric_data", "=", "metric_data_list", "[", "(", "class_name", ",", "self", ".", "cfg", ".", "dist_th_tp", ")", "]", "\n", "if", "class_name", "in", "[", "'traffic_cone'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", ",", "'orient_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "elif", "class_name", "in", "[", "'barrier'", "]", "and", "metric_name", "in", "[", "'attr_err'", ",", "'vel_err'", "]", ":", "\n", "                    ", "tp", "=", "np", ".", "nan", "\n", "", "else", ":", "\n", "                    ", "tp", "=", "calc_tp", "(", "metric_data", ",", "self", ".", "cfg", ".", "min_recall", ",", "metric_name", ")", "\n", "", "metrics", ".", "add_label_tp", "(", "class_name", ",", "metric_name", ",", "tp", ")", "\n", "\n", "# Compute evaluation time.", "\n", "", "", "metrics", ".", "add_runtime", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "\n", "return", "metrics", ",", "metric_data_list", "\n", "\n", "", "def", "render", "(", "self", ",", "metrics", ":", "DetectionMetrics", ",", "md_list", ":", "DetectionMetricDataList", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Renders various PR and TP curves.\n        :param metrics: DetectionMetrics instance.\n        :param md_list: DetectionMetricDataList instance.\n        \"\"\"", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Rendering PR and TP curves'", ")", "\n", "\n", "", "def", "savepath", "(", "name", ")", ":", "\n", "            ", "return", "os", ".", "path", ".", "join", "(", "self", ".", "plot_dir", ",", "name", "+", "'.pdf'", ")", "\n", "\n", "", "summary_plot", "(", "md_list", ",", "metrics", ",", "min_precision", "=", "self", ".", "cfg", ".", "min_precision", ",", "min_recall", "=", "self", ".", "cfg", ".", "min_recall", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.wrap_result_segmentation": [[161, 197], ["class_all_pq.flatten().tolist.flatten().tolist.flatten().tolist", "class_all_sq.flatten().tolist.flatten().tolist.flatten().tolist", "class_all_rq.flatten().tolist.flatten().tolist.flatten().tolist", "class_all_iou.flatten().tolist.flatten().tolist.flatten().tolist", "dict", "dict", "enumerate", "numpy.mean", "mean_pq.item", "mean_sq.item", "mean_rq.item", "mean_iou.item", "zip", "dict", "float", "float", "class_all_pq.flatten().tolist.flatten().tolist.flatten", "class_all_sq.flatten().tolist.flatten().tolist.flatten", "class_all_rq.flatten().tolist.flatten().tolist.flatten", "class_all_iou.flatten().tolist.flatten().tolist.flatten"], "methods", ["None"], ["dist_th_tp", "=", "self", ".", "cfg", ".", "dist_th_tp", ",", "savepath", "=", "savepath", "(", "'summary'", ")", ")", "\n", "\n", "for", "detection_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "class_pr_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "self", ".", "cfg", ".", "min_precision", ",", "self", ".", "cfg", ".", "min_recall", ",", "\n", "savepath", "=", "savepath", "(", "detection_name", "+", "'_pr'", ")", ")", "\n", "\n", "class_tp_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "self", ".", "cfg", ".", "min_recall", ",", "self", ".", "cfg", ".", "dist_th_tp", ",", "\n", "savepath", "=", "savepath", "(", "detection_name", "+", "'_tp'", ")", ")", "\n", "\n", "", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "            ", "dist_pr_curve", "(", "md_list", ",", "metrics", ",", "dist_th", ",", "self", ".", "cfg", ".", "min_precision", ",", "self", ".", "cfg", ".", "min_recall", ",", "\n", "savepath", "=", "savepath", "(", "'dist_pr_'", "+", "str", "(", "dist_th", ")", ")", ")", "\n", "\n", "", "", "def", "main", "(", "self", ",", "\n", "plot_examples", ":", "int", "=", "0", ",", "\n", "render_curves", ":", "bool", "=", "True", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Main function that loads the evaluation code, visualizes samples, runs the evaluation and renders stat plots.\n        :param plot_examples: How many example visualizations to write to disk.\n        :param render_curves: Whether to render PR and TP curves to disk.\n        :return: A dict that stores the high-level metrics and meta data.\n        \"\"\"", "\n", "if", "plot_examples", ">", "0", ":", "\n", "# Select a random but fixed subset to plot.", "\n", "            ", "random", ".", "seed", "(", "42", ")", "\n", "sample_tokens", "=", "list", "(", "self", ".", "sample_tokens", ")", "\n", "random", ".", "shuffle", "(", "sample_tokens", ")", "\n", "sample_tokens", "=", "sample_tokens", "[", ":", "plot_examples", "]", "\n", "\n", "# Visualize samples.", "\n", "example_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'examples'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "example_dir", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "example_dir", ")", "\n", "", "for", "sample_token", "in", "sample_tokens", ":", "\n", "                ", "visualize_sample", "(", "self", ".", "nusc", ",", "\n", "sample_token", ",", "\n", "self", ".", "gt_boxes", "if", "self", ".", "eval_set", "!=", "'test'", "else", "EvalBoxes", "(", ")", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.evaluate_tracking": [[198, 250], ["tqdm.tqdm.tqdm", "evaluate.NuScenesPanopticEval.evaluator[].get_ptq", "evaluate.NuScenesPanopticEval.evaluator[].getSemIoU", "evaluate.NuScenesPanopticEval.evaluator[].get_lstq", "evaluate.NuScenesPanopticEval.wrap_result_mopt", "nuscenes.utils.splits.create_splits_scenes", "evaluate.NuScenesPanopticEval.nusc.get", "evaluate.NuScenesPanopticEval.nusc.get", "os.path.join", "nuscenes.utils.data_io.load_bin_file", "label_sem.append", "label_inst.append", "os.path.join", "nuscenes.utils.data_io.load_bin_file", "pred_sem.append", "pred_inst.append", "evaluate.NuScenesPanopticEval.evaluator[].add_batch", "evaluate.NuScenesPanopticEval.mapper.convert_label", "evaluate.NuScenesPanopticEval.nusc.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.get_ptq", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getSemIoU", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.get_lstq", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.wrap_result_mopt", "home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_scenes", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_track_evaluator.PanopticTrackingEval.add_batch", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.convert_label", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["# Don't render test GT.", "\n", "self", ".", "pred_boxes", ",", "\n", "eval_range", "=", "max", "(", "self", ".", "cfg", ".", "class_range", ".", "values", "(", ")", ")", ",", "\n", "savepath", "=", "os", ".", "path", ".", "join", "(", "example_dir", ",", "'{}.png'", ".", "format", "(", "sample_token", ")", ")", ")", "\n", "\n", "# Run evaluation.", "\n", "", "", "metrics", ",", "metric_data_list", "=", "self", ".", "evaluate", "(", ")", "\n", "\n", "# Render PR and TP curves.", "\n", "if", "render_curves", ":", "\n", "            ", "self", ".", "render", "(", "metrics", ",", "metric_data_list", ")", "\n", "\n", "# Dump the metric data, meta and metrics to disk.", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Saving metrics to: %s'", "%", "self", ".", "output_dir", ")", "\n", "", "metrics_summary", "=", "metrics", ".", "serialize", "(", ")", "\n", "metrics_summary", "[", "'meta'", "]", "=", "self", ".", "meta", ".", "copy", "(", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'metrics_summary.json'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "metrics_summary", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'metrics_details.json'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "metric_data_list", ".", "serialize", "(", ")", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "# Print high-level metrics.", "\n", "", "print", "(", "'mAP: %.4f'", "%", "(", "metrics_summary", "[", "'mean_ap'", "]", ")", ")", "\n", "err_name_mapping", "=", "{", "\n", "'trans_err'", ":", "'mATE'", ",", "\n", "'scale_err'", ":", "'mASE'", ",", "\n", "'orient_err'", ":", "'mAOE'", ",", "\n", "'vel_err'", ":", "'mAVE'", ",", "\n", "'attr_err'", ":", "'mAAE'", "\n", "}", "\n", "for", "tp_name", ",", "tp_val", "in", "metrics_summary", "[", "'tp_errors'", "]", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'%s: %.4f'", "%", "(", "err_name_mapping", "[", "tp_name", "]", ",", "tp_val", ")", ")", "\n", "", "print", "(", "'NDS: %.4f'", "%", "(", "metrics_summary", "[", "'nd_score'", "]", ")", ")", "\n", "print", "(", "'Eval time: %.1fs'", "%", "metrics_summary", "[", "'eval_time'", "]", ")", "\n", "\n", "# Print per-class metrics.", "\n", "print", "(", ")", "\n", "print", "(", "'Per-class results:'", ")", "\n", "print", "(", "'Object Class\\tAP\\tATE\\tASE\\tAOE\\tAVE\\tAAE'", ")", "\n", "class_aps", "=", "metrics_summary", "[", "'mean_dist_aps'", "]", "\n", "class_tps", "=", "metrics_summary", "[", "'label_tp_errors'", "]", "\n", "for", "class_name", "in", "class_aps", ".", "keys", "(", ")", ":", "\n", "            ", "print", "(", "'%s\\t%.3f\\t%.3f\\t%.3f\\t%.3f\\t%.3f\\t%.3f'", "\n", "%", "(", "class_name", ",", "class_aps", "[", "class_name", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'trans_err'", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'scale_err'", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'orient_err'", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'vel_err'", "]", ",", "\n", "class_tps", "[", "class_name", "]", "[", "'attr_err'", "]", ")", ")", "\n", "\n", "", "return", "metrics_summary", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.wrap_result_mopt": [[251, 286], ["class_all_ptq.flatten().tolist.flatten().tolist.flatten().tolist", "class_all_sptq.flatten().tolist.flatten().tolist.flatten().tolist", "class_all_iou.flatten().tolist.flatten().tolist.flatten().tolist", "dict", "dict", "enumerate", "numpy.mean", "mean_ptq.item", "mean_sptq.item", "mean_iou.item", "zip", "dict", "float", "float", "class_all_ptq.flatten().tolist.flatten().tolist.flatten", "class_all_sptq.flatten().tolist.flatten().tolist.flatten", "class_all_iou.flatten().tolist.flatten().tolist.flatten"], "methods", ["None"], ["\n", "", "", "class", "NuScenesEval", "(", "DetectionEval", ")", ":", "\n", "    ", "\"\"\"\n    Dummy class for backward-compatibility. Same as DetectionEval.\n    \"\"\"", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "\n", "# Settings.", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Evaluate nuScenes detection results.'", ",", "\n", "formatter_class", "=", "argparse", ".", "ArgumentDefaultsHelpFormatter", ")", "\n", "parser", ".", "add_argument", "(", "'result_path'", ",", "type", "=", "str", ",", "help", "=", "'The submission as a JSON file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--output_dir'", ",", "type", "=", "str", ",", "default", "=", "'~/nuscenes-metrics'", ",", "\n", "help", "=", "'Folder to store result metrics, graphs and example visualizations.'", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_set'", ",", "type", "=", "str", ",", "default", "=", "'val'", ",", "\n", "help", "=", "'Which dataset split to evaluate on, train, val or test.'", ")", "\n", "parser", ".", "add_argument", "(", "'--dataroot'", ",", "type", "=", "str", ",", "default", "=", "'/data/sets/nuscenes'", ",", "\n", "help", "=", "'Default nuScenes data directory.'", ")", "\n", "parser", ".", "add_argument", "(", "'--version'", ",", "type", "=", "str", ",", "default", "=", "'v1.0-trainval'", ",", "\n", "help", "=", "'Which version of the nuScenes dataset to evaluate on, e.g. v1.0-trainval.'", ")", "\n", "parser", ".", "add_argument", "(", "'--config_path'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "\n", "help", "=", "'Path to the configuration file.'", "\n", "'If no path given, the CVPR 2019 configuration will be used.'", ")", "\n", "parser", ".", "add_argument", "(", "'--plot_examples'", ",", "type", "=", "int", ",", "default", "=", "10", ",", "\n", "help", "=", "'How many example visualizations to write to disk.'", ")", "\n", "parser", ".", "add_argument", "(", "'--render_curves'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Whether to render PR and TP curves to disk.'", ")", "\n", "parser", ".", "add_argument", "(", "'--verbose'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'Whether to print to stdout.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "result_path_", "=", "os", ".", "path", ".", "expanduser", "(", "args", ".", "result_path", ")", "\n", "output_dir_", "=", "os", ".", "path", ".", "expanduser", "(", "args", ".", "output_dir", ")", "\n", "eval_set_", "=", "args", ".", "eval_set", "\n", "dataroot_", "=", "args", ".", "dataroot", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.NuScenesPanopticEval.save_result": [[287, 303], ["os.makedirs", "ValueError", "print", "print", "print", "open", "json.dump", "json.dumps"], "methods", ["None"], ["version_", "=", "args", ".", "version", "\n", "config_path", "=", "args", ".", "config_path", "\n", "plot_examples_", "=", "args", ".", "plot_examples", "\n", "render_curves_", "=", "bool", "(", "args", ".", "render_curves", ")", "\n", "verbose_", "=", "bool", "(", "args", ".", "verbose", ")", "\n", "\n", "if", "config_path", "==", "''", ":", "\n", "        ", "cfg_", "=", "config_factory", "(", "'detection_cvpr_2019'", ")", "\n", "", "else", ":", "\n", "        ", "with", "open", "(", "config_path", ",", "'r'", ")", "as", "_f", ":", "\n", "            ", "cfg_", "=", "DetectionConfig", ".", "deserialize", "(", "json", ".", "load", "(", "_f", ")", ")", "\n", "\n", "", "", "nusc_", "=", "NuScenes", "(", "version", "=", "version_", ",", "verbose", "=", "verbose_", ",", "dataroot", "=", "dataroot_", ")", "\n", "nusc_eval", "=", "DetectionEval", "(", "nusc_", ",", "config", "=", "cfg_", ",", "result_path", "=", "result_path_", ",", "eval_set", "=", "eval_set_", ",", "\n", "output_dir", "=", "output_dir_", ",", "verbose", "=", "verbose_", ")", "\n", "nusc_eval", ".", "main", "(", "plot_examples", "=", "plot_examples_", ",", "render_curves", "=", "render_curves_", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.evaluate.main": [[305, 348], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.join", "os.path.exists", "print", "nuscenes.nuscenes.NuScenes", "evaluate.NuScenesPanopticEval", "NuScenesPanopticEval.evaluate", "print", "print", "ValueError", "open", "json.load"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.evaluate"], []], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.__init__": [[21, 30], ["numpy.array", "numpy.array", "panoptic_seg_evaluator.PanopticEval.reset", "range"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset"], ["def", "__init__", "(", "self", ",", "n_classes", ",", "ignore", "=", "None", ",", "offset", "=", "2", "**", "32", ",", "min_points", "=", "30", ")", ":", "\n", "        ", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "ignore", "=", "np", ".", "array", "(", "ignore", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "include", "=", "np", ".", "array", "(", "[", "n", "for", "n", "in", "range", "(", "self", ".", "n_classes", ")", "if", "n", "not", "in", "self", ".", "ignore", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "self", ".", "reset", "(", ")", "\n", "self", ".", "offset", "=", "offset", "# largest number of instances in a given scan", "\n", "self", ".", "min_points", "=", "min_points", "# smallest number of points to consider instances in gt", "\n", "self", ".", "eps", "=", "1e-15", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.num_classes": [[31, 33], ["None"], "methods", ["None"], ["", "def", "num_classes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset": [[34, 43], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "# general things", "\n", "# iou stuff", "\n", "        ", "self", ".", "px_iou_conf_matrix", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_classes", ",", "self", ".", "n_classes", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "# panoptic stuff", "\n", "self", ".", "pan_tp", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "pan_iou", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "double", ")", "\n", "self", ".", "pan_fp", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "pan_fn", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.addBatchSemIoU": [[44, 50], ["numpy.stack", "numpy.add.at", "tuple"], "methods", ["None"], ["", "def", "addBatchSemIoU", "(", "self", ",", "x_sem", ",", "y_sem", ")", ":", "\n", "# idxs are labels and predictions", "\n", "        ", "idxs", "=", "np", ".", "stack", "(", "[", "x_sem", ",", "y_sem", "]", ",", "axis", "=", "0", ")", "\n", "\n", "# make confusion matrix (cols = gt, rows = pred)", "\n", "np", ".", "add", ".", "at", "(", "self", ".", "px_iou_conf_matrix", ",", "tuple", "(", "idxs", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getSemIoUStats": [[51, 65], ["panoptic_seg_evaluator.PanopticEval.px_iou_conf_matrix.copy().astype", "panoptic_seg_evaluator.PanopticEval.diagonal", "panoptic_seg_evaluator.PanopticEval.sum", "panoptic_seg_evaluator.PanopticEval.sum", "panoptic_seg_evaluator.PanopticEval.px_iou_conf_matrix.copy"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["", "def", "getSemIoUStats", "(", "self", ")", ":", "\n", "# clone to avoid modifying the real deal", "\n", "        ", "conf", "=", "self", ".", "px_iou_conf_matrix", ".", "copy", "(", ")", ".", "astype", "(", "np", ".", "double", ")", "\n", "# remove fp from confusion on the ignore classes predictions", "\n", "# points that were predicted of another class, but were ignore", "\n", "# (corresponds to zeroing the cols of those classes, since the predictions", "\n", "# go on the rows)", "\n", "conf", "[", ":", ",", "self", ".", "ignore", "]", "=", "0", "\n", "\n", "# get the clean stats", "\n", "tp", "=", "conf", ".", "diagonal", "(", ")", "\n", "fp", "=", "conf", ".", "sum", "(", "axis", "=", "1", ")", "-", "tp", "\n", "fn", "=", "conf", ".", "sum", "(", "axis", "=", "0", ")", "-", "tp", "\n", "return", "tp", ",", "fp", ",", "fn", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getSemIoU": [[66, 75], ["panoptic_seg_evaluator.PanopticEval.getSemIoUStats", "numpy.maximum", "intersection.astype", "numpy.maximum.astype", "intersection[].astype", "union[].astype"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getSemIoUStats"], ["", "def", "getSemIoU", "(", "self", ")", ":", "\n", "        ", "tp", ",", "fp", ",", "fn", "=", "self", ".", "getSemIoUStats", "(", ")", "\n", "intersection", "=", "tp", "\n", "union", "=", "tp", "+", "fp", "+", "fn", "\n", "union", "=", "np", ".", "maximum", "(", "union", ",", "self", ".", "eps", ")", "\n", "iou", "=", "intersection", ".", "astype", "(", "np", ".", "double", ")", "/", "union", ".", "astype", "(", "np", ".", "double", ")", "\n", "iou_mean", "=", "(", "intersection", "[", "self", ".", "include", "]", ".", "astype", "(", "np", ".", "double", ")", "/", "union", "[", "self", ".", "include", "]", ".", "astype", "(", "np", ".", "double", ")", ")", ".", "mean", "(", ")", "\n", "\n", "return", "iou_mean", ",", "iou", "# returns \"iou mean\", \"iou per class\" ALL CLASSES", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getSemAcc": [[76, 85], ["panoptic_seg_evaluator.PanopticEval.getSemIoUStats", "tp.sum", "numpy.maximum", "tp[].sum", "fp[].sum", "tp.sum.astype", "numpy.maximum.astype"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getSemIoUStats"], ["", "def", "getSemAcc", "(", "self", ")", ":", "\n", "        ", "tp", ",", "fp", ",", "fn", "=", "self", ".", "getSemIoUStats", "(", ")", "\n", "total_tp", "=", "tp", ".", "sum", "(", ")", "\n", "total", "=", "tp", "[", "self", ".", "include", "]", ".", "sum", "(", ")", "+", "fp", "[", "self", ".", "include", "]", ".", "sum", "(", ")", "\n", "total", "=", "np", ".", "maximum", "(", "total", ",", "self", ".", "eps", ")", "\n", "# Mean accuracy over all classes.", "\n", "acc_mean", "=", "total_tp", ".", "astype", "(", "np", ".", "double", ")", "/", "total", ".", "astype", "(", "np", ".", "double", ")", "\n", "\n", "return", "acc_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.addBatchPanoptic": [[86, 148], ["numpy.unique", "numpy.array", "numpy.unique", "numpy.array", "numpy.logical_and", "numpy.unique", "numpy.array", "numpy.array", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "x_inst_in_cl_mask.astype", "y_inst_in_cl_mask.astype", "intersections.astype", "unions.astype", "numpy.logical_and", "numpy.logical_and", "enumerate", "enumerate"], "methods", ["None"], ["", "def", "addBatchPanoptic", "(", "self", ",", "x_sem_row", ",", "x_inst_row", ",", "y_sem_row", ",", "y_inst_row", ")", ":", "\n", "# make sure instances are not zeros (it messes with my approach)", "\n", "        ", "x_inst_row", "=", "x_inst_row", "+", "1", "\n", "y_inst_row", "=", "y_inst_row", "+", "1", "\n", "\n", "# only interested in points that are outside the void area (not in excluded classes)", "\n", "for", "cl", "in", "self", ".", "ignore", ":", "\n", "# make a mask for this class", "\n", "            ", "gt_not_in_excl_mask", "=", "y_sem_row", "!=", "cl", "\n", "# remove all other points", "\n", "x_sem_row", "=", "x_sem_row", "[", "gt_not_in_excl_mask", "]", "\n", "y_sem_row", "=", "y_sem_row", "[", "gt_not_in_excl_mask", "]", "\n", "x_inst_row", "=", "x_inst_row", "[", "gt_not_in_excl_mask", "]", "\n", "y_inst_row", "=", "y_inst_row", "[", "gt_not_in_excl_mask", "]", "\n", "\n", "# first step is to count intersections > 0.5 IoU for each class (except the ignored ones)", "\n", "", "for", "cl", "in", "self", ".", "include", ":", "\n", "# get a class mask", "\n", "            ", "x_inst_in_cl_mask", "=", "x_sem_row", "==", "cl", "\n", "y_inst_in_cl_mask", "=", "y_sem_row", "==", "cl", "\n", "\n", "# get instance points in class (makes outside stuff 0)", "\n", "x_inst_in_cl", "=", "x_inst_row", "*", "x_inst_in_cl_mask", ".", "astype", "(", "np", ".", "int64", ")", "\n", "y_inst_in_cl", "=", "y_inst_row", "*", "y_inst_in_cl_mask", ".", "astype", "(", "np", ".", "int64", ")", "\n", "\n", "# generate the areas for each unique instance prediction", "\n", "unique_pred", ",", "counts_pred", "=", "np", ".", "unique", "(", "x_inst_in_cl", "[", "x_inst_in_cl", ">", "0", "]", ",", "return_counts", "=", "True", ")", "\n", "id2idx_pred", "=", "{", "id", ":", "idx", "for", "idx", ",", "id", "in", "enumerate", "(", "unique_pred", ")", "}", "\n", "matched_pred", "=", "np", ".", "array", "(", "[", "False", "]", "*", "unique_pred", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# generate the areas for each unique instance gt_np", "\n", "unique_gt", ",", "counts_gt", "=", "np", ".", "unique", "(", "y_inst_in_cl", "[", "y_inst_in_cl", ">", "0", "]", ",", "return_counts", "=", "True", ")", "\n", "id2idx_gt", "=", "{", "id", ":", "idx", "for", "idx", ",", "id", "in", "enumerate", "(", "unique_gt", ")", "}", "\n", "matched_gt", "=", "np", ".", "array", "(", "[", "False", "]", "*", "unique_gt", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# generate intersection using offset", "\n", "valid_combos", "=", "np", ".", "logical_and", "(", "x_inst_in_cl", ">", "0", ",", "y_inst_in_cl", ">", "0", ")", "\n", "offset_combo", "=", "x_inst_in_cl", "[", "valid_combos", "]", "+", "self", ".", "offset", "*", "y_inst_in_cl", "[", "valid_combos", "]", "\n", "unique_combo", ",", "counts_combo", "=", "np", ".", "unique", "(", "offset_combo", ",", "return_counts", "=", "True", ")", "\n", "\n", "# generate an intersection map", "\n", "# count the intersections with over 0.5 IoU as TP", "\n", "gt_labels", "=", "unique_combo", "//", "self", ".", "offset", "\n", "pred_labels", "=", "unique_combo", "%", "self", ".", "offset", "\n", "gt_areas", "=", "np", ".", "array", "(", "[", "counts_gt", "[", "id2idx_gt", "[", "id", "]", "]", "for", "id", "in", "gt_labels", "]", ")", "\n", "pred_areas", "=", "np", ".", "array", "(", "[", "counts_pred", "[", "id2idx_pred", "[", "id", "]", "]", "for", "id", "in", "pred_labels", "]", ")", "\n", "intersections", "=", "counts_combo", "\n", "unions", "=", "gt_areas", "+", "pred_areas", "-", "intersections", "\n", "ious", "=", "intersections", ".", "astype", "(", "np", ".", "float", ")", "/", "unions", ".", "astype", "(", "np", ".", "float", ")", "\n", "\n", "tp_indexes", "=", "ious", ">", "0.5", "\n", "self", ".", "pan_tp", "[", "cl", "]", "+=", "np", ".", "sum", "(", "tp_indexes", ")", "\n", "self", ".", "pan_iou", "[", "cl", "]", "+=", "np", ".", "sum", "(", "ious", "[", "tp_indexes", "]", ")", "\n", "\n", "matched_gt", "[", "[", "id2idx_gt", "[", "id", "]", "for", "id", "in", "gt_labels", "[", "tp_indexes", "]", "]", "]", "=", "True", "\n", "matched_pred", "[", "[", "id2idx_pred", "[", "id", "]", "for", "id", "in", "pred_labels", "[", "tp_indexes", "]", "]", "]", "=", "True", "\n", "\n", "# count the FN", "\n", "self", ".", "pan_fn", "[", "cl", "]", "+=", "np", ".", "sum", "(", "np", ".", "logical_and", "(", "counts_gt", ">=", "self", ".", "min_points", ",", "matched_gt", "==", "False", ")", ")", "\n", "\n", "# count the FP", "\n", "self", ".", "pan_fp", "[", "cl", "]", "+=", "np", ".", "sum", "(", "np", ".", "logical_and", "(", "counts_pred", ">=", "self", ".", "min_points", ",", "matched_pred", "==", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.getPQ": [[149, 164], ["sq_all[].mean", "rq_all[].mean", "pq_all[].mean", "panoptic_seg_evaluator.PanopticEval.pan_iou.astype", "numpy.maximum", "panoptic_seg_evaluator.PanopticEval.pan_tp.astype", "numpy.maximum", "panoptic_seg_evaluator.PanopticEval.pan_tp.astype", "panoptic_seg_evaluator.PanopticEval.pan_tp.astype", "panoptic_seg_evaluator.PanopticEval.pan_fn.astype", "panoptic_seg_evaluator.PanopticEval.pan_fp.astype"], "methods", ["None"], ["", "", "def", "getPQ", "(", "self", ")", ":", "\n", "        ", "\"\"\" Calculate Panoptic Quality (PQ) metrics \"\"\"", "\n", "# first calculate for all classes", "\n", "sq_all", "=", "self", ".", "pan_iou", ".", "astype", "(", "np", ".", "double", ")", "/", "np", ".", "maximum", "(", "self", ".", "pan_tp", ".", "astype", "(", "np", ".", "double", ")", ",", "self", ".", "eps", ")", "\n", "rq_all", "=", "self", ".", "pan_tp", ".", "astype", "(", "np", ".", "double", ")", "/", "np", ".", "maximum", "(", "\n", "self", ".", "pan_tp", ".", "astype", "(", "np", ".", "double", ")", "+", "0.5", "*", "self", ".", "pan_fp", ".", "astype", "(", "np", ".", "double", ")", "+", "0.5", "*", "self", ".", "pan_fn", ".", "astype", "(", "np", ".", "double", ")", ",", "\n", "self", ".", "eps", ")", "\n", "pq_all", "=", "sq_all", "*", "rq_all", "\n", "\n", "# then do the REAL mean (no ignored classes)", "\n", "SQ", "=", "sq_all", "[", "self", ".", "include", "]", ".", "mean", "(", ")", "\n", "RQ", "=", "rq_all", "[", "self", ".", "include", "]", ".", "mean", "(", ")", "\n", "PQ", "=", "pq_all", "[", "self", ".", "include", "]", ".", "mean", "(", ")", "\n", "\n", "return", "PQ", ",", "SQ", ",", "RQ", ",", "pq_all", ",", "sq_all", ",", "rq_all", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.addBatch": [[165, 172], ["panoptic_seg_evaluator.PanopticEval.addBatchSemIoU", "panoptic_seg_evaluator.PanopticEval.addBatchPanoptic"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.addBatchSemIoU", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.addBatchPanoptic"], ["", "def", "addBatch", "(", "self", ",", "x_sem", ",", "x_inst", ",", "y_sem", ",", "y_inst", ")", ":", "# x=preds, y=targets", "\n", "        ", "\"\"\" IMPORTANT: Inputs must be batched. Either [N,H,W], or [N, P] \"\"\"", "\n", "# add to IoU calculation (for checking purposes)", "\n", "self", ".", "addBatchSemIoU", "(", "x_sem", ",", "y_sem", ")", "\n", "\n", "# now do the panoptic stuff", "\n", "self", ".", "addBatchPanoptic", "(", "x_sem", ",", "x_inst", ",", "y_sem", ",", "y_inst", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.utils.PanopticClassMapper.__init__": [[22, 30], ["nuscenes.eval.lidarseg.utils.LidarsegClassMapper.__init__", "utils.PanopticClassMapper.get_things", "utils.PanopticClassMapper.get_stuff"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.utils.PanopticClassMapper.get_things", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.utils.PanopticClassMapper.get_stuff"], ["\n", "outstr", "=", "category_name", "\n", "\n", "if", "with_attributes", ":", "\n", "        ", "atts", "=", "[", "attribute", "[", "'name'", "]", "for", "attribute", "in", "attributes", "]", "\n", "if", "len", "(", "atts", ")", ">", "0", ":", "\n", "            ", "outstr", "=", "outstr", "+", "\"--\"", "+", "'.'", ".", "join", "(", "atts", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.utils.PanopticClassMapper.get_stuff": [[31, 51], ["utils.PanopticClassMapper.get_coarse2idx", "set", "utils.PanopticClassMapper.keys"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_coarse2idx", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["\n", "", "", "return", "outstr", "\n", "\n", "\n", "", "def", "mask_decode", "(", "mask", ":", "dict", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Decode the mask from base64 string to binary string, then feed it to the external pycocotools library to get a mask.\n    :param mask: The mask dictionary with fields `size` and `counts`.\n    :return: A numpy array representing the binary mask for this class.\n    \"\"\"", "\n", "# Note that it is essential to copy the mask here. If we use the same variable we will overwrite the NuImage class", "\n", "# and cause the Jupyter Notebook to crash on some systems.", "\n", "new_mask", "=", "mask", ".", "copy", "(", ")", "\n", "new_mask", "[", "'counts'", "]", "=", "base64", ".", "b64decode", "(", "mask", "[", "'counts'", "]", ")", "\n", "return", "cocomask", ".", "decode", "(", "new_mask", ")", "\n", "\n", "\n", "", "def", "get_font", "(", "fonts_valid", ":", "List", "[", "str", "]", "=", "None", ",", "font_size", ":", "int", "=", "15", ")", "->", "ImageFont", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.utils.PanopticClassMapper.get_things": [[52, 77], ["utils.PanopticClassMapper.get_coarse2idx", "set", "utils.PanopticClassMapper.keys"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_coarse2idx", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["\n", "# If there are no desired fonts supplied, use a hardcoded list of fonts which are desirable.", "\n", "if", "fonts_valid", "is", "None", ":", "\n", "        ", "fonts_valid", "=", "[", "'FreeSerif.ttf'", ",", "'FreeSans.ttf'", ",", "'Century.ttf'", ",", "'Calibri.ttf'", ",", "'arial.ttf'", "]", "\n", "\n", "# Find a list of fonts within the user's system.", "\n", "", "fonts_in_sys", "=", "matplotlib", ".", "font_manager", ".", "findSystemFonts", "(", "fontpaths", "=", "None", ",", "fontext", "=", "'ttf'", ")", "\n", "# Sort the list of fonts to ensure that the desired fonts are always found in the same order.", "\n", "fonts_in_sys", "=", "sorted", "(", "fonts_in_sys", ")", "\n", "# Of all the fonts found in the user's system, check if any of them are desired.", "\n", "for", "font_in_sys", "in", "fonts_in_sys", ":", "\n", "        ", "if", "any", "(", "os", ".", "path", ".", "basename", "(", "font_in_sys", ")", "in", "s", "for", "s", "in", "fonts_valid", ")", ":", "\n", "            ", "return", "ImageFont", ".", "truetype", "(", "font_in_sys", ",", "font_size", ")", "\n", "\n", "# If none of the fonts in the user's system are desirable, then use the default font.", "\n", "", "", "warnings", ".", "warn", "(", "'No suitable fonts were found in your system. '", "\n", "'A default font will be used instead (the font size will not be adjustable).'", ")", "\n", "return", "ImageFont", ".", "load_default", "(", ")", "\n", "\n", "\n", "", "def", "name_to_index_mapping", "(", "category", ":", "List", "[", "dict", "]", ")", "->", "Dict", "[", "str", ",", "int", "]", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.generate_panoptic_labels.generate_panoptic_labels": [[22, 97], ["len", "os.path.join", "os.path.join", "os.makedirs", "tqdm.tqdm", "os.path.join", "os.makedirs", "os.path.join", "os.path.join", "RuntimeError", "print", "range", "os.path.join", "os.path.join", "nuscenes.utils.data_classes.LidarSegPointCloud", "numpy.zeros", "panoptic_file.replace.replace", "panoptic_file.replace.replace", "panoptic_json.append", "numpy.savez_compressed", "open", "json.dump", "os.path.isfile", "os.path.join", "shutil.copyfile", "hasattr", "len", "nuscenes.utils.data_classes.LidarSegPointCloud.labels.astype", "nusc.get", "nusc.get_sample_data", "range", "[].split", "os.path.join", "getattr", "nusc.get", "nusc.get", "numpy.where", "len", "os.path.join", "panop_labels.astype", "nuscenes.utils.geometry_utils.points_in_box", "len", "nusc.get"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.get_sample_data", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.points_in_box", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["def", "generate_panoptic_labels", "(", "nusc", ":", "NuScenes", ",", "out_dir", ":", "str", ",", "verbose", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Generate nuScenes lidar panoptic ground truth labels.\n    :param nusc: NuScenes instance.\n    :param out_dir: output directory.\n    :param verbose: True to print verbose.\n    \"\"\"", "\n", "if", "not", "hasattr", "(", "nusc", ",", "\"lidarseg\"", ")", "or", "len", "(", "getattr", "(", "nusc", ",", "'lidarseg'", ")", ")", "==", "0", ":", "\n", "        ", "raise", "RuntimeError", "(", "f\"No nuscenes-lidarseg annotations found in {nusc.version}\"", ")", "\n", "", "cat_name_to_idx", "=", "nusc", ".", "lidarseg_name2idx_mapping", "\n", "num_samples", "=", "len", "(", "nusc", ".", "sample", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "f'There are {num_samples} samples.'", ")", "\n", "\n", "# Make output directory.", "\n", "", "panoptic_subdir", "=", "os", ".", "path", ".", "join", "(", "'panoptic'", ",", "nusc", ".", "version", ")", "\n", "panoptic_dir", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "panoptic_subdir", ")", "\n", "os", ".", "makedirs", "(", "panoptic_dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "panoptic_json", "=", "[", "]", "\n", "inst_tok2id", "=", "{", "}", "# instance token to ID mapping", "\n", "for", "sample_idx", "in", "tqdm", "(", "range", "(", "num_samples", ")", ",", "disable", "=", "not", "verbose", ")", ":", "\n", "        ", "curr_sample", "=", "nusc", ".", "sample", "[", "sample_idx", "]", "\n", "scene_token", "=", "curr_sample", "[", "'scene_token'", "]", "\n", "if", "scene_token", "not", "in", "inst_tok2id", ":", "\n", "            ", "inst_tok2id", "[", "scene_token", "]", "=", "{", "}", "\n", "", "lidar_token", "=", "curr_sample", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", "\n", "point_path", "=", "os", ".", "path", ".", "join", "(", "nusc", ".", "dataroot", ",", "nusc", ".", "get", "(", "'sample_data'", ",", "lidar_token", ")", "[", "'filename'", "]", ")", "\n", "label_path", "=", "os", ".", "path", ".", "join", "(", "nusc", ".", "dataroot", ",", "nusc", ".", "get", "(", "'lidarseg'", ",", "lidar_token", ")", "[", "'filename'", "]", ")", "\n", "lidar_seg", "=", "LidarSegPointCloud", "(", "point_path", ",", "label_path", ")", "\n", "# panoptic labels will be set as 1000 * category_index + instance_id, instance_id will be [1, 2, 3, ...] within", "\n", "# each thing category, these points fall within more than 1 bounding boxes will have instance_id = 0.", "\n", "panop_labels", "=", "lidar_seg", ".", "labels", ".", "astype", "(", "np", ".", "int32", ")", "*", "1000", "\n", "overlap_box_count", "=", "np", ".", "zeros", "(", "lidar_seg", ".", "labels", ".", "shape", ",", "dtype", "=", "np", ".", "uint16", ")", "\n", "\n", "for", "ann_token", "in", "curr_sample", "[", "'anns'", "]", ":", "\n", "            ", "ann", "=", "nusc", ".", "get", "(", "'sample_annotation'", ",", "ann_token", ")", "\n", "instance_token", "=", "ann", "[", "'instance_token'", "]", "\n", "if", "not", "inst_tok2id", "[", "scene_token", "]", ":", "\n", "                ", "inst_tok2id", "[", "scene_token", "]", "[", "instance_token", "]", "=", "1", "\n", "", "elif", "instance_token", "not", "in", "inst_tok2id", "[", "scene_token", "]", ":", "\n", "                ", "inst_tok2id", "[", "scene_token", "]", "[", "instance_token", "]", "=", "len", "(", "inst_tok2id", "[", "scene_token", "]", ")", "+", "1", "\n", "", "instance_id", "=", "inst_tok2id", "[", "scene_token", "]", "[", "instance_token", "]", "\n", "_", ",", "boxes", ",", "_", "=", "nusc", ".", "get_sample_data", "(", "lidar_token", ",", "selected_anntokens", "=", "[", "ann_token", "]", ")", "\n", "indices", "=", "np", ".", "where", "(", "points_in_box", "(", "boxes", "[", "0", "]", ",", "lidar_seg", ".", "points", "[", ":", ",", ":", "3", "]", ".", "T", ")", ")", "[", "0", "]", "\n", "\n", "for", "index", "in", "range", "(", "len", "(", "indices", ")", ")", ":", "\n", "                ", "if", "lidar_seg", ".", "labels", "[", "indices", "[", "index", "]", "]", "==", "cat_name_to_idx", "[", "ann", "[", "'category_name'", "]", "]", ":", "\n", "                    ", "panop_labels", "[", "indices", "[", "index", "]", "]", "+=", "instance_id", "\n", "overlap_box_count", "[", "indices", "[", "index", "]", "]", "+=", "1", "\n", "\n", "", "", "", "panop_labels", "[", "overlap_box_count", ">", "1", "]", "=", "0", "\n", "\n", "panoptic_file", "=", "nusc", ".", "get", "(", "'lidarseg'", ",", "lidar_token", ")", "[", "'filename'", "]", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "panoptic_file", "=", "panoptic_file", ".", "replace", "(", "'lidarseg'", ",", "'panoptic'", ")", "\n", "panoptic_file", "=", "panoptic_file", ".", "replace", "(", "'.bin'", ",", "'.npz'", ")", "\n", "panoptic_json", ".", "append", "(", "{", "\n", "\"token\"", ":", "lidar_token", ",", "\n", "\"sample_data_token\"", ":", "lidar_token", ",", "\n", "\"filename\"", ":", "os", ".", "path", ".", "join", "(", "panoptic_subdir", ",", "panoptic_file", ")", ",", "\n", "}", ")", "\n", "np", ".", "savez_compressed", "(", "os", ".", "path", ".", "join", "(", "panoptic_dir", ",", "panoptic_file", ")", ",", "data", "=", "panop_labels", ".", "astype", "(", "np", ".", "uint16", ")", ")", "\n", "\n", "# Write the panoptic table.", "\n", "", "meta_dir", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "nusc", ".", "version", ")", "\n", "os", ".", "makedirs", "(", "meta_dir", ",", "exist_ok", "=", "True", ")", "\n", "json_file", "=", "os", ".", "path", ".", "join", "(", "meta_dir", ",", "'panoptic.json'", ")", "\n", "with", "open", "(", "json_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "panoptic_json", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "# Copy category.json from lidarseg.", "\n", "", "category_dst_path", "=", "os", ".", "path", ".", "join", "(", "meta_dir", ",", "'category.json'", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "category_dst_path", ")", ":", "\n", "        ", "category_src_path", "=", "os", ".", "path", ".", "join", "(", "nusc", ".", "dataroot", ",", "nusc", ".", "version", ",", "'category.json'", ")", "\n", "copyfile", "(", "category_src_path", ",", "category_dst_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.generate_panoptic_labels.main": [[99, 112], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "nuscenes.nuscenes.NuScenes", "generate_panoptic_labels.generate_panoptic_labels", "print"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.generate_panoptic_labels.generate_panoptic_labels"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Generate nuScenes lidar panaptic gt.'", ")", "\n", "parser", ".", "add_argument", "(", "'--dataroot'", ",", "type", "=", "str", ",", "default", "=", "'/data/sets/nuscenes'", ",", "help", "=", "'Default nuScenes data directory.'", ")", "\n", "parser", ".", "add_argument", "(", "'--version'", ",", "type", "=", "str", ",", "default", "=", "'v1.0-trainval'", ",", "\n", "help", "=", "'Which version of the nuScenes dataset to evaluate on, e.g. v1.0-trainval.'", ")", "\n", "parser", ".", "add_argument", "(", "'--verbose'", ",", "type", "=", "bool", ",", "default", "=", "True", ",", "help", "=", "'Whether to print to stdout.'", ")", "\n", "parser", ".", "add_argument", "(", "'--out_dir'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "help", "=", "'Folder to write the panoptic labels to.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "out_dir", "=", "args", ".", "out_dir", "if", "args", ".", "out_dir", "is", "not", "None", "else", "f'nuScenes-panoptic-{args.version}'", "\n", "print", "(", "f'Start panoptic ground truths generation... \\nArguments: {args}'", ")", "\n", "nusc", "=", "NuScenes", "(", "version", "=", "args", ".", "version", ",", "dataroot", "=", "args", ".", "dataroot", ",", "verbose", "=", "args", ".", "verbose", ")", "\n", "generate_panoptic_labels", "(", "nusc", "=", "nusc", ",", "out_dir", "=", "out_dir", ",", "verbose", "=", "args", ".", "verbose", ")", "\n", "print", "(", "f'Panoptic ground truths saved at {args.out_dir}. \\nFinished panoptic ground truth generation.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.stuff_cat_ids": [[18, 24], ["list", "range"], "function", ["None"], ["def", "stuff_cat_ids", "(", "num_categories", ":", "int", ")", "->", "List", "[", "int", "]", ":", "\n", "    ", "\"\"\"\n    :param num_categories: total number of classes.\n    :return: List of stuff class indices.\n    \"\"\"", "\n", "return", "list", "(", "range", "(", "STUFF_START_CLASS_ID", ",", "num_categories", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.generate_panoptic_colors": [[26, 47], ["numpy.random.seed", "lidarseg.lidarseg_utils.colormap_to_colors", "numpy.random.uniform", "range", "len", "utils.color_map.get_colormap"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.colormap_to_colors", "home.repos.pwc.inspect_result.fpthink_v2b.utils.color_map.get_colormap"], ["", "def", "generate_panoptic_colors", "(", "colormap", ":", "Dict", "[", "str", ",", "Iterable", "[", "int", "]", "]", ",", "\n", "name2idx", ":", "Dict", "[", "str", ",", "int", "]", ",", "\n", "max_instances", ":", "int", "=", "32000", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Create an array of RGB values from a colormap for stuff categories, and random colors for thing instances. Note\n    that the RGB values are normalized between 0 and 1, not 0 and 255.\n    :param colormap: A dictionary containing the mapping from class names to RGB values.\n    :param name2idx: A dictionary containing the mapping form class names to class index.\n    :param max_instances: maximal number of instances.\n    :return: An array of colors.\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "colors_for_categories", "=", "colormap_to_colors", "(", "colormap", "=", "colormap", ",", "name2idx", "=", "name2idx", ")", "\n", "# randomly generate colors for stuff and thing instances", "\n", "colors", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0.0", ",", "high", "=", "1.0", ",", "size", "=", "(", "max_instances", ",", "3", ")", ")", "\n", "# Use constant colors for stuff points, category ranges in [24, 31]", "\n", "for", "id_i", "in", "range", "(", "STUFF_START_CLASS_ID", ",", "len", "(", "colors_for_categories", ")", ")", ":", "\n", "        ", "colors", "[", "id_i", "*", "1000", "]", "=", "colors_for_categories", "[", "id_i", "]", "\n", "", "colors", "[", "0", "]", "=", "[", "c", "/", "255.0", "for", "c", "in", "get_colormap", "(", ")", "[", "'noise'", "]", "]", "\n", "\n", "return", "colors", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.paint_panop_points_label": [[49, 91], ["utils.data_io.load_bin_file", "panoptic_utils.generate_panoptic_colors", "isinstance", "all", "numpy.concatenate", "numpy.unique", "numpy.ones", "len", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.generate_panoptic_colors", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "def", "paint_panop_points_label", "(", "panoptic_labels_filename", ":", "str", ",", "\n", "filter_panoptic_labels", ":", "List", "[", "int", "]", ",", "\n", "name2idx", ":", "Dict", "[", "str", ",", "int", "]", ",", "\n", "colormap", ":", "Dict", "[", "str", ",", "Tuple", "[", "int", ",", "int", ",", "int", "]", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Paint each label in a pointcloud with the corresponding RGB value, and set the opacity of the labels to\n    be shown to 1 (the opacity of the rest will be set to 0); e.g.:\n        [30, 5, 12, 34, ...] ------> [[R30, G30, B30, 0], [R5, G5, B5, 1], [R34, G34, B34, 1], ...]\n    :param panoptic_labels_filename: Path to the .bin file containing the labels.\n    :param filter_panoptic_labels: The labels for which to set opacity to zero; this is to hide those points\n                                   thereby preventing them from being displayed.\n    :param name2idx: A dictionary containing the mapping from class names to class indices.\n    :param colormap: A dictionary containing the mapping from class names to RGB values.\n    :return: A numpy array which has length equal to the number of points in the pointcloud, and each value is\n             a RGBA array.\n    \"\"\"", "\n", "# Load labels from .npz file.", "\n", "panoptic_labels", "=", "load_bin_file", "(", "panoptic_labels_filename", ",", "type", "=", "'panoptic'", ")", "# [num_points]", "\n", "# Given a colormap (class name -> RGB color) and a mapping from class name to class index,", "\n", "# get an array of RGB values where each color sits at the index in the array corresponding", "\n", "# to the class index.", "\n", "colors", "=", "generate_panoptic_colors", "(", "colormap", ",", "name2idx", ")", "# Shape: [num_instances, 3]", "\n", "\n", "if", "filter_panoptic_labels", "is", "not", "None", ":", "\n", "# Ensure that filter_panoptic_labels is an iterable.", "\n", "        ", "assert", "isinstance", "(", "filter_panoptic_labels", ",", "(", "list", ",", "np", ".", "ndarray", ")", ")", ",", "'Error: filter_panoptic_labels should be a list of class indices, eg. [9], [10, 21].'", "\n", "\n", "# Check that class indices in filter_panoptic_labels are valid.", "\n", "assert", "all", "(", "[", "0", "<=", "x", "<", "len", "(", "name2idx", ")", "for", "x", "in", "filter_panoptic_labels", "]", ")", ",", "f'All class indices in filter_panoptic_labels should be between 0 and {len(name2idx) - 1}'", "\n", "\n", "# Filter to get only the colors of the desired classes; this is done by setting the", "\n", "# alpha channel of the classes to be viewed to 1, and the rest to 0.", "\n", "colors", "=", "np", ".", "concatenate", "(", "(", "colors", ",", "np", ".", "ones", "(", "(", "colors", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ")", ",", "1", ")", "\n", "for", "id_i", "in", "np", ".", "unique", "(", "panoptic_labels", ")", ":", "# Shape: [num_class, 4]", "\n", "            ", "if", "id_i", "//", "1000", "not", "in", "filter_panoptic_labels", ":", "\n", "                ", "colors", "[", "id_i", ",", "-", "1", "]", "=", "0.0", "\n", "\n", "", "", "", "coloring", "=", "colors", "[", "panoptic_labels", "]", "# Shape: [num_points, 4]", "\n", "\n", "return", "coloring", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.get_frame_panoptic_instances": [[93, 112], ["numpy.concatenate().astype", "numpy.array", "numpy.full", "numpy.concatenate", "numpy.unique", "numpy.concatenate"], "function", ["None"], ["", "def", "get_frame_panoptic_instances", "(", "panoptic_label", ":", "np", ".", "ndarray", ",", "frame_id", ":", "int", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Get frequency of each label in a point cloud.\n    :param panoptic_label: np.array((rows, cols), np.uint16), a numPy array which contains the panoptic labels of the\n    point cloud; e.g. 1000 * cat_idx + instance_id. The instance_id starts from 1.\n    :param frame_id: frame index.\n    :return: np.array((num_instances, k), np.int), k = 3. Each true flag of frame_id will add extra 1 column.\n    An full array contains one row (frame_index, category_id, instance_id, num_points) for each instance. frame_index\n    column will be skipped if the flag is False.\n    \"\"\"", "\n", "inst_count", "=", "np", ".", "array", "(", "np", ".", "unique", "(", "panoptic_label", ",", "return_counts", "=", "True", ")", ")", ".", "T", "\n", "cat_inst_count", "=", "np", ".", "concatenate", "(", "[", "inst_count", "[", ":", ",", "0", ":", "1", "]", "//", "1000", ",", "inst_count", "[", ":", ",", "0", ":", "1", "]", "%", "1000", ",", "inst_count", "[", ":", ",", "1", ":", "]", "]", ",", "\n", "axis", "=", "1", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "if", "frame_id", "is", "not", "None", ":", "\n", "        ", "frame_id_col", "=", "np", ".", "full", "(", "(", "cat_inst_count", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "fill_value", "=", "frame_id", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "cat_inst_count", "=", "np", ".", "concatenate", "(", "[", "frame_id_col", ",", "cat_inst_count", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "return", "cat_inst_count", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_utils.get_panoptic_instances_stats": [[114, 206], ["numpy.empty", "enumerate", "numpy.logical_and", "numpy.sum", "dict", "numpy.array", "numpy.sum", "dict", "len", "scene_inst_stats.values", "numpy.full", "numpy.concatenate", "numpy.concatenate", "numpy.array", "numpy.mean", "numpy.std", "per_frame_panoptic_stats.update", "numpy.unique", "len", "numpy.unique", "numpy.array", "numpy.array", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "per_category_panoptic_stats[].update", "cat_idx2name.items", "numpy.array", "numpy.array", "numpy.unique", "numpy.unique", "dict.items", "list", "scene_inst_stats.keys"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update"], ["", "def", "get_panoptic_instances_stats", "(", "scene_inst_stats", ":", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ",", "\n", "cat_idx2name", ":", "Dict", "[", "int", ",", "str", "]", ",", "\n", "get_hist", ":", "bool", "=", "False", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "    ", "\"\"\"\n    Get panoptic instance stats on a database level.\n    :param scene_inst_stats:  {scene_token : np.array((n, 4), np.int32)), each row is (frame_id, category_id,\n        instance_id, num_points) for each instance within the same scene.\n    :param cat_idx2name: {int: str}, category index to name mapping.\n    :param get_hist: True to return per frame instance counts and per category counts (number of spanned frames\n        per instance and num of points per instance). These could be used for more deep histogram analysis.\n    :return: A dict of panoptic data stats.\n        {\n            'num_instances': int,\n            'num_instance_states': int,\n            'per_frame_panoptic_stats': {\n                'per_frame_num_instances': (mean, std),\n                'per_frame_num_instance_hist': np.array((num_frames,), np.int32)\n            },\n            'per_category_panoptic_stats': {\n                'human.pedestrian.adult': {\n                    'num_instances': int,\n                    'num_frames_per_instance': (mean, std),\n                    'num_points_per_instance': (mean, std),\n                    'num_frames_per_instance_count': np.ndarray((num_instances,), np.int32)  # optional\n                    'num_points_per_instance_count': np.ndarray((num_boxes,), np.int32)      # optional\n                }\n            },\n        }\n    \"\"\"", "\n", "assert", "len", "(", "scene_inst_stats", ")", ">", "0", ",", "\"Empty input data !\"", "\n", "ncols", "=", "scene_inst_stats", "[", "list", "(", "scene_inst_stats", ".", "keys", "(", ")", ")", "[", "0", "]", "]", ".", "shape", "[", "1", "]", "\n", "# Create database mat, add scene_id column, each row: (scene_id, frame_id, category_id, instance_id, num_points).", "\n", "data", "=", "np", ".", "empty", "(", "(", "0", ",", "ncols", "+", "1", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "scene_id", ",", "scene_data", "in", "enumerate", "(", "scene_inst_stats", ".", "values", "(", ")", ")", ":", "\n", "        ", "scene_id_col", "=", "np", ".", "full", "(", "(", "scene_data", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "fill_value", "=", "scene_id", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "scene_data", "=", "np", ".", "concatenate", "(", "[", "scene_id_col", ",", "scene_data", "]", ",", "axis", "=", "1", ")", "\n", "data", "=", "np", ".", "concatenate", "(", "[", "data", ",", "scene_data", "]", ",", "axis", "=", "0", ")", "\n", "\n", "", "thing_row_mask", "=", "np", ".", "logical_and", "(", "data", "[", ":", ",", "2", "]", ">", "0", ",", "data", "[", ":", ",", "2", "]", "<", "STUFF_START_CLASS_ID", ")", "# thing instances only.", "\n", "data_thing", "=", "data", "[", "thing_row_mask", "]", "\n", "# 1. Per-frame instance stats.", "\n", "# Need to make unique frame index: 1000 * scene_id * frame_id, support max 1000 frames per scene. All instances", "\n", "# in the same frame will share the same unique frame index. We can count the occurrences for each frame.", "\n", "inst_num_each_frame", "=", "np", ".", "array", "(", "np", ".", "unique", "(", "1000", "*", "data_thing", "[", ":", ",", "0", "]", "+", "data_thing", "[", ":", ",", "1", "]", ",", "return_counts", "=", "True", ")", ")", "[", "1", "]", "\n", "mean_inst_num_per_frame", ",", "std_inst_num_per_frame", "=", "np", ".", "mean", "(", "inst_num_each_frame", ")", ",", "np", ".", "std", "(", "inst_num_each_frame", ")", "\n", "total_num_sample_annotations", "=", "np", ".", "sum", "(", "inst_num_each_frame", ")", "\n", "\n", "per_frame_panoptic_stats", "=", "{", "'per_frame_num_instances'", ":", "(", "mean_inst_num_per_frame", ",", "std_inst_num_per_frame", ")", "}", "\n", "if", "get_hist", ":", "\n", "        ", "inst_num_per_frame_hist", "=", "np", ".", "array", "(", "np", ".", "unique", "(", "inst_num_each_frame", ",", "return_counts", "=", "True", ")", ")", ".", "T", "\n", "per_frame_panoptic_stats", ".", "update", "(", "{", "'per_frame_num_instances_hist'", ":", "inst_num_per_frame_hist", "}", ")", "\n", "\n", "# 2. Per-category instance stats.", "\n", "", "per_category_panoptic_stats", "=", "dict", "(", ")", "\n", "unique_cat_ids", "=", "np", ".", "array", "(", "np", ".", "unique", "(", "data_thing", "[", ":", ",", "2", "]", ")", ")", "\n", "# Need to make unique instance ID across scene, inst_id = 1000 * scene_id + inst_id", "\n", "unique_inst_ids", "=", "1000", "*", "data_thing", "[", ":", ",", "0", "]", "+", "data_thing", "[", ":", ",", "3", "]", "\n", "for", "cat_id", "in", "unique_cat_ids", ":", "\n", "        ", "per_cat_inst_mask", "=", "data_thing", "[", ":", ",", "2", "]", "==", "cat_id", "\n", "per_cat_unique_inst_ids", "=", "unique_inst_ids", "[", "per_cat_inst_mask", "]", "\n", "per_cat_inst_frame_count", "=", "np", ".", "array", "(", "np", ".", "unique", "(", "per_cat_unique_inst_ids", ",", "return_counts", "=", "True", ")", ")", "[", "1", "]", "\n", "num_instances", "=", "len", "(", "per_cat_inst_frame_count", ")", "\n", "mean_num_frames", ",", "std_num_frames", "=", "np", ".", "mean", "(", "per_cat_inst_frame_count", ")", ",", "np", ".", "std", "(", "per_cat_inst_frame_count", ")", "\n", "per_cat_inst_num_pts", "=", "data_thing", "[", "per_cat_inst_mask", ",", "4", "]", "\n", "mean_num_pts", ",", "std_num_pts", "=", "np", ".", "mean", "(", "per_cat_inst_num_pts", ")", ",", "np", ".", "std", "(", "per_cat_inst_num_pts", ")", "\n", "per_category_panoptic_stats", "[", "cat_idx2name", "[", "cat_id", "]", "]", "=", "{", "\n", "'num_instances'", ":", "num_instances", ",", "\n", "'num_frames_per_instance'", ":", "(", "mean_num_frames", ",", "std_num_frames", ")", ",", "\n", "'num_points_per_instance'", ":", "(", "mean_num_pts", ",", "std_num_pts", ")", ",", "\n", "}", "\n", "if", "get_hist", ":", "\n", "            ", "per_category_panoptic_stats", "[", "cat_idx2name", "[", "cat_id", "]", "]", ".", "update", "(", "{", "\n", "'num_frames_per_instance_count'", ":", "per_cat_inst_frame_count", ",", "\n", "'num_points_per_instance_count'", ":", "per_cat_inst_num_pts", ",", "\n", "}", ")", "\n", "\n", "", "", "total_num_instances", "=", "np", ".", "sum", "(", "[", "v", "[", "'num_instances'", "]", "for", "_", ",", "v", "in", "per_category_panoptic_stats", ".", "items", "(", ")", "]", ")", "\n", "# for completeness of all categories, fill with empty values for categories with zero instances.", "\n", "other_cats", "=", "[", "name", "for", "i", ",", "name", "in", "cat_idx2name", ".", "items", "(", ")", "if", "0", "<", "i", "<", "STUFF_START_CLASS_ID", "and", "i", "not", "in", "unique_cat_ids", "]", "\n", "for", "cat_name", "in", "other_cats", ":", "\n", "        ", "per_category_panoptic_stats", "[", "cat_name", "]", "=", "{", "\n", "'num_instances'", ":", "0", ",", "\n", "'num_frames_per_instance'", ":", "(", "0", ",", "0", ")", ",", "\n", "'num_points_per_instance'", ":", "(", "0", ",", "0", ")", ",", "\n", "'num_frames_per_instance_count'", ":", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int32", ")", ",", "\n", "'num_points_per_instance_count'", ":", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "}", "\n", "\n", "", "return", "dict", "(", "num_instances", "=", "total_num_instances", ",", "\n", "num_sample_annotations", "=", "total_num_sample_annotations", ",", "\n", "per_frame_panoptic_stats", "=", "per_frame_panoptic_stats", ",", "\n", "per_category_panoptic_stats", "=", "per_category_panoptic_stats", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.evaluate.LidarSegEval.__init__": [[36, 75], ["os.path.join", "os.path.exists", "nuscenes.eval.lidarseg.utils.LidarsegClassMapper", "len", "nuscenes.eval.lidarseg.utils.ConfusionMatrix", "nuscenes.eval.lidarseg.utils.get_samples_in_eval_set", "len", "print", "print", "evaluate.LidarSegEval.mapper.coarse_name_2_coarse_idx_mapping.items", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.get_samples_in_eval_set"], ["\n", "def", "__init__", "(", "self", ",", "\n", "nusc", ":", "NuScenes", ",", "\n", "config", ":", "DetectionConfig", ",", "\n", "result_path", ":", "str", ",", "\n", "eval_set", ":", "str", ",", "\n", "output_dir", ":", "str", "=", "None", ",", "\n", "verbose", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a DetectionEval object.\n        :param nusc: A NuScenes object.\n        :param config: A DetectionConfig object.\n        :param result_path: Path of the nuScenes JSON result file.\n        :param eval_set: The dataset split to evaluate on, e.g. train, val or test.\n        :param output_dir: Folder to save plots and results to.\n        :param verbose: Whether to print to stdout.\n        \"\"\"", "\n", "self", ".", "nusc", "=", "nusc", "\n", "self", ".", "result_path", "=", "result_path", "\n", "self", ".", "eval_set", "=", "eval_set", "\n", "self", ".", "output_dir", "=", "output_dir", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "cfg", "=", "config", "\n", "\n", "# Check result file exists.", "\n", "assert", "os", ".", "path", ".", "exists", "(", "result_path", ")", ",", "'Error: The result file does not exist!'", "\n", "\n", "# Make dirs.", "\n", "self", ".", "plot_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_dir", ",", "'plots'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "output_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "output_dir", ")", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "plot_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "plot_dir", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.evaluate.LidarSegEval.evaluate": [[76, 119], ["tqdm.tqdm.tqdm", "evaluate.LidarSegEval.global_cm.get_per_class_iou", "evaluate.LidarSegEval.global_cm.get_mean_iou", "evaluate.LidarSegEval.global_cm.get_freqweighted_iou", "evaluate.LidarSegEval.nusc.get", "os.path.join", "nuscenes.utils.data_io.load_bin_file", "evaluate.LidarSegEval.mapper.convert_label", "os.path.join", "nuscenes.utils.data_io.load_bin_file", "evaluate.LidarSegEval.global_cm.update", "print", "print", "print", "json.dumps", "evaluate.LidarSegEval.nusc.get", "enumerate"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_per_class_iou", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_mean_iou", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_freqweighted_iou", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.convert_label", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_io.load_bin_file", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["\n", "# Load data.", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'Initializing nuScenes detection evaluation'", ")", "\n", "", "self", ".", "pred_boxes", ",", "self", ".", "meta", "=", "load_prediction", "(", "self", ".", "result_path", ",", "self", ".", "cfg", ".", "max_boxes_per_sample", ",", "DetectionBox", ",", "\n", "verbose", "=", "verbose", ")", "\n", "self", ".", "gt_boxes", "=", "load_gt", "(", "self", ".", "nusc", ",", "self", ".", "eval_set", ",", "DetectionBox", ",", "verbose", "=", "verbose", ")", "\n", "\n", "assert", "set", "(", "self", ".", "pred_boxes", ".", "sample_tokens", ")", "==", "set", "(", "self", ".", "gt_boxes", ".", "sample_tokens", ")", ",", "\"Samples in split doesn't match samples in predictions.\"", "\n", "\n", "# Add center distances.", "\n", "self", ".", "pred_boxes", "=", "add_center_dist", "(", "nusc", ",", "self", ".", "pred_boxes", ")", "\n", "self", ".", "gt_boxes", "=", "add_center_dist", "(", "nusc", ",", "self", ".", "gt_boxes", ")", "\n", "\n", "# Filter boxes (distance, points per box, etc.).", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Filtering predictions'", ")", "\n", "", "self", ".", "pred_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "self", ".", "pred_boxes", ",", "self", ".", "cfg", ".", "class_range", ",", "verbose", "=", "verbose", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Filtering ground truth annotations'", ")", "\n", "", "self", ".", "gt_boxes", "=", "filter_eval_boxes", "(", "nusc", ",", "self", ".", "gt_boxes", ",", "self", ".", "cfg", ".", "class_range", ",", "verbose", "=", "verbose", ")", "\n", "\n", "self", ".", "sample_tokens", "=", "self", ".", "gt_boxes", ".", "sample_tokens", "\n", "\n", "", "def", "evaluate", "(", "self", ")", "->", "Tuple", "[", "DetectionMetrics", ",", "DetectionMetricDataList", "]", ":", "\n", "        ", "\"\"\"\n        Performs the actual evaluation.\n        :return: A tuple of high-level and the raw metric data.\n        \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# -----------------------------------", "\n", "# Step 1: Accumulate metric data for all classes and distance thresholds.", "\n", "# -----------------------------------", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "'Accumulating metric data...'", ")", "\n", "", "metric_data_list", "=", "DetectionMetricDataList", "(", ")", "\n", "for", "class_name", "in", "self", ".", "cfg", ".", "class_names", ":", "\n", "            ", "for", "dist_th", "in", "self", ".", "cfg", ".", "dist_ths", ":", "\n", "                ", "md", "=", "accumulate", "(", "self", ".", "gt_boxes", ",", "self", ".", "pred_boxes", ",", "class_name", ",", "self", ".", "cfg", ".", "dist_fcn_callable", ",", "dist_th", ")", "\n", "metric_data_list", ".", "set", "(", "class_name", ",", "dist_th", ",", "md", ")", "\n", "\n", "# -----------------------------------", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.__init__": [[22, 68], ["nuscenes.eval.lidarseg.evaluate.LidarSegEval.__init__", "os.path.exists", "nuscenes.eval.lidarseg.utils.ConfusionMatrix", "enumerate", "range", "str", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["\n", "def", "visualize_sample", "(", "nusc", ":", "NuScenes", ",", "\n", "sample_token", ":", "str", ",", "\n", "gt_boxes", ":", "EvalBoxes", ",", "\n", "pred_boxes", ":", "EvalBoxes", ",", "\n", "nsweeps", ":", "int", "=", "1", ",", "\n", "conf_th", ":", "float", "=", "0.15", ",", "\n", "eval_range", ":", "float", "=", "50", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "savepath", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Visualizes a sample from BEV with annotations and detection results.\n    :param nusc: NuScenes object.\n    :param sample_token: The nuScenes sample token.\n    :param gt_boxes: Ground truth boxes grouped by sample.\n    :param pred_boxes: Prediction grouped by sample.\n    :param nsweeps: Number of sweeps used for lidar visualization.\n    :param conf_th: The confidence threshold used to filter negatives.\n    :param eval_range: Range in meters beyond which boxes are ignored.\n    :param verbose: Whether to print to stdout.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    \"\"\"", "\n", "# Retrieve sensor & pose records.", "\n", "sample_rec", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "sd_record", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "\n", "cs_record", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "sd_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pose_record", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "sd_record", "[", "'ego_pose_token'", "]", ")", "\n", "\n", "# Get boxes.", "\n", "boxes_gt_global", "=", "gt_boxes", "[", "sample_token", "]", "\n", "boxes_est_global", "=", "pred_boxes", "[", "sample_token", "]", "\n", "\n", "# Map GT boxes to lidar.", "\n", "boxes_gt", "=", "boxes_to_sensor", "(", "boxes_gt_global", ",", "pose_record", ",", "cs_record", ")", "\n", "\n", "# Map EST boxes to lidar.", "\n", "boxes_est", "=", "boxes_to_sensor", "(", "boxes_est_global", ",", "pose_record", ",", "cs_record", ")", "\n", "\n", "# Add scores to EST boxes.", "\n", "for", "box_est", ",", "box_est_global", "in", "zip", "(", "boxes_est", ",", "boxes_est_global", ")", ":", "\n", "        ", "box_est", ".", "score", "=", "box_est_global", ".", "detection_score", "\n", "\n", "# Get point cloud in lidar frame.", "\n", "", "pc", ",", "_", "=", "LidarPointCloud", ".", "from_file_multisweep", "(", "nusc", ",", "sample_rec", ",", "'LIDAR_TOP'", ",", "'LIDAR_TOP'", ",", "nsweeps", "=", "nsweeps", ")", "\n", "\n", "# Init axes.", "\n", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "9", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.evaluate": [[69, 105], ["enumerate", "render.LidarSegEvalStratified.get_stratified_per_class_metrics", "tqdm.tqdm.tqdm", "print", "render.LidarSegEvalStratified.render_stratified_per_class_metrics", "render.LidarSegEvalStratified.render_stratified_overall_metrics", "print", "render.LidarSegEvalStratified.nusc.get", "render.LidarSegEvalStratified.nusc.get", "os.path.join", "os.path.join", "nuscenes.utils.data_classes.LidarSegPointCloud", "render.LidarSegEvalStratified.mapper.convert_label", "os.path.join", "nuscenes.utils.data_classes.LidarSegPointCloud", "render.LidarSegEvalStratified.filter_pointcloud_by_depth", "render.LidarSegEvalStratified.filter_pointcloud_by_depth", "render.LidarSegEvalStratified.global_cm[].update", "json.dumps", "os.path.join", "os.path.join", "render.LidarSegEvalStratified.nusc.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.get_stratified_per_class_metrics", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.render_stratified_per_class_metrics", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.render_stratified_overall_metrics", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.convert_label", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.filter_pointcloud_by_depth", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.filter_pointcloud_by_depth", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["\n", "# Show point cloud.", "\n", "points", "=", "view_points", "(", "pc", ".", "points", "[", ":", "3", ",", ":", "]", ",", "np", ".", "eye", "(", "4", ")", ",", "normalize", "=", "False", ")", "\n", "dists", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "pc", ".", "points", "[", ":", "2", ",", ":", "]", "**", "2", ",", "axis", "=", "0", ")", ")", "\n", "colors", "=", "np", ".", "minimum", "(", "1", ",", "dists", "/", "eval_range", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "colors", ",", "s", "=", "0.2", ")", "\n", "\n", "# Show ego vehicle.", "\n", "ax", ".", "plot", "(", "0", ",", "0", ",", "'x'", ",", "color", "=", "'black'", ")", "\n", "\n", "# Show GT boxes.", "\n", "for", "box", "in", "boxes_gt", ":", "\n", "        ", "box", ".", "render", "(", "ax", ",", "view", "=", "np", ".", "eye", "(", "4", ")", ",", "colors", "=", "(", "'g'", ",", "'g'", ",", "'g'", ")", ",", "linewidth", "=", "2", ")", "\n", "\n", "# Show EST boxes.", "\n", "", "for", "box", "in", "boxes_est", ":", "\n", "# Show only predictions with a high score.", "\n", "        ", "assert", "not", "np", ".", "isnan", "(", "box", ".", "score", ")", ",", "'Error: Box score cannot be NaN!'", "\n", "if", "box", ".", "score", ">=", "conf_th", ":", "\n", "            ", "box", ".", "render", "(", "ax", ",", "view", "=", "np", ".", "eye", "(", "4", ")", ",", "colors", "=", "(", "'b'", ",", "'b'", ",", "'b'", ")", ",", "linewidth", "=", "1", ")", "\n", "\n", "# Limit visible range.", "\n", "", "", "axes_limit", "=", "eval_range", "+", "3", "# Slightly bigger to include boxes that extend beyond the range.", "\n", "ax", ".", "set_xlim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "ax", ".", "set_ylim", "(", "-", "axes_limit", ",", "axes_limit", ")", "\n", "\n", "# Show / save plot.", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'Rendering sample token %s'", "%", "sample_token", ")", "\n", "", "plt", ".", "title", "(", "sample_token", ")", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.render_stratified_overall_metrics": [[106, 138], ["matplotlib.pyplot.figure", "matplotlib.pyplot.figure.add_subplot", "plt.figure.add_subplot.bar", "plt.figure.add_subplot.spines[].set_visible", "plt.figure.add_subplot.spines[].set_visible", "plt.figure.add_subplot.set_xticklabels", "plt.figure.add_subplot.set_ylabel", "plt.figure.add_subplot.set_ylim", "plt.figure.add_subplot.set_title", "plt.figure.add_subplot.tick_params", "enumerate", "matplotlib.pyplot.tight_layout", "matplotlib.pyplot.savefig", "list", "list", "plt.figure.add_subplot.text", "matplotlib.pyplot.show", "enumerate", "stratified_iou.keys", "stratified_iou.values", "rect.get_x", "rect.get_width", "rect.get_y", "rect.get_height", "list", "stratified_iou.values"], "methods", ["None"], ["", "", "def", "class_pr_curve", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n", "metrics", ":", "DetectionMetrics", ",", "\n", "detection_name", ":", "str", ",", "\n", "min_precision", ":", "float", ",", "\n", "min_recall", ":", "float", ",", "\n", "savepath", ":", "str", "=", "None", ",", "\n", "ax", ":", "Axis", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Plot a precision recall curve for the specified class.\n    :param md_list: DetectionMetricDataList instance.\n    :param metrics: DetectionMetrics instance.\n    :param detection_name: The detection class.\n    :param min_precision:\n    :param min_recall: Minimum recall value.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    :param ax: Axes onto which to render.\n    \"\"\"", "\n", "# Prepare axis.", "\n", "if", "ax", "is", "None", ":", "\n", "        ", "ax", "=", "setup_axis", "(", "title", "=", "PRETTY_DETECTION_NAMES", "[", "detection_name", "]", ",", "xlabel", "=", "'Recall'", ",", "ylabel", "=", "'Precision'", ",", "xlim", "=", "1", ",", "\n", "ylim", "=", "1", ",", "min_precision", "=", "min_precision", ",", "min_recall", "=", "min_recall", ")", "\n", "\n", "# Get recall vs precision values of given class for each distance threshold.", "\n", "", "data", "=", "md_list", ".", "get_class_data", "(", "detection_name", ")", "\n", "\n", "# Plot the recall vs. precision curve for each distance threshold.", "\n", "for", "md", ",", "dist_th", "in", "data", ":", "\n", "        ", "md", ":", "DetectionMetricData", "\n", "ap", "=", "metrics", ".", "get_label_ap", "(", "detection_name", ",", "dist_th", ")", "\n", "ax", ".", "plot", "(", "md", ".", "recall", ",", "md", ".", "precision", ",", "label", "=", "'Dist. : {}, AP: {:.1f}'", ".", "format", "(", "dist_th", ",", "ap", "*", "100", ")", ")", "\n", "\n", "", "ax", ".", "legend", "(", "loc", "=", "'best'", ")", "\n", "if", "savepath", "is", "not", "None", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.render_stratified_per_class_metrics": [[139, 180], ["stratified_classes.pop", "int", "matplotlib.gridspec.GridSpec", "matplotlib.pyplot.figure", "enumerate", "matplotlib.pyplot.tight_layout", "matplotlib.pyplot.savefig", "stratum_metrics[].items", "numpy.ceil", "stratified_classes.items", "matplotlib.pyplot.figure.add_subplot", "plt.figure.add_subplot.bar", "plt.figure.add_subplot.spines[].set_visible", "plt.figure.add_subplot.spines[].set_visible", "plt.figure.add_subplot.set_xticklabels", "plt.figure.add_subplot.set_ylabel", "plt.figure.add_subplot.set_ylim", "plt.figure.add_subplot.set_title", "plt.figure.add_subplot.tick_params", "enumerate", "matplotlib.pyplot.show", "render.LidarSegEvalStratified.id2name.values", "stratified_classes[].append", "plt.figure.add_subplot.text", "len", "numpy.array", "rect.get_x", "rect.get_width", "rect.get_y", "rect.get_height"], "methods", ["None"], ["        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "\n", "", "", "def", "class_tp_curve", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n", "metrics", ":", "DetectionMetrics", ",", "\n", "detection_name", ":", "str", ",", "\n", "min_recall", ":", "float", ",", "\n", "dist_th_tp", ":", "float", ",", "\n", "savepath", ":", "str", "=", "None", ",", "\n", "ax", ":", "Axis", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Plot the true positive curve for the specified class.\n    :param md_list: DetectionMetricDataList instance.\n    :param metrics: DetectionMetrics instance.\n    :param detection_name:\n    :param min_recall: Minimum recall value.\n    :param dist_th_tp: The distance threshold used to determine matches.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    :param ax: Axes onto which to render.\n    \"\"\"", "\n", "# Get metric data for given detection class with tp distance threshold.", "\n", "md", "=", "md_list", "[", "(", "detection_name", ",", "dist_th_tp", ")", "]", "\n", "min_recall_ind", "=", "round", "(", "100", "*", "min_recall", ")", "\n", "if", "min_recall_ind", "<=", "md", ".", "max_recall_ind", ":", "\n", "# For traffic_cone and barrier only a subset of the metrics are plotted.", "\n", "        ", "rel_metrics", "=", "[", "m", "for", "m", "in", "TP_METRICS", "if", "not", "np", ".", "isnan", "(", "metrics", ".", "get_label_tp", "(", "detection_name", ",", "m", ")", ")", "]", "\n", "ylimit", "=", "max", "(", "[", "max", "(", "getattr", "(", "md", ",", "metric", ")", "[", "min_recall_ind", ":", "md", ".", "max_recall_ind", "+", "1", "]", ")", "for", "metric", "in", "rel_metrics", "]", ")", "*", "1.1", "\n", "", "else", ":", "\n", "        ", "ylimit", "=", "1.0", "\n", "\n", "# Prepare axis.", "\n", "", "if", "ax", "is", "None", ":", "\n", "        ", "ax", "=", "setup_axis", "(", "title", "=", "PRETTY_DETECTION_NAMES", "[", "detection_name", "]", ",", "xlabel", "=", "'Recall'", ",", "ylabel", "=", "'Error'", ",", "xlim", "=", "1", ",", "\n", "min_recall", "=", "min_recall", ")", "\n", "", "ax", ".", "set_ylim", "(", "0", ",", "ylimit", ")", "\n", "\n", "# Plot the recall vs. error curve for each tp metric.", "\n", "for", "metric", "in", "TP_METRICS", ":", "\n", "        ", "tp", "=", "metrics", ".", "get_label_tp", "(", "detection_name", ",", "metric", ")", "\n", "\n", "# Plot only if we have valid data.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.get_stratified_per_class_metrics": [[181, 201], ["stratum_cm.get_per_class_iou", "stratum_cm.get_mean_iou", "stratum_cm.get_freqweighted_iou", "stratified_per_class_iou.append", "enumerate"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_per_class_iou", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_mean_iou", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_freqweighted_iou"], ["if", "tp", "is", "not", "np", ".", "nan", "and", "min_recall_ind", "<=", "md", ".", "max_recall_ind", ":", "\n", "            ", "recall", ",", "error", "=", "md", ".", "recall", "[", ":", "md", ".", "max_recall_ind", "+", "1", "]", ",", "getattr", "(", "md", ",", "metric", ")", "[", ":", "md", ".", "max_recall_ind", "+", "1", "]", "\n", "", "else", ":", "\n", "            ", "recall", ",", "error", "=", "[", "]", ",", "[", "]", "\n", "\n", "# Change legend based on tp value", "\n", "", "if", "tp", "is", "np", ".", "nan", ":", "\n", "            ", "label", "=", "'{}: n/a'", ".", "format", "(", "PRETTY_TP_METRICS", "[", "metric", "]", ")", "\n", "", "elif", "min_recall_ind", ">", "md", ".", "max_recall_ind", ":", "\n", "            ", "label", "=", "'{}: nan'", ".", "format", "(", "PRETTY_TP_METRICS", "[", "metric", "]", ")", "\n", "", "else", ":", "\n", "            ", "label", "=", "'{}: {:.2f} ({})'", ".", "format", "(", "PRETTY_TP_METRICS", "[", "metric", "]", ",", "tp", ",", "TP_METRICS_UNITS", "[", "metric", "]", ")", "\n", "", "ax", ".", "plot", "(", "recall", ",", "error", ",", "label", "=", "label", ")", "\n", "", "ax", ".", "axvline", "(", "x", "=", "md", ".", "max_recall", ",", "linestyle", "=", "'-.'", ",", "color", "=", "(", "0", ",", "0", ",", "0", ",", "0.3", ")", ")", "\n", "ax", ".", "legend", "(", "loc", "=", "'best'", ")", "\n", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.LidarSegEvalStratified.filter_pointcloud_by_depth": [[202, 232], ["numpy.linalg.norm", "numpy.where", "numpy.intersect1d", "numpy.where"], "methods", ["None"], ["", "", "def", "dist_pr_curve", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n", "metrics", ":", "DetectionMetrics", ",", "\n", "dist_th", ":", "float", ",", "\n", "min_precision", ":", "float", ",", "\n", "min_recall", ":", "float", ",", "\n", "savepath", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Plot the PR curves for different distance thresholds.\n    :param md_list: DetectionMetricDataList instance.\n    :param metrics: DetectionMetrics instance.\n    :param dist_th: Distance threshold for matching.\n    :param min_precision: Minimum precision value.\n    :param min_recall: Minimum recall value.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    \"\"\"", "\n", "# Prepare axis.", "\n", "fig", ",", "(", "ax", ",", "lax", ")", "=", "plt", ".", "subplots", "(", "ncols", "=", "2", ",", "gridspec_kw", "=", "{", "\"width_ratios\"", ":", "[", "4", ",", "1", "]", "}", ",", "\n", "figsize", "=", "(", "7.5", ",", "5", ")", ")", "\n", "ax", "=", "setup_axis", "(", "xlabel", "=", "'Recall'", ",", "ylabel", "=", "'Precision'", ",", "\n", "xlim", "=", "1", ",", "ylim", "=", "1", ",", "min_precision", "=", "min_precision", ",", "min_recall", "=", "min_recall", ",", "ax", "=", "ax", ")", "\n", "\n", "# Plot the recall vs. precision curve for each detection class.", "\n", "data", "=", "md_list", ".", "get_dist_data", "(", "dist_th", ")", "\n", "for", "md", ",", "detection_name", "in", "data", ":", "\n", "        ", "md", "=", "md_list", "[", "(", "detection_name", ",", "dist_th", ")", "]", "\n", "ap", "=", "metrics", ".", "get_label_ap", "(", "detection_name", ",", "dist_th", ")", "\n", "ax", ".", "plot", "(", "md", ".", "recall", ",", "md", ".", "precision", ",", "label", "=", "'{}: {:.1f}%'", ".", "format", "(", "PRETTY_DETECTION_NAMES", "[", "detection_name", "]", ",", "ap", "*", "100", ")", ",", "\n", "color", "=", "DETECTION_COLORS", "[", "detection_name", "]", ")", "\n", "", "hx", ",", "lx", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "lax", ".", "legend", "(", "hx", ",", "lx", ",", "borderaxespad", "=", "0", ")", "\n", "lax", ".", "axis", "(", "\"off\"", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.render.visualize_semantic_differences_bev": [[234, 299], ["nuscenes.eval.lidarseg.utils.LidarsegClassMapper", "nusc.get", "nusc.get", "os.path.join", "os.path.join", "nuscenes.utils.data_classes.LidarSegPointCloud", "nuscenes.eval.lidarseg.utils.LidarsegClassMapper.convert_label", "os.path.join", "nuscenes.utils.data_classes.LidarSegPointCloud", "matplotlib.pyplot.subplots", "nuscenes.utils.data_classes.LidarSegPointCloud.render", "nuscenes.utils.data_classes.LidarSegPointCloud.render", "nuscenes.lidarseg.lidarseg_utils.colormap_to_colors", "numpy.array().astype", "axes[].scatter", "axes[].set_title", "matplotlib.pyplot.xlim", "matplotlib.pyplot.ylim", "matplotlib.pyplot.tight_layout", "matplotlib.pyplot.show", "numpy.where", "matplotlib.pyplot.savefig", "nusc.get", "numpy.array"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.convert_label", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.render.TrackingRenderer.render", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.colormap_to_colors", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "\n", "", "", "def", "summary_plot", "(", "md_list", ":", "DetectionMetricDataList", ",", "\n", "metrics", ":", "DetectionMetrics", ",", "\n", "min_precision", ":", "float", ",", "\n", "min_recall", ":", "float", ",", "\n", "dist_th_tp", ":", "float", ",", "\n", "savepath", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Creates a summary plot with PR and TP curves for each class.\n    :param md_list: DetectionMetricDataList instance.\n    :param metrics: DetectionMetrics instance.\n    :param min_precision: Minimum precision value.\n    :param min_recall: Minimum recall value.\n    :param dist_th_tp: The distance threshold used to determine matches.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    \"\"\"", "\n", "n_classes", "=", "len", "(", "DETECTION_NAMES", ")", "\n", "_", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "n_classes", ",", "ncols", "=", "2", ",", "figsize", "=", "(", "15", ",", "5", "*", "n_classes", ")", ")", "\n", "for", "ind", ",", "detection_name", "in", "enumerate", "(", "DETECTION_NAMES", ")", ":", "\n", "        ", "title1", ",", "title2", "=", "(", "'Recall vs Precision'", ",", "'Recall vs Error'", ")", "if", "ind", "==", "0", "else", "(", "None", ",", "None", ")", "\n", "\n", "ax1", "=", "setup_axis", "(", "xlim", "=", "1", ",", "ylim", "=", "1", ",", "title", "=", "title1", ",", "min_precision", "=", "min_precision", ",", "\n", "min_recall", "=", "min_recall", ",", "ax", "=", "axes", "[", "ind", ",", "0", "]", ")", "\n", "ax1", ".", "set_ylabel", "(", "'{} \\n \\n Precision'", ".", "format", "(", "PRETTY_DETECTION_NAMES", "[", "detection_name", "]", ")", ",", "size", "=", "20", ")", "\n", "\n", "ax2", "=", "setup_axis", "(", "xlim", "=", "1", ",", "title", "=", "title2", ",", "min_recall", "=", "min_recall", ",", "ax", "=", "axes", "[", "ind", ",", "1", "]", ")", "\n", "if", "ind", "==", "n_classes", "-", "1", ":", "\n", "            ", "ax1", ".", "set_xlabel", "(", "'Recall'", ",", "size", "=", "20", ")", "\n", "ax2", ".", "set_xlabel", "(", "'Recall'", ",", "size", "=", "20", ")", "\n", "\n", "", "class_pr_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "min_precision", ",", "min_recall", ",", "ax", "=", "ax1", ")", "\n", "class_tp_curve", "(", "md_list", ",", "metrics", ",", "detection_name", ",", "min_recall", ",", "dist_th_tp", "=", "dist_th_tp", ",", "ax", "=", "ax2", ")", "\n", "\n", "", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "if", "savepath", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savepath", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "\n", "", "", "def", "detailed_results_table_tex", "(", "metrics_path", ":", "str", ",", "output_path", ":", "str", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Renders a detailed results table in tex.\n    :param metrics_path: path to a serialized DetectionMetrics file.\n    :param output_path: path to the output file.\n    \"\"\"", "\n", "with", "open", "(", "metrics_path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "metrics", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "tex", "=", "''", "\n", "tex", "+=", "'\\\\begin{table}[]\\n'", "\n", "tex", "+=", "'\\\\small\\n'", "\n", "tex", "+=", "'\\\\begin{tabular}{| c | c | c | c | c | c | c |} \\\\hline\\n'", "\n", "tex", "+=", "'\\\\textbf{Class}    &   \\\\textbf{AP}  &   \\\\textbf{ATE} &   \\\\textbf{ASE} & \\\\textbf{AOE}   & '", "'\\\\textbf{AVE}   & '", "'\\\\textbf{AAE}   \\\\\\\\ \\\\hline '", "'\\\\hline\\n'", "\n", "for", "name", "in", "DETECTION_NAMES", ":", "\n", "        ", "ap", "=", "np", ".", "mean", "(", "metrics", "[", "'label_aps'", "]", "[", "name", "]", ".", "values", "(", ")", ")", "*", "100", "\n", "ate", "=", "metrics", "[", "'label_tp_errors'", "]", "[", "name", "]", "[", "'trans_err'", "]", "\n", "ase", "=", "metrics", "[", "'label_tp_errors'", "]", "[", "name", "]", "[", "'scale_err'", "]", "\n", "aoe", "=", "metrics", "[", "'label_tp_errors'", "]", "[", "name", "]", "[", "'orient_err'", "]", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.validate_submission.validate_submission": [[14, 129], ["nuscenes.eval.lidarseg.utils.LidarsegClassMapper", "len", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists", "nuscenes.eval.lidarseg.utils.get_samples_in_eval_set", "tqdm.tqdm", "print", "print", "print", "open", "json.load", "print", "print", "nusc.get", "os.path.join", "os.path.exists", "numpy.fromfile", "all", "print", "print", "os.path.exists", "os.path.join", "shutil.make_archive", "set", "type", "len", "os.path.join", "os.path.exists", "numpy.fromfile", "len", "nusc.get", "os.path.join", "nuscenes.utils.data_classes.LidarPointCloud.from_file", "len", "len", "os.path.basename", "print", "submission_meta[].keys", "os.path.normpath", "nusc.get"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.get_samples_in_eval_set", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.RadarPointCloud.from_file", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["def", "validate_submission", "(", "nusc", ":", "NuScenes", ",", "\n", "results_folder", ":", "str", ",", "\n", "eval_set", ":", "str", ",", "\n", "verbose", ":", "bool", "=", "False", ",", "\n", "zip_out", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Checks if a results folder is valid. The following checks are performed:\n    - Check that the submission folder is according to that described in\n      https://github.com/nutonomy/nuscenes-devkit/blob/master/python-sdk/nuscenes/eval/lidarseg/README.md\n    - Check that the submission.json is of the following structure:\n        {\"meta\": {\"use_camera\": false,\n                  \"use_lidar\": true,\n                  \"use_radar\": false,\n                  \"use_map\": false,\n                  \"use_external\": false}}\n    - Check that each each lidar sample data in the evaluation set is present and valid.\n\n    :param nusc: A NuScenes object.\n    :param results_folder: Path to the folder.\n    :param eval_set: The dataset split to evaluate on, e.g. train, val or test.\n    :param verbose: Whether to print messages during the evaluation.\n    :param zip_out: Path to zip results_folder to, if provided.\n    \"\"\"", "\n", "mapper", "=", "LidarsegClassMapper", "(", "nusc", ")", "\n", "num_classes", "=", "len", "(", "mapper", ".", "coarse_name_2_coarse_idx_mapping", ")", "\n", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'Checking if folder structure of {} is correct...'", ".", "format", "(", "results_folder", ")", ")", "\n", "\n", "# Check that {results_folder}/{eval_set} exists.", "\n", "", "results_meta_folder", "=", "os", ".", "path", ".", "join", "(", "results_folder", ",", "eval_set", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "results_meta_folder", ")", ",", "'Error: The folder containing the submission.json ({}) does not exist.'", ".", "format", "(", "results_meta_folder", ")", "\n", "\n", "# Check that {results_folder}/{eval_set}/submission.json exists.", "\n", "submisson_json_path", "=", "os", ".", "path", ".", "join", "(", "results_meta_folder", ",", "'submission.json'", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "submisson_json_path", ")", ",", "'Error: submission.json ({}) does not exist.'", ".", "format", "(", "submisson_json_path", ")", "\n", "\n", "# Check that {results_folder}/lidarseg/{eval_set} exists.", "\n", "results_bin_folder", "=", "os", ".", "path", ".", "join", "(", "results_folder", ",", "'lidarseg'", ",", "eval_set", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "results_bin_folder", ")", ",", "'Error: The folder containing the .bin files ({}) does not exist.'", ".", "format", "(", "results_bin_folder", ")", "\n", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "'\\tPassed.'", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'Checking contents of {}...'", ".", "format", "(", "submisson_json_path", ")", ")", "\n", "\n", "", "with", "open", "(", "submisson_json_path", ")", "as", "f", ":", "\n", "        ", "submission_meta", "=", "json", ".", "load", "(", "f", ")", "\n", "valid_meta", "=", "{", "\"use_camera\"", ",", "\"use_lidar\"", ",", "\"use_radar\"", ",", "\"use_map\"", ",", "\"use_external\"", "}", "\n", "assert", "valid_meta", "==", "set", "(", "submission_meta", "[", "'meta'", "]", ".", "keys", "(", ")", ")", ",", "'{} must contain {}.'", ".", "format", "(", "submisson_json_path", ",", "valid_meta", ")", "\n", "for", "meta_key", "in", "valid_meta", ":", "\n", "            ", "meta_key_type", "=", "type", "(", "submission_meta", "[", "'meta'", "]", "[", "meta_key", "]", ")", "\n", "assert", "meta_key_type", "==", "bool", ",", "'Error: Value for {} should be bool, not {}.'", ".", "format", "(", "meta_key", ",", "meta_key_type", ")", "\n", "\n", "", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'\\tPassed.'", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'Checking if all .bin files for {} exist and are valid...'", ".", "format", "(", "eval_set", ")", ")", "\n", "", "sample_tokens", "=", "get_samples_in_eval_set", "(", "nusc", ",", "eval_set", ")", "\n", "for", "sample_token", "in", "tqdm", "(", "sample_tokens", ",", "disable", "=", "not", "verbose", ")", ":", "\n", "        ", "sample", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "\n", "# Get the sample data token of the point cloud.", "\n", "sd_token", "=", "sample", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", "\n", "\n", "# Load the predictions for the point cloud.", "\n", "lidarseg_pred_filename", "=", "os", ".", "path", ".", "join", "(", "results_bin_folder", ",", "sd_token", "+", "'_lidarseg.bin'", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "lidarseg_pred_filename", ")", ",", "'Error: The prediction .bin file {} does not exist.'", ".", "format", "(", "lidarseg_pred_filename", ")", "\n", "lidarseg_pred", "=", "np", ".", "fromfile", "(", "lidarseg_pred_filename", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "# Check number of predictions for the point cloud.", "\n", "if", "len", "(", "nusc", ".", "lidarseg", ")", ">", "0", ":", "# If ground truth exists, compare the no. of predictions with that of ground truth.", "\n", "            ", "lidarseg_label_filename", "=", "os", ".", "path", ".", "join", "(", "nusc", ".", "dataroot", ",", "nusc", ".", "get", "(", "'lidarseg'", ",", "sd_token", ")", "[", "'filename'", "]", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "lidarseg_label_filename", ")", ",", "'Error: The ground truth .bin file {} does not exist.'", ".", "format", "(", "lidarseg_label_filename", ")", "\n", "lidarseg_label", "=", "np", ".", "fromfile", "(", "lidarseg_label_filename", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "num_points", "=", "len", "(", "lidarseg_label", ")", "\n", "", "else", ":", "# If no ground truth is available, compare the no. of predictions with that of points in a point cloud.", "\n", "            ", "pointsensor", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sd_token", ")", "\n", "pcl_path", "=", "os", ".", "path", ".", "join", "(", "nusc", ".", "dataroot", ",", "pointsensor", "[", "'filename'", "]", ")", "\n", "pc", "=", "LidarPointCloud", ".", "from_file", "(", "pcl_path", ")", "\n", "points", "=", "pc", ".", "points", "\n", "num_points", "=", "points", ".", "shape", "[", "1", "]", "\n", "\n", "", "assert", "num_points", "==", "len", "(", "lidarseg_pred", ")", ",", "'Error: There are {} predictions for lidar sample data token {} '", "'but there are only {} points in the point cloud.'", ".", "format", "(", "len", "(", "lidarseg_pred", ")", ",", "sd_token", ",", "num_points", ")", "\n", "\n", "assert", "all", "(", "(", "lidarseg_pred", ">", "0", ")", "&", "(", "lidarseg_pred", "<", "num_classes", ")", ")", ",", "\"Error: Array for predictions in {} must be between 1 and {} (inclusive).\"", ".", "format", "(", "lidarseg_pred_filename", ",", "num_classes", "-", "1", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'\\tPassed.'", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'Results folder {} successfully validated!'", ".", "format", "(", "results_folder", ")", ")", "\n", "\n", "# Zip up results folder if desired.", "\n", "", "if", "zip_out", ":", "\n", "        ", "assert", "os", ".", "path", ".", "exists", "(", "zip_out", ")", ",", "'Error: The folder {} to zip the results to does not exist.'", ".", "format", "(", "zip_out", ")", "\n", "\n", "results_zip", "=", "os", ".", "path", ".", "join", "(", "zip_out", ",", "os", ".", "path", ".", "basename", "(", "os", ".", "path", ".", "normpath", "(", "results_folder", ")", ")", ")", "\n", "results_zip_name", "=", "shutil", ".", "make_archive", "(", "results_zip", ",", "'zip'", ",", "results_folder", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Results folder {} zipped to {}'", ".", "format", "(", "results_folder", ",", "results_zip_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.__init__": [[12, 22], ["None"], "methods", ["None"], ["from", "pycocotools", "import", "mask", "as", "cocomask", "\n", "\n", "\n", "def", "annotation_name", "(", "attributes", ":", "List", "[", "dict", "]", ",", "\n", "category_name", ":", "str", ",", "\n", "with_attributes", ":", "bool", "=", "False", ")", "->", "str", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update": [[23, 35], ["utils.ConfusionMatrix._get_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix._get_confusion_matrix"], ["\n", "outstr", "=", "category_name", "\n", "\n", "if", "with_attributes", ":", "\n", "        ", "atts", "=", "[", "attribute", "[", "'name'", "]", "for", "attribute", "in", "attributes", "]", "\n", "if", "len", "(", "atts", ")", ">", "0", ":", "\n", "            ", "outstr", "=", "outstr", "+", "\"--\"", "+", "'.'", ".", "join", "(", "atts", ")", "\n", "\n", "", "", "return", "outstr", "\n", "\n", "\n", "", "def", "mask_decode", "(", "mask", ":", "dict", ")", "->", "np", ".", "ndarray", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix._get_confusion_matrix": [[36, 61], ["all", "all", "numpy.bincount", "numpy.bincount.reshape", "gt_array.astype"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["    ", "\"\"\"\n    Decode the mask from base64 string to binary string, then feed it to the external pycocotools library to get a mask.\n    :param mask: The mask dictionary with fields `size` and `counts`.\n    :return: A numpy array representing the binary mask for this class.\n    \"\"\"", "\n", "# Note that it is essential to copy the mask here. If we use the same variable we will overwrite the NuImage class", "\n", "# and cause the Jupyter Notebook to crash on some systems.", "\n", "new_mask", "=", "mask", ".", "copy", "(", ")", "\n", "new_mask", "[", "'counts'", "]", "=", "base64", ".", "b64decode", "(", "mask", "[", "'counts'", "]", ")", "\n", "return", "cocomask", ".", "decode", "(", "new_mask", ")", "\n", "\n", "\n", "", "def", "get_font", "(", "fonts_valid", ":", "List", "[", "str", "]", "=", "None", ",", "font_size", ":", "int", "=", "15", ")", "->", "ImageFont", ":", "\n", "    ", "\"\"\"\n    Check if there is a desired font present in the user's system. If there is, use that font; otherwise, use a default\n    font.\n    :param fonts_valid: A list of fonts which are desirable.\n    :param font_size: The size of the font to set. Note that if the default font is used, then the font size\n        cannot be set.\n    :return: An ImageFont object to use as the font in a PIL image.\n    \"\"\"", "\n", "# If there are no desired fonts supplied, use a hardcoded list of fonts which are desirable.", "\n", "if", "fonts_valid", "is", "None", ":", "\n", "        ", "fonts_valid", "=", "[", "'FreeSerif.ttf'", ",", "'FreeSans.ttf'", ",", "'Century.ttf'", ",", "'Calibri.ttf'", ",", "'arial.ttf'", "]", "\n", "\n", "# Find a list of fonts within the user's system.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_per_class_iou": [[62, 85], ["utils.ConfusionMatrix.global_cm.copy", "numpy.diagonal", "utils.ConfusionMatrix.sum", "utils.ConfusionMatrix.sum", "numpy.errstate", "union.astype"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["", "fonts_in_sys", "=", "matplotlib", ".", "font_manager", ".", "findSystemFonts", "(", "fontpaths", "=", "None", ",", "fontext", "=", "'ttf'", ")", "\n", "# Sort the list of fonts to ensure that the desired fonts are always found in the same order.", "\n", "fonts_in_sys", "=", "sorted", "(", "fonts_in_sys", ")", "\n", "# Of all the fonts found in the user's system, check if any of them are desired.", "\n", "for", "font_in_sys", "in", "fonts_in_sys", ":", "\n", "        ", "if", "any", "(", "os", ".", "path", ".", "basename", "(", "font_in_sys", ")", "in", "s", "for", "s", "in", "fonts_valid", ")", ":", "\n", "            ", "return", "ImageFont", ".", "truetype", "(", "font_in_sys", ",", "font_size", ")", "\n", "\n", "# If none of the fonts in the user's system are desirable, then use the default font.", "\n", "", "", "warnings", ".", "warn", "(", "'No suitable fonts were found in your system. '", "\n", "'A default font will be used instead (the font size will not be adjustable).'", ")", "\n", "return", "ImageFont", ".", "load_default", "(", ")", "\n", "\n", "\n", "", "def", "name_to_index_mapping", "(", "category", ":", "List", "[", "dict", "]", ")", "->", "Dict", "[", "str", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Build a mapping from name to index to look up index in O(1) time.\n    :param category: The nuImages category table.\n    :return: The mapping from category name to category index.\n    \"\"\"", "\n", "# The 0 index is reserved for non-labelled background; thus, the categories should start from index 1.", "\n", "# Also, sort the categories before looping so that the order is always the same (alphabetical).", "\n", "name_to_index", "=", "dict", "(", ")", "\n", "i", "=", "1", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_mean_iou": [[86, 94], ["utils.ConfusionMatrix.get_per_class_iou", "float", "numpy.nanmean"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_per_class_iou"], ["sorted_category", ":", "List", "=", "sorted", "(", "category", ".", "copy", "(", ")", ",", "key", "=", "lambda", "k", ":", "k", "[", "'name'", "]", ")", "\n", "for", "c", "in", "sorted_category", ":", "\n", "# Ignore the vehicle.ego and flat.driveable_surface classes first; they will be mapped later.", "\n", "        ", "if", "c", "[", "'name'", "]", "!=", "'vehicle.ego'", "and", "c", "[", "'name'", "]", "!=", "'flat.driveable_surface'", ":", "\n", "            ", "name_to_index", "[", "c", "[", "'name'", "]", "]", "=", "i", "\n", "i", "+=", "1", "\n", "\n", "", "", "assert", "max", "(", "name_to_index", ".", "values", "(", ")", ")", "<", "24", ",", "'Error: There are {} classes (excluding vehicle.ego and flat.driveable_surface), '"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_freqweighted_iou": [[95, 115], ["utils.ConfusionMatrix.global_cm.copy", "utils.ConfusionMatrix.sum", "utils.ConfusionMatrix.sum", "utils.ConfusionMatrix.get_per_class_iou", "float", "numpy.nansum"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.get_per_class_iou"], ["'but there should be 23. Please check your category.json'", ".", "format", "(", "max", "(", "name_to_index", ".", "values", "(", ")", ")", ")", "\n", "\n", "# Now map the vehicle.ego and flat.driveable_surface classes.", "\n", "name_to_index", "[", "'flat.driveable_surface'", "]", "=", "24", "\n", "name_to_index", "[", "'vehicle.ego'", "]", "=", "31", "\n", "\n", "# Ensure that each class name is uniquely paired with a class index, and vice versa.", "\n", "assert", "len", "(", "name_to_index", ")", "==", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ",", "'Error: There are {} class names but {} class indices'", ".", "format", "(", "len", "(", "name_to_index", ")", ",", "\n", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ")", "\n", "\n", "return", "name_to_index", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.__init__": [[125, 141], ["utils.LidarsegClassMapper.get_ignore_class", "utils.LidarsegClassMapper.get_fine2coarse", "utils.LidarsegClassMapper.get_coarse2idx", "utils.LidarsegClassMapper.get_coarse2color", "utils.LidarsegClassMapper.check_mapping", "utils.LidarsegClassMapper.get_fine_idx_2_coarse_idx"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_ignore_class", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_fine2coarse", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_coarse2idx", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_coarse2color", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.check_mapping", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_fine_idx_2_coarse_idx"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_ignore_class": [[142, 149], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_fine2coarse": [[150, 187], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_coarse2idx": [[188, 210], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_coarse2color": [[211, 233], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_fine_idx_2_coarse_idx": [[234, 245], ["dict", "utils.LidarsegClassMapper.nusc.lidarseg_name2idx_mapping.items"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.check_mapping": [[246, 256], ["set", "utils.LidarsegClassMapper.fine_name_2_coarse_name_mapping.items", "set.add", "set", "utils.LidarsegClassMapper.coarse_name_2_coarse_idx_mapping.keys"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.convert_label": [[257, 274], ["utils.LidarsegClassMapper.get_stats", "utils.LidarsegClassMapper.get_stats", "utils.LidarsegClassMapper.compare_stats", "numpy.vectorize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.get_stats", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.get_stats", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.compare_stats"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.compare_stats": [[275, 292], ["enumerate", "len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.LidarsegClassMapper.get_stats": [[293, 314], ["numpy.bincount", "zip", "numpy.nonzero", "max", "max", "max", "utils.LidarsegClassMapper.fine_idx_2_coarse_idx_mapping.keys", "utils.LidarsegClassMapper.fine_idx_2_coarse_idx_mapping.values"], "methods", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.get_samples_in_eval_set": [[316, 355], ["dict", "nuscenes.utils.splits.create_splits_scenes", "nusc.get", "nusc.get", "samples.append"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_scenes", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], []], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.get_stats": [[14, 33], ["numpy.bincount", "zip", "numpy.nonzero"], "function", ["None"], ["def", "get_stats", "(", "points_label", ":", "np", ".", "array", ",", "num_classes", ":", "int", ")", "->", "List", "[", "int", "]", ":", "\n", "    ", "\"\"\"\n    Get frequency of each label in a point cloud.\n    :param num_classes: The number of classes.\n    :param points_label: A numPy array which contains the labels of the point cloud; e.g. np.array([2, 1, 34, ..., 38])\n    :return: An array which contains the counts of each label in the point cloud. The index of the point cloud\n              corresponds to the index of the class label. E.g. [0, 2345, 12, 451] means that there are no points in\n              class 0, there are 2345 points in class 1, there are 12 points in class 2 etc.\n    \"\"\"", "\n", "\n", "lidarseg_counts", "=", "[", "0", "]", "*", "num_classes", "# Create as many bins as there are classes, and initialize all bins as 0.", "\n", "\n", "indices", ":", "np", ".", "ndarray", "=", "np", ".", "bincount", "(", "points_label", ")", "\n", "ii", "=", "np", ".", "nonzero", "(", "indices", ")", "[", "0", "]", "\n", "\n", "for", "class_idx", ",", "class_count", "in", "zip", "(", "ii", ",", "indices", "[", "ii", "]", ")", ":", "\n", "        ", "lidarseg_counts", "[", "class_idx", "]", "+=", "class_count", "# Increment the count for the particular class name.", "\n", "\n", "", "return", "lidarseg_counts", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.plt_to_cv2": [[35, 69], ["matplotlib.figure", "matplotlib.Axes", "plt.figure.add_axes", "plt.Axes.axis", "plt.Axes.margins", "plt.Axes.imshow", "plt.Axes.scatter", "matplotlib.backends.backend_agg.FigureCanvasAgg", "matplotlib.backends.backend_agg.FigureCanvasAgg.draw", "numpy.array().astype", "cv2.cvtColor", "cv2.resize", "matplotlib.close", "numpy.array", "matplotlib.backends.backend_agg.FigureCanvasAgg.renderer.buffer_rgba"], "function", ["None"], ["", "def", "plt_to_cv2", "(", "points", ":", "np", ".", "array", ",", "coloring", ":", "np", ".", "array", ",", "im", ",", "imsize", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "640", ",", "360", ")", ",", "dpi", ":", "int", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Converts a scatter plot in matplotlib to an image in cv2. This is useful as cv2 is unable to do\n    scatter plots.\n    :param points: A numPy array (of size [2 x num_points] and type float) representing the pointcloud.\n    :param coloring: A numPy array (of size [num_points] containing the color (in RGB, normalized\n                     between 0 and 1) for each point.\n    :param im: An image (e.g. a camera view) to put the scatter plot on.\n    :param imsize: Size of image to render. The larger the slower this will run.\n    :param dpi: Resolution of the output figure.\n    :return: cv2 image with the scatter plot.\n    \"\"\"", "\n", "# Render lidarseg labels in image.", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "imsize", "[", "0", "]", "/", "dpi", ",", "imsize", "[", "1", "]", "/", "dpi", ")", ",", "dpi", "=", "dpi", ")", "\n", "ax", "=", "plt", ".", "Axes", "(", "fig", ",", "[", "0.", ",", "0.", ",", "1.", ",", "1.", "]", ")", "\n", "fig", ".", "add_axes", "(", "ax", ")", "\n", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "ax", ".", "margins", "(", "0", ",", "0", ")", "\n", "\n", "ax", ".", "imshow", "(", "im", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "0", ",", ":", "]", ",", "points", "[", "1", ",", ":", "]", ",", "c", "=", "coloring", ",", "s", "=", "5", ")", "\n", "\n", "# Convert from pyplot to cv2.", "\n", "canvas", "=", "FigureCanvas", "(", "fig", ")", "\n", "canvas", ".", "draw", "(", ")", "\n", "mat", "=", "np", ".", "array", "(", "canvas", ".", "renderer", ".", "buffer_rgba", "(", ")", ")", ".", "astype", "(", "'uint8'", ")", "# Put pixel buffer in numpy array.", "\n", "mat", "=", "cv2", ".", "cvtColor", "(", "mat", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "mat", "=", "cv2", ".", "resize", "(", "mat", ",", "imsize", ")", "\n", "\n", "# Clear off the current figure to prevent an accumulation of figures in memory.", "\n", "plt", ".", "close", "(", "'all'", ")", "\n", "\n", "return", "mat", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.colormap_to_colors": [[71, 89], ["enumerate", "colormap.items", "colors.append", "numpy.array"], "function", ["None"], ["", "def", "colormap_to_colors", "(", "colormap", ":", "Dict", "[", "str", ",", "Iterable", "[", "int", "]", "]", ",", "name2idx", ":", "Dict", "[", "str", ",", "int", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Create an array of RGB values from a colormap. Note that the RGB values are normalized\n    between 0 and 1, not 0 and 255.\n    :param colormap: A dictionary containing the mapping from class names to RGB values.\n    :param name2idx: A dictionary containing the mapping form class names to class index.\n    :return: An array of colors.\n    \"\"\"", "\n", "colors", "=", "[", "]", "\n", "for", "i", ",", "(", "k", ",", "v", ")", "in", "enumerate", "(", "colormap", ".", "items", "(", ")", ")", ":", "\n", "# Ensure that the indices from the colormap is same as the class indices.", "\n", "        ", "assert", "i", "==", "name2idx", "[", "k", "]", ",", "'Error: {} is of index {}, '", "'but it is of index {} in the colormap.'", ".", "format", "(", "k", ",", "name2idx", "[", "k", "]", ",", "i", ")", "\n", "colors", ".", "append", "(", "v", ")", "\n", "\n", "", "colors", "=", "np", ".", "array", "(", "colors", ")", "/", "255", "# Normalize RGB values to be between 0 and 1 for each channel.", "\n", "\n", "return", "colors", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.filter_colors": [[91, 114], ["range", "numpy.array", "numpy.concatenate", "len", "numpy.all"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["", "def", "filter_colors", "(", "colors", ":", "np", ".", "array", ",", "classes_to_display", ":", "np", ".", "array", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Given an array of RGB colors and a list of classes to display, return a colormap (in RGBA) with the opacity\n    of the labels to be display set to 1.0 and those to be hidden set to 0.0\n    :param colors: [n x 3] array where each row consist of the RGB values for the corresponding class index\n    :param classes_to_display: An array of classes to display (e.g. [1, 8, 32]). The array need not be ordered.\n    :return: (colormap <np.float: n, 4)>).\n\n    colormap = np.array([[R1, G1, B1],             colormap = np.array([[1.0, 1.0, 1.0, 0.0],\n                         [R2, G2, B2],   ------>                        [R2,  G2,  B2,  1.0],\n                         ...,                                           ...,\n                         Rn, Gn, Bn]])                                  [1.0, 1.0, 1.0, 0.0]])\n    \"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "colors", ")", ")", ":", "\n", "        ", "if", "i", "not", "in", "classes_to_display", ":", "\n", "            ", "colors", "[", "i", "]", "=", "[", "1.0", ",", "1.0", ",", "1.0", "]", "# Mask labels to be hidden with 1.0 in all channels.", "\n", "\n", "# Convert the RGB colormap to an RGBA array, with the alpha channel set to zero whenever the R, G and B channels", "\n", "# are all equal to 1.0.", "\n", "", "", "alpha", "=", "np", ".", "array", "(", "[", "~", "np", ".", "all", "(", "colors", "==", "1.0", ",", "axis", "=", "1", ")", "*", "1.0", "]", ")", "\n", "colors", "=", "np", ".", "concatenate", "(", "(", "colors", ",", "alpha", ".", "T", ")", ",", "axis", "=", "1", ")", "\n", "\n", "return", "colors", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.get_labels_in_coloring": [[116, 146], ["list", "enumerate", "next", "set", "lidarseg_utils.get_labels_in_coloring._array_in_list"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["", "def", "get_labels_in_coloring", "(", "color_legend", ":", "np", ".", "ndarray", ",", "coloring", ":", "np", ".", "ndarray", ")", "->", "List", "[", "int", "]", ":", "\n", "    ", "\"\"\"\n    Find the class labels which are present in a pointcloud which has been projected onto an image.\n    :param color_legend: A list of arrays in which each array corresponds to the RGB values of a class.\n    :param coloring: A list of arrays in which each array corresponds to the RGB values of a point in the portion of\n                     the pointcloud projected onto the image.\n    :return: List of class indices which are present in the image.\n    \"\"\"", "\n", "\n", "def", "_array_in_list", "(", "arr", ":", "List", ",", "list_arrays", ":", "List", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Check if an array is in a list of arrays.\n        :param: arr: An array.\n        :param: list_arrays: A list of arrays.\n        :return: Whether the given array is in the list of arrays.\n        \"\"\"", "\n", "# Credits: https://stackoverflow.com/questions/23979146/check-if-numpy-array-is-in-list-of-numpy-arrays", "\n", "return", "next", "(", "(", "True", "for", "elem", "in", "list_arrays", "if", "np", ".", "array_equal", "(", "elem", ",", "arr", ")", ")", ",", "False", ")", "\n", "\n", "", "filter_lidarseg_labels", "=", "[", "]", "\n", "\n", "# Get only the distinct colors present in the pointcloud so that we will not need to compare each color in", "\n", "# the color legend with every single point in the pointcloud later.", "\n", "distinct_colors", "=", "list", "(", "set", "(", "tuple", "(", "c", ")", "for", "c", "in", "coloring", ")", ")", "\n", "\n", "for", "i", ",", "color", "in", "enumerate", "(", "color_legend", ")", ":", "\n", "        ", "if", "_array_in_list", "(", "color", ",", "distinct_colors", ")", ":", "\n", "            ", "filter_lidarseg_labels", ".", "append", "(", "i", ")", "\n", "\n", "", "", "return", "filter_lidarseg_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.create_lidarseg_legend": [[148, 184], ["range", "len", "ax.legend", "matplotlib.legend", "sorted", "recs.append", "classes_final.append", "idx2name.items", "matplotlib.Rectangle", "numpy.array"], "function", ["None"], ["", "def", "create_lidarseg_legend", "(", "labels_to_include_in_legend", ":", "List", "[", "int", "]", ",", "\n", "idx2name", ":", "Dict", "[", "int", ",", "str", "]", ",", "\n", "name2color", ":", "Dict", "[", "str", ",", "Tuple", "[", "int", ",", "int", ",", "int", "]", "]", ",", "\n", "ax", ":", "axes", ".", "Axes", "=", "None", ",", "\n", "loc", ":", "str", "=", "'upper center'", ",", "\n", "ncol", ":", "int", "=", "3", ",", "\n", "bbox_to_anchor", ":", "Tuple", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Given a list of class indices, the mapping from class index to class name, and the mapping from class name\n    to class color, produce a legend which shows the color and the corresponding class name.\n    :param labels_to_include_in_legend: Labels to show in the legend.\n    :param idx2name: The mapping from class index to class name.\n    :param name2color: The mapping from class name to class color.\n    :param ax: Axes onto which to render.\n    :param loc: The location of the legend.\n    :param ncol: The number of columns that the legend has.\n    :param bbox_to_anchor: A 2-tuple (x, y) which places the top-left corner of the legend specified by loc\n                           at x, y. The origin is at the bottom-left corner and x and y are normalized between\n                           0 and 1 (i.e. x > 1 and / or y > 1 will place the legend outside the plot.\n    \"\"\"", "\n", "\n", "recs", "=", "[", "]", "\n", "classes_final", "=", "[", "]", "\n", "classes", "=", "[", "name", "for", "idx", ",", "name", "in", "sorted", "(", "idx2name", ".", "items", "(", ")", ")", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "classes", ")", ")", ":", "\n", "        ", "if", "labels_to_include_in_legend", "is", "None", "or", "i", "in", "labels_to_include_in_legend", ":", "\n", "            ", "name", "=", "classes", "[", "i", "]", "\n", "recs", ".", "append", "(", "mpatches", ".", "Rectangle", "(", "(", "0", ",", "0", ")", ",", "1", ",", "1", ",", "fc", "=", "np", ".", "array", "(", "name2color", "[", "name", "]", ")", "/", "255", ")", ")", "\n", "\n", "# Truncate class names to only first 25 chars so that legend is not excessively long.", "\n", "classes_final", ".", "append", "(", "classes", "[", "i", "]", "[", ":", "25", "]", ")", "\n", "", "", "if", "ax", "is", "not", "None", ":", "\n", "        ", "ax", ".", "legend", "(", "recs", ",", "classes_final", ",", "loc", "=", "loc", ",", "ncol", "=", "ncol", ",", "bbox_to_anchor", "=", "bbox_to_anchor", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "legend", "(", "recs", ",", "classes_final", ",", "loc", "=", "loc", ",", "ncol", "=", "ncol", ",", "bbox_to_anchor", "=", "bbox_to_anchor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.paint_points_label": [[186, 227], ["numpy.fromfile", "lidarseg_utils.colormap_to_colors", "isinstance", "all", "lidarseg_utils.filter_colors", "len", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.colormap_to_colors", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.lidarseg_utils.filter_colors"], ["", "", "def", "paint_points_label", "(", "lidarseg_labels_filename", ":", "str", ",", "filter_lidarseg_labels", ":", "List", "[", "int", "]", ",", "\n", "name2idx", ":", "Dict", "[", "str", ",", "int", "]", ",", "colormap", ":", "Dict", "[", "str", ",", "Tuple", "[", "int", ",", "int", ",", "int", "]", "]", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Paint each label in a pointcloud with the corresponding RGB value, and set the opacity of the labels to\n    be shown to 1 (the opacity of the rest will be set to 0); e.g.:\n        [30, 5, 12, 34, ...] ------> [[R30, G30, B30, 0], [R5, G5, B5, 1], [R34, G34, B34, 1], ...]\n    :param lidarseg_labels_filename: Path to the .bin file containing the labels.\n    :param filter_lidarseg_labels: The labels for which to set opacity to zero; this is to hide those points\n                                   thereby preventing them from being displayed.\n    :param name2idx: A dictionary containing the mapping from class names to class indices.\n    :param colormap: A dictionary containing the mapping from class names to RGB values.\n    :return: A numpy array which has length equal to the number of points in the pointcloud, and each value is\n             a RGBA array.\n    \"\"\"", "\n", "\n", "# Load labels from .bin file.", "\n", "points_label", "=", "np", ".", "fromfile", "(", "lidarseg_labels_filename", ",", "dtype", "=", "np", ".", "uint8", ")", "# [num_points]", "\n", "\n", "# Given a colormap (class name -> RGB color) and a mapping from class name to class index,", "\n", "# get an array of RGB values where each color sits at the index in the array corresponding", "\n", "# to the class index.", "\n", "colors", "=", "colormap_to_colors", "(", "colormap", ",", "name2idx", ")", "# Shape: [num_class, 3]", "\n", "\n", "if", "filter_lidarseg_labels", "is", "not", "None", ":", "\n", "# Ensure that filter_lidarseg_labels is an iterable.", "\n", "        ", "assert", "isinstance", "(", "filter_lidarseg_labels", ",", "(", "list", ",", "np", ".", "ndarray", ")", ")", ",", "'Error: filter_lidarseg_labels should be a list of class indices, eg. [9], [10, 21].'", "\n", "\n", "# Check that class indices in filter_lidarseg_labels are valid.", "\n", "assert", "all", "(", "[", "0", "<=", "x", "<", "len", "(", "name2idx", ")", "for", "x", "in", "filter_lidarseg_labels", "]", ")", ",", "'All class indices in filter_lidarseg_labels should '", "'be between 0 and {}'", ".", "format", "(", "len", "(", "name2idx", ")", "-", "1", ")", "\n", "\n", "# Filter to get only the colors of the desired classes; this is done by setting the", "\n", "# alpha channel of the classes to be viewed to 1, and the rest to 0.", "\n", "colors", "=", "filter_colors", "(", "colors", ",", "filter_lidarseg_labels", ")", "# Shape: [num_class, 4]", "\n", "\n", "# Paint each label with its respective RGBA value.", "\n", "", "coloring", "=", "colors", "[", "points_label", "]", "# Shape: [num_points, 4]", "\n", "\n", "return", "coloring", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.class_histogram.truncate_class_name": [[14, 57], ["None"], "function", ["None"], ["def", "truncate_class_name", "(", "class_name", ":", "str", ")", "->", "str", ":", "\n", "    ", "\"\"\"\n    Truncate a given class name according to a pre-defined map.\n    :param class_name: The long form (i.e. original form) of the class name.\n    :return: The truncated form of the class name.\n    \"\"\"", "\n", "\n", "string_mapper", "=", "{", "\n", "\"noise\"", ":", "'noise'", ",", "\n", "\"human.pedestrian.adult\"", ":", "'adult'", ",", "\n", "\"human.pedestrian.child\"", ":", "'child'", ",", "\n", "\"human.pedestrian.wheelchair\"", ":", "'wheelchair'", ",", "\n", "\"human.pedestrian.stroller\"", ":", "'stroller'", ",", "\n", "\"human.pedestrian.personal_mobility\"", ":", "'p.mobility'", ",", "\n", "\"human.pedestrian.police_officer\"", ":", "'police'", ",", "\n", "\"human.pedestrian.construction_worker\"", ":", "'worker'", ",", "\n", "\"animal\"", ":", "'animal'", ",", "\n", "\"vehicle.car\"", ":", "'car'", ",", "\n", "\"vehicle.motorcycle\"", ":", "'motorcycle'", ",", "\n", "\"vehicle.bicycle\"", ":", "'bicycle'", ",", "\n", "\"vehicle.bus.bendy\"", ":", "'bus.bendy'", ",", "\n", "\"vehicle.bus.rigid\"", ":", "'bus.rigid'", ",", "\n", "\"vehicle.truck\"", ":", "'truck'", ",", "\n", "\"vehicle.construction\"", ":", "'constr. veh'", ",", "\n", "\"vehicle.emergency.ambulance\"", ":", "'ambulance'", ",", "\n", "\"vehicle.emergency.police\"", ":", "'police car'", ",", "\n", "\"vehicle.trailer\"", ":", "'trailer'", ",", "\n", "\"movable_object.barrier\"", ":", "'barrier'", ",", "\n", "\"movable_object.trafficcone\"", ":", "'trafficcone'", ",", "\n", "\"movable_object.pushable_pullable\"", ":", "'push/pullable'", ",", "\n", "\"movable_object.debris\"", ":", "'debris'", ",", "\n", "\"static_object.bicycle_rack\"", ":", "'bicycle racks'", ",", "\n", "\"flat.driveable_surface\"", ":", "'driveable'", ",", "\n", "\"flat.sidewalk\"", ":", "'sidewalk'", ",", "\n", "\"flat.terrain\"", ":", "'terrain'", ",", "\n", "\"flat.other\"", ":", "'flat.other'", ",", "\n", "\"static.manmade\"", ":", "'manmade'", ",", "\n", "\"static.vegetation\"", ":", "'vegetation'", ",", "\n", "\"static.other\"", ":", "'static.other'", ",", "\n", "\"vehicle.ego\"", ":", "\"ego\"", "\n", "}", "\n", "\n", "return", "string_mapper", "[", "class_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.class_histogram.render_lidarseg_histogram": [[59, 150], ["print", "time.time", "class_histogram.get_lidarseg_stats", "print", "nuscenes.utils.color_map.get_colormap", "matplotlib.subplots", "matplotlib.margins", "ax.set_axisbelow", "ax.yaxis.grid", "ax.set_facecolor", "ax.spines[].set_visible", "ax.spines[].set_visible", "ax.spines[].set_visible", "ax.spines[].set_visible", "ax.bar", "ax.set_xlabel", "ax.set_xticklabels", "matplotlib.Affine2D().translate", "ax.get_xticklabels", "ax.set_ylabel", "ax.set_yticklabels", "matplotlib.ticker.ScalarFormatter", "ax.yaxis.set_major_formatter", "class_histogram.truncate_class_name", "len", "len", "len", "len", "t.set_transform", "ax.set_yscale", "matplotlib.ticker.FuncFormatter", "ax.set_title", "ax.get_figure", "matplotlib.tight_layout", "ax.get_figure.savefig", "matplotlib.show", "len", "tuple", "ax.get_xticks", "ax.get_xticks", "matplotlib.Affine2D", "time.time", "t.get_transform", "matplotlib.ticker.ScalarFormatter._formatSciNotation"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.class_histogram.get_lidarseg_stats", "home.repos.pwc.inspect_result.fpthink_v2b.utils.color_map.get_colormap", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.class_histogram.truncate_class_name"], ["", "def", "render_lidarseg_histogram", "(", "nusc", ":", "NuScenes", ",", "\n", "sort_by", ":", "str", "=", "'count_desc'", ",", "\n", "chart_title", ":", "str", "=", "None", ",", "\n", "x_label", ":", "str", "=", "None", ",", "\n", "y_label", ":", "str", "=", "\"Lidar points (logarithmic)\"", ",", "\n", "y_log_scale", ":", "bool", "=", "True", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "font_size", ":", "int", "=", "20", ",", "\n", "save_as_img_name", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Render a histogram for the given nuScenes split.\n    :param nusc: A nuScenes object.\n    :param sort_by: How to sort the classes:\n        - count_desc: Sort the classes by the number of points belonging to each class, in descending order.\n        - count_asc: Sort the classes by the number of points belonging to each class, in ascending order.\n        - name: Sort the classes by alphabetical order.\n        - index: Sort the classes by their indices.\n    :param chart_title: Title to display on the histogram.\n    :param x_label: Title to display on the x-axis of the histogram.\n    :param y_label: Title to display on the y-axis of the histogram.\n    :param y_log_scale: Whether to use log scale on the y-axis.\n    :param verbose: Whether to display plot in a window after rendering.\n    :param font_size: Size of the font to use for the histogram.\n    :param save_as_img_name: Path (including image name and extension) to save the histogram as.\n    \"\"\"", "\n", "\n", "print", "(", "'Calculating stats for nuScenes-lidarseg...'", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# Get the statistics for the given nuScenes split.", "\n", "class_names", ",", "counts", "=", "get_lidarseg_stats", "(", "nusc", ",", "sort_by", "=", "sort_by", ")", "\n", "\n", "print", "(", "'Calculated stats for {} point clouds in {:.1f} seconds.\\n====='", ".", "format", "(", "\n", "len", "(", "nusc", ".", "lidarseg", ")", ",", "time", ".", "time", "(", ")", "-", "start_time", ")", ")", "\n", "\n", "# Create an array with the colors to use.", "\n", "cmap", "=", "get_colormap", "(", ")", "\n", "colors", "=", "[", "'#%02x%02x%02x'", "%", "tuple", "(", "cmap", "[", "cn", "]", ")", "for", "cn", "in", "class_names", "]", "# Convert from RGB to hex.", "\n", "\n", "# Make the class names shorter so that they do not take up much space in the plot.", "\n", "class_names", "=", "[", "truncate_class_name", "(", "cn", ")", "for", "cn", "in", "class_names", "]", "\n", "\n", "# Start a plot.", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "(", "16", ",", "9", ")", ")", "\n", "plt", ".", "margins", "(", "x", "=", "0.005", ")", "# Add some padding to the left and right limits of the x-axis for aesthetics.", "\n", "ax", ".", "set_axisbelow", "(", "True", ")", "# Ensure that axis ticks and gridlines will be below all other ploy elements.", "\n", "ax", ".", "yaxis", ".", "grid", "(", "color", "=", "'white'", ",", "linewidth", "=", "2", ")", "# Show horizontal gridlines.", "\n", "ax", ".", "set_facecolor", "(", "'#eaeaf2'", ")", "# Set background of plot.", "\n", "ax", ".", "spines", "[", "'top'", "]", ".", "set_visible", "(", "False", ")", "# Remove top border of plot.", "\n", "ax", ".", "spines", "[", "'right'", "]", ".", "set_visible", "(", "False", ")", "# Remove right border of plot.", "\n", "ax", ".", "spines", "[", "'bottom'", "]", ".", "set_visible", "(", "False", ")", "# Remove bottom border of plot.", "\n", "ax", ".", "spines", "[", "'left'", "]", ".", "set_visible", "(", "False", ")", "# Remove left border of plot.", "\n", "\n", "# Plot the histogram.", "\n", "ax", ".", "bar", "(", "class_names", ",", "counts", ",", "color", "=", "colors", ")", "\n", "assert", "len", "(", "class_names", ")", "==", "len", "(", "ax", ".", "get_xticks", "(", ")", ")", ",", "'There are {} classes, but {} are shown on the x-axis'", ".", "format", "(", "len", "(", "class_names", ")", ",", "len", "(", "ax", ".", "get_xticks", "(", ")", ")", ")", "\n", "\n", "# Format the x-axis.", "\n", "ax", ".", "set_xlabel", "(", "x_label", ",", "fontsize", "=", "font_size", ")", "\n", "ax", ".", "set_xticklabels", "(", "class_names", ",", "rotation", "=", "45", ",", "horizontalalignment", "=", "'right'", ",", "\n", "fontweight", "=", "'light'", ",", "fontsize", "=", "font_size", ")", "\n", "\n", "# Shift the class names on the x-axis slightly to the right for aesthetics.", "\n", "trans", "=", "mtrans", ".", "Affine2D", "(", ")", ".", "translate", "(", "10", ",", "0", ")", "\n", "for", "t", "in", "ax", ".", "get_xticklabels", "(", ")", ":", "\n", "        ", "t", ".", "set_transform", "(", "t", ".", "get_transform", "(", ")", "+", "trans", ")", "\n", "\n", "# Format the y-axis.", "\n", "", "ax", ".", "set_ylabel", "(", "y_label", ",", "fontsize", "=", "font_size", ")", "\n", "ax", ".", "set_yticklabels", "(", "counts", ",", "size", "=", "font_size", ")", "\n", "\n", "# Transform the y-axis to log scale.", "\n", "if", "y_log_scale", ":", "\n", "        ", "ax", ".", "set_yscale", "(", "\"log\"", ")", "\n", "\n", "# Display the y-axis using nice scientific notation.", "\n", "", "formatter", "=", "ScalarFormatter", "(", "useOffset", "=", "False", ",", "useMathText", "=", "True", ")", "\n", "ax", ".", "yaxis", ".", "set_major_formatter", "(", "\n", "FuncFormatter", "(", "lambda", "x", ",", "pos", ":", "\"${}$\"", ".", "format", "(", "formatter", ".", "_formatSciNotation", "(", "'%1.10e'", "%", "x", ")", ")", ")", ")", "\n", "\n", "if", "chart_title", ":", "\n", "        ", "ax", ".", "set_title", "(", "chart_title", ",", "fontsize", "=", "font_size", ")", "\n", "\n", "", "if", "save_as_img_name", ":", "\n", "        ", "fig", "=", "ax", ".", "get_figure", "(", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "fig", ".", "savefig", "(", "save_as_img_name", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.class_histogram.get_lidarseg_stats": [[152, 200], ["dict", "range", "len", "os.path.join", "numpy.fromfile", "numpy.bincount", "zip", "len", "sorted", "class_names.append", "counts.append", "numpy.nonzero", "dict.items", "sorted", "dict.items", "sorted", "dict.items", "dict.items", "Exception"], "function", ["None"], ["", "", "def", "get_lidarseg_stats", "(", "nusc", ":", "NuScenes", ",", "sort_by", ":", "str", "=", "'count_desc'", ")", "->", "Tuple", "[", "List", "[", "str", "]", ",", "List", "[", "int", "]", "]", ":", "\n", "    ", "\"\"\"\n    Get the number of points belonging to each class for the given nuScenes split.\n    :param nusc: A NuScenes object.\n    :param sort_by: How to sort the classes:\n        - count_desc: Sort the classes by the number of points belonging to each class, in descending order.\n        - count_asc: Sort the classes by the number of points belonging to each class, in ascending order.\n        - name: Sort the classes by alphabetical order.\n        - index: Sort the classes by their indices.\n    :return: A list of class names and a list of the corresponding number of points for each class.\n    \"\"\"", "\n", "\n", "# Initialize an array of zeroes, one for each class name.", "\n", "lidarseg_counts", "=", "[", "0", "]", "*", "len", "(", "nusc", ".", "lidarseg_idx2name_mapping", ")", "\n", "\n", "for", "record_lidarseg", "in", "nusc", ".", "lidarseg", ":", "\n", "        ", "lidarseg_labels_filename", "=", "os", ".", "path", ".", "join", "(", "nusc", ".", "dataroot", ",", "record_lidarseg", "[", "'filename'", "]", ")", "\n", "\n", "points_label", "=", "np", ".", "fromfile", "(", "lidarseg_labels_filename", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "indices", "=", "np", ".", "bincount", "(", "points_label", ")", "\n", "ii", "=", "np", ".", "nonzero", "(", "indices", ")", "[", "0", "]", "\n", "for", "class_idx", ",", "class_count", "in", "zip", "(", "ii", ",", "indices", "[", "ii", "]", ")", ":", "\n", "            ", "lidarseg_counts", "[", "class_idx", "]", "+=", "class_count", "\n", "\n", "", "", "lidarseg_counts_dict", "=", "dict", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "lidarseg_counts", ")", ")", ":", "\n", "        ", "lidarseg_counts_dict", "[", "nusc", ".", "lidarseg_idx2name_mapping", "[", "i", "]", "]", "=", "lidarseg_counts", "[", "i", "]", "\n", "\n", "", "if", "sort_by", "==", "'count_desc'", ":", "\n", "        ", "out", "=", "sorted", "(", "lidarseg_counts_dict", ".", "items", "(", ")", ",", "key", "=", "lambda", "item", ":", "item", "[", "1", "]", ",", "reverse", "=", "True", ")", "\n", "", "elif", "sort_by", "==", "'count_asc'", ":", "\n", "        ", "out", "=", "sorted", "(", "lidarseg_counts_dict", ".", "items", "(", ")", ",", "key", "=", "lambda", "item", ":", "item", "[", "1", "]", ")", "\n", "", "elif", "sort_by", "==", "'name'", ":", "\n", "        ", "out", "=", "sorted", "(", "lidarseg_counts_dict", ".", "items", "(", ")", ")", "\n", "", "elif", "sort_by", "==", "'index'", ":", "\n", "        ", "out", "=", "lidarseg_counts_dict", ".", "items", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Error: Invalid sorting mode {}. '", "\n", "'Only `count_desc`, `count_asc`, `name` or `index` are valid.'", ".", "format", "(", "sort_by", ")", ")", "\n", "\n", "# Get frequency counts of each class in the lidarseg dataset.", "\n", "", "class_names", "=", "[", "]", "\n", "counts", "=", "[", "]", "\n", "for", "class_name", ",", "count", "in", "out", ":", "\n", "        ", "class_names", ".", "append", "(", "class_name", ")", "\n", "counts", ".", "append", "(", "count", ")", "\n", "\n", "", "return", "class_names", ",", "counts", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.load_prediction": [[21, 51], ["nuscenes.eval.common.data_classes.EvalBoxes.deserialize", "open", "json.load", "print", "len", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize"], ["\n", "def", "interp_list", "(", "left", ",", "right", ",", "rratio", ")", ":", "\n", "        ", "return", "tuple", "(", "\n", "(", "1.0", "-", "rratio", ")", "*", "np", ".", "array", "(", "left", ",", "dtype", "=", "float", ")", "\n", "+", "rratio", "*", "np", ".", "array", "(", "right", ",", "dtype", "=", "float", ")", "\n", ")", "\n", "\n", "", "def", "interp_float", "(", "left", ",", "right", ",", "rratio", ")", ":", "\n", "        ", "return", "(", "1.0", "-", "rratio", ")", "*", "float", "(", "left", ")", "+", "rratio", "*", "float", "(", "right", ")", "\n", "\n", "# Interpolate quaternion.", "\n", "", "rotation", "=", "Quaternion", ".", "slerp", "(", "\n", "q0", "=", "Quaternion", "(", "left_box", ".", "rotation", ")", ",", "\n", "q1", "=", "Quaternion", "(", "right_box", ".", "rotation", ")", ",", "\n", "amount", "=", "right_ratio", "\n", ")", ".", "elements", "\n", "\n", "# Score will remain -1 for GT.", "\n", "tracking_score", "=", "interp_float", "(", "left_box", ".", "tracking_score", ",", "right_box", ".", "tracking_score", ",", "right_ratio", ")", "\n", "\n", "return", "TrackingBox", "(", "sample_token", "=", "right_box", ".", "sample_token", ",", "\n", "translation", "=", "interp_list", "(", "left_box", ".", "translation", ",", "right_box", ".", "translation", ",", "right_ratio", ")", ",", "\n", "size", "=", "interp_list", "(", "left_box", ".", "size", ",", "right_box", ".", "size", ",", "right_ratio", ")", ",", "\n", "rotation", "=", "rotation", ",", "\n", "velocity", "=", "interp_list", "(", "left_box", ".", "velocity", ",", "right_box", ".", "velocity", ",", "right_ratio", ")", ",", "\n", "ego_translation", "=", "interp_list", "(", "left_box", ".", "ego_translation", ",", "right_box", ".", "ego_translation", ",", "\n", "right_ratio", ")", ",", "# May be inaccurate.", "\n", "tracking_id", "=", "right_box", ".", "tracking_id", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.load_gt": [[53, 178], ["nuscenes.utils.splits.create_splits_scenes", "nuscenes.eval.common.data_classes.EvalBoxes", "set", "tqdm.tqdm", "print", "len", "version.endswith", "nusc.get", "nusc.get", "nuscenes.eval.common.data_classes.EvalBoxes.add_boxes", "print", "version.endswith", "len", "nusc.get", "sample_tokens.append", "nusc.get", "version.endswith", "ValueError", "nuscenes.eval.detection.utils.category_to_detection_name", "len", "sample_boxes.append", "len", "box_cls", "set.add", "category_to_tracking_name", "sample_boxes.append", "NotImplementedError", "Exception", "box_cls", "nusc.box_velocity", "nusc.box_velocity"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.splits.create_splits_scenes", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.detection.utils.category_to_detection_name", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.utils.category_to_tracking_name", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.box_velocity", "home.repos.pwc.inspect_result.fpthink_v2b.nuscenes.nuscenes.NuScenes.box_velocity"], ["tracking_score", "=", "tracking_score", ")", "\n", "\n", "\n", "", "def", "interpolate_tracks", "(", "tracks_by_timestamp", ":", "DefaultDict", "[", "int", ",", "List", "[", "TrackingBox", "]", "]", ")", "->", "DefaultDict", "[", "int", ",", "List", "[", "TrackingBox", "]", "]", ":", "\n", "    ", "\"\"\"\n    Interpolate the tracks to fill in holes, especially since GT boxes with 0 lidar points are removed.\n    This interpolation does not take into account visibility. It interpolates despite occlusion.\n    :param tracks_by_timestamp: The tracks.\n    :return: The interpolated tracks.\n    \"\"\"", "\n", "# Group tracks by id.", "\n", "tracks_by_id", "=", "defaultdict", "(", "list", ")", "\n", "track_timestamps_by_id", "=", "defaultdict", "(", "list", ")", "\n", "for", "timestamp", ",", "tracking_boxes", "in", "tracks_by_timestamp", ".", "items", "(", ")", ":", "\n", "        ", "for", "tracking_box", "in", "tracking_boxes", ":", "\n", "            ", "tracks_by_id", "[", "tracking_box", ".", "tracking_id", "]", ".", "append", "(", "tracking_box", ")", "\n", "track_timestamps_by_id", "[", "tracking_box", ".", "tracking_id", "]", ".", "append", "(", "timestamp", ")", "\n", "\n", "# Interpolate missing timestamps for each track.", "\n", "", "", "timestamps", "=", "tracks_by_timestamp", ".", "keys", "(", ")", "\n", "interpolate_count", "=", "0", "\n", "for", "timestamp", "in", "timestamps", ":", "\n", "        ", "for", "tracking_id", ",", "track", "in", "tracks_by_id", ".", "items", "(", ")", ":", "\n", "            ", "if", "track_timestamps_by_id", "[", "tracking_id", "]", "[", "0", "]", "<=", "timestamp", "<=", "track_timestamps_by_id", "[", "tracking_id", "]", "[", "-", "1", "]", "and", "timestamp", "not", "in", "track_timestamps_by_id", "[", "tracking_id", "]", ":", "\n", "\n", "# Find the closest boxes before and after this timestamp.", "\n", "                ", "right_ind", "=", "bisect", "(", "track_timestamps_by_id", "[", "tracking_id", "]", ",", "timestamp", ")", "\n", "left_ind", "=", "right_ind", "-", "1", "\n", "right_timestamp", "=", "track_timestamps_by_id", "[", "tracking_id", "]", "[", "right_ind", "]", "\n", "left_timestamp", "=", "track_timestamps_by_id", "[", "tracking_id", "]", "[", "left_ind", "]", "\n", "right_tracking_box", "=", "tracks_by_id", "[", "tracking_id", "]", "[", "right_ind", "]", "\n", "left_tracking_box", "=", "tracks_by_id", "[", "tracking_id", "]", "[", "left_ind", "]", "\n", "right_ratio", "=", "float", "(", "right_timestamp", "-", "timestamp", ")", "/", "(", "right_timestamp", "-", "left_timestamp", ")", "\n", "\n", "# Interpolate.", "\n", "tracking_box", "=", "interpolate_tracking_boxes", "(", "left_tracking_box", ",", "right_tracking_box", ",", "right_ratio", ")", "\n", "interpolate_count", "+=", "1", "\n", "tracks_by_timestamp", "[", "timestamp", "]", ".", "append", "(", "tracking_box", ")", "\n", "\n", "", "", "", "return", "tracks_by_timestamp", "\n", "\n", "\n", "", "def", "create_tracks", "(", "all_boxes", ":", "EvalBoxes", ",", "nusc", ":", "NuScenes", ",", "eval_split", ":", "str", ",", "gt", ":", "bool", ")", "->", "Dict", "[", "str", ",", "Dict", "[", "int", ",", "List", "[", "TrackingBox", "]", "]", "]", ":", "\n", "    ", "\"\"\"\n    Returns all tracks for all scenes. Samples within a track are sorted in chronological order.\n    This can be applied either to GT or predictions.\n    :param all_boxes: Holds all GT or predicted boxes.\n    :param nusc: The NuScenes instance to load the sample information from.\n    :param eval_split: The evaluation split for which we create tracks.\n    :param gt: Whether we are creating tracks for GT or predictions\n    :return: The tracks.\n    \"\"\"", "\n", "# Only keep samples from this split.", "\n", "splits", "=", "create_splits_scenes", "(", ")", "\n", "scene_tokens", "=", "set", "(", ")", "\n", "for", "sample_token", "in", "all_boxes", ".", "sample_tokens", ":", "\n", "        ", "scene_token", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "[", "'scene_token'", "]", "\n", "scene", "=", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "if", "scene", "[", "'name'", "]", "in", "splits", "[", "eval_split", "]", ":", "\n", "            ", "scene_tokens", ".", "add", "(", "scene_token", ")", "\n", "\n", "# Tracks are stored as dict {scene_token: {timestamp: List[TrackingBox]}}.", "\n", "", "", "tracks", "=", "defaultdict", "(", "lambda", ":", "defaultdict", "(", "list", ")", ")", "\n", "\n", "# Init all scenes and timestamps to guarantee completeness.", "\n", "for", "scene_token", "in", "scene_tokens", ":", "\n", "# Init all timestamps in this scene.", "\n", "        ", "scene", "=", "nusc", ".", "get", "(", "'scene'", ",", "scene_token", ")", "\n", "cur_sample_token", "=", "scene", "[", "'first_sample_token'", "]", "\n", "while", "True", ":", "\n", "# Initialize array for current timestamp.", "\n", "            ", "cur_sample", "=", "nusc", ".", "get", "(", "'sample'", ",", "cur_sample_token", ")", "\n", "tracks", "[", "scene_token", "]", "[", "cur_sample", "[", "'timestamp'", "]", "]", "=", "[", "]", "\n", "\n", "# Abort after the last sample.", "\n", "if", "cur_sample_token", "==", "scene", "[", "'last_sample_token'", "]", ":", "\n", "                ", "break", "\n", "\n", "# Move to next sample.", "\n", "", "cur_sample_token", "=", "cur_sample", "[", "'next'", "]", "\n", "\n", "# Group annotations wrt scene and timestamp.", "\n", "", "", "for", "sample_token", "in", "all_boxes", ".", "sample_tokens", ":", "\n", "        ", "sample_record", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "scene_token", "=", "sample_record", "[", "'scene_token'", "]", "\n", "tracks", "[", "scene_token", "]", "[", "sample_record", "[", "'timestamp'", "]", "]", "=", "all_boxes", ".", "boxes", "[", "sample_token", "]", "\n", "\n", "# Replace box scores with track score (average box score). This only affects the compute_thresholds method and", "\n", "# should be done before interpolation to avoid diluting the original scores with interpolated boxes.", "\n", "", "if", "not", "gt", ":", "\n", "        ", "for", "scene_id", ",", "scene_tracks", "in", "tracks", ".", "items", "(", ")", ":", "\n", "# For each track_id, collect the scores.", "\n", "            ", "track_id_scores", "=", "defaultdict", "(", "list", ")", "\n", "for", "timestamp", ",", "boxes", "in", "scene_tracks", ".", "items", "(", ")", ":", "\n", "                ", "for", "box", "in", "boxes", ":", "\n", "                    ", "track_id_scores", "[", "box", ".", "tracking_id", "]", ".", "append", "(", "box", ".", "tracking_score", ")", "\n", "\n", "# Compute average scores for each track.", "\n", "", "", "track_id_avg_scores", "=", "{", "}", "\n", "for", "tracking_id", ",", "scores", "in", "track_id_scores", ".", "items", "(", ")", ":", "\n", "                ", "track_id_avg_scores", "[", "tracking_id", "]", "=", "np", ".", "mean", "(", "scores", ")", "\n", "\n", "# Apply average score to each box.", "\n", "", "for", "timestamp", ",", "boxes", "in", "scene_tracks", ".", "items", "(", ")", ":", "\n", "                ", "for", "box", "in", "boxes", ":", "\n", "                    ", "box", ".", "tracking_score", "=", "track_id_avg_scores", "[", "box", ".", "tracking_id", "]", "\n", "\n", "# Interpolate GT and predicted tracks.", "\n", "", "", "", "", "for", "scene_token", "in", "tracks", ".", "keys", "(", ")", ":", "\n", "        ", "tracks", "[", "scene_token", "]", "=", "interpolate_tracks", "(", "tracks", "[", "scene_token", "]", ")", "\n", "\n", "if", "not", "gt", ":", "\n", "# Make sure predictions are sorted in in time. (Always true for GT).", "\n", "            ", "tracks", "[", "scene_token", "]", "=", "defaultdict", "(", "list", ",", "sorted", "(", "tracks", "[", "scene_token", "]", ".", "items", "(", ")", ",", "key", "=", "lambda", "kv", ":", "kv", "[", "0", "]", ")", ")", "\n", "\n", "", "", "return", "tracks", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.add_center_dist": [[180, 205], ["nusc.get", "nusc.get", "nusc.get", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], []], "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders.filter_eval_boxes": [[207, 262], ["loaders._get_box_class_field", "enumerate", "len", "len", "len", "len", "print", "print", "print", "print", "nusc.get", "nusc.get", "nuscenes.utils.data_classes.Box", "pyquaternion.Quaternion", "box.__getattribute__", "filtered_boxes.append", "filtered_boxes.append", "nusc.get", "numpy.sum", "box.__getattribute__", "nuscenes.utils.geometry_utils.points_in_box", "numpy.expand_dims", "numpy.array"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.loaders._get_box_class_field", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.utils.geometry_utils.points_in_box"], []], "home.repos.pwc.inspect_result.fpthink_v2b.common.loaders._get_box_class_field": [[264, 286], ["eval_boxes.boxes.values", "isinstance", "len", "isinstance", "len", "Exception"], "function", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBox.__init__": [[14, 52], ["type", "len", "numpy.any", "len", "numpy.any", "len", "numpy.any", "len", "len", "numpy.any", "type", "numpy.any", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan"], "methods", ["None"], ["from", "pyquaternion", "import", "Quaternion", "\n", "import", "sys", "\n", "sys", ".", "path", ".", "append", "(", "\"..\"", ")", "\n", "from", "lidarseg", ".", "lidarseg_utils", "import", "colormap_to_colors", ",", "create_lidarseg_legend", "\n", "from", "utils", ".", "data_io", "import", "load_bin_file", "\n", "from", "utils", ".", "geometry_utils", "import", "view_points", ",", "transform_matrix", "\n", "\n", "\n", "class", "PointCloud", "(", "ABC", ")", ":", "\n", "    ", "\"\"\"\n    Abstract class for manipulating and viewing point clouds.\n    Every point cloud (lidar and radar) consists of points where:\n    - Dimensions 0, 1, 2 represent x, y, z coordinates.\n        These are modified when the point cloud is rotated or translated.\n    - All other dimensions are optional. Hence these have to be manually modified if the reference frame changes.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "points", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a point cloud and check it has the correct dimensions.\n        :param points: <np.float: d, n>. d-dimensional input point cloud matrix.\n        \"\"\"", "\n", "assert", "points", ".", "shape", "[", "0", "]", "==", "self", ".", "nbr_dims", "(", ")", ",", "'Error: Pointcloud points must have format: %d x n'", "%", "self", ".", "nbr_dims", "(", ")", "\n", "self", ".", "points", "=", "points", "\n", "\n", "", "@", "staticmethod", "\n", "@", "abstractmethod", "\n", "def", "nbr_dims", "(", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Returns the number of dimensions.\n        :return: Number of dimensions.\n        \"\"\"", "\n", "pass", "\n", "\n", "", "@", "classmethod", "\n", "@", "abstractmethod", "\n", "def", "from_file", "(", "cls", ",", "file_name", ":", "str", ")", "->", "'PointCloud'", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBox.ego_dist": [[53, 57], ["numpy.sqrt", "numpy.sum", "numpy.array"], "methods", ["None"], ["\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBox.__repr__": [[58, 60], ["str", "data_classes.EvalBox.serialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["", "@", "classmethod", "\n", "def", "from_file_multisweep", "(", "cls", ",", "\n", "nusc", ":", "'NuScenes'", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBox.serialize": [[61, 64], ["None"], "methods", ["None"], ["sample_rec", ":", "Dict", ",", "\n", "chan", ":", "str", ",", "\n", "ref_chan", ":", "str", ",", "\n", "nsweeps", ":", "int", "=", "5", ",", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBox.deserialize": [[65, 69], ["None"], "methods", ["None"], ["min_distance", ":", "float", "=", "1.0", ")", "->", "Tuple", "[", "'PointCloud'", ",", "np", ".", "ndarray", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.__init__": [[77, 82], ["collections.defaultdict"], "methods", ["None"], ["\n", "# Init.", "\n", "points", "=", "np", ".", "zeros", "(", "(", "cls", ".", "nbr_dims", "(", ")", ",", "0", ")", ",", "dtype", "=", "np", ".", "float32", "if", "cls", "==", "LidarPointCloud", "else", "np", ".", "float64", ")", "\n", "all_pc", "=", "cls", "(", "points", ")", "\n", "all_times", "=", "np", ".", "zeros", "(", "(", "1", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.__repr__": [[83, 85], ["len", "len"], "methods", ["None"], ["# Get reference pose and timestamp.", "\n", "ref_sd_token", "=", "sample_rec", "[", "'data'", "]", "[", "ref_chan", "]", "\n", "ref_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "ref_sd_token", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.__getitem__": [[86, 88], ["None"], "methods", ["None"], ["ref_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "ref_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "ref_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "ref_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "ref_time", "=", "1e-6", "*", "ref_sd_rec", "[", "'timestamp'", "]", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.__eq__": [[89, 99], ["zip", "set", "set", "len", "len"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set", "home.repos.pwc.inspect_result.fpthink_v2b.tracking.data_classes.TrackingMetricDataList.set"], ["\n", "# Homogeneous transform from ego car frame to reference frame.", "\n", "ref_from_car", "=", "transform_matrix", "(", "ref_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_cs_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "True", ")", "\n", "\n", "# Homogeneous transformation matrix from global to _current_ ego car frame.", "\n", "car_from_global", "=", "transform_matrix", "(", "ref_pose_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "ref_pose_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "True", ")", "\n", "\n", "# Aggregate current and previous sweeps.", "\n", "sample_data_token", "=", "sample_rec", "[", "'data'", "]", "[", "chan", "]", "\n", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_data_token", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.__len__": [[100, 102], ["len"], "methods", ["None"], ["for", "_", "in", "range", "(", "nsweeps", ")", ":", "\n", "# Load up the pointcloud and remove points close to the sensor.", "\n", "            ", "current_pc", "=", "cls", ".", "from_file", "(", "osp", ".", "join", "(", "nusc", ".", "dataroot", ",", "current_sd_rec", "[", "'filename'", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all": [[103, 110], ["ab.extend"], "methods", ["None"], ["current_pc", ".", "remove_close", "(", "min_distance", ")", "\n", "\n", "# Get past pose.", "\n", "current_pose_rec", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "current_sd_rec", "[", "'ego_pose_token'", "]", ")", "\n", "global_from_car", "=", "transform_matrix", "(", "current_pose_rec", "[", "'translation'", "]", ",", "\n", "Quaternion", "(", "current_pose_rec", "[", "'rotation'", "]", ")", ",", "inverse", "=", "False", ")", "\n", "\n", "# Homogeneous transformation matrix from sensor coordinate frame to ego car frame.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.sample_tokens": [[111, 115], ["list", "data_classes.EvalBoxes.boxes.keys"], "methods", ["None"], ["current_cs_rec", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "current_sd_rec", "[", "'calibrated_sensor_token'", "]", ")", "\n", "car_from_current", "=", "transform_matrix", "(", "current_cs_rec", "[", "'translation'", "]", ",", "Quaternion", "(", "current_cs_rec", "[", "'rotation'", "]", ")", ",", "\n", "inverse", "=", "False", ")", "\n", "\n", "# Fuse four transformation matrices into one and perform transform.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes": [[116, 119], ["data_classes.EvalBoxes.boxes[].extend"], "methods", ["None"], ["trans_matrix", "=", "reduce", "(", "np", ".", "dot", ",", "[", "ref_from_car", ",", "car_from_global", ",", "global_from_car", ",", "car_from_current", "]", ")", "\n", "current_pc", ".", "transform", "(", "trans_matrix", ")", "\n", "\n", "# Add time vector which can be used as a temporal feature.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.serialize": [[120, 123], ["box.serialize", "data_classes.EvalBoxes.boxes.items"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize"], ["time_lag", "=", "ref_time", "-", "1e-6", "*", "current_sd_rec", "[", "'timestamp'", "]", "# Positive difference.", "\n", "times", "=", "time_lag", "*", "np", ".", "ones", "(", "(", "1", ",", "current_pc", ".", "nbr_points", "(", ")", ")", ")", "\n", "all_times", "=", "np", ".", "hstack", "(", "(", "all_times", ",", "times", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.deserialize": [[124, 135], ["cls", "content.items", "cls.add_boxes", "box_cls.deserialize"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.add_boxes", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize"], ["# Merge with key pc.", "\n", "all_pc", ".", "points", "=", "np", ".", "hstack", "(", "(", "all_pc", ".", "points", ",", "current_pc", ".", "points", ")", ")", "\n", "\n", "# Abort if there are no previous sweeps.", "\n", "if", "current_sd_rec", "[", "'prev'", "]", "==", "''", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "current_sd_rec", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "current_sd_rec", "[", "'prev'", "]", ")", "\n", "\n", "", "", "return", "all_pc", ",", "all_times", "\n", "\n", "", "def", "nbr_points", "(", "self", ")", "->", "int", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.serialize": [[140, 144], ["None"], "methods", ["None"], ["return", "self", ".", "points", ".", "shape", "[", "1", "]", "\n", "\n", "", "def", "subsample", "(", "self", ",", "ratio", ":", "float", ")", "->", "None", ":", "\n", "        "]], "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize": [[145, 150], ["None"], "methods", ["None"], ["\n", "selected_ind", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "0", ",", "self", ".", "nbr_points", "(", ")", ")", ",", "size", "=", "int", "(", "self", ".", "nbr_points", "(", ")", "*", "ratio", ")", ")", "\n", "self", ".", "points", "=", "self", ".", "points", "[", ":", ",", "selected_ind", "]", "\n", "\n", "", "def", "remove_close", "(", "self", ",", "radius", ":", "float", ")", "->", "None", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.config.config_factory": [[12, 38], ["configuration_name.split", "os.path.dirname", "os.path.join", "os.path.exists", "len", "os.path.abspath", "open", "json.load", "nuscenes.eval.detection.data_classes.DetectionConfig.deserialize", "nuscenes.eval.tracking.data_classes.TrackingConfig.deserialize", "Exception"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.MetricData.deserialize"], ["\n", "\n", "# Check if config exists.", "\n", "this_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "cfg_path", "=", "os", ".", "path", ".", "join", "(", "this_dir", ",", "'configs'", ",", "'%s.json'", "%", "configuration_name", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "cfg_path", ")", ",", "'Requested unknown configuration {}'", ".", "format", "(", "configuration_name", ")", "\n", "\n", "# Load config file and deserialize it.", "\n", "with", "open", "(", "cfg_path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "f", ")", "\n", "", "cfg", "=", "DetectionConfig", ".", "deserialize", "(", "data", ")", "\n", "\n", "return", "cfg", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.common.render.setup_axis": [[11, 69], ["plt.subplot.get_xaxis().tick_bottom", "plt.subplot.tick_params", "plt.subplot.get_yaxis().tick_left", "matplotlib.subplot", "plt.subplot.spines[].set_visible", "plt.subplot.spines[].set_visible", "plt.subplot.set_title", "plt.subplot.set_xlabel", "plt.subplot.set_ylabel", "plt.subplot.set_xlim", "plt.subplot.set_ylim", "plt.subplot.axvline", "plt.subplot.axhline", "plt.subplot.get_xaxis", "plt.subplot.get_yaxis", "plt.subplot.spines[].set_visible", "plt.subplot.spines[].set_visible"], "function", ["None"], ["from", "nuscenes", ".", "eval", ".", "common", ".", "data_classes", "import", "EvalBoxes", "\n", "from", "nuscenes", ".", "eval", ".", "common", ".", "render", "import", "setup_axis", "\n", "from", "nuscenes", ".", "eval", ".", "common", ".", "utils", "import", "boxes_to_sensor", "\n", "from", "nuscenes", ".", "eval", ".", "detection", ".", "constants", "import", "TP_METRICS", ",", "DETECTION_NAMES", ",", "DETECTION_COLORS", ",", "TP_METRICS_UNITS", ",", "PRETTY_DETECTION_NAMES", ",", "PRETTY_TP_METRICS", "\n", "from", "nuscenes", ".", "eval", ".", "detection", ".", "data_classes", "import", "DetectionMetrics", ",", "DetectionMetricData", ",", "DetectionMetricDataList", "\n", "from", "nuscenes", ".", "utils", ".", "data_classes", "import", "LidarPointCloud", "\n", "from", "nuscenes", ".", "utils", ".", "geometry_utils", "import", "view_points", "\n", "\n", "Axis", "=", "Any", "\n", "\n", "\n", "def", "visualize_sample", "(", "nusc", ":", "NuScenes", ",", "\n", "sample_token", ":", "str", ",", "\n", "gt_boxes", ":", "EvalBoxes", ",", "\n", "pred_boxes", ":", "EvalBoxes", ",", "\n", "nsweeps", ":", "int", "=", "1", ",", "\n", "conf_th", ":", "float", "=", "0.15", ",", "\n", "eval_range", ":", "float", "=", "50", ",", "\n", "verbose", ":", "bool", "=", "True", ",", "\n", "savepath", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Visualizes a sample from BEV with annotations and detection results.\n    :param nusc: NuScenes object.\n    :param sample_token: The nuScenes sample token.\n    :param gt_boxes: Ground truth boxes grouped by sample.\n    :param pred_boxes: Prediction grouped by sample.\n    :param nsweeps: Number of sweeps used for lidar visualization.\n    :param conf_th: The confidence threshold used to filter negatives.\n    :param eval_range: Range in meters beyond which boxes are ignored.\n    :param verbose: Whether to print to stdout.\n    :param savepath: If given, saves the the rendering here instead of displaying.\n    \"\"\"", "\n", "# Retrieve sensor & pose records.", "\n", "sample_rec", "=", "nusc", ".", "get", "(", "'sample'", ",", "sample_token", ")", "\n", "sd_record", "=", "nusc", ".", "get", "(", "'sample_data'", ",", "sample_rec", "[", "'data'", "]", "[", "'LIDAR_TOP'", "]", ")", "\n", "cs_record", "=", "nusc", ".", "get", "(", "'calibrated_sensor'", ",", "sd_record", "[", "'calibrated_sensor_token'", "]", ")", "\n", "pose_record", "=", "nusc", ".", "get", "(", "'ego_pose'", ",", "sd_record", "[", "'ego_pose_token'", "]", ")", "\n", "\n", "# Get boxes.", "\n", "boxes_gt_global", "=", "gt_boxes", "[", "sample_token", "]", "\n", "boxes_est_global", "=", "pred_boxes", "[", "sample_token", "]", "\n", "\n", "# Map GT boxes to lidar.", "\n", "boxes_gt", "=", "boxes_to_sensor", "(", "boxes_gt_global", ",", "pose_record", ",", "cs_record", ")", "\n", "\n", "# Map EST boxes to lidar.", "\n", "boxes_est", "=", "boxes_to_sensor", "(", "boxes_est_global", ",", "pose_record", ",", "cs_record", ")", "\n", "\n", "# Add scores to EST boxes.", "\n", "for", "box_est", ",", "box_est_global", "in", "zip", "(", "boxes_est", ",", "boxes_est_global", ")", ":", "\n", "        ", "box_est", ".", "score", "=", "box_est_global", ".", "detection_score", "\n", "\n", "# Get point cloud in lidar frame.", "\n", "", "pc", ",", "_", "=", "LidarPointCloud", ".", "from_file_multisweep", "(", "nusc", ",", "sample_rec", ",", "'LIDAR_TOP'", ",", "'LIDAR_TOP'", ",", "nsweeps", "=", "nsweeps", ")", "\n", "\n", "# Init axes.", "\n", "_", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "9", ",", "9", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.center_distance": [[15, 23], ["numpy.linalg.norm", "numpy.array", "numpy.array"], "function", ["None"], ["def", "annotation_name", "(", "attributes", ":", "List", "[", "dict", "]", ",", "\n", "category_name", ":", "str", ",", "\n", "with_attributes", ":", "bool", "=", "False", ")", "->", "str", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.velocity_l2": [[25, 34], ["numpy.linalg.norm", "numpy.array", "numpy.array"], "function", ["None"], ["outstr", "=", "category_name", "\n", "\n", "if", "with_attributes", ":", "\n", "        ", "atts", "=", "[", "attribute", "[", "'name'", "]", "for", "attribute", "in", "attributes", "]", "\n", "if", "len", "(", "atts", ")", ">", "0", ":", "\n", "            ", "outstr", "=", "outstr", "+", "\"--\"", "+", "'.'", ".", "join", "(", "atts", ")", "\n", "\n", "", "", "return", "outstr", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.yaw_diff": [[36, 48], ["utils.quaternion_yaw", "utils.quaternion_yaw", "abs", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "utils.angle_diff"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw", "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.angle_diff"], ["    ", "\"\"\"\n    Decode the mask from base64 string to binary string, then feed it to the external pycocotools library to get a mask.\n    :param mask: The mask dictionary with fields `size` and `counts`.\n    :return: A numpy array representing the binary mask for this class.\n    \"\"\"", "\n", "# Note that it is essential to copy the mask here. If we use the same variable we will overwrite the NuImage class", "\n", "# and cause the Jupyter Notebook to crash on some systems.", "\n", "new_mask", "=", "mask", ".", "copy", "(", ")", "\n", "new_mask", "[", "'counts'", "]", "=", "base64", ".", "b64decode", "(", "mask", "[", "'counts'", "]", ")", "\n", "return", "cocomask", ".", "decode", "(", "new_mask", ")", "\n", "\n", "\n", "", "def", "get_font", "(", "fonts_valid", ":", "List", "[", "str", "]", "=", "None", ",", "font_size", ":", "int", "=", "15", ")", "->", "ImageFont", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.angle_diff": [[50, 65], ["None"], "function", ["None"], ["\n", "# If there are no desired fonts supplied, use a hardcoded list of fonts which are desirable.", "\n", "if", "fonts_valid", "is", "None", ":", "\n", "        ", "fonts_valid", "=", "[", "'FreeSerif.ttf'", ",", "'FreeSans.ttf'", ",", "'Century.ttf'", ",", "'Calibri.ttf'", ",", "'arial.ttf'", "]", "\n", "\n", "# Find a list of fonts within the user's system.", "\n", "", "fonts_in_sys", "=", "matplotlib", ".", "font_manager", ".", "findSystemFonts", "(", "fontpaths", "=", "None", ",", "fontext", "=", "'ttf'", ")", "\n", "# Sort the list of fonts to ensure that the desired fonts are always found in the same order.", "\n", "fonts_in_sys", "=", "sorted", "(", "fonts_in_sys", ")", "\n", "# Of all the fonts found in the user's system, check if any of them are desired.", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.attr_acc": [[67, 84], ["float"], "function", ["None"], ["        ", "if", "any", "(", "os", ".", "path", ".", "basename", "(", "font_in_sys", ")", "in", "s", "for", "s", "in", "fonts_valid", ")", ":", "\n", "            ", "return", "ImageFont", ".", "truetype", "(", "font_in_sys", ",", "font_size", ")", "\n", "\n", "# If none of the fonts in the user's system are desirable, then use the default font.", "\n", "", "", "warnings", ".", "warn", "(", "'No suitable fonts were found in your system. '", "\n", "'A default font will be used instead (the font size will not be adjustable).'", ")", "\n", "return", "ImageFont", ".", "load_default", "(", ")", "\n", "\n", "\n", "", "def", "name_to_index_mapping", "(", "category", ":", "List", "[", "dict", "]", ")", "->", "Dict", "[", "str", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Build a mapping from name to index to look up index in O(1) time.\n    :param category: The nuImages category table.\n    :return: The mapping from category name to category index.\n    \"\"\"", "\n", "# The 0 index is reserved for non-labelled background; thus, the categories should start from index 1.", "\n", "# Also, sort the categories before looping so that the order is always the same (alphabetical).", "\n", "name_to_index", "=", "dict", "(", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.scale_iou": [[86, 110], ["numpy.array", "numpy.array", "all", "all", "numpy.minimum", "numpy.prod", "numpy.prod", "numpy.prod"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all", "home.repos.pwc.inspect_result.fpthink_v2b.common.data_classes.EvalBoxes.all"], ["sorted_category", ":", "List", "=", "sorted", "(", "category", ".", "copy", "(", ")", ",", "key", "=", "lambda", "k", ":", "k", "[", "'name'", "]", ")", "\n", "for", "c", "in", "sorted_category", ":", "\n", "# Ignore the vehicle.ego and flat.driveable_surface classes first; they will be mapped later.", "\n", "        ", "if", "c", "[", "'name'", "]", "!=", "'vehicle.ego'", "and", "c", "[", "'name'", "]", "!=", "'flat.driveable_surface'", ":", "\n", "            ", "name_to_index", "[", "c", "[", "'name'", "]", "]", "=", "i", "\n", "i", "+=", "1", "\n", "\n", "", "", "assert", "max", "(", "name_to_index", ".", "values", "(", ")", ")", "<", "24", ",", "'Error: There are {} classes (excluding vehicle.ego and flat.driveable_surface), '", "'but there should be 23. Please check your category.json'", ".", "format", "(", "max", "(", "name_to_index", ".", "values", "(", ")", ")", ")", "\n", "\n", "# Now map the vehicle.ego and flat.driveable_surface classes.", "\n", "name_to_index", "[", "'flat.driveable_surface'", "]", "=", "24", "\n", "name_to_index", "[", "'vehicle.ego'", "]", "=", "31", "\n", "\n", "# Ensure that each class name is uniquely paired with a class index, and vice versa.", "\n", "assert", "len", "(", "name_to_index", ")", "==", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ",", "'Error: There are {} class names but {} class indices'", ".", "format", "(", "len", "(", "name_to_index", ")", ",", "\n", "len", "(", "set", "(", "name_to_index", ".", "values", "(", ")", ")", ")", ")", "\n", "\n", "return", "name_to_index", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.quaternion_yaw": [[112, 128], ["numpy.dot", "numpy.arctan2", "numpy.array"], "function", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.boxes_to_sensor": [[130, 154], ["nuscenes.utils.data_classes.Box", "nuscenes.utils.data_classes.Box.translate", "nuscenes.utils.data_classes.Box.rotate", "nuscenes.utils.data_classes.Box.translate", "nuscenes.utils.data_classes.Box.rotate", "boxes_out.append", "pyquaternion.Quaternion", "numpy.array", "pyquaternion.Quaternion", "numpy.array", "pyquaternion.Quaternion"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], []], "home.repos.pwc.inspect_result.fpthink_v2b.common.utils.cummean": [[156, 170], ["sum", "len", "numpy.ones", "numpy.nancumsum", "numpy.cumsum", "numpy.divide", "numpy.isnan", "len", "x.astype", "numpy.isnan", "numpy.zeros_like"], "function", ["None"], []], "home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.__init__": [[22, 63], ["os.path.join", "os.path.isdir", "Exception", "can_bus_api.NuScenesCanBus.list_misaligned_routes", "int"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.list_misaligned_routes"], ["def", "__init__", "(", "self", ",", "\n", "dataroot", ":", "str", "=", "'/data/sets/nuscenes'", ",", "\n", "max_misalignment", ":", "float", "=", "5.0", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the nuScenes CAN bus API.\n        :param dataroot: The nuScenes directory where the \"can\" folder is located.\n        :param max_misalignment: Maximum distance in m that any pose is allowed to be away from the route.\n        \"\"\"", "\n", "# Check that folder exists.", "\n", "self", ".", "can_dir", "=", "os", ".", "path", ".", "join", "(", "dataroot", ",", "'can_bus'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "can_dir", ")", ":", "\n", "            ", "raise", "Exception", "(", "'Error: CAN bus directory not found: %s. Please download it from '", "\n", "'https://www.nuscenes.org/download'", "%", "self", ".", "can_dir", ")", "\n", "\n", "# Define blacklist for scenes where route and ego pose are not aligned.", "\n", "", "if", "max_misalignment", "==", "5.0", ":", "\n", "# Default settings are hard-coded for performance reasons.", "\n", "            ", "self", ".", "route_blacklist", "=", "[", "\n", "71", ",", "73", ",", "74", ",", "75", ",", "76", ",", "85", ",", "100", ",", "101", ",", "106", ",", "107", ",", "108", ",", "109", ",", "110", ",", "112", ",", "113", ",", "114", ",", "115", ",", "116", ",", "117", ",", "118", ",", "119", ",", "\n", "261", ",", "262", ",", "263", ",", "264", ",", "276", ",", "302", ",", "303", ",", "304", ",", "305", ",", "306", ",", "334", ",", "388", ",", "389", ",", "390", ",", "436", ",", "499", ",", "500", ",", "501", ",", "502", ",", "504", ",", "\n", "505", ",", "506", ",", "507", ",", "508", ",", "509", ",", "510", ",", "511", ",", "512", ",", "513", ",", "514", ",", "515", ",", "517", ",", "518", ",", "547", ",", "548", ",", "549", ",", "550", ",", "551", ",", "556", ",", "557", ",", "\n", "558", ",", "559", ",", "560", ",", "561", ",", "562", ",", "563", ",", "564", ",", "565", ",", "730", ",", "731", ",", "733", ",", "734", ",", "735", ",", "736", ",", "737", ",", "738", ",", "778", ",", "780", ",", "781", ",", "782", ",", "\n", "783", ",", "784", ",", "904", ",", "905", ",", "1073", ",", "1074", "\n", "]", "\n", "", "else", ":", "\n", "            ", "misaligned", "=", "self", ".", "list_misaligned_routes", "(", ")", "\n", "self", ".", "route_blacklist", "=", "[", "int", "(", "s", "[", "-", "4", ":", "]", ")", "for", "s", "in", "misaligned", "]", "\n", "\n", "# Define blacklist for scenes without CAN bus data.", "\n", "", "self", ".", "can_blacklist", "=", "[", "\n", "161", ",", "162", ",", "163", ",", "164", ",", "165", ",", "166", ",", "167", ",", "168", ",", "170", ",", "171", ",", "172", ",", "173", ",", "174", ",", "175", ",", "176", ",", "309", ",", "310", ",", "311", ",", "312", ",", "313", ",", "314", "\n", "]", "\n", "\n", "# Define all messages.", "\n", "self", ".", "can_messages", "=", "[", "\n", "'ms_imu'", ",", "'pose'", ",", "'steeranglefeedback'", ",", "'vehicle_monitor'", ",", "'zoesensors'", ",", "'zoe_veh_info'", "\n", "]", "\n", "self", ".", "derived_messages", "=", "[", "\n", "'meta'", ",", "'route'", "\n", "]", "\n", "self", ".", "all_messages", "=", "self", ".", "can_messages", "+", "self", ".", "derived_messages", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.print_all_message_stats": [[64, 82], ["can_bus_api.NuScenesCanBus.get_messages", "print", "print", "json.dumps", "list", "json.dumps", "stats.keys", "all_messages.items"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.get_messages"], ["", "def", "print_all_message_stats", "(", "self", ",", "\n", "scene_name", ":", "str", ",", "\n", "print_full", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Prints the meta stats for each CAN message type of a particular scene.\n        :param scene_name: The name of the scene, e.g. scene-0001.\n        :param print_full: Whether to show all stats for all message types in the scene.\n        \"\"\"", "\n", "all_messages", "=", "{", "}", "\n", "for", "message_name", "in", "self", ".", "can_messages", ":", "\n", "            ", "messages", "=", "self", ".", "get_messages", "(", "scene_name", ",", "'meta'", ")", "\n", "all_messages", "[", "message_name", "]", "=", "messages", "\n", "\n", "", "if", "print_full", ":", "\n", "            ", "print", "(", "json", ".", "dumps", "(", "all_messages", ",", "indent", "=", "2", ")", ")", "\n", "", "else", ":", "\n", "            ", "partial_messages", "=", "{", "message", ":", "list", "(", "stats", ".", "keys", "(", ")", ")", "for", "message", ",", "stats", "in", "all_messages", ".", "items", "(", ")", "}", "\n", "print", "(", "json", ".", "dumps", "(", "partial_messages", ",", "indent", "=", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.print_message_stats": [[83, 94], ["can_bus_api.NuScenesCanBus.get_messages", "print", "json.dumps"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.get_messages"], ["", "", "def", "print_message_stats", "(", "self", ",", "\n", "scene_name", ":", "str", ",", "\n", "message_name", ":", "str", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Prints the meta stats for a particular scene and message name.\n        :param scene_name: The name of the scene, e.g. scene-0001.\n        :param message_name: The name of the CAN bus message type, e.g. ms_imu.\n        \"\"\"", "\n", "assert", "message_name", "!=", "'meta'", ",", "'Error: Cannot print stats for meta '", "\n", "messages", "=", "self", ".", "get_messages", "(", "scene_name", ",", "'meta'", ")", "\n", "print", "(", "json", ".", "dumps", "(", "messages", "[", "message_name", "]", ",", "indent", "=", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.plot_baseline_route": [[95, 118], ["can_bus_api.NuScenesCanBus.get_pose_and_route", "matplotlib.figure", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.show", "matplotlib.savefig"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.get_pose_and_route"], ["", "def", "plot_baseline_route", "(", "self", ",", "\n", "scene_name", ":", "str", ",", "\n", "out_path", ":", "str", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Plot the baseline route and the closest ego poses for a scene.\n        Note that the plot is not closed and should be closed by the caller.\n        :param scene_name: The name of the scene, e.g. scene-0001.\n        :param out_path: Output path to dump the plot to. Ignored if None.\n        \"\"\"", "\n", "# Get data.", "\n", "route", ",", "pose", "=", "self", ".", "get_pose_and_route", "(", "scene_name", ")", "\n", "\n", "# Visualize.", "\n", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "plot", "(", "route", "[", ":", ",", "0", "]", ",", "route", "[", ":", ",", "1", "]", ")", "\n", "plt", ".", "plot", "(", "pose", "[", ":", ",", "0", "]", ",", "pose", "[", ":", ",", "1", "]", ")", "\n", "plt", ".", "plot", "(", "pose", "[", "0", ",", "0", "]", ",", "pose", "[", "0", ",", "1", "]", ",", "'rx'", ",", "markersize", "=", "10", ")", "\n", "plt", ".", "legend", "(", "(", "'Route'", ",", "'Pose'", ",", "'Start'", ")", ")", "\n", "plt", ".", "xlabel", "(", "'Map coordinate x in m'", ")", "\n", "plt", ".", "ylabel", "(", "'Map coordinate y in m'", ")", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ")", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.plot_message_data": [[119, 162], ["can_bus_api.NuScenesCanBus.get_messages", "numpy.array", "numpy.array", "matplotlib.figure", "matplotlib.plot", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.show", "numpy.linalg.norm", "matplotlib.savefig", "min", "Exception"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.get_messages"], ["", "def", "plot_message_data", "(", "self", ",", "\n", "scene_name", ":", "str", ",", "\n", "message_name", ":", "str", ",", "\n", "key_name", ":", "str", ",", "\n", "dimension", ":", "int", "=", "0", ",", "\n", "out_path", ":", "str", "=", "None", ",", "\n", "plot_format", ":", "str", "=", "'b-'", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Plot the data for a particular message.\n        :param scene_name: The name of the scene, e.g. scene-0001.\n        :param message_name: The name of the CAN bus message type, e.g. ms_imu.\n        :param key_name: The name of the key in the message, e.g. linear_accel.\n        :param dimension: Which dimension to render (default is 0). If -1, we render the norm of the values.\n        :param out_path: Output path to dump the plot to. Ignored if None.\n        :param plot_format: A string that describes a matplotlib format, by default 'b-' for a blue dashed line.\n        \"\"\"", "\n", "# Get data.", "\n", "messages", "=", "self", ".", "get_messages", "(", "scene_name", ",", "message_name", ")", "\n", "data", "=", "np", ".", "array", "(", "[", "m", "[", "key_name", "]", "for", "m", "in", "messages", "]", ")", "\n", "utimes", "=", "np", ".", "array", "(", "[", "m", "[", "'utime'", "]", "for", "m", "in", "messages", "]", ")", "\n", "\n", "# Convert utimes to seconds and subtract the minimum.", "\n", "utimes", "=", "(", "utimes", "-", "min", "(", "utimes", ")", ")", "/", "1e6", "\n", "\n", "# Take selected column.", "\n", "if", "dimension", "==", "-", "1", ":", "\n", "            ", "data", "=", "np", ".", "linalg", ".", "norm", "(", "data", ",", "axis", "=", "1", ")", "\n", "", "elif", "dimension", "==", "0", ":", "\n", "            ", "pass", "\n", "", "elif", "data", ".", "ndim", ">", "1", "and", "data", ".", "shape", "[", "1", "]", ">=", "dimension", "+", "1", ":", "\n", "            ", "data", "=", "data", "[", ":", ",", "dimension", "]", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Error: Invalid dimension %d for key \"%s\"!'", "%", "(", "dimension", ",", "key_name", ")", ")", "\n", "\n", "# Render.", "\n", "", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "plot", "(", "utimes", ",", "data", ",", "plot_format", ",", "markersize", "=", "1", ")", "\n", "plt", ".", "title", "(", "scene_name", ")", "\n", "plt", ".", "xlabel", "(", "'Scene time in s'", ")", "\n", "plt", ".", "ylabel", "(", "'%s - %s'", "%", "(", "message_name", ",", "key_name", ")", ")", "\n", "if", "out_path", "is", "not", "None", ":", "\n", "            ", "plt", ".", "savefig", "(", "out_path", ")", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.list_misaligned_routes": [[163, 189], ["os.listdir", "list", "numpy.unique", "can_bus_api.NuScenesCanBus.get_pose_and_route", "scipy.cdist", "numpy.max", "numpy.min", "misaligned.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.get_pose_and_route"], ["", "def", "list_misaligned_routes", "(", "self", ",", "\n", "max_misalignment", ":", "float", "=", "5.0", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"\n        Print all scenes where ego poses and baseline route are misaligned.\n        We use the Hausdorff distance to decide on the misalignment.\n        :param max_misalignment: Maximum distance in m that any pose is allowed to be away from the route.\n        :return: A list of all the names of misaligned scenes.\n        \"\"\"", "\n", "# Get all scenes.", "\n", "all_files", "=", "os", ".", "listdir", "(", "self", ".", "can_dir", ")", "\n", "scene_list", "=", "list", "(", "np", ".", "unique", "(", "[", "f", "[", ":", "10", "]", "for", "f", "in", "all_files", "]", ")", ")", "# Get the scene name from e.g. scene-0123_meta.json.", "\n", "\n", "# Init.", "\n", "misaligned", "=", "[", "]", "\n", "\n", "for", "scene_name", "in", "scene_list", ":", "\n", "# Get data.", "\n", "            ", "route", ",", "pose", "=", "self", ".", "get_pose_and_route", "(", "scene_name", ",", "print_warnings", "=", "False", ")", "\n", "\n", "# Filter by Hausdorff distance.", "\n", "dists", "=", "scipy_dist", ".", "cdist", "(", "pose", ",", "route", ")", "\n", "max_dist", "=", "np", ".", "max", "(", "np", ".", "min", "(", "dists", ",", "axis", "=", "1", ")", ")", "\n", "if", "max_dist", ">", "max_misalignment", ":", "\n", "                ", "misaligned", ".", "append", "(", "scene_name", ")", "\n", "\n", "", "", "return", "misaligned", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.get_pose_and_route": [[190, 208], ["can_bus_api.NuScenesCanBus.get_messages", "can_bus_api.NuScenesCanBus.get_messages", "numpy.asarray", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.get_messages", "home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.get_messages"], ["", "def", "get_pose_and_route", "(", "self", ",", "\n", "scene_name", ":", "str", ",", "\n", "print_warnings", ":", "bool", "=", "True", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return the route and pose for a scene as numpy arrays.\n        :param scene_name: The name of the scene, e.g. scene-0001.\n        :param print_warnings: Whether to print out warnings if the requested data is not available or not reliable.\n        :return: A tuple of route and pose arrays (each point is 2d).\n        \"\"\"", "\n", "# Load baseline route and poses.", "\n", "route", "=", "self", ".", "get_messages", "(", "scene_name", ",", "'route'", ",", "print_warnings", "=", "print_warnings", ")", "\n", "pose", "=", "self", ".", "get_messages", "(", "scene_name", ",", "'pose'", ",", "print_warnings", "=", "print_warnings", ")", "\n", "\n", "# Convert to numpy format.", "\n", "route", "=", "np", ".", "asarray", "(", "route", ")", "\n", "pose", "=", "np", ".", "asarray", "(", "[", "p", "[", "'pos'", "]", "[", ":", "2", "]", "for", "p", "in", "pose", "]", ")", "\n", "\n", "return", "route", ",", "pose", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.can_bus.can_bus_api.NuScenesCanBus.get_messages": [[209, 249], ["re.match", "int", "os.path.join", "isinstance", "Exception", "open", "json.load", "type", "k.lower", "json.load.items", "warnings.warn", "warnings.warn"], "methods", ["None"], ["", "def", "get_messages", "(", "self", ",", "\n", "scene_name", ":", "str", ",", "\n", "message_name", ":", "str", ",", "\n", "print_warnings", ":", "bool", "=", "True", ")", "->", "Union", "[", "List", "[", "Dict", "]", ",", "Dict", "]", ":", "\n", "        ", "\"\"\"\n        Retrieve the messages for a particular scene and message type.\n        :param scene_name: The name of the scene, e.g. scene-0001.\n        :param message_name: The name of the CAN bus message type, e.g. ms_imu.\n        :param print_warnings: Whether to print out warnings if the requested data is not available or not reliable.\n        :return: The raw contents of the message type, either a dict (for `meta`) or a list of messages.\n        \"\"\"", "\n", "# Check inputs. Scene names must be in the format scene-0123.", "\n", "assert", "re", ".", "match", "(", "'^scene-\\\\d\\\\d\\\\d\\\\d$'", ",", "scene_name", ")", "\n", "assert", "message_name", "in", "self", ".", "all_messages", ",", "'Error: Invalid CAN bus message name: %s'", "%", "message_name", "\n", "\n", "# Check for data issues.", "\n", "scene_id", "=", "int", "(", "scene_name", "[", "-", "4", ":", "]", ")", "\n", "if", "scene_id", "in", "self", ".", "can_blacklist", ":", "\n", "# Check for logs that have no CAN bus data.", "\n", "            ", "raise", "Exception", "(", "'Error: %s does not have any CAN bus data!'", "%", "scene_name", ")", "\n", "", "elif", "print_warnings", ":", "\n", "# Print warnings for scenes that are known to have bad data.", "\n", "            ", "if", "message_name", "==", "'route'", ":", "\n", "                ", "if", "scene_id", "in", "self", ".", "route_blacklist", ":", "\n", "                    ", "warnings", ".", "warn", "(", "'Warning: %s is not well aligned with the baseline route!'", "%", "scene_name", ")", "\n", "", "", "elif", "message_name", "==", "'vehicle_monitor'", ":", "\n", "                ", "if", "scene_id", "in", "[", "419", "]", ":", "\n", "                    ", "warnings", ".", "warn", "(", "'Warning: %s does not have any vehicle_monitor messages!'", ")", "\n", "\n", "# Load messages.", "\n", "", "", "", "message_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "can_dir", ",", "'%s_%s.json'", "%", "(", "scene_name", ",", "message_name", ")", ")", "\n", "with", "open", "(", "message_path", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "messages", "=", "json", ".", "load", "(", "f", ")", "\n", "", "assert", "type", "(", "messages", ")", "in", "[", "list", ",", "dict", "]", "\n", "\n", "# Rename all dict keys to lower-case.", "\n", "if", "isinstance", "(", "messages", ",", "dict", ")", ":", "\n", "            ", "messages", "=", "{", "k", ".", "lower", "(", ")", ":", "v", "for", "(", "k", ",", "v", ")", "in", "messages", ".", "items", "(", ")", "}", "\n", "\n", "", "return", "messages", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.setup.setup.get_dirlist": [[20, 30], ["os.scandir", "entry.is_dir", "dirlist.append", "setup.get_dirlist", "entry.name.startswith"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.setup.setup.get_dirlist"], ["", "", "def", "get_dirlist", "(", "_rootdir", ")", ":", "\n", "    ", "dirlist", "=", "[", "]", "\n", "\n", "with", "os", ".", "scandir", "(", "_rootdir", ")", "as", "rit", ":", "\n", "        ", "for", "entry", "in", "rit", ":", "\n", "            ", "if", "not", "entry", ".", "name", ".", "startswith", "(", "'.'", ")", "and", "entry", ".", "is_dir", "(", ")", ":", "\n", "                ", "dirlist", ".", "append", "(", "entry", ".", "path", ")", "\n", "dirlist", "+=", "get_dirlist", "(", "entry", ".", "path", ")", "\n", "\n", "", "", "", "return", "dirlist", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.main.init_opts": [[24, 66], ["manual_opts.which_dataset.upper", "os.path.join", "utils.options.opts.which_dataset.upper", "ValueError", "ValueError", "ValueError", "ValueError", "os.makedirs", "os.makedirs", "utils.options.opts.which_dataset.upper", "utils.options.opts.which_dataset.upper", "utils.options.opts.which_dataset.upper", "utils.options.opts.which_dataset.upper", "utils.options.opts.which_dataset.upper", "utils.options.opts.rp_which_dataset.lower", "utils.options.opts.rp_category.lower", "utils.options.opts.rp_category.lower"], "function", ["None"], ["def", "init_opts", "(", "opts", ",", "manual_opts", ")", ":", "\n", "    ", "opts", ".", "which_dataset", "=", "manual_opts", ".", "which_dataset", ".", "upper", "(", ")", "\n", "\n", "if", "opts", ".", "which_dataset", ".", "upper", "(", ")", "not", "in", "[", "'KITTI'", ",", "'NUSCENES'", ",", "'WAYMO'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"Please use command '--which_dataset kitti/nuscenes/waymo' to select datasets we support.\"", ")", "\n", "\n", "", "opts", ".", "batch_size", "=", "manual_opts", ".", "batch_size", "\n", "opts", ".", "n_workers", "=", "manual_opts", ".", "n_workers", "\n", "opts", ".", "n_epoches", "=", "manual_opts", ".", "n_epoches", "\n", "opts", ".", "n_gpus", "=", "manual_opts", ".", "n_gpus", "\n", "opts", ".", "train_test", "=", "manual_opts", ".", "train_test", "\n", "opts", ".", "visual", "=", "manual_opts", ".", "visual", "\n", "\n", "opts", ".", "db", "=", "opts", ".", "db", "[", "opts", ".", "which_dataset", "]", "\n", "if", "opts", ".", "which_dataset", ".", "upper", "(", ")", "==", "'KITTI'", "and", "manual_opts", ".", "category_name", "not", "in", "[", "'Car'", ",", "'Pedestrian'", ",", "'Van'", ",", "'Cyclist'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"Please enter the correct species name supported by the KITTI dataset (Car/Pedestrian/Van/Cyclist).\"", ")", "\n", "", "if", "opts", ".", "which_dataset", ".", "upper", "(", ")", "==", "'NUSCENES'", "and", "manual_opts", ".", "category_name", "not", "in", "[", "'car'", ",", "'pedestrian'", ",", "'truck'", ",", "'bicycle'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"Please enter the correct species name supported by the nuScenes dataset (car/pedestrian/truck/bicycle).\"", ")", "\n", "", "if", "opts", ".", "which_dataset", ".", "upper", "(", ")", "==", "'WAYMO'", "and", "manual_opts", ".", "category_name", "not", "in", "[", "'vehicle'", ",", "'pedestrian'", ",", "'cyclist'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"Please enter the correct species name supported by the waymo open dataset (vehicle/pedestrian/cyclist).\"", ")", "\n", "", "opts", ".", "db", ".", "category_name", "=", "manual_opts", ".", "category_name", "\n", "\n", "# note that: we only use waymo oepn dataset to test the generalization ability of the kitti model", "\n", "# KITTI/WAYMO ==> kitti, NUSCENES ==> nuscenes", "\n", "# WAYMO.vehicle/pedestrian/cyclist ==> KITTI.Car/Pedestrian/Cyclist", "\n", "opts", ".", "rp_which_dataset", "=", "'nuscenes'", "if", "opts", ".", "which_dataset", ".", "upper", "(", ")", "==", "'NUSCENES'", "else", "'kitti'", "\n", "opts", ".", "rp_category", "=", "'Car'", "if", "(", "opts", ".", "which_dataset", ".", "upper", "(", ")", "==", "'WAYMO'", "and", "opts", ".", "db", ".", "category_name", "==", "'vehicle'", ")", "else", "opts", ".", "db", ".", "category_name", "\n", "\n", "opts", ".", "data_save_path", "=", "os", ".", "path", ".", "join", "(", "'/opt/data/private/tracking/v2b/'", ",", "(", "'tiny'", "if", "opts", ".", "use_tiny", "else", "'full'", ")", ",", "opts", ".", "rp_which_dataset", ")", "\n", "\n", "if", "opts", ".", "train_test", "==", "'train'", ":", "\n", "        ", "opts", ".", "mode", "=", "True", "\n", "opts", ".", "results_dir", "=", "\"./results/%s_%s\"", "%", "(", "opts", ".", "rp_which_dataset", ".", "lower", "(", ")", ",", "opts", ".", "rp_category", ".", "lower", "(", ")", ")", "\n", "os", ".", "makedirs", "(", "opts", ".", "results_dir", ",", "exist_ok", "=", "True", ")", "\n", "os", ".", "makedirs", "(", "opts", ".", "data_save_path", ",", "exist_ok", "=", "True", ")", "\n", "", "elif", "opts", ".", "train_test", "==", "'test'", ":", "\n", "        ", "opts", ".", "mode", "=", "False", "\n", "opts", ".", "results_dir", "=", "\"./results/%s_%s\"", "%", "(", "'kitti'", ",", "opts", ".", "rp_category", ".", "lower", "(", ")", ")", "\n", "\n", "", "opts", ".", "model_path", "=", "\"%s/Epoch%d.pth\"", "%", "(", "opts", ".", "results_dir", ",", "manual_opts", ".", "model_epoch", ")", "\n", "\n", "return", "opts", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.train_tracking.set_seed": [[16, 22], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all"], "function", ["None"], ["def", "set_seed", "(", "seed", ")", ":", "\n", "    ", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "seed", ")", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.train_tracking.train_tracking": [[23, 87], ["utils.show_line.print_info", "train_tracking.set_seed", "utils.show_line.print_info", "datasets.get_v2b_db.get_dataset", "datasets.get_v2b_db.get_dataset", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "utils.show_line.print_info", "modules.v2b_net.V2B_Tracking", "torch.nn.DataParallel.to", "utils.show_line.print_info", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "utils.show_line.print_info", "utils.show_line.print_info", "range", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel.parameters", "opts.which_dataset.upper", "torch.StepLR", "torch.StepLR", "utils.loss.losses.FocalLoss().to", "utils.loss.losses.RegL1Loss().to", "utils.loss.losses.RegL1Loss().to", "utils.loss.PCLosses.ChamferLoss().to", "print", "trainers.trainer.train_model", "trainers.trainer.valid_model", "torch.save", "torch.save", "torch.save", "lr_scheduler.StepLR.step", "print", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "range", "str", "torch.nn.DataParallel.state_dict", "os.path.join", "torch.save", "torch.save", "torch.save", "train_db.voxel_size.copy", "train_db.scene_ground.copy", "train_db.min_img_coord.copy", "train_db.xy_size.copy", "utils.loss.losses.FocalLoss", "utils.loss.losses.RegL1Loss", "utils.loss.losses.RegL1Loss", "utils.loss.PCLosses.ChamferLoss", "torch.nn.DataParallel.state_dict", "os.path.join", "str"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.set_seed", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.get_v2b_db.get_dataset", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.get_v2b_db.get_dataset", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.trainers.trainer.train_model", "home.repos.pwc.inspect_result.fpthink_v2b.trainers.trainer.valid_model", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["", "def", "train_tracking", "(", "opts", ")", ":", "\n", "## Init", "\n", "    ", "print_info", "(", "opts", ".", "ncols", ",", "'Start'", ")", "\n", "set_seed", "(", "opts", ".", "seed", ")", "\n", "\n", "## Define dataset", "\n", "print_info", "(", "opts", ".", "ncols", ",", "'Define dataset'", ")", "\n", "train_loader", ",", "train_db", "=", "get_dataset", "(", "opts", ",", "partition", "=", "\"Train\"", ",", "shuffle", "=", "True", ")", "\n", "valid_loader", ",", "valid_db", "=", "get_dataset", "(", "opts", ",", "partition", "=", "\"Valid\"", ",", "shuffle", "=", "False", ")", "\n", "\n", "opts", ".", "voxel_size", "=", "torch", ".", "from_numpy", "(", "train_db", ".", "voxel_size", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "opts", ".", "voxel_area", "=", "train_db", ".", "voxel_grid_size", "\n", "opts", ".", "scene_ground", "=", "torch", ".", "from_numpy", "(", "train_db", ".", "scene_ground", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "opts", ".", "min_img_coord", "=", "torch", ".", "from_numpy", "(", "train_db", ".", "min_img_coord", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "opts", ".", "xy_size", "=", "torch", ".", "from_numpy", "(", "train_db", ".", "xy_size", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "\n", "## Define model", "\n", "print_info", "(", "opts", ".", "ncols", ",", "'Define model'", ")", "\n", "model", "=", "V2B_Tracking", "(", "opts", ")", "\n", "if", "(", "opts", ".", "n_gpus", ">", "1", ")", "and", "(", "opts", ".", "n_gpus", ">=", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", ":", "\n", "        ", "model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "model", ",", "range", "(", "opts", ".", "n_gpus", ")", ")", "\n", "", "model", "=", "model", ".", "to", "(", "opts", ".", "device", ")", "\n", "\n", "## Define optim & scheduler", "\n", "print_info", "(", "opts", ".", "ncols", ",", "'Define optimizer & scheduler'", ")", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "opts", ".", "learning_rate", ",", "betas", "=", "(", "0.9", ",", "0.999", ")", ")", "\n", "\n", "if", "opts", ".", "which_dataset", ".", "upper", "(", ")", "==", "\"NUSCENES\"", ":", "\n", "        ", "scheduler", "=", "lr_scheduler", ".", "StepLR", "(", "optimizer", ",", "step_size", "=", "2", ",", "gamma", "=", "0.2", ")", "\n", "", "else", ":", "\n", "        ", "scheduler", "=", "lr_scheduler", ".", "StepLR", "(", "optimizer", ",", "step_size", "=", "6", ",", "gamma", "=", "0.2", ")", "\n", "\n", "## Define loss", "\n", "", "print_info", "(", "opts", ".", "ncols", ",", "'Define loss'", ")", "\n", "criternions", "=", "{", "\n", "'hm'", ":", "FocalLoss", "(", ")", ".", "to", "(", "opts", ".", "device", ")", ",", "\n", "'loc'", ":", "RegL1Loss", "(", ")", ".", "to", "(", "opts", ".", "device", ")", ",", "\n", "'z_axis'", ":", "RegL1Loss", "(", ")", ".", "to", "(", "opts", ".", "device", ")", ",", "\n", "'completion'", ":", "ChamferLoss", "(", ")", ".", "to", "(", "opts", ".", "device", ")", ",", "\n", "}", "\n", "\n", "## Training", "\n", "print_info", "(", "opts", ".", "ncols", ",", "'Start training!'", ")", "\n", "\n", "best_loss", "=", "9e99", "\n", "for", "epoch", "in", "range", "(", "1", ",", "opts", ".", "n_epoches", "+", "1", ")", ":", "\n", "        ", "print", "(", "'Epoch'", ",", "str", "(", "epoch", ")", ",", "'is training:'", ")", "\n", "\n", "# train current epoch", "\n", "train_loss", "=", "train_model", "(", "opts", ",", "model", ",", "train_loader", ",", "optimizer", ",", "criternions", ",", "epoch", ")", "\n", "valid_loss", "=", "valid_model", "(", "opts", ",", "model", ",", "valid_loader", ",", "criternions", ",", "epoch", ")", "\n", "\n", "# save current epoch state_dict", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "opts", ".", "results_dir", ",", "\"Epoch\"", "+", "str", "(", "epoch", ")", "+", "\".pth\"", ")", ")", "\n", "\n", "# save best model state_dict", "\n", "if", "valid_loss", "<", "best_loss", ":", "\n", "            ", "best_loss", "=", "valid_loss", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "opts", ".", "results_dir", ",", "\"Best.pth\"", ")", ")", "\n", "\n", "# update scheduler", "\n", "", "scheduler", ".", "step", "(", "epoch", ")", "\n", "\n", "print", "(", "'======>>>>> Train: loss: %.5f, Valid: loss: %.5f <<<<<======'", "%", "(", "train_loss", ",", "valid_loss", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.set_seed": [[12, 15], ["torch.manual_seed", "numpy.random.seed"], "function", ["None"], ["def", "set_seed", "(", "seed", ")", ":", "\n", "    ", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.test_tracking": [[16, 23], ["opts.which_dataset.upper", "test_tracking.test_tracking_waymo_format", "test_tracking.test_tracking_kitti_format"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.test_tracking_waymo_format", "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.test_tracking_kitti_format"], ["", "def", "test_tracking", "(", "opts", ")", ":", "\n", "    ", "if", "opts", ".", "which_dataset", ".", "upper", "(", ")", "==", "'WAYMO'", ":", "\n", "# in the future, we expect to unify the data format between waymo and kitti/nuscenes", "\n", "        ", "test_tracking_waymo_format", "(", "opts", ")", "\n", "", "else", ":", "\n", "# nuscenes have the same data format as kitti", "\n", "        ", "test_tracking_kitti_format", "(", "opts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.test_tracking_kitti_format": [[24, 79], ["utils.show_line.print_info", "test_tracking.set_seed", "utils.show_line.print_info", "datasets.get_v2b_db.get_dataset", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "utils.show_line.print_info", "modules.v2b_net.V2B_Tracking", "isinstance", "modules.v2b_net.V2B_Tracking.cuda", "test_db.get_tracklet_framse", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.show_line.print_info", "range", "opts.which_dataset.upper", "trainers.tester.test_model_kitti_format", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "print", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "modules.v2b_net.V2B_Tracking.load_state_dict", "test_db.voxel_size.copy", "test_db.scene_ground.copy", "test_db.min_img_coord.copy", "test_db.xy_size.copy", "torch.load", "torch.load", "modules.v2b_net.V2B_Tracking.load_state_dict", "opts.db.category_name.lower", "opts.db.category_name.lower", "k.startswith", "k.startswith"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.set_seed", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.get_v2b_db.get_dataset", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.get_tracklet_framse", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.trainers.tester.test_model_kitti_format", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["", "", "def", "test_tracking_kitti_format", "(", "opts", ")", ":", "\n", "## Init", "\n", "    ", "print_info", "(", "opts", ".", "ncols", ",", "'Start'", ")", "\n", "set_seed", "(", "opts", ".", "seed", ")", "\n", "\n", "## Define dataset", "\n", "print_info", "(", "opts", ".", "ncols", ",", "'Define datasets'", ")", "\n", "test_loader", ",", "test_db", "=", "get_dataset", "(", "opts", ",", "partition", "=", "\"Test\"", ",", "shuffle", "=", "False", ")", "\n", "opts", ".", "voxel_size", "=", "torch", ".", "from_numpy", "(", "test_db", ".", "voxel_size", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "opts", ".", "voxel_area", "=", "test_db", ".", "voxel_grid_size", "\n", "opts", ".", "scene_ground", "=", "torch", ".", "from_numpy", "(", "test_db", ".", "scene_ground", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "opts", ".", "min_img_coord", "=", "torch", ".", "from_numpy", "(", "test_db", ".", "min_img_coord", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "opts", ".", "xy_size", "=", "torch", ".", "from_numpy", "(", "test_db", ".", "xy_size", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "\n", "## Define model", "\n", "print_info", "(", "opts", ".", "ncols", ",", "'Load model: %s'", "%", "opts", ".", "model_path", ")", "\n", "model", "=", "V2B_Tracking", "(", "opts", ")", "\n", "if", "opts", ".", "model_path", "!=", "''", ":", "\n", "        ", "try", ":", "\n", "            ", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "opts", ".", "model_path", ")", ")", "\n", "", "except", ":", "\n", "            ", "state_dict_", "=", "torch", ".", "load", "(", "opts", ".", "model_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "state_dict", "=", "{", "}", "\n", "for", "k", "in", "state_dict_", ":", "\n", "                ", "if", "k", ".", "startswith", "(", "'module'", ")", "and", "not", "k", ".", "startswith", "(", "'module_list'", ")", ":", "\n", "                    ", "state_dict", "[", "k", "[", "7", ":", "]", "]", "=", "state_dict_", "[", "k", "]", "\n", "", "else", ":", "\n", "                    ", "state_dict", "[", "k", "]", "=", "state_dict_", "[", "k", "]", "\n", "", "", "model", ".", "load_state_dict", "(", "state_dict", ",", "strict", "=", "True", ")", "\n", "", "", "if", "isinstance", "(", "model", ",", "torch", ".", "nn", ".", "DataParallel", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "", "model", ".", "cuda", "(", ")", "\n", "\n", "## online tracking test", "\n", "total_lenth", "=", "test_db", ".", "get_tracklet_framse", "(", ")", "\n", "\n", "Success_run", "=", "AverageMeter", "(", ")", "\n", "Precision_run", "=", "AverageMeter", "(", ")", "\n", "\n", "max_epoch", "=", "1", "\n", "\n", "print_info", "(", "opts", ".", "ncols", ",", "'Start tracking!'", ")", "\n", "interval", "=", "{", "'car'", ":", "[", "0", ",", "150", ",", "1000", ",", "2500", "]", ",", "'pedestrian'", ":", "[", "0", ",", "100", ",", "500", ",", "1000", "]", ",", "'van'", ":", "[", "0", ",", "150", ",", "1000", ",", "2500", "]", ",", "'cyclist'", ":", "[", "0", ",", "100", ",", "500", ",", "1000", "]", "}", "\n", "interval_nuscenes", "=", "{", "'car'", ":", "[", "0", ",", "150", ",", "1000", ",", "2500", "]", ",", "'pedestrian'", ":", "[", "0", ",", "100", ",", "500", ",", "1000", "]", ",", "'truck'", ":", "[", "0", ",", "150", ",", "1000", ",", "2500", "]", ",", "'bicycle'", ":", "[", "0", ",", "100", ",", "500", ",", "1000", "]", "}", "\n", "if", "opts", ".", "which_dataset", ".", "upper", "(", ")", "==", "'NUSCENES'", ":", "\n", "        ", "opts", ".", "sparse_interval", "=", "interval_nuscenes", "[", "opts", ".", "db", ".", "category_name", ".", "lower", "(", ")", "]", "\n", "", "else", ":", "\n", "        ", "opts", ".", "sparse_interval", "=", "interval", "[", "opts", ".", "db", ".", "category_name", ".", "lower", "(", ")", "]", "\n", "\n", "", "for", "epoch", "in", "range", "(", "1", ",", "max_epoch", "+", "1", ")", ":", "\n", "        ", "Succ", ",", "Prec", "=", "test_model_kitti_format", "(", "opts", ",", "model", ",", "test_loader", ",", "total_lenth", ")", "\n", "Success_run", ".", "update", "(", "Succ", ")", "\n", "Precision_run", ".", "update", "(", "Prec", ")", "\n", "\n", "print", "(", "'epoch %d : cur Succ/Prec %.2f/%.2f,   mean Succ/Prec %.2f/%.2f '", "%", "(", "epoch", ",", "Succ", ",", "Prec", ",", "Success_run", ".", "avg", ",", "Precision_run", ".", "avg", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.test_tracking_waymo_format": [[80, 193], ["utils.show_line.print_info", "test_tracking.set_seed", "test_tracking.init_voxel_opts", "utils.show_line.print_info", "modules.v2b_net.V2B_Tracking", "isinstance", "modules.v2b_net.V2B_Tracking.cuda", "utils.show_line.print_info", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "enumerate", "print", "bench_paths.append", "bench_lists.append", "easy_id_list.append", "medium_id_list.append", "hard_id_list.append", "datasets.get_v2b_db.get_dataset", "wod_dataset.get_tracklet_lenth", "print", "trainers.tester.test_model_waymo_format", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "print", "print", "modules.v2b_net.V2B_Tracking.load_state_dict", "os.path.join", "json.load", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "torch.load", "torch.load", "modules.v2b_net.V2B_Tracking.load_state_dict", "open", "len", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "k.startswith", "k.startswith"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.set_seed", "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.init_voxel_opts", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.utils.show_line.print_info", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.get_v2b_db.get_dataset", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD.get_tracklet_lenth", "home.repos.pwc.inspect_result.fpthink_v2b.trainers.tester.test_model_waymo_format", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update"], ["", "", "def", "test_tracking_waymo_format", "(", "opts", ")", ":", "\n", "## Init", "\n", "    ", "print_info", "(", "opts", ".", "ncols", ",", "'Init voxel opts'", ")", "\n", "set_seed", "(", "opts", ".", "seed", ")", "\n", "init_voxel_opts", "(", "opts", ")", "\n", "\n", "## Define model", "\n", "print_info", "(", "opts", ".", "ncols", ",", "'Load model: %s'", "%", "opts", ".", "model_path", ")", "\n", "model", "=", "V2B_Tracking", "(", "opts", ")", "\n", "if", "opts", ".", "model_path", "!=", "''", ":", "\n", "        ", "try", ":", "\n", "            ", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "opts", ".", "model_path", ")", ")", "\n", "", "except", ":", "\n", "            ", "state_dict_", "=", "torch", ".", "load", "(", "opts", ".", "model_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "state_dict", "=", "{", "}", "\n", "for", "k", "in", "state_dict_", ":", "\n", "                ", "if", "k", ".", "startswith", "(", "'module'", ")", "and", "not", "k", ".", "startswith", "(", "'module_list'", ")", ":", "\n", "                    ", "state_dict", "[", "k", "[", "7", ":", "]", "]", "=", "state_dict_", "[", "k", "]", "\n", "", "else", ":", "\n", "                    ", "state_dict", "[", "k", "]", "=", "state_dict_", "[", "k", "]", "\n", "", "", "model", ".", "load_state_dict", "(", "state_dict", ",", "strict", "=", "True", ")", "\n", "", "", "if", "isinstance", "(", "model", ",", "torch", ".", "nn", ".", "DataParallel", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "", "model", ".", "cuda", "(", ")", "\n", "\n", "## Test tracking", "\n", "print_info", "(", "opts", ".", "ncols", ",", "'Start tracking!'", ")", "\n", "data_folder", "=", "opts", ".", "db", ".", "data_dir", "\n", "\n", "bench_paths", "=", "[", "]", "\n", "bench_lists", "=", "[", "]", "\n", "json_names", "=", "[", "'easy.json'", ",", "'medium.json'", ",", "'hard.json'", ",", "'bench_list.json'", "]", "\n", "\n", "for", "json_name", "in", "json_names", ":", "\n", "        ", "bench_paths", ".", "append", "(", "os", ".", "path", ".", "join", "(", "data_folder", ",", "'benchmark/validation/'", ",", "opts", ".", "db", ".", "category_name", ",", "json_name", ")", ")", "\n", "", "for", "bench_path", "in", "bench_paths", ":", "\n", "        ", "bench_lists", ".", "append", "(", "json", ".", "load", "(", "open", "(", "bench_path", ",", "'r'", ")", ")", ")", "\n", "\n", "", "easy_id_list", "=", "[", "]", "\n", "medium_id_list", "=", "[", "]", "\n", "hard_id_list", "=", "[", "]", "\n", "for", "tracklet_info", "in", "bench_lists", "[", "0", "]", ":", "\n", "        ", "easy_id_list", ".", "append", "(", "tracklet_info", "[", "'id'", "]", ")", "\n", "", "for", "tracklet_info", "in", "bench_lists", "[", "1", "]", ":", "\n", "        ", "medium_id_list", ".", "append", "(", "tracklet_info", "[", "'id'", "]", ")", "\n", "", "for", "tracklet_info", "in", "bench_lists", "[", "2", "]", ":", "\n", "        ", "hard_id_list", ".", "append", "(", "tracklet_info", "[", "'id'", "]", ")", "\n", "\n", "", "Success_run", "=", "AverageMeter", "(", ")", "\n", "Precision_run", "=", "AverageMeter", "(", ")", "\n", "Success_easy_run", "=", "AverageMeter", "(", ")", "\n", "Precision_easy_run", "=", "AverageMeter", "(", ")", "\n", "Success_medium_run", "=", "AverageMeter", "(", ")", "\n", "Precision_medium_run", "=", "AverageMeter", "(", ")", "\n", "Success_hard_run", "=", "AverageMeter", "(", ")", "\n", "Precision_hard_run", "=", "AverageMeter", "(", ")", "\n", "\n", "easy_frame_num", "=", "0", "\n", "medium_frame_num", "=", "0", "\n", "hard_frame_num", "=", "0", "\n", "total_frame_num", "=", "0", "\n", "\n", "passed_num", "=", "0", "\n", "\n", "for", "tracklet_index", ",", "tracklet_info", "in", "enumerate", "(", "bench_lists", "[", "-", "1", "]", ")", ":", "\n", "        ", "opts", ".", "db", ".", "tracklet_id", "=", "tracklet_info", "[", "'id'", "]", "\n", "opts", ".", "db", ".", "segment_name", "=", "tracklet_info", "[", "'segment_name'", "]", "\n", "opts", ".", "db", ".", "frame_range", "=", "tracklet_info", "[", "'frame_range'", "]", "\n", "\n", "_", ",", "wod_dataset", "=", "get_dataset", "(", "opts", ",", "partition", "=", "\"Test\"", ")", "\n", "tracklet_length", "=", "wod_dataset", ".", "get_tracklet_lenth", "(", ")", "\n", "\n", "print", "(", "'Prog:({:4d}/{:4d}), ID:\"{:}\", Len:{:3d}, '", ".", "format", "(", "tracklet_index", "+", "1", ",", "len", "(", "bench_lists", "[", "-", "1", "]", ")", ",", "tracklet_info", "[", "'id'", "]", ",", "tracklet_length", ")", ",", "end", "=", "''", ")", "\n", "\n", "'''\n        There are bus/truck and other instance in the vehicle category of waymo\n        and their length may even exceed 10 meters\n        but the car category of kitti will not exceed 5.5 meters at most\n        '''", "\n", "# box_lenth = wod_dataset.get_instance_lenth()", "\n", "# if box_lenth > 7.0:", "\n", "#     print('Sorry, this vehicle is too long ({:.2f} m)! Pass.'.format(box_lenth))", "\n", "#     passed_num += 1", "\n", "#     continue", "\n", "\n", "Succ", ",", "Prec", "=", "test_model_waymo_format", "(", "opts", "=", "opts", ",", "model", "=", "model", ",", "dataset", "=", "wod_dataset", ")", "\n", "\n", "Success_run", ".", "update", "(", "Succ", ",", "n", "=", "tracklet_length", ")", "\n", "Precision_run", ".", "update", "(", "Prec", ",", "n", "=", "tracklet_length", ")", "\n", "\n", "total_frame_num", "+=", "tracklet_length", "\n", "if", "opts", ".", "db", ".", "tracklet_id", "in", "easy_id_list", ":", "\n", "            ", "easy_frame_num", "+=", "tracklet_length", "\n", "Success_easy_run", ".", "update", "(", "Succ", ",", "n", "=", "tracklet_length", ")", "\n", "Precision_easy_run", ".", "update", "(", "Prec", ",", "n", "=", "tracklet_length", ")", "\n", "", "elif", "opts", ".", "db", ".", "tracklet_id", "in", "medium_id_list", ":", "\n", "            ", "medium_frame_num", "+=", "tracklet_length", "\n", "Success_medium_run", ".", "update", "(", "Succ", ",", "n", "=", "tracklet_length", ")", "\n", "Precision_medium_run", ".", "update", "(", "Prec", ",", "n", "=", "tracklet_length", ")", "\n", "", "else", ":", "\n", "            ", "hard_frame_num", "+=", "tracklet_length", "\n", "Success_hard_run", ".", "update", "(", "Succ", ",", "n", "=", "tracklet_length", ")", "\n", "Precision_hard_run", ".", "update", "(", "Prec", ",", "n", "=", "tracklet_length", ")", "\n", "\n", "# T_F ==> total frames ", "\n", "# C_S/P, T_S/P ==> current success/precision,   total success/precision", "\n", "", "print", "(", "'T_F: %6d (%5d, %5d, %5d), '", "%", "(", "total_frame_num", ",", "easy_frame_num", ",", "medium_frame_num", ",", "hard_frame_num", ")", ",", "end", "=", "''", ")", "\n", "print", "(", "'C_S/P %5.2f/%5.2f, T_S/P %4.1f/%4.1f (%4.1f/%4.1f, %4.1f/%4.1f, %4.1f/%4.1f)'", "%", "(", "Succ", ",", "Prec", ",", "Success_run", ".", "avg", ",", "Precision_run", ".", "avg", ",", "Success_easy_run", ".", "avg", ",", "Precision_easy_run", ".", "avg", ",", "Success_medium_run", ".", "avg", ",", "Precision_medium_run", ".", "avg", ",", "Success_hard_run", ".", "avg", ",", "Precision_hard_run", ".", "avg", ",", ")", ")", "\n", "\n", "", "print", "(", "'mean Succ/Prec %.2f/%.2f '", "%", "(", "Success_run", ".", "avg", ",", "Precision_run", ".", "avg", ")", ")", "\n", "# print('There are %d object is too long.'%(passed_num))", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.V2B_main.test_tracking.init_voxel_opts": [[195, 215], ["numpy.array", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().transpose", "numpy.floor", "np.array().reshape.transpose", "voxel_grid_size.astype.astype", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "numpy.array", "ValueError", "numpy.ceil", "numpy.floor", "numpy.array", "numpy.array", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "np.array.copy", "scene_ground.copy", "np.floor.copy", "xy_size.copy"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["", "def", "init_voxel_opts", "(", "opts", ")", ":", "\n", "    ", "voxel_size", "=", "np", ".", "array", "(", "opts", ".", "voxel_size", ")", "\n", "area_extents", "=", "np", ".", "array", "(", "opts", ".", "area_extents", ")", ".", "reshape", "(", "3", ",", "2", ")", "\n", "xy_size", "=", "np", ".", "array", "(", "opts", ".", "xy_size", ")", "*", "opts", ".", "downsample", "\n", "xy_area_extents", "=", "np", ".", "array", "(", "opts", ".", "xy_area_extents", ")", ".", "reshape", "(", "2", ",", "2", ")", "\n", "extents_transpose", "=", "np", ".", "array", "(", "xy_area_extents", ")", ".", "transpose", "(", ")", "\n", "if", "extents_transpose", ".", "shape", "!=", "(", "2", ",", "2", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Extents are the wrong shape {}\"", ".", "format", "(", "extents_transpose", ".", "shape", ")", ")", "\n", "# Set image grid extents", "\n", "", "min_img_coord", "=", "np", ".", "floor", "(", "extents_transpose", "[", "0", "]", "/", "xy_size", ")", "\n", "voxel_extents_transpose", "=", "area_extents", ".", "transpose", "(", ")", "\n", "scene_ground", "=", "voxel_extents_transpose", "[", "0", "]", "\n", "voxel_grid_size", "=", "np", ".", "ceil", "(", "voxel_extents_transpose", "[", "1", "]", "/", "voxel_size", ")", "-", "np", ".", "floor", "(", "voxel_extents_transpose", "[", "0", "]", "/", "voxel_size", ")", "\n", "voxel_grid_size", "=", "voxel_grid_size", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "opts", ".", "voxel_size", "=", "torch", ".", "from_numpy", "(", "voxel_size", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "opts", ".", "voxel_area", "=", "voxel_grid_size", "\n", "opts", ".", "scene_ground", "=", "torch", ".", "from_numpy", "(", "scene_ground", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "opts", ".", "min_img_coord", "=", "torch", ".", "from_numpy", "(", "min_img_coord", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "\n", "opts", ".", "xy_size", "=", "torch", ".", "from_numpy", "(", "xy_size", ".", "copy", "(", ")", ")", ".", "float", "(", ")", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.replicate.DataParallelWithCallback.replicate": [[64, 68], ["super().replicate", "replicate.execute_replication_callbacks"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.replicate.DataParallelWithCallback.replicate", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.replicate.execute_replication_callbacks"], ["def", "replicate", "(", "self", ",", "module", ",", "device_ids", ")", ":", "\n", "        ", "modules", "=", "super", "(", "DataParallelWithCallback", ",", "self", ")", ".", "replicate", "(", "module", ",", "device_ids", ")", "\n", "execute_replication_callbacks", "(", "modules", ")", "\n", "return", "modules", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.replicate.execute_replication_callbacks": [[27, 48], ["len", "enumerate", "list", "replicate.CallbackContext", "enumerate", "master_copy.modules", "range", "module.modules", "hasattr", "m.__data_parallel_replicate__"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._SynchronizedBatchNorm.__data_parallel_replicate__"], ["", "def", "execute_replication_callbacks", "(", "modules", ")", ":", "\n", "    ", "\"\"\"\n    Execute an replication callback `__data_parallel_replicate__` on each module created by original replication.\n\n    The callback will be invoked with arguments `__data_parallel_replicate__(ctx, copy_id)`\n\n    Note that, as all modules are isomorphism, we assign each sub-module with a context\n    (shared among multiple copies of this module on different devices).\n    Through this context, different copies can share some information.\n\n    We guarantee that the callback on the master copy (the first copy) will be called ahead of calling the callback\n    of any slave copies.\n    \"\"\"", "\n", "master_copy", "=", "modules", "[", "0", "]", "\n", "nr_modules", "=", "len", "(", "list", "(", "master_copy", ".", "modules", "(", ")", ")", ")", "\n", "ctxs", "=", "[", "CallbackContext", "(", ")", "for", "_", "in", "range", "(", "nr_modules", ")", "]", "\n", "\n", "for", "i", ",", "module", "in", "enumerate", "(", "modules", ")", ":", "\n", "        ", "for", "j", ",", "m", "in", "enumerate", "(", "module", ".", "modules", "(", ")", ")", ":", "\n", "            ", "if", "hasattr", "(", "m", ",", "'__data_parallel_replicate__'", ")", ":", "\n", "                ", "m", ".", "__data_parallel_replicate__", "(", "ctxs", "[", "j", "]", ",", "i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.replicate.patch_replication_callback": [[70, 95], ["isinstance", "functools.wraps", "old_replicate", "replicate.execute_replication_callbacks"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.replicate.execute_replication_callbacks"], ["", "", "def", "patch_replication_callback", "(", "data_parallel", ")", ":", "\n", "    ", "\"\"\"\n    Monkey-patch an existing `DataParallel` object. Add the replication callback.\n    Useful when you have customized `DataParallel` implementation.\n\n    Examples:\n        > sync_bn = SynchronizedBatchNorm1d(10, eps=1e-5, affine=False)\n        > sync_bn = DataParallel(sync_bn, device_ids=[0, 1])\n        > patch_replication_callback(sync_bn)\n        # this is equivalent to\n        > sync_bn = SynchronizedBatchNorm1d(10, eps=1e-5, affine=False)\n        > sync_bn = DataParallelWithCallback(sync_bn, device_ids=[0, 1])\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "data_parallel", ",", "DataParallel", ")", "\n", "\n", "old_replicate", "=", "data_parallel", ".", "replicate", "\n", "\n", "@", "functools", ".", "wraps", "(", "old_replicate", ")", "\n", "def", "new_replicate", "(", "module", ",", "device_ids", ")", ":", "\n", "        ", "modules", "=", "old_replicate", "(", "module", ",", "device_ids", ")", "\n", "execute_replication_callbacks", "(", "modules", ")", "\n", "return", "modules", "\n", "\n", "", "data_parallel", ".", "replicate", "=", "new_replicate", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.__init__": [[21, 25], ["threading.Lock", "threading.Condition"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_result", "=", "None", "\n", "self", ".", "_lock", "=", "threading", ".", "Lock", "(", ")", "\n", "self", ".", "_cond", "=", "threading", ".", "Condition", "(", "self", ".", "_lock", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.put": [[26, 31], ["comm.FutureResult._cond.notify"], "methods", ["None"], ["", "def", "put", "(", "self", ",", "result", ")", ":", "\n", "        ", "with", "self", ".", "_lock", ":", "\n", "            ", "assert", "self", ".", "_result", "is", "None", ",", "'Previous result has\\'t been fetched.'", "\n", "self", ".", "_result", "=", "result", "\n", "self", ".", "_cond", ".", "notify", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get": [[32, 40], ["comm.FutureResult._cond.wait"], "methods", ["None"], ["", "", "def", "get", "(", "self", ")", ":", "\n", "        ", "with", "self", ".", "_lock", ":", "\n", "            ", "if", "self", ".", "_result", "is", "None", ":", "\n", "                ", "self", ".", "_cond", ".", "wait", "(", ")", "\n", "\n", "", "res", "=", "self", ".", "_result", "\n", "self", ".", "_result", "=", "None", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SlavePipe.run_slave": [[49, 54], ["comm.SlavePipe.queue.put", "comm.SlavePipe.result.get", "comm.SlavePipe.queue.put"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.put", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.put"], ["def", "run_slave", "(", "self", ",", "msg", ")", ":", "\n", "        ", "self", ".", "queue", ".", "put", "(", "(", "self", ".", "identifier", ",", "msg", ")", ")", "\n", "ret", "=", "self", ".", "result", ".", "get", "(", ")", "\n", "self", ".", "queue", ".", "put", "(", "True", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SyncMaster.__init__": [[67, 77], ["queue.Queue", "collections.OrderedDict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "master_callback", ")", ":", "\n", "        ", "\"\"\"\n\n        Args:\n            master_callback: a callback to be invoked after having collected messages from slave devices.\n        \"\"\"", "\n", "self", ".", "_master_callback", "=", "master_callback", "\n", "self", ".", "_queue", "=", "queue", ".", "Queue", "(", ")", "\n", "self", ".", "_registry", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "self", ".", "_activated", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SyncMaster.__getstate__": [[78, 80], ["None"], "methods", ["None"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "        ", "return", "{", "'master_callback'", ":", "self", ".", "_master_callback", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SyncMaster.__setstate__": [[81, 83], ["comm.SyncMaster.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "self", ".", "__init__", "(", "state", "[", "'master_callback'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SyncMaster.register_slave": [[84, 101], ["comm.FutureResult", "_MasterRegistry", "comm.SlavePipe", "comm.SyncMaster._queue.empty", "comm.SyncMaster._registry.clear"], "methods", ["None"], ["", "def", "register_slave", "(", "self", ",", "identifier", ")", ":", "\n", "        ", "\"\"\"\n        Register an slave device.\n\n        Args:\n            identifier: an identifier, usually is the device id.\n\n        Returns: a `SlavePipe` object which can be used to communicate with the master device.\n\n        \"\"\"", "\n", "if", "self", ".", "_activated", ":", "\n", "            ", "assert", "self", ".", "_queue", ".", "empty", "(", ")", ",", "'Queue is not clean before next initialization.'", "\n", "self", ".", "_activated", "=", "False", "\n", "self", ".", "_registry", ".", "clear", "(", ")", "\n", "", "future", "=", "FutureResult", "(", ")", "\n", "self", ".", "_registry", "[", "identifier", "]", "=", "_MasterRegistry", "(", "future", ")", "\n", "return", "SlavePipe", "(", "identifier", ",", "self", ".", "_queue", ",", "future", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SyncMaster.run_master": [[102, 134], ["range", "comm.SyncMaster._master_callback", "range", "intermediates.append", "comm.SyncMaster._registry[].result.put", "comm.SyncMaster._queue.get", "comm.SyncMaster._queue.get"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.put", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.FutureResult.get"], ["", "def", "run_master", "(", "self", ",", "master_msg", ")", ":", "\n", "        ", "\"\"\"\n        Main entry for the master device in each forward pass.\n        The messages were first collected from each devices (including the master device), and then\n        an callback will be invoked to compute the message to be sent back to each devices\n        (including the master device).\n\n        Args:\n            master_msg: the message that the master want to send to itself. This will be placed as the first\n            message when calling `master_callback`. For detailed usage, see `_SynchronizedBatchNorm` for an example.\n\n        Returns: the message to be sent back to the master device.\n\n        \"\"\"", "\n", "self", ".", "_activated", "=", "True", "\n", "\n", "intermediates", "=", "[", "(", "0", ",", "master_msg", ")", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "nr_slaves", ")", ":", "\n", "            ", "intermediates", ".", "append", "(", "self", ".", "_queue", ".", "get", "(", ")", ")", "\n", "\n", "", "results", "=", "self", ".", "_master_callback", "(", "intermediates", ")", "\n", "assert", "results", "[", "0", "]", "[", "0", "]", "==", "0", ",", "'The first result should belongs to the master.'", "\n", "\n", "for", "i", ",", "res", "in", "results", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "continue", "\n", "", "self", ".", "_registry", "[", "i", "]", ".", "result", ".", "put", "(", "res", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "nr_slaves", ")", ":", "\n", "            ", "assert", "self", ".", "_queue", ".", "get", "(", ")", "is", "True", "\n", "\n", "", "return", "results", "[", "0", "]", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SyncMaster.nr_slaves": [[135, 138], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "nr_slaves", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_registry", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.unittest.TorchTestCase.assertTensorClose": [[24, 29], ["unittest.TorchTestCase.assertTrue", "unittest.as_numpy", "unittest.as_numpy", "numpy.allclose", "numpy.abs().max", "numpy.abs().max", "numpy.abs", "numpy.abs", "numpy.fmax"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.unittest.as_numpy", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.unittest.as_numpy"], ["    ", "def", "assertTensorClose", "(", "self", ",", "a", ",", "b", ",", "atol", "=", "1e-3", ",", "rtol", "=", "1e-3", ")", ":", "\n", "        ", "npa", ",", "npb", "=", "as_numpy", "(", "a", ")", ",", "as_numpy", "(", "b", ")", "\n", "self", ".", "assertTrue", "(", "\n", "np", ".", "allclose", "(", "npa", ",", "npb", ",", "atol", "=", "atol", ")", ",", "\n", "'Tensor close check failed\\n{}\\n{}\\nadiff={}, rdiff={}'", ".", "format", "(", "a", ",", "b", ",", "np", ".", "abs", "(", "npa", "-", "npb", ")", ".", "max", "(", ")", ",", "np", ".", "abs", "(", "(", "npa", "-", "npb", ")", "/", "np", ".", "fmax", "(", "npa", ",", "1e-5", ")", ")", ".", "max", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.unittest.as_numpy": [[17, 21], ["isinstance", "v.cpu().numpy", "v.cpu"], "function", ["None"], ["def", "as_numpy", "(", "v", ")", ":", "\n", "    ", "if", "isinstance", "(", "v", ",", "Variable", ")", ":", "\n", "        ", "v", "=", "v", ".", "data", "\n", "", "return", "v", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._SynchronizedBatchNorm.__init__": [[39, 47], ["torch.nn.modules.batchnorm._BatchNorm.__init__", "comm.SyncMaster"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-5", ",", "momentum", "=", "0.1", ",", "affine", "=", "True", ")", ":", "\n", "        ", "super", "(", "_SynchronizedBatchNorm", ",", "self", ")", ".", "__init__", "(", "num_features", ",", "eps", "=", "eps", ",", "momentum", "=", "momentum", ",", "affine", "=", "affine", ")", "\n", "\n", "self", ".", "_sync_master", "=", "SyncMaster", "(", "self", ".", "_data_parallel_master", ")", "\n", "\n", "self", ".", "_is_parallel", "=", "False", "\n", "self", ".", "_parallel_id", "=", "None", "\n", "self", ".", "_slave_pipe", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._SynchronizedBatchNorm.forward": [[48, 79], ["input.view.view.size", "input.view.view.view", "batchnorm._sum_ft", "batchnorm._sum_ft", "output.view", "torch.batch_norm", "torch.batch_norm", "input.view.view.size", "input.view.view.size", "input.view.view.size", "batchnorm._SynchronizedBatchNorm._sync_master.run_master", "batchnorm._SynchronizedBatchNorm._slave_pipe.run_slave", "_ChildMessage", "_ChildMessage", "batchnorm._unsqueeze_ft", "batchnorm._unsqueeze_ft", "batchnorm._unsqueeze_ft", "batchnorm._unsqueeze_ft", "batchnorm._unsqueeze_ft"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._sum_ft", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._sum_ft", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SyncMaster.run_master", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SlavePipe.run_slave", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._unsqueeze_ft", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._unsqueeze_ft", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._unsqueeze_ft", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._unsqueeze_ft", "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._unsqueeze_ft"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "# If it is not parallel computation or is in evaluation mode, use PyTorch's implementation.", "\n", "        ", "if", "not", "(", "self", ".", "_is_parallel", "and", "self", ".", "training", ")", ":", "\n", "            ", "return", "F", ".", "batch_norm", "(", "\n", "input", ",", "self", ".", "running_mean", ",", "self", ".", "running_var", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "\n", "self", ".", "training", ",", "self", ".", "momentum", ",", "self", ".", "eps", ")", "\n", "\n", "# Resize the input to (B, C, -1).", "\n", "", "input_shape", "=", "input", ".", "size", "(", ")", "\n", "input", "=", "input", ".", "view", "(", "input", ".", "size", "(", "0", ")", ",", "self", ".", "num_features", ",", "-", "1", ")", "\n", "\n", "# Compute the sum and square-sum.", "\n", "sum_size", "=", "input", ".", "size", "(", "0", ")", "*", "input", ".", "size", "(", "2", ")", "\n", "input_sum", "=", "_sum_ft", "(", "input", ")", "\n", "input_ssum", "=", "_sum_ft", "(", "input", "**", "2", ")", "\n", "\n", "# Reduce-and-broadcast the statistics.", "\n", "if", "self", ".", "_parallel_id", "==", "0", ":", "\n", "            ", "mean", ",", "inv_std", "=", "self", ".", "_sync_master", ".", "run_master", "(", "_ChildMessage", "(", "input_sum", ",", "input_ssum", ",", "sum_size", ")", ")", "\n", "", "else", ":", "\n", "            ", "mean", ",", "inv_std", "=", "self", ".", "_slave_pipe", ".", "run_slave", "(", "_ChildMessage", "(", "input_sum", ",", "input_ssum", ",", "sum_size", ")", ")", "\n", "\n", "# Compute the output.", "\n", "", "if", "self", ".", "affine", ":", "\n", "# MJY:: Fuse the multiplication for speed.", "\n", "            ", "output", "=", "(", "input", "-", "_unsqueeze_ft", "(", "mean", ")", ")", "*", "_unsqueeze_ft", "(", "inv_std", "*", "self", ".", "weight", ")", "+", "_unsqueeze_ft", "(", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "(", "input", "-", "_unsqueeze_ft", "(", "mean", ")", ")", "*", "_unsqueeze_ft", "(", "inv_std", ")", "\n", "\n", "# Reshape it.", "\n", "", "return", "output", ".", "view", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._SynchronizedBatchNorm.__data_parallel_replicate__": [[80, 89], ["ctx.sync_master.register_slave"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.comm.SyncMaster.register_slave"], ["", "def", "__data_parallel_replicate__", "(", "self", ",", "ctx", ",", "copy_id", ")", ":", "\n", "        ", "self", ".", "_is_parallel", "=", "True", "\n", "self", ".", "_parallel_id", "=", "copy_id", "\n", "\n", "# parallel_id == 0 means master device.", "\n", "if", "self", ".", "_parallel_id", "==", "0", ":", "\n", "            ", "ctx", ".", "sync_master", "=", "self", ".", "_sync_master", "\n", "", "else", ":", "\n", "            ", "self", ".", "_slave_pipe", "=", "ctx", ".", "sync_master", ".", "register_slave", "(", "copy_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._SynchronizedBatchNorm._data_parallel_master": [[90, 112], ["sorted", "sum", "torch.nn.parallel._functions.ReduceAddCoalesced.apply", "torch.nn.parallel._functions.ReduceAddCoalesced.apply", "batchnorm._SynchronizedBatchNorm._compute_mean_std", "torch.nn.parallel._functions.Broadcast.apply", "torch.nn.parallel._functions.Broadcast.apply", "enumerate", "i[].sum.get_device", "outputs.append", "i[].sum.get_device", "_MasterMessage"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._SynchronizedBatchNorm._compute_mean_std"], ["", "", "def", "_data_parallel_master", "(", "self", ",", "intermediates", ")", ":", "\n", "        ", "\"\"\"Reduce the sum and square-sum, compute the statistics, and broadcast it.\"\"\"", "\n", "\n", "# Always using same \"device order\" makes the ReduceAdd operation faster.", "\n", "# Thanks to:: Tete Xiao (http://tetexiao.com/)", "\n", "intermediates", "=", "sorted", "(", "intermediates", ",", "key", "=", "lambda", "i", ":", "i", "[", "1", "]", ".", "sum", ".", "get_device", "(", ")", ")", "\n", "\n", "to_reduce", "=", "[", "i", "[", "1", "]", "[", ":", "2", "]", "for", "i", "in", "intermediates", "]", "\n", "to_reduce", "=", "[", "j", "for", "i", "in", "to_reduce", "for", "j", "in", "i", "]", "# flatten", "\n", "target_gpus", "=", "[", "i", "[", "1", "]", ".", "sum", ".", "get_device", "(", ")", "for", "i", "in", "intermediates", "]", "\n", "\n", "sum_size", "=", "sum", "(", "[", "i", "[", "1", "]", ".", "sum_size", "for", "i", "in", "intermediates", "]", ")", "\n", "sum_", ",", "ssum", "=", "ReduceAddCoalesced", ".", "apply", "(", "target_gpus", "[", "0", "]", ",", "2", ",", "*", "to_reduce", ")", "\n", "mean", ",", "inv_std", "=", "self", ".", "_compute_mean_std", "(", "sum_", ",", "ssum", ",", "sum_size", ")", "\n", "\n", "broadcasted", "=", "Broadcast", ".", "apply", "(", "target_gpus", ",", "mean", ",", "inv_std", ")", "\n", "\n", "outputs", "=", "[", "]", "\n", "for", "i", ",", "rec", "in", "enumerate", "(", "intermediates", ")", ":", "\n", "            ", "outputs", ".", "append", "(", "(", "rec", "[", "0", "]", ",", "_MasterMessage", "(", "*", "broadcasted", "[", "i", "*", "2", ":", "i", "*", "2", "+", "2", "]", ")", ")", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._SynchronizedBatchNorm._compute_mean_std": [[113, 126], ["bias_var.clamp"], "methods", ["None"], ["", "def", "_compute_mean_std", "(", "self", ",", "sum_", ",", "ssum", ",", "size", ")", ":", "\n", "        ", "\"\"\"Compute the mean and standard-deviation with sum and square-sum. This method\n        also maintains the moving average on the master device.\"\"\"", "\n", "assert", "size", ">", "1", ",", "'BatchNorm computes unbiased standard-deviation, which requires size > 1.'", "\n", "mean", "=", "sum_", "/", "size", "\n", "sumvar", "=", "ssum", "-", "sum_", "*", "mean", "\n", "unbias_var", "=", "sumvar", "/", "(", "size", "-", "1", ")", "\n", "bias_var", "=", "sumvar", "/", "size", "\n", "\n", "self", ".", "running_mean", "=", "(", "1", "-", "self", ".", "momentum", ")", "*", "self", ".", "running_mean", "+", "self", ".", "momentum", "*", "mean", ".", "data", "\n", "self", ".", "running_var", "=", "(", "1", "-", "self", ".", "momentum", ")", "*", "self", ".", "running_var", "+", "self", ".", "momentum", "*", "unbias_var", ".", "data", "\n", "\n", "return", "mean", ",", "bias_var", ".", "clamp", "(", "self", ".", "eps", ")", "**", "-", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm.SynchronizedBatchNorm1d._check_input_dim": [[184, 189], ["super()._check_input_dim", "ValueError", "input.dim", "input.dim", "input.dim"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm.SynchronizedBatchNorm3d._check_input_dim"], ["def", "_check_input_dim", "(", "self", ",", "input", ")", ":", "\n", "        ", "if", "input", ".", "dim", "(", ")", "!=", "2", "and", "input", ".", "dim", "(", ")", "!=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "'expected 2D or 3D input (got {}D input)'", "\n", ".", "format", "(", "input", ".", "dim", "(", ")", ")", ")", "\n", "", "super", "(", "SynchronizedBatchNorm1d", ",", "self", ")", ".", "_check_input_dim", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm.SynchronizedBatchNorm2d._check_input_dim": [[247, 252], ["super()._check_input_dim", "input.dim", "ValueError", "input.dim"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm.SynchronizedBatchNorm3d._check_input_dim"], ["def", "_check_input_dim", "(", "self", ",", "input", ")", ":", "\n", "        ", "if", "input", ".", "dim", "(", ")", "!=", "4", ":", "\n", "            ", "raise", "ValueError", "(", "'expected 4D input (got {}D input)'", "\n", ".", "format", "(", "input", ".", "dim", "(", ")", ")", ")", "\n", "", "super", "(", "SynchronizedBatchNorm2d", ",", "self", ")", ".", "_check_input_dim", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm.SynchronizedBatchNorm3d._check_input_dim": [[311, 316], ["super()._check_input_dim", "input.dim", "ValueError", "input.dim"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm.SynchronizedBatchNorm3d._check_input_dim"], ["def", "_check_input_dim", "(", "self", ",", "input", ")", ":", "\n", "        ", "if", "input", ".", "dim", "(", ")", "!=", "5", ":", "\n", "            ", "raise", "ValueError", "(", "'expected 5D input (got {}D input)'", "\n", ".", "format", "(", "input", ".", "dim", "(", ")", ")", ")", "\n", "", "super", "(", "SynchronizedBatchNorm3d", ",", "self", ")", ".", "_check_input_dim", "(", "input", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._sum_ft": [[24, 27], ["tensor.sum().sum", "tensor.sum"], "function", ["None"], ["def", "_sum_ft", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"sum over the first and last dimention\"\"\"", "\n", "return", "tensor", ".", "sum", "(", "dim", "=", "0", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.sync_bn.batchnorm._unsqueeze_ft": [[29, 32], ["tensor.unsqueeze().unsqueeze", "tensor.unsqueeze"], "function", ["None"], ["", "def", "_unsqueeze_ft", "(", "tensor", ")", ":", "\n", "    ", "\"\"\"add new dementions at the front and the tail\"\"\"", "\n", "return", "tensor", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.FurthestSampling.forward": [[11, 23], ["xyz.is_contiguous", "xyz.size", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "pointops_cuda.furthestsampling_cuda", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "xyz", ",", "m", ")", ":", "\n", "        ", "\"\"\"\n        input: xyz: (b, n, 3) and n > m, m: int32\n        output: idx: (b, m)\n        \"\"\"", "\n", "assert", "xyz", ".", "is_contiguous", "(", ")", "\n", "b", ",", "n", ",", "_", "=", "xyz", ".", "size", "(", ")", "\n", "idx", "=", "torch", ".", "cuda", ".", "IntTensor", "(", "b", ",", "m", ")", "\n", "temp", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "n", ")", ".", "fill_", "(", "1e10", ")", "\n", "pointops_cuda", ".", "furthestsampling_cuda", "(", "b", ",", "n", ",", "m", ",", "xyz", ",", "temp", ",", "idx", ")", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.FurthestSampling.backward": [[24, 27], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "xyz", ",", "a", "=", "None", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.Gathering.forward": [[32, 46], ["features.is_contiguous", "idx.is_contiguous", "features.size", "idx.size", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "pointops_cuda.gathering_forward_cuda"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "features", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        input: features: (b, c, n), idx : (b, m) tensor\n        output: (b, c, m)\n        \"\"\"", "\n", "assert", "features", ".", "is_contiguous", "(", ")", "\n", "assert", "idx", ".", "is_contiguous", "(", ")", "\n", "b", ",", "c", ",", "n", "=", "features", ".", "size", "(", ")", "\n", "m", "=", "idx", ".", "size", "(", "1", ")", "\n", "output", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "c", ",", "m", ")", "\n", "pointops_cuda", ".", "gathering_forward_cuda", "(", "b", ",", "c", ",", "n", ",", "m", ",", "features", ",", "idx", ",", "output", ")", "\n", "ctx", ".", "for_backwards", "=", "(", "idx", ",", "c", ",", "n", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.Gathering.backward": [[47, 55], ["idx.size", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "grad_out.data.contiguous", "pointops_cuda.gathering_backward_cuda", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_out", ")", ":", "\n", "        ", "idx", ",", "c", ",", "n", "=", "ctx", ".", "for_backwards", "\n", "b", ",", "m", "=", "idx", ".", "size", "(", ")", "\n", "grad_features", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "c", ",", "n", ")", ".", "zero_", "(", ")", "\n", "grad_out_data", "=", "grad_out", ".", "data", ".", "contiguous", "(", ")", "\n", "pointops_cuda", ".", "gathering_backward_cuda", "(", "b", ",", "c", ",", "n", ",", "m", ",", "grad_out_data", ",", "idx", ",", "grad_features", ".", "data", ")", "\n", "return", "grad_features", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.NearestNeighbor.forward": [[60, 76], ["unknown.is_contiguous", "known.is_contiguous", "unknown.size", "known.size", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "pointops_cuda.nearestneighbor_cuda", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "unknown", ":", "torch", ".", "Tensor", ",", "known", ":", "torch", ".", "Tensor", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Find the three nearest neighbors of unknown in known\n        input: unknown: (b, n, 3), known: (b, m, 3)\n        output: dist2: (b, n, 3) l2 distance to the three nearest neighbors\n                idx: (b, n, 3) index of 3 nearest neighbors\n        \"\"\"", "\n", "assert", "unknown", ".", "is_contiguous", "(", ")", "\n", "assert", "known", ".", "is_contiguous", "(", ")", "\n", "b", ",", "n", ",", "_", "=", "unknown", ".", "size", "(", ")", "\n", "m", "=", "known", ".", "size", "(", "1", ")", "\n", "dist2", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "n", ",", "3", ")", "\n", "idx", "=", "torch", ".", "cuda", ".", "IntTensor", "(", "b", ",", "n", ",", "3", ")", "\n", "pointops_cuda", ".", "nearestneighbor_cuda", "(", "b", ",", "n", ",", "m", ",", "unknown", ",", "known", ",", "dist2", ",", "idx", ")", "\n", "return", "torch", ".", "sqrt", "(", "dist2", ")", ",", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.NearestNeighbor.backward": [[77, 80], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "a", "=", "None", ",", "b", "=", "None", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.Interpolation.forward": [[85, 103], ["features.is_contiguous", "idx.is_contiguous", "weight.is_contiguous", "features.size", "idx.size", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "pointops_cuda.interpolation_forward_cuda"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "features", ":", "torch", ".", "Tensor", ",", "idx", ":", "torch", ".", "Tensor", ",", "weight", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Performs weight linear interpolation on 3 features\n        input: features: (b, c, m) features descriptors to be interpolated from\n               idx: (b, n, 3) three nearest neighbors of the target features in features\n               weight: (b, n, 3) weights\n        output: (b, c, n) tensor of the interpolated features\n        \"\"\"", "\n", "assert", "features", ".", "is_contiguous", "(", ")", "\n", "assert", "idx", ".", "is_contiguous", "(", ")", "\n", "assert", "weight", ".", "is_contiguous", "(", ")", "\n", "b", ",", "c", ",", "m", "=", "features", ".", "size", "(", ")", "\n", "n", "=", "idx", ".", "size", "(", "1", ")", "\n", "ctx", ".", "interpolation_for_backward", "=", "(", "idx", ",", "weight", ",", "m", ")", "\n", "output", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "c", ",", "n", ")", "\n", "pointops_cuda", ".", "interpolation_forward_cuda", "(", "b", ",", "c", ",", "m", ",", "n", ",", "features", ",", "idx", ",", "weight", ",", "output", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.Interpolation.backward": [[104, 116], ["grad_out.size", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "grad_out.data.contiguous", "pointops_cuda.interpolation_backward_cuda", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_out", ":", "torch", ".", "Tensor", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        input: grad_out: (b, c, n)\n        output: grad_features: (b, c, m), None, None\n        \"\"\"", "\n", "idx", ",", "weight", ",", "m", "=", "ctx", ".", "interpolation_for_backward", "\n", "b", ",", "c", ",", "n", "=", "grad_out", ".", "size", "(", ")", "\n", "grad_features", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "c", ",", "m", ")", ".", "zero_", "(", ")", "\n", "grad_out_data", "=", "grad_out", ".", "data", ".", "contiguous", "(", ")", "\n", "pointops_cuda", ".", "interpolation_backward_cuda", "(", "b", ",", "c", ",", "n", ",", "m", ",", "grad_out_data", ",", "idx", ",", "weight", ",", "grad_features", ".", "data", ")", "\n", "return", "grad_features", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.Grouping.forward": [[121, 135], ["features.is_contiguous", "idx.is_contiguous", "features.size", "idx.size", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "pointops_cuda.grouping_forward_cuda"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "features", ":", "torch", ".", "Tensor", ",", "idx", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        input: features: (b, c, n), idx : (b, m, nsample) containing the indicies of features to group with\n        output: (b, c, m, nsample)\n        \"\"\"", "\n", "assert", "features", ".", "is_contiguous", "(", ")", "\n", "assert", "idx", ".", "is_contiguous", "(", ")", "\n", "b", ",", "c", ",", "n", "=", "features", ".", "size", "(", ")", "\n", "_", ",", "m", ",", "nsample", "=", "idx", ".", "size", "(", ")", "\n", "output", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "c", ",", "m", ",", "nsample", ")", "\n", "pointops_cuda", ".", "grouping_forward_cuda", "(", "b", ",", "c", ",", "n", ",", "m", ",", "nsample", ",", "features", ",", "idx", ",", "output", ")", "\n", "ctx", ".", "for_backwards", "=", "(", "idx", ",", "n", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.Grouping.backward": [[136, 148], ["grad_out.size", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "grad_out.data.contiguous", "pointops_cuda.grouping_backward_cuda", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_out", ":", "torch", ".", "Tensor", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        input: grad_out: (b, c, m, nsample)\n        output: (b, c, n), None\n        \"\"\"", "\n", "idx", ",", "n", "=", "ctx", ".", "for_backwards", "\n", "b", ",", "c", ",", "m", ",", "nsample", "=", "grad_out", ".", "size", "(", ")", "\n", "grad_features", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "c", ",", "n", ")", ".", "zero_", "(", ")", "\n", "grad_out_data", "=", "grad_out", ".", "data", ".", "contiguous", "(", ")", "\n", "pointops_cuda", ".", "grouping_backward_cuda", "(", "b", ",", "c", ",", "n", ",", "m", ",", "nsample", ",", "grad_out_data", ",", "idx", ",", "grad_features", ".", "data", ")", "\n", "return", "grad_features", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.GroupingInt.forward": [[153, 166], ["features.is_contiguous", "idx.is_contiguous", "features.size", "idx.size", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "pointops_cuda.grouping_int_forward_cuda"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "features", ":", "torch", ".", "Tensor", ",", "idx", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        input: features: (b, c, n), idx : (b, m, nsample) containing the indicies of features to group with\n        output: (b, c, m, nsample)\n        \"\"\"", "\n", "assert", "features", ".", "is_contiguous", "(", ")", "\n", "assert", "idx", ".", "is_contiguous", "(", ")", "\n", "b", ",", "c", ",", "n", "=", "features", ".", "size", "(", ")", "\n", "_", ",", "m", ",", "nsample", "=", "idx", ".", "size", "(", ")", "\n", "output", "=", "torch", ".", "cuda", ".", "LongTensor", "(", "b", ",", "c", ",", "m", ",", "nsample", ")", "\n", "pointops_cuda", ".", "grouping_int_forward_cuda", "(", "b", ",", "c", ",", "n", ",", "m", ",", "nsample", ",", "features", ",", "idx", ",", "output", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.GroupingInt.backward": [[167, 170], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "a", "=", "None", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.BallQuery.forward": [[175, 191], ["xyz.is_contiguous", "new_xyz.is_contiguous", "xyz.size", "new_xyz.size", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "pointops_cuda.ballquery_cuda", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "radius", ":", "float", ",", "nsample", ":", "int", ",", "xyz", ":", "torch", ".", "Tensor", ",", "new_xyz", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        input: radius: float, radius of the balls\n               nsample: int, maximum number of features in the balls\n               xyz: torch.Tensor, (b, n, 3) xyz coordinates of the features\n               new_xyz: torch.Tensor, (b, m, 3) centers of the ball query\n        output: (b, m, nsample) tensor with the indicies of the features that form the query balls\n        \"\"\"", "\n", "assert", "xyz", ".", "is_contiguous", "(", ")", "\n", "assert", "new_xyz", ".", "is_contiguous", "(", ")", "\n", "b", ",", "n", ",", "_", "=", "xyz", ".", "size", "(", ")", "\n", "m", "=", "new_xyz", ".", "size", "(", "1", ")", "\n", "idx", "=", "torch", ".", "cuda", ".", "IntTensor", "(", "b", ",", "m", ",", "nsample", ")", ".", "zero_", "(", ")", "\n", "pointops_cuda", ".", "ballquery_cuda", "(", "b", ",", "n", ",", "m", ",", "radius", ",", "nsample", ",", "new_xyz", ",", "xyz", ",", "idx", ")", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.BallQuery.backward": [[192, 195], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "a", "=", "None", ")", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.FeatureDistribute.forward": [[200, 215], ["max_xyz.is_contiguous", "xyz.is_contiguous", "max_xyz.size", "xyz.size", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "pointops_cuda.featuredistribute_cuda", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "max_xyz", ":", "torch", ".", "Tensor", ",", "xyz", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        :param ctx:\n        :param max_xyz: (b, n, 3)\n        :param xyz: (b, m, 3)\n        :return: distribute_idx: (b, m)\n        \"\"\"", "\n", "assert", "max_xyz", ".", "is_contiguous", "(", ")", "\n", "assert", "xyz", ".", "is_contiguous", "(", ")", "\n", "b", ",", "n", ",", "_", "=", "max_xyz", ".", "size", "(", ")", "\n", "m", "=", "xyz", ".", "size", "(", "1", ")", "\n", "distribute_idx", "=", "torch", ".", "cuda", ".", "IntTensor", "(", "b", ",", "m", ")", ".", "zero_", "(", ")", "\n", "pointops_cuda", ".", "featuredistribute_cuda", "(", "b", ",", "n", ",", "m", ",", "max_xyz", ",", "xyz", ",", "distribute_idx", ")", "\n", "return", "distribute_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.FeatureDistribute.backward": [[216, 219], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "a", "=", "None", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.FeatureGather.forward": [[224, 240], ["max_feature.is_contiguous", "distribute_idx.is_contiguous", "max_feature.size", "distribute_idx.size", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "pointops_cuda.featuregather_forward_cuda", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "max_feature", ":", "torch", ".", "Tensor", ",", "distribute_idx", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "'''\n        :param ctx:\n        :param max_feature: (b, c, n)\n        :param distribute_idx: (b, m)\n        :return: distribute_feature: (b, c, m)\n        '''", "\n", "assert", "max_feature", ".", "is_contiguous", "(", ")", "\n", "assert", "distribute_idx", ".", "is_contiguous", "(", ")", "\n", "b", ",", "c", ",", "n", "=", "max_feature", ".", "size", "(", ")", "\n", "m", "=", "distribute_idx", ".", "size", "(", "1", ")", "\n", "distribute_feature", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "c", ",", "m", ")", ".", "zero_", "(", ")", "\n", "pointops_cuda", ".", "featuregather_forward_cuda", "(", "b", ",", "n", ",", "m", ",", "c", ",", "max_feature", ",", "distribute_idx", ",", "distribute_feature", ")", "\n", "ctx", ".", "for_backwards", "=", "(", "distribute_idx", ",", "n", ")", "\n", "return", "distribute_feature", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.FeatureGather.backward": [[241, 254], ["grad_distribute_feature.size", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "grad_distribute_feature.data.contiguous", "pointops_cuda.featuregather_backward_cuda", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_distribute_feature", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "'''\n        :param ctx:\n        :param grad_distribute_feature: (b, c, m)\n        :return: grad_max_feature: (b, c, n),    None\n        '''", "\n", "distribute_idx", ",", "n", "=", "ctx", ".", "for_backwards", "\n", "b", ",", "c", ",", "m", "=", "grad_distribute_feature", ".", "size", "(", ")", "\n", "grad_max_feature", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "c", ",", "n", ")", ".", "zero_", "(", ")", "\n", "grad_distribute_feature_data", "=", "grad_distribute_feature", ".", "data", ".", "contiguous", "(", ")", "\n", "pointops_cuda", ".", "featuregather_backward_cuda", "(", "b", ",", "n", ",", "m", ",", "c", ",", "grad_distribute_feature_data", ",", "distribute_idx", ",", "grad_max_feature", ".", "data", ")", "\n", "return", "grad_max_feature", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.LabelStatBallRange.forward": [[259, 279], ["xyz.is_contiguous", "new_xyz.is_contiguous", "label_stat.is_contiguous", "label_stat.size", "new_xyz.size", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "pointops_cuda.labelstat_ballrange_cuda", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "radius", ":", "float", ",", "xyz", ":", "torch", ".", "Tensor", ",", "new_xyz", ":", "torch", ".", "Tensor", ",", "label_stat", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "'''\n        :param ctx:\n        :param radius:\n        :param xyz: (b, n, 3)\n        :param new_xyz: (b, m, 3)\n        :param label_stat: (b, n, nclass)\n        :return: new_label_stat: (b, m, nclass)\n        '''", "\n", "assert", "xyz", ".", "is_contiguous", "(", ")", "\n", "assert", "new_xyz", ".", "is_contiguous", "(", ")", "\n", "assert", "label_stat", ".", "is_contiguous", "(", ")", "\n", "\n", "b", ",", "n", ",", "nclass", "=", "label_stat", ".", "size", "(", ")", "\n", "m", "=", "new_xyz", ".", "size", "(", "1", ")", "\n", "new_label_stat", "=", "torch", ".", "cuda", ".", "IntTensor", "(", "b", ",", "m", ",", "nclass", ")", ".", "zero_", "(", ")", "\n", "pointops_cuda", ".", "labelstat_ballrange_cuda", "(", "b", ",", "n", ",", "m", ",", "radius", ",", "nclass", ",", "new_xyz", ",", "xyz", ",", "label_stat", ",", "new_label_stat", ")", "\n", "\n", "return", "new_label_stat", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.LabelStatBallRange.backward": [[280, 283], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "a", "=", "None", ")", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.LabelStatIdx.forward": [[288, 306], ["label_stat.is_contiguous", "idx.is_contiguous", "label_stat.size", "idx.size", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "pointops_cuda.labelstat_idx_cuda", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "nsample", ":", "int", ",", "label_stat", ":", "torch", ".", "Tensor", ",", "idx", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "'''\n        :param ctx:\n        :param nsample:\n        :param label_stat: (b, n, nclass)\n        :param idx: (b, m, nsample)\n        :return: new_label_stat: (b, m, nclass)\n        '''", "\n", "assert", "label_stat", ".", "is_contiguous", "(", ")", "\n", "assert", "idx", ".", "is_contiguous", "(", ")", "\n", "\n", "b", ",", "n", ",", "nclass", "=", "label_stat", ".", "size", "(", ")", "\n", "m", "=", "idx", ".", "size", "(", "1", ")", "\n", "new_label_stat", "=", "torch", ".", "cuda", ".", "IntTensor", "(", "b", ",", "m", ",", "nclass", ")", ".", "zero_", "(", ")", "\n", "pointops_cuda", ".", "labelstat_idx_cuda", "(", "b", ",", "n", ",", "m", ",", "nsample", ",", "nclass", ",", "label_stat", ",", "idx", ",", "new_label_stat", ")", "\n", "\n", "return", "new_label_stat", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.LabelStatIdx.backward": [[307, 310], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "a", "=", "None", ")", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.LabelStatAndBallQuery.forward": [[315, 338], ["xyz.is_contiguous", "new_xyz.is_contiguous", "label_stat.is_contiguous", "label_stat.size", "new_xyz.size", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "pointops_cuda.labelstat_and_ballquery_cuda", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "radius", ":", "float", ",", "nsample", ":", "int", ",", "xyz", ":", "torch", ".", "Tensor", ",", "new_xyz", ":", "torch", ".", "Tensor", ",", "label_stat", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "'''\n        :param ctx:\n        :param radius:\n        :param nsample:\n        :param xyz: (b, n, 3)\n        :param new_xyz: (b, m, 3)\n        :param label_stat: (b, n, nclass)\n        :return: new_label_stat: (b, m, nclass)  idx: (b, m, nsample)\n        '''", "\n", "assert", "xyz", ".", "is_contiguous", "(", ")", "\n", "assert", "new_xyz", ".", "is_contiguous", "(", ")", "\n", "assert", "label_stat", ".", "is_contiguous", "(", ")", "\n", "\n", "b", ",", "n", ",", "nclass", "=", "label_stat", ".", "size", "(", ")", "\n", "m", "=", "new_xyz", ".", "size", "(", "1", ")", "\n", "new_label_stat", "=", "torch", ".", "cuda", ".", "IntTensor", "(", "b", ",", "m", ",", "nclass", ")", ".", "zero_", "(", ")", "\n", "idx", "=", "torch", ".", "cuda", ".", "IntTensor", "(", "b", ",", "m", ",", "nsample", ")", ".", "zero_", "(", ")", "\n", "\n", "pointops_cuda", ".", "labelstat_and_ballquery_cuda", "(", "b", ",", "n", ",", "m", ",", "radius", ",", "nsample", ",", "nclass", ",", "new_xyz", ",", "xyz", ",", "label_stat", ",", "idx", ",", "new_label_stat", ")", "\n", "\n", "return", "new_label_stat", ",", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.LabelStatAndBallQuery.backward": [[339, 342], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "a", "=", "None", ",", "b", "=", "None", ")", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.KNNQueryNaive.forward": [[367, 398], ["new_xyz.size", "xyz.size", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "idxs[].int", "new_xyz.repeat().view", "xyz.repeat().view", "new_xyz.repeat", "xyz.repeat"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "nsample", ":", "int", ",", "xyz", ":", "torch", ".", "Tensor", ",", "new_xyz", ":", "torch", ".", "Tensor", "=", "None", ")", "->", "Tuple", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        KNN Indexing\n        input: nsample: int32, Number of neighbor\n               xyz: (b, n, 3) coordinates of the features\n               new_xyz: (b, m, 3) centriods\n            output: idx: (b, m, nsample)\n        \"\"\"", "\n", "if", "new_xyz", "is", "None", ":", "\n", "            ", "new_xyz", "=", "xyz", "\n", "", "b", ",", "m", ",", "_", "=", "new_xyz", ".", "size", "(", ")", "\n", "n", "=", "xyz", ".", "size", "(", "1", ")", "\n", "\n", "'''\n        idx = torch.zeros(b, m, nsample).int().cuda()\n        for i in range(b):\n            dist = pairwise_distances(new_xyz[i, :, :], xyz[i, :, :])\n            [_, idxs] = torch.sort(dist, dim=1)\n            idx[i, :, :] = idxs[:, 0:nsample]\n        '''", "\n", "\n", "# '''", "\n", "# new_xyz_repeat = new_xyz.repeat(1, 1, n).view(b, m * n, 3)", "\n", "# xyz_repeat = xyz.repeat(1, m, 1).view(b, m * n, 3)", "\n", "# dist = (new_xyz_repeat - xyz_repeat).pow(2).sum(dim=2).view(b, m, n)", "\n", "dist", "=", "(", "new_xyz", ".", "repeat", "(", "1", ",", "1", ",", "n", ")", ".", "view", "(", "b", ",", "m", "*", "n", ",", "3", ")", "-", "xyz", ".", "repeat", "(", "1", ",", "m", ",", "1", ")", ".", "view", "(", "b", ",", "m", "*", "n", ",", "3", ")", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", "dim", "=", "2", ")", ".", "view", "(", "b", ",", "m", ",", "n", ")", "\n", "[", "_", ",", "idxs", "]", "=", "torch", ".", "sort", "(", "dist", ",", "dim", "=", "2", ")", "\n", "idx", "=", "idxs", "[", ":", ",", ":", ",", "0", ":", "nsample", "]", ".", "int", "(", ")", "\n", "# '''", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.KNNQueryNaive.backward": [[399, 402], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ")", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.KNNQuery.forward": [[407, 427], ["xyz.is_contiguous", "new_xyz.is_contiguous", "new_xyz.size", "xyz.size", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.IntTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "torch.cuda.FloatTensor().zero_", "pointops_cuda.knnquery_cuda", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.IntTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "nsample", ":", "int", ",", "xyz", ":", "torch", ".", "Tensor", ",", "new_xyz", ":", "torch", ".", "Tensor", "=", "None", ")", "->", "Tuple", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        KNN Indexing\n        input: nsample: int32, Number of neighbor\n               xyz: (b, n, 3) coordinates of the features\n               new_xyz: (b, m, 3) centriods\n            output: idx: (b, m, nsample)\n                   ( dist2: (b, m, nsample) )\n        \"\"\"", "\n", "if", "new_xyz", "is", "None", ":", "\n", "            ", "new_xyz", "=", "xyz", "\n", "", "assert", "xyz", ".", "is_contiguous", "(", ")", "\n", "assert", "new_xyz", ".", "is_contiguous", "(", ")", "\n", "b", ",", "m", ",", "_", "=", "new_xyz", ".", "size", "(", ")", "\n", "n", "=", "xyz", ".", "size", "(", "1", ")", "\n", "idx", "=", "torch", ".", "cuda", ".", "IntTensor", "(", "b", ",", "m", ",", "nsample", ")", ".", "zero_", "(", ")", "\n", "dist2", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "b", ",", "m", ",", "nsample", ")", ".", "zero_", "(", ")", "\n", "pointops_cuda", ".", "knnquery_cuda", "(", "b", ",", "n", ",", "m", ",", "nsample", ",", "xyz", ",", "new_xyz", ",", "idx", ",", "dist2", ")", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.KNNQuery.backward": [[428, 431], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "a", "=", "None", ")", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.KNNQueryExclude.forward": [[436, 467], ["new_xyz.size", "xyz.size", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "idxs[].int", "new_xyz.repeat().view", "xyz.repeat().view", "new_xyz.repeat", "xyz.repeat"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "nsample", ":", "int", ",", "xyz", ":", "torch", ".", "Tensor", ",", "new_xyz", ":", "torch", ".", "Tensor", "=", "None", ")", "->", "Tuple", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        KNN Indexing\n        input: nsample: int32, Number of neighbor\n               xyz: (b, n, 3) coordinates of the features\n               new_xyz: (b, m, 3) centriods\n            output: new_features: (b, m, nsample)\n        \"\"\"", "\n", "if", "new_xyz", "is", "None", ":", "\n", "            ", "new_xyz", "=", "xyz", "\n", "", "b", ",", "m", ",", "_", "=", "new_xyz", ".", "size", "(", ")", "\n", "n", "=", "xyz", ".", "size", "(", "1", ")", "\n", "\n", "'''\n        idx = torch.zeros(b, m, nsample).int().cuda()\n        for i in range(b):\n            dist = pairwise_distances(new_xyz[i, :, :], xyz[i, :, :])\n            [_, idxs] = torch.sort(dist, dim=1)\n            idx[i, :, :] = idxs[:, 0:nsample]\n        '''", "\n", "\n", "# '''", "\n", "# new_xyz_repeat = new_xyz.repeat(1, 1, n).view(b, m * n, 3)", "\n", "# xyz_repeat = xyz.repeat(1, m, 1).view(b, m * n, 3)", "\n", "# dist = (new_xyz_repeat - xyz_repeat).pow(2).sum(dim=2).view(b, m, n)", "\n", "dist", "=", "(", "new_xyz", ".", "repeat", "(", "1", ",", "1", ",", "n", ")", ".", "view", "(", "b", ",", "m", "*", "n", ",", "3", ")", "-", "xyz", ".", "repeat", "(", "1", ",", "m", ",", "1", ")", ".", "view", "(", "b", ",", "m", "*", "n", ",", "3", ")", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", "dim", "=", "2", ")", ".", "view", "(", "b", ",", "m", ",", "n", ")", "\n", "[", "_", ",", "idxs", "]", "=", "torch", ".", "sort", "(", "dist", ",", "dim", "=", "2", ")", "\n", "idx", "=", "idxs", "[", ":", ",", ":", ",", "1", ":", "nsample", "+", "1", "]", ".", "int", "(", ")", "\n", "# '''", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.KNNQueryExclude.backward": [[468, 471], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ")", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.QueryAndGroup.__init__": [[482, 485], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ",", "radius", "=", "None", ",", "nsample", "=", "32", ",", "use_xyz", "=", "True", ")", ":", "\n", "        ", "super", "(", "QueryAndGroup", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "radius", ",", "self", ".", "nsample", ",", "self", ".", "use_xyz", "=", "radius", ",", "nsample", ",", "use_xyz", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.QueryAndGroup.forward": [[486, 519], ["xyz.transpose().contiguous", "grouping", "new_xyz.transpose().unsqueeze", "grouping", "ballquery", "knnquery", "xyz.transpose", "new_xyz.transpose", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "xyz", ":", "torch", ".", "Tensor", ",", "new_xyz", ":", "torch", ".", "Tensor", "=", "None", ",", "features", ":", "torch", ".", "Tensor", "=", "None", ",", "idx", ":", "torch", ".", "Tensor", "=", "None", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        input: xyz: (b, n, 3) coordinates of the features\n               new_xyz: (b, m, 3) centriods\n               features: (b, c, n)\n               idx: idx of neighbors\n               # idxs: (b, n)\n        output: new_features: (b, c+3, m, nsample)\n              #  grouped_idxs: (b, m, nsample)\n        \"\"\"", "\n", "if", "new_xyz", "is", "None", ":", "\n", "            ", "new_xyz", "=", "xyz", "\n", "", "if", "idx", "is", "None", ":", "\n", "            ", "if", "self", ".", "radius", "is", "not", "None", ":", "\n", "                ", "idx", "=", "ballquery", "(", "self", ".", "radius", ",", "self", ".", "nsample", ",", "xyz", ",", "new_xyz", ")", "\n", "", "else", ":", "\n", "# idx = knnquery_naive(self.nsample, xyz, new_xyz)   # (b, m, nsample)", "\n", "                ", "idx", "=", "knnquery", "(", "self", ".", "nsample", ",", "xyz", ",", "new_xyz", ")", "# (b, m, nsample)", "\n", "", "", "xyz_trans", "=", "xyz", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "grouped_xyz", "=", "grouping", "(", "xyz_trans", ",", "idx", ")", "# (b, 3, m, nsample)", "\n", "# grouped_idxs = grouping(idxs.unsqueeze(1).float(), idx).squeeze(1).int()  # (b, m, nsample)", "\n", "\n", "grouped_xyz", "-=", "new_xyz", ".", "transpose", "(", "1", ",", "2", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "if", "features", "is", "not", "None", ":", "\n", "            ", "grouped_features", "=", "grouping", "(", "features", ",", "idx", ")", "\n", "if", "self", ".", "use_xyz", ":", "\n", "                ", "new_features", "=", "torch", ".", "cat", "(", "[", "grouped_xyz", ",", "grouped_features", "]", ",", "dim", "=", "1", ")", "# (b, c+3, m, nsample)", "\n", "", "else", ":", "\n", "                ", "new_features", "=", "grouped_features", "\n", "", "", "else", ":", "\n", "            ", "assert", "self", ".", "use_xyz", ",", "\"Cannot have not features and not use xyz as a feature!\"", "\n", "new_features", "=", "grouped_xyz", "\n", "", "return", "new_features", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.GroupAll.__init__": [[525, 528], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ",", "use_xyz", ":", "bool", "=", "True", ")", ":", "\n", "        ", "super", "(", "GroupAll", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "use_xyz", "=", "use_xyz", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.GroupAll.forward": [[529, 546], ["xyz.transpose().unsqueeze", "features.unsqueeze", "xyz.transpose", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "xyz", ":", "torch", ".", "Tensor", ",", "new_xyz", ":", "torch", ".", "Tensor", ",", "features", ":", "torch", ".", "Tensor", "=", "None", ")", "->", "Tuple", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        input: xyz: (b, n, 3) coordinates of the features\n               new_xyz: ignored torch\n               features: (b, c, n) descriptors of the features\n        output: new_features: (b, c+3, 1, N) tensor\n        \"\"\"", "\n", "grouped_xyz", "=", "xyz", ".", "transpose", "(", "1", ",", "2", ")", ".", "unsqueeze", "(", "2", ")", "\n", "if", "features", "is", "not", "None", ":", "\n", "            ", "grouped_features", "=", "features", ".", "unsqueeze", "(", "2", ")", "\n", "if", "self", ".", "use_xyz", ":", "\n", "                ", "new_features", "=", "torch", ".", "cat", "(", "[", "grouped_xyz", ",", "grouped_features", "]", ",", "dim", "=", "1", ")", "# (b, c+3, 1, n)", "\n", "", "else", ":", "\n", "                ", "new_features", "=", "grouped_features", "\n", "", "", "else", ":", "\n", "            ", "new_features", "=", "grouped_xyz", "\n", "", "return", "new_features", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functions.pointops.pairwise_distances": [[346, 364], ["torch.clamp", "torch.clamp", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "x_norm.view", "torch.mm", "torch.mm"], "function", ["None"], ["def", "pairwise_distances", "(", "x", ",", "y", "=", "None", ")", ":", "\n", "    ", "'''\n    Input: x is a Nxd matrix\n           y is an optional Mxd matirx\n    Output: dist is a NxM matrix where dist[i,j] is the square norm between x[i,:] and y[j,:]\n            if y is not given then use 'y=x'.\n    i.e. dist[i,j] = ||x[i,:]-y[j,:]||^2\n    '''", "\n", "x_norm", "=", "(", "x", "**", "2", ")", ".", "sum", "(", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "if", "y", "is", "not", "None", ":", "\n", "        ", "y_t", "=", "torch", ".", "transpose", "(", "y", ",", "0", ",", "1", ")", "\n", "y_norm", "=", "(", "y", "**", "2", ")", ".", "sum", "(", "1", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "y_t", "=", "torch", ".", "transpose", "(", "x", ",", "0", ",", "1", ")", "\n", "y_norm", "=", "x_norm", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "", "dist", "=", "x_norm", "+", "y_norm", "-", "2.0", "*", "torch", ".", "mm", "(", "x", ",", "y_t", ")", "\n", "import", "numpy", "as", "np", "\n", "return", "torch", ".", "clamp", "(", "dist", ",", "0.0", ",", "np", ".", "inf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.PCLosses.ChamferLoss.__init__": [[31, 34], ["torch.Module.__init__", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "ChamferLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "use_cuda", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.PCLosses.ChamferLoss.forward": [[35, 58], ["preds.permute().contiguous().view.permute().contiguous().view.size", "PCLosses.batch_pairwise_dist", "torch.min", "torch.min", "torch.min", "torch.min", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.min", "torch.min", "torch.min", "torch.min", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "idx.size", "preds.permute().contiguous().view.permute().contiguous().view.permute().contiguous", "gts.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous", "preds.permute().contiguous().view.permute().contiguous().view.permute().contiguous().view", "gts.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view", "preds.permute().contiguous().view.permute().contiguous().view.size", "preds.permute().contiguous().view.permute().contiguous().view.permute", "gts.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute", "preds.permute().contiguous().view.permute().contiguous().view.permute().contiguous", "gts.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous", "gts.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand", "preds.permute().contiguous().view.permute().contiguous().view.permute", "gts.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute", "gts.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view.unsqueeze", "gts.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand", "gts.unsqueeze().expand().permute().contiguous().view.unsqueeze().expand().permute().contiguous().view.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.PCLosses.batch_pairwise_dist"], ["", "def", "forward", "(", "self", ",", "preds", ",", "gts", ",", "idx", ")", ":", "\n", "# preds & gts of size (BS, 3, N)", "\n", "\n", "        ", "bs", ",", "points_dim", ",", "num_points_x", ",", "seeds", "=", "preds", ".", "size", "(", ")", "\n", "if", "idx", "is", "not", "None", ":", "\n", "            ", "num", "=", "idx", ".", "size", "(", "0", ")", "\n", "preds", "=", "preds", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", "[", "idx", "[", ":", ",", "0", "]", ",", "idx", "[", ":", ",", "1", "]", "]", "\n", "gts", "=", "gts", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "bs", ",", "points_dim", ",", "num_points_x", ",", "seeds", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", "[", "idx", "[", ":", ",", "0", "]", ",", "idx", "[", ":", ",", "1", "]", "]", "\n", "", "elif", "idx", "is", "None", ":", "\n", "            ", "preds", "=", "preds", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "bs", "*", "seeds", ",", "points_dim", ",", "num_points_x", ")", "\n", "gts", "=", "gts", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "bs", ",", "points_dim", ",", "num_points_x", ",", "seeds", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "bs", "*", "seeds", ",", "points_dim", ",", "num_points_x", ")", "\n", "num", "=", "preds", ".", "size", "(", "0", ")", "\n", "\n", "", "P", "=", "batch_pairwise_dist", "(", "preds", ",", "gts", ",", "self", ".", "use_cuda", ")", "\n", "# P of size (BS, 3, N)", "\n", "mins1", ",", "_", "=", "torch", ".", "min", "(", "P", ",", "1", ")", "\n", "# mins1=mins1.view(bs,-1,num_points_x)", "\n", "loss_1", "=", "torch", ".", "sum", "(", "mins1", ")", "# sum of all batches", "\n", "mins2", ",", "_", "=", "torch", ".", "min", "(", "P", ",", "2", ")", "\n", "# mins2 = mins2.view(bs, -1, num_points_x)", "\n", "loss_2", "=", "torch", ".", "sum", "(", "mins2", ")", "# sum of all batches", "\n", "\n", "return", "(", "loss_1", "+", "loss_2", ")", "/", "num", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.PCLosses.batch_pairwise_dist": [[6, 26], ["x.transpose.transpose", "y.transpose.transpose", "x.transpose.size", "y.transpose.size", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.arange().cuda", "torch.arange().cuda", "torch.arange().cuda", "torch.arange().cuda", "xx[].unsqueeze().expand_as", "yy[].unsqueeze().expand_as", "x.transpose.transpose", "y.transpose.transpose", "y.transpose.transpose", "torch.bmm.transpose", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "xx[].unsqueeze", "yy[].unsqueeze", "xx[].unsqueeze().expand_as.transpose"], "function", ["None"], ["def", "batch_pairwise_dist", "(", "x", ",", "y", ",", "use_cuda", "=", "True", ")", ":", "\n", "    ", "x", "=", "x", ".", "transpose", "(", "2", ",", "1", ")", "\n", "y", "=", "y", ".", "transpose", "(", "2", ",", "1", ")", "\n", "bs", ",", "num_points_x", ",", "points_dim", "=", "x", ".", "size", "(", ")", "\n", "_", ",", "num_points_y", ",", "_", "=", "y", ".", "size", "(", ")", "\n", "xx", "=", "torch", ".", "bmm", "(", "x", ",", "x", ".", "transpose", "(", "2", ",", "1", ")", ")", "\n", "yy", "=", "torch", ".", "bmm", "(", "y", ",", "y", ".", "transpose", "(", "2", ",", "1", ")", ")", "\n", "zz", "=", "torch", ".", "bmm", "(", "x", ",", "y", ".", "transpose", "(", "2", ",", "1", ")", ")", "\n", "if", "use_cuda", ":", "\n", "        ", "dtype", "=", "torch", ".", "cuda", ".", "LongTensor", "\n", "", "else", ":", "\n", "        ", "dtype", "=", "torch", ".", "LongTensor", "\n", "", "diag_ind_x", "=", "torch", ".", "arange", "(", "0", ",", "num_points_x", ")", ".", "cuda", "(", ")", "\n", "diag_ind_y", "=", "torch", ".", "arange", "(", "0", ",", "num_points_y", ")", ".", "cuda", "(", ")", "\n", "rx", "=", "xx", "[", ":", ",", "diag_ind_x", ",", "diag_ind_x", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "\n", "zz", ".", "transpose", "(", "2", ",", "1", ")", ")", "\n", "ry", "=", "yy", "[", ":", ",", "diag_ind_y", ",", "diag_ind_y", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "zz", ")", "\n", "# torch.cuda.empty_cache()", "\n", "P", "=", "(", "rx", ".", "transpose", "(", "2", ",", "1", ")", "+", "ry", "-", "2", "*", "zz", ")", "\n", "return", "P", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.PCLosses.acc_comp": [[61, 68], ["batch_pairwise_dist().abs().sqrt", "torch.min", "torch.min", "torch.min", "torch.min", "pred_mins.mean", "gts_mins.mean", "batch_pairwise_dist().abs", "PCLosses.batch_pairwise_dist"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.PCLosses.batch_pairwise_dist"], ["", "", "def", "acc_comp", "(", "preds", ",", "gts", ",", "rho", "=", "0.02", ")", ":", "\n", "    ", "P", "=", "batch_pairwise_dist", "(", "preds", ",", "gts", ")", ".", "abs", "(", ")", ".", "sqrt", "(", ")", "\n", "pred_mins", ",", "_", "=", "torch", ".", "min", "(", "P", ",", "2", ")", "\n", "gts_mins", ",", "_", "=", "torch", ".", "min", "(", "P", ",", "1", ")", "\n", "acc", "=", "pred_mins", ".", "mean", "(", "dim", "=", "1", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "comp", "=", "gts_mins", ".", "mean", "(", "dim", "=", "1", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "return", "acc", ",", "comp", "\n", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._sigmoid": [[8, 11], ["torch.clamp", "x.sigmoid_"], "function", ["None"], ["\n", "import", "matplotlib", ".", "font_manager", "\n", "from", "PIL", "import", "ImageFont", "\n", "import", "numpy", "as", "np", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._gather_feat": [[12, 21], ["feat.view.size", "ind.unsqueeze().expand.unsqueeze().expand", "feat.view.gather", "ind.unsqueeze().expand.size", "ind.unsqueeze().expand.size", "mask.unsqueeze().expand_as.unsqueeze().expand_as", "feat.view.view", "ind.unsqueeze().expand.unsqueeze", "mask.unsqueeze().expand_as.unsqueeze"], "function", ["None"], ["from", "pycocotools", "import", "mask", "as", "cocomask", "\n", "\n", "\n", "def", "annotation_name", "(", "attributes", ":", "List", "[", "dict", "]", ",", "\n", "category_name", ":", "str", ",", "\n", "with_attributes", ":", "bool", "=", "False", ")", "->", "str", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._tranpose_and_gather_feat": [[22, 27], ["_gather_feat.permute().contiguous", "_gather_feat.view", "utils._gather_feat", "_gather_feat.size", "_gather_feat.size", "_gather_feat.permute"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._gather_feat"], ["\n", "outstr", "=", "category_name", "\n", "\n", "if", "with_attributes", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.utils.flip_tensor": [[28, 30], ["torch.flip"], "function", ["None"], ["        ", "atts", "=", "[", "attribute", "[", "'name'", "]", "for", "attribute", "in", "attributes", "]", "\n", "if", "len", "(", "atts", ")", ">", "0", ":", "\n", "            ", "outstr", "=", "outstr", "+", "\"--\"", "+", "'.'", ".", "join", "(", "atts", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.utils.flip_lr": [[33, 40], ["[].copy", "torch.from_numpy().to", "tmp[].copy", "tmp[].copy", "torch.from_numpy", "x.detach().cpu().numpy", "[].copy.reshape", "x.detach().cpu", "x.detach"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["\n", "\n", "", "def", "mask_decode", "(", "mask", ":", "dict", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Decode the mask from base64 string to binary string, then feed it to the external pycocotools library to get a mask.\n    :param mask: The mask dictionary with fields `size` and `counts`.\n    :return: A numpy array representing the binary mask for this class.\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.utils.flip_lr_off": [[41, 51], ["[].copy", "tmp.reshape.reshape", "torch.from_numpy().to", "tmp[].copy", "tmp[].copy", "torch.from_numpy", "x.detach().cpu().numpy", "tmp.reshape.reshape", "x.detach().cpu", "x.detach"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy"], ["# Note that it is essential to copy the mask here. If we use the same variable we will overwrite the NuImage class", "\n", "# and cause the Jupyter Notebook to crash on some systems.", "\n", "new_mask", "=", "mask", ".", "copy", "(", ")", "\n", "new_mask", "[", "'counts'", "]", "=", "base64", ".", "b64decode", "(", "mask", "[", "'counts'", "]", ")", "\n", "return", "cocomask", ".", "decode", "(", "new_mask", ")", "\n", "\n", "\n", "", "def", "get_font", "(", "fonts_valid", ":", "List", "[", "str", "]", "=", "None", ",", "font_size", ":", "int", "=", "15", ")", "->", "ImageFont", ":", "\n", "    "]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.FocalLoss.__init__": [[137, 140], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", "FocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "neg_loss", "=", "_neg_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.FocalLoss.forward": [[141, 143], ["losses.FocalLoss.neg_loss"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "out", ",", "target", ")", ":", "\n", "    ", "return", "self", ".", "neg_loss", "(", "out", ",", "target", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.RegLoss.__init__": [[152, 154], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", "RegLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.RegLoss.forward": [[155, 159], ["utils.loss.utils._tranpose_and_gather_feat", "losses._reg_loss"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._tranpose_and_gather_feat", "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses._reg_loss"], ["", "def", "forward", "(", "self", ",", "output", ",", "ind", ",", "target", ")", ":", "\n", "    ", "pred", "=", "_tranpose_and_gather_feat", "(", "output", ",", "ind", ")", "\n", "loss", "=", "_reg_loss", "(", "pred", ",", "target", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.RegL1Loss.__init__": [[161, 163], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", "RegL1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.RegL1Loss.forward": [[164, 169], ["utils.loss.utils._tranpose_and_gather_feat", "torch.l1_loss", "torch.l1_loss", "torch.l1_loss"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._tranpose_and_gather_feat"], ["", "def", "forward", "(", "self", ",", "output", ",", "ind", ",", "target", ")", ":", "\n", "    ", "pred", "=", "_tranpose_and_gather_feat", "(", "output", ",", "ind", ")", "\n", "# loss = F.l1_loss(pred * mask, target * mask, reduction='elementwise_mean')", "\n", "loss", "=", "F", ".", "l1_loss", "(", "pred", ",", "target", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.NormRegL1Loss.__init__": [[171, 173], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", "NormRegL1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.NormRegL1Loss.forward": [[174, 183], ["utils.loss.utils._tranpose_and_gather_feat", "mask.unsqueeze().expand_as().float.unsqueeze().expand_as().float.unsqueeze().expand_as().float", "torch.l1_loss", "torch.l1_loss", "torch.l1_loss", "mask.unsqueeze().expand_as().float.unsqueeze().expand_as().float.unsqueeze().expand_as", "mask.unsqueeze().expand_as().float.unsqueeze().expand_as().float.sum", "mask.unsqueeze().expand_as().float.unsqueeze().expand_as().float.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._tranpose_and_gather_feat"], ["", "def", "forward", "(", "self", ",", "output", ",", "mask", ",", "ind", ",", "target", ")", ":", "\n", "    ", "pred", "=", "_tranpose_and_gather_feat", "(", "output", ",", "ind", ")", "\n", "mask", "=", "mask", ".", "unsqueeze", "(", "2", ")", ".", "expand_as", "(", "pred", ")", ".", "float", "(", ")", "\n", "# loss = F.l1_loss(pred * mask, target * mask, reduction='elementwise_mean')", "\n", "pred", "=", "pred", "/", "(", "target", "+", "1e-4", ")", "\n", "target", "=", "target", "*", "0", "+", "1", "\n", "loss", "=", "F", ".", "l1_loss", "(", "pred", "*", "mask", ",", "target", "*", "mask", ",", "size_average", "=", "False", ")", "\n", "loss", "=", "loss", "/", "(", "mask", ".", "sum", "(", ")", "+", "1e-4", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.RegWeightedL1Loss.__init__": [[185, 187], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", "RegWeightedL1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.RegWeightedL1Loss.forward": [[188, 195], ["utils.loss.utils._tranpose_and_gather_feat", "mask.float.float.float", "torch.l1_loss", "torch.l1_loss", "torch.l1_loss", "mask.float.float.sum"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._tranpose_and_gather_feat"], ["", "def", "forward", "(", "self", ",", "output", ",", "mask", ",", "ind", ",", "target", ")", ":", "\n", "    ", "pred", "=", "_tranpose_and_gather_feat", "(", "output", ",", "ind", ")", "\n", "mask", "=", "mask", ".", "float", "(", ")", "\n", "# loss = F.l1_loss(pred * mask, target * mask, reduction='elementwise_mean')", "\n", "loss", "=", "F", ".", "l1_loss", "(", "pred", "*", "mask", ",", "target", "*", "mask", ",", "size_average", "=", "False", ")", "\n", "loss", "=", "loss", "/", "(", "mask", ".", "sum", "(", ")", "+", "1e-4", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.L1Loss.__init__": [[197, 199], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", "L1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.L1Loss.forward": [[200, 205], ["utils.loss.utils._tranpose_and_gather_feat", "mask.unsqueeze().expand_as().float.unsqueeze().expand_as().float.unsqueeze().expand_as().float", "torch.l1_loss", "torch.l1_loss", "torch.l1_loss", "mask.unsqueeze().expand_as().float.unsqueeze().expand_as().float.unsqueeze().expand_as", "mask.unsqueeze().expand_as().float.unsqueeze().expand_as().float.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._tranpose_and_gather_feat"], ["", "def", "forward", "(", "self", ",", "output", ",", "mask", ",", "ind", ",", "target", ")", ":", "\n", "    ", "pred", "=", "_tranpose_and_gather_feat", "(", "output", ",", "ind", ")", "\n", "mask", "=", "mask", ".", "unsqueeze", "(", "2", ")", ".", "expand_as", "(", "pred", ")", ".", "float", "(", ")", "\n", "loss", "=", "F", ".", "l1_loss", "(", "pred", "*", "mask", ",", "target", "*", "mask", ",", "reduction", "=", "'elementwise_mean'", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.BinRotLoss.__init__": [[207, 209], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", "BinRotLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.BinRotLoss.forward": [[210, 214], ["utils.loss.utils._tranpose_and_gather_feat", "losses.compute_rot_loss"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._tranpose_and_gather_feat", "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_rot_loss"], ["", "def", "forward", "(", "self", ",", "output", ",", "mask", ",", "ind", ",", "rotbin", ",", "rotres", ")", ":", "\n", "    ", "pred", "=", "_tranpose_and_gather_feat", "(", "output", ",", "ind", ")", "\n", "loss", "=", "compute_rot_loss", "(", "pred", ",", "rotbin", ",", "rotres", ",", "mask", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.TripletLoss.__init__": [[268, 273], ["torch.Module.__init__", "torch.MarginRankingLoss", "torch.MarginRankingLoss", "torch.MarginRankingLoss"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ",", "margin", "=", "0.3", ",", "mutual_flag", "=", "False", ")", ":", "\n", "        ", "super", "(", "TripletLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "margin", "=", "margin", "\n", "self", ".", "ranking_loss", "=", "nn", ".", "MarginRankingLoss", "(", "margin", "=", "margin", ")", "\n", "self", ".", "mutual", "=", "mutual_flag", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.TripletLoss.forward": [[274, 301], ["inputs.size", "torch.pow().sum().expand", "torch.pow().sum().expand", "torch.pow().sum().expand", "torch.pow().sum().expand", "torch.pow().sum().expand", "torch.pow().sum().expand", "torch.pow().sum().expand", "torch.pow().sum().expand", "torch.pow().sum().expand", "dist.clamp().sqrt.clamp().sqrt.addmm_", "dist.clamp().sqrt.clamp().sqrt.clamp().sqrt", "targets.expand().eq", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "losses.TripletLoss.ranking_loss", "dist.clamp().sqrt.clamp().sqrt.t", "inputs.t", "targets.expand().t", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "dist.clamp().sqrt.clamp().sqrt.clamp", "targets.expand", "[].max().unsqueeze", "[].min().unsqueeze", "targets.expand", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "[].max", "[].min"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: feature matrix with shape (batch_size, feat_dim)\n            targets: ground truth labels with shape (num_classes)\n        \"\"\"", "\n", "n", "=", "inputs", ".", "size", "(", "0", ")", "\n", "# inputs = 1. * inputs / (torch.norm(inputs, 2, dim=-1, keepdim=True).expand_as(inputs) + 1e-12)", "\n", "# Compute pairwise distance, replace by the official when merged", "\n", "dist", "=", "torch", ".", "pow", "(", "inputs", ",", "2", ")", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ".", "expand", "(", "n", ",", "n", ")", "\n", "dist", "=", "dist", "+", "dist", ".", "t", "(", ")", "\n", "dist", ".", "addmm_", "(", "1", ",", "-", "2", ",", "inputs", ",", "inputs", ".", "t", "(", ")", ")", "\n", "dist", "=", "dist", ".", "clamp", "(", "min", "=", "1e-12", ")", ".", "sqrt", "(", ")", "# for numerical stability", "\n", "# For each anchor, find the hardest positive and negative", "\n", "mask", "=", "targets", ".", "expand", "(", "n", ",", "n", ")", ".", "eq", "(", "targets", ".", "expand", "(", "n", ",", "n", ")", ".", "t", "(", ")", ")", "\n", "dist_ap", ",", "dist_an", "=", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "dist_ap", ".", "append", "(", "dist", "[", "i", "]", "[", "mask", "[", "i", "]", "]", ".", "max", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "dist_an", ".", "append", "(", "dist", "[", "i", "]", "[", "mask", "[", "i", "]", "==", "0", "]", ".", "min", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "", "dist_ap", "=", "torch", ".", "cat", "(", "dist_ap", ")", "\n", "dist_an", "=", "torch", ".", "cat", "(", "dist_an", ")", "\n", "# Compute ranking hinge loss", "\n", "y", "=", "torch", ".", "ones_like", "(", "dist_an", ")", "\n", "loss", "=", "self", ".", "ranking_loss", "(", "dist_an", ",", "dist_ap", ",", "y", ")", "\n", "if", "self", ".", "mutual", ":", "\n", "            ", "return", "loss", ",", "dist", "\n", "", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses._slow_neg_loss": [[17, 40], ["gt.eq", "gt.lt", "torch.pow", "torch.pow", "torch.pow", "gt.eq.float().sum", "pos_loss.sum.sum", "neg_loss.sum.sum", "torch.log", "torch.log", "torch.log", "torch.pow", "torch.pow", "torch.pow", "pos_pred.nelement", "torch.log", "torch.log", "torch.log", "torch.pow", "torch.pow", "torch.pow", "gt.eq.float"], "function", ["None"], ["def", "_slow_neg_loss", "(", "pred", ",", "gt", ")", ":", "\n", "  ", "'''focal loss from CornerNet'''", "\n", "pos_inds", "=", "gt", ".", "eq", "(", "1", ")", "\n", "neg_inds", "=", "gt", ".", "lt", "(", "1", ")", "\n", "\n", "neg_weights", "=", "torch", ".", "pow", "(", "1", "-", "gt", "[", "neg_inds", "]", ",", "4", ")", "\n", "\n", "loss", "=", "0", "\n", "pos_pred", "=", "pred", "[", "pos_inds", "]", "\n", "neg_pred", "=", "pred", "[", "neg_inds", "]", "\n", "\n", "pos_loss", "=", "torch", ".", "log", "(", "pos_pred", ")", "*", "torch", ".", "pow", "(", "1", "-", "pos_pred", ",", "2", ")", "\n", "neg_loss", "=", "torch", ".", "log", "(", "1", "-", "neg_pred", ")", "*", "torch", ".", "pow", "(", "neg_pred", ",", "2", ")", "*", "neg_weights", "\n", "\n", "num_pos", "=", "pos_inds", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "pos_loss", "=", "pos_loss", ".", "sum", "(", ")", "\n", "neg_loss", "=", "neg_loss", ".", "sum", "(", ")", "\n", "\n", "if", "pos_pred", ".", "nelement", "(", ")", "==", "0", ":", "\n", "    ", "loss", "=", "loss", "-", "neg_loss", "\n", "", "else", ":", "\n", "    ", "loss", "=", "loss", "-", "(", "pos_loss", "+", "neg_loss", ")", "/", "num_pos", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses._neg_loss": [[42, 68], ["gt.eq().float", "gt.lt().float", "torch.pow", "torch.pow", "torch.pow", "gt.eq().float.float().sum", "pos_loss.sum.sum", "neg_loss.sum.sum", "gt.eq", "gt.lt", "torch.log", "torch.log", "torch.log", "torch.pow", "torch.pow", "torch.pow", "gt.eq().float.float", "torch.log", "torch.log", "torch.log", "torch.pow", "torch.pow", "torch.pow"], "function", ["None"], ["", "def", "_neg_loss", "(", "pred", ",", "gt", ")", ":", "\n", "  ", "''' Modified focal loss. Exactly the same as CornerNet.\n      Runs faster and costs a little bit more memory\n    Arguments:\n      pred (batch x c x h x w)\n      gt_regr (batch x c x h x w)\n  '''", "\n", "pos_inds", "=", "gt", ".", "eq", "(", "1", ")", ".", "float", "(", ")", "\n", "neg_inds", "=", "gt", ".", "lt", "(", "1", ")", ".", "float", "(", ")", "\n", "\n", "neg_weights", "=", "torch", ".", "pow", "(", "1", "-", "gt", ",", "4", ")", "\n", "\n", "loss", "=", "0", "\n", "\n", "pos_loss", "=", "torch", ".", "log", "(", "pred", ")", "*", "torch", ".", "pow", "(", "1", "-", "pred", ",", "2", ")", "*", "pos_inds", "\n", "neg_loss", "=", "torch", ".", "log", "(", "1", "-", "pred", ")", "*", "torch", ".", "pow", "(", "pred", ",", "2", ")", "*", "neg_weights", "*", "neg_inds", "\n", "\n", "num_pos", "=", "pos_inds", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "pos_loss", "=", "pos_loss", ".", "sum", "(", ")", "\n", "neg_loss", "=", "neg_loss", ".", "sum", "(", ")", "\n", "\n", "if", "num_pos", "==", "0", ":", "\n", "    ", "loss", "=", "loss", "-", "neg_loss", "\n", "", "else", ":", "\n", "    ", "loss", "=", "loss", "-", "(", "pos_loss", "+", "neg_loss", ")", "/", "num_pos", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses._top_smooth_loss": [[69, 96], ["objectness_label.float().sum", "objectness_mask.float().sum", "pos_loss.sum.sum", "neg_loss.sum.sum", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "objectness_label.float", "objectness_mask.float"], "function", ["None"], ["", "def", "_top_smooth_loss", "(", "pred", ",", "gt", ",", "gate", ",", "objectness_mask", ",", "objectness_label", ")", ":", "\n", "  ", "''' Modified focal loss. Exactly the same as CornerNet.\n      Runs faster and costs a little bit more memory\n    Arguments:\n      pred (batch x N)\n      gt_regr (batch x N)\n  '''", "\n", "# pos_inds = gt.ge(gate).float()", "\n", "# neg_inds = gt.lt(gate).float()", "\n", "\n", "\n", "loss", "=", "0", "\n", "\n", "# pos_loss = 2.0*torch.log(pred) * gt * objectness_label", "\n", "pos_loss", "=", "2.0", "*", "torch", ".", "log", "(", "pred", ")", "*", "objectness_label", "\n", "neg_loss", "=", "torch", ".", "log", "(", "1", "-", "pred", ")", "*", "objectness_mask", "\n", "\n", "num_pos", "=", "objectness_label", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "num_neg", "=", "objectness_mask", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "pos_loss", "=", "pos_loss", ".", "sum", "(", ")", "\n", "neg_loss", "=", "neg_loss", ".", "sum", "(", ")", "\n", "\n", "if", "num_pos", "==", "0", ":", "\n", "    ", "loss", "=", "loss", "-", "neg_loss", "/", "(", "num_neg", "+", "1e-6", ")", "\n", "", "else", ":", "\n", "    ", "loss", "=", "loss", "-", "(", "pos_loss", "+", "neg_loss", ")", "/", "(", "num_neg", "+", "num_pos", "+", "1e-6", ")", "\n", "", "return", "loss", ",", "num_pos", ",", "num_neg", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses._not_faster_neg_loss": [[97, 113], ["gt.eq().float", "gt.lt().float", "gt.eq().float.float().sum", "torch.pow", "torch.pow", "torch.pow", "all_loss.sum.sum", "gt.eq", "gt.lt", "gt.eq().float.float", "torch.log", "torch.log", "torch.log", "torch.pow", "torch.pow", "torch.pow"], "function", ["None"], ["", "def", "_not_faster_neg_loss", "(", "pred", ",", "gt", ")", ":", "\n", "    ", "pos_inds", "=", "gt", ".", "eq", "(", "1", ")", ".", "float", "(", ")", "\n", "neg_inds", "=", "gt", ".", "lt", "(", "1", ")", ".", "float", "(", ")", "\n", "num_pos", "=", "pos_inds", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "neg_weights", "=", "torch", ".", "pow", "(", "1", "-", "gt", ",", "4", ")", "\n", "\n", "loss", "=", "0", "\n", "trans_pred", "=", "pred", "*", "neg_inds", "+", "(", "1", "-", "pred", ")", "*", "pos_inds", "\n", "weight", "=", "neg_weights", "*", "neg_inds", "+", "pos_inds", "\n", "all_loss", "=", "torch", ".", "log", "(", "1", "-", "trans_pred", ")", "*", "torch", ".", "pow", "(", "trans_pred", ",", "2", ")", "*", "weight", "\n", "all_loss", "=", "all_loss", ".", "sum", "(", ")", "\n", "\n", "if", "num_pos", ">", "0", ":", "\n", "        ", "all_loss", "/=", "num_pos", "\n", "", "loss", "-=", "all_loss", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses._slow_reg_loss": [[114, 124], ["mask.unsqueeze().expand_as.float().sum", "mask.unsqueeze().expand_as.unsqueeze().expand_as", "torch.functional.smooth_l1_loss", "mask.unsqueeze().expand_as.float", "mask.unsqueeze().expand_as.unsqueeze"], "function", ["None"], ["", "def", "_slow_reg_loss", "(", "regr", ",", "gt_regr", ",", "mask", ")", ":", "\n", "    ", "num", "=", "mask", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "mask", "=", "mask", ".", "unsqueeze", "(", "2", ")", ".", "expand_as", "(", "gt_regr", ")", "\n", "\n", "regr", "=", "regr", "[", "mask", "]", "\n", "gt_regr", "=", "gt_regr", "[", "mask", "]", "\n", "\n", "regr_loss", "=", "nn", ".", "functional", ".", "smooth_l1_loss", "(", "regr", ",", "gt_regr", ",", "size_average", "=", "False", ")", "\n", "regr_loss", "=", "regr_loss", "/", "(", "num", "+", "1e-4", ")", "\n", "return", "regr_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses._reg_loss": [[125, 134], ["torch.functional.smooth_l1_loss"], "function", ["None"], ["", "def", "_reg_loss", "(", "regr", ",", "gt_regr", ")", ":", "\n", "  ", "''' L1 regression loss\n    Arguments:\n      regr (batch x max_objects x dim)\n      gt_regr (batch x max_objects x dim)\n      mask (batch x max_objects)\n  '''", "\n", "regr_loss", "=", "nn", ".", "functional", ".", "smooth_l1_loss", "(", "regr", ",", "gt_regr", ")", "\n", "return", "regr_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_res_loss": [[215, 217], ["torch.smooth_l1_loss"], "function", ["None"], ["", "", "def", "compute_res_loss", "(", "output", ",", "target", ")", ":", "\n", "    ", "return", "F", ".", "smooth_l1_loss", "(", "output", ",", "target", ",", "reduction", "=", "'elementwise_mean'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_bin_loss": [[219, 223], ["mask.expand_as.expand_as", "torch.cross_entropy", "mask.expand_as.float"], "function", ["None"], ["", "def", "compute_bin_loss", "(", "output", ",", "target", ",", "mask", ")", ":", "\n", "    ", "mask", "=", "mask", ".", "expand_as", "(", "output", ")", "\n", "output", "=", "output", "*", "mask", ".", "float", "(", ")", "\n", "return", "F", ".", "cross_entropy", "(", "output", ",", "target", ",", "reduction", "=", "'elementwise_mean'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_rot_loss": [[224, 257], ["output.view.view", "target_bin.view.view", "target_res.view.view", "mask.view.view", "losses.compute_bin_loss", "losses.compute_bin_loss", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "losses.compute_res_loss", "losses.compute_res_loss", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "losses.compute_res_loss", "losses.compute_res_loss", "target_bin[].nonzero", "idx1.long", "idx1.long", "torch.sin", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.cos", "target_bin[].nonzero", "idx2.long", "idx2.long", "torch.sin", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.cos", "target_bin[].nonzero", "target_bin[].nonzero"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_bin_loss", "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_bin_loss", "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_res_loss", "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_res_loss", "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_res_loss", "home.repos.pwc.inspect_result.fpthink_v2b.loss.losses.compute_res_loss"], ["", "def", "compute_rot_loss", "(", "output", ",", "target_bin", ",", "target_res", ",", "mask", ")", ":", "\n", "# output: (B, 128, 8) [bin1_cls[0], bin1_cls[1], bin1_sin, bin1_cos, ", "\n", "#                 bin2_cls[0], bin2_cls[1], bin2_sin, bin2_cos]", "\n", "# target_bin: (B, 128, 2) [bin1_cls, bin2_cls]", "\n", "# target_res: (B, 128, 2) [bin1_res, bin2_res]", "\n", "# mask: (B, 128, 1)", "\n", "# import pdb; pdb.set_trace()", "\n", "    ", "output", "=", "output", ".", "view", "(", "-", "1", ",", "8", ")", "\n", "target_bin", "=", "target_bin", ".", "view", "(", "-", "1", ",", "2", ")", "\n", "target_res", "=", "target_res", ".", "view", "(", "-", "1", ",", "2", ")", "\n", "mask", "=", "mask", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "loss_bin1", "=", "compute_bin_loss", "(", "output", "[", ":", ",", "0", ":", "2", "]", ",", "target_bin", "[", ":", ",", "0", "]", ",", "mask", ")", "\n", "loss_bin2", "=", "compute_bin_loss", "(", "output", "[", ":", ",", "4", ":", "6", "]", ",", "target_bin", "[", ":", ",", "1", "]", ",", "mask", ")", "\n", "loss_res", "=", "torch", ".", "zeros_like", "(", "loss_bin1", ")", "\n", "if", "target_bin", "[", ":", ",", "0", "]", ".", "nonzero", "(", ")", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "        ", "idx1", "=", "target_bin", "[", ":", ",", "0", "]", ".", "nonzero", "(", ")", "[", ":", ",", "0", "]", "\n", "valid_output1", "=", "torch", ".", "index_select", "(", "output", ",", "0", ",", "idx1", ".", "long", "(", ")", ")", "\n", "valid_target_res1", "=", "torch", ".", "index_select", "(", "target_res", ",", "0", ",", "idx1", ".", "long", "(", ")", ")", "\n", "loss_sin1", "=", "compute_res_loss", "(", "\n", "valid_output1", "[", ":", ",", "2", "]", ",", "torch", ".", "sin", "(", "valid_target_res1", "[", ":", ",", "0", "]", ")", ")", "\n", "loss_cos1", "=", "compute_res_loss", "(", "\n", "valid_output1", "[", ":", ",", "3", "]", ",", "torch", ".", "cos", "(", "valid_target_res1", "[", ":", ",", "0", "]", ")", ")", "\n", "loss_res", "+=", "loss_sin1", "+", "loss_cos1", "\n", "", "if", "target_bin", "[", ":", ",", "1", "]", ".", "nonzero", "(", ")", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "        ", "idx2", "=", "target_bin", "[", ":", ",", "1", "]", ".", "nonzero", "(", ")", "[", ":", ",", "0", "]", "\n", "valid_output2", "=", "torch", ".", "index_select", "(", "output", ",", "0", ",", "idx2", ".", "long", "(", ")", ")", "\n", "valid_target_res2", "=", "torch", ".", "index_select", "(", "target_res", ",", "0", ",", "idx2", ".", "long", "(", ")", ")", "\n", "loss_sin2", "=", "compute_res_loss", "(", "\n", "valid_output2", "[", ":", ",", "6", "]", ",", "torch", ".", "sin", "(", "valid_target_res2", "[", ":", ",", "1", "]", ")", ")", "\n", "loss_cos2", "=", "compute_res_loss", "(", "\n", "valid_output2", "[", ":", ",", "7", "]", ",", "torch", ".", "cos", "(", "valid_target_res2", "[", ":", ",", "1", "]", ")", ")", "\n", "loss_res", "+=", "loss_sin2", "+", "loss_cos2", "\n", "", "return", "loss_bin1", "+", "loss_bin2", "+", "loss_res", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.LineMesh.__init__": [[40, 59], ["numpy.array", "numpy.array", "LineMesh.LineMesh.create_line_mesh", "numpy.array", "LineMesh.LineMesh.lines_from_ordered_points"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.LineMesh.create_line_mesh", "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.LineMesh.lines_from_ordered_points"], ["    ", "def", "__init__", "(", "self", ",", "points", ",", "lines", "=", "None", ",", "colors", "=", "[", "0", ",", "1", ",", "0", "]", ",", "radius", "=", "0.15", ")", ":", "\n", "        ", "\"\"\"Creates a line represented as sequence of cylinder triangular meshes\n\n        Arguments:\n            points {ndarray} -- Numpy array of ponts Nx3.\n\n        Keyword Arguments:\n            lines {list[list] or None} -- List of point index pairs denoting line segments. If None, implicit lines from ordered pairwise points. (default: {None})\n            colors {list} -- list of colors, or single color of the line (default: {[0, 1, 0]})\n            radius {float} -- radius of cylinder (default: {0.15})\n        \"\"\"", "\n", "self", ".", "points", "=", "np", ".", "array", "(", "points", ")", "\n", "self", ".", "lines", "=", "np", ".", "array", "(", "\n", "lines", ")", "if", "lines", "is", "not", "None", "else", "self", ".", "lines_from_ordered_points", "(", "self", ".", "points", ")", "\n", "self", ".", "colors", "=", "np", ".", "array", "(", "colors", ")", "\n", "self", ".", "radius", "=", "radius", "\n", "self", ".", "cylinder_segments", "=", "[", "]", "\n", "\n", "self", ".", "create_line_mesh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.LineMesh.lines_from_ordered_points": [[60, 64], ["numpy.array", "range"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "lines_from_ordered_points", "(", "points", ")", ":", "\n", "        ", "lines", "=", "[", "[", "i", ",", "i", "+", "1", "]", "for", "i", "in", "range", "(", "0", ",", "points", ".", "shape", "[", "0", "]", "-", "1", ",", "1", ")", "]", "\n", "return", "np", ".", "array", "(", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.LineMesh.create_line_mesh": [[65, 96], ["LineMesh.normalized", "numpy.array", "range", "LineMesh.align_vector_to_another", "open3d.geometry.TriangleMesh.create_cylinder", "cylinder_segment.rotate.rotate.translate", "cylinder_segment.rotate.rotate.paint_uniform_color", "LineMesh.LineMesh.cylinder_segments.append", "cylinder_segment.rotate.rotate.rotate", "open3d.geometry.get_rotation_matrix_from_axis_angle", "cylinder_segment.rotate.rotate.get_center"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.normalized", "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.align_vector_to_another", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.translate", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.rotate"], ["", "def", "create_line_mesh", "(", "self", ")", ":", "\n", "        ", "first_points", "=", "self", ".", "points", "[", "self", ".", "lines", "[", ":", ",", "0", "]", ",", ":", "]", "\n", "second_points", "=", "self", ".", "points", "[", "self", ".", "lines", "[", ":", ",", "1", "]", ",", ":", "]", "\n", "line_segments", "=", "second_points", "-", "first_points", "\n", "line_segments_unit", ",", "line_lengths", "=", "normalized", "(", "line_segments", ")", "\n", "\n", "z_axis", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", "\n", "# Create triangular mesh cylinder segments of line", "\n", "for", "i", "in", "range", "(", "line_segments_unit", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "line_segment", "=", "line_segments_unit", "[", "i", ",", ":", "]", "\n", "line_length", "=", "line_lengths", "[", "i", "]", "\n", "# get axis angle rotation to allign cylinder with line segment", "\n", "axis", ",", "angle", "=", "align_vector_to_another", "(", "z_axis", ",", "line_segment", ")", "\n", "# Get translation vector", "\n", "translation", "=", "first_points", "[", "i", ",", ":", "]", "+", "line_segment", "*", "line_length", "*", "0.5", "\n", "# create cylinder and apply transformations", "\n", "cylinder_segment", "=", "o3d", ".", "geometry", ".", "TriangleMesh", ".", "create_cylinder", "(", "\n", "self", ".", "radius", ",", "line_length", ")", "\n", "cylinder_segment", "=", "cylinder_segment", ".", "translate", "(", "\n", "translation", ",", "relative", "=", "False", ")", "\n", "if", "axis", "is", "not", "None", ":", "\n", "                ", "axis_a", "=", "axis", "*", "angle", "\n", "cylinder_segment", "=", "cylinder_segment", ".", "rotate", "(", "\n", "R", "=", "o3d", ".", "geometry", ".", "get_rotation_matrix_from_axis_angle", "(", "axis_a", ")", ",", "\n", "center", "=", "cylinder_segment", ".", "get_center", "(", ")", ")", "\n", "\n", "# color cylinder", "\n", "", "color", "=", "self", ".", "colors", "if", "self", ".", "colors", ".", "ndim", "==", "1", "else", "self", ".", "colors", "[", "i", ",", ":", "]", "\n", "cylinder_segment", ".", "paint_uniform_color", "(", "color", ")", "\n", "\n", "self", ".", "cylinder_segments", ".", "append", "(", "cylinder_segment", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.LineMesh.add_line": [[97, 101], ["vis.add_geometry"], "methods", ["None"], ["", "", "def", "add_line", "(", "self", ",", "vis", ")", ":", "\n", "        ", "\"\"\"Adds this line to the visualizer\"\"\"", "\n", "for", "cylinder", "in", "self", ".", "cylinder_segments", ":", "\n", "            ", "vis", ".", "add_geometry", "(", "cylinder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.LineMesh.remove_line": [[102, 106], ["vis.remove_geometry"], "methods", ["None"], ["", "", "def", "remove_line", "(", "self", ",", "vis", ")", ":", "\n", "        ", "\"\"\"Removes this line from the visualizer\"\"\"", "\n", "for", "cylinder", "in", "self", ".", "cylinder_segments", ":", "\n", "            ", "vis", ".", "remove_geometry", "(", "cylinder", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.align_vector_to_another": [[17, 30], ["numpy.array", "numpy.array", "numpy.cross", "numpy.arccos", "numpy.array_equal", "numpy.array_equal", "numpy.linalg.norm", "numpy.dot"], "function", ["None"], ["def", "align_vector_to_another", "(", "a", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", ",", "b", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", ")", ":", "\n", "    ", "\"\"\"\n    Aligns vector a to vector b with axis angle rotation\n    \"\"\"", "\n", "if", "np", ".", "array_equal", "(", "a", ",", "b", ")", "or", "np", ".", "array_equal", "(", "a", ",", "-", "b", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "# print('a:', a)", "\n", "# print('b:', b)", "\n", "", "axis_", "=", "np", ".", "cross", "(", "a", ",", "b", ")", "\n", "axis_", "=", "axis_", "/", "np", ".", "linalg", ".", "norm", "(", "axis_", ")", "\n", "angle", "=", "np", ".", "arccos", "(", "np", ".", "dot", "(", "a", ",", "b", ")", ")", "\n", "\n", "return", "axis_", ",", "angle", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.normalized": [[32, 37], ["numpy.atleast_1d", "numpy.linalg.norm", "numpy.expand_dims"], "function", ["None"], ["", "def", "normalized", "(", "a", ",", "axis", "=", "-", "1", ",", "order", "=", "2", ")", ":", "\n", "    ", "\"\"\"Normalizes a numpy array of points\"\"\"", "\n", "l2", "=", "np", ".", "atleast_1d", "(", "np", ".", "linalg", ".", "norm", "(", "a", ",", "order", ",", "axis", ")", ")", "\n", "l2", "[", "l2", "==", "0", "]", "=", "1", "\n", "return", "a", "/", "np", ".", "expand_dims", "(", "l2", ",", "axis", ")", ",", "l2", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.visualization.visual.show_one_frame": [[7, 43], ["open3d.visualization.Visualizer", "o3d.visualization.Visualizer.create_window", "open3d.geometry.PointCloud", "open3d.utility.Vector3dVector", "open3d.utility.Vector3dVector", "numpy.array", "numpy.array", "LineMesh.LineMesh", "numpy.array", "LineMesh.LineMesh", "o3d.visualization.Visualizer.add_geometry", "LineMesh.LineMesh.add_line", "LineMesh.LineMesh.add_line", "o3d.visualization.Visualizer.run", "o3d.visualization.Visualizer.destroy_window", "numpy.ones", "o3d.visualization.Visualizer.capture_screen_image", "range", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.LineMesh.add_line", "home.repos.pwc.inspect_result.fpthink_v2b.visualization.LineMesh.LineMesh.add_line"], ["def", "show_one_frame", "(", "pc", ",", "\n", "gt_bbox", ",", "\n", "pred_bbox", ",", "\n", "capture_path", "=", "None", ",", "\n", "window_pose", "=", "[", "960", ",", "540", ",", "100", ",", "100", "]", ",", "\n", ")", ":", "\n", "    ", "vis", "=", "o3d", ".", "visualization", ".", "Visualizer", "(", ")", "\n", "vis", ".", "create_window", "(", "width", "=", "window_pose", "[", "0", "]", ",", "height", "=", "window_pose", "[", "1", "]", ",", "left", "=", "window_pose", "[", "2", "]", ",", "top", "=", "window_pose", "[", "3", "]", ")", "\n", "\n", "scene_color", "=", "np", ".", "ones", "(", "(", "pc", ".", "shape", "[", "0", "]", ",", "3", ")", ")", "*", "0.4", "\n", "point_cloud", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "point_cloud", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "pc", ")", "\n", "point_cloud", ".", "colors", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "scene_color", ")", "\n", "\n", "# bbox", "\n", "lines_box", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "[", "1", ",", "2", "]", ",", "[", "2", ",", "3", "]", ",", "[", "3", ",", "0", "]", ",", "\n", "[", "4", ",", "5", "]", ",", "[", "5", ",", "6", "]", ",", "[", "6", ",", "7", "]", ",", "[", "7", ",", "4", "]", ",", "\n", "[", "0", ",", "4", "]", ",", "[", "1", ",", "5", "]", ",", "[", "2", ",", "6", "]", ",", "[", "3", ",", "7", "]", "]", ")", "\n", "\n", "gt_colors", "=", "np", ".", "array", "(", "[", "[", "0.", ",", "1.", ",", "0.", "]", "for", "_", "in", "range", "(", "len", "(", "lines_box", ")", ")", "]", ")", "# green", "\n", "gt_line_mesh", "=", "LineMesh", "(", "gt_bbox", ",", "lines_box", ",", "gt_colors", ",", "radius", "=", "0.02", ")", "\n", "\n", "pred_colors", "=", "np", ".", "array", "(", "[", "[", "1.", ",", "0.", ",", "0.", "]", "for", "_", "in", "range", "(", "len", "(", "lines_box", ")", ")", "]", ")", "# red", "\n", "pred_line_mesh", "=", "LineMesh", "(", "pred_bbox", ",", "lines_box", ",", "pred_colors", ",", "radius", "=", "0.02", ")", "\n", "\n", "vis", ".", "add_geometry", "(", "point_cloud", ")", "\n", "gt_line_mesh", ".", "add_line", "(", "vis", ")", "\n", "pred_line_mesh", ".", "add_line", "(", "vis", ")", "\n", "\n", "vis", ".", "run", "(", ")", "\n", "\n", "# save picture", "\n", "if", "not", "capture_path", "is", "None", ":", "\n", "        ", "vis", ".", "capture_screen_image", "(", "capture_path", ")", "\n", "\n", "", "vis", ".", "destroy_window", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.__init__": [[14, 97], ["datasets.base_dataset.BaseDataset.__init__", "numpy.array", "numpy.array().reshape", "numpy.array().reshape", "v2b_dataset.TrainDataset.area_extents.copy().transpose", "v2b_dataset.TrainDataset.voxel_grid_size.astype", "v2b_dataset.TrainDataset.xy_area_extents.transpose", "numpy.floor", "numpy.array", "numpy.ceil", "numpy.floor", "ValueError", "numpy.ceil", "os.path.exists", "v2b_dataset.TrainDataset.dataset.load_data", "v2b_dataset.TrainDataset.dataset.load_data", "tqdm.tqdm.tqdm", "v2b_dataset.TrainDataset.dataset.save_data", "v2b_dataset.TrainDataset.dataset.save_data", "os.path.exists", "tqdm.tqdm.tqdm", "v2b_dataset.TrainDataset.dataset.load_data", "tqdm.tqdm.tqdm", "v2b_dataset.TrainDataset.dataset.save_data", "split.split", "numpy.array", "numpy.array", "v2b_dataset.TrainDataset.area_extents.copy", "range", "range", "len", "range", "utils.kitti_utils.getModel", "len", "v2b_dataset.TrainDataset.getBBandPC", "utils.kitti_utils.cropPC", "v2b_dataset.TrainDataset.list_of_PCs.append", "v2b_dataset.TrainDataset.list_of_BBs.append", "len", "len", "v2b_dataset.TrainDataset.getBBandPC", "PCs.append", "BBs.append", "split.split", "split.split", "split.split"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.load_data", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.load_data", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.save_data", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.save_data", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.load_data", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.save_data", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.Box.copy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getModel", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getBBandPC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropPC", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getBBandPC"], ["    ", "def", "__init__", "(", "self", ",", "opts", ",", "split", ")", ":", "\n", "        ", "super", "(", "TrainDataset", ",", "self", ")", ".", "__init__", "(", "\n", "which_dataset", "=", "opts", ".", "which_dataset", ",", "\n", "path", "=", "opts", ".", "db", ".", "data_dir", ",", "\n", "split", "=", "split", ",", "\n", "category_name", "=", "opts", ".", "db", ".", "category_name", ",", "\n", "offset_BB", "=", "opts", ".", "offset_BB", ",", "\n", "scale_BB", "=", "opts", ".", "scale_BB", "\n", ")", "\n", "# Number of candidate point clouds per frame", "\n", "self", ".", "num_candidates_perframe", "=", "4", "\n", "# Init", "\n", "self", ".", "offset_BB", "=", "opts", ".", "offset_BB", "\n", "self", ".", "scale_BB", "=", "opts", ".", "scale_BB", "\n", "self", ".", "templates_num", "=", "opts", ".", "templates_num", "\n", "self", ".", "subsample_number", "=", "opts", ".", "subsample_number", "\n", "self", ".", "min_points_num", "=", "opts", ".", "min_points_num", "\n", "self", ".", "preload_data_path", "=", "opts", ".", "data_save_path", "+", "'/'", "+", "self", ".", "category_name", "+", "'_'", "+", "split", ".", "split", "(", "'_'", ")", "[", "1", "]", "\n", "\n", "# voxelize point cloud parameter", "\n", "self", ".", "voxel_size", "=", "np", ".", "array", "(", "opts", ".", "voxel_size", ")", "\n", "self", ".", "xy_size", "=", "np", ".", "array", "(", "opts", ".", "xy_size", ")", "*", "opts", ".", "downsample", "\n", "self", ".", "area_extents", "=", "np", ".", "array", "(", "opts", ".", "area_extents", ")", ".", "reshape", "(", "3", ",", "2", ")", "\n", "self", ".", "xy_area_extents", "=", "np", ".", "array", "(", "opts", ".", "xy_area_extents", ")", ".", "reshape", "(", "2", ",", "2", ")", "\n", "self", ".", "regress_radius", "=", "opts", ".", "regress_radius", "\n", "self", ".", "voxel_extents_transpose", "=", "self", ".", "area_extents", ".", "copy", "(", ")", ".", "transpose", "(", ")", "\n", "self", ".", "scene_ground", "=", "self", ".", "voxel_extents_transpose", "[", "0", "]", "\n", "self", ".", "voxel_grid_size", "=", "np", ".", "ceil", "(", "self", ".", "voxel_extents_transpose", "[", "1", "]", "/", "self", ".", "voxel_size", ")", "-", "np", ".", "floor", "(", "self", ".", "voxel_extents_transpose", "[", "0", "]", "/", "self", ".", "voxel_size", ")", "\n", "self", ".", "voxel_grid_size", "=", "self", ".", "voxel_grid_size", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "# set image grid extents", "\n", "extents_transpose", "=", "self", ".", "xy_area_extents", ".", "transpose", "(", ")", "\n", "if", "extents_transpose", ".", "shape", "!=", "(", "2", ",", "2", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Extents are the wrong shape {}\"", ".", "format", "(", "extents_transpose", ".", "shape", ")", ")", "\n", "\n", "", "self", ".", "min_img_coord", "=", "np", ".", "floor", "(", "extents_transpose", "[", "0", "]", "/", "self", ".", "xy_size", ")", "\n", "self", ".", "max_img_coord", "=", "np", ".", "ceil", "(", "extents_transpose", "[", "1", "]", "/", "self", ".", "xy_size", ")", "-", "1", "\n", "self", ".", "img_size", "=", "(", "(", "self", ".", "max_img_coord", "-", "self", ".", "min_img_coord", ")", "+", "1", ")", ".", "astype", "(", "np", ".", "int32", ")", "# [h, w]", "\n", "\n", "# Process the original dataset", "\n", "if", "(", "not", "self", ".", "preload_data_path", "is", "None", ")", "and", "os", ".", "path", ".", "exists", "(", "self", ".", "preload_data_path", "+", "'_PCs.pth'", ")", ":", "\n", "            ", "self", ".", "list_of_PCs", "=", "self", ".", "dataset", ".", "load_data", "(", "self", ".", "preload_data_path", "+", "'_PCs.pth'", ")", "\n", "self", ".", "list_of_BBs", "=", "self", ".", "dataset", ".", "load_data", "(", "self", ".", "preload_data_path", "+", "'_BBs.pth'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "list_of_PCs", "=", "[", "]", "\n", "self", ".", "list_of_BBs", "=", "[", "]", "\n", "for", "tracklet", "in", "tqdm", "(", "self", ".", "list_of_tracklet_anno", ",", "ncols", "=", "opts", ".", "ncols", ",", "ascii", "=", "True", ",", "desc", "=", "\"Create %s PCs & BBs\"", "%", "split", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", ":", "\n", "                ", "for", "idx", "in", "range", "(", "len", "(", "tracklet", ")", ")", ":", "\n", "                    ", "this_PC", ",", "this_BB", "=", "self", ".", "getBBandPC", "(", "tracklet", "[", "idx", "]", ")", "\n", "this_PC", "=", "kitti_utils", ".", "cropPC", "(", "this_PC", ",", "this_BB", ",", "offset", "=", "10", ",", "scale", "=", "1.0", ")", "# offset 10m, reduce storage capacity", "\n", "self", ".", "list_of_PCs", ".", "append", "(", "this_PC", ")", "\n", "self", ".", "list_of_BBs", ".", "append", "(", "this_BB", ")", "\n", "", "", "self", ".", "dataset", ".", "save_data", "(", "self", ".", "preload_data_path", "+", "'_PCs.pth'", ",", "self", ".", "list_of_PCs", ")", "\n", "self", ".", "dataset", ".", "save_data", "(", "self", ".", "preload_data_path", "+", "'_BBs.pth'", ",", "self", ".", "list_of_BBs", ")", "\n", "\n", "", "if", "(", "not", "self", ".", "preload_data_path", "is", "None", ")", "and", "os", ".", "path", ".", "exists", "(", "self", ".", "preload_data_path", "+", "'_Models.pth'", ")", ":", "\n", "            ", "for", "i", "in", "tqdm", "(", "range", "(", "len", "(", "self", ".", "list_of_tracklet_anno", ")", ")", ",", "ncols", "=", "opts", ".", "ncols", ",", "ascii", "=", "True", ",", "desc", "=", "\"Load %s model_pc\"", "%", "split", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", ":", "\n", "                ", "list_of_anno", "=", "self", ".", "list_of_tracklet_anno", "[", "i", "]", "\n", "cnt", "=", "0", "\n", "for", "anno", "in", "list_of_anno", ":", "\n", "                    ", "anno", "[", "\"model_idx\"", "]", "=", "i", "\n", "anno", "[", "\"relative_idx\"", "]", "=", "cnt", "\n", "cnt", "+=", "1", "\n", "", "", "self", ".", "model_PC", "=", "self", ".", "dataset", ".", "load_data", "(", "self", ".", "preload_data_path", "+", "'_Models.pth'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "model_PC", "=", "[", "None", "]", "*", "len", "(", "self", ".", "list_of_tracklet_anno", ")", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "len", "(", "self", ".", "list_of_tracklet_anno", ")", ")", ",", "ncols", "=", "opts", ".", "ncols", ",", "ascii", "=", "True", ",", "desc", "=", "\"Create %s model_pc\"", "%", "split", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", ":", "\n", "                ", "list_of_anno", "=", "self", ".", "list_of_tracklet_anno", "[", "i", "]", "\n", "PCs", "=", "[", "]", "\n", "BBs", "=", "[", "]", "\n", "cnt", "=", "0", "\n", "for", "anno", "in", "list_of_anno", ":", "\n", "                    ", "this_PC", ",", "this_BB", "=", "self", ".", "getBBandPC", "(", "anno", ")", "\n", "PCs", ".", "append", "(", "this_PC", ")", "\n", "BBs", ".", "append", "(", "this_BB", ")", "\n", "anno", "[", "\"model_idx\"", "]", "=", "i", "\n", "anno", "[", "\"relative_idx\"", "]", "=", "cnt", "\n", "cnt", "+=", "1", "\n", "", "self", ".", "model_PC", "[", "i", "]", "=", "kitti_utils", ".", "getModel", "(", "PCs", ",", "BBs", ",", "offset", "=", "0", ",", "scale", "=", "1.25", ")", "\n", "", "self", ".", "dataset", ".", "save_data", "(", "self", ".", "preload_data_path", "+", "'_Models.pth'", ",", "self", ".", "model_PC", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.__getitem__": [[98, 100], ["v2b_dataset.TrainDataset.getitem"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.getitem"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "getitem", "(", "index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.getPCandBBfromIndex": [[101, 105], ["None"], "methods", ["None"], ["", "def", "getPCandBBfromIndex", "(", "self", ",", "anno_idx", ")", ":", "\n", "        ", "this_PC", "=", "self", ".", "list_of_PCs", "[", "anno_idx", "]", "\n", "this_BB", "=", "self", ".", "list_of_BBs", "[", "anno_idx", "]", "\n", "return", "this_PC", ",", "this_BB", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.getitem": [[106, 231], ["v2b_dataset.TrainDataset.getAnnotationIndex", "v2b_dataset.TrainDataset.getSearchSpaceIndex", "v2b_dataset.TrainDataset.getPCandBBfromIndex", "utils.kitti_utils.getOffsetBB_data", "utils.kitti_utils.cropAndCenterPC_withClaAndOff", "utils.kitti_utils.subsamplePC_withClaAndOff", "v2b_dataset.TrainDataset.getPCandBBfromIndex", "v2b_dataset.TrainDataset.getPCandBBfromIndex", "utils.kitti_utils.getOffsetBB_data", "utils.kitti_utils.getModel", "numpy.array", "utils.kitti_utils.subsamplePC", "utils.kitti_utils.subsamplePC", "pyquaternion.Quaternion", "numpy.dot", "torch.from_numpy().float", "tgt_offcenter[].numpy", "numpy.floor().astype", "numpy.min", "numpy.max", "numpy.arange", "numpy.arange", "numpy.meshgrid", "numpy.concatenate", "numpy.floor().astype", "numpy.sqrt", "numpy.zeros", "numpy.zeros", "numpy.array", "numpy.array", "numpy.zeros", "range", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "utils.searchspace.KalmanFiltering", "utils.searchspace.KalmanFiltering", "utils.searchspace.KalmanFiltering.sample", "target_PC.nbr_points", "v2b_dataset.TrainDataset.getitem", "numpy.zeros", "numpy.random.uniform", "utils.kitti_utils.subsamplePC.nbr_points", "v2b_dataset.TrainDataset.getitem", "torch.from_numpy().float.t", "numpy.sum", "v2b_dataset.TrainDataset.getitem", "range", "numpy.random.randint", "numpy.random.randint", "torch.from_numpy", "adapt_cur_BB.corners", "numpy.floor", "numpy.floor", "numpy.random.randint", "numpy.zeros", "v2b_dataset.TrainDataset.__len__", "v2b_dataset.TrainDataset.__len__", "v2b_dataset.TrainDataset.__len__", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.getAnnotationIndex", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.getSearchSpaceIndex", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.getPCandBBfromIndex", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getOffsetBB_data", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropAndCenterPC_withClaAndOff", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.subsamplePC_withClaAndOff", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.getPCandBBfromIndex", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.getPCandBBfromIndex", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getOffsetBB_data", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getModel", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.subsamplePC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.subsamplePC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.searchspace.GaussianMixtureModel.sample", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.nbr_points", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.getitem", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.PointCloud.nbr_points", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.getitem", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.getitem", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.__len__", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.__len__", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.__len__"], ["", "def", "getitem", "(", "self", ",", "index", ")", ":", "\n", "        ", "anno_idx", "=", "self", ".", "getAnnotationIndex", "(", "index", ")", "\n", "sample_idx", "=", "self", ".", "getSearchSpaceIndex", "(", "index", ")", "\n", "\n", "this_anno", "=", "self", ".", "list_of_anno", "[", "anno_idx", "]", "\n", "\n", "# 1. Get the search point cloud", "\n", "cur_PC", ",", "cur_BB", "=", "self", ".", "getPCandBBfromIndex", "(", "anno_idx", ")", "\n", "\n", "if", "sample_idx", "==", "0", ":", "\n", "# sample_offsets = np.zeros(4)", "\n", "            ", "gaussian", "=", "searchspace", ".", "KalmanFiltering", "(", "bnd", "=", "[", "0.1", ",", "0.1", ",", "0.05", ",", "0.5", "]", ")", "\n", "", "else", ":", "\n", "            ", "gaussian", "=", "searchspace", ".", "KalmanFiltering", "(", "bnd", "=", "[", "1", ",", "1", ",", "0.5", ",", "5", "]", ")", "\n", "", "sample_offsets", "=", "gaussian", ".", "sample", "(", "1", ")", "[", "0", "]", "\n", "sample_cur_BB", "=", "kitti_utils", ".", "getOffsetBB_data", "(", "cur_BB", ",", "sample_offsets", ")", "\n", "\n", "target_PC", ",", "tgt_surf_cla", ",", "tgt_offcenter", ",", "adapt_cur_BB", "=", "kitti_utils", ".", "cropAndCenterPC_withClaAndOff", "(", "cur_PC", ",", "sample_cur_BB", ",", "cur_BB", ",", "offset", "=", "self", ".", "offset_BB", ",", "scale", "=", "1.25", ",", "limit_area", "=", "self", ".", "area_extents", ")", "\n", "\n", "if", "target_PC", ".", "nbr_points", "(", ")", "<=", "self", ".", "min_points_num", ":", "# Too few points, sample one again", "\n", "            ", "return", "self", ".", "getitem", "(", "np", ".", "random", ".", "randint", "(", "0", ",", "self", ".", "__len__", "(", ")", ")", ")", "\n", "\n", "", "target_PC", "=", "target_PC", ".", "points", "\n", "target_PC", ",", "tgt_surf_cla", ",", "tgt_offcenter", "=", "kitti_utils", ".", "subsamplePC_withClaAndOff", "(", "target_PC", ",", "tgt_surf_cla", ",", "tgt_offcenter", ",", "self", ".", "subsample_number", ")", "\n", "\n", "# 2. Get the template point cloud", "\n", "if", "this_anno", "[", "\"relative_idx\"", "]", "==", "0", ":", "\n", "            ", "prev_idx", "=", "anno_idx", "\n", "fir_idx", "=", "anno_idx", "\n", "", "else", ":", "\n", "            ", "prev_idx", "=", "anno_idx", "-", "1", "\n", "fir_idx", "=", "anno_idx", "-", "this_anno", "[", "\"relative_idx\"", "]", "\n", "", "pre_PC", ",", "pre_BB", "=", "self", ".", "getPCandBBfromIndex", "(", "prev_idx", ")", "\n", "fir_PC", ",", "fir_BB", "=", "self", ".", "getPCandBBfromIndex", "(", "fir_idx", ")", "\n", "\n", "if", "sample_idx", "==", "0", ":", "\n", "            ", "samplegt_offsets", "=", "np", ".", "zeros", "(", "4", ")", "\n", "", "else", ":", "\n", "            ", "samplegt_offsets", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "-", "0.3", ",", "high", "=", "0.3", ",", "size", "=", "4", ")", "\n", "samplegt_offsets", "[", "3", "]", "=", "samplegt_offsets", "[", "3", "]", "*", "5.0", "\n", "", "sample_pre_BB", "=", "kitti_utils", ".", "getOffsetBB_data", "(", "pre_BB", ",", "samplegt_offsets", ")", "\n", "\n", "model_PC", "=", "kitti_utils", ".", "getModel", "(", "[", "fir_PC", ",", "pre_PC", "]", ",", "[", "fir_BB", ",", "sample_pre_BB", "]", ",", "scale", "=", "1.25", ")", "\n", "\n", "if", "model_PC", ".", "nbr_points", "(", ")", "<=", "self", ".", "min_points_num", ":", "\n", "            ", "return", "self", ".", "getitem", "(", "np", ".", "random", ".", "randint", "(", "0", ",", "self", ".", "__len__", "(", ")", ")", ")", "\n", "\n", "", "model_PC", "=", "np", ".", "array", "(", "model_PC", ".", "points", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "model_PC", "=", "kitti_utils", ".", "subsamplePC", "(", "model_PC", ",", "self", ".", "subsample_number", "//", "2", ")", "\n", "\n", "# 3. Get the completion point cloud", "\n", "model_idx", "=", "this_anno", "[", "\"model_idx\"", "]", "\n", "completion_PC", "=", "kitti_utils", ".", "subsamplePC", "(", "self", ".", "model_PC", "[", "model_idx", "]", ".", "points", ",", "2", "*", "self", ".", "subsample_number", ")", "\n", "rot", "=", "Quaternion", "(", "axis", "=", "[", "0", ",", "0", ",", "1", "]", ",", "angle", "=", "-", "sample_offsets", "[", "3", "]", "*", "np", ".", "pi", "/", "180", ")", "\n", "completion_PC", "=", "np", ".", "dot", "(", "rot", ".", "rotation_matrix", ",", "completion_PC", ".", "t", "(", ")", ")", "\n", "completion_PC", "=", "torch", ".", "from_numpy", "(", "completion_PC", ")", ".", "float", "(", ")", "\n", "\n", "# 4. Set image grid extents", "\n", "offcenter", "=", "tgt_offcenter", "[", "0", "]", ".", "numpy", "(", ")", "\n", "corners", "=", "adapt_cur_BB", ".", "corners", "(", ")", "[", ":", "2", "]", ".", "T", "# corners.shape (3,8) ==> (2,8) ==> (8,2)", "\n", "corners", "=", "corners", "[", "[", "0", ",", "2", ",", "4", ",", "6", "]", "]", "\n", "\n", "output_h", "=", "self", ".", "img_size", "[", "1", "]", "\n", "output_w", "=", "self", ".", "img_size", "[", "0", "]", "\n", "\n", "# hot_map", "\n", "corners_int", "=", "np", ".", "floor", "(", "(", "corners", "/", "self", ".", "xy_size", ")", "-", "self", ".", "min_img_coord", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "corners_int_ul", "=", "np", ".", "min", "(", "corners_int", ",", "axis", "=", "0", ")", "# upper left           ", "\n", "corners_int_br", "=", "np", ".", "max", "(", "corners_int", ",", "axis", "=", "0", ")", "# bottom right", "\n", "x", "=", "np", ".", "arange", "(", "corners_int_ul", "[", "0", "]", ",", "corners_int_br", "[", "0", "]", "+", "1", ",", "1", ")", "\n", "y", "=", "np", ".", "arange", "(", "corners_int_ul", "[", "1", "]", ",", "corners_int_br", "[", "1", "]", "+", "1", ",", "1", ")", "\n", "xx", ",", "yy", "=", "np", ".", "meshgrid", "(", "x", ",", "y", ")", "\n", "\n", "hot_map_grid", "=", "np", ".", "concatenate", "(", "[", "xx", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "yy", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "]", ",", "axis", "=", "2", ")", "\n", "ct", "=", "offcenter", "[", ":", "2", "]", "# xy-offcenter ", "\n", "ct_image", "=", "(", "ct", "/", "self", ".", "xy_size", ")", "-", "self", ".", "min_img_coord", "\n", "ct_image_int", "=", "np", ".", "floor", "(", "ct_image", ")", ".", "astype", "(", "np", ".", "int32", ")", "# offcenter(xy) in image-coordinate", "\n", "\n", "# (local_h, local_w)", "\n", "hot_map_grid", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "(", "hot_map_grid", "-", "ct_image_int", ")", "**", "2", ",", "axis", "=", "2", ")", ")", "\n", "hot_map_grid", "[", "hot_map_grid", "==", "0", "]", "=", "1e-6", "\n", "hot_map_grid", "=", "1.0", "/", "hot_map_grid", "\n", "# (1, h, w)", "\n", "hot_map", "=", "np", ".", "zeros", "(", "(", "1", ",", "output_h", ",", "output_w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# center: 1.0   around: 0.8     else: 0.0", "\n", "if", "hot_map", "[", "0", ",", "corners_int_ul", "[", "1", "]", ":", "corners_int_br", "[", "1", "]", "+", "1", ",", "corners_int_ul", "[", "0", "]", ":", "corners_int_br", "[", "0", "]", "+", "1", "]", ".", "shape", "!=", "(", "corners_int_br", "[", "1", "]", "+", "1", "-", "corners_int_ul", "[", "1", "]", ",", "corners_int_br", "[", "0", "]", "+", "1", "-", "corners_int_ul", "[", "0", "]", ")", ":", "\n", "            ", "return", "self", ".", "getitem", "(", "np", ".", "random", ".", "randint", "(", "0", ",", "self", ".", "__len__", "(", ")", ")", ")", "\n", "", "hot_map", "[", "0", ",", "corners_int_ul", "[", "1", "]", ":", "corners_int_br", "[", "1", "]", "+", "1", ",", "corners_int_ul", "[", "0", "]", ":", "corners_int_br", "[", "0", "]", "+", "1", "]", "=", "hot_map_grid", "\n", "hot_map", "[", "0", ",", "ct_image_int", "[", "1", "]", ",", "ct_image_int", "[", "0", "]", "]", "=", "1.0", "# center: 1.0", "\n", "hot_map", "[", "0", ",", "[", "ct_image_int", "[", "1", "]", ",", "ct_image_int", "[", "1", "]", ",", "ct_image_int", "[", "1", "]", "+", "1", ",", "ct_image_int", "[", "1", "]", "-", "1", "]", ",", "[", "ct_image_int", "[", "0", "]", "-", "1", ",", "ct_image_int", "[", "0", "]", "+", "1", ",", "ct_image_int", "[", "0", "]", ",", "ct_image_int", "[", "0", "]", "]", "]", "=", "0.8", "# around: 0.8", "\n", "\n", "# ((2r+1)^2,3) x,y,ry", "\n", "local_offsets", "=", "np", ".", "zeros", "(", "(", "(", "2", "*", "self", ".", "regress_radius", "+", "1", ")", "**", "2", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# (1,1)", "\n", "z_axis", "=", "np", ".", "array", "(", "[", "[", "offcenter", "[", "2", "]", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# center index", "\n", "index_center", "=", "np", ".", "array", "(", "[", "ct_image_int", "[", "1", "]", "*", "output_w", "+", "ct_image_int", "[", "0", "]", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "index_offsets", "=", "np", ".", "zeros", "(", "(", "(", "2", "*", "self", ".", "regress_radius", "+", "1", ")", "**", "2", ",", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "for", "i", "in", "range", "(", "-", "self", ".", "regress_radius", ",", "self", ".", "regress_radius", "+", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "-", "self", ".", "regress_radius", ",", "self", ".", "regress_radius", "+", "1", ")", ":", "\n", "                ", "offsets", "=", "np", ".", "zeros", "(", "(", "3", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "offsets", "[", ":", "2", "]", "=", "ct_image", "-", "ct_image_int", "-", "np", ".", "array", "(", "[", "i", ",", "j", "]", ")", "\n", "# rotate", "\n", "offsets", "[", "2", "]", "=", "offcenter", "[", "3", "]", "\n", "local_offsets", "[", "(", "i", "+", "self", ".", "regress_radius", ")", "*", "(", "2", "*", "self", ".", "regress_radius", "+", "1", ")", "+", "(", "j", "+", "self", ".", "regress_radius", ")", "]", "=", "offsets", "\n", "ind_int", "=", "ct_image_int", "+", "np", ".", "array", "(", "[", "i", ",", "j", "]", ")", "\n", "index_offsets", "[", "(", "i", "+", "self", ".", "regress_radius", ")", "*", "(", "2", "*", "self", ".", "regress_radius", "+", "1", ")", "+", "(", "j", "+", "self", ".", "regress_radius", ")", "]", "=", "ind_int", "[", "1", "]", "*", "output_w", "+", "ind_int", "[", "0", "]", "\n", "\n", "", "", "hot_map", "=", "torch", ".", "from_numpy", "(", "hot_map", ")", "# (1, H, W)", "\n", "index_center", "=", "torch", ".", "from_numpy", "(", "index_center", ")", "# (1, )", "\n", "z_axis", "=", "torch", ".", "from_numpy", "(", "z_axis", ")", "# (1, 1)", "\n", "index_offsets", "=", "torch", ".", "from_numpy", "(", "index_offsets", ")", "# ((2*degress_ratio+1)**2,  ) ==> (25, )", "\n", "local_offsets", "=", "torch", ".", "from_numpy", "(", "local_offsets", ")", "# ((2*degress_ratio+1)**2, 3) ==> (25, 3)", "\n", "\n", "return", "{", "\n", "'completion_pc'", ":", "completion_PC", ",", "\n", "'template_pc'", ":", "model_PC", ",", "\n", "'search_pc'", ":", "target_PC", ",", "\n", "'heat_map'", ":", "hot_map", ",", "\n", "'index_center'", ":", "index_center", ",", "\n", "'z_axis'", ":", "z_axis", ",", "\n", "'index_offsets'", ":", "index_offsets", ",", "\n", "'local_offsets'", ":", "local_offsets", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.__len__": [[233, 235], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "list_of_anno", ")", "*", "self", ".", "num_candidates_perframe", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.getAnnotationIndex": [[236, 238], ["int"], "methods", ["None"], ["", "def", "getAnnotationIndex", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "int", "(", "index", "/", "(", "self", ".", "num_candidates_perframe", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TrainDataset.getSearchSpaceIndex": [[239, 241], ["int"], "methods", ["None"], ["", "def", "getSearchSpaceIndex", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "int", "(", "index", "%", "self", ".", "num_candidates_perframe", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.__init__": [[243, 273], ["datasets.base_dataset.BaseDataset.__init__", "numpy.array", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().transpose", "numpy.floor", "v2b_dataset.TestDataset.area_extents.transpose", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.ceil", "numpy.floor"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opts", ",", "split", ")", ":", "\n", "        ", "super", "(", "TestDataset", ",", "self", ")", ".", "__init__", "(", "\n", "which_dataset", "=", "opts", ".", "which_dataset", ",", "\n", "path", "=", "opts", ".", "db", ".", "data_dir", ",", "\n", "split", "=", "split", ",", "\n", "category_name", "=", "opts", ".", "db", ".", "category_name", ",", "\n", "offset_BB", "=", "opts", ".", "offset_BB", ",", "\n", "scale_BB", "=", "opts", ".", "scale_BB", "\n", ")", "\n", "# common parameters", "\n", "self", ".", "which_dataset", "=", "opts", ".", "which_dataset", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "subsample_number", "=", "opts", ".", "subsample_number", "\n", "self", ".", "offset_BB", "=", "opts", ".", "offset_BB", "\n", "self", ".", "scale_BB", "=", "opts", ".", "scale_BB", "\n", "\n", "self", ".", "voxel_size", "=", "np", ".", "array", "(", "opts", ".", "voxel_size", ")", "\n", "self", ".", "xy_size", "=", "np", ".", "array", "(", "opts", ".", "xy_size", ")", "*", "opts", ".", "downsample", "\n", "self", ".", "area_extents", "=", "np", ".", "array", "(", "opts", ".", "area_extents", ")", ".", "reshape", "(", "3", ",", "2", ")", "\n", "self", ".", "xy_area_extents", "=", "np", ".", "array", "(", "opts", ".", "xy_area_extents", ")", ".", "reshape", "(", "2", ",", "2", ")", "\n", "\n", "extents_transpose", "=", "np", ".", "array", "(", "self", ".", "xy_area_extents", ")", ".", "transpose", "(", ")", "\n", "assert", "extents_transpose", ".", "shape", "==", "(", "2", ",", "2", ")", ",", "\"Extents are the wrong shape {}\"", ".", "format", "(", "extents_transpose", ".", "shape", ")", "\n", "\n", "# image grid extents", "\n", "self", ".", "min_img_coord", "=", "np", ".", "floor", "(", "extents_transpose", "[", "0", "]", "/", "self", ".", "xy_size", ")", "\n", "voxel_extents_transpose", "=", "self", ".", "area_extents", ".", "transpose", "(", ")", "\n", "self", ".", "scene_ground", "=", "voxel_extents_transpose", "[", "0", "]", "\n", "self", ".", "voxel_grid_size", "=", "(", "np", ".", "ceil", "(", "voxel_extents_transpose", "[", "1", "]", "/", "self", ".", "voxel_size", ")", "-", "\n", "np", ".", "floor", "(", "voxel_extents_transpose", "[", "0", "]", "/", "self", ".", "voxel_size", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.getitem": [[274, 283], ["v2b_dataset.TestDataset.getBBandPC", "PCs.append", "BBs.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getBBandPC"], ["", "def", "getitem", "(", "self", ",", "index", ")", ":", "\n", "        ", "list_of_anno", "=", "self", ".", "list_of_tracklet_anno", "[", "index", "]", "\n", "PCs", "=", "[", "]", "\n", "BBs", "=", "[", "]", "\n", "for", "anno", "in", "list_of_anno", ":", "\n", "            ", "this_PC", ",", "this_BB", "=", "self", ".", "getBBandPC", "(", "anno", ")", "\n", "PCs", ".", "append", "(", "this_PC", ")", "\n", "BBs", ".", "append", "(", "this_BB", ")", "\n", "", "return", "PCs", ",", "BBs", ",", "list_of_anno", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.__len__": [[284, 286], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "list_of_tracklet_anno", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.get_tracklet_framse": [[287, 291], ["list", "sum", "map", "len"], "methods", ["None"], ["", "def", "get_tracklet_framse", "(", "self", ")", ":", "\n", "        ", "tracklet_length", "=", "list", "(", "map", "(", "lambda", "x", ":", "len", "(", "x", ")", ",", "self", ".", "list_of_tracklet_anno", ")", ")", "\n", "\n", "return", "sum", "(", "tracklet_length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD.__init__": [[293, 309], ["numpy.load", "numpy.load", "v2b_dataset.TestDataset_WOD._create_pcs_and_bboxs", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD._create_pcs_and_bboxs"], ["    ", "def", "__init__", "(", "self", ",", "opts", ",", "pc_type", "=", "'raw_pc'", ")", ":", "\n", "# pc_type: raw_pc, ground_pc, clean_pc", "\n", "        ", "self", ".", "tracklet_id", "=", "opts", ".", "db", ".", "tracklet_id", "\n", "self", ".", "segment_name", "=", "opts", ".", "db", ".", "segment_name", "\n", "self", ".", "data_folder", "=", "opts", ".", "db", ".", "data_dir", "\n", "\n", "self", ".", "start_frame", "=", "opts", ".", "db", ".", "frame_range", "[", "0", "]", "\n", "self", ".", "end_frame", "=", "opts", ".", "db", ".", "frame_range", "[", "1", "]", "\n", "\n", "self", ".", "cur_frame", "=", "0", "\n", "self", ".", "tracklet_lenth", "=", "self", ".", "end_frame", "-", "self", ".", "start_frame", "\n", "\n", "self", ".", "gt_info", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "data_folder", ",", "'gt_info'", ",", "'{:}.npz'", ".", "format", "(", "self", ".", "segment_name", ")", ")", ",", "allow_pickle", "=", "True", ")", "\n", "self", ".", "pcs", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "data_folder", ",", "'pc'", ",", "pc_type", ",", "'{:}.npz'", ".", "format", "(", "self", ".", "segment_name", ")", ")", ",", "allow_pickle", "=", "True", ")", "\n", "\n", "self", ".", "PCs", ",", "self", ".", "BBs", "=", "self", ".", "_create_pcs_and_bboxs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD.__iter__": [[310, 312], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD.__next__": [[313, 322], ["None"], "methods", ["None"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "cur_frame", ">", "self", ".", "tracklet_lenth", ":", "\n", "            ", "raise", "StopIteration", "\n", "\n", "", "cur_pc", "=", "self", ".", "PCs", "[", "self", ".", "cur_frame", "]", "\n", "cur_bbox", "=", "self", ".", "BBs", "[", "self", ".", "cur_frame", "]", "\n", "\n", "self", ".", "cur_frame", "+=", "1", "\n", "return", "cur_pc", ",", "cur_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD._create_pcs_and_bboxs": [[323, 333], ["range", "v2b_dataset.TestDataset_WOD._getBBandPC", "PCs.append", "BBs.append"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD._getBBandPC"], ["", "def", "_create_pcs_and_bboxs", "(", "self", ")", ":", "\n", "        ", "PCs", "=", "[", "]", "\n", "BBs", "=", "[", "]", "\n", "\n", "for", "idx", "in", "range", "(", "self", ".", "start_frame", ",", "self", ".", "end_frame", "+", "1", ")", ":", "\n", "            ", "this_PC", ",", "this_BB", "=", "self", ".", "_getBBandPC", "(", "idx", ")", "\n", "PCs", ".", "append", "(", "this_PC", ")", "\n", "BBs", ".", "append", "(", "this_BB", ")", "\n", "\n", "", "return", "PCs", ",", "BBs", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD._getBBandPC": [[334, 349], ["utils.data_classes.PointCloud", "frame_ids.index", "pyquaternion.Quaternion", "utils.data_classes.BoundingBox", "str"], "methods", ["None"], ["", "def", "_getBBandPC", "(", "self", ",", "idx", ")", ":", "\n", "        ", "this_PC", "=", "PointCloud", "(", "self", ".", "pcs", "[", "str", "(", "idx", ")", "]", ".", "T", ")", "\n", "\n", "frame_bboxes", "=", "self", ".", "gt_info", "[", "'bboxes'", "]", "[", "idx", "]", "\n", "frame_ids", "=", "self", ".", "gt_info", "[", "'ids'", "]", "[", "idx", "]", "\n", "index", "=", "frame_ids", ".", "index", "(", "self", ".", "tracklet_id", ")", "\n", "bbox", "=", "frame_bboxes", "[", "index", "]", "\n", "\n", "center", "=", "[", "bbox", "[", "0", "]", ",", "bbox", "[", "1", "]", ",", "bbox", "[", "2", "]", "]", "\n", "size", "=", "[", "bbox", "[", "5", "]", ",", "bbox", "[", "4", "]", ",", "bbox", "[", "6", "]", "]", "\n", "orientation", "=", "Quaternion", "(", "axis", "=", "[", "0", ",", "0", ",", "1", "]", ",", "angle", "=", "bbox", "[", "3", "]", ")", "\n", "\n", "this_BB", "=", "BoundingBox", "(", "center", ",", "size", ",", "orientation", ")", "\n", "\n", "return", "this_PC", ",", "this_BB", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD.get_instance_lenth": [[350, 352], ["None"], "methods", ["None"], ["", "def", "get_instance_lenth", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "BBs", "[", "0", "]", ".", "wlh", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD.get_tracklet_lenth": [[353, 355], ["len"], "methods", ["None"], ["", "def", "get_tracklet_lenth", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "BBs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD.get_PCs_and_BBs": [[356, 358], ["None"], "methods", ["None"], ["", "def", "get_PCs_and_BBs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "PCs", ",", "self", ".", "BBs", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.get_v2b_db.get_dataset": [[4, 26], ["datasets.v2b_dataset.TrainDataset", "torch.utils.data.DataLoader", "opts.which_dataset.upper", "datasets.v2b_dataset.TestDataset", "torch.utils.data.DataLoader", "datasets.v2b_dataset.TestDataset_WOD"], "function", ["None"], ["def", "get_dataset", "(", "opts", ",", "partition", ",", "shuffle", "=", "False", ")", ":", "\n", "    ", "loader", ",", "db", "=", "None", ",", "None", "\n", "\n", "if", "opts", ".", "use_tiny", ":", "\n", "        ", "split", "=", "\"Tiny_\"", "+", "partition", "\n", "", "else", ":", "\n", "        ", "split", "=", "\"Full_\"", "+", "partition", "\n", "\n", "\n", "", "if", "partition", "in", "[", "\"Train\"", ",", "\"Valid\"", "]", ":", "\n", "        ", "db", "=", "TrainDataset", "(", "opts", ",", "split", ")", "\n", "loader", "=", "DataLoader", "(", "db", ",", "batch_size", "=", "opts", ".", "batch_size", ",", "shuffle", "=", "shuffle", ",", "num_workers", "=", "opts", ".", "n_workers", ",", "pin_memory", "=", "True", ")", "\n", "", "else", ":", "\n", "# Test dataset", "\n", "        ", "if", "opts", ".", "which_dataset", ".", "upper", "(", ")", "in", "[", "'KITTI'", ",", "'NUSCENES'", "]", ":", "\n", "            ", "db", "=", "TestDataset", "(", "opts", ",", "split", ")", "\n", "loader", "=", "DataLoader", "(", "db", ",", "batch_size", "=", "1", ",", "shuffle", "=", "shuffle", ",", "num_workers", "=", "opts", ".", "n_workers", ",", "pin_memory", "=", "True", ",", "collate_fn", "=", "lambda", "x", ":", "x", ")", "\n", "", "else", ":", "\n", "# waymo test", "\n", "            ", "db", "=", "TestDataset_WOD", "(", "opts", ",", "pc_type", "=", "'raw_pc'", ")", "\n", "\n", "", "", "return", "loader", ",", "db", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.__init__": [[13, 19], ["os.path.join", "os.path.join", "os.path.join"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "path", ",", "which_dataset", ")", ":", "\n", "        ", "self", ".", "which_dataset", "=", "which_dataset", "\n", "self", ".", "KITTI_Folder", "=", "path", "\n", "self", ".", "KITTI_velo", "=", "os", ".", "path", ".", "join", "(", "self", ".", "KITTI_Folder", ",", "\"velodyne\"", ")", "\n", "self", ".", "KITTI_label", "=", "os", ".", "path", ".", "join", "(", "self", ".", "KITTI_Folder", ",", "\"label_02\"", ")", "\n", "self", ".", "KITTI_calib", "=", "os", ".", "path", ".", "join", "(", "self", ".", "KITTI_Folder", ",", "\"calib\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getSceneID": [[20, 64], ["base_dataset.kittiDataset.which_dataset.upper", "split.upper", "split.upper", "split.upper", "list", "split.upper", "split.upper", "list", "list", "split.upper", "range", "split.upper", "list", "split.upper", "range", "range", "split.upper", "list", "list", "split.upper", "list", "range", "split.upper", "list", "range", "range", "split.upper", "list", "list", "range", "range", "range", "range"], "methods", ["None"], ["", "def", "getSceneID", "(", "self", ",", "split", ")", ":", "\n", "        ", "if", "self", ".", "which_dataset", ".", "upper", "(", ")", "==", "'NUSCENES'", ":", "\n", "            ", "if", "\"TRAIN\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "# Training SET", "\n", "                ", "if", "\"TINY\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "                    ", "sceneID", "=", "[", "0", "]", "\n", "", "else", ":", "\n", "                    ", "sceneID", "=", "list", "(", "range", "(", "0", ",", "350", ")", ")", "\n", "", "", "elif", "\"VALID\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "# Validation Set", "\n", "                ", "if", "\"TINY\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "                    ", "sceneID", "=", "[", "0", "]", "\n", "", "else", ":", "\n", "                    ", "sceneID", "=", "list", "(", "range", "(", "0", ",", "10", ")", ")", "\n", "", "", "elif", "\"TEST\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "# Testing Set", "\n", "                ", "if", "\"TINY\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "                    ", "sceneID", "=", "[", "0", "]", "\n", "", "else", ":", "\n", "                    ", "sceneID", "=", "list", "(", "range", "(", "0", ",", "150", ")", ")", "\n", "", "", "", "else", ":", "\n", "# KITTI dataset", "\n", "            ", "if", "\"TRAIN\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "# Training SET", "\n", "                ", "if", "\"TINY\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "                    ", "sceneID", "=", "list", "(", "range", "(", "0", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "                    ", "sceneID", "=", "list", "(", "range", "(", "0", ",", "17", ")", ")", "\n", "", "", "elif", "\"VALID\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "# Validation Set", "\n", "                ", "if", "\"TINY\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "                    ", "sceneID", "=", "list", "(", "range", "(", "0", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "                    ", "sceneID", "=", "list", "(", "range", "(", "17", ",", "19", ")", ")", "\n", "", "", "elif", "\"TEST\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "# Testing Set", "\n", "                ", "if", "\"TINY\"", "in", "split", ".", "upper", "(", ")", ":", "\n", "                    ", "sceneID", "=", "list", "(", "range", "(", "0", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "                    ", "sceneID", "=", "list", "(", "range", "(", "19", ",", "21", ")", ")", "\n", "", "", "else", ":", "\n", "# Full Dataset", "\n", "                ", "sceneID", "=", "list", "(", "range", "(", "21", ")", ")", "\n", "", "", "return", "sceneID", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getListOfAnno": [[65, 107], ["os.path.join", "pandas.read_csv.insert", "pandas.read_csv.track_id.unique", "os.listdir", "base_dataset.kittiDataset.which_dataset.upper", "pandas.read_csv", "pandas.read_csv", "df_tracklet.reset_index.reset_index.reset_index", "list_of_tracklet_anno.append", "os.path.isdir", "os.path.join", "int", "df_tracklet.reset_index.reset_index.iterrows"], "methods", ["None"], ["", "def", "getListOfAnno", "(", "self", ",", "sceneID", ",", "category_name", "=", "\"Car\"", ")", ":", "\n", "        ", "list_of_scene", "=", "[", "\n", "path", "for", "path", "in", "os", ".", "listdir", "(", "self", ".", "KITTI_velo", ")", "\n", "if", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "self", ".", "KITTI_velo", ",", "path", ")", ")", "and", "\n", "int", "(", "path", ")", "in", "sceneID", "\n", "]", "\n", "\n", "list_of_tracklet_anno", "=", "[", "]", "\n", "for", "scene", "in", "list_of_scene", ":", "\n", "# read the label file", "\n", "            ", "label_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "KITTI_label", ",", "scene", "+", "\".txt\"", ")", "\n", "if", "self", ".", "which_dataset", ".", "upper", "(", ")", "==", "'NUSCENES'", ":", "\n", "                ", "df", "=", "pd", ".", "read_csv", "(", "\n", "label_file", ",", "\n", "sep", "=", "' '", ",", "\n", "names", "=", "[", "\n", "\"frame\"", ",", "\"track_id\"", ",", "\"type\"", ",", "\"truncated\"", ",", "\"occluded\"", ",", "\n", "\"alpha\"", ",", "\"bbox_left\"", ",", "\"bbox_top\"", ",", "\"bbox_right\"", ",", "\n", "\"bbox_bottom\"", ",", "\"height\"", ",", "\"width\"", ",", "\"length\"", ",", "\"x\"", ",", "\"y\"", ",", "\"z\"", ",", "\n", "\"rotation_y\"", ",", "\"score\"", ",", "'num_lidar_pts'", ",", "'is_key_frame'", "\n", "]", ")", "\n", "", "else", ":", "\n", "                ", "df", "=", "pd", ".", "read_csv", "(", "\n", "label_file", ",", "\n", "sep", "=", "' '", ",", "\n", "names", "=", "[", "\n", "\"frame\"", ",", "\"track_id\"", ",", "\"type\"", ",", "\"truncated\"", ",", "\"occluded\"", ",", "\n", "\"alpha\"", ",", "\"bbox_left\"", ",", "\"bbox_top\"", ",", "\"bbox_right\"", ",", "\n", "\"bbox_bottom\"", ",", "\"height\"", ",", "\"width\"", ",", "\"length\"", ",", "\"x\"", ",", "\"y\"", ",", "\"z\"", ",", "\n", "\"rotation_y\"", ",", "\"score\"", "\n", "]", ")", "\n", "\n", "", "df", "=", "df", "[", "df", "[", "\"type\"", "]", "==", "category_name", "]", "\n", "# insert the scene dim", "\n", "df", ".", "insert", "(", "loc", "=", "0", ",", "column", "=", "\"scene\"", ",", "value", "=", "scene", ")", "\n", "for", "track_id", "in", "df", ".", "track_id", ".", "unique", "(", ")", ":", "\n", "                ", "df_tracklet", "=", "df", "[", "df", "[", "\"track_id\"", "]", "==", "track_id", "]", "\n", "df_tracklet", "=", "df_tracklet", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "tracklet_anno", "=", "[", "anno", "for", "index", ",", "anno", "in", "df_tracklet", ".", "iterrows", "(", ")", "]", "\n", "list_of_tracklet_anno", ".", "append", "(", "tracklet_anno", ")", "\n", "\n", "", "", "return", "list_of_tracklet_anno", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.read_calib_file": [[108, 127], ["open", "f.readlines", "line.split", "values[].find", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "numpy.array", "numpy.array", "numpy.array", "float", "float", "float"], "methods", ["None"], ["", "def", "read_calib_file", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "\"\"\"Read in a calibration file and parse into a dictionary.\"\"\"", "\n", "data", "=", "{", "}", "\n", "with", "open", "(", "filepath", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "values", "=", "line", ".", "split", "(", ")", "\n", "\n", "try", ":", "\n", "                    ", "ind", "=", "values", "[", "0", "]", ".", "find", "(", "':'", ")", "\n", "if", "ind", "!=", "-", "1", ":", "\n", "                        ", "data", "[", "values", "[", "0", "]", "[", ":", "ind", "]", "]", "=", "np", ".", "array", "(", "\n", "[", "float", "(", "x", ")", "for", "x", "in", "values", "[", "1", ":", "]", "]", ")", ".", "reshape", "(", "3", ",", "4", ")", "\n", "", "else", ":", "\n", "                        ", "data", "[", "values", "[", "0", "]", "]", "=", "np", ".", "array", "(", "\n", "[", "float", "(", "x", ")", "for", "x", "in", "values", "[", "1", ":", "]", "]", ")", ".", "reshape", "(", "3", ",", "4", ")", "\n", "", "", "except", "ValueError", ":", "\n", "                    ", "data", "[", "values", "[", "0", "]", "]", "=", "np", ".", "array", "(", "\n", "[", "float", "(", "x", ")", "for", "x", "in", "values", "[", "1", ":", "]", "]", ")", ".", "reshape", "(", "3", ",", "3", ")", "\n", "", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getBBandPC": [[128, 135], ["os.path.join", "base_dataset.kittiDataset.read_calib_file", "numpy.vstack", "base_dataset.kittiDataset.getPCandBBfromPandas", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.read_calib_file", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getPCandBBfromPandas"], ["", "def", "getBBandPC", "(", "self", ",", "anno", ")", ":", "\n", "        ", "calib_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "KITTI_calib", ",", "anno", "[", "'scene'", "]", "+", "\".txt\"", ")", "\n", "calib", "=", "self", ".", "read_calib_file", "(", "calib_path", ")", "\n", "# get the Tr_velo_cam matrix, which transforms the point cloud from the velo coordinate system to the cam coordinate system", "\n", "transf_mat", "=", "np", ".", "vstack", "(", "(", "calib", "[", "\"Tr_velo_cam\"", "]", ",", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "1", "]", ")", ")", ")", "# 3*4 --> 4*4", "\n", "PC", ",", "bbox", "=", "self", ".", "getPCandBBfromPandas", "(", "anno", ",", "transf_mat", ")", "\n", "return", "PC", ",", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getPCandBBfromPandas": [[136, 152], ["utils.data_classes.BoundingBox", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "os.path.join", "utils.data_classes.PointCloud", "utils.data_classes.PointCloud.transform", "utils.data_classes.PointCloud", "numpy.fromfile().reshape", "numpy.array", "numpy.fromfile"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.transform"], ["", "def", "getPCandBBfromPandas", "(", "self", ",", "box", ",", "calib", ")", ":", "\n", "        ", "center", "=", "[", "box", "[", "\"x\"", "]", ",", "box", "[", "\"y\"", "]", "-", "box", "[", "\"height\"", "]", "/", "2", ",", "box", "[", "\"z\"", "]", "]", "\n", "size", "=", "[", "box", "[", "\"width\"", "]", ",", "box", "[", "\"length\"", "]", ",", "box", "[", "\"height\"", "]", "]", "\n", "orientation", "=", "Quaternion", "(", "axis", "=", "[", "0", ",", "1", ",", "0", "]", ",", "radians", "=", "box", "[", "\"rotation_y\"", "]", ")", "*", "Quaternion", "(", "axis", "=", "[", "1", ",", "0", ",", "0", "]", ",", "radians", "=", "np", ".", "pi", "/", "2", ")", "\n", "BB", "=", "BoundingBox", "(", "center", ",", "size", ",", "orientation", ")", "\n", "\n", "try", ":", "\n", "# VELODYNE PointCloud", "\n", "            ", "velodyne_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "KITTI_velo", ",", "box", "[", "\"scene\"", "]", ",", "f'{box[\"frame\"]:06}.bin'", ")", "\n", "PC", "=", "PointCloud", "(", "np", ".", "fromfile", "(", "velodyne_path", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", ".", "T", ")", "\n", "# use calib(Tr_velo_cam matrix) rotate from the velo coordinate system to the cam coordinate system", "\n", "PC", ".", "transform", "(", "calib", ")", "\n", "", "except", ":", "\n", "            ", "PC", "=", "PointCloud", "(", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", "]", ")", ".", "T", ")", "\n", "\n", "", "return", "PC", ",", "BB", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.load_data": [[153, 158], ["open", "pickle.load", "open.close"], "methods", ["None"], ["", "def", "load_data", "(", "self", ",", "path", ")", ":", "\n", "        ", "file", "=", "open", "(", "path", ",", "\"rb\"", ")", "\n", "data", "=", "pickle", ".", "load", "(", "file", ")", "\n", "file", ".", "close", "(", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.save_data": [[159, 163], ["open", "pickle.dump", "open.close"], "methods", ["None"], ["", "def", "save_data", "(", "self", ",", "path", ",", "data", ")", ":", "\n", "        ", "file", "=", "open", "(", "path", ",", "\"wb\"", ")", "\n", "pickle", ".", "dump", "(", "data", ",", "file", ")", "\n", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.BaseDataset.__init__": [[165, 187], ["numpy.zeros", "numpy.ones", "base_dataset.kittiDataset", "base_dataset.BaseDataset.dataset.getSceneID", "base_dataset.BaseDataset.dataset.getListOfAnno"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getSceneID", "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.kittiDataset.getListOfAnno"], ["    ", "def", "__init__", "(", "self", ",", "which_dataset", ",", "path", ",", "split", ",", "category_name", "=", "\"Car\"", ",", "offset_BB", "=", "np", ".", "zeros", "(", "1", ")", ",", "scale_BB", "=", "np", ".", "ones", "(", "1", ")", ")", ":", "\n", "\n", "        ", "self", ".", "dataset", "=", "kittiDataset", "(", "path", "=", "path", ",", "which_dataset", "=", "which_dataset", ")", "\n", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "category_name", "=", "category_name", "\n", "\n", "self", ".", "getBBandPC", "=", "self", ".", "dataset", ".", "getBBandPC", "\n", "\n", "self", ".", "sceneID", "=", "self", ".", "dataset", ".", "getSceneID", "(", "split", "=", "split", ")", "\n", "\n", "'''every anno include:\n        \"sceneID\", \"frame\", \"track_id\", \"type\", \n        \"truncated\", \"occluded\", \"alpha\", \n        \"bbox_left\", \"bbox_top\", \"bbox_right\", \"bbox_bottom\", \n        \"height\", \"width\", \"length\", \"x\", \"y\", \"z\", \"rotation_y\"\n        '''", "\n", "# list, every object is a tracklet anno", "\n", "self", ".", "list_of_tracklet_anno", "=", "self", ".", "dataset", ".", "getListOfAnno", "(", "self", ".", "sceneID", ",", "category_name", ")", "\n", "self", ".", "list_of_anno", "=", "[", "\n", "anno", "for", "tracklet_anno", "in", "self", ".", "list_of_tracklet_anno", "\n", "for", "anno", "in", "tracklet_anno", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.BaseDataset.isTiny": [[189, 191], ["base_dataset.BaseDataset.split.upper"], "methods", ["None"], ["", "def", "isTiny", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"TINY\"", "in", "self", ".", "split", ".", "upper", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.datasets.base_dataset.BaseDataset.__getitem__": [[192, 194], ["base_dataset.BaseDataset.getitem"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset.getitem"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "getitem", "(", "index", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.trainers.trainer.train_model": [[9, 76], ["utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "model.train", "tqdm.tqdm", "enumerate", "torch.cuda.synchronize", "model", "utils.loss.utils._sigmoid", "optimizer.zero_grad", "total_loss.backward", "optimizer.step", "torch.cuda.synchronize", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "t.set_description", "len", "torch.autograd.Variable().to", "total_loss.item", "data.items", "loss_reg_completion.item", "loss_reg_hm.item", "loss_reg_loc.item", "loss_reg_z.item", "torch.autograd.Variable"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._sigmoid", "home.repos.pwc.inspect_result.fpthink_v2b.functional.voxelization.fAvgVoxelization.backward", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update"], ["def", "train_model", "(", "opts", ",", "model", ",", "train_dataloder", ",", "optimizer", ",", "criternions", ",", "epoch", ")", ":", "\n", "# total loss", "\n", "    ", "losses_total", "=", "AverageMeter", "(", ")", "\n", "# regression loss", "\n", "losses_reg_completion", "=", "AverageMeter", "(", ")", "\n", "losses_reg_hm", "=", "AverageMeter", "(", ")", "\n", "losses_reg_loc", "=", "AverageMeter", "(", ")", "\n", "losses_reg_z", "=", "AverageMeter", "(", ")", "\n", "\n", "# train model", "\n", "model", ".", "train", "(", ")", "\n", "\n", "with", "tqdm", "(", "enumerate", "(", "train_dataloder", ")", ",", "total", "=", "len", "(", "train_dataloder", ")", ",", "ncols", "=", "opts", ".", "ncols", ")", "as", "t", ":", "\n", "        ", "for", "i", ",", "data", "in", "t", ":", "\n", "# 1. get inputs", "\n", "# data : {", "\n", "#     'completion_pc':    completion_PC,", "\n", "#     'template_pc':      templates_PC,", "\n", "#     'search_pc':        target_PC,", "\n", "#     'heat_map':         hot_map,", "\n", "#     'index_center':     index_center,", "\n", "#     'z_axis':           z_axis,", "\n", "#     'index_offsets':    index_offsets,", "\n", "#     'local_offsets':    local_offsets,", "\n", "# }", "\n", "            ", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "data", "=", "{", "key", ":", "Variable", "(", "value", ",", "requires_grad", "=", "False", ")", ".", "to", "(", "opts", ".", "device", ")", "for", "key", ",", "value", "in", "data", ".", "items", "(", ")", "}", "\n", "\n", "completion_points", ",", "pred_hm", ",", "pred_loc", ",", "pred_z_axis", "=", "model", "(", "data", "[", "'template_pc'", "]", ",", "data", "[", "'search_pc'", "]", ")", "\n", "pred_hm", "=", "_sigmoid", "(", "pred_hm", ")", "\n", "\n", "# 3. calculate loss", "\n", "loss_reg_completion", "=", "criternions", "[", "'completion'", "]", "(", "completion_points", ",", "data", "[", "'completion_pc'", "]", ",", "None", ")", "\n", "loss_reg_hm", "=", "criternions", "[", "'hm'", "]", "(", "pred_hm", ",", "data", "[", "'heat_map'", "]", ")", "\n", "loss_reg_loc", "=", "criternions", "[", "'loc'", "]", "(", "pred_loc", ",", "data", "[", "'index_offsets'", "]", ",", "data", "[", "'local_offsets'", "]", ")", "\n", "loss_reg_z", "=", "criternions", "[", "'z_axis'", "]", "(", "pred_z_axis", ",", "data", "[", "'index_center'", "]", ",", "data", "[", "'z_axis'", "]", ")", "\n", "# total loss", "\n", "total_loss", "=", "1e-6", "*", "loss_reg_completion", "+", "1.0", "*", "loss_reg_hm", "+", "1.0", "*", "loss_reg_loc", "+", "2.0", "*", "loss_reg_z", "\n", "\n", "# 4. calculate gradient and do SGD step", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "total_loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "torch", ".", "cuda", ".", "synchronize", "(", ")", "\n", "\n", "# 5. update infomation", "\n", "# 5.1 update training error", "\n", "# regression loss", "\n", "losses_reg_completion", ".", "update", "(", "1e-3", "*", "loss_reg_completion", ".", "item", "(", ")", ")", "\n", "losses_reg_hm", ".", "update", "(", "1.0", "*", "loss_reg_hm", ".", "item", "(", ")", ")", "\n", "losses_reg_loc", ".", "update", "(", "1.0", "*", "loss_reg_loc", ".", "item", "(", ")", ")", "\n", "losses_reg_z", ".", "update", "(", "2.0", "*", "loss_reg_z", ".", "item", "(", ")", ")", "\n", "# total loss", "\n", "losses_total", ".", "update", "(", "total_loss", ".", "item", "(", ")", ")", "\n", "\n", "lr", "=", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "\n", "t", ".", "set_description", "(", "f'Train {epoch}: '", "\n", "f'Loss:{losses_total.avg:.3f} '", "\n", "f'Reg:({losses_reg_hm.avg:.4f}, '", "\n", "f'{losses_reg_loc.avg:.4f}, '", "\n", "f'{losses_reg_z.avg:.3f}), '", "\n", "f'comp:{losses_reg_completion.avg:.3f}, '", "\n", "f'lr:{1000*lr:.3f} '", "\n", ")", "\n", "\n", "", "", "return", "losses_total", ".", "avg", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.trainers.trainer.valid_model": [[77, 127], ["utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "model.eval", "tqdm.tqdm", "enumerate", "torch.no_grad", "time.time", "len", "model", "utils.loss.utils._sigmoid", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "utils.metrics.AverageMeter.update", "t.set_description", "torch.autograd.Variable().to", "total_loss.item", "data.items", "loss_reg_completion.item", "loss_reg_hm.item", "loss_reg_loc.item", "loss_reg_z.item", "torch.autograd.Variable"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.loss.utils._sigmoid", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update"], ["", "def", "valid_model", "(", "opts", ",", "model", ",", "valid_dataloder", ",", "criternions", ",", "epoch", ")", ":", "\n", "# total loss", "\n", "    ", "losses_total", "=", "AverageMeter", "(", ")", "\n", "# regression loss", "\n", "losses_reg_completion", "=", "AverageMeter", "(", ")", "\n", "losses_reg_hm", "=", "AverageMeter", "(", ")", "\n", "losses_reg_loc", "=", "AverageMeter", "(", ")", "\n", "losses_reg_z", "=", "AverageMeter", "(", ")", "\n", "\n", "# evaluate model", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "with", "tqdm", "(", "enumerate", "(", "valid_dataloder", ")", ",", "total", "=", "len", "(", "valid_dataloder", ")", ",", "ncols", "=", "opts", ".", "ncols", ")", "as", "t", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "end", "=", "time", ".", "time", "(", ")", "\n", "for", "i", ",", "data", "in", "t", ":", "\n", "# 1. get inputs", "\n", "                ", "data", "=", "{", "key", ":", "Variable", "(", "value", ",", "requires_grad", "=", "False", ")", ".", "to", "(", "opts", ".", "device", ")", "for", "key", ",", "value", "in", "data", ".", "items", "(", ")", "}", "\n", "\n", "# 2. calculate outputs", "\n", "completion_points", ",", "pred_hm", ",", "pred_loc", ",", "pred_z_axis", "=", "model", "(", "data", "[", "'template_pc'", "]", ",", "data", "[", "'search_pc'", "]", ")", "\n", "pred_hm", "=", "_sigmoid", "(", "pred_hm", ")", "\n", "\n", "# 3. calculate loss", "\n", "loss_reg_completion", "=", "criternions", "[", "'completion'", "]", "(", "completion_points", ",", "data", "[", "'completion_pc'", "]", ",", "None", ")", "\n", "loss_reg_hm", "=", "criternions", "[", "'hm'", "]", "(", "pred_hm", ",", "data", "[", "'heat_map'", "]", ")", "\n", "loss_reg_loc", "=", "criternions", "[", "'loc'", "]", "(", "pred_loc", ",", "data", "[", "'index_offsets'", "]", ",", "data", "[", "'local_offsets'", "]", ")", "\n", "loss_reg_z", "=", "criternions", "[", "'z_axis'", "]", "(", "pred_z_axis", ",", "data", "[", "'index_center'", "]", ",", "data", "[", "'z_axis'", "]", ")", "\n", "# total loss", "\n", "total_loss", "=", "1e-6", "*", "loss_reg_completion", "+", "1.0", "*", "loss_reg_hm", "+", "1.0", "*", "loss_reg_loc", "+", "2.0", "*", "loss_reg_z", "\n", "\n", "# 4. update infomation", "\n", "# 4.1 update training error", "\n", "# regression loss", "\n", "losses_reg_completion", ".", "update", "(", "1e-3", "*", "loss_reg_completion", ".", "item", "(", ")", ")", "\n", "losses_reg_hm", ".", "update", "(", "1.0", "*", "loss_reg_hm", ".", "item", "(", ")", ")", "\n", "losses_reg_loc", ".", "update", "(", "1.0", "*", "loss_reg_loc", ".", "item", "(", ")", ")", "\n", "losses_reg_z", ".", "update", "(", "2.0", "*", "loss_reg_z", ".", "item", "(", ")", ")", "\n", "# total loss", "\n", "losses_total", ".", "update", "(", "total_loss", ".", "item", "(", ")", ")", "\n", "\n", "t", ".", "set_description", "(", "f'Test  {epoch}: '", "\n", "f'Loss:{losses_total.avg:.3f} '", "\n", "f'Reg:({losses_reg_hm.avg:.4f}, '", "\n", "f'{losses_reg_loc.avg:.4f}, '", "\n", "f'{losses_reg_z.avg:.3f}), '", "\n", "f'comp:{losses_reg_completion.avg:.3f}, '", "\n", ")", "\n", "\n", "", "", "", "return", "losses_total", ".", "avg", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.trainers.tester.test_model_kitti_format": [[12, 185], ["utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.AverageMeter", "utils.metrics.Success", "utils.metrics.Precision", "utils.metrics.Success", "utils.metrics.Precision", "utils.metrics.Success", "utils.metrics.Precision", "utils.metrics.Success", "utils.metrics.Precision", "numpy.array().reshape", "model.eval", "time.time", "enumerate", "numpy.array", "len", "enumerate", "len", "utils.metrics.Success.reset", "utils.metrics.Precision.reset", "utils.metrics.Success.reset", "utils.metrics.Precision.reset", "utils.metrics.estimateOverlap", "utils.metrics.estimateAccuracy", "utils.metrics.Success.add_overlap", "utils.metrics.Precision.add_accuracy", "utils.metrics.Success.add_overlap", "utils.metrics.Precision.add_accuracy", "utils.metrics.AverageMeter.update", "time.time", "print", "print", "open", "pickle.dump", "open.close", "results_BBs.append", "utils.kitti_utils.cropAndCenterPC", "utils.kitti_utils.getModel", "numpy.array", "utils.kitti_utils.subsamplePC", "utils.kitti_utils.subsamplePC", "utils.metrics.AverageMeter.update", "time.time", "model", "utils.metrics.AverageMeter.update", "time.time", "utils.decode.mot_decode.squeeze().detach().cpu().numpy", "utils.kitti_utils.getOffsetBBtest", "results_BBs.append", "utils.metrics.Success.add_overlap", "utils.metrics.Precision.add_accuracy", "utils.metrics.Success.add_overlap", "utils.metrics.Precision.add_accuracy", "visual_data[].append", "visual_data[].append", "visual_data[].append", "opts.reference_BB.upper", "kitti_utils.subsamplePC.unsqueeze().cuda", "kitti_utils.subsamplePC.unsqueeze().cuda", "torch.no_grad", "pred_hm.sigmoid_", "utils.decode.mot_decode", "time.time", "BBs[].corners", "results_BBs[].corners", "dataset.which_dataset.lower", "dataset.category_name.lower", "opts.reference_BB.upper", "time.time", "time.time", "utils.decode.mot_decode.squeeze().detach().cpu", "kitti_utils.subsamplePC.unsqueeze", "kitti_utils.subsamplePC.unsqueeze", "utils.decode.mot_decode.squeeze().detach", "utils.decode.mot_decode.squeeze", "len", "len"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset", "home.repos.pwc.inspect_result.fpthink_v2b.panoptic.panoptic_seg_evaluator.PanopticEval.reset", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.estimateOverlap", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.estimateAccuracy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.add_overlap", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.add_accuracy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.add_overlap", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.add_accuracy", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropAndCenterPC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getModel", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.subsamplePC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.subsamplePC", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.lidarseg.utils.ConfusionMatrix.update", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getOffsetBBtest", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.add_overlap", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.add_accuracy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.add_overlap", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.add_accuracy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.decode.mot_decode", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners", "home.repos.pwc.inspect_result.fpthink_v2b.utils.data_classes.BoundingBox.corners"], ["def", "test_model_kitti_format", "(", "opts", ",", "model", ",", "dataloder", ",", "total_lenth", ")", ":", "\n", "    ", "opts", ".", "sparse_interval", "\n", "# Defining statistical objects", "\n", "batch_time", "=", "AverageMeter", "(", ")", "# \u6a21\u578b\u524d\u5411\u4f20\u64ad\u65f6\u95f4", "\n", "data_time", "=", "AverageMeter", "(", ")", "# \u6570\u636e\u51c6\u5907\u65f6\u95f4", "\n", "post_process_time", "=", "AverageMeter", "(", ")", "# \u540e\u7eed\u5904\u7406\u65f6\u95f4", "\n", "\n", "Success_main", "=", "Success", "(", ")", "\n", "Precision_main", "=", "Precision", "(", ")", "\n", "Success_batch", "=", "Success", "(", ")", "\n", "Precision_batch", "=", "Precision", "(", ")", "\n", "Success_key_main", "=", "Success", "(", ")", "\n", "Precision_key_main", "=", "Precision", "(", ")", "\n", "Success_key_batch", "=", "Success", "(", ")", "\n", "Precision_key_batch", "=", "Precision", "(", ")", "\n", "\n", "cur_lenth", "=", "0", "\n", "\n", "area_extents", "=", "np", ".", "array", "(", "opts", ".", "area_extents", ")", ".", "reshape", "(", "3", ",", "2", ")", "\n", "\n", "# Switch to evaluate mode", "\n", "dataset", "=", "dataloder", ".", "dataset", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "\n", "tracklet_nums", "=", "0", "\n", "track_anno_nums", "=", "0", "\n", "key_track_anno_nums", "=", "0", "\n", "\n", "# with tqdm(enumerate(dataloder), total=len(dataloder.dataset.list_of_anno)) as t:", "\n", "for", "batch_id", ",", "batch", "in", "enumerate", "(", "dataloder", ")", ":", "\n", "# For each tracklet, do the tracking test", "\n", "        ", "for", "PCs", ",", "BBs", ",", "list_of_anno", "in", "batch", ":", "\n", "            ", "results_BBs", "=", "[", "]", "\n", "if", "dataset", ".", "which_dataset", "==", "'NUSCENES'", ":", "\n", "                ", "if", "list_of_anno", "[", "0", "]", "[", "'num_lidar_pts'", "]", "==", "0", ":", "\n", "                    ", "break", "\n", "", "", "this_key_track_anno_nums", "=", "0", "\n", "track_anno_nums", "+=", "len", "(", "PCs", ")", "\n", "tracklet_nums", "+=", "1", "\n", "\n", "visual_data", "=", "{", "\n", "'pointcloud'", ":", "[", "]", ",", "\n", "'gt_box'", ":", "[", "]", ",", "\n", "'pred_box'", ":", "[", "]", "\n", "}", "\n", "\n", "for", "i", ",", "_", "in", "enumerate", "(", "PCs", ")", ":", "\n", "                ", "this_anno", "=", "list_of_anno", "[", "i", "]", "\n", "this_BB", "=", "BBs", "[", "i", "]", "\n", "this_PC", "=", "PCs", "[", "i", "]", "\n", "if", "dataset", ".", "which_dataset", "==", "'NUSCENES'", "and", "this_anno", "[", "'is_key_frame'", "]", "==", "1", ":", "\n", "                    ", "key_track_anno_nums", "+=", "1", "\n", "this_key_track_anno_nums", "+=", "1", "\n", "\n", "# step 1. Initial frame", "\n", "", "if", "i", "==", "0", ":", "\n", "# the first frame of current tracklet, we can get the grount truth bounding box", "\n", "                    ", "results_BBs", ".", "append", "(", "BBs", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "# others frame, we need use our model to predict the bounding box", "\n", "                    ", "cur_PC", "=", "PCs", "[", "i", "]", "\n", "\n", "# step 2. Get the previoud/reference bounding box", "\n", "if", "(", "\"previous_result\"", ".", "upper", "(", ")", "in", "opts", ".", "reference_BB", ".", "upper", "(", ")", ")", ":", "\n", "                        ", "pre_BB", "=", "results_BBs", "[", "-", "1", "]", "\n", "", "elif", "(", "\"previous_gt\"", ".", "upper", "(", ")", "in", "opts", ".", "reference_BB", ".", "upper", "(", ")", ")", ":", "\n", "                        ", "pre_BB", "=", "BBs", "[", "i", "-", "1", "]", "\n", "", "else", ":", "\n", "                        ", "pre_BB", "=", "BBs", "[", "i", "]", "\n", "\n", "# step 3. Get the point cloud", "\n", "", "target_PC", "=", "kitti_utils", ".", "cropAndCenterPC", "(", "cur_PC", ",", "pre_BB", ",", "offset", "=", "dataset", ".", "offset_BB", ",", "scale", "=", "1.25", ",", "limit_area", "=", "area_extents", ")", "# (3, N2)", "\n", "model_PC", "=", "kitti_utils", ".", "getModel", "(", "[", "PCs", "[", "0", "]", ",", "PCs", "[", "i", "-", "1", "]", "]", ",", "[", "results_BBs", "[", "0", "]", ",", "results_BBs", "[", "i", "-", "1", "]", "]", ",", "scale", "=", "1.25", ")", "\n", "# step 3.1 translate to numpy", "\n", "target_PC", "=", "target_PC", ".", "points", "# (3, N2)", "\n", "model_PC", "=", "np", ".", "array", "(", "model_PC", ".", "points", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# step 3.2 subsample", "\n", "target_PC", "=", "kitti_utils", ".", "subsamplePC", "(", "target_PC", ",", "dataset", ".", "subsample_number", ")", "# (M  , 3), tensor", "\n", "model_PC", "=", "kitti_utils", ".", "subsamplePC", "(", "model_PC", ",", "dataset", ".", "subsample_number", "//", "2", ")", "# (M/2, 3), tensor", "\n", "\n", "data_time", ".", "update", "(", "time", ".", "time", "(", ")", "-", "end", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "\n", "# step 4. Regression", "\n", "completion_points", ",", "pred_hm", ",", "pred_loc", ",", "pred_z_axis", "=", "model", "(", "model_PC", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ",", "\n", "target_PC", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ")", "\n", "\n", "batch_time", ".", "update", "(", "time", ".", "time", "(", ")", "-", "end", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "\n", "# step 5. Get current bounding box", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "hm", "=", "pred_hm", ".", "sigmoid_", "(", ")", "\n", "xy_img_z_ry", "=", "mot_decode", "(", "hm", ",", "pred_loc", ",", "pred_z_axis", ",", "K", "=", "1", ")", "\n", "\n", "", "xy_img_z_ry_cpu", "=", "xy_img_z_ry", ".", "squeeze", "(", "0", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "xy_img_z_ry_cpu", "[", ":", ",", ":", "2", "]", "=", "(", "xy_img_z_ry_cpu", "[", ":", ",", ":", "2", "]", "+", "dataset", ".", "min_img_coord", ")", "*", "dataset", ".", "xy_size", "\n", "estimate_box", "=", "xy_img_z_ry_cpu", "[", "0", "]", "\n", "\n", "box", "=", "kitti_utils", ".", "getOffsetBBtest", "(", "pre_BB", ",", "estimate_box", "[", ":", "4", "]", ")", "\n", "results_BBs", ".", "append", "(", "box", ")", "\n", "\n", "# step 6. Estimate overlap/accuracy for current sample", "\n", "# the BBs[i] is gournd truth box, and the results_BBs[-1] is model predict box", "\n", "", "this_overlap", "=", "estimateOverlap", "(", "BBs", "[", "i", "]", ",", "results_BBs", "[", "-", "1", "]", ",", "dim", "=", "opts", ".", "IoU_Space", ")", "\n", "this_accuracy", "=", "estimateAccuracy", "(", "BBs", "[", "i", "]", ",", "results_BBs", "[", "-", "1", "]", ",", "dim", "=", "opts", ".", "IoU_Space", ")", "\n", "\n", "Success_main", ".", "add_overlap", "(", "this_overlap", ")", "\n", "Precision_main", ".", "add_accuracy", "(", "this_accuracy", ")", "\n", "Success_batch", ".", "add_overlap", "(", "this_overlap", ")", "\n", "Precision_batch", ".", "add_accuracy", "(", "this_accuracy", ")", "\n", "if", "dataset", ".", "which_dataset", "==", "'NUSCENES'", "and", "this_anno", "[", "'is_key_frame'", "]", "==", "1", ":", "\n", "                    ", "Success_key_main", ".", "add_overlap", "(", "this_overlap", ")", "\n", "Precision_key_main", ".", "add_accuracy", "(", "this_accuracy", ")", "\n", "Success_key_batch", ".", "add_overlap", "(", "this_overlap", ")", "\n", "Precision_key_batch", ".", "add_accuracy", "(", "this_accuracy", ")", "\n", "\n", "# measure elapsed time", "\n", "", "post_process_time", ".", "update", "(", "time", ".", "time", "(", ")", "-", "end", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "\n", "# for visualization", "\n", "if", "opts", ".", "visual", ":", "\n", "                    ", "visual_data", "[", "'pointcloud'", "]", ".", "append", "(", "this_PC", ".", "points", ")", "\n", "visual_data", "[", "'gt_box'", "]", ".", "append", "(", "BBs", "[", "i", "]", ".", "corners", "(", ")", ")", "\n", "visual_data", "[", "'pred_box'", "]", ".", "append", "(", "results_BBs", "[", "-", "1", "]", ".", "corners", "(", ")", ")", "\n", "\n", "", "", "cur_lenth", "+=", "len", "(", "PCs", ")", "\n", "# batch end", "\n", "if", "dataset", ".", "which_dataset", "==", "'NUSCENES'", ":", "\n", "                ", "print", "(", "'Tracklet ID {:3d}: '", ".", "format", "(", "batch_id", ")", "+", "\n", "'Length:({:3d}/{:3d}), '", ".", "format", "(", "this_key_track_anno_nums", ",", "len", "(", "PCs", ")", ")", "+", "\n", "'Data:{:4.1f}ms '", ".", "format", "(", "1000", "*", "data_time", ".", "avg", ")", "+", "\n", "'Forward:{:5.1f}ms '", ".", "format", "(", "1000", "*", "batch_time", ".", "avg", ")", "+", "\n", "'Pose:{:4.1f}ms '", ".", "format", "(", "1000", "*", "post_process_time", ".", "avg", ")", "+", "\n", "'Succ/Prec:'", "+", "\n", "'{:5.1f}/'", ".", "format", "(", "Success_key_batch", ".", "average", ")", "+", "\n", "'{:5.1f} '", ".", "format", "(", "Precision_key_batch", ".", "average", ")", "+", "\n", "'(Total:{:5.1f}/'", ".", "format", "(", "Success_key_main", ".", "average", ")", "+", "\n", "'{:5.1f}), '", ".", "format", "(", "Precision_key_main", ".", "average", ")", "+", "\n", "'Key_nums prog:({:4d}/ {:4d}), '", ".", "format", "(", "key_track_anno_nums", ",", "track_anno_nums", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "'Tracklet ID {:3d}: '", ".", "format", "(", "batch_id", ")", "+", "\n", "'Length:{:3d}, '", ".", "format", "(", "len", "(", "PCs", ")", ")", "+", "\n", "'Data:{:4.1f}ms '", ".", "format", "(", "1000", "*", "data_time", ".", "avg", ")", "+", "\n", "'Forward:{:5.1f}ms '", ".", "format", "(", "1000", "*", "batch_time", ".", "avg", ")", "+", "\n", "'Pose:{:4.1f}ms '", ".", "format", "(", "1000", "*", "post_process_time", ".", "avg", ")", "+", "\n", "'Succ/Prec:'", "+", "\n", "'{:5.1f}/'", ".", "format", "(", "Success_batch", ".", "average", ")", "+", "\n", "'{:5.1f} '", ".", "format", "(", "Precision_batch", ".", "average", ")", "+", "\n", "'(Total:{:5.1f}/'", ".", "format", "(", "Success_main", ".", "average", ")", "+", "\n", "'{:5.1f}), '", ".", "format", "(", "Precision_main", ".", "average", ")", "+", "\n", "'Prog:{:6.2f}%'", ".", "format", "(", "100", "*", "cur_lenth", "/", "total_lenth", ")", "\n", ")", "\n", "\n", "# for visualization", "\n", "", "if", "opts", ".", "visual", ":", "\n", "                ", "save_path", "=", "\"visualization/data/%s_%s_%d.pth\"", "%", "(", "dataset", ".", "which_dataset", ".", "lower", "(", ")", ",", "dataset", ".", "category_name", ".", "lower", "(", ")", ",", "batch_id", ")", "\n", "file", "=", "open", "(", "save_path", ",", "\"wb\"", ")", "\n", "pickle", ".", "dump", "(", "visual_data", ",", "file", ")", "\n", "file", ".", "close", "(", ")", "\n", "\n", "# batch reset", "\n", "", "Success_batch", ".", "reset", "(", ")", "\n", "Precision_batch", ".", "reset", "(", ")", "\n", "Success_key_batch", ".", "reset", "(", ")", "\n", "Precision_key_batch", ".", "reset", "(", ")", "\n", "", "", "if", "dataset", ".", "which_dataset", "==", "'NUSCENES'", ":", "\n", "        ", "return", "Success_key_main", ".", "average", ",", "Precision_key_main", ".", "average", "\n", "", "return", "Success_main", ".", "average", ",", "Precision_main", ".", "average", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.trainers.tester.test_model_waymo_format": [[186, 257], ["opts.xy_size.numpy", "opts.min_img_coord.numpy", "utils.metrics.Success", "utils.metrics.Precision", "numpy.array().reshape", "model.eval", "dataset.get_PCs_and_BBs", "range", "len", "utils.metrics.estimateOverlap", "utils.metrics.estimateAccuracy", "utils.metrics.Success.add_overlap", "utils.metrics.Precision.add_accuracy", "numpy.array", "results_BBs.append", "utils.kitti_utils.cropAndCenterPC", "utils.kitti_utils.getModel", "numpy.array", "utils.kitti_utils.subsamplePC", "utils.kitti_utils.subsamplePC", "model", "utils.decode.mot_decode.squeeze().detach().cpu().numpy", "utils.kitti_utils.getOffsetBBtest", "results_BBs.append", "reference_BB.upper", "kitti_utils.subsamplePC.unsqueeze().cuda", "kitti_utils.subsamplePC.unsqueeze().cuda", "torch.no_grad", "pred_hm.sigmoid_", "utils.decode.mot_decode", "reference_BB.upper", "utils.decode.mot_decode.squeeze().detach().cpu", "kitti_utils.subsamplePC.unsqueeze", "kitti_utils.subsamplePC.unsqueeze", "utils.decode.mot_decode.squeeze().detach", "utils.decode.mot_decode.squeeze"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.datasets.v2b_dataset.TestDataset_WOD.get_PCs_and_BBs", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.estimateOverlap", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.estimateAccuracy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Success.add_overlap", "home.repos.pwc.inspect_result.fpthink_v2b.utils.metrics.Precision.add_accuracy", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.cropAndCenterPC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getModel", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.subsamplePC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.subsamplePC", "home.repos.pwc.inspect_result.fpthink_v2b.utils.kitti_utils.getOffsetBBtest", "home.repos.pwc.inspect_result.fpthink_v2b.utils.decode.mot_decode"], ["", "def", "test_model_waymo_format", "(", "opts", ",", "model", ",", "dataset", ")", ":", "\n", "    ", "reference_BB", "=", "opts", ".", "reference_BB", "\n", "IoU_Space", "=", "opts", ".", "IoU_Space", "\n", "subsample_number", "=", "opts", ".", "subsample_number", "\n", "offset_BB", "=", "opts", ".", "offset_BB", "\n", "\n", "area_extents", "=", "opts", ".", "area_extents", "\n", "xy_size", "=", "opts", ".", "xy_size", ".", "numpy", "(", ")", "\n", "min_img_coord", "=", "opts", ".", "min_img_coord", ".", "numpy", "(", ")", "\n", "\n", "Success_main", "=", "Success", "(", ")", "\n", "Precision_main", "=", "Precision", "(", ")", "\n", "\n", "area_extents", "=", "np", ".", "array", "(", "area_extents", ")", ".", "reshape", "(", "3", ",", "2", ")", "\n", "\n", "# Switch to evaluate mode", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "PCs", ",", "BBs", "=", "dataset", ".", "get_PCs_and_BBs", "(", ")", "\n", "results_BBs", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "PCs", ")", ")", ":", "\n", "        ", "if", "i", "==", "0", ":", "\n", "# the first frame of current tracklet, we can get the grount truth bounding box", "\n", "            ", "results_BBs", ".", "append", "(", "BBs", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "# others frame, we need use our model to predict the bounding box", "\n", "            ", "cur_PC", "=", "PCs", "[", "i", "]", "# current  frame's point cloud, (3, n2)", "\n", "\n", "# step 2. Get the previoud/reference bounding box", "\n", "if", "(", "\"previous_result\"", ".", "upper", "(", ")", "in", "reference_BB", ".", "upper", "(", ")", ")", ":", "\n", "                ", "pre_BB", "=", "results_BBs", "[", "-", "1", "]", "\n", "", "elif", "(", "\"previous_gt\"", ".", "upper", "(", ")", "in", "reference_BB", ".", "upper", "(", ")", ")", ":", "\n", "                ", "pre_BB", "=", "BBs", "[", "i", "-", "1", "]", "\n", "", "else", ":", "\n", "                ", "pre_BB", "=", "BBs", "[", "i", "]", "\n", "\n", "# step 3. Get the point cloud", "\n", "", "target_PC", "=", "kitti_utils", ".", "cropAndCenterPC", "(", "cur_PC", ",", "pre_BB", ",", "offset", "=", "offset_BB", ",", "scale", "=", "1.25", ",", "limit_area", "=", "area_extents", ")", "# (3, N2)", "\n", "model_PC", "=", "kitti_utils", ".", "getModel", "(", "[", "PCs", "[", "0", "]", ",", "PCs", "[", "i", "-", "1", "]", "]", ",", "[", "results_BBs", "[", "0", "]", ",", "results_BBs", "[", "i", "-", "1", "]", "]", ",", "scale", "=", "1.25", ")", "\n", "# step 3.1 translate to numpy", "\n", "target_PC", "=", "target_PC", ".", "points", "# (3, N2)", "\n", "model_PC", "=", "np", ".", "array", "(", "model_PC", ".", "points", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# step 3.2 subsample", "\n", "target_PC", "=", "kitti_utils", ".", "subsamplePC", "(", "target_PC", ",", "subsample_number", ")", "# (M  , 3), tensor", "\n", "model_PC", "=", "kitti_utils", ".", "subsamplePC", "(", "model_PC", ",", "subsample_number", "//", "2", ")", "# (M/2, 3), tensor", "\n", "\n", "# step 4. Regression", "\n", "completion_points", ",", "pred_hm", ",", "pred_loc", ",", "pred_z_axis", "=", "model", "(", "model_PC", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ",", "\n", "target_PC", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ")", "\n", "\n", "# step 5. Get current bounding box", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "hm", "=", "pred_hm", ".", "sigmoid_", "(", ")", "\n", "xy_img_z_ry", "=", "mot_decode", "(", "hm", ",", "pred_loc", ",", "pred_z_axis", ",", "K", "=", "1", ")", "\n", "\n", "", "xy_img_z_ry_cpu", "=", "xy_img_z_ry", ".", "squeeze", "(", "0", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "xy_img_z_ry_cpu", "[", ":", ",", ":", "2", "]", "=", "(", "xy_img_z_ry_cpu", "[", ":", ",", ":", "2", "]", "+", "min_img_coord", ")", "*", "xy_size", "\n", "estimate_box", "=", "xy_img_z_ry_cpu", "[", "0", "]", "\n", "\n", "box", "=", "kitti_utils", ".", "getOffsetBBtest", "(", "pre_BB", ",", "estimate_box", "[", ":", "4", "]", ")", "\n", "results_BBs", ".", "append", "(", "box", ")", "\n", "\n", "# step 6. Estimate overlap/accuracy fro current sample", "\n", "# the BBs[i] is gournd truth box, and the results_BBs[-1] is model predict box", "\n", "", "this_overlap", "=", "estimateOverlap", "(", "BBs", "[", "i", "]", ",", "results_BBs", "[", "-", "1", "]", ",", "dim", "=", "IoU_Space", ",", "dataset_type", "=", "'waymo'", ")", "\n", "this_accuracy", "=", "estimateAccuracy", "(", "BBs", "[", "i", "]", ",", "results_BBs", "[", "-", "1", "]", ",", "dim", "=", "IoU_Space", ")", "\n", "Success_main", ".", "add_overlap", "(", "this_overlap", ")", "\n", "Precision_main", ".", "add_accuracy", "(", "this_accuracy", ")", "\n", "\n", "", "return", "Success_main", ".", "average", ",", "Precision_main", ".", "average", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.v2b_net.V2B_Tracking.__init__": [[18, 65], ["torch.Module.__init__", "modules.backbone_net.Pointnet2_Backbone", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.CosineSimilarity", "torch.CosineSimilarity", "torch.CosineSimilarity", "etw_pytorch_utils.Seq().conv1d().conv1d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "etw_pytorch_utils.SharedMLP", "etw_pytorch_utils.Seq().conv1d().conv1d", "modules.completion_net.ts_up_sampling", "modules.voxel_utils.voxelization.Voxelization", "modules.voxel_utils.voxel.voxelnet.Conv_Middle_layers", "modules.voxel_utils.voxel.region_proposal_network.RPN", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "etw_pytorch_utils.Seq().conv1d", "etw_pytorch_utils.Seq().conv1d", "etw_pytorch_utils.Seq", "etw_pytorch_utils.Seq"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opts", ")", ":", "\n", "        ", "super", "(", "V2B_Tracking", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "opts", "=", "opts", "\n", "\n", "# voxel net", "\n", "self", ".", "voxel_size", "=", "opts", ".", "voxel_size", "\n", "self", ".", "voxel_area", "=", "opts", ".", "voxel_area", "\n", "self", ".", "scene_ground", "=", "opts", ".", "scene_ground", "\n", "self", ".", "min_img_coord", "=", "opts", ".", "min_img_coord", "\n", "self", ".", "xy_size", "=", "opts", ".", "xy_size", "\n", "\n", "self", ".", "mode", "=", "opts", ".", "mode", "\n", "self", ".", "feat_emb", "=", "opts", ".", "feat_emb", "\n", "\n", "self", ".", "backbone_net", "=", "Pointnet2_Backbone", "(", "opts", ".", "n_input_feats", ",", "use_xyz", "=", "opts", ".", "use_xyz", ")", "\n", "\n", "self", ".", "mask", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "64", ",", "64", ",", "kernel_size", "=", "1", ",", "bias", "=", "True", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "64", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv1d", "(", "64", ",", "1", ",", "kernel_size", "=", "1", ",", "bias", "=", "True", ")", ",", "\n", "nn", ".", "Sigmoid", "(", ")", "\n", ")", "\n", "self", ".", "cosine", "=", "nn", ".", "CosineSimilarity", "(", "dim", "=", "1", ")", "\n", "\n", "self", ".", "mlp", "=", "(", "\n", "pt_utils", ".", "Seq", "(", "4", "+", "32", "+", "32", ")", "\n", ".", "conv1d", "(", "32", ",", "bn", "=", "True", ")", "\n", ".", "conv1d", "(", "32", ",", "bn", "=", "True", ")", ")", "\n", "self", ".", "global_weight", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "32", ",", "32", ",", "kernel_size", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "True", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "32", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "32", ",", "32", ",", "kernel_size", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "True", ")", ",", "\n", "nn", ".", "Sigmoid", "(", ")", "\n", ")", "\n", "self", ".", "global_mlp", "=", "pt_utils", ".", "SharedMLP", "(", "[", "3", "+", "32", ",", "32", ",", "32", "]", ",", "bn", "=", "True", ")", "\n", "self", ".", "fea_layer", "=", "(", "pt_utils", ".", "Seq", "(", "64", ")", "\n", ".", "conv1d", "(", "64", ",", "bn", "=", "True", ")", "\n", ".", "conv1d", "(", "64", ",", "activation", "=", "None", ")", ")", "\n", "\n", "self", ".", "completion_fc", "=", "ts_up_sampling", "(", "input_c", "=", "64", ",", "mid_c", "=", "32", ")", "\n", "\n", "self", ".", "voxelize", "=", "Voxelization", "(", "self", ".", "voxel_area", "[", "0", "]", ",", "self", ".", "voxel_area", "[", "1", "]", ",", "self", ".", "voxel_area", "[", "2", "]", ",", "\n", "scene_ground", "=", "self", ".", "scene_ground", ",", "mode", "=", "opts", ".", "mode", ",", "voxel_size", "=", "self", ".", "voxel_size", ")", "\n", "self", ".", "cml", "=", "Conv_Middle_layers", "(", "inplanes", "=", "3", "+", "64", ")", "\n", "self", ".", "RPN", "=", "RPN", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.v2b_net.V2B_Tracking.xcorr": [[66, 94], ["x_object.size", "x_object.size", "x_object.size", "x_label.size", "v2b_net.V2B_Tracking.cosine", "v2b_net.V2B_Tracking.detach", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.argmax().expand", "torch.argmax().expand", "torch.argmax().expand", "torch.argmax().expand", "torch.argmax().expand", "torch.argmax().expand", "torch.argmax().expand", "torch.argmax().expand", "torch.argmax().expand", "torch.cat.gather", "torch.cat.gather", "torch.cat.gather", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "max_cla.squeeze.squeeze.squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "v2b_net.V2B_Tracking.mlp", "v2b_net.V2B_Tracking.global_weight", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "v2b_net.V2B_Tracking.global_mlp", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "global_feature.squeeze.squeeze.squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "v2b_net.V2B_Tracking.fea_layer", "x_object.unsqueeze().expand", "x_label.unsqueeze().expand", "torch.cat.size", "torch.cat.size", "torch.cat.size", "v2b_net.V2B_Tracking.unsqueeze", "x_label.unsqueeze().expand", "x_object.unsqueeze().expand", "x_object.unsqueeze().expand", "template_xyz.transpose().contiguous", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "template_xyz.transpose().contiguous().unsqueeze().expand", "x_object.unsqueeze", "x_label.unsqueeze", "v2b_net.V2B_Tracking.size", "x_label.unsqueeze", "x_object.unsqueeze", "x_object.unsqueeze", "global_feature.squeeze.squeeze.size", "template_xyz.transpose", "template_xyz.transpose().contiguous().unsqueeze", "template_xyz.transpose().contiguous", "template_xyz.transpose"], "methods", ["None"], ["", "def", "xcorr", "(", "self", ",", "x_label", ",", "x_object", ",", "template_xyz", ")", ":", "\n", "\n", "        ", "B", "=", "x_object", ".", "size", "(", "0", ")", "\n", "f", "=", "x_object", ".", "size", "(", "1", ")", "\n", "n1", "=", "x_object", ".", "size", "(", "2", ")", "\n", "n2", "=", "x_label", ".", "size", "(", "2", ")", "\n", "final_out_cla", "=", "self", ".", "cosine", "(", "x_object", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "B", ",", "f", ",", "n1", ",", "n2", ")", ",", "x_label", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "B", ",", "f", ",", "n1", ",", "n2", ")", ")", "\n", "final_out_cla_de", "=", "final_out_cla", ".", "detach", "(", ")", "\n", "template_xyz_fea", "=", "torch", ".", "cat", "(", "(", "template_xyz", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ",", "x_object", ")", ",", "dim", "=", "1", ")", "\n", "max_ind", "=", "torch", ".", "argmax", "(", "final_out_cla_de", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ".", "expand", "(", "-", "1", ",", "template_xyz_fea", ".", "size", "(", "1", ")", ",", "-", "1", ")", "\n", "\n", "template_fea", "=", "template_xyz_fea", ".", "gather", "(", "dim", "=", "2", ",", "index", "=", "max_ind", ")", "\n", "max_cla", "=", "F", ".", "max_pool2d", "(", "final_out_cla", ".", "unsqueeze", "(", "dim", "=", "1", ")", ",", "kernel_size", "=", "[", "final_out_cla", ".", "size", "(", "1", ")", ",", "1", "]", ")", "\n", "max_cla", "=", "max_cla", ".", "squeeze", "(", "2", ")", "\n", "fusion_feature", "=", "torch", ".", "cat", "(", "(", "max_cla", ",", "template_fea", ",", "x_label", ")", ",", "dim", "=", "1", ")", "\n", "fusion_feature", "=", "self", ".", "mlp", "(", "fusion_feature", ")", "\n", "\n", "diff_fea", "=", "x_label", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "B", ",", "f", ",", "n1", ",", "n2", ")", "-", "x_object", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "B", ",", "f", ",", "n1", ",", "n2", ")", "\n", "global_weight", "=", "self", ".", "global_weight", "(", "diff_fea", ")", "\n", "global_feature", "=", "(", "global_weight", "*", "x_object", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "B", ",", "f", ",", "n1", ",", "n2", ")", ")", "\n", "global_feature", "=", "torch", ".", "cat", "(", "(", "template_xyz", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "B", ",", "3", ",", "n1", ",", "n2", ")", ",", "global_feature", ")", ",", "dim", "=", "1", ")", "\n", "global_feature", "=", "self", ".", "global_mlp", "(", "global_feature", ")", "\n", "global_feature", "=", "F", ".", "max_pool2d", "(", "global_feature", ",", "kernel_size", "=", "[", "global_feature", ".", "size", "(", "2", ")", ",", "1", "]", ")", "\n", "global_feature", "=", "global_feature", ".", "squeeze", "(", "2", ")", "\n", "fusion_feature", "=", "torch", ".", "cat", "(", "(", "fusion_feature", ",", "global_feature", ")", ",", "dim", "=", "1", ")", "\n", "fusion_feature", "=", "self", ".", "fea_layer", "(", "fusion_feature", ")", "\n", "\n", "return", "fusion_feature", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.v2b_net.V2B_Tracking.forward": [[95, 124], ["v2b_net.V2B_Tracking.backbone_net", "v2b_net.V2B_Tracking.backbone_net", "v2b_net.V2B_Tracking.xcorr", "v2b_net.V2B_Tracking.mask", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "v2b_net.V2B_Tracking.voxelize", "voxel_features.permute().contiguous.permute().contiguous.permute().contiguous", "v2b_net.V2B_Tracking.cml", "v2b_net.V2B_Tracking.RPN", "v2b_net.V2B_Tracking.completion_fc", "completion_points.unsqueeze.unsqueeze.unsqueeze", "search_xyz.transpose().contiguous", "voxel_features.permute().contiguous.permute().contiguous.permute", "search_xyz.transpose"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.modules.v2b_net.V2B_Tracking.xcorr", "home.repos.pwc.inspect_result.fpthink_v2b.utils.map_mask.MapMask.mask", "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.voxelize"], ["", "def", "forward", "(", "self", ",", "template", ",", "search", ")", ":", "\n", "        ", "r\"\"\"\n            template: B*512*3 or B*512*6\n            search: B*1024*3 or B*1024*6\n        \"\"\"", "\n", "template_xyz", ",", "template_feature", "=", "self", ".", "backbone_net", "(", "template", ",", "[", "256", ",", "128", ",", "64", "]", ")", "\n", "\n", "search_xyz", ",", "search_feature", "=", "self", ".", "backbone_net", "(", "search", ",", "[", "512", ",", "256", ",", "128", "]", ")", "\n", "\n", "fusion_feature", "=", "self", ".", "xcorr", "(", "search_feature", ",", "template_feature", ",", "template_xyz", ")", "\n", "\n", "#b 1 1024", "\n", "search_mask", "=", "self", ".", "mask", "(", "fusion_feature", ")", "\n", "\n", "if", "self", ".", "mode", ":", "\n", "            ", "weighted_fusion_feature", "=", "search_mask", "*", "fusion_feature", "\n", "completion_points", "=", "self", ".", "completion_fc", "(", "weighted_fusion_feature", ")", "\n", "completion_points", "=", "completion_points", ".", "unsqueeze", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "completion_points", "=", "None", "\n", "\n", "", "fusion_xyz_feature", "=", "torch", ".", "cat", "(", "(", "search_xyz", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ",", "fusion_feature", ")", ",", "dim", "=", "1", ")", "\n", "voxel_features", "=", "self", ".", "voxelize", "(", "fusion_xyz_feature", ",", "search_xyz", ")", "\n", "voxel_features", "=", "voxel_features", ".", "permute", "(", "0", ",", "1", ",", "4", ",", "3", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "cml_out", "=", "self", ".", "cml", "(", "voxel_features", ")", "\n", "# (b,1,36,56),(b,3,36,56),(b,3,36,56),(b,1,36,56),(b,3x1024,9)", "\n", "pred_hm", ",", "pred_loc", ",", "pred_z_axis", "=", "self", ".", "RPN", "(", "cml_out", ")", "\n", "\n", "return", "completion_points", ",", "pred_hm", ",", "pred_loc", ",", "pred_z_axis", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.completion_net.ts_up_sampling.__init__": [[40, 54], ["torch.Module.__init__", "etw_pytorch_utils.Seq().conv1d", "etw_pytorch_utils.Seq().conv1d", "etw_pytorch_utils.SharedMLP", "etw_pytorch_utils.Seq().conv1d().conv1d", "etw_pytorch_utils.Seq().conv1d().conv1d", "etw_pytorch_utils.Seq", "etw_pytorch_utils.Seq", "etw_pytorch_utils.Seq().conv1d", "etw_pytorch_utils.Seq().conv1d", "etw_pytorch_utils.Seq", "etw_pytorch_utils.Seq"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_c", "=", "128", ",", "mid_c", "=", "64", ")", ":", "\n", "        ", "super", "(", "ts_up_sampling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_c", "=", "input_c", "\n", "self", ".", "duplate", "=", "(", "pt_utils", ".", "Seq", "(", "input_c", ")", "\n", ".", "conv1d", "(", "2", "*", "input_c", ",", "bn", "=", "True", ")", ")", "\n", "self", ".", "c1", "=", "(", "pt_utils", ".", "Seq", "(", "input_c", ")", "\n", ".", "conv1d", "(", "mid_c", ",", "bn", "=", "True", ")", ")", "\n", "self", ".", "c2", "=", "pt_utils", ".", "SharedMLP", "(", "[", "input_c", ",", "mid_c", ",", "mid_c", ",", "mid_c", "]", ",", "bn", "=", "True", ")", "\n", "self", ".", "c3", "=", "(", "pt_utils", ".", "Seq", "(", "mid_c", ")", "\n", ".", "conv1d", "(", "input_c", ",", "bn", "=", "True", ")", "\n", ".", "conv1d", "(", "input_c", ",", "bn", "=", "True", ")", ")", "\n", "self", ".", "c4", "=", "(", "pt_utils", ".", "Seq", "(", "input_c", "+", "mid_c", ")", "\n", ".", "conv1d", "(", "2", "*", "input_c", ")", "\n", ".", "conv1d", "(", "3", ",", "activation", "=", "None", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.completion_net.ts_up_sampling.forward": [[55, 76], ["search_keypoint.size", "search_keypoint.size", "completion_net.ts_up_sampling.duplate", "torch.max_pool2d.view", "torch.max_pool2d.view", "completion_net.ts_up_sampling.c1", "torch.max_pool1d", "torch.max_pool1d", "torch.max_pool1d", "completion_net.get_graph_feature", "completion_net.ts_up_sampling.c2", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "completion_net.ts_up_sampling.c3", "torch.max_pool2d.squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "completion_net.ts_up_sampling.c4", "int", "completion_net.ts_up_sampling.expand", "torch.max_pool2d.size", "F.max_pool2d.squeeze.size"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.modules.completion_net.get_graph_feature"], ["", "def", "forward", "(", "self", ",", "search_keypoint", ")", ":", "\n", "        ", "B", "=", "search_keypoint", ".", "size", "(", "0", ")", "\n", "N", "=", "search_keypoint", ".", "size", "(", "2", ")", "\n", "\n", "up_sampling_fea", "=", "self", ".", "duplate", "(", "search_keypoint", ")", "\n", "up_sampling_fea", "=", "up_sampling_fea", ".", "view", "(", "B", ",", "self", ".", "input_c", ",", "int", "(", "2048", "/", "N", ")", ",", "N", ")", "\n", "up_sampling_fea", "=", "up_sampling_fea", ".", "view", "(", "B", ",", "self", ".", "input_c", ",", "-", "1", ")", "\n", "up_sampling_fea", "=", "self", ".", "c1", "(", "up_sampling_fea", ")", "\n", "#b c 1", "\n", "global_fea", "=", "F", ".", "max_pool1d", "(", "up_sampling_fea", ",", "kernel_size", "=", "2048", ")", "\n", "#b 2c N K", "\n", "up_sampling_fea", "=", "get_graph_feature", "(", "up_sampling_fea", ",", "k", "=", "4", ")", "\n", "up_sampling_fea", "=", "self", ".", "c2", "(", "up_sampling_fea", ")", "\n", "up_sampling_fea", "=", "F", ".", "max_pool2d", "(", "up_sampling_fea", ",", "kernel_size", "=", "[", "1", ",", "up_sampling_fea", ".", "size", "(", "3", ")", "]", ")", "\n", "\n", "global_fea", "=", "self", ".", "c3", "(", "global_fea", ")", "\n", "#b c N", "\n", "local_fea", "=", "up_sampling_fea", ".", "squeeze", "(", "-", "1", ")", "\n", "final_fea", "=", "torch", ".", "cat", "(", "(", "local_fea", ",", "global_fea", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "local_fea", ".", "size", "(", "2", ")", ")", ")", ",", "dim", "=", "1", ")", "\n", "points_coord", "=", "self", ".", "c4", "(", "final_fea", ")", "\n", "return", "points_coord", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.completion_net.knn": [[6, 13], ["torch.sum", "torch.sum", "torch.sum", "torch.matmul", "torch.matmul", "torch.matmul", "torch.sum.transpose", "pairwise_distance.topk", "x.transpose"], "function", ["None"], ["def", "knn", "(", "x", ",", "k", ")", ":", "\n", "    ", "inner", "=", "-", "2", "*", "torch", ".", "matmul", "(", "x", ".", "transpose", "(", "2", ",", "1", ")", ",", "x", ")", "\n", "xx", "=", "torch", ".", "sum", "(", "x", "**", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "pairwise_distance", "=", "-", "xx", "-", "inner", "-", "xx", ".", "transpose", "(", "2", ",", "1", ")", "\n", "\n", "idx", "=", "pairwise_distance", ".", "topk", "(", "k", "=", "k", ",", "dim", "=", "-", "1", ")", "[", "1", "]", "# (batch_size, num_points, k)", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.completion_net.get_graph_feature": [[14, 38], ["x.view().repeat.size", "x.view().repeat.size", "x.view().repeat.view", "torch.device", "torch.device", "torch.device", "knn.view", "x.view().repeat.size", "x.view().repeat.transpose().contiguous", "torch.cat().permute().contiguous.view", "x.view().repeat.view().repeat", "torch.cat().permute().contiguous", "torch.cat().permute().contiguous", "torch.cat().permute().contiguous", "completion_net.knn", "torch.arange().view", "torch.arange().view", "torch.arange().view", "x.view().repeat.view", "x.view().repeat.transpose", "x.view().repeat.view", "torch.cat().permute", "torch.cat().permute", "torch.cat().permute", "torch.arange", "torch.arange", "torch.arange", "torch.cat", "torch.cat", "torch.cat"], "function", ["home.repos.pwc.inspect_result.fpthink_v2b.modules.completion_net.knn"], ["", "def", "get_graph_feature", "(", "x", ",", "k", "=", "20", ",", "idx", "=", "None", ")", ":", "\n", "    ", "batch_size", "=", "x", ".", "size", "(", "0", ")", "\n", "num_points", "=", "x", ".", "size", "(", "2", ")", "\n", "x", "=", "x", ".", "view", "(", "batch_size", ",", "-", "1", ",", "num_points", ")", "\n", "if", "idx", "is", "None", ":", "\n", "        ", "idx", "=", "knn", "(", "x", ",", "k", "=", "k", ")", "# (batch_size, num_points, k)", "\n", "", "device", "=", "torch", ".", "device", "(", "'cuda'", ")", "\n", "\n", "idx_base", "=", "torch", ".", "arange", "(", "0", ",", "batch_size", ",", "device", "=", "device", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", "*", "num_points", "\n", "\n", "idx", "=", "idx", "+", "idx_base", "\n", "\n", "idx", "=", "idx", ".", "view", "(", "-", "1", ")", "\n", "\n", "_", ",", "num_dims", ",", "_", "=", "x", ".", "size", "(", ")", "\n", "\n", "x", "=", "x", ".", "transpose", "(", "2", ",", "1", ")", ".", "contiguous", "(", ")", "# (batch_size, num_points, num_dims)  -> (batch_size*num_points, num_dims) #   batch_size * num_points * k + range(0, batch_size*num_points)", "\n", "feature", "=", "x", ".", "view", "(", "batch_size", "*", "num_points", ",", "-", "1", ")", "[", "idx", ",", ":", "]", "\n", "feature", "=", "feature", ".", "view", "(", "batch_size", ",", "num_points", ",", "k", ",", "num_dims", ")", "\n", "x", "=", "x", ".", "view", "(", "batch_size", ",", "num_points", ",", "1", ",", "num_dims", ")", ".", "repeat", "(", "1", ",", "1", ",", "k", ",", "1", ")", "\n", "\n", "feature", "=", "torch", ".", "cat", "(", "(", "feature", "-", "x", ",", "x", ")", ",", "dim", "=", "3", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "\n", "return", "feature", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.backbone_net.Pointnet2_Backbone.__init__": [[21, 58], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "backbone_net.Pointnet2_Backbone.SA_modules.append", "backbone_net.Pointnet2_Backbone.SA_modules.append", "backbone_net.Pointnet2_Backbone.SA_modules.append", "torch.ModuleList", "torch.ModuleList", "backbone_net.Pointnet2_Backbone.FP_modules.append", "backbone_net.Pointnet2_Backbone.FP_modules.append", "backbone_net.Pointnet2_Backbone.FP_modules.append", "torch.Conv1d", "torch.Conv1d", "modules.pointnet2.utils.pointnet2_modules.PointNet2SAModule", "modules.pointnet2.utils.pointnet2_modules.PointNet2SAModule", "modules.pointnet2.utils.pointnet2_modules.PointNet2SAModule", "modules.pointnet2.utils.pointnet2_modules.PointNet2FPModule", "modules.pointnet2.utils.pointnet2_modules.PointNet2FPModule", "modules.pointnet2.utils.pointnet2_modules.PointNet2FPModule"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["def", "__init__", "(", "self", ",", "input_channels", "=", "3", ",", "use_xyz", "=", "True", ")", ":", "\n", "        ", "super", "(", "Pointnet2_Backbone", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "SA_modules", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "SA_modules", ".", "append", "(", "\n", "PointNet2SAModule", "(", "\n", "radius", "=", "0.3", ",", "\n", "nsample", "=", "32", ",", "\n", "mlp", "=", "[", "input_channels", ",", "32", ",", "32", ",", "64", "]", ",", "\n", "use_xyz", "=", "use_xyz", ",", "\n", "use_edge", "=", "False", "\n", ")", "\n", ")", "\n", "self", ".", "SA_modules", ".", "append", "(", "\n", "PointNet2SAModule", "(", "\n", "radius", "=", "None", ",", "#0.5", "\n", "nsample", "=", "48", ",", "\n", "mlp", "=", "[", "64", ",", "64", ",", "64", ",", "128", "]", ",", "\n", "use_xyz", "=", "use_xyz", ",", "\n", "use_edge", "=", "False", "\n", ")", "\n", ")", "\n", "self", ".", "SA_modules", ".", "append", "(", "\n", "PointNet2SAModule", "(", "\n", "radius", "=", "None", ",", "#0.7", "\n", "nsample", "=", "48", ",", "\n", "mlp", "=", "[", "128", ",", "128", ",", "128", ",", "128", "]", ",", "\n", "use_xyz", "=", "use_xyz", ",", "\n", "use_edge", "=", "False", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "FP_modules", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "FP_modules", ".", "append", "(", "PointNet2FPModule", "(", "mlp", "=", "[", "64", ",", "32", ",", "32", "]", ")", ")", "\n", "self", ".", "FP_modules", ".", "append", "(", "PointNet2FPModule", "(", "mlp", "=", "[", "192", ",", "128", ",", "64", "]", ")", ")", "\n", "self", ".", "FP_modules", ".", "append", "(", "PointNet2FPModule", "(", "mlp", "=", "[", "256", ",", "128", ",", "128", "]", ")", ")", "\n", "self", ".", "cov_final", "=", "nn", ".", "Conv1d", "(", "32", ",", "32", ",", "kernel_size", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.backbone_net.Pointnet2_Backbone._break_up_pc": [[60, 65], ["pc[].contiguous", "pc[].transpose().contiguous", "pc.size", "pc[].transpose"], "methods", ["None"], ["", "def", "_break_up_pc", "(", "self", ",", "pc", ")", ":", "\n", "        ", "xyz", "=", "pc", "[", "...", ",", "0", ":", "3", "]", ".", "contiguous", "(", ")", "\n", "features", "=", "pc", "[", "...", ",", "3", ":", "]", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "if", "pc", ".", "size", "(", "-", "1", ")", ">", "3", "else", "None", "\n", "\n", "return", "xyz", ",", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.modules.backbone_net.Pointnet2_Backbone.forward": [[66, 91], ["backbone_net.Pointnet2_Backbone._break_up_pc", "range", "len", "l_xyz.append", "l_features.append", "backbone_net.Pointnet2_Backbone.cov_final"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.modules.backbone_net.Pointnet2_Backbone._break_up_pc"], ["", "def", "forward", "(", "self", ",", "pointcloud", ",", "numpoints", ")", ":", "\n", "# type: (Pointnet2SSG, torch.cuda.FloatTensor) -> pt_utils.Seq", "\n", "        ", "r\"\"\"\n            Forward pass of the network\n\n            Parameters\n            ----------\n            pointcloud: Variable(torch.cuda.FloatTensor)\n                (B, N, 3 + input_channels) tensor\n                Point cloud to run predicts on\n                Each point in the point-cloud MUST\n                be formated as (x, y, z, features...)\n        \"\"\"", "\n", "xyz", ",", "features", "=", "self", ".", "_break_up_pc", "(", "pointcloud", ")", "\n", "\n", "l_xyz", ",", "l_features", "=", "[", "xyz", "]", ",", "[", "features", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "SA_modules", ")", ")", ":", "\n", "            ", "li_xyz", ",", "li_features", "=", "self", ".", "SA_modules", "[", "i", "]", "(", "l_xyz", "[", "i", "]", ",", "l_features", "[", "i", "]", ",", "numpoints", "[", "i", "]", ")", "\n", "l_xyz", ".", "append", "(", "li_xyz", ")", "\n", "l_features", ".", "append", "(", "li_features", ")", "\n", "\n", "", "for", "i", "in", "[", "2", ",", "1", ",", "0", "]", ":", "\n", "            ", "l_features", "[", "i", "]", "=", "self", ".", "FP_modules", "[", "i", "]", "(", "l_xyz", "[", "i", "]", ",", "l_xyz", "[", "i", "+", "1", "]", ",", "l_features", "[", "i", "]", ",", "l_features", "[", "i", "+", "1", "]", ")", "\n", "\n", "", "return", "l_xyz", "[", "0", "]", ",", "self", ".", "cov_final", "(", "l_features", "[", "0", "]", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel_utils.se.SE3d.__init__": [[7, 14], ["torch.Module.__init__", "torch.Sequential", "torch.Linear", "torch.ReLU", "torch.Linear", "torch.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "channel", ",", "reduction", "=", "8", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "channel", ",", "channel", "//", "reduction", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "channel", "//", "reduction", ",", "channel", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "Sigmoid", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel_utils.se.SE3d.forward": [[16, 18], ["se.SE3d.fc().view", "se.SE3d.fc", "inputs.mean().mean().mean", "inputs.mean().mean", "inputs.mean"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "return", "inputs", "*", "self", ".", "fc", "(", "inputs", ".", "mean", "(", "-", "1", ")", ".", "mean", "(", "-", "1", ")", ".", "mean", "(", "-", "1", ")", ")", ".", "view", "(", "inputs", ".", "shape", "[", "0", "]", ",", "inputs", ".", "shape", "[", "1", "]", ",", "1", ",", "1", ",", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel_utils.voxelization.Voxelization.__init__": [[9, 19], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.Module.__init__", "int", "int", "int", "torch.floor", "torch.floor", "torch.floor", "torch.floor"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "x", ",", "y", ",", "z", ",", "scene_ground", "=", "torch", ".", "tensor", "(", "[", "-", "5.6", ",", "-", "3.6", ",", "-", "2.4", "]", ")", ",", "voxel_size", "=", "torch", ".", "tensor", "(", "[", "0.3", ",", "0.3", ",", "0.2", "]", ")", ",", "mode", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "x", "=", "int", "(", "x", ")", "\n", "self", ".", "y", "=", "int", "(", "y", ")", "\n", "self", ".", "z", "=", "int", "(", "z", ")", "\n", "self", ".", "scene_ground", "=", "scene_ground", "\n", "self", ".", "voxel_size", "=", "voxel_size", "\n", "self", ".", "min_voxel_coord", "=", "torch", ".", "floor", "(", "self", ".", "scene_ground", "/", "self", ".", "voxel_size", ")", "\n", "self", ".", "resolution", "=", "(", "-", "2", "*", "self", ".", "min_voxel_coord", ")", ".", "int", "(", ")", "\n", "self", ".", "mode", "=", "mode", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel_utils.voxelization.Voxelization.forward": [[20, 30], ["coords.detach", "torch.floor", "torch.floor", "torch.floor", "torch.floor", "voxel_indices.transpose().contiguous.transpose().contiguous.transpose().contiguous", "modules.voxel_utils.functional.voxelization.favg_voxelize", "modules.voxel_utils.functional.voxelization.avg_voxelize", "voxelization.Voxelization.voxel_size.cuda", "voxel_indices.transpose().contiguous.transpose().contiguous.transpose", "voxelization.Voxelization.min_voxel_coord.cuda"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ",", "coords", ")", ":", "\n", "#(b,c,n)(b,n,3)", "\n", "        ", "coords_detach", "=", "coords", ".", "detach", "(", ")", "\n", "discrete_pts", "=", "torch", ".", "floor", "(", "coords_detach", "/", "self", ".", "voxel_size", ".", "cuda", "(", ")", ")", "\n", "voxel_indices", "=", "(", "discrete_pts", "-", "self", ".", "min_voxel_coord", ".", "cuda", "(", ")", ")", ".", "int", "(", ")", "\n", "voxel_indices", "=", "voxel_indices", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "if", "self", ".", "mode", ":", "\n", "            ", "return", "favg_voxelize", "(", "features", ",", "voxel_indices", ",", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "z", ")", "\n", "", "else", ":", "\n", "            ", "return", "avg_voxelize", "(", "features", ",", "voxel_indices", ",", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel_utils.voxelization.Voxelization.extra_repr": [[31, 33], ["print"], "methods", ["None"], ["", "", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "print", "(", "'information:x {} y {} z {} min_voxel_coord {} voxel_size {} '", ".", "format", "(", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "z", ",", "self", ".", "min_voxel_coord", ",", "self", ".", "voxel_size", ")", ")", "\n", "# if __name__ == '__main__':", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.__init__": [[22, 32], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "voxel_size", "=", "0.0", "\n", "self", ".", "min_voxel_coord", "=", "[", "]", "\n", "self", ".", "max_voxel_coord", "=", "[", "]", "\n", "self", ".", "num_divisions", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "\n", "self", ".", "points", "=", "[", "]", "\n", "self", ".", "voxel_indices", "=", "[", "]", "\n", "self", ".", "leaf_layout", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.voxelize": [[33, 151], ["numpy.floor().astype", "numpy.lexsort", "voxel_grid.VoxelGrid.points.astype", "numpy.ascontiguousarray().view", "numpy.unique", "unique_indices.sort", "numpy.diff", "numpy.append", "numpy.dtype", "numpy.array().transpose", "numpy.floor", "numpy.amin", "numpy.amax", "numpy.zeros", "enumerate", "numpy.floor", "numpy.ascontiguousarray", "ValueError", "numpy.ceil", "print", "ValueError", "print", "ValueError", "zip", "numpy.ones", "numpy.array", "numpy.amin", "numpy.amax", "numpy.mean", "numpy.random.choice", "numpy.mean", "voxel_grid.VoxelGrid.num_divisions.astype", "numpy.amin", "numpy.amax"], "methods", ["None"], ["", "def", "voxelize", "(", "self", ",", "pts", ",", "voxel_size", ",", "extents", "=", "None", ",", "create_leaf_layout", "=", "True", ",", "num_T", "=", "35", ")", ":", "\n", "        ", "\"\"\"\n        The input for the voxelization is expected to be a PointCloud\n        with N points in 4 dimension (x,y,z,i). Voxel size is the quantization size\n        for the voxel grid.\n\n        :param pts: Point cloud as N x [x, y, z, i]\n        :param voxel_size: Quantization size for the grid, vd, vh, vw\n        :param extents: Optional, specifies the full extents of the point cloud.\n                        Used for creating same sized voxel grids.\n        :param create_leaf_layout: Set this to False to create an empty leaf_layout,\n                                   which will save computation time.\n        :param num_T: Number of points voxel after sampling                           \n        \"\"\"", "\n", "# Check if points are 3D, otherwise early exit", "\n", "# if pts.shape[1] != 4 or pts.shape[1] != 3:", "\n", "#     raise ValueError(\"Points have the wrong shape: {}\".format(pts.shape))", "\n", "\n", "self", ".", "voxel_size", "=", "voxel_size", "\n", "\n", "# Discretize voxel coordinates to given quantization size", "\n", "discrete_pts", "=", "np", ".", "floor", "(", "pts", "[", ":", ",", ":", "3", "]", "/", "voxel_size", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "# Use Lex Sort, sort by x, then y, then z \u7f51\u683c\u4ece\u6700\u5c0f\u503c\u5f00\u59cb", "\n", "x_col", "=", "discrete_pts", "[", ":", ",", "0", "]", "\n", "y_col", "=", "discrete_pts", "[", ":", ",", "1", "]", "\n", "z_col", "=", "discrete_pts", "[", ":", ",", "2", "]", "\n", "sorted_order", "=", "np", ".", "lexsort", "(", "(", "z_col", ",", "y_col", ",", "x_col", ")", ")", "\n", "\n", "# Save original points in sorted order", "\n", "self", ".", "points", "=", "pts", "[", "sorted_order", "]", "\n", "self", ".", "points", "=", "self", ".", "points", ".", "astype", "(", "np", ".", "float32", ")", "\n", "discrete_pts", "=", "discrete_pts", "[", "sorted_order", "]", "\n", "\n", "# Format the array to c-contiguous array for unique function", "\n", "contiguous_array", "=", "np", ".", "ascontiguousarray", "(", "discrete_pts", ")", ".", "view", "(", "\n", "np", ".", "dtype", "(", "(", "np", ".", "void", ",", "discrete_pts", ".", "dtype", ".", "itemsize", "*", "discrete_pts", ".", "shape", "[", "1", "]", ")", ")", ")", "\n", "\n", "# The new coordinates are the discretized array with its unique indexes", "\n", "_", ",", "unique_indices", "=", "np", ".", "unique", "(", "contiguous_array", ",", "return_index", "=", "True", ")", "\n", "\n", "# Sort unique indices to preserve order", "\n", "unique_indices", ".", "sort", "(", ")", "\n", "self", ".", "unique_indices", "=", "unique_indices", "\n", "\n", "voxel_coords", "=", "discrete_pts", "[", "unique_indices", "]", "\n", "\n", "# Number of points per voxel, last voxel calculated separately", "\n", "num_points_in_voxel", "=", "np", ".", "diff", "(", "unique_indices", ")", "\n", "num_points_in_voxel", "=", "np", ".", "append", "(", "num_points_in_voxel", ",", "\n", "discrete_pts", ".", "shape", "[", "0", "]", "-", "\n", "unique_indices", "[", "-", "1", "]", ")", "\n", "self", ".", "num_pts_in_voxel", "=", "num_points_in_voxel", "\n", "\n", "# Find the minimum and maximum voxel coordinates", "\n", "if", "extents", "is", "not", "None", ":", "\n", "# Check provided extents", "\n", "            ", "extents_transpose", "=", "np", ".", "array", "(", "extents", ")", ".", "transpose", "(", ")", "\n", "if", "extents_transpose", ".", "shape", "!=", "(", "2", ",", "3", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"Extents are the wrong shape {}\"", ".", "format", "(", "extents", ".", "shape", ")", ")", "\n", "# extents_transpose = calib.project_velo_to_rect(extents_transpose)", "\n", "\n", "# Set voxel grid extents", "\n", "", "self", ".", "min_voxel_coord", "=", "np", ".", "floor", "(", "extents_transpose", "[", "0", "]", "/", "voxel_size", ")", "\n", "self", ".", "max_voxel_coord", "=", "np", ".", "ceil", "(", "extents_transpose", "[", "1", "]", "/", "voxel_size", ")", "-", "1", "\n", "# print(self.min_voxel_coord, self.max_voxel_coord)", "\n", "# Check that points are bounded by new extents", "\n", "if", "not", "(", "self", ".", "min_voxel_coord", "<=", "np", ".", "amin", "(", "voxel_coords", ",", "axis", "=", "0", ")", ")", ".", "all", "(", ")", ":", "\n", "                ", "print", "(", "np", ".", "amin", "(", "voxel_coords", ",", "axis", "=", "0", ")", ")", "\n", "raise", "ValueError", "(", "\"Extents are smaller than min_voxel_coord\"", ")", "\n", "", "if", "not", "(", "self", ".", "max_voxel_coord", ">=", "np", ".", "amax", "(", "voxel_coords", ",", "axis", "=", "0", ")", ")", ".", "all", "(", ")", ":", "\n", "                ", "print", "(", "np", ".", "amax", "(", "voxel_coords", ",", "axis", "=", "0", ")", ")", "\n", "raise", "ValueError", "(", "\"Extents are smaller than max_voxel_coord\"", ")", "\n", "", "", "else", ":", "\n", "# Automatically calculate extents", "\n", "            ", "self", ".", "min_voxel_coord", "=", "np", ".", "amin", "(", "voxel_coords", ",", "axis", "=", "0", ")", "\n", "self", ".", "max_voxel_coord", "=", "np", ".", "amax", "(", "voxel_coords", ",", "axis", "=", "0", ")", "\n", "\n", "# Get the voxel grid dimensions", "\n", "", "self", ".", "num_divisions", "=", "(", "(", "self", ".", "max_voxel_coord", "-", "self", ".", "min_voxel_coord", ")", "+", "1", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "# self.num_divisions.shape", "\n", "\n", "# Bring the min voxel to the origin", "\n", "self", ".", "voxel_indices", "=", "(", "voxel_coords", "-", "self", ".", "min_voxel_coord", ")", ".", "astype", "(", "int", ")", "\n", "\n", "if", "create_leaf_layout", ":", "\n", "# padded_voxel_points = np.zeros([unique_indices.shape[0], num_T, pts.shape[1]], dtype=np.float32)", "\n", "# for i, v in enumerate(zip(unique_indices, num_points_in_voxel)):", "\n", "#     if v[1]<num_T:", "\n", "#         padded_voxel_points[i,:v[1],:] = self.points[v[0]:v[0]+v[1], :]", "\n", "#     else:", "\n", "#         inds = np.random.choice(v[1], num_T)", "\n", "#         padded_voxel_points[i, :, :] = self.points[v[0]+inds, :]", "\n", "\n", "            ", "padded_voxel_points", "=", "np", ".", "zeros", "(", "[", "unique_indices", ".", "shape", "[", "0", "]", ",", "num_T", ",", "pts", ".", "shape", "[", "1", "]", "+", "3", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", ",", "v", "in", "enumerate", "(", "zip", "(", "unique_indices", ",", "num_points_in_voxel", ")", ")", ":", "\n", "                ", "if", "v", "[", "1", "]", "<", "num_T", ":", "\n", "                    ", "padded_voxel_points", "[", "i", ",", ":", "v", "[", "1", "]", ",", ":", "3", "]", "=", "self", ".", "points", "[", "v", "[", "0", "]", ":", "v", "[", "0", "]", "+", "v", "[", "1", "]", ",", ":", "]", "\n", "middle_points", "=", "np", ".", "mean", "(", "self", ".", "points", "[", "v", "[", "0", "]", ":", "v", "[", "0", "]", "+", "v", "[", "1", "]", ",", ":", "3", "]", ",", "axis", "=", "0", ")", "\n", "padded_voxel_points", "[", "i", ",", ":", "v", "[", "1", "]", ",", "3", ":", "]", "=", "padded_voxel_points", "[", "i", ",", ":", "v", "[", "1", "]", ",", ":", "3", "]", "-", "middle_points", "\n", "", "else", ":", "\n", "                    ", "inds", "=", "np", ".", "random", ".", "choice", "(", "v", "[", "1", "]", ",", "num_T", ")", "\n", "padded_voxel_points", "[", "i", ",", ":", ",", ":", "3", "]", "=", "self", ".", "points", "[", "v", "[", "0", "]", "+", "inds", ",", ":", "]", "\n", "middle_points", "=", "np", ".", "mean", "(", "self", ".", "points", "[", "v", "[", "0", "]", "+", "inds", ",", ":", "3", "]", ",", "axis", "=", "0", ")", "\n", "padded_voxel_points", "[", "i", ",", ":", ",", "3", ":", "]", "=", "padded_voxel_points", "[", "i", ",", ":", ",", ":", "3", "]", "-", "middle_points", "\n", "\n", "\n", "", "", "self", ".", "padded_voxel_points", "=", "padded_voxel_points", "\n", "# Create Voxel Object with -1 as empty/occluded", "\n", "self", ".", "leaf_layout", "=", "self", ".", "VOXEL_EMPTY", "*", "np", ".", "ones", "(", "self", ".", "num_divisions", ".", "astype", "(", "int", ")", ")", "\n", "\n", "# Fill out the leaf layout", "\n", "self", ".", "leaf_layout", "[", "self", ".", "voxel_indices", "[", ":", ",", "0", "]", ",", "\n", "self", ".", "voxel_indices", "[", ":", ",", "1", "]", ",", "\n", "self", ".", "voxel_indices", "[", ":", ",", "2", "]", "]", "=", "self", ".", "VOXEL_FILLED", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.map_to_index": [[153, 170], ["numpy.maximum", "numpy.minimum", "len", "len", "numpy.floor"], "methods", ["None"], ["", "", "def", "map_to_index", "(", "self", ",", "map_index", ")", ":", "\n", "        ", "\"\"\" convert map coordinate values to 1-based discrectized grid index coordinate\n            Note: Any values outside the extent of the grid will be forced to be the maximum grid\n            coordinate.\n\n        :param map_index: N x 3 points\n\n        :return: N x length(dim) (grid coordinate)\n                [] if min_voxel_coord or voxel_size or grid_index or dim is not set.\n        \"\"\"", "\n", "if", "self", ".", "voxel_size", "==", "0", "or", "len", "(", "self", ".", "min_voxel_coord", ")", "==", "0", "or", "len", "(", "map_index", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "return", "np", ".", "maximum", "(", "0", ",", "np", ".", "minimum", "(", "self", ".", "num_divisions", "[", ":", "]", ",", "np", ".", "floor", "(", "map_index", "/", "self", ".", "voxel_size", ")", "\n", "-", "self", ".", "min_voxel_coord", "[", ":", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid_test.VoxelGridTest.setUpClass": [[10, 34], ["numpy.array", "numpy.floor().astype", "numpy.ones", "numpy.floor", "tuple"], "methods", ["None"], ["    ", "@", "classmethod", "\n", "def", "setUpClass", "(", "cls", ")", ":", "\n", "        ", "cls", ".", "test_points", "=", "np", ".", "array", "(", "\n", "[", "[", "-", "39.99", ",", "4.99", ",", "0", "]", ",", "\n", "[", "39.99", ",", "4.99", ",", "0", "]", ",", "\n", "[", "-", "39.99", ",", "-", "4.99", ",", "0", "]", ",", "\n", "[", "39.99", ",", "-", "4.99", ",", "0", "]", ",", "\n", "[", "-", "39.99", ",", "4.99", ",", "69.99", "]", ",", "\n", "[", "39.99", ",", "4.99", ",", "69.99", "]", ",", "\n", "[", "-", "39.99", ",", "-", "4.99", ",", "69.99", "]", ",", "\n", "[", "39.99", ",", "-", "4.99", ",", "69.99", "]", ",", "\n", "[", "-", "39.99", ",", "4.99", ",", "69.99", "]", ",", "\n", "[", "39.99", ",", "4.99", ",", "69.99", "]", ",", "\n", "[", "-", "39.99", ",", "-", "4.99", ",", "69.99", "]", ",", "\n", "[", "-", "39.99", ",", "-", "4.99", ",", "69.99", "]", ",", "\n", "[", "39.99", ",", "-", "4.99", ",", "69.99", "]", "]", ")", "\n", "\n", "# Expected leaf layout for voxelization at size 0.1", "\n", "filled_indices", "=", "np", ".", "floor", "(", "\n", "(", "cls", ".", "test_points", "*", "10", ")", "+", "[", "400", ",", "50", ",", "0", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "cls", ".", "expected_leaf_layout", "=", "VoxelGrid", ".", "VOXEL_EMPTY", "*", "np", ".", "ones", "(", "(", "800", ",", "100", ",", "700", ")", ")", "\n", "for", "idx", "in", "filled_indices", ":", "\n", "            ", "cls", ".", "expected_leaf_layout", "[", "tuple", "(", "idx", ")", "]", "=", "VoxelGrid", ".", "VOXEL_FILLED", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid_test.VoxelGridTest.test_voxelization": [[35, 58], ["lib.dataset.voxel_grid.VoxelGrid", "lib.dataset.voxel_grid.VoxelGrid.voxelize", "voxel_grid_test.VoxelGridTest.assertAlmostEqual", "voxel_grid_test.VoxelGridTest.assertTrue", "voxel_grid_test.VoxelGridTest.assertTrue", "voxel_grid_test.VoxelGridTest.assertTrue", "voxel_grid_test.VoxelGridTest.assertTrue"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.voxelize"], ["", "", "def", "test_voxelization", "(", "self", ")", ":", "\n", "\n", "        ", "voxel_grid", "=", "VoxelGrid", "(", ")", "\n", "\n", "# Test with actual data", "\n", "# voxel_grid.voxelize(self.test_points, (0.1, 0.1, 0.2))", "\n", "voxel_grid", ".", "voxelize", "(", "self", ".", "test_points", ",", "0.1", ")", "\n", "\n", "# Test Size variable", "\n", "self", ".", "assertAlmostEqual", "(", "voxel_grid", ".", "voxel_size", ",", "0.1", ")", "\n", "\n", "# Test Minimum Coordinates", "\n", "self", ".", "assertTrue", "(", "(", "voxel_grid", ".", "min_voxel_coord", "==", "[", "-", "400", ",", "-", "50", ",", "0", "]", ")", ".", "all", "(", ")", ")", "\n", "\n", "# # Test Maximum Coordinates", "\n", "self", ".", "assertTrue", "(", "(", "voxel_grid", ".", "max_voxel_coord", "==", "[", "399", ",", "49", ",", "699", "]", ")", ".", "all", "(", ")", ")", "\n", "\n", "# Test Divisions", "\n", "self", ".", "assertTrue", "(", "(", "voxel_grid", ".", "num_divisions", "==", "[", "800", ",", "100", ",", "700", "]", ")", ".", "all", "(", ")", ")", "\n", "\n", "# Test every entry of out put leafs", "\n", "self", ".", "assertTrue", "(", "\n", "(", "voxel_grid", ".", "leaf_layout", "==", "self", ".", "expected_leaf_layout", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid_test.VoxelGridTest.test_voxel_grid_extents": [[59, 82], ["lib.dataset.voxel_grid.VoxelGrid", "numpy.array", "voxel_grid_test.VoxelGridTest.assertRaises", "numpy.array", "lib.dataset.voxel_grid.VoxelGrid.voxelize", "voxel_grid_test.VoxelGridTest.assertTrue", "voxel_grid_test.VoxelGridTest.assertTrue", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.voxelize"], ["", "def", "test_voxel_grid_extents", "(", "self", ")", ":", "\n", "\n", "        ", "voxel_grid", "=", "VoxelGrid", "(", ")", "\n", "\n", "# Generate random points between xyz [[-40, 40], [-4, 4], [-30, 30]]", "\n", "points", "=", "(", "np", ".", "random", ".", "rand", "(", "70000", ",", "3", ")", "*", "[", "80", ",", "8", ",", "60", "]", ")", "-", "[", "40", ",", "4", ",", "0", "]", "\n", "\n", "# Test bad extents", "\n", "bad_extents", "=", "np", ".", "array", "(", "[", "[", "-", "30", ",", "30", "]", ",", "[", "-", "3", ",", "3", "]", ",", "[", "10", ",", "60", "]", "]", ")", "\n", "self", ".", "assertRaises", "(", "\n", "ValueError", ",", "\n", "voxel_grid", ".", "voxelize", ",", "\n", "points", ",", "\n", "0.1", ",", "\n", "bad_extents", ")", "\n", "\n", "extents", "=", "np", ".", "array", "(", "[", "[", "-", "50", ",", "50", "]", ",", "[", "-", "5", ",", "5", "]", ",", "[", "0", ",", "70", "]", "]", ")", "\n", "voxel_grid", ".", "voxelize", "(", "points", ",", "1", ",", "extents", ")", "\n", "\n", "# Check number of divisions and leaf layout shape are correct and are", "\n", "# the same", "\n", "self", ".", "assertTrue", "(", "(", "voxel_grid", ".", "num_divisions", "==", "[", "1000", ",", "100", ",", "700", "]", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "voxel_grid", ".", "leaf_layout", ".", "shape", "==", "(", "1000", ",", "100", ",", "700", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid_test.VoxelGridTest.test_voxel_coordinate_conversion": [[83, 122], ["lib.dataset.voxel_grid.VoxelGrid", "numpy.array", "lib.dataset.voxel_grid.VoxelGrid.voxelize", "numpy.array", "numpy.array", "voxel_grid_test.VoxelGridTest.assertTrue", "numpy.array", "voxel_grid_test.VoxelGridTest.assertTrue", "numpy.array", "numpy.array", "voxel_grid_test.VoxelGridTest.assertTrue", "numpy.array", "print", "numpy.array", "voxel_grid_test.VoxelGridTest.assertTrue", "numpy.array", "voxel_grid_test.VoxelGridTest.assertTrue", "numpy.array", "lib.dataset.voxel_grid.VoxelGrid.map_to_index", "numpy.random.rand", "lib.dataset.voxel_grid.VoxelGrid.map_to_index", "lib.dataset.voxel_grid.VoxelGrid.map_to_index", "lib.dataset.voxel_grid.VoxelGrid.map_to_index", "lib.dataset.voxel_grid.VoxelGrid.map_to_index", "lib.dataset.voxel_grid.VoxelGrid.map_to_index"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.voxelize", "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.map_to_index", "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.map_to_index", "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.map_to_index", "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.map_to_index", "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.map_to_index", "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxel_grid.VoxelGrid.map_to_index"], ["", "def", "test_voxel_coordinate_conversion", "(", "self", ")", ":", "\n", "        ", "voxel_grid", "=", "VoxelGrid", "(", ")", "\n", "\n", "# Generate random points between xyz [[-40, 40], [-4, 4], [-30, 30]]", "\n", "points", "=", "(", "np", ".", "random", ".", "rand", "(", "70000", ",", "3", ")", "*", "[", "80", ",", "8", ",", "60", "]", ")", "-", "[", "40", ",", "4", ",", "0", "]", "\n", "extents", "=", "np", ".", "array", "(", "[", "[", "-", "50", ",", "50", "]", ",", "[", "-", "5", ",", "5", "]", ",", "[", "0", ",", "70", "]", "]", ")", "\n", "voxel_grid", ".", "voxelize", "(", "points", ",", "0.1", ",", "extents", ")", "\n", "\n", "# Left Top Corner, z = 0", "\n", "coordinates", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "# Map spans from [-500, 500], [-50, 50], [0, 700]", "\n", "expected", "=", "np", ".", "array", "(", "[", "500", ",", "50", ",", "0", "]", ")", "\n", "self", ".", "assertTrue", "(", "\n", "(", "voxel_grid", ".", "map_to_index", "(", "coordinates", ")", "==", "expected", ")", ".", "all", "(", ")", ")", "\n", "\n", "coordinates", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", "]", ")", "+", "0.1", "\n", "# Increment of 1 grid size", "\n", "expected", "=", "np", ".", "array", "(", "[", "501", ",", "51", ",", "1", "]", ")", "\n", "self", ".", "assertTrue", "(", "\n", "(", "voxel_grid", ".", "map_to_index", "(", "coordinates", ")", "==", "expected", ")", ".", "all", "(", ")", ")", "\n", "\n", "# Start of Grid", "\n", "coordinates", "=", "np", ".", "array", "(", "[", "[", "-", "50", ",", "-", "5", ",", "0", "]", "]", ")", "\n", "expected", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "self", ".", "assertTrue", "(", "\n", "(", "voxel_grid", ".", "map_to_index", "(", "coordinates", ")", "==", "expected", ")", ".", "all", "(", ")", ")", "\n", "\n", "# End of Grid", "\n", "coordinates", "=", "np", ".", "array", "(", "[", "[", "49.9", ",", "4.9", ",", "69.9", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "print", "(", "voxel_grid", ".", "map_to_index", "(", "coordinates", ")", ")", "\n", "expected", "=", "np", ".", "array", "(", "[", "1000", ",", "100", ",", "700", "]", ")", "\n", "self", ".", "assertTrue", "(", "\n", "(", "voxel_grid", ".", "map_to_index", "(", "coordinates", ")", "==", "expected", ")", ".", "all", "(", ")", ")", "\n", "\n", "# Outside the grid", "\n", "coordinates", "=", "coordinates", "+", "10", "\n", "expected", "=", "np", ".", "array", "(", "[", "1000", ",", "100", ",", "700", "]", ")", "\n", "self", ".", "assertTrue", "(", "\n", "(", "voxel_grid", ".", "map_to_index", "(", "coordinates", ")", "==", "expected", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.block.GroupCompletion.__init__": [[4, 10], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Conv1d", "torch.Conv1d", "torch.ReLU", "torch.ReLU", "torch.Conv1d", "torch.Conv1d"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["\t", "def", "__init__", "(", "self", ",", "inplane", ")", ":", "\n", "\t\t", "super", "(", "GroupCompletion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "one", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "inplane", ",", "2", "*", "inplane", ",", "1", ",", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv1d", "(", "2", "*", "inplane", ",", "3", "*", "2048", ",", "1", ",", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.block.GroupCompletion.forward": [[13, 16], ["block.GroupCompletion.one"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\t\t", "out", "=", "self", ".", "one", "(", "x", ")", "\n", "return", "out", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.torch_util.Conv2d.__init__": [[4, 9], ["torch.Module.__init__", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", ",", "padding", ")", ":", "\n", "        ", "super", "(", "Conv2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "3", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.torch_util.Conv2d.forward": [[10, 15], ["torch_util.Conv2d.conv1", "torch_util.Conv2d.bn1", "torch_util.Conv2d.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.torch_util.Conv3d.__init__": [[17, 22], ["torch.Module.__init__", "torch.Conv3d", "torch.BatchNorm3d", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", ",", "padding", ")", ":", "\n", "        ", "super", "(", "Conv3d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv3d", "(", "inplanes", ",", "planes", ",", "3", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm3d", "(", "planes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.torch_util.Conv3d.forward": [[23, 28], ["torch_util.Conv3d.conv1", "torch_util.Conv3d.bn1", "torch_util.Conv3d.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "return", "out", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxelnet.FCN.__init__": [[11, 17], ["torch.Module.__init__", "int", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ")", ":", "\n", "        ", "super", "(", "FCN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "planes", "=", "int", "(", "planes", "/", "2", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxelnet.FCN.forward": [[18, 23], ["voxelnet.FCN.conv1", "voxelnet.FCN.bn1", "voxelnet.FCN.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxelnet.VFE.__init__": [[25, 28], ["torch.Module.__init__", "voxelnet.FCN"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ")", ":", "\n", "        ", "super", "(", "VFE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fcn1", "=", "FCN", "(", "inplanes", ",", "planes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxelnet.VFE.forward": [[29, 37], ["x.size", "voxelnet.VFE.fcn1", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "logger.debug", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "logger.debug", "torch.max_pool2d.size", "torch.max_pool2d.repeat", "torch.cat.size", "torch.cat.size", "torch.cat.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "batch", ",", "channel", ",", "voxels", ",", "num_T", "=", "x", ".", "size", "(", ")", "\n", "out", "=", "self", ".", "fcn1", "(", "x", ")", "\n", "point_wise_feature", "=", "F", ".", "max_pool2d", "(", "out", ",", "kernel_size", "=", "[", "1", ",", "num_T", "]", ",", "stride", "=", "[", "1", ",", "num_T", "]", ")", "\n", "logger", ".", "debug", "(", "'point_wise_feature size: {}'", ".", "format", "(", "point_wise_feature", ".", "size", "(", ")", ")", ")", "\n", "out", "=", "torch", ".", "cat", "(", "(", "out", ",", "point_wise_feature", ".", "repeat", "(", "1", ",", "1", ",", "1", ",", "num_T", ")", ")", ",", "1", ")", "\n", "logger", ".", "debug", "(", "'VFE size: {}'", ".", "format", "(", "out", ".", "size", "(", ")", ")", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxelnet.Conv_Middle_layers.__init__": [[39, 49], ["torch.Module.__init__", "torch_util.Conv3d", "torch_util.Conv3d", "torch_util.Conv3d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "collections.OrderedDict", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ")", ":", "\n", "        ", "super", "(", "Conv_Middle_layers", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "Conv3d", "(", "inplanes", ",", "64", ",", "stride", "=", "(", "2", ",", "1", ",", "1", ")", ",", "padding", "=", "(", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "conv2", "=", "Conv3d", "(", "64", ",", "64", ",", "stride", "=", "(", "1", ",", "1", ",", "1", ")", ",", "padding", "=", "(", "0", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "conv3", "=", "Conv3d", "(", "64", ",", "64", ",", "stride", "=", "(", "2", ",", "1", ",", "1", ")", ",", "padding", "=", "(", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "# ('conv3d',nn.Conv3d(64,128,kernel_size=(1,1,1),stride=(1,1,1),padding=(0,0,0))),", "\n", "(", "'conv3d'", ",", "nn", ".", "Conv3d", "(", "64", ",", "128", ",", "kernel_size", "=", "(", "3", ",", "1", ",", "1", ")", ",", "stride", "=", "(", "1", ",", "1", ",", "1", ")", ",", "padding", "=", "(", "0", ",", "0", ",", "0", ")", ")", ")", ",", "\n", "(", "'bn'", ",", "nn", ".", "BatchNorm3d", "(", "128", ")", ")", ",", "\n", "(", "'relu'", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.voxelnet.Conv_Middle_layers.forward": [[51, 62], ["voxelnet.Conv_Middle_layers.conv1", "voxelnet.Conv_Middle_layers.conv2", "voxelnet.Conv_Middle_layers.conv3", "voxelnet.Conv_Middle_layers.conv4", "out.squeeze.squeeze.size", "torch.max_pool3d", "torch.max_pool3d", "torch.max_pool3d", "out.squeeze.squeeze.squeeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "conv4", "(", "out", ")", "\n", "shape", "=", "out", ".", "size", "(", ")", "\n", "# print(\"conv3d feature before maxpool: {}\".format(shape))", "\n", "out", "=", "F", ".", "max_pool3d", "(", "out", ",", "kernel_size", "=", "[", "shape", "[", "2", "]", ",", "1", ",", "1", "]", ")", "\n", "out", "=", "out", ".", "squeeze", "(", "2", ")", "\n", "# print(\"conv3d feature size: {}\".format(out.size()))", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.NaiveRpnHead.__init__": [[15, 39], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "region_proposal_network.NaiveRpnHead.cls[].bias.data.fill_", "region_proposal_network.fill_fc_weights", "region_proposal_network.fill_fc_weights", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__", "home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.fill_fc_weights", "home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.fill_fc_weights"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "num_classes", ")", ":", "\n", "        ", "'''\n        Args:\n            inplanes: input channel\n            num_classes: as the name implies\n            num_anchors: as the name implies\n        '''", "\n", "super", "(", "NaiveRpnHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "cls", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "inplanes", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "64", ",", "self", ".", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ")", "\n", "self", ".", "loc", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "inplanes", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "64", ",", "3", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ")", "\n", "self", ".", "z_axis", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "inplanes", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "64", ",", "1", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ")", "\n", "self", ".", "cls", "[", "-", "1", "]", ".", "bias", ".", "data", ".", "fill_", "(", "-", "2.19", ")", "\n", "fill_fc_weights", "(", "self", ".", "loc", ")", "\n", "fill_fc_weights", "(", "self", ".", "z_axis", ")", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.NaiveRpnHead.forward": [[39, 52], ["region_proposal_network.NaiveRpnHead.cls", "region_proposal_network.NaiveRpnHead.loc", "region_proposal_network.NaiveRpnHead.z_axis"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "'''\n        Args:\n            x: [B, inplanes, h, w], input feature\n        Return:\n            pred_cls: [B, num_anchors, h, w]\n            pred_loc: [B, num_anchors*4, h, w]\n        '''", "\n", "pred_cls", "=", "self", ".", "cls", "(", "x", ")", "\n", "pred_loc", "=", "self", ".", "loc", "(", "x", ")", "\n", "pred_z_axis", "=", "self", ".", "z_axis", "(", "x", ")", "\n", "#(B,9,C)", "\n", "return", "pred_cls", ",", "pred_loc", ",", "pred_z_axis", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__": [[54, 66], ["torch.Module.__init__", "torch_util.Conv2d", "torch_util.Conv2d", "torch_util.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "region_proposal_network.NaiveRpnHead", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_classes", "=", "1", ")", ":", "\n", "        ", "super", "(", "RPN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1_1", "=", "Conv2d", "(", "128", ",", "128", ",", "2", ",", "padding", "=", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "conv1_2", "=", "Conv2d", "(", "128", ",", "128", ",", "1", ",", "padding", "=", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "conv1_3", "=", "Conv2d", "(", "128", ",", "128", ",", "1", ",", "padding", "=", "(", "1", ",", "1", ")", ")", "\n", "\n", "self", ".", "deconv1", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "(", "'ConvTranspose'", ",", "nn", ".", "ConvTranspose2d", "(", "128", ",", "128", ",", "2", ",", "2", ",", "0", ")", ")", ",", "(", "'bn'", ",", "nn", ".", "BatchNorm2d", "(", "128", ")", ")", ",", "(", "'relu'", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "]", ")", ")", "\n", "self", ".", "deconv", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "(", "'ConvTranspose'", ",", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "1", ",", "1", ",", "0", ")", ")", ",", "(", "'bn'", ",", "nn", ".", "BatchNorm2d", "(", "128", ")", ")", ",", "(", "'relu'", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "]", ")", ")", "\n", "\n", "self", ".", "conv_final", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "(", "'Conv'", ",", "nn", ".", "Conv2d", "(", "128", "*", "2", ",", "128", ",", "1", ",", "1", ")", ")", ",", "(", "'bn'", ",", "nn", ".", "BatchNorm2d", "(", "128", ")", ")", ",", "(", "'relu'", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "]", ")", ")", "\n", "\n", "self", ".", "rpn_head", "=", "NaiveRpnHead", "(", "128", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.RPN.forward": [[67, 79], ["region_proposal_network.RPN.deconv", "region_proposal_network.RPN.conv1_1", "region_proposal_network.RPN.conv1_2", "region_proposal_network.RPN.conv1_3", "region_proposal_network.RPN.deconv1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "region_proposal_network.RPN.conv_final", "region_proposal_network.RPN.rpn_head"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "deconv", "=", "self", ".", "deconv", "(", "x", ")", "\n", "out", "=", "self", ".", "conv1_1", "(", "x", ")", "\n", "out", "=", "self", ".", "conv1_2", "(", "out", ")", "\n", "out", "=", "self", ".", "conv1_3", "(", "out", ")", "\n", "out", "=", "self", ".", "deconv1", "(", "out", ")", "\n", "# print('x shape: {}'.format(x.size()))", "\n", "# print('deconv1 shape: {}'.format(out.size()))", "\n", "out", "=", "torch", ".", "cat", "(", "[", "deconv", ",", "out", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_final", "(", "out", ")", "\n", "rpn_pred_cls", ",", "rpn_pred_loc", ",", "pred_z_axis", "=", "self", ".", "rpn_head", "(", "out", ")", "\n", "return", "rpn_pred_cls", ",", "rpn_pred_loc", ",", "pred_z_axis", "", "", "", ""]], "home.repos.pwc.inspect_result.fpthink_v2b.voxel.region_proposal_network.fill_fc_weights": [[9, 14], ["layers.modules", "isinstance", "torch.init.constant_"], "function", ["None"], ["def", "fill_fc_weights", "(", "layers", ")", ":", "\n", "    ", "for", "m", "in", "layers", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "            ", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "", "", "", "class", "NaiveRpnHead", "(", "nn", ".", "Module", ")", ":", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functional.voxelization.AvgVoxelization.forward": [[9, 27], ["features.contiguous.contiguous.contiguous", "coords.int().contiguous.int().contiguous.int().contiguous", "features.contiguous.contiguous.double", "modules.voxel_utils.functional.backend._backend.avg_voxelize_forward", "out.float.float.float", "ctx.save_for_backward", "out.float.float.view", "coords.int().contiguous.int().contiguous.int"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "x", ",", "y", ",", "z", ",", "scene_ground", "=", "torch", ".", "tensor", "(", "[", "-", "5.6", ",", "-", "3.6", ",", "-", "2.4", "]", ")", ",", "voxel_size", "=", "torch", ".", "tensor", "(", "[", "0.3", ",", "0.3", ",", "0.2", "]", ")", ",", "mode", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "x", "=", "int", "(", "x", ")", "\n", "self", ".", "y", "=", "int", "(", "y", ")", "\n", "self", ".", "z", "=", "int", "(", "z", ")", "\n", "self", ".", "scene_ground", "=", "scene_ground", "\n", "self", ".", "voxel_size", "=", "voxel_size", "\n", "self", ".", "min_voxel_coord", "=", "torch", ".", "floor", "(", "self", ".", "scene_ground", "/", "self", ".", "voxel_size", ")", "\n", "self", ".", "resolution", "=", "(", "-", "2", "*", "self", ".", "min_voxel_coord", ")", ".", "int", "(", ")", "\n", "self", ".", "mode", "=", "mode", "\n", "\n", "", "def", "forward", "(", "self", ",", "features", ",", "coords", ")", ":", "\n", "#(b,c,n)(b,n,3)", "\n", "        ", "coords_detach", "=", "coords", ".", "detach", "(", ")", "\n", "discrete_pts", "=", "torch", ".", "floor", "(", "coords_detach", "/", "self", ".", "voxel_size", ".", "cuda", "(", ")", ")", "\n", "voxel_indices", "=", "(", "discrete_pts", "-", "self", ".", "min_voxel_coord", ".", "cuda", "(", ")", ")", ".", "int", "(", ")", "\n", "voxel_indices", "=", "voxel_indices", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "if", "self", ".", "mode", ":", "\n", "            ", "return", "favg_voxelize", "(", "features", ",", "voxel_indices", ",", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "z", ")", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functional.voxelization.AvgVoxelization.backward": [[28, 40], ["modules.voxel_utils.functional.backend._backend.avg_voxelize_backward", "grad_output.contiguous().view", "grad_output.contiguous"], "methods", ["None"], ["", "else", ":", "\n", "            ", "return", "avg_voxelize", "(", "features", ",", "voxel_indices", ",", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "z", ")", "\n", "\n", "", "", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "print", "(", "'information:x {} y {} z {} min_voxel_coord {} voxel_size {} '", ".", "format", "(", "self", ".", "x", ",", "self", ".", "y", ",", "self", ".", "z", ",", "self", ".", "min_voxel_coord", ",", "self", ".", "voxel_size", ")", ")", "\n", "# if __name__ == '__main__':", "\n", "#     conv=nn.Conv1d(128,128,1,1)", "\n", "#     voxel=Voxelization(56,36,24)", "\n", "#     voxel.cuda()", "\n", "#     conv.cuda()", "\n", "#     coords_x=torch.rand((1,2048,1),dtype=torch.float32)*5.6", "\n", "#     coords_y=torch.rand((1,2048,1),dtype=torch.float32)*3.6", "\n", "#     coords_z=torch.rand((1,2048,1),dtype=torch.float32)*2.4", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functional.voxelization.fAvgVoxelization.forward": [[45, 61], ["features.contiguous.contiguous.contiguous", "coords.int().contiguous.int().contiguous.int().contiguous", "modules.voxel_utils.functional.backend._backend.favg_voxelize_forward", "ctx.save_for_backward", "out.view", "coords.int().contiguous.int().contiguous.int"], "methods", ["None"], ["#         import time", "\n", "#         import random", "\n", "#         ti1=time.time()", "\n", "#         random.seed(0)", "\n", "#         torch.manual_seed(0)", "\n", "#         # torch.cuda.manual_seed(0)", "\n", "#         features = torch.rand(1, 128, 2048, dtype=torch.float32).cuda().requires_grad_()", "\n", "#         out = conv(features)", "\n", "#         voxels=voxel(out,coord)", "\n", "#         ti2 = time.time()", "\n", "#         print(ti2-ti1)", "\n", "#         output1[i].append(voxels.clone().detach())", "\n", "#     for t1, t2 in zip(output1[0], output1[1]):", "\n", "#         print(t1.equal(t2))", "\n", "#     # print(voxels[0,:,28,18,12])", "\n", "#     voxels=voxels.permute(0, 1, 4, 3, 2).contiguous()", "\n", "#     voxels=voxels.sum()", "\n"]], "home.repos.pwc.inspect_result.fpthink_v2b.functional.voxelization.fAvgVoxelization.backward": [[62, 74], ["modules.voxel_utils.functional.backend._backend.favg_voxelize_backward", "grad_output.contiguous().view", "grad_output.contiguous"], "methods", ["None"], ["#     voxels.backward()", "\n", "#     print(features.grad,features.dtype,voxels.dtype)", "", "", "", ""]]}