{"home.repos.pwc.inspect_result.sxzrt_proxy-set.None.dataset_selection.logger_config": [[36, 48], ["logging.getLogger", "logging.getLogger.setLevel", "logging.FileHandler", "logging.FileHandler.setLevel", "logging.Formatter", "logging.FileHandler.setFormatter", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.getLogger.addHandler", "logging.getLogger.addHandler"], "function", ["None"], ["def", "logger_config", "(", "log_path", ",", "logging_name", ")", ":", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "logging_name", ")", "\n", "logger", ".", "setLevel", "(", "level", "=", "logging", ".", "DEBUG", ")", "\n", "handler", "=", "logging", ".", "FileHandler", "(", "log_path", ",", "encoding", "=", "'UTF-8'", ",", "mode", "=", "'w'", ")", "\n", "handler", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "'%(asctime)s - %(name)s - %(levelname)s - %(message)s'", ")", "\n", "handler", ".", "setFormatter", "(", "formatter", ")", "\n", "console", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "console", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "logger", ".", "addHandler", "(", "handler", ")", "\n", "logger", ".", "addHandler", "(", "console", ")", "\n", "return", "logger", "\n", "#######################################################################", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.random_apply": [[32, 39], ["tensorflow.cond", "tensorflow.less", "tensorflow.random_uniform", "tensorflow.cast", "DG_image_processing.to_grayscale"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.to_grayscale"], ["def", "random_apply", "(", "func", ",", "p", ",", "x", ")", ":", "\n", "  ", "\"\"\"Randomly apply function func to x with probability p.\"\"\"", "\n", "return", "tf", ".", "cond", "(", "\n", "tf", ".", "less", "(", "tf", ".", "random_uniform", "(", "[", "]", ",", "minval", "=", "0", ",", "maxval", "=", "1", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "cast", "(", "p", ",", "tf", ".", "float32", ")", ")", ",", "\n", "lambda", ":", "func", "(", "x", ")", ",", "\n", "lambda", ":", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.random_brightness": [[41, 52], ["tensorflow.random_uniform", "tensorflow.maximum", "tensorflow.image.random_brightness", "ValueError"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_brightness"], ["", "def", "random_brightness", "(", "image", ",", "max_delta", ",", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"A multiplicative vs additive change of brightness.\"\"\"", "\n", "if", "impl", "==", "'simclrv2'", ":", "\n", "    ", "factor", "=", "tf", ".", "random_uniform", "(", "\n", "[", "]", ",", "tf", ".", "maximum", "(", "1.0", "-", "max_delta", ",", "0", ")", ",", "1.0", "+", "max_delta", ")", "\n", "image", "=", "image", "*", "factor", "\n", "", "elif", "impl", "==", "'simclrv1'", ":", "\n", "    ", "image", "=", "tf", ".", "image", ".", "random_brightness", "(", "image", ",", "max_delta", "=", "max_delta", ")", "\n", "", "else", ":", "\n", "    ", "raise", "ValueError", "(", "'Unknown impl {} for random brightness.'", ".", "format", "(", "impl", ")", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.to_grayscale": [[54, 59], ["tensorflow.image.rgb_to_grayscale", "tensorflow.tile"], "function", ["None"], ["", "def", "to_grayscale", "(", "image", ",", "keep_channels", "=", "True", ")", ":", "\n", "  ", "image", "=", "tf", ".", "image", ".", "rgb_to_grayscale", "(", "image", ")", "\n", "if", "keep_channels", ":", "\n", "    ", "image", "=", "tf", ".", "tile", "(", "image", ",", "[", "1", ",", "1", ",", "3", "]", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.color_jitter": [[61, 82], ["DG_image_processing.color_jitter_rand", "DG_image_processing.color_jitter_nonrand"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.color_jitter_rand", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.color_jitter_nonrand"], ["", "def", "color_jitter", "(", "image", ",", "strength", ",", "random_order", "=", "True", ",", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"Distorts the color of the image.\n  Args:\n    image: The input image tensor.\n    strength: the floating number for the strength of the color augmentation.\n    random_order: A bool, specifying whether to randomize the jittering order.\n    impl: 'simclrv1' or 'simclrv2'.  Whether to use simclrv1 or simclrv2's\n        version of random brightness.\n  Returns:\n    The distorted image tensor.\n  \"\"\"", "\n", "brightness", "=", "0.8", "*", "strength", "\n", "contrast", "=", "0.8", "*", "strength", "\n", "saturation", "=", "0.8", "*", "strength", "\n", "hue", "=", "0.2", "*", "strength", "\n", "if", "random_order", ":", "\n", "    ", "return", "color_jitter_rand", "(", "\n", "image", ",", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ",", "impl", "=", "impl", ")", "\n", "", "else", ":", "\n", "    ", "return", "color_jitter_nonrand", "(", "\n", "image", ",", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ",", "impl", "=", "impl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.color_jitter_nonrand": [[84, 121], ["tensorflow.name_scope", "range", "DG_image_processing.color_jitter_nonrand.apply_transform"], "function", ["None"], ["", "", "def", "color_jitter_nonrand", "(", "image", ",", "\n", "brightness", "=", "0", ",", "\n", "contrast", "=", "0", ",", "\n", "saturation", "=", "0", ",", "\n", "hue", "=", "0", ",", "\n", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"Distorts the color of the image (jittering order is fixed).\n  Args:\n    image: The input image tensor.\n    brightness: A float, specifying the brightness for color jitter.\n    contrast: A float, specifying the contrast for color jitter.\n    saturation: A float, specifying the saturation for color jitter.\n    hue: A float, specifying the hue for color jitter.\n    impl: 'simclrv1' or 'simclrv2'.  Whether to use simclrv1 or simclrv2's\n        version of random brightness.\n  Returns:\n    The distorted image tensor.\n  \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "'distort_color'", ")", ":", "\n", "    ", "def", "apply_transform", "(", "i", ",", "x", ",", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ")", ":", "\n", "      ", "\"\"\"Apply the i-th transformation.\"\"\"", "\n", "if", "brightness", "!=", "0", "and", "i", "==", "0", ":", "\n", "        ", "x", "=", "random_brightness", "(", "x", ",", "max_delta", "=", "brightness", ",", "impl", "=", "impl", ")", "\n", "", "elif", "contrast", "!=", "0", "and", "i", "==", "1", ":", "\n", "        ", "x", "=", "tf", ".", "image", ".", "random_contrast", "(", "\n", "x", ",", "lower", "=", "1", "-", "contrast", ",", "upper", "=", "1", "+", "contrast", ")", "\n", "", "elif", "saturation", "!=", "0", "and", "i", "==", "2", ":", "\n", "        ", "x", "=", "tf", ".", "image", ".", "random_saturation", "(", "\n", "x", ",", "lower", "=", "1", "-", "saturation", ",", "upper", "=", "1", "+", "saturation", ")", "\n", "", "elif", "hue", "!=", "0", ":", "\n", "        ", "x", "=", "tf", ".", "image", ".", "random_hue", "(", "x", ",", "max_delta", "=", "hue", ")", "\n", "", "return", "x", "\n", "\n", "", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "      ", "image", "=", "apply_transform", "(", "i", ",", "image", ",", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ")", "\n", "image", "=", "tf", ".", "clip_by_value", "(", "image", ",", "0.", ",", "1.", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.color_jitter_rand": [[123, 176], ["tensorflow.name_scope", "tensorflow.random_shuffle", "range", "tensorflow.cond", "tensorflow.range", "DG_image_processing.color_jitter_nonrand.apply_transform"], "function", ["None"], ["", "", "def", "color_jitter_rand", "(", "image", ",", "\n", "brightness", "=", "0", ",", "\n", "contrast", "=", "0", ",", "\n", "saturation", "=", "0", ",", "\n", "hue", "=", "0", ",", "\n", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"Distorts the color of the image (jittering order is random).\n  Args:\n    image: The input image tensor.\n    brightness: A float, specifying the brightness for color jitter.\n    contrast: A float, specifying the contrast for color jitter.\n    saturation: A float, specifying the saturation for color jitter.\n    hue: A float, specifying the hue for color jitter.\n    impl: 'simclrv1' or 'simclrv2'.  Whether to use simclrv1 or simclrv2's\n        version of random brightness.\n  Returns:\n    The distorted image tensor.\n  \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "'distort_color'", ")", ":", "\n", "    ", "def", "apply_transform", "(", "i", ",", "x", ")", ":", "\n", "      ", "\"\"\"Apply the i-th transformation.\"\"\"", "\n", "def", "brightness_foo", "(", ")", ":", "\n", "        ", "if", "brightness", "==", "0", ":", "\n", "          ", "return", "x", "\n", "", "else", ":", "\n", "          ", "return", "random_brightness", "(", "x", ",", "max_delta", "=", "brightness", ",", "impl", "=", "impl", ")", "\n", "\n", "", "", "def", "contrast_foo", "(", ")", ":", "\n", "        ", "if", "contrast", "==", "0", ":", "\n", "          ", "return", "x", "\n", "", "else", ":", "\n", "          ", "return", "tf", ".", "image", ".", "random_contrast", "(", "x", ",", "lower", "=", "1", "-", "contrast", ",", "upper", "=", "1", "+", "contrast", ")", "\n", "", "", "def", "saturation_foo", "(", ")", ":", "\n", "        ", "if", "saturation", "==", "0", ":", "\n", "          ", "return", "x", "\n", "", "else", ":", "\n", "          ", "return", "tf", ".", "image", ".", "random_saturation", "(", "\n", "x", ",", "lower", "=", "1", "-", "saturation", ",", "upper", "=", "1", "+", "saturation", ")", "\n", "", "", "def", "hue_foo", "(", ")", ":", "\n", "        ", "if", "hue", "==", "0", ":", "\n", "          ", "return", "x", "\n", "", "else", ":", "\n", "          ", "return", "tf", ".", "image", ".", "random_hue", "(", "x", ",", "max_delta", "=", "hue", ")", "\n", "", "", "x", "=", "tf", ".", "cond", "(", "tf", ".", "less", "(", "i", ",", "2", ")", ",", "\n", "lambda", ":", "tf", ".", "cond", "(", "tf", ".", "less", "(", "i", ",", "1", ")", ",", "brightness_foo", ",", "contrast_foo", ")", ",", "\n", "lambda", ":", "tf", ".", "cond", "(", "tf", ".", "less", "(", "i", ",", "3", ")", ",", "saturation_foo", ",", "hue_foo", ")", ")", "\n", "return", "x", "\n", "\n", "", "perm", "=", "tf", ".", "random_shuffle", "(", "tf", ".", "range", "(", "4", ")", ")", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "      ", "image", "=", "apply_transform", "(", "perm", "[", "i", "]", ",", "image", ")", "\n", "image", "=", "tf", ".", "clip_by_value", "(", "image", ",", "0.", ",", "1.", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing._compute_crop_shape": [[178, 214], ["tensorflow.cast", "tensorflow.cast", "tensorflow.cond", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.rint", "tensorflow.rint", "tensorflow.rint", "tensorflow.rint"], "function", ["None"], ["", "", "def", "_compute_crop_shape", "(", "\n", "image_height", ",", "image_width", ",", "aspect_ratio", ",", "crop_proportion", ")", ":", "\n", "  ", "\"\"\"Compute aspect ratio-preserving shape for central crop.\n  The resulting shape retains `crop_proportion` along one side and a proportion\n  less than or equal to `crop_proportion` along the other side.\n  Args:\n    image_height: Height of image to be cropped.\n    image_width: Width of image to be cropped.\n    aspect_ratio: Desired aspect ratio (width / height) of output.\n    crop_proportion: Proportion of image to retain along the less-cropped side.\n  Returns:\n    crop_height: Height of image after cropping.\n    crop_width: Width of image after cropping.\n  \"\"\"", "\n", "image_width_float", "=", "tf", ".", "cast", "(", "image_width", ",", "tf", ".", "float32", ")", "\n", "image_height_float", "=", "tf", ".", "cast", "(", "image_height", ",", "tf", ".", "float32", ")", "\n", "\n", "def", "_requested_aspect_ratio_wider_than_image", "(", ")", ":", "\n", "    ", "crop_height", "=", "tf", ".", "cast", "(", "tf", ".", "rint", "(", "\n", "crop_proportion", "/", "aspect_ratio", "*", "image_width_float", ")", ",", "tf", ".", "int32", ")", "\n", "crop_width", "=", "tf", ".", "cast", "(", "tf", ".", "rint", "(", "\n", "crop_proportion", "*", "image_width_float", ")", ",", "tf", ".", "int32", ")", "\n", "return", "crop_height", ",", "crop_width", "\n", "\n", "", "def", "_image_wider_than_requested_aspect_ratio", "(", ")", ":", "\n", "    ", "crop_height", "=", "tf", ".", "cast", "(", "\n", "tf", ".", "rint", "(", "crop_proportion", "*", "image_height_float", ")", ",", "tf", ".", "int32", ")", "\n", "crop_width", "=", "tf", ".", "cast", "(", "tf", ".", "rint", "(", "\n", "crop_proportion", "*", "aspect_ratio", "*", "\n", "image_height_float", ")", ",", "tf", ".", "int32", ")", "\n", "return", "crop_height", ",", "crop_width", "\n", "\n", "", "return", "tf", ".", "cond", "(", "\n", "aspect_ratio", ">", "image_width_float", "/", "image_height_float", ",", "\n", "_requested_aspect_ratio_wider_than_image", ",", "\n", "_image_wider_than_requested_aspect_ratio", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.center_crop": [[216, 239], ["tensorflow.shape", "DG_image_processing._compute_crop_shape", "tensorflow.image.crop_to_bounding_box", "tensorflow.image.resize_bicubic"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data._compute_crop_shape"], ["", "def", "center_crop", "(", "image", ",", "height", ",", "width", ",", "crop_proportion", ")", ":", "\n", "  ", "\"\"\"Crops to center of image and rescales to desired size.\n  Args:\n    image: Image Tensor to crop.\n    height: Height of image to be cropped.\n    width: Width of image to be cropped.\n    crop_proportion: Proportion of image to retain along the less-cropped side.\n  Returns:\n    A `height` x `width` x channels Tensor holding a central crop of `image`.\n  \"\"\"", "\n", "shape", "=", "tf", ".", "shape", "(", "image", ")", "\n", "image_height", "=", "shape", "[", "0", "]", "\n", "image_width", "=", "shape", "[", "1", "]", "\n", "crop_height", ",", "crop_width", "=", "_compute_crop_shape", "(", "\n", "image_height", ",", "image_width", ",", "height", "/", "width", ",", "crop_proportion", ")", "\n", "offset_height", "=", "(", "(", "image_height", "-", "crop_height", ")", "+", "1", ")", "//", "2", "\n", "offset_width", "=", "(", "(", "image_width", "-", "crop_width", ")", "+", "1", ")", "//", "2", "\n", "image", "=", "tf", ".", "image", ".", "crop_to_bounding_box", "(", "\n", "image", ",", "offset_height", ",", "offset_width", ",", "crop_height", ",", "crop_width", ")", "\n", "\n", "image", "=", "tf", ".", "image", ".", "resize_bicubic", "(", "[", "image", "]", ",", "[", "height", ",", "width", "]", ")", "[", "0", "]", "\n", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.distorted_bounding_box_crop": [[241, 289], ["tensorflow.name_scope", "tensorflow.shape", "tensorflow.image.sample_distorted_bounding_box", "tensorflow.unstack", "tensorflow.unstack", "tensorflow.image.crop_to_bounding_box"], "function", ["None"], ["", "def", "distorted_bounding_box_crop", "(", "image", ",", "\n", "bbox", ",", "\n", "min_object_covered", "=", "0.1", ",", "\n", "aspect_ratio_range", "=", "(", "0.75", ",", "1.33", ")", ",", "\n", "area_range", "=", "(", "0.05", ",", "1.0", ")", ",", "\n", "max_attempts", "=", "100", ",", "\n", "scope", "=", "None", ")", ":", "\n", "  ", "\"\"\"Generates cropped_image using one of the bboxes randomly distorted.\n  See `tf.image.sample_distorted_bounding_box` for more documentation.\n  Args:\n    image: `Tensor` of image data.\n    bbox: `Tensor` of bounding boxes arranged `[1, num_boxes, coords]`\n        where each coordinate is [0, 1) and the coordinates are arranged\n        as `[ymin, xmin, ymax, xmax]`. If num_boxes is 0 then use the whole\n        image.\n    min_object_covered: An optional `float`. Defaults to `0.1`. The cropped\n        area of the image must contain at least this fraction of any bounding\n        box supplied.\n    aspect_ratio_range: An optional list of `float`s. The cropped area of the\n        image must have an aspect ratio = width / height within this range.\n    area_range: An optional list of `float`s. The cropped area of the image\n        must contain a fraction of the supplied image within in this range.\n    max_attempts: An optional `int`. Number of attempts at generating a cropped\n        region of the image of the specified constraints. After `max_attempts`\n        failures, return the entire image.\n    scope: Optional `str` for name scope.\n  Returns:\n    (cropped image `Tensor`, distorted bbox `Tensor`).\n  \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "scope", ",", "'distorted_bounding_box_crop'", ",", "[", "image", ",", "bbox", "]", ")", ":", "\n", "    ", "shape", "=", "tf", ".", "shape", "(", "image", ")", "\n", "sample_distorted_bounding_box", "=", "tf", ".", "image", ".", "sample_distorted_bounding_box", "(", "\n", "shape", ",", "\n", "bounding_boxes", "=", "bbox", ",", "\n", "min_object_covered", "=", "min_object_covered", ",", "\n", "aspect_ratio_range", "=", "aspect_ratio_range", ",", "\n", "area_range", "=", "area_range", ",", "\n", "max_attempts", "=", "max_attempts", ",", "\n", "use_image_if_no_bounding_boxes", "=", "True", ")", "\n", "bbox_begin", ",", "bbox_size", ",", "_", "=", "sample_distorted_bounding_box", "\n", "\n", "# Crop the image to the specified bounding box.", "\n", "offset_y", ",", "offset_x", ",", "_", "=", "tf", ".", "unstack", "(", "bbox_begin", ")", "\n", "target_height", ",", "target_width", ",", "_", "=", "tf", ".", "unstack", "(", "bbox_size", ")", "\n", "image", "=", "tf", ".", "image", ".", "crop_to_bounding_box", "(", "\n", "image", ",", "offset_y", ",", "offset_x", ",", "target_height", ",", "target_width", ")", "\n", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.crop_and_resize": [[291, 311], ["tensorflow.constant", "DG_image_processing.distorted_bounding_box_crop", "tensorflow.image.resize_bicubic"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.distorted_bounding_box_crop"], ["", "", "def", "crop_and_resize", "(", "image", ",", "height", ",", "width", ")", ":", "\n", "  ", "\"\"\"Make a random crop and resize it to height `height` and width `width`.\n  Args:\n    image: Tensor representing the image.\n    height: Desired image height.\n    width: Desired image width.\n  Returns:\n    A `height` x `width` x channels Tensor holding a random crop of `image`.\n  \"\"\"", "\n", "bbox", "=", "tf", ".", "constant", "(", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ",", "dtype", "=", "tf", ".", "float32", ",", "shape", "=", "[", "1", ",", "1", ",", "4", "]", ")", "\n", "aspect_ratio", "=", "width", "/", "height", "\n", "image", "=", "distorted_bounding_box_crop", "(", "\n", "image", ",", "\n", "bbox", ",", "\n", "min_object_covered", "=", "0.1", ",", "\n", "aspect_ratio_range", "=", "(", "3.", "/", "4", "*", "aspect_ratio", ",", "4.", "/", "3.", "*", "aspect_ratio", ")", ",", "\n", "area_range", "=", "(", "0.08", ",", "1.0", ")", ",", "\n", "max_attempts", "=", "100", ",", "\n", "scope", "=", "None", ")", "\n", "return", "tf", ".", "image", ".", "resize_bicubic", "(", "[", "image", "]", ",", "[", "height", ",", "width", "]", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.add_gaussian_noise": [[314, 321], ["tensorflow.name_scope", "tensorflow.random_normal", "tensorflow.clip_by_value", "tensorflow.shape"], "function", ["None"], ["", "def", "add_gaussian_noise", "(", "image", ")", ":", "\n", "# image must be scaled in [0, 1]", "\n", "    ", "with", "tf", ".", "name_scope", "(", "'Add_gaussian_noise'", ")", ":", "\n", "        ", "noise", "=", "tf", ".", "random_normal", "(", "shape", "=", "tf", ".", "shape", "(", "image", ")", ",", "mean", "=", "0.0", ",", "stddev", "=", "(", "50", ")", "/", "(", "255", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "noise_img", "=", "image", "+", "noise", "\n", "noise_img", "=", "tf", ".", "clip_by_value", "(", "noise_img", ",", "0.0", ",", "1.0", ")", "\n", "", "return", "noise_img", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.gaussian_blur": [[323, 359], ["tensorflow.to_int32", "tensorflow.to_float", "tensorflow.exp", "tensorflow.reduce_sum", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.tile", "tensorflow.tile", "tensorflow.nn.depthwise_conv2d", "tensorflow.nn.depthwise_conv2d", "tensorflow.range", "tensorflow.shape", "tensorflow.expand_dims", "tensorflow.squeeze", "tensorflow.pow", "tensorflow.pow", "tensorflow.to_float"], "function", ["None"], ["", "def", "gaussian_blur", "(", "image", ",", "kernel_size", ",", "sigma", ",", "padding", "=", "'SAME'", ")", ":", "\n", "  ", "\"\"\"Blurs the given image with separable convolution.\n  Args:\n    image: Tensor of shape [height, width, channels] and dtype float to blur.\n    kernel_size: Integer Tensor for the size of the blur kernel. This is should\n      be an odd number. If it is an even number, the actual kernel size will be\n      size + 1.\n    sigma: Sigma value for gaussian operator.\n    padding: Padding to use for the convolution. Typically 'SAME' or 'VALID'.\n  Returns:\n    A Tensor representing the blurred image.\n  \"\"\"", "\n", "radius", "=", "tf", ".", "to_int32", "(", "kernel_size", "/", "2", ")", "\n", "kernel_size", "=", "radius", "*", "2", "+", "1", "\n", "x", "=", "tf", ".", "to_float", "(", "tf", ".", "range", "(", "-", "radius", ",", "radius", "+", "1", ")", ")", "\n", "blur_filter", "=", "tf", ".", "exp", "(", "\n", "-", "tf", ".", "pow", "(", "x", ",", "2.0", ")", "/", "(", "2.0", "*", "tf", ".", "pow", "(", "tf", ".", "to_float", "(", "sigma", ")", ",", "2.0", ")", ")", ")", "\n", "blur_filter", "/=", "tf", ".", "reduce_sum", "(", "blur_filter", ")", "\n", "# One vertical and one horizontal filter.", "\n", "blur_v", "=", "tf", ".", "reshape", "(", "blur_filter", ",", "[", "kernel_size", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "blur_h", "=", "tf", ".", "reshape", "(", "blur_filter", ",", "[", "1", ",", "kernel_size", ",", "1", ",", "1", "]", ")", "\n", "num_channels", "=", "tf", ".", "shape", "(", "image", ")", "[", "-", "1", "]", "\n", "blur_h", "=", "tf", ".", "tile", "(", "blur_h", ",", "[", "1", ",", "1", ",", "num_channels", ",", "1", "]", ")", "\n", "blur_v", "=", "tf", ".", "tile", "(", "blur_v", ",", "[", "1", ",", "1", ",", "num_channels", ",", "1", "]", ")", "\n", "expand_batch_dim", "=", "image", ".", "shape", ".", "ndims", "==", "3", "\n", "if", "expand_batch_dim", ":", "\n", "# Tensorflow requires batched input to convolutions, which we can fake with", "\n", "# an extra dimension.", "\n", "    ", "image", "=", "tf", ".", "expand_dims", "(", "image", ",", "axis", "=", "0", ")", "\n", "", "blurred", "=", "tf", ".", "nn", ".", "depthwise_conv2d", "(", "\n", "image", ",", "blur_h", ",", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "padding", "=", "padding", ")", "\n", "blurred", "=", "tf", ".", "nn", ".", "depthwise_conv2d", "(", "\n", "blurred", ",", "blur_v", ",", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "padding", "=", "padding", ")", "\n", "if", "expand_batch_dim", ":", "\n", "    ", "blurred", "=", "tf", ".", "squeeze", "(", "blurred", ",", "axis", "=", "0", ")", "\n", "", "return", "blurred", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.random_crop_with_resize": [[361, 375], ["DG_image_processing.random_apply", "DG_image_processing.crop_and_resize"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.crop_and_resize"], ["", "def", "random_crop_with_resize", "(", "image", ",", "height", ",", "width", ",", "p", "=", "1.0", ")", ":", "\n", "  ", "\"\"\"Randomly crop and resize an image.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    p: Probability of applying this transformation.\n  Returns:\n    A preprocessed image `Tensor`.\n  \"\"\"", "\n", "def", "_transform", "(", "image", ")", ":", "# pylint: disable=missing-docstring", "\n", "    ", "image", "=", "crop_and_resize", "(", "image", ",", "height", ",", "width", ")", "\n", "return", "image", "\n", "", "return", "random_apply", "(", "_transform", ",", "p", "=", "p", ",", "x", "=", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.random_color_jitter": [[377, 385], ["DG_image_processing.random_apply", "functools.partial", "DG_image_processing.random_apply", "DG_image_processing.random_apply"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply"], ["", "def", "random_color_jitter", "(", "image", ",", "p", "=", "1.0", ",", "impl", "=", "'simclrv2'", ")", ":", "\n", "\n", "  ", "def", "_transform", "(", "image", ")", ":", "\n", "    ", "color_jitter_t", "=", "functools", ".", "partial", "(", "\n", "color_jitter", ",", "strength", "=", "FLAGS", ".", "color_jitter_strength", ",", "impl", "=", "impl", ")", "\n", "image", "=", "random_apply", "(", "color_jitter_t", ",", "p", "=", "0.8", ",", "x", "=", "image", ")", "\n", "return", "random_apply", "(", "to_grayscale", ",", "p", "=", "0.2", ",", "x", "=", "image", ")", "\n", "", "return", "random_apply", "(", "_transform", ",", "p", "=", "p", ",", "x", "=", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.random_blur": [[387, 403], ["DG_image_processing.random_apply", "tensorflow.random.uniform", "DG_image_processing.gaussian_blur"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.gaussian_blur"], ["", "def", "random_blur", "(", "image", ",", "height", ",", "width", ",", "p", "=", "1.0", ")", ":", "\n", "  ", "\"\"\"Randomly blur an image.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    p: probability of applying this transformation.\n  Returns:\n    A preprocessed image `Tensor`.\n  \"\"\"", "\n", "del", "width", "\n", "def", "_transform", "(", "image", ")", ":", "\n", "    ", "sigma", "=", "tf", ".", "random", ".", "uniform", "(", "[", "]", ",", "0.1", ",", "2.0", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "return", "gaussian_blur", "(", "\n", "image", ",", "kernel_size", "=", "height", "//", "10", ",", "sigma", "=", "sigma", ",", "padding", "=", "'SAME'", ")", "\n", "", "return", "random_apply", "(", "_transform", ",", "p", "=", "p", ",", "x", "=", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.batch_random_blur": [[405, 431], ["tensorflow.cast", "DG_image_processing.random_blur", "DG_image_processing.batch_random_blur.generate_selector"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_blur"], ["", "def", "batch_random_blur", "(", "images_list", ",", "height", ",", "width", ",", "blur_probability", "=", "0.5", ")", ":", "\n", "  ", "\"\"\"Apply efficient batch data transformations.\n  Args:\n    images_list: a list of image tensors.\n    height: the height of image.\n    width: the width of image.\n    blur_probability: the probaility to apply the blur operator.\n  Returns:\n    Preprocessed feature list.\n  \"\"\"", "\n", "def", "generate_selector", "(", "p", ",", "bsz", ")", ":", "\n", "    ", "shape", "=", "[", "bsz", ",", "1", ",", "1", ",", "1", "]", "\n", "selector", "=", "tf", ".", "cast", "(", "\n", "tf", ".", "less", "(", "tf", ".", "random_uniform", "(", "shape", ",", "0", ",", "1", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "p", ")", ",", "\n", "tf", ".", "float32", ")", "\n", "return", "selector", "\n", "\n", "", "new_images_list", "=", "[", "]", "\n", "for", "images", "in", "images_list", ":", "\n", "    ", "images_new", "=", "random_blur", "(", "images", ",", "height", ",", "width", ",", "p", "=", "1.", ")", "\n", "selector", "=", "generate_selector", "(", "blur_probability", ",", "tf", ".", "shape", "(", "images", ")", "[", "0", "]", ")", "\n", "images", "=", "images_new", "*", "selector", "+", "images", "*", "(", "1", "-", "selector", ")", "\n", "images", "=", "tf", ".", "clip_by_value", "(", "images", ",", "0.", ",", "1.", ")", "\n", "new_images_list", ".", "append", "(", "images", ")", "\n", "\n", "", "return", "new_images_list", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.preprocess_for_train": [[433, 462], ["tensorflow.reshape", "tensorflow.clip_by_value", "DG_image_processing.random_crop_with_resize", "tensorflow.image.random_flip_left_right", "DG_image_processing.random_color_jitter"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_crop_with_resize", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_color_jitter"], ["", "def", "preprocess_for_train", "(", "image", ",", "\n", "height", ",", "\n", "width", ",", "\n", "color_distort", "=", "True", ",", "\n", "crop", "=", "False", ",", "\n", "flip", "=", "True", ",", "\n", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"Preprocesses the given image for training.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    color_distort: Whether to apply the color distortion.\n    crop: Whether to crop the image.\n    flip: Whether or not to flip left and right of an image.\n    impl: 'simclrv1' or 'simclrv2'.  Whether to use simclrv1 or simclrv2's\n        version of random brightness.\n  Returns:\n    A preprocessed image `Tensor`.\n  \"\"\"", "\n", "if", "crop", ":", "\n", "    ", "image", "=", "random_crop_with_resize", "(", "image", ",", "height", ",", "width", ")", "\n", "", "if", "flip", ":", "\n", "    ", "image", "=", "tf", ".", "image", ".", "random_flip_left_right", "(", "image", ")", "\n", "", "if", "color_distort", ":", "\n", "    ", "image", "=", "random_color_jitter", "(", "image", ",", "impl", "=", "impl", ")", "\n", "", "image", "=", "tf", ".", "reshape", "(", "image", ",", "[", "height", ",", "width", ",", "3", "]", ")", "\n", "image", "=", "tf", ".", "clip_by_value", "(", "image", ",", "0.", ",", "1.", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.preprocess_for_eval": [[464, 479], ["tensorflow.reshape", "tensorflow.clip_by_value", "DG_image_processing.center_crop"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.center_crop"], ["", "def", "preprocess_for_eval", "(", "image", ",", "height", ",", "width", ",", "crop", "=", "True", ")", ":", "\n", "  ", "\"\"\"Preprocesses the given image for evaluation.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    crop: Whether or not to (center) crop the test images.\n  Returns:\n    A preprocessed image `Tensor`.\n  \"\"\"", "\n", "if", "crop", ":", "\n", "    ", "image", "=", "center_crop", "(", "image", ",", "height", ",", "width", ",", "crop_proportion", "=", "CROP_PROPORTION", ")", "\n", "", "image", "=", "tf", ".", "reshape", "(", "image", ",", "[", "height", ",", "width", ",", "3", "]", ")", "\n", "image", "=", "tf", ".", "clip_by_value", "(", "image", ",", "0.", ",", "1.", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_image_processing.preprocess_image": [[481, 500], ["tensorflow.image.convert_image_dtype", "DG_image_processing.preprocess_for_train", "DG_image_processing.preprocess_for_eval"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.preprocess_for_train", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.preprocess_for_eval"], ["", "def", "preprocess_image", "(", "image", ",", "height", ",", "width", ",", "is_training", "=", "True", ",", "\n", "color_distort", "=", "True", ",", "test_crop", "=", "True", ")", ":", "\n", "  ", "\"\"\"Preprocesses the given image.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    is_training: `bool` for whether the preprocessing is for training.\n    color_distort: whether to apply the color distortion.\n    test_crop: whether or not to extract a central crop of the images\n        (as for standard ImageNet evaluation) during the evaluation.\n  Returns:\n    A preprocessed image `Tensor` of range [0, 1].\n  \"\"\"", "\n", "image", "=", "tf", ".", "image", ".", "convert_image_dtype", "(", "image", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "if", "is_training", ":", "\n", "    ", "return", "preprocess_for_train", "(", "image", ",", "height", ",", "width", ",", "color_distort", ")", "\n", "", "else", ":", "\n", "    ", "return", "preprocess_for_eval", "(", "image", ",", "height", ",", "width", ",", "test_crop", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply": [[32, 39], ["tensorflow.cond", "tensorflow.less", "tensorflow.random_uniform", "tensorflow.cast", "DG_gegerate_data.to_grayscale"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.to_grayscale"], ["def", "random_apply", "(", "func", ",", "p", ",", "x", ")", ":", "\n", "  ", "\"\"\"Randomly apply function func to x with probability p.\"\"\"", "\n", "return", "tf", ".", "cond", "(", "\n", "tf", ".", "less", "(", "tf", ".", "random_uniform", "(", "[", "]", ",", "minval", "=", "0", ",", "maxval", "=", "1", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "\n", "tf", ".", "cast", "(", "p", ",", "tf", ".", "float32", ")", ")", ",", "\n", "lambda", ":", "func", "(", "x", ")", ",", "\n", "lambda", ":", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_brightness": [[41, 52], ["tensorflow.random_uniform", "tensorflow.maximum", "tensorflow.image.random_brightness", "ValueError"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_brightness"], ["", "def", "random_brightness", "(", "image", ",", "max_delta", ",", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"A multiplicative vs additive change of brightness.\"\"\"", "\n", "if", "impl", "==", "'simclrv2'", ":", "\n", "    ", "factor", "=", "tf", ".", "random_uniform", "(", "\n", "[", "]", ",", "tf", ".", "maximum", "(", "1.0", "-", "max_delta", ",", "0", ")", ",", "1.0", "+", "max_delta", ")", "\n", "image", "=", "image", "*", "factor", "\n", "", "elif", "impl", "==", "'simclrv1'", ":", "\n", "    ", "image", "=", "tf", ".", "image", ".", "random_brightness", "(", "image", ",", "max_delta", "=", "max_delta", ")", "\n", "", "else", ":", "\n", "    ", "raise", "ValueError", "(", "'Unknown impl {} for random brightness.'", ".", "format", "(", "impl", ")", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.to_grayscale": [[54, 59], ["tensorflow.image.rgb_to_grayscale", "tensorflow.tile"], "function", ["None"], ["", "def", "to_grayscale", "(", "image", ",", "keep_channels", "=", "True", ")", ":", "\n", "  ", "image", "=", "tf", ".", "image", ".", "rgb_to_grayscale", "(", "image", ")", "\n", "if", "keep_channels", ":", "\n", "    ", "image", "=", "tf", ".", "tile", "(", "image", ",", "[", "1", ",", "1", ",", "3", "]", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.color_jitter": [[61, 82], ["DG_gegerate_data.color_jitter_rand", "DG_gegerate_data.color_jitter_nonrand"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.color_jitter_rand", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.color_jitter_nonrand"], ["", "def", "color_jitter", "(", "image", ",", "strength", ",", "random_order", "=", "True", ",", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"Distorts the color of the image.\n  Args:\n    image: The input image tensor.\n    strength: the floating number for the strength of the color augmentation.\n    random_order: A bool, specifying whether to randomize the jittering order.\n    impl: 'simclrv1' or 'simclrv2'.  Whether to use simclrv1 or simclrv2's\n        version of random brightness.\n  Returns:\n    The distorted image tensor.\n  \"\"\"", "\n", "brightness", "=", "0.8", "*", "strength", "\n", "contrast", "=", "0.8", "*", "strength", "\n", "saturation", "=", "0.8", "*", "strength", "\n", "hue", "=", "0.2", "*", "strength", "\n", "if", "random_order", ":", "\n", "    ", "return", "color_jitter_rand", "(", "\n", "image", ",", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ",", "impl", "=", "impl", ")", "\n", "", "else", ":", "\n", "    ", "return", "color_jitter_nonrand", "(", "\n", "image", ",", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ",", "impl", "=", "impl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.color_jitter_nonrand": [[84, 121], ["tensorflow.name_scope", "range", "DG_gegerate_data.color_jitter_nonrand.apply_transform"], "function", ["None"], ["", "", "def", "color_jitter_nonrand", "(", "image", ",", "\n", "brightness", "=", "0", ",", "\n", "contrast", "=", "0", ",", "\n", "saturation", "=", "0", ",", "\n", "hue", "=", "0", ",", "\n", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"Distorts the color of the image (jittering order is fixed).\n  Args:\n    image: The input image tensor.\n    brightness: A float, specifying the brightness for color jitter.\n    contrast: A float, specifying the contrast for color jitter.\n    saturation: A float, specifying the saturation for color jitter.\n    hue: A float, specifying the hue for color jitter.\n    impl: 'simclrv1' or 'simclrv2'.  Whether to use simclrv1 or simclrv2's\n        version of random brightness.\n  Returns:\n    The distorted image tensor.\n  \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "'distort_color'", ")", ":", "\n", "    ", "def", "apply_transform", "(", "i", ",", "x", ",", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ")", ":", "\n", "      ", "\"\"\"Apply the i-th transformation.\"\"\"", "\n", "if", "brightness", "!=", "0", "and", "i", "==", "0", ":", "\n", "        ", "x", "=", "random_brightness", "(", "x", ",", "max_delta", "=", "brightness", ",", "impl", "=", "impl", ")", "\n", "", "elif", "contrast", "!=", "0", "and", "i", "==", "1", ":", "\n", "        ", "x", "=", "tf", ".", "image", ".", "random_contrast", "(", "\n", "x", ",", "lower", "=", "1", "-", "contrast", ",", "upper", "=", "1", "+", "contrast", ")", "\n", "", "elif", "saturation", "!=", "0", "and", "i", "==", "2", ":", "\n", "        ", "x", "=", "tf", ".", "image", ".", "random_saturation", "(", "\n", "x", ",", "lower", "=", "1", "-", "saturation", ",", "upper", "=", "1", "+", "saturation", ")", "\n", "", "elif", "hue", "!=", "0", ":", "\n", "        ", "x", "=", "tf", ".", "image", ".", "random_hue", "(", "x", ",", "max_delta", "=", "hue", ")", "\n", "", "return", "x", "\n", "\n", "", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "      ", "image", "=", "apply_transform", "(", "i", ",", "image", ",", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ")", "\n", "image", "=", "tf", ".", "clip_by_value", "(", "image", ",", "0.", ",", "1.", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.color_jitter_rand": [[123, 176], ["tensorflow.name_scope", "tensorflow.random_shuffle", "range", "tensorflow.cond", "tensorflow.range", "DG_gegerate_data.color_jitter_nonrand.apply_transform"], "function", ["None"], ["", "", "def", "color_jitter_rand", "(", "image", ",", "\n", "brightness", "=", "0", ",", "\n", "contrast", "=", "0", ",", "\n", "saturation", "=", "0", ",", "\n", "hue", "=", "0", ",", "\n", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"Distorts the color of the image (jittering order is random).\n  Args:\n    image: The input image tensor.\n    brightness: A float, specifying the brightness for color jitter.\n    contrast: A float, specifying the contrast for color jitter.\n    saturation: A float, specifying the saturation for color jitter.\n    hue: A float, specifying the hue for color jitter.\n    impl: 'simclrv1' or 'simclrv2'.  Whether to use simclrv1 or simclrv2's\n        version of random brightness.\n  Returns:\n    The distorted image tensor.\n  \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "'distort_color'", ")", ":", "\n", "    ", "def", "apply_transform", "(", "i", ",", "x", ")", ":", "\n", "      ", "\"\"\"Apply the i-th transformation.\"\"\"", "\n", "def", "brightness_foo", "(", ")", ":", "\n", "        ", "if", "brightness", "==", "0", ":", "\n", "          ", "return", "x", "\n", "", "else", ":", "\n", "          ", "return", "random_brightness", "(", "x", ",", "max_delta", "=", "brightness", ",", "impl", "=", "impl", ")", "\n", "\n", "", "", "def", "contrast_foo", "(", ")", ":", "\n", "        ", "if", "contrast", "==", "0", ":", "\n", "          ", "return", "x", "\n", "", "else", ":", "\n", "          ", "return", "tf", ".", "image", ".", "random_contrast", "(", "x", ",", "lower", "=", "1", "-", "contrast", ",", "upper", "=", "1", "+", "contrast", ")", "\n", "", "", "def", "saturation_foo", "(", ")", ":", "\n", "        ", "if", "saturation", "==", "0", ":", "\n", "          ", "return", "x", "\n", "", "else", ":", "\n", "          ", "return", "tf", ".", "image", ".", "random_saturation", "(", "\n", "x", ",", "lower", "=", "1", "-", "saturation", ",", "upper", "=", "1", "+", "saturation", ")", "\n", "", "", "def", "hue_foo", "(", ")", ":", "\n", "        ", "if", "hue", "==", "0", ":", "\n", "          ", "return", "x", "\n", "", "else", ":", "\n", "          ", "return", "tf", ".", "image", ".", "random_hue", "(", "x", ",", "max_delta", "=", "hue", ")", "\n", "", "", "x", "=", "tf", ".", "cond", "(", "tf", ".", "less", "(", "i", ",", "2", ")", ",", "\n", "lambda", ":", "tf", ".", "cond", "(", "tf", ".", "less", "(", "i", ",", "1", ")", ",", "brightness_foo", ",", "contrast_foo", ")", ",", "\n", "lambda", ":", "tf", ".", "cond", "(", "tf", ".", "less", "(", "i", ",", "3", ")", ",", "saturation_foo", ",", "hue_foo", ")", ")", "\n", "return", "x", "\n", "\n", "", "perm", "=", "tf", ".", "random_shuffle", "(", "tf", ".", "range", "(", "4", ")", ")", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "      ", "image", "=", "apply_transform", "(", "perm", "[", "i", "]", ",", "image", ")", "\n", "image", "=", "tf", ".", "clip_by_value", "(", "image", ",", "0.", ",", "1.", ")", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data._compute_crop_shape": [[178, 214], ["tensorflow.cast", "tensorflow.cast", "tensorflow.cond", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.rint", "tensorflow.rint", "tensorflow.rint", "tensorflow.rint"], "function", ["None"], ["", "", "def", "_compute_crop_shape", "(", "\n", "image_height", ",", "image_width", ",", "aspect_ratio", ",", "crop_proportion", ")", ":", "\n", "  ", "\"\"\"Compute aspect ratio-preserving shape for central crop.\n  The resulting shape retains `crop_proportion` along one side and a proportion\n  less than or equal to `crop_proportion` along the other side.\n  Args:\n    image_height: Height of image to be cropped.\n    image_width: Width of image to be cropped.\n    aspect_ratio: Desired aspect ratio (width / height) of output.\n    crop_proportion: Proportion of image to retain along the less-cropped side.\n  Returns:\n    crop_height: Height of image after cropping.\n    crop_width: Width of image after cropping.\n  \"\"\"", "\n", "image_width_float", "=", "tf", ".", "cast", "(", "image_width", ",", "tf", ".", "float32", ")", "\n", "image_height_float", "=", "tf", ".", "cast", "(", "image_height", ",", "tf", ".", "float32", ")", "\n", "\n", "def", "_requested_aspect_ratio_wider_than_image", "(", ")", ":", "\n", "    ", "crop_height", "=", "tf", ".", "cast", "(", "tf", ".", "rint", "(", "\n", "crop_proportion", "/", "aspect_ratio", "*", "image_width_float", ")", ",", "tf", ".", "int32", ")", "\n", "crop_width", "=", "tf", ".", "cast", "(", "tf", ".", "rint", "(", "\n", "crop_proportion", "*", "image_width_float", ")", ",", "tf", ".", "int32", ")", "\n", "return", "crop_height", ",", "crop_width", "\n", "\n", "", "def", "_image_wider_than_requested_aspect_ratio", "(", ")", ":", "\n", "    ", "crop_height", "=", "tf", ".", "cast", "(", "\n", "tf", ".", "rint", "(", "crop_proportion", "*", "image_height_float", ")", ",", "tf", ".", "int32", ")", "\n", "crop_width", "=", "tf", ".", "cast", "(", "tf", ".", "rint", "(", "\n", "crop_proportion", "*", "aspect_ratio", "*", "\n", "image_height_float", ")", ",", "tf", ".", "int32", ")", "\n", "return", "crop_height", ",", "crop_width", "\n", "\n", "", "return", "tf", ".", "cond", "(", "\n", "aspect_ratio", ">", "image_width_float", "/", "image_height_float", ",", "\n", "_requested_aspect_ratio_wider_than_image", ",", "\n", "_image_wider_than_requested_aspect_ratio", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.center_crop": [[216, 239], ["tensorflow.shape", "DG_gegerate_data._compute_crop_shape", "tensorflow.image.crop_to_bounding_box", "tensorflow.image.resize_bicubic"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data._compute_crop_shape"], ["", "def", "center_crop", "(", "image", ",", "height", ",", "width", ",", "crop_proportion", ")", ":", "\n", "  ", "\"\"\"Crops to center of image and rescales to desired size.\n  Args:\n    image: Image Tensor to crop.\n    height: Height of image to be cropped.\n    width: Width of image to be cropped.\n    crop_proportion: Proportion of image to retain along the less-cropped side.\n  Returns:\n    A `height` x `width` x channels Tensor holding a central crop of `image`.\n  \"\"\"", "\n", "shape", "=", "tf", ".", "shape", "(", "image", ")", "\n", "image_height", "=", "shape", "[", "0", "]", "\n", "image_width", "=", "shape", "[", "1", "]", "\n", "crop_height", ",", "crop_width", "=", "_compute_crop_shape", "(", "\n", "image_height", ",", "image_width", ",", "height", "/", "width", ",", "crop_proportion", ")", "\n", "offset_height", "=", "(", "(", "image_height", "-", "crop_height", ")", "+", "1", ")", "//", "2", "\n", "offset_width", "=", "(", "(", "image_width", "-", "crop_width", ")", "+", "1", ")", "//", "2", "\n", "image", "=", "tf", ".", "image", ".", "crop_to_bounding_box", "(", "\n", "image", ",", "offset_height", ",", "offset_width", ",", "crop_height", ",", "crop_width", ")", "\n", "\n", "image", "=", "tf", ".", "image", ".", "resize_bicubic", "(", "[", "image", "]", ",", "[", "height", ",", "width", "]", ")", "[", "0", "]", "\n", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.distorted_bounding_box_crop": [[241, 289], ["tensorflow.name_scope", "tensorflow.shape", "tensorflow.image.sample_distorted_bounding_box", "tensorflow.unstack", "tensorflow.unstack", "tensorflow.image.crop_to_bounding_box"], "function", ["None"], ["", "def", "distorted_bounding_box_crop", "(", "image", ",", "\n", "bbox", ",", "\n", "min_object_covered", "=", "0.1", ",", "\n", "aspect_ratio_range", "=", "(", "0.75", ",", "1.33", ")", ",", "\n", "area_range", "=", "(", "0.05", ",", "1.0", ")", ",", "\n", "max_attempts", "=", "100", ",", "\n", "scope", "=", "None", ")", ":", "\n", "  ", "\"\"\"Generates cropped_image using one of the bboxes randomly distorted.\n  See `tf.image.sample_distorted_bounding_box` for more documentation.\n  Args:\n    image: `Tensor` of image data.\n    bbox: `Tensor` of bounding boxes arranged `[1, num_boxes, coords]`\n        where each coordinate is [0, 1) and the coordinates are arranged\n        as `[ymin, xmin, ymax, xmax]`. If num_boxes is 0 then use the whole\n        image.\n    min_object_covered: An optional `float`. Defaults to `0.1`. The cropped\n        area of the image must contain at least this fraction of any bounding\n        box supplied.\n    aspect_ratio_range: An optional list of `float`s. The cropped area of the\n        image must have an aspect ratio = width / height within this range.\n    area_range: An optional list of `float`s. The cropped area of the image\n        must contain a fraction of the supplied image within in this range.\n    max_attempts: An optional `int`. Number of attempts at generating a cropped\n        region of the image of the specified constraints. After `max_attempts`\n        failures, return the entire image.\n    scope: Optional `str` for name scope.\n  Returns:\n    (cropped image `Tensor`, distorted bbox `Tensor`).\n  \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "scope", ",", "'distorted_bounding_box_crop'", ",", "[", "image", ",", "bbox", "]", ")", ":", "\n", "    ", "shape", "=", "tf", ".", "shape", "(", "image", ")", "\n", "sample_distorted_bounding_box", "=", "tf", ".", "image", ".", "sample_distorted_bounding_box", "(", "\n", "shape", ",", "\n", "bounding_boxes", "=", "bbox", ",", "\n", "min_object_covered", "=", "min_object_covered", ",", "\n", "aspect_ratio_range", "=", "aspect_ratio_range", ",", "\n", "area_range", "=", "area_range", ",", "\n", "max_attempts", "=", "max_attempts", ",", "\n", "use_image_if_no_bounding_boxes", "=", "True", ")", "\n", "bbox_begin", ",", "bbox_size", ",", "_", "=", "sample_distorted_bounding_box", "\n", "\n", "# Crop the image to the specified bounding box.", "\n", "offset_y", ",", "offset_x", ",", "_", "=", "tf", ".", "unstack", "(", "bbox_begin", ")", "\n", "target_height", ",", "target_width", ",", "_", "=", "tf", ".", "unstack", "(", "bbox_size", ")", "\n", "image", "=", "tf", ".", "image", ".", "crop_to_bounding_box", "(", "\n", "image", ",", "offset_y", ",", "offset_x", ",", "target_height", ",", "target_width", ")", "\n", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.crop_and_resize": [[291, 311], ["tensorflow.constant", "DG_gegerate_data.distorted_bounding_box_crop", "tensorflow.image.resize_bicubic"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.distorted_bounding_box_crop"], ["", "", "def", "crop_and_resize", "(", "image", ",", "height", ",", "width", ")", ":", "\n", "  ", "\"\"\"Make a random crop and resize it to height `height` and width `width`.\n  Args:\n    image: Tensor representing the image.\n    height: Desired image height.\n    width: Desired image width.\n  Returns:\n    A `height` x `width` x channels Tensor holding a random crop of `image`.\n  \"\"\"", "\n", "bbox", "=", "tf", ".", "constant", "(", "[", "0.0", ",", "0.0", ",", "1.0", ",", "1.0", "]", ",", "dtype", "=", "tf", ".", "float32", ",", "shape", "=", "[", "1", ",", "1", ",", "4", "]", ")", "\n", "aspect_ratio", "=", "width", "/", "height", "\n", "image", "=", "distorted_bounding_box_crop", "(", "\n", "image", ",", "\n", "bbox", ",", "\n", "min_object_covered", "=", "0.1", ",", "\n", "aspect_ratio_range", "=", "(", "3.", "/", "4", "*", "aspect_ratio", ",", "4.", "/", "3.", "*", "aspect_ratio", ")", ",", "\n", "area_range", "=", "(", "0.08", ",", "1.0", ")", ",", "\n", "max_attempts", "=", "100", ",", "\n", "scope", "=", "None", ")", "\n", "return", "tf", ".", "image", ".", "resize_bicubic", "(", "[", "image", "]", ",", "[", "height", ",", "width", "]", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.gaussian_blur": [[313, 349], ["tensorflow.to_int32", "tensorflow.to_float", "tensorflow.exp", "tensorflow.reduce_sum", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.tile", "tensorflow.tile", "tensorflow.nn.depthwise_conv2d", "tensorflow.nn.depthwise_conv2d", "tensorflow.range", "tensorflow.shape", "tensorflow.expand_dims", "tensorflow.squeeze", "tensorflow.pow", "tensorflow.pow", "tensorflow.to_float"], "function", ["None"], ["", "def", "gaussian_blur", "(", "image", ",", "kernel_size", ",", "sigma", ",", "padding", "=", "'SAME'", ")", ":", "\n", "  ", "\"\"\"Blurs the given image with separable convolution.\n  Args:\n    image: Tensor of shape [height, width, channels] and dtype float to blur.\n    kernel_size: Integer Tensor for the size of the blur kernel. This is should\n      be an odd number. If it is an even number, the actual kernel size will be\n      size + 1.\n    sigma: Sigma value for gaussian operator.\n    padding: Padding to use for the convolution. Typically 'SAME' or 'VALID'.\n  Returns:\n    A Tensor representing the blurred image.\n  \"\"\"", "\n", "radius", "=", "tf", ".", "to_int32", "(", "kernel_size", "/", "2", ")", "\n", "kernel_size", "=", "radius", "*", "2", "+", "1", "\n", "x", "=", "tf", ".", "to_float", "(", "tf", ".", "range", "(", "-", "radius", ",", "radius", "+", "1", ")", ")", "\n", "blur_filter", "=", "tf", ".", "exp", "(", "\n", "-", "tf", ".", "pow", "(", "x", ",", "2.0", ")", "/", "(", "2.0", "*", "tf", ".", "pow", "(", "tf", ".", "to_float", "(", "sigma", ")", ",", "2.0", ")", ")", ")", "\n", "blur_filter", "/=", "tf", ".", "reduce_sum", "(", "blur_filter", ")", "\n", "# One vertical and one horizontal filter.", "\n", "blur_v", "=", "tf", ".", "reshape", "(", "blur_filter", ",", "[", "kernel_size", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "blur_h", "=", "tf", ".", "reshape", "(", "blur_filter", ",", "[", "1", ",", "kernel_size", ",", "1", ",", "1", "]", ")", "\n", "num_channels", "=", "tf", ".", "shape", "(", "image", ")", "[", "-", "1", "]", "\n", "blur_h", "=", "tf", ".", "tile", "(", "blur_h", ",", "[", "1", ",", "1", ",", "num_channels", ",", "1", "]", ")", "\n", "blur_v", "=", "tf", ".", "tile", "(", "blur_v", ",", "[", "1", ",", "1", ",", "num_channels", ",", "1", "]", ")", "\n", "expand_batch_dim", "=", "image", ".", "shape", ".", "ndims", "==", "3", "\n", "if", "expand_batch_dim", ":", "\n", "# Tensorflow requires batched input to convolutions, which we can fake with", "\n", "# an extra dimension.", "\n", "    ", "image", "=", "tf", ".", "expand_dims", "(", "image", ",", "axis", "=", "0", ")", "\n", "", "blurred", "=", "tf", ".", "nn", ".", "depthwise_conv2d", "(", "\n", "image", ",", "blur_h", ",", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "padding", "=", "padding", ")", "\n", "blurred", "=", "tf", ".", "nn", ".", "depthwise_conv2d", "(", "\n", "blurred", ",", "blur_v", ",", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "padding", "=", "padding", ")", "\n", "if", "expand_batch_dim", ":", "\n", "    ", "blurred", "=", "tf", ".", "squeeze", "(", "blurred", ",", "axis", "=", "0", ")", "\n", "", "return", "blurred", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_crop_with_resize": [[351, 365], ["DG_gegerate_data.random_apply", "DG_gegerate_data.crop_and_resize"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.crop_and_resize"], ["", "def", "random_crop_with_resize", "(", "image", ",", "height", ",", "width", ",", "p", "=", "1.0", ")", ":", "\n", "  ", "\"\"\"Randomly crop and resize an image.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    p: Probability of applying this transformation.\n  Returns:\n    A preprocessed image `Tensor`.\n  \"\"\"", "\n", "def", "_transform", "(", "image", ")", ":", "# pylint: disable=missing-docstring", "\n", "    ", "image", "=", "crop_and_resize", "(", "image", ",", "height", ",", "width", ")", "\n", "return", "image", "\n", "", "return", "random_apply", "(", "_transform", ",", "p", "=", "p", ",", "x", "=", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_color_jitter": [[367, 375], ["DG_gegerate_data.random_apply", "functools.partial", "DG_gegerate_data.random_apply", "DG_gegerate_data.random_apply"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply"], ["", "def", "random_color_jitter", "(", "image", ",", "p", "=", "1.0", ",", "impl", "=", "'simclrv2'", ")", ":", "\n", "\n", "  ", "def", "_transform", "(", "image", ")", ":", "\n", "    ", "color_jitter_t", "=", "functools", ".", "partial", "(", "\n", "color_jitter", ",", "strength", "=", "FLAGS", ".", "color_jitter_strength", ",", "impl", "=", "impl", ")", "\n", "image", "=", "random_apply", "(", "color_jitter_t", ",", "p", "=", "0.8", ",", "x", "=", "image", ")", "\n", "return", "random_apply", "(", "to_grayscale", ",", "p", "=", "0.2", ",", "x", "=", "image", ")", "\n", "", "return", "random_apply", "(", "_transform", ",", "p", "=", "p", ",", "x", "=", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_blur": [[377, 393], ["DG_gegerate_data.random_apply", "tensorflow.random.uniform", "DG_gegerate_data.gaussian_blur"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_apply", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.gaussian_blur"], ["", "def", "random_blur", "(", "image", ",", "height", ",", "width", ",", "p", "=", "1.0", ")", ":", "\n", "  ", "\"\"\"Randomly blur an image.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    p: probability of applying this transformation.\n  Returns:\n    A preprocessed image `Tensor`.\n  \"\"\"", "\n", "del", "width", "\n", "def", "_transform", "(", "image", ")", ":", "\n", "    ", "sigma", "=", "tf", ".", "random", ".", "uniform", "(", "[", "]", ",", "0.1", ",", "2.0", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "return", "gaussian_blur", "(", "\n", "image", ",", "kernel_size", "=", "height", "//", "10", ",", "sigma", "=", "sigma", ",", "padding", "=", "'SAME'", ")", "\n", "", "return", "random_apply", "(", "_transform", ",", "p", "=", "p", ",", "x", "=", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.batch_random_blur": [[395, 421], ["tensorflow.cast", "DG_gegerate_data.random_blur", "DG_gegerate_data.batch_random_blur.generate_selector"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_blur"], ["", "def", "batch_random_blur", "(", "images_list", ",", "height", ",", "width", ",", "blur_probability", "=", "0.5", ")", ":", "\n", "  ", "\"\"\"Apply efficient batch data transformations.\n  Args:\n    images_list: a list of image tensors.\n    height: the height of image.\n    width: the width of image.\n    blur_probability: the probaility to apply the blur operator.\n  Returns:\n    Preprocessed feature list.\n  \"\"\"", "\n", "def", "generate_selector", "(", "p", ",", "bsz", ")", ":", "\n", "    ", "shape", "=", "[", "bsz", ",", "1", ",", "1", ",", "1", "]", "\n", "selector", "=", "tf", ".", "cast", "(", "\n", "tf", ".", "less", "(", "tf", ".", "random_uniform", "(", "shape", ",", "0", ",", "1", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "p", ")", ",", "\n", "tf", ".", "float32", ")", "\n", "return", "selector", "\n", "\n", "", "new_images_list", "=", "[", "]", "\n", "for", "images", "in", "images_list", ":", "\n", "    ", "images_new", "=", "random_blur", "(", "images", ",", "height", ",", "width", ",", "p", "=", "1.", ")", "\n", "selector", "=", "generate_selector", "(", "blur_probability", ",", "tf", ".", "shape", "(", "images", ")", "[", "0", "]", ")", "\n", "images", "=", "images_new", "*", "selector", "+", "images", "*", "(", "1", "-", "selector", ")", "\n", "images", "=", "tf", ".", "clip_by_value", "(", "images", ",", "0.", ",", "1.", ")", "\n", "new_images_list", ".", "append", "(", "images", ")", "\n", "\n", "", "return", "new_images_list", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.preprocess_for_train": [[423, 452], ["tensorflow.reshape", "tensorflow.clip_by_value", "DG_gegerate_data.random_crop_with_resize", "tensorflow.image.random_flip_left_right", "DG_gegerate_data.random_color_jitter"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_crop_with_resize", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.random_color_jitter"], ["", "def", "preprocess_for_train", "(", "image", ",", "\n", "height", ",", "\n", "width", ",", "\n", "color_distort", "=", "True", ",", "\n", "crop", "=", "True", ",", "\n", "flip", "=", "True", ",", "\n", "impl", "=", "'simclrv2'", ")", ":", "\n", "  ", "\"\"\"Preprocesses the given image for training.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    color_distort: Whether to apply the color distortion.\n    crop: Whether to crop the image.\n    flip: Whether or not to flip left and right of an image.\n    impl: 'simclrv1' or 'simclrv2'.  Whether to use simclrv1 or simclrv2's\n        version of random brightness.\n  Returns:\n    A preprocessed image `Tensor`.\n  \"\"\"", "\n", "if", "crop", ":", "\n", "    ", "image", "=", "random_crop_with_resize", "(", "image", ",", "height", ",", "width", ")", "\n", "", "if", "flip", ":", "\n", "    ", "image", "=", "tf", ".", "image", ".", "random_flip_left_right", "(", "image", ")", "\n", "", "if", "color_distort", ":", "\n", "    ", "image", "=", "random_color_jitter", "(", "image", ",", "impl", "=", "impl", ")", "\n", "", "image", "=", "tf", ".", "reshape", "(", "image", ",", "[", "height", ",", "width", ",", "3", "]", ")", "\n", "image", "=", "tf", ".", "clip_by_value", "(", "image", ",", "0.", ",", "1.", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.preprocess_for_eval": [[454, 469], ["tensorflow.reshape", "tensorflow.clip_by_value", "DG_gegerate_data.center_crop"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.center_crop"], ["", "def", "preprocess_for_eval", "(", "image", ",", "height", ",", "width", ",", "crop", "=", "True", ")", ":", "\n", "  ", "\"\"\"Preprocesses the given image for evaluation.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    crop: Whether or not to (center) crop the test images.\n  Returns:\n    A preprocessed image `Tensor`.\n  \"\"\"", "\n", "if", "crop", ":", "\n", "    ", "image", "=", "center_crop", "(", "image", ",", "height", ",", "width", ",", "crop_proportion", "=", "CROP_PROPORTION", ")", "\n", "", "image", "=", "tf", ".", "reshape", "(", "image", ",", "[", "height", ",", "width", ",", "3", "]", ")", "\n", "image", "=", "tf", ".", "clip_by_value", "(", "image", ",", "0.", ",", "1.", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.preprocess_image": [[471, 490], ["tensorflow.image.convert_image_dtype", "DG_gegerate_data.preprocess_for_train", "DG_gegerate_data.preprocess_for_eval"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.preprocess_for_train", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.DG_gegerate_data.preprocess_for_eval"], ["", "def", "preprocess_image", "(", "image", ",", "height", ",", "width", ",", "is_training", "=", "False", ",", "\n", "color_distort", "=", "True", ",", "test_crop", "=", "True", ")", ":", "\n", "  ", "\"\"\"Preprocesses the given image.\n  Args:\n    image: `Tensor` representing an image of arbitrary size.\n    height: Height of output image.\n    width: Width of output image.\n    is_training: `bool` for whether the preprocessing is for training.\n    color_distort: whether to apply the color distortion.\n    test_crop: whether or not to extract a central crop of the images\n        (as for standard ImageNet evaluation) during the evaluation.\n  Returns:\n    A preprocessed image `Tensor` of range [0, 1].\n  \"\"\"", "\n", "image", "=", "tf", ".", "image", ".", "convert_image_dtype", "(", "image", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "if", "is_training", ":", "\n", "    ", "return", "preprocess_for_train", "(", "image", ",", "height", ",", "width", ",", "color_distort", ")", "\n", "", "else", ":", "\n", "    ", "return", "preprocess_for_eval", "(", "image", ",", "height", ",", "width", ",", "test_crop", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.make_square": [[79, 90], ["max", "numpy.pad", "numpy.shape", "numpy.shape"], "function", ["None"], ["def", "make_square", "(", "image", ",", "max_dim", "=", "512", ")", ":", "\n", "    ", "max_dim", "=", "max", "(", "np", ".", "shape", "(", "image", ")", "[", "0", "]", ",", "np", ".", "shape", "(", "image", ")", "[", "1", "]", ")", "\n", "h", ",", "w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "top_pad", "=", "(", "max_dim", "-", "h", ")", "//", "2", "\n", "bottom_pad", "=", "max_dim", "-", "h", "-", "top_pad", "\n", "left_pad", "=", "(", "max_dim", "-", "w", ")", "//", "2", "\n", "right_pad", "=", "max_dim", "-", "w", "-", "left_pad", "\n", "padding", "=", "[", "(", "top_pad", ",", "bottom_pad", ")", ",", "(", "left_pad", ",", "right_pad", ")", ",", "(", "0", ",", "0", ")", "]", "\n", "image", "=", "np", ".", "pad", "(", "image", ",", "padding", ",", "mode", "=", "'constant'", ",", "constant_values", "=", "0", ")", "\n", "window", "=", "(", "top_pad", ",", "left_pad", ",", "h", "+", "top_pad", ",", "w", "+", "left_pad", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.get_activations": [[91, 168], ["model.eval", "numpy.empty", "range", "len", "print", "len", "len", "len", "print", "numpy.array", "images.transpose.transpose", "torch.from_numpy().type", "torch.nn.functional.adaptive_avg_pool2d.cpu().data.numpy().reshape", "print", "print", "print", "batch.cuda.cuda", "model", "torch.nn.functional.adaptive_max_pool2d", "scipy.misc.imresize().astype", "torch.from_numpy", "model", "torch.nn.functional.adaptive_avg_pool2d", "torch.nn.functional.adaptive_avg_pool2d.cpu().data.numpy", "scipy.misc.imresize", "scipy.misc.imread().astype", "torch.nn.functional.adaptive_avg_pool2d.cpu", "scipy.misc.imread", "str"], "function", ["None"], ["", "def", "get_activations", "(", "opt", ",", "files", ",", "model", ",", "batch_size", "=", "50", ",", "dims", "=", "8192", ",", "\n", "cuda", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculates the activations of the pool_3 layer for all images.\n\n    Params:\n    -- files       : List of image files paths\n    -- model       : Instance of inception model\n    -- batch_size  : Batch size of images for the model to process at once.\n                     Make sure that the number of samples is a multiple of\n                     the batch size, otherwise some samples are ignored. This\n                     behavior is retained to match the original FID score\n                     implementation.\n    -- dims        : Dimensionality of features returned by Inception\n    -- cuda        : If set to True, use GPU\n    -- verbose     : If set to True and parameter out_step is given, the number\n                     of calculated batches is reported.\n    Returns:\n    -- A numpy array of dimension (num images, dims) that contains the\n       activations of the given tensor when feeding inception with the\n       query tensor.\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "# if len(files) % batch_size != 0:", "\n", "#     print(('Warning: number of images is not a multiple of the '", "\n", "#            'batch size. Some samples are going to be ignored.'))", "\n", "if", "batch_size", ">", "len", "(", "files", ")", ":", "\n", "        ", "print", "(", "(", "'Warning: batch size is bigger than the data size. '", "\n", "'Setting batch size to data size'", ")", ")", "\n", "batch_size", "=", "len", "(", "files", ")", "\n", "\n", "", "n_batches", "=", "len", "(", "files", ")", "//", "batch_size", "\n", "n_remainder", "=", "len", "(", "files", ")", "%", "batch_size", "\n", "\n", "print", "(", "'\\rnumber of batches is %d'", "%", "n_batches", ")", ",", "\n", "n_used_imgs", "=", "n_batches", "*", "batch_size", "\n", "\n", "pred_arr", "=", "np", ".", "empty", "(", "(", "n_used_imgs", "+", "n_remainder", ",", "dims", ")", ")", "\n", "if", "n_remainder", "!=", "0", ":", "\n", "        ", "n_batches", "=", "n_batches", "+", "1", "\n", "", "for", "i", "in", "range", "(", "n_batches", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "'\\rPropagating batch %d/%d'", "%", "(", "i", "+", "1", ",", "n_batches", ")", ",", "\n", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "", "start", "=", "i", "*", "batch_size", "\n", "if", "n_remainder", "!=", "0", "and", "i", "==", "n_batches", "-", "1", ":", "\n", "          ", "end", "=", "start", "+", "n_remainder", "\n", "", "else", ":", "\n", "          ", "end", "=", "start", "+", "batch_size", "\n", "\n", "", "images", "=", "np", ".", "array", "(", "[", "misc", ".", "imresize", "(", "imread", "(", "str", "(", "f", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "size", "=", "[", "64", ",", "64", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "for", "f", "in", "files", "[", "start", ":", "end", "]", "]", ")", "\n", "\n", "images", "=", "images", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "2", ")", ")", "\n", "images", "/=", "255", "\n", "\n", "batch", "=", "torch", ".", "from_numpy", "(", "images", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", "\n", "if", "cuda", ":", "\n", "            ", "batch", "=", "batch", ".", "cuda", "(", ")", "\n", "\n", "", "if", "opt", ".", "FD_model", "==", "'inception'", ":", "\n", "            ", "pred", "=", "model", "(", "batch", ")", "[", "0", "]", "\n", "# If model output is not scalar, apply global spatial average pooling.", "\n", "# This happens if you choose a dimensionality not equal 2048.", "\n", "if", "pred", ".", "shape", "[", "2", "]", "!=", "1", "or", "pred", ".", "shape", "[", "3", "]", "!=", "1", ":", "\n", "                ", "pred", "=", "adaptive_avg_pool2d", "(", "pred", ",", "output_size", "=", "(", "1", ",", "1", ")", ")", "\n", "", "", "if", "opt", ".", "FD_model", "==", "'posenet'", ":", "\n", "            ", "pred", "=", "model", "(", "batch", ")", "\n", "# print (np.shape (pred))", "\n", "pred", "=", "adaptive_max_pool2d", "(", "pred", ",", "output_size", "=", "(", "1", ",", "1", ")", ")", "\n", "", "pred_arr", "[", "start", ":", "end", "]", "=", "pred", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "reshape", "(", "end", "-", "start", ",", "-", "1", ")", "\n", "print", "(", "'\\rPropagating batch %d/%d'", "%", "(", "i", "+", "1", ",", "n_batches", ")", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "' done'", ")", "\n", "\n", "", "return", "pred_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.calculate_frechet_distance": [[170, 225], ["numpy.atleast_1d", "numpy.atleast_1d", "numpy.atleast_2d", "numpy.atleast_2d", "scipy.linalg.sqrtm", "numpy.iscomplexobj", "numpy.trace", "np.atleast_2d.dot", "numpy.isfinite().all", "print", "scipy.linalg.sqrtm", "numpy.eye", "numpy.allclose", "numpy.max", "ValueError", "numpy.trace", "numpy.isfinite", "numpy.abs", "diff.dot", "numpy.trace", "numpy.diagonal"], "function", ["None"], ["", "def", "calculate_frechet_distance", "(", "mu1", ",", "sigma1", ",", "mu2", ",", "sigma2", ",", "eps", "=", "1e-6", ")", ":", "\n", "    ", "\"\"\"Numpy implementation of the Frechet Distance.\n    The Frechet distance between two multivariate Gaussians X_1 ~ N(mu_1, C_1)\n    and X_2 ~ N(mu_2, C_2) is\n            d^2 = ||mu_1 - mu_2||^2 + Tr(C_1 + C_2 - 2*sqrt(C_1*C_2)).\n\n    Stable version by Dougal J. Sutherland.\n\n    Params:\n    -- mu1   : Numpy array containing the activations of a layer of the\n               inception net (like returned by the function 'get_predictions')\n               for generated samples.\n    -- mu2   : The sample mean over activations, precalculated on an\n               representative data set.\n    -- sigma1: The covariance matrix over activations for generated samples.\n    -- sigma2: The covariance matrix over activations, precalculated on an\n               representative data set.\n\n    Returns:\n    --   : The Frechet Distance.\n    \"\"\"", "\n", "\n", "mu1", "=", "np", ".", "atleast_1d", "(", "mu1", ")", "\n", "mu2", "=", "np", ".", "atleast_1d", "(", "mu2", ")", "\n", "\n", "sigma1", "=", "np", ".", "atleast_2d", "(", "sigma1", ")", "\n", "sigma2", "=", "np", ".", "atleast_2d", "(", "sigma2", ")", "\n", "\n", "assert", "mu1", ".", "shape", "==", "mu2", ".", "shape", ",", "'Training and test mean vectors have different lengths'", "\n", "assert", "sigma1", ".", "shape", "==", "sigma2", ".", "shape", ",", "'Training and test covariances have different dimensions'", "\n", "\n", "diff", "=", "mu1", "-", "mu2", "\n", "\n", "# Product might be almost singular", "\n", "covmean", ",", "_", "=", "linalg", ".", "sqrtm", "(", "sigma1", ".", "dot", "(", "sigma2", ")", ",", "disp", "=", "False", ")", "\n", "if", "not", "np", ".", "isfinite", "(", "covmean", ")", ".", "all", "(", ")", ":", "\n", "        ", "msg", "=", "(", "'fid calculation produces singular product; '", "\n", "'adding %s to diagonal of cov estimates'", ")", "%", "eps", "\n", "print", "(", "msg", ")", "\n", "offset", "=", "np", ".", "eye", "(", "sigma1", ".", "shape", "[", "0", "]", ")", "*", "eps", "\n", "covmean", "=", "linalg", ".", "sqrtm", "(", "(", "sigma1", "+", "offset", ")", ".", "dot", "(", "sigma2", "+", "offset", ")", ")", "\n", "\n", "# Numerical error might give slight imaginary component", "\n", "", "if", "np", ".", "iscomplexobj", "(", "covmean", ")", ":", "\n", "        ", "if", "not", "np", ".", "allclose", "(", "np", ".", "diagonal", "(", "covmean", ")", ".", "imag", ",", "0", ",", "atol", "=", "1e-3", ")", ":", "\n", "            ", "m", "=", "np", ".", "max", "(", "np", ".", "abs", "(", "covmean", ".", "imag", ")", ")", "\n", "raise", "ValueError", "(", "'Imaginary component {}'", ".", "format", "(", "m", ")", ")", "\n", "", "covmean", "=", "covmean", ".", "real", "\n", "\n", "", "tr_covmean", "=", "np", ".", "trace", "(", "covmean", ")", "\n", "\n", "return", "(", "diff", ".", "dot", "(", "diff", ")", "+", "np", ".", "trace", "(", "sigma1", ")", "+", "\n", "np", ".", "trace", "(", "sigma2", ")", "-", "2", "*", "tr_covmean", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.calculate_activation_statistics": [[227, 253], ["fd_score.get_activations", "numpy.mean", "numpy.cov", "np.cov.diagonal().sum", "np.cov.diagonal"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.get_activations"], ["", "def", "calculate_activation_statistics", "(", "opt", ",", "files", ",", "model", ",", "batch_size", "=", "50", ",", "\n", "dims", "=", "8192", ",", "cuda", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculation of the statistics used by the FID.\n    Params:\n    -- files       : List of image files paths\n    -- model       : Instance of inception model\n    -- batch_size  : The images numpy array is split into batches with\n                     batch size batch_size. A reasonable batch size\n                     depends on the hardware.\n    -- dims        : Dimensionality of features returned by Inception\n    -- cuda        : If set to True, use GPU\n    -- verbose     : If set to True and parameter out_step is given, the\n                     number of calculated batches is reported.\n    Returns:\n    -- mu    : The mean over samples of the activations of the pool_3 layer of\n               the inception model.\n    -- sigma : The covariance matrix of the activations of the pool_3 layer of\n               the inception model.\n    \"\"\"", "\n", "act", "=", "get_activations", "(", "opt", ",", "files", ",", "model", ",", "batch_size", ",", "dims", ",", "cuda", ",", "verbose", ")", "\n", "mu", "=", "np", ".", "mean", "(", "act", ",", "axis", "=", "0", ")", "\n", "sigma", "=", "np", ".", "cov", "(", "act", ",", "rowvar", "=", "False", ")", "\n", "#eigen_vals, eigen_vecs= np.linalg.eig(sigma)", "\n", "#sum_eigen_val=eigen_vals.sum().real", "\n", "sum_eigen_val", "=", "(", "sigma", ".", "diagonal", "(", ")", ")", ".", "sum", "(", ")", "\n", "return", "mu", ",", "sigma", ",", "sum_eigen_val", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score._compute_statistics_of_path": [[255, 268], ["pathlib.Path.endswith", "numpy.load", "np.load.close", "pathlib.Path", "fd_score.calculate_activation_statistics", "list", "list", "pathlib.Path.glob", "pathlib.Path.glob"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.calculate_activation_statistics"], ["", "def", "_compute_statistics_of_path", "(", "opt", ",", "path", ",", "model", ",", "batch_size", ",", "dims", ",", "cuda", ")", ":", "\n", "    ", "if", "path", ".", "endswith", "(", "'.npz'", ")", ":", "\n", "        ", "f", "=", "np", ".", "load", "(", "path", ")", "\n", "m", ",", "s", "=", "f", "[", "'mu'", "]", "[", ":", "]", ",", "f", "[", "'sigma'", "]", "[", ":", "]", "\n", "f", ".", "close", "(", ")", "\n", "", "else", ":", "\n", "        ", "path", "=", "pathlib", ".", "Path", "(", "path", ")", "\n", "files", "=", "list", "(", "path", ".", "glob", "(", "'*.jpg'", ")", ")", "+", "list", "(", "path", ".", "glob", "(", "'*.png'", ")", ")", "\n", "#random.shuffle(files)", "\n", "#files = files[:2000]", "\n", "m", ",", "s", ",", "sum_eigen_val", "=", "calculate_activation_statistics", "(", "opt", ",", "files", ",", "model", ",", "batch_size", ",", "\n", "dims", ",", "cuda", ")", "\n", "", "return", "m", ",", "s", ",", "sum_eigen_val", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.get_id_path_of_data": [[270, 296], ["re.compile", "pathlib.Path", "dataset_ids.extend", "img_paths.extend", "map", "person_ids.append", "dataset.append", "list", "list", "re.compile.search().groups", "pathlib.Path.glob", "pathlib.Path.glob", "range", "len", "re.compile.search", "str"], "function", ["None"], ["", "def", "get_id_path_of_data", "(", "dataset_id", ",", "paths", ")", ":", "\n", "    ", "img_paths", "=", "[", "]", "\n", "dataset_ids", "=", "[", "]", "\n", "person_ids", "=", "[", "]", "\n", "pattern", "=", "re", ".", "compile", "(", "r'([-\\d]+)_c([-\\d]+)'", ")", "\n", "did", "=", "0", "\n", "for", "sub_path", "in", "paths", ":", "\n", "        ", "sub_path", "=", "pathlib", ".", "Path", "(", "sub_path", ")", "\n", "files", "=", "list", "(", "sub_path", ".", "glob", "(", "'*.jpg'", ")", ")", "+", "list", "(", "sub_path", ".", "glob", "(", "'*.png'", ")", ")", "\n", "# files=glob.glob(osp.join(sub_path, '*.png'))+glob.glob(osp.join(sub_path, '*.jpg'))", "\n", "dataset_id_list", "=", "[", "dataset_id", "[", "did", "]", "for", "n", "in", "range", "(", "len", "(", "files", ")", ")", "]", "\n", "dataset_ids", ".", "extend", "(", "dataset_id_list", ")", "\n", "img_paths", ".", "extend", "(", "files", ")", "\n", "did", "+=", "1", "\n", "", "dataset", "=", "[", "]", "\n", "ii", "=", "0", "\n", "for", "img_path", "in", "img_paths", ":", "\n", "        ", "pid", ",", "camid", "=", "map", "(", "int", ",", "pattern", ".", "search", "(", "str", "(", "img_path", ")", ")", ".", "groups", "(", ")", ")", "\n", "# if pid == -1: continue  # junk images are just ignored", "\n", "camid", "-=", "1", "# index starts from 0", "\n", "dataid", "=", "dataset_ids", "[", "ii", "]", "\n", "person_ids", ".", "append", "(", "pid", ")", "\n", "dataset", ".", "append", "(", "(", "img_path", ",", "pid", ",", "dataid", ")", ")", "\n", "ii", "=", "ii", "+", "1", "\n", "\n", "", "return", "img_paths", ",", "person_ids", ",", "dataset_ids", ",", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.clustering_sample": [[297, 450], ["fd_score.get_id_path_of_data", "print", "pathlib.Path", "fd_score.get_activations", "numpy.mean", "numpy.cov", "np.cov.diagonal().sum", "numpy.array", "numpy.r_[].squeeze", "numpy.delete", "numpy.delete", "print", "print", "numpy.array", "numpy.array", "scipy.special.softmax", "scipy.special.softmax", "range", "range", "numpy.sort", "print", "fd_score.dataset_build", "print", "domain_gap.models.inception.InceptionV3", "domain_gap.models.inception.InceptionV3.cuda", "list", "list", "os.path.exists", "os.path.exists", "print", "fd_score.get_activations", "numpy.save", "numpy.load", "os.path.exists", "os.path.exists", "numpy.save", "numpy.save", "numpy.load", "numpy.load", "os.path.exists", "os.path.exists", "sklearn.cluster.KMeans", "sklearn.cluster.KMeans.fit", "numpy.save", "numpy.load", "os.path.exists", "os.path.exists", "tqdm", "numpy.save", "numpy.load", "c_num_len.append", "len", "id_score.append", "numpy.random.choice", "os.path.isdir", "os.path.isdir", "os.mkdir", "os.mkdir", "os.path.exists", "os.path.exists", "RuntimeError", "pathlib.Path.glob", "pathlib.Path.glob", "np.cov.diagonal", "os.path.isdir", "os.path.isdir", "os.mkdir", "os.mkdir", "numpy.argwhere().squeeze", "set", "range", "range", "cluster_feature.append", "numpy.mean", "numpy.cov", "numpy.abs", "fd_score.calculate_frechet_distance", "cluster_fid.append", "cluster_var_gap.append", "len", "range", "numpy.argwhere().squeeze", "feature_per_id.mean", "np.load.append", "pid_per_id.append", "did_per_id.append", "len", "len", "numpy.argwhere", "numpy.array", "numpy.array", "str", "str", "str", "np.cov.diagonal().sum", "numpy.argwhere", "numpy.argwhere", "numpy.argwhere", "numpy.array", "numpy.array", "numpy.array", "np.cov.diagonal", "numpy.array"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.get_id_path_of_data", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.get_activations", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.dataset_build", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.get_activations", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.calculate_frechet_distance"], ["", "def", "clustering_sample", "(", "tpaths", ",", "dict", ",", "dataset_id", ",", "opt", ",", "result_dir", ",", "c_num", ",", "score_name", ",", "weight", ",", "n_num", ")", ":", "\n", "    ", "\"\"\"clustering the ids from different datasets and sampleing\"\"\"", "\n", "\n", "# preparing dataset", "\n", "paths", "=", "[", "dict", "[", "i", "]", "+", "'bounding_box_test'", "for", "i", "in", "dataset_id", "]", "\n", "img_paths", ",", "person_ids", ",", "dataset_ids", ",", "_", "=", "get_id_path_of_data", "(", "dataset_id", ",", "paths", ")", "\n", "\n", "cuda", "=", "True", "\n", "for", "p", "in", "paths", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "p", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'Invalid path: %s'", "%", "p", ")", "\n", "\n", "", "", "if", "opt", ".", "FD_model", "==", "'inception'", ":", "\n", "        ", "dims", "=", "2048", "\n", "block_idx", "=", "InceptionV3", ".", "BLOCK_INDEX_BY_DIM", "[", "dims", "]", "\n", "model", "=", "InceptionV3", "(", "[", "block_idx", "]", ")", "\n", "\n", "", "if", "cuda", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "", "batch_size", "=", "256", "\n", "\n", "# caculate the various, mu sigma of target ste", "\n", "print", "(", "'=========== extracting feature of target traning set ==========='", ")", "\n", "target_path", "=", "pathlib", ".", "Path", "(", "tpaths", ")", "\n", "files", "=", "list", "(", "target_path", ".", "glob", "(", "'*.jpg'", ")", ")", "+", "list", "(", "target_path", ".", "glob", "(", "'*.png'", ")", ")", "\n", "# random.shuffle(files)", "\n", "# files = files[:2000]", "\n", "target_feature", "=", "get_activations", "(", "opt", ",", "files", ",", "model", ",", "batch_size", ",", "dims", ",", "cuda", ",", "verbose", "=", "False", ")", "\n", "m1", "=", "np", ".", "mean", "(", "target_feature", ",", "axis", "=", "0", ")", "\n", "s1", "=", "np", ".", "cov", "(", "target_feature", ",", "rowvar", "=", "False", ")", "\n", "sum_eigen_val1", "=", "(", "s1", ".", "diagonal", "(", ")", ")", ".", "sum", "(", ")", "\n", "\n", "\n", "# extracter feature for data pool", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "result_dir", "+", "'/feature.npy'", ")", ":", "\n", "        ", "print", "(", "'=========== extracting feature of data pool ==========='", ")", "\n", "feature", "=", "get_activations", "(", "opt", ",", "img_paths", ",", "model", ",", "batch_size", ",", "dims", ",", "cuda", ",", "verbose", "=", "False", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "result_dir", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "result_dir", ")", "\n", "", "np", ".", "save", "(", "result_dir", "+", "'/feature.npy'", ",", "feature", ")", "\n", "", "else", ":", "\n", "        ", "feature", "=", "np", ".", "load", "(", "result_dir", "+", "'/feature.npy'", ")", "\n", "\n", "", "person_ids_array", "=", "np", ".", "array", "(", "person_ids", ")", "\n", "mean_feature_per_id", "=", "[", "]", "\n", "pid_per_id", "=", "[", "]", "\n", "did_per_id", "=", "[", "]", "\n", "\n", "# get mean fature of perid and the fid, various of per_id with the target", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "result_dir", "+", "'/mean_feature_per_id.npy'", ")", ":", "\n", "        ", "for", "did", "in", "dataset_id", ":", "\n", "           ", "ind_of_set", "=", "np", ".", "argwhere", "(", "np", ".", "array", "(", "dataset_ids", ")", "==", "did", ")", ".", "squeeze", "(", ")", "\n", "dataset_feature", "=", "feature", "[", "ind_of_set", "]", "\n", "dataset_pid", "=", "person_ids_array", "[", "ind_of_set", "]", "\n", "pid_of_dataset", "=", "set", "(", "dataset_pid", ")", "\n", "for", "pid", "in", "pid_of_dataset", ":", "\n", "              ", "ind_of_pid", "=", "np", ".", "argwhere", "(", "np", ".", "array", "(", "dataset_pid", ")", "==", "pid", ")", ".", "squeeze", "(", ")", "\n", "feature_per_id", "=", "dataset_feature", "[", "ind_of_pid", "]", "\n", "id_ave_feature", "=", "feature_per_id", ".", "mean", "(", "0", ")", "\n", "mean_feature_per_id", ".", "append", "(", "id_ave_feature", ")", "\n", "pid_per_id", ".", "append", "(", "pid", ")", "\n", "did_per_id", ".", "append", "(", "did", ")", "\n", "", "", "np", ".", "save", "(", "result_dir", "+", "'/mean_feature_per_id.npy'", ",", "mean_feature_per_id", ")", "\n", "pid_did_fid_var", "=", "np", ".", "c_", "[", "np", ".", "array", "(", "pid_per_id", ")", ",", "np", ".", "array", "(", "did_per_id", ")", "]", "\n", "np", ".", "save", "(", "result_dir", "+", "'/pid_did_fid_var.npy'", ",", "pid_did_fid_var", ")", "\n", "", "else", ":", "\n", "       ", "mean_feature_per_id", "=", "np", ".", "load", "(", "result_dir", "+", "'/mean_feature_per_id.npy'", ")", "\n", "pid_did_fid_var", "=", "np", ".", "load", "(", "result_dir", "+", "'/pid_did_fid_var.npy'", ")", "\n", "\n", "#remove 0 and -1", "\n", "", "ori_pid_per_id", "=", "pid_did_fid_var", "[", ":", ",", "0", "]", "\n", "remove_ind", "=", "np", ".", "r_", "[", "np", ".", "argwhere", "(", "ori_pid_per_id", "==", "-", "1", ")", ",", "np", ".", "argwhere", "(", "ori_pid_per_id", "==", "0", ")", "]", ".", "squeeze", "(", ")", "\n", "\n", "new_pid_did_fid_var", "=", "np", ".", "delete", "(", "pid_did_fid_var", ",", "remove_ind", ",", "0", ")", "\n", "new_mean_feature_per_id", "=", "np", ".", "delete", "(", "mean_feature_per_id", ",", "remove_ind", ",", "0", ")", "\n", "\n", "\n", "print", "(", "'\\r=========== clustering the data pool ==========='", ")", "\n", "pid_per_id", "=", "new_pid_did_fid_var", "[", ":", ",", "0", "]", "\n", "did_per_id", "=", "new_pid_did_fid_var", "[", ":", ",", "1", "]", "\n", "# clustering ids based on ids' mean feature", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "result_dir", "+", "'/label_cluster_'", "+", "str", "(", "c_num", ")", "+", "'.npy'", ")", ":", "\n", "        ", "estimator", "=", "KMeans", "(", "n_clusters", "=", "c_num", ")", "\n", "estimator", ".", "fit", "(", "new_mean_feature_per_id", ")", "\n", "label_pred", "=", "estimator", ".", "labels_", "\n", "np", ".", "save", "(", "result_dir", "+", "'/label_cluster_'", "+", "str", "(", "c_num", ")", "+", "'.npy'", ",", "label_pred", ")", "\n", "", "else", ":", "\n", "        ", "label_pred", "=", "np", ".", "load", "(", "'sample_data/'", "+", "'/label_cluster_'", "+", "str", "(", "c_num", ")", "+", "'.npy'", ")", "\n", "\n", "", "print", "(", "'\\r=========== caculating the fid and v_gap between T and C_k ==========='", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "result_dir", "+", "'/cluster_fid_var.npy'", ")", ":", "\n", "        ", "cluster_feature", "=", "[", "]", "\n", "cluster_fid", "=", "[", "]", "\n", "cluster_mmd", "=", "[", "]", "\n", "cluster_var_gap", "=", "[", "]", "\n", "for", "k", "in", "tqdm", "(", "range", "(", "c_num", ")", ")", ":", "\n", "# initializatn of the first seed cluster 0", "\n", "            ", "initial_pid", "=", "pid_per_id", "[", "label_pred", "==", "k", "]", "\n", "initial_did", "=", "did_per_id", "[", "label_pred", "==", "k", "]", "\n", "initial_feature", "=", "feature", "[", "(", "dataset_ids", "==", "initial_did", "[", "0", "]", ")", "&", "(", "person_ids_array", "==", "initial_pid", "[", "0", "]", ")", "]", "\n", "for", "j", "in", "range", "(", "1", ",", "len", "(", "initial_pid", ")", ")", ":", "\n", "                ", "current_feature", "=", "feature", "[", "(", "dataset_ids", "==", "initial_did", "[", "j", "]", ")", "&", "(", "person_ids_array", "==", "initial_pid", "[", "j", "]", ")", "]", "\n", "initial_feature", "=", "np", ".", "r_", "[", "initial_feature", ",", "current_feature", "]", "\n", "", "cluster_feature", ".", "append", "(", "initial_feature", ")", "\n", "mu", "=", "np", ".", "mean", "(", "initial_feature", ",", "axis", "=", "0", ")", "\n", "sigma", "=", "np", ".", "cov", "(", "initial_feature", ",", "rowvar", "=", "False", ")", "\n", "# caculating various", "\n", "current_var_gap", "=", "np", ".", "abs", "(", "(", "sigma", ".", "diagonal", "(", ")", ")", ".", "sum", "(", ")", "-", "sum_eigen_val1", ")", "\n", "current_fid", "=", "calculate_frechet_distance", "(", "m1", ",", "s1", ",", "mu", ",", "sigma", ")", "\n", "# mmd_value = polynomial_mmd_averages(torch.from_numpy(initial_feature), torch.from_numpy(target_feature))", "\n", "# current_mmd=mmd_value[0].mean()", "\n", "cluster_fid", ".", "append", "(", "current_fid", ")", "\n", "# cluster_mmd.append(current_mmd)", "\n", "cluster_var_gap", ".", "append", "(", "current_var_gap", ")", "\n", "", "np", ".", "save", "(", "result_dir", "+", "'/cluster_fid_var.npy'", ",", "np", ".", "c_", "[", "np", ".", "array", "(", "cluster_fid", ")", ",", "np", ".", "array", "(", "cluster_var_gap", ")", "]", ")", "\n", "#np.save(result_dir+'/cluster_fid_var.npy', np.c_[np.array(cluster_fid),np.array(cluster_var_gap)])", "\n", "", "else", ":", "\n", "        ", "cluster_fid_var", "=", "np", ".", "load", "(", "result_dir", "+", "'/cluster_fid_var.npy'", ")", "\n", "cluster_fid", "=", "cluster_fid_var", "[", ":", ",", "0", "]", "\n", "cluster_var_gap", "=", "cluster_fid_var", "[", ":", ",", "1", "]", "\n", "\n", "#    cluster_fid=cluster_mmd", "\n", "#    calculatting softmax score", "\n", "", "cluster_fida", "=", "np", ".", "array", "(", "cluster_fid", ")", "\n", "cluster_var_gapa", "=", "np", ".", "array", "(", "cluster_var_gap", ")", "\n", "score_fid", "=", "softmax", "(", "-", "cluster_fida", ")", "\n", "score_var_gap", "=", "softmax", "(", "-", "cluster_var_gapa", ")", "\n", "if", "score_name", "==", "'fid'", ":", "\n", "        ", "sample_rate", "=", "score_fid", "\n", "", "elif", "score_name", "==", "'var'", ":", "\n", "        ", "sample_rate", "=", "score_var_gap", "\n", "", "else", ":", "\n", "        ", "sample_rate", "=", "score_fid", "*", "weight", "+", "score_var_gap", "*", "(", "1", "-", "weight", ")", "\n", "\n", "", "c_num_len", "=", "[", "]", "\n", "id_score", "=", "[", "]", "\n", "for", "kk", "in", "range", "(", "c_num", ")", ":", "\n", "        ", "initial_pid", "=", "pid_per_id", "[", "label_pred", "==", "kk", "]", "\n", "c_num_len", ".", "append", "(", "len", "(", "initial_pid", ")", ")", "\n", "", "for", "jj", "in", "range", "(", "len", "(", "label_pred", ")", ")", ":", "\n", "        ", "id_score", ".", "append", "(", "sample_rate", "[", "label_pred", "[", "jj", "]", "]", "/", "c_num_len", "[", "label_pred", "[", "jj", "]", "]", ")", "\n", "\n", "", "selected_data_ind", "=", "np", ".", "sort", "(", "np", ".", "random", ".", "choice", "(", "range", "(", "len", "(", "id_score", ")", ")", ",", "n_num", ",", "p", "=", "id_score", ")", ")", "\n", "sdid", "=", "did_per_id", "[", "selected_data_ind", "]", "\n", "spid", "=", "pid_per_id", "[", "selected_data_ind", "]", "\n", "data_dir", "=", "result_dir", "+", "'/proxy_set'", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "data_dir", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "data_dir", ")", "\n", "", "print", "(", "'\\r=========== building proxy set ==========='", ")", "\n", "sampled_data", "=", "np", ".", "c_", "[", "sdid", ",", "spid", "]", "\n", "ii", "=", "dataset_build", "(", "dict", ",", "dataset_id", ",", "sampled_data", ",", "data_dir", ")", "\n", "print", "(", "'finished'", ")", "\n", "return", "sampled_data", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.dataset_build": [[452, 492], ["re.compile", "range", "numpy.arange", "len", "os.walk", "os.walk", "os.walk", "os.walk", "len", "map", "shutil.copyfile", "shutil.copyfile", "re.compile.search().groups", "int", "os.path.isdir", "os.path.isdir", "os.mkdir", "os.mkdir", "os.mkdir", "os.mkdir", "shutil.copyfile", "int", "os.path.isdir", "os.path.isdir", "os.mkdir", "os.mkdir", "re.compile.search", "str"], "function", ["None"], ["", "def", "dataset_build", "(", "dict", ",", "dataset_id", ",", "sampled_data", ",", "result_dir", ")", ":", "\n", "    ", "pattern", "=", "re", ".", "compile", "(", "r'([-\\d]+)_c([-\\d]+)'", ")", "\n", "pid", "=", "sampled_data", "[", ":", ",", "1", "]", "\n", "new_pid", "=", "np", ".", "arange", "(", "len", "(", "pid", ")", ")", "+", "1", "\n", "did", "=", "sampled_data", "[", ":", ",", "0", "]", "\n", "\n", "for", "ii", "in", "range", "(", "len", "(", "pid", ")", ")", ":", "\n", "        ", "id", "=", "pid", "[", "ii", "]", "\n", "id_set", "=", "did", "[", "ii", "]", "\n", "new_id", "=", "new_pid", "[", "ii", "]", "\n", "# sample images", "\n", "gallery_data_path", "=", "dict", "[", "id_set", "]", "+", "'bounding_box_test'", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "gallery_data_path", ",", "topdown", "=", "True", ")", ":", "\n", "            ", "for", "name", "in", "files", ":", "\n", "                ", "current_id", ",", "_", "=", "map", "(", "int", ",", "pattern", ".", "search", "(", "str", "(", "name", ")", ")", ".", "groups", "(", ")", ")", "\n", "if", "not", "(", "name", "[", "-", "3", ":", "]", "==", "'png'", "or", "name", "[", "-", "3", ":", "]", "==", "'jpg'", ")", ":", "\n", "                    ", "continue", "\n", "", "if", "int", "(", "current_id", ")", "!=", "id", ":", "\n", "                    ", "continue", "\n", "", "src_path", "=", "gallery_data_path", "+", "'/'", "+", "name", "\n", "dst_path", "=", "result_dir", "+", "'/bounding_box_test'", "\n", "dstr_path", "=", "result_dir", "+", "'/bounding_box_train'", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "dst_path", ")", ":", "\n", "                    ", "os", ".", "mkdir", "(", "dst_path", ")", "\n", "os", ".", "mkdir", "(", "dstr_path", ")", "\n", "# one picture in train", "\n", "copyfile", "(", "src_path", ",", "dstr_path", "+", "'/'", "+", "'{:04}'", ".", "format", "(", "new_id", ")", "+", "name", "[", "4", ":", "-", "3", "]", "+", "'jpg'", ")", "\n", "", "copyfile", "(", "src_path", ",", "dst_path", "+", "'/'", "+", "'{:04}'", ".", "format", "(", "new_id", ")", "+", "name", "[", "4", ":", "-", "3", "]", "+", "'jpg'", ")", "\n", "", "", "query_data_path", "=", "gallery_data_path", "[", "0", ":", "-", "18", "]", "+", "'/query'", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "query_data_path", ",", "topdown", "=", "True", ")", ":", "\n", "            ", "for", "name", "in", "files", ":", "\n", "                ", "if", "not", "(", "name", "[", "-", "3", ":", "]", "==", "'png'", "or", "name", "[", "-", "3", ":", "]", "==", "'jpg'", ")", ":", "\n", "                    ", "continue", "\n", "", "if", "int", "(", "name", "[", "0", ":", "4", "]", ")", "!=", "id", ":", "\n", "                    ", "continue", "\n", "", "src_path", "=", "query_data_path", "+", "'/'", "+", "name", "\n", "dst_path", "=", "result_dir", "+", "'/query'", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "dst_path", ")", ":", "\n", "                    ", "os", ".", "mkdir", "(", "dst_path", ")", "\n", "", "copyfile", "(", "src_path", ",", "dst_path", "+", "'/'", "+", "'{:04}'", ".", "format", "(", "new_id", ")", "+", "name", "[", "4", ":", "-", "3", "]", "+", "'jpg'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score.calculate_fd_given_paths": [[495, 528], ["fd_score._compute_statistics_of_path", "fd_score._compute_statistics_of_path", "fd_score.calculate_frechet_distance", "domain_gap.models.inception.InceptionV3", "domain_gap.models.inception.InceptionV3.cuda", "paths[].endswith", "numpy.savez", "os.path.exists", "os.path.exists", "RuntimeError", "paths[].endswith"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._compute_statistics_of_path", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._compute_statistics_of_path", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.calculate_frechet_distance"], ["", "", "", "", "def", "calculate_fd_given_paths", "(", "paths", ",", "opt", ")", ":", "\n", "    ", "\"\"\"Calculates the FID of two paths\"\"\"", "\n", "\n", "cuda", "=", "True", "\n", "for", "p", "in", "paths", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "p", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'Invalid path: %s'", "%", "p", ")", "\n", "\n", "", "", "if", "opt", ".", "FD_model", "==", "'inception'", ":", "\n", "        ", "dims", "=", "2048", "\n", "block_idx", "=", "InceptionV3", ".", "BLOCK_INDEX_BY_DIM", "[", "dims", "]", "\n", "model", "=", "InceptionV3", "(", "[", "block_idx", "]", ")", "\n", "\n", "", "if", "cuda", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "\n", "", "m1", ",", "s1", ",", "sum_eigen_val1", "=", "_compute_statistics_of_path", "(", "opt", ",", "paths", "[", "0", "]", ",", "model", ",", "256", ",", "\n", "dims", ",", "cuda", ")", "\n", "\n", "npz_path", "=", "None", "\n", "if", "not", "paths", "[", "0", "]", ".", "endswith", "(", "\".npz\"", ")", ":", "\n", "        ", "if", "not", "paths", "[", "0", "]", ".", "endswith", "(", "'/'", ")", ":", "\n", "            ", "npz_path", "=", "paths", "[", "0", "]", "+", "\".npz\"", "\n", "", "else", ":", "\n", "            ", "npz_path", "=", "paths", "[", "0", "]", "[", ":", "-", "1", "]", "+", "\".npz\"", "\n", "", "np", ".", "savez", "(", "npz_path", ",", "mu", "=", "m1", ",", "sigma", "=", "s1", ")", "\n", "", "m2", ",", "s2", ",", "sum_eigen_val2", "=", "_compute_statistics_of_path", "(", "opt", ",", "paths", "[", "1", "]", ",", "model", ",", "256", ",", "\n", "dims", ",", "cuda", ")", "\n", "\n", "\n", "fd_value", "=", "calculate_frechet_distance", "(", "m1", ",", "s1", ",", "m2", ",", "s2", ")", "\n", "\n", "return", "fd_value", ",", "npz_path", ",", "sum_eigen_val1", ",", "sum_eigen_val2", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.make_square": [[71, 82], ["max", "numpy.pad", "numpy.shape", "numpy.shape"], "function", ["None"], ["def", "make_square", "(", "image", ",", "max_dim", "=", "512", ")", ":", "\n", "    ", "max_dim", "=", "max", "(", "np", ".", "shape", "(", "image", ")", "[", "0", "]", ",", "np", ".", "shape", "(", "image", ")", "[", "1", "]", ")", "\n", "h", ",", "w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "top_pad", "=", "(", "max_dim", "-", "h", ")", "//", "2", "\n", "bottom_pad", "=", "max_dim", "-", "h", "-", "top_pad", "\n", "left_pad", "=", "(", "max_dim", "-", "w", ")", "//", "2", "\n", "right_pad", "=", "max_dim", "-", "w", "-", "left_pad", "\n", "padding", "=", "[", "(", "top_pad", ",", "bottom_pad", ")", ",", "(", "left_pad", ",", "right_pad", ")", ",", "(", "0", ",", "0", ")", "]", "\n", "image", "=", "np", ".", "pad", "(", "image", ",", "padding", ",", "mode", "=", "'constant'", ",", "constant_values", "=", "0", ")", "\n", "window", "=", "(", "top_pad", ",", "left_pad", ",", "h", "+", "top_pad", ",", "w", "+", "left_pad", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.get_activations": [[83, 162], ["model.eval", "numpy.empty", "range", "print", "len", "numpy.zeros", "np.zeros.transpose", "torch.from_numpy().type", "torch.nn.functional.adaptive_avg_pool2d.cpu().data.numpy().reshape", "print", "numpy.shape", "numpy.shape", "print", "len", "batch.cuda.cuda", "model", "torch.nn.functional.adaptive_max_pool2d", "model", "numpy.shape", "torch.from_numpy", "model", "torch.nn.functional.adaptive_avg_pool2d", "torch.nn.functional.adaptive_avg_pool2d.cpu().data.numpy", "torch.nn.functional.adaptive_avg_pool2d.cpu"], "function", ["None"], ["", "def", "get_activations", "(", "size", ",", "target_model", ",", "data_i", ",", "model", ",", "batch_size", "=", "50", ",", "dims", "=", "8192", ",", "\n", "cuda", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculates the activations of the pool_3 layer for all images.\n\n    Params:\n    -- files       : List of image files paths\n    -- model       : Instance of inception model\n    -- batch_size  : Batch size of images for the model to process at once.\n                     Make sure that the number of samples is a multiple of\n                     the batch size, otherwise some samples are ignored. This\n                     behavior is retained to match the original FID score\n                     implementation.\n    -- dims        : Dimensionality of features returned by Inception\n    -- cuda        : If set to True, use GPU\n    -- verbose     : If set to True and parameter out_step is given, the number\n                     of calculated batches is reported.\n    Returns:\n    -- A numpy array of dimension (num images, dims) that contains the\n       activations of the given tensor when feeding inception with the\n       query tensor.\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "# if len(files) % batch_size != 0:", "\n", "#     print(('Warning: number of images is not a multiple of the '", "\n", "#            'batch size. Some samples are going to be ignored.'))", "\n", "if", "batch_size", ">", "np", ".", "shape", "(", "data_i", ")", "[", "0", "]", ":", "\n", "        ", "print", "(", "(", "'Warning: batch size is bigger than the data size. '", "\n", "'Setting batch size to data size'", ")", ")", "\n", "batch_size", "=", "np", ".", "shape", "(", "data_i", ")", "[", "0", "]", "\n", "\n", "", "n_batches", "=", "len", "(", "data_i", ")", "//", "batch_size", "\n", "n_used_imgs", "=", "n_batches", "*", "batch_size", "\n", "\n", "pred_arr", "=", "np", ".", "empty", "(", "(", "n_used_imgs", ",", "dims", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_batches", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "'\\rPropagating batch %d/%d'", "%", "(", "i", "+", "1", ",", "n_batches", ")", ",", "\n", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "", "start", "=", "i", "*", "batch_size", "\n", "end", "=", "start", "+", "batch_size", "\n", "test_data", "=", "np", ".", "zeros", "(", "[", "batch_size", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "3", "]", ")", "\n", "# print (np.shape (data_i))", "\n", "# print (np.max(data_i[0]))", "\n", "# assert (0)", "\n", "images", "=", "data_i", "[", "start", ":", "end", "]", "#np.array([misc.imresize( imread(str(f)).astype(np.float32), size=[size[0], size[1]]).astype(np.float32)", "\n", "# for f in files[start:end]])", "\n", "if", "len", "(", "np", ".", "shape", "(", "images", ")", ")", "==", "3", ":", "\n", "            ", "test_data", "[", ":", ",", ":", ",", ":", ",", "0", "]", "=", "images", "\n", "test_data", "[", ":", ",", ":", ",", ":", ",", "1", "]", "=", "images", "\n", "test_data", "[", ":", ",", ":", ",", ":", ",", "2", "]", "=", "images", "\n", "", "else", ":", "\n", "            ", "test_data", "=", "images", "\n", "", "images", "=", "test_data", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "2", ")", ")", "\n", "images", "/=", "255", "\n", "\n", "batch", "=", "torch", ".", "from_numpy", "(", "images", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", "\n", "if", "cuda", ":", "\n", "            ", "batch", "=", "batch", ".", "cuda", "(", ")", "\n", "\n", "", "if", "target_model", "==", "'inception'", ":", "\n", "            ", "pred", "=", "model", "(", "batch", ")", "[", "0", "]", "\n", "# If model output is not scalar, apply global spatial average pooling.", "\n", "# This happens if you choose a dimensionality not equal 2048.", "\n", "if", "pred", ".", "shape", "[", "2", "]", "!=", "1", "or", "pred", ".", "shape", "[", "3", "]", "!=", "1", ":", "\n", "                ", "pred", "=", "adaptive_avg_pool2d", "(", "pred", ",", "output_size", "=", "(", "1", ",", "1", ")", ")", "\n", "", "", "if", "target_model", "==", "'posenet'", ":", "\n", "            ", "pred", "=", "model", "(", "batch", ")", "\n", "# print (np.shape (pred))", "\n", "pred", "=", "adaptive_max_pool2d", "(", "pred", ",", "output_size", "=", "(", "1", ",", "1", ")", ")", "\n", "", "if", "target_model", "==", "'net2layer'", ":", "\n", "            ", "pred", "=", "model", "(", "batch", ")", "\n", "", "pred_arr", "[", "start", ":", "end", "]", "=", "pred", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "reshape", "(", "end", "-", "start", ",", "-", "1", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "' done'", ")", "\n", "\n", "", "return", "pred_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.calculate_frechet_distance": [[164, 225], ["range", "numpy.mean", "len", "numpy.atleast_1d", "numpy.atleast_1d", "numpy.atleast_2d", "numpy.atleast_2d", "scipy.linalg.sqrtm", "numpy.iscomplexobj", "numpy.trace", "fd_all.append", "numpy.array", "np.atleast_2d.dot", "numpy.isfinite().all", "print", "scipy.linalg.sqrtm", "numpy.eye", "numpy.allclose", "numpy.max", "ValueError", "numpy.trace", "numpy.isfinite", "numpy.abs", "diff.dot", "numpy.trace", "numpy.diagonal"], "function", ["None"], ["", "def", "calculate_frechet_distance", "(", "mu1_list", ",", "sigma1_list", ",", "mu2_list", ",", "sigma2_list", ",", "eps", "=", "1e-6", ")", ":", "\n", "    ", "\"\"\"Numpy implementation of the Frechet Distance.\n    The Frechet distance between two multivariate Gaussians X_1 ~ N(mu_1, C_1)\n    and X_2 ~ N(mu_2, C_2) is\n            d^2 = ||mu_1 - mu_2||^2 + Tr(C_1 + C_2 - 2*sqrt(C_1*C_2)).\n\n    Stable version by Dougal J. Sutherland.\n\n    Params:\n    -- mu1   : Numpy array containing the activations of a layer of the\n               inception net (like returned by the function 'get_predictions')\n               for generated samples.\n    -- mu2   : The sample mean over activations, precalculated on an\n               representative data set.\n    -- sigma1: The covariance matrix over activations for generated samples.\n    -- sigma2: The covariance matrix over activations, precalculated on an\n               representative data set.\n\n    Returns:\n    --   : The Frechet Distance.\n    \"\"\"", "\n", "\n", "fd_all", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "mu1_list", ")", ")", ":", "\n", "\n", "        ", "mu1", "=", "np", ".", "atleast_1d", "(", "mu1_list", "[", "i", "]", ")", "\n", "mu2", "=", "np", ".", "atleast_1d", "(", "mu2_list", "[", "i", "]", ")", "\n", "\n", "sigma1", "=", "np", ".", "atleast_2d", "(", "sigma1_list", "[", "i", "]", ")", "\n", "sigma2", "=", "np", ".", "atleast_2d", "(", "sigma2_list", "[", "i", "]", ")", "\n", "\n", "assert", "mu1", ".", "shape", "==", "mu2", ".", "shape", ",", "'Training and test mean vectors have different lengths'", "\n", "assert", "sigma1", ".", "shape", "==", "sigma2", ".", "shape", ",", "'Training and test covariances have different dimensions'", "\n", "\n", "diff", "=", "mu1", "-", "mu2", "\n", "\n", "# Product might be almost singular", "\n", "covmean", ",", "_", "=", "linalg", ".", "sqrtm", "(", "sigma1", ".", "dot", "(", "sigma2", ")", ",", "disp", "=", "False", ")", "\n", "if", "not", "np", ".", "isfinite", "(", "covmean", ")", ".", "all", "(", ")", ":", "\n", "            ", "msg", "=", "(", "'fid calculation produces singular product; '", "\n", "'adding %s to diagonal of cov estimates'", ")", "%", "eps", "\n", "print", "(", "msg", ")", "\n", "offset", "=", "np", ".", "eye", "(", "sigma1", ".", "shape", "[", "0", "]", ")", "*", "eps", "\n", "covmean", "=", "linalg", ".", "sqrtm", "(", "(", "sigma1", "+", "offset", ")", ".", "dot", "(", "sigma2", "+", "offset", ")", ")", "\n", "\n", "# Numerical error might give slight imaginary component", "\n", "", "if", "np", ".", "iscomplexobj", "(", "covmean", ")", ":", "\n", "            ", "if", "not", "np", ".", "allclose", "(", "np", ".", "diagonal", "(", "covmean", ")", ".", "imag", ",", "0", ",", "atol", "=", "1e-3", ")", ":", "\n", "                ", "m", "=", "np", ".", "max", "(", "np", ".", "abs", "(", "covmean", ".", "imag", ")", ")", "\n", "raise", "ValueError", "(", "'Imaginary component {}'", ".", "format", "(", "m", ")", ")", "\n", "", "covmean", "=", "covmean", ".", "real", "\n", "\n", "", "tr_covmean", "=", "np", ".", "trace", "(", "covmean", ")", "\n", "\n", "fd", "=", "(", "diff", ".", "dot", "(", "diff", ")", "+", "np", ".", "trace", "(", "sigma1", ")", "+", "\n", "np", ".", "trace", "(", "sigma2", ")", "-", "2", "*", "tr_covmean", ")", "\n", "\n", "fd_all", ".", "append", "(", "fd", ")", "\n", "", "return", "np", ".", "mean", "(", "np", ".", "array", "(", "fd_all", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.calculate_activation_statistics": [[227, 263], ["numpy.unique", "fd_score_label.get_activations", "numpy.mean", "numpy.cov", "mu_list.append", "sigma_list.append", "numpy.where"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.get_activations"], ["", "def", "calculate_activation_statistics", "(", "size", ",", "target_model", ",", "data", ",", "lbls", ",", "model", ",", "batch_size", "=", "50", ",", "\n", "dims", "=", "8192", ",", "cuda", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculation of the statistics used by the FID.\n    Params:\n    -- files       : List of image files paths\n    -- model       : Instance of inception model\n    -- batch_size  : The images numpy array is split into batches with\n                     batch size batch_size. A reasonable batch size\n                     depends on the hardware.\n    -- dims        : Dimensionality of features returned by Inception\n    -- cuda        : If set to True, use GPU\n    -- verbose     : If set to True and parameter out_step is given, the\n                     number of calculated batches is reported.\n    Returns:\n    -- mu    : The mean over samples of the activations of the pool_3 layer of\n               the inception model.\n    -- sigma : The covariance matrix of the activations of the pool_3 layer of\n               the inception model.\n    \"\"\"", "\n", "# print (lbls)", "\n", "unique", ",", "counts", "=", "np", ".", "unique", "(", "lbls", ",", "return_counts", "=", "True", ")", "\n", "\n", "mu_list", "=", "[", "]", "\n", "sigma_list", "=", "[", "]", "\n", "\n", "for", "i", "in", "unique", ":", "\n", "        ", "data_i", "=", "data", "[", "np", ".", "where", "(", "lbls", "==", "i", ")", "]", "\n", "act", "=", "get_activations", "(", "size", ",", "target_model", ",", "data_i", ",", "model", ",", "batch_size", ",", "dims", ",", "cuda", ",", "verbose", ")", "\n", "mu", "=", "np", ".", "mean", "(", "act", ",", "axis", "=", "0", ")", "\n", "sigma", "=", "np", ".", "cov", "(", "act", ",", "rowvar", "=", "False", ")", "\n", "mu_list", ".", "append", "(", "mu", ")", "\n", "sigma_list", ".", "append", "(", "sigma", ")", "\n", "# print (np.shape (mu_list), np.shape (sigma_list))", "\n", "\n", "# assert (0)", "\n", "", "return", "mu_list", ",", "sigma_list", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.load_and_make_list": [[264, 278], ["numpy.load", "numpy.load", "len", "numpy.transpose", "numpy.shape", "len", "numpy.array", "numpy.zeros", "numpy.shape", "numpy.split", "numpy.shape", "numpy.shape", "numpy.shape"], "function", ["None"], ["", "def", "load_and_make_list", "(", "target_path", ")", ":", "\n", "    ", "mode", "=", "\"test\"", "\n", "data", "=", "np", ".", "load", "(", "target_path", "+", "mode", "+", "'_data.npy'", ")", "\n", "lbls", "=", "np", ".", "load", "(", "target_path", "+", "mode", "+", "'_label.npy'", ")", "\n", "if", "len", "(", "np", ".", "shape", "(", "data", ")", ")", "==", "4", ":", "\n", "        ", "data", "=", "np", ".", "transpose", "(", "data", ",", "(", "3", ",", "0", ",", "1", ",", "2", ")", ")", "\n", "", "elif", "len", "(", "np", ".", "shape", "(", "data", ")", ")", "==", "3", ":", "\n", "        ", "data", "=", "np", ".", "array", "(", "np", ".", "split", "(", "data", ",", "data", ".", "shape", "[", "2", "]", ",", "2", ")", ")", "\n", "test_data", "=", "np", ".", "zeros", "(", "[", "np", ".", "shape", "(", "data", ")", "[", "0", "]", ",", "np", ".", "shape", "(", "data", ")", "[", "1", "]", ",", "np", ".", "shape", "(", "data", ")", "[", "2", "]", ",", "3", "]", ")", "\n", "test_data", "[", ":", ",", ":", ",", ":", ",", "0", "]", "=", "data", "[", ":", ",", ":", ",", ":", ",", "0", "]", "\n", "test_data", "[", ":", ",", ":", ",", ":", ",", "1", "]", "=", "data", "[", ":", ",", ":", ",", ":", ",", "0", "]", "\n", "test_data", "[", ":", ",", ":", ",", ":", ",", "2", "]", "=", "data", "[", ":", ",", ":", ",", ":", ",", "0", "]", "\n", "data", "=", "test_data", "\n", "", "return", "data", ",", "lbls", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label._compute_statistics_of_path": [[280, 291], ["path.endswith", "numpy.load", "np.load.close", "fd_score_label.load_and_make_list", "fd_score_label.calculate_activation_statistics"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.load_and_make_list", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.calculate_activation_statistics"], ["", "def", "_compute_statistics_of_path", "(", "size", ",", "target_model", ",", "path", ",", "model", ",", "batch_size", ",", "dims", ",", "cuda", ")", ":", "\n", "    ", "if", "path", ".", "endswith", "(", "'.npz'", ")", ":", "\n", "        ", "f", "=", "np", ".", "load", "(", "path", ")", "\n", "m_list", ",", "s_list", "=", "f", "[", "'mu'", "]", "[", ":", "]", ",", "f", "[", "'sigma'", "]", "[", ":", "]", "\n", "f", ".", "close", "(", ")", "\n", "", "else", ":", "\n", "        ", "data", ",", "lbls", "=", "load_and_make_list", "(", "path", ")", "\n", "m_list", ",", "s_list", "=", "calculate_activation_statistics", "(", "size", ",", "target_model", ",", "data", ",", "lbls", ",", "model", ",", "batch_size", ",", "\n", "dims", ",", "cuda", ")", "\n", "\n", "", "return", "m_list", ",", "s_list", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.calculate_fd_label_given_paths": [[293, 337], ["fd_score_label._compute_statistics_of_path", "fd_score_label._compute_statistics_of_path", "fd_score_label.calculate_frechet_distance", "domain_gap.models.net2layer.net2layer", "domain_gap.models.inception.InceptionV3.state_dict", "model.state_dict.update", "domain_gap.models.inception.InceptionV3.load_state_dict", "domain_gap.models.inception.InceptionV3", "domain_gap.models.inception.InceptionV3.cuda", "paths[].endswith", "numpy.savez", "os.path.exists", "RuntimeError", "torch.load", "paths[].endswith", "torch.load.items", "model.state_dict.keys", "v.size", "model_dict[].size"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._compute_statistics_of_path", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._compute_statistics_of_path", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.fd_score_label.calculate_frechet_distance"], ["", "def", "calculate_fd_label_given_paths", "(", "paths", ",", "target_model", ",", "size", ",", "checkpoint_path", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculates the FID of two paths\"\"\"", "\n", "\n", "cuda", "=", "True", "\n", "for", "p", "in", "paths", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "p", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'Invalid path: %s'", "%", "p", ")", "\n", "\n", "", "", "if", "target_model", "==", "'net2layer'", ":", "\n", "        ", "dims", "=", "128", "\n", "model", "=", "net2layer", "(", ")", "\n", "if", "checkpoint_path", "!=", "None", ":", "\n", "            ", "pretrained_dict", "=", "torch", ".", "load", "(", "checkpoint_path", ")", "\n", "", "else", ":", "\n", "            ", "assert", "(", "\"Error in checkpoint path\"", ")", "\n", "", "model_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "pretrained_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "pretrained_dict", ".", "items", "(", ")", "if", "k", "in", "model_dict", ".", "keys", "(", ")", "and", "v", ".", "size", "(", ")", "==", "model_dict", "[", "k", "]", ".", "size", "(", ")", "}", "\n", "model_dict", ".", "update", "(", "pretrained_dict", ")", "\n", "model", ".", "load_state_dict", "(", "model_dict", ")", "\n", "\n", "", "if", "target_model", "==", "'inception'", ":", "\n", "        ", "dims", "=", "2048", "\n", "block_idx", "=", "InceptionV3", ".", "BLOCK_INDEX_BY_DIM", "[", "dims", "]", "\n", "model", "=", "InceptionV3", "(", "[", "block_idx", "]", ")", "\n", "\n", "", "if", "cuda", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "\n", "", "m1", ",", "s1", "=", "_compute_statistics_of_path", "(", "size", ",", "target_model", ",", "paths", "[", "0", "]", ",", "model", ",", "16", ",", "\n", "dims", ",", "cuda", ")", "\n", "\n", "npz_path", "=", "None", "\n", "if", "not", "paths", "[", "0", "]", ".", "endswith", "(", "\".npz\"", ")", ":", "\n", "        ", "if", "not", "paths", "[", "0", "]", ".", "endswith", "(", "'/'", ")", ":", "\n", "            ", "npz_path", "=", "paths", "[", "0", "]", "+", "\".npz\"", "\n", "", "else", ":", "\n", "            ", "npz_path", "=", "paths", "[", "0", "]", "[", ":", "-", "1", "]", "+", "\".npz\"", "\n", "", "np", ".", "savez", "(", "npz_path", ",", "mu", "=", "m1", ",", "sigma", "=", "s1", ")", "\n", "", "m2", ",", "s2", "=", "_compute_statistics_of_path", "(", "size", ",", "target_model", ",", "paths", "[", "1", "]", ",", "model", ",", "16", ",", "\n", "dims", ",", "cuda", ")", "\n", "\n", "fd_value", "=", "calculate_frechet_distance", "(", "m1", ",", "s1", ",", "m2", ",", "s2", ")", "\n", "\n", "return", "fd_value", ",", "npz_path", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.get_activations": [[20, 92], ["model.eval", "numpy.empty", "range", "len", "print", "len", "len", "numpy.zeros", "numpy.array", "np.zeros.transpose", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.nn.functional.adaptive_avg_pool2d.cpu().data.numpy().reshape", "print", "print", "len", "batch.cuda.cuda", "model", "torch.nn.functional.adaptive_max_pool2d", "model", "scipy.misc.imresize().astype", "numpy.shape", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "model", "torch.nn.functional.adaptive_avg_pool2d", "torch.nn.functional.adaptive_avg_pool2d.cpu().data.numpy", "scipy.misc.imresize", "scipy.misc.imread().astype", "torch.nn.functional.adaptive_avg_pool2d.cpu", "scipy.misc.imread", "str"], "function", ["None"], ["def", "get_activations", "(", "size", ",", "target_model", ",", "files", ",", "model", ",", "batch_size", "=", "50", ",", "dims", "=", "2048", ",", "\n", "cuda", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculates the activations of the pool_3 layer for all images.\n\n    Params:\n    -- files       : List of image files paths\n    -- model       : Instance of inception model\n    -- batch_size  : Batch size of images for the model to process at once.\n                     Make sure that the number of samples is a multiple of\n                     the batch size, otherwise some samples are ignored. This\n                     behavior is retained to match the original FID score\n                     implementation.\n    -- dims        : Dimensionality of features returned by Inception\n    -- cuda        : If set to True, use GPU\n    -- verbose     : If set to True and parameter out_step is given, the number\n                     of calculated batches is reported.\n    Returns:\n    -- A numpy array of dimension (num images, dims) that contains the\n       activations of the given tensor when feeding inception with the\n       query tensor.\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "if", "batch_size", ">", "len", "(", "files", ")", ":", "\n", "        ", "print", "(", "(", "'Warning: batch size is bigger than the data size. '", "\n", "'Setting batch size to data size'", ")", ")", "\n", "batch_size", "=", "len", "(", "files", ")", "\n", "\n", "", "n_batches", "=", "len", "(", "files", ")", "//", "batch_size", "\n", "n_used_imgs", "=", "n_batches", "*", "batch_size", "\n", "\n", "pred_arr", "=", "np", ".", "empty", "(", "(", "n_used_imgs", ",", "dims", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_batches", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "'\\rPropagating batch %d/%d'", "%", "(", "i", "+", "1", ",", "n_batches", ")", ",", "\n", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "", "start", "=", "i", "*", "batch_size", "\n", "end", "=", "start", "+", "batch_size", "\n", "\n", "test_data", "=", "np", ".", "zeros", "(", "[", "batch_size", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "3", "]", ")", "\n", "images", "=", "np", ".", "array", "(", "[", "misc", ".", "imresize", "(", "imread", "(", "str", "(", "f", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "size", "=", "[", "size", "[", "0", "]", ",", "size", "[", "1", "]", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "for", "f", "in", "files", "[", "start", ":", "end", "]", "]", ")", "\n", "if", "len", "(", "np", ".", "shape", "(", "images", ")", ")", "==", "3", ":", "\n", "            ", "test_data", "[", ":", ",", ":", ",", ":", ",", "0", "]", "=", "images", "\n", "test_data", "[", ":", ",", ":", ",", ":", ",", "1", "]", "=", "images", "\n", "test_data", "[", ":", ",", ":", ",", ":", ",", "2", "]", "=", "images", "\n", "", "else", ":", "\n", "            ", "test_data", "=", "images", "\n", "", "images", "=", "test_data", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "2", ")", ")", "\n", "images", "/=", "255", "\n", "\n", "batch", "=", "torch", ".", "from_numpy", "(", "images", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", "\n", "if", "cuda", ":", "\n", "            ", "batch", "=", "batch", ".", "cuda", "(", ")", "\n", "\n", "", "if", "target_model", "==", "'inception'", ":", "\n", "            ", "pred", "=", "model", "(", "batch", ")", "[", "0", "]", "\n", "# If model output is not scalar, apply global spatial average pooling.", "\n", "# This happens if you choose a dimensionality not equal 2048.", "\n", "if", "pred", ".", "shape", "[", "2", "]", "!=", "1", "or", "pred", ".", "shape", "[", "3", "]", "!=", "1", ":", "\n", "                ", "pred", "=", "adaptive_avg_pool2d", "(", "pred", ",", "output_size", "=", "(", "1", ",", "1", ")", ")", "\n", "", "", "if", "target_model", "==", "'posenet'", ":", "\n", "            ", "pred", "=", "model", "(", "batch", ")", "\n", "# print (np.shape (pred))", "\n", "pred", "=", "adaptive_max_pool2d", "(", "pred", ",", "output_size", "=", "(", "1", ",", "1", ")", ")", "\n", "", "if", "target_model", "==", "'net2layer'", ":", "\n", "            ", "pred", "=", "model", "(", "batch", ")", "\n", "", "pred_arr", "[", "start", ":", "end", "]", "=", "pred", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "reshape", "(", "end", "-", "start", ",", "-", "1", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "' done'", ")", "\n", "", "return", "pred_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.calculate_activation_statistics": [[93, 112], ["kd_score.get_activations"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.get_activations"], ["", "def", "calculate_activation_statistics", "(", "size", ",", "target_model", ",", "files", ",", "model", ",", "batch_size", "=", "50", ",", "\n", "dims", "=", "2048", ",", "cuda", "=", "False", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculation of the statistics used by the FID.\n    Params:\n    -- files       : List of image files paths\n    -- model       : Instance of inception model\n    -- batch_size  : The images numpy array is split into batches with\n                     batch size batch_size. A reasonable batch size\n                     depends on the hardware.\n    -- dims        : Dimensionality of features returned by Inception\n    -- cuda        : If set to True, use GPU\n    -- verbose     : If set to True and parameter out_step is given, the\n                     number of calculated batches is reported.\n    Returns:\n    -- act    : activations of the pool_3 layer of\n               the inception model.\n    \"\"\"", "\n", "act", "=", "get_activations", "(", "size", ",", "target_model", ",", "files", ",", "model", ",", "batch_size", ",", "dims", ",", "cuda", ",", "verbose", ")", "\n", "return", "act", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._compute_statistics_of_path": [[113, 127], ["pathlib.Path.endswith", "numpy.load", "np.load.close", "pathlib.Path", "random.shuffle", "kd_score.calculate_activation_statistics", "list", "list", "pathlib.Path.glob", "pathlib.Path.glob"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.calculate_activation_statistics"], ["", "def", "_compute_statistics_of_path", "(", "size", ",", "target_model", ",", "path", ",", "model", ",", "batch_size", ",", "dims", ",", "cuda", ")", ":", "\n", "    ", "if", "path", ".", "endswith", "(", "'.npz'", ")", ":", "\n", "        ", "f", "=", "np", ".", "load", "(", "path", ")", "\n", "act", "=", "f", "[", "'act'", "]", "[", ":", "]", "\n", "f", ".", "close", "(", ")", "\n", "", "else", ":", "\n", "        ", "path", "=", "pathlib", ".", "Path", "(", "path", ")", "\n", "files", "=", "list", "(", "path", ".", "glob", "(", "'*.jpg'", ")", ")", "+", "list", "(", "path", ".", "glob", "(", "'*.png'", ")", ")", "\n", "# files = files[:2000] not use top 2000 in the MMD calculation", "\n", "random", ".", "shuffle", "(", "files", ")", "\n", "files", "=", "files", "[", ":", "2000", "]", "\n", "act", "=", "calculate_activation_statistics", "(", "size", ",", "target_model", ",", "files", ",", "model", ",", "batch_size", ",", "\n", "dims", ",", "cuda", ")", "\n", "", "return", "act", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.polynomial_mmd": [[128, 141], ["sklearn.metrics.pairwise.polynomial_kernel", "sklearn.metrics.pairwise.polynomial_kernel", "sklearn.metrics.pairwise.polynomial_kernel", "kd_score._mmd2_and_variance"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._mmd2_and_variance"], ["", "def", "polynomial_mmd", "(", "codes_g", ",", "codes_r", ",", "degree", "=", "3", ",", "gamma", "=", "None", ",", "coef0", "=", "1", ",", "\n", "var_at_m", "=", "None", ",", "ret_var", "=", "True", ")", ":", "\n", "# use  k(x, y) = (gamma <x, y> + coef0)^degree", "\n", "# default gamma is 1 / dim", "\n", "    ", "X", "=", "codes_g", "\n", "Y", "=", "codes_r", "\n", "\n", "K_XX", "=", "polynomial_kernel", "(", "X", ",", "degree", "=", "degree", ",", "gamma", "=", "gamma", ",", "coef0", "=", "coef0", ")", "\n", "K_YY", "=", "polynomial_kernel", "(", "Y", ",", "degree", "=", "degree", ",", "gamma", "=", "gamma", ",", "coef0", "=", "coef0", ")", "\n", "K_XY", "=", "polynomial_kernel", "(", "X", ",", "Y", ",", "degree", "=", "degree", ",", "gamma", "=", "gamma", ",", "coef0", "=", "coef0", ")", "\n", "\n", "return", "_mmd2_and_variance", "(", "K_XX", ",", "K_XY", ",", "K_YY", ",", "\n", "var_at_m", "=", "var_at_m", ",", "ret_var", "=", "ret_var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn": [[142, 145], ["numpy.ravel", "np.ravel.dot"], "function", ["None"], ["", "def", "_sqn", "(", "arr", ")", ":", "\n", "    ", "flat", "=", "np", ".", "ravel", "(", "arr", ")", "\n", "return", "flat", ".", "dot", "(", "flat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.polynomial_mmd_averages": [[146, 166], ["min", "numpy.zeros", "range", "numpy.zeros", "kd_score.polynomial_mmd", "choice", "choice", "len", "len"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.polynomial_mmd"], ["", "def", "polynomial_mmd_averages", "(", "codes_g", ",", "codes_r", ",", "n_subsets", "=", "50", ",", "subset_size", "=", "1000", ",", "\n", "ret_var", "=", "True", ",", "output", "=", "sys", ".", "stdout", ",", "**", "kernel_args", ")", ":", "\n", "    ", "m", "=", "min", "(", "codes_g", ".", "shape", "[", "0", "]", ",", "codes_r", ".", "shape", "[", "0", "]", ")", "\n", "mmds", "=", "np", ".", "zeros", "(", "n_subsets", ")", "\n", "if", "ret_var", ":", "\n", "        ", "vars", "=", "np", ".", "zeros", "(", "n_subsets", ")", "\n", "", "choice", "=", "np", ".", "random", ".", "choice", "\n", "\n", "#with tqdm(range(n_subsets), desc='MMD', file=output) as bar:", "\n", "for", "i", "in", "range", "(", "n_subsets", ")", ":", "\n", "        ", "g", "=", "codes_g", "[", "choice", "(", "len", "(", "codes_g", ")", ",", "subset_size", ",", "replace", "=", "True", ")", "]", "\n", "r", "=", "codes_r", "[", "choice", "(", "len", "(", "codes_r", ")", ",", "subset_size", ",", "replace", "=", "False", ")", "]", "\n", "\n", "o", "=", "polynomial_mmd", "(", "g", ",", "r", ",", "**", "kernel_args", ",", "var_at_m", "=", "m", ",", "ret_var", "=", "ret_var", ")", "\n", "if", "ret_var", ":", "\n", "            ", "mmds", "[", "i", "]", ",", "vars", "[", "i", "]", "=", "o", "\n", "", "else", ":", "\n", "            ", "mmds", "[", "i", "]", "=", "o", "\n", "#bar.set_postfix({'mean': mmds[:i+1].mean()})", "\n", "", "", "return", "(", "mmds", ",", "vars", ")", "if", "ret_var", "else", "mmds", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._mmd2_and_variance": [[167, 251], ["K_XY.sum", "K_XY.sum", "Kt_XX_sums.sum", "Kt_YY_sums.sum", "K_XY.sum.sum", "kd_score._sqn", "Kt_XX_sums.dot", "Kt_YY_sums.dot", "numpy.diagonal", "numpy.diagonal", "np.diagonal.sum", "np.diagonal.sum", "kd_score._sqn", "kd_score._sqn", "K_XX.sum", "K_YY.sum", "kd_score._sqn", "kd_score._sqn", "numpy.trace", "kd_score._sqn", "kd_score._sqn", "kd_score._sqn", "kd_score._sqn"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._sqn"], ["", "def", "_mmd2_and_variance", "(", "K_XX", ",", "K_XY", ",", "K_YY", ",", "unit_diagonal", "=", "False", ",", "\n", "mmd_est", "=", "'unbiased'", ",", "block_size", "=", "1024", ",", "\n", "var_at_m", "=", "None", ",", "ret_var", "=", "True", ")", ":", "\n", "# based on", "\n", "# https://github.com/dougalsutherland/opt-mmd/blob/master/two_sample/mmd.py", "\n", "# but changed to not compute the full kernel matrix at once", "\n", "    ", "m", "=", "K_XX", ".", "shape", "[", "0", "]", "\n", "assert", "K_XX", ".", "shape", "==", "(", "m", ",", "m", ")", "\n", "assert", "K_XY", ".", "shape", "==", "(", "m", ",", "m", ")", "\n", "assert", "K_YY", ".", "shape", "==", "(", "m", ",", "m", ")", "\n", "if", "var_at_m", "is", "None", ":", "\n", "        ", "var_at_m", "=", "m", "\n", "\n", "# Get the various sums of kernels that we'll use", "\n", "# Kts drop the diagonal, but we don't need to compute them explicitly", "\n", "", "if", "unit_diagonal", ":", "\n", "        ", "diag_X", "=", "diag_Y", "=", "1", "\n", "sum_diag_X", "=", "sum_diag_Y", "=", "m", "\n", "sum_diag2_X", "=", "sum_diag2_Y", "=", "m", "\n", "", "else", ":", "\n", "        ", "diag_X", "=", "np", ".", "diagonal", "(", "K_XX", ")", "\n", "diag_Y", "=", "np", ".", "diagonal", "(", "K_YY", ")", "\n", "\n", "sum_diag_X", "=", "diag_X", ".", "sum", "(", ")", "\n", "sum_diag_Y", "=", "diag_Y", ".", "sum", "(", ")", "\n", "\n", "sum_diag2_X", "=", "_sqn", "(", "diag_X", ")", "\n", "sum_diag2_Y", "=", "_sqn", "(", "diag_Y", ")", "\n", "\n", "", "Kt_XX_sums", "=", "K_XX", ".", "sum", "(", "axis", "=", "1", ")", "-", "diag_X", "\n", "Kt_YY_sums", "=", "K_YY", ".", "sum", "(", "axis", "=", "1", ")", "-", "diag_Y", "\n", "K_XY_sums_0", "=", "K_XY", ".", "sum", "(", "axis", "=", "0", ")", "\n", "K_XY_sums_1", "=", "K_XY", ".", "sum", "(", "axis", "=", "1", ")", "\n", "\n", "Kt_XX_sum", "=", "Kt_XX_sums", ".", "sum", "(", ")", "\n", "Kt_YY_sum", "=", "Kt_YY_sums", ".", "sum", "(", ")", "\n", "K_XY_sum", "=", "K_XY_sums_0", ".", "sum", "(", ")", "\n", "\n", "if", "mmd_est", "==", "'biased'", ":", "\n", "        ", "mmd2", "=", "(", "(", "Kt_XX_sum", "+", "sum_diag_X", ")", "/", "(", "m", "*", "m", ")", "\n", "+", "(", "Kt_YY_sum", "+", "sum_diag_Y", ")", "/", "(", "m", "*", "m", ")", "\n", "-", "2", "*", "K_XY_sum", "/", "(", "m", "*", "m", ")", ")", "\n", "", "else", ":", "\n", "        ", "assert", "mmd_est", "in", "{", "'unbiased'", ",", "'u-statistic'", "}", "\n", "mmd2", "=", "(", "Kt_XX_sum", "+", "Kt_YY_sum", ")", "/", "(", "m", "*", "(", "m", "-", "1", ")", ")", "\n", "if", "mmd_est", "==", "'unbiased'", ":", "\n", "            ", "mmd2", "-=", "2", "*", "K_XY_sum", "/", "(", "m", "*", "m", ")", "\n", "", "else", ":", "\n", "            ", "mmd2", "-=", "2", "*", "(", "K_XY_sum", "-", "np", ".", "trace", "(", "K_XY", ")", ")", "/", "(", "m", "*", "(", "m", "-", "1", ")", ")", "\n", "\n", "", "", "if", "not", "ret_var", ":", "\n", "        ", "return", "mmd2", "\n", "\n", "", "Kt_XX_2_sum", "=", "_sqn", "(", "K_XX", ")", "-", "sum_diag2_X", "\n", "Kt_YY_2_sum", "=", "_sqn", "(", "K_YY", ")", "-", "sum_diag2_Y", "\n", "K_XY_2_sum", "=", "_sqn", "(", "K_XY", ")", "\n", "\n", "dot_XX_XY", "=", "Kt_XX_sums", ".", "dot", "(", "K_XY_sums_1", ")", "\n", "dot_YY_YX", "=", "Kt_YY_sums", ".", "dot", "(", "K_XY_sums_0", ")", "\n", "\n", "m1", "=", "m", "-", "1", "\n", "m2", "=", "m", "-", "2", "\n", "zeta1_est", "=", "(", "\n", "1", "/", "(", "m", "*", "m1", "*", "m2", ")", "*", "(", "\n", "_sqn", "(", "Kt_XX_sums", ")", "-", "Kt_XX_2_sum", "+", "_sqn", "(", "Kt_YY_sums", ")", "-", "Kt_YY_2_sum", ")", "\n", "-", "1", "/", "(", "m", "*", "m1", ")", "**", "2", "*", "(", "Kt_XX_sum", "**", "2", "+", "Kt_YY_sum", "**", "2", ")", "\n", "+", "1", "/", "(", "m", "*", "m", "*", "m1", ")", "*", "(", "\n", "_sqn", "(", "K_XY_sums_1", ")", "+", "_sqn", "(", "K_XY_sums_0", ")", "-", "2", "*", "K_XY_2_sum", ")", "\n", "-", "2", "/", "m", "**", "4", "*", "K_XY_sum", "**", "2", "\n", "-", "2", "/", "(", "m", "*", "m", "*", "m1", ")", "*", "(", "dot_XX_XY", "+", "dot_YY_YX", ")", "\n", "+", "2", "/", "(", "m", "**", "3", "*", "m1", ")", "*", "(", "Kt_XX_sum", "+", "Kt_YY_sum", ")", "*", "K_XY_sum", "\n", ")", "\n", "zeta2_est", "=", "(", "\n", "1", "/", "(", "m", "*", "m1", ")", "*", "(", "Kt_XX_2_sum", "+", "Kt_YY_2_sum", ")", "\n", "-", "1", "/", "(", "m", "*", "m1", ")", "**", "2", "*", "(", "Kt_XX_sum", "**", "2", "+", "Kt_YY_sum", "**", "2", ")", "\n", "+", "2", "/", "(", "m", "*", "m", ")", "*", "K_XY_2_sum", "\n", "-", "2", "/", "m", "**", "4", "*", "K_XY_sum", "**", "2", "\n", "-", "4", "/", "(", "m", "*", "m", "*", "m1", ")", "*", "(", "dot_XX_XY", "+", "dot_YY_YX", ")", "\n", "+", "4", "/", "(", "m", "**", "3", "*", "m1", ")", "*", "(", "Kt_XX_sum", "+", "Kt_YY_sum", ")", "*", "K_XY_sum", "\n", ")", "\n", "var_est", "=", "(", "4", "*", "(", "var_at_m", "-", "2", ")", "/", "(", "var_at_m", "*", "(", "var_at_m", "-", "1", ")", ")", "*", "zeta1_est", "\n", "+", "2", "/", "(", "var_at_m", "*", "(", "var_at_m", "-", "1", ")", ")", "*", "zeta2_est", ")", "\n", "\n", "return", "mmd2", ",", "var_est", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.calculate_kd_given_paths": [[252, 294], ["kd_score._compute_statistics_of_path", "kd_score._compute_statistics_of_path", "kd_score.polynomial_mmd_averages", "domain_gap.models.net2layer.net2layer", "domain_gap.models.inception.InceptionV3.state_dict", "model.state_dict.update", "domain_gap.models.inception.InceptionV3.load_state_dict", "domain_gap.models.inception.InceptionV3", "domain_gap.models.inception.InceptionV3.cuda", "paths[].endswith", "numpy.savez", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "mmd_value[].mean", "os.path.exists", "os.path.exists", "RuntimeError", "torch.load", "torch.load", "torch.load", "paths[].endswith", "torch.load.items", "model.state_dict.keys", "v.size", "model_dict[].size"], "function", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._compute_statistics_of_path", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score._compute_statistics_of_path", "home.repos.pwc.inspect_result.sxzrt_proxy-set.domain_gap.kd_score.polynomial_mmd_averages"], ["", "def", "calculate_kd_given_paths", "(", "paths", ",", "target_model", ",", "size", ",", "checkpoint_path", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculates the FID of two paths\"\"\"", "\n", "\n", "cuda", "=", "True", "\n", "for", "p", "in", "paths", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "p", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'Invalid path: %s'", "%", "p", ")", "\n", "\n", "", "", "if", "target_model", "==", "'net2layer'", ":", "\n", "        ", "dims", "=", "128", "\n", "model", "=", "net2layer", "(", ")", "\n", "if", "checkpoint_path", "!=", "None", ":", "\n", "            ", "pretrained_dict", "=", "torch", ".", "load", "(", "checkpoint_path", ")", "\n", "", "else", ":", "\n", "            ", "assert", "(", "\"Error in checkpoint path\"", ")", "\n", "", "model_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "pretrained_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "pretrained_dict", ".", "items", "(", ")", "if", "k", "in", "model_dict", ".", "keys", "(", ")", "and", "v", ".", "size", "(", ")", "==", "model_dict", "[", "k", "]", ".", "size", "(", ")", "}", "\n", "model_dict", ".", "update", "(", "pretrained_dict", ")", "\n", "model", ".", "load_state_dict", "(", "model_dict", ")", "\n", "\n", "", "if", "target_model", "==", "'inception'", ":", "\n", "        ", "dims", "=", "2048", "\n", "block_idx", "=", "InceptionV3", ".", "BLOCK_INDEX_BY_DIM", "[", "dims", "]", "\n", "model", "=", "InceptionV3", "(", "[", "block_idx", "]", ")", "\n", "\n", "", "if", "cuda", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "\n", "", "act1", "=", "_compute_statistics_of_path", "(", "size", ",", "target_model", ",", "paths", "[", "0", "]", ",", "model", ",", "16", ",", "\n", "dims", ",", "cuda", ")", "\n", "npz_path", "=", "None", "\n", "if", "not", "paths", "[", "0", "]", ".", "endswith", "(", "\".npz\"", ")", ":", "\n", "        ", "if", "not", "paths", "[", "0", "]", ".", "endswith", "(", "'/'", ")", ":", "\n", "            ", "npz_path", "=", "paths", "[", "0", "]", "+", "\".npz\"", "\n", "", "else", ":", "\n", "            ", "npz_path", "=", "paths", "[", "0", "]", "[", ":", "-", "1", "]", "+", "\".npz\"", "\n", "", "np", ".", "savez", "(", "npz_path", ",", "act", "=", "act1", ")", "\n", "", "act2", "=", "_compute_statistics_of_path", "(", "size", ",", "target_model", ",", "paths", "[", "1", "]", ",", "model", ",", "16", ",", "\n", "dims", ",", "cuda", ")", "\n", "\n", "mmd_value", "=", "polynomial_mmd_averages", "(", "torch", ".", "from_numpy", "(", "act1", ")", ",", "torch", ".", "from_numpy", "(", "act2", ")", ")", "\n", "return", "mmd_value", "[", "0", "]", ".", "mean", "(", ")", ",", "npz_path", "", "", ""]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.InceptionV3.__init__": [[31, 128], ["torch.Module.__init__", "sorted", "max", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "models.inception_v3.InceptionV3.blocks.append", "models.inception_v3.InceptionV3.parameters", "inception.fid_inception_v3", "torchvision.models.inception_v3", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "models.inception_v3.InceptionV3.blocks.append", "models.inception_v3.InceptionV3.blocks.append", "models.inception_v3.InceptionV3.blocks.append", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Sequential", "torch.Sequential", "torch.Sequential"], "methods", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.models.net2layer.net2layer.__init__", "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.fid_inception_v3"], ["def", "__init__", "(", "self", ",", "\n", "output_blocks", "=", "[", "DEFAULT_BLOCK_INDEX", "]", ",", "\n", "resize_input", "=", "True", ",", "\n", "normalize_input", "=", "True", ",", "\n", "requires_grad", "=", "False", ",", "\n", "use_fid_inception", "=", "True", ")", ":", "\n", "        ", "\"\"\"Build pretrained InceptionV3\n\n        Parameters\n        ----------\n        output_blocks : list of int\n            Indices of blocks to return features of. Possible values are:\n                - 0: corresponds to output of first max pooling\n                - 1: corresponds to output of second max pooling\n                - 2: corresponds to output which is fed to aux classifier\n                - 3: corresponds to output of final average pooling\n        resize_input : bool\n            If true, bilinearly resizes input to width and height 299 before\n            feeding input to model. As the network without fully connected\n            layers is fully convolutional, it should be able to handle inputs\n            of arbitrary size, so resizing might not be strictly needed\n        normalize_input : bool\n            If true, scales the input from range (0, 1) to the range the\n            pretrained Inception network expects, namely (-1, 1)\n        requires_grad : bool\n            If true, parameters of the model require gradients. Possibly useful\n            for finetuning the network\n        use_fid_inception : bool\n            If true, uses the pretrained Inception model used in Tensorflow's\n            FID implementation. If false, uses the pretrained Inception model\n            available in torchvision. The FID Inception model has different\n            weights and a slightly different structure from torchvision's\n            Inception model. If you want to compute FID scores, you are\n            strongly advised to set this parameter to true to get comparable\n            results.\n        \"\"\"", "\n", "super", "(", "InceptionV3", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "resize_input", "=", "resize_input", "\n", "self", ".", "normalize_input", "=", "normalize_input", "\n", "self", ".", "output_blocks", "=", "sorted", "(", "output_blocks", ")", "\n", "self", ".", "last_needed_block", "=", "max", "(", "output_blocks", ")", "\n", "\n", "assert", "self", ".", "last_needed_block", "<=", "3", ",", "'Last possible output block index is 3'", "\n", "\n", "self", ".", "blocks", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "if", "use_fid_inception", ":", "\n", "            ", "inception", "=", "fid_inception_v3", "(", ")", "\n", "", "else", ":", "\n", "            ", "inception", "=", "models", ".", "inception_v3", "(", "pretrained", "=", "True", ")", "\n", "\n", "# Block 0: input to maxpool1", "\n", "", "block0", "=", "[", "\n", "inception", ".", "Conv2d_1a_3x3", ",", "\n", "inception", ".", "Conv2d_2a_3x3", ",", "\n", "inception", ".", "Conv2d_2b_3x3", ",", "\n", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ")", "\n", "]", "\n", "self", ".", "blocks", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "block0", ")", ")", "\n", "\n", "# Block 1: maxpool1 to maxpool2", "\n", "if", "self", ".", "last_needed_block", ">=", "1", ":", "\n", "            ", "block1", "=", "[", "\n", "inception", ".", "Conv2d_3b_1x1", ",", "\n", "inception", ".", "Conv2d_4a_3x3", ",", "\n", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ")", "\n", "]", "\n", "self", ".", "blocks", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "block1", ")", ")", "\n", "\n", "# Block 2: maxpool2 to aux classifier", "\n", "", "if", "self", ".", "last_needed_block", ">=", "2", ":", "\n", "            ", "block2", "=", "[", "\n", "inception", ".", "Mixed_5b", ",", "\n", "inception", ".", "Mixed_5c", ",", "\n", "inception", ".", "Mixed_5d", ",", "\n", "inception", ".", "Mixed_6a", ",", "\n", "inception", ".", "Mixed_6b", ",", "\n", "inception", ".", "Mixed_6c", ",", "\n", "inception", ".", "Mixed_6d", ",", "\n", "inception", ".", "Mixed_6e", ",", "\n", "]", "\n", "self", ".", "blocks", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "block2", ")", ")", "\n", "\n", "# Block 3: aux classifier to final avgpool", "\n", "", "if", "self", ".", "last_needed_block", ">=", "3", ":", "\n", "            ", "block3", "=", "[", "\n", "inception", ".", "Mixed_7a", ",", "\n", "inception", ".", "Mixed_7b", ",", "\n", "inception", ".", "Mixed_7c", ",", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "output_size", "=", "(", "1", ",", "1", ")", ")", "\n", "]", "\n", "self", ".", "blocks", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "block3", ")", ")", "\n", "\n", "", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "requires_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.InceptionV3.forward": [[129, 164], ["enumerate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "block", "outp.append"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\"Get Inception feature maps\n\n        Parameters\n        ----------\n        inp : torch.autograd.Variable\n            Input tensor of shape Bx3xHxW. Values are expected to be in\n            range (0, 1)\n\n        Returns\n        -------\n        List of torch.autograd.Variable, corresponding to the selected output\n        block, sorted ascending by index\n        \"\"\"", "\n", "outp", "=", "[", "]", "\n", "x", "=", "inp", "\n", "\n", "if", "self", ".", "resize_input", ":", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "x", ",", "\n", "size", "=", "(", "299", ",", "299", ")", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "False", ")", "\n", "\n", "", "if", "self", ".", "normalize_input", ":", "\n", "            ", "x", "=", "2", "*", "x", "-", "1", "# Scale from range (0, 1) to range (-1, 1)", "\n", "\n", "", "for", "idx", ",", "block", "in", "enumerate", "(", "self", ".", "blocks", ")", ":", "\n", "            ", "x", "=", "block", "(", "x", ")", "\n", "if", "idx", "in", "self", ".", "output_blocks", ":", "\n", "                ", "outp", ".", "append", "(", "x", ")", "\n", "\n", "", "if", "idx", "==", "self", ".", "last_needed_block", ":", "\n", "                ", "break", "\n", "\n", "", "", "return", "outp", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.FIDInceptionA.__init__": [[198, 200], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.models.net2layer.net2layer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "pool_features", ")", ":", "\n", "        ", "super", "(", "FIDInceptionA", ",", "self", ")", ".", "__init__", "(", "in_channels", ",", "pool_features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.FIDInceptionA.forward": [[201, 219], ["inception.FIDInceptionA.branch1x1", "inception.FIDInceptionA.branch5x5_1", "inception.FIDInceptionA.branch5x5_2", "inception.FIDInceptionA.branch3x3dbl_1", "inception.FIDInceptionA.branch3x3dbl_2", "inception.FIDInceptionA.branch3x3dbl_3", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "inception.FIDInceptionA.branch_pool", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "branch1x1", "=", "self", ".", "branch1x1", "(", "x", ")", "\n", "\n", "branch5x5", "=", "self", ".", "branch5x5_1", "(", "x", ")", "\n", "branch5x5", "=", "self", ".", "branch5x5_2", "(", "branch5x5", ")", "\n", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_1", "(", "x", ")", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_2", "(", "branch3x3dbl", ")", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_3", "(", "branch3x3dbl", ")", "\n", "\n", "# Patch: Tensorflow's average pool does not use the padded zero's in", "\n", "# its average calculation", "\n", "branch_pool", "=", "F", ".", "avg_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "\n", "count_include_pad", "=", "False", ")", "\n", "branch_pool", "=", "self", ".", "branch_pool", "(", "branch_pool", ")", "\n", "\n", "outputs", "=", "[", "branch1x1", ",", "branch5x5", ",", "branch3x3dbl", ",", "branch_pool", "]", "\n", "return", "torch", ".", "cat", "(", "outputs", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.FIDInceptionC.__init__": [[223, 225], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.models.net2layer.net2layer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "channels_7x7", ")", ":", "\n", "        ", "super", "(", "FIDInceptionC", ",", "self", ")", ".", "__init__", "(", "in_channels", ",", "channels_7x7", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.FIDInceptionC.forward": [[226, 247], ["inception.FIDInceptionC.branch1x1", "inception.FIDInceptionC.branch7x7_1", "inception.FIDInceptionC.branch7x7_2", "inception.FIDInceptionC.branch7x7_3", "inception.FIDInceptionC.branch7x7dbl_1", "inception.FIDInceptionC.branch7x7dbl_2", "inception.FIDInceptionC.branch7x7dbl_3", "inception.FIDInceptionC.branch7x7dbl_4", "inception.FIDInceptionC.branch7x7dbl_5", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "inception.FIDInceptionC.branch_pool", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "branch1x1", "=", "self", ".", "branch1x1", "(", "x", ")", "\n", "\n", "branch7x7", "=", "self", ".", "branch7x7_1", "(", "x", ")", "\n", "branch7x7", "=", "self", ".", "branch7x7_2", "(", "branch7x7", ")", "\n", "branch7x7", "=", "self", ".", "branch7x7_3", "(", "branch7x7", ")", "\n", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_1", "(", "x", ")", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_2", "(", "branch7x7dbl", ")", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_3", "(", "branch7x7dbl", ")", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_4", "(", "branch7x7dbl", ")", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_5", "(", "branch7x7dbl", ")", "\n", "\n", "# Patch: Tensorflow's average pool does not use the padded zero's in", "\n", "# its average calculation", "\n", "branch_pool", "=", "F", ".", "avg_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "\n", "count_include_pad", "=", "False", ")", "\n", "branch_pool", "=", "self", ".", "branch_pool", "(", "branch_pool", ")", "\n", "\n", "outputs", "=", "[", "branch1x1", ",", "branch7x7", ",", "branch7x7dbl", ",", "branch_pool", "]", "\n", "return", "torch", ".", "cat", "(", "outputs", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.FIDInceptionE_1.__init__": [[251, 253], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.models.net2layer.net2layer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "FIDInceptionE_1", ",", "self", ")", ".", "__init__", "(", "in_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.FIDInceptionE_1.forward": [[254, 280], ["inception.FIDInceptionE_1.branch1x1", "inception.FIDInceptionE_1.branch3x3_1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "inception.FIDInceptionE_1.branch3x3dbl_1", "inception.FIDInceptionE_1.branch3x3dbl_2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "inception.FIDInceptionE_1.branch_pool", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "inception.FIDInceptionE_1.branch3x3_2a", "inception.FIDInceptionE_1.branch3x3_2b", "inception.FIDInceptionE_1.branch3x3dbl_3a", "inception.FIDInceptionE_1.branch3x3dbl_3b"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "branch1x1", "=", "self", ".", "branch1x1", "(", "x", ")", "\n", "\n", "branch3x3", "=", "self", ".", "branch3x3_1", "(", "x", ")", "\n", "branch3x3", "=", "[", "\n", "self", ".", "branch3x3_2a", "(", "branch3x3", ")", ",", "\n", "self", ".", "branch3x3_2b", "(", "branch3x3", ")", ",", "\n", "]", "\n", "branch3x3", "=", "torch", ".", "cat", "(", "branch3x3", ",", "1", ")", "\n", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_1", "(", "x", ")", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_2", "(", "branch3x3dbl", ")", "\n", "branch3x3dbl", "=", "[", "\n", "self", ".", "branch3x3dbl_3a", "(", "branch3x3dbl", ")", ",", "\n", "self", ".", "branch3x3dbl_3b", "(", "branch3x3dbl", ")", ",", "\n", "]", "\n", "branch3x3dbl", "=", "torch", ".", "cat", "(", "branch3x3dbl", ",", "1", ")", "\n", "\n", "# Patch: Tensorflow's average pool does not use the padded zero's in", "\n", "# its average calculation", "\n", "branch_pool", "=", "F", ".", "avg_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "\n", "count_include_pad", "=", "False", ")", "\n", "branch_pool", "=", "self", ".", "branch_pool", "(", "branch_pool", ")", "\n", "\n", "outputs", "=", "[", "branch1x1", ",", "branch3x3", ",", "branch3x3dbl", ",", "branch_pool", "]", "\n", "return", "torch", ".", "cat", "(", "outputs", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.FIDInceptionE_2.__init__": [[284, 286], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.models.net2layer.net2layer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "FIDInceptionE_2", ",", "self", ")", ".", "__init__", "(", "in_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.FIDInceptionE_2.forward": [[287, 314], ["inception.FIDInceptionE_2.branch1x1", "inception.FIDInceptionE_2.branch3x3_1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "inception.FIDInceptionE_2.branch3x3dbl_1", "inception.FIDInceptionE_2.branch3x3dbl_2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "inception.FIDInceptionE_2.branch_pool", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "inception.FIDInceptionE_2.branch3x3_2a", "inception.FIDInceptionE_2.branch3x3_2b", "inception.FIDInceptionE_2.branch3x3dbl_3a", "inception.FIDInceptionE_2.branch3x3dbl_3b"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "branch1x1", "=", "self", ".", "branch1x1", "(", "x", ")", "\n", "\n", "branch3x3", "=", "self", ".", "branch3x3_1", "(", "x", ")", "\n", "branch3x3", "=", "[", "\n", "self", ".", "branch3x3_2a", "(", "branch3x3", ")", ",", "\n", "self", ".", "branch3x3_2b", "(", "branch3x3", ")", ",", "\n", "]", "\n", "branch3x3", "=", "torch", ".", "cat", "(", "branch3x3", ",", "1", ")", "\n", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_1", "(", "x", ")", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_2", "(", "branch3x3dbl", ")", "\n", "branch3x3dbl", "=", "[", "\n", "self", ".", "branch3x3dbl_3a", "(", "branch3x3dbl", ")", ",", "\n", "self", ".", "branch3x3dbl_3b", "(", "branch3x3dbl", ")", ",", "\n", "]", "\n", "branch3x3dbl", "=", "torch", ".", "cat", "(", "branch3x3dbl", ",", "1", ")", "\n", "\n", "# Patch: The FID Inception model uses max pooling instead of average", "\n", "# pooling. This is likely an error in this specific Inception", "\n", "# implementation, as other Inception models use average pooling here", "\n", "# (which matches the description in the paper).", "\n", "branch_pool", "=", "F", ".", "max_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "branch_pool", "=", "self", ".", "branch_pool", "(", "branch_pool", ")", "\n", "\n", "outputs", "=", "[", "branch1x1", ",", "branch3x3", ",", "branch3x3dbl", ",", "branch_pool", "]", "\n", "return", "torch", ".", "cat", "(", "outputs", ",", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.inception.fid_inception_v3": [[166, 194], ["torchvision.models.inception_v3", "inception.FIDInceptionA", "inception.FIDInceptionA", "inception.FIDInceptionA", "inception.FIDInceptionC", "inception.FIDInceptionC", "inception.FIDInceptionC", "inception.FIDInceptionC", "inception.FIDInceptionE_1", "inception.FIDInceptionE_2", "load_state_dict_from_url", "models.inception_v3.load_state_dict"], "function", ["None"], ["", "", "def", "fid_inception_v3", "(", ")", ":", "\n", "    ", "\"\"\"Build pretrained Inception model for FID computation\n\n    The Inception model for FID computation uses a different set of weights\n    and has a slightly different structure than torchvision's Inception.\n\n    This method first constructs torchvision's Inception and then patches the\n    necessary parts that are different in the FID Inception model.\n    \"\"\"", "\n", "inception", "=", "models", ".", "inception_v3", "(", "num_classes", "=", "1008", ",", "\n", "aux_logits", "=", "False", ",", "\n", "pretrained", "=", "False", ")", "\n", "inception", ".", "Mixed_5b", "=", "FIDInceptionA", "(", "192", ",", "pool_features", "=", "32", ")", "\n", "inception", ".", "Mixed_5c", "=", "FIDInceptionA", "(", "256", ",", "pool_features", "=", "64", ")", "\n", "inception", ".", "Mixed_5d", "=", "FIDInceptionA", "(", "288", ",", "pool_features", "=", "64", ")", "\n", "inception", ".", "Mixed_6b", "=", "FIDInceptionC", "(", "768", ",", "channels_7x7", "=", "128", ")", "\n", "inception", ".", "Mixed_6c", "=", "FIDInceptionC", "(", "768", ",", "channels_7x7", "=", "160", ")", "\n", "inception", ".", "Mixed_6d", "=", "FIDInceptionC", "(", "768", ",", "channels_7x7", "=", "160", ")", "\n", "inception", ".", "Mixed_6e", "=", "FIDInceptionC", "(", "768", ",", "channels_7x7", "=", "192", ")", "\n", "inception", ".", "Mixed_7b", "=", "FIDInceptionE_1", "(", "1280", ")", "\n", "inception", ".", "Mixed_7c", "=", "FIDInceptionE_2", "(", "2048", ")", "\n", "\n", "state_dict", "=", "load_state_dict_from_url", "(", "FID_WEIGHTS_URL", ",", "progress", "=", "True", ")", "\n", "inception", ".", "load_state_dict", "(", "state_dict", ")", "\n", "modify", "=", "0", "\n", "# if modify==1:", "\n", "#     inception=l11;", "\n", "return", "inception", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.net2layer.net2layer.__init__": [[10, 18], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Dropout2d", "torch.Dropout2d", "torch.Dropout2d", "torch.Dropout2d", "torch.Dropout2d", "torch.Dropout2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.sxzrt_proxy-set.models.net2layer.net2layer.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "net2layer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "32", ",", "3", ",", "1", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "32", ",", "64", ",", "3", ",", "1", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout2d", "(", "0.25", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout2d", "(", "0.5", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "9216", ",", "128", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "128", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sxzrt_proxy-set.models.net2layer.net2layer.forward": [[19, 36], ["net2layer.net2layer.conv1", "torch.relu", "torch.relu", "torch.relu", "net2layer.net2layer.conv2", "torch.relu", "torch.relu", "torch.relu", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "net2layer.net2layer.dropout1", "x.view.view.view", "net2layer.net2layer.fc1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "x", "=", "F", ".", "max_pool2d", "(", "x", ",", "2", ")", "\n", "x", "=", "self", ".", "dropout1", "(", "x", ")", "\n", "# print (np.shape (x))", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "9216", ")", "\n", "# x = torch.flatten(x, 1)", "\n", "fea", "=", "self", ".", "fc1", "(", "x", ")", "\n", "# x = F.relu(fea)", "\n", "# x = self.dropout2(x)", "\n", "# x = self.fc2(x)", "\n", "# output = F.log_softmax(x, dim=1)", "\n", "\n", "return", "fea", "", "", "", ""]]}