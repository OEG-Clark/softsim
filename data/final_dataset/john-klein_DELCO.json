{"home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.my_make_moons": [[20, 72], ["sklearn.utils.check_random_state", "numpy.cos", "numpy.sin", "numpy.hstack", "sklearn.utils.check_random_state.uniform", "sklearn.utils.check_random_state.uniform", "numpy.cos", "numpy.vstack", "sklearn.utils.shuffle", "sklearn.utils.check_random_state.normal", "numpy.sin", "numpy.zeros", "numpy.ones", "numpy.append", "numpy.append"], "function", ["None"], ["def", "my_make_moons", "(", "n_samples", "=", "100", ",", "shuffle", "=", "True", ",", "noise", "=", "None", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "\"\"\"This is a slightly modified function as compared to the sklearn version.\n    This functions makes two interleaving half circles\n    A simple toy dataset to visualize clustering and classification\n    algorithms. Read more in the :ref:`User Guide <sample_generators>`. \n    In this version, the position of sample points on the half circles is also\n    random.\n    Parameters\n    ----------\n    n_samples : int, optional (default=100)\n        The total number of points generated.\n    shuffle : bool, optional (default=True)\n        Whether to shuffle the samples.\n    noise : double or None (default=None)\n        Standard deviation of Gaussian noise added to the data.\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n    Returns\n    -------\n    X : array of shape [n_samples, 2]\n        The generated samples.\n    y : array of shape [n_samples]\n        The integer labels (0 or 1) for class membership of each sample.\n    \"\"\"", "\n", "\n", "n_samples_out", "=", "n_samples", "//", "2", "\n", "n_samples_in", "=", "n_samples", "-", "n_samples_out", "\n", "\n", "generator", "=", "check_random_state", "(", "random_state", ")", "\n", "\n", "angle", "=", "generator", ".", "uniform", "(", "size", "=", "(", "n_samples_out", ",", ")", ")", "*", "np", ".", "pi", "\n", "outer_circ_x", "=", "np", ".", "cos", "(", "angle", ")", "\n", "outer_circ_y", "=", "np", ".", "sin", "(", "angle", ")", "\n", "angle", "=", "generator", ".", "uniform", "(", "size", "=", "(", "n_samples_out", ",", ")", ")", "*", "np", ".", "pi", "\n", "inner_circ_x", "=", "1", "-", "np", ".", "cos", "(", "angle", ")", "\n", "inner_circ_y", "=", "1", "-", "np", ".", "sin", "(", "angle", ")", "-", ".5", "\n", "\n", "X", "=", "np", ".", "vstack", "(", "(", "np", ".", "append", "(", "outer_circ_x", ",", "inner_circ_x", ")", ",", "\n", "np", ".", "append", "(", "outer_circ_y", ",", "inner_circ_y", ")", ")", ")", ".", "T", "\n", "y", "=", "np", ".", "hstack", "(", "[", "np", ".", "zeros", "(", "n_samples_out", ",", "dtype", "=", "np", ".", "intp", ")", ",", "\n", "np", ".", "ones", "(", "n_samples_in", ",", "dtype", "=", "np", ".", "intp", ")", "]", ")", "\n", "\n", "if", "shuffle", ":", "\n", "        ", "X", ",", "y", "=", "util_shuffle", "(", "X", ",", "y", ",", "random_state", "=", "generator", ")", "\n", "\n", "", "if", "noise", "!=", "None", ":", "\n", "        ", "X", "+=", "generator", ".", "normal", "(", "scale", "=", "noise", ",", "size", "=", "X", ".", "shape", ")", "\n", "\n", "", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.kfold_data": [[74, 118], ["numpy.array", "range", "range", "range", "X_test_folds.append", "c_test_folds.append", "X_train_folds.append", "c_train_folds.append", "numpy.where", "int", "numpy.setdiff1d", "numpy.array", "numpy.hstack", "numpy.hstack", "numpy.arange", "numpy.hstack", "numpy.hstack", "range", "len", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "kfold_data", "(", "X", ",", "c", ",", "k", ",", "n_class", ")", ":", "\n", "    ", "\"\"\"\n    A function to split a dataset according to the statified k fold cross validation\n    principle. If there is less class representative example than folds, some\n    folds may not contain any example of this class.\n    \"\"\"", "\n", "(", "d", ",", "n", ")", "=", "X", ".", "shape", "\n", "X_test_folds", "=", "[", "]", "\n", "c_test_folds", "=", "[", "]", "\n", "X_train_folds", "=", "[", "]", "\n", "c_train_folds", "=", "[", "]", "\n", "myrows", "=", "np", ".", "array", "(", "range", "(", "d", ")", ",", "dtype", "=", "np", ".", "int", ")", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_class", ")", ":", "\n", "            ", "mycols", "=", "np", ".", "where", "(", "c", "==", "j", ")", "\n", "X_loc", "=", "X", "[", "myrows", "[", ":", ",", "np", ".", "newaxis", "]", ",", "mycols", "]", "\n", "c_loc", "=", "c", "[", "mycols", "]", "\n", "(", "d", ",", "n_loc", ")", "=", "X_loc", ".", "shape", "\n", "fold_size", "=", "int", "(", "n_loc", "/", "k", ")", "\n", "if", "(", "fold_size", ">", "0", ")", ":", "\n", "                ", "mycols", "=", "np", ".", "array", "(", "range", "(", "i", "*", "fold_size", ",", "(", "i", "+", "1", ")", "*", "fold_size", ")", ",", "dtype", "=", "np", ".", "int", ")", "\n", "", "else", ":", "\n", "                ", "if", "(", "i", "<", "len", "(", "c_loc", ")", ")", ":", "\n", "                    ", "mycols", "=", "np", ".", "array", "(", "[", "i", "]", ",", "dtype", "=", "np", ".", "int", ")", "\n", "", "else", ":", "\n", "                    ", "mycols", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int", ")", "\n", "", "", "if", "(", "j", "==", "0", ")", ":", "\n", "                ", "X_test_fold", "=", "X_loc", "[", "myrows", "[", ":", ",", "np", ".", "newaxis", "]", ",", "mycols", "]", "\n", "c_test_fold", "=", "c_loc", "[", "mycols", "]", "\n", "", "else", ":", "\n", "                ", "X_test_fold", "=", "np", ".", "hstack", "(", "(", "X_test_fold", ",", "X_loc", "[", "myrows", "[", ":", ",", "np", ".", "newaxis", "]", ",", "mycols", "]", ")", ")", "\n", "c_test_fold", "=", "np", ".", "hstack", "(", "(", "c_test_fold", ",", "c_loc", "[", "mycols", "]", ")", ")", "\n", "", "mycols", "=", "np", ".", "setdiff1d", "(", "np", ".", "arange", "(", "0", ",", "n_loc", ")", ",", "mycols", ")", "\n", "if", "(", "j", "==", "0", ")", ":", "\n", "                ", "X_train_fold", "=", "X_loc", "[", "myrows", "[", ":", ",", "np", ".", "newaxis", "]", ",", "mycols", "]", "\n", "c_train_fold", "=", "c_loc", "[", "mycols", "]", "\n", "", "else", ":", "\n", "                ", "X_train_fold", "=", "np", ".", "hstack", "(", "(", "X_train_fold", ",", "X_loc", "[", "myrows", "[", ":", ",", "np", ".", "newaxis", "]", ",", "mycols", "]", ")", ")", "\n", "c_train_fold", "=", "np", ".", "hstack", "(", "(", "c_train_fold", ",", "c_loc", "[", "mycols", "]", ")", ")", "\n", "", "", "X_test_folds", ".", "append", "(", "X_test_fold", ")", "\n", "c_test_folds", ".", "append", "(", "c_test_fold", ")", "\n", "X_train_folds", ".", "append", "(", "X_train_fold", ")", "\n", "c_train_folds", ".", "append", "(", "c_train_fold", ")", "\n", "", "return", "X_train_folds", ",", "c_train_folds", ",", "X_test_folds", ",", "c_test_folds", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.indep": [[119, 131], ["numpy.zeros", "range", "range"], "function", ["None"], ["", "def", "indep", "(", "cond_cdf", ",", "n_class", ")", ":", "\n", "    ", "\"\"\"\n    A function to compute the conditional joint cdfs from conditional maginal \n    ones using to the indepedent copula model.\n    The joint cdf is 2D, meaning that it applies to a pair of clfs.\n    The function cannot be used if the number of classes is too large.\n    \"\"\"", "\n", "joint_cdf", "=", "np", ".", "zeros", "(", "(", "n_class", ",", "n_class", ",", "n_class", ")", ")", "\n", "for", "i", "in", "range", "(", "n_class", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_class", ")", ":", "\n", "            ", "joint_cdf", "[", "j", ",", ":", ",", "i", "]", "=", "cond_cdf", "[", "0", "]", "[", "j", ",", "i", "]", "*", "cond_cdf", "[", "1", "]", "[", ":", ",", "i", "]", "\n", "", "", "return", "joint_cdf", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.pdf2cdf": [[133, 147], ["numpy.zeros", "range", "ValueError", "range", "numpy.cumsum"], "function", ["None"], ["", "def", "pdf2cdf", "(", "pdf", ")", ":", "\n", "    ", "\"\"\"\n    This function turns a set of joint pdfs to a set of joint cdfs.\n    Warning: only works for a pair of classifiers.\n    input pdf is a collection of conditional 2D joint cdfs (given true class).\n    \"\"\"", "\n", "(", "Ns_loc", ",", "n_class1", ",", "n_class2", ")", "=", "pdf", ".", "shape", "\n", "if", "(", "n_class1", "!=", "n_class2", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'The second and third dimensions must agree (number of classes).'", ")", "\n", "", "cdf", "=", "np", ".", "zeros", "(", "(", "Ns_loc", ",", "n_class1", ",", "n_class1", ")", ")", "\n", "for", "i", "in", "range", "(", "Ns_loc", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_class1", ")", ":", "\n", "            ", "cdf", "[", "i", "]", "[", ":", ",", "j", "]", "=", "np", ".", "cumsum", "(", "pdf", "[", "i", "]", "[", ":", ",", "j", "]", ")", "\n", "", "", "return", "cdf", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.gausscop_pdf": [[149, 186], ["numpy.sum", "scipy.stats.norm.ppf", "numpy.power", "len", "max", "len", "min", "print", "ValueError", "numpy.dot", "numpy.eye", "numpy.min", "numpy.where", "numpy.where", "numpy.dot", "numpy.log", "len", "numpy.ones", "len", "len", "numpy.where", "numpy.where", "numpy.max", "numpy.eye", "len", "len", "numpy.where", "len", "len", "numpy.where"], "function", ["None"], ["", "def", "gausscop_pdf", "(", "u", ",", "theta", ")", ":", "\n", "    ", "\"\"\"\n    Computes the combined predictions based on those returned by classifiers.\n    \n    Parameters\n    ----------    \n     - u : numpy array containing the conditional cdf of each classifier \n    - theta : the classifier covariance parameter. This parameter lives in the \n    open interval (-1/(len(u)-1);1).\n    \n    Returns\n    -------\n    - cop : scalar (copula value)\n    \"\"\"", "\n", "invmat", "=", "1", "/", "(", "1", "-", "theta", ")", "*", "(", "np", ".", "eye", "(", "len", "(", "u", ")", ")", "-", "theta", "/", "(", "1", "+", "(", "len", "(", "u", ")", "-", "1", ")", "*", "theta", ")", "*", "np", ".", "ones", "(", "(", "len", "(", "u", ")", ",", "len", "(", "u", ")", ")", ")", ")", "\n", "det", "=", "(", "1", "+", "(", "len", "(", "u", ")", "-", "1", ")", "*", "theta", ")", "*", "np", ".", "power", "(", "1", "-", "theta", ",", "len", "(", "u", ")", "-", "1", ")", "\n", "precision", "=", "sys", ".", "float_info", ".", "epsilon", "*", "1e6", "\n", "if", "(", "len", "(", "u", "[", "np", ".", "where", "(", "u", ">", "precision", ")", "]", ")", ">", "0", ")", ":", "\n", "        ", "mini", "=", "np", ".", "min", "(", "u", "[", "np", ".", "where", "(", "u", ">", "0", ")", "]", ")", "*", "1e-6", "#something a lot smaller than the minimal positive value in u", "\n", "mini", "=", "max", "(", "mini", ",", "precision", ")", "\n", "", "else", ":", "# all entries in u are null or negative", "\n", "        ", "mini", "=", "precision", "\n", "", "if", "(", "len", "(", "u", "[", "np", ".", "where", "(", "u", "<", "1", "-", "precision", ")", "]", ")", ">", "0", ")", ":", "\n", "        ", "maxi", "=", "1", "-", "(", "1", "-", "np", ".", "max", "(", "u", "[", "np", ".", "where", "(", "u", "<", "1", ")", "]", ")", ")", "*", "1e-6", "#something a lot larger than the maximal value in u that is below 1", "\n", "maxi", "=", "min", "(", "maxi", ",", "1", "-", "precision", ")", "\n", "", "else", ":", "# all entries in u are 1 or something bigger", "\n", "        ", "maxi", "=", "1", "-", "precision", "\n", "", "u", "[", "np", ".", "where", "(", "u", "<=", "0", ")", "]", "=", "mini", "#avoid -inf", "\n", "u", "[", "np", ".", "where", "(", "u", ">=", "1", ")", "]", "=", "maxi", "#avoid +inf     ", "\n", "if", "(", "np", ".", "sum", "(", "u", ">=", "1", ")", ")", ":", "\n", "        ", "print", "(", "u", ")", "\n", "raise", "ValueError", "(", "'stop'", ")", "\n", "", "v", "=", "norm", ".", "ppf", "(", "u", ")", "\n", "\n", "#cop = 1/np.sqrt(det) * np.exp(np.dot(-0.5*v, np.dot(invmat-np.eye(len(u)),v) ))", "\n", "log_cop", "=", "np", ".", "dot", "(", "-", "0.5", "*", "v", ",", "np", ".", "dot", "(", "invmat", "-", "np", ".", "eye", "(", "len", "(", "u", ")", ")", ",", "v", ")", ")", "-", "0.5", "*", "np", ".", "log", "(", "det", ")", "\n", "return", "log_cop", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.combinedPred": [[187, 262], ["numpy.zeros", "range", "numpy.reshape", "numpy.isscalar", "ValueError", "numpy.asarray", "range", "numpy.reshape", "numpy.prod", "numpy.ones", "numpy.append", "numpy.asarray", "range", "numpy.reshape", "numpy.zeros", "range", "numpy.argmax", "numpy.argmax", "numpy.append", "numpy.multiply", "numpy.multiply", "delco.gausscop_pdf", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.gausscop_pdf"], ["", "def", "combinedPred", "(", "preds", ",", "cond_pdfs", ",", "priors", ",", "copula", "=", "'indep'", ",", "theta", "=", "None", ",", "cond_cdfs", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Computes the combined predictions based on those returned by classifiers.\n    \n    Parameters\n    ----------    \n     - preds : a 2D numpy array of int\n         It containing the predictions returned by each \n         classifier individually. The 1st dimension is the number of classifier.\n         The second dimension is the number of examples from which the predictions \n         are obtained.\n    \n    - cond_pdfs : 3D numpy array of float\n        It is a collection of conditional pdfs of predicted class given true \n        class for each classifier. The 1st dimension is the classifier index.\n        The second dimension is the predicted class index. The third dimension\n        is the true class index\n        \n    - priors : 1D numpy array of float\n        Probabilities of true classes.\n        \n    - copula : string\n        The name of the chosen copula function (indep,clayton or franck)\n        \n    - theta : float or 1D numpy array of float\n        The parameter of the copula function (only if copula is not indep).\n        The parameters can be different for each true class.\n    Returns\n    -------\n    - pred_out : 1D numpy array\n        This array contains the prediction of the classifier ensemble for each\n        example.\n    \"\"\"", "\n", "n_class", "=", "priors", ".", "shape", "[", "0", "]", "\n", "if", "(", "preds", ".", "ndim", "==", "1", ")", ":", "\n", "        ", "Ns_loc", "=", "preds", ".", "size", "\n", "n_loc", "=", "1", "\n", "my_preds", "=", "np", ".", "reshape", "(", "preds", ",", "(", "Ns_loc", ",", "1", ")", ")", "\n", "", "if", "(", "preds", ".", "ndim", "==", "2", ")", ":", "\n", "        ", "(", "Ns_loc", ",", "n_loc", ")", "=", "preds", ".", "shape", "\n", "my_preds", "=", "preds", "\n", "", "if", "(", "np", ".", "isscalar", "(", "theta", ")", "==", "True", ")", ":", "\n", "        ", "my_theta", "=", "theta", "*", "np", ".", "ones", "(", "(", "n_class", ",", ")", ")", "\n", "", "else", ":", "\n", "        ", "my_theta", "=", "theta", "\n", "", "(", "Ns_loc", ",", "n_class1", ",", "n_class2", ")", "=", "cond_pdfs", ".", "shape", "\n", "pred_out", "=", "np", ".", "zeros", "(", "(", "n_loc", ",", ")", ",", "dtype", "=", "int", ")", "\n", "if", "(", "n_class1", "!=", "n_class2", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'The second and third dimensions must agree (number of classes).'", ")", "\n", "", "for", "i", "in", "range", "(", "n_loc", ")", ":", "#loop on examples", "\n", "        ", "pdf", "=", "np", ".", "asarray", "(", "[", "]", ")", "\n", "for", "j", "in", "range", "(", "Ns_loc", ")", ":", "\n", "            ", "pdf", "=", "np", ".", "append", "(", "pdf", ",", "cond_pdfs", "[", "j", ",", "my_preds", "[", "j", ",", "i", "]", ",", ":", "]", ")", "\n", "", "pdf", "=", "np", ".", "reshape", "(", "pdf", ",", "(", "Ns_loc", ",", "n_class1", ")", ")", "\n", "comb_pdf", "=", "np", ".", "prod", "(", "pdf", ",", "axis", "=", "0", ")", "\n", "#if (my_preds[2,i]!=my_preds[1,i]):", "\n", "#print(pdf,comb_pdf)", "\n", "if", "(", "copula", "!=", "'indep'", ")", ":", "\n", "            ", "cdf", "=", "np", ".", "asarray", "(", "[", "]", ")", "\n", "for", "j", "in", "range", "(", "Ns_loc", ")", ":", "\n", "                ", "cdf", "=", "np", ".", "append", "(", "cdf", ",", "cond_cdfs", "[", "j", ",", "my_preds", "[", "j", ",", "i", "]", ",", ":", "]", ")", "\n", "", "cdf", "=", "np", ".", "reshape", "(", "cdf", ",", "(", "Ns_loc", ",", "n_class1", ")", ")", "\n", "cop", "=", "np", ".", "zeros", "(", "(", "n_class1", ",", ")", ")", "\n", "for", "j", "in", "range", "(", "n_class1", ")", ":", "\n", "                ", "if", "(", "copula", "==", "'Gaussian'", ")", ":", "\n", "                    ", "cop", "[", "j", "]", "=", "gausscop_pdf", "(", "cdf", "[", ":", ",", "j", "]", ",", "my_theta", "[", "j", "]", ")", "\n", "", "", "if", "(", "copula", "==", "'Gaussian'", ")", ":", "\n", "                ", "comb_pdf", "=", "np", ".", "log", "(", "comb_pdf", ")", "+", "cop", "\n", "", "else", ":", "\n", "                ", "comb_pdf", "=", "np", ".", "multiply", "(", "comb_pdf", ",", "cop", ")", "\n", "", "", "if", "(", "copula", "==", "'Gaussian'", ")", ":", "\n", "            ", "pred_out", "[", "i", "]", "=", "np", ".", "argmax", "(", "np", ".", "log", "(", "priors", ")", "+", "comb_pdf", ")", "\n", "", "else", ":", "\n", "            ", "pred_out", "[", "i", "]", "=", "np", ".", "argmax", "(", "np", ".", "multiply", "(", "comb_pdf", ",", "priors", ")", ")", "\n", "", "", "return", "pred_out", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.gen_blobs": [[263, 276], ["sklearn.datasets.make_blobs", "sklearn.datasets.make_blobs", "numpy.vstack", "numpy.hstack", "int", "numpy.asarray", "int", "numpy.asarray"], "function", ["None"], ["", "def", "gen_blobs", "(", "n", ")", ":", "\n", "    ", "\"\"\"\n    This function generates a dataset from the following generating process: \n    4 gaussian 2D distributions centered on each corner of a centered square\n    whose side length is 4. Each gaussian has unit variance\n    The diagonal blobs generates example of class n\u00b0 0. The anti-diagonal blobs \n    generates examples of class n\u00b01 and n\u00b02 respectively.\n    \"\"\"", "\n", "X", ",", "y", "=", "make_blobs", "(", "n_samples", "=", "int", "(", "0.75", "*", "n", ")", ",", "n_features", "=", "2", ",", "centers", "=", "np", ".", "asarray", "(", "[", "[", "-", "2", ",", "-", "2", "]", ",", "[", "-", "2", ",", "2", "]", ",", "[", "2", ",", "-", "2", "]", "]", ")", ")", "\n", "X2", ",", "y2", "=", "make_blobs", "(", "n_samples", "=", "int", "(", "0.25", "*", "n", ")", ",", "n_features", "=", "2", ",", "centers", "=", "np", ".", "asarray", "(", "[", "[", "2", ",", "2", "]", "]", ")", ")", "\n", "X", "=", "np", ".", "vstack", "(", "(", "X", ",", "X2", ")", ")", "\n", "y", "=", "np", ".", "hstack", "(", "(", "y", ",", "y2", ")", ")", "\n", "return", "(", "X", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.weighted_vote": [[277, 288], ["numpy.zeros", "range", "numpy.argmax", "range"], "function", ["None"], ["", "def", "weighted_vote", "(", "preds", ",", "acc", ",", "n_class", ")", ":", "\n", "    ", "\"\"\"\n    A simple classifier combination based on a weighted vote. Each classifier \n    vote is weighted according to its estimated accuraccy.\n    \"\"\"", "\n", "(", "Ns", ",", "n", ")", "=", "preds", ".", "shape", "\n", "votes", "=", "np", ".", "zeros", "(", "(", "n", ",", "n_class", ")", ")", "\n", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "        ", "votes", "[", "range", "(", "n", ")", ",", "preds", "[", "i", ",", ":", "]", "]", "+=", "acc", "[", "i", "]", "\n", "", "pred_out", "=", "np", ".", "argmax", "(", "votes", ",", "axis", "=", "1", ")", "\n", "return", "pred_out", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.opt_pred": [[289, 318], ["numpy.zeros", "numpy.where", "numpy.where", "numpy.linspace", "numpy.cos", "numpy.sin", "range", "numpy.cos", "numpy.sum", "numpy.sum", "ValueError", "numpy.sin", "numpy.exp", "numpy.exp"], "function", ["None"], ["", "def", "opt_pred", "(", "name", ",", "X", ")", ":", "\n", "    ", "\"\"\"\n    Optimal classifiers for each generating process.\n    \"\"\"", "\n", "preds", "=", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", ")", ",", "dtype", "=", "int", ")", "\n", "if", "(", "name", "==", "'blobs'", ")", ":", "\n", "        ", "ind", "=", "np", ".", "where", "(", "(", "X", "[", ":", ",", "0", "]", "<", "0", ")", "&", "(", "X", "[", ":", ",", "1", "]", ">", "0", ")", ")", "\n", "preds", "[", "ind", "]", "=", "1", "\n", "ind", "=", "np", ".", "where", "(", "(", "X", "[", ":", ",", "0", "]", ">", "0", ")", "&", "(", "X", "[", ":", ",", "1", "]", "<", "0", ")", ")", "\n", "preds", "[", "ind", "]", "=", "2", "\n", "", "elif", "(", "name", "==", "'moons'", ")", ":", "\n", "        ", "angle", "=", "np", ".", "linspace", "(", "0", ",", "np", ".", "pi", ",", "100", ")", "\n", "outer_circ_x", "=", "np", ".", "cos", "(", "angle", ")", "\n", "outer_circ_y", "=", "np", ".", "sin", "(", "angle", ")", "\n", "inner_circ_x", "=", "1", "-", "np", ".", "cos", "(", "angle", ")", "\n", "inner_circ_y", "=", "1", "-", "np", ".", "sin", "(", "angle", ")", "-", ".5", "\n", "for", "i", "in", "range", "(", "X", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "d0", "=", "(", "outer_circ_x", "-", "X", "[", "i", ",", ":", "]", "[", "0", "]", ")", "**", "2", "+", "(", "outer_circ_y", "-", "X", "[", "i", ",", ":", "]", "[", "1", "]", ")", "**", "2", "\n", "p0", "=", "np", ".", "sum", "(", "np", ".", "exp", "(", "-", "d0", "/", "(", "2", "*", "0.3", "**", "2", ")", ")", ")", "\n", "d1", "=", "(", "inner_circ_x", "-", "X", "[", "i", ",", ":", "]", "[", "0", "]", ")", "**", "2", "+", "(", "inner_circ_y", "-", "X", "[", "i", ",", ":", "]", "[", "1", "]", ")", "**", "2", "\n", "p1", "=", "np", ".", "sum", "(", "np", ".", "exp", "(", "-", "d1", "/", "(", "2", "*", "0.3", "**", "2", ")", ")", ")", "\n", "if", "(", "p1", ">", "p0", ")", ":", "\n", "                ", "preds", "[", "i", "]", "=", "1", "\n", "", "", "", "elif", "(", "name", "==", "'circles'", ")", ":", "\n", "        ", "d", "=", "(", "X", "[", ":", ",", "0", "]", ")", "**", "2", "+", "(", "X", "[", ":", ",", "1", "]", ")", "**", "2", "\n", "preds", "=", "(", "d", "<", "0.75", "**", "2", ")", ".", "astype", "(", "int", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown generating process name.'", ")", "\n", "", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.get_local_data": [[319, 363], ["numpy.where", "numpy.where", "numpy.arctan2", "ValueError", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.where"], "function", ["None"], ["", "def", "get_local_data", "(", "X", ",", "y", ",", "i", ",", "name", ")", ":", "\n", "    ", "\"\"\"\n    This functions returns the piece of the dataset that will be used to train\n    classifier number i.\n    \"\"\"", "\n", "if", "(", "name", "==", "'blobs'", ")", ":", "\n", "        ", "if", "(", "i", "==", "0", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "X", "[", ":", ",", "0", "]", "<", "-", "X", "[", ":", ",", "1", "]", ")", "[", "0", "]", "\n", "X_train_loc", "=", "X", "[", "ind", ",", ":", "]", "\n", "y_train_loc", "=", "y", "[", "ind", "]", "\n", "", "if", "(", "i", "==", "1", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "X", "[", ":", ",", "0", "]", ">=", "-", "X", "[", ":", ",", "1", "]", ")", "[", "0", "]", "\n", "X_train_loc", "=", "X", "[", "ind", ",", ":", "]", "\n", "y_train_loc", "=", "y", "[", "ind", "]", "\n", "", "", "elif", "(", "name", "==", "'moons'", ")", ":", "\n", "        ", "if", "(", "i", "==", "0", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "X", "[", ":", ",", "0", "]", "<", "0", ")", "[", "0", "]", "\n", "X_train_loc", "=", "X", "[", "ind", ",", ":", "]", "\n", "y_train_loc", "=", "y", "[", "ind", "]", "\n", "", "if", "(", "i", "==", "1", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "(", "X", "[", ":", ",", "0", "]", ">=", "0", ")", "&", "(", "X", "[", ":", ",", "0", "]", "<", "1", ")", ")", "[", "0", "]", "\n", "X_train_loc", "=", "X", "[", "ind", ",", ":", "]", "\n", "y_train_loc", "=", "y", "[", "ind", "]", "\n", "", "if", "(", "i", "==", "2", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "X", "[", ":", ",", "0", "]", ">=", "1", ")", "[", "0", "]", "\n", "X_train_loc", "=", "X", "[", "ind", ",", ":", "]", "\n", "y_train_loc", "=", "y", "[", "ind", "]", "\n", "", "", "elif", "(", "name", "==", "'circles'", ")", ":", "\n", "        ", "theta", "=", "np", ".", "arctan2", "(", "X", "[", ":", ",", "1", "]", ",", "X", "[", ":", ",", "0", "]", ")", "\n", "if", "(", "i", "==", "0", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "theta", "<", "-", "np", ".", "pi", "/", "3", ")", "[", "0", "]", "\n", "X_train_loc", "=", "X", "[", "ind", ",", ":", "]", "\n", "y_train_loc", "=", "y", "[", "ind", "]", "\n", "", "if", "(", "i", "==", "1", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "(", "theta", ">=", "-", "np", ".", "pi", "/", "3", ")", "&", "(", "theta", "<", "np", ".", "pi", "/", "3", ")", ")", "[", "0", "]", "\n", "X_train_loc", "=", "X", "[", "ind", ",", ":", "]", "\n", "y_train_loc", "=", "y", "[", "ind", "]", "\n", "", "if", "(", "i", "==", "2", ")", ":", "\n", "            ", "ind", "=", "np", ".", "where", "(", "theta", ">=", "np", ".", "pi", "/", "3", ")", "[", "0", "]", "\n", "X_train_loc", "=", "X", "[", "ind", ",", ":", "]", "\n", "y_train_loc", "=", "y", "[", "ind", "]", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown generating process name.'", ")", "\n", "", "return", "X_train_loc", ",", "y_train_loc", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.get_split_data": [[364, 386], ["range", "delco.get_local_data", "X.append", "y.append", "delco.kfold_data", "range", "ValueError", "X.append", "y.append"], "function", ["home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.get_local_data", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.kfold_data"], ["", "def", "get_split_data", "(", "X_all", ",", "y_all", ",", "name", ",", "mode", ",", "Ns", ",", "n_class", ")", ":", "\n", "    ", "\"\"\"\n    This function splits the dataset into several pieces - on for each classifier\n    to be trained. The splitting scheme is different for each generating process.\n    \"\"\"", "\n", "X", "=", "[", "]", "\n", "y", "=", "[", "]", "\n", "if", "(", "mode", "==", "'deterministic_split'", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "            ", "(", "X_loc", ",", "y_loc", ")", "=", "get_local_data", "(", "X_all", ",", "y_all", ",", "i", ",", "name", ")", "\n", "X", ".", "append", "(", "X_loc", ")", "\n", "y", ".", "append", "(", "y_loc", ")", "\n", "", "", "elif", "(", "mode", "==", "'random_split'", ")", ":", "\n", "        ", "X_train_folds", ",", "y_train_folds", ",", "X_test_folds", ",", "y_test_folds", "=", "kfold_data", "(", "X_all", ".", "T", ",", "y_all", ",", "Ns", ",", "n_class", ")", "\n", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "            ", "X_loc", "=", "X_test_folds", "[", "i", "]", ".", "T", "\n", "y_loc", "=", "y_test_folds", "[", "i", "]", "\n", "X", ".", "append", "(", "X_loc", ")", "\n", "y", ".", "append", "(", "y_loc", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown spliting mode name.'", ")", "\n", "", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.normalize": [[387, 392], ["numpy.sum"], "function", ["None"], ["", "def", "normalize", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    This functions normalizes a numpy array (x) so that it sums to one.\n    \"\"\"", "\n", "return", "x", "/", "np", ".", "sum", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.simple_split": [[393, 412], ["numpy.zeros", "range", "numpy.setdiff1d", "numpy.min", "numpy.sum", "int", "range", "numpy.min", "list", "len", "numpy.min", "numpy.where", "numpy.min"], "function", ["None"], ["", "def", "simple_split", "(", "X", ",", "y", ",", "percent", ",", "n_class", ")", ":", "\n", "    ", "\"\"\"\n    This function splits the data in two subsets. The fraction of the data kept\n    by the 1st subset is specified by the parameter \"percent\".\n    \"\"\"", "\n", "cards", "=", "np", ".", "zeros", "(", "(", "n_class", ",", ")", ")", "\n", "inds", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "np", ".", "min", "(", "y", ")", ",", "np", ".", "min", "(", "y", ")", "+", "n_class", ")", ":", "\n", "        ", "cards", "[", "i", "-", "np", ".", "min", "(", "y", ")", "]", "=", "np", ".", "sum", "(", "y", "==", "i", ")", "\n", "proportion", "=", "int", "(", "percent", "*", "cards", "[", "i", "-", "np", ".", "min", "(", "y", ")", "]", ")", "\n", "if", "(", "proportion", "==", "0", ")", ":", "\n", "            ", "proportion", "=", "1", "\n", "", "inds", "=", "inds", "+", "list", "(", "np", ".", "where", "(", "y", "==", "i", ")", "[", "0", "]", "[", ":", "proportion", "]", ")", "\n", "", "X1", "=", "X", "[", "inds", "]", "\n", "y1", "=", "y", "[", "inds", "]", "\n", "inds2", "=", "np", ".", "setdiff1d", "(", "range", "(", "len", "(", "y", ")", ")", ",", "inds", ")", "\n", "X2", "=", "X", "[", "inds2", "]", "\n", "y2", "=", "y", "[", "inds2", "]", "\n", "return", "X1", ",", "y1", ",", "X2", ",", "y2", "\n", "\n"]], "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.launch_test": [[413, 713], ["time.time", "len", "range", "sklearn.linear_model.LogisticRegression", "sklearn.linear_model.LogisticRegression", "print", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "matplotlib.figure", "matplotlib.scatter", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "matplotlib.xlim", "matplotlib.ylim", "delco.get_split_data", "range", "range", "clf[].fit", "clf[].score", "clf[].predict", "range", "numpy.argmax", "delco.pdf2cdf", "numpy.zeros", "range", "sklearn.linear_model.LogisticRegression.fit", "range", "sklearn.linear_model.LogisticRegression.fit", "numpy.zeros", "numpy.ones", "print", "print", "range", "print", "print", "print", "print", "print", "print", "print", "time.time", "print", "matplotlib.plot", "clf.append", "numpy.linspace", "ValueError", "delco.gen_blobs", "delco.simple_split", "X_loc_small.append", "y_loc_small.append", "range", "range", "numpy.zeros", "numpy.zeros", "range", "numpy.median", "clf[].fit", "numpy.zeros", "range", "numpy.zeros", "range", "numpy.sum", "range", "numpy.sum", "delco.opt_pred", "numpy.sum", "range", "numpy.sum", "delco.weighted_vote", "numpy.sum", "sklearn.linear_model.LogisticRegression.predict", "numpy.sum", "sklearn.linear_model.LogisticRegression.predict", "numpy.sum", "range", "print", "sys.stdout.flush", "print", "matplotlib.plot", "matplotlib.plot", "sklearn.linear_model.LogisticRegression", "delco.my_make_moons", "y_all.max", "y_all.min", "numpy.vstack", "numpy.hstack", "numpy.where", "numpy.sum", "numpy.asarray", "numpy.asarray", "range", "numpy.reshape", "numpy.reshape", "numpy.prod", "range", "numpy.max", "delco.gen_blobs", "clf[].predict", "delco.combinedPred", "numpy.sum", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "delco.combinedPred", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "numpy.isnan", "numpy.max", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "ValueError", "sklearn.datasets.make_circles", "ValueError", "numpy.sum", "numpy.sum", "numpy.append", "numpy.append", "numpy.zeros", "range", "numpy.argmax", "delco.my_make_moons", "scipy.stats.beta.ppf", "scipy.stats.beta.ppf", "numpy.sum", "numpy.multiply", "numpy.multiply", "numpy.where", "sklearn.datasets.make_circles", "ValueError", "str", "delco.gausscop_pdf", "numpy.log", "numpy.log", "numpy.sqrt", "numpy.sqrt", "numpy.max"], "function", ["home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.get_split_data", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.pdf2cdf", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.gen_blobs", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.simple_split", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.opt_pred", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.weighted_vote", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.my_make_moons", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.gen_blobs", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.combinedPred", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.combinedPred", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.my_make_moons", "home.repos.pwc.inspect_result.john-klein_DELCO.None.delco.gausscop_pdf"], ["", "def", "launch_test", "(", "dataset", ",", "mode", ",", "n", ",", "iter_max", "=", "1e6", ",", "sent", "=", "0.1", ",", "copula", "=", "'Gaussian'", ")", ":", "\n", "    ", "\"\"\"\n    This functions launches the DELCO ensemble method as well as other reference\n    methods.\n    \n    Parameters\n    ----------    \n    - dataset : string\n        It specifies the name of the synthetic dataset on which methods are tested.\n        Possible choices are 'moons', 'circles' and 'blobs'.\n    \n    - mode : string\n        It specifies the type of splits for local nodes (base classifiers). To \n        reproduce the paper's results choose 'deterministic_split'. Another \n        available type of split is 'random_split'.\n        \n    - n : int\n        dataset size.\n        \n    - iter_max : int\n        Maximal number of loops. It should be set to np.inf to achieve the \n        prescribed confidence level.\n        \n    - sent: float\n        Percentage of the data sent to the central node.\n    \n    - copula: string\n        The name of the chosen copula for DELCO. Possible choices are 'Gaussian'\n        and 'indep'\n    \n    - \n    Returns\n    -------\n    none. Accuracies of the methods are printed.    \n    \"\"\"", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "##########################################", "\n", "# PARAMETERS BELOW SHOULD NOT BE CHANGED #", "\n", "##########################################", "\n", "epsi", "=", "1e-7", "\n", "#classifiers (decentralized logistic regressors)", "\n", "if", "(", "dataset", "==", "'blobs'", ")", ":", "\n", "            ", "names", "=", "[", "\"Reg Log\"", ",", "\"Reg Log\"", "]", "\n", "", "else", ":", "\n", "            ", "names", "=", "[", "\"Reg Log\"", ",", "\"Reg Log\"", ",", "\"Reg Log\"", "]", "\n", "\n", "", "Ns", "=", "len", "(", "names", ")", "\n", "\n", "#base classifier instances", "\n", "clf", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "        ", "if", "names", "[", "i", "]", "==", "'Reg Log'", ":", "\n", "            ", "clf", ".", "append", "(", "LogisticRegression", "(", "penalty", "=", "'l2'", ",", "C", "=", "1.0", ")", ")", "\n", "\n", "#central classifier instance", "\n", "", "", "clf_ctl", "=", "LogisticRegression", "(", "penalty", "=", "'l2'", ",", "C", "=", "1.0", ")", "\n", "\n", "#second level classifier instance (for stacking)", "\n", "clf_meta", "=", "LogisticRegression", "(", "penalty", "=", "'l2'", ",", "C", "=", "1.0", ")", "\n", "\n", "if", "(", "copula", "!=", "'indep'", ")", ":", "\n", "        ", "if", "(", "copula", "==", "'Gaussian'", ")", ":", "\n", "            ", "theta_range", "=", "np", ".", "linspace", "(", "-", "1.0", "/", "(", "Ns", "-", "1", ")", "+", "1e-2", ",", "0.99", ",", "101", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown copula name.'", ")", "\n", "\n", "", "", "degenerate", "=", "True", "\n", "while", "(", "degenerate", "==", "True", ")", ":", "\n", "        ", "if", "(", "dataset", "==", "'blobs'", ")", ":", "\n", "            ", "(", "X_all", ",", "y_all", ")", "=", "gen_blobs", "(", "n", ")", "\n", "", "elif", "(", "dataset", "==", "'moons'", ")", ":", "\n", "            ", "(", "X_all", ",", "y_all", ")", "=", "my_make_moons", "(", "n_samples", "=", "n", ",", "noise", "=", "0.3", ")", "\n", "", "elif", "(", "dataset", "==", "'circles'", ")", ":", "\n", "            ", "(", "X_all", ",", "y_all", ")", "=", "make_circles", "(", "n_samples", "=", "n", ",", "factor", "=", ".5", ",", "noise", "=", ".15", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown generating process name.'", ")", "\n", "\n", "", "n_class", "=", "y_all", ".", "max", "(", ")", "-", "y_all", ".", "min", "(", ")", "+", "1", "\n", "\n", "#Spliting data for each local clf", "\n", "(", "X_loc", ",", "y_loc", ")", "=", "get_split_data", "(", "X_all", ",", "y_all", ",", "dataset", ",", "mode", ",", "Ns", ",", "n_class", ")", "\n", "\n", "#Selecting the send examples to central machine for those methods with budgeted training", "\n", "X_loc_small", "=", "[", "]", "\n", "y_loc_small", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "            ", "X_s", ",", "y_s", ",", "X_i", ",", "y_i", "=", "simple_split", "(", "X_loc", "[", "i", "]", ",", "y_loc", "[", "i", "]", ",", "sent", ",", "n_class", ")", "\n", "X_loc_small", ".", "append", "(", "X_i", ")", "\n", "y_loc_small", ".", "append", "(", "y_i", ")", "\n", "if", "(", "i", "==", "0", ")", ":", "\n", "                ", "X_sent", "=", "X_s", "\n", "y_sent", "=", "y_s", "\n", "", "else", ":", "\n", "                ", "X_sent", "=", "np", ".", "vstack", "(", "(", "X_sent", ",", "X_s", ")", ")", "\n", "y_sent", "=", "np", ".", "hstack", "(", "(", "y_sent", ",", "y_s", ")", ")", "\n", "\n", "", "", "degenerate", "=", "False", "\n", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "n_class", ")", ":", "\n", "                ", "if", "(", "np", ".", "sum", "(", "y_loc_small", "[", "i", "]", "==", "j", ")", "<", "1", ")", ":", "\n", "                    ", "degenerate", "=", "True", "\n", "", "if", "(", "np", ".", "sum", "(", "y_sent", "==", "j", ")", "==", "0", ")", ":", "\n", "                    ", "degenerate", "=", "True", "\n", "", "", "", "", "print", "(", "'dataset ok'", ")", "\n", "\n", "#Estimation of conditional probabilities (predicted class given actual class)", "\n", "cond_pdf", "=", "np", ".", "zeros", "(", "(", "Ns", ",", "n_class", ",", "n_class", ")", ")", "\n", "score_clf", "=", "np", ".", "zeros", "(", "(", "Ns", ",", ")", ")", "\n", "preds", "=", "np", ".", "zeros", "(", "(", "Ns", ",", "y_sent", ".", "size", ")", ",", "dtype", "=", "int", ")", "\n", "for", "i", "in", "range", "(", "Ns", ")", ":", "#Classifier number", "\n", "#Training clfs on decentralized machines on datapoints that are not sent to central machine", "\n", "        ", "clf", "[", "i", "]", ".", "fit", "(", "X_loc_small", "[", "i", "]", ",", "y_loc_small", "[", "i", "]", ")", "\n", "#Evaluation in the central machine", "\n", "score_clf", "[", "i", "]", "=", "clf", "[", "i", "]", ".", "score", "(", "X_sent", ",", "y_sent", ")", "\n", "preds", "[", "i", "]", "=", "clf", "[", "i", "]", ".", "predict", "(", "X_sent", ")", "\n", "for", "j", "in", "range", "(", "n_class", ")", ":", "#True class index", "\n", "            ", "ind", "=", "np", ".", "where", "(", "y_sent", "==", "j", ")", "[", "0", "]", "\n", "for", "k", "in", "range", "(", "n_class", ")", ":", "#Predicted class index", "\n", "                ", "cond_pdf", "[", "i", "]", "[", "k", ",", "j", "]", "+=", "(", "np", ".", "sum", "(", "preds", "[", "i", ",", "ind", "]", "==", "k", ")", "+", "1", ")", "/", "(", "ind", ".", "size", "+", "n_class", ")", "#Laplace add one", "\n", "\n", "", "", "", "if", "(", "degenerate", "==", "False", ")", ":", "#Going on only if it is worth", "\n", "        ", "select", "=", "np", ".", "argmax", "(", "score_clf", ")", "\n", "\n", "#Conditional cumulative distributions", "\n", "cond_cdf", "=", "pdf2cdf", "(", "cond_pdf", ")", "\n", "\n", "#True class probabilities (in central machine)", "\n", "prior", "=", "np", ".", "zeros", "(", "(", "n_class", ",", ")", ")", "\n", "for", "i", "in", "range", "(", "n_class", ")", ":", "\n", "            ", "prior", "[", "i", "]", "=", "np", ".", "sum", "(", "y_sent", "==", "i", ")", "/", "y_sent", ".", "size", "\n", "\n", "#Stacked log reg training", "\n", "", "clf_meta", ".", "fit", "(", "preds", ".", "T", ",", "y_sent", ")", "\n", "\n", "#Copula parameter estimation (grid search) using the sent data on the central machine", "\n", "if", "(", "copula", "!=", "'indep'", ")", ":", "\n", "            ", "theta", "=", "np", ".", "zeros", "(", "(", "n_class", ",", ")", ")", "\n", "theta_success", "=", "np", ".", "zeros", "(", "(", "theta_range", ".", "size", ",", ")", ")", "\n", "#For each (centralized) test data", "\n", "for", "i", "in", "range", "(", "y_sent", ".", "size", ")", ":", "\n", "#Starting the computatuon of the copula based combination prediction", "\n", "                ", "pdf_loc", "=", "np", ".", "asarray", "(", "[", "]", ")", "\n", "cdf_loc", "=", "np", ".", "asarray", "(", "[", "]", ")", "\n", "for", "k", "in", "range", "(", "Ns", ")", ":", "\n", "                    ", "pdf_loc", "=", "np", ".", "append", "(", "pdf_loc", ",", "cond_pdf", "[", "k", ",", "preds", "[", "k", ",", "i", "]", ",", ":", "]", ")", "\n", "cdf_loc", "=", "np", ".", "append", "(", "cdf_loc", ",", "cond_cdf", "[", "k", ",", "preds", "[", "k", ",", "i", "]", ",", ":", "]", ")", "\n", "", "pdf_loc", "=", "np", ".", "reshape", "(", "pdf_loc", ",", "(", "Ns", ",", "n_class", ")", ")", "\n", "cdf_loc", "=", "np", ".", "reshape", "(", "cdf_loc", ",", "(", "Ns", ",", "n_class", ")", ")", "\n", "comb_pdf", "=", "np", ".", "prod", "(", "pdf_loc", ",", "axis", "=", "0", ")", "\n", "#Loop on values of parameter theta", "\n", "for", "j", "in", "range", "(", "theta_range", ".", "size", ")", ":", "\n", "                    ", "cop", "=", "np", ".", "zeros", "(", "(", "n_class", ",", ")", ")", "\n", "for", "k", "in", "range", "(", "n_class", ")", ":", "\n", "                        ", "if", "(", "copula", "==", "'Gaussian'", ")", ":", "\n", "                            ", "cop", "[", "k", "]", "=", "gausscop_pdf", "(", "cdf_loc", "[", ":", ",", "k", "]", ",", "theta_range", "[", "j", "]", ")", "\n", "", "", "if", "(", "copula", "==", "'Gaussian'", ")", ":", "\n", "                        ", "joint", "=", "np", ".", "log", "(", "comb_pdf", ")", "+", "cop", "\n", "posterior", "=", "np", ".", "log", "(", "prior", ")", "+", "joint", "\n", "", "else", ":", "\n", "                        ", "joint", "=", "np", ".", "multiply", "(", "comb_pdf", ",", "cop", ")", "\n", "posterior", "=", "np", ".", "multiply", "(", "joint", ",", "prior", ")", "\n", "", "comb_pred", "=", "np", ".", "argmax", "(", "posterior", ")", "\n", "if", "(", "comb_pred", "==", "y_sent", "[", "i", "]", ")", ":", "\n", "                        ", "theta_success", "[", "j", "]", "+=", "1", "\n", "", "", "", "theta_success", "=", "theta_success", "/", "y_sent", ".", "size", "\n", "theta", "=", "np", ".", "median", "(", "theta_range", "[", "np", ".", "where", "(", "theta_success", "==", "np", ".", "max", "(", "theta_success", ")", ")", "]", ")", "\n", "\n", "#Retrain base classifiers on the whole training set", "\n", "", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "            ", "clf", "[", "i", "]", ".", "fit", "(", "X_loc", "[", "i", "]", ",", "y_loc", "[", "i", "]", ")", "\n", "\n", "#Traning in centralized fashion", "\n", "", "clf_ctl", ".", "fit", "(", "X_all", ",", "y_all", ")", "\n", "\n", "#Start testing on newly generated examples", "\n", "n_test", "=", "0", "\n", "n_test_batch", "=", "10000", "\n", "n_success", "=", "0", "\n", "n_success_select", "=", "0", "\n", "n_success_opt", "=", "0", "\n", "n_success_ind", "=", "0", "\n", "n_success_vote", "=", "0", "\n", "n_success_ctl", "=", "0", "\n", "n_success_met", "=", "0", "\n", "clf_rates", "=", "np", ".", "zeros", "(", "(", "Ns", ",", ")", ")", "\n", "alpha", "=", "0.05", "\n", "clopper_pearson_interval", "=", "np", ".", "ones", "(", "(", "Ns", "+", "7", ")", ")", "\n", "iter_nb", "=", "0", "\n", "print", "(", "'entering main loop'", ")", "\n", "#Looping until Clopper Pearson interval meets prescribed conditions for the accurracy of each prediction method", "\n", "while", "(", "(", "np", ".", "max", "(", "clopper_pearson_interval", ")", ">", "0.002", ")", "and", "(", "iter_nb", "<", "iter_max", ")", ")", ":", "#3e5", "\n", "            ", "if", "(", "dataset", "==", "'blobs'", ")", ":", "\n", "                ", "(", "X_test", ",", "y_test", ")", "=", "gen_blobs", "(", "n_test_batch", ")", "\n", "", "elif", "(", "dataset", "==", "'moons'", ")", ":", "\n", "                ", "(", "X_test", ",", "y_test", ")", "=", "my_make_moons", "(", "n_samples", "=", "n_test_batch", ",", "noise", "=", "0.3", ")", "\n", "", "elif", "(", "dataset", "==", "'circles'", ")", ":", "\n", "                ", "(", "X_test", ",", "y_test", ")", "=", "make_circles", "(", "n_samples", "=", "n_test_batch", ",", "factor", "=", ".5", ",", "noise", "=", ".15", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Unknown generating process name.'", ")", "\n", "", "n_test", "+=", "y_test", ".", "size", "\n", "preds", "=", "np", ".", "zeros", "(", "(", "Ns", ",", "y_test", ".", "size", ")", ",", "dtype", "=", "int", ")", "\n", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "                ", "preds", "[", "i", ",", ":", "]", "=", "clf", "[", "i", "]", ".", "predict", "(", "X_test", ")", "\n", "", "combined_pred", "=", "np", ".", "zeros", "(", "(", "y_test", ".", "size", ",", ")", ")", "\n", "for", "i", "in", "range", "(", "y_test", ".", "size", ")", ":", "\n", "                ", "combined_pred", "[", "i", "]", "=", "combinedPred", "(", "preds", "[", ":", ",", "i", "]", ",", "cond_pdf", ",", "prior", ",", "copula", "=", "copula", ",", "theta", "=", "theta", ",", "cond_cdfs", "=", "cond_cdf", ")", "\n", "", "n_success", "+=", "np", ".", "sum", "(", "combined_pred", "==", "y_test", ")", "\n", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "                ", "clf_rates", "[", "i", "]", "+=", "np", ".", "sum", "(", "preds", "[", "i", ",", ":", "]", "==", "y_test", ")", "\n", "clopper_pearson_interval", "[", "i", "]", "=", "beta", ".", "ppf", "(", "1", "-", "alpha", "/", "2", ",", "clf_rates", "[", "i", "]", "+", "1", ",", "n_test", "-", "clf_rates", "[", "i", "]", "+", "epsi", ")", "-", "beta", ".", "ppf", "(", "alpha", "/", "2", ",", "clf_rates", "[", "i", "]", "+", "epsi", ",", "n_test", "-", "clf_rates", "[", "i", "]", "+", "1", ")", "\n", "", "n_success_select", "+=", "np", ".", "sum", "(", "preds", "[", "select", ",", ":", "]", "==", "y_test", ")", "\n", "#clf selection ", "\n", "clopper_pearson_interval", "[", "Ns", "]", "=", "beta", ".", "ppf", "(", "1", "-", "alpha", "/", "2", ",", "n_success_select", "+", "1", ",", "n_test", "-", "n_success_select", "+", "epsi", ")", "-", "beta", ".", "ppf", "(", "alpha", "/", "2", ",", "n_success_select", "+", "epsi", ",", "n_test", "-", "n_success_select", "+", "1", ")", "\n", "#clf combination", "\n", "clopper_pearson_interval", "[", "Ns", "+", "1", "]", "=", "beta", ".", "ppf", "(", "1", "-", "alpha", "/", "2", ",", "n_success", "+", "1", ",", "n_test", "-", "n_success", "+", "epsi", ")", "-", "beta", ".", "ppf", "(", "alpha", "/", "2", ",", "n_success", "+", "epsi", ",", "n_test", "-", "n_success", "+", "1", ")", "\n", "#optimal classifier", "\n", "opt_preds", "=", "opt_pred", "(", "dataset", ",", "X_test", ")", "\n", "n_success_opt", "+=", "np", ".", "sum", "(", "opt_preds", "==", "y_test", ")", "\n", "clopper_pearson_interval", "[", "Ns", "+", "2", "]", "=", "beta", ".", "ppf", "(", "1", "-", "alpha", "/", "2", ",", "n_success_opt", "+", "1", ",", "n_test", "-", "n_success_opt", "+", "epsi", ")", "-", "beta", ".", "ppf", "(", "alpha", "/", "2", ",", "n_success_opt", "+", "epsi", ",", "n_test", "-", "n_success_opt", "+", "1", ")", "\n", "#clf combination with independent copula", "\n", "for", "i", "in", "range", "(", "y_test", ".", "size", ")", ":", "\n", "                ", "combined_pred", "[", "i", "]", "=", "combinedPred", "(", "preds", "[", ":", ",", "i", "]", ",", "cond_pdf", ",", "prior", ",", "copula", "=", "'indep'", ",", "theta", "=", "theta", ",", "cond_cdfs", "=", "cond_cdf", ")", "\n", "", "n_success_ind", "+=", "np", ".", "sum", "(", "combined_pred", "==", "y_test", ")", "\n", "clopper_pearson_interval", "[", "Ns", "+", "3", "]", "=", "beta", ".", "ppf", "(", "1", "-", "alpha", "/", "2", ",", "n_success_ind", "+", "1", ",", "n_test", "-", "n_success_ind", "+", "epsi", ")", "-", "beta", ".", "ppf", "(", "alpha", "/", "2", ",", "n_success_ind", "+", "epsi", ",", "n_test", "-", "n_success_ind", "+", "1", ")", "\n", "#clf combination based on weighted voting", "\n", "vote_preds", "=", "weighted_vote", "(", "preds", ",", "score_clf", ",", "n_class", ")", "\n", "n_success_vote", "+=", "np", ".", "sum", "(", "vote_preds", "==", "y_test", ")", "\n", "clopper_pearson_interval", "[", "Ns", "+", "4", "]", "=", "beta", ".", "ppf", "(", "1", "-", "alpha", "/", "2", ",", "n_success_vote", "+", "1", ",", "n_test", "-", "n_success_vote", "+", "epsi", ")", "-", "beta", ".", "ppf", "(", "alpha", "/", "2", ",", "n_success_vote", "+", "epsi", ",", "n_test", "-", "n_success_vote", "+", "1", ")", "\n", "#clf centralized learning", "\n", "ctl_preds", "=", "clf_ctl", ".", "predict", "(", "X_test", ")", "\n", "n_success_ctl", "+=", "np", ".", "sum", "(", "ctl_preds", "==", "y_test", ")", "\n", "clopper_pearson_interval", "[", "Ns", "+", "5", "]", "=", "beta", ".", "ppf", "(", "1", "-", "alpha", "/", "2", ",", "n_success_ctl", "+", "1", ",", "n_test", "-", "n_success_ctl", "+", "epsi", ")", "-", "beta", ".", "ppf", "(", "alpha", "/", "2", ",", "n_success_ctl", "+", "epsi", ",", "n_test", "-", "n_success_ctl", "+", "1", ")", "\n", "#stacked clf ", "\n", "met_preds", "=", "clf_meta", ".", "predict", "(", "preds", ".", "T", ")", "\n", "n_success_met", "+=", "np", ".", "sum", "(", "met_preds", "==", "y_test", ")", "\n", "clopper_pearson_interval", "[", "Ns", "+", "6", "]", "=", "beta", ".", "ppf", "(", "1", "-", "alpha", "/", "2", ",", "n_success_met", "+", "1", ",", "n_test", "-", "n_success_met", "+", "epsi", ")", "-", "beta", ".", "ppf", "(", "alpha", "/", "2", ",", "n_success_met", "+", "epsi", ",", "n_test", "-", "n_success_met", "+", "1", ")", "\n", "for", "i", "in", "range", "(", "Ns", "+", "7", ")", ":", "\n", "                ", "if", "(", "np", ".", "isnan", "(", "clopper_pearson_interval", "[", "i", "]", ")", ")", ":", "\n", "                    ", "clopper_pearson_interval", "[", "i", "]", "=", "1", "\n", "", "", "iter_nb", "+=", "1", "\n", "print", "(", "\"\\r{}\"", ".", "format", "(", "iter_nb", ")", ",", "'Largest Clopper-Pearson interval width:'", ",", "np", ".", "max", "(", "clopper_pearson_interval", ")", ",", "end", "=", "\"\"", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "", "print", "(", "'\\n'", ")", "\n", "clf_rates", "/=", "n_test", "\n", "for", "i", "in", "range", "(", "Ns", ")", ":", "\n", "            ", "print", "(", "'Base classifier '", "+", "str", "(", "i", ")", "+", "' accuracy:'", ",", "clf_rates", "[", "i", "]", ")", "\n", "", "select_rate", "=", "n_success_select", "/", "n_test", "\n", "print", "(", "'Selected classifier accuracy:'", ",", "select_rate", ")", "\n", "vote_rate", "=", "n_success_vote", "/", "n_test", "\n", "print", "(", "'Weighted vote accuracy:'", ",", "vote_rate", ")", "\n", "ind_rate", "=", "n_success_ind", "/", "n_test", "\n", "print", "(", "'DELCO (indep. cop.) accuracy:'", ",", "ind_rate", ")", "\n", "combined_rate", "=", "n_success", "/", "n_test", "\n", "print", "(", "'DELCO (Gaussian cop.) accuracy:'", ",", "combined_rate", ")", "\n", "met_rate", "=", "n_success_met", "/", "n_test", "\n", "print", "(", "'Stacking accuracy:'", ",", "met_rate", ")", "\n", "ctl_rate", "=", "n_success_ctl", "/", "n_test", "\n", "print", "(", "'Centralized classifier accuracy:'", ",", "ctl_rate", ")", "\n", "opt_rate", "=", "n_success_opt", "/", "n_test", "\n", "print", "(", "'Optimal classifier accuracy:'", ",", "opt_rate", ")", "\n", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'Elapsed time:'", ",", "end", "-", "start", ")", "\n", "\n", "\n", "", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "scatter", "(", "X_all", "[", ":", ",", "0", "]", ",", "X_all", "[", ":", ",", "1", "]", ",", "marker", "=", "'o'", ",", "c", "=", "y_all", ",", "s", "=", "25", ",", "cmap", "=", "'tab10'", ")", "\n", "x_min", "=", "np", ".", "min", "(", "X_all", "[", ":", ",", "0", "]", ")", "\n", "if", "(", "x_min", "<", "0", ")", ":", "\n", "        ", "x_min", "*=", "1.05", "\n", "", "else", ":", "\n", "        ", "x_min", "*=", "0.95", "\n", "", "x_max", "=", "np", ".", "max", "(", "X_all", "[", ":", ",", "0", "]", ")", "\n", "if", "(", "x_max", ">", "0", ")", ":", "\n", "        ", "x_max", "*=", "1.05", "\n", "", "else", ":", "\n", "        ", "x_max", "*=", "0.95", "\n", "", "y_min", "=", "np", ".", "min", "(", "X_all", "[", ":", ",", "1", "]", ")", "\n", "if", "(", "y_min", "<", "0", ")", ":", "\n", "        ", "y_min", "*=", "1.05", "\n", "", "else", ":", "\n", "        ", "y_min", "*=", "0.95", "\n", "", "y_max", "=", "np", ".", "max", "(", "X_all", "[", ":", ",", "1", "]", ")", "\n", "if", "(", "y_max", ">", "0", ")", ":", "\n", "        ", "y_max", "*=", "1.05", "\n", "", "else", ":", "\n", "        ", "y_max", "*=", "0.95", "\n", "", "plt", ".", "xlim", "(", "x_min", ",", "x_max", ")", "\n", "plt", ".", "ylim", "(", "y_min", ",", "y_max", ")", "\n", "if", "(", "dataset", "==", "'blobs'", ")", ":", "\n", "        ", "plt", ".", "plot", "(", "[", "x_min", ",", "x_max", "]", ",", "[", "y_max", ",", "y_min", "]", ",", "'--m'", ")", "\n", "", "elif", "(", "dataset", "==", "'moons'", ")", ":", "\n", "        ", "plt", ".", "plot", "(", "[", "0", ",", "0", "]", ",", "[", "y_max", ",", "y_min", "]", ",", "'--m'", ")", "\n", "plt", ".", "plot", "(", "[", "1", ",", "1", "]", ",", "[", "y_max", ",", "y_min", "]", ",", "'--m'", ")", "\n", "", "elif", "(", "dataset", "==", "'circles'", ")", ":", "\n", "        ", "plt", ".", "plot", "(", "[", "0", ",", "-", "y_min", "/", "np", ".", "sqrt", "(", "3", ")", "]", ",", "[", "0", ",", "y_min", "]", ",", "'--m'", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "y_max", "/", "np", ".", "sqrt", "(", "3", ")", "]", ",", "[", "0", ",", "y_max", "]", ",", "'--m'", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "x_min", "]", ",", "[", "0", ",", "0", "]", ",", "'--m'", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown generating process name.'", ")", "\n", "\n"]]}