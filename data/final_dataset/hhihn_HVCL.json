{"home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.__init__": [[15, 19], ["collections.deque"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "buffer_size", ":", "int", ")", "->", "None", ":", "\n", "        ", "self", ".", "buffer_size", ":", "int", "=", "buffer_size", "\n", "self", ".", "num_experiences", ":", "int", "=", "0", "\n", "self", ".", "buffer", ":", "deque", "=", "deque", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.get_batch": [[20, 30], ["random.sample", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample"], ["", "def", "get_batch", "(", "self", ",", "num_samples", ":", "int", ")", "->", "np", ".", "array", ":", "\n", "\n", "# Randomly sample batch_size examples", "\n", "        ", "experiences", "=", "random", ".", "sample", "(", "self", ".", "buffer", ",", "num_samples", ")", "\n", "return", "{", "\n", "\"states0\"", ":", "np", ".", "asarray", "(", "[", "exp", "[", "0", "]", "for", "exp", "in", "experiences", "]", ",", "np", ".", "float32", ")", ",", "\n", "\"actions\"", ":", "np", ".", "asarray", "(", "[", "exp", "[", "1", "]", "for", "exp", "in", "experiences", "]", ",", "np", ".", "float32", ")", ",", "\n", "\"rewards\"", ":", "np", ".", "asarray", "(", "[", "exp", "[", "2", "]", "for", "exp", "in", "experiences", "]", ",", "np", ".", "float32", ")", ",", "\n", "\"states1\"", ":", "np", ".", "asarray", "(", "[", "exp", "[", "3", "]", "for", "exp", "in", "experiences", "]", ",", "np", ".", "float32", ")", ",", "\n", "\"terminals1\"", ":", "np", ".", "asarray", "(", "[", "exp", "[", "4", "]", "for", "exp", "in", "experiences", "]", ",", "np", ".", "float32", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.add": [[32, 40], ["HVCL_rl_utils.ReplayBuffer.buffer.append", "HVCL_rl_utils.ReplayBuffer.buffer.popleft", "HVCL_rl_utils.ReplayBuffer.buffer.append"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "state", ":", "np", ".", "ndarray", ",", "action", ":", "np", ".", "ndarray", ",", "reward", ":", "float", ",", "new_state", ":", "np", ".", "ndarray", ",", "done", ":", "bool", ")", ":", "\n", "        ", "experience", "=", "(", "state", ",", "action", ",", "reward", ",", "new_state", ",", "done", ")", "\n", "if", "self", ".", "num_experiences", "<", "self", ".", "buffer_size", ":", "\n", "            ", "self", ".", "buffer", ".", "append", "(", "experience", ")", "\n", "self", ".", "num_experiences", "+=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "buffer", ".", "popleft", "(", ")", "\n", "self", ".", "buffer", ".", "append", "(", "experience", ")", "\n", "# print(\"Added Experience:\", experience, \"Count is now %d\"%self.num_experiences)", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size": [[42, 45], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "size", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "buffer_size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.n_entries": [[46, 51], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_entries", "(", "self", ")", "->", "int", ":", "\n", "# If buffer is full, return buffer size", "\n", "# Otherwise, return experience counter", "\n", "        ", "return", "self", ".", "num_experiences", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.get_last_n": [[52, 59], ["range", "data.append", "HVCL_rl_utils.ReplayBuffer.buffer.popleft"], "methods", ["None"], ["", "def", "get_last_n", "(", "self", ",", "n", ")", ":", "\n", "        ", "if", "n", ">", "self", ".", "num_experiences", ":", "\n", "            ", "n", "=", "self", ".", "num_experiences", "\n", "", "data", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "            ", "data", ".", "append", "(", "self", ".", "buffer", ".", "popleft", "(", ")", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.erase": [[60, 63], ["collections.deque"], "methods", ["None"], ["", "def", "erase", "(", "self", ")", ":", "\n", "        ", "self", ".", "buffer", "=", "deque", "(", ")", "\n", "self", ".", "num_experiences", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.extend": [[64, 67], ["len", "HVCL_rl_utils.ReplayBuffer.buffer.extend"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.extend"], ["", "def", "extend", "(", "self", ",", "data", ")", ":", "\n", "        ", "self", ".", "num_experiences", "+=", "len", "(", "data", ")", "\n", "self", ".", "buffer", ".", "extend", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.__init__": [[70, 162], ["tensorflow.keras.Model.__init__", "tensorflow.keras.layers.Input", "tensorflow.keras.Model", "HVCL_rl_utils.ActorNetwork.model_layers.compile", "print", "HVCL_rl_utils.ActorNetwork.model_layers.summary", "ds.kl_divergence", "tensorflow.cast", "tensorflow.maximum", "tensorflow.cast", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "p.entropy", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.entropy"], ["    ", "def", "__init__", "(", "self", ",", "n_hidden_units", ",", "n_actions", ",", "logprob_epsilon", ",", "expert_beta", ",", "gating_beta", ",", "inputdim", ",", "\n", "n_experts", "=", "1", ",", "vmoe", "=", "True", ",", "k", "=", "1", ")", ":", "\n", "        ", "super", "(", "ActorNetwork", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "deep", "=", "True", "\n", "self", ".", "vmoe", "=", "vmoe", "\n", "self", ".", "n_actions", "=", "n_actions", "\n", "self", ".", "n_experts", "=", "n_experts", "\n", "self", ".", "expert_beta", "=", "expert_beta", "\n", "self", ".", "gating_beta", "=", "gating_beta", "\n", "self", ".", "diversity_bonus", "=", "1e-1", "\n", "self", ".", "kl_divergence_function", "=", "(", "lambda", "q", ",", "p", ":", "ds", ".", "kl_divergence", "(", "q", ",", "p", ")", "/", "tf", ".", "cast", "(", "1.0", ",", "dtype", "=", "tf", ".", "float32", ")", ")", "\n", "self", ".", "entropy_function", "=", "(", "lambda", "p", ":", "tf", ".", "maximum", "(", "p", ".", "entropy", "(", ")", ",", "0.0", ")", "/", "tf", ".", "cast", "(", "12560", ",", "dtype", "=", "tf", ".", "float32", ")", ")", "\n", "self", ".", "logprob_epsilon", "=", "logprob_epsilon", "\n", "self", ".", "k", "=", "k", "\n", "input_layer", "=", "Input", "(", "shape", "=", "inputdim", ")", "\n", "if", "self", ".", "vmoe", ":", "\n", "            ", "if", "self", ".", "deep", ":", "\n", "                ", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "name", "=", "\"actor_dense_0\"", ")", "(", "input_layer", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "name", "=", "\"actor_dense_1\"", ")", "(", "x", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "name", "=", "\"actor_dense_2\"", ")", "(", "x", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "name", "=", "\"actor_dense_3\"", ")", "(", "x", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "name", "=", "\"actor_dense_0\"", ")", "(", "input_layer", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "name", "=", "\"actor_dense_1\"", ")", "(", "x", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "", "actor_output", "=", "DenseMoVE", "(", "units", "=", "n_actions", "*", "2", ",", "expert_activation", "=", "None", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "entropy_fun", "=", "self", ".", "entropy_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "name", "=", "\"actor_output\"", ")", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "Dense", "(", "units", "=", "n_hidden_units", ",", "activation", "=", "tf", ".", "nn", ".", "relu", ")", "(", "input_layer", ")", "\n", "x", "=", "Dense", "(", "units", "=", "n_hidden_units", ",", "activation", "=", "tf", ".", "nn", ".", "relu", ")", "(", "x", ")", "\n", "actor_output", "=", "Dense", "(", "units", "=", "n_actions", "*", "2", ",", "activation", "=", "None", ")", "(", "x", ")", "\n", "", "self", ".", "model_layers", "=", "Model", "(", "input_layer", ",", "actor_output", ")", "\n", "self", ".", "model_layers", ".", "compile", "(", ")", "\n", "print", "(", "self", ".", "model_layers", ".", "summary", "(", ")", ")", "\n", "# self.log_std = Dense(units=n_actions, activation=None, kernel_initializer=\"glorot_uniform\", name=\"actor_log_std\")", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.gaussian_likelihood": [[164, 177], ["tensorflow.function", "tensorflow.reduce_sum", "numpy.log", "tensorflow.exp"], "methods", ["None"], ["", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "gaussian_likelihood", "(", "self", ",", "input", ",", "mu", ",", "log_std", ")", ":", "\n", "        ", "\"\"\"\n        Helper to compute log likelihood of a gaussian.\n        Here we assume this is a Diagonal Gaussian.\n        :param input_: (tf.Tensor)\n        :param mu_: (tf.Tensor)\n        :param log_std: (tf.Tensor)\n        :return: (tf.Tensor)\n        \"\"\"", "\n", "pre_sum", "=", "-", "0.5", "*", "(", "\n", "(", "(", "input", "-", "mu", ")", "/", "(", "tf", ".", "exp", "(", "log_std", ")", "+", "self", ".", "logprob_epsilon", ")", ")", "**", "2", "+", "2", "*", "log_std", "+", "np", ".", "log", "(", "2", "*", "np", ".", "pi", ")", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "pre_sum", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.call": [[178, 197], ["tensorflow.function", "HVCL_rl_utils.ActorNetwork.model_layers", "tensorflow.clip_by_value", "tensorflow.exp", "tensorflow.tanh", "HVCL_rl_utils.ActorNetwork.gaussian_likelihood", "tensorflow.reduce_sum", "tensorflow.nn.tanh", "tensorflow.random.normal", "tensorflow.math.log", "tensorflow.shape", "tensorflow.pow"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.gaussian_likelihood"], ["", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "call", "(", "self", ",", "inp", ")", ":", "\n", "        ", "x", "=", "self", ".", "model_layers", "(", "inp", ")", "\n", "mean", "=", "x", "[", ":", ",", ":", "self", ".", "n_actions", "]", "\n", "log_std", "=", "x", "[", ":", ",", "self", ".", "n_actions", ":", "]", "\n", "log_std", "=", "tf", ".", "clip_by_value", "(", "t", "=", "log_std", ",", "clip_value_min", "=", "-", "20", ",", "clip_value_max", "=", "2", ")", "\n", "std", "=", "tf", ".", "exp", "(", "log_std", ")", "\n", "action", "=", "mean", "+", "tf", ".", "random", ".", "normal", "(", "tf", ".", "shape", "(", "mean", ")", ")", "*", "std", "\n", "squashed_actions", "=", "tf", ".", "tanh", "(", "action", ")", "\n", "# numerically unstable:", "\n", "# logprob = action_dist.log_prob(action) - tf.reduce_sum(", "\n", "#     tf.math.log((1.0 - tf.pow(squashed_actions, 2)) + self.logprob_epsilon), axis=-1)", "\n", "# ref: https://github.com/vitchyr/rlkit/blob/0073d73235d7b4265cd9abe1683b30786d863ffe/rlkit/torch/distributions.py#L358", "\n", "# ref: https://github.com/tensorflow/probability/blob/master/tensorflow_probability/python/bijectors/tanh.py#L73", "\n", "# numerically stable version:", "\n", "# logprob = self.gaussian_likelihood(action, mean, log_std) - tf.reduce_sum((2 * (np.log(2) - squashed_actions - tf.math.softplus(-2 * squashed_actions))), axis=-1)", "\n", "logprob", "=", "self", ".", "gaussian_likelihood", "(", "mu", "=", "mean", ",", "input", "=", "action", ",", "log_std", "=", "log_std", ")", "-", "tf", ".", "reduce_sum", "(", "\n", "tf", ".", "math", ".", "log", "(", "(", "1.0", "-", "tf", ".", "pow", "(", "squashed_actions", ",", "2", ")", ")", "+", "self", ".", "logprob_epsilon", ")", ",", "axis", "=", "-", "1", ")", "\n", "return", "squashed_actions", ",", "logprob", ",", "tf", ".", "nn", ".", "tanh", "(", "mean", ")", ",", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.loss_call": [[198, 210], ["tensorflow.function", "HVCL_rl_utils.ActorNetwork.model_layers", "tensorflow.clip_by_value", "tensorflow.exp", "tensorflow.tanh", "HVCL_rl_utils.ActorNetwork.gaussian_likelihood", "tensorflow.reduce_sum", "tensorflow.nn.tanh", "tensorflow.reduce_sum", "tensorflow.random.normal", "tensorflow.math.log", "tensorflow.shape", "tensorflow.pow"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.gaussian_likelihood"], ["", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "loss_call", "(", "self", ",", "inp", ")", ":", "\n", "        ", "x", "=", "self", ".", "model_layers", "(", "inp", ")", "\n", "mean", "=", "x", "[", ":", ",", ":", "self", ".", "n_actions", "]", "\n", "log_std", "=", "x", "[", ":", ",", "self", ".", "n_actions", ":", "]", "\n", "log_std", "=", "tf", ".", "clip_by_value", "(", "t", "=", "log_std", ",", "clip_value_min", "=", "-", "20", ",", "clip_value_max", "=", "2", ")", "\n", "std", "=", "tf", ".", "exp", "(", "log_std", ")", "\n", "action", "=", "mean", "+", "tf", ".", "random", ".", "normal", "(", "tf", ".", "shape", "(", "mean", ")", ")", "*", "std", "\n", "squashed_actions", "=", "tf", ".", "tanh", "(", "action", ")", "\n", "logprob", "=", "self", ".", "gaussian_likelihood", "(", "mu", "=", "mean", ",", "input", "=", "action", ",", "log_std", "=", "log_std", ")", "-", "tf", ".", "reduce_sum", "(", "\n", "tf", ".", "math", ".", "log", "(", "(", "1.0", "-", "tf", ".", "pow", "(", "squashed_actions", ",", "2", ")", ")", "+", "self", ".", "logprob_epsilon", ")", ",", "axis", "=", "-", "1", ")", "\n", "return", "squashed_actions", ",", "logprob", ",", "tf", ".", "nn", ".", "tanh", "(", "mean", ")", ",", "std", ",", "tf", ".", "reduce_sum", "(", "self", ".", "model_layers", ".", "losses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.get_model_losses": [[211, 214], ["tensorflow.reduce_sum"], "methods", ["None"], ["", "@", "tf", ".", "function", "\n", "def", "get_model_losses", "(", "self", ")", ":", "\n", "        ", "return", "tf", ".", "reduce_sum", "(", "self", ".", "model_layers", ".", "losses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork._get_params": [[215, 223], ["HVCL_rl_utils.ActorNetwork.sess.run", "HVCL_rl_utils.ActorNetwork.graph.as_default", "tensorflow.trainable_variables", "zip"], "methods", ["None"], ["", "def", "_get_params", "(", "self", ")", ":", "\n", "        ", "''", "\n", "with", "self", ".", "graph", ".", "as_default", "(", ")", ":", "\n", "            ", "params", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "", "names", "=", "[", "p", ".", "name", "for", "p", "in", "params", "]", "\n", "values", "=", "self", ".", "sess", ".", "run", "(", "params", ")", "\n", "params", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "zip", "(", "names", ",", "values", ")", "}", "\n", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.__getstate__": [[224, 228], ["HVCL_rl_utils.ActorNetwork._get_params"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork._get_params"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "        ", "params", "=", "self", ".", "_get_params", "(", ")", "\n", "state", "=", "self", ".", "args_copy", ",", "params", "\n", "return", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.__setstate__": [[229, 233], ["HVCL_rl_utils.ActorNetwork.__init__", "HVCL_rl_utils.ActorNetwork.restore_params"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "args", ",", "params", "=", "state", "\n", "self", ".", "__init__", "(", "**", "args", ")", "\n", "self", ".", "restore_params", "(", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.SoftQNetwork.__init__": [[236, 323], ["tensorflow.keras.Model.__init__", "tensorflow.keras.layers.Input", "tensorflow.keras.Model", "HVCL_rl_utils.SoftQNetwork.model_layers.compile", "print", "HVCL_rl_utils.SoftQNetwork.model_layers.summary", "ds.kl_divergence", "tensorflow.cast", "tensorflow.maximum", "tensorflow.cast", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "p.entropy", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate", "DenseMoVE.DenseMoVE.DenseMoVE", "tensorflow.keras.layers.Concatenate"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.entropy"], ["    ", "def", "__init__", "(", "self", ",", "n_hidden_units", ",", "expert_beta", ",", "gating_beta", ",", "inputdim", ",", "qi", "=", "\"0\"", ",", "n_experts", "=", "1", ",", "\n", "vmoe", "=", "True", ",", "k", "=", "1", ")", ":", "\n", "        ", "super", "(", "SoftQNetwork", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "deep", "=", "True", "\n", "self", ".", "vmoe", "=", "vmoe", "\n", "self", ".", "k", "=", "k", "\n", "self", ".", "n_experts", "=", "n_experts", "\n", "self", ".", "expert_beta", "=", "expert_beta", "\n", "self", ".", "gating_beta", "=", "gating_beta", "\n", "self", ".", "diversity_bonus", "=", "1e-1", "\n", "self", ".", "kl_divergence_function", "=", "(", "lambda", "q", ",", "p", ":", "ds", ".", "kl_divergence", "(", "q", ",", "p", ")", "/", "tf", ".", "cast", "(", "1.0", ",", "dtype", "=", "tf", ".", "float32", ")", ")", "\n", "self", ".", "entropy_function", "=", "(", "lambda", "p", ":", "tf", ".", "maximum", "(", "p", ".", "entropy", "(", ")", ",", "0.0", ")", "/", "tf", ".", "cast", "(", "10000.0", ",", "dtype", "=", "tf", ".", "float32", ")", ")", "\n", "input_layer", "=", "Input", "(", "shape", "=", "inputdim", ")", "\n", "if", "self", ".", "vmoe", ":", "\n", "            ", "if", "self", ".", "deep", ":", "\n", "                ", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "name", "=", "\"softq_dense_in_%s\"", "%", "(", "qi", ")", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ")", "(", "input_layer", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "name", "=", "\"softq_dense_0_%s\"", "%", "(", "qi", ")", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ")", "(", "x", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "name", "=", "\"softq_dense_1_%s\"", "%", "(", "qi", ")", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ")", "(", "x", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "name", "=", "\"softq_dense_3_%s\"", "%", "(", "qi", ")", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ")", "(", "x", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "name", "=", "\"softq_dense_in_%s\"", "%", "(", "qi", ")", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ")", "(", "input_layer", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "x", "=", "DenseMoVE", "(", "units", "=", "n_hidden_units", ",", "expert_activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "name", "=", "\"softq_dense_0_%s\"", "%", "(", "qi", ")", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ")", "(", "x", ")", "\n", "x", "=", "Concatenate", "(", "axis", "=", "-", "1", ")", "(", "[", "x", ",", "input_layer", "]", ")", "\n", "", "out", "=", "DenseMoVE", "(", "units", "=", "1", ",", "expert_activation", "=", "None", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "name", "=", "\"softq_dense_out_%s\"", "%", "(", "qi", ")", ",", "\n", "expert_beta", "=", "self", ".", "expert_beta", ",", "gating_beta", "=", "self", ".", "gating_beta", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "diversity_bonus", "=", "self", ".", "diversity_bonus", ",", "\n", "kl_div_fun", "=", "self", ".", "kl_divergence_function", ",", "\n", "k", "=", "self", ".", "k", ",", "\n", "entropy_fun", "=", "self", ".", "entropy_function", ")", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "Dense", "(", "units", "=", "n_hidden_units", ",", "activation", "=", "tf", ".", "nn", ".", "relu", ")", "(", "input_layer", ")", "\n", "x", "=", "Dense", "(", "units", "=", "n_hidden_units", ",", "activation", "=", "tf", ".", "nn", ".", "relu", ")", "(", "x", ")", "\n", "out", "=", "Dense", "(", "units", "=", "1", ",", "activation", "=", "None", ")", "(", "x", ")", "\n", "", "self", ".", "model_layers", "=", "Model", "(", "input_layer", ",", "out", ")", "\n", "self", ".", "model_layers", ".", "compile", "(", ")", "\n", "print", "(", "self", ".", "model_layers", ".", "summary", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.SoftQNetwork.get_model_losses": [[324, 327], ["tensorflow.reduce_sum"], "methods", ["None"], ["", "@", "tf", ".", "function", "\n", "def", "get_model_losses", "(", "self", ")", ":", "\n", "        ", "return", "tf", ".", "reduce_sum", "(", "self", ".", "model_layers", ".", "losses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.SoftQNetwork.call": [[328, 332], ["tensorflow.function", "tensorflow.concat", "HVCL_rl_utils.SoftQNetwork.model_layers"], "methods", ["None"], ["", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "call", "(", "self", ",", "states", ",", "actions", ")", ":", "\n", "        ", "x", "=", "tf", ".", "concat", "(", "[", "states", ",", "actions", "]", ",", "-", "1", ")", "\n", "return", "self", ".", "model_layers", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.SoftQNetwork.loss_call": [[333, 337], ["tensorflow.function", "tensorflow.concat", "HVCL_rl_utils.SoftQNetwork.model_layers", "tensorflow.reduce_sum"], "methods", ["None"], ["", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "loss_call", "(", "self", ",", "states", ",", "actions", ")", ":", "\n", "        ", "x", "=", "tf", ".", "concat", "(", "[", "states", ",", "actions", "]", ",", "-", "1", ")", "\n", "return", "self", ".", "model_layers", "(", "x", ")", ",", "tf", ".", "reduce_sum", "(", "self", ".", "model_layers", ".", "losses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.OUNoise.__init__": [[378, 389], ["HVCL_rl_utils.OUNoise.reset"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset"], ["    ", "def", "__init__", "(", "self", ",", "action_space", ",", "mu", "=", "0.0", ",", "theta", "=", "0.15", ",", "max_sigma", "=", "0.2", ",", "min_sigma", "=", "-", "0.2", ",", "decay_period", "=", "100", ")", ":", "\n", "        ", "self", ".", "mu", "=", "mu", "\n", "self", ".", "theta", "=", "theta", "\n", "self", ".", "sigma", "=", "max_sigma", "\n", "self", ".", "max_sigma", "=", "max_sigma", "\n", "self", ".", "min_sigma", "=", "min_sigma", "\n", "self", ".", "decay_period", "=", "decay_period", "\n", "self", ".", "action_dim", "=", "action_space", "\n", "self", ".", "low", "=", "-", "1.0", "\n", "self", ".", "high", "=", "1.0", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.OUNoise.reset": [[390, 392], ["numpy.ones"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "state", "=", "np", ".", "ones", "(", "self", ".", "action_dim", ")", "*", "self", ".", "mu", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.OUNoise.evolve_state": [[393, 398], ["numpy.random.randn"], "methods", ["None"], ["", "def", "evolve_state", "(", "self", ")", ":", "\n", "        ", "x", "=", "self", ".", "state", "\n", "dx", "=", "self", ".", "theta", "*", "(", "self", ".", "mu", "-", "x", ")", "+", "self", ".", "sigma", "*", "np", ".", "random", ".", "randn", "(", "self", ".", "action_dim", ")", "\n", "self", ".", "state", "=", "x", "+", "dx", "\n", "return", "self", ".", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.OUNoise.get_action": [[399, 403], ["HVCL_rl_utils.OUNoise.evolve_state", "numpy.clip", "min"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.OUNoise.evolve_state"], ["", "def", "get_action", "(", "self", ",", "action", ",", "t", "=", "0", ")", ":", "\n", "        ", "ou_state", "=", "self", ".", "evolve_state", "(", ")", "\n", "self", ".", "sigma", "=", "self", ".", "max_sigma", "-", "(", "self", ".", "max_sigma", "-", "self", ".", "min_sigma", ")", "*", "min", "(", "1.0", ",", "t", "/", "self", ".", "decay_period", ")", "\n", "return", "np", ".", "clip", "(", "action", "*", "0.2", "+", "ou_state", ",", "self", ".", "low", ",", "self", ".", "high", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.plot_episode_stats": [[339, 367], ["matplotlib.pyplot.figure", "matplotlib.pyplot.plot", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.figure", "matplotlib.pyplot.plot", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.figure", "matplotlib.pyplot.plot", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.figure", "pandas.Series().rolling().mean", "matplotlib.pyplot.plot", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.show", "pandas.Series().rolling", "pandas.Series"], "function", ["None"], ["", "", "def", "plot_episode_stats", "(", "actor_losses", ",", "softq_losses", ",", "action_logprob_means", ",", "episode_rewards", ",", "smoothing_window", "=", "15", ")", ":", "\n", "# Plot the episode length over time", "\n", "    ", "plt", ".", "figure", "(", "figsize", "=", "(", "10", ",", "5", ")", ")", "\n", "plt", ".", "plot", "(", "actor_losses", ",", "label", "=", "\"Actor\"", ")", "\n", "plt", ".", "xlabel", "(", "\"Episode\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Actor Loss\"", ")", "\n", "plt", ".", "title", "(", "\"Actor Loss over Time\"", ")", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "10", ",", "5", ")", ")", "\n", "plt", ".", "plot", "(", "softq_losses", ",", "label", "=", "\"Soft-Q\"", ")", "\n", "plt", ".", "xlabel", "(", "\"Episode\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Soft-Q Loss\"", ")", "\n", "plt", ".", "title", "(", "\"Soft-Q Loss over Time\"", ")", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "10", ",", "5", ")", ")", "\n", "plt", ".", "plot", "(", "action_logprob_means", ",", "label", "=", "\"log(p(a))\"", ")", "\n", "plt", ".", "xlabel", "(", "\"Episode\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Log Prob\"", ")", "\n", "plt", ".", "title", "(", "\"Log Prob over Time\"", ")", "\n", "\n", "# Plot the episode reward over time", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "10", ",", "5", ")", ")", "\n", "rewards_smoothed", "=", "pd", ".", "Series", "(", "episode_rewards", ")", ".", "rolling", "(", "smoothing_window", ",", "min_periods", "=", "smoothing_window", ")", ".", "mean", "(", ")", "\n", "plt", ".", "plot", "(", "rewards_smoothed", ")", "\n", "plt", ".", "xlabel", "(", "\"Episode\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Episode Reward (Smoothed)\"", ")", "\n", "plt", ".", "title", "(", "\"Episode Reward over Time (Smoothed over window size {})\"", ".", "format", "(", "smoothing_window", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.plot_reward": [[369, 375], ["matplotlib.pyplot.plot", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.show", "range", "len"], "function", ["None"], ["", "def", "plot_reward", "(", "episode_rewards", ")", ":", "\n", "    ", "plt", ".", "plot", "(", "range", "(", "len", "(", "episode_rewards", ")", ")", ",", "episode_rewards", ")", "\n", "plt", ".", "xlabel", "(", "\"Episode\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Episode Reward\"", ")", "\n", "plt", ".", "title", "(", "\"Episode Reward over Time\"", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_agent.Agent.__init__": [[10, 27], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "replay_buffer", ",", "replay_start_size", ",", "\n", "batch_size", ",", "train_n_steps", ",", "largest_act_dim", ",", "largest_obs_dim", ",", "vmoe", ",", "task", ",", "train_interval", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "replay_buffer", "=", "replay_buffer", "\n", "self", ".", "replay_start_size", "=", "replay_start_size", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "largest_act_dim", "=", "largest_act_dim", "\n", "self", ".", "largest_obs_dim", "=", "largest_obs_dim", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "train_n_steps", "=", "train_n_steps", "\n", "self", ".", "n_timesteps", "=", "100", "\n", "self", ".", "train_interval", "=", "train_interval", "\n", "self", ".", "eval_interval", "=", "10000", "\n", "self", ".", "total_steps", "=", "0", "\n", "self", ".", "total_episodes", "=", "0", "\n", "self", ".", "vmoe", "=", "vmoe", "\n", "self", ".", "task", "=", "task", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_agent.Agent.reset_state": [[28, 33], ["None"], "methods", ["None"], ["", "def", "reset_state", "(", "self", ",", "train_env", ",", "n_actions", ",", "eval_envs", ",", "continual_replay_buffer", ")", ":", "\n", "        ", "self", ".", "train_env", "=", "train_env", "\n", "self", ".", "n_actions", "=", "n_actions", "\n", "self", ".", "eval_envs", "=", "eval_envs", "\n", "self", ".", "continual_replay_buffer", "=", "continual_replay_buffer", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_agent.Agent.train": [[34, 228], ["int", "print", "deque", "parallel_gym.make_mp_envs", "parallel_gym.make_mp_envs.close", "timeit.default_timer", "parallel_gym.make_mp_envs.reset().astype", "range", "timeit.default_timer", "deque.append", "print", "HVCL_rl_agent.Agent.replay_buffer.get_batch", "zip", "range", "HVCL_rl_agent.Agent.model.actions", "np.reshape", "parallel_gym.make_mp_envs.step", "zip", "K.set_learning_phase", "range", "HVCL_rl_agent.Agent.replay_buffer.update_priority", "actor_losses.append", "softq_losses.append", "action_logprob_means.append", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "len", "K.set_learning_phase", "enumerate", "HVCL_rl_agent.Agent.continual_replay_buffer.add", "len", "parallel_gym.make_mp_envs.reset", "HVCL_rl_agent.Agent.replay_buffer.add", "np.shape", "np.shape", "np.shape", "np.shape", "HVCL_rl_agent.Agent.replay_buffer.get_batch", "HVCL_rl_agent.Agent.model.train", "w_idxs.extend", "new_prios.extend", "np.array", "np.array", "np.array", "np.array", "np.array", "np.array", "np.array", "np.array", "np.array", "len", "HVCL_rl_agent.Agent.continual_replay_buffer.update_priority", "np.mean", "time.strftime", "print", "np.std", "print", "time.strftime", "print", "np.ones", "env.reset().astype", "np.any", "np.array", "np.sum", "np.mean", "env_evals_r[].append", "last_eval_rewars.append", "print", "HVCL_rl_agent.Agent.continual_replay_buffer.get_batch", "td_error.numpy", "old_w_idxs.extend", "old_prios.extend", "time.gmtime", "time.gmtime", "HVCL_rl_agent.Agent.model.actions", "np.reshape", "env.step", "enumerate", "enumerate", "old_td_error.numpy", "env.reset", "range", "np.shape", "np.shape", "eval_rewards[].append", "eval_rewards[].append", "np.shape", "np.shape"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.make_mp_envs", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.close", "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.get_batch", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.actions", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.update_priority", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.get_batch", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.extend", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.extend", "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.update_priority", "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.get_batch", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.extend", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.extend", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.actions", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "pre_training_phase", "=", "1", "\n", "train_step", "=", "0", "\n", "\n", "# Noise + epsilon parameters", "\n", "epsilon", "=", "1", "\n", "train_interval", "=", "self", ".", "train_interval", "\n", "eval_interval", "=", "self", ".", "eval_interval", "\n", "num_env", "=", "int", "(", "train_interval", "/", "self", ".", "n_timesteps", ")", "\n", "print", "(", "\"Collecting with %d envs\"", "%", "num_env", ")", "\n", "sample_eval_ctr", "=", "0", "\n", "actor_losses", "=", "[", "]", "\n", "softq_losses", "=", "[", "]", "\n", "action_logprob_means", "=", "[", "]", "\n", "env_evals_r", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "self", ".", "eval_envs", ")", ")", "]", "\n", "durations", "=", "deque", "(", "maxlen", "=", "20", ")", "\n", "parallel_envs", "=", "make_mp_envs", "(", "env_id", "=", "self", ".", "train_env", ".", "envs", "[", "0", "]", ".", "spec", ".", "id", ",", "num_env", "=", "num_env", ",", "norm_reward", "=", "True", ",", "\n", "largest_obs_dim", "=", "self", ".", "largest_obs_dim", ")", "\n", "train_sample_ctr", "=", "0", "\n", "duration_sample_ctr", "=", "0", "\n", "duration", "=", ".0", "\n", "while", "train_step", "<", "self", ".", "train_n_steps", ":", "\n", "            ", "start", "=", "timer", "(", ")", "\n", "\n", "state", "=", "parallel_envs", ".", "reset", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "for", "k", "in", "range", "(", "self", ".", "n_timesteps", ")", ":", "\n", "                ", "action", "=", "self", ".", "model", ".", "actions", "(", "state", ")", "\n", "# get action into right format", "\n", "ext_action", "=", "action", "[", ":", ",", ":", "self", ".", "n_actions", "]", "\n", "ext_action", "=", "np", ".", "reshape", "(", "ext_action", ",", "newshape", "=", "(", "np", ".", "shape", "(", "ext_action", ")", "[", "0", "]", ",", "1", ",", "np", ".", "shape", "(", "ext_action", ")", "[", "-", "1", "]", ")", ")", "\n", "\n", "new_state", ",", "reward", ",", "done", ",", "_", "=", "parallel_envs", ".", "step", "(", "ext_action", ")", "\n", "for", "s", ",", "a", ",", "r", ",", "ss", ",", "d", "in", "zip", "(", "state", ",", "action", ",", "reward", ",", "new_state", ",", "done", ")", ":", "\n", "                    ", "self", ".", "replay_buffer", ".", "add", "(", "state", "=", "s", ",", "action", "=", "a", ",", "reward", "=", "r", ",", "new_state", "=", "ss", ",", "done", "=", "d", ")", "\n", "\n", "", "state", "=", "new_state", "\n", "train_step", "+=", "np", ".", "shape", "(", "state", ")", "[", "0", "]", "\n", "train_sample_ctr", "+=", "np", ".", "shape", "(", "state", ")", "[", "0", "]", "\n", "sample_eval_ctr", "+=", "np", ".", "shape", "(", "state", ")", "[", "0", "]", "\n", "duration_sample_ctr", "+=", "np", ".", "shape", "(", "state", ")", "[", "0", "]", "\n", "# if not pre_training_phase and epsilon > epsilon_min:", "\n", "#     epsilon = epsilon * epsilon_dk", "\n", "if", "self", ".", "replay_buffer", ".", "n_entries", ">", "self", ".", "replay_start_size", ":", "\n", "                    ", "if", "pre_training_phase", ":", "\n", "                        ", "print", "(", "\"Started Training with %d Samples in Buffer\"", "%", "self", ".", "replay_buffer", ".", "n_entries", ")", "\n", "", "pre_training_phase", "=", "0", "\n", "", "if", "train_sample_ctr", ">=", "train_interval", ":", "\n", "                    ", "self", ".", "total_episodes", "+=", "1", "\n", "break", "\n", "", "", "if", "not", "pre_training_phase", "and", "train_sample_ctr", ">=", "train_interval", ":", "\n", "                ", "K", ".", "set_learning_phase", "(", "True", ")", "\n", "mean_a_loss", "=", "0.0", "\n", "mean_sq_loss", "=", "0.0", "\n", "mean_alp_loss", "=", "0.0", "\n", "mean_soft_targets_mean", "=", "0.0", "\n", "mean_q_values_mean", "=", "0.0", "\n", "mean_Qs_log_targets", "=", "0.0", "\n", "mean_alpha", "=", "0.0", "\n", "train_sample_ctr", "=", "0", "\n", "mean_a_model_loss", "=", "0.0", "\n", "mean_sq_model_loss", "=", "0.0", "\n", "num_updates", "=", "50", "# train_interval #np.minimum(100, episode_length)", "\n", "w_idxs", "=", "[", "]", "\n", "new_prios", "=", "[", "]", "\n", "old_w_idxs", "=", "[", "]", "\n", "old_prios", "=", "[", "]", "\n", "for", "nu", "in", "range", "(", "num_updates", ")", ":", "\n", "                    ", "sample", ",", "w", ",", "w_idx", "=", "self", ".", "replay_buffer", ".", "get_batch", "(", "global_step", "=", "train_step", ",", "\n", "num_samples", "=", "self", ".", "batch_size", ")", "\n", "if", "self", ".", "continual_replay_buffer", "is", "not", "None", "and", "self", ".", "vmoe", "and", "self", ".", "task", ">", "0", ":", "\n", "                        ", "old_sample", ",", "old_w", ",", "old_w_idx", "=", "self", ".", "continual_replay_buffer", ".", "get_batch", "(", "\n", "global_step", "=", "train_step", "+", "self", ".", "train_n_steps", "*", "(", "self", ".", "task", "+", "1", ")", ",", "\n", "num_samples", "=", "self", ".", "batch_size", ")", "\n", "", "else", ":", "\n", "                        ", "old_sample", ",", "old_w", ",", "old_w_idx", "=", "None", ",", "None", ",", "None", "\n", "", "softq_loss", ",", "actor_loss", ",", "action_logprob_mean", ",", "soft_targets_mean", ",", "q_values_mean", ",", "Qs_log_targets", ",", "actor_model_losses", ",", "qmodel_losses", ",", "alpha", ",", "means", ",", "stds", ",", "td_error", ",", "old_td_error", "=", "self", ".", "model", ".", "train", "(", "\n", "sample", ",", "\n", "self", ".", "batch_size", ",", "\n", "experience_weights", "=", "w", ",", "\n", "old_sample", "=", "old_sample", ",", "\n", "old_experience_weights", "=", "old_w", ",", "\n", "task", "=", "self", ".", "task", ")", "\n", "w_idxs", ".", "extend", "(", "w_idx", ")", "\n", "td_error", "=", "td_error", ".", "numpy", "(", ")", "[", ":", ",", "0", "]", "\n", "new_prios", ".", "extend", "(", "td_error", ")", "\n", "if", "old_td_error", "is", "not", "None", ":", "\n", "                        ", "old_w_idxs", ".", "extend", "(", "old_w_idx", ")", "\n", "old_td_error", "=", "old_td_error", ".", "numpy", "(", ")", "[", ":", ",", "0", "]", "\n", "old_prios", ".", "extend", "(", "old_td_error", ")", "\n", "\n", "", "mean_a_loss", "+=", "np", ".", "array", "(", "actor_loss", ")", "\n", "mean_a_model_loss", "+=", "np", ".", "array", "(", "actor_model_losses", ")", "\n", "mean_sq_model_loss", "+=", "np", ".", "array", "(", "qmodel_losses", ")", "\n", "mean_sq_loss", "+=", "np", ".", "array", "(", "softq_loss", ")", "\n", "mean_alp_loss", "+=", "np", ".", "array", "(", "action_logprob_mean", ")", "\n", "mean_soft_targets_mean", "+=", "np", ".", "array", "(", "soft_targets_mean", ")", "\n", "mean_q_values_mean", "+=", "np", ".", "array", "(", "q_values_mean", ")", "\n", "mean_Qs_log_targets", "+=", "np", ".", "array", "(", "Qs_log_targets", ")", "\n", "mean_alpha", "+=", "np", ".", "array", "(", "alpha", ")", "\n", "", "self", ".", "model", ".", "updates_performed", "+=", "1", "\n", "self", ".", "replay_buffer", ".", "update_priority", "(", "indices", "=", "w_idxs", ",", "priorities", "=", "new_prios", ")", "\n", "if", "self", ".", "continual_replay_buffer", "is", "not", "None", "and", "len", "(", "old_prios", ")", ":", "\n", "                    ", "self", ".", "continual_replay_buffer", ".", "update_priority", "(", "indices", "=", "old_w_idxs", ",", "priorities", "=", "old_prios", ")", "\n", "", "mean_a_loss", "/=", "train_interval", "\n", "mean_sq_loss", "/=", "train_interval", "\n", "mean_alp_loss", "/=", "train_interval", "\n", "mean_soft_targets_mean", "/=", "train_interval", "\n", "mean_q_values_mean", "/=", "train_interval", "\n", "mean_Qs_log_targets", "/=", "train_interval", "\n", "mean_alpha", "/=", "train_interval", "\n", "actor_losses", ".", "append", "(", "mean_a_loss", ")", "\n", "softq_losses", ".", "append", "(", "mean_sq_loss", ")", "\n", "action_logprob_means", ".", "append", "(", "mean_alp_loss", ")", "\n", "\n", "print", "(", "\"Environment is\"", ",", "self", ".", "train_env", ".", "envs", "[", "0", "]", ".", "spec", ".", "id", ")", "\n", "print", "(", "\"Model Updates:\"", ",", "self", ".", "model", ".", "updates_performed", ")", "\n", "print", "(", "\"Actor loss is\"", ",", "mean_a_loss", ")", "\n", "print", "(", "\"Actor model loss is\"", ",", "mean_a_model_loss", ")", "\n", "print", "(", "\"Action log-p mean is\"", ",", "mean_alp_loss", ")", "\n", "print", "(", "\"Q loss is\"", ",", "mean_sq_loss", ")", "\n", "print", "(", "\"Q model loss is\"", ",", "mean_sq_model_loss", ")", "\n", "print", "(", "\"Soft Q Targets mean\"", ",", "mean_soft_targets_mean", ")", "\n", "print", "(", "\"Q Values mean\"", ",", "mean_q_values_mean", ")", "\n", "print", "(", "\"Q Log Targets mean\"", ",", "mean_Qs_log_targets", ")", "\n", "print", "(", "\"Alpha\"", ",", "mean_alpha", ")", "\n", "print", "(", "\"Epsilon\"", ",", "epsilon", ")", "\n", "print", "(", "\"Beta:\"", ",", "self", ".", "model", ".", "actor_exp_beta", ",", "self", ".", "model", ".", "actor_gate_beta", ",", "self", ".", "model", ".", "qnet_exp_beta", ",", "\n", "self", ".", "model", ".", "qnet_gate_beta", ",", "self", ".", "model", ".", "beta_schedule", "[", "self", ".", "model", ".", "updates_performed", "]", ")", "\n", "if", "len", "(", "durations", ")", ":", "\n", "                    ", "mean_duration", "=", "np", ".", "mean", "(", "durations", ")", "\n", "time_str", "=", "time", ".", "strftime", "(", "'%H:%M:%S'", ",", "\n", "time", ".", "gmtime", "(", "mean_duration", "*", "(", "self", ".", "train_n_steps", "-", "(", "train_step", "+", "1.0", ")", ")", ")", ")", "\n", "print", "(", "\"duration\"", ",", "duration", ")", "\n", "std_duration", "=", "np", ".", "std", "(", "durations", ")", "\n", "print", "(", "\"T per Step: %.4f +/- %.4f\"", "%", "(", "mean_duration", ",", "std_duration", ")", ")", "\n", "time_str_std", "=", "time", ".", "strftime", "(", "'%H:%M:%S'", ",", "\n", "time", ".", "gmtime", "(", "std_duration", "*", "(", "self", ".", "train_n_steps", "-", "(", "train_step", "+", "1.0", ")", ")", ")", ")", "\n", "print", "(", "\"ETA: %s, +/- %s\"", "%", "(", "time_str", ",", "time_str_std", ")", ")", "\n", "", "", "eval_t", "=", "0", "\n", "last_eval_rewars", "=", "[", "]", "\n", "if", "sample_eval_ctr", ">=", "eval_interval", ":", "\n", "                ", "K", ".", "set_learning_phase", "(", "False", ")", "\n", "sample_eval_ctr", "=", "0", "\n", "# eval", "\n", "env_actions", "=", "[", "(", "0", ",", "6", ")", ",", "(", "1", ",", "6", ")", ",", "(", "2", ",", "8", ")", ",", "(", "3", ",", "1", ")", ",", "(", "4", ",", "3", ")", "]", "\n", "last_eval_rewars", "=", "[", "]", "\n", "for", "env_idx", ",", "env", "in", "enumerate", "(", "self", ".", "eval_envs", ")", ":", "\n", "                    ", "eval_n_actions", "=", "env_actions", "[", "env_idx", "]", "[", "1", "]", "\n", "# for ei in range(eval_runs):", "\n", "env_running_mask", "=", "np", ".", "ones", "(", "shape", "=", "env", ".", "no_of_envs", ")", "\n", "state", "=", "env", ".", "reset", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "eval_t", "=", "0", "\n", "eval_rewards", "=", "[", "[", "]", "for", "_", "in", "range", "(", "env", ".", "no_of_envs", ")", "]", "\n", "while", "np", ".", "any", "(", "env_running_mask", ")", ":", "\n", "                        ", "action", "=", "self", ".", "model", ".", "actions", "(", "state", ")", "\n", "ext_action", "=", "action", "[", ":", ",", ":", "eval_n_actions", "]", "\n", "ext_action", "=", "np", ".", "reshape", "(", "ext_action", ",", "\n", "newshape", "=", "(", "np", ".", "shape", "(", "ext_action", ")", "[", "0", "]", ",", "1", ",", "np", ".", "shape", "(", "ext_action", ")", "[", "-", "1", "]", ")", ")", "\n", "new_state", ",", "reward", ",", "eval_done", ",", "_", "=", "env", ".", "step", "(", "ext_action", ")", "\n", "state", "=", "new_state", "\n", "eval_t", "+=", "1", "\n", "for", "di", ",", "d", "in", "enumerate", "(", "env_running_mask", ")", ":", "\n", "                            ", "if", "d", ":", "\n", "                                ", "eval_rewards", "[", "di", "]", ".", "append", "(", "reward", "[", "di", "]", ")", "\n", "", "else", ":", "\n", "                                ", "eval_rewards", "[", "di", "]", ".", "append", "(", "0", ")", "\n", "", "", "for", "di", ",", "d", "in", "enumerate", "(", "eval_done", ")", ":", "\n", "                            ", "if", "d", ":", "\n", "                                ", "env_running_mask", "[", "di", "]", "=", "0", "\n", "", "", "", "eval_rewards", "=", "np", ".", "array", "(", "eval_rewards", ")", "\n", "eval_rewards", "=", "np", ".", "sum", "(", "eval_rewards", ",", "axis", "=", "-", "1", ")", "\n", "mean_eval_episode_reward", "=", "np", ".", "mean", "(", "eval_rewards", ",", "axis", "=", "-", "1", ")", "\n", "env_evals_r", "[", "env_idx", "]", ".", "append", "(", "mean_eval_episode_reward", ")", "\n", "last_eval_rewars", ".", "append", "(", "mean_eval_episode_reward", ")", "\n", "", "", "end", "=", "timer", "(", ")", "\n", "duration", "=", "end", "-", "start", "\n", "durations", ".", "append", "(", "duration", "/", "duration_sample_ctr", ")", "\n", "duration_sample_ctr", "=", "0", "\n", "print", "(", "\"env:\"", ",", "self", ".", "train_env", ".", "envs", "[", "0", "]", ".", "spec", ".", "id", "\n", ",", "\"Episode n.\"", ",", "self", ".", "total_episodes", ",", "\"ended! Steps:\"", ",", "train_step", ",", "\"The eval rewards are\"", ",", "\n", "last_eval_rewars", ",", "\n", "\", number of steps:\"", ",", "eval_t", ",", "end", "=", "\"\\r\"", ")", "\n", "", "if", "self", ".", "vmoe", "and", "self", ".", "continual_replay_buffer", "is", "not", "None", ":", "\n", "            ", "samples", ",", "_", ",", "_", "=", "self", ".", "replay_buffer", ".", "get_batch", "(", "global_step", "=", "train_step", ",", "num_samples", "=", "50000", ")", "\n", "states", "=", "samples", "[", "'states0'", "]", "\n", "actions", "=", "samples", "[", "'actions'", "]", "\n", "new_states", "=", "samples", "[", "'states1'", "]", "\n", "dones", "=", "samples", "[", "'terminals1'", "]", "\n", "rewards", "=", "samples", "[", "'rewards'", "]", "\n", "for", "s", ",", "a", ",", "r", ",", "ss", ",", "d", "in", "zip", "(", "states", ",", "actions", ",", "rewards", ",", "new_states", ",", "dones", ")", ":", "\n", "                ", "self", ".", "continual_replay_buffer", ".", "add", "(", "s", ",", "a", ",", "r", ",", "ss", ",", "d", ")", "\n", "", "", "parallel_envs", ".", "close", "(", ")", "\n", "return", "env_evals_r", ",", "self", ".", "continual_replay_buffer", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_agent.Agent.test": [[229, 237], ["HVCL_rl_agent.Agent.model.load", "HVCL_rl_agent.Agent.test_env.reset", "HVCL_rl_agent.Agent.model.action", "HVCL_rl_agent.Agent.test_env.step", "HVCL_rl_agent.Agent.test_env.render", "obs.astype"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.action", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step"], ["", "def", "test", "(", "self", ",", "model_path", ")", ":", "\n", "        ", "self", ".", "model", ".", "load", "(", "model_path", ")", "\n", "while", "True", ":", "\n", "            ", "obs", ",", "done", "=", "self", ".", "test_env", ".", "reset", "(", ")", ",", "False", "\n", "while", "not", "done", ":", "\n", "                ", "action", "=", "self", ".", "model", ".", "action", "(", "obs", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "obs", ",", "reward", ",", "done", ",", "info", "=", "self", ".", "test_env", ".", "step", "(", "action", ")", "\n", "self", ".", "test_env", ".", "render", "(", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.__init__": [[83, 100], ["tensorflow.cast", "tensorflow.unstack", "tensorflow.reduce_sum", "tensorflow.gather", "tensorflow.where", "tensorflow.cast", "tensorflow.reshape", "tensorflow.transpose"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_experts", ",", "gates", ")", ":", "\n", "        ", "\"\"\"Create a SparseDispatcher.\n    Args:\n      num_experts: an integer.\n      gates: a `Tensor` of shape `[batch_size, num_experts]`.\n    Returns:\n      a SparseDispatcher\n    \"\"\"", "\n", "self", ".", "_gates", "=", "gates", "\n", "self", ".", "_num_experts", "=", "num_experts", "\n", "\n", "where", "=", "tf", ".", "cast", "(", "tf", ".", "where", "(", "tf", ".", "transpose", "(", "gates", ")", ">", "0", ")", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "self", ".", "_expert_index", ",", "self", ".", "_batch_index", "=", "tf", ".", "unstack", "(", "where", ",", "num", "=", "2", ",", "axis", "=", "1", ")", "\n", "self", ".", "_part_sizes_tensor", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "cast", "(", "gates", ">", "0", ",", "dtype", "=", "tf", ".", "int32", ")", ",", "[", "0", "]", ")", "\n", "self", ".", "_nonzero_gates", "=", "tf", ".", "gather", "(", "\n", "tf", ".", "reshape", "(", "self", ".", "_gates", ",", "[", "-", "1", "]", ")", ",", "\n", "self", ".", "_batch_index", "*", "num_experts", "+", "self", ".", "_expert_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.dispatch": [[101, 114], ["SparseDispatcher.add_name_scope", "tensorflow.gather", "tensorflow.split"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.add_name_scope"], ["", "@", "add_name_scope", "(", ")", "\n", "def", "dispatch", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\"Create one input Tensor for each expert.\n    The `Tensor` for a expert `i` contains the slices of `inp` corresponding\n    to the batch elements `b` where `gates[b, i] > 0`.\n    Args:\n      inp: a `Tensor` of shape \"[batch_size, <extra_input_dims>]`\n    Returns:\n      a list of `num_experts` `Tensor`s with shapes\n        `[expert_batch_size_i, <extra_input_dims>]`.\n    \"\"\"", "\n", "inp", "=", "tf", ".", "gather", "(", "inp", ",", "self", ".", "_batch_index", ")", "\n", "return", "tf", ".", "split", "(", "inp", ",", "self", ".", "_part_sizes_tensor", ",", "0", ",", "num", "=", "self", ".", "_num_experts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.combine": [[115, 136], ["SparseDispatcher.add_name_scope", "tensorflow.concat", "tensorflow.math.unsorted_segment_sum", "tensorflow.expand_dims", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.add_name_scope"], ["", "@", "add_name_scope", "(", ")", "\n", "def", "combine", "(", "self", ",", "expert_out", ",", "multiply_by_gates", "=", "True", ")", ":", "\n", "        ", "\"\"\"Sum together the expert output, weighted by the gates.\n    The slice corresponding to a particular batch element `b` is computed\n    as the sum over all experts `i` of the expert output, weighted by the\n    corresponding gate values.  If `multiply_by_gates` is set to False, the\n    gate values are ignored.\n    Args:\n      expert_out: a list of `num_experts` `Tensor`s, each with shape\n        `[expert_batch_size_i, <extra_output_dims>]`.\n      multiply_by_gates: a boolean\n    Returns:\n      a `Tensor` with shape `[batch_size, <extra_output_dims>]`.\n    \"\"\"", "\n", "# see comments on convert_gradient_to_tensor", "\n", "stitched", "=", "tf", ".", "concat", "(", "expert_out", ",", "0", ")", "\n", "if", "multiply_by_gates", ":", "\n", "            ", "stitched", "*=", "tf", ".", "expand_dims", "(", "self", ".", "_nonzero_gates", ",", "1", ")", "\n", "", "combined", "=", "tf", ".", "math", ".", "unsorted_segment_sum", "(", "stitched", ",", "self", ".", "_batch_index", ",", "\n", "tf", ".", "shape", "(", "self", ".", "_gates", ")", "[", "0", "]", ")", "\n", "return", "combined", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.expert_to_gates": [[137, 145], ["tensorflow.split"], "methods", ["None"], ["", "def", "expert_to_gates", "(", "self", ")", ":", "\n", "        ", "\"\"\"Gate values corresponding to the examples in the per-expert `Tensor`s.\n    Returns:\n      a list of `num_experts` one-dimensional `Tensor`s with type `tf.float32`\n          and shapes `[expert_batch_size_i]`\n    \"\"\"", "\n", "return", "tf", ".", "split", "(", "\n", "self", ".", "_nonzero_gates", ",", "self", ".", "_part_sizes_tensor", ",", "0", ",", "num", "=", "self", ".", "_num_experts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.expert_to_batch_indices": [[146, 154], ["tensorflow.split"], "methods", ["None"], ["", "def", "expert_to_batch_indices", "(", "self", ")", ":", "\n", "        ", "\"\"\"Batch indices corresponding to the examples in the per-expert `Tensor`s.\n    Returns:\n      a list of `num_experts` one-dimensional `Tensor`s with type `tf.int64`\n          and shapes `[expert_batch_size_i]`\n    \"\"\"", "\n", "return", "tf", ".", "split", "(", "\n", "self", ".", "_batch_index", ",", "self", ".", "_part_sizes_tensor", ",", "0", ",", "num", "=", "self", ".", "_num_experts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.part_sizes": [[155, 158], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "part_sizes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_part_sizes_tensor", "\n", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.add_scope": [[5, 27], ["functools.wraps", "kwargs.pop", "scope_fn", "f"], "function", ["None"], ["def", "add_scope", "(", "scope", "=", "None", ",", "scope_fn", "=", "None", ")", ":", "\n", "  ", "\"\"\"Return a decorator which add a TF name/variable scope to a function.\n  Note that the function returned by the decorator accept an additional 'name'\n  parameter, which can overwrite the name scope given when the function is\n  created.\n  Args:\n    scope (str): name of the scope. If None, the function name is used.\n    scope_fn (fct): Either tf.name_scope or tf.variable_scope\n  Returns:\n    fct: the add_scope decorator\n  \"\"\"", "\n", "def", "decorator", "(", "f", ")", ":", "\n", "\n", "    ", "@", "functools", ".", "wraps", "(", "f", ")", "\n", "def", "decorated", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "      ", "name", "=", "kwargs", ".", "pop", "(", "\"name\"", ",", "None", ")", "# Python 2 hack for keyword only args", "\n", "with", "scope_fn", "(", "name", "or", "scope", "or", "f", ".", "__name__", ")", ":", "\n", "        ", "return", "f", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "decorated", "\n", "\n", "", "return", "decorator", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.add_name_scope": [[29, 31], ["SparseDispatcher.add_scope"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.add_scope"], ["", "def", "add_name_scope", "(", "scope", "=", "None", ")", ":", "\n", "  ", "return", "add_scope", "(", "scope", ",", "scope_fn", "=", "tf", ".", "name_scope", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.convert_gradient_to_tensor": [[32, 50], ["tensorflow.python.framework.function.Defun", "tensorflow.convert_to_tensor", "op.inputs[].get_shape"], "function", ["None"], ["", "@", "function", ".", "Defun", "(", "\n", "python_grad_func", "=", "lambda", "x", ",", "dy", ":", "tf", ".", "convert_to_tensor", "(", "dy", ")", ",", "\n", "shape_func", "=", "lambda", "op", ":", "[", "op", ".", "inputs", "[", "0", "]", ".", "get_shape", "(", ")", "]", ")", "\n", "def", "convert_gradient_to_tensor", "(", "x", ")", ":", "\n", "  ", "\"\"\"Identity operation whose gradient is converted to a `Tensor`.\n  Currently, the gradient to `tf.concat` is particularly expensive to\n  compute if dy is an `IndexedSlices` (a lack of GPU implementation\n  forces the gradient operation onto CPU).  This situation occurs when\n  the output of the `tf.concat` is eventually passed to `tf.gather`.\n  It is sometimes faster to convert the gradient to a `Tensor`, so as\n  to get the cheaper gradient for `tf.concat`.  To do this, replace\n  `tf.concat(x)` with `convert_gradient_to_tensor(tf.concat(x))`.\n  Args:\n    x: A `Tensor`.\n  Returns:\n    The input `Tensor`.\n  \"\"\"", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.SubprocVecEnv.__init__": [[20, 40], ["len", "zip", "zip", "multiprocessing.Process", "parallel_gym.SubprocVecEnv.ps.append", "p.start", "remote.close", "multiprocessing.Pipe", "range", "parallel_gym.CloudpickleWrapper"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.close"], ["    ", "def", "__init__", "(", "self", ",", "env_fns", ",", "largest_obs_dim", ")", ":", "\n", "        ", "self", ".", "largest_obs_dim", "=", "largest_obs_dim", "\n", "self", ".", "waiting", "=", "False", "\n", "self", ".", "closed", "=", "False", "\n", "self", ".", "no_of_envs", "=", "len", "(", "env_fns", ")", "\n", "self", ".", "remotes", ",", "self", ".", "work_remotes", "=", "zip", "(", "*", "[", "Pipe", "(", ")", "for", "_", "in", "range", "(", "self", ".", "no_of_envs", ")", "]", ")", "\n", "self", ".", "ps", "=", "[", "]", "\n", "\n", "for", "wrk", ",", "rem", ",", "fn", "in", "zip", "(", "self", ".", "work_remotes", ",", "self", ".", "remotes", ",", "env_fns", ")", ":", "\n", "            ", "proc", "=", "Process", "(", "target", "=", "worker", ",", "\n", "args", "=", "(", "wrk", ",", "rem", ",", "CloudpickleWrapper", "(", "fn", ")", ",", "self", ".", "largest_obs_dim", ")", ")", "\n", "self", ".", "ps", ".", "append", "(", "proc", ")", "\n", "\n", "", "for", "p", "in", "self", ".", "ps", ":", "\n", "            ", "p", ".", "daemon", "=", "True", "\n", "p", ".", "start", "(", ")", "\n", "\n", "", "for", "remote", "in", "self", ".", "work_remotes", ":", "\n", "            ", "remote", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.SubprocVecEnv.step_async": [[41, 48], ["zip", "remote.send"], "methods", ["None"], ["", "", "def", "step_async", "(", "self", ",", "actions", ")", ":", "\n", "        ", "if", "self", ".", "waiting", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "self", ".", "waiting", "=", "True", "\n", "\n", "for", "remote", ",", "action", "in", "zip", "(", "self", ".", "remotes", ",", "actions", ")", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'step'", ",", "action", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.SubprocVecEnv.step_wait": [[49, 60], ["zip", "numpy.stack", "numpy.stack", "numpy.stack", "remote.recv"], "methods", ["None"], ["", "", "def", "step_wait", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "waiting", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "self", ".", "waiting", "=", "False", "\n", "\n", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "obs", ",", "rews", ",", "dones", ",", "infos", "=", "zip", "(", "*", "results", ")", "\n", "obs", "=", "np", ".", "stack", "(", "obs", ")", "\n", "rews", "=", "np", ".", "stack", "(", "rews", ")", "\n", "dones", "=", "np", ".", "stack", "(", "dones", ")", "\n", "return", "obs", ",", "rews", ",", "dones", ",", "infos", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.SubprocVecEnv.step": [[61, 64], ["parallel_gym.SubprocVecEnv.step_async", "parallel_gym.SubprocVecEnv.step_wait"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorch.step_async", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.step_wait"], ["", "def", "step", "(", "self", ",", "actions", ")", ":", "\n", "        ", "self", ".", "step_async", "(", "actions", ")", "\n", "return", "self", ".", "step_wait", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.SubprocVecEnv.reset": [[65, 69], ["numpy.stack", "remote.send", "remote.recv"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'reset'", ",", "None", ")", ")", "\n", "", "return", "np", ".", "stack", "(", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.SubprocVecEnv.get_rms": [[70, 74], ["numpy.stack", "remote.send", "remote.recv"], "methods", ["None"], ["", "def", "get_rms", "(", "self", ")", ":", "\n", "        ", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'get_rms'", ",", "None", ")", ")", "\n", "", "return", "np", ".", "stack", "(", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.SubprocVecEnv.get_original_reward": [[75, 79], ["numpy.stack", "remote.send", "remote.recv"], "methods", ["None"], ["", "def", "get_original_reward", "(", "self", ")", ":", "\n", "        ", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'get_original_reward'", ",", "None", ")", ")", "\n", "", "return", "np", ".", "stack", "(", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.SubprocVecEnv.close": [[80, 91], ["remote.send", "p.join", "remote.recv"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "closed", ":", "\n", "            ", "return", "\n", "", "if", "self", ".", "waiting", ":", "\n", "            ", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "                ", "remote", ".", "recv", "(", ")", "\n", "", "", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'close'", ",", "None", ")", ")", "\n", "", "for", "p", "in", "self", ".", "ps", ":", "\n", "            ", "p", ".", "join", "(", ")", "\n", "", "self", ".", "closed", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.CloudpickleWrapper.__init__": [[94, 96], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "x", ")", ":", "\n", "        ", "self", ".", "x", "=", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.CloudpickleWrapper.__getstate__": [[97, 99], ["cloudpickle.dumps"], "methods", ["None"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "        ", "return", "cloudpickle", ".", "dumps", "(", "self", ".", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.CloudpickleWrapper.__setstate__": [[100, 102], ["pickle.loads"], "methods", ["None"], ["", "def", "__setstate__", "(", "self", ",", "ob", ")", ":", "\n", "        ", "self", ".", "x", "=", "pickle", ".", "loads", "(", "ob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.CloudpickleWrapper.__call__": [[103, 105], ["parallel_gym.CloudpickleWrapper.x"], "methods", ["None"], ["", "def", "__call__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "x", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.worker": [[107, 151], ["parent_remote.close", "env_fn", "remote.recv", "env_fn.step", "numpy.pad", "ob.astype.astype", "remote.send", "env_fn.reset", "len", "remote.send", "numpy.shape", "env_fn.render", "remote.close", "remote.send", "env_fn.get_original_reward", "remote.send", "numpy.shape", "env_fn.reset", "numpy.pad", "ob.astype.astype", "remote.send", "len", "numpy.shape", "numpy.shape"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.close", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.close", "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.SubprocVecEnv.get_original_reward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset"], ["", "", "def", "worker", "(", "remote", ",", "parent_remote", ",", "env_fn", ",", "largest_obs_dim", ")", ":", "\n", "    ", "parent_remote", ".", "close", "(", ")", "\n", "env", "=", "env_fn", "(", ")", "\n", "while", "True", ":", "\n", "        ", "cmd", ",", "data", "=", "remote", ".", "recv", "(", ")", "\n", "if", "cmd", "==", "'step'", ":", "\n", "            ", "ob", ",", "reward", ",", "done", ",", "info", "=", "env", ".", "step", "(", "data", ")", "\n", "if", "done", ":", "\n", "                ", "ob", "=", "env", ".", "reset", "(", ")", "\n", "", "if", "len", "(", "np", ".", "shape", "(", "ob", ")", ")", ">", "1", ":", "\n", "                ", "ob", "=", "ob", "[", "0", ",", ":", "]", "\n", "reward", "=", "reward", "[", "0", "]", "\n", "done", "=", "done", "[", "0", "]", "\n", "", "ob", "=", "np", ".", "pad", "(", "ob", ",", "pad_width", "=", "(", "0", ",", "largest_obs_dim", "-", "np", ".", "shape", "(", "ob", ")", "[", "-", "1", "]", ")", ",", "mode", "=", "\"constant\"", ")", "\n", "ob", "=", "ob", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "\n", "remote", ".", "send", "(", "(", "ob", ",", "reward", ",", "done", ",", "info", ")", ")", "\n", "", "elif", "cmd", "==", "'render'", ":", "\n", "            ", "remote", ".", "send", "(", "env", ".", "render", "(", ")", ")", "\n", "\n", "", "elif", "cmd", "==", "'close'", ":", "\n", "            ", "remote", ".", "close", "(", ")", "\n", "break", "\n", "\n", "", "elif", "cmd", "==", "'get_rms'", ":", "\n", "            ", "rms_mean", "=", "env", ".", "obs_rms", ".", "mean", "\n", "rms_var", "=", "env", ".", "obs_rms", ".", "var", "\n", "remote", ".", "send", "(", "(", "rms_mean", ",", "rms_var", ")", ")", "\n", "\n", "", "elif", "cmd", "==", "'get_original_reward'", ":", "\n", "            ", "r", "=", "env", ".", "get_original_reward", "(", ")", "\n", "remote", ".", "send", "(", "r", ")", "\n", "\n", "", "elif", "cmd", "==", "'reset'", ":", "\n", "            ", "ob", "=", "env", ".", "reset", "(", ")", "\n", "if", "len", "(", "np", ".", "shape", "(", "ob", ")", ")", ">", "1", ":", "\n", "                ", "ob", "=", "ob", "[", "0", ",", ":", "]", "\n", "", "ob", "=", "np", ".", "pad", "(", "ob", ",", "pad_width", "=", "(", "0", ",", "largest_obs_dim", "-", "np", ".", "shape", "(", "ob", ")", "[", "-", "1", "]", ")", ",", "mode", "=", "\"constant\"", ")", "\n", "ob", "=", "ob", ".", "astype", "(", "np", ".", "float32", ")", "\n", "remote", ".", "send", "(", "ob", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.parallel_gym.make_mp_envs": [[153, 165], ["parallel_gym.SubprocVecEnv", "stable_baselines.common.vec_env.DummyVecEnv", "stable_baselines.common.vec_env.VecNormalize", "parallel_gym.make_mp_envs.make_env"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.make_env"], ["", "", "", "def", "make_mp_envs", "(", "env_id", ",", "num_env", ",", "norm_reward", "=", "True", ",", "seed", "=", "1234", ",", "start_idx", "=", "0", ",", "largest_obs_dim", "=", "28", ")", ":", "\n", "    ", "def", "make_env", "(", "rank", ")", ":", "\n", "        ", "def", "fn", "(", ")", ":", "\n", "            ", "env", "=", "DummyVecEnv", "(", "[", "lambda", ":", "gym", ".", "make", "(", "env_id", ")", "]", ")", "\n", "env", "=", "VecNormalize", "(", "env", ",", "norm_obs", "=", "False", ",", "norm_reward", "=", "norm_reward", ",", "clip_obs", "=", "1000.", ",", "clip_reward", "=", "10000", ")", "\n", "if", "seed", "is", "not", "None", ":", "\n", "                ", "env", ".", "seed", "(", "seed", "+", "rank", ")", "\n", "", "return", "env", "\n", "\n", "", "return", "fn", "\n", "\n", "", "return", "SubprocVecEnv", "(", "[", "make_env", "(", "i", "+", "start_idx", ")", "for", "i", "in", "range", "(", "num_env", ")", "]", ",", "largest_obs_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.__init__": [[7, 31], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "largest_obs_dim", ",", "largest_act_dim", ",", "discount", ",", "polyak_coef", ",", "lr", ",", "\n", "n_hidden_units", ",", "save_dir", ",", "task", ",", "total_episodes", ",", "n_experts", "=", "1", ",", "k", "=", "1", ",", "vmoe", "=", "True", ",", "m_rl", "=", "True", ",", "\n", "exp_beta", "=", "1.0", ",", "gate_beta", "=", "1.0", ")", ":", "\n", "\n", "        ", "self", ".", "largest_obs_dim", "=", "largest_obs_dim", "\n", "self", ".", "largest_act_dim", "=", "largest_act_dim", "\n", "self", ".", "n_hidden_units", "=", "n_hidden_units", "\n", "self", ".", "discount", "=", "discount", "\n", "self", ".", "polyak_coef", "=", "polyak_coef", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "gamma", "=", "discount", "\n", "self", ".", "reward_scale", "=", "1.0", "\n", "self", ".", "exp_beta", "=", "exp_beta", "\n", "self", ".", "gate_beta", "=", "gate_beta", "\n", "self", ".", "vmoe", "=", "vmoe", "\n", "self", ".", "n_experts", "=", "n_experts", "\n", "self", ".", "k", "=", "k", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "munchausen_rl", "=", "m_rl", "\n", "self", ".", "munch_alpha", "=", "0.9", "\n", "self", ".", "munch_tau", "=", "0.03", "\n", "self", ".", "munch_lo", "=", "-", "1", "\n", "self", ".", "total_episodes", "=", "total_episodes", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.reset_state": [[32, 134], ["hasattr", "tf.Variable", "tfp.util.DeferredTensor", "tensorflow_addons.optimizers.LazyAdam", "HVCL_rl_utils.ActorNetwork", "HVCL_rl_utils.SoftQNetwork", "HVCL_rl_utils.SoftQNetwork", "HVCL_rl_utils.SoftQNetwork", "HVCL_rl_utils.SoftQNetwork", "tensorflow_addons.optimizers.LazyAdam", "tensorflow_addons.optimizers.LazyAdam", "tensorflow_addons.optimizers.LazyAdam", "HVCL_rla.SAC._update_target", "HVCL_rla.SAC.frange_cycle_sigmoid", "np.prod"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC._update_target", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.frange_cycle_sigmoid"], ["", "def", "reset_state", "(", "self", ",", "actions_dim", ",", "obs_dim", ",", "n_actions", ",", "act_lim", ",", "env", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "'actor_network'", ")", ":", "\n", "            ", "del", "self", ".", "actor_network", "\n", "del", "self", ".", "actor_optimizer", "\n", "del", "self", ".", "Qs", "\n", "del", "self", ".", "Q_targets", "\n", "del", "self", ".", "Q_optimizers", "\n", "del", "self", ".", "alpha_optimizer", "\n", "\n", "", "self", ".", "act_lim", "=", "act_lim", "\n", "self", ".", "obs_dim", "=", "obs_dim", "\n", "self", ".", "n_actions", "=", "n_actions", "\n", "self", ".", "actions_dim", "=", "actions_dim", "\n", "self", ".", "env", "=", "env", "\n", "self", ".", "actor_exp_beta", "=", "1e-5", "if", "self", ".", "task", "==", "0", "else", "self", ".", "exp_beta", "\n", "self", ".", "actor_gate_beta", "=", "1e-5", "if", "self", ".", "task", "==", "0", "else", "self", ".", "gate_beta", "\n", "self", ".", "qnet_exp_beta", "=", "1e-5", "if", "self", ".", "task", "==", "0", "else", "self", ".", "exp_beta", "\n", "self", ".", "qnet_gate_beta", "=", "1e-5", "if", "self", ".", "task", "==", "0", "else", "self", ".", "gate_beta", "\n", "# alpha optimizer", "\n", "self", ".", "alpha_lr", "=", "self", ".", "lr", "\n", "self", ".", "target_entropy", "=", "-", "np", ".", "prod", "(", "self", ".", "largest_act_dim", ")", "\n", "self", ".", "log_alpha", "=", "tf", ".", "Variable", "(", "0.0", ")", "\n", "self", ".", "alpha", "=", "tfp", ".", "util", ".", "DeferredTensor", "(", "self", ".", "log_alpha", ",", "tf", ".", "exp", ")", "\n", "\n", "self", ".", "alpha_optimizer", "=", "tfa", ".", "optimizers", ".", "LazyAdam", "(", "self", ".", "alpha_lr", ",", "name", "=", "'alpha_optimizer'", ")", "\n", "### Creating networks and optimizers ###", "\n", "# Policy network", "\n", "# action_output are the squashed actions and action_original those straight from the normal distribution", "\n", "logprob_epsilon", "=", "1e-6", "# For numerical stability when computing tf.log", "\n", "self", ".", "actor_network", "=", "ActorNetwork", "(", "self", ".", "n_hidden_units", ",", "self", ".", "largest_act_dim", ",", "\n", "logprob_epsilon", ",", "\n", "vmoe", "=", "self", ".", "vmoe", ",", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "expert_beta", "=", "self", ".", "actor_exp_beta", ",", "\n", "gating_beta", "=", "self", ".", "actor_gate_beta", ",", "\n", "inputdim", "=", "self", ".", "largest_obs_dim", ",", "\n", "k", "=", "self", ".", "k", ")", "\n", "\n", "# 2 Soft q-functions networks + targets", "\n", "self", ".", "softq_network", "=", "SoftQNetwork", "(", "self", ".", "n_hidden_units", ",", "qi", "=", "\"source_0\"", ",", "vmoe", "=", "self", ".", "vmoe", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "expert_beta", "=", "self", ".", "qnet_exp_beta", ",", "\n", "gating_beta", "=", "self", ".", "qnet_gate_beta", ",", "\n", "inputdim", "=", "self", ".", "largest_obs_dim", "+", "self", ".", "largest_act_dim", ",", "\n", "k", "=", "self", ".", "k", ")", "\n", "self", ".", "softq_target_network", "=", "SoftQNetwork", "(", "self", ".", "n_hidden_units", ",", "qi", "=", "\"target_0\"", ",", "vmoe", "=", "self", ".", "vmoe", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "\n", "expert_beta", "=", "self", ".", "qnet_exp_beta", ",", "\n", "gating_beta", "=", "self", ".", "qnet_gate_beta", ",", "\n", "inputdim", "=", "self", ".", "largest_obs_dim", "+", "self", ".", "largest_act_dim", ",", "\n", "k", "=", "self", ".", "k", ")", "\n", "\n", "self", ".", "softq_network2", "=", "SoftQNetwork", "(", "self", ".", "n_hidden_units", ",", "qi", "=", "\"source_1\"", ",", "vmoe", "=", "self", ".", "vmoe", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "expert_beta", "=", "0.0", ",", "\n", "gating_beta", "=", "0.0", ",", "\n", "inputdim", "=", "self", ".", "largest_obs_dim", "+", "self", ".", "largest_act_dim", ",", "\n", "k", "=", "self", ".", "k", ")", "\n", "self", ".", "softq_target_network2", "=", "SoftQNetwork", "(", "self", ".", "n_hidden_units", ",", "qi", "=", "\"target_1\"", ",", "\n", "vmoe", "=", "self", ".", "vmoe", ",", "\n", "n_experts", "=", "self", ".", "n_experts", ",", "expert_beta", "=", "0.0", ",", "\n", "gating_beta", "=", "0.0", ",", "\n", "inputdim", "=", "self", ".", "largest_obs_dim", "+", "self", ".", "largest_act_dim", ",", "\n", "k", "=", "self", ".", "k", ")", "\n", "\n", "# input1 = np.zeros(shape=(1, self.largest_obs_dim), dtype=\"float32\")", "\n", "# input2 = np.zeros(shape=(1, self.largest_act_dim), dtype=\"float32\")", "\n", "#", "\n", "# self.actor_network(input1)", "\n", "# self.softq_network(input1, input2)", "\n", "# self.softq_target_network(input1, input2)", "\n", "# self.softq_network2(input1, input2)", "\n", "# self.softq_target_network2(input1, input2)", "\n", "# print(self.softq_network.softq.summary())", "\n", "# print(self.softq_target_network.softq.summary())", "\n", "# print(self.softq_network2.softq.summary())", "\n", "# print(self.softq_target_network2.softq.summary())", "\n", "\n", "# Optimizers for the networks", "\n", "self", ".", "softq_optimizer", "=", "tfa", ".", "optimizers", ".", "LazyAdam", "(", "learning_rate", "=", "self", ".", "lr", ")", "\n", "self", ".", "softq_optimizer2", "=", "tfa", ".", "optimizers", ".", "LazyAdam", "(", "learning_rate", "=", "self", ".", "lr", ")", "\n", "self", ".", "actor_optimizer", "=", "tfa", ".", "optimizers", ".", "LazyAdam", "(", "learning_rate", "=", "self", ".", "lr", ")", "\n", "\n", "self", ".", "Qs", "=", "[", "self", ".", "softq_network", ",", "self", ".", "softq_network2", "]", "\n", "self", ".", "Q_targets", "=", "[", "self", ".", "softq_target_network", ",", "self", ".", "softq_target_network2", "]", "\n", "self", ".", "Q_optimizers", "=", "[", "self", ".", "softq_optimizer", ",", "self", ".", "softq_optimizer2", "]", "\n", "self", ".", "_update_target", "(", "tau", "=", "0.0", ")", "\n", "\n", "# for Q, Qtarget in zip(self.Qs, self.Q_targets):", "\n", "#     source_w = Q.trainable_variables", "\n", "#     target_w = Qtarget.trainable_variables", "\n", "#     for sw, tw in zip(source_w, target_w):", "\n", "#         tf.debugging.assert_equal(sw, tw)", "\n", "#", "\n", "# pred_q2 = self.softq_network(input1, input2)", "\n", "# target_pred_q2 = self.softq_target_network(input1, input2)", "\n", "# tf.debugging.assert_equal(pred_q2, target_pred_q2)", "\n", "#", "\n", "# pred_q2 = self.softq_network2(input1, input2)", "\n", "# target_pred_q2 = self.softq_target_network2(input1, input2)", "\n", "# tf.debugging.assert_equal(pred_q2, target_pred_q2)", "\n", "\n", "self", ".", "updates_performed", "=", "0", "\n", "self", ".", "frange_cycle_sigmoid", "(", "start", "=", "0.0", ",", "stop", "=", "1.0", ",", "n_epoch", "=", "self", ".", "total_episodes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.softq_value": [[135, 137], ["HVCL_rla.SAC.softq_network"], "methods", ["None"], ["", "def", "softq_value", "(", "self", ",", "states", ":", "np", ".", "ndarray", ",", "actions", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "self", ".", "softq_network", "(", "states", ",", "actions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.softq_value2": [[138, 140], ["HVCL_rla.SAC.softq_network2"], "methods", ["None"], ["", "def", "softq_value2", "(", "self", ",", "states", ":", "np", ".", "ndarray", ",", "actions", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "self", ".", "softq_network2", "(", "states", ",", "actions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.actions": [[141, 146], ["len", "HVCL_rla.SAC.actor_network", "np.shape"], "methods", ["None"], ["", "def", "actions", "(", "self", ",", "states", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Get the actions for a batch of states.\"\"\"", "\n", "if", "len", "(", "np", ".", "shape", "(", "states", ")", ")", "==", "1", ":", "\n", "            ", "states", "=", "states", "[", "None", ",", ":", "]", "\n", "", "return", "self", ".", "actor_network", "(", "states", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.action": [[147, 150], ["HVCL_rla.SAC.actor_network"], "methods", ["None"], ["", "def", "action", "(", "self", ",", "state", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Get the action for a single state.\"\"\"", "\n", "return", "self", ".", "actor_network", "(", "state", "[", "None", ",", ":", "]", ")", "[", "0", "]", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.step": [[151, 153], ["HVCL_rla.SAC.actor_network"], "methods", ["None"], ["", "def", "step", "(", "self", ",", "obs", ")", ":", "\n", "        ", "return", "self", ".", "actor_network", "(", "obs", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.get_models": [[154, 157], ["None"], "methods", ["None"], ["", "def", "get_models", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "actor_network", ",", "self", ".", "softq_network", ",", "self", ".", "softq_network2", ",", "self", ".", "softq_target_network", ",", "\n", "self", ".", "softq_target_network2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC._update_alpha": [[158, 174], ["tf.function", "HVCL_rla.SAC.actor_network", "tape.gradient", "HVCL_rla.SAC.alpha_optimizer.apply_gradients", "isinstance", "tf.GradientTape", "tf.nn.compute_average_loss", "zip", "tf.stop_gradient"], "methods", ["None"], ["", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "_update_alpha", "(", "self", ",", "observations", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "self", ".", "target_entropy", ",", "Number", ")", ":", "\n", "            ", "return", "0.0", "\n", "\n", "", "actions", ",", "log_pis", ",", "_", ",", "_", "=", "self", ".", "actor_network", "(", "observations", ")", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "            ", "alpha_losses", "=", "-", "1.0", "*", "(", "\n", "self", ".", "alpha", "*", "tf", ".", "stop_gradient", "(", "log_pis", "+", "self", ".", "target_entropy", ")", ")", "\n", "alpha_loss", "=", "tf", ".", "nn", ".", "compute_average_loss", "(", "alpha_losses", ")", "\n", "\n", "", "alpha_gradients", "=", "tape", ".", "gradient", "(", "alpha_loss", ",", "[", "self", ".", "log_alpha", "]", ")", "\n", "self", ".", "alpha_optimizer", ".", "apply_gradients", "(", "zip", "(", "\n", "alpha_gradients", ",", "[", "self", ".", "log_alpha", "]", ")", ")", "\n", "\n", "return", "alpha_losses", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.td_targets": [[175, 178], ["tf.function"], "methods", ["None"], ["", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "td_targets", "(", "self", ",", "rewards", ",", "discounts", ",", "next_values", ")", ":", "\n", "        ", "return", "rewards", "+", "discounts", "*", "next_values", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.frange_cycle_sigmoid": [[179, 195], ["np.ones", "np.ones.astype"], "methods", ["None"], ["", "def", "frange_cycle_sigmoid", "(", "self", ",", "start", ",", "stop", ",", "n_epoch", ",", "n_cycle", "=", "4", ",", "ratio", "=", "0.9", ")", ":", "\n", "        ", "L", "=", "np", ".", "ones", "(", "n_epoch", ")", "\n", "# period = n_epoch / n_cycle", "\n", "# step = (stop - start) / (period * ratio)  # step is in [0,1]", "\n", "#", "\n", "# # transform into [-6, 6] for plots: v*12.-6.", "\n", "#", "\n", "# for c in range(n_cycle):", "\n", "#", "\n", "#     v, i = start, 0", "\n", "#     while v <= stop:", "\n", "#         L[int(i + c * period)] = 1.0 / (1.0 + np.exp(- (v * 12. - 6.)))", "\n", "#         v += step", "\n", "#         i += 1", "\n", "\n", "self", ".", "beta_schedule", "=", "L", ".", "astype", "(", "dtype", "=", "\"float32\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.copy_weights": [[197, 293], ["zip", "zip", "old_layer.get_weights", "new_layer.get_weights", "zip", "zip", "len", "print", "new_layer.set_weights", "range", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "print", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append", "updated_new_weights.append"], "methods", ["None"], ["", "def", "copy_weights", "(", "self", ",", "old_models", ",", "num_train_samples", "=", "1", ")", ":", "\n", "        ", "for", "old_model", ",", "new_model", "in", "zip", "(", "old_models", ",", "[", "self", ".", "actor_network", ",", "self", ".", "softq_network", ",", "self", ".", "softq_network2", ",", "\n", "self", ".", "softq_target_network", ",", "self", ".", "softq_target_network2", "]", ")", ":", "\n", "            ", "if", "old_model", "is", "not", "None", ":", "\n", "                ", "for", "new_layer", ",", "old_layer", "in", "zip", "(", "new_model", ".", "model_layers", ".", "layers", ",", "old_model", ".", "model_layers", ".", "layers", ")", ":", "\n", "                    ", "test_weights", "=", "[", "]", "\n", "old_weights", "=", "old_layer", ".", "get_weights", "(", ")", "\n", "new_weights", "=", "new_layer", ".", "get_weights", "(", ")", "\n", "old_weight_obj", "=", "old_layer", ".", "weights", "\n", "new_weight_obj", "=", "new_layer", ".", "weights", "\n", "prior_weights", "=", "[", "[", "]", "for", "_", "in", "range", "(", "20", ")", "]", "\n", "# print(\"looking at layer %s out of %d layers\" % (old_layer.name, len(old_model.layers)))", "\n", "for", "wobj", ",", "weight", "in", "zip", "(", "old_weight_obj", ",", "old_weights", ")", ":", "\n", "# experts", "\n", "                        ", "if", "\"post_expert_mu_kernel\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "prior_weights", "[", "0", "]", "=", "weight", "\n", "", "elif", "\"post_expert_rho_kernel\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "prior_weights", "[", "1", "]", "=", "weight", "\n", "", "elif", "\"post_expert_bias\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "prior_weights", "[", "2", "]", "=", "weight", "\n", "# gating", "\n", "", "elif", "\"post_gating_kernel\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "prior_weights", "[", "3", "]", "=", "weight", "\n", "", "elif", "\"post_gating_bias\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "prior_weights", "[", "4", "]", "=", "weight", "\n", "", "elif", "\"post_gating_out_kernel\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "prior_weights", "[", "5", "]", "=", "weight", "\n", "", "elif", "\"post_gating_out_bias\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "prior_weights", "[", "6", "]", "=", "weight", "\n", "# batchnorms", "\n", "", "elif", "\"batch_norm\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "if", "\"gamma\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "prior_weights", "[", "7", "]", "=", "weight", "\n", "", "elif", "\"beta\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "prior_weights", "[", "8", "]", "=", "weight", "\n", "", "elif", "\"moving_mean\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "prior_weights", "[", "9", "]", "=", "weight", "\n", "", "elif", "\"moving_variance\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "prior_weights", "[", "10", "]", "=", "weight", "\n", "# transpose convs", "\n", "", "", "elif", "\"transpose\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "if", "\"kernel\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "prior_weights", "[", "11", "]", "=", "weight", "\n", "", "elif", "\"bias\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "prior_weights", "[", "12", "]", "=", "weight", "\n", "", "", "elif", "\"layer_norm\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "if", "\"gamma\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "prior_weights", "[", "13", "]", "=", "weight", "\n", "", "elif", "\"beta\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "prior_weights", "[", "14", "]", "=", "weight", "\n", "\n", "", "", "", "updated_new_weights", "=", "[", "]", "\n", "for", "wobj", ",", "weight", "in", "zip", "(", "new_weight_obj", ",", "new_weights", ")", ":", "\n", "                        ", "print", "(", "wobj", ".", "name", ")", "\n", "# experts", "\n", "if", "\"expert_mu_kernel\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "0", "]", ")", "\n", "", "elif", "\"expert_rho_kernel\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "1", "]", ")", "\n", "", "elif", "\"expert_bias\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "2", "]", ")", "\n", "# gating", "\n", "", "elif", "\"gating_kernel\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "3", "]", ")", "\n", "", "elif", "\"gating_bias\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "4", "]", ")", "\n", "", "elif", "\"gating_out_kernel\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "5", "]", ")", "\n", "", "elif", "\"gating_out_bias\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "6", "]", ")", "\n", "# batchnorms", "\n", "", "elif", "\"batch_norm\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "if", "\"gamma\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "7", "]", ")", "\n", "", "elif", "\"beta\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "8", "]", ")", "\n", "", "elif", "\"moving_mean\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "9", "]", ")", "\n", "", "elif", "\"moving_variance\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "10", "]", ")", "\n", "# transpose convs", "\n", "", "", "elif", "\"transpose\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "if", "\"kernel\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "11", "]", ")", "\n", "", "elif", "\"bias\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "12", "]", ")", "\n", "", "", "elif", "\"layer_norm\"", "in", "wobj", ".", "name", ":", "\n", "                            ", "if", "\"gamma\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "13", "]", ")", "\n", "", "elif", "\"beta\"", "in", "wobj", ".", "name", ":", "\n", "                                ", "updated_new_weights", ".", "append", "(", "prior_weights", "[", "14", "]", ")", "\n", "", "", "else", ":", "\n", "                            ", "updated_new_weights", ".", "append", "(", "weight", ")", "\n", "print", "(", "\"could not find %s and copied\"", "%", "wobj", ".", "name", ")", "\n", "", "", "if", "len", "(", "updated_new_weights", ")", ":", "\n", "                        ", "new_layer", ".", "set_weights", "(", "updated_new_weights", ")", "\n", "# return new_models", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC._update_target": [[295, 302], ["tf.function", "zip", "zip", "target_weight.assign"], "methods", ["None"], ["", "", "", "", "", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "_update_target", "(", "self", ",", "tau", ")", ":", "\n", "        ", "for", "Q", ",", "Q_target", "in", "zip", "(", "self", ".", "Qs", ",", "self", ".", "Q_targets", ")", ":", "\n", "            ", "for", "source_weight", ",", "target_weight", "in", "zip", "(", "\n", "Q", ".", "trainable_variables", ",", "Q_target", ".", "trainable_variables", ")", ":", "\n", "                ", "target_weight", ".", "assign", "(", "\n", "tau", "*", "target_weight", "+", "(", "1.0", "-", "tau", ")", "*", "source_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.compute_Q_targets": [[303, 319], ["tf.function", "tf.cast", "HVCL_rla.SAC.td_targets"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.td_targets"], ["", "", "", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "compute_Q_targets", "(", "self", ",", "next_Q_values", ",", "\n", "next_log_pis", ",", "\n", "rewards", ",", "\n", "terminals", ",", "\n", "discount", ",", "\n", "entropy_scale", ",", "\n", "reward_scale", ")", ":", "\n", "        ", "next_values", "=", "next_Q_values", "-", "entropy_scale", "*", "next_log_pis", "\n", "terminals", "=", "tf", ".", "cast", "(", "terminals", ",", "next_values", ".", "dtype", ")", "\n", "\n", "Q_targets", "=", "self", ".", "td_targets", "(", "\n", "rewards", "=", "reward_scale", "*", "rewards", ",", "\n", "discounts", "=", "discount", ",", "\n", "next_values", "=", "(", "1.0", "-", "terminals", ")", "*", "next_values", ")", "\n", "return", "Q_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC._compute_Q_targets": [[320, 360], ["tf.function", "tf.convert_to_tensor", "tf.convert_to_tensor", "tf.convert_to_tensor", "HVCL_rla.SAC.actor_network", "tf.concat", "tf.math.reduce_min", "HVCL_rla.SAC.compute_Q_targets", "tf.debugging.assert_all_finite", "tf.stop_gradient", "HVCL_rla.SAC.actor_network", "print", "print", "tf.math.reduce_min.append", "HVCL_rla.SAC.actor_network.gaussian_likelihood", "Q", "tf.clip_by_value"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.compute_Q_targets", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ActorNetwork.gaussian_likelihood"], ["", "@", "tf", ".", "function", "(", "experimental_relax_shapes", "=", "True", ")", "\n", "def", "_compute_Q_targets", "(", "self", ",", "batch", ")", ":", "\n", "        ", "next_observations", "=", "batch", "[", "'states1'", "]", "\n", "rewards", "=", "batch", "[", "'rewards'", "]", "\n", "terminals", "=", "batch", "[", "'terminals1'", "]", "\n", "observations", "=", "batch", "[", "'states0'", "]", "\n", "if", "self", ".", "munchausen_rl", ":", "\n", "            ", "actions", "=", "batch", "[", "'actions'", "]", "\n", "_", ",", "_", ",", "mu_m", ",", "log_std_m", "=", "self", ".", "actor_network", "(", "observations", ")", "\n", "log_pi_a", "=", "self", ".", "munch_tau", "*", "self", ".", "actor_network", ".", "gaussian_likelihood", "(", "mu", "=", "mu_m", ",", "input", "=", "actions", ",", "log_std", "=", "log_std_m", ")", "\n", "print", "(", "\"logpi\"", ",", "log_pi_a", ".", "shape", ")", "\n", "print", "(", "\"rewards\"", ",", "rewards", ".", "shape", ")", "\n", "assert", "log_pi_a", ".", "shape", "==", "rewards", ".", "shape", "\n", "munchausen_reward", "=", "(", "rewards", "+", "self", ".", "munch_alpha", "*", "tf", ".", "clip_by_value", "(", "log_pi_a", ",", "\n", "clip_value_min", "=", "self", ".", "munch_lo", ",", "\n", "clip_value_max", "=", "0", ")", ")", "\n", "assert", "munchausen_reward", ".", "shape", "==", "rewards", ".", "shape", "\n", "rewards", "=", "munchausen_reward", "\n", "\n", "", "entropy_scale", "=", "tf", ".", "convert_to_tensor", "(", "self", ".", "alpha", ")", "\n", "reward_scale", "=", "tf", ".", "convert_to_tensor", "(", "self", ".", "reward_scale", ")", "\n", "discount", "=", "tf", ".", "convert_to_tensor", "(", "self", ".", "gamma", ")", "\n", "\n", "next_actions", ",", "next_log_pis", ",", "_", ",", "_", "=", "self", ".", "actor_network", "(", "next_observations", ")", "\n", "next_Qs_values", "=", "[", "]", "\n", "for", "Q", "in", "self", ".", "Q_targets", ":", "\n", "            ", "next_Qs_values", ".", "append", "(", "Q", "(", "next_observations", ",", "next_actions", ")", ")", "\n", "", "next_Qs_values", "=", "tf", ".", "concat", "(", "next_Qs_values", ",", "axis", "=", "-", "1", ")", "\n", "next_Qs_values", "=", "tf", ".", "math", ".", "reduce_min", "(", "next_Qs_values", ",", "axis", "=", "-", "1", ")", "\n", "\n", "Q_targets", "=", "self", ".", "compute_Q_targets", "(", "\n", "next_Qs_values", ",", "\n", "next_log_pis", ",", "\n", "rewards", ",", "\n", "terminals", ",", "\n", "discount", ",", "\n", "entropy_scale", ",", "\n", "reward_scale", ")", "\n", "tf", ".", "debugging", ".", "assert_all_finite", "(", "Q_targets", ",", "\"q targets not finite\"", ")", "\n", "return", "tf", ".", "stop_gradient", "(", "Q_targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.measure_graph_size": [[361, 365], ["print", "f.get_concrete_function", "len", "map", "g.as_graph_def"], "methods", ["None"], ["", "def", "measure_graph_size", "(", "self", ",", "f", ",", "*", "args", ")", ":", "\n", "        ", "g", "=", "f", ".", "get_concrete_function", "(", "*", "args", ")", ".", "graph", "\n", "print", "(", "\"{}({}) contains {} nodes in its graph\"", ".", "format", "(", "\n", "f", ".", "__name__", ",", "', '", ".", "join", "(", "map", "(", "str", ",", "args", ")", ")", ",", "len", "(", "g", ".", "as_graph_def", "(", ")", ".", "node", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC.train": [[367, 465], ["HVCL_rla.SAC._compute_Q_targets", "tf.reshape", "tf.debugging.assert_all_finite", "tf.zeros_like", "tf.zeros_like", "tf.zeros", "zip", "tf.convert_to_tensor", "actor_tape.gradient", "tf.clip_by_global_norm", "HVCL_rla.SAC.actor_optimizer.apply_gradients", "HVCL_rla.SAC._update_target", "HVCL_rla.SAC._update_alpha", "tape.gradient", "tf.clip_by_global_norm", "optimizer.apply_gradients", "tf.GradientTape", "HVCL_rla.SAC.actor_network.loss_call", "tf.concat", "tf.math.reduce_min", "tf.nn.compute_average_loss", "tf.debugging.assert_all_finite", "zip", "tf.reduce_mean", "tf.reduce_mean", "tf.reduce_mean", "tf.reduce_mean", "tf.reduce_mean", "tf.reduce_mean", "tf.reduce_mean", "tf.reduce_mean", "tf.GradientTape", "Q.loss_call", "tf.keras.losses.huber", "tf.nn.compute_average_loss", "q_losses.append", "tf.debugging.assert_all_finite", "zip", "tf.math.reduce_min.append", "HVCL_rla.SAC.actor_network.loss_call", "tf.concat", "tf.math.reduce_min", "tf.nn.compute_average_loss", "tf.multiply", "HVCL_rla.SAC._compute_Q_targets", "tf.reshape", "tf.debugging.assert_all_finite", "Q.loss_call", "tf.keras.losses.huber", "tf.nn.compute_average_loss", "Q", "tf.math.reduce_min.append", "tf.abs", "Q", "tf.abs"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC._compute_Q_targets", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC._update_target", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC._update_alpha", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.SoftQNetwork.loss_call", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.SoftQNetwork.loss_call", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.SoftQNetwork.loss_call", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rla.SAC._compute_Q_targets", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.SoftQNetwork.loss_call"], ["", "@", "tf", ".", "function", "\n", "def", "train", "(", "self", ",", "sample", ",", "batch_size", ",", "experience_weights", "=", "None", ",", "old_sample", "=", "None", ",", "old_experience_weights", "=", "None", ",", "task", "=", "1", ")", ":", "\n", "        ", "observations", "=", "sample", "[", "\"states0\"", "]", "\n", "actions", "=", "sample", "[", "\"actions\"", "]", "\n", "\n", "# Computing target for q-functions", "\n", "softq_targets", "=", "self", ".", "_compute_Q_targets", "(", "sample", ")", "\n", "softq_targets", "=", "tf", ".", "reshape", "(", "softq_targets", ",", "[", "batch_size", ",", "1", "]", ")", "\n", "tf", ".", "debugging", ".", "assert_all_finite", "(", "softq_targets", ",", "\"q values not finite\"", ")", "\n", "q_losses", "=", "[", "]", "\n", "avg_td_errors", "=", "tf", ".", "zeros_like", "(", "softq_targets", ")", "\n", "avg_old_td_errors", "=", "tf", ".", "zeros_like", "(", "softq_targets", ")", "\n", "avg_qmodel_losses", "=", "tf", ".", "zeros", "(", "shape", "=", "(", ")", ")", "\n", "if", "task", ">=", "1", "and", "old_sample", "is", "not", "None", ":", "\n", "            ", "new_weight", "=", "0.5", "\n", "old_weight", "=", "0.5", "\n", "", "else", ":", "\n", "            ", "new_weight", "=", "1.0", "\n", "old_weight", "=", "1.0", "\n", "", "for", "Q", ",", "optimizer", "in", "zip", "(", "self", ".", "Qs", ",", "self", ".", "Q_optimizers", ")", ":", "\n", "            ", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "                ", "Q_values", ",", "q_model_losses", "=", "Q", ".", "loss_call", "(", "observations", ",", "actions", ")", "\n", "avg_qmodel_losses", "=", "avg_qmodel_losses", "+", "tf", ".", "multiply", "(", "0.5", ",", "q_model_losses", ")", "\n", "pred_Q_losses", "=", "tf", ".", "keras", ".", "losses", ".", "huber", "(", "y_true", "=", "softq_targets", ",", "y_pred", "=", "Q_values", ")", "\n", "Q_losses", "=", "tf", ".", "nn", ".", "compute_average_loss", "(", "pred_Q_losses", ",", "sample_weight", "=", "experience_weights", ")", "\n", "Q_loss", "=", "Q_losses", "\n", "avg_td_errors", "=", "avg_td_errors", "+", "0.5", "*", "tf", ".", "abs", "(", "softq_targets", "-", "Q_values", ")", "\n", "if", "self", ".", "vmoe", ":", "\n", "                    ", "Q_loss", "+=", "(", "self", ".", "beta_schedule", "[", "self", ".", "updates_performed", "]", "*", "q_model_losses", ")", "\n", "", "q_losses", ".", "append", "(", "Q_loss", ")", "\n", "\n", "if", "old_sample", "is", "not", "None", ":", "\n", "                    ", "old_observations", "=", "old_sample", "[", "\"states0\"", "]", "\n", "old_actions", "=", "old_sample", "[", "\"actions\"", "]", "\n", "old_softq_targets", "=", "self", ".", "_compute_Q_targets", "(", "old_sample", ")", "\n", "old_softq_targets", "=", "tf", ".", "reshape", "(", "old_softq_targets", ",", "[", "batch_size", ",", "1", "]", ")", "\n", "tf", ".", "debugging", ".", "assert_all_finite", "(", "old_softq_targets", ",", "\"old q values not finite\"", ")", "\n", "old_Q_values", ",", "old_q_model_losses", "=", "Q", ".", "loss_call", "(", "old_observations", ",", "old_actions", ")", "\n", "pred_old_Q_losses", "=", "tf", ".", "keras", ".", "losses", ".", "huber", "(", "y_true", "=", "old_softq_targets", ",", "y_pred", "=", "old_Q_values", ")", "\n", "old_Q_losses", "=", "tf", ".", "nn", ".", "compute_average_loss", "(", "pred_old_Q_losses", ",", "sample_weight", "=", "old_experience_weights", ")", "\n", "old_Q_loss", "=", "old_Q_losses", "\n", "avg_old_td_errors", "=", "avg_old_td_errors", "+", "0.5", "*", "tf", ".", "abs", "(", "old_softq_targets", "-", "old_Q_values", ")", "\n", "if", "self", ".", "vmoe", ":", "\n", "                        ", "old_Q_loss", "+=", "(", "self", ".", "beta_schedule", "[", "self", ".", "updates_performed", "]", "*", "old_q_model_losses", ")", "\n", "", "total_Q_loss", "=", "new_weight", "*", "Q_loss", "+", "old_weight", "*", "old_Q_loss", "\n", "", "else", ":", "\n", "                    ", "total_Q_loss", "=", "Q_loss", "\n", "pred_old_Q_losses", "=", "None", "\n", "", "", "total_gradients", "=", "tape", ".", "gradient", "(", "total_Q_loss", ",", "Q", ".", "trainable_variables", ")", "\n", "[", "tf", ".", "debugging", ".", "assert_all_finite", "(", "g", ",", "\"q fun grads not finite\"", ")", "for", "g", "in", "total_gradients", "]", "\n", "total_gradients", ",", "_", "=", "tf", ".", "clip_by_global_norm", "(", "total_gradients", ",", "1.0", ")", "\n", "optimizer", ".", "apply_gradients", "(", "zip", "(", "total_gradients", ",", "Q", ".", "trainable_variables", ")", ")", "\n", "", "if", "old_sample", "is", "None", ":", "\n", "            ", "avg_old_td_errors", "=", "None", "\n", "# Gradient ascent for the policy (actor)", "\n", "", "entropy_scale", "=", "tf", ".", "convert_to_tensor", "(", "self", ".", "alpha", ")", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "actor_tape", ":", "\n", "            ", "actions", ",", "log_pis", ",", "mean", ",", "std", ",", "actor_model_loss", "=", "self", ".", "actor_network", ".", "loss_call", "(", "observations", ")", "\n", "Qs_log_targets", "=", "[", "]", "\n", "for", "Q", "in", "self", ".", "Qs", ":", "\n", "                ", "Qs_log_targets", ".", "append", "(", "Q", "(", "observations", ",", "actions", ")", ")", "\n", "", "Qs_log_targets", "=", "tf", ".", "concat", "(", "Qs_log_targets", ",", "axis", "=", "-", "1", ")", "\n", "Qs_log_targets", "=", "tf", ".", "math", ".", "reduce_min", "(", "Qs_log_targets", ",", "axis", "=", "-", "1", ")", "\n", "actor_loss", "=", "(", "entropy_scale", "*", "log_pis", ")", "-", "Qs_log_targets", "\n", "actor_loss", "=", "tf", ".", "nn", ".", "compute_average_loss", "(", "actor_loss", ",", "sample_weight", "=", "experience_weights", ")", "\n", "actor_loss", "=", "actor_loss", "\n", "if", "self", ".", "vmoe", ":", "\n", "                ", "actor_loss", "+=", "(", "self", ".", "beta_schedule", "[", "self", ".", "updates_performed", "]", "*", "actor_model_loss", ")", "\n", "\n", "", "if", "old_sample", "is", "not", "None", ":", "\n", "                ", "old_actions", ",", "old_log_pis", ",", "old_mean", ",", "old_std", ",", "actor_model_loss", "=", "self", ".", "actor_network", ".", "loss_call", "(", "old_observations", ")", "\n", "old_Qs_log_targets", "=", "[", "]", "\n", "for", "Q", "in", "self", ".", "Qs", ":", "\n", "                    ", "old_Qs_log_targets", ".", "append", "(", "Q", "(", "old_observations", ",", "old_actions", ")", ")", "\n", "", "old_Qs_log_targets", "=", "tf", ".", "concat", "(", "old_Qs_log_targets", ",", "axis", "=", "-", "1", ")", "\n", "old_Qs_log_targets", "=", "tf", ".", "math", ".", "reduce_min", "(", "old_Qs_log_targets", ",", "axis", "=", "-", "1", ")", "\n", "old_actor_loss", "=", "(", "entropy_scale", "*", "old_log_pis", ")", "-", "old_Qs_log_targets", "\n", "old_actor_loss", "=", "tf", ".", "nn", ".", "compute_average_loss", "(", "old_actor_loss", ",", "sample_weight", "=", "old_experience_weights", ")", "\n", "old_actor_loss", "=", "old_actor_loss", "\n", "if", "self", ".", "vmoe", ":", "\n", "                    ", "old_actor_loss", "+=", "(", "self", ".", "beta_schedule", "[", "self", ".", "updates_performed", "]", "*", "actor_model_loss", ")", "\n", "", "total_actor_loss", "=", "new_weight", "*", "actor_loss", "+", "old_weight", "*", "old_actor_loss", "\n", "", "else", ":", "\n", "                ", "total_actor_loss", "=", "actor_loss", "\n", "", "", "total_actor_gradients", "=", "actor_tape", ".", "gradient", "(", "total_actor_loss", ",", "self", ".", "actor_network", ".", "trainable_weights", ")", "\n", "[", "tf", ".", "debugging", ".", "assert_all_finite", "(", "g", ",", "\"actor grads not finite\"", ")", "for", "g", "in", "total_actor_gradients", "]", "\n", "total_actor_gradients", ",", "_", "=", "tf", ".", "clip_by_global_norm", "(", "total_actor_gradients", ",", "1.0", ")", "\n", "# Minimize gradients wrt weights", "\n", "self", ".", "actor_optimizer", ".", "apply_gradients", "(", "zip", "(", "total_actor_gradients", ",", "self", ".", "actor_network", ".", "trainable_weights", ")", ")", "\n", "\n", "# Update the weights of the soft q-function target networks", "\n", "self", ".", "_update_target", "(", "tau", "=", "self", ".", "polyak_coef", ")", "\n", "\n", "self", ".", "_update_alpha", "(", "observations", "=", "observations", ")", "\n", "\n", "return", "tf", ".", "reduce_mean", "(", "total_Q_loss", ")", ",", "tf", ".", "reduce_mean", "(", "total_actor_loss", ")", ",", "tf", ".", "reduce_mean", "(", "log_pis", ")", ",", "tf", ".", "reduce_mean", "(", "\n", "softq_targets", ")", ",", "tf", ".", "reduce_mean", "(", "Q_values", ")", ",", "tf", ".", "reduce_mean", "(", "Qs_log_targets", ")", ",", "tf", ".", "reduce_mean", "(", "actor_model_loss", ")", ",", "tf", ".", "reduce_mean", "(", "avg_qmodel_losses", ")", ",", "self", ".", "alpha", ",", "mean", ",", "std", ",", "avg_td_errors", ",", "avg_old_td_errors", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.replay_buffer.ReplayBuffer.__init__": [[5, 13], ["numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "state_space", ",", "action_space", ",", "max_size", "=", "50000", ")", ":", "\n", "        ", "self", ".", "current_states", "=", "np", ".", "empty", "(", "(", "0", ",", "state_space", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "self", ".", "actions", "=", "np", ".", "empty", "(", "(", "0", ",", "action_space", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "self", ".", "rewards", "=", "np", ".", "empty", "(", "(", "0", ",", "1", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "self", ".", "next_states", "=", "np", ".", "empty", "(", "(", "0", ",", "state_space", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "self", ".", "ends", "=", "np", ".", "empty", "(", "(", "0", ",", "1", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "self", ".", "total_size", "=", "0", "\n", "self", ".", "max_size", "=", "max_size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.replay_buffer.ReplayBuffer.store": [[14, 26], ["numpy.append", "numpy.append", "numpy.append", "numpy.append", "numpy.append", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "store", "(", "self", ",", "current_state", ",", "action", ",", "reward", ",", "next_state", ",", "end", ")", ":", "\n", "        ", "self", ".", "current_states", "=", "np", ".", "append", "(", "self", ".", "current_states", "[", "-", "self", ".", "max_size", ":", "]", ",", "\n", "np", ".", "array", "(", "current_state", ",", "ndmin", "=", "2", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "actions", "=", "np", ".", "append", "(", "self", ".", "actions", "[", "-", "self", ".", "max_size", ":", "]", ",", "\n", "np", ".", "array", "(", "action", ",", "ndmin", "=", "2", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "rewards", "=", "np", ".", "append", "(", "self", ".", "rewards", "[", "-", "self", ".", "max_size", ":", "]", ",", "\n", "np", ".", "array", "(", "reward", ",", "ndmin", "=", "2", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "next_states", "=", "np", ".", "append", "(", "self", ".", "next_states", "[", "-", "self", ".", "max_size", ":", "]", ",", "\n", "np", ".", "array", "(", "next_state", ",", "ndmin", "=", "2", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "ends", "=", "np", ".", "append", "(", "self", ".", "ends", "[", "-", "self", ".", "max_size", ":", "]", ",", "\n", "np", ".", "array", "(", "end", ",", "ndmin", "=", "2", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "total_size", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.replay_buffer.ReplayBuffer.fetch_sample": [[27, 43], ["numpy.random.choice", "range", "min"], "methods", ["None"], ["", "def", "fetch_sample", "(", "self", ",", "num_samples", ")", ":", "\n", "\n", "        ", "if", "num_samples", ">", "self", ".", "total_size", ":", "\n", "            ", "num_samples", "=", "self", ".", "total_size", "\n", "\n", "", "idx", "=", "np", ".", "random", ".", "choice", "(", "range", "(", "min", "(", "self", ".", "total_size", ",", "self", ".", "max_size", ")", ")", ",", "\n", "size", "=", "num_samples", ",", "\n", "replace", "=", "False", ")", "\n", "\n", "current_states_", "=", "self", ".", "current_states", "[", "idx", "]", "\n", "actions_", "=", "self", ".", "actions", "[", "idx", "]", "\n", "rewards_", "=", "self", ".", "rewards", "[", "idx", "]", "\n", "next_states_", "=", "self", ".", "next_states", "[", "idx", "]", "\n", "ends_", "=", "self", ".", "ends", "[", "idx", "]", "\n", "\n", "return", "current_states_", ",", "actions_", ",", "rewards_", ",", "next_states_", ",", "ends_", "\n", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.initializer.HeNormalExpertInitializer.__init__": [[8, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "numexp", ",", "mode", "=", "\"fan_in\"", ")", ":", "\n", "        ", "self", ".", "numexp", "=", "numexp", "\n", "self", ".", "scale", "=", "2.0", "\n", "self", ".", "mode", "=", "mode", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.initializer.HeNormalExpertInitializer.__call__": [[13, 32], ["tensorflow.python.ops.init_ops._compute_fans", "numpy.sqrt", "range", "tensorflow.stack", "tensorflow.reshape", "len", "ValueError", "max", "tensorflow.reshape.append", "max", "max", "tensorflow.random.normal", "len"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "shape", ",", "dtype", "=", "None", ")", ":", "\n", "        ", "if", "len", "(", "shape", ")", "!=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid Input: Expected 3 dims, got %d\"", "%", "len", "(", "shape", ")", ")", "\n", "", "expert_shape", "=", "(", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ")", "\n", "scale", "=", "self", ".", "scale", "\n", "fan_in", ",", "fan_out", "=", "_compute_fans", "(", "shape", ")", "\n", "if", "self", ".", "mode", "==", "\"fan_in\"", ":", "\n", "            ", "scale", "/=", "max", "(", "1.", ",", "fan_in", ")", "\n", "", "elif", "self", ".", "mode", "==", "\"fan_out\"", ":", "\n", "            ", "scale", "/=", "max", "(", "1.", ",", "fan_out", ")", "\n", "", "else", ":", "\n", "            ", "scale", "/=", "max", "(", "1.", ",", "(", "fan_in", "+", "fan_out", ")", "/", "2.", ")", "\n", "", "stddev", "=", "np", ".", "sqrt", "(", "scale", ")", "\n", "weights", "=", "[", "]", "\n", "for", "m", "in", "range", "(", "self", ".", "numexp", ")", ":", "\n", "            ", "weights", ".", "append", "(", "tf", ".", "random", ".", "normal", "(", "expert_shape", ",", "stddev", "=", "stddev", ",", "dtype", "=", "dtype", ")", ")", "\n", "", "weights", "=", "tf", ".", "stack", "(", "weights", ")", "\n", "weights", "=", "tf", ".", "reshape", "(", "weights", ",", "shape", ")", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.initializer.HeNormalExpertInitializer.get_config": [[33, 35], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "# To support serialization", "\n", "        ", "return", "{", "'numexp'", ":", "self", ".", "numexp", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.initializer.HeUniformExpertInitializer.__init__": [[39, 42], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "numexp", ")", ":", "\n", "        ", "self", ".", "numexp", "=", "numexp", "\n", "self", ".", "scale", "=", "2.0", "*", "numexp", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.initializer.HeUniformExpertInitializer.__call__": [[43, 59], ["tensorflow.python.ops.init_ops._compute_fans", "tensorflow.sqrt", "range", "tensorflow.stack", "tensorflow.reshape", "len", "ValueError", "len", "len", "tensorflow.reshape.append", "tensorflow.random.uniform", "len"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "shape", ",", "dtype", "=", "None", ")", ":", "\n", "        ", "if", "len", "(", "shape", ")", "<", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid Input: Expected at least 3 dims, got %d\"", "%", "len", "(", "shape", ")", ")", "\n", "", "if", "len", "(", "shape", ")", "==", "3", ":", "\n", "            ", "expert_shape", "=", "(", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ")", "\n", "", "if", "len", "(", "shape", ")", "==", "5", ":", "\n", "            ", "expert_shape", "=", "(", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ",", "shape", "[", "2", "]", ",", "shape", "[", "3", "]", ")", "\n", "", "fan_in", ",", "fan_out", "=", "_compute_fans", "(", "shape", ")", "\n", "limit", "=", "tf", ".", "sqrt", "(", "self", ".", "scale", "/", "fan_in", ")", "\n", "weights", "=", "[", "]", "\n", "for", "m", "in", "range", "(", "self", ".", "numexp", ")", ":", "\n", "            ", "e_limit", "=", "limit", "\n", "weights", ".", "append", "(", "tf", ".", "random", ".", "uniform", "(", "expert_shape", ",", "minval", "=", "-", "e_limit", ",", "maxval", "=", "e_limit", ",", "dtype", "=", "dtype", ")", ")", "\n", "", "weights", "=", "tf", ".", "stack", "(", "weights", ")", "\n", "weights", "=", "tf", ".", "reshape", "(", "weights", ",", "shape", ")", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.initializer.HeUniformExpertInitializer.get_config": [[60, 62], ["None"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "# To support serialization", "\n", "        ", "return", "{", "'numexp'", ":", "self", ".", "numexp", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.__init__": [[27, 111], ["tensorflow.python.keras.engine.base_layer.Layer.__init__", "tensorflow.python.keras.utils.conv_utils.normalize_tuple", "tensorflow.python.keras.utils.conv_utils.normalize_tuple", "tensorflow.python.keras.utils.conv_utils.normalize_padding", "tensorflow.python.keras.utils.conv_utils.normalize_data_format", "tensorflow.python.keras.utils.conv_utils.normalize_tuple", "initializer.HeUniformExpertInitializer", "tensorflow.keras.initializers.random_normal", "tensorflow.keras.activations.get", "tensorflow.keras.activations.get", "tensorflow.keras.initializers.get", "tensorflow.keras.initializers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "tensorflow.keras.regularizers.get", "tensorflow.python.keras.engine.input_spec.InputSpec", "min", "type"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get"], ["def", "__init__", "(", "self", ",", "rank", ",", "\n", "n_filters", ",", "\n", "n_experts", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "1", ",", "\n", "padding", "=", "'same'", ",", "\n", "data_format", "=", "'channels_last'", ",", "\n", "dilation_rate", "=", "1", ",", "\n", "expert_activation", "=", "None", ",", "\n", "gating_activation", "=", "tf", ".", "nn", ".", "softmax", ",", "\n", "use_expert_bias", "=", "True", ",", "\n", "use_gating_bias", "=", "True", ",", "\n", "expert_bias_initializer", "=", "'zeros'", ",", "\n", "gating_bias_initializer", "=", "'zeros'", ",", "\n", "expert_kernel_regularizer", "=", "None", ",", "\n", "gating_kernel_regularizer", "=", "None", ",", "\n", "expert_bias_regularizer", "=", "None", ",", "\n", "gating_bias_regularizer", "=", "None", ",", "\n", "expert_kernel_constraint", "=", "None", ",", "\n", "gating_kernel_constraint", "=", "None", ",", "\n", "expert_bias_constraint", "=", "None", ",", "\n", "gating_bias_constraint", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "gating_noise_sigma", "=", "0.0001", ",", "\n", "gating_prior_momentum", "=", "0.9995", ",", "\n", "gating_beta", "=", "0.001", ",", "\n", "expert_beta", "=", "0.001", ",", "\n", "diversity_bonus", "=", "1.0", ",", "\n", "k", "=", "1", ",", "\n", "n_monte_carlo", "=", "10", ",", "\n", "kernel_width", "=", "10", ",", "\n", "kl_div_fun", "=", "None", ",", "\n", "entropy_fun", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "_ConvMoVE", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "n_filters", "=", "n_filters", "\n", "self", ".", "n_experts", "=", "n_experts", "\n", "if", "type", "(", "k", ")", "is", "str", "and", "k", "==", "'all'", ":", "\n", "            ", "self", ".", "k", "=", "n_experts", "\n", "", "else", ":", "\n", "            ", "self", ".", "k", "=", "min", "(", "n_experts", ",", "k", ")", "\n", "", "self", ".", "kernel_width", "=", "kernel_width", "\n", "self", ".", "n_monte_carlo", "=", "n_monte_carlo", "\n", "self", ".", "gating_prior_momentum", "=", "gating_prior_momentum", "\n", "self", ".", "gating_noise_sigma", "=", "gating_noise_sigma", "\n", "self", ".", "kl_div_fun", "=", "kl_div_fun", "\n", "self", ".", "gating_beta", "=", "gating_beta", "\n", "self", ".", "expert_beta", "=", "expert_beta", "\n", "self", ".", "entropy_fun", "=", "entropy_fun", "\n", "self", ".", "diversity_bonus", "=", "diversity_bonus", "\n", "self", ".", "n_total_filters", "=", "self", ".", "n_filters", "*", "self", ".", "n_experts", "\n", "self", ".", "kernel_size", "=", "conv_utils", ".", "normalize_tuple", "(", "kernel_size", ",", "rank", ",", "'kernel_size'", ")", "\n", "self", ".", "strides", "=", "conv_utils", ".", "normalize_tuple", "(", "strides", ",", "rank", ",", "'strides'", ")", "\n", "self", ".", "padding", "=", "conv_utils", ".", "normalize_padding", "(", "padding", ")", "\n", "self", ".", "data_format", "=", "conv_utils", ".", "normalize_data_format", "(", "data_format", ")", "\n", "self", ".", "dilation_rate", "=", "conv_utils", ".", "normalize_tuple", "(", "dilation_rate", ",", "rank", ",", "'dilation_rate'", ")", "\n", "\n", "self", ".", "expert_kernel_initializer", "=", "HeUniformExpertInitializer", "(", "numexp", "=", "self", ".", "n_experts", ")", "\n", "rho_init", "=", "-", "6.0", "#self._softplus_inverse(0.006)", "\n", "self", ".", "rho_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "random_normal", "(", "mean", "=", "rho_init", ",", "stddev", "=", "0.01", ")", "\n", "self", ".", "expert_activation", "=", "activations", ".", "get", "(", "expert_activation", ")", "\n", "self", ".", "gating_activation", "=", "activations", ".", "get", "(", "gating_activation", ")", "\n", "\n", "self", ".", "use_expert_bias", "=", "use_expert_bias", "\n", "self", ".", "use_gating_bias", "=", "use_gating_bias", "\n", "\n", "self", ".", "expert_bias_initializer", "=", "initializers", ".", "get", "(", "expert_bias_initializer", ")", "\n", "self", ".", "gating_bias_initializer", "=", "initializers", ".", "get", "(", "gating_bias_initializer", ")", "\n", "\n", "self", ".", "expert_kernel_regularizer", "=", "regularizers", ".", "get", "(", "expert_kernel_regularizer", ")", "\n", "self", ".", "gating_kernel_regularizer", "=", "regularizers", ".", "get", "(", "gating_kernel_regularizer", ")", "\n", "\n", "self", ".", "expert_bias_regularizer", "=", "regularizers", ".", "get", "(", "expert_bias_regularizer", ")", "\n", "self", ".", "gating_bias_regularizer", "=", "regularizers", ".", "get", "(", "gating_bias_regularizer", ")", "\n", "\n", "self", ".", "expert_kernel_constraint", "=", "constraints", ".", "get", "(", "expert_kernel_constraint", ")", "\n", "self", ".", "gating_kernel_constraint", "=", "constraints", ".", "get", "(", "gating_kernel_constraint", ")", "\n", "\n", "self", ".", "expert_bias_constraint", "=", "constraints", ".", "get", "(", "expert_bias_constraint", ")", "\n", "self", ".", "gating_bias_constraint", "=", "constraints", ".", "get", "(", "gating_bias_constraint", ")", "\n", "\n", "self", ".", "activity_regularizer", "=", "regularizers", ".", "get", "(", "activity_regularizer", ")", "\n", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "self", ".", "rank", "+", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.build": [[112, 276], ["ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "int", "int", "int", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "range", "tensorflow.python.ops.nn_ops.Convolution", "tensorflow.python.ops.nn_ops.Convolution", "tensorflow.python.keras.engine.input_spec.InputSpec", "ValueError", "numpy.ceil", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "ConvMoVE._ConvMoVE.add_weight", "numpy.floor", "tensorflow.initializers.constant", "tensorflow.initializers.constant", "tensorflow.TensorShape", "ConvMoVE._ConvMoVE.padding.upper", "tensorflow.python.layers.utils.convert_data_format", "tensorflow.TensorShape", "ConvMoVE._ConvMoVE.padding.upper", "tensorflow.python.layers.utils.convert_data_format"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "            ", "channel_axis", "=", "1", "\n", "self", ".", "tf_data_format", "=", "'NCHW'", "\n", "", "else", ":", "\n", "            ", "channel_axis", "=", "-", "1", "\n", "self", ".", "tf_data_format", "=", "'NHWC'", "\n", "\n", "", "if", "input_shape", "[", "channel_axis", "]", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'The channel dimension of the inputs should be defined. Found `None`.'", ")", "\n", "\n", "", "input_dim", "=", "input_shape", "[", "channel_axis", "]", "\n", "\n", "expert_kernel_shape", "=", "self", ".", "kernel_size", "+", "(", "input_dim", ",", "self", ".", "n_filters", ",", "self", ".", "n_experts", ")", "\n", "expert_rho_shape", "=", "self", ".", "kernel_size", "[", "1", ":", "]", "+", "(", "input_dim", ",", "self", ".", "n_filters", ",", "self", ".", "n_experts", ")", "\n", "\n", "self", ".", "expert_mu_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "expert_kernel_shape", ",", "\n", "initializer", "=", "self", ".", "expert_kernel_initializer", ",", "\n", "name", "=", "'post_expert_mu_kernel'", ",", "\n", "regularizer", "=", "self", ".", "expert_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_kernel_constraint", ")", "\n", "\n", "self", ".", "expert_rho_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "expert_rho_shape", ",", "\n", "initializer", "=", "self", ".", "rho_initializer", ",", "\n", "name", "=", "'post_expert_rho_kernel'", ",", "\n", "regularizer", "=", "self", ".", "expert_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_kernel_constraint", ")", "\n", "\n", "self", ".", "prior_expert_mu_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "expert_kernel_shape", ",", "\n", "initializer", "=", "\"glorot_uniform\"", ",", "\n", "name", "=", "'prior_expert_mu_kernel'", ",", "\n", "regularizer", "=", "self", ".", "expert_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_kernel_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "self", ".", "prior_expert_rho_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "expert_rho_shape", ",", "\n", "initializer", "=", "self", ".", "rho_initializer", ",", "\n", "name", "=", "'prior_expert_rho_kernel'", ",", "\n", "regularizer", "=", "self", ".", "expert_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_kernel_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "self", ".", "n_gating_filters", "=", "self", ".", "n_filters", "\n", "gating_kernel_shape", "=", "self", ".", "kernel_size", "+", "(", "input_dim", ",", "self", ".", "n_gating_filters", ")", "\n", "output_size_offset", "=", "1", "# elf.rank - 1", "\n", "padding", "=", "int", "(", "np", ".", "ceil", "(", "(", "self", ".", "kernel_size", "[", "\n", "0", "]", "-", "1", ")", "/", "2.0", ")", ")", "# (self.strides[0] - 1) * input_shape[1] - self.strides[0] + self.kernel_size[0] / 2.0)", "\n", "gating_out_kernel_size", "=", "int", "(", "\n", "np", ".", "floor", "(", "(", "input_shape", "[", "1", "]", "+", "2", "*", "padding", "-", "self", ".", "kernel_size", "[", "0", "]", ")", "/", "self", ".", "strides", "[", "0", "]", ")", "+", "output_size_offset", ")", "\n", "gating_out_kernel_size", "=", "int", "(", "gating_out_kernel_size", "*", "0.5", ")", "# apply max pooling factor", "\n", "self", ".", "gating_out_kernel_shape", "=", "(", "self", ".", "n_gating_filters", "*", "gating_out_kernel_size", "**", "self", ".", "rank", ")", "\n", "if", "self", ".", "n_experts", ">", "1", ":", "\n", "            ", "self", ".", "gating_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "gating_kernel_shape", ",", "\n", "initializer", "=", "\"he_uniform\"", ",", "\n", "name", "=", "'post_gating_kernel'", ",", "\n", "regularizer", "=", "self", ".", "gating_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_kernel_constraint", ")", "\n", "self", ".", "gating_out_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "gating_out_kernel_shape", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "\"he_uniform\"", ",", "\n", "name", "=", "'post_gating_out_kernel'", ",", "\n", "regularizer", "=", "self", ".", "gating_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_kernel_constraint", ")", "\n", "\n", "self", ".", "prior_gating_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "gating_kernel_shape", ",", "\n", "initializer", "=", "\"he_uniform\"", ",", "\n", "name", "=", "'prior_gating_kernel'", ",", "\n", "regularizer", "=", "self", ".", "gating_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_kernel_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "self", ".", "prior_gating_out_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "gating_out_kernel_shape", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "\"he_uniform\"", ",", "\n", "name", "=", "'prior_gating_out_kernel'", ",", "\n", "regularizer", "=", "self", ".", "gating_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_kernel_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "gating_noise", "=", "None", "\n", "self", ".", "gating_kernel", "=", "None", "\n", "self", ".", "prior_gating_kernel", "=", "None", "\n", "self", ".", "prior_gating", "=", "None", "\n", "self", ".", "old_prior_gating", "=", "None", "\n", "\n", "", "if", "self", ".", "use_expert_bias", ":", "\n", "            ", "expert_bias_shape", "=", "(", "self", ".", "n_filters", ",", "self", ".", "n_experts", ")", "\n", "self", ".", "expert_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "expert_bias_shape", ",", "\n", "initializer", "=", "self", ".", "expert_bias_initializer", ",", "\n", "name", "=", "'post_expert_bias'", ",", "\n", "regularizer", "=", "self", ".", "expert_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_bias_constraint", ")", "\n", "self", ".", "prior_expert_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "expert_bias_shape", ",", "\n", "initializer", "=", "self", ".", "expert_bias_initializer", ",", "\n", "name", "=", "'prior_expert_bias'", ",", "\n", "regularizer", "=", "self", ".", "expert_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_bias_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "expert_bias", "=", "None", "\n", "self", ".", "prior_expert_bias", "=", "None", "\n", "\n", "", "if", "self", ".", "use_gating_bias", "and", "self", ".", "n_experts", ">", "1", ":", "\n", "            ", "self", ".", "gating_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "n_gating_filters", ",", ")", ",", "\n", "initializer", "=", "self", ".", "gating_bias_initializer", ",", "\n", "name", "=", "'post_gating_bias'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ")", "\n", "self", ".", "prior_gating_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "n_gating_filters", ",", ")", ",", "\n", "initializer", "=", "self", ".", "gating_bias_initializer", ",", "\n", "name", "=", "'prior_gating_bias'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "self", ".", "gating_out_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "n_experts", ",", ")", ",", "\n", "initializer", "=", "self", ".", "gating_bias_initializer", ",", "\n", "name", "=", "'post_gating_out_bias'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ")", "\n", "self", ".", "prior_gating_out_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "n_experts", ",", ")", ",", "\n", "initializer", "=", "self", ".", "gating_bias_initializer", ",", "\n", "name", "=", "'prior_gating_out_bias'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "gating_bias", "=", "None", "\n", "self", ".", "prior_gating_bias", "=", "None", "\n", "\n", "", "self", ".", "kl_weight", "=", "self", ".", "add_weight", "(", "shape", "=", "(", ")", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "constant", "(", "self", ".", "expert_beta", ")", ",", "\n", "name", "=", "'kl_weights'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "self", ".", "gating_kl_weight", "=", "self", ".", "add_weight", "(", "shape", "=", "(", ")", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "constant", "(", "self", ".", "gating_beta", ")", ",", "\n", "name", "=", "'gating_kl_weight'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "self", ".", "new_gating_outputs_shape", "=", "(", "-", "1", ",", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "rank", ")", ":", "\n", "            ", "self", ".", "new_gating_outputs_shape", "=", "self", ".", "new_gating_outputs_shape", "+", "(", "1", ",", ")", "\n", "", "self", ".", "new_gating_outputs_shape", "=", "self", ".", "new_gating_outputs_shape", "+", "(", "self", ".", "n_filters", ",", "self", ".", "n_experts", ")", "\n", "\n", "kernel_shape", "=", "self", ".", "kernel_size", "+", "(", "input_dim", ",", "self", ".", "n_filters", ")", "\n", "self", ".", "_convolution_op", "=", "nn_ops", ".", "Convolution", "(", "\n", "input_shape", ",", "\n", "filter_shape", "=", "tf", ".", "TensorShape", "(", "kernel_shape", ")", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ".", "upper", "(", ")", ",", "\n", "data_format", "=", "tf_layers_util", ".", "convert_data_format", "(", "\n", "self", ".", "data_format", ",", "self", ".", "rank", "+", "2", ")", ")", "\n", "\n", "self", ".", "gating_convolution_op", "=", "nn_ops", ".", "Convolution", "(", "\n", "input_shape", ",", "\n", "filter_shape", "=", "tf", ".", "TensorShape", "(", "gating_kernel_shape", ")", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ".", "upper", "(", ")", ",", "\n", "data_format", "=", "tf_layers_util", ".", "convert_data_format", "(", "\n", "self", ".", "data_format", ",", "self", ".", "rank", "+", "2", ")", ")", "\n", "# Set input spec.", "\n", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "self", ".", "rank", "+", "2", ",", "axes", "=", "{", "channel_axis", ":", "input_dim", "}", ")", "\n", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.call": [[277, 334], ["SparseDispatcher.SparseDispatcher.SparseDispatcher", "SparseDispatcher.SparseDispatcher.SparseDispatcher.dispatch", "SparseDispatcher.SparseDispatcher.SparseDispatcher.expert_to_gates", "ConvMoVE._ConvMoVE.apply_kernels", "ConvMoVE._ConvMoVE.add_loss", "ConvMoVE._ConvMoVE.apply_gating_kernels", "tensorflow_probability.distributions.Categorical", "tensorflow.reduce_mean", "ConvMoVE._ConvMoVE.add_loss", "ConvMoVE._ConvMoVE.add_loss", "ConvMoVE._ConvMoVE.top_k_gating", "tensorflow_probability.distributions.Categorical", "tensorflow_probability.distributions.Categorical", "tensorflow.reduce_mean", "ConvMoVE._ConvMoVE.add_loss", "range", "tensorflow.linalg.det", "ConvMoVE._ConvMoVE.add_loss", "tensorflow.ones", "SparseDispatcher.SparseDispatcher.SparseDispatcher.combine", "tensorflow.keras.layers.Reshape", "ConvMoVE._ConvMoVE.entropy_fun", "ConvMoVE._ConvMoVE.kl_div_fun", "range", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.ones", "range", "range", "ConvMoVE._ConvMoVE.wasserstein_dist", "tensorflow.exp", "tensorflow.ones", "tensorflow.shape", "ConvMoVE._ConvMoVE.wasserstein_dist"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.dispatch", "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.expert_to_gates", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.apply_kernels", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.apply_gating_kernels", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.top_k_gating", "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.combine", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.wasserstein_dist", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.wasserstein_dist"], ["", "def", "call", "(", "self", ",", "inputs", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "if", "self", ".", "n_experts", ">", "1", ":", "\n", "            ", "noisy_gating_outputs", ",", "activated_gating_outputs", ",", "activated_prior_gating_outputs", ",", "gating_cond_entropy", ",", "attn_inuts", "=", "self", ".", "apply_gating_kernels", "(", "inputs", ",", "\n", "**", "kwargs", ")", "\n", "\n", "# gating entropy penalty", "\n", "batch_gating_prior", "=", "tfp", ".", "distributions", ".", "Categorical", "(", "\n", "probs", "=", "tf", ".", "reduce_mean", "(", "activated_gating_outputs", ",", "axis", "=", "0", ",", "keepdims", "=", "True", ")", ")", "\n", "batch_activated_gating_entropy", "=", "tf", ".", "reduce_mean", "(", "self", ".", "entropy_fun", "(", "batch_gating_prior", ")", ")", "\n", "self", ".", "add_loss", "(", "self", ".", "diversity_bonus", "*", "batch_activated_gating_entropy", ")", "\n", "self", ".", "add_loss", "(", "self", ".", "diversity_bonus", "*", "gating_cond_entropy", ")", "\n", "\n", "gates", "=", "self", ".", "top_k_gating", "(", "noisy_gating_outputs", ")", "\n", "\n", "# gating KL div penalty", "\n", "gating_posterior_dist", "=", "tfp", ".", "distributions", ".", "Categorical", "(", "probs", "=", "activated_gating_outputs", ",", "\n", "validate_args", "=", "True", ")", "\n", "gating_prior_dist", "=", "tfp", ".", "distributions", ".", "Categorical", "(", "probs", "=", "activated_prior_gating_outputs", ",", "\n", "validate_args", "=", "True", ")", "\n", "kl_loss", "=", "tf", ".", "reduce_mean", "(", "self", ".", "kl_div_fun", "(", "gating_posterior_dist", ",", "gating_prior_dist", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "add_loss", "(", "self", ".", "gating_kl_weight", "*", "kl_loss", ")", "\n", "# balance_loss = self.load_balanced_loss(router_probs=activated_gating_outputs, expert_mask=gates)", "\n", "# self.add_loss(self.diversity_bonus * balance_loss)", "\n", "# expert diversity bonus", "\n", "dkl_mat", "=", "[", "[", "tf", ".", "ones", "(", "shape", "=", "(", ")", ")", "for", "_", "in", "range", "(", "self", ".", "n_experts", ")", "]", "for", "_", "in", "range", "(", "self", ".", "n_experts", ")", "]", "\n", "kernel_width", "=", "self", ".", "kernel_width", "\n", "for", "iexp", "in", "range", "(", "self", ".", "n_experts", ")", ":", "\n", "                ", "for", "jexp", "in", "range", "(", "iexp", ",", "self", ".", "n_experts", ")", ":", "\n", "                    ", "if", "iexp", "!=", "jexp", ":", "\n", "                        ", "dkl_mat", "[", "iexp", "]", "[", "jexp", "]", "=", "self", ".", "wasserstein_dist", "(", "iexp", ",", "jexp", ")", "\n", "dkl_mat", "[", "iexp", "]", "[", "jexp", "]", "=", "tf", ".", "exp", "(", "-", "self", ".", "wasserstein_dist", "(", "iexp", ",", "jexp", ")", "/", "kernel_width", ")", "\n", "dkl_mat", "[", "jexp", "]", "[", "iexp", "]", "=", "dkl_mat", "[", "iexp", "]", "[", "jexp", "]", "\n", "", "else", ":", "\n", "                        ", "dkl_mat", "[", "iexp", "]", "[", "jexp", "]", "=", "tf", ".", "ones", "(", "shape", "=", "(", ")", ")", "\n", "\n", "# exp_diversity = 1.0 - tf.math.square(dkl_mat[0][1])  # tf.linalg.det(dkl_mat)", "\n", "", "", "", "exp_diversity", "=", "tf", ".", "linalg", ".", "det", "(", "dkl_mat", ")", "\n", "div_bonus", "=", "-", "exp_diversity", "\n", "self", ".", "add_loss", "(", "self", ".", "diversity_bonus", "*", "div_bonus", ")", "\n", "", "else", ":", "\n", "            ", "activated_gating_outputs", "=", "None", "\n", "gates", "=", "tf", ".", "ones", "(", "shape", "=", "(", "tf", ".", "shape", "(", "inputs", ")", "[", "0", "]", ",", "1", ")", ")", "\n", "\n", "", "dispatcher", "=", "SparseDispatcher", "(", "self", ".", "n_experts", ",", "gates", ")", "\n", "e_inputs", "=", "dispatcher", ".", "dispatch", "(", "inputs", ")", "\n", "dispatcher", ".", "expert_to_gates", "(", ")", "\n", "\n", "expert_outputs", ",", "approx_expert_dkl", ",", "output_shape", "=", "self", ".", "apply_kernels", "(", "e_inputs", ")", "\n", "self", ".", "add_loss", "(", "self", ".", "kl_weight", "*", "tf", ".", "reduce_mean", "(", "approx_expert_dkl", ")", ")", "\n", "if", "self", ".", "n_experts", ">", "1", ":", "\n", "            ", "outputs", "=", "dispatcher", ".", "combine", "(", "expert_outputs", ")", "\n", "", "else", ":", "\n", "            ", "outputs", "=", "expert_outputs", "[", "0", "]", "\n", "", "outputs", "=", "tf", ".", "keras", ".", "layers", ".", "Reshape", "(", "output_shape", ")", "(", "outputs", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.load_balanced_loss": [[335, 354], ["tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.shape", "tensorflow.reduce_mean", "tensorflow.cast"], "methods", ["None"], ["", "def", "load_balanced_loss", "(", "self", ",", "router_probs", ",", "expert_mask", ")", ":", "\n", "# router_probs [tokens_per_batch, num_experts] is the probability assigned for", "\n", "# each expert per token. expert_mask [tokens_per_batch, num_experts] contains", "\n", "# the expert with the highest router probability in one\u2212hot format.", "\n", "\n", "        ", "num_experts", "=", "tf", ".", "shape", "(", "expert_mask", ")", "[", "-", "1", "]", "\n", "# Get the fraction of tokens routed to each expert.", "\n", "# density is a vector of length num experts that sums to 1.", "\n", "density", "=", "tf", ".", "reduce_mean", "(", "expert_mask", ",", "axis", "=", "0", ")", "\n", "# Get fraction of probability mass assigned to each expert from the router", "\n", "# across all tokens. density_proxy is a vector of length num experts that sums to 1.", "\n", "density_proxy", "=", "tf", ".", "reduce_mean", "(", "router_probs", ",", "axis", "=", "0", ")", "\n", "# Want both vectors to have uniform allocation (1/num experts) across all", "\n", "# num_expert elements. The two vectors will be pushed towards uniform allocation", "\n", "# when the dot product is minimized.", "\n", "loss", "=", "tf", ".", "reduce_mean", "(", "density_proxy", "*", "density", ")", "*", "tf", ".", "cast", "(", "\n", "(", "num_experts", "**", "2", ")", ",", "tf", ".", "dtypes", ".", "float32", "\n", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.apply_kernels": [[355, 421], ["range", "tensorflow.random.uniform", "tensorflow.cast", "tensorflow.shape", "tensorflow.expand_dims", "ConvMoVE._ConvMoVE.apply_kernels.random_rademacher"], "methods", ["None"], ["", "def", "apply_kernels", "(", "self", ",", "expert_input_tensors", ")", ":", "\n", "\n", "        ", "def", "random_rademacher", "(", "shape", ",", "dtype", "=", "tf", ".", "float32", ",", "seed", "=", "None", ")", ":", "\n", "            ", "int_dtype", "=", "tf", ".", "int64", "if", "tf", ".", "as_dtype", "(", "dtype", ")", "!=", "tf", ".", "int32", "else", "tf", ".", "int32", "\n", "random_bernoulli", "=", "tf", ".", "random", ".", "uniform", "(", "\n", "shape", ",", "minval", "=", "0", ",", "maxval", "=", "2", ",", "dtype", "=", "int_dtype", ",", "seed", "=", "seed", ")", "\n", "return", "tf", ".", "cast", "(", "2", "*", "random_bernoulli", "-", "1", ",", "dtype", ")", "\n", "\n", "", "expert_outputs", "=", "[", "]", "\n", "expert_kls", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_experts", ")", ":", "\n", "            ", "expert_input", "=", "expert_input_tensors", "[", "i", "]", "\n", "input_shape", "=", "tf", ".", "shape", "(", "expert_input", ")", "\n", "batch_shape", "=", "tf", ".", "expand_dims", "(", "input_shape", "[", "0", "]", ",", "0", ")", "\n", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "                ", "channels", "=", "input_shape", "[", "1", "]", "\n", "", "else", ":", "\n", "                ", "channels", "=", "input_shape", "[", "-", "1", "]", "\n", "\n", "", "if", "self", ".", "rank", "==", "2", ":", "\n", "                ", "posterior_affine_tensor", "=", "tfp", ".", "distributions", ".", "Normal", "(", "\n", "loc", "=", "tf", ".", "zeros_like", "(", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", ":", ",", "i", "]", ")", ",", "\n", "scale", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", ":", ",", ":", ",", "i", "]", ")", ")", ".", "sample", "(", ")", "\n", "", "if", "self", ".", "rank", "==", "1", ":", "\n", "                ", "posterior_affine_tensor", "=", "tfp", ".", "distributions", ".", "Normal", "(", "\n", "loc", "=", "tf", ".", "zeros_like", "(", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", "i", "]", ")", ",", "\n", "scale", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", ":", ",", "i", "]", ")", ")", ".", "sample", "(", ")", "\n", "\n", "", "if", "self", ".", "rank", "==", "2", ":", "\n", "                ", "outputs", "=", "self", ".", "_convolution_op", "(", "\n", "expert_input", ",", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", ":", ",", "i", "]", ")", "\n", "", "if", "self", ".", "rank", "==", "1", ":", "\n", "                ", "outputs", "=", "self", ".", "_convolution_op", "(", "\n", "expert_input", ",", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", "i", "]", ")", "\n", "\n", "", "sign_input", "=", "random_rademacher", "(", "\n", "tf", ".", "concat", "(", "[", "batch_shape", ",", "\n", "tf", ".", "expand_dims", "(", "channels", ",", "0", ")", "]", ",", "0", ")", ",", "\n", "dtype", "=", "expert_input", ".", "dtype", ")", "\n", "sign_output", "=", "random_rademacher", "(", "\n", "tf", ".", "concat", "(", "[", "batch_shape", ",", "\n", "tf", ".", "expand_dims", "(", "self", ".", "n_filters", ",", "0", ")", "]", ",", "0", ")", ",", "\n", "dtype", "=", "expert_input", ".", "dtype", ")", "\n", "\n", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "                ", "for", "_", "in", "range", "(", "self", ".", "rank", ")", ":", "\n", "                    ", "sign_input", "=", "tf", ".", "expand_dims", "(", "sign_input", ",", "-", "1", ")", "# 2D ex: (B, C, 1, 1)", "\n", "sign_output", "=", "tf", ".", "expand_dims", "(", "sign_output", ",", "-", "1", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "_", "in", "range", "(", "self", ".", "rank", ")", ":", "\n", "                    ", "sign_input", "=", "tf", ".", "expand_dims", "(", "sign_input", ",", "1", ")", "# 2D ex: (B, 1, 1, C)", "\n", "sign_output", "=", "tf", ".", "expand_dims", "(", "sign_output", ",", "1", ")", "\n", "\n", "", "", "perturbed_inputs", "=", "self", ".", "_convolution_op", "(", "\n", "expert_input", "*", "sign_input", ",", "posterior_affine_tensor", ")", "*", "sign_output", "\n", "\n", "outputs", "+=", "perturbed_inputs", "\n", "if", "self", ".", "use_expert_bias", ":", "\n", "                ", "outputs", "=", "nn", ".", "bias_add", "(", "outputs", ",", "self", ".", "expert_bias", "[", ":", ",", "i", "]", ",", "data_format", "=", "self", ".", "tf_data_format", ")", "\n", "", "if", "self", ".", "expert_activation", "is", "not", "None", ":", "\n", "                ", "outputs", "=", "self", ".", "expert_activation", "(", "outputs", ")", "\n", "", "flat_expert_outputs", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "(", "outputs", ")", "\n", "expert_outputs", ".", "append", "(", "flat_expert_outputs", ")", "\n", "exp_kl", "=", "self", ".", "approx_expert_dkl", "(", "exp", "=", "i", ")", "\n", "expert_kls", ".", "append", "(", "exp_kl", ")", "\n", "", "return", "expert_outputs", ",", "expert_kls", ",", "outputs", ".", "shape", "[", "1", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.approx_expert_dkl": [[422, 453], ["tensorflow_probability.distributions.MultivariateNormalDiag", "tensorflow_probability.distributions.MultivariateNormalDiag", "ConvMoVE._ConvMoVE.kl_div_fun", "tensorflow.reduce_mean", "tensorflow.nn.softplus", "tensorflow.nn.softplus", "tensorflow.nn.softplus", "tensorflow.nn.softplus"], "methods", ["None"], ["", "def", "approx_expert_dkl", "(", "self", ",", "exp", ",", "q", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Computes DKL between p and q\n        :param exp: index of expert distribution\n        :param q: if none, then q is exp's prior\n        :return: DKL as tensor\n        \"\"\"", "\n", "if", "self", ".", "rank", "==", "2", ":", "\n", "            ", "cov_post", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", ":", ",", ":", ",", "exp", "]", ")", "\n", "mu_post", "=", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", ":", ",", "exp", "]", "\n", "\n", "", "if", "self", ".", "rank", "==", "1", ":", "\n", "            ", "cov_post", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", ":", ",", "exp", "]", ")", "\n", "mu_post", "=", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", "exp", "]", "\n", "\n", "", "if", "q", "is", "not", "None", ":", "\n", "            ", "exp", "=", "q", "\n", "\n", "", "if", "self", ".", "rank", "==", "2", ":", "\n", "            ", "cov_prior", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "prior_expert_rho_kernel", "[", ":", ",", ":", ",", ":", ",", "exp", "]", ")", "\n", "mu_prior", "=", "self", ".", "prior_expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", ":", ",", "exp", "]", "\n", "\n", "", "if", "self", ".", "rank", "==", "1", ":", "\n", "            ", "cov_prior", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "prior_expert_rho_kernel", "[", ":", ",", ":", ",", "exp", "]", ")", "\n", "mu_prior", "=", "self", ".", "prior_expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", "exp", "]", "\n", "\n", "", "expert_kernel_dist", "=", "tfp", ".", "distributions", ".", "MultivariateNormalDiag", "(", "mu_post", ",", "cov_post", ")", "\n", "expert_kernel_dist_prior", "=", "tfp", ".", "distributions", ".", "MultivariateNormalDiag", "(", "mu_prior", ",", "cov_prior", ")", "\n", "kl", "=", "self", ".", "kl_div_fun", "(", "expert_kernel_dist", ",", "expert_kernel_dist_prior", ")", "\n", "kl_loss", "=", "tf", ".", "reduce_mean", "(", "kl", ",", "axis", "=", "-", "1", ")", "\n", "return", "kl_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.top_k_gating": [[454, 465], ["ConvMoVE._ConvMoVE._my_top_k", "tensorflow.slice", "tensorflow.slice", "tensorflow.nn.softmax", "ConvMoVE._ConvMoVE._rowwise_unsorted_segment_sum", "min"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._my_top_k", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._rowwise_unsorted_segment_sum"], ["", "def", "top_k_gating", "(", "self", ",", "gating_logits", ")", ":", "\n", "        ", "top_logits", ",", "top_indices", "=", "self", ".", "_my_top_k", "(", "gating_logits", ",", "min", "(", "self", ".", "k", ",", "self", ".", "n_experts", ")", ")", "\n", "\n", "top_k_logits", "=", "tf", ".", "slice", "(", "top_logits", ",", "[", "0", ",", "0", "]", ",", "[", "-", "1", ",", "self", ".", "k", "]", ")", "\n", "top_k_indices", "=", "tf", ".", "slice", "(", "top_indices", ",", "[", "0", ",", "0", "]", ",", "[", "-", "1", ",", "self", ".", "k", "]", ")", "\n", "top_k_gates", "=", "tf", ".", "nn", ".", "softmax", "(", "top_k_logits", ")", "\n", "gates", "=", "self", ".", "_rowwise_unsorted_segment_sum", "(", "top_k_gates", ",", "top_k_indices", ",", "self", ".", "n_experts", ")", "\n", "# update gating prior", "\n", "# avg_gates = tf.reduce_sum(gates, axis=0, keepdims=True)", "\n", "# avg_gates = avg_gates / tf.reduce_sum(avg_gates)", "\n", "return", "gates", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.apply_gating_kernels": [[466, 490], ["ConvMoVE._ConvMoVE.gating_convolution_op", "ConvMoVE._ConvMoVE.gating_convolution_op", "tensorflow.nn.leaky_relu", "tensorflow.nn.leaky_relu", "tensorflow.keras.backend.dot", "tensorflow.keras.backend.bias_add", "tensorflow.keras.backend.dot", "tensorflow.keras.backend.bias_add", "tensorflow.keras.backend.bias_add", "tensorflow.keras.backend.bias_add", "tensorflow.keras.layers.MaxPooling2D", "tensorflow.keras.layers.Flatten", "tensorflow.keras.layers.MaxPooling2D", "tensorflow.keras.layers.Flatten", "ConvMoVE._ConvMoVE.gating_activation", "ConvMoVE._ConvMoVE.gating_activation"], "methods", ["None"], ["", "def", "apply_gating_kernels", "(", "self", ",", "inputs", ",", "**", "kwargs", ")", ":", "\n", "        ", "gating_outputs", "=", "self", ".", "gating_convolution_op", "(", "inputs", ",", "self", ".", "gating_kernel", ")", "\n", "prior_gating_outputs", "=", "self", ".", "gating_convolution_op", "(", "inputs", ",", "self", ".", "prior_gating_kernel", ")", "\n", "if", "self", ".", "use_gating_bias", ":", "\n", "            ", "gating_outputs", "=", "K", ".", "bias_add", "(", "gating_outputs", ",", "self", ".", "gating_bias", ",", "data_format", "=", "self", ".", "data_format", ")", "\n", "prior_gating_outputs", "=", "K", ".", "bias_add", "(", "prior_gating_outputs", ",", "self", ".", "prior_gating_bias", ",", "\n", "data_format", "=", "self", ".", "data_format", ")", "\n", "", "gating_outputs", "=", "tf", ".", "nn", ".", "leaky_relu", "(", "gating_outputs", ")", "\n", "gating_outputs", "=", "MaxPooling2D", "(", ")", "(", "gating_outputs", ")", "\n", "gating_outputs", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "(", "gating_outputs", ")", "\n", "\n", "prior_gating_outputs", "=", "tf", ".", "nn", ".", "leaky_relu", "(", "prior_gating_outputs", ")", "\n", "prior_gating_outputs", "=", "MaxPooling2D", "(", ")", "(", "prior_gating_outputs", ")", "\n", "prior_gating_outputs", "=", "tf", ".", "keras", ".", "layers", ".", "Flatten", "(", ")", "(", "prior_gating_outputs", ")", "\n", "\n", "gating_outputs", "=", "K", ".", "dot", "(", "gating_outputs", ",", "self", ".", "gating_out_kernel", ")", "\n", "gating_outputs", "=", "K", ".", "bias_add", "(", "gating_outputs", ",", "self", ".", "gating_out_bias", ")", "\n", "prior_gating_outputs", "=", "K", ".", "dot", "(", "prior_gating_outputs", ",", "self", ".", "prior_gating_out_kernel", ")", "\n", "prior_gating_outputs", "=", "K", ".", "bias_add", "(", "prior_gating_outputs", ",", "self", ".", "prior_gating_out_bias", ")", "\n", "\n", "if", "self", ".", "gating_activation", "is", "not", "None", ":", "\n", "            ", "activated_gating_outputs", "=", "self", ".", "gating_activation", "(", "gating_outputs", ")", "\n", "activated_prior_gating_outputs", "=", "self", ".", "gating_activation", "(", "prior_gating_outputs", ")", "\n", "", "return", "gating_outputs", ",", "activated_gating_outputs", ",", "activated_prior_gating_outputs", ",", "0.0", ",", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.norm": [[491, 494], ["tensorflow.sqrt", "tensorflow.reduce_sum", "tensorflow.square"], "methods", ["None"], ["", "def", "norm", "(", "self", ",", "x", ")", ":", "\n", "        ", "n", "=", "tf", ".", "sqrt", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "x", ")", ")", ")", "\n", "return", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.wasserstein_dist": [[495, 511], ["tensorflow.square", "ConvMoVE._ConvMoVE.norm", "tensorflow.reduce_mean", "tensorflow.norm", "tensorflow.math.sqrt", "tensorflow.math.sqrt", "tensorflow.math.sqrt", "tensorflow.math.sqrt", "tensorflow.reduce_mean", "tensorflow.nn.softplus", "tensorflow.nn.softplus", "tensorflow.nn.softplus", "tensorflow.nn.softplus"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm"], ["", "def", "wasserstein_dist", "(", "self", ",", "i", ",", "j", ")", ":", "\n", "        ", "if", "self", ".", "rank", "==", "2", ":", "\n", "            ", "diff", "=", "tf", ".", "reduce_mean", "(", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", ":", ",", "i", "]", "-", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", ":", ",", "j", "]", ",", "axis", "=", "0", ")", "\n", "", "elif", "self", ".", "rank", "==", "1", ":", "\n", "            ", "diff", "=", "tf", ".", "reduce_mean", "(", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", "i", "]", "-", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", ":", ",", "j", "]", ",", "axis", "=", "0", ")", "\n", "", "mu_norm", "=", "tf", ".", "square", "(", "tf", ".", "norm", "(", "diff", ")", ")", "\n", "# Hellinger Distance between diagonal Covariance Matrices", "\n", "if", "self", ".", "rank", "==", "2", ":", "\n", "            ", "cov_i", "=", "tf", ".", "math", ".", "sqrt", "(", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", ":", ",", ":", ",", "i", "]", ")", "+", "1e-6", ")", "\n", "cov_j", "=", "tf", ".", "math", ".", "sqrt", "(", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", ":", ",", ":", ",", "j", "]", ")", "+", "1e-6", ")", "\n", "", "else", ":", "\n", "            ", "cov_i", "=", "tf", ".", "math", ".", "sqrt", "(", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", ":", ",", "i", "]", ")", "+", "1e-6", ")", "\n", "cov_j", "=", "tf", ".", "math", ".", "sqrt", "(", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", ":", ",", "j", "]", ")", "+", "1e-6", ")", "\n", "", "cov_trace", "=", "self", ".", "norm", "(", "cov_i", "-", "cov_j", ")", "\n", "w", "=", "mu_norm", "+", "cov_trace", "\n", "return", "w", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.get_config": [[512, 540], ["super().get_config", "dict", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.regularizers.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "{", "\n", "'rank'", ":", "self", ".", "rank", ",", "\n", "'n_filters'", ":", "self", ".", "n_filters", ",", "\n", "'n_experts'", ":", "self", ".", "n_experts", ",", "\n", "'kernel_size'", ":", "self", ".", "kernel_size", ",", "\n", "'strides'", ":", "self", ".", "strides", ",", "\n", "'padding'", ":", "self", ".", "padding", ",", "\n", "'data_format'", ":", "self", ".", "data_format", ",", "\n", "'dilation_rate'", ":", "self", ".", "dilation_rate", ",", "\n", "'expert_activation'", ":", "activations", ".", "serialize", "(", "self", ".", "expert_activation", ")", ",", "\n", "'gating_activation'", ":", "activations", ".", "serialize", "(", "self", ".", "gating_activation", ")", ",", "\n", "'use_expert_bias'", ":", "self", ".", "use_expert_bias", ",", "\n", "'use_gating_bias'", ":", "self", ".", "use_gating_bias", ",", "\n", "'expert_bias_initializer'", ":", "initializers", ".", "serialize", "(", "self", ".", "expert_bias_initializer", ")", ",", "\n", "'gating_bias_initializer'", ":", "initializers", ".", "serialize", "(", "self", ".", "gating_bias_initializer", ")", ",", "\n", "'expert_kernel_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "expert_kernel_regularizer", ")", ",", "\n", "'gating_kernel_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "gating_kernel_regularizer", ")", ",", "\n", "'expert_bias_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "expert_bias_regularizer", ")", ",", "\n", "'gating_bias_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "gating_bias_regularizer", ")", ",", "\n", "'expert_kernel_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "expert_kernel_constraint", ")", ",", "\n", "'gating_kernel_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "gating_kernel_constraint", ")", ",", "\n", "'expert_bias_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "expert_bias_constraint", ")", ",", "\n", "'gating_bias_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "gating_bias_constraint", ")", ",", "\n", "'activity_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "activity_regularizer", ")", "\n", "}", "\n", "base_config", "=", "super", "(", "_ConvMoVE", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE._softplus_inverse": [[541, 544], ["tensorflow.math.log", "tensorflow.math.expm1"], "methods", ["None"], ["", "def", "_softplus_inverse", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Helper which computes the function inverse of `tf.nn.softplus`.\"\"\"", "\n", "return", "tf", ".", "math", ".", "log", "(", "tf", ".", "math", ".", "expm1", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE._my_top_k": [[545, 577], ["range", "tensorflow.nn.top_k", "tensorflow.shape", "tensorflow.stack", "tensorflow.cast", "values.append", "tensorflow.argmax", "indices.append", "ds.Categorical", "ds.Categorical.sample", "values.append", "indices.append", "tensorflow.one_hot", "tensorflow.stack", "tensorflow.reduce_max", "ds.Categorical.log_prob"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample"], ["", "def", "_my_top_k", "(", "self", ",", "x", ",", "k", ",", "soft", "=", "True", ")", ":", "\n", "        ", "\"\"\"GPU-compatible version of top-k that works for very small constant k.\n        Calls argmax repeatedly.\n        tf.nn.top_k is implemented for GPU, but the gradient, sparse_to_dense,\n        seems not to be, so if we use tf.nn.top_k, then both the top_k and its\n        gradient go on cpu.  Once this is not an issue, this function becomes\n        obsolete and should be replaced by tf.nn.top_k.\n        Args:\n        x: a 2d Tensor.\n        k: a small integer.\n        Returns:\n        values: a Tensor of shape [batch_size, k]\n        indices: a int32 Tensor of shape [batch_size, k]\n        \"\"\"", "\n", "if", "k", ">", "10", ":", "\n", "            ", "return", "tf", ".", "nn", ".", "top_k", "(", "x", ",", "k", ")", "\n", "", "values", "=", "[", "]", "\n", "indices", "=", "[", "]", "\n", "depth", "=", "tf", ".", "shape", "(", "x", ")", "[", "1", "]", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "            ", "if", "not", "soft", ":", "\n", "                ", "values", ".", "append", "(", "tf", ".", "reduce_max", "(", "x", ",", "1", ")", ")", "\n", "idx", "=", "tf", ".", "argmax", "(", "x", ",", "1", ")", "\n", "indices", ".", "append", "(", "idx", ")", "\n", "", "else", ":", "\n", "                ", "dist", "=", "ds", ".", "Categorical", "(", "logits", "=", "x", ")", "\n", "idx", "=", "dist", ".", "sample", "(", ")", "\n", "values", ".", "append", "(", "dist", ".", "log_prob", "(", "idx", ")", ")", "\n", "indices", ".", "append", "(", "idx", ")", "\n", "", "if", "i", "+", "1", "<", "k", ":", "\n", "                ", "x", "+=", "tf", ".", "one_hot", "(", "idx", ",", "depth", ",", "-", "1e9", ")", "\n", "", "", "return", "tf", ".", "stack", "(", "values", ",", "axis", "=", "1", ")", ",", "tf", ".", "cast", "(", "tf", ".", "stack", "(", "indices", ",", "axis", "=", "1", ")", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE._assign_moving_average": [[578, 587], ["tensorflow.keras.backend.name_scope", "tensorflow.python.framework.ops.colocate_with", "tensorflow.python.ops.state_ops.assign_sub", "tensorflow.python.ops.array_ops.where", "tensorflow.python.ops.math_ops.cast", "tensorflow.keras.backend.zeros_like"], "methods", ["None"], ["", "def", "_assign_moving_average", "(", "self", ",", "variable", ",", "value", ",", "momentum", ",", "inputs_size", "=", "None", ")", ":", "\n", "        ", "with", "K", ".", "name_scope", "(", "'AssignMovingAvg'", ")", "as", "scope", ":", "\n", "            ", "with", "ops", ".", "colocate_with", "(", "variable", ")", ":", "\n", "                ", "decay", "=", "1.0", "-", "momentum", "\n", "update_delta", "=", "(", "variable", "-", "math_ops", ".", "cast", "(", "value", ",", "variable", ".", "dtype", ")", ")", "*", "decay", "\n", "if", "inputs_size", "is", "not", "None", ":", "\n", "                    ", "update_delta", "=", "array_ops", ".", "where", "(", "inputs_size", ">", "0", ",", "update_delta", ",", "\n", "K", ".", "zeros_like", "(", "update_delta", ")", ")", "\n", "", "return", "state_ops", ".", "assign_sub", "(", "variable", ",", "update_delta", ",", "name", "=", "scope", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE._rowwise_unsorted_segment_sum": [[588, 601], ["tensorflow.unstack", "tensorflow.math.unsorted_segment_sum", "tensorflow.reshape", "tensorflow.shape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.cast", "tensorflow.divide", "tensorflow.range"], "methods", ["None"], ["", "", "", "def", "_rowwise_unsorted_segment_sum", "(", "self", ",", "values", ",", "indices", ",", "n", ")", ":", "\n", "        ", "\"\"\"UnsortedSegmentSum on each row.\n        Args:\n        values: a `Tensor` with shape `[batch_size, k]`.\n        indices: an integer `Tensor` with shape `[batch_size, k]`.\n        n: an integer.\n        Returns:\n        A `Tensor` with the same type as `values` and shape `[batch_size, n]`.\n        \"\"\"", "\n", "batch", ",", "k", "=", "tf", ".", "unstack", "(", "tf", ".", "shape", "(", "indices", ")", ",", "num", "=", "2", ")", "\n", "indices_flat", "=", "tf", ".", "reshape", "(", "indices", ",", "[", "-", "1", "]", ")", "+", "tf", ".", "cast", "(", "tf", ".", "divide", "(", "tf", ".", "range", "(", "batch", "*", "k", ")", ",", "k", ")", ",", "dtype", "=", "tf", ".", "int32", ")", "*", "n", "\n", "ret_flat", "=", "tf", ".", "math", ".", "unsorted_segment_sum", "(", "tf", ".", "reshape", "(", "values", ",", "[", "-", "1", "]", ")", ",", "indices_flat", ",", "batch", "*", "n", ")", "\n", "return", "tf", ".", "reshape", "(", "ret_flat", ",", "[", "batch", ",", "n", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE._prob_in_top_k": [[602, 642], ["tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.greater", "tensorflow.expand_dims", "ConvMoVE._ConvMoVE._normal_distribution_cdf", "ConvMoVE._ConvMoVE._normal_distribution_cdf", "tensorflow.where", "tensorflow.shape", "tensorflow.shape", "tensorflow.gather", "tensorflow.cast", "tensorflow.gather", "tensorflow.range"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._normal_distribution_cdf", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._normal_distribution_cdf"], ["", "def", "_prob_in_top_k", "(", "self", ",", "clean_values", ",", "noisy_values", ",", "noise_stddev", ",", "noisy_top_values", ",", "k", ")", ":", "\n", "        ", "\"\"\"Helper function to NoisyTopKGating.\n        Computes the probability that value is in top k, given different random noise.\n        This gives us a way of backpropagating from a loss that balances the number\n        of times each expert is in the top k experts per example.\n        In the case of no noise, pass in None for noise_stddev, and the result will\n        not be differentiable.\n        Args:\n          clean_values: a `Tensor` of shape [batch, n].\n          noisy_values: a `Tensor` of shape [batch, n].  Equal to clean values plus\n            normally distributed noise with standard deviation noise_stddev.\n          noise_stddev: a `Tensor` of shape [batch, n], or None\n          noisy_top_values: a `Tensor` of shape [batch, m].\n             \"values\" Output of tf.top_k(noisy_top_values, m).  m >= k+1\n          k: an integer.\n        Returns:\n          a `Tensor` of shape [batch, n].\n        \"\"\"", "\n", "batch", "=", "tf", ".", "shape", "(", "clean_values", ")", "[", "0", "]", "\n", "m", "=", "tf", ".", "shape", "(", "noisy_top_values", ")", "[", "1", "]", "\n", "top_values_flat", "=", "tf", ".", "reshape", "(", "noisy_top_values", ",", "[", "-", "1", "]", ")", "\n", "# we want to compute the threshold that a particular value would have to", "\n", "# exceed in order to make the top k.  This computation differs depending", "\n", "# on whether the value is already in the top k.", "\n", "threshold_positions_if_in", "=", "tf", ".", "range", "(", "batch", ")", "*", "m", "+", "k", "\n", "threshold_if_in", "=", "tf", ".", "expand_dims", "(", "\n", "tf", ".", "gather", "(", "top_values_flat", ",", "threshold_positions_if_in", ")", ",", "1", ")", "\n", "is_in", "=", "tf", ".", "greater", "(", "noisy_values", ",", "threshold_if_in", ")", "\n", "if", "noise_stddev", "is", "None", ":", "\n", "            ", "return", "tf", ".", "cast", "(", "is_in", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "", "threshold_positions_if_out", "=", "threshold_positions_if_in", "-", "1", "\n", "threshold_if_out", "=", "tf", ".", "expand_dims", "(", "\n", "tf", ".", "gather", "(", "top_values_flat", ",", "threshold_positions_if_out", ")", ",", "1", ")", "\n", "# is each value currently in the top k.", "\n", "prob_if_in", "=", "self", ".", "_normal_distribution_cdf", "(", "clean_values", "-", "threshold_if_in", ",", "\n", "noise_stddev", ")", "\n", "prob_if_out", "=", "self", ".", "_normal_distribution_cdf", "(", "clean_values", "-", "threshold_if_out", ",", "\n", "noise_stddev", ")", "\n", "prob", "=", "tf", ".", "where", "(", "is_in", ",", "prob_if_in", ",", "prob_if_out", ")", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE._normal_distribution_cdf": [[643, 655], ["tensorflow.math.erf", "tensorflow.math.sqrt"], "methods", ["None"], ["", "def", "_normal_distribution_cdf", "(", "self", ",", "x", ",", "stddev", ")", ":", "\n", "        ", "\"\"\"Evaluates the CDF of the normal distribution.\n      Normal distribution with mean 0 and standard deviation stddev,\n      evaluated at x=x.\n      input and output `Tensor`s have matching shapes.\n      Args:\n        x: a `Tensor`\n        stddev: a `Tensor` with the same shape as `x`.\n      Returns:\n        a `Tensor` with the same shape as `x`.\n      \"\"\"", "\n", "return", "0.5", "*", "(", "1.0", "+", "tf", ".", "math", ".", "erf", "(", "x", "/", "(", "tf", ".", "math", ".", "sqrt", "(", "2.0", ")", "*", "stddev", "+", "1e-20", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE._ConvMoVE.cv_squared": [[656, 671], ["tensorflow.cast", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.size", "tensorflow.math.squared_difference", "tensorflow.square"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "cv_squared", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"The squared coefficient of variation of a sample.\n        Useful as a loss to encourage a positive distribution to be more uniform.\n        Epsilons added for numerical stability.\n        Returns 0 for an empty Tensor.\n        Args:\n          x: a `Tensor`.\n        Returns:\n          a `Scalar`.\n        \"\"\"", "\n", "epsilon", "=", "1e-10", "\n", "float_size", "=", "tf", ".", "cast", "(", "tf", ".", "size", "(", "x", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "+", "epsilon", "\n", "mean", "=", "tf", ".", "reduce_sum", "(", "x", ")", "/", "float_size", "\n", "variance", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "math", ".", "squared_difference", "(", "x", ",", "mean", ")", ")", "/", "float_size", "\n", "return", "variance", "/", "(", "tf", ".", "square", "(", "mean", ")", "+", "epsilon", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE.Conv1DMoVE.__init__": [[684, 738], ["ConvMoVE._ConvMoVE.__init__", "tensorflow.python.keras.engine.input_spec.InputSpec", "ValueError"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_filters", ",", "\n", "n_experts", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "1", ",", "\n", "padding", "=", "'valid'", ",", "\n", "data_format", "=", "'channels_last'", ",", "\n", "dilation_rate", "=", "1", ",", "\n", "expert_activation", "=", "None", ",", "\n", "gating_activation", "=", "None", ",", "\n", "use_expert_bias", "=", "True", ",", "\n", "use_gating_bias", "=", "True", ",", "\n", "expert_bias_initializer", "=", "'zeros'", ",", "\n", "gating_bias_initializer", "=", "'zeros'", ",", "\n", "expert_kernel_regularizer", "=", "None", ",", "\n", "gating_kernel_regularizer", "=", "None", ",", "\n", "expert_bias_regularizer", "=", "None", ",", "\n", "gating_bias_regularizer", "=", "None", ",", "\n", "expert_kernel_constraint", "=", "None", ",", "\n", "gating_kernel_constraint", "=", "None", ",", "\n", "expert_bias_constraint", "=", "None", ",", "\n", "gating_bias_constraint", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "padding", "==", "'causal'", ":", "\n", "            ", "if", "data_format", "!=", "'channels_last'", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "'When using causal padding in `Conv1DMoE`, `data_format` must be \"channels_last\" (temporal data).'", ")", "\n", "", "", "super", "(", "Conv1DMoVE", ",", "self", ")", ".", "__init__", "(", "\n", "rank", "=", "1", ",", "\n", "n_filters", "=", "n_filters", ",", "\n", "n_experts", "=", "n_experts", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "data_format", "=", "data_format", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "expert_activation", "=", "expert_activation", ",", "\n", "gating_activation", "=", "gating_activation", ",", "\n", "use_expert_bias", "=", "use_expert_bias", ",", "\n", "use_gating_bias", "=", "use_gating_bias", ",", "\n", "expert_bias_initializer", "=", "expert_bias_initializer", ",", "\n", "gating_bias_initializer", "=", "gating_bias_initializer", ",", "\n", "expert_kernel_regularizer", "=", "expert_kernel_regularizer", ",", "\n", "gating_kernel_regularizer", "=", "gating_kernel_regularizer", ",", "\n", "expert_bias_regularizer", "=", "expert_bias_regularizer", ",", "\n", "gating_bias_regularizer", "=", "gating_bias_regularizer", ",", "\n", "expert_kernel_constraint", "=", "expert_kernel_constraint", ",", "\n", "gating_kernel_constraint", "=", "gating_kernel_constraint", ",", "\n", "expert_bias_constraint", "=", "expert_bias_constraint", ",", "\n", "gating_bias_constraint", "=", "gating_bias_constraint", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE.Conv1DMoVE.get_config": [[739, 743], ["ConvMoVE._ConvMoVE.get_config", "super().get_config.pop"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", "Conv1DMoVE", ",", "self", ")", ".", "get_config", "(", ")", "\n", "config", ".", "pop", "(", "'rank'", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE.Conv2DMoVE.__init__": [[766, 816], ["ConvMoVE._ConvMoVE.__init__", "tensorflow.python.keras.engine.input_spec.InputSpec"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_filters", ",", "\n", "n_experts", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "'valid'", ",", "\n", "data_format", "=", "'channels_last'", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "\n", "expert_activation", "=", "None", ",", "\n", "gating_activation", "=", "None", ",", "\n", "use_expert_bias", "=", "True", ",", "\n", "use_gating_bias", "=", "True", ",", "\n", "expert_bias_initializer", "=", "'zeros'", ",", "\n", "gating_bias_initializer", "=", "'zeros'", ",", "\n", "expert_kernel_regularizer", "=", "None", ",", "\n", "gating_kernel_regularizer", "=", "None", ",", "\n", "expert_bias_regularizer", "=", "None", ",", "\n", "gating_bias_regularizer", "=", "None", ",", "\n", "expert_kernel_constraint", "=", "None", ",", "\n", "gating_kernel_constraint", "=", "None", ",", "\n", "expert_bias_constraint", "=", "None", ",", "\n", "gating_bias_constraint", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Conv2DMoVE", ",", "self", ")", ".", "__init__", "(", "\n", "rank", "=", "2", ",", "\n", "n_filters", "=", "n_filters", ",", "\n", "n_experts", "=", "n_experts", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "data_format", "=", "data_format", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "expert_activation", "=", "expert_activation", ",", "\n", "gating_activation", "=", "gating_activation", ",", "\n", "use_expert_bias", "=", "use_expert_bias", ",", "\n", "use_gating_bias", "=", "use_gating_bias", ",", "\n", "expert_bias_initializer", "=", "expert_bias_initializer", ",", "\n", "gating_bias_initializer", "=", "gating_bias_initializer", ",", "\n", "expert_kernel_regularizer", "=", "expert_kernel_regularizer", ",", "\n", "gating_kernel_regularizer", "=", "gating_kernel_regularizer", ",", "\n", "expert_bias_regularizer", "=", "expert_bias_regularizer", ",", "\n", "gating_bias_regularizer", "=", "gating_bias_regularizer", ",", "\n", "expert_kernel_constraint", "=", "expert_kernel_constraint", ",", "\n", "gating_kernel_constraint", "=", "gating_kernel_constraint", ",", "\n", "expert_bias_constraint", "=", "expert_bias_constraint", ",", "\n", "gating_bias_constraint", "=", "gating_bias_constraint", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE.Conv2DMoVE.get_config": [[817, 821], ["ConvMoVE._ConvMoVE.get_config", "super().get_config.pop"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", "Conv2DMoVE", ",", "self", ")", ".", "get_config", "(", ")", "\n", "config", ".", "pop", "(", "'rank'", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE.Conv3DMoVE.__init__": [[844, 894], ["ConvMoVE._ConvMoVE.__init__", "tensorflow.python.keras.engine.input_spec.InputSpec"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_filters", ",", "\n", "n_experts", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "padding", "=", "'valid'", ",", "\n", "data_format", "=", "'channels_last'", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "expert_activation", "=", "None", ",", "\n", "gating_activation", "=", "None", ",", "\n", "use_expert_bias", "=", "True", ",", "\n", "use_gating_bias", "=", "True", ",", "\n", "expert_bias_initializer", "=", "'zeros'", ",", "\n", "gating_bias_initializer", "=", "'zeros'", ",", "\n", "expert_kernel_regularizer", "=", "None", ",", "\n", "gating_kernel_regularizer", "=", "None", ",", "\n", "expert_bias_regularizer", "=", "None", ",", "\n", "gating_bias_regularizer", "=", "None", ",", "\n", "expert_kernel_constraint", "=", "None", ",", "\n", "gating_kernel_constraint", "=", "None", ",", "\n", "expert_bias_constraint", "=", "None", ",", "\n", "gating_bias_constraint", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Conv3DMoVE", ",", "self", ")", ".", "__init__", "(", "\n", "rank", "=", "3", ",", "\n", "n_filters", "=", "n_filters", ",", "\n", "n_experts", "=", "n_experts", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "data_format", "=", "data_format", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "\n", "expert_activation", "=", "expert_activation", ",", "\n", "gating_activation", "=", "gating_activation", ",", "\n", "use_expert_bias", "=", "use_expert_bias", ",", "\n", "use_gating_bias", "=", "use_gating_bias", ",", "\n", "expert_bias_initializer", "=", "expert_bias_initializer", ",", "\n", "gating_bias_initializer", "=", "gating_bias_initializer", ",", "\n", "expert_kernel_regularizer", "=", "expert_kernel_regularizer", ",", "\n", "gating_kernel_regularizer", "=", "gating_kernel_regularizer", ",", "\n", "expert_bias_regularizer", "=", "expert_bias_regularizer", ",", "\n", "gating_bias_regularizer", "=", "gating_bias_regularizer", ",", "\n", "expert_kernel_constraint", "=", "expert_kernel_constraint", ",", "\n", "gating_kernel_constraint", "=", "gating_kernel_constraint", ",", "\n", "expert_bias_constraint", "=", "expert_bias_constraint", ",", "\n", "gating_bias_constraint", "=", "gating_bias_constraint", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ConvMoVE.Conv3DMoVE.get_config": [[895, 899], ["ConvMoVE._ConvMoVE.get_config", "super().get_config.pop"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", "Conv3DMoVE", ",", "self", ")", ".", "get_config", "(", ")", "\n", "config", ".", "pop", "(", "'rank'", ")", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.__init__": [[14, 22], ["int", "math.ceil", "range", "range", "math.log"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "max_size", ")", ":", "\n", "        ", "self", ".", "max_size", "=", "max_size", "\n", "self", ".", "tree_level", "=", "int", "(", "math", ".", "ceil", "(", "math", ".", "log", "(", "max_size", "+", "1", ",", "2", ")", ")", ")", "+", "1", "\n", "self", ".", "tree_size", "=", "2", "**", "self", ".", "tree_level", "-", "1", "\n", "self", ".", "tree", "=", "[", "0", "for", "i", "in", "range", "(", "self", ".", "tree_size", ")", "]", "\n", "self", ".", "data", "=", "[", "None", "for", "i", "in", "range", "(", "self", ".", "max_size", ")", "]", "\n", "self", ".", "size", "=", "0", "\n", "self", ".", "cursor", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.add": [[23, 30], ["min", "sum_tree.SumTree.val_update"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.val_update"], ["", "def", "add", "(", "self", ",", "contents", ",", "value", ")", ":", "\n", "        ", "index", "=", "self", ".", "cursor", "\n", "self", ".", "cursor", "=", "(", "self", ".", "cursor", "+", "1", ")", "%", "self", ".", "max_size", "\n", "self", ".", "size", "=", "min", "(", "self", ".", "size", "+", "1", ",", "self", ".", "max_size", ")", "\n", "\n", "self", ".", "data", "[", "index", "]", "=", "contents", "\n", "self", ".", "val_update", "(", "index", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.get_val": [[31, 34], ["None"], "methods", ["None"], ["", "def", "get_val", "(", "self", ",", "index", ")", ":", "\n", "        ", "tree_index", "=", "2", "**", "(", "self", ".", "tree_level", "-", "1", ")", "-", "1", "+", "index", "\n", "return", "self", ".", "tree", "[", "tree_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.val_update": [[35, 39], ["sum_tree.SumTree.reconstruct"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.reconstruct"], ["", "def", "val_update", "(", "self", ",", "index", ",", "value", ")", ":", "\n", "        ", "tree_index", "=", "2", "**", "(", "self", ".", "tree_level", "-", "1", ")", "-", "1", "+", "index", "\n", "diff", "=", "value", "-", "self", ".", "tree", "[", "tree_index", "]", "\n", "self", ".", "reconstruct", "(", "tree_index", ",", "diff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.reconstruct": [[40, 45], ["int", "sum_tree.SumTree.reconstruct"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.reconstruct"], ["", "def", "reconstruct", "(", "self", ",", "tindex", ",", "diff", ")", ":", "\n", "        ", "self", ".", "tree", "[", "tindex", "]", "+=", "diff", "\n", "if", "not", "tindex", "==", "0", ":", "\n", "            ", "tindex", "=", "int", "(", "(", "tindex", "-", "1", ")", "/", "2", ")", "\n", "self", ".", "reconstruct", "(", "tindex", ",", "diff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.find": [[46, 50], ["sum_tree.SumTree._find"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree._find"], ["", "", "def", "find", "(", "self", ",", "value", ",", "norm", "=", "True", ")", ":", "\n", "        ", "if", "norm", ":", "\n", "            ", "value", "*=", "self", ".", "tree", "[", "0", "]", "\n", "", "return", "self", ".", "_find", "(", "value", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree._find": [[51, 62], ["sum_tree.SumTree._find", "sum_tree.SumTree._find"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree._find", "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree._find"], ["", "def", "_find", "(", "self", ",", "value", ",", "index", ")", ":", "\n", "        ", "if", "2", "**", "(", "self", ".", "tree_level", "-", "1", ")", "-", "1", "<=", "index", ":", "\n", "            ", "return", "self", ".", "data", "[", "index", "-", "(", "2", "**", "(", "self", ".", "tree_level", "-", "1", ")", "-", "1", ")", "]", ",", "self", ".", "tree", "[", "index", "]", ",", "index", "-", "(", "\n", "2", "**", "(", "self", ".", "tree_level", "-", "1", ")", "-", "1", ")", "\n", "\n", "", "left", "=", "self", ".", "tree", "[", "2", "*", "index", "+", "1", "]", "\n", "\n", "if", "value", "<=", "left", ":", "\n", "            ", "return", "self", ".", "_find", "(", "value", ",", "2", "*", "index", "+", "1", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_find", "(", "value", "-", "left", ",", "2", "*", "(", "index", "+", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.print_tree": [[63, 68], ["range", "range", "print", "print"], "methods", ["None"], ["", "", "def", "print_tree", "(", "self", ")", ":", "\n", "        ", "for", "k", "in", "range", "(", "1", ",", "self", ".", "tree_level", "+", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "2", "**", "(", "k", "-", "1", ")", "-", "1", ",", "2", "**", "k", "-", "1", ")", ":", "\n", "                ", "print", "(", "self", ".", "tree", "[", "j", "]", ",", "end", "=", "' '", ")", "\n", "", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.filled_size": [[69, 71], ["None"], "methods", ["None"], ["", "", "def", "filled_size", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.BetaSchedule.__init__": [[14, 22], ["int", "int", "int"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "conf", "=", "None", ")", ":", "\n", "        ", "self", ".", "batch_size", "=", "int", "(", "conf", "[", "'batch_size'", "]", "if", "'batch_size'", "in", "conf", "else", "32", ")", "\n", "\n", "self", ".", "beta_zero", "=", "conf", "[", "'beta_zero'", "]", "if", "'beta_zero'", "in", "conf", "else", "0.4", "\n", "self", ".", "learn_start", "=", "int", "(", "conf", "[", "'learn_start'", "]", "if", "'learn_start'", "in", "conf", "else", "2", ")", "\n", "# http://www.evernote.com/l/ACnDUVK3ShVEO7fDm38joUGNhDik3fFaB5o/", "\n", "self", ".", "total_steps", "=", "int", "(", "conf", "[", "'total_steps'", "]", "if", "'total_steps'", "in", "conf", "else", "5", ")", "\n", "self", ".", "beta_grad", "=", "(", "1", "-", "self", ".", "beta_zero", ")", "/", "(", "self", ".", "total_steps", "-", "self", ".", "learn_start", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.BetaSchedule.get_beta": [[23, 27], ["min"], "methods", ["None"], ["", "def", "get_beta", "(", "self", ",", "global_step", ")", ":", "\n", "# beta, increase by global_step, max 1", "\n", "        ", "beta", "=", "min", "(", "self", ".", "beta_zero", "+", "(", "global_step", "-", "self", ".", "learn_start", ")", "*", "self", ".", "beta_grad", ",", "1", ")", "\n", "return", "beta", ",", "self", ".", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.__init__": [[40, 72], ["ExperienceBuffer.BetaSchedule", "sum_tree.SumTree", "int", "float"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conf", "=", "{", "}", ")", ":", "\n", "        ", "\"\"\" Prioritized experience replay buffer initialization.\n\n        Parameters\n        ----------\n        memory_size : int\n            sample size to be stored\n        batch_size : int\n            batch size to be selected by `select` method\n        alpha: float\n            exponent determine how much prioritization.\n            Prob_i \\sim priority_i**alpha/sum(priority**alpha)\n        \"\"\"", "\n", "self", ".", "beta_sched", "=", "BetaSchedule", "(", "conf", ")", "\n", "self", ".", "_max_priority", "=", "1.0", "\n", "\n", "self", ".", "index", "=", "0", "\n", "self", ".", "record_size", "=", "0", "\n", "self", ".", "isFull", "=", "False", "\n", "self", ".", "prioritized_replay_eps", "=", "1e-6", "\n", "\n", "self", ".", "largest_obs_dim", "=", "conf", "[", "'largest_obs_dim'", "]", "\n", "self", ".", "largest_act_dim", "=", "conf", "[", "'largest_act_dim'", "]", "\n", "\n", "if", "conf", "is", "not", "None", ":", "\n", "            ", "memory_size", "=", "int", "(", "conf", "[", "'size'", "]", ")", "if", "'size'", "in", "conf", "else", "10000", "\n", "self", ".", "memory_size", "=", "memory_size", "\n", "self", ".", "tree", "=", "sum_tree", ".", "SumTree", "(", "memory_size", ")", "\n", "# self.batch_size = batch_size", "\n", "self", ".", "alpha", "=", "conf", "[", "'alpha'", "]", "if", "'alpha'", "in", "conf", "else", "0.7", "\n", "if", "'prioritized_replay_eps'", "in", "conf", ":", "\n", "                ", "self", ".", "prioritized_replay_eps", "=", "float", "(", "conf", "[", "'prioritized_replay_eps'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.save": [[73, 76], ["None"], "methods", ["None"], ["", "", "", "def", "save", "(", "self", ",", "filename", ")", ":", "\n", "        ", "assert", "False", ",", "\"proportional.experience.save() is not implemented!\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.load": [[77, 80], ["None"], "methods", ["None"], ["", "def", "load", "(", "self", ",", "filename", ")", ":", "\n", "        ", "assert", "False", ",", "\"proportional.experience.load() is not implemented!\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.fix_index": [[81, 94], ["None"], "methods", ["None"], ["", "def", "fix_index", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        get next insert index\n        :return: index, int\n        \"\"\"", "\n", "if", "self", ".", "record_size", "<=", "self", ".", "memory_size", ":", "\n", "            ", "self", ".", "record_size", "+=", "1", "\n", "", "if", "self", ".", "index", "%", "self", ".", "memory_size", "==", "0", ":", "\n", "            ", "self", ".", "index", "=", "1", "\n", "return", "self", ".", "index", "\n", "", "else", ":", "\n", "            ", "self", ".", "index", "+=", "1", "\n", "return", "self", ".", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.add": [[95, 110], ["ExperienceBuffer.ExperienceBuffer.fix_index", "ExperienceBuffer.ExperienceBuffer.tree.add"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.fix_index", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add"], ["", "", "def", "add", "(", "self", ",", "state", ":", "np", ".", "ndarray", ",", "action", ":", "np", ".", "ndarray", ",", "reward", ":", "float", ",", "new_state", ":", "np", ".", "ndarray", ",", "done", ":", "bool", ",", "priority", "=", "None", ")", ":", "\n", "        ", "\"\"\" Add new sample.\n\n        Parameters\n        ----------\n        data : object\n            new sample\n        priority : float\n            sample's priority, i.e., the td error\n        \"\"\"", "\n", "data", "=", "(", "state", ",", "action", ",", "reward", ",", "new_state", ",", "done", ")", "\n", "if", "priority", "is", "None", ":", "\n", "            ", "priority", "=", "self", ".", "_max_priority", "\n", "", "self", ".", "fix_index", "(", ")", "\n", "self", ".", "tree", ".", "add", "(", "data", ",", "priority", "**", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.get_batch": [[111, 116], ["ExperienceBuffer.ExperienceBuffer.beta_sched.get_beta", "ExperienceBuffer.ExperienceBuffer.select"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.BetaSchedule.get_beta", "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.select"], ["", "def", "get_batch", "(", "self", ",", "global_step", ",", "num_samples", "=", "None", ")", ":", "\n", "        ", "beta", ",", "batch_size", "=", "self", ".", "beta_sched", ".", "get_beta", "(", "global_step", ")", "\n", "if", "num_samples", "is", "None", ":", "\n", "            ", "num_samples", "=", "batch_size", "\n", "", "return", "self", ".", "select", "(", "beta", ",", "batch_size", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.n_entries": [[117, 120], ["ExperienceBuffer.ExperienceBuffer.tree.filled_size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.filled_size"], ["", "@", "property", "\n", "def", "n_entries", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tree", ".", "filled_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.select": [[121, 185], ["numpy.random.uniform", "ExperienceBuffer.ExperienceBuffer.update_priority", "numpy.array", "numpy.divide", "ExperienceBuffer.ExperienceBuffer.tree.filled_size", "ExperienceBuffer.ExperienceBuffer.tree.filled_size", "numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty", "ExperienceBuffer.ExperienceBuffer.tree.find", "priorities.append", "weights.append", "indices.append", "enumerate", "max", "print", "print", "print", "print", "print", "print", "print", "print", "out.keys", "numpy.append", "numpy.random.random", "ExperienceBuffer.ExperienceBuffer.tree.find", "numpy.reshape", "len"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.update_priority", "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.filled_size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.filled_size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.find", "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.find"], ["", "def", "select", "(", "self", ",", "beta", ",", "batch_size", "=", "32", ")", ":", "\n", "        ", "\"\"\" The method return samples randomly.\n\n        Parameters\n        ----------\n        beta : float\n\n        Returns\n        -------\n        out :\n            list of samples\n        weights:\n            list of weight\n        indices:\n            list of sample indices\n            The indices indicate sample positions in a sum tree.\n        \"\"\"", "\n", "\n", "if", "self", ".", "tree", ".", "filled_size", "(", ")", "<", "batch_size", ":", "\n", "            ", "batch_size", "=", "self", ".", "tree", ".", "filled_size", "(", ")", "\n", "\n", "", "out", "=", "{", "'states0'", ":", "np", ".", "empty", "(", "shape", "=", "(", "0", ",", "self", ".", "largest_obs_dim", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'actions'", ":", "np", ".", "empty", "(", "shape", "=", "(", "0", ",", "self", ".", "largest_act_dim", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'rewards'", ":", "np", ".", "empty", "(", "shape", "=", "0", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'states1'", ":", "np", ".", "empty", "(", "shape", "=", "(", "0", ",", "self", ".", "largest_obs_dim", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'terminals1'", ":", "np", ".", "empty", "(", "shape", "=", "0", ",", "dtype", "=", "np", ".", "float32", ")", "}", "\n", "\n", "indices", "=", "[", "]", "\n", "weights", "=", "[", "]", "\n", "priorities", "=", "[", "]", "\n", "rand_vals", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0.0", ",", "high", "=", "0.9999", ",", "size", "=", "batch_size", ")", "\n", "for", "r", "in", "rand_vals", ":", "# range(batch_size):", "\n", "# r = random.random()", "\n", "            ", "data", ",", "priority", ",", "index", "=", "self", ".", "tree", ".", "find", "(", "r", ")", "\n", "if", "data", "is", "None", ":", "\n", "                ", "print", "(", "\"data\"", ",", "data", ")", "\n", "print", "(", "\"beta\"", ",", "beta", ")", "\n", "print", "(", "\"priorities\"", ",", "priority", ")", "\n", "print", "(", "\"index\"", ",", "index", ")", "\n", "print", "(", "\"rand\"", ",", "r", ")", "\n", "print", "(", "\"batchsize\"", ",", "batch_size", ")", "\n", "print", "(", "\"trying to get a new one...\"", ")", "\n", "tries", "=", "0", "\n", "while", "data", "is", "None", ":", "\n", "                    ", "tries", "=", "tries", "+", "1", "\n", "rt", "=", "np", ".", "random", ".", "random", "(", "1", ")", "\n", "data", ",", "priority", ",", "index", "=", "self", ".", "tree", ".", "find", "(", "rt", ")", "\n", "", "print", "(", "\"done in %d tries.\"", "%", "tries", ")", "\n", "", "priorities", ".", "append", "(", "priority", ")", "\n", "weights", ".", "append", "(", "(", "1.", "/", "(", "self", ".", "memory_size", "*", "priority", ")", ")", "**", "beta", "if", "priority", ">", "1e-16", "else", "0", ")", "\n", "indices", ".", "append", "(", "index", ")", "\n", "for", "i", ",", "k", "in", "enumerate", "(", "out", ".", "keys", "(", ")", ")", ":", "\n", "                ", "if", "k", "in", "[", "'states0'", ",", "'actions'", ",", "'states1'", "]", ":", "\n", "                    ", "d", "=", "np", ".", "reshape", "(", "data", "[", "i", "]", ",", "newshape", "=", "(", "1", ",", "len", "(", "data", "[", "i", "]", ")", ")", ")", "\n", "", "else", ":", "\n", "                    ", "d", "=", "[", "data", "[", "i", "]", "]", "\n", "", "out", "[", "k", "]", "=", "np", ".", "append", "(", "out", "[", "k", "]", ",", "d", ",", "axis", "=", "0", ")", "\n", "# self.update_priority([index], [0]) # To avoid duplicating", "\n", "\n", "", "", "self", ".", "update_priority", "(", "indices", ",", "priorities", ")", "# Revert priorities", "\n", "# weights /= max(weights) # Normalize for stability", "\n", "w", "=", "np", ".", "array", "(", "weights", ")", "\n", "w", "=", "np", ".", "divide", "(", "w", ",", "max", "(", "w", ")", ")", "\n", "return", "out", ",", "w", ",", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.update_priority": [[186, 196], ["zip", "ExperienceBuffer.ExperienceBuffer.tree.val_update"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.val_update"], ["", "def", "update_priority", "(", "self", ",", "indices", ",", "priorities", ")", ":", "\n", "        ", "\"\"\" The methods update sample priority.\n\n        Parameters\n        ----------\n        indices :\n            list of sample indices\n        \"\"\"", "\n", "for", "i", ",", "p", "in", "zip", "(", "indices", ",", "priorities", ")", ":", "\n", "            ", "self", ".", "tree", ".", "val_update", "(", "i", ",", "(", "p", "+", "self", ".", "prioritized_replay_eps", ")", "**", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.reset_alpha": [[197, 207], ["ExperienceBuffer.ExperienceBuffer.update_priority", "range", "ExperienceBuffer.ExperienceBuffer.tree.get_val", "range", "ExperienceBuffer.ExperienceBuffer.tree.filled_size", "ExperienceBuffer.ExperienceBuffer.tree.filled_size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.update_priority", "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.get_val", "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.filled_size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.filled_size"], ["", "", "def", "reset_alpha", "(", "self", ",", "alpha", ")", ":", "\n", "        ", "\"\"\" Reset a exponent alpha.\n\n        Parameters\n        ----------\n        alpha : float\n        \"\"\"", "\n", "self", ".", "alpha", ",", "old_alpha", "=", "alpha", ",", "self", ".", "alpha", "\n", "priorities", "=", "[", "self", ".", "tree", ".", "get_val", "(", "i", ")", "**", "-", "old_alpha", "for", "i", "in", "range", "(", "self", ".", "tree", ".", "filled_size", "(", ")", ")", "]", "\n", "self", ".", "update_priority", "(", "range", "(", "self", ".", "tree", ".", "filled_size", "(", ")", ")", ",", "priorities", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.ExperienceBuffer.ExperienceBuffer.rebalance": [[208, 210], ["None"], "methods", ["None"], ["", "def", "rebalance", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.__init__": [[50, 134], ["tensorflow.python.keras.engine.base_layer.Layer.__init__", "int", "initializer.HeUniformExpertInitializer", "tensorflow.keras.initializers.random_normal", "tensorflow.keras.activations.get", "tensorflow.keras.activations.get", "tensorflow.keras.initializers.get", "tensorflow.keras.initializers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.regularizers.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "tensorflow.keras.constraints.get", "tensorflow.keras.regularizers.get", "tensorflow.python.keras.engine.input_spec.InputSpec", "kwargs.pop", "type"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get", "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get"], ["def", "__init__", "(", "self", ",", "units", ",", "\n", "n_experts", ",", "\n", "expert_activation", "=", "None", ",", "\n", "gating_activation", "=", "'softmax'", ",", "\n", "use_expert_bias", "=", "True", ",", "\n", "use_gating_bias", "=", "True", ",", "\n", "expert_bias_initializer", "=", "'zeros'", ",", "\n", "gating_bias_initializer", "=", "'zeros'", ",", "\n", "expert_kernel_regularizer", "=", "None", ",", "# tf.keras.regularizers.l2(l=1e-6),", "\n", "gating_kernel_regularizer", "=", "None", ",", "# tf.keras.regularizers.l2(l=1e-6),", "\n", "attn_kernel_regularizer", "=", "None", ",", "# tf.keras.regularizers.l1(l=0.05),", "\n", "gating_noise_kernel_regularizer", "=", "None", ",", "# tf.keras.regularizers.l1(l=0.05),", "\n", "expert_bias_regularizer", "=", "None", ",", "\n", "gating_bias_regularizer", "=", "None", ",", "\n", "expert_kernel_constraint", "=", "None", ",", "\n", "gating_kernel_constraint", "=", "None", ",", "\n", "expert_bias_constraint", "=", "None", ",", "\n", "gating_bias_constraint", "=", "None", ",", "\n", "activity_regularizer", "=", "None", ",", "\n", "gating_prior_momentum", "=", "0.99", ",", "\n", "gating_beta", "=", "0.01", ",", "\n", "expert_beta", "=", "0.01", ",", "\n", "kernel_width", "=", "10.0", ",", "\n", "diversity_bonus", "=", "1.0", ",", "\n", "k", "=", "1", ",", "\n", "n_monte_carlo", "=", "100", ",", "\n", "attn", "=", "True", ",", "\n", "kl_div_fun", "=", "None", ",", "\n", "entropy_fun", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "        ", "if", "'input_shape'", "not", "in", "kwargs", "and", "'input_dim'", "in", "kwargs", ":", "\n", "            ", "kwargs", "[", "'input_shape'", "]", "=", "(", "kwargs", ".", "pop", "(", "'input_dim'", ")", ",", ")", "\n", "", "super", "(", "DenseMoVE", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "self", ".", "gating_beta", "=", "gating_beta", "\n", "self", ".", "diversity_bonus", "=", "diversity_bonus", "\n", "self", ".", "expert_beta", "=", "expert_beta", "\n", "self", ".", "units", "=", "units", "\n", "self", ".", "gating_units", "=", "int", "(", "units", "*", "1.5", ")", "\n", "self", ".", "n_experts", "=", "n_experts", "\n", "self", ".", "intermediate_gating_units", "=", "units", "\n", "self", ".", "kernel_width", "=", "kernel_width", "\n", "# self.attn = attn", "\n", "self", ".", "kl_div_fun", "=", "kl_div_fun", "\n", "if", "type", "(", "k", ")", "is", "str", "and", "k", "==", "'all'", ":", "\n", "            ", "self", ".", "k", "=", "n_experts", "\n", "", "else", ":", "\n", "            ", "self", ".", "k", "=", "k", "\n", "", "self", ".", "n_monte_carlo", "=", "n_monte_carlo", "\n", "self", ".", "expert_kernel_initializer", "=", "HeUniformExpertInitializer", "(", "numexp", "=", "self", ".", "n_experts", ")", "\n", "rho_init", "=", "-", "2.6", "#self._softplus_inverse(0.006)", "\n", "self", ".", "rho_initializer", "=", "tf", ".", "keras", ".", "initializers", ".", "random_normal", "(", "mean", "=", "rho_init", ",", "stddev", "=", "0.01", ")", "\n", "\n", "self", ".", "expert_activation", "=", "activations", ".", "get", "(", "expert_activation", ")", "\n", "self", ".", "gating_activation", "=", "activations", ".", "get", "(", "gating_activation", ")", "\n", "self", ".", "entropy_fun", "=", "entropy_fun", "\n", "self", ".", "use_expert_bias", "=", "use_expert_bias", "\n", "self", ".", "use_gating_bias", "=", "use_gating_bias", "\n", "\n", "self", ".", "expert_bias_initializer", "=", "initializers", ".", "get", "(", "expert_bias_initializer", ")", "\n", "self", ".", "gating_bias_initializer", "=", "initializers", ".", "get", "(", "gating_bias_initializer", ")", "\n", "\n", "self", ".", "expert_kernel_regularizer", "=", "expert_kernel_regularizer", "\n", "self", ".", "gating_kernel_regularizer", "=", "gating_kernel_regularizer", "\n", "self", ".", "attn_kernel_regularizer", "=", "attn_kernel_regularizer", "\n", "self", ".", "gating_noise_kernel_regularizer", "=", "gating_noise_kernel_regularizer", "\n", "\n", "self", ".", "expert_bias_regularizer", "=", "regularizers", ".", "get", "(", "expert_bias_regularizer", ")", "\n", "self", ".", "gating_bias_regularizer", "=", "regularizers", ".", "get", "(", "gating_bias_regularizer", ")", "\n", "\n", "self", ".", "expert_kernel_constraint", "=", "constraints", ".", "get", "(", "expert_kernel_constraint", ")", "\n", "self", ".", "gating_kernel_constraint", "=", "constraints", ".", "get", "(", "gating_kernel_constraint", ")", "\n", "\n", "self", ".", "expert_bias_constraint", "=", "constraints", ".", "get", "(", "expert_bias_constraint", ")", "\n", "self", ".", "gating_bias_constraint", "=", "constraints", ".", "get", "(", "gating_bias_constraint", ")", "\n", "\n", "self", ".", "activity_regularizer", "=", "regularizers", ".", "get", "(", "activity_regularizer", ")", "\n", "\n", "self", ".", "gating_prior_momentum", "=", "gating_prior_momentum", "\n", "\n", "self", ".", "gating_reduction_axis", "=", "-", "1", "\n", "self", ".", "input_spec", "=", "InputSpec", "(", "min_ndim", "=", "2", ")", "\n", "self", ".", "supports_masking", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.build": [[135, 234], ["DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "tensorflow.python.keras.engine.input_spec.InputSpec", "len", "DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "DenseMoVE.DenseMoVE.add_weight", "tensorflow.initializers.constant", "tensorflow.initializers.constant"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "assert", "len", "(", "input_shape", ")", ">=", "2", "\n", "self", ".", "input_dim", "=", "input_shape", "[", "-", "1", "]", "\n", "self", ".", "sel_input_dim", "=", "input_shape", "[", "-", "1", "]", "\n", "self", ".", "data_dim", "=", "self", ".", "input_dim", "\n", "self", ".", "expert_mu_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "data_dim", ",", "self", ".", "units", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "self", ".", "expert_kernel_initializer", ",", "\n", "name", "=", "'post_expert_mu_kernel'", ",", "\n", "regularizer", "=", "self", ".", "expert_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_kernel_constraint", ")", "\n", "\n", "self", ".", "expert_rho_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "units", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "self", ".", "rho_initializer", ",", "\n", "name", "=", "'post_expert_rho_kernel'", ",", "\n", "regularizer", "=", "self", ".", "expert_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_kernel_constraint", ")", "\n", "\n", "self", ".", "prior_expert_mu_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "data_dim", ",", "self", ".", "units", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "'zeros'", ",", "\n", "name", "=", "'prior_expert_mu_kernel'", ",", "\n", "regularizer", "=", "self", ".", "expert_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_kernel_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "self", ".", "prior_expert_rho_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "units", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "self", ".", "rho_initializer", ",", "\n", "name", "=", "'prior_expert_rho_kernel'", ",", "\n", "regularizer", "=", "self", ".", "expert_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_kernel_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "if", "self", ".", "n_experts", ">", "1", ":", "\n", "\n", "            ", "self", ".", "gating_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "sel_input_dim", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "\"he_uniform\"", ",", "\n", "name", "=", "'post_gating_kernel'", ",", "\n", "regularizer", "=", "self", ".", "gating_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_kernel_constraint", ")", "\n", "\n", "self", ".", "prior_gating_kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "sel_input_dim", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "\"zeros\"", ",", "\n", "name", "=", "'prior_gating_kernel'", ",", "\n", "regularizer", "=", "self", ".", "gating_kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_kernel_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "gating_noise", "=", "None", "\n", "self", ".", "gating_kernel", "=", "None", "\n", "self", ".", "prior_gating_kernel", "=", "None", "\n", "self", ".", "prior_gating", "=", "None", "\n", "self", ".", "old_prior_gating", "=", "None", "\n", "\n", "", "if", "self", ".", "use_expert_bias", ":", "\n", "            ", "self", ".", "expert_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "units", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "self", ".", "expert_bias_initializer", ",", "\n", "name", "=", "'post_expert_bias'", ",", "\n", "regularizer", "=", "self", ".", "expert_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_bias_constraint", ")", "\n", "self", ".", "prior_expert_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "units", ",", "self", ".", "n_experts", ")", ",", "\n", "initializer", "=", "self", ".", "expert_bias_initializer", ",", "\n", "name", "=", "'prior_expert_bias'", ",", "\n", "regularizer", "=", "self", ".", "expert_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "expert_bias_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "expert_bias", "=", "None", "\n", "self", ".", "prior_expert_bias", "=", "None", "\n", "\n", "", "if", "self", ".", "use_gating_bias", "and", "self", ".", "n_experts", ">", "1", ":", "\n", "            ", "self", ".", "gating_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "n_experts", ",", ")", ",", "\n", "initializer", "=", "self", ".", "gating_bias_initializer", ",", "\n", "name", "=", "'post_gating_bias'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ")", "\n", "self", ".", "prior_gating_bias", "=", "self", ".", "add_weight", "(", "shape", "=", "(", "self", ".", "n_experts", ",", ")", ",", "\n", "initializer", "=", "self", ".", "gating_bias_initializer", ",", "\n", "name", "=", "'prior_gating_bias'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "gating_bias", "=", "None", "\n", "self", ".", "prior_gating_bias", "=", "None", "\n", "\n", "", "self", ".", "kl_weight", "=", "self", ".", "add_weight", "(", "shape", "=", "(", ")", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "constant", "(", "self", ".", "expert_beta", ")", ",", "\n", "name", "=", "'kl_weights'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "self", ".", "gating_kl_weight", "=", "self", ".", "add_weight", "(", "shape", "=", "(", ")", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "constant", "(", "self", ".", "gating_beta", ")", ",", "\n", "name", "=", "'gating_kl_weight'", ",", "\n", "regularizer", "=", "self", ".", "gating_bias_regularizer", ",", "\n", "constraint", "=", "self", ".", "gating_bias_constraint", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "self", ".", "input_spec", "=", "InputSpec", "(", "min_ndim", "=", "2", ",", "axes", "=", "{", "-", "1", ":", "self", ".", "input_dim", "}", ")", "\n", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.load_balanced_loss": [[235, 243], ["tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.shape", "tensorflow.reduce_mean", "tensorflow.cast"], "methods", ["None"], ["", "def", "load_balanced_loss", "(", "self", ",", "router_probs", ",", "expert_mask", ")", ":", "\n", "        ", "num_experts", "=", "tf", ".", "shape", "(", "expert_mask", ")", "[", "-", "1", "]", "\n", "density", "=", "tf", ".", "reduce_mean", "(", "expert_mask", ",", "axis", "=", "0", ")", "\n", "density_proxy", "=", "tf", ".", "reduce_mean", "(", "router_probs", ",", "axis", "=", "0", ")", "\n", "loss", "=", "tf", ".", "reduce_mean", "(", "density_proxy", "*", "density", ")", "*", "tf", ".", "cast", "(", "\n", "(", "num_experts", "**", "2", ")", ",", "tf", ".", "dtypes", ".", "float32", "\n", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.call": [[244, 293], ["SparseDispatcher.SparseDispatcher.SparseDispatcher", "SparseDispatcher.SparseDispatcher.SparseDispatcher.dispatch", "SparseDispatcher.SparseDispatcher.SparseDispatcher.expert_to_gates", "DenseMoVE.DenseMoVE.apply_kernels", "DenseMoVE.DenseMoVE.add_loss", "DenseMoVE.DenseMoVE.apply_gating_kernels", "ds.Categorical", "tensorflow.reduce_mean", "DenseMoVE.DenseMoVE.add_loss", "DenseMoVE.DenseMoVE.add_loss", "tensorflow_probability.distributions.Categorical", "tensorflow_probability.distributions.Categorical", "tensorflow.reduce_mean", "DenseMoVE.DenseMoVE.add_loss", "DenseMoVE.DenseMoVE.top_k_gating", "range", "tensorflow.linalg.det", "DenseMoVE.DenseMoVE.add_loss", "tensorflow.ones", "SparseDispatcher.SparseDispatcher.SparseDispatcher.combine", "DenseMoVE.DenseMoVE.entropy_fun", "DenseMoVE.DenseMoVE.kl_div_fun", "range", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.ones", "range", "range", "DenseMoVE.DenseMoVE.wasserstein_dist", "tensorflow.exp", "tensorflow.ones", "tensorflow.shape", "DenseMoVE.DenseMoVE.wasserstein_dist"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.dispatch", "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.expert_to_gates", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.apply_kernels", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.apply_gating_kernels", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.top_k_gating", "home.repos.pwc.inspect_result.hhihn_HVCL.None.SparseDispatcher.SparseDispatcher.combine", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.wasserstein_dist", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.wasserstein_dist"], ["", "def", "call", "(", "self", ",", "inputs", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "self", ".", "n_experts", ">", "1", ":", "\n", "            ", "gating_logits", ",", "activated_gating_outputs", ",", "activated_prior_gating_outputs", ",", "gating_cond_entropy", "=", "self", ".", "apply_gating_kernels", "(", "inputs", ")", "\n", "\n", "# gating entropy penalty", "\n", "batch_gating_prior", "=", "ds", ".", "Categorical", "(", "probs", "=", "tf", ".", "reduce_mean", "(", "activated_gating_outputs", ",", "axis", "=", "0", ",", "keepdims", "=", "True", ")", ")", "\n", "batch_activated_gating_entropy", "=", "tf", ".", "reduce_mean", "(", "self", ".", "entropy_fun", "(", "batch_gating_prior", ")", ")", "\n", "self", ".", "add_loss", "(", "self", ".", "diversity_bonus", "*", "batch_activated_gating_entropy", ")", "\n", "self", ".", "add_loss", "(", "self", ".", "diversity_bonus", "*", "gating_cond_entropy", ")", "\n", "\n", "# gating KL div penalty", "\n", "gating_posterior_dist", "=", "tfp", ".", "distributions", ".", "Categorical", "(", "probs", "=", "activated_gating_outputs", ")", "\n", "gating_prior_dist", "=", "tfp", ".", "distributions", ".", "Categorical", "(", "probs", "=", "activated_prior_gating_outputs", ")", "\n", "kl_loss", "=", "tf", ".", "reduce_mean", "(", "self", ".", "kl_div_fun", "(", "gating_posterior_dist", ",", "gating_prior_dist", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "add_loss", "(", "self", ".", "gating_kl_weight", "*", "kl_loss", ")", "\n", "#", "\n", "gates", "=", "self", ".", "top_k_gating", "(", "gating_logits", ")", "\n", "# balance_loss = self.load_balanced_loss(router_probs=activated_gating_outputs, expert_mask=gates)", "\n", "# self.add_loss(self.diversity_bonus * balance_loss)", "\n", "# expert diversity bonus", "\n", "dkl_mat", "=", "[", "[", "tf", ".", "ones", "(", "shape", "=", "(", ")", ")", "for", "_", "in", "range", "(", "self", ".", "n_experts", ")", "]", "for", "_", "in", "range", "(", "self", ".", "n_experts", ")", "]", "\n", "kernel_width", "=", "self", ".", "kernel_width", "\n", "for", "iexp", "in", "range", "(", "self", ".", "n_experts", ")", ":", "\n", "                ", "for", "jexp", "in", "range", "(", "iexp", ",", "self", ".", "n_experts", ")", ":", "\n", "                    ", "if", "iexp", "!=", "jexp", ":", "\n", "                        ", "dkl_mat", "[", "iexp", "]", "[", "jexp", "]", "=", "self", ".", "wasserstein_dist", "(", "iexp", ",", "jexp", ")", "\n", "dkl_mat", "[", "iexp", "]", "[", "jexp", "]", "=", "tf", ".", "exp", "(", "-", "self", ".", "wasserstein_dist", "(", "iexp", ",", "jexp", ")", "/", "kernel_width", ")", "\n", "dkl_mat", "[", "jexp", "]", "[", "iexp", "]", "=", "dkl_mat", "[", "iexp", "]", "[", "jexp", "]", "\n", "", "else", ":", "\n", "                        ", "dkl_mat", "[", "iexp", "]", "[", "jexp", "]", "=", "tf", ".", "ones", "(", "shape", "=", "(", ")", ")", "\n", "\n", "", "", "", "exp_diversity", "=", "tf", ".", "linalg", ".", "det", "(", "dkl_mat", ")", "\n", "div_bonus", "=", "-", "exp_diversity", "\n", "self", ".", "add_loss", "(", "self", ".", "diversity_bonus", "*", "div_bonus", ")", "\n", "", "else", ":", "\n", "            ", "gates", "=", "tf", ".", "ones", "(", "shape", "=", "(", "tf", ".", "shape", "(", "inputs", ")", "[", "0", "]", ",", "1", ")", ")", "\n", "", "dispatcher", "=", "SparseDispatcher", "(", "self", ".", "n_experts", ",", "gates", ")", "\n", "e_inputs", "=", "dispatcher", ".", "dispatch", "(", "inputs", ")", "\n", "dispatcher", ".", "expert_to_gates", "(", ")", "\n", "\n", "expert_outputs", ",", "approx_expert_dkl", "=", "self", ".", "apply_kernels", "(", "expert_input_tensors", "=", "e_inputs", ")", "\n", "self", ".", "add_loss", "(", "self", ".", "kl_weight", "*", "tf", ".", "reduce_mean", "(", "approx_expert_dkl", ")", ")", "\n", "# Combine Experts", "\n", "if", "self", ".", "n_experts", ">", "1", ":", "\n", "            ", "output", "=", "dispatcher", ".", "combine", "(", "expert_outputs", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "expert_outputs", "[", "0", "]", "\n", "", "return", "output", "# , activated_gating_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm": [[294, 297], ["tensorflow.sqrt", "tensorflow.reduce_sum", "tensorflow.square"], "methods", ["None"], ["", "def", "norm", "(", "self", ",", "x", ")", ":", "\n", "        ", "n", "=", "tf", ".", "sqrt", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "x", ")", ")", "+", "1e-4", ")", "\n", "return", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.wasserstein_dist": [[298, 308], ["tensorflow.math.sqrt", "tensorflow.math.sqrt", "DenseMoVE.DenseMoVE.norm", "tensorflow.square", "tensorflow.norm", "tensorflow.nn.softplus", "tensorflow.nn.softplus"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm"], ["", "def", "wasserstein_dist", "(", "self", ",", "i", ",", "j", ")", ":", "\n", "# Hellinger Distance between diagonal Covariance Matrices", "\n", "        ", "cov_i", "=", "tf", ".", "math", ".", "sqrt", "(", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", "i", "]", ")", "+", "1e-6", ")", "\n", "cov_j", "=", "tf", ".", "math", ".", "sqrt", "(", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", "j", "]", ")", "+", "1e-6", ")", "\n", "cov_trace", "=", "self", ".", "norm", "(", "cov_i", "-", "cov_j", ")", "\n", "# mean over units", "\n", "diff", "=", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", "i", "]", "-", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", "j", "]", "\n", "mu_norm", "=", "tf", ".", "square", "(", "tf", ".", "norm", "(", "diff", ")", ")", "\n", "w", "=", "mu_norm", "+", "cov_trace", "\n", "return", "w", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.entropy": [[309, 314], ["tensorflow.nn.softplus", "tensorflow_probability.distributions.MultivariateNormalDiag", "tensorflow.reduce_sum", "DenseMoVE.DenseMoVE.entropy_fun"], "methods", ["None"], ["", "def", "entropy", "(", "self", ",", "exp", ")", ":", "\n", "        ", "cov_post", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", "exp", "]", ")", "\n", "mu_post", "=", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", "exp", "]", "\n", "expert_kernel_dist", "=", "tfp", ".", "distributions", ".", "MultivariateNormalDiag", "(", "mu_post", ",", "cov_post", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "self", ".", "entropy_fun", "(", "expert_kernel_dist", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.apply_attention": [[315, 327], ["tensorflow.keras.backend.dot", "tensorflow.keras.backend.dot", "tensorflow.python.ops.math_ops.matmul", "tensorflow.nn.softmax", "tensorflow.python.ops.math_ops.matmul", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.keras.layers.concatenate"], "methods", ["None"], ["", "def", "apply_attention", "(", "self", ",", "data", ")", ":", "\n", "        ", "query", "=", "K", ".", "dot", "(", "data", ",", "self", ".", "gating_attn", ")", "\n", "key", "=", "K", ".", "dot", "(", "data", ",", "self", ".", "gating_attn", ")", "\n", "value", "=", "key", "\n", "scores", "=", "math_ops", ".", "matmul", "(", "query", ",", "key", ",", "transpose_b", "=", "True", ")", "\n", "scores", "*=", "self", ".", "scale", "\n", "weights", "=", "tf", ".", "nn", ".", "softmax", "(", "scores", ")", "\n", "self_attn", "=", "math_ops", ".", "matmul", "(", "weights", ",", "value", ")", "\n", "query_encoding", "=", "tf", ".", "reduce_mean", "(", "query", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "\n", "query_value_attention", "=", "tf", ".", "reduce_mean", "(", "self_attn", ",", "axis", "=", "-", "1", ",", "keepdims", "=", "True", ")", "\n", "self_attn", "=", "concatenate", "(", "axis", "=", "-", "1", ",", "inputs", "=", "[", "query_encoding", ",", "query_value_attention", "]", ")", "\n", "return", "self_attn", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.apply_gating_kernels": [[328, 342], ["tensorflow.matmul", "tensorflow.matmul", "DenseMoVE.DenseMoVE.gating_activation", "DenseMoVE.DenseMoVE.gating_activation", "ds.Categorical", "tensorflow.reduce_mean", "tensorflow.keras.backend.bias_add", "tensorflow.keras.backend.bias_add", "DenseMoVE.DenseMoVE.entropy_fun"], "methods", ["None"], ["", "def", "apply_gating_kernels", "(", "self", ",", "inputs", ")", ":", "\n", "\n", "        ", "gating_outputs", "=", "tf", ".", "matmul", "(", "inputs", ",", "self", ".", "gating_kernel", ")", "\n", "prior_gating_outputs", "=", "tf", ".", "matmul", "(", "inputs", ",", "self", ".", "prior_gating_kernel", ")", "\n", "\n", "if", "self", ".", "use_gating_bias", ":", "\n", "            ", "gating_outputs", "=", "K", ".", "bias_add", "(", "gating_outputs", ",", "self", ".", "gating_bias", ")", "\n", "prior_gating_outputs", "=", "K", ".", "bias_add", "(", "prior_gating_outputs", ",", "self", ".", "prior_gating_bias", ")", "\n", "\n", "", "activated_gating_outputs", "=", "self", ".", "gating_activation", "(", "gating_outputs", ")", "\n", "activated_prior_gating_outputs", "=", "self", ".", "gating_activation", "(", "prior_gating_outputs", ")", "\n", "gating_dist", "=", "ds", ".", "Categorical", "(", "probs", "=", "activated_gating_outputs", ")", "\n", "gating_entropy", "=", "tf", ".", "reduce_mean", "(", "self", ".", "entropy_fun", "(", "gating_dist", ")", ")", "\n", "return", "gating_outputs", ",", "activated_gating_outputs", ",", "activated_prior_gating_outputs", ",", "gating_entropy", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.approx_expert_dkl": [[343, 362], ["tensorflow.nn.softplus", "tensorflow.nn.softplus", "tensorflow_probability.distributions.MultivariateNormalDiag", "tensorflow_probability.distributions.MultivariateNormalDiag", "DenseMoVE.DenseMoVE.kl_div_fun", "tensorflow.reduce_mean"], "methods", ["None"], ["", "def", "approx_expert_dkl", "(", "self", ",", "exp", ",", "q", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Computes DKL between p and q\n        :param exp: index of expert distribution\n        :param q: if none, then q is exp's prior\n        :return: DKL as tensor\n        \"\"\"", "\n", "cov_post", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", "exp", "]", ")", "\n", "mu_post", "=", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", "exp", "]", "\n", "\n", "if", "q", "is", "not", "None", ":", "\n", "            ", "exp", "=", "q", "\n", "", "cov_prior", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "prior_expert_rho_kernel", "[", ":", ",", "exp", "]", ")", "\n", "mu_prior", "=", "self", ".", "prior_expert_mu_kernel", "[", ":", ",", ":", ",", "exp", "]", "\n", "expert_kernel_dist", "=", "tfp", ".", "distributions", ".", "MultivariateNormalDiag", "(", "mu_post", ",", "cov_post", ")", "\n", "expert_kernel_dist_prior", "=", "tfp", ".", "distributions", ".", "MultivariateNormalDiag", "(", "mu_prior", ",", "cov_prior", ")", "\n", "kl", "=", "self", ".", "kl_div_fun", "(", "expert_kernel_dist", ",", "expert_kernel_dist_prior", ")", "\n", "kl_loss", "=", "tf", ".", "reduce_mean", "(", "kl", ",", "axis", "=", "-", "1", ")", "\n", "return", "kl_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.top_k_gating": [[363, 370], ["DenseMoVE.DenseMoVE._my_top_k", "tensorflow.slice", "tensorflow.slice", "tensorflow.nn.softmax", "DenseMoVE.DenseMoVE._rowwise_unsorted_segment_sum", "min"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._my_top_k", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._rowwise_unsorted_segment_sum"], ["", "def", "top_k_gating", "(", "self", ",", "gating_logits", ")", ":", "\n", "        ", "top_logits", ",", "top_indices", "=", "self", ".", "_my_top_k", "(", "gating_logits", ",", "min", "(", "self", ".", "k", ",", "self", ".", "n_experts", ")", ")", "\n", "top_k_logits", "=", "tf", ".", "slice", "(", "top_logits", ",", "[", "0", ",", "0", "]", ",", "[", "-", "1", ",", "self", ".", "k", "]", ")", "\n", "top_k_indices", "=", "tf", ".", "slice", "(", "top_indices", ",", "[", "0", ",", "0", "]", ",", "[", "-", "1", ",", "self", ".", "k", "]", ")", "\n", "top_k_gates", "=", "tf", ".", "nn", ".", "softmax", "(", "top_k_logits", ")", "\n", "gates", "=", "self", ".", "_rowwise_unsorted_segment_sum", "(", "top_k_gates", ",", "top_k_indices", ",", "self", ".", "n_experts", ")", "\n", "return", "gates", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.apply_kernels": [[371, 407], ["range", "tensorflow.random.uniform", "tensorflow.cast", "tensorflow.shape", "tensorflow_probability.distributions.Normal().sample", "DenseMoVE.DenseMoVE.apply_kernels.random_rademacher"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample"], ["", "def", "apply_kernels", "(", "self", ",", "expert_input_tensors", ")", ":", "\n", "\n", "        ", "def", "random_rademacher", "(", "shape", ",", "dtype", "=", "tf", ".", "float64", ",", "seed", "=", "None", ")", ":", "\n", "            ", "int_dtype", "=", "tf", ".", "int64", "if", "tf", ".", "as_dtype", "(", "dtype", ")", "!=", "tf", ".", "int32", "else", "tf", ".", "int32", "\n", "random_bernoulli", "=", "tf", ".", "random", ".", "uniform", "(", "\n", "shape", ",", "minval", "=", "0", ",", "maxval", "=", "2", ",", "dtype", "=", "int_dtype", ",", "seed", "=", "seed", ")", "\n", "return", "tf", ".", "cast", "(", "2", "*", "random_bernoulli", "-", "1", ",", "dtype", ")", "\n", "\n", "", "expert_outputs", "=", "[", "]", "\n", "expert_kls", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_experts", ")", ":", "\n", "            ", "expert_input", "=", "expert_input_tensors", "[", "i", "]", "\n", "input_shape", "=", "tf", ".", "shape", "(", "expert_input", ")", "\n", "batch_shape", "=", "input_shape", "[", ":", "-", "1", "]", "\n", "posterior_affine_tensor", "=", "tfp", ".", "distributions", ".", "Normal", "(", "\n", "loc", "=", "tf", ".", "zeros_like", "(", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", "i", "]", ")", ",", "\n", "scale", "=", "tf", ".", "nn", ".", "softplus", "(", "self", ".", "expert_rho_kernel", "[", ":", ",", "i", "]", ")", ")", ".", "sample", "(", ")", "\n", "sign_input", "=", "random_rademacher", "(", "\n", "input_shape", ",", "\n", "dtype", "=", "expert_input", ".", "dtype", ")", "\n", "sign_output", "=", "random_rademacher", "(", "\n", "tf", ".", "concat", "(", "[", "batch_shape", ",", "\n", "tf", ".", "expand_dims", "(", "self", ".", "units", ",", "0", ")", "]", ",", "0", ")", ",", "\n", "dtype", "=", "expert_input", ".", "dtype", ")", "\n", "perturbed_inputs", "=", "tf", ".", "matmul", "(", "expert_input", "*", "sign_input", ",", "posterior_affine_tensor", ")", "*", "sign_output", "\n", "\n", "out", "=", "tf", ".", "matmul", "(", "expert_input", ",", "self", ".", "expert_mu_kernel", "[", ":", ",", ":", ",", "i", "]", ")", "\n", "out", "+=", "perturbed_inputs", "\n", "if", "self", ".", "use_expert_bias", ":", "\n", "                ", "out", "=", "out", "+", "self", ".", "expert_bias", "[", ":", ",", "i", "]", "\n", "", "if", "self", ".", "expert_activation", "is", "not", "None", ":", "\n", "                ", "out", "=", "self", ".", "expert_activation", "(", "out", ")", "\n", "", "expert_outputs", ".", "append", "(", "out", ")", "\n", "exp_kl", "=", "self", ".", "approx_expert_dkl", "(", "exp", "=", "i", ")", "\n", "expert_kls", ".", "append", "(", "exp_kl", ")", "\n", "", "return", "expert_outputs", ",", "expert_kls", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.compute_output_shape": [[408, 414], ["list", "tuple", "len"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "assert", "input_shape", "and", "len", "(", "input_shape", ")", ">=", "2", "\n", "assert", "input_shape", "[", "-", "1", "]", "\n", "output_shape", "=", "list", "(", "input_shape", ")", "\n", "output_shape", "[", "-", "1", "]", "=", "self", ".", "units", "\n", "return", "tuple", "(", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._assign_moving_average": [[415, 424], ["tensorflow.keras.backend.name_scope", "tensorflow.python.framework.ops.colocate_with", "tensorflow.python.ops.state_ops.assign_sub", "tensorflow.python.ops.array_ops.where", "tensorflow.python.ops.math_ops.cast", "tensorflow.keras.backend.zeros_like"], "methods", ["None"], ["", "def", "_assign_moving_average", "(", "self", ",", "variable", ",", "value", ",", "momentum", ",", "inputs_size", "=", "None", ")", ":", "\n", "        ", "with", "K", ".", "name_scope", "(", "'AssignMovingAvg'", ")", "as", "scope", ":", "\n", "            ", "with", "ops", ".", "colocate_with", "(", "variable", ")", ":", "\n", "                ", "decay", "=", "1.0", "-", "momentum", "\n", "update_delta", "=", "(", "variable", "-", "math_ops", ".", "cast", "(", "value", ",", "variable", ".", "dtype", ")", ")", "*", "decay", "\n", "if", "inputs_size", "is", "not", "None", ":", "\n", "                    ", "update_delta", "=", "array_ops", ".", "where", "(", "inputs_size", ">", "0", ",", "update_delta", ",", "\n", "K", ".", "zeros_like", "(", "update_delta", ")", ")", "\n", "", "return", "state_ops", ".", "assign_sub", "(", "variable", ",", "update_delta", ",", "name", "=", "scope", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.get_config": [[425, 452], ["super().get_config", "dict", "tensorflow.keras.activations.serialize", "tensorflow.keras.activations.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.initializers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.regularizers.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.constraints.serialize", "tensorflow.keras.regularizers.serialize", "list", "list", "super().get_config.items", "config.items"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.get_config"], ["", "", "", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "{", "\n", "'units'", ":", "self", ".", "units", ",", "\n", "'n_experts'", ":", "self", ".", "n_experts", ",", "\n", "'expert_activation'", ":", "activations", ".", "serialize", "(", "self", ".", "expert_activation", ")", ",", "\n", "'gating_activation'", ":", "activations", ".", "serialize", "(", "self", ".", "gating_activation", ")", ",", "\n", "'use_expert_bias'", ":", "self", ".", "use_expert_bias", ",", "\n", "'use_gating_bias'", ":", "self", ".", "use_gating_bias", ",", "\n", "'expert_bias_initializer'", ":", "initializers", ".", "serialize", "(", "self", ".", "expert_bias_initializer", ")", ",", "\n", "'gating_bias_initializer'", ":", "initializers", ".", "serialize", "(", "self", ".", "gating_bias_initializer", ")", ",", "\n", "'expert_kernel_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "expert_kernel_regularizer", ")", ",", "\n", "'gating_kernel_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "gating_kernel_regularizer", ")", ",", "\n", "'expert_bias_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "expert_bias_regularizer", ")", ",", "\n", "'gating_bias_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "gating_bias_regularizer", ")", ",", "\n", "'expert_kernel_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "expert_kernel_constraint", ")", ",", "\n", "'gating_kernel_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "gating_kernel_constraint", ")", ",", "\n", "'expert_bias_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "expert_bias_constraint", ")", ",", "\n", "'gating_bias_constraint'", ":", "constraints", ".", "serialize", "(", "self", ".", "gating_bias_constraint", ")", ",", "\n", "'activity_regularizer'", ":", "regularizers", ".", "serialize", "(", "self", ".", "activity_regularizer", ")", ",", "\n", "'gating_beta'", ":", "self", ".", "gating_beta", ",", "\n", "'expert_beta'", ":", "self", ".", "expert_beta", ",", "\n", "'diversity_bonus'", ":", "self", ".", "diversity_bonus", ",", "\n", "'k'", ":", "self", ".", "k", ",", "\n", "'n_monte_carlo'", ":", "self", ".", "n_monte_carlo", ",", "\n", "}", "\n", "base_config", "=", "super", "(", "DenseMoVE", ",", "self", ")", ".", "get_config", "(", ")", "\n", "return", "dict", "(", "list", "(", "base_config", ".", "items", "(", ")", ")", "+", "list", "(", "config", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._softplus_inverse": [[453, 456], ["numpy.log", "numpy.exp"], "methods", ["None"], ["", "def", "_softplus_inverse", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Helper which computes the function inverse of `tf.nn.softplus`.\"\"\"", "\n", "return", "np", ".", "log", "(", "np", ".", "exp", "(", "x", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._my_top_k": [[457, 489], ["range", "tensorflow.math.top_k", "tensorflow.shape", "indices.append", "tensorflow.stack", "tensorflow.cast", "tensorflow.argmax", "values.append", "ds.Categorical", "ds.Categorical.sample", "values.append", "tensorflow.one_hot", "tensorflow.stack", "tensorflow.reduce_max", "ds.Categorical.log_prob"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample"], ["", "def", "_my_top_k", "(", "self", ",", "x", ",", "k", ",", "soft", "=", "True", ")", ":", "\n", "        ", "\"\"\"GPU-compatible version of top-k that works for very small constant k.\n        Calls argmax repeatedly.\n        tf.nn.top_k is implemented for GPU, but the gradient, sparse_to_dense,\n        seems not to be, so if we use tf.nn.top_k, then both the top_k and its\n        gradient go on cpu.  Once this is not an issue, this function becomes\n        obsolete and should be replaced by tf.nn.top_k.\n        Args:\n        x: a 2d Tensor.\n        k: a small integer.\n        soft: sample or use argmax\n        Returns:\n        values: a Tensor of shape [batch_size, k]\n        indices: a int32 Tensor of shape [batch_size, k]\n        \"\"\"", "\n", "if", "k", ">", "10", ":", "\n", "            ", "return", "tf", ".", "math", ".", "top_k", "(", "x", ",", "k", ")", "\n", "", "values", "=", "[", "]", "\n", "indices", "=", "[", "]", "\n", "depth", "=", "tf", ".", "shape", "(", "x", ")", "[", "1", "]", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "            ", "if", "not", "soft", ":", "\n", "                ", "idx", "=", "tf", ".", "argmax", "(", "x", ",", "1", ")", "\n", "values", ".", "append", "(", "tf", ".", "reduce_max", "(", "x", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "dist", "=", "ds", ".", "Categorical", "(", "logits", "=", "x", ")", "\n", "idx", "=", "dist", ".", "sample", "(", ")", "\n", "values", ".", "append", "(", "dist", ".", "log_prob", "(", "idx", ")", ")", "\n", "", "indices", ".", "append", "(", "idx", ")", "\n", "if", "i", "+", "1", "<", "k", ":", "\n", "                ", "x", "+=", "tf", ".", "one_hot", "(", "idx", ",", "depth", ",", "-", "1e9", ")", "\n", "", "", "return", "tf", ".", "stack", "(", "values", ",", "axis", "=", "1", ")", ",", "tf", ".", "cast", "(", "tf", ".", "stack", "(", "indices", ",", "axis", "=", "1", ")", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._rowwise_unsorted_segment_sum": [[490, 503], ["tensorflow.unstack", "tensorflow.math.unsorted_segment_sum", "tensorflow.reshape", "tensorflow.shape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.cast", "tensorflow.divide", "tensorflow.range"], "methods", ["None"], ["", "def", "_rowwise_unsorted_segment_sum", "(", "self", ",", "values", ",", "indices", ",", "n", ")", ":", "\n", "        ", "\"\"\"UnsortedSegmentSum on each row.\n        Args:\n        values: a `Tensor` with shape `[batch_size, k]`.\n        indices: an integer `Tensor` with shape `[batch_size, k]`.\n        n: an integer.\n        Returns:\n        A `Tensor` with the same type as `values` and shape `[batch_size, n]`.\n        \"\"\"", "\n", "batch", ",", "k", "=", "tf", ".", "unstack", "(", "tf", ".", "shape", "(", "indices", ")", ",", "num", "=", "2", ")", "\n", "indices_flat", "=", "tf", ".", "reshape", "(", "indices", ",", "[", "-", "1", "]", ")", "+", "tf", ".", "cast", "(", "tf", ".", "divide", "(", "tf", ".", "range", "(", "batch", "*", "k", ")", ",", "k", ")", ",", "dtype", "=", "tf", ".", "int32", ")", "*", "n", "\n", "ret_flat", "=", "tf", ".", "math", ".", "unsorted_segment_sum", "(", "tf", ".", "reshape", "(", "values", ",", "[", "-", "1", "]", ")", ",", "indices_flat", ",", "batch", "*", "n", ")", "\n", "return", "tf", ".", "reshape", "(", "ret_flat", ",", "[", "batch", ",", "n", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._prob_in_top_k": [[504, 544], ["tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.greater", "tensorflow.expand_dims", "DenseMoVE.DenseMoVE._normal_distribution_cdf", "DenseMoVE.DenseMoVE._normal_distribution_cdf", "tensorflow.where", "tensorflow.shape", "tensorflow.shape", "tensorflow.gather", "tensorflow.cast", "tensorflow.gather", "tensorflow.range"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._normal_distribution_cdf", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._normal_distribution_cdf"], ["", "def", "_prob_in_top_k", "(", "self", ",", "clean_values", ",", "noisy_values", ",", "noise_stddev", ",", "noisy_top_values", ",", "k", ")", ":", "\n", "        ", "\"\"\"Helper function to NoisyTopKGating.\n        Computes the probability that value is in top k, given different random noise.\n        This gives us a way of backpropagating from a loss that balances the number\n        of times each expert is in the top k experts per example.\n        In the case of no noise, pass in None for noise_stddev, and the result will\n        not be differentiable.\n        Args:\n          clean_values: a `Tensor` of shape [batch, n].\n          noisy_values: a `Tensor` of shape [batch, n].  Equal to clean values plus\n            normally distributed noise with standard deviation noise_stddev.\n          noise_stddev: a `Tensor` of shape [batch, n], or None\n          noisy_top_values: a `Tensor` of shape [batch, m].\n             \"values\" Output of tf.top_k(noisy_top_values, m).  m >= k+1\n          k: an integer.\n        Returns:\n          a `Tensor` of shape [batch, n].\n        \"\"\"", "\n", "batch", "=", "tf", ".", "shape", "(", "clean_values", ")", "[", "0", "]", "\n", "m", "=", "tf", ".", "shape", "(", "noisy_top_values", ")", "[", "1", "]", "\n", "top_values_flat", "=", "tf", ".", "reshape", "(", "noisy_top_values", ",", "[", "-", "1", "]", ")", "\n", "# we want to compute the threshold that a particular value would have to", "\n", "# exceed in order to make the top k.  This computation differs depending", "\n", "# on whether the value is already in the top k.", "\n", "threshold_positions_if_in", "=", "tf", ".", "range", "(", "batch", ")", "*", "m", "+", "k", "\n", "threshold_if_in", "=", "tf", ".", "expand_dims", "(", "\n", "tf", ".", "gather", "(", "top_values_flat", ",", "threshold_positions_if_in", ")", ",", "1", ")", "\n", "is_in", "=", "tf", ".", "greater", "(", "noisy_values", ",", "threshold_if_in", ")", "\n", "if", "noise_stddev", "is", "None", ":", "\n", "            ", "return", "tf", ".", "cast", "(", "is_in", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "", "threshold_positions_if_out", "=", "threshold_positions_if_in", "-", "1", "\n", "threshold_if_out", "=", "tf", ".", "expand_dims", "(", "\n", "tf", ".", "gather", "(", "top_values_flat", ",", "threshold_positions_if_out", ")", ",", "1", ")", "\n", "# is each value currently in the top k.", "\n", "prob_if_in", "=", "self", ".", "_normal_distribution_cdf", "(", "clean_values", "-", "threshold_if_in", ",", "\n", "noise_stddev", ")", "\n", "prob_if_out", "=", "self", ".", "_normal_distribution_cdf", "(", "clean_values", "-", "threshold_if_out", ",", "\n", "noise_stddev", ")", "\n", "prob", "=", "tf", ".", "where", "(", "is_in", ",", "prob_if_in", ",", "prob_if_out", ")", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE._normal_distribution_cdf": [[545, 557], ["tensorflow.math.erf", "tensorflow.math.sqrt"], "methods", ["None"], ["", "def", "_normal_distribution_cdf", "(", "self", ",", "x", ",", "stddev", ")", ":", "\n", "        ", "\"\"\"Evaluates the CDF of the normal distribution.\n      Normal distribution with mean 0 and standard deviation stddev,\n      evaluated at x=x.\n      input and output `Tensor`s have matching shapes.\n      Args:\n        x: a `Tensor`\n        stddev: a `Tensor` with the same shape as `x`.\n      Returns:\n        a `Tensor` with the same shape as `x`.\n      \"\"\"", "\n", "return", "0.5", "*", "(", "1.0", "+", "tf", ".", "math", ".", "erf", "(", "x", "/", "(", "tf", ".", "math", ".", "sqrt", "(", "2.0", ")", "*", "stddev", "+", "1e-20", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.cv_squared": [[558, 573], ["tensorflow.cast", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.size", "tensorflow.math.squared_difference", "tensorflow.square"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "cv_squared", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"The squared coefficient of variation of a sample.\n        Useful as a loss to encourage a positive distribution to be more uniform.\n        Epsilons added for numerical stability.\n        Returns 0 for an empty Tensor.\n        Args:\n          x: a `Tensor`.\n        Returns:\n          a `Scalar`.\n        \"\"\"", "\n", "epsilon", "=", "1e-10", "\n", "float_size", "=", "tf", ".", "cast", "(", "tf", ".", "size", "(", "x", ")", ",", "dtype", "=", "tf", ".", "float64", ")", "+", "epsilon", "\n", "mean", "=", "tf", ".", "reduce_sum", "(", "x", ")", "/", "float_size", "\n", "variance", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "math", ".", "squared_difference", "(", "x", ",", "mean", ")", ")", "/", "float_size", "\n", "return", "variance", "/", "(", "tf", ".", "square", "(", "mean", ")", "+", "epsilon", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.arguments.get_args": [[4, 85], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "get_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Continual'", ")", "\n", "# Arguments", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'(default=%(default)d)'", ")", "\n", "parser", ".", "add_argument", "(", "'--experiment'", ",", "default", "=", "''", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "choices", "=", "[", "'mnist2'", ",", "\n", "'pmnist'", ",", "\n", "'split_pmnist'", ",", "\n", "'row_pmnist'", ",", "\n", "'mixture'", ",", "\n", "'omniglot'", ",", "\n", "'split_mnist'", ",", "\n", "'split_notmnist'", ",", "\n", "'split_row_pmnist'", ",", "\n", "'split_cifar10_100'", ",", "\n", "'split_cifar100'", ",", "\n", "'split_cifar100_20'", ",", "\n", "'split_CUB200'", ",", "\n", "'split_tiny_imagenet'", ",", "\n", "'split_mini_imagenet'", ",", "\n", "'split_cifar10'", "]", ",", "\n", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "'--approach'", ",", "default", "=", "''", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "choices", "=", "[", "'random'", ",", "\n", "'sgd'", ",", "\n", "'sgd-frozen'", ",", "\n", "'sgd_with_log'", ",", "\n", "'sgd_L2_with_log'", ",", "\n", "'lwf'", ",", "'lwf_with_log'", ",", "\n", "'lfl'", ",", "\n", "'ewc'", ",", "\n", "'si'", ",", "\n", "'rwalk'", ",", "\n", "'mas'", ",", "\n", "'ucl'", ",", "\n", "'ucl_ablation'", ",", "\n", "'baye_fisher'", ",", "\n", "'baye_hat'", ",", "\n", "'imm-mean'", ",", "\n", "'progressive'", ",", "\n", "'pathnet'", ",", "\n", "'imm-mode'", ",", "\n", "'sgd-restart'", ",", "\n", "'joint'", ",", "\n", "'hat'", ",", "\n", "'hat-test'", "]", ",", "\n", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "'--optimizer'", ",", "default", "=", "'Adam'", ",", "type", "=", "str", ",", "required", "=", "False", ",", "\n", "choices", "=", "[", "'SGD'", ",", "\n", "'SGD_momentum_decay'", ",", "\n", "'Adam'", "]", ",", "\n", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "'--ablation'", ",", "default", "=", "'None'", ",", "type", "=", "str", ",", "required", "=", "False", ",", "\n", "choices", "=", "[", "'no_L1'", ",", "\n", "'no_upper'", ",", "\n", "'no_lower'", ",", "\n", "'no_sigma_normal'", ",", "\n", "'None'", "]", ",", "\n", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "'--output'", ",", "default", "=", "''", ",", "type", "=", "str", ",", "required", "=", "False", ",", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "'--nepochs'", ",", "default", "=", "100", ",", "type", "=", "int", ",", "required", "=", "False", ",", "help", "=", "'(default=%(default)d)'", ")", "\n", "parser", ".", "add_argument", "(", "'--unitN'", ",", "default", "=", "400", ",", "type", "=", "int", ",", "required", "=", "False", ",", "help", "=", "'(default=%(default)d)'", ")", "\n", "parser", ".", "add_argument", "(", "'--batch-size'", ",", "default", "=", "256", ",", "type", "=", "int", ",", "required", "=", "False", ",", "help", "=", "'(default=%(default)d)'", ")", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "default", "=", "0.001", ",", "type", "=", "float", ",", "required", "=", "False", ",", "help", "=", "'(default=%(default)f)'", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_rho'", ",", "default", "=", "0.001", ",", "type", "=", "float", ",", "required", "=", "False", ",", "help", "=", "'(default=%(default)f)'", ")", "\n", "parser", ".", "add_argument", "(", "'--ratio'", ",", "default", "=", "'0.5'", ",", "type", "=", "float", ",", "help", "=", "'(default=%(default)f)'", ")", "\n", "parser", ".", "add_argument", "(", "'--alpha'", ",", "default", "=", "0.01", ",", "type", "=", "float", ",", "help", "=", "'(default=%(default)f)'", ")", "\n", "parser", ".", "add_argument", "(", "'--beta'", ",", "default", "=", "'0.03'", ",", "type", "=", "float", ",", "help", "=", "'(default=%(default)f)'", ")", "\n", "parser", ".", "add_argument", "(", "'--gamma'", ",", "default", "=", "0.75", ",", "type", "=", "float", ",", "help", "=", "'(default=%(default)f)'", ")", "\n", "parser", ".", "add_argument", "(", "'--smax'", ",", "default", "=", "400", ",", "type", "=", "float", ",", "help", "=", "'(default=%(default)f)'", ")", "\n", "parser", ".", "add_argument", "(", "'--lamb'", ",", "default", "=", "'1'", ",", "type", "=", "float", ",", "help", "=", "'(default=%(default)f)'", ")", "\n", "parser", ".", "add_argument", "(", "'--c'", ",", "default", "=", "'0.9'", ",", "type", "=", "float", ",", "help", "=", "'(default=%(default)f)'", ")", "\n", "parser", ".", "add_argument", "(", "'--date'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "'--tasknum'", ",", "default", "=", "50", ",", "type", "=", "int", ",", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "'--conv-net'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "'Using convolution network'", ")", "\n", "parser", ".", "add_argument", "(", "'--rebuttal'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "'Using convolution network'", ")", "\n", "parser", ".", "add_argument", "(", "'--parameter'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "'--sample'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'Using sigma max to support coefficient'", ")", "\n", "parser", ".", "add_argument", "(", "'--rho'", ",", "type", "=", "float", ",", "default", "=", "-", "2.783", ",", "help", "=", "'initial rho'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.plot.normalize": [[9, 17], ["print", "print", "numpy.max", "print", "len"], "function", ["None"], ["def", "normalize", "(", "x", ",", "i", ")", ":", "\n", "    ", "print", "(", "x", ")", "\n", "step", "=", "len", "(", "x", ")", "//", "5", "\n", "print", "(", "\"step\"", ",", "step", ")", "\n", "train_data", "=", "x", "[", "i", "*", "step", ":", "(", "i", "+", "1", ")", "*", "step", "]", "\n", "norm", "=", "np", ".", "max", "(", "train_data", ")", "\n", "print", "(", "\"train_data\"", ",", "train_data", ".", "shape", ",", "train_data", ",", "norm", ")", "\n", "return", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.plot.clip_to_one": [[19, 24], ["range", "len"], "function", ["None"], ["", "def", "clip_to_one", "(", "data", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "len", "(", "data", ")", ")", ":", "\n", "        ", "if", "data", "[", "i", "]", ">", "0", ":", "\n", "            ", "data", "[", "i", "]", "=", "1", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.arguments_rl.get_args": [[6, 227], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "torch.cuda.is_available"], "function", ["None"], ["def", "get_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'RL'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--algo'", ",", "default", "=", "'ppo'", ",", "help", "=", "'algorithm to use: a2c | ppo | acktr'", ")", "\n", "parser", ".", "add_argument", "(", "'--approach'", ",", "default", "=", "'ucl'", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "choices", "=", "[", "'fine-tuning'", ",", "\n", "'ewc'", ",", "\n", "'ucl'", ",", "]", ",", "\n", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "'--experiment'", ",", "default", "=", "'roboschool'", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "choices", "=", "[", "'roboschool'", ",", "]", ",", "\n", "help", "=", "'(default=%(default)s)'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--optimizer'", ",", "default", "=", "'Adam'", ",", "type", "=", "str", ",", "required", "=", "False", ",", "\n", "choices", "=", "[", "'Adam'", ",", "]", ",", "\n", "help", "=", "'(default=%(default)s)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--gail'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "default", "=", "False", ",", "\n", "help", "=", "'do imitation learning with gail'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--gail-experts-dir'", ",", "\n", "default", "=", "'./gail_experts'", ",", "\n", "help", "=", "'directory that contains expert demonstrations for gail'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--gail-batch-size'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "128", ",", "\n", "help", "=", "'gail batch size (default: 128)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--gail-epoch'", ",", "type", "=", "int", ",", "default", "=", "5", ",", "help", "=", "'gail epochs (default: 5)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--lr'", ",", "type", "=", "float", ",", "default", "=", "3e-4", ",", "help", "=", "'learning rate (default: 3e-4)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--eps'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "1e-5", ",", "\n", "help", "=", "'RMSprop optimizer epsilon (default: 1e-5)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--alpha'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.99", ",", "\n", "help", "=", "'RMSprop optimizer apha (default: 0.99)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--gamma'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.99", ",", "\n", "help", "=", "'discount factor for rewards (default: 0.99)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--use-gae'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "default", "=", "True", ",", "\n", "help", "=", "'use generalized advantage estimation'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--gae-lambda'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.95", ",", "\n", "help", "=", "'gae lambda parameter (default: 0.95)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--entropy-coef'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.0", ",", "\n", "help", "=", "'entropy term coefficient (default: 0.0)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--value-loss-coef'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.5", ",", "\n", "help", "=", "'value loss coefficient (default: 0.5)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--max-grad-norm'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.5", ",", "\n", "help", "=", "'max norm of gradients (default: 0.5)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'random seed (default: 1)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--cuda-deterministic'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "default", "=", "False", ",", "\n", "help", "=", "\"sets flags for determinism when using CUDA (potentially slow!)\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--num-processes'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "128", ",", "\n", "help", "=", "'how many training CPU processes to use (default: 128)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--num-steps'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "64", ",", "\n", "help", "=", "'number of forward steps in A2C (default: 64)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--ppo-epoch'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "10", ",", "\n", "help", "=", "'number of ppo epochs (default: 10)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--num-mini-batch'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "64", ",", "\n", "help", "=", "'number of batches for ppo (default: 64)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--clip-param'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.2", ",", "\n", "help", "=", "'ppo clip parameter (default: 0.2)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\n", "'--log-interval'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "'log interval, one log per n updates (default: 100)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--save-interval'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "'save interval, one save per n updates (default: 100)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--eval-interval'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "10", ",", "\n", "help", "=", "'eval interval, one eval per n updates (default: 10)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--num-env-steps'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "5000000", ",", "\n", "help", "=", "'number of environment steps to train (default: 5000000)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--env-name'", ",", "\n", "default", "=", "'PongNoFrameskip-v4'", ",", "\n", "help", "=", "'environment to train on (default: PongNoFrameskip-v4)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--single-task'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "default", "=", "False", ",", "\n", "help", "=", "\"use a single task for training and evaluation\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--log-dir'", ",", "\n", "default", "=", "'./logs/'", ",", "\n", "help", "=", "'directory to save agent logs (default: /tmp/gym)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--save-dir'", ",", "\n", "default", "=", "'./trained_models/'", ",", "\n", "help", "=", "'directory to save agent logs (default: ./trained_models/)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--no-cuda'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "default", "=", "False", ",", "\n", "help", "=", "'disables CUDA training'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--use-proper-time-limits'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "default", "=", "False", ",", "\n", "help", "=", "'compute returns taking into account time limits'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--recurrent-policy'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "default", "=", "False", ",", "\n", "help", "=", "'use a recurrent policy'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--use-linear-lr-decay'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "default", "=", "True", ",", "\n", "help", "=", "'use a linear schedule on the learning rate'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--ewc-lambda'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "5000", ",", "\n", "help", "=", "'lambda for EWC'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--ewc-online'", ",", "\n", "default", "=", "False", ",", "\n", "help", "=", "'True == online EWC'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--ewc-epochs'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "100", ",", "\n", "help", "=", "'epochs for EWC'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--num-ewc-steps'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "20", ",", "\n", "help", "=", "'epochs for EWC'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--save-name'", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'savename for tensorboard'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--ucl-rho'", ",", "\n", "default", "=", "-", "2.2522", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'savename for tensorboard'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--ucl-beta'", ",", "\n", "default", "=", "0.001", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'savename for tensorboard'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--date'", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'savename for tensorboard'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--task_id'", ",", "\n", "default", "=", "None", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'task_id'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--input-padding'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "'apply no sampling'", ")", "\n", "parser", ".", "add_argument", "(", "'--sample'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "'apply no sampling'", ")", "\n", "parser", ".", "add_argument", "(", "'--samples'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'no of samples to sample'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "args", ".", "cuda", "=", "not", "args", ".", "no_cuda", "and", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "\n", "assert", "args", ".", "algo", "in", "[", "'a2c'", ",", "'ppo'", ",", "'acktr'", "]", "\n", "if", "args", ".", "recurrent_policy", ":", "\n", "        ", "assert", "args", ".", "algo", "in", "[", "'a2c'", ",", "'ppo'", "]", ",", "'Recurrent policy is not implemented for ACKTR'", "\n", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.bayes_layer.Gaussian.__init__": [[29, 34], ["object.__init__", "mu.cuda", "rho.cuda", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "mu", ",", "rho", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mu", "=", "mu", ".", "cuda", "(", ")", "\n", "self", ".", "rho", "=", "rho", ".", "cuda", "(", ")", "\n", "self", ".", "normal", "=", "torch", ".", "distributions", ".", "Normal", "(", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.bayes_layer.Gaussian.sigma": [[35, 38], ["torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "@", "property", "\n", "def", "sigma", "(", "self", ")", ":", "\n", "        ", "return", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "self", ".", "rho", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.bayes_layer.Gaussian.sample": [[39, 42], ["bayes_layer.Gaussian.normal.sample().cuda", "bayes_layer.Gaussian.normal.sample", "bayes_layer.Gaussian.mu.size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "sample", "(", "self", ")", ":", "\n", "        ", "epsilon", "=", "self", ".", "normal", ".", "sample", "(", "self", ".", "mu", ".", "size", "(", ")", ")", ".", "cuda", "(", ")", "\n", "return", "self", ".", "mu", "+", "self", ".", "sigma", "*", "epsilon", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.bayes_layer.BayesianLinear.__init__": [[44, 68], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "bayes_layer._calculate_fan_in_and_fan_out", "numpy.log", "torch.init.uniform_", "torch.init.uniform_", "torch.init.uniform_", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "bayes_layer.Gaussian", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "numpy.exp", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer._calculate_fan_in_and_fan_out"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "ratio", "=", "0.5", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "\n", "self", ".", "weight_mu", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_features", ",", "in_features", ")", ")", "\n", "\n", "fan_in", ",", "_", "=", "_calculate_fan_in_and_fan_out", "(", "self", ".", "weight_mu", ")", "\n", "gain", "=", "1", "# Var[w] + sigma^2 = 2/fan_in", "\n", "\n", "total_var", "=", "2", "/", "fan_in", "\n", "noise_var", "=", "total_var", "*", "ratio", "\n", "mu_var", "=", "total_var", "-", "noise_var", "\n", "\n", "noise_std", ",", "mu_std", "=", "math", ".", "sqrt", "(", "noise_var", ")", ",", "math", ".", "sqrt", "(", "mu_var", ")", "\n", "bound", "=", "math", ".", "sqrt", "(", "3.0", ")", "*", "mu_std", "\n", "rho_init", "=", "np", ".", "log", "(", "np", ".", "exp", "(", "noise_std", ")", "-", "1", ")", "\n", "\n", "nn", ".", "init", ".", "uniform_", "(", "self", ".", "weight_mu", ",", "-", "bound", ",", "bound", ")", "\n", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_features", ")", ".", "uniform_", "(", "0", ",", "0", ")", ")", "\n", "\n", "self", ".", "weight_rho", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_features", ",", "1", ")", ".", "uniform_", "(", "rho_init", ",", "rho_init", ")", ")", "\n", "\n", "self", ".", "weight", "=", "Gaussian", "(", "self", ".", "weight_mu", ",", "self", ".", "weight_rho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.bayes_layer.BayesianLinear.forward": [[69, 78], ["torch.linear", "torch.linear", "torch.linear", "bayes_layer.BayesianLinear.weight.sample"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample"], ["", "def", "forward", "(", "self", ",", "input", ",", "sample", "=", "False", ")", ":", "\n", "        ", "if", "sample", ":", "\n", "            ", "weight", "=", "self", ".", "weight", ".", "sample", "(", ")", "\n", "bias", "=", "self", ".", "bias", "\n", "", "else", ":", "\n", "            ", "weight", "=", "self", ".", "weight", ".", "mu", "\n", "bias", "=", "self", ".", "bias", "\n", "\n", "", "return", "F", ".", "linear", "(", "input", ",", "weight", ",", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.bayes_layer._BayesianConvNd.__init__": [[81, 115], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "bayes_layer._calculate_fan_in_and_fan_out", "numpy.log", "torch.init.uniform_", "torch.init.uniform_", "torch.init.uniform_", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "bayes_layer.Gaussian", "ValueError", "ValueError", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "numpy.exp", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer._calculate_fan_in_and_fan_out"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "\n", "stride", ",", "padding", ",", "dilation", ",", "transposed", ",", "output_padding", ",", "groups", ",", "bias", ",", "ratio", ")", ":", "\n", "        ", "super", "(", "_BayesianConvNd", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "in_channels", "%", "groups", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'in_channels must be divisible by groups'", ")", "\n", "", "if", "out_channels", "%", "groups", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'out_channels must be divisible by groups'", ")", "\n", "", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "transposed", "=", "transposed", "\n", "self", ".", "output_padding", "=", "output_padding", "\n", "self", ".", "groups", "=", "groups", "\n", "\n", "self", ".", "weight_mu", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_channels", ",", "in_channels", "//", "groups", ",", "*", "kernel_size", ")", ")", "\n", "\n", "_", ",", "fan_out", "=", "_calculate_fan_in_and_fan_out", "(", "self", ".", "weight_mu", ")", "\n", "total_var", "=", "2", "/", "fan_out", "\n", "noise_var", "=", "total_var", "*", "ratio", "\n", "mu_var", "=", "total_var", "-", "noise_var", "\n", "\n", "noise_std", ",", "mu_std", "=", "math", ".", "sqrt", "(", "noise_var", ")", ",", "math", ".", "sqrt", "(", "mu_var", ")", "\n", "bound", "=", "math", ".", "sqrt", "(", "3.0", ")", "*", "mu_std", "\n", "rho_init", "=", "np", ".", "log", "(", "np", ".", "exp", "(", "noise_std", ")", "-", "1", ")", "\n", "\n", "nn", ".", "init", ".", "uniform_", "(", "self", ".", "weight_mu", ",", "-", "bound", ",", "bound", ")", "\n", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_channels", ")", ".", "uniform_", "(", "0", ",", "0", ")", ",", "requires_grad", "=", "bias", ")", "\n", "\n", "self", ".", "weight_rho", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_channels", ",", "1", ",", "1", ",", "1", ")", ".", "uniform_", "(", "rho_init", ",", "rho_init", ")", ")", "\n", "\n", "self", ".", "weight", "=", "Gaussian", "(", "self", ".", "weight_mu", ",", "self", ".", "weight_rho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.bayes_layer.BayesianConv2D.__init__": [[118, 126], ["torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "bayes_layer._BayesianConvNd.__init__", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair", "torch.nn.modules.utils._pair"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "\n", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ",", "groups", "=", "1", ",", "bias", "=", "True", ",", "ratio", "=", "0.25", ")", ":", "\n", "        ", "kernel_size", "=", "_pair", "(", "kernel_size", ")", "\n", "stride", "=", "_pair", "(", "stride", ")", "\n", "padding", "=", "_pair", "(", "padding", ")", "\n", "dilation", "=", "_pair", "(", "dilation", ")", "\n", "super", "(", "BayesianConv2D", ",", "self", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "\n", "stride", ",", "padding", ",", "dilation", ",", "False", ",", "_pair", "(", "0", ")", ",", "groups", ",", "bias", ",", "ratio", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.bayes_layer.BayesianConv2D.forward": [[127, 135], ["torch.conv2d", "torch.conv2d", "torch.conv2d", "bayes_layer.BayesianConv2D.weight.sample"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample"], ["", "def", "forward", "(", "self", ",", "input", ",", "sample", "=", "False", ")", ":", "\n", "        ", "if", "sample", ":", "\n", "            ", "weight", "=", "self", ".", "weight", ".", "sample", "(", ")", "\n", "\n", "", "else", ":", "\n", "            ", "weight", "=", "self", ".", "weight", ".", "mu", "\n", "\n", "", "return", "F", ".", "conv2d", "(", "input", ",", "weight", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "groups", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.bayes_layer._calculate_fan_in_and_fan_out": [[9, 27], ["tensor.dim", "ValueError", "tensor.size", "tensor.size", "tensor.size", "tensor.size", "tensor.dim", "[].numel"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["def", "_calculate_fan_in_and_fan_out", "(", "tensor", ")", ":", "\n", "    ", "dimensions", "=", "tensor", ".", "dim", "(", ")", "\n", "if", "dimensions", "<", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Fan in and fan out can not be computed for tensor with fewer than 2 dimensions\"", ")", "\n", "\n", "", "if", "dimensions", "==", "2", ":", "# Linear", "\n", "        ", "fan_in", "=", "tensor", ".", "size", "(", "1", ")", "\n", "fan_out", "=", "tensor", ".", "size", "(", "0", ")", "\n", "", "else", ":", "\n", "        ", "num_input_fmaps", "=", "tensor", ".", "size", "(", "1", ")", "\n", "num_output_fmaps", "=", "tensor", ".", "size", "(", "0", ")", "\n", "receptive_field_size", "=", "1", "\n", "if", "tensor", ".", "dim", "(", ")", ">", "2", ":", "\n", "            ", "receptive_field_size", "=", "tensor", "[", "0", "]", "[", "0", "]", ".", "numel", "(", ")", "\n", "", "fan_in", "=", "num_input_fmaps", "*", "receptive_field_size", "\n", "fan_out", "=", "num_output_fmaps", "*", "receptive_field_size", "\n", "\n", "", "return", "fan_in", ",", "fan_out", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.Adam.__init__": [[48, 64], ["dict", "torch.optim.Optimizer.__init__", "ValueError", "ValueError", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["def", "__init__", "(", "self", ",", "params", ",", "lr", "=", "1e-3", ",", "lr_rho", "=", "1e-3", ",", "betas", "=", "(", "0.9", ",", "0.999", ")", ",", "eps", "=", "1e-8", ",", "\n", "weight_decay", "=", "0", ",", "amsgrad", "=", "False", ",", "param_name", "=", "None", ",", "lr_scale", "=", "None", ")", ":", "\n", "        ", "if", "not", "0.0", "<=", "lr", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid learning rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n", "", "if", "not", "0.0", "<=", "eps", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid epsilon value: {}\"", ".", "format", "(", "eps", ")", ")", "\n", "", "if", "not", "0.0", "<=", "betas", "[", "0", "]", "<", "1.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid beta parameter at index 0: {}\"", ".", "format", "(", "betas", "[", "0", "]", ")", ")", "\n", "", "if", "not", "0.0", "<=", "betas", "[", "1", "]", "<", "1.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid beta parameter at index 1: {}\"", ".", "format", "(", "betas", "[", "1", "]", ")", ")", "\n", "", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "betas", "=", "betas", ",", "eps", "=", "eps", ",", "\n", "weight_decay", "=", "weight_decay", ",", "amsgrad", "=", "amsgrad", ")", "\n", "self", ".", "param_name", "=", "param_name", "\n", "self", ".", "lr_rho", "=", "lr_rho", "\n", "self", ".", "lr_scale", "=", "lr_scale", "\n", "super", "(", "Adam", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.Adam.__setstate__": [[65, 69], ["super().__setstate__", "group.setdefault"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.Adam.__setstate__"], ["", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "super", "(", "Adam", ",", "self", ")", ".", "__setstate__", "(", "state", ")", "\n", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "group", ".", "setdefault", "(", "'amsgrad'", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.Adam.step": [[70, 138], ["closure", "enumerate", "exp_avg.mul_().add_", "exp_avg_sq.mul_().addcmul_", "p.data.addcdiv_", "RuntimeError", "len", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "grad.add_", "torch.max", "torch.max", "torch.max", "torch.max", "max_exp_avg_sq.sqrt().add_", "exp_avg_sq.sqrt().add_", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "exp_avg.mul_", "exp_avg_sq.mul_", "max_exp_avg_sq.sqrt", "exp_avg_sq.sqrt", "math.sqrt", "math.sqrt"], "methods", ["None"], ["", "", "def", "step", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "        ", "\"\"\"Performs a single optimization step.\n\n        Arguments:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n        \"\"\"", "\n", "loss", "=", "None", "\n", "if", "closure", "is", "not", "None", ":", "\n", "            ", "loss", "=", "closure", "(", ")", "\n", "\n", "", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "for", "i", ",", "p", "in", "enumerate", "(", "group", "[", "'params'", "]", ")", ":", "\n", "                ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "grad", "=", "p", ".", "grad", ".", "data", "\n", "if", "grad", ".", "is_sparse", ":", "\n", "                    ", "raise", "RuntimeError", "(", "'Adam does not support sparse gradients, please consider SparseAdam instead'", ")", "\n", "", "amsgrad", "=", "group", "[", "'amsgrad'", "]", "\n", "\n", "state", "=", "self", ".", "state", "[", "p", "]", "\n", "\n", "# State initialization", "\n", "if", "len", "(", "state", ")", "==", "0", ":", "\n", "                    ", "state", "[", "'step'", "]", "=", "0", "\n", "# Exponential moving average of gradient values", "\n", "state", "[", "'exp_avg'", "]", "=", "torch", ".", "zeros_like", "(", "p", ".", "data", ")", "\n", "# Exponential moving average of squared gradient values", "\n", "state", "[", "'exp_avg_sq'", "]", "=", "torch", ".", "zeros_like", "(", "p", ".", "data", ")", "\n", "if", "amsgrad", ":", "\n", "# Maintains max of all exp. moving avg. of sq. grad. values", "\n", "                        ", "state", "[", "'max_exp_avg_sq'", "]", "=", "torch", ".", "zeros_like", "(", "p", ".", "data", ")", "\n", "\n", "", "", "exp_avg", ",", "exp_avg_sq", "=", "state", "[", "'exp_avg'", "]", ",", "state", "[", "'exp_avg_sq'", "]", "\n", "if", "amsgrad", ":", "\n", "                    ", "max_exp_avg_sq", "=", "state", "[", "'max_exp_avg_sq'", "]", "\n", "", "beta1", ",", "beta2", "=", "group", "[", "'betas'", "]", "\n", "\n", "state", "[", "'step'", "]", "+=", "1", "\n", "\n", "if", "group", "[", "'weight_decay'", "]", "!=", "0", ":", "\n", "                    ", "grad", ".", "add_", "(", "group", "[", "'weight_decay'", "]", ",", "p", ".", "data", ")", "\n", "\n", "# Decay the first and second moment running average coefficient", "\n", "", "exp_avg", ".", "mul_", "(", "beta1", ")", ".", "add_", "(", "1", "-", "beta1", ",", "grad", ")", "\n", "exp_avg_sq", ".", "mul_", "(", "beta2", ")", ".", "addcmul_", "(", "1", "-", "beta2", ",", "grad", ",", "grad", ")", "\n", "if", "amsgrad", ":", "\n", "# Maintains the maximum of all 2nd moment running avg. till now", "\n", "                    ", "torch", ".", "max", "(", "max_exp_avg_sq", ",", "exp_avg_sq", ",", "out", "=", "max_exp_avg_sq", ")", "\n", "# Use the max. for normalizing running avg. of gradient", "\n", "denom", "=", "max_exp_avg_sq", ".", "sqrt", "(", ")", ".", "add_", "(", "group", "[", "'eps'", "]", ")", "\n", "", "else", ":", "\n", "                    ", "denom", "=", "exp_avg_sq", ".", "sqrt", "(", ")", ".", "add_", "(", "group", "[", "'eps'", "]", ")", "\n", "\n", "", "bias_correction1", "=", "1", "-", "beta1", "**", "state", "[", "'step'", "]", "\n", "bias_correction2", "=", "1", "-", "beta2", "**", "state", "[", "'step'", "]", "\n", "\n", "n", "=", "self", ".", "param_name", "[", "i", "]", "\n", "\n", "if", "'rho'", "in", "self", ".", "param_name", "[", "i", "]", ":", "\n", "                    ", "step_size", "=", "self", ".", "lr_rho", "*", "math", ".", "sqrt", "(", "bias_correction2", ")", "/", "bias_correction1", "\n", "", "else", ":", "\n", "                    ", "step_size", "=", "group", "[", "'lr'", "]", "*", "math", ".", "sqrt", "(", "bias_correction2", ")", "/", "bias_correction1", "\n", "\n", "#                 p.data.addcdiv_(-step_size, self.lr_scale[n] * exp_avg, denom)", "\n", "", "p", ".", "data", ".", "addcdiv_", "(", "-", "step_size", ",", "exp_avg", ",", "denom", ")", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.__init__": [[365, 380], ["os.path.join", "os.path.isfile", "pandas.DataFrame", "utils.logger.load", "os.remove", "pandas.DataFrame"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load"], ["    ", "def", "__init__", "(", "self", ",", "file_name", "=", "'pmnist2'", ",", "resume", "=", "False", ",", "path", "=", "'./result_data/csvdata/'", ",", "data_format", "=", "'csv'", ")", ":", "\n", "\n", "        ", "self", ".", "data_name", "=", "os", ".", "path", ".", "join", "(", "path", ",", "file_name", ")", "\n", "self", ".", "data_path", "=", "'{}.csv'", ".", "format", "(", "self", ".", "data_name", ")", "\n", "self", ".", "log", "=", "None", "\n", "if", "os", ".", "path", ".", "isfile", "(", "self", ".", "data_path", ")", ":", "\n", "            ", "if", "resume", ":", "\n", "                ", "self", ".", "load", "(", "self", ".", "data_path", ")", "\n", "", "else", ":", "\n", "                ", "os", ".", "remove", "(", "self", ".", "data_path", ")", "\n", "self", ".", "log", "=", "pd", ".", "DataFrame", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "log", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "", "self", ".", "data_format", "=", "data_format", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add": [[382, 390], ["pandas.DataFrame", "utils.logger.log.append", "kwargs.values", "kwargs.keys"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Add a new row to the dataframe\n        example:\n            resultsLog.add(epoch=epoch_num, train_loss=loss,\n                           test_loss=test_loss)\n        \"\"\"", "\n", "df", "=", "pd", ".", "DataFrame", "(", "[", "kwargs", ".", "values", "(", ")", "]", ",", "columns", "=", "kwargs", ".", "keys", "(", ")", ")", "\n", "self", ".", "log", "=", "self", ".", "log", ".", "append", "(", "df", ",", "ignore_index", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save": [[392, 394], ["utils.logger.log.to_csv"], "methods", ["None"], ["", "def", "save", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "log", ".", "to_csv", "(", "self", ".", "data_path", ",", "index", "=", "False", ",", "index_label", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load": [[395, 401], ["os.path.isfile", "utils.logger.log.read_csv", "ValueError"], "methods", ["None"], ["", "def", "load", "(", "self", ",", "path", "=", "None", ")", ":", "\n", "        ", "path", "=", "path", "or", "self", ".", "data_path", "\n", "if", "os", ".", "path", ".", "isfile", "(", "path", ")", ":", "\n", "            ", "self", ".", "log", ".", "read_csv", "(", "path", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'{} isn'", "'t a file'", ".", "format", "(", "path", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.crop": [[141, 172], ["len", "torch.stack().view().cuda", "torch.stack().view().cuda", "range", "numpy.transpose", "torchvision.to_tensor", "cropped_image.append", "range", "torch.stack().view", "torch.stack().view", "sklearn.feature_extraction.image.extract_patches_2d", "random.random", "numpy.fliplr", "random.random", "numpy.flipud", "tvF.to_tensor.copy", "x[].data.cpu().numpy", "numpy.transpose", "torchvision.to_tensor", "cropped_image.append", "tvF.to_tensor.copy", "torch.stack", "torch.stack", "x[].data.cpu().numpy", "x[].data.cpu", "x[].data.cpu"], "function", ["None"], ["", "", "def", "crop", "(", "x", ",", "patch_size", ",", "mode", "=", "'train'", ")", ":", "\n", "    ", "cropped_image", "=", "[", "]", "\n", "arr_len", "=", "len", "(", "x", ")", "\n", "if", "mode", "==", "'train'", ":", "\n", "        ", "for", "idx", "in", "range", "(", "arr_len", ")", ":", "\n", "\n", "            ", "patch", "=", "image", ".", "extract_patches_2d", "(", "image", "=", "x", "[", "idx", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "patch_size", "=", "(", "patch_size", ",", "patch_size", ")", ",", "max_patches", "=", "1", ")", "[", "0", "]", "\n", "\n", "# Random horizontal flipping", "\n", "if", "random", ".", "random", "(", ")", ">", "0.5", ":", "\n", "                ", "patch", "=", "np", ".", "fliplr", "(", "patch", ")", "\n", "# Random vertical flipping", "\n", "", "if", "random", ".", "random", "(", ")", ">", "0.5", ":", "\n", "                ", "patch", "=", "np", ".", "flipud", "(", "patch", ")", "\n", "# Corrupt source image", "\n", "", "patch", "=", "np", ".", "transpose", "(", "patch", ",", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "patch", "=", "tvF", ".", "to_tensor", "(", "patch", ".", "copy", "(", ")", ")", "\n", "cropped_image", ".", "append", "(", "patch", ")", "\n", "", "", "elif", "mode", "==", "'valid'", "or", "mode", "==", "'test'", ":", "\n", "        ", "for", "idx", "in", "range", "(", "arr_len", ")", ":", "\n", "            ", "patch", "=", "x", "[", "idx", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "H", ",", "W", ",", "C", "=", "patch", ".", "shape", "\n", "patch", "=", "patch", "[", "H", "//", "2", "-", "patch_size", "//", "2", ":", "H", "//", "2", "+", "patch_size", "//", "2", ",", "W", "//", "2", "-", "patch_size", "//", "2", ":", "W", "//", "2", "+", "patch_size", "//", "2", ",", ":", "]", "\n", "# Corrupt source image", "\n", "patch", "=", "np", ".", "transpose", "(", "patch", ",", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "patch", "=", "tvF", ".", "to_tensor", "(", "patch", ".", "copy", "(", ")", ")", "\n", "cropped_image", ".", "append", "(", "patch", ")", "\n", "\n", "", "", "image_tensor", "=", "torch", ".", "stack", "(", "cropped_image", ")", ".", "view", "(", "-", "1", ",", "3", ",", "patch_size", ",", "patch_size", ")", ".", "cuda", "(", ")", "\n", "return", "image_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.print_model_report": [[174, 186], ["print", "print", "print", "model.parameters", "print", "print", "print", "print", "numpy.prod", "p.size", "p.size", "utils.human_format"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.human_format"], ["", "def", "print_model_report", "(", "model", ")", ":", "\n", "    ", "print", "(", "'-'", "*", "100", ")", "\n", "print", "(", "model", ")", "\n", "print", "(", "'Dimensions ='", ",", "end", "=", "' '", ")", "\n", "count", "=", "0", "\n", "for", "p", "in", "model", ".", "parameters", "(", ")", ":", "\n", "        ", "print", "(", "p", ".", "size", "(", ")", ",", "end", "=", "' '", ")", "\n", "count", "+=", "np", ".", "prod", "(", "p", ".", "size", "(", ")", ")", "\n", "", "print", "(", ")", "\n", "print", "(", "'Num parameters = %s'", "%", "(", "human_format", "(", "count", ")", ")", ")", "\n", "print", "(", "'-'", "*", "100", ")", "\n", "return", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.human_format": [[187, 193], ["abs"], "function", ["None"], ["", "def", "human_format", "(", "num", ")", ":", "\n", "    ", "magnitude", "=", "0", "\n", "while", "abs", "(", "num", ")", ">=", "1000", ":", "\n", "        ", "magnitude", "+=", "1", "\n", "num", "/=", "1000.0", "\n", "", "return", "'%.1f%s'", "%", "(", "num", ",", "[", "''", ",", "'K'", ",", "'M'", ",", "'G'", ",", "'T'", ",", "'P'", "]", "[", "magnitude", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.print_optimizer_config": [[194, 205], ["print", "print", "opt.keys", "print", "n.startswith", "print"], "function", ["None"], ["", "def", "print_optimizer_config", "(", "optim", ")", ":", "\n", "    ", "if", "optim", "is", "None", ":", "\n", "        ", "print", "(", "optim", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "optim", ",", "'='", ",", "end", "=", "' '", ")", "\n", "opt", "=", "optim", ".", "param_groups", "[", "0", "]", "\n", "for", "n", "in", "opt", ".", "keys", "(", ")", ":", "\n", "            ", "if", "not", "n", ".", "startswith", "(", "'param'", ")", ":", "\n", "                ", "print", "(", "n", "+", "':'", ",", "opt", "[", "n", "]", ",", "end", "=", "', '", ")", "\n", "", "", "print", "(", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model": [[208, 210], ["copy.deepcopy", "model.state_dict"], "function", ["None"], ["", "def", "get_model", "(", "model", ")", ":", "\n", "    ", "return", "deepcopy", "(", "model", ".", "state_dict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.set_model_": [[211, 214], ["model.load_state_dict", "copy.deepcopy"], "function", ["None"], ["", "def", "set_model_", "(", "model", ",", "state_dict", ")", ":", "\n", "    ", "model", ".", "load_state_dict", "(", "deepcopy", "(", "state_dict", ")", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.freeze_model": [[215, 219], ["model.parameters"], "function", ["None"], ["", "def", "freeze_model", "(", "model", ")", ":", "\n", "    ", "for", "param", "in", "model", ".", "parameters", "(", ")", ":", "\n", "        ", "param", ".", "requires_grad", "=", "False", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.compute_conv_output_size": [[222, 224], ["int", "numpy.floor", "float"], "function", ["None"], ["", "def", "compute_conv_output_size", "(", "Lin", ",", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ")", ":", "\n", "    ", "return", "int", "(", "np", ".", "floor", "(", "(", "Lin", "+", "2", "*", "padding", "-", "dilation", "*", "(", "kernel_size", "-", "1", ")", "-", "1", ")", "/", "float", "(", "stride", ")", "+", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.compute_mean_std_dataset": [[227, 243], ["torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "len", "mean.view().expand_as", "sklearn.feature_extraction.image.mean().mean", "mean.view", "sklearn.feature_extraction.image.mean", "mean.size", "mean.size", "sklearn.feature_extraction.image.size", "len", "sklearn.feature_extraction.image.size"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "compute_mean_std_dataset", "(", "dataset", ")", ":", "\n", "# dataset already put ToTensor", "\n", "    ", "mean", "=", "0", "\n", "std", "=", "0", "\n", "loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dataset", ",", "batch_size", "=", "1", ",", "shuffle", "=", "False", ")", "\n", "for", "image", ",", "_", "in", "loader", ":", "\n", "        ", "mean", "+=", "image", ".", "mean", "(", "3", ")", ".", "mean", "(", "2", ")", "\n", "", "mean", "/=", "len", "(", "dataset", ")", "\n", "\n", "mean_expanded", "=", "mean", ".", "view", "(", "mean", ".", "size", "(", "0", ")", ",", "mean", ".", "size", "(", "1", ")", ",", "1", ",", "1", ")", ".", "expand_as", "(", "image", ")", "\n", "for", "image", ",", "_", "in", "loader", ":", "\n", "        ", "std", "+=", "(", "image", "-", "mean_expanded", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", "3", ")", ".", "sum", "(", "2", ")", "\n", "\n", "", "std", "=", "(", "std", "/", "(", "len", "(", "dataset", ")", "*", "image", ".", "size", "(", "2", ")", "*", "image", ".", "size", "(", "3", ")", "-", "1", ")", ")", ".", "sqrt", "(", ")", "\n", "\n", "return", "mean", ",", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.fisher_matrix_diag": [[246, 279], ["model.named_parameters", "model.train", "tqdm.tqdm", "range", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "model.zero_grad", "criterion", "criterion.backward", "model.named_parameters", "torch.no_grad", "torch.no_grad", "model.named_parameters", "x.size", "feature_extractor", "model.forward", "torch.LongTensor", "torch.LongTensor", "model.forward", "x.size", "numpy.arange", "p.grad.data.pow", "numpy.min", "x.size"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "fisher_matrix_diag", "(", "t", ",", "x", ",", "y", ",", "model", ",", "criterion", ",", "sbatch", "=", "20", ",", "split", "=", "False", ")", ":", "\n", "# Init", "\n", "    ", "fisher", "=", "{", "}", "\n", "for", "n", ",", "p", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "fisher", "[", "n", "]", "=", "0", "*", "p", ".", "data", "\n", "# Compute", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "0", ",", "x", ".", "size", "(", "0", ")", ",", "sbatch", ")", ",", "desc", "=", "'Fisher diagonal'", ",", "ncols", "=", "100", ",", "ascii", "=", "True", ")", ":", "\n", "        ", "b", "=", "torch", ".", "LongTensor", "(", "np", ".", "arange", "(", "i", ",", "np", ".", "min", "(", "[", "i", "+", "sbatch", ",", "x", ".", "size", "(", "0", ")", "]", ")", ")", ")", ".", "cuda", "(", ")", "\n", "images", "=", "x", "[", "b", "]", "\n", "target", "=", "y", "[", "b", "]", "\n", "\n", "if", "args", ".", "experiment", "==", "'split_CUB200'", ":", "\n", "            ", "images", "=", "feature_extractor", "(", "images", ")", "\n", "\n", "# Forward and backward", "\n", "", "model", ".", "zero_grad", "(", ")", "\n", "if", "split", ":", "\n", "            ", "outputs", "=", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "            ", "outputs", "=", "model", ".", "forward", "(", "images", ")", "\n", "", "loss", "=", "criterion", "(", "t", ",", "outputs", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "# Get gradients", "\n", "for", "n", ",", "p", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "                ", "fisher", "[", "n", "]", "+=", "sbatch", "*", "p", ".", "grad", ".", "data", ".", "pow", "(", "2", ")", "\n", "# Mean", "\n", "", "", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "n", ",", "_", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "fisher", "[", "n", "]", "=", "fisher", "[", "n", "]", "/", "x", ".", "size", "(", "0", ")", "\n", "", "", "return", "fisher", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.cross_entropy": [[282, 296], ["torch.nn.functional.softmax", "torch.nn.functional.softmax", "torch.nn.functional.softmax", "torch.nn.functional.softmax", "out.pow.pow", "tar.pow.pow", "out.pow.sum().view().expand_as", "ce.mean.mean", "out.pow.sum().view().expand_as", "tar.pow.sum().view().expand_as", "out.pow.size", "out.pow.sum().view", "out.pow.sum().view", "tar.pow.sum().view", "out.pow.log", "out.pow.sum", "out.pow.sum", "tar.pow.sum"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "cross_entropy", "(", "outputs", ",", "targets", ",", "exp", "=", "1", ",", "size_average", "=", "True", ",", "eps", "=", "1e-5", ")", ":", "\n", "    ", "out", "=", "torch", ".", "nn", ".", "functional", ".", "softmax", "(", "outputs", ")", "\n", "tar", "=", "torch", ".", "nn", ".", "functional", ".", "softmax", "(", "targets", ")", "\n", "if", "exp", "!=", "1", ":", "\n", "        ", "out", "=", "out", ".", "pow", "(", "exp", ")", "\n", "out", "=", "out", "/", "out", ".", "sum", "(", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "out", ")", "\n", "tar", "=", "tar", ".", "pow", "(", "exp", ")", "\n", "tar", "=", "tar", "/", "tar", ".", "sum", "(", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "tar", ")", "\n", "", "out", "=", "out", "+", "eps", "/", "out", ".", "size", "(", "1", ")", "\n", "out", "=", "out", "/", "out", ".", "sum", "(", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "out", ")", "\n", "ce", "=", "-", "(", "tar", "*", "out", ".", "log", "(", ")", ")", ".", "sum", "(", "1", ")", "\n", "if", "size_average", ":", "\n", "        ", "ce", "=", "ce", ".", "mean", "(", ")", "\n", "", "return", "ce", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.set_req_grad": [[299, 305], ["hasattr", "hasattr"], "function", ["None"], ["", "def", "set_req_grad", "(", "layer", ",", "req_grad", ")", ":", "\n", "    ", "if", "hasattr", "(", "layer", ",", "'weight'", ")", ":", "\n", "        ", "layer", ".", "weight", ".", "requires_grad", "=", "req_grad", "\n", "", "if", "hasattr", "(", "layer", ",", "'bias'", ")", ":", "\n", "        ", "layer", ".", "bias", ".", "requires_grad", "=", "req_grad", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.is_number": [[308, 323], ["float", "unicodedata.numeric"], "function", ["None"], ["", "def", "is_number", "(", "s", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "float", "(", "s", ")", "\n", "return", "True", "\n", "", "except", "ValueError", ":", "\n", "        ", "pass", "\n", "\n", "", "try", ":", "\n", "        ", "import", "unicodedata", "\n", "unicodedata", ".", "numeric", "(", "s", ")", "\n", "return", "True", "\n", "", "except", "(", "TypeError", ",", "ValueError", ")", ":", "\n", "        ", "pass", "\n", "\n", "", "return", "False", "\n", "########################################################################################################################", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.clip_relevance_norm_": [[325, 361], ["isinstance", "list", "float", "float", "filter", "max", "p.data.norm", "p.data.mul_", "p.data.abs().max", "p.data.norm.item", "p.data.abs"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm"], ["", "def", "clip_relevance_norm_", "(", "parameters", ",", "max_norm", ",", "norm_type", "=", "2", ")", ":", "\n", "    ", "r\"\"\"Clips gradient norm of an iterable of parameters.\n\n    The norm is computed over all gradients together, as if they were\n    concatenated into a single vector. Gradients are modified in-place.\n\n    Arguments:\n        parameters (Iterable[Tensor] or Tensor): an iterable of Tensors or a\n            single Tensor that will have gradients normalized\n        max_norm (float or int): max norm of the gradients\n        norm_type (float or int): type of the used p-norm. Can be ``'inf'`` for\n            infinity norm.\n\n    Returns:\n        Total norm of the parameters (viewed as a single vector).\n    \"\"\"", "\n", "\n", "if", "isinstance", "(", "parameters", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "parameters", "=", "[", "parameters", "]", "\n", "", "parameters", "=", "list", "(", "filter", "(", "lambda", "p", ":", "p", "is", "not", "None", ",", "parameters", ")", ")", "\n", "max_norm", "=", "float", "(", "max_norm", ")", "\n", "norm_type", "=", "float", "(", "norm_type", ")", "\n", "if", "norm_type", "==", "inf", ":", "\n", "        ", "total_norm", "=", "max", "(", "p", ".", "data", ".", "abs", "(", ")", ".", "max", "(", ")", "for", "p", "in", "parameters", ")", "\n", "", "else", ":", "\n", "        ", "total_norm", "=", "0", "\n", "for", "p", "in", "parameters", ":", "\n", "            ", "param_norm", "=", "p", ".", "data", ".", "norm", "(", "norm_type", ")", "\n", "total_norm", "+=", "param_norm", ".", "item", "(", ")", "**", "norm_type", "\n", "", "total_norm", "=", "total_norm", "**", "(", "1.", "/", "norm_type", ")", "\n", "", "clip_coef", "=", "max_norm", "/", "(", "total_norm", "+", "1e-6", ")", "\n", "if", "clip_coef", "<", "1", ":", "\n", "        ", "for", "p", "in", "parameters", ":", "\n", "            ", "p", ".", "data", ".", "mul_", "(", "clip_coef", ")", "\n", "\n", "", "", "return", "total_norm", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_ucl.Net.__init__": [[9, 32], ["torch.Module.__init__", "bayes_layer.BayesianLinear", "bayes_layer.BayesianLinear", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "bayes_layer.BayesianLinear", "bayes_layer.BayesianLinear", "bayes_layer.BayesianLinear", "mlp_ucl.Net.last.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inputsize", ",", "taskcla", ",", "ratio", ",", "unitN", "=", "400", ",", "split", "=", "False", ",", "notMNIST", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "ncha", ",", "size", ",", "_", "=", "inputsize", "\n", "self", ".", "notMNIST", "=", "notMNIST", "\n", "if", "notMNIST", ":", "\n", "            ", "unitN", "=", "150", "\n", "", "self", ".", "taskcla", "=", "taskcla", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "fc1", "=", "BayesianLinear", "(", "28", "*", "28", ",", "unitN", ",", "ratio", "=", "ratio", ")", "\n", "self", ".", "fc2", "=", "BayesianLinear", "(", "unitN", ",", "unitN", ",", "ratio", "=", "ratio", ")", "\n", "\n", "if", "notMNIST", ":", "\n", "            ", "self", ".", "fc3", "=", "BayesianLinear", "(", "unitN", ",", "unitN", ",", "ratio", "=", "ratio", ")", "\n", "self", ".", "fc4", "=", "BayesianLinear", "(", "unitN", ",", "unitN", ",", "ratio", "=", "ratio", ")", "\n", "", "self", ".", "last", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "if", "split", ":", "\n", "            ", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "                ", "self", ".", "last", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "n", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "fc3", "=", "BayesianLinear", "(", "unitN", ",", "taskcla", "[", "0", "]", "[", "1", "]", ",", "ratio", "=", "ratio", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_ucl.Net.forward": [[34, 52], ["mlp_ucl.Net.view", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "mlp_ucl.Net.fc1", "mlp_ucl.Net.fc2", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "mlp_ucl.Net.fc3", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "mlp_ucl.Net.fc3", "mlp_ucl.Net.fc4", "torch.log_softmax.append"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "sample", "=", "False", ")", ":", "\n", "        ", "x", "=", "x", ".", "view", "(", "-", "1", ",", "28", "*", "28", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "fc1", "(", "x", ",", "sample", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "fc2", "(", "x", ",", "sample", ")", ")", "\n", "if", "self", ".", "notMNIST", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "self", ".", "fc3", "(", "x", ",", "sample", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "fc4", "(", "x", ",", "sample", ")", ")", "\n", "\n", "", "if", "self", ".", "split", ":", "\n", "            ", "y", "=", "[", "]", "\n", "for", "t", ",", "i", "in", "self", ".", "taskcla", ":", "\n", "                ", "y", ".", "append", "(", "self", ".", "last", "[", "t", "]", "(", "x", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "fc3", "(", "x", ",", "sample", ")", "\n", "y", "=", "F", ".", "log_softmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net.Net.__init__": [[7, 40], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "conv_net.Net.last.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size"], ["    ", "def", "__init__", "(", "self", ",", "inputsize", ",", "taskcla", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "ncha", ",", "size", ",", "_", "=", "inputsize", "\n", "self", ".", "taskcla", "=", "taskcla", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "ncha", ",", "32", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "size", ",", "3", ",", "padding", "=", "1", ")", "# 32", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "32", ",", "32", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 32", "\n", "s", "=", "s", "//", "2", "# 16", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "32", ",", "64", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 16", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 16", "\n", "s", "=", "s", "//", "2", "# 8", "\n", "self", ".", "conv5", "=", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 8", "\n", "self", ".", "conv6", "=", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 8", "\n", "#         self.conv7 = nn.Conv2d(128,128,kernel_size=3,padding=1)", "\n", "#         s = compute_conv_output_size(s,3, padding=1) # 8", "\n", "s", "=", "s", "//", "2", "# 4", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "s", "*", "s", "*", "128", ",", "256", ")", "# 2048", "\n", "self", ".", "drop1", "=", "nn", ".", "Dropout", "(", "0.25", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "Dropout", "(", "0.5", ")", "\n", "self", ".", "MaxPool", "=", "torch", ".", "nn", ".", "MaxPool2d", "(", "2", ")", "\n", "\n", "self", ".", "last", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "            ", "self", ".", "last", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "256", ",", "n", ")", ")", "\n", "", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net.Net.forward": [[41, 59], ["conv_net.Net.relu", "conv_net.Net.relu", "conv_net.Net.drop1", "conv_net.Net.relu", "conv_net.Net.relu", "conv_net.Net.drop1", "conv_net.Net.relu", "conv_net.Net.relu", "conv_net.Net.drop1", "conv_net.Net.view", "conv_net.Net.drop2", "conv_net.Net.conv1", "conv_net.Net.conv2", "conv_net.Net.MaxPool", "conv_net.Net.conv3", "conv_net.Net.conv4", "conv_net.Net.MaxPool", "conv_net.Net.conv5", "conv_net.Net.conv6", "conv_net.Net.MaxPool", "conv_net.Net.relu", "y.append", "conv_net.Net.fc1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "h", "=", "self", ".", "relu", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv2", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "MaxPool", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv3", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv4", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "MaxPool", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv5", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv6", "(", "h", ")", ")", "\n", "#         h=self.relu(self.conv7(h))", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "MaxPool", "(", "h", ")", ")", "\n", "h", "=", "h", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "h", "=", "self", ".", "drop2", "(", "self", ".", "relu", "(", "self", ".", "fc1", "(", "h", ")", ")", ")", "\n", "y", "=", "[", "]", "\n", "for", "t", ",", "i", "in", "self", ".", "taskcla", ":", "\n", "            ", "y", ".", "append", "(", "self", ".", "last", "[", "t", "]", "(", "h", ")", ")", "\n", "\n", "", "return", "y", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_hat.Net.__init__": [[8, 67], ["super().__init__", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Linear", "torch.Linear", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.Sigmoid", "torch.nn.Sigmoid", "torch.nn.Sigmoid", "torch.nn.Sigmoid", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.Embedding", "conv_net_hat.Net.last.append", "len", "len", "len", "len", "len", "len", "len", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size"], ["    ", "def", "__init__", "(", "self", ",", "inputsize", ",", "taskcla", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "ncha", ",", "size", ",", "_", "=", "inputsize", "\n", "self", ".", "taskcla", "=", "taskcla", "\n", "\n", "self", ".", "c1", "=", "nn", ".", "Conv2d", "(", "ncha", ",", "32", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "size", ",", "3", ",", "padding", "=", "1", ")", "# 32", "\n", "self", ".", "c2", "=", "nn", ".", "Conv2d", "(", "32", ",", "32", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 32", "\n", "s", "=", "s", "//", "2", "# 16", "\n", "self", ".", "c3", "=", "nn", ".", "Conv2d", "(", "32", ",", "64", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 16", "\n", "self", ".", "c4", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 16", "\n", "s", "=", "s", "//", "2", "# 8", "\n", "self", ".", "c5", "=", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 8", "\n", "self", ".", "c6", "=", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 8", "\n", "#         self.c7 = nn.Conv2d(128,128,kernel_size=3,padding=1)", "\n", "#         s = compute_conv_output_size(s,3, padding=1) # 8", "\n", "s", "=", "s", "//", "2", "# 4", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "s", "*", "s", "*", "128", ",", "256", ")", "# 2048", "\n", "self", ".", "drop1", "=", "torch", ".", "nn", ".", "Dropout", "(", "0.2", ")", "\n", "self", ".", "drop2", "=", "torch", ".", "nn", ".", "Dropout", "(", "0.5", ")", "\n", "\n", "self", ".", "smid", "=", "s", "\n", "self", ".", "MaxPool", "=", "torch", ".", "nn", ".", "MaxPool2d", "(", "2", ")", "\n", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", ")", "\n", "\n", "self", ".", "last", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "            ", "self", ".", "last", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "256", ",", "n", ")", ")", "\n", "\n", "", "self", ".", "gate", "=", "torch", ".", "nn", ".", "Sigmoid", "(", ")", "\n", "# All embedding stuff should start with 'e'", "\n", "self", ".", "ec1", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "32", ")", "\n", "self", ".", "ec2", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "32", ")", "\n", "self", ".", "ec3", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "64", ")", "\n", "self", ".", "ec4", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "64", ")", "\n", "self", ".", "ec5", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "128", ")", "\n", "self", ".", "ec6", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "128", ")", "\n", "#         self.ec7=torch.nn.Embedding(len(self.taskcla),128)", "\n", "self", ".", "efc1", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "256", ")", "\n", "\n", "\"\"\" (e.g., used in the compression experiments)\n        lo,hi=0,2\n        self.ec1.weight.data.uniform_(lo,hi)\n        self.ec2.weight.data.uniform_(lo,hi)\n        self.ec3.weight.data.uniform_(lo,hi)\n        self.ec4.weight.data.uniform_(lo,hi)\n        self.ec5.weight.data.uniform_(lo,hi)\n        self.ec6.weight.data.uniform_(lo,hi)\n        self.ec7.weight.data.uniform_(lo,hi)\n        self.efc1.weight.data.uniform_(lo,hi)\n        #\"\"\"", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_hat.Net.forward": [[68, 102], ["conv_net_hat.Net.mask", "conv_net_hat.Net.relu", "conv_net_hat.Net.relu", "conv_net_hat.Net.drop1", "conv_net_hat.Net.relu", "conv_net_hat.Net.relu", "conv_net_hat.Net.drop1", "conv_net_hat.Net.relu", "conv_net_hat.Net.relu", "conv_net_hat.Net.drop1", "conv_net_hat.Net.view", "conv_net_hat.Net.drop2", "conv_net_hat.Net.c1", "gc1.view().expand_as", "conv_net_hat.Net.c2", "gc2.view().expand_as", "conv_net_hat.Net.MaxPool", "conv_net_hat.Net.c3", "gc3.view().expand_as", "conv_net_hat.Net.c4", "gc4.view().expand_as", "conv_net_hat.Net.MaxPool", "conv_net_hat.Net.c5", "gc5.view().expand_as", "conv_net_hat.Net.c6", "gc6.view().expand_as", "conv_net_hat.Net.MaxPool", "conv_net_hat.Net.relu", "gfc1.expand_as", "y.append", "conv_net_hat.Net.fc1", "gc1.view", "gc2.view", "gc3.view", "gc4.view", "gc5.view", "gc6.view"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.mask"], ["", "def", "forward", "(", "self", ",", "t", ",", "x", ",", "s", "=", "1", ")", ":", "\n", "# Gates", "\n", "        ", "masks", "=", "self", ".", "mask", "(", "t", ",", "s", "=", "s", ")", "\n", "#         gc1,gc2,gc3,gc4,gc5,gc6,gc7,gfc1=masks", "\n", "gc1", ",", "gc2", ",", "gc3", ",", "gc4", ",", "gc5", ",", "gc6", ",", "gfc1", "=", "masks", "\n", "\n", "# Gated", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "c1", "(", "x", ")", ")", "\n", "h", "=", "h", "*", "gc1", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "h", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "c2", "(", "h", ")", ")", "\n", "h", "=", "h", "*", "gc2", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "h", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "MaxPool", "(", "h", ")", ")", "\n", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "c3", "(", "h", ")", ")", "\n", "h", "=", "h", "*", "gc3", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "h", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "c4", "(", "h", ")", ")", "\n", "h", "=", "h", "*", "gc4", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "h", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "MaxPool", "(", "h", ")", ")", "\n", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "c5", "(", "h", ")", ")", "\n", "h", "=", "h", "*", "gc5", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "h", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "c6", "(", "h", ")", ")", "\n", "h", "=", "h", "*", "gc6", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "h", ")", "\n", "#         h=self.relu(self.c7(h))", "\n", "#         h=h*gc7.view(1,-1,1,1).expand_as(h)", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "MaxPool", "(", "h", ")", ")", "\n", "\n", "h", "=", "h", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "h", "=", "self", ".", "drop2", "(", "self", ".", "relu", "(", "self", ".", "fc1", "(", "h", ")", ")", ")", "\n", "h", "=", "h", "*", "gfc1", ".", "expand_as", "(", "h", ")", "\n", "y", "=", "[", "]", "\n", "for", "i", ",", "_", "in", "self", ".", "taskcla", ":", "\n", "            ", "y", ".", "append", "(", "self", ".", "last", "[", "i", "]", "(", "h", ")", ")", "\n", "", "return", "y", ",", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_hat.Net.mask": [[103, 114], ["conv_net_hat.Net.gate", "conv_net_hat.Net.gate", "conv_net_hat.Net.gate", "conv_net_hat.Net.gate", "conv_net_hat.Net.gate", "conv_net_hat.Net.gate", "conv_net_hat.Net.gate", "conv_net_hat.Net.ec1", "conv_net_hat.Net.ec2", "conv_net_hat.Net.ec3", "conv_net_hat.Net.ec4", "conv_net_hat.Net.ec5", "conv_net_hat.Net.ec6", "conv_net_hat.Net.efc1"], "methods", ["None"], ["", "def", "mask", "(", "self", ",", "t", ",", "s", "=", "1", ")", ":", "\n", "        ", "gc1", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "ec1", "(", "t", ")", ")", "\n", "gc2", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "ec2", "(", "t", ")", ")", "\n", "gc3", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "ec3", "(", "t", ")", ")", "\n", "gc4", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "ec4", "(", "t", ")", ")", "\n", "gc5", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "ec5", "(", "t", ")", ")", "\n", "gc6", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "ec6", "(", "t", ")", ")", "\n", "#         gc7=self.gate(s*self.ec7(t))", "\n", "gfc1", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "efc1", "(", "t", ")", ")", "\n", "#         return [gc1,gc2,gc3,gc4,gc5,gc6,gc7,gfc1]", "\n", "return", "[", "gc1", ",", "gc2", ",", "gc3", ",", "gc4", ",", "gc5", ",", "gc6", ",", "gfc1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_hat.Net.get_view_for": [[115, 167], ["gfc1.data.view().expand_as", "gc6.data.view().expand().contiguous().view().expand_as", "torch.min", "torch.min", "torch.min", "torch.min", "gfc1.data.view", "gfc1.data.view", "gc6.data.view().expand().contiguous().view", "gc1.data.view().expand_as", "gc1.data.view", "gc6.data.view().expand().contiguous", "gc1.data.view", "gc2.data.view().expand_as", "gc1.data.view().expand_as", "torch.min", "torch.min", "torch.min", "torch.min", "gc2.data.view", "gc6.data.view().expand", "gc2.data.view", "gc1.data.view", "gc3.data.view().expand_as", "gc2.data.view().expand_as", "torch.min", "torch.min", "torch.min", "torch.min", "gc3.data.view", "gc6.data.view", "conv_net_hat.Net.ec6.weight.size", "gc3.data.view", "gc2.data.view", "gc4.data.view().expand_as", "gc3.data.view().expand_as", "torch.min", "torch.min", "torch.min", "torch.min", "gc4.data.view", "gc4.data.view", "gc3.data.view", "gc5.data.view().expand_as", "gc4.data.view().expand_as", "torch.min", "torch.min", "torch.min", "torch.min", "gc5.data.view", "gc5.data.view", "gc4.data.view", "gc6.data.view().expand_as", "gc5.data.view().expand_as", "torch.min", "torch.min", "torch.min", "torch.min", "gc6.data.view", "gc6.data.view", "gc5.data.view"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "get_view_for", "(", "self", ",", "n", ",", "masks", ")", ":", "\n", "#         gc1,gc2,gc3,gc4,gc5,gc6,gc7,gfc1=masks", "\n", "        ", "gc1", ",", "gc2", ",", "gc3", ",", "gc4", ",", "gc5", ",", "gc6", ",", "gfc1", "=", "masks", "\n", "if", "n", "==", "'fc1.weight'", ":", "\n", "            ", "post", "=", "gfc1", ".", "data", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "fc1", ".", "weight", ")", "\n", "pre", "=", "gc6", ".", "data", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "(", "self", ".", "ec6", ".", "weight", ".", "size", "(", "1", ")", ",", "\n", "self", ".", "smid", ",", "\n", "self", ".", "smid", ")", ")", ".", "contiguous", "(", ")", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "self", ".", "fc1", ".", "weight", ")", "\n", "return", "torch", ".", "min", "(", "post", ",", "pre", ")", "\n", "", "elif", "n", "==", "'fc1.bias'", ":", "\n", "            ", "return", "gfc1", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "", "elif", "n", "==", "'c1.weight'", ":", "\n", "            ", "return", "gc1", ".", "data", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c1", ".", "weight", ")", "\n", "", "elif", "n", "==", "'c1.bias'", ":", "\n", "            ", "return", "gc1", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "", "elif", "n", "==", "'c2.weight'", ":", "\n", "            ", "post", "=", "gc2", ".", "data", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c2", ".", "weight", ")", "\n", "pre", "=", "gc1", ".", "data", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c2", ".", "weight", ")", "\n", "return", "torch", ".", "min", "(", "post", ",", "pre", ")", "\n", "", "elif", "n", "==", "'c2.bias'", ":", "\n", "            ", "return", "gc2", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "", "elif", "n", "==", "'c3.weight'", ":", "\n", "            ", "post", "=", "gc3", ".", "data", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c3", ".", "weight", ")", "\n", "pre", "=", "gc2", ".", "data", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c3", ".", "weight", ")", "\n", "return", "torch", ".", "min", "(", "post", ",", "pre", ")", "\n", "", "elif", "n", "==", "'c3.bias'", ":", "\n", "            ", "return", "gc3", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "", "elif", "n", "==", "'c4.weight'", ":", "\n", "            ", "post", "=", "gc4", ".", "data", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c4", ".", "weight", ")", "\n", "pre", "=", "gc3", ".", "data", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c4", ".", "weight", ")", "\n", "return", "torch", ".", "min", "(", "post", ",", "pre", ")", "\n", "", "elif", "n", "==", "'c4.bias'", ":", "\n", "            ", "return", "gc4", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "", "elif", "n", "==", "'c5.weight'", ":", "\n", "            ", "post", "=", "gc5", ".", "data", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c5", ".", "weight", ")", "\n", "pre", "=", "gc4", ".", "data", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c5", ".", "weight", ")", "\n", "return", "torch", ".", "min", "(", "post", ",", "pre", ")", "\n", "", "elif", "n", "==", "'c5.bias'", ":", "\n", "            ", "return", "gc5", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "", "elif", "n", "==", "'c6.weight'", ":", "\n", "            ", "post", "=", "gc6", ".", "data", ".", "view", "(", "-", "1", ",", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c6", ".", "weight", ")", "\n", "pre", "=", "gc5", ".", "data", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "c6", ".", "weight", ")", "\n", "return", "torch", ".", "min", "(", "post", ",", "pre", ")", "\n", "", "elif", "n", "==", "'c6.bias'", ":", "\n", "            ", "return", "gc6", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "#         elif n=='c7.weight':", "\n", "#             post=gc7.data.view(-1,1,1,1).expand_as(self.c7.weight)", "\n", "#             pre=gc6.data.view(1,-1,1,1).expand_as(self.c7.weight)", "\n", "#             return torch.min(post,pre)", "\n", "#         elif n=='c7.bias':", "\n", "#             return gc7.data.view(-1)", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp.Net.__init__": [[8, 32], ["super().__init__", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "mlp.Net.last.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inputsize", ",", "taskcla", ",", "unitN", "=", "400", ",", "split", "=", "False", ",", "notMNIST", "=", "False", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "ncha", ",", "size", ",", "_", "=", "inputsize", "\n", "self", ".", "notMNIST", "=", "notMNIST", "\n", "if", "notMNIST", ":", "\n", "            ", "unitN", "=", "150", "\n", "", "self", ".", "taskcla", "=", "taskcla", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "drop", "=", "torch", ".", "nn", ".", "Dropout", "(", "0.5", ")", "\n", "self", ".", "fc1", "=", "torch", ".", "nn", ".", "Linear", "(", "ncha", "*", "size", "*", "size", ",", "unitN", ")", "\n", "self", ".", "fc2", "=", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "unitN", ")", "\n", "\n", "if", "notMNIST", ":", "\n", "            ", "self", ".", "fc3", "=", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "unitN", ")", "\n", "self", ".", "fc4", "=", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "unitN", ")", "\n", "\n", "", "if", "split", ":", "\n", "            ", "self", ".", "last", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "                ", "self", ".", "last", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "n", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "fc3", "=", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "taskcla", "[", "0", "]", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp.Net.forward": [[33, 50], ["x.view", "mlp.Net.drop", "mlp.Net.drop", "x.size", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "mlp.Net.drop", "mlp.Net.drop", "mlp.Net.fc3", "mlp.Net.fc1", "mlp.Net.fc2", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "mlp.Net.append", "mlp.Net.fc3", "mlp.Net.fc4"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "h", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "h", "=", "self", ".", "drop", "(", "F", ".", "relu", "(", "self", ".", "fc1", "(", "h", ")", ")", ")", "\n", "h", "=", "self", ".", "drop", "(", "F", ".", "relu", "(", "self", ".", "fc2", "(", "h", ")", ")", ")", "\n", "if", "self", ".", "notMNIST", ":", "\n", "            ", "h", "=", "self", ".", "drop", "(", "F", ".", "relu", "(", "self", ".", "fc3", "(", "h", ")", ")", ")", "\n", "h", "=", "self", ".", "drop", "(", "F", ".", "relu", "(", "self", ".", "fc4", "(", "h", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "split", ":", "\n", "            ", "y", "=", "[", "]", "\n", "for", "t", ",", "i", "in", "self", ".", "taskcla", ":", "\n", "                ", "y", ".", "append", "(", "self", ".", "last", "[", "t", "]", "(", "h", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "y", "=", "self", ".", "fc3", "(", "h", ")", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.__init__": [[8, 47], ["super().__init__", "torch.nn.ReLU", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Embedding", "torch.nn.Linear", "torch.nn.Embedding", "torch.nn.Sigmoid", "len", "len", "torch.nn.Linear", "torch.nn.Embedding", "torch.nn.Linear", "torch.nn.Embedding", "torch.nn.ModuleList", "torch.nn.Linear", "len", "len", "mlp_hat.Net.last.append", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inputsize", ",", "taskcla", ",", "unitN", "=", "400", ",", "split", "=", "False", ",", "notMNIST", "=", "False", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "ncha", ",", "size", ",", "_", "=", "inputsize", "\n", "self", ".", "notMNIST", "=", "notMNIST", "\n", "if", "notMNIST", ":", "\n", "            ", "unitN", "=", "150", "\n", "", "self", ".", "taskcla", "=", "taskcla", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "drop1", "=", "torch", ".", "nn", ".", "Dropout", "(", "0.2", ")", "\n", "self", ".", "drop2", "=", "torch", ".", "nn", ".", "Dropout", "(", "0.5", ")", "\n", "self", ".", "fc1", "=", "torch", ".", "nn", ".", "Linear", "(", "ncha", "*", "size", "*", "size", ",", "unitN", ")", "\n", "self", ".", "efc1", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "unitN", ")", "\n", "self", ".", "fc2", "=", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "unitN", ")", "\n", "self", ".", "efc2", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "unitN", ")", "\n", "if", "notMNIST", ":", "\n", "            ", "self", ".", "fc3", "=", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "unitN", ")", "\n", "self", ".", "efc3", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "unitN", ")", "\n", "self", ".", "fc4", "=", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "unitN", ")", "\n", "self", ".", "efc4", "=", "torch", ".", "nn", ".", "Embedding", "(", "len", "(", "self", ".", "taskcla", ")", ",", "unitN", ")", "\n", "\n", "", "if", "split", ":", "\n", "            ", "self", ".", "last", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "                ", "self", ".", "last", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "n", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "fc3", "=", "torch", ".", "nn", ".", "Linear", "(", "unitN", ",", "taskcla", "[", "0", "]", "[", "1", "]", ")", "\n", "", "self", ".", "gate", "=", "torch", ".", "nn", ".", "Sigmoid", "(", ")", "\n", "\n", "\n", "\"\"\" (e.g., used with compression experiments)\n        lo,hi=0,2\n        self.efc1.weight.data.uniform_(lo,hi)\n        self.efc2.weight.data.uniform_(lo,hi)\n        self.efc3.weight.data.uniform_(lo,hi)\n        #\"\"\"", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.forward": [[48, 80], ["mlp_hat.Net.gate", "mlp_hat.Net.gate", "mlp_hat.Net.drop2", "mlp_hat.Net.drop1", "mlp_hat.Net.drop1", "x.view", "mlp_hat.Net.relu", "mlp_hat.Net.expand_as", "mlp_hat.Net.relu", "mlp_hat.Net.expand_as", "mlp_hat.Net.gate", "mlp_hat.Net.gate", "mlp_hat.Net.drop1", "mlp_hat.Net.drop1", "mlp_hat.Net.fc3", "mlp_hat.Net.efc1", "mlp_hat.Net.efc2", "x.size", "mlp_hat.Net.fc1", "mlp_hat.Net.fc2", "mlp_hat.Net.relu", "mlp_hat.Net.expand_as", "mlp_hat.Net.relu", "mlp_hat.Net.expand_as", "mlp_hat.Net.append", "mlp_hat.Net.efc3", "mlp_hat.Net.efc4", "mlp_hat.Net.fc3", "mlp_hat.Net.fc4"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "forward", "(", "self", ",", "t", ",", "x", ",", "s", "=", "1", ")", ":", "\n", "# Gates", "\n", "        ", "gfc1", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "efc1", "(", "t", ")", ")", "\n", "gfc2", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "efc2", "(", "t", ")", ")", "\n", "\n", "# Gated", "\n", "h", "=", "self", ".", "drop2", "(", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "relu", "(", "self", ".", "fc1", "(", "h", ")", ")", ")", "\n", "h", "=", "h", "*", "gfc1", ".", "expand_as", "(", "h", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "relu", "(", "self", ".", "fc2", "(", "h", ")", ")", ")", "\n", "h", "=", "h", "*", "gfc2", ".", "expand_as", "(", "h", ")", "\n", "if", "self", ".", "notMNIST", ":", "\n", "            ", "gfc3", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "efc3", "(", "t", ")", ")", "\n", "gfc4", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "efc4", "(", "t", ")", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "relu", "(", "self", ".", "fc3", "(", "h", ")", ")", ")", "\n", "h", "=", "h", "*", "gfc3", ".", "expand_as", "(", "h", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "relu", "(", "self", ".", "fc4", "(", "h", ")", ")", ")", "\n", "h", "=", "h", "*", "gfc4", ".", "expand_as", "(", "h", ")", "\n", "\n", "", "if", "self", ".", "split", ":", "\n", "            ", "y", "=", "[", "]", "\n", "for", "t", ",", "i", "in", "self", ".", "taskcla", ":", "\n", "                ", "y", ".", "append", "(", "self", ".", "last", "[", "t", "]", "(", "h", ")", ")", "\n", "", "", "else", ":", "\n", "#             y=self.relu(self.fc3(h))", "\n", "            ", "y", "=", "self", ".", "fc3", "(", "h", ")", "\n", "\n", "", "masks", "=", "[", "gfc1", ",", "gfc2", "]", "\n", "if", "self", ".", "notMNIST", ":", "\n", "            ", "mask", "=", "[", "gfc1", ",", "gfc2", ",", "gfc3", ",", "gfc4", "]", "\n", "\n", "", "return", "y", ",", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.mask": [[81, 90], ["mlp_hat.Net.gate", "mlp_hat.Net.gate", "mlp_hat.Net.gate", "mlp_hat.Net.gate", "mlp_hat.Net.efc1", "mlp_hat.Net.efc2", "mlp_hat.Net.efc3", "mlp_hat.Net.efc4"], "methods", ["None"], ["", "def", "mask", "(", "self", ",", "t", ",", "s", "=", "1", ")", ":", "\n", "        ", "gfc1", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "efc1", "(", "t", ")", ")", "\n", "gfc2", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "efc2", "(", "t", ")", ")", "\n", "if", "self", ".", "notMNIST", ":", "\n", "            ", "gfc3", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "efc3", "(", "t", ")", ")", "\n", "gfc4", "=", "self", ".", "gate", "(", "s", "*", "self", ".", "efc4", "(", "t", ")", ")", "\n", "return", "[", "gfc1", ",", "gfc2", ",", "gfc3", ",", "gfc4", "]", "\n", "\n", "", "return", "[", "gfc1", ",", "gfc2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.get_view_for": [[92, 124], ["gfc1.data.view().expand_as", "gfc1.data.view", "gfc3.data.view().expand_as", "gfc2.data.view().expand_as", "torch.min", "gfc1.data.view", "gfc2.data.view().expand_as", "gfc1.data.view().expand_as", "torch.min", "gfc3.data.view", "gfc2.data.view", "gfc3.data.view", "gfc2.data.view", "gfc4.data.view().expand_as", "gfc3.data.view().expand_as", "torch.min", "gfc2.data.view", "gfc1.data.view", "gfc4.data.view", "gfc4.data.view", "gfc3.data.view"], "methods", ["None"], ["", "def", "get_view_for", "(", "self", ",", "n", ",", "masks", ")", ":", "\n", "        ", "if", "self", ".", "notMNIST", ":", "\n", "            ", "gfc1", ",", "gfc2", ",", "gfc3", ",", "gfc4", "=", "masks", "\n", "", "else", ":", "\n", "            ", "gfc1", ",", "gfc2", "=", "masks", "\n", "\n", "", "if", "n", "==", "'fc1.weight'", ":", "\n", "            ", "return", "gfc1", ".", "data", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "fc1", ".", "weight", ")", "\n", "", "elif", "n", "==", "'fc1.bias'", ":", "\n", "            ", "return", "gfc1", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "", "elif", "n", "==", "'fc2.weight'", ":", "\n", "            ", "post", "=", "gfc2", ".", "data", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "fc2", ".", "weight", ")", "\n", "pre", "=", "gfc1", ".", "data", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "self", ".", "fc2", ".", "weight", ")", "\n", "return", "torch", ".", "min", "(", "post", ",", "pre", ")", "\n", "", "elif", "n", "==", "'fc2.bias'", ":", "\n", "            ", "return", "gfc2", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "", "if", "self", ".", "notMNIST", ":", "\n", "            ", "if", "n", "==", "'fc3.weight'", ":", "\n", "                ", "post", "=", "gfc3", ".", "data", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "fc3", ".", "weight", ")", "\n", "pre", "=", "gfc2", ".", "data", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "self", ".", "fc3", ".", "weight", ")", "\n", "return", "torch", ".", "min", "(", "post", ",", "pre", ")", "\n", "", "elif", "n", "==", "'fc3.bias'", ":", "\n", "                ", "return", "gfc3", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "", "elif", "n", "==", "'fc4.weight'", ":", "\n", "                ", "post", "=", "gfc4", ".", "data", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "self", ".", "fc4", ".", "weight", ")", "\n", "pre", "=", "gfc3", ".", "data", ".", "view", "(", "1", ",", "-", "1", ")", ".", "expand_as", "(", "self", ".", "fc4", ".", "weight", ")", "\n", "return", "torch", ".", "min", "(", "post", ",", "pre", ")", "\n", "", "elif", "n", "==", "'fc4.bias'", ":", "\n", "                ", "return", "gfc4", ".", "data", ".", "view", "(", "-", "1", ")", "\n", "\n", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot.Net.__init__": [[7, 31], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.Conv2d", "torch.Conv2d", "compute_conv_output_size", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "conv_net_omniglot.Net.last.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size"], ["    ", "def", "__init__", "(", "self", ",", "inputsize", ",", "taskcla", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "ncha", ",", "size", ",", "_", "=", "inputsize", "#28", "\n", "self", ".", "taskcla", "=", "taskcla", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "ncha", ",", "64", ",", "kernel_size", "=", "3", ")", "\n", "s", "=", "compute_conv_output_size", "(", "size", ",", "3", ")", "#26", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ")", "#24", "\n", "s", "=", "s", "//", "2", "#12", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ")", "#10", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ")", "#8", "\n", "s", "=", "s", "//", "2", "#4", "\n", "\n", "self", ".", "MaxPool", "=", "torch", ".", "nn", ".", "MaxPool2d", "(", "2", ")", "\n", "\n", "self", ".", "last", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "            ", "self", ".", "last", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "s", "*", "s", "*", "64", ",", "n", ")", ")", "#4*4*64 = 1024", "\n", "", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot.Net.forward": [[32, 45], ["conv_net_omniglot.Net.relu", "conv_net_omniglot.Net.relu", "conv_net_omniglot.Net.MaxPool", "conv_net_omniglot.Net.relu", "conv_net_omniglot.Net.relu", "conv_net_omniglot.Net.MaxPool", "h.view.view.view", "conv_net_omniglot.Net.conv1", "conv_net_omniglot.Net.conv2", "conv_net_omniglot.Net.conv3", "conv_net_omniglot.Net.conv4", "y.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "h", "=", "self", ".", "relu", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv2", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "MaxPool", "(", "h", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv3", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv4", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "MaxPool", "(", "h", ")", "\n", "h", "=", "h", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "y", "=", "[", "]", "\n", "for", "t", ",", "i", "in", "self", ".", "taskcla", ":", "\n", "            ", "y", ".", "append", "(", "self", ".", "last", "[", "t", "]", "(", "h", ")", ")", "\n", "\n", "", "return", "y", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_ucl.Net.__init__": [[13, 46], ["torch.Module.__init__", "bayes_layer.BayesianConv2D", "conv_net_ucl.compute_conv_output_size", "bayes_layer.BayesianConv2D", "conv_net_ucl.compute_conv_output_size", "bayes_layer.BayesianConv2D", "conv_net_ucl.compute_conv_output_size", "bayes_layer.BayesianConv2D", "conv_net_ucl.compute_conv_output_size", "bayes_layer.BayesianConv2D", "conv_net_ucl.compute_conv_output_size", "bayes_layer.BayesianConv2D", "conv_net_ucl.compute_conv_output_size", "bayes_layer.BayesianLinear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "conv_net_ucl.Net.last.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size"], ["    ", "def", "__init__", "(", "self", ",", "inputsize", ",", "taskcla", ",", "ratio", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "ncha", ",", "size", ",", "_", "=", "inputsize", "\n", "self", ".", "taskcla", "=", "taskcla", "\n", "\n", "self", ".", "conv1", "=", "BayesianConv2D", "(", "ncha", ",", "32", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "size", ",", "3", ",", "padding", "=", "1", ")", "# 32", "\n", "self", ".", "conv2", "=", "BayesianConv2D", "(", "32", ",", "32", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 32", "\n", "s", "=", "s", "//", "2", "# 16", "\n", "self", ".", "conv3", "=", "BayesianConv2D", "(", "32", ",", "64", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 16", "\n", "self", ".", "conv4", "=", "BayesianConv2D", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 16", "\n", "s", "=", "s", "//", "2", "# 8", "\n", "self", ".", "conv5", "=", "BayesianConv2D", "(", "64", ",", "128", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 8", "\n", "self", ".", "conv6", "=", "BayesianConv2D", "(", "128", ",", "128", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ",", "padding", "=", "1", ")", "# 8", "\n", "#         self.conv7 = BayesianConv2D(128,128,kernel_size=3, padding=1, ratio)", "\n", "#         s = compute_conv_output_size(s,3, padding=1) # 8", "\n", "s", "=", "s", "//", "2", "# 4", "\n", "self", ".", "fc1", "=", "BayesianLinear", "(", "s", "*", "s", "*", "128", ",", "256", ",", "ratio", "=", "ratio", ")", "\n", "self", ".", "drop1", "=", "nn", ".", "Dropout", "(", "0.25", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "Dropout", "(", "0.5", ")", "\n", "self", ".", "MaxPool", "=", "torch", ".", "nn", ".", "MaxPool2d", "(", "2", ")", "\n", "\n", "self", ".", "last", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "            ", "self", ".", "last", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "256", ",", "n", ")", ")", "\n", "", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_ucl.Net.forward": [[47, 65], ["conv_net_ucl.Net.relu", "conv_net_ucl.Net.relu", "conv_net_ucl.Net.drop1", "conv_net_ucl.Net.relu", "conv_net_ucl.Net.relu", "conv_net_ucl.Net.drop1", "conv_net_ucl.Net.relu", "conv_net_ucl.Net.relu", "conv_net_ucl.Net.drop1", "conv_net_ucl.Net.view", "conv_net_ucl.Net.drop2", "conv_net_ucl.Net.conv1", "conv_net_ucl.Net.conv2", "conv_net_ucl.Net.MaxPool", "conv_net_ucl.Net.conv3", "conv_net_ucl.Net.conv4", "conv_net_ucl.Net.MaxPool", "conv_net_ucl.Net.conv5", "conv_net_ucl.Net.conv6", "conv_net_ucl.Net.MaxPool", "conv_net_ucl.Net.relu", "y.append", "conv_net_ucl.Net.fc1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "sample", "=", "False", ")", ":", "\n", "        ", "h", "=", "self", ".", "relu", "(", "self", ".", "conv1", "(", "x", ",", "sample", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv2", "(", "h", ",", "sample", ")", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "MaxPool", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv3", "(", "h", ",", "sample", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv4", "(", "h", ",", "sample", ")", ")", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "MaxPool", "(", "h", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv5", "(", "h", ",", "sample", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv6", "(", "h", ",", "sample", ")", ")", "\n", "#         h=self.relu(self.conv7(h,sample))", "\n", "h", "=", "self", ".", "drop1", "(", "self", ".", "MaxPool", "(", "h", ")", ")", "\n", "h", "=", "h", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "h", "=", "self", ".", "drop2", "(", "self", ".", "relu", "(", "self", ".", "fc1", "(", "h", ",", "sample", ")", ")", ")", "\n", "y", "=", "[", "]", "\n", "for", "t", ",", "i", "in", "self", ".", "taskcla", ":", "\n", "            ", "y", ".", "append", "(", "self", ".", "last", "[", "t", "]", "(", "h", ")", ")", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_ucl.compute_conv_output_size": [[9, 11], ["int", "numpy.floor", "float"], "function", ["None"], ["def", "compute_conv_output_size", "(", "Lin", ",", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ")", ":", "\n", "    ", "return", "int", "(", "np", ".", "floor", "(", "(", "Lin", "+", "2", "*", "padding", "-", "dilation", "*", "(", "kernel_size", "-", "1", ")", "-", "1", ")", "/", "float", "(", "stride", ")", "+", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.Net.__init__": [[13, 37], ["torch.Module.__init__", "bayes_layer.BayesianConv2D", "conv_net_omniglot_ucl.compute_conv_output_size", "bayes_layer.BayesianConv2D", "conv_net_omniglot_ucl.compute_conv_output_size", "bayes_layer.BayesianConv2D", "conv_net_omniglot_ucl.compute_conv_output_size", "bayes_layer.BayesianConv2D", "conv_net_omniglot_ucl.compute_conv_output_size", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "conv_net_omniglot_ucl.Net.last.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size"], ["    ", "def", "__init__", "(", "self", ",", "inputsize", ",", "taskcla", ",", "ratio", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "ncha", ",", "size", ",", "_", "=", "inputsize", "#28", "\n", "self", ".", "taskcla", "=", "taskcla", "\n", "\n", "self", ".", "conv1", "=", "BayesianConv2D", "(", "ncha", ",", "64", ",", "kernel_size", "=", "3", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "size", ",", "3", ")", "#26", "\n", "self", ".", "conv2", "=", "BayesianConv2D", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ")", "#24", "\n", "s", "=", "s", "//", "2", "#12", "\n", "self", ".", "conv3", "=", "BayesianConv2D", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ")", "#10", "\n", "self", ".", "conv4", "=", "BayesianConv2D", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "ratio", "=", "ratio", ")", "\n", "s", "=", "compute_conv_output_size", "(", "s", ",", "3", ")", "#8", "\n", "s", "=", "s", "//", "2", "#4", "\n", "\n", "self", ".", "MaxPool", "=", "torch", ".", "nn", ".", "MaxPool2d", "(", "2", ")", "\n", "\n", "self", ".", "last", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "            ", "self", ".", "last", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "s", "*", "s", "*", "64", ",", "n", ")", ")", "#4*4*64 = 1024", "\n", "", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.Net.forward": [[38, 51], ["conv_net_omniglot_ucl.Net.relu", "conv_net_omniglot_ucl.Net.relu", "conv_net_omniglot_ucl.Net.MaxPool", "conv_net_omniglot_ucl.Net.relu", "conv_net_omniglot_ucl.Net.relu", "conv_net_omniglot_ucl.Net.MaxPool", "h.view.view.view", "conv_net_omniglot_ucl.Net.conv1", "conv_net_omniglot_ucl.Net.conv2", "conv_net_omniglot_ucl.Net.conv3", "conv_net_omniglot_ucl.Net.conv4", "y.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "sample", "=", "False", ")", ":", "\n", "        ", "h", "=", "self", ".", "relu", "(", "self", ".", "conv1", "(", "x", ",", "sample", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv2", "(", "h", ",", "sample", ")", ")", "\n", "h", "=", "self", ".", "MaxPool", "(", "h", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv3", "(", "h", ",", "sample", ")", ")", "\n", "h", "=", "self", ".", "relu", "(", "self", ".", "conv4", "(", "h", ",", "sample", ")", ")", "\n", "h", "=", "self", ".", "MaxPool", "(", "h", ")", "\n", "h", "=", "h", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "y", "=", "[", "]", "\n", "for", "t", ",", "i", "in", "self", ".", "taskcla", ":", "\n", "            ", "y", ".", "append", "(", "self", ".", "last", "[", "t", "]", "(", "h", ")", ")", "\n", "\n", "", "return", "y", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.networks.conv_net_omniglot_ucl.compute_conv_output_size": [[9, 11], ["int", "numpy.floor", "float"], "function", ["None"], ["def", "compute_conv_output_size", "(", "Lin", ",", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ")", ":", "\n", "    ", "return", "int", "(", "np", ".", "floor", "(", "(", "Lin", "+", "2", "*", "padding", "-", "dilation", "*", "(", "kernel_size", "-", "1", ")", "-", "1", ")", "/", "float", "(", "stride", ")", "+", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ewc.PPO_EWC.__init__": [[8, 45], ["print", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "actor_critic.parameters"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "actor_critic", ",", "\n", "clip_param", ",", "\n", "ppo_epoch", ",", "\n", "num_mini_batch", ",", "\n", "value_loss_coef", ",", "\n", "entropy_coef", ",", "\n", "lr", "=", "None", ",", "\n", "eps", "=", "None", ",", "\n", "max_grad_norm", "=", "None", ",", "\n", "use_clipped_value_loss", "=", "True", ",", "\n", "ewc_epoch", "=", "1", ",", "\n", "ewc_lambda", "=", "5000", ",", "\n", "gamma", "=", "0.99", ",", "\n", "online", "=", "False", ")", ":", "\n", "\n", "        ", "self", ".", "actor_critic", "=", "actor_critic", "\n", "\n", "self", ".", "clip_param", "=", "clip_param", "\n", "self", ".", "ppo_epoch", "=", "ppo_epoch", "\n", "self", ".", "num_mini_batch", "=", "num_mini_batch", "\n", "\n", "self", ".", "value_loss_coef", "=", "value_loss_coef", "\n", "self", ".", "entropy_coef", "=", "entropy_coef", "\n", "\n", "self", ".", "max_grad_norm", "=", "max_grad_norm", "\n", "self", ".", "use_clipped_value_loss", "=", "use_clipped_value_loss", "\n", "\n", "self", ".", "ewc_epoch", "=", "ewc_epoch", "\n", "self", ".", "ewc_lambda", "=", "ewc_lambda", "\n", "self", ".", "gamma", "=", "gamma", "\n", "\n", "print", "(", "'ewc_lambda : '", ",", "self", ".", "ewc_lambda", ")", "\n", "\n", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "actor_critic", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "eps", "=", "eps", ")", "\n", "self", ".", "EWC_task_count", "=", "0", "\n", "self", ".", "online", "=", "online", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ewc.PPO_EWC.update": [[46, 111], ["range", "advantages.mean", "advantages.std", "rollouts.recurrent_generator", "rollouts.feed_forward_generator", "ppo_ewc.PPO_EWC.actor_critic.evaluate_actions", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "ppo_ewc.PPO_EWC.optimizer.zero_grad", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "ppo_ewc.PPO_EWC.optimizer.step", "value_loss.item", "action_loss.item", "dist_entropy.item", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "ppo_ewc.PPO_EWC.ewc_loss", "ppo_ewc.PPO_EWC.actor_critic.parameters", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.recurrent_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.feed_forward_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.evaluate_actions", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ewc.PPO_EWC.ewc_loss"], ["", "def", "update", "(", "self", ",", "rollouts", ",", "task_num", ")", ":", "\n", "        ", "advantages", "=", "rollouts", ".", "returns", "[", ":", "-", "1", "]", "-", "rollouts", ".", "value_preds", "[", ":", "-", "1", "]", "\n", "advantages", "=", "(", "advantages", "-", "advantages", ".", "mean", "(", ")", ")", "/", "(", "\n", "advantages", ".", "std", "(", ")", "+", "1e-5", ")", "\n", "\n", "value_loss_epoch", "=", "0", "\n", "action_loss_epoch", "=", "0", "\n", "dist_entropy_epoch", "=", "0", "\n", "\n", "for", "e", "in", "range", "(", "self", ".", "ppo_epoch", ")", ":", "\n", "            ", "if", "self", ".", "actor_critic", ".", "is_recurrent", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "recurrent_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "", "else", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "feed_forward_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "\n", "", "for", "sample", "in", "data_generator", ":", "\n", "                ", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "actions_batch", ",", "value_preds_batch", ",", "return_batch", ",", "masks_batch", ",", "old_action_log_probs_batch", ",", "adv_targ", "=", "sample", "\n", "\n", "# Reshape to do in a single forward pass for all steps", "\n", "values", ",", "action_log_probs", ",", "dist_entropy", ",", "_", "=", "self", ".", "actor_critic", ".", "evaluate_actions", "(", "\n", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "masks_batch", ",", "\n", "actions_batch", ",", "task_num", ")", "\n", "\n", "ratio", "=", "torch", ".", "exp", "(", "action_log_probs", "-", "\n", "old_action_log_probs_batch", ")", "\n", "surr1", "=", "ratio", "*", "adv_targ", "\n", "surr2", "=", "torch", ".", "clamp", "(", "ratio", ",", "1.0", "-", "self", ".", "clip_param", ",", "\n", "1.0", "+", "self", ".", "clip_param", ")", "*", "adv_targ", "\n", "action_loss", "=", "-", "torch", ".", "min", "(", "surr1", ",", "surr2", ")", ".", "mean", "(", ")", "\n", "\n", "if", "self", ".", "use_clipped_value_loss", ":", "\n", "                    ", "value_pred_clipped", "=", "value_preds_batch", "+", "(", "values", "-", "value_preds_batch", ")", ".", "clamp", "(", "-", "self", ".", "clip_param", ",", "self", ".", "clip_param", ")", "\n", "value_losses", "=", "(", "values", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_losses_clipped", "=", "(", "\n", "value_pred_clipped", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_loss", "=", "0.5", "*", "torch", ".", "max", "(", "value_losses", ",", "\n", "value_losses_clipped", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                    ", "value_loss", "=", "0.5", "*", "(", "return_batch", "-", "values", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "reg_loss", "=", "self", ".", "ewc_lambda", "*", "self", ".", "ewc_loss", "(", ")", "\n", "(", "value_loss", "*", "self", ".", "value_loss_coef", "+", "action_loss", "-", "\n", "dist_entropy", "*", "self", ".", "entropy_coef", "+", "reg_loss", ")", ".", "backward", "(", ")", "\n", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "actor_critic", ".", "parameters", "(", ")", ",", "\n", "self", ".", "max_grad_norm", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "value_loss_epoch", "+=", "value_loss", ".", "item", "(", ")", "\n", "action_loss_epoch", "+=", "action_loss", ".", "item", "(", ")", "\n", "dist_entropy_epoch", "+=", "dist_entropy", ".", "item", "(", ")", "\n", "\n", "", "", "num_updates", "=", "self", ".", "ppo_epoch", "*", "self", ".", "num_mini_batch", "\n", "\n", "value_loss_epoch", "/=", "num_updates", "\n", "action_loss_epoch", "/=", "num_updates", "\n", "dist_entropy_epoch", "/=", "num_updates", "\n", "\n", "return", "value_loss_epoch", ",", "action_loss_epoch", ",", "dist_entropy_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ewc.PPO_EWC.update_fisher": [[112, 120], ["print", "ppo_ewc.PPO_EWC.actor_critic.named_parameters", "ppo_ewc.PPO_EWC.estimate_fisher", "ppo_ewc.PPO_EWC.store_fisher_n_params", "n.replace.replace.replace", "fisher_dict.update", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ewc.PPO_EWC.estimate_fisher", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ewc.PPO_EWC.store_fisher_n_params", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.update"], ["", "def", "update_fisher", "(", "self", ",", "rollouts", ",", "task_num", ")", ":", "\n", "        ", "print", "(", "\"updating fisher matrix for task %d\"", "%", "task_num", ")", "\n", "fisher_dict", "=", "{", "}", "\n", "for", "n", ",", "p", "in", "self", ".", "actor_critic", ".", "named_parameters", "(", ")", ":", "\n", "            ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "fisher_dict", ".", "update", "(", "{", "n", ":", "torch", ".", "zeros_like", "(", "p", ")", "}", ")", "\n", "", "new_fisher", "=", "self", ".", "estimate_fisher", "(", "rollouts", "=", "rollouts", ",", "fisher_dict", "=", "fisher_dict", ",", "task_num", "=", "task_num", ")", "\n", "self", ".", "store_fisher_n_params", "(", "new_fisher", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ewc.PPO_EWC.estimate_fisher": [[121, 182], ["range", "advantages.mean", "advantages.std", "rollouts.recurrent_generator", "rollouts.feed_forward_generator", "ppo_ewc.PPO_EWC.actor_critic.evaluate_actions", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "ppo_ewc.PPO_EWC.optimizer.zero_grad", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "ppo_ewc.PPO_EWC.actor_critic.named_parameters", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "ppo_ewc.PPO_EWC.actor_critic.parameters", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "n.replace.replace.replace", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "p.grad.detach"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.recurrent_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.feed_forward_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.evaluate_actions"], ["", "def", "estimate_fisher", "(", "self", ",", "rollouts", ",", "fisher_dict", ",", "task_num", ")", ":", "\n", "\n", "        ", "est_fisher_info", "=", "fisher_dict", "\n", "\n", "advantages", "=", "rollouts", ".", "returns", "[", ":", "-", "1", "]", "-", "rollouts", ".", "value_preds", "[", ":", "-", "1", "]", "\n", "advantages", "=", "(", "advantages", "-", "advantages", ".", "mean", "(", ")", ")", "/", "(", "\n", "advantages", ".", "std", "(", ")", "+", "1e-5", ")", "\n", "\n", "value_loss_epoch", "=", "0", "\n", "action_loss_epoch", "=", "0", "\n", "dist_entropy_epoch", "=", "0", "\n", "\n", "for", "e", "in", "range", "(", "self", ".", "ewc_epoch", ")", ":", "\n", "            ", "if", "self", ".", "actor_critic", ".", "is_recurrent", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "recurrent_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "", "else", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "feed_forward_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "\n", "", "for", "sample", "in", "data_generator", ":", "\n", "                ", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "actions_batch", ",", "value_preds_batch", ",", "return_batch", ",", "masks_batch", ",", "old_action_log_probs_batch", ",", "adv_targ", "=", "sample", "\n", "\n", "# Reshape to do in a single forward pass for all steps", "\n", "values", ",", "action_log_probs", ",", "dist_entropy", ",", "_", "=", "self", ".", "actor_critic", ".", "evaluate_actions", "(", "\n", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "masks_batch", ",", "\n", "actions_batch", ",", "task_num", ")", "\n", "\n", "ratio", "=", "torch", ".", "exp", "(", "action_log_probs", "-", "\n", "old_action_log_probs_batch", ")", "\n", "surr1", "=", "ratio", "*", "adv_targ", "\n", "surr2", "=", "torch", ".", "clamp", "(", "ratio", ",", "1.0", "-", "self", ".", "clip_param", ",", "\n", "1.0", "+", "self", ".", "clip_param", ")", "*", "adv_targ", "\n", "action_loss", "=", "-", "torch", ".", "min", "(", "surr1", ",", "surr2", ")", ".", "mean", "(", ")", "\n", "\n", "if", "self", ".", "use_clipped_value_loss", ":", "\n", "                    ", "value_pred_clipped", "=", "value_preds_batch", "+", "(", "values", "-", "value_preds_batch", ")", ".", "clamp", "(", "-", "self", ".", "clip_param", ",", "self", ".", "clip_param", ")", "\n", "value_losses", "=", "(", "values", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_losses_clipped", "=", "(", "\n", "value_pred_clipped", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_loss", "=", "0.5", "*", "torch", ".", "max", "(", "value_losses", ",", "\n", "value_losses_clipped", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                    ", "value_loss", "=", "0.5", "*", "(", "return_batch", "-", "values", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "(", "value_loss", "*", "self", ".", "value_loss_coef", "+", "action_loss", "-", "\n", "dist_entropy", "*", "self", ".", "entropy_coef", ")", ".", "backward", "(", ")", "\n", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "actor_critic", ".", "parameters", "(", ")", ",", "\n", "self", ".", "max_grad_norm", ")", "\n", "\n", "for", "n", ",", "p", "in", "self", ".", "actor_critic", ".", "named_parameters", "(", ")", ":", "\n", "                    ", "if", "p", ".", "requires_grad", ":", "\n", "                        ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "                            ", "est_fisher_info", "[", "n", "]", "+=", "p", ".", "grad", ".", "detach", "(", ")", "**", "2", "\n", "\n", "", "", "", "", "", "return", "est_fisher_info", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ewc.PPO_EWC.store_fisher_n_params": [[183, 200], ["ppo_ewc.PPO_EWC.actor_critic.named_parameters", "n.replace.replace.replace", "ppo_ewc.PPO_EWC.actor_critic.register_buffer", "ppo_ewc.PPO_EWC.actor_critic.register_buffer", "p.detach().clone", "getattr", "p.detach"], "methods", ["None"], ["", "def", "store_fisher_n_params", "(", "self", ",", "fisher", ")", ":", "\n", "# Store new values in the network", "\n", "        ", "for", "n", ",", "p", "in", "self", ".", "actor_critic", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "requires_grad", ":", "\n", "                ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "# -mode (=MAP parameter estimate)", "\n", "self", ".", "actor_critic", ".", "register_buffer", "(", "'{}_EWC_prev_task{}'", ".", "format", "(", "n", ",", "\"\"", "if", "self", ".", "online", "else", "self", ".", "EWC_task_count", "+", "1", ")", ",", "\n", "p", ".", "detach", "(", ")", ".", "clone", "(", ")", ")", "\n", "# -precision (approximated by diagonal Fisher Information matrix)", "\n", "if", "self", ".", "online", "and", "self", ".", "EWC_task_count", "==", "1", ":", "\n", "                    ", "existing_values", "=", "getattr", "(", "self", ".", "actor_critic", ",", "'{}_EWC_estimated_fisher'", ".", "format", "(", "n", ")", ")", "\n", "fisher", "[", "n", "]", "+=", "self", ".", "gamma", "*", "existing_values", "\n", "", "self", ".", "actor_critic", ".", "register_buffer", "(", "'{}_EWC_estimated_fisher{}'", ".", "format", "(", "n", ",", "\"\"", "if", "self", ".", "online", "else", "self", ".", "EWC_task_count", "+", "1", ")", ",", "\n", "fisher", "[", "n", "]", ")", "\n", "\n", "# If \"offline EWC\", increase task-count (for \"online EWC\", set it to 1 to indicate EWC-loss can be calculated)", "\n", "", "", "self", ".", "EWC_task_count", "=", "1", "if", "self", ".", "online", "else", "self", ".", "EWC_task_count", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ewc.PPO_EWC.ewc_loss": [[201, 222], ["range", "ppo_ewc.PPO_EWC.actor_critic.named_parameters", "sum", "n.replace.replace.replace", "getattr", "getattr", "losses.append"], "methods", ["None"], ["", "def", "ewc_loss", "(", "self", ")", ":", "\n", "        ", "'''Calculate EWC-loss.'''", "\n", "if", "self", ".", "EWC_task_count", ">", "0", ":", "\n", "            ", "losses", "=", "[", "]", "\n", "# If \"offline EWC\", loop over all previous tasks (if \"online EWC\", [EWC_task_count]=1 so only 1 iteration)", "\n", "for", "task", "in", "range", "(", "1", ",", "self", ".", "EWC_task_count", "+", "1", ")", ":", "\n", "                ", "for", "n", ",", "p", "in", "self", ".", "actor_critic", ".", "named_parameters", "(", ")", ":", "\n", "                    ", "if", "p", ".", "requires_grad", ":", "\n", "# Retrieve stored mode (MAP estimate) and precision (Fisher Information matrix)", "\n", "                        ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "mean", "=", "getattr", "(", "self", ".", "actor_critic", ",", "'{}_EWC_prev_task{}'", ".", "format", "(", "n", ",", "\"\"", "if", "self", ".", "online", "else", "task", ")", ")", "\n", "fisher", "=", "getattr", "(", "self", ".", "actor_critic", ",", "'{}_EWC_estimated_fisher{}'", ".", "format", "(", "n", ",", "\"\"", "if", "self", ".", "online", "else", "task", ")", ")", "\n", "# If \"online EWC\", apply decay-term to the running sum of the Fisher Information matrices", "\n", "fisher", "=", "self", ".", "gamma", "*", "fisher", "if", "self", ".", "online", "else", "fisher", "\n", "# Calculate EWC-loss", "\n", "losses", ".", "append", "(", "(", "fisher", "*", "(", "p", "-", "mean", ")", "**", "2", ")", ".", "sum", "(", ")", ")", "\n", "# Sum EWC-loss from all parameters (and from all tasks, if \"offline EWC\")", "\n", "", "", "", "return", "(", "1.", "/", "2", ")", "*", "sum", "(", "losses", ")", "\n", "", "else", ":", "\n", "# EWC-loss is 0 if there are no stored mode and precision yet", "\n", "            ", "return", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.__init__": [[29, 34], ["object.__init__", "mu.cuda", "rho.cuda", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "mu", ",", "rho", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mu", "=", "mu", ".", "cuda", "(", ")", "\n", "self", ".", "rho", "=", "rho", ".", "cuda", "(", ")", "\n", "self", ".", "normal", "=", "torch", ".", "distributions", ".", "Normal", "(", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sigma": [[35, 38], ["torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "@", "property", "\n", "def", "sigma", "(", "self", ")", ":", "\n", "        ", "return", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "self", ".", "rho", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample": [[39, 42], ["baye_layer.Gaussian.normal.sample().cuda", "baye_layer.Gaussian.normal.sample", "baye_layer.Gaussian.mu.size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "sample", "(", "self", ")", ":", "\n", "        ", "epsilon", "=", "self", ".", "normal", ".", "sample", "(", "self", ".", "mu", ".", "size", "(", ")", ")", ".", "cuda", "(", ")", "\n", "return", "self", ".", "mu", "+", "self", ".", "sigma", "*", "epsilon", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.BayesianLinear.__init__": [[44, 68], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "baye_layer._calculate_fan_in_and_fan_out", "numpy.log", "torch.init.uniform_", "torch.init.uniform_", "torch.init.uniform_", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "baye_layer.Gaussian", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "math.sqrt", "math.sqrt", "math.sqrt", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "numpy.exp", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer._calculate_fan_in_and_fan_out"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "ratio", "=", "0.5", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "\n", "self", ".", "weight_mu", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_features", ",", "in_features", ")", ")", "\n", "\n", "fan_in", ",", "_", "=", "_calculate_fan_in_and_fan_out", "(", "self", ".", "weight_mu", ")", "\n", "gain", "=", "1", "# Var[w] + sigma^2 = 2/fan_in", "\n", "\n", "total_var", "=", "2", "/", "fan_in", "\n", "noise_var", "=", "total_var", "*", "ratio", "\n", "mu_var", "=", "total_var", "-", "noise_var", "\n", "\n", "noise_std", ",", "mu_std", "=", "math", ".", "sqrt", "(", "noise_var", ")", ",", "math", ".", "sqrt", "(", "mu_var", ")", "\n", "bound", "=", "math", ".", "sqrt", "(", "3.0", ")", "*", "mu_std", "\n", "rho_init", "=", "np", ".", "log", "(", "np", ".", "exp", "(", "noise_std", ")", "-", "1", ")", "\n", "\n", "nn", ".", "init", ".", "uniform_", "(", "self", ".", "weight_mu", ",", "-", "bound", ",", "bound", ")", "\n", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_features", ")", ".", "uniform_", "(", "0", ",", "0", ")", ")", "\n", "\n", "self", ".", "weight_rho", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "out_features", ",", "1", ")", ".", "uniform_", "(", "rho_init", ",", "rho_init", ")", ")", "\n", "\n", "self", ".", "weight", "=", "Gaussian", "(", "self", ".", "weight_mu", ",", "self", ".", "weight_rho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.BayesianLinear.forward": [[69, 78], ["torch.linear", "torch.linear", "torch.linear", "baye_layer.BayesianLinear.weight.sample"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample"], ["", "def", "forward", "(", "self", ",", "input", ",", "sample", "=", "False", ")", ":", "\n", "        ", "if", "sample", ":", "\n", "            ", "weight", "=", "self", ".", "weight", ".", "sample", "(", ")", "\n", "bias", "=", "self", ".", "bias", "\n", "", "else", ":", "\n", "            ", "weight", "=", "self", ".", "weight", ".", "mu", "\n", "bias", "=", "self", ".", "bias", "\n", "\n", "", "return", "F", ".", "linear", "(", "input", ",", "weight", ",", "bias", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer._calculate_fan_in_and_fan_out": [[9, 27], ["tensor.dim", "ValueError", "tensor.size", "tensor.size", "tensor.size", "tensor.size", "tensor.dim", "[].numel"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["def", "_calculate_fan_in_and_fan_out", "(", "tensor", ")", ":", "\n", "    ", "dimensions", "=", "tensor", ".", "dim", "(", ")", "\n", "if", "dimensions", "<", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Fan in and fan out can not be computed for tensor with fewer than 2 dimensions\"", ")", "\n", "\n", "", "if", "dimensions", "==", "2", ":", "# Linear", "\n", "        ", "fan_in", "=", "tensor", ".", "size", "(", "1", ")", "\n", "fan_out", "=", "tensor", ".", "size", "(", "0", ")", "\n", "", "else", ":", "\n", "        ", "num_input_fmaps", "=", "tensor", ".", "size", "(", "1", ")", "\n", "num_output_fmaps", "=", "tensor", ".", "size", "(", "0", ")", "\n", "receptive_field_size", "=", "1", "\n", "if", "tensor", ".", "dim", "(", ")", ">", "2", ":", "\n", "            ", "receptive_field_size", "=", "tensor", "[", "0", "]", "[", "0", "]", ".", "numel", "(", ")", "\n", "", "fan_in", "=", "num_input_fmaps", "*", "receptive_field_size", "\n", "fan_out", "=", "num_output_fmaps", "*", "receptive_field_size", "\n", "\n", "", "return", "fan_in", ",", "fan_out", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.train_ppo.train_ppo": [[13, 116], ["time.time", "tqdm.tqdm", "range", "range", "rollouts.compute_returns", "agent.update", "rollouts.after_update", "a2c_ppo_acktr.utils.update_linear_schedule", "envs.step", "torch.FloatTensor", "torch.FloatTensor", "rollouts.insert", "torch.no_grad", "actor_critic.get_value().detach", "os.path.join", "torch.save", "time.time", "print", "tr_reward_arr.append", "print", "range", "range", "range", "scipy.savemat", "torch.no_grad", "actor_critic.act", "torch.clamp", "os.makedirs", "os.path.join", "len", "numpy.mean", "len", "evaluation.evaluate", "print", "len", "len", "[].append", "len", "[].append", "len", "[].append", "info.keys", "episode_rewards.append", "actor_critic.get_value", "getattr", "int", "len", "numpy.mean", "numpy.median", "numpy.min", "numpy.max", "len", "numpy.mean", "numpy.max", "numpy.min", "numpy.array", "numpy.array", "a2c_ppo_acktr.utils.get_vec_normalize", "info.keys", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.compute_returns", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.update", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.after_update", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.update_linear_schedule", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.insert", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.act", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.evaluation.evaluate", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.get_value", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.get_vec_normalize"], ["def", "train_ppo", "(", "actor_critic", ",", "agent", ",", "rollouts", ",", "task_idx", ",", "env_name", ",", "task_sequences", ",", "envs", ",", "new_obs", ",", "obs_shape", ",", "obs_shape_real", ",", "args", ",", "\n", "episode_rewards", ",", "tr_reward_arr", ",", "te_reward_arr", ",", "num_updates", ",", "log_name", ",", "device", ")", ":", "\n", "    ", "start", "=", "time", ".", "time", "(", ")", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "num_updates", ")", ")", ":", "\n", "\n", "        ", "if", "args", ".", "use_linear_lr_decay", ":", "\n", "# decrease learning rate linearly", "\n", "            ", "utils", ".", "update_linear_schedule", "(", "\n", "agent", ".", "optimizer", ",", "j", ",", "num_updates", ",", "args", ".", "lr", ")", "\n", "\n", "", "for", "step", "in", "range", "(", "args", ".", "num_steps", ")", ":", "\n", "# Sample actions", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "value", ",", "action", ",", "action_log_prob", ",", "recurrent_hidden_states", "=", "actor_critic", ".", "act", "(", "\n", "rollouts", ".", "obs", "[", "step", "]", ",", "rollouts", ".", "recurrent_hidden_states", "[", "step", "]", ",", "\n", "rollouts", ".", "masks", "[", "step", "]", ",", "task_idx", ")", "\n", "\n", "# Obser reward and next obs", "\n", "", "if", "env_name", "==", "'MinitaurBulletEnv-v0'", ":", "\n", "                ", "action", "=", "torch", ".", "clamp", "(", "action", ",", "-", "1", ",", "1", ")", "# for MinitaurBulletEnv", "\n", "\n", "", "obs", ",", "reward", ",", "done", ",", "infos", "=", "envs", ".", "step", "(", "action", ")", "\n", "\n", "for", "info", "in", "infos", ":", "\n", "                ", "if", "'episode'", "in", "info", ".", "keys", "(", ")", ":", "\n", "                    ", "episode_rewards", ".", "append", "(", "info", "[", "'episode'", "]", "[", "'r'", "]", ")", "\n", "\n", "# If done then clean the history of observations.", "\n", "", "", "masks", "=", "torch", ".", "FloatTensor", "(", "\n", "[", "[", "0.0", "]", "if", "done_", "else", "[", "1.0", "]", "for", "done_", "in", "done", "]", ")", "\n", "bad_masks", "=", "torch", ".", "FloatTensor", "(", "\n", "[", "[", "0.0", "]", "if", "'bad_transition'", "in", "info", ".", "keys", "(", ")", "else", "[", "1.0", "]", "\n", "for", "info", "in", "infos", "]", ")", "\n", "\n", "if", "args", ".", "experiment", "==", "'roboschool'", ":", "\n", "#### reshape for traiing ###############", "\n", "                ", "new_obs", "[", ":", ",", ":", "obs_shape_real", "[", "0", "]", "]", "=", "obs", "\n", "########################################", "\n", "\n", "", "rollouts", ".", "insert", "(", "new_obs", ",", "recurrent_hidden_states", ",", "action", ",", "\n", "action_log_prob", ",", "value", ",", "reward", ",", "masks", ",", "bad_masks", ")", "\n", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "next_value", "=", "actor_critic", ".", "get_value", "(", "\n", "rollouts", ".", "obs", "[", "-", "1", "]", ",", "rollouts", ".", "recurrent_hidden_states", "[", "-", "1", "]", ",", "\n", "rollouts", ".", "masks", "[", "-", "1", "]", ",", "task_idx", ")", ".", "detach", "(", ")", "\n", "\n", "\n", "", "rollouts", ".", "compute_returns", "(", "next_value", ",", "args", ".", "use_gae", ",", "args", ".", "gamma", ",", "\n", "args", ".", "gae_lambda", ",", "args", ".", "use_proper_time_limits", ")", "\n", "\n", "value_loss", ",", "action_loss", ",", "dist_entropy", "=", "agent", ".", "update", "(", "rollouts", ",", "task_idx", ")", "\n", "\n", "rollouts", ".", "after_update", "(", ")", "\n", "\n", "# save for every interval-th episode or for the last epoch", "\n", "if", "(", "j", "%", "args", ".", "save_interval", "==", "0", "\n", "or", "j", "==", "num_updates", "-", "1", ")", "and", "args", ".", "save_dir", "!=", "\"\"", ":", "\n", "            ", "save_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "save_dir", ",", "args", ".", "algo", ")", "\n", "try", ":", "\n", "                ", "os", ".", "makedirs", "(", "save_path", ")", "\n", "", "except", "OSError", ":", "\n", "                ", "pass", "\n", "\n", "", "torch", ".", "save", "(", "[", "\n", "actor_critic", ",", "\n", "getattr", "(", "utils", ".", "get_vec_normalize", "(", "envs", ")", ",", "'ob_rms'", ",", "None", ")", "\n", "]", ",", "os", ".", "path", ".", "join", "(", "save_path", ",", "log_name", "+", "'_task_'", "+", "str", "(", "task_idx", ")", "+", "\".pt\"", ")", ")", "\n", "\n", "", "if", "j", "%", "args", ".", "log_interval", "==", "0", "and", "len", "(", "episode_rewards", ")", ">", "1", ":", "\n", "            ", "total_num_steps", "=", "(", "j", "+", "1", ")", "*", "args", ".", "num_processes", "*", "args", ".", "num_steps", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\n", "\"Updates {}, num timesteps {}, FPS {} \\n Last {} training episodes: mean/median reward {:.1f}/{:.1f}, min/max reward {:.1f}/{:.1f}\\n\"", "\n", ".", "format", "(", "j", ",", "total_num_steps", ",", "\n", "int", "(", "total_num_steps", "/", "(", "end", "-", "start", ")", ")", ",", "\n", "len", "(", "episode_rewards", ")", ",", "np", ".", "mean", "(", "episode_rewards", ")", ",", "\n", "np", ".", "median", "(", "episode_rewards", ")", ",", "np", ".", "min", "(", "episode_rewards", ")", ",", "\n", "np", ".", "max", "(", "episode_rewards", ")", ",", "dist_entropy", ",", "value_loss", ",", "\n", "action_loss", ")", ")", "\n", "\n", "tr_reward_arr", ".", "append", "(", "np", ".", "mean", "(", "episode_rewards", ")", ")", "\n", "\n", "", "if", "(", "args", ".", "eval_interval", "is", "not", "None", "and", "len", "(", "episode_rewards", ")", ">", "1", "\n", "and", "j", "%", "args", ".", "eval_interval", "==", "0", ")", ":", "\n", "            ", "ob_rms", "=", "None", "\n", "if", "args", ".", "experiment", "==", "'roboschool'", ":", "\n", "                ", "eval_episode_rewards", "=", "evaluate", "(", "actor_critic", ",", "ob_rms", ",", "task_sequences", ",", "args", ".", "seed", ",", "\n", "10", ",", "args", ".", "log_dir", ",", "device", ",", "obs_shape", ",", "task_idx", ",", "args", ".", "gamma", ")", "\n", "print", "(", "len", "(", "eval_episode_rewards", ")", ",", "eval_episode_rewards", "[", "0", "]", ".", "shape", ")", "\n", "", "print", "(", "'len task_sequences : '", ",", "len", "(", "task_sequences", ")", ")", "\n", "for", "idx", "in", "range", "(", "len", "(", "task_sequences", ")", ")", ":", "\n", "                ", "te_reward_arr", "[", "'mean'", "]", "[", "'task'", "+", "str", "(", "idx", ")", "]", ".", "append", "(", "(", "np", ".", "mean", "(", "eval_episode_rewards", "[", "idx", "]", ")", ")", ")", "\n", "\n", "", "for", "idx", "in", "range", "(", "len", "(", "task_sequences", ")", ")", ":", "\n", "                ", "te_reward_arr", "[", "'max'", "]", "[", "'task'", "+", "str", "(", "idx", ")", "]", ".", "append", "(", "(", "np", ".", "max", "(", "eval_episode_rewards", "[", "idx", "]", ")", ")", ")", "\n", "\n", "", "for", "idx", "in", "range", "(", "len", "(", "task_sequences", ")", ")", ":", "\n", "                ", "te_reward_arr", "[", "'min'", "]", "[", "'task'", "+", "str", "(", "idx", ")", "]", ".", "append", "(", "(", "np", ".", "min", "(", "eval_episode_rewards", "[", "idx", "]", ")", ")", ")", "\n", "\n", "", "sio", ".", "savemat", "(", "'./result_data/'", "+", "log_name", "+", "'_result.mat'", ",", "{", "'tr_reward_arr'", ":", "np", ".", "array", "(", "tr_reward_arr", ")", ",", "\n", "'te_reward_arr'", ":", "np", ".", "array", "(", "te_reward_arr", ")", "}", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.Flatten.forward": [[13, 15], ["x.view", "x.size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.Policy.__init__": [[17, 33], ["torch.Module.__init__", "base", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "ucl_model.Policy.dist.append", "len", "a2c_ppo_acktr.distributions.DiagGaussian"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "obs_shape", ",", "taskcla", ",", "base", "=", "None", ",", "ratio_init", "=", "32.", ",", "base_kwargs", "=", "None", ")", ":", "\n", "        ", "super", "(", "Policy", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "base_kwargs", "is", "None", ":", "\n", "            ", "base_kwargs", "=", "{", "}", "\n", "", "if", "base", "is", "None", ":", "\n", "            ", "if", "len", "(", "obs_shape", ")", "==", "1", ":", "\n", "                ", "base", "=", "MLPBase", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "", "", "self", ".", "taskcla", "=", "taskcla", "\n", "self", ".", "num_inputs", "=", "obs_shape", "\n", "self", ".", "base", "=", "base", "(", "obs_shape", "[", "0", "]", ",", "taskcla", ",", "1", "/", "ratio_init", ",", "**", "base_kwargs", ")", "\n", "\n", "self", ".", "dist", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "            ", "self", ".", "dist", ".", "append", "(", "DiagGaussian", "(", "self", ".", "base", ".", "output_size", ",", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.Policy.is_recurrent": [[34, 37], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "is_recurrent", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "base", ".", "is_recurrent", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.Policy.recurrent_hidden_state_size": [[38, 42], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_hidden_state_size", "(", "self", ")", ":", "\n", "        ", "\"\"\"Size of rnn_hx.\"\"\"", "\n", "return", "self", ".", "base", ".", "recurrent_hidden_state_size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.Policy.forward": [[43, 45], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.Policy.act": [[46, 59], ["ucl_model.Policy.base", "dist.log_probs", "dist.entropy().mean", "dist.mode", "dist.sample", "dist.entropy"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.entropy"], ["", "def", "act", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ",", "deterministic", "=", "False", ")", ":", "\n", "        ", "value", ",", "actor_features", ",", "rnn_hxs", "=", "self", ".", "base", "(", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ",", "sample", "=", "True", ")", "\n", "dist", "=", "self", ".", "dist", "[", "task_num", "]", "(", "actor_features", ")", "\n", "\n", "if", "deterministic", ":", "\n", "            ", "action", "=", "dist", ".", "mode", "(", ")", "\n", "", "else", ":", "\n", "            ", "action", "=", "dist", ".", "sample", "(", ")", "\n", "\n", "", "action_log_probs", "=", "dist", ".", "log_probs", "(", "action", ")", "\n", "dist_entropy", "=", "dist", ".", "entropy", "(", ")", ".", "mean", "(", ")", "\n", "\n", "return", "value", ",", "action", ",", "action_log_probs", ",", "rnn_hxs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.Policy.get_value": [[60, 63], ["ucl_model.Policy.base"], "methods", ["None"], ["", "def", "get_value", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ")", ":", "\n", "        ", "value", ",", "_", ",", "_", "=", "self", ".", "base", "(", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ")", "\n", "return", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.Policy.evaluate_actions": [[64, 85], ["len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "ucl_model.Policy.base", "dist.log_probs", "dist.entropy().mean", "torch.zeros.mean", "torch.zeros.mean", "torch.zeros.mean", "torch.zeros.mean", "torch.zeros.mean", "torch.zeros.mean", "dist.entropy"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.entropy"], ["", "def", "evaluate_actions", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "action", ",", "task_num", ",", "sample", "=", "False", ",", "sample_num", "=", "1", ")", ":", "\n", "\n", "        ", "BATCH_SIZE", "=", "len", "(", "inputs", ")", "\n", "sample_value", "=", "torch", ".", "zeros", "(", "sample_num", ",", "BATCH_SIZE", ",", "1", ")", "\n", "sample_action_log_probs", "=", "torch", ".", "zeros", "(", "sample_num", ",", "BATCH_SIZE", ",", "1", ")", "\n", "sample_dist_entropy", "=", "torch", ".", "zeros", "(", "sample_num", ")", "\n", "\n", "for", "i", "in", "range", "(", "sample_num", ")", ":", "\n", "\n", "            ", "value", ",", "actor_features", ",", "rnn_hxs", "=", "self", ".", "base", "(", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ",", "sample", "=", "sample", ")", "\n", "dist", "=", "self", ".", "dist", "[", "task_num", "]", "(", "actor_features", ")", "\n", "\n", "action_log_probs", "=", "dist", ".", "log_probs", "(", "action", ")", "\n", "dist_entropy", "=", "dist", ".", "entropy", "(", ")", ".", "mean", "(", ")", "\n", "\n", "sample_value", "[", "i", "]", "=", "value", "[", "task_num", "]", "\n", "\n", "sample_action_log_probs", "[", "i", "]", "=", "action_log_probs", "\n", "sample_dist_entropy", "[", "i", "]", "=", "dist_entropy", "\n", "\n", "", "return", "sample_value", ",", "sample_action_log_probs", ".", "mean", "(", "0", ")", ",", "sample_dist_entropy", ".", "mean", "(", "0", ")", ",", "rnn_hxs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.NNBase.__init__": [[88, 101], ["torch.Module.__init__", "torch.GRU", "torch.GRU", "torch.GRU", "ucl_model.NNBase.gru.named_parameters", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.orthogonal_", "torch.init.orthogonal_", "torch.init.orthogonal_"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "recurrent", ",", "recurrent_input_size", ",", "hidden_size", ")", ":", "\n", "        ", "super", "(", "NNBase", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "_hidden_size", "=", "hidden_size", "\n", "self", ".", "_recurrent", "=", "recurrent", "\n", "\n", "if", "recurrent", ":", "\n", "            ", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "recurrent_input_size", ",", "hidden_size", ")", "\n", "for", "name", ",", "param", "in", "self", ".", "gru", ".", "named_parameters", "(", ")", ":", "\n", "                ", "if", "'bias'", "in", "name", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "'weight'", "in", "name", ":", "\n", "                    ", "nn", ".", "init", ".", "orthogonal_", "(", "param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.NNBase.is_recurrent": [[102, 105], ["None"], "methods", ["None"], ["", "", "", "", "@", "property", "\n", "def", "is_recurrent", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_recurrent", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.NNBase.recurrent_hidden_state_size": [[106, 111], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_hidden_state_size", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_recurrent", ":", "\n", "            ", "return", "self", ".", "_hidden_size", "\n", "", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.NNBase.output_size": [[112, 115], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_hidden_size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.NNBase._forward_gru": [[116, 172], ["x.view.view.size", "hxs.squeeze.squeeze.size", "ucl_model.NNBase.gru", "x.view.view.squeeze", "hxs.squeeze.squeeze.squeeze", "hxs.squeeze.squeeze.size", "int", "x.view.view.view", "masks.view.view.view", "hxs.squeeze.squeeze.unsqueeze", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "x.view.view.view", "hxs.squeeze.squeeze.squeeze", "x.view.view.unsqueeze", "x.view.view.size", "has_zeros.dim", "ucl_model.NNBase.gru", "outputs.append", "x.view.view.size", "len", "has_zeros.item", "masks[].view"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "_forward_gru", "(", "self", ",", "x", ",", "hxs", ",", "masks", ")", ":", "\n", "        ", "if", "x", ".", "size", "(", "0", ")", "==", "hxs", ".", "size", "(", "0", ")", ":", "\n", "            ", "x", ",", "hxs", "=", "self", ".", "gru", "(", "x", ".", "unsqueeze", "(", "0", ")", ",", "(", "hxs", "*", "masks", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "x", "=", "x", ".", "squeeze", "(", "0", ")", "\n", "hxs", "=", "hxs", ".", "squeeze", "(", "0", ")", "\n", "", "else", ":", "\n", "# x is a (T, N, -1) tensor that has been flatten to (T * N, -1)", "\n", "            ", "N", "=", "hxs", ".", "size", "(", "0", ")", "\n", "T", "=", "int", "(", "x", ".", "size", "(", "0", ")", "/", "N", ")", "\n", "\n", "# unflatten", "\n", "x", "=", "x", ".", "view", "(", "T", ",", "N", ",", "x", ".", "size", "(", "1", ")", ")", "\n", "\n", "# Same deal with masks", "\n", "masks", "=", "masks", ".", "view", "(", "T", ",", "N", ")", "\n", "\n", "# Let's figure out which steps in the sequence have a zero for any agent", "\n", "# We will always assume t=0 has a zero in it as that makes the logic cleaner", "\n", "has_zeros", "=", "(", "(", "masks", "[", "1", ":", "]", "==", "0.0", ")", ".", "any", "(", "dim", "=", "-", "1", ")", "\n", ".", "nonzero", "(", ")", "\n", ".", "squeeze", "(", ")", "\n", ".", "cpu", "(", ")", ")", "\n", "\n", "# +1 to correct the masks[1:]", "\n", "if", "has_zeros", ".", "dim", "(", ")", "==", "0", ":", "\n", "# Deal with scalar", "\n", "                ", "has_zeros", "=", "[", "has_zeros", ".", "item", "(", ")", "+", "1", "]", "\n", "", "else", ":", "\n", "                ", "has_zeros", "=", "(", "has_zeros", "+", "1", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "\n", "# add t=0 and t=T to the list", "\n", "", "has_zeros", "=", "[", "0", "]", "+", "has_zeros", "+", "[", "T", "]", "\n", "\n", "hxs", "=", "hxs", ".", "unsqueeze", "(", "0", ")", "\n", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "has_zeros", ")", "-", "1", ")", ":", "\n", "# We can now process steps that don't have any zeros in masks together!", "\n", "# This is much faster", "\n", "                ", "start_idx", "=", "has_zeros", "[", "i", "]", "\n", "end_idx", "=", "has_zeros", "[", "i", "+", "1", "]", "\n", "\n", "rnn_scores", ",", "hxs", "=", "self", ".", "gru", "(", "\n", "x", "[", "start_idx", ":", "end_idx", "]", ",", "\n", "hxs", "*", "masks", "[", "start_idx", "]", ".", "view", "(", "1", ",", "-", "1", ",", "1", ")", ")", "\n", "\n", "outputs", ".", "append", "(", "rnn_scores", ")", "\n", "\n", "# assert len(outputs) == T", "\n", "# x is a (T, N, -1) tensor", "\n", "", "x", "=", "torch", ".", "cat", "(", "outputs", ",", "dim", "=", "0", ")", "\n", "# flatten", "\n", "x", "=", "x", ".", "view", "(", "T", "*", "N", ",", "-", "1", ")", "\n", "hxs", "=", "hxs", ".", "squeeze", "(", "0", ")", "\n", "\n", "", "return", "x", ",", "hxs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.MLPBase.__init__": [[175, 200], ["ucl_model.NNBase.__init__", "print", "baye_layer.BayesianLinear", "baye_layer.BayesianLinear", "baye_layer.BayesianLinear", "baye_layer.BayesianLinear", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "ucl_model.MLPBase.train", "a2c_ppo_acktr.utils.init", "ucl_model.MLPBase.critic_linear.append", "numpy.sqrt", "init_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.init"], ["    ", "def", "__init__", "(", "self", ",", "num_inputs", ",", "taskcla", ",", "ratio_init", "=", "1", "/", "16", ",", "recurrent", "=", "False", ",", "hidden_size", "=", "16", ")", ":", "\n", "        ", "super", "(", "MLPBase", ",", "self", ")", ".", "__init__", "(", "recurrent", ",", "num_inputs", ",", "hidden_size", ")", "\n", "\n", "if", "recurrent", ":", "\n", "            ", "num_inputs", "=", "hidden_size", "\n", "\n", "", "init_", "=", "lambda", "m", ":", "init", "(", "m", ",", "nn", ".", "init", ".", "orthogonal_", ",", "lambda", "x", ":", "nn", ".", "init", ".", "\n", "constant_", "(", "x", ",", "0", ")", ",", "np", ".", "sqrt", "(", "2", ")", ")", "\n", "self", ".", "taskcla", "=", "taskcla", "\n", "\n", "print", "(", "'hidden size : '", ",", "hidden_size", ")", "\n", "\n", "self", ".", "nn1_actor", "=", "BayesianLinear", "(", "num_inputs", ",", "hidden_size", ",", "ratio", "=", "ratio_init", ")", "\n", "self", ".", "nn2_actor", "=", "BayesianLinear", "(", "hidden_size", ",", "hidden_size", ",", "ratio", "=", "ratio_init", ")", "\n", "\n", "self", ".", "nn1_critic", "=", "BayesianLinear", "(", "num_inputs", ",", "hidden_size", ",", "ratio", "=", "ratio_init", ")", "\n", "self", ".", "nn2_critic", "=", "BayesianLinear", "(", "hidden_size", ",", "hidden_size", ",", "ratio", "=", "ratio_init", ")", "\n", "\n", "self", ".", "critic_linear", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "            ", "self", ".", "critic_linear", ".", "append", "(", "init_", "(", "torch", ".", "nn", ".", "Linear", "(", "hidden_size", ",", "1", ")", ")", ")", "\n", "\n", "#         self.critic_linear = init_(nn.Linear(hidden_size, 1))", "\n", "\n", "", "self", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ucl_model.MLPBase.forward": [[201, 218], ["torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "ucl_model.MLPBase._forward_gru", "ucl_model.MLPBase.nn1_critic", "ucl_model.MLPBase.nn2_critic", "ucl_model.MLPBase.nn1_actor", "ucl_model.MLPBase.nn2_actor", "critic_output.append"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.NNBase._forward_gru"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ",", "sample", "=", "False", ")", ":", "\n", "        ", "x_ciritic", "=", "inputs", "\n", "x_actor", "=", "inputs", "\n", "\n", "if", "self", ".", "is_recurrent", ":", "\n", "            ", "x", ",", "rnn_hxs", "=", "self", ".", "_forward_gru", "(", "x", ",", "rnn_hxs", ",", "masks", ")", "\n", "\n", "", "x_ciritic", "=", "F", ".", "tanh", "(", "self", ".", "nn1_critic", "(", "x_ciritic", ",", "sample", ")", ")", "\n", "hidden_critic", "=", "F", ".", "tanh", "(", "self", ".", "nn2_critic", "(", "x_ciritic", ",", "sample", ")", ")", "\n", "\n", "x_actor", "=", "F", ".", "tanh", "(", "self", ".", "nn1_actor", "(", "x_actor", ",", "sample", ")", ")", "\n", "hidden_actor", "=", "F", ".", "tanh", "(", "self", ".", "nn2_actor", "(", "x_actor", ",", "sample", ")", ")", "\n", "critic_output", "=", "[", "]", "\n", "for", "t", ",", "i", "in", "self", ".", "taskcla", ":", "\n", "            ", "critic_output", ".", "append", "(", "(", "self", ".", "critic_linear", "[", "t", "]", "(", "hidden_critic", ")", ")", ")", "\n", "\n", "", "return", "critic_output", "[", "task_num", "]", ",", "hidden_actor", ",", "rnn_hxs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ucl.PPO_UCL.__init__": [[14, 54], ["copy.deepcopy", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "print", "print", "actor_critic.parameters"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "actor_critic", ",", "\n", "clip_param", ",", "\n", "ppo_epoch", ",", "\n", "num_mini_batch", ",", "\n", "value_loss_coef", ",", "\n", "entropy_coef", ",", "\n", "lr", "=", "None", ",", "\n", "eps", "=", "None", ",", "\n", "max_grad_norm", "=", "None", ",", "\n", "use_clipped_value_loss", "=", "True", ",", "\n", "conv_net", "=", "False", ",", "\n", "beta", "=", "0.03", ",", "\n", "rho_init", "=", "-", "2.783", ",", "\n", ")", ":", "\n", "\n", "        ", "self", ".", "actor_critic", "=", "actor_critic", "\n", "self", ".", "old_actor_critic", "=", "deepcopy", "(", "self", ".", "actor_critic", ")", "\n", "\n", "self", ".", "conv_net", "=", "conv_net", "\n", "\n", "self", ".", "clip_param", "=", "clip_param", "\n", "self", ".", "ppo_epoch", "=", "ppo_epoch", "\n", "self", ".", "num_mini_batch", "=", "num_mini_batch", "\n", "\n", "self", ".", "value_loss_coef", "=", "value_loss_coef", "\n", "self", ".", "entropy_coef", "=", "entropy_coef", "\n", "\n", "self", ".", "max_grad_norm", "=", "max_grad_norm", "\n", "self", ".", "use_clipped_value_loss", "=", "use_clipped_value_loss", "\n", "\n", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "actor_critic", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "eps", "=", "eps", ")", "\n", "\n", "self", ".", "num_mini_batch", "=", "num_mini_batch", "\n", "self", ".", "saved", "=", "0", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "rho", "=", "rho_init", "\n", "\n", "print", "(", "'beta : '", ",", "self", ".", "beta", ")", "\n", "print", "(", "'rho : '", ",", "self", ".", "rho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ucl.PPO_UCL.update": [[55, 120], ["range", "advantages.mean", "advantages.std", "rollouts.recurrent_generator", "rollouts.feed_forward_generator", "ppo_ucl.PPO_UCL.actor_critic.evaluate_actions", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "ppo_ucl.PPO_UCL.optimizer.zero_grad", "ppo_ucl.PPO_UCL.custom_regularization", "loss.backward", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "ppo_ucl.PPO_UCL.optimizer.step", "value_loss.item", "action_loss.item", "dist_entropy.item", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "ppo_ucl.PPO_UCL.actor_critic.parameters", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.recurrent_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.feed_forward_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.evaluate_actions", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.custom_regularization", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step"], ["", "def", "update", "(", "self", ",", "rollouts", ",", "task_num", ",", "sample_flag", "=", "True", ",", "sample_num", "=", "1", ")", ":", "\n", "        ", "advantages", "=", "rollouts", ".", "returns", "[", ":", "-", "1", "]", "-", "rollouts", ".", "value_preds", "[", ":", "-", "1", "]", "\n", "advantages", "=", "(", "advantages", "-", "advantages", ".", "mean", "(", ")", ")", "/", "(", "\n", "advantages", ".", "std", "(", ")", "+", "1e-5", ")", "\n", "\n", "value_loss_epoch", "=", "0", "\n", "action_loss_epoch", "=", "0", "\n", "dist_entropy_epoch", "=", "0", "\n", "\n", "for", "e", "in", "range", "(", "self", ".", "ppo_epoch", ")", ":", "\n", "            ", "if", "self", ".", "actor_critic", ".", "is_recurrent", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "recurrent_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "", "else", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "feed_forward_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "\n", "", "for", "sample", "in", "data_generator", ":", "\n", "                ", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "actions_batch", ",", "value_preds_batch", ",", "return_batch", ",", "masks_batch", ",", "old_action_log_probs_batch", ",", "adv_targ", "=", "sample", "\n", "\n", "# Reshape to do in a single forward pass for all steps", "\n", "values", ",", "action_log_probs", ",", "dist_entropy", ",", "_", "=", "self", ".", "actor_critic", ".", "evaluate_actions", "(", "\n", "inputs", "=", "obs_batch", ",", "rnn_hxs", "=", "recurrent_hidden_states_batch", ",", "masks", "=", "masks_batch", ",", "\n", "action", "=", "actions_batch", ",", "task_num", "=", "task_num", ")", "\n", "\n", "ratio", "=", "torch", ".", "exp", "(", "action_log_probs", "-", "\n", "old_action_log_probs_batch", ")", "\n", "surr1", "=", "ratio", "*", "adv_targ", "\n", "surr2", "=", "torch", ".", "clamp", "(", "ratio", ",", "1.0", "-", "self", ".", "clip_param", ",", "\n", "1.0", "+", "self", ".", "clip_param", ")", "*", "adv_targ", "\n", "action_loss", "=", "-", "torch", ".", "min", "(", "surr1", ",", "surr2", ")", ".", "mean", "(", ")", "\n", "\n", "if", "self", ".", "use_clipped_value_loss", ":", "\n", "                    ", "value_pred_clipped", "=", "value_preds_batch", "+", "(", "values", "-", "value_preds_batch", ")", ".", "clamp", "(", "-", "self", ".", "clip_param", ",", "self", ".", "clip_param", ")", "\n", "value_losses", "=", "(", "values", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_losses_clipped", "=", "(", "\n", "value_pred_clipped", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_loss", "=", "0.5", "*", "torch", ".", "max", "(", "value_losses", ",", "\n", "value_losses_clipped", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                    ", "value_loss", "=", "0.5", "*", "(", "return_batch", "-", "values", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "reg_loss", "=", "self", ".", "custom_regularization", "(", "self", ".", "num_mini_batch", ")", "\n", "loss", "=", "value_loss", "*", "self", ".", "value_loss_coef", "+", "action_loss", "-", "dist_entropy", "*", "self", ".", "entropy_coef", "+", "reg_loss", "\n", "loss", ".", "backward", "(", ")", "\n", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "actor_critic", ".", "parameters", "(", ")", ",", "\n", "self", ".", "max_grad_norm", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "value_loss_epoch", "+=", "value_loss", ".", "item", "(", ")", "\n", "action_loss_epoch", "+=", "action_loss", ".", "item", "(", ")", "\n", "dist_entropy_epoch", "+=", "dist_entropy", ".", "item", "(", ")", "\n", "\n", "", "", "num_updates", "=", "self", ".", "ppo_epoch", "*", "self", ".", "num_mini_batch", "\n", "\n", "value_loss_epoch", "/=", "num_updates", "\n", "action_loss_epoch", "/=", "num_updates", "\n", "dist_entropy_epoch", "/=", "num_updates", "\n", "\n", "return", "value_loss_epoch", ",", "action_loss_epoch", ",", "dist_entropy_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ucl.PPO_UCL.update_saved": [[121, 125], ["None"], "methods", ["None"], ["", "def", "update_saved", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "saved", "=", "1", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ucl.PPO_UCL.update_old_actor_critic": [[126, 129], ["copy.deepcopy"], "methods", ["None"], ["", "def", "update_old_actor_critic", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "old_actor_critic", "=", "deepcopy", "(", "self", ".", "actor_critic", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_ucl.PPO_UCL.custom_regularization": [[130, 216], ["zip", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "ppo_ucl.PPO_UCL.old_actor_critic.named_children", "ppo_ucl.PPO_UCL.actor_critic.named_children", "zip", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "saver_module.named_children", "trainer_module.named_children", "isinstance", "isinstance", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "isinstance", "isinstance", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p.expand", "torch.log1p.expand", "torch.log1p.expand", "torch.log1p.expand", "torch.log1p().cuda.expand", "torch.log1p().cuda.expand", "torch.log1p().cuda.expand", "torch.log1p().cuda.expand", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "numpy.log", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "numpy.exp", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm"], ["", "def", "custom_regularization", "(", "self", ",", "mini_batch_size", ")", ":", "\n", "\n", "        ", "sigma_weight_reg_sum", "=", "0", "\n", "sigma_bias_reg_sum", "=", "0", "\n", "mu_weight_reg_sum", "=", "0", "\n", "mu_bias_reg_sum", "=", "0", "\n", "L1_mu_weight_reg_sum", "=", "0", "\n", "L1_mu_bias_reg_sum", "=", "0", "\n", "#", "\n", "if", "self", ".", "conv_net", ":", "\n", "            ", "prev_rho", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "actor_critic", ".", "num_inputs", ")", ".", "uniform_", "(", "1", ",", "1", ")", ")", "\n", "prev_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "prev_rho", ")", ")", "\n", "\n", "if", "isinstance", "(", "self", ".", "old_actor_critic", ".", "base", ",", "CNNBase", ")", "==", "False", "or", "isinstance", "(", "self", ".", "actor_critic", ".", "base", ",", "\n", "CNNBase", ")", "==", "False", ":", "\n", "                ", "return", "\n", "\n", "", "", "else", ":", "\n", "            ", "prev_rho", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "actor_critic", ".", "num_inputs", ")", ".", "uniform_", "(", "1", ",", "1", ")", ")", "\n", "prev_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "prev_rho", ")", ")", ".", "cuda", "(", ")", "\n", "if", "not", "(", "isinstance", "(", "self", ".", "old_actor_critic", ".", "base", ",", "MLPBase", ")", "and", "isinstance", "(", "self", ".", "actor_critic", ".", "base", ",", "MLPBase", ")", ")", ":", "\n", "                ", "return", "\n", "\n", "", "", "for", "(", "module_name", ",", "saver_module", ")", ",", "(", "_", ",", "trainer_module", ")", "in", "zip", "(", "self", ".", "old_actor_critic", ".", "named_children", "(", ")", ",", "\n", "self", ".", "actor_critic", ".", "named_children", "(", ")", ")", ":", "\n", "            ", "for", "(", "layer_name", ",", "saver_layer", ")", ",", "(", "_", ",", "trainer_layer", ")", "in", "zip", "(", "saver_module", ".", "named_children", "(", ")", ",", "\n", "trainer_module", ".", "named_children", "(", ")", ")", ":", "\n", "\n", "                ", "if", "not", "(", "(", "(", "layer_name", "==", "'critic_linear'", ")", "or", "(", "module_name", "==", "'dist'", ")", ")", ")", ":", "\n", "\n", "# calculate mu regularization", "\n", "                    ", "trainer_weight_mu", "=", "trainer_layer", ".", "weight_mu", "\n", "saver_weight_mu", "=", "saver_layer", ".", "weight_mu", "\n", "# trainer_bias_mu = trainer_layer.bias_mu", "\n", "# saver_bias_mu = saver_layer.bias_mu", "\n", "\n", "trainer_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "trainer_layer", ".", "weight_rho", ")", ")", "\n", "saver_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "saver_layer", ".", "weight_rho", ")", ")", "\n", "# trainer_bias_sigma = torch.log1p(torch.exp(trainer_layer.bias_rho))", "\n", "# saver_bias_sigma = torch.log1p(torch.exp(saver_layer.bias_rho))", "\n", "\n", "out_features", ",", "in_features", "=", "saver_weight_mu", ".", "shape", "\n", "curr_sigma", "=", "saver_weight_sigma", ".", "expand", "(", "out_features", ",", "in_features", ")", "\n", "prev_sigma", "=", "prev_weight_sigma", ".", "expand", "(", "out_features", ",", "in_features", ")", "\n", "\n", "L1_sigma", "=", "saver_weight_sigma", "\n", "L2_sigma", "=", "torch", ".", "min", "(", "curr_sigma", ",", "prev_sigma", ")", "\n", "prev_weight_sigma", "=", "saver_weight_sigma", "\n", "\n", "mu_weight_reg", "=", "(", "torch", ".", "div", "(", "trainer_weight_mu", "-", "saver_weight_mu", ",", "L2_sigma", ")", ")", ".", "norm", "(", "2", ")", "**", "2", "\n", "# mu_bias_reg = (torch.div(trainer_bias_mu-saver_bias_mu, saver_bias_sigma)).norm(2)**2", "\n", "\n", "L1_mu_weight_reg", "=", "(", "torch", ".", "div", "(", "saver_weight_mu", "**", "2", ",", "L1_sigma", "**", "2", ")", "*", "(", "trainer_weight_mu", "-", "saver_weight_mu", ")", ")", ".", "norm", "(", "1", ")", "\n", "# L1_mu_bias_reg = (torch.div(saver_bias_mu**2,saver_bias_sigma**2)*(trainer_bias_mu - saver_bias_mu)).norm(1)", "\n", "\n", "std_init", "=", "np", ".", "log", "(", "1", "+", "np", ".", "exp", "(", "self", ".", "rho", ")", ")", "\n", "\n", "mu_weight_reg", "=", "mu_weight_reg", "*", "(", "std_init", "**", "2", ")", "\n", "# mu_bias_reg = mu_bias_reg * (std_init ** 2)", "\n", "L1_mu_weight_reg", "=", "L1_mu_weight_reg", "*", "(", "std_init", "**", "2", ")", "\n", "# L1_mu_bias_reg = L1_mu_bias_reg * (std_init ** 2)", "\n", "\n", "weight_sigma", "=", "trainer_weight_sigma", "**", "2", "/", "saver_weight_sigma", "**", "2", "\n", "# bias_sigma = trainer_bias_sigma**2 / saver_bias_sigma**2", "\n", "\n", "normal_weight_sigma", "=", "trainer_weight_sigma", "**", "2", "\n", "# normal_bias_sigma = trainer_bias_sigma**2", "\n", "\n", "sigma_weight_reg_sum", "+=", "(", "weight_sigma", "-", "torch", ".", "log", "(", "weight_sigma", ")", ")", ".", "sum", "(", ")", "\n", "sigma_weight_reg_sum", "+=", "(", "normal_weight_sigma", "-", "torch", ".", "log", "(", "normal_weight_sigma", ")", ")", ".", "sum", "(", ")", "\n", "# sigma_bias_reg_sum += (bias_sigma - torch.log(bias_sigma)).sum()", "\n", "# sigma_bias_reg_sum += (normal_bias_sigma - torch.log(normal_bias_sigma)).sum()", "\n", "\n", "mu_weight_reg_sum", "+=", "mu_weight_reg", "\n", "# mu_bias_reg_sum += mu_bias_reg", "\n", "L1_mu_weight_reg_sum", "+=", "L1_mu_weight_reg", "\n", "# L1_mu_bias_reg_sum += L1_mu_bias_reg", "\n", "\n", "# L2 loss", "\n", "", "", "", "loss", "=", "(", "mu_weight_reg_sum", "+", "mu_bias_reg_sum", ")", "/", "(", "2", "*", "mini_batch_size", ")", "\n", "# L1 loss", "\n", "loss", "=", "loss", "+", "self", ".", "saved", "*", "(", "L1_mu_weight_reg_sum", "+", "L1_mu_bias_reg_sum", ")", "/", "(", "mini_batch_size", ")", "\n", "# sigma regularization", "\n", "loss", "=", "loss", "+", "self", ".", "beta", "*", "(", "sigma_weight_reg_sum", "+", "sigma_bias_reg_sum", ")", "/", "(", "2", "*", "mini_batch_size", ")", "\n", "\n", "return", "loss", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Flatten.forward": [[10, 12], ["x.view", "x.size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.__init__": [[15, 32], ["torch.Module.__init__", "base", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "ppo_model.Policy.dist.append", "len", "a2c_ppo_acktr.distributions.DiagGaussian"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "obs_shape", ",", "taskcla", ",", "base", "=", "None", ",", "base_kwargs", "=", "None", ")", ":", "\n", "        ", "super", "(", "Policy", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "base_kwargs", "is", "None", ":", "\n", "            ", "base_kwargs", "=", "{", "}", "\n", "", "if", "base", "is", "None", ":", "\n", "            ", "if", "len", "(", "obs_shape", ")", "==", "1", ":", "\n", "                ", "base", "=", "MLPBase", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "self", ".", "taskcla", "=", "taskcla", "\n", "self", ".", "num_inputs", "=", "obs_shape", "[", "-", "1", "]", "\n", "self", ".", "base", "=", "base", "(", "obs_shape", "[", "0", "]", ",", "taskcla", ",", "**", "base_kwargs", ")", "\n", "\n", "self", ".", "dist", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "            ", "self", ".", "dist", ".", "append", "(", "DiagGaussian", "(", "self", ".", "base", ".", "output_size", ",", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.is_recurrent": [[33, 36], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "is_recurrent", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "base", ".", "is_recurrent", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.recurrent_hidden_state_size": [[37, 41], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_hidden_state_size", "(", "self", ")", ":", "\n", "        ", "\"\"\"Size of rnn_hx.\"\"\"", "\n", "return", "self", ".", "base", ".", "recurrent_hidden_state_size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.forward": [[42, 44], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.act": [[45, 58], ["ppo_model.Policy.base", "dist.log_probs", "dist.entropy().mean", "dist.mode", "dist.sample", "dist.entropy"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer.Gaussian.sample", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.entropy"], ["", "def", "act", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ",", "deterministic", "=", "False", ")", ":", "\n", "        ", "value", ",", "actor_features", ",", "rnn_hxs", "=", "self", ".", "base", "(", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ")", "\n", "dist", "=", "self", ".", "dist", "[", "task_num", "]", "(", "actor_features", ")", "\n", "\n", "if", "deterministic", ":", "\n", "            ", "action", "=", "dist", ".", "mode", "(", ")", "\n", "", "else", ":", "\n", "            ", "action", "=", "dist", ".", "sample", "(", ")", "\n", "\n", "", "action_log_probs", "=", "dist", ".", "log_probs", "(", "action", ")", "\n", "dist_entropy", "=", "dist", ".", "entropy", "(", ")", ".", "mean", "(", ")", "\n", "\n", "return", "value", ",", "action", ",", "action_log_probs", ",", "rnn_hxs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.get_value": [[59, 62], ["ppo_model.Policy.base"], "methods", ["None"], ["", "def", "get_value", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ")", ":", "\n", "        ", "value", ",", "_", ",", "_", "=", "self", ".", "base", "(", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ")", "\n", "return", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.evaluate_actions": [[63, 71], ["ppo_model.Policy.base", "dist.log_probs", "dist.entropy().mean", "dist.entropy"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.entropy"], ["", "def", "evaluate_actions", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "action", ",", "task_num", ")", ":", "\n", "        ", "value", ",", "actor_features", ",", "rnn_hxs", "=", "self", ".", "base", "(", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ")", "\n", "dist", "=", "self", ".", "dist", "[", "task_num", "]", "(", "actor_features", ")", "\n", "\n", "action_log_probs", "=", "dist", ".", "log_probs", "(", "action", ")", "\n", "dist_entropy", "=", "dist", ".", "entropy", "(", ")", ".", "mean", "(", ")", "\n", "\n", "return", "value", ",", "action_log_probs", ",", "dist_entropy", ",", "rnn_hxs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.NNBase.__init__": [[74, 87], ["torch.Module.__init__", "torch.GRU", "torch.GRU", "torch.GRU", "ppo_model.NNBase.gru.named_parameters", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.orthogonal_", "torch.init.orthogonal_", "torch.init.orthogonal_"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "recurrent", ",", "recurrent_input_size", ",", "hidden_size", ")", ":", "\n", "        ", "super", "(", "NNBase", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "_hidden_size", "=", "hidden_size", "\n", "self", ".", "_recurrent", "=", "recurrent", "\n", "\n", "if", "recurrent", ":", "\n", "            ", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "recurrent_input_size", ",", "hidden_size", ")", "\n", "for", "name", ",", "param", "in", "self", ".", "gru", ".", "named_parameters", "(", ")", ":", "\n", "                ", "if", "'bias'", "in", "name", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "'weight'", "in", "name", ":", "\n", "                    ", "nn", ".", "init", ".", "orthogonal_", "(", "param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.NNBase.is_recurrent": [[88, 91], ["None"], "methods", ["None"], ["", "", "", "", "@", "property", "\n", "def", "is_recurrent", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_recurrent", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.NNBase.recurrent_hidden_state_size": [[92, 97], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "recurrent_hidden_state_size", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_recurrent", ":", "\n", "            ", "return", "self", ".", "_hidden_size", "\n", "", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.NNBase.output_size": [[98, 101], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_size", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_hidden_size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.NNBase._forward_gru": [[102, 158], ["x.view.view.size", "hxs.squeeze.squeeze.size", "ppo_model.NNBase.gru", "x.view.view.squeeze", "hxs.squeeze.squeeze.squeeze", "hxs.squeeze.squeeze.size", "int", "x.view.view.view", "masks.view.view.view", "hxs.squeeze.squeeze.unsqueeze", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "x.view.view.view", "hxs.squeeze.squeeze.squeeze", "x.view.view.unsqueeze", "x.view.view.size", "has_zeros.dim", "ppo_model.NNBase.gru", "outputs.append", "x.view.view.size", "len", "has_zeros.item", "masks[].view"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "_forward_gru", "(", "self", ",", "x", ",", "hxs", ",", "masks", ")", ":", "\n", "        ", "if", "x", ".", "size", "(", "0", ")", "==", "hxs", ".", "size", "(", "0", ")", ":", "\n", "            ", "x", ",", "hxs", "=", "self", ".", "gru", "(", "x", ".", "unsqueeze", "(", "0", ")", ",", "(", "hxs", "*", "masks", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "x", "=", "x", ".", "squeeze", "(", "0", ")", "\n", "hxs", "=", "hxs", ".", "squeeze", "(", "0", ")", "\n", "", "else", ":", "\n", "# x is a (T, N, -1) tensor that has been flatten to (T * N, -1)", "\n", "            ", "N", "=", "hxs", ".", "size", "(", "0", ")", "\n", "T", "=", "int", "(", "x", ".", "size", "(", "0", ")", "/", "N", ")", "\n", "\n", "# unflatten", "\n", "x", "=", "x", ".", "view", "(", "T", ",", "N", ",", "x", ".", "size", "(", "1", ")", ")", "\n", "\n", "# Same deal with masks", "\n", "masks", "=", "masks", ".", "view", "(", "T", ",", "N", ")", "\n", "\n", "# Let's figure out which steps in the sequence have a zero for any agent", "\n", "# We will always assume t=0 has a zero in it as that makes the logic cleaner", "\n", "has_zeros", "=", "(", "(", "masks", "[", "1", ":", "]", "==", "0.0", ")", ".", "any", "(", "dim", "=", "-", "1", ")", "\n", ".", "nonzero", "(", ")", "\n", ".", "squeeze", "(", ")", "\n", ".", "cpu", "(", ")", ")", "\n", "\n", "# +1 to correct the masks[1:]", "\n", "if", "has_zeros", ".", "dim", "(", ")", "==", "0", ":", "\n", "# Deal with scalar", "\n", "                ", "has_zeros", "=", "[", "has_zeros", ".", "item", "(", ")", "+", "1", "]", "\n", "", "else", ":", "\n", "                ", "has_zeros", "=", "(", "has_zeros", "+", "1", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "\n", "# add t=0 and t=T to the list", "\n", "", "has_zeros", "=", "[", "0", "]", "+", "has_zeros", "+", "[", "T", "]", "\n", "\n", "hxs", "=", "hxs", ".", "unsqueeze", "(", "0", ")", "\n", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "has_zeros", ")", "-", "1", ")", ":", "\n", "# We can now process steps that don't have any zeros in masks together!", "\n", "# This is much faster", "\n", "                ", "start_idx", "=", "has_zeros", "[", "i", "]", "\n", "end_idx", "=", "has_zeros", "[", "i", "+", "1", "]", "\n", "\n", "rnn_scores", ",", "hxs", "=", "self", ".", "gru", "(", "\n", "x", "[", "start_idx", ":", "end_idx", "]", ",", "\n", "hxs", "*", "masks", "[", "start_idx", "]", ".", "view", "(", "1", ",", "-", "1", ",", "1", ")", ")", "\n", "\n", "outputs", ".", "append", "(", "rnn_scores", ")", "\n", "\n", "# assert len(outputs) == T", "\n", "# x is a (T, N, -1) tensor", "\n", "", "x", "=", "torch", ".", "cat", "(", "outputs", ",", "dim", "=", "0", ")", "\n", "# flatten", "\n", "x", "=", "x", ".", "view", "(", "T", "*", "N", ",", "-", "1", ")", "\n", "hxs", "=", "hxs", ".", "squeeze", "(", "0", ")", "\n", "\n", "", "return", "x", ",", "hxs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.MLPBase.__init__": [[160, 185], ["ppo_model.NNBase.__init__", "print", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "ppo_model.MLPBase.train", "a2c_ppo_acktr.utils.init", "init_", "torch.Tanh", "torch.Tanh", "torch.Tanh", "init_", "torch.Tanh", "torch.Tanh", "torch.Tanh", "init_", "torch.Tanh", "torch.Tanh", "torch.Tanh", "init_", "torch.Tanh", "torch.Tanh", "torch.Tanh", "ppo_model.MLPBase.critic_linear.append", "numpy.sqrt", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "init_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.init"], ["    ", "def", "__init__", "(", "self", ",", "num_inputs", ",", "taskcla", ",", "recurrent", "=", "False", ",", "hidden_size", "=", "16", ")", ":", "\n", "        ", "super", "(", "MLPBase", ",", "self", ")", ".", "__init__", "(", "recurrent", ",", "num_inputs", ",", "hidden_size", ")", "\n", "\n", "if", "recurrent", ":", "\n", "            ", "num_inputs", "=", "hidden_size", "\n", "\n", "", "init_", "=", "lambda", "m", ":", "init", "(", "m", ",", "nn", ".", "init", ".", "orthogonal_", ",", "lambda", "x", ":", "nn", ".", "init", ".", "\n", "constant_", "(", "x", ",", "0", ")", ",", "np", ".", "sqrt", "(", "2", ")", ")", "\n", "self", ".", "taskcla", "=", "taskcla", "\n", "\n", "print", "(", "'hidden_size : '", ",", "hidden_size", ")", "\n", "\n", "self", ".", "actor", "=", "nn", ".", "Sequential", "(", "\n", "init_", "(", "nn", ".", "Linear", "(", "num_inputs", ",", "hidden_size", ")", ")", ",", "nn", ".", "Tanh", "(", ")", ",", "\n", "init_", "(", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", ")", ",", "nn", ".", "Tanh", "(", ")", ")", "\n", "\n", "self", ".", "critic", "=", "nn", ".", "Sequential", "(", "\n", "init_", "(", "nn", ".", "Linear", "(", "num_inputs", ",", "hidden_size", ")", ")", ",", "nn", ".", "Tanh", "(", ")", ",", "\n", "init_", "(", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", ")", ",", "nn", ".", "Tanh", "(", ")", ")", "\n", "\n", "self", ".", "critic_linear", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "t", ",", "n", "in", "self", ".", "taskcla", ":", "\n", "            ", "self", ".", "critic_linear", ".", "append", "(", "init_", "(", "torch", ".", "nn", ".", "Linear", "(", "hidden_size", ",", "1", ")", ")", ")", "\n", "\n", "", "self", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.MLPBase.forward": [[186, 200], ["ppo_model.MLPBase.critic", "ppo_model.MLPBase.actor", "ppo_model.MLPBase._forward_gru", "critic_output.append"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.NNBase._forward_gru"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "rnn_hxs", ",", "masks", ",", "task_num", ")", ":", "\n", "        ", "x", "=", "inputs", "\n", "\n", "if", "self", ".", "is_recurrent", ":", "\n", "            ", "x", ",", "rnn_hxs", "=", "self", ".", "_forward_gru", "(", "x", ",", "rnn_hxs", ",", "masks", ")", "\n", "\n", "", "hidden_critic", "=", "self", ".", "critic", "(", "x", ")", "\n", "hidden_actor", "=", "self", ".", "actor", "(", "x", ")", "\n", "\n", "critic_output", "=", "[", "]", "\n", "for", "t", ",", "i", "in", "self", ".", "taskcla", ":", "\n", "            ", "critic_output", ".", "append", "(", "(", "self", ".", "critic_linear", "[", "t", "]", "(", "hidden_actor", ")", ")", ")", "\n", "\n", "", "return", "critic_output", "[", "task_num", "]", ",", "hidden_actor", ",", "rnn_hxs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo.PPO.__init__": [[8, 33], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "actor_critic.parameters"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "actor_critic", ",", "\n", "clip_param", ",", "\n", "ppo_epoch", ",", "\n", "num_mini_batch", ",", "\n", "value_loss_coef", ",", "\n", "entropy_coef", ",", "\n", "lr", "=", "None", ",", "\n", "eps", "=", "None", ",", "\n", "max_grad_norm", "=", "None", ",", "\n", "use_clipped_value_loss", "=", "True", ")", ":", "\n", "\n", "        ", "self", ".", "actor_critic", "=", "actor_critic", "\n", "\n", "self", ".", "clip_param", "=", "clip_param", "\n", "self", ".", "ppo_epoch", "=", "ppo_epoch", "\n", "self", ".", "num_mini_batch", "=", "num_mini_batch", "\n", "\n", "self", ".", "value_loss_coef", "=", "value_loss_coef", "\n", "self", ".", "entropy_coef", "=", "entropy_coef", "\n", "\n", "self", ".", "max_grad_norm", "=", "max_grad_norm", "\n", "self", ".", "use_clipped_value_loss", "=", "use_clipped_value_loss", "\n", "\n", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "actor_critic", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "eps", "=", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo.PPO.update": [[34, 97], ["range", "advantages.mean", "advantages.std", "rollouts.recurrent_generator", "rollouts.feed_forward_generator", "ppo.PPO.actor_critic.evaluate_actions", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "ppo.PPO.optimizer.zero_grad", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "ppo.PPO.optimizer.step", "value_loss.item", "action_loss.item", "dist_entropy.item", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "ppo.PPO.actor_critic.parameters", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.recurrent_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.feed_forward_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.evaluate_actions", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step"], ["", "def", "update", "(", "self", ",", "rollouts", ",", "task_idx", ")", ":", "\n", "        ", "advantages", "=", "rollouts", ".", "returns", "[", ":", "-", "1", "]", "-", "rollouts", ".", "value_preds", "[", ":", "-", "1", "]", "\n", "advantages", "=", "(", "advantages", "-", "advantages", ".", "mean", "(", ")", ")", "/", "(", "\n", "advantages", ".", "std", "(", ")", "+", "1e-5", ")", "\n", "\n", "value_loss_epoch", "=", "0", "\n", "action_loss_epoch", "=", "0", "\n", "dist_entropy_epoch", "=", "0", "\n", "\n", "for", "e", "in", "range", "(", "self", ".", "ppo_epoch", ")", ":", "\n", "            ", "if", "self", ".", "actor_critic", ".", "is_recurrent", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "recurrent_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "", "else", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "feed_forward_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "\n", "", "for", "sample", "in", "data_generator", ":", "\n", "                ", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "actions_batch", ",", "value_preds_batch", ",", "return_batch", ",", "masks_batch", ",", "old_action_log_probs_batch", ",", "adv_targ", "=", "sample", "\n", "\n", "# Reshape to do in a single forward pass for all steps", "\n", "values", ",", "action_log_probs", ",", "dist_entropy", ",", "_", "=", "self", ".", "actor_critic", ".", "evaluate_actions", "(", "\n", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "masks_batch", ",", "\n", "actions_batch", ",", "task_num", "=", "task_idx", ")", "\n", "\n", "ratio", "=", "torch", ".", "exp", "(", "action_log_probs", "-", "\n", "old_action_log_probs_batch", ")", "\n", "surr1", "=", "ratio", "*", "adv_targ", "\n", "surr2", "=", "torch", ".", "clamp", "(", "ratio", ",", "1.0", "-", "self", ".", "clip_param", ",", "\n", "1.0", "+", "self", ".", "clip_param", ")", "*", "adv_targ", "\n", "action_loss", "=", "-", "torch", ".", "min", "(", "surr1", ",", "surr2", ")", ".", "mean", "(", ")", "\n", "\n", "if", "self", ".", "use_clipped_value_loss", ":", "\n", "                    ", "value_pred_clipped", "=", "value_preds_batch", "+", "(", "values", "-", "value_preds_batch", ")", ".", "clamp", "(", "-", "self", ".", "clip_param", ",", "self", ".", "clip_param", ")", "\n", "value_losses", "=", "(", "values", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_losses_clipped", "=", "(", "\n", "value_pred_clipped", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_loss", "=", "0.5", "*", "torch", ".", "max", "(", "value_losses", ",", "\n", "value_losses_clipped", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                    ", "value_loss", "=", "0.5", "*", "(", "return_batch", "-", "values", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "(", "value_loss", "*", "self", ".", "value_loss_coef", "+", "action_loss", "-", "\n", "dist_entropy", "*", "self", ".", "entropy_coef", ")", ".", "backward", "(", ")", "\n", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "actor_critic", ".", "parameters", "(", ")", ",", "\n", "self", ".", "max_grad_norm", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "value_loss_epoch", "+=", "value_loss", ".", "item", "(", ")", "\n", "action_loss_epoch", "+=", "action_loss", ".", "item", "(", ")", "\n", "dist_entropy_epoch", "+=", "dist_entropy", ".", "item", "(", ")", "\n", "\n", "", "", "num_updates", "=", "self", ".", "ppo_epoch", "*", "self", ".", "num_mini_batch", "\n", "\n", "value_loss_epoch", "/=", "num_updates", "\n", "action_loss_epoch", "/=", "num_updates", "\n", "dist_entropy_epoch", "/=", "num_updates", "\n", "\n", "return", "value_loss_epoch", ",", "action_loss_epoch", ",", "dist_entropy_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.evaluation.evaluate": [[8, 66], ["print", "a2c_ppo_acktr.envs.make_vec_envs", "collections.deque", "a2c_ppo_acktr.envs.make_vec_envs.reset", "torch.zeros().cuda", "torch.zeros", "torch.zeros", "eval_episode_rewards_arr.append", "a2c_ppo_acktr.envs.make_vec_envs.close", "print", "eval_episode_rewards_arr.append", "len", "a2c_ppo_acktr.envs.make_vec_envs.step", "torch.tensor", "numpy.mean", "torch.zeros", "torch.no_grad", "actor_critic.act", "len", "numpy.mean", "numpy.max", "numpy.min", "info.keys", "collections.deque.append"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.make_vec_envs", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.close", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.act"], ["def", "evaluate", "(", "actor_critic", ",", "ob_rms", ",", "task_sequences", ",", "seed", ",", "num_processes", ",", "eval_log_dir", ",", "\n", "device", ",", "obs_shape", ",", "current_task_idx", ",", "gamma", ")", ":", "\n", "\n", "    ", "eval_episode_rewards_arr", "=", "[", "]", "\n", "print", "(", "\"Evaluating...\"", ")", "\n", "for", "task_idx", ",", "task_name", "in", "task_sequences", ":", "\n", "\n", "        ", "if", "task_idx", "<=", "current_task_idx", ":", "\n", "\n", "            ", "eval_envs", "=", "make_vec_envs", "(", "task_name", ",", "seed", "+", "num_processes", ",", "num_processes", ",", "\n", "gamma", ",", "eval_log_dir", ",", "device", ",", "False", ")", "\n", "\n", "eval_episode_rewards", "=", "deque", "(", "maxlen", "=", "10", ")", "\n", "\n", "obs", "=", "eval_envs", ".", "reset", "(", ")", "\n", "obs_shape_real", "=", "eval_envs", ".", "observation_space", ".", "shape", "\n", "current_obs", "=", "torch", ".", "zeros", "(", "num_processes", ",", "*", "obs_shape", ")", ".", "cuda", "(", ")", "\n", "#### reshape for traiing ###############", "\n", "current_obs", "[", ":", ",", ":", "obs_shape_real", "[", "0", "]", "]", "=", "obs", "\n", "########################################", "\n", "eval_recurrent_hidden_states", "=", "torch", ".", "zeros", "(", "\n", "num_processes", ",", "actor_critic", ".", "recurrent_hidden_state_size", ",", "device", "=", "device", ")", "\n", "eval_masks", "=", "torch", ".", "zeros", "(", "num_processes", ",", "1", ",", "device", "=", "device", ")", "\n", "while", "len", "(", "eval_episode_rewards", ")", "<", "10", ":", "\n", "                ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "_", ",", "action", ",", "_", ",", "eval_recurrent_hidden_states", "=", "actor_critic", ".", "act", "(", "\n", "current_obs", ",", "\n", "eval_recurrent_hidden_states", ",", "\n", "eval_masks", ",", "\n", "task_idx", ",", "\n", "deterministic", "=", "True", ")", "\n", "\n", "# Obser reward and next obs", "\n", "", "obs", ",", "_", ",", "done", ",", "infos", "=", "eval_envs", ".", "step", "(", "action", ")", "\n", "\n", "#### reshape for traiing ###############", "\n", "current_obs", "[", ":", ",", ":", "obs_shape_real", "[", "0", "]", "]", "=", "obs", "\n", "########################################", "\n", "\n", "eval_masks", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0.0", "]", "if", "done_", "else", "[", "1.0", "]", "for", "done_", "in", "done", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "\n", "device", "=", "device", ")", "\n", "\n", "for", "info", "in", "infos", ":", "\n", "                    ", "if", "'episode'", "in", "info", ".", "keys", "(", ")", ":", "\n", "                        ", "eval_episode_rewards", ".", "append", "(", "info", "[", "'episode'", "]", "[", "'r'", "]", ")", "\n", "\n", "", "", "", "eval_episode_rewards_arr", ".", "append", "(", "np", ".", "mean", "(", "eval_episode_rewards", ")", ")", "\n", "\n", "eval_envs", ".", "close", "(", ")", "\n", "\n", "print", "(", "\" Evaluation in Task {} using {} episodes: mean reward {:.2f}, max reward {:.2f}, min reward {:.2f} \\n\"", ".", "format", "(", "\n", "current_task_idx", ",", "len", "(", "eval_episode_rewards", ")", ",", "np", ".", "mean", "(", "eval_episode_rewards", ")", ",", "np", ".", "max", "(", "eval_episode_rewards", ")", ",", "np", ".", "min", "(", "eval_episode_rewards", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "eval_episode_rewards_arr", ".", "append", "(", "0", ")", "\n", "\n", "", "", "return", "eval_episode_rewards_arr", "\n", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step": [[113, 119], ["envs.TimeLimitMask.env.step"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step"], ["    ", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "obs", ",", "rew", ",", "done", ",", "info", "=", "self", ".", "env", ".", "step", "(", "action", ")", "\n", "if", "done", "and", "self", ".", "env", ".", "_max_episode_steps", "==", "self", ".", "env", ".", "_elapsed_steps", ":", "\n", "            ", "info", "[", "'bad_transition'", "]", "=", "True", "\n", "\n", "", "return", "obs", ",", "rew", ",", "done", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.reset": [[120, 122], ["envs.TimeLimitMask.env.reset"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset"], ["", "def", "reset", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "env", ".", "reset", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.MaskGoal.observation": [[126, 130], ["None"], "methods", ["None"], ["    ", "def", "observation", "(", "self", ",", "observation", ")", ":", "\n", "        ", "if", "self", ".", "env", ".", "_elapsed_steps", ">", "0", ":", "\n", "            ", "observation", "[", "-", "2", ":", "0", "]", "=", "0", "\n", "", "return", "observation", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TransposeObs.__init__": [[133, 138], ["gym.ObservationWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Transpose observation space (base class)\n        \"\"\"", "\n", "super", "(", "TransposeObs", ",", "self", ")", ".", "__init__", "(", "env", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TransposeImage.__init__": [[141, 156], ["envs.TransposeObs.__init__", "gym.spaces.box.Box", "len", "str"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "env", "=", "None", ",", "op", "=", "[", "2", ",", "0", ",", "1", "]", ")", ":", "\n", "        ", "\"\"\"\n        Transpose observation space for images\n        \"\"\"", "\n", "super", "(", "TransposeImage", ",", "self", ")", ".", "__init__", "(", "env", ")", "\n", "assert", "len", "(", "op", ")", "==", "3", ",", "f\"Error: Operation, {str(op)}, must be dim3\"", "\n", "self", ".", "op", "=", "op", "\n", "obs_shape", "=", "self", ".", "observation_space", ".", "shape", "\n", "self", ".", "observation_space", "=", "Box", "(", "\n", "self", ".", "observation_space", ".", "low", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "self", ".", "observation_space", ".", "high", "[", "0", ",", "0", ",", "0", "]", ",", "[", "\n", "obs_shape", "[", "self", ".", "op", "[", "0", "]", "]", ",", "obs_shape", "[", "self", ".", "op", "[", "1", "]", "]", ",", "\n", "obs_shape", "[", "self", ".", "op", "[", "2", "]", "]", "\n", "]", ",", "\n", "dtype", "=", "self", ".", "observation_space", ".", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TransposeImage.observation": [[157, 159], ["ob.transpose"], "methods", ["None"], ["", "def", "observation", "(", "self", ",", "ob", ")", ":", "\n", "        ", "return", "ob", ".", "transpose", "(", "self", ".", "op", "[", "0", "]", ",", "self", ".", "op", "[", "1", "]", ",", "self", ".", "op", "[", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorch.__init__": [[162, 166], ["baselines.common.vec_env.VecEnvWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "venv", ",", "device", ")", ":", "\n", "        ", "\"\"\"Return only every `skip`-th frame\"\"\"", "\n", "super", "(", "VecPyTorch", ",", "self", ")", ".", "__init__", "(", "venv", ")", "\n", "self", ".", "device", "=", "device", "\n", "# TODO: Fix data types", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorch.reset": [[168, 172], ["envs.VecPyTorch.venv.reset", "torch.from_numpy().float().to", "torch.from_numpy().float", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "obs", "=", "self", ".", "venv", ".", "reset", "(", ")", "\n", "obs", "=", "torch", ".", "from_numpy", "(", "obs", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "return", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorch.step_async": [[173, 179], ["isinstance", "actions.squeeze.squeeze.cpu().numpy", "envs.VecPyTorch.venv.step_async", "actions.squeeze.squeeze.squeeze", "actions.squeeze.squeeze.cpu"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorch.step_async"], ["", "def", "step_async", "(", "self", ",", "actions", ")", ":", "\n", "        ", "if", "isinstance", "(", "actions", ",", "torch", ".", "LongTensor", ")", ":", "\n", "# Squeeze the dimension for discrete actions", "\n", "            ", "actions", "=", "actions", ".", "squeeze", "(", "1", ")", "\n", "", "actions", "=", "actions", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "venv", ".", "step_async", "(", "actions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorch.step_wait": [[180, 185], ["envs.VecPyTorch.venv.step_wait", "torch.from_numpy().float().to", "torch.from_numpy().unsqueeze().float", "torch.from_numpy().float", "torch.from_numpy().unsqueeze", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.step_wait", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to"], ["", "def", "step_wait", "(", "self", ")", ":", "\n", "        ", "obs", ",", "reward", ",", "done", ",", "info", "=", "self", ".", "venv", ".", "step_wait", "(", ")", "\n", "obs", "=", "torch", ".", "from_numpy", "(", "obs", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "reward", "=", "torch", ".", "from_numpy", "(", "reward", ")", ".", "unsqueeze", "(", "dim", "=", "1", ")", ".", "float", "(", ")", "\n", "return", "obs", ",", "reward", ",", "done", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecNormalize.__init__": [[188, 191], ["baselines.common.vec_env.vec_normalize.VecNormalize.__init__"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "VecNormalize", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "training", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecNormalize._obfilt": [[192, 202], ["numpy.clip", "envs.VecNormalize.ob_rms.update", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.update"], ["", "def", "_obfilt", "(", "self", ",", "obs", ",", "update", "=", "True", ")", ":", "\n", "        ", "if", "self", ".", "ob_rms", ":", "\n", "            ", "if", "self", ".", "training", "and", "update", ":", "\n", "                ", "self", ".", "ob_rms", ".", "update", "(", "obs", ")", "\n", "", "obs", "=", "np", ".", "clip", "(", "(", "obs", "-", "self", ".", "ob_rms", ".", "mean", ")", "/", "\n", "np", ".", "sqrt", "(", "self", ".", "ob_rms", ".", "var", "+", "self", ".", "epsilon", ")", ",", "\n", "-", "self", ".", "clipob", ",", "self", ".", "clipob", ")", "\n", "return", "obs", "\n", "", "else", ":", "\n", "            ", "return", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecNormalize.train": [[203, 205], ["None"], "methods", ["None"], ["", "", "def", "train", "(", "self", ")", ":", "\n", "        ", "self", ".", "training", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecNormalize.eval": [[206, 208], ["None"], "methods", ["None"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "self", ".", "training", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.__init__": [[213, 231], ["numpy.repeat", "numpy.repeat", "torch.zeros().to", "gym.spaces.Box", "baselines.common.vec_env.VecEnvWrapper.__init__", "torch.device", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], ["    ", "def", "__init__", "(", "self", ",", "venv", ",", "nstack", ",", "device", "=", "None", ")", ":", "\n", "        ", "self", ".", "venv", "=", "venv", "\n", "self", ".", "nstack", "=", "nstack", "\n", "\n", "wos", "=", "venv", ".", "observation_space", "# wrapped ob space", "\n", "self", ".", "shape_dim0", "=", "wos", ".", "shape", "[", "0", "]", "\n", "\n", "low", "=", "np", ".", "repeat", "(", "wos", ".", "low", ",", "self", ".", "nstack", ",", "axis", "=", "0", ")", "\n", "high", "=", "np", ".", "repeat", "(", "wos", ".", "high", ",", "self", ".", "nstack", ",", "axis", "=", "0", ")", "\n", "\n", "if", "device", "is", "None", ":", "\n", "            ", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", "\n", "", "self", ".", "stacked_obs", "=", "torch", ".", "zeros", "(", "(", "venv", ".", "num_envs", ",", ")", "+", "\n", "low", ".", "shape", ")", ".", "to", "(", "device", ")", "\n", "\n", "observation_space", "=", "gym", ".", "spaces", ".", "Box", "(", "\n", "low", "=", "low", ",", "high", "=", "high", ",", "dtype", "=", "venv", ".", "observation_space", ".", "dtype", ")", "\n", "VecEnvWrapper", ".", "__init__", "(", "self", ",", "venv", ",", "observation_space", "=", "observation_space", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.step_wait": [[232, 241], ["envs.VecPyTorchFrameStack.venv.step_wait", "enumerate"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.step_wait"], ["", "def", "step_wait", "(", "self", ")", ":", "\n", "        ", "obs", ",", "rews", ",", "news", ",", "infos", "=", "self", ".", "venv", ".", "step_wait", "(", ")", "\n", "self", ".", "stacked_obs", "[", ":", ",", ":", "-", "self", ".", "shape_dim0", "]", "=", "self", ".", "stacked_obs", "[", ":", ",", "self", ".", "shape_dim0", ":", "]", "\n", "for", "(", "i", ",", "new", ")", "in", "enumerate", "(", "news", ")", ":", "\n", "            ", "if", "new", ":", "\n", "                ", "self", ".", "stacked_obs", "[", "i", "]", "=", "0", "\n", "", "", "self", ".", "stacked_obs", "[", ":", ",", "-", "self", ".", "shape_dim0", ":", "]", "=", "obs", "\n", "return", "self", ".", "stacked_obs", ",", "rews", ",", "news", ",", "infos", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset": [[242, 250], ["envs.VecPyTorchFrameStack.venv.reset", "torch.zeros", "envs.VecPyTorchFrameStack.stacked_obs.zero_"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.reset"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "obs", "=", "self", ".", "venv", ".", "reset", "(", ")", "\n", "if", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", ":", "\n", "            ", "self", ".", "stacked_obs", "=", "torch", ".", "zeros", "(", "self", ".", "stacked_obs", ".", "shape", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "stacked_obs", ".", "zero_", "(", ")", "\n", "", "self", ".", "stacked_obs", "[", ":", ",", "-", "self", ".", "shape_dim0", ":", "]", "=", "obs", "\n", "return", "self", ".", "stacked_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.close": [[251, 253], ["envs.VecPyTorchFrameStack.venv.close"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.VecPyTorchFrameStack.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "venv", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.make_env": [[32, 75], ["env_id.startswith", "baselines.common.atari_wrappers.wrap_deepmind.seed", "env_id.split", "dm_control2gym.make", "gym.make", "hasattr", "isinstance", "baselines.common.atari_wrappers.make_atari", "str().find", "envs.TimeLimitMask", "baselines.bench.Monitor", "envs.TransposeImage", "os.path.join", "len", "baselines.common.atari_wrappers.wrap_deepmind", "len", "NotImplementedError", "len", "str", "str"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.sum_tree.SumTree.find"], ["", "def", "make_env", "(", "env_id", ",", "seed", ",", "rank", ",", "log_dir", ",", "allow_early_resets", ")", ":", "\n", "    ", "def", "_thunk", "(", ")", ":", "\n", "        ", "if", "env_id", ".", "startswith", "(", "\"dm\"", ")", ":", "\n", "            ", "_", ",", "domain", ",", "task", "=", "env_id", ".", "split", "(", "'.'", ")", "\n", "env", "=", "dm_control2gym", ".", "make", "(", "domain_name", "=", "domain", ",", "task_name", "=", "task", ")", "\n", "", "else", ":", "\n", "            ", "env", "=", "gym", ".", "make", "(", "env_id", ")", "\n", "\n", "", "is_atari", "=", "hasattr", "(", "gym", ".", "envs", ",", "'atari'", ")", "and", "isinstance", "(", "\n", "env", ".", "unwrapped", ",", "gym", ".", "envs", ".", "atari", ".", "atari_env", ".", "AtariEnv", ")", "\n", "if", "is_atari", ":", "\n", "            ", "env", "=", "make_atari", "(", "env_id", ")", "\n", "\n", "", "env", ".", "seed", "(", "seed", "+", "rank", ")", "\n", "\n", "obs_shape", "=", "env", ".", "observation_space", ".", "shape", "\n", "\n", "if", "str", "(", "env", ".", "__class__", ".", "__name__", ")", ".", "find", "(", "'TimeLimit'", ")", ">=", "0", ":", "\n", "            ", "env", "=", "TimeLimitMask", "(", "env", ")", "\n", "\n", "", "if", "log_dir", "is", "not", "None", ":", "\n", "            ", "env", "=", "bench", ".", "Monitor", "(", "\n", "env", ",", "\n", "os", ".", "path", ".", "join", "(", "log_dir", ",", "str", "(", "rank", ")", ")", ",", "\n", "allow_early_resets", "=", "allow_early_resets", ")", "\n", "\n", "", "if", "is_atari", ":", "\n", "            ", "if", "len", "(", "env", ".", "observation_space", ".", "shape", ")", "==", "3", ":", "\n", "                ", "env", "=", "wrap_deepmind", "(", "env", ")", "\n", "", "", "elif", "len", "(", "env", ".", "observation_space", ".", "shape", ")", "==", "3", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"CNN models work only for atari,\\n\"", "\n", "\"please use a custom wrapper for a custom pixel input env.\\n\"", "\n", "\"See wrap_deepmind for an example.\"", ")", "\n", "\n", "# If the input has shape (W,H,3), wrap for PyTorch convolutions", "\n", "", "obs_shape", "=", "env", ".", "observation_space", ".", "shape", "\n", "if", "len", "(", "obs_shape", ")", "==", "3", "and", "obs_shape", "[", "2", "]", "in", "[", "1", ",", "3", "]", ":", "\n", "            ", "env", "=", "TransposeImage", "(", "env", ",", "op", "=", "[", "2", ",", "0", ",", "1", "]", ")", "\n", "\n", "", "return", "env", "\n", "\n", "", "return", "_thunk", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.make_vec_envs": [[77, 109], ["envs.VecPyTorch", "envs.make_env", "len", "baselines.common.vec_env.shmem_vec_env.ShmemVecEnv", "baselines.common.vec_env.dummy_vec_env.DummyVecEnv", "len", "envs.VecPyTorchFrameStack", "range", "envs.VecNormalize", "envs.VecNormalize", "len", "envs.VecPyTorchFrameStack"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.make_env"], ["", "def", "make_vec_envs", "(", "env_name", ",", "\n", "seed", ",", "\n", "num_processes", ",", "\n", "gamma", ",", "\n", "log_dir", ",", "\n", "device", ",", "\n", "allow_early_resets", ",", "\n", "num_frame_stack", "=", "None", ")", ":", "\n", "    ", "envs", "=", "[", "\n", "make_env", "(", "env_name", ",", "seed", ",", "i", ",", "log_dir", ",", "allow_early_resets", ")", "\n", "for", "i", "in", "range", "(", "num_processes", ")", "\n", "]", "\n", "\n", "if", "len", "(", "envs", ")", ">", "1", ":", "\n", "        ", "envs", "=", "ShmemVecEnv", "(", "envs", ",", "context", "=", "'fork'", ")", "\n", "", "else", ":", "\n", "        ", "envs", "=", "DummyVecEnv", "(", "envs", ")", "\n", "\n", "", "if", "len", "(", "envs", ".", "observation_space", ".", "shape", ")", "==", "1", ":", "\n", "        ", "if", "gamma", "is", "None", ":", "\n", "            ", "envs", "=", "VecNormalize", "(", "envs", ",", "ret", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "envs", "=", "VecNormalize", "(", "envs", ",", "gamma", "=", "gamma", ")", "\n", "\n", "", "", "envs", "=", "VecPyTorch", "(", "envs", ",", "device", ")", "\n", "\n", "if", "num_frame_stack", "is", "not", "None", ":", "\n", "        ", "envs", "=", "VecPyTorchFrameStack", "(", "envs", ",", "num_frame_stack", ",", "device", ")", "\n", "", "elif", "len", "(", "envs", ".", "observation_space", ".", "shape", ")", "==", "3", ":", "\n", "        ", "envs", "=", "VecPyTorchFrameStack", "(", "envs", ",", "4", ",", "device", ")", "\n", "\n", "", "return", "envs", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.distributions.Categorical.__init__": [[55, 65], ["torch.Module.__init__", "init_", "utils.init", "torch.Linear", "torch.Linear", "torch.Linear", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.init"], ["    ", "def", "__init__", "(", "self", ",", "num_inputs", ",", "num_outputs", ")", ":", "\n", "        ", "super", "(", "Categorical", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "init_", "=", "lambda", "m", ":", "init", "(", "\n", "m", ",", "\n", "nn", ".", "init", ".", "orthogonal_", ",", "\n", "lambda", "x", ":", "nn", ".", "init", ".", "constant_", "(", "x", ",", "0", ")", ",", "\n", "gain", "=", "0.01", ")", "\n", "\n", "self", ".", "linear", "=", "init_", "(", "nn", ".", "Linear", "(", "num_inputs", ",", "num_outputs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.distributions.Categorical.forward": [[66, 69], ["distributions.Categorical.linear", "FixedCategorical"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "return", "FixedCategorical", "(", "logits", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.distributions.DiagGaussian.__init__": [[72, 80], ["torch.Module.__init__", "init_", "utils.AddBias", "utils.init", "torch.Linear", "torch.Linear", "torch.Linear", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.init"], ["    ", "def", "__init__", "(", "self", ",", "num_inputs", ",", "num_outputs", ")", ":", "\n", "        ", "super", "(", "DiagGaussian", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "init_", "=", "lambda", "m", ":", "init", "(", "m", ",", "nn", ".", "init", ".", "orthogonal_", ",", "lambda", "x", ":", "nn", ".", "init", ".", "\n", "constant_", "(", "x", ",", "0", ")", ")", "\n", "\n", "self", ".", "fc_mean", "=", "init_", "(", "nn", ".", "Linear", "(", "num_inputs", ",", "num_outputs", ")", ")", "\n", "self", ".", "logstd", "=", "AddBias", "(", "torch", ".", "zeros", "(", "num_outputs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.distributions.DiagGaussian.forward": [[81, 91], ["distributions.DiagGaussian.fc_mean", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "distributions.DiagGaussian.logstd", "FixedNormal", "distributions.DiagGaussian.size", "zeros.cuda.cuda.cuda", "distributions.DiagGaussian.exp"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "action_mean", "=", "self", ".", "fc_mean", "(", "x", ")", "\n", "\n", "#  An ugly hack for my KFAC implementation.", "\n", "zeros", "=", "torch", ".", "zeros", "(", "action_mean", ".", "size", "(", ")", ")", "\n", "if", "x", ".", "is_cuda", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "\n", "", "action_logstd", "=", "self", ".", "logstd", "(", "zeros", ")", "\n", "return", "FixedNormal", "(", "action_mean", ",", "action_logstd", ".", "exp", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.distributions.Bernoulli.__init__": [[94, 101], ["torch.Module.__init__", "init_", "utils.init", "torch.Linear", "torch.Linear", "torch.Linear", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.init"], ["    ", "def", "__init__", "(", "self", ",", "num_inputs", ",", "num_outputs", ")", ":", "\n", "        ", "super", "(", "Bernoulli", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "init_", "=", "lambda", "m", ":", "init", "(", "m", ",", "nn", ".", "init", ".", "orthogonal_", ",", "lambda", "x", ":", "nn", ".", "init", ".", "\n", "constant_", "(", "x", ",", "0", ")", ")", "\n", "\n", "self", ".", "linear", "=", "init_", "(", "nn", ".", "Linear", "(", "num_inputs", ",", "num_outputs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.distributions.Bernoulli.forward": [[102, 105], ["distributions.Bernoulli.linear", "FixedBernoulli"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "return", "FixedBernoulli", "(", "logits", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.__init__": [[10, 34], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "storage.RolloutStorage.actions.long"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "num_steps", ",", "num_processes", ",", "obs_shape", ",", "action_space", ",", "\n", "recurrent_hidden_state_size", ")", ":", "\n", "        ", "self", ".", "obs", "=", "torch", ".", "zeros", "(", "num_steps", "+", "1", ",", "num_processes", ",", "*", "obs_shape", ")", "\n", "self", ".", "recurrent_hidden_states", "=", "torch", ".", "zeros", "(", "\n", "num_steps", "+", "1", ",", "num_processes", ",", "recurrent_hidden_state_size", ")", "\n", "self", ".", "rewards", "=", "torch", ".", "zeros", "(", "num_steps", ",", "num_processes", ",", "1", ")", "\n", "self", ".", "value_preds", "=", "torch", ".", "zeros", "(", "num_steps", "+", "1", ",", "num_processes", ",", "1", ")", "\n", "self", ".", "returns", "=", "torch", ".", "zeros", "(", "num_steps", "+", "1", ",", "num_processes", ",", "1", ")", "\n", "self", ".", "action_log_probs", "=", "torch", ".", "zeros", "(", "num_steps", ",", "num_processes", ",", "1", ")", "\n", "if", "action_space", ".", "__class__", ".", "__name__", "==", "'Discrete'", ":", "\n", "            ", "action_shape", "=", "1", "\n", "", "else", ":", "\n", "            ", "action_shape", "=", "action_space", ".", "shape", "[", "0", "]", "\n", "", "self", ".", "actions", "=", "torch", ".", "zeros", "(", "num_steps", ",", "num_processes", ",", "action_shape", ")", "\n", "if", "action_space", ".", "__class__", ".", "__name__", "==", "'Discrete'", ":", "\n", "            ", "self", ".", "actions", "=", "self", ".", "actions", ".", "long", "(", ")", "\n", "", "self", ".", "masks", "=", "torch", ".", "ones", "(", "num_steps", "+", "1", ",", "num_processes", ",", "1", ")", "\n", "\n", "# Masks that indicate whether it's a true terminal state", "\n", "# or time limit end state", "\n", "self", ".", "bad_masks", "=", "torch", ".", "ones", "(", "num_steps", "+", "1", ",", "num_processes", ",", "1", ")", "\n", "\n", "self", ".", "num_steps", "=", "num_steps", "\n", "self", ".", "step", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to": [[35, 45], ["storage.RolloutStorage.obs.to", "storage.RolloutStorage.recurrent_hidden_states.to", "storage.RolloutStorage.rewards.to", "storage.RolloutStorage.value_preds.to", "storage.RolloutStorage.returns.to", "storage.RolloutStorage.action_log_probs.to", "storage.RolloutStorage.actions.to", "storage.RolloutStorage.masks.to", "storage.RolloutStorage.bad_masks.to"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "self", ".", "obs", "=", "self", ".", "obs", ".", "to", "(", "device", ")", "\n", "self", ".", "recurrent_hidden_states", "=", "self", ".", "recurrent_hidden_states", ".", "to", "(", "device", ")", "\n", "self", ".", "rewards", "=", "self", ".", "rewards", ".", "to", "(", "device", ")", "\n", "self", ".", "value_preds", "=", "self", ".", "value_preds", ".", "to", "(", "device", ")", "\n", "self", ".", "returns", "=", "self", ".", "returns", ".", "to", "(", "device", ")", "\n", "self", ".", "action_log_probs", "=", "self", ".", "action_log_probs", ".", "to", "(", "device", ")", "\n", "self", ".", "actions", "=", "self", ".", "actions", ".", "to", "(", "device", ")", "\n", "self", ".", "masks", "=", "self", ".", "masks", ".", "to", "(", "device", ")", "\n", "self", ".", "bad_masks", "=", "self", ".", "bad_masks", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.insert": [[46, 59], ["storage.RolloutStorage.obs[].copy_", "storage.RolloutStorage.recurrent_hidden_states[].copy_", "storage.RolloutStorage.actions[].copy_", "storage.RolloutStorage.action_log_probs[].copy_", "storage.RolloutStorage.value_preds[].copy_", "storage.RolloutStorage.rewards[].copy_", "storage.RolloutStorage.masks[].copy_", "storage.RolloutStorage.bad_masks[].copy_"], "methods", ["None"], ["", "def", "insert", "(", "self", ",", "obs", ",", "recurrent_hidden_states", ",", "actions", ",", "action_log_probs", ",", "\n", "value_preds", ",", "rewards", ",", "masks", ",", "bad_masks", ")", ":", "\n", "        ", "self", ".", "obs", "[", "self", ".", "step", "+", "1", "]", ".", "copy_", "(", "obs", ")", "\n", "self", ".", "recurrent_hidden_states", "[", "self", ".", "step", "+", "\n", "1", "]", ".", "copy_", "(", "recurrent_hidden_states", ")", "\n", "self", ".", "actions", "[", "self", ".", "step", "]", ".", "copy_", "(", "actions", ")", "\n", "self", ".", "action_log_probs", "[", "self", ".", "step", "]", ".", "copy_", "(", "action_log_probs", ")", "\n", "self", ".", "value_preds", "[", "self", ".", "step", "]", ".", "copy_", "(", "value_preds", ")", "\n", "self", ".", "rewards", "[", "self", ".", "step", "]", ".", "copy_", "(", "rewards", ")", "\n", "self", ".", "masks", "[", "self", ".", "step", "+", "1", "]", ".", "copy_", "(", "masks", ")", "\n", "self", ".", "bad_masks", "[", "self", ".", "step", "+", "1", "]", ".", "copy_", "(", "bad_masks", ")", "\n", "\n", "self", ".", "step", "=", "(", "self", ".", "step", "+", "1", ")", "%", "self", ".", "num_steps", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.after_update": [[60, 65], ["storage.RolloutStorage.obs[].copy_", "storage.RolloutStorage.recurrent_hidden_states[].copy_", "storage.RolloutStorage.masks[].copy_", "storage.RolloutStorage.bad_masks[].copy_"], "methods", ["None"], ["", "def", "after_update", "(", "self", ")", ":", "\n", "        ", "self", ".", "obs", "[", "0", "]", ".", "copy_", "(", "self", ".", "obs", "[", "-", "1", "]", ")", "\n", "self", ".", "recurrent_hidden_states", "[", "0", "]", ".", "copy_", "(", "self", ".", "recurrent_hidden_states", "[", "-", "1", "]", ")", "\n", "self", ".", "masks", "[", "0", "]", ".", "copy_", "(", "self", ".", "masks", "[", "-", "1", "]", ")", "\n", "self", ".", "bad_masks", "[", "0", "]", ".", "copy_", "(", "self", ".", "bad_masks", "[", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.compute_returns": [[66, 106], ["reversed", "reversed", "reversed", "reversed", "range", "range", "range", "range", "storage.RolloutStorage.rewards.size", "storage.RolloutStorage.rewards.size", "storage.RolloutStorage.rewards.size", "storage.RolloutStorage.rewards.size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "compute_returns", "(", "self", ",", "\n", "next_value", ",", "\n", "use_gae", ",", "\n", "gamma", ",", "\n", "gae_lambda", ",", "\n", "use_proper_time_limits", "=", "True", ")", ":", "\n", "        ", "if", "use_proper_time_limits", ":", "\n", "            ", "if", "use_gae", ":", "\n", "                ", "self", ".", "value_preds", "[", "-", "1", "]", "=", "next_value", "\n", "gae", "=", "0", "\n", "for", "step", "in", "reversed", "(", "range", "(", "self", ".", "rewards", ".", "size", "(", "0", ")", ")", ")", ":", "\n", "                    ", "delta", "=", "self", ".", "rewards", "[", "step", "]", "+", "gamma", "*", "self", ".", "value_preds", "[", "\n", "step", "+", "1", "]", "*", "self", ".", "masks", "[", "step", "+", "\n", "1", "]", "-", "self", ".", "value_preds", "[", "step", "]", "\n", "gae", "=", "delta", "+", "gamma", "*", "gae_lambda", "*", "self", ".", "masks", "[", "step", "+", "\n", "1", "]", "*", "gae", "\n", "gae", "=", "gae", "*", "self", ".", "bad_masks", "[", "step", "+", "1", "]", "\n", "self", ".", "returns", "[", "step", "]", "=", "gae", "+", "self", ".", "value_preds", "[", "step", "]", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "returns", "[", "-", "1", "]", "=", "next_value", "\n", "for", "step", "in", "reversed", "(", "range", "(", "self", ".", "rewards", ".", "size", "(", "0", ")", ")", ")", ":", "\n", "                    ", "self", ".", "returns", "[", "step", "]", "=", "(", "self", ".", "returns", "[", "step", "+", "1", "]", "*", "gamma", "*", "self", ".", "masks", "[", "step", "+", "1", "]", "+", "self", ".", "rewards", "[", "step", "]", ")", "*", "self", ".", "bad_masks", "[", "step", "+", "1", "]", "+", "(", "1", "-", "self", ".", "bad_masks", "[", "step", "+", "1", "]", ")", "*", "self", ".", "value_preds", "[", "step", "]", "\n", "", "", "", "else", ":", "\n", "            ", "if", "use_gae", ":", "\n", "                ", "self", ".", "value_preds", "[", "-", "1", "]", "=", "next_value", "\n", "gae", "=", "0", "\n", "for", "step", "in", "reversed", "(", "range", "(", "self", ".", "rewards", ".", "size", "(", "0", ")", ")", ")", ":", "\n", "                    ", "delta", "=", "self", ".", "rewards", "[", "step", "]", "+", "gamma", "*", "self", ".", "value_preds", "[", "\n", "step", "+", "1", "]", "*", "self", ".", "masks", "[", "step", "+", "\n", "1", "]", "-", "self", ".", "value_preds", "[", "step", "]", "\n", "gae", "=", "delta", "+", "gamma", "*", "gae_lambda", "*", "self", ".", "masks", "[", "step", "+", "\n", "1", "]", "*", "gae", "\n", "self", ".", "returns", "[", "step", "]", "=", "gae", "+", "self", ".", "value_preds", "[", "step", "]", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "returns", "[", "-", "1", "]", "=", "next_value", "\n", "for", "step", "in", "reversed", "(", "range", "(", "self", ".", "rewards", ".", "size", "(", "0", ")", ")", ")", ":", "\n", "                    ", "self", ".", "returns", "[", "step", "]", "=", "self", ".", "returns", "[", "step", "+", "1", "]", "*", "gamma", "*", "self", ".", "masks", "[", "step", "+", "1", "]", "+", "self", ".", "rewards", "[", "step", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.feed_forward_generator": [[107, 144], ["torch.utils.data.sampler.BatchSampler", "storage.RolloutStorage.rewards.size", "torch.utils.data.sampler.SubsetRandomSampler", "range", "storage.RolloutStorage.obs[].view", "storage.RolloutStorage.recurrent_hidden_states[].view", "storage.RolloutStorage.actions.view", "storage.RolloutStorage.value_preds[].view", "storage.RolloutStorage.returns[].view", "storage.RolloutStorage.masks[].view", "storage.RolloutStorage.action_log_probs.view", "storage.RolloutStorage.recurrent_hidden_states.size", "storage.RolloutStorage.actions.size", "advantages.view", "storage.RolloutStorage.obs.size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "", "", "", "def", "feed_forward_generator", "(", "self", ",", "\n", "advantages", ",", "\n", "num_mini_batch", "=", "None", ",", "\n", "mini_batch_size", "=", "None", ")", ":", "\n", "        ", "num_steps", ",", "num_processes", "=", "self", ".", "rewards", ".", "size", "(", ")", "[", "0", ":", "2", "]", "\n", "batch_size", "=", "num_processes", "*", "num_steps", "\n", "\n", "if", "mini_batch_size", "is", "None", ":", "\n", "            ", "assert", "batch_size", ">=", "num_mini_batch", ",", "(", "\n", "\"PPO requires the number of processes ({}) \"", "\n", "\"* number of steps ({}) = {} \"", "\n", "\"to be greater than or equal to the number of PPO mini batches ({}).\"", "\n", "\"\"", ".", "format", "(", "num_processes", ",", "num_steps", ",", "num_processes", "*", "num_steps", ",", "\n", "num_mini_batch", ")", ")", "\n", "mini_batch_size", "=", "batch_size", "//", "num_mini_batch", "\n", "", "sampler", "=", "BatchSampler", "(", "\n", "SubsetRandomSampler", "(", "range", "(", "batch_size", ")", ")", ",", "\n", "mini_batch_size", ",", "\n", "drop_last", "=", "True", ")", "\n", "for", "indices", "in", "sampler", ":", "\n", "            ", "obs_batch", "=", "self", ".", "obs", "[", ":", "-", "1", "]", ".", "view", "(", "-", "1", ",", "*", "self", ".", "obs", ".", "size", "(", ")", "[", "2", ":", "]", ")", "[", "indices", "]", "\n", "recurrent_hidden_states_batch", "=", "self", ".", "recurrent_hidden_states", "[", ":", "-", "1", "]", ".", "view", "(", "\n", "-", "1", ",", "self", ".", "recurrent_hidden_states", ".", "size", "(", "-", "1", ")", ")", "[", "indices", "]", "\n", "actions_batch", "=", "self", ".", "actions", ".", "view", "(", "-", "1", ",", "\n", "self", ".", "actions", ".", "size", "(", "-", "1", ")", ")", "[", "indices", "]", "\n", "value_preds_batch", "=", "self", ".", "value_preds", "[", ":", "-", "1", "]", ".", "view", "(", "-", "1", ",", "1", ")", "[", "indices", "]", "\n", "return_batch", "=", "self", ".", "returns", "[", ":", "-", "1", "]", ".", "view", "(", "-", "1", ",", "1", ")", "[", "indices", "]", "\n", "masks_batch", "=", "self", ".", "masks", "[", ":", "-", "1", "]", ".", "view", "(", "-", "1", ",", "1", ")", "[", "indices", "]", "\n", "old_action_log_probs_batch", "=", "self", ".", "action_log_probs", ".", "view", "(", "-", "1", ",", "\n", "1", ")", "[", "indices", "]", "\n", "if", "advantages", "is", "None", ":", "\n", "                ", "adv_targ", "=", "None", "\n", "", "else", ":", "\n", "                ", "adv_targ", "=", "advantages", ".", "view", "(", "-", "1", ",", "1", ")", "[", "indices", "]", "\n", "\n", "", "yield", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "actions_batch", ",", "value_preds_batch", ",", "return_batch", ",", "masks_batch", ",", "old_action_log_probs_batch", ",", "adv_targ", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.recurrent_generator": [[145, 203], ["storage.RolloutStorage.rewards.size", "torch.randperm", "range", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack().view", "storage._flatten_helper", "storage._flatten_helper", "storage._flatten_helper", "storage._flatten_helper", "storage._flatten_helper", "storage._flatten_helper", "storage._flatten_helper", "_flatten_helper.append", "torch.stack().view.append", "_flatten_helper.append", "_flatten_helper.append", "_flatten_helper.append", "_flatten_helper.append", "_flatten_helper.append", "_flatten_helper.append", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage._flatten_helper", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage._flatten_helper", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage._flatten_helper", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage._flatten_helper", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage._flatten_helper", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage._flatten_helper", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage._flatten_helper"], ["", "", "def", "recurrent_generator", "(", "self", ",", "advantages", ",", "num_mini_batch", ")", ":", "\n", "        ", "num_processes", "=", "self", ".", "rewards", ".", "size", "(", "1", ")", "\n", "assert", "num_processes", ">=", "num_mini_batch", ",", "(", "\n", "\"PPO requires the number of processes ({}) \"", "\n", "\"to be greater than or equal to the number of \"", "\n", "\"PPO mini batches ({}).\"", ".", "format", "(", "num_processes", ",", "num_mini_batch", ")", ")", "\n", "num_envs_per_batch", "=", "num_processes", "//", "num_mini_batch", "\n", "perm", "=", "torch", ".", "randperm", "(", "num_processes", ")", "\n", "for", "start_ind", "in", "range", "(", "0", ",", "num_processes", ",", "num_envs_per_batch", ")", ":", "\n", "            ", "obs_batch", "=", "[", "]", "\n", "recurrent_hidden_states_batch", "=", "[", "]", "\n", "actions_batch", "=", "[", "]", "\n", "value_preds_batch", "=", "[", "]", "\n", "return_batch", "=", "[", "]", "\n", "masks_batch", "=", "[", "]", "\n", "old_action_log_probs_batch", "=", "[", "]", "\n", "adv_targ", "=", "[", "]", "\n", "\n", "for", "offset", "in", "range", "(", "num_envs_per_batch", ")", ":", "\n", "                ", "ind", "=", "perm", "[", "start_ind", "+", "offset", "]", "\n", "obs_batch", ".", "append", "(", "self", ".", "obs", "[", ":", "-", "1", ",", "ind", "]", ")", "\n", "recurrent_hidden_states_batch", ".", "append", "(", "\n", "self", ".", "recurrent_hidden_states", "[", "0", ":", "1", ",", "ind", "]", ")", "\n", "actions_batch", ".", "append", "(", "self", ".", "actions", "[", ":", ",", "ind", "]", ")", "\n", "value_preds_batch", ".", "append", "(", "self", ".", "value_preds", "[", ":", "-", "1", ",", "ind", "]", ")", "\n", "return_batch", ".", "append", "(", "self", ".", "returns", "[", ":", "-", "1", ",", "ind", "]", ")", "\n", "masks_batch", ".", "append", "(", "self", ".", "masks", "[", ":", "-", "1", ",", "ind", "]", ")", "\n", "old_action_log_probs_batch", ".", "append", "(", "\n", "self", ".", "action_log_probs", "[", ":", ",", "ind", "]", ")", "\n", "adv_targ", ".", "append", "(", "advantages", "[", ":", ",", "ind", "]", ")", "\n", "\n", "", "T", ",", "N", "=", "self", ".", "num_steps", ",", "num_envs_per_batch", "\n", "# These are all tensors of size (T, N, -1)", "\n", "obs_batch", "=", "torch", ".", "stack", "(", "obs_batch", ",", "1", ")", "\n", "actions_batch", "=", "torch", ".", "stack", "(", "actions_batch", ",", "1", ")", "\n", "value_preds_batch", "=", "torch", ".", "stack", "(", "value_preds_batch", ",", "1", ")", "\n", "return_batch", "=", "torch", ".", "stack", "(", "return_batch", ",", "1", ")", "\n", "masks_batch", "=", "torch", ".", "stack", "(", "masks_batch", ",", "1", ")", "\n", "old_action_log_probs_batch", "=", "torch", ".", "stack", "(", "\n", "old_action_log_probs_batch", ",", "1", ")", "\n", "adv_targ", "=", "torch", ".", "stack", "(", "adv_targ", ",", "1", ")", "\n", "\n", "# States is just a (N, -1) tensor", "\n", "recurrent_hidden_states_batch", "=", "torch", ".", "stack", "(", "\n", "recurrent_hidden_states_batch", ",", "1", ")", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "\n", "# Flatten the (T, N, ...) tensors to (T * N, ...)", "\n", "obs_batch", "=", "_flatten_helper", "(", "T", ",", "N", ",", "obs_batch", ")", "\n", "actions_batch", "=", "_flatten_helper", "(", "T", ",", "N", ",", "actions_batch", ")", "\n", "value_preds_batch", "=", "_flatten_helper", "(", "T", ",", "N", ",", "value_preds_batch", ")", "\n", "return_batch", "=", "_flatten_helper", "(", "T", ",", "N", ",", "return_batch", ")", "\n", "masks_batch", "=", "_flatten_helper", "(", "T", ",", "N", ",", "masks_batch", ")", "\n", "old_action_log_probs_batch", "=", "_flatten_helper", "(", "T", ",", "N", ",", "old_action_log_probs_batch", ")", "\n", "adv_targ", "=", "_flatten_helper", "(", "T", ",", "N", ",", "adv_targ", ")", "\n", "\n", "yield", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "actions_batch", ",", "value_preds_batch", ",", "return_batch", ",", "masks_batch", ",", "old_action_log_probs_batch", ",", "adv_targ", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage._flatten_helper": [[5, 7], ["_tensor.view", "_tensor.size"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["def", "_flatten_helper", "(", "T", ",", "N", ",", "_tensor", ")", ":", "\n", "    ", "return", "_tensor", ".", "view", "(", "T", "*", "N", ",", "*", "_tensor", ".", "size", "(", ")", "[", "2", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.__init__": [[33, 36], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "bias.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__"], []], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward": [[37, 44], ["x.dim", "utils.AddBias._bias.t().view", "utils.AddBias._bias.t().view", "utils.AddBias._bias.t", "utils.AddBias._bias.t"], "methods", ["None"], []], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.get_render_func": [[11, 20], ["hasattr", "hasattr", "utils.get_render_func", "hasattr", "utils.get_render_func"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.get_render_func", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.get_render_func"], ["import", "pandas", "as", "pd", "\n", "from", "PIL", "import", "Image", "\n", "from", "sklearn", ".", "feature_extraction", "import", "image", "\n", "import", "torchvision", ".", "transforms", ".", "functional", "as", "tvF", "\n", "import", "torchvision", ".", "transforms", "as", "transforms", "\n", "from", "torchvision", "import", "models", "\n", "from", "torchvision", ".", "models", ".", "resnet", "import", "*", "\n", "from", "arguments", "import", "get_args", "\n", "args", "=", "get_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.get_vec_normalize": [[22, 29], ["isinstance", "hasattr", "utils.get_vec_normalize"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.get_vec_normalize"], ["feature_extractor", "=", "nn", ".", "Sequential", "(", "*", "list", "(", "resnet_model", ".", "children", "(", ")", ")", "[", ":", "-", "4", "]", ")", "\n", "\n", "class", "Adam", "(", "Optimizer", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.update_linear_schedule": [[46, 51], ["float"], "function", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "params", ",", "lr", "=", "1e-3", ",", "lr_rho", "=", "1e-3", ",", "betas", "=", "(", "0.9", ",", "0.999", ")", ",", "eps", "=", "1e-8", ",", "\n", "weight_decay", "=", "0", ",", "amsgrad", "=", "False", ",", "param_name", "=", "None", ",", "lr_scale", "=", "None", ")", ":", "\n", "        ", "if", "not", "0.0", "<=", "lr", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid learning rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.init": [[53, 57], ["weight_init", "bias_init"], "function", ["None"], ["            ", "raise", "ValueError", "(", "\"Invalid epsilon value: {}\"", ".", "format", "(", "eps", ")", ")", "\n", "", "if", "not", "0.0", "<=", "betas", "[", "0", "]", "<", "1.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid beta parameter at index 0: {}\"", ".", "format", "(", "betas", "[", "0", "]", ")", ")", "\n", "", "if", "not", "0.0", "<=", "betas", "[", "1", "]", "<", "1.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid beta parameter at index 1: {}\"", ".", "format", "(", "betas", "[", "1", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.cleanup_log_dir": [[59, 66], ["os.makedirs", "glob.glob", "os.path.join", "os.remove"], "function", ["None"], ["weight_decay", "=", "weight_decay", ",", "amsgrad", "=", "amsgrad", ")", "\n", "self", ".", "param_name", "=", "param_name", "\n", "self", ".", "lr_rho", "=", "lr_rho", "\n", "self", ".", "lr_scale", "=", "lr_scale", "\n", "super", "(", "Adam", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n", "", "def", "__setstate__", "(", "self", ",", "state", ")", ":", "\n", "        ", "super", "(", "Adam", ",", "self", ")", ".", "__setstate__", "(", "state", ")", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_notmnist.split_notMNIST_loader": [[17, 53], ["range", "os.listdir", "os.path.join", "print", "os.listdir", "os.path.join", "torch.Tensor().float", "[].append", "[].append", "scipy.misc.imread", "print", "torch.Tensor", "ord", "ord"], "function", ["None"], ["def", "split_notMNIST_loader", "(", "root", ")", ":", "\n", "\n", "    ", "data", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "        ", "data", "[", "i", "]", "=", "{", "}", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'split_notmnist-{:d}'", ".", "format", "(", "i", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "2", "\n", "data", "[", "i", "]", "[", "'train'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "'test'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "\n", "", "folders", "=", "os", ".", "listdir", "(", "root", ")", "\n", "task_cnt", "=", "0", "\n", "for", "folder", "in", "folders", ":", "\n", "        ", "folder_path", "=", "os", ".", "path", ".", "join", "(", "root", ",", "folder", ")", "\n", "cnt", "=", "0", "\n", "print", "(", "folder", ")", "\n", "for", "ims", "in", "os", ".", "listdir", "(", "folder_path", ")", ":", "\n", "            ", "s", "=", "'train'", "\n", "if", "cnt", ">=", "40000", ":", "\n", "                ", "s", "=", "'test'", "\n", "", "try", ":", "\n", "                ", "img_path", "=", "os", ".", "path", ".", "join", "(", "folder_path", ",", "ims", ")", "\n", "img", "=", "imread", "(", "img_path", ")", "/", "255.0", "\n", "img_tensor", "=", "Tensor", "(", "img", ")", ".", "float", "(", ")", "\n", "task_idx", "=", "(", "ord", "(", "folder", ")", "-", "65", ")", "%", "5", "\n", "label", "=", "(", "ord", "(", "folder", ")", "-", "65", ")", "//", "5", "\n", "data", "[", "task_idx", "]", "[", "s", "]", "[", "'x'", "]", ".", "append", "(", "img_tensor", ")", "\n", "data", "[", "task_idx", "]", "[", "s", "]", "[", "'y'", "]", ".", "append", "(", "label", ")", "# Folders are A-J so labels will be 0-9", "\n", "cnt", "+=", "1", "\n", "\n", "", "except", ":", "\n", "# Some images in the dataset are damaged", "\n", "                ", "print", "(", "\"File {}/{} is broken\"", ".", "format", "(", "folder", ",", "ims", ")", ")", "\n", "", "", "task_cnt", "+=", "1", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_notmnist.get": [[55, 109], ["range", "range", "os.path.isdir", "os.makedirs", "os.path.dirname", "split_notmnist.split_notMNIST_loader", "range", "range", "[].clone", "[].clone", "taskcla.append", "os.path.join", "dict.fromkeys", "torch.stack", "torch.LongTensor().view", "torch.save", "torch.save", "torch.load", "torch.load", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "torch.LongTensor", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "numpy.array", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_notmnist.split_notMNIST_loader", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load"], ["", "def", "get", "(", "seed", "=", "0", ",", "fixed_order", "=", "False", ",", "pc_valid", "=", "0", ",", "tasknum", "=", "5", ")", ":", "\n", "    ", "if", "tasknum", ">", "5", ":", "\n", "        ", "tasknum", "=", "5", "\n", "\n", "", "data", "=", "{", "}", "\n", "taskcla", "=", "[", "]", "\n", "size", "=", "[", "1", ",", "28", ",", "28", "]", "\n", "\n", "\n", "# Pre-load", "\n", "# notMNIST", "\n", "#     mean = (0.1307,)", "\n", "#     std = (0.3081,)", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "'../dat/binary_split_notmnist/'", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "'../dat/binary_split_notmnist'", ")", "\n", "root", "=", "os", ".", "path", ".", "dirname", "(", "__file__", ")", "\n", "data", "=", "split_notMNIST_loader", "(", "os", ".", "path", ".", "join", "(", "root", ",", "'../../dat/notMNIST_large'", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "            ", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "                ", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "stack", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "LongTensor", "(", "np", ".", "array", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", ",", "dtype", "=", "int", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "torch", ".", "save", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_notmnist'", ")", ",", "\n", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "torch", ".", "save", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_notmnist'", ")", ",", "\n", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "", "", "", "else", ":", "\n", "# Load binary files", "\n", "        ", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "            ", "data", "[", "i", "]", "=", "dict", ".", "fromkeys", "(", "[", "'name'", ",", "'ncla'", ",", "'train'", ",", "'test'", "]", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "2", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'split_notmnist-{:d}'", ".", "format", "(", "i", ")", "\n", "\n", "# Load", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "                ", "data", "[", "i", "]", "[", "s", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_notmnist'", ")", ",", "\n", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_notmnist'", ")", ",", "\n", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "\n", "", "", "", "for", "t", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "data", "[", "t", "]", "[", "'valid'", "]", "=", "{", "}", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'x'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'y'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", ".", "clone", "(", ")", "\n", "\n", "# Others", "\n", "", "n", "=", "0", "\n", "for", "t", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "taskcla", ".", "append", "(", "(", "t", ",", "data", "[", "t", "]", "[", "'ncla'", "]", ")", ")", "\n", "n", "+=", "data", "[", "t", "]", "[", "'ncla'", "]", "\n", "", "data", "[", "'ncla'", "]", "=", "n", "\n", "\n", "return", "data", ",", "taskcla", ",", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.pmnist.get": [[10, 56], ["torch.Tensor", "torch.Tensor", "torchvision.datasets.MNIST", "torchvision.datasets.MNIST", "range", "range", "range", "print", "sys.stdout.flush", "numpy.random.permutation", "[].clone", "[].clone", "taskcla.append", "arr[].view", "dat[].train_data.view().float", "torch.LongTensor", "dat[].test_data.view().float", "torch.LongTensor", "dat[].train_data.view", "dat[].test_data.view"], "function", ["None"], ["def", "get", "(", "seed", "=", "0", ",", "fixed_order", "=", "False", ",", "pc_valid", "=", "0", ",", "tasknum", "=", "10", ")", ":", "\n", "    ", "data", "=", "{", "}", "\n", "taskcla", "=", "[", "]", "\n", "size", "=", "[", "1", ",", "28", ",", "28", "]", "\n", "# Pre-load", "\n", "# MNIST", "\n", "mean", "=", "torch", ".", "Tensor", "(", "[", "0.1307", "]", ")", "\n", "std", "=", "torch", ".", "Tensor", "(", "[", "0.3081", "]", ")", "\n", "dat", "=", "{", "}", "\n", "dat", "[", "'train'", "]", "=", "datasets", ".", "MNIST", "(", "'../dat/'", ",", "train", "=", "True", ",", "download", "=", "True", ")", "\n", "dat", "[", "'test'", "]", "=", "datasets", ".", "MNIST", "(", "'../dat/'", ",", "train", "=", "False", ",", "download", "=", "True", ")", "\n", "\n", "for", "i", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "print", "(", "i", ",", "end", "=", "','", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "data", "[", "i", "]", "=", "{", "}", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'pmnist-{:d}'", ".", "format", "(", "i", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "10", "\n", "permutation", "=", "np", ".", "random", ".", "permutation", "(", "28", "*", "28", ")", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "            ", "if", "s", "==", "'train'", ":", "\n", "                ", "arr", "=", "dat", "[", "s", "]", ".", "train_data", ".", "view", "(", "dat", "[", "s", "]", ".", "train_data", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ".", "float", "(", ")", "\n", "label", "=", "torch", ".", "LongTensor", "(", "dat", "[", "s", "]", ".", "train_labels", ")", "\n", "", "else", ":", "\n", "                ", "arr", "=", "dat", "[", "s", "]", ".", "test_data", ".", "view", "(", "dat", "[", "s", "]", ".", "test_data", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ".", "float", "(", ")", "\n", "label", "=", "torch", ".", "LongTensor", "(", "dat", "[", "s", "]", ".", "test_labels", ")", "\n", "\n", "", "arr", "=", "(", "arr", "/", "255", "-", "mean", ")", "/", "std", "\n", "data", "[", "i", "]", "[", "s", "]", "=", "{", "}", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "arr", "[", ":", ",", "permutation", "]", ".", "view", "(", "-", "1", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "size", "[", "2", "]", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "label", "\n", "\n", "# Validation", "\n", "", "", "for", "t", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "data", "[", "t", "]", "[", "'valid'", "]", "=", "{", "}", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'x'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'y'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", ".", "clone", "(", ")", "\n", "\n", "# Others", "\n", "", "n", "=", "0", "\n", "for", "t", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "taskcla", ".", "append", "(", "(", "t", ",", "data", "[", "t", "]", "[", "'ncla'", "]", ")", ")", "\n", "n", "+=", "data", "[", "t", "]", "[", "'ncla'", "]", "\n", "", "data", "[", "'ncla'", "]", "=", "n", "\n", "\n", "return", "data", ",", "taskcla", ",", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_mnist.get": [[8, 71], ["range", "range", "os.path.isdir", "os.makedirs", "torchvision.datasets.MNIST", "torchvision.datasets.MNIST", "range", "range", "range", "[].clone", "[].clone", "taskcla.append", "torch.utils.data.DataLoader", "dict.fromkeys", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "[].append", "[].append", "torch.stack", "torch.LongTensor().view", "torch.save", "torch.save", "torch.load", "torch.load", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "target.numpy", "torch.LongTensor", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "target.numpy", "numpy.array", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load"], ["def", "get", "(", "seed", "=", "0", ",", "fixed_order", "=", "False", ",", "pc_valid", "=", "0", ",", "tasknum", "=", "5", ")", ":", "\n", "    ", "if", "tasknum", ">", "5", ":", "\n", "        ", "tasknum", "=", "5", "\n", "", "data", "=", "{", "}", "\n", "taskcla", "=", "[", "]", "\n", "size", "=", "[", "1", ",", "28", ",", "28", "]", "\n", "\n", "# Pre-load", "\n", "# MNIST", "\n", "mean", "=", "(", "0.1307", ",", ")", "\n", "std", "=", "(", "0.3081", ",", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "'../dat/binary_split_mnist/'", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "'../dat/binary_split_mnist'", ")", "\n", "dat", "=", "{", "}", "\n", "dat", "[", "'train'", "]", "=", "datasets", ".", "MNIST", "(", "'../dat/'", ",", "train", "=", "True", ",", "download", "=", "True", ",", "transform", "=", "transforms", ".", "Compose", "(", "\n", "[", "transforms", ".", "ToTensor", "(", ")", ",", "transforms", ".", "Normalize", "(", "mean", ",", "std", ")", "]", ")", ")", "\n", "dat", "[", "'test'", "]", "=", "datasets", ".", "MNIST", "(", "'../dat/'", ",", "train", "=", "False", ",", "download", "=", "True", ",", "transform", "=", "transforms", ".", "Compose", "(", "\n", "[", "transforms", ".", "ToTensor", "(", ")", ",", "transforms", ".", "Normalize", "(", "mean", ",", "std", ")", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "            ", "data", "[", "i", "]", "=", "{", "}", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'split_mnist-{:d}'", ".", "format", "(", "i", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "2", "\n", "data", "[", "i", "]", "[", "'train'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "'test'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "            ", "loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dat", "[", "s", "]", ",", "batch_size", "=", "1", ",", "shuffle", "=", "False", ")", "\n", "for", "image", ",", "target", "in", "loader", ":", "\n", "                ", "task_idx", "=", "target", ".", "numpy", "(", ")", "[", "0", "]", "//", "2", "\n", "data", "[", "task_idx", "]", "[", "s", "]", "[", "'x'", "]", ".", "append", "(", "image", ")", "\n", "data", "[", "task_idx", "]", "[", "s", "]", "[", "'y'", "]", ".", "append", "(", "target", ".", "numpy", "(", ")", "[", "0", "]", "%", "2", ")", "\n", "\n", "", "", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "            ", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "                ", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "stack", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "LongTensor", "(", "np", ".", "array", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", ",", "dtype", "=", "int", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "torch", ".", "save", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_mnist'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "torch", ".", "save", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_mnist'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "", "", "", "else", ":", "\n", "# Load binary files", "\n", "        ", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "            ", "data", "[", "i", "]", "=", "dict", ".", "fromkeys", "(", "[", "'name'", ",", "'ncla'", ",", "'train'", ",", "'test'", "]", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "2", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'split_mnist-{:d}'", ".", "format", "(", "i", ")", "\n", "\n", "# Load", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "                ", "data", "[", "i", "]", "[", "s", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_mnist'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_mnist'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "\n", "", "", "", "for", "t", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "data", "[", "t", "]", "[", "'valid'", "]", "=", "{", "}", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'x'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'y'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", ".", "clone", "(", ")", "\n", "\n", "# Others", "\n", "", "n", "=", "0", "\n", "for", "t", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "taskcla", ".", "append", "(", "(", "t", ",", "data", "[", "t", "]", "[", "'ncla'", "]", ")", ")", "\n", "n", "+=", "data", "[", "t", "]", "[", "'ncla'", "]", "\n", "", "data", "[", "'ncla'", "]", "=", "n", "\n", "\n", "return", "data", ",", "taskcla", ",", "size", "\n", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.row_pmnist.get": [[10, 57], ["torch.Tensor", "torch.Tensor", "torchvision.datasets.MNIST", "torchvision.datasets.MNIST", "range", "range", "range", "print", "sys.stdout.flush", "numpy.random.permutation", "[].clone", "[].clone", "taskcla.append", "arr[].view", "dat[].train_data.float", "torch.LongTensor", "dat[].test_data.float", "torch.LongTensor"], "function", ["None"], ["def", "get", "(", "seed", "=", "0", ",", "fixed_order", "=", "False", ",", "pc_valid", "=", "0", ",", "tasknum", "=", "10", ")", ":", "\n", "    ", "data", "=", "{", "}", "\n", "taskcla", "=", "[", "]", "\n", "size", "=", "[", "1", ",", "28", ",", "28", "]", "\n", "\n", "# Pre-load", "\n", "# MNIST", "\n", "mean", "=", "torch", ".", "Tensor", "(", "[", "0.1307", "]", ")", "\n", "std", "=", "torch", ".", "Tensor", "(", "[", "0.3081", "]", ")", "\n", "dat", "=", "{", "}", "\n", "dat", "[", "'train'", "]", "=", "datasets", ".", "MNIST", "(", "'../dat/'", ",", "train", "=", "True", ",", "download", "=", "True", ")", "\n", "dat", "[", "'test'", "]", "=", "datasets", ".", "MNIST", "(", "'../dat/'", ",", "train", "=", "False", ",", "download", "=", "True", ")", "\n", "\n", "for", "i", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "print", "(", "i", ",", "end", "=", "','", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "data", "[", "i", "]", "=", "{", "}", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'pmnist-{:d}'", ".", "format", "(", "i", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "10", "\n", "permutation", "=", "np", ".", "random", ".", "permutation", "(", "28", ")", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "            ", "if", "s", "==", "'train'", ":", "\n", "                ", "arr", "=", "dat", "[", "s", "]", ".", "train_data", ".", "float", "(", ")", "\n", "label", "=", "torch", ".", "LongTensor", "(", "dat", "[", "s", "]", ".", "train_labels", ")", "\n", "", "else", ":", "\n", "                ", "arr", "=", "dat", "[", "s", "]", ".", "test_data", ".", "float", "(", ")", "\n", "label", "=", "torch", ".", "LongTensor", "(", "dat", "[", "s", "]", ".", "test_labels", ")", "\n", "\n", "", "arr", "=", "(", "arr", "/", "255", "-", "mean", ")", "/", "std", "\n", "data", "[", "i", "]", "[", "s", "]", "=", "{", "}", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "arr", "[", ":", ",", "permutation", ",", ":", "]", ".", "view", "(", "-", "1", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "size", "[", "2", "]", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "label", "\n", "\n", "# Validation", "\n", "", "", "for", "t", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "data", "[", "t", "]", "[", "'valid'", "]", "=", "{", "}", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'x'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'y'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", ".", "clone", "(", ")", "\n", "\n", "# Others", "\n", "", "n", "=", "0", "\n", "for", "t", "in", "range", "(", "tasknum", ")", ":", "\n", "        ", "taskcla", ".", "append", "(", "(", "t", ",", "data", "[", "t", "]", "[", "'ncla'", "]", ")", ")", "\n", "n", "+=", "data", "[", "t", "]", "[", "'ncla'", "]", "\n", "", "data", "[", "'ncla'", "]", "=", "n", "\n", "\n", "return", "data", ",", "taskcla", ",", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_omniglot.get": [[11, 101], ["data.keys", "print", "print", "os.path.isdir", "os.makedirs", "os.path.join", "torch.load", "range", "torch.save", "torch.load", "list", "print", "range", "taskcla.append", "print", "os.getcwd", "os.path.join", "numpy.arange", "numpy.random.shuffle", "os.path.join", "os.path.join", "numpy.arange", "dict.fromkeys", "len", "torch.LongTensor().view", "torch.save", "torch.save", "os.path.expanduser", "os.path.expanduser", "torch.load", "torch.load", "len", "len", "len", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "torch.LongTensor", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "numpy.array", "torch.max", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load"], ["def", "get", "(", "seed", "=", "0", ",", "fixed_order", "=", "False", ",", "pc_valid", "=", "0", ",", "tasknum", "=", "50", ")", ":", "\n", "    ", "data", "=", "{", "}", "\n", "taskcla", "=", "[", "]", "\n", "size", "=", "[", "1", ",", "28", ",", "28", "]", "\n", "tasknum", "=", "50", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "'../dat/binary_omniglot/'", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "'../dat/binary_omniglot'", ")", "\n", "\n", "filename", "=", "'Permuted_Omniglot_task50.pt'", "\n", "filepath", "=", "os", ".", "path", ".", "join", "(", "os", ".", "getcwd", "(", ")", ",", "'dataloaders'", ")", "\n", "#         filepath = os.path.join(os.getcwd(), '')", "\n", "f", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "filepath", ",", "filename", ")", ")", "\n", "ncla_dict", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "tasknum", ")", ":", "\n", "            ", "data", "[", "i", "]", "=", "{", "}", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'omniglot-{:d}'", ".", "format", "(", "i", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "(", "torch", ".", "max", "(", "f", "[", "'Y'", "]", "[", "'train'", "]", "[", "i", "]", ")", "+", "1", ")", ".", "int", "(", ")", ".", "item", "(", ")", "\n", "ncla_dict", "[", "i", "]", "=", "data", "[", "i", "]", "[", "'ncla'", "]", "\n", "\n", "\n", "#                 loader = torch.utils.data.DataLoader(dat[s], batch_size=1, shuffle=False)", "\n", "data", "[", "i", "]", "[", "'train'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "'test'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "'valid'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "\n", "image", "=", "f", "[", "'X'", "]", "[", "'train'", "]", "[", "i", "]", "\n", "target", "=", "f", "[", "'Y'", "]", "[", "'train'", "]", "[", "i", "]", "\n", "\n", "index_arr", "=", "np", ".", "arange", "(", "len", "(", "image", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "index_arr", ")", "\n", "train_ratio", "=", "(", "len", "(", "image", ")", "//", "10", ")", "*", "8", "\n", "valid_ratio", "=", "(", "len", "(", "image", ")", "//", "10", ")", "*", "1", "\n", "test_ratio", "=", "(", "len", "(", "image", ")", "//", "10", ")", "*", "1", "\n", "\n", "train_idx", "=", "index_arr", "[", ":", "train_ratio", "]", "\n", "valid_idx", "=", "index_arr", "[", "train_ratio", ":", "train_ratio", "+", "valid_ratio", "]", "\n", "test_idx", "=", "index_arr", "[", "train_ratio", "+", "valid_ratio", ":", "]", "\n", "\n", "data", "[", "i", "]", "[", "'train'", "]", "[", "'x'", "]", "=", "image", "[", "train_idx", "]", "\n", "data", "[", "i", "]", "[", "'train'", "]", "[", "'y'", "]", "=", "target", "[", "train_idx", "]", "\n", "data", "[", "i", "]", "[", "'valid'", "]", "[", "'x'", "]", "=", "image", "[", "valid_idx", "]", "\n", "data", "[", "i", "]", "[", "'valid'", "]", "[", "'y'", "]", "=", "target", "[", "valid_idx", "]", "\n", "data", "[", "i", "]", "[", "'test'", "]", "[", "'x'", "]", "=", "image", "[", "test_idx", "]", "\n", "data", "[", "i", "]", "[", "'test'", "]", "[", "'y'", "]", "=", "target", "[", "test_idx", "]", "\n", "\n", "\n", "# \"Unify\" and save", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", ",", "'valid'", "]", ":", "\n", "#                 data[i][s]['x'] = torch.stack(data[i][s]['x']).view(-1, size[0], size[1], size[2])", "\n", "                ", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "LongTensor", "(", "np", ".", "array", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", ",", "dtype", "=", "int", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "torch", ".", "save", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "torch", ".", "save", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "", "", "torch", ".", "save", "(", "ncla_dict", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'ncla_dict.pt'", ")", ")", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "ncla_dict", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'ncla_dict.pt'", ")", ")", "\n", "# Load binary files", "\n", "#         ids=list(shuffle(np.arange(tasknum),random_state=seed))", "\n", "ids", "=", "list", "(", "np", ".", "arange", "(", "tasknum", ")", ")", "\n", "print", "(", "'Task order ='", ",", "ids", ")", "\n", "for", "i", "in", "range", "(", "tasknum", ")", ":", "\n", "            ", "data", "[", "i", "]", "=", "dict", ".", "fromkeys", "(", "[", "'name'", ",", "'ncla'", ",", "'train'", ",", "'test'", ",", "'valid'", "]", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "ncla_dict", "[", "ids", "[", "i", "]", "]", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'omniglot-{:d}'", ".", "format", "(", "i", ")", "\n", "\n", "# Load", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", ",", "'valid'", "]", ":", "\n", "                ", "data", "[", "i", "]", "[", "s", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "\n", "'data'", "+", "str", "(", "ids", "[", "i", "]", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "\n", "'data'", "+", "str", "(", "ids", "[", "i", "]", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "\n", "\n", "# Others", "\n", "", "", "", "n", "=", "0", "\n", "data_num", "=", "0", "\n", "for", "t", "in", "data", ".", "keys", "(", ")", ":", "\n", "        ", "taskcla", ".", "append", "(", "(", "t", ",", "data", "[", "t", "]", "[", "'ncla'", "]", ")", ")", "\n", "n", "+=", "data", "[", "t", "]", "[", "'ncla'", "]", "\n", "print", "(", "'Task %d: %d classes'", "%", "(", "t", "+", "1", ",", "data", "[", "t", "]", "[", "'ncla'", "]", ")", ")", "\n", "#         print(data[t]['train']['x'].shape[0])", "\n", "data_num", "+=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "shape", "[", "0", "]", "\n", "", "print", "(", "data_num", ")", "\n", "\n", "data", "[", "'ncla'", "]", "=", "n", "\n", "print", "(", "n", ")", "\n", "return", "data", ",", "taskcla", ",", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar100.get": [[8, 86], ["dict.fromkeys", "list", "print", "range", "range", "range", "os.path.isdir", "os.makedirs", "torchvision.datasets.CIFAR100", "torchvision.datasets.CIFAR100", "range", "range", "dict.fromkeys", "len", "numpy.arange", "numpy.array", "int", "torch.LongTensor", "torch.LongTensor", "[].clone", "[].clone", "[].clone", "[].clone", "taskcla.append", "torch.utils.data.DataLoader", "sklearn.utils.shuffle", "torch.load", "torch.load", "numpy.unique", "str", "[].size", "sklearn.utils.shuffle", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "[].append", "[].append", "torch.stack().view", "torch.LongTensor().view", "torch.save", "torch.save", "numpy.arange", "os.path.join", "os.path.join", "[].numpy", "len", "os.path.join", "os.path.join", "os.path.expanduser", "os.path.expanduser", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "target.numpy", "torch.stack", "torch.LongTensor", "os.path.expanduser", "os.path.expanduser", "target.numpy", "numpy.array", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save"], ["def", "get", "(", "seed", "=", "0", ",", "pc_valid", "=", "0.10", ",", "tasknum", "=", "20", ")", ":", "\n", "    ", "data", "=", "{", "}", "\n", "taskcla", "=", "[", "]", "\n", "size", "=", "[", "3", ",", "32", ",", "32", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "'../dat/binary_split_cifar100/'", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "'../dat/binary_split_cifar100'", ")", "\n", "\n", "mean", "=", "[", "x", "/", "255", "for", "x", "in", "[", "125.3", ",", "123.0", ",", "113.9", "]", "]", "\n", "std", "=", "[", "x", "/", "255", "for", "x", "in", "[", "63.0", ",", "62.1", ",", "66.7", "]", "]", "\n", "\n", "# CIFAR100", "\n", "dat", "=", "{", "}", "\n", "\n", "dat", "[", "'train'", "]", "=", "datasets", ".", "CIFAR100", "(", "'../dat/'", ",", "train", "=", "True", ",", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "transforms", ".", "Normalize", "(", "mean", ",", "std", ")", "]", ")", ")", "\n", "dat", "[", "'test'", "]", "=", "datasets", ".", "CIFAR100", "(", "'../dat/'", ",", "train", "=", "False", ",", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "transforms", ".", "Normalize", "(", "mean", ",", "std", ")", "]", ")", ")", "\n", "for", "n", "in", "range", "(", "10", ")", ":", "\n", "            ", "data", "[", "n", "]", "=", "{", "}", "\n", "data", "[", "n", "]", "[", "'name'", "]", "=", "'cifar100'", "\n", "data", "[", "n", "]", "[", "'ncla'", "]", "=", "10", "\n", "data", "[", "n", "]", "[", "'train'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "n", "]", "[", "'test'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "            ", "loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dat", "[", "s", "]", ",", "batch_size", "=", "1", ",", "shuffle", "=", "False", ")", "\n", "for", "image", ",", "target", "in", "loader", ":", "\n", "                ", "task_idx", "=", "target", ".", "numpy", "(", ")", "[", "0", "]", "//", "10", "\n", "data", "[", "task_idx", "]", "[", "s", "]", "[", "'x'", "]", ".", "append", "(", "image", ")", "\n", "data", "[", "task_idx", "]", "[", "s", "]", "[", "'y'", "]", ".", "append", "(", "target", ".", "numpy", "(", ")", "[", "0", "]", "%", "10", ")", "\n", "\n", "# \"Unify\" and save", "\n", "", "", "for", "t", "in", "range", "(", "10", ")", ":", "\n", "            ", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "                ", "data", "[", "t", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "stack", "(", "data", "[", "t", "]", "[", "s", "]", "[", "'x'", "]", ")", ".", "view", "(", "-", "1", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "size", "[", "2", "]", ")", "\n", "data", "[", "t", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "LongTensor", "(", "np", ".", "array", "(", "data", "[", "t", "]", "[", "s", "]", "[", "'y'", "]", ",", "dtype", "=", "int", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "torch", ".", "save", "(", "data", "[", "t", "]", "[", "s", "]", "[", "'x'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_cifar100'", ")", ",", "\n", "'data'", "+", "str", "(", "t", "+", "1", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "torch", ".", "save", "(", "data", "[", "t", "]", "[", "s", "]", "[", "'y'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_cifar100'", ")", ",", "\n", "'data'", "+", "str", "(", "t", "+", "1", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "\n", "# Load binary files", "\n", "", "", "", "data", "=", "{", "}", "\n", "data", "[", "0", "]", "=", "dict", ".", "fromkeys", "(", "[", "'name'", ",", "'ncla'", ",", "'train'", ",", "'test'", "]", ")", "\n", "ids", "=", "list", "(", "shuffle", "(", "np", ".", "arange", "(", "10", ")", ",", "random_state", "=", "seed", ")", "+", "1", ")", "\n", "print", "(", "'Task order ='", ",", "ids", ")", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "        ", "data", "[", "i", "]", "=", "dict", ".", "fromkeys", "(", "[", "'name'", ",", "'ncla'", ",", "'train'", ",", "'test'", "]", ")", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "            ", "data", "[", "i", "]", "[", "s", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_cifar100'", ")", ",", "\n", "'data'", "+", "str", "(", "ids", "[", "i", "]", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_cifar100'", ")", ",", "\n", "'data'", "+", "str", "(", "ids", "[", "i", "]", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "len", "(", "np", ".", "unique", "(", "data", "[", "i", "]", "[", "'train'", "]", "[", "'y'", "]", ".", "numpy", "(", ")", ")", ")", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'cifar100-'", "+", "str", "(", "ids", "[", "i", "-", "1", "]", ")", "\n", "\n", "# Validation", "\n", "", "for", "t", "in", "range", "(", "10", ")", ":", "\n", "        ", "r", "=", "np", ".", "arange", "(", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "np", ".", "array", "(", "shuffle", "(", "r", ",", "random_state", "=", "seed", ")", ",", "dtype", "=", "int", ")", "\n", "nvalid", "=", "int", "(", "pc_valid", "*", "len", "(", "r", ")", ")", "\n", "ivalid", "=", "torch", ".", "LongTensor", "(", "r", "[", ":", "nvalid", "]", ")", "\n", "itrain", "=", "torch", ".", "LongTensor", "(", "r", "[", "nvalid", ":", "]", ")", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "=", "{", "}", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'x'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", "[", "ivalid", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'y'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", "[", "ivalid", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", "[", "itrain", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", "[", "itrain", "]", ".", "clone", "(", ")", "\n", "\n", "# Others", "\n", "", "n", "=", "0", "\n", "for", "t", "in", "range", "(", "10", ")", ":", "\n", "        ", "taskcla", ".", "append", "(", "(", "t", ",", "data", "[", "t", "]", "[", "'ncla'", "]", ")", ")", "\n", "n", "+=", "data", "[", "t", "]", "[", "'ncla'", "]", "\n", "", "data", "[", "'ncla'", "]", "=", "n", "\n", "\n", "return", "data", ",", "taskcla", ",", "size", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.omniglot.get": [[11, 86], ["data.keys", "print", "data.keys", "os.path.isdir", "os.makedirs", "os.path.join", "torch.load", "range", "torch.save", "torch.load", "range", "[].clone", "[].clone", "print", "taskcla.append", "os.getcwd", "os.path.join", "os.path.join", "os.path.join", "dict.fromkeys", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().view", "torch.save", "torch.save", "os.path.expanduser", "os.path.expanduser", "torch.load", "torch.load", "len", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "torch.LongTensor", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "numpy.array", "torch.max", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load"], ["def", "get", "(", "seed", "=", "0", ",", "fixed_order", "=", "False", ",", "pc_valid", "=", "0", ",", "tasknum", "=", "25", ")", ":", "\n", "    ", "data", "=", "{", "}", "\n", "taskcla", "=", "[", "]", "\n", "size", "=", "[", "1", ",", "28", ",", "28", "]", "\n", "tasknum", "=", "25", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "'../dat/binary_omniglot/'", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "'../dat/binary_omniglot'", ")", "\n", "\n", "filename", "=", "'Permuted_Omniglot_task50.pt'", "\n", "filepath", "=", "os", ".", "path", ".", "join", "(", "os", ".", "getcwd", "(", ")", ",", "'dataloaders/'", ")", "\n", "f", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "filepath", ",", "filename", ")", ")", "\n", "ncla_dict", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "tasknum", ")", ":", "\n", "            ", "data", "[", "i", "]", "=", "{", "}", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'omniglot-{:d}'", ".", "format", "(", "i", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "(", "torch", ".", "max", "(", "f", "[", "'Y'", "]", "[", "'train'", "]", "[", "i", "]", ")", "+", "1", ")", ".", "int", "(", ")", ".", "item", "(", ")", "\n", "ncla_dict", "[", "i", "]", "=", "data", "[", "i", "]", "[", "'ncla'", "]", "\n", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "\n", "#                 loader = torch.utils.data.DataLoader(dat[s], batch_size=1, shuffle=False)", "\n", "                ", "data", "[", "i", "]", "[", "s", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "\n", "image", "=", "f", "[", "'X'", "]", "[", "'train'", "]", "[", "i", "]", "\n", "target", "=", "f", "[", "'Y'", "]", "[", "'train'", "]", "[", "i", "]", "\n", "\n", "index_arr", "=", "np", ".", "arange", "(", "len", "(", "image", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "index_arr", ")", "\n", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "image", "[", "index_arr", "]", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "target", "[", "index_arr", "]", "\n", "\n", "# \"Unify\" and save", "\n", "", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "#                 data[i][s]['x'] = torch.stack(data[i][s]['x']).view(-1, size[0], size[1], size[2])", "\n", "                ", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "LongTensor", "(", "np", ".", "array", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", ",", "dtype", "=", "int", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "torch", ".", "save", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "torch", ".", "save", "(", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "", "", "torch", ".", "save", "(", "ncla_dict", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'ncla_dict.pt'", ")", ")", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "data_num", "=", "0", "\n", "\n", "ncla_dict", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'ncla_dict.pt'", ")", ")", "\n", "# Load binary files", "\n", "for", "i", "in", "range", "(", "tasknum", ")", ":", "\n", "            ", "data", "[", "i", "]", "=", "dict", ".", "fromkeys", "(", "[", "'name'", ",", "'ncla'", ",", "'train'", ",", "'test'", "]", ")", "\n", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "ncla_dict", "[", "i", "]", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'omniglot-{:d}'", ".", "format", "(", "i", ")", "\n", "\n", "# Load", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "                ", "data", "[", "i", "]", "[", "s", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_omniglot'", ")", ",", "'data'", "+", "str", "(", "i", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "\n", "# Validation", "\n", "", "", "", "for", "t", "in", "data", ".", "keys", "(", ")", ":", "\n", "        ", "data", "[", "t", "]", "[", "'valid'", "]", "=", "{", "}", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'x'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'y'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", ".", "clone", "(", ")", "\n", "print", "(", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "shape", "[", "0", "]", ")", "\n", "data_num", "+=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "shape", "[", "0", "]", "\n", "", "print", "(", "data_num", ")", "\n", "\n", "# Others", "\n", "n", "=", "0", "\n", "for", "t", "in", "data", ".", "keys", "(", ")", ":", "\n", "        ", "taskcla", ".", "append", "(", "(", "t", "//", "5", ",", "data", "[", "t", "]", "[", "'ncla'", "]", ")", ")", "\n", "n", "+=", "data", "[", "t", "]", "[", "'ncla'", "]", "\n", "", "data", "[", "'ncla'", "]", "=", "n", "\n", "\n", "return", "data", ",", "taskcla", ",", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.dataloaders.split_cifar10_100.get": [[8, 118], ["dict.fromkeys", "len", "list", "print", "range", "range", "range", "os.path.isdir", "os.makedirs", "os.makedirs", "torchvision.datasets.CIFAR10", "torchvision.datasets.CIFAR10", "torchvision.datasets.CIFAR100", "torchvision.datasets.CIFAR100", "range", "range", "torch.load", "torch.load", "numpy.unique", "dict.fromkeys", "len", "numpy.arange", "numpy.array", "int", "torch.LongTensor", "torch.LongTensor", "[].clone", "[].clone", "[].clone", "[].clone", "taskcla.append", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.stack().view", "torch.LongTensor().view", "torch.save", "torch.save", "os.path.join", "os.path.join", "[].numpy", "sklearn.utils.shuffle", "torch.load", "torch.load", "numpy.unique", "str", "[].size", "sklearn.utils.shuffle", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "[].append", "[].append", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "[].append", "[].append", "os.path.join", "os.path.join", "torch.stack().view", "torch.LongTensor().view", "torch.save", "torch.save", "os.path.expanduser", "os.path.expanduser", "numpy.arange", "os.path.join", "os.path.join", "[].numpy", "len", "torch.stack", "torch.LongTensor", "os.path.expanduser", "os.path.expanduser", "os.path.join", "os.path.join", "os.path.expanduser", "os.path.expanduser", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "target.numpy", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "numpy.array", "torch.stack", "torch.LongTensor", "os.path.expanduser", "os.path.expanduser", "target.numpy", "target.numpy", "numpy.array", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.load", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save"], ["def", "get", "(", "seed", "=", "0", ",", "pc_valid", "=", "0.10", ",", "tasknum", "=", "10", ")", ":", "\n", "    ", "data", "=", "{", "}", "\n", "taskcla", "=", "[", "]", "\n", "size", "=", "[", "3", ",", "32", ",", "32", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "'../dat/binary_split_cifar100/'", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "'../dat/binary_split_cifar100'", ")", "\n", "os", ".", "makedirs", "(", "'../dat/binary_cifar10'", ")", "\n", "\n", "mean", "=", "[", "x", "/", "255", "for", "x", "in", "[", "125.3", ",", "123.0", ",", "113.9", "]", "]", "\n", "std", "=", "[", "x", "/", "255", "for", "x", "in", "[", "63.0", ",", "62.1", ",", "66.7", "]", "]", "\n", "\n", "# CIFAR10", "\n", "dat", "=", "{", "}", "\n", "dat", "[", "'train'", "]", "=", "datasets", ".", "CIFAR10", "(", "'../dat/'", ",", "train", "=", "True", ",", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "transforms", ".", "Normalize", "(", "mean", ",", "std", ")", "]", ")", ")", "\n", "dat", "[", "'test'", "]", "=", "datasets", ".", "CIFAR10", "(", "'../dat/'", ",", "train", "=", "False", ",", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "transforms", ".", "Normalize", "(", "mean", ",", "std", ")", "]", ")", ")", "\n", "data", "[", "0", "]", "=", "{", "}", "\n", "data", "[", "0", "]", "[", "'name'", "]", "=", "'cifar10'", "\n", "data", "[", "0", "]", "[", "'ncla'", "]", "=", "10", "\n", "data", "[", "0", "]", "[", "'train'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "0", "]", "[", "'test'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "            ", "loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dat", "[", "s", "]", ",", "batch_size", "=", "1", ",", "shuffle", "=", "False", ")", "\n", "for", "image", ",", "target", "in", "loader", ":", "\n", "                ", "data", "[", "0", "]", "[", "s", "]", "[", "'x'", "]", ".", "append", "(", "image", ")", "\n", "data", "[", "0", "]", "[", "s", "]", "[", "'y'", "]", ".", "append", "(", "target", ".", "numpy", "(", ")", "[", "0", "]", ")", "\n", "\n", "\n", "# CIFAR100", "\n", "", "", "dat", "=", "{", "}", "\n", "\n", "dat", "[", "'train'", "]", "=", "datasets", ".", "CIFAR100", "(", "'../dat/'", ",", "train", "=", "True", ",", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "transforms", ".", "Normalize", "(", "mean", ",", "std", ")", "]", ")", ")", "\n", "dat", "[", "'test'", "]", "=", "datasets", ".", "CIFAR100", "(", "'../dat/'", ",", "train", "=", "False", ",", "download", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "transforms", ".", "Normalize", "(", "mean", ",", "std", ")", "]", ")", ")", "\n", "for", "n", "in", "range", "(", "1", ",", "11", ")", ":", "\n", "            ", "data", "[", "n", "]", "=", "{", "}", "\n", "data", "[", "n", "]", "[", "'name'", "]", "=", "'cifar100'", "\n", "data", "[", "n", "]", "[", "'ncla'", "]", "=", "10", "\n", "data", "[", "n", "]", "[", "'train'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "n", "]", "[", "'test'", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "            ", "loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dat", "[", "s", "]", ",", "batch_size", "=", "1", ",", "shuffle", "=", "False", ")", "\n", "for", "image", ",", "target", "in", "loader", ":", "\n", "                ", "task_idx", "=", "target", ".", "numpy", "(", ")", "[", "0", "]", "//", "10", "+", "1", "\n", "data", "[", "task_idx", "]", "[", "s", "]", "[", "'x'", "]", ".", "append", "(", "image", ")", "\n", "data", "[", "task_idx", "]", "[", "s", "]", "[", "'y'", "]", ".", "append", "(", "target", ".", "numpy", "(", ")", "[", "0", "]", "%", "10", ")", "\n", "\n", "# \"Unify\" and save", "\n", "", "", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "            ", "data", "[", "0", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "stack", "(", "data", "[", "0", "]", "[", "s", "]", "[", "'x'", "]", ")", ".", "view", "(", "-", "1", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "size", "[", "2", "]", ")", "\n", "data", "[", "0", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "LongTensor", "(", "np", ".", "array", "(", "data", "[", "0", "]", "[", "s", "]", "[", "'y'", "]", ",", "dtype", "=", "int", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "torch", ".", "save", "(", "data", "[", "0", "]", "[", "s", "]", "[", "'x'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_cifar10'", ")", ",", "'data'", "+", "s", "+", "'x.bin'", ")", ")", "\n", "torch", ".", "save", "(", "data", "[", "0", "]", "[", "s", "]", "[", "'y'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_cifar10'", ")", ",", "'data'", "+", "s", "+", "'y.bin'", ")", ")", "\n", "", "for", "t", "in", "range", "(", "1", ",", "11", ")", ":", "\n", "            ", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "                ", "data", "[", "t", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "stack", "(", "data", "[", "t", "]", "[", "s", "]", "[", "'x'", "]", ")", ".", "view", "(", "-", "1", ",", "size", "[", "0", "]", ",", "size", "[", "1", "]", ",", "size", "[", "2", "]", ")", "\n", "data", "[", "t", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "LongTensor", "(", "np", ".", "array", "(", "data", "[", "t", "]", "[", "s", "]", "[", "'y'", "]", ",", "dtype", "=", "int", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "torch", ".", "save", "(", "data", "[", "t", "]", "[", "s", "]", "[", "'x'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_cifar100'", ")", ",", "\n", "'data'", "+", "str", "(", "t", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "torch", ".", "save", "(", "data", "[", "t", "]", "[", "s", "]", "[", "'y'", "]", ",", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_cifar100'", ")", ",", "\n", "'data'", "+", "str", "(", "t", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "\n", "# Load binary files", "\n", "", "", "", "data", "=", "{", "}", "\n", "data", "[", "0", "]", "=", "dict", ".", "fromkeys", "(", "[", "'name'", ",", "'ncla'", ",", "'train'", ",", "'test'", "]", ")", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "        ", "data", "[", "0", "]", "[", "s", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "0", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_cifar10'", ")", ",", "'data'", "+", "s", "+", "'x.bin'", ")", ")", "\n", "data", "[", "0", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_cifar10'", ")", ",", "'data'", "+", "s", "+", "'y.bin'", ")", ")", "\n", "", "data", "[", "0", "]", "[", "'ncla'", "]", "=", "len", "(", "np", ".", "unique", "(", "data", "[", "0", "]", "[", "'train'", "]", "[", "'y'", "]", ".", "numpy", "(", ")", ")", ")", "\n", "data", "[", "0", "]", "[", "'name'", "]", "=", "'cifar10'", "\n", "\n", "ids", "=", "list", "(", "shuffle", "(", "np", ".", "arange", "(", "10", ")", ",", "random_state", "=", "seed", ")", "+", "1", ")", "\n", "#     ids=list(range(1,11))", "\n", "print", "(", "'Task order ='", ",", "ids", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "11", ")", ":", "\n", "        ", "data", "[", "i", "]", "=", "dict", ".", "fromkeys", "(", "[", "'name'", ",", "'ncla'", ",", "'train'", ",", "'test'", "]", ")", "\n", "for", "s", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "            ", "data", "[", "i", "]", "[", "s", "]", "=", "{", "'x'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'x'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_cifar100'", ")", ",", "\n", "'data'", "+", "str", "(", "ids", "[", "i", "-", "1", "]", ")", "+", "s", "+", "'x.bin'", ")", ")", "\n", "data", "[", "i", "]", "[", "s", "]", "[", "'y'", "]", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'../dat/binary_split_cifar100'", ")", ",", "\n", "'data'", "+", "str", "(", "ids", "[", "i", "-", "1", "]", ")", "+", "s", "+", "'y.bin'", ")", ")", "\n", "", "data", "[", "i", "]", "[", "'ncla'", "]", "=", "len", "(", "np", ".", "unique", "(", "data", "[", "i", "]", "[", "'train'", "]", "[", "'y'", "]", ".", "numpy", "(", ")", ")", ")", "\n", "data", "[", "i", "]", "[", "'name'", "]", "=", "'cifar100-'", "+", "str", "(", "ids", "[", "i", "-", "1", "]", ")", "\n", "\n", "# Validation", "\n", "", "for", "t", "in", "range", "(", "11", ")", ":", "\n", "        ", "r", "=", "np", ".", "arange", "(", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "np", ".", "array", "(", "shuffle", "(", "r", ",", "random_state", "=", "seed", ")", ",", "dtype", "=", "int", ")", "\n", "nvalid", "=", "int", "(", "pc_valid", "*", "len", "(", "r", ")", ")", "\n", "ivalid", "=", "torch", ".", "LongTensor", "(", "r", "[", ":", "nvalid", "]", ")", "\n", "itrain", "=", "torch", ".", "LongTensor", "(", "r", "[", "nvalid", ":", "]", ")", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "=", "{", "}", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'x'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", "[", "ivalid", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'valid'", "]", "[", "'y'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", "[", "ivalid", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'x'", "]", "[", "itrain", "]", ".", "clone", "(", ")", "\n", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", "=", "data", "[", "t", "]", "[", "'train'", "]", "[", "'y'", "]", "[", "itrain", "]", ".", "clone", "(", ")", "\n", "\n", "# Others", "\n", "", "n", "=", "0", "\n", "for", "t", "in", "range", "(", "11", ")", ":", "\n", "        ", "taskcla", ".", "append", "(", "(", "t", ",", "data", "[", "t", "]", "[", "'ncla'", "]", ")", ")", "\n", "n", "+=", "data", "[", "t", "]", "[", "'ncla'", "]", "\n", "", "data", "[", "'ncla'", "]", "=", "n", "\n", "\n", "return", "data", ",", "taskcla", ",", "size", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ewc.PPO_EWC.__init__": [[8, 43], ["print", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "actor_critic.parameters"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "actor_critic", ",", "\n", "clip_param", ",", "\n", "ppo_epoch", ",", "\n", "num_mini_batch", ",", "\n", "value_loss_coef", ",", "\n", "entropy_coef", ",", "\n", "lr", "=", "None", ",", "\n", "eps", "=", "None", ",", "\n", "max_grad_norm", "=", "None", ",", "\n", "use_clipped_value_loss", "=", "True", ",", "\n", "ewc_epoch", "=", "1", ",", "\n", "ewc_lambda", "=", "5000", ",", "\n", "gamma", "=", "0.99", ",", "\n", "online", "=", "False", ")", ":", "\n", "\n", "        ", "self", ".", "actor_critic", "=", "actor_critic", "\n", "\n", "self", ".", "clip_param", "=", "clip_param", "\n", "self", ".", "ppo_epoch", "=", "ppo_epoch", "\n", "self", ".", "num_mini_batch", "=", "num_mini_batch", "\n", "\n", "self", ".", "value_loss_coef", "=", "value_loss_coef", "\n", "self", ".", "entropy_coef", "=", "entropy_coef", "\n", "\n", "self", ".", "max_grad_norm", "=", "max_grad_norm", "\n", "self", ".", "use_clipped_value_loss", "=", "use_clipped_value_loss", "\n", "\n", "self", ".", "ewc_epoch", "=", "ewc_epoch", "\n", "self", ".", "ewc_lambda", "=", "ewc_lambda", "\n", "self", ".", "gamma", "=", "gamma", "\n", "\n", "print", "(", "'ewc_lambda : '", ",", "self", ".", "ewc_lambda", ")", "\n", "\n", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "actor_critic", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "eps", "=", "eps", ")", "\n", "self", ".", "EWC_task_count", "=", "0", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ewc.PPO_EWC.update": [[44, 109], ["range", "advantages.mean", "advantages.std", "rollouts.recurrent_generator", "rollouts.feed_forward_generator", "ppo_ewc.PPO_EWC.actor_critic.evaluate_actions", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "ppo_ewc.PPO_EWC.optimizer.zero_grad", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "ppo_ewc.PPO_EWC.optimizer.step", "value_loss.item", "action_loss.item", "dist_entropy.item", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "ppo_ewc.PPO_EWC.ewc_loss", "ppo_ewc.PPO_EWC.actor_critic.parameters", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.recurrent_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.feed_forward_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.evaluate_actions", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ewc.PPO_EWC.ewc_loss"], ["self", ".", "online", "=", "online", "\n", "\n", "", "def", "update", "(", "self", ",", "rollouts", ",", "task_num", ")", ":", "\n", "        ", "advantages", "=", "rollouts", ".", "returns", "[", ":", "-", "1", "]", "-", "rollouts", ".", "value_preds", "[", ":", "-", "1", "]", "\n", "advantages", "=", "(", "advantages", "-", "advantages", ".", "mean", "(", ")", ")", "/", "(", "\n", "advantages", ".", "std", "(", ")", "+", "1e-5", ")", "\n", "\n", "value_loss_epoch", "=", "0", "\n", "action_loss_epoch", "=", "0", "\n", "dist_entropy_epoch", "=", "0", "\n", "\n", "for", "e", "in", "range", "(", "self", ".", "ppo_epoch", ")", ":", "\n", "            ", "if", "self", ".", "actor_critic", ".", "is_recurrent", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "recurrent_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "", "else", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "feed_forward_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "\n", "", "for", "sample", "in", "data_generator", ":", "\n", "                ", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "actions_batch", ",", "value_preds_batch", ",", "return_batch", ",", "masks_batch", ",", "old_action_log_probs_batch", ",", "adv_targ", "=", "sample", "\n", "\n", "# Reshape to do in a single forward pass for all steps", "\n", "values", ",", "action_log_probs", ",", "dist_entropy", ",", "_", "=", "self", ".", "actor_critic", ".", "evaluate_actions", "(", "\n", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "masks_batch", ",", "\n", "actions_batch", ",", "task_num", ")", "\n", "\n", "ratio", "=", "torch", ".", "exp", "(", "action_log_probs", "-", "\n", "old_action_log_probs_batch", ")", "\n", "surr1", "=", "ratio", "*", "adv_targ", "\n", "surr2", "=", "torch", ".", "clamp", "(", "ratio", ",", "1.0", "-", "self", ".", "clip_param", ",", "\n", "1.0", "+", "self", ".", "clip_param", ")", "*", "adv_targ", "\n", "action_loss", "=", "-", "torch", ".", "min", "(", "surr1", ",", "surr2", ")", ".", "mean", "(", ")", "\n", "\n", "if", "self", ".", "use_clipped_value_loss", ":", "\n", "                    ", "value_pred_clipped", "=", "value_preds_batch", "+", "(", "values", "-", "value_preds_batch", ")", ".", "clamp", "(", "-", "self", ".", "clip_param", ",", "self", ".", "clip_param", ")", "\n", "value_losses", "=", "(", "values", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_losses_clipped", "=", "(", "\n", "value_pred_clipped", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_loss", "=", "0.5", "*", "torch", ".", "max", "(", "value_losses", ",", "\n", "value_losses_clipped", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                    ", "value_loss", "=", "0.5", "*", "(", "return_batch", "-", "values", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "reg_loss", "=", "self", ".", "ewc_lambda", "*", "self", ".", "ewc_loss", "(", ")", "\n", "(", "value_loss", "*", "self", ".", "value_loss_coef", "+", "action_loss", "-", "\n", "dist_entropy", "*", "self", ".", "entropy_coef", "+", "reg_loss", ")", ".", "backward", "(", ")", "\n", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "actor_critic", ".", "parameters", "(", ")", ",", "\n", "self", ".", "max_grad_norm", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "value_loss_epoch", "+=", "value_loss", ".", "item", "(", ")", "\n", "action_loss_epoch", "+=", "action_loss", ".", "item", "(", ")", "\n", "dist_entropy_epoch", "+=", "dist_entropy", ".", "item", "(", ")", "\n", "\n", "", "", "num_updates", "=", "self", ".", "ppo_epoch", "*", "self", ".", "num_mini_batch", "\n", "\n", "value_loss_epoch", "/=", "num_updates", "\n", "action_loss_epoch", "/=", "num_updates", "\n", "dist_entropy_epoch", "/=", "num_updates", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ewc.PPO_EWC.estimate_fisher": [[110, 171], ["range", "advantages.mean", "advantages.std", "rollouts.recurrent_generator", "rollouts.feed_forward_generator", "ppo_ewc.PPO_EWC.actor_critic.evaluate_actions", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "ppo_ewc.PPO_EWC.optimizer.zero_grad", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "ppo_ewc.PPO_EWC.actor_critic.named_parameters", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "ppo_ewc.PPO_EWC.actor_critic.parameters", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "n.replace.replace.replace", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "p.grad.detach"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.recurrent_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.feed_forward_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.evaluate_actions"], ["return", "value_loss_epoch", ",", "action_loss_epoch", ",", "dist_entropy_epoch", "\n", "\n", "", "def", "update_fisher", "(", "self", ",", "rollouts", ",", "task_num", ")", ":", "\n", "        ", "print", "(", "\"updating fisher matrix for task %d\"", "%", "task_num", ")", "\n", "fisher_dict", "=", "{", "}", "\n", "for", "n", ",", "p", "in", "self", ".", "actor_critic", ".", "named_parameters", "(", ")", ":", "\n", "            ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "fisher_dict", ".", "update", "(", "{", "n", ":", "torch", ".", "zeros_like", "(", "p", ")", "}", ")", "\n", "", "new_fisher", "=", "self", ".", "estimate_fisher", "(", "rollouts", "=", "rollouts", ",", "fisher_dict", "=", "fisher_dict", ",", "task_num", "=", "task_num", ")", "\n", "self", ".", "store_fisher_n_params", "(", "new_fisher", ")", "\n", "\n", "", "def", "estimate_fisher", "(", "self", ",", "rollouts", ",", "fisher_dict", ",", "task_num", ")", ":", "\n", "\n", "        ", "est_fisher_info", "=", "fisher_dict", "\n", "\n", "advantages", "=", "rollouts", ".", "returns", "[", ":", "-", "1", "]", "-", "rollouts", ".", "value_preds", "[", ":", "-", "1", "]", "\n", "advantages", "=", "(", "advantages", "-", "advantages", ".", "mean", "(", ")", ")", "/", "(", "\n", "advantages", ".", "std", "(", ")", "+", "1e-5", ")", "\n", "\n", "value_loss_epoch", "=", "0", "\n", "action_loss_epoch", "=", "0", "\n", "dist_entropy_epoch", "=", "0", "\n", "\n", "for", "e", "in", "range", "(", "self", ".", "ewc_epoch", ")", ":", "\n", "            ", "if", "self", ".", "actor_critic", ".", "is_recurrent", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "recurrent_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "", "else", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "feed_forward_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "\n", "", "for", "sample", "in", "data_generator", ":", "\n", "                ", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "actions_batch", ",", "value_preds_batch", ",", "return_batch", ",", "masks_batch", ",", "old_action_log_probs_batch", ",", "adv_targ", "=", "sample", "\n", "\n", "# Reshape to do in a single forward pass for all steps", "\n", "values", ",", "action_log_probs", ",", "dist_entropy", ",", "_", "=", "self", ".", "actor_critic", ".", "evaluate_actions", "(", "\n", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "masks_batch", ",", "\n", "actions_batch", ",", "task_num", ")", "\n", "\n", "ratio", "=", "torch", ".", "exp", "(", "action_log_probs", "-", "\n", "old_action_log_probs_batch", ")", "\n", "surr1", "=", "ratio", "*", "adv_targ", "\n", "surr2", "=", "torch", ".", "clamp", "(", "ratio", ",", "1.0", "-", "self", ".", "clip_param", ",", "\n", "1.0", "+", "self", ".", "clip_param", ")", "*", "adv_targ", "\n", "action_loss", "=", "-", "torch", ".", "min", "(", "surr1", ",", "surr2", ")", ".", "mean", "(", ")", "\n", "\n", "if", "self", ".", "use_clipped_value_loss", ":", "\n", "                    ", "value_pred_clipped", "=", "value_preds_batch", "+", "(", "values", "-", "value_preds_batch", ")", ".", "clamp", "(", "-", "self", ".", "clip_param", ",", "self", ".", "clip_param", ")", "\n", "value_losses", "=", "(", "values", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_losses_clipped", "=", "(", "\n", "value_pred_clipped", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_loss", "=", "0.5", "*", "torch", ".", "max", "(", "value_losses", ",", "\n", "value_losses_clipped", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                    ", "value_loss", "=", "0.5", "*", "(", "return_batch", "-", "values", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "(", "value_loss", "*", "self", ".", "value_loss_coef", "+", "action_loss", "-", "\n", "dist_entropy", "*", "self", ".", "entropy_coef", ")", ".", "backward", "(", ")", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ewc.PPO_EWC.store_fisher_n_params": [[172, 189], ["ppo_ewc.PPO_EWC.actor_critic.named_parameters", "n.replace.replace.replace", "ppo_ewc.PPO_EWC.actor_critic.register_buffer", "ppo_ewc.PPO_EWC.actor_critic.register_buffer", "p.detach().clone", "getattr", "p.detach"], "methods", ["None"], ["nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "actor_critic", ".", "parameters", "(", ")", ",", "\n", "self", ".", "max_grad_norm", ")", "\n", "\n", "for", "n", ",", "p", "in", "self", ".", "actor_critic", ".", "named_parameters", "(", ")", ":", "\n", "                    ", "if", "p", ".", "requires_grad", ":", "\n", "                        ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "                            ", "est_fisher_info", "[", "n", "]", "+=", "p", ".", "grad", ".", "detach", "(", ")", "**", "2", "\n", "\n", "", "", "", "", "", "return", "est_fisher_info", "\n", "\n", "", "def", "store_fisher_n_params", "(", "self", ",", "fisher", ")", ":", "\n", "# Store new values in the network", "\n", "        ", "for", "n", ",", "p", "in", "self", ".", "actor_critic", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "requires_grad", ":", "\n", "                ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "# -mode (=MAP parameter estimate)", "\n", "self", ".", "actor_critic", ".", "register_buffer", "(", "'{}_EWC_prev_task{}'", ".", "format", "(", "n", ",", "\"\"", "if", "self", ".", "online", "else", "self", ".", "EWC_task_count", "+", "1", ")", ",", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ewc.PPO_EWC.ewc_loss": [[190, 211], ["range", "ppo_ewc.PPO_EWC.actor_critic.named_parameters", "sum", "n.replace.replace.replace", "getattr", "getattr", "losses.append"], "methods", ["None"], ["p", ".", "detach", "(", ")", ".", "clone", "(", ")", ")", "\n", "# -precision (approximated by diagonal Fisher Information matrix)", "\n", "if", "self", ".", "online", "and", "self", ".", "EWC_task_count", "==", "1", ":", "\n", "                    ", "existing_values", "=", "getattr", "(", "self", ".", "actor_critic", ",", "'{}_EWC_estimated_fisher'", ".", "format", "(", "n", ")", ")", "\n", "fisher", "[", "n", "]", "+=", "self", ".", "gamma", "*", "existing_values", "\n", "", "self", ".", "actor_critic", ".", "register_buffer", "(", "'{}_EWC_estimated_fisher{}'", ".", "format", "(", "n", ",", "\"\"", "if", "self", ".", "online", "else", "self", ".", "EWC_task_count", "+", "1", ")", ",", "\n", "fisher", "[", "n", "]", ")", "\n", "\n", "# If \"offline EWC\", increase task-count (for \"online EWC\", set it to 1 to indicate EWC-loss can be calculated)", "\n", "", "", "self", ".", "EWC_task_count", "=", "1", "if", "self", ".", "online", "else", "self", ".", "EWC_task_count", "+", "1", "\n", "\n", "", "def", "ewc_loss", "(", "self", ")", ":", "\n", "        ", "'''Calculate EWC-loss.'''", "\n", "if", "self", ".", "EWC_task_count", ">", "0", ":", "\n", "            ", "losses", "=", "[", "]", "\n", "# If \"offline EWC\", loop over all previous tasks (if \"online EWC\", [EWC_task_count]=1 so only 1 iteration)", "\n", "for", "task", "in", "range", "(", "1", ",", "self", ".", "EWC_task_count", "+", "1", ")", ":", "\n", "                ", "for", "n", ",", "p", "in", "self", ".", "actor_critic", ".", "named_parameters", "(", ")", ":", "\n", "                    ", "if", "p", ".", "requires_grad", ":", "\n", "# Retrieve stored mode (MAP estimate) and precision (Fisher Information matrix)", "\n", "                        ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "mean", "=", "getattr", "(", "self", ".", "actor_critic", ",", "'{}_EWC_prev_task{}'", ".", "format", "(", "n", ",", "\"\"", "if", "self", ".", "online", "else", "task", ")", ")", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr.__init__": [[24, 60], ["super().__init__", "utils.logger", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "si.Appr._get_optimizer", "si.Appr.model.named_parameters", "n.replace.replace.replace", "si.Appr.model.register_buffer", "p.data.clone"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["def", "__init__", "(", "self", ",", "model", ",", "nepochs", "=", "100", ",", "sbatch", "=", "256", ",", "lr", "=", "0.001", ",", "lr_min", "=", "1e-6", ",", "lr_factor", "=", "3", ",", "lr_patience", "=", "5", ",", "clipgrad", "=", "100", ",", "args", "=", "None", ",", "log_name", "=", "None", ",", "split", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "model_old", "=", "model", "\n", "\n", "file_name", "=", "log_name", "\n", "self", ".", "logger", "=", "utils", ".", "logger", "(", "file_name", "=", "file_name", ",", "resume", "=", "False", ",", "path", "=", "'./result_data/csvdata/'", ",", "data_format", "=", "'csv'", ")", "\n", "\n", "self", ".", "nepochs", "=", "nepochs", "\n", "self", ".", "sbatch", "=", "sbatch", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "lr_min", "=", "lr_min", "\n", "self", ".", "lr_factor", "=", "lr_factor", "\n", "self", ".", "lr_patience", "=", "lr_patience", "\n", "self", ".", "clipgrad", "=", "clipgrad", "\n", "self", ".", "split", "=", "split", "\n", "\n", "self", ".", "ce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", ")", "\n", "self", ".", "c", "=", "args", ".", "c", "\n", "self", ".", "epsilon", "=", "0.01", "\n", "if", "args", ".", "experiment", "==", "'split_notmnist'", ":", "\n", "            ", "self", ".", "epsilon", "=", "0.001", "\n", "", "self", ".", "omega", "=", "{", "}", "\n", "self", ".", "W", "=", "{", "}", "\n", "self", ".", "p_old", "=", "{", "}", "\n", "\n", "n", "=", "0", "\n", "\n", "# Register starting param-values (needed for \u201cintelligent synapses\u201d).", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "requires_grad", ":", "\n", "                ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "self", ".", "model", ".", "register_buffer", "(", "'{}_SI_prev_task'", ".", "format", "(", "n", ")", ",", "p", ".", "data", ".", "clone", "(", ")", ")", "\n", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr._get_optimizer": [[61, 67], ["torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "si.Appr.model.parameters", "si.Appr.model.parameters"], "methods", ["None"], ["", "def", "_get_optimizer", "(", "self", ",", "lr", "=", "None", ")", ":", "\n", "        ", "if", "lr", "is", "None", ":", "lr", "=", "self", ".", "lr", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "", "if", "args", ".", "optimizer", "==", "'Adam'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr.train": [[68, 138], ["utils.get_model", "si.Appr._get_optimizer", "si.Appr.model.named_parameters", "range", "utils.set_model_", "si.Appr.logger.save", "si.Appr.update_omega", "copy.deepcopy", "utils.freeze_model", "time.time", "xtrain.size", "si.Appr.train_epoch", "time.time", "si.Appr.eval", "time.time", "print", "si.Appr.eval", "print", "si.Appr.logger.add", "range", "print", "n.replace.replace.replace", "p.data.clone().zero_", "p.data.clone", "[].cuda", "[].cuda", "si.Appr.eval", "si.Appr.logger.add", "utils.get_model", "print", "print", "si.Appr._get_optimizer", "p.data.clone", "print"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.set_model_", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr.update_omega", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.freeze_model", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train_epoch", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["", "", "def", "train", "(", "self", ",", "t", ",", "xtrain", ",", "ytrain", ",", "xvalid", ",", "yvalid", ",", "data", ",", "input_size", ",", "taskcla", ")", ":", "\n", "        ", "best_loss", "=", "np", ".", "inf", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "lr", "=", "self", ".", "lr", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "\n", "self", ".", "W", "=", "{", "}", "\n", "self", ".", "p_old", "=", "{", "}", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "requires_grad", ":", "\n", "                ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "self", ".", "W", "[", "n", "]", "=", "p", ".", "data", ".", "clone", "(", ")", ".", "zero_", "(", ")", "\n", "self", ".", "p_old", "[", "n", "]", "=", "p", ".", "data", ".", "clone", "(", ")", "\n", "\n", "# Loop epochs", "\n", "", "", "for", "e", "in", "range", "(", "self", ".", "nepochs", ")", ":", "\n", "# Train", "\n", "            ", "clock0", "=", "time", ".", "time", "(", ")", "\n", "num_batch", "=", "xtrain", ".", "size", "(", "0", ")", "\n", "\n", "self", ".", "train_epoch", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "\n", "clock1", "=", "time", ".", "time", "(", ")", "\n", "train_loss", ",", "train_acc", "=", "self", ".", "eval", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "clock2", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "\n", "e", "+", "1", ",", "1000", "*", "self", ".", "sbatch", "*", "(", "clock1", "-", "clock0", ")", "/", "num_batch", ",", "1000", "*", "self", ".", "sbatch", "*", "(", "clock2", "-", "clock1", ")", "/", "num_batch", ",", "train_loss", ",", "100", "*", "train_acc", ")", ",", "end", "=", "''", ")", "\n", "# Valid", "\n", "valid_loss", ",", "valid_acc", "=", "self", ".", "eval", "(", "t", ",", "xvalid", ",", "yvalid", ")", "\n", "print", "(", "' Valid: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "valid_loss", ",", "100", "*", "valid_acc", ")", ",", "end", "=", "''", ")", "\n", "\n", "#save log for current task & old tasks at every epoch", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "t", "+", "1", ",", "valid_loss", "=", "valid_loss", ",", "valid_acc", "=", "valid_acc", ")", "\n", "for", "task", "in", "range", "(", "t", ")", ":", "\n", "                ", "xvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'x'", "]", ".", "cuda", "(", ")", "\n", "yvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'y'", "]", ".", "cuda", "(", ")", "\n", "\n", "valid_loss_t", ",", "valid_acc_t", "=", "self", ".", "eval", "(", "task", ",", "xvalid_t", ",", "yvalid_t", ")", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "task", "+", "1", ",", "valid_loss", "=", "valid_loss_t", ",", "valid_acc", "=", "valid_acc_t", ")", "\n", "\n", "# Adapt lr", "\n", "", "if", "valid_loss", "<", "best_loss", ":", "\n", "                ", "best_loss", "=", "valid_loss", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "print", "(", "' *'", ",", "end", "=", "''", ")", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "if", "patience", "<=", "0", ":", "\n", "                    ", "lr", "/=", "self", ".", "lr_factor", "\n", "print", "(", "' lr={:.1e}'", ".", "format", "(", "lr", ")", ",", "end", "=", "''", ")", "\n", "if", "lr", "<", "self", ".", "lr_min", ":", "\n", "                        ", "print", "(", ")", "\n", "if", "args", ".", "conv_net", ":", "\n", "                            ", "pass", "\n", "\n", "", "", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "", "", "print", "(", ")", "\n", "\n", "# Restore best", "\n", "", "utils", ".", "set_model_", "(", "self", ".", "model", ",", "best_model", ")", "\n", "\n", "self", ".", "logger", ".", "save", "(", ")", "\n", "self", ".", "update_omega", "(", "self", ".", "W", ",", "self", ".", "epsilon", ")", "\n", "self", ".", "model_old", "=", "deepcopy", "(", "self", ".", "model", ")", "\n", "utils", ".", "freeze_model", "(", "self", ".", "model_old", ")", "# Freeze the weights", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr.train_epoch": [[139, 175], ["si.Appr.model.train", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "si.Appr.criterion", "si.Appr.optimizer.zero_grad", "si.Appr.backward", "si.Appr.optimizer.step", "si.Appr.model.named_parameters", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "si.Appr.model.forward", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "si.Appr.model.forward", "si.Appr.model.parameters", "n.replace.replace.replace", "p.detach().clone", "si.Appr.W[].add_", "p.detach", "p.detach"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward"], ["", "def", "train_epoch", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "r", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward current model", "\n", "if", "self", ".", "split", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "\n", "", "loss", "=", "self", ".", "criterion", "(", "t", ",", "output", ",", "targets", ")", "\n", "\n", "n", "=", "0", "\n", "# Backward", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", "or", "args", ".", "optimizer", "==", "'SGD_momentum_decay'", ":", "\n", "                ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "clipgrad", ")", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "               ", "if", "p", ".", "requires_grad", ":", "\n", "                    ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "                        ", "self", ".", "W", "[", "n", "]", ".", "add_", "(", "-", "p", ".", "grad", "*", "(", "p", ".", "detach", "(", ")", "-", "self", ".", "p_old", "[", "n", "]", ")", ")", "\n", "", "self", ".", "p_old", "[", "n", "]", "=", "p", ".", "detach", "(", ")", ".", "clone", "(", ")", "\n", "\n", "", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr.eval": [[176, 210], ["si.Appr.model.eval", "numpy.arange", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "si.Appr.criterion", "si.Appr.max", "hits.sum().data.cpu().numpy", "len", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "si.Appr.model.forward", "si.Appr.data.cpu().numpy", "len", "si.Appr.model.forward", "hits.sum().data.cpu", "si.Appr.data.cpu", "hits.sum"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward"], ["", "def", "eval", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "total_loss", "=", "0", "\n", "total_acc", "=", "0", "\n", "total_num", "=", "0", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward", "\n", "if", "self", ".", "split", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "\n", "\n", "", "loss", "=", "self", ".", "criterion", "(", "t", ",", "output", ",", "targets", ")", "\n", "_", ",", "pred", "=", "output", ".", "max", "(", "1", ")", "\n", "hits", "=", "(", "pred", "==", "targets", ")", ".", "float", "(", ")", "\n", "\n", "# Log", "\n", "#             total_loss+=loss.data.cpu().numpy()[0]*len(b)", "\n", "#             total_acc+=hits.sum().data.cpu().numpy()[0]", "\n", "total_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "len", "(", "b", ")", "\n", "total_acc", "+=", "hits", ".", "sum", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "total_num", "+=", "len", "(", "b", ")", "\n", "\n", "", "return", "total_loss", "/", "total_num", ",", "total_acc", "/", "total_num", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr.criterion": [[211, 218], ["si.Appr.surrogate_loss", "si.Appr.ce"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr.surrogate_loss"], ["", "def", "criterion", "(", "self", ",", "t", ",", "output", ",", "targets", ")", ":", "\n", "# Regularization for all previous tasks", "\n", "        ", "loss_reg", "=", "0", "\n", "if", "t", ">", "0", ":", "\n", "            ", "loss_reg", "=", "self", ".", "surrogate_loss", "(", ")", "\n", "\n", "", "return", "self", ".", "ce", "(", "output", ",", "targets", ")", "+", "self", ".", "c", "*", "loss_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr.update_omega": [[219, 243], ["si.Appr.model.named_parameters", "n.replace.replace.replace", "getattr", "p.detach().clone", "si.Appr.model.register_buffer", "si.Appr.model.register_buffer", "getattr", "p.detach", "p.detach().clone().zero_", "p.detach().clone", "p.detach"], "methods", ["None"], ["", "def", "update_omega", "(", "self", ",", "W", ",", "epsilon", ")", ":", "\n", "        ", "\"\"\"After completing training on a task, update the per-parameter regularization strength.\n        [W]         <dict> estimated parameter-specific contribution to changes in total loss of completed task\n        [epsilon]   <float> dampening parameter (to bound [omega] when [p_change] goes to 0)\"\"\"", "\n", "\n", "# Loop over all parameters", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "requires_grad", ":", "\n", "                ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "\n", "# Find/calculate new values for quadratic penalty on parameters", "\n", "p_prev", "=", "getattr", "(", "self", ".", "model", ",", "'{}_SI_prev_task'", ".", "format", "(", "n", ")", ")", "\n", "p_current", "=", "p", ".", "detach", "(", ")", ".", "clone", "(", ")", "\n", "p_change", "=", "p_current", "-", "p_prev", "\n", "omega_add", "=", "W", "[", "n", "]", "/", "(", "p_change", "**", "2", "+", "epsilon", ")", "\n", "try", ":", "\n", "                    ", "omega", "=", "getattr", "(", "self", ".", "model", ",", "'{}_SI_omega'", ".", "format", "(", "n", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "                    ", "omega", "=", "p", ".", "detach", "(", ")", ".", "clone", "(", ")", ".", "zero_", "(", ")", "\n", "", "omega_new", "=", "omega", "+", "omega_add", "\n", "\n", "# Store these new values in the model", "\n", "self", ".", "model", ".", "register_buffer", "(", "'{}_SI_prev_task'", ".", "format", "(", "n", ")", ",", "p_current", ")", "\n", "self", ".", "model", ".", "register_buffer", "(", "'{}_SI_omega'", ".", "format", "(", "n", ")", ",", "omega_new", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.si.Appr.surrogate_loss": [[244, 260], ["si.Appr.model.named_parameters", "sum", "n.replace.replace.replace", "getattr", "getattr", "losses.append"], "methods", ["None"], ["", "", "", "def", "surrogate_loss", "(", "self", ")", ":", "\n", "        ", "\"\"\"Calculate SI\u2019s surrogate loss\"\"\"", "\n", "try", ":", "\n", "            ", "losses", "=", "[", "]", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                ", "if", "p", ".", "requires_grad", ":", "\n", "# Retrieve previous parameter values and their normalized path integral (i.e., omega)", "\n", "                    ", "n", "=", "n", ".", "replace", "(", "'.'", ",", "'__'", ")", "\n", "prev_values", "=", "getattr", "(", "self", ".", "model", ",", "'{}_SI_prev_task'", ".", "format", "(", "n", ")", ")", "\n", "omega", "=", "getattr", "(", "self", ".", "model", ",", "'{}_SI_omega'", ".", "format", "(", "n", ")", ")", "\n", "# Calculate SI\u2019s surrogate loss, sum over all parameters", "\n", "losses", ".", "append", "(", "(", "omega", "*", "(", "p", "-", "prev_values", ")", "**", "2", ")", ".", "sum", "(", ")", ")", "\n", "", "", "return", "sum", "(", "losses", ")", "\n", "", "except", "AttributeError", ":", "\n", "# SI-loss is 0 if there is no stored omega yet", "\n", "            ", "return", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.rwalk.Appr.__init__": [[27, 71], ["utils.logger", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "rwalk.Appr._get_optimizer", "rwalk.Appr.model.named_parameters", "len", "args.parameter.split", "print", "float", "p.data.clone"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["def", "__init__", "(", "self", ",", "model", ",", "nepochs", "=", "100", ",", "sbatch", "=", "256", ",", "lr", "=", "0.001", ",", "lr_min", "=", "2e-6", ",", "lr_factor", "=", "3", ",", "lr_patience", "=", "5", ",", "clipgrad", "=", "100", ",", "args", "=", "None", ",", "log_name", "=", "None", ",", "split", "=", "False", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "model_old", "=", "model", "\n", "\n", "file_name", "=", "log_name", "\n", "self", ".", "logger", "=", "utils", ".", "logger", "(", "file_name", "=", "file_name", ",", "resume", "=", "False", ",", "path", "=", "'./result_data/csvdata/'", ",", "data_format", "=", "'csv'", ")", "\n", "\n", "self", ".", "nepochs", "=", "nepochs", "\n", "self", ".", "sbatch", "=", "sbatch", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "lr_min", "=", "lr_min", "\n", "self", ".", "lr_factor", "=", "lr_factor", "\n", "self", ".", "lr_patience", "=", "lr_patience", "\n", "self", ".", "clipgrad", "=", "clipgrad", "\n", "self", ".", "split", "=", "split", "\n", "\n", "self", ".", "ce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", ")", "\n", "self", ".", "lamb", "=", "args", ".", "lamb", "\n", "self", ".", "alpha", "=", "0.9", "\n", "if", "len", "(", "args", ".", "parameter", ")", ">=", "1", ":", "\n", "            ", "params", "=", "args", ".", "parameter", ".", "split", "(", "','", ")", "\n", "print", "(", "'Setting parameters to'", ",", "params", ")", "\n", "self", ".", "lamb", "=", "float", "(", "params", "[", "0", "]", ")", "\n", "\n", "", "self", ".", "s", "=", "{", "}", "\n", "self", ".", "s_running", "=", "{", "}", "\n", "self", ".", "fisher", "=", "{", "}", "\n", "self", ".", "fisher_running", "=", "{", "}", "\n", "self", ".", "p_old", "=", "{", "}", "\n", "\n", "self", ".", "eps", "=", "0.01", "\n", "\n", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "requires_grad", ":", "\n", "                ", "self", ".", "s", "[", "n", "]", "=", "0", "\n", "self", ".", "s_running", "[", "n", "]", "=", "0", "\n", "self", ".", "fisher", "[", "n", "]", "=", "0", "\n", "self", ".", "fisher_running", "[", "n", "]", "=", "0", "\n", "self", ".", "p_old", "[", "n", "]", "=", "p", ".", "data", ".", "clone", "(", ")", "\n", "\n", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.rwalk.Appr._get_optimizer": [[72, 78], ["torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "rwalk.Appr.model.parameters", "rwalk.Appr.model.parameters"], "methods", ["None"], ["", "def", "_get_optimizer", "(", "self", ",", "lr", "=", "None", ")", ":", "\n", "        ", "if", "lr", "is", "None", ":", "lr", "=", "self", ".", "lr", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "", "if", "args", ".", "optimizer", "==", "'Adam'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.rwalk.Appr.train": [[79, 153], ["utils.get_model", "rwalk.Appr._get_optimizer", "range", "utils.set_model_", "rwalk.Appr.logger.save", "copy.deepcopy", "utils.freeze_model", "rwalk.Appr.model.named_parameters", "time.time", "xtrain.size", "rwalk.Appr.train_epoch", "time.time", "rwalk.Appr.eval", "time.time", "print", "rwalk.Appr.eval", "print", "rwalk.Appr.logger.add", "range", "print", "[].cuda", "[].cuda", "rwalk.Appr.eval", "rwalk.Appr.logger.add", "utils.get_model", "print", "print", "rwalk.Appr._get_optimizer", "rwalk.Appr.fisher_running[].clone", "rwalk.Appr.s[].clone", "print", "rwalk.Appr.s_running[].clone"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.set_model_", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.freeze_model", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train_epoch", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["", "", "def", "train", "(", "self", ",", "t", ",", "xtrain", ",", "ytrain", ",", "xvalid", ",", "yvalid", ",", "data", ",", "input_size", ",", "taskcla", ")", ":", "\n", "        ", "best_loss", "=", "np", ".", "inf", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "lr", "=", "self", ".", "lr", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "\n", "# Loop epochs", "\n", "for", "e", "in", "range", "(", "self", ".", "nepochs", ")", ":", "\n", "# Train", "\n", "            ", "clock0", "=", "time", ".", "time", "(", ")", "\n", "num_batch", "=", "xtrain", ".", "size", "(", "0", ")", "\n", "\n", "self", ".", "train_epoch", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "\n", "clock1", "=", "time", ".", "time", "(", ")", "\n", "train_loss", ",", "train_acc", "=", "self", ".", "eval", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "clock2", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "\n", "e", "+", "1", ",", "1000", "*", "self", ".", "sbatch", "*", "(", "clock1", "-", "clock0", ")", "/", "num_batch", ",", "\n", "1000", "*", "self", ".", "sbatch", "*", "(", "clock2", "-", "clock1", ")", "/", "num_batch", ",", "train_loss", ",", "100", "*", "train_acc", ")", ",", "end", "=", "''", ")", "\n", "# Valid", "\n", "valid_loss", ",", "valid_acc", "=", "self", ".", "eval", "(", "t", ",", "xvalid", ",", "yvalid", ")", "\n", "print", "(", "' Valid: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "valid_loss", ",", "100", "*", "valid_acc", ")", ",", "end", "=", "''", ")", "\n", "\n", "#save log for current task & old tasks at every epoch", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "t", "+", "1", ",", "valid_loss", "=", "valid_loss", ",", "valid_acc", "=", "valid_acc", ")", "\n", "for", "task", "in", "range", "(", "t", ")", ":", "\n", "                ", "xvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'x'", "]", ".", "cuda", "(", ")", "\n", "yvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'y'", "]", ".", "cuda", "(", ")", "\n", "\n", "valid_loss_t", ",", "valid_acc_t", "=", "self", ".", "eval", "(", "task", ",", "xvalid_t", ",", "yvalid_t", ")", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "task", "+", "1", ",", "valid_loss", "=", "valid_loss_t", ",", "\n", "valid_acc", "=", "valid_acc_t", ")", "\n", "\n", "# Adapt lr", "\n", "", "if", "valid_loss", "<", "best_loss", ":", "\n", "                ", "best_loss", "=", "valid_loss", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "print", "(", "' *'", ",", "end", "=", "''", ")", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "if", "patience", "<=", "0", ":", "\n", "                    ", "lr", "/=", "self", ".", "lr_factor", "\n", "print", "(", "' lr={:.1e}'", ".", "format", "(", "lr", ")", ",", "end", "=", "''", ")", "\n", "if", "lr", "<", "self", ".", "lr_min", ":", "\n", "                        ", "print", "(", ")", "\n", "if", "args", ".", "conv_net", ":", "\n", "                            ", "pass", "\n", "#                             break", "\n", "", "", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "", "", "print", "(", ")", "\n", "\n", "# Restore best", "\n", "", "utils", ".", "set_model_", "(", "self", ".", "model", ",", "best_model", ")", "\n", "\n", "self", ".", "logger", ".", "save", "(", ")", "\n", "\n", "# Update old", "\n", "self", ".", "model_old", "=", "deepcopy", "(", "self", ".", "model", ")", "\n", "utils", ".", "freeze_model", "(", "self", ".", "model_old", ")", "# Freeze the weights", "\n", "\n", "\n", "# Update fisher & s", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "requires_grad", ":", "\n", "                ", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "                    ", "self", ".", "fisher", "[", "n", "]", "=", "self", ".", "fisher_running", "[", "n", "]", ".", "clone", "(", ")", "\n", "self", ".", "s", "[", "n", "]", "=", "(", "1", "/", "2", ")", "*", "self", ".", "s_running", "[", "n", "]", ".", "clone", "(", ")", "\n", "self", ".", "s_running", "[", "n", "]", "=", "self", ".", "s", "[", "n", "]", ".", "clone", "(", ")", "\n", "\n", "", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.rwalk.Appr.train_epoch": [[154, 186], ["rwalk.Appr.model.train", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "rwalk.Appr.criterion", "rwalk.Appr.optimizer.zero_grad", "rwalk.Appr.backward", "rwalk.Appr.optimizer.step", "rwalk.Appr.update_fisher_and_s", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "rwalk.Appr.model.forward", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "rwalk.Appr.model.forward", "rwalk.Appr.model.parameters"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.rwalk.Appr.update_fisher_and_s", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward"], ["", "def", "train_epoch", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "r", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward current model", "\n", "if", "self", ".", "split", ":", "\n", "                ", "outputs", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "                ", "outputs", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "\n", "", "loss", "=", "self", ".", "criterion", "(", "t", ",", "outputs", ",", "targets", ")", "\n", "\n", "# Backward", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", "or", "args", ".", "optimizer", "==", "'SGD_momentum_decay'", ":", "\n", "                ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "clipgrad", ")", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Compute Fisher & s", "\n", "self", ".", "update_fisher_and_s", "(", ")", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.rwalk.Appr.eval": [[187, 221], ["rwalk.Appr.model.eval", "numpy.arange", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "rwalk.Appr.criterion", "rwalk.Appr.max", "hits.sum().data.cpu().numpy", "len", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "rwalk.Appr.model.forward", "rwalk.Appr.data.cpu().numpy", "len", "rwalk.Appr.model.forward", "hits.sum().data.cpu", "rwalk.Appr.data.cpu", "hits.sum"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward"], ["", "def", "eval", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "total_loss", "=", "0", "\n", "total_acc", "=", "0", "\n", "total_num", "=", "0", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward", "\n", "if", "self", ".", "split", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "\n", "\n", "", "loss", "=", "self", ".", "criterion", "(", "t", ",", "output", ",", "targets", ")", "\n", "_", ",", "pred", "=", "output", ".", "max", "(", "1", ")", "\n", "hits", "=", "(", "pred", "==", "targets", ")", ".", "float", "(", ")", "\n", "\n", "# Log", "\n", "#             total_loss+=loss.data.cpu().numpy()[0]*len(b)", "\n", "#             total_acc+=hits.sum().data.cpu().numpy()[0]", "\n", "total_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "len", "(", "b", ")", "\n", "total_acc", "+=", "hits", ".", "sum", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "total_num", "+=", "len", "(", "b", ")", "\n", "\n", "", "return", "total_loss", "/", "total_num", ",", "total_acc", "/", "total_num", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.rwalk.Appr.criterion": [[222, 229], ["zip", "rwalk.Appr.ce", "rwalk.Appr.model.named_parameters", "rwalk.Appr.model_old.named_parameters", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "criterion", "(", "self", ",", "t", ",", "output", ",", "targets", ")", ":", "\n", "# Regularization for all previous tasks", "\n", "        ", "loss_reg", "=", "0", "\n", "if", "t", ">", "0", ":", "\n", "            ", "for", "(", "n", ",", "param", ")", ",", "(", "_", ",", "param_old", ")", "in", "zip", "(", "self", ".", "model", ".", "named_parameters", "(", ")", ",", "self", ".", "model_old", ".", "named_parameters", "(", ")", ")", ":", "\n", "                ", "loss_reg", "+=", "torch", ".", "sum", "(", "(", "self", ".", "fisher", "[", "n", "]", "+", "self", ".", "s", "[", "n", "]", ")", "*", "(", "param_old", "-", "param", ")", ".", "pow", "(", "2", ")", ")", "\n", "", "", "return", "self", ".", "ce", "(", "output", ",", "targets", ")", "+", "self", ".", "lamb", "*", "loss_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.rwalk.Appr.update_fisher_and_s": [[230, 245], ["rwalk.Appr.model.named_parameters", "p.detach().clone", "p.grad.data.pow", "p.detach", "p.detach", "p.detach"], "methods", ["None"], ["", "def", "update_fisher_and_s", "(", "self", ")", ":", "\n", "        ", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "requires_grad", ":", "\n", "                ", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "# Compute running fisher", "\n", "                    ", "fisher_current", "=", "p", ".", "grad", ".", "data", ".", "pow", "(", "2", ")", "\n", "self", ".", "fisher_running", "[", "n", "]", "=", "self", ".", "alpha", "*", "fisher_current", "+", "(", "1", "-", "self", ".", "alpha", ")", "*", "self", ".", "fisher_running", "[", "n", "]", "\n", "\n", "# Compute running s", "\n", "loss_diff", "=", "-", "p", ".", "grad", "*", "(", "p", ".", "detach", "(", ")", "-", "self", ".", "p_old", "[", "n", "]", ")", "\n", "fisher_distance", "=", "(", "1", "/", "2", ")", "*", "(", "self", ".", "fisher_running", "[", "n", "]", "*", "(", "p", ".", "detach", "(", ")", "-", "self", ".", "p_old", "[", "n", "]", ")", "**", "2", ")", "\n", "s", "=", "loss_diff", "/", "(", "fisher_distance", "+", "self", ".", "eps", ")", "\n", "self", ".", "s_running", "[", "n", "]", "=", "self", ".", "s_running", "[", "n", "]", "+", "s", "\n", "\n", "", "self", ".", "p_old", "[", "n", "]", "=", "p", ".", "detach", "(", ")", ".", "clone", "(", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.mas.Appr.__init__": [[25, 52], ["utils.logger", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "mas.Appr._get_optimizer", "mas.Appr.model.named_parameters"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["def", "__init__", "(", "self", ",", "model", ",", "nepochs", "=", "100", ",", "sbatch", "=", "256", ",", "lr", "=", "0.001", ",", "lr_min", "=", "1e-6", ",", "lr_factor", "=", "3", ",", "lr_patience", "=", "5", ",", "clipgrad", "=", "100", ",", "args", "=", "None", ",", "log_name", "=", "None", ",", "split", "=", "False", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "model_old", "=", "model", "\n", "self", ".", "fisher", "=", "None", "\n", "\n", "file_name", "=", "log_name", "\n", "self", ".", "logger", "=", "utils", ".", "logger", "(", "file_name", "=", "file_name", ",", "resume", "=", "False", ",", "path", "=", "'./result_data/csvdata/'", ",", "data_format", "=", "'csv'", ")", "\n", "\n", "self", ".", "nepochs", "=", "nepochs", "\n", "self", ".", "sbatch", "=", "sbatch", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "lr_min", "=", "lr_min", "\n", "self", ".", "lr_factor", "=", "lr_factor", "\n", "self", ".", "lr_patience", "=", "lr_patience", "\n", "self", ".", "clipgrad", "=", "clipgrad", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "lamb", "=", "args", ".", "lamb", "\n", "\n", "self", ".", "ce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", ")", "\n", "\n", "self", ".", "omega", "=", "{", "}", "\n", "\n", "for", "n", ",", "_", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "self", ".", "omega", "[", "n", "]", "=", "0", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.mas.Appr._get_optimizer": [[53, 59], ["torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "mas.Appr.model.parameters", "mas.Appr.model.parameters"], "methods", ["None"], ["", "def", "_get_optimizer", "(", "self", ",", "lr", "=", "None", ")", ":", "\n", "        ", "if", "lr", "is", "None", ":", "lr", "=", "self", ".", "lr", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "", "if", "args", ".", "optimizer", "==", "'Adam'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.mas.Appr.train": [[60, 127], ["utils.get_model", "mas.Appr._get_optimizer", "range", "utils.set_model_", "mas.Appr.logger.save", "copy.deepcopy", "utils.freeze_model", "mas.Appr.omega_update", "time.time", "xtrain.size", "mas.Appr.train_epoch", "time.time", "mas.Appr.eval", "time.time", "print", "mas.Appr.eval", "print", "mas.Appr.logger.add", "range", "print", "[].cuda", "[].cuda", "mas.Appr.eval", "mas.Appr.logger.add", "utils.get_model", "print", "print", "mas.Appr._get_optimizer", "print"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.set_model_", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.freeze_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.mas.Appr.omega_update", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train_epoch", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["", "", "def", "train", "(", "self", ",", "t", ",", "xtrain", ",", "ytrain", ",", "xvalid", ",", "yvalid", ",", "data", ",", "input_size", ",", "taskcla", ")", ":", "\n", "        ", "best_loss", "=", "np", ".", "inf", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "lr", "=", "self", ".", "lr", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "\n", "# Loop epochs", "\n", "for", "e", "in", "range", "(", "self", ".", "nepochs", ")", ":", "\n", "# Train", "\n", "            ", "clock0", "=", "time", ".", "time", "(", ")", "\n", "\n", "num_batch", "=", "xtrain", ".", "size", "(", "0", ")", "\n", "\n", "self", ".", "train_epoch", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "\n", "clock1", "=", "time", ".", "time", "(", ")", "\n", "train_loss", ",", "train_acc", "=", "self", ".", "eval", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "clock2", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "\n", "e", "+", "1", ",", "1000", "*", "self", ".", "sbatch", "*", "(", "clock1", "-", "clock0", ")", "/", "num_batch", ",", "\n", "1000", "*", "self", ".", "sbatch", "*", "(", "clock2", "-", "clock1", ")", "/", "num_batch", ",", "train_loss", ",", "100", "*", "train_acc", ")", ",", "end", "=", "''", ")", "\n", "# Valid", "\n", "valid_loss", ",", "valid_acc", "=", "self", ".", "eval", "(", "t", ",", "xvalid", ",", "yvalid", ")", "\n", "print", "(", "' Valid: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "valid_loss", ",", "100", "*", "valid_acc", ")", ",", "end", "=", "''", ")", "\n", "\n", "#save log for current task & old tasks at every epoch", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "t", "+", "1", ",", "valid_loss", "=", "valid_loss", ",", "valid_acc", "=", "valid_acc", ")", "\n", "for", "task", "in", "range", "(", "t", ")", ":", "\n", "                ", "xvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'x'", "]", ".", "cuda", "(", ")", "\n", "yvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'y'", "]", ".", "cuda", "(", ")", "\n", "\n", "valid_loss_t", ",", "valid_acc_t", "=", "self", ".", "eval", "(", "task", ",", "xvalid_t", ",", "yvalid_t", ")", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "task", "+", "1", ",", "valid_loss", "=", "valid_loss_t", ",", "\n", "valid_acc", "=", "valid_acc_t", ")", "\n", "\n", "# Adapt lr", "\n", "", "if", "valid_loss", "<", "best_loss", ":", "\n", "                ", "best_loss", "=", "valid_loss", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "print", "(", "' *'", ",", "end", "=", "''", ")", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "if", "patience", "<=", "0", ":", "\n", "                    ", "lr", "/=", "self", ".", "lr_factor", "\n", "print", "(", "' lr={:.1e}'", ".", "format", "(", "lr", ")", ",", "end", "=", "''", ")", "\n", "if", "lr", "<", "self", ".", "lr_min", ":", "\n", "                        ", "print", "(", ")", "\n", "if", "args", ".", "conv_net", ":", "\n", "                            ", "pass", "\n", "#                             break", "\n", "", "", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "", "", "print", "(", ")", "\n", "\n", "# Restore best", "\n", "", "utils", ".", "set_model_", "(", "self", ".", "model", ",", "best_model", ")", "\n", "\n", "self", ".", "logger", ".", "save", "(", ")", "\n", "\n", "# Update old", "\n", "self", ".", "model_old", "=", "deepcopy", "(", "self", ".", "model", ")", "\n", "utils", ".", "freeze_model", "(", "self", ".", "model_old", ")", "# Freeze the weights", "\n", "self", ".", "omega_update", "(", "t", ",", "xtrain", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.mas.Appr.train_epoch": [[128, 157], ["mas.Appr.model.train", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "mas.Appr.criterion", "mas.Appr.optimizer.zero_grad", "mas.Appr.backward", "mas.Appr.optimizer.step", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "mas.Appr.model.forward", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "mas.Appr.model.forward", "mas.Appr.model.parameters"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward"], ["", "def", "train_epoch", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "r", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward current model", "\n", "if", "self", ".", "split", ":", "\n", "                ", "outputs", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "                ", "outputs", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "\n", "", "loss", "=", "self", ".", "criterion", "(", "t", ",", "outputs", ",", "targets", ")", "\n", "\n", "# Backward", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", "or", "args", ".", "optimizer", "==", "'SGD_momentum_decay'", ":", "\n", "                ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "clipgrad", ")", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.mas.Appr.eval": [[158, 192], ["mas.Appr.model.eval", "numpy.arange", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "mas.Appr.criterion", "mas.Appr.max", "hits.sum().data.cpu().numpy", "len", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "mas.Appr.model.forward", "mas.Appr.data.cpu().numpy", "len", "mas.Appr.model.forward", "hits.sum().data.cpu", "mas.Appr.data.cpu", "hits.sum"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward"], ["", "def", "eval", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "total_loss", "=", "0", "\n", "total_acc", "=", "0", "\n", "total_num", "=", "0", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward", "\n", "if", "self", ".", "split", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "\n", "\n", "", "loss", "=", "self", ".", "criterion", "(", "t", ",", "output", ",", "targets", ")", "\n", "_", ",", "pred", "=", "output", ".", "max", "(", "1", ")", "\n", "hits", "=", "(", "pred", "==", "targets", ")", ".", "float", "(", ")", "\n", "\n", "# Log", "\n", "#             total_loss+=loss.data.cpu().numpy()[0]*len(b)", "\n", "#             total_acc+=hits.sum().data.cpu().numpy()[0]", "\n", "total_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "len", "(", "b", ")", "\n", "total_acc", "+=", "hits", ".", "sum", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "total_num", "+=", "len", "(", "b", ")", "\n", "\n", "", "return", "total_loss", "/", "total_num", ",", "total_acc", "/", "total_num", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.mas.Appr.criterion": [[193, 200], ["zip", "mas.Appr.model.named_parameters", "mas.Appr.model_old.named_parameters", "mas.Appr.ce", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "criterion", "(", "self", ",", "t", ",", "output", ",", "targets", ")", ":", "\n", "# Regularization for all previous tasks", "\n", "        ", "loss_reg", "=", "0", "\n", "for", "(", "name", ",", "param", ")", ",", "(", "_", ",", "param_old", ")", "in", "zip", "(", "self", ".", "model", ".", "named_parameters", "(", ")", ",", "self", ".", "model_old", ".", "named_parameters", "(", ")", ")", ":", "\n", "                ", "loss_reg", "+=", "torch", ".", "sum", "(", "self", ".", "omega", "[", "name", "]", "*", "(", "param_old", "-", "param", ")", ".", "pow", "(", "2", ")", ")", "/", "2", "\n", "\n", "", "return", "self", ".", "ce", "(", "output", ",", "targets", ")", "+", "self", ".", "lamb", "*", "loss_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.mas.Appr.omega_update": [[201, 228], ["mas.Appr.model.train", "tqdm.tqdm.tqdm", "range", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "mas.Appr.model.zero_grad", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum.backward", "torch.sum.backward", "torch.sum.backward", "mas.Appr.model.named_parameters", "x.size", "mas.Appr.model.forward", "mas.Appr.norm", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "mas.Appr.model.forward", "numpy.arange", "p.grad.data.abs", "x.size", "numpy.min", "x.size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "omega_update", "(", "self", ",", "t", ",", "x", ")", ":", "\n", "        ", "sbatch", "=", "self", ".", "sbatch", "\n", "#         sbatch = 1", "\n", "\n", "# Compute", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "0", ",", "x", ".", "size", "(", "0", ")", ",", "sbatch", ")", ",", "desc", "=", "'Omega'", ",", "ncols", "=", "100", ",", "ascii", "=", "True", ")", ":", "\n", "            ", "b", "=", "torch", ".", "LongTensor", "(", "np", ".", "arange", "(", "i", ",", "np", ".", "min", "(", "[", "i", "+", "sbatch", ",", "x", ".", "size", "(", "0", ")", "]", ")", ")", ")", ".", "cuda", "(", ")", "\n", "images", "=", "x", "[", "b", "]", "\n", "# Forward and backward", "\n", "self", ".", "model", ".", "zero_grad", "(", ")", "\n", "if", "self", ".", "split", ":", "\n", "                ", "outputs", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "                ", "outputs", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "\n", "\n", "# Sum of L2 norm of output scores", "\n", "", "loss", "=", "torch", ".", "sum", "(", "outputs", ".", "norm", "(", "2", ",", "dim", "=", "-", "1", ")", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# Get gradients", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                ", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "                    ", "self", ".", "omega", "[", "n", "]", "+=", "p", ".", "grad", ".", "data", ".", "abs", "(", ")", "/", "x", ".", "size", "(", "0", ")", "\n", "\n", "", "", "", "return", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ucl.Appr.__init__": [[24, 63], ["copy.deepcopy", "utils.logger", "ucl.Appr.model.named_parameters", "ucl.Appr._get_optimizer", "ucl.Appr.param_name.append", "len", "args.parameter.split", "print", "float"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "nepochs", "=", "100", ",", "sbatch", "=", "256", ",", "lr", "=", "0.001", ",", "\n", "lr_min", "=", "2e-6", ",", "lr_factor", "=", "3", ",", "lr_patience", "=", "5", ",", "clipgrad", "=", "100", ",", "args", "=", "None", ",", "log_name", "=", "None", ",", "split", "=", "False", ")", ":", "\n", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "model_old", "=", "deepcopy", "(", "self", ".", "model", ")", "\n", "\n", "file_name", "=", "log_name", "\n", "self", ".", "logger", "=", "utils", ".", "logger", "(", "file_name", "=", "file_name", ",", "resume", "=", "False", ",", "path", "=", "'./result_data/csvdata/'", ",", "data_format", "=", "'csv'", ")", "\n", "\n", "self", ".", "nepochs", "=", "nepochs", "\n", "self", ".", "sbatch", "=", "sbatch", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "lr_rho", "=", "args", ".", "lr_rho", "\n", "self", ".", "lr_min", "=", "lr", "/", "(", "lr_factor", "**", "5", ")", "\n", "self", ".", "lr_factor", "=", "lr_factor", "\n", "self", ".", "lr_patience", "=", "5", "\n", "self", ".", "clipgrad", "=", "clipgrad", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "iteration", "=", "0", "\n", "self", ".", "epoch", "=", "0", "\n", "self", ".", "saved", "=", "0", "\n", "self", ".", "split", "=", "split", "\n", "self", ".", "beta", "=", "args", ".", "beta", "\n", "\n", "self", ".", "drop", "=", "[", "20", ",", "40", ",", "60", ",", "75", ",", "90", "]", "\n", "\n", "self", ".", "param_name", "=", "[", "]", "\n", "\n", "for", "(", "name", ",", "p", ")", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "self", ".", "param_name", ".", "append", "(", "name", ")", "\n", "\n", "", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", ")", "\n", "\n", "if", "len", "(", "args", ".", "parameter", ")", ">=", "1", ":", "\n", "            ", "params", "=", "args", ".", "parameter", ".", "split", "(", "','", ")", "\n", "print", "(", "'Setting parameters to'", ",", "params", ")", "\n", "self", ".", "lamb", "=", "float", "(", "para", ",", "ms", "[", "0", "]", ")", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ucl.Appr._get_optimizer": [[64, 71], ["Adam", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "ucl.Appr.model.parameters", "ucl.Appr.model.parameters"], "methods", ["None"], ["", "def", "_get_optimizer", "(", "self", ",", "lr", "=", "None", ",", "lr_rho", "=", "None", ")", ":", "\n", "        ", "if", "lr", "is", "None", ":", "lr", "=", "self", ".", "lr", "\n", "if", "lr_rho", "is", "None", ":", "lr_rho", "=", "self", ".", "lr_rho", "\n", "if", "args", ".", "optimizer", "==", "'Adam'", ":", "\n", "            ", "return", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "lr_rho", "=", "lr_rho", ",", "param_name", "=", "self", ".", "param_name", ")", "\n", "", "if", "args", ".", "optimizer", "==", "'SGD'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ucl.Appr.train": [[72, 140], ["utils.get_model", "ucl.Appr._get_optimizer", "range", "utils.set_model_", "copy.deepcopy", "ucl.Appr.logger.save", "time.time", "xtrain.size", "ucl.Appr.train_epoch", "time.time", "ucl.Appr.eval", "time.time", "print", "ucl.Appr.eval", "print", "ucl.Appr.logger.add", "range", "print", "utils.freeze_model", "[].cuda", "[].cuda", "ucl.Appr.eval", "ucl.Appr.logger.add", "utils.get_model", "print", "print", "ucl.Appr._get_optimizer", "print"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.set_model_", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train_epoch", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.freeze_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["", "", "def", "train", "(", "self", ",", "t", ",", "xtrain", ",", "ytrain", ",", "xvalid", ",", "yvalid", ",", "data", ",", "input_size", ",", "taskcla", ")", ":", "\n", "        ", "best_loss", "=", "np", ".", "inf", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "lr", "=", "self", ".", "lr", "\n", "lr_rho", "=", "self", ".", "lr_rho", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ",", "lr_rho", ")", "\n", "\n", "# Loop epochs", "\n", "for", "e", "in", "range", "(", "self", ".", "nepochs", ")", ":", "\n", "            ", "self", ".", "epoch", "=", "self", ".", "epoch", "+", "1", "\n", "# Train", "\n", "clock0", "=", "time", ".", "time", "(", ")", "\n", "\n", "num_batch", "=", "xtrain", ".", "size", "(", "0", ")", "\n", "\n", "self", ".", "train_epoch", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "\n", "clock1", "=", "time", ".", "time", "(", ")", "\n", "train_loss", ",", "train_acc", "=", "self", ".", "eval", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "\n", "clock2", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "\n", "e", "+", "1", ",", "1000", "*", "self", ".", "sbatch", "*", "(", "clock1", "-", "clock0", ")", "/", "num_batch", ",", "\n", "1000", "*", "self", ".", "sbatch", "*", "(", "clock2", "-", "clock1", ")", "/", "num_batch", ",", "train_loss", ",", "100", "*", "train_acc", ")", ",", "end", "=", "''", ")", "\n", "# Valid", "\n", "\n", "valid_loss", ",", "valid_acc", "=", "self", ".", "eval", "(", "t", ",", "xvalid", ",", "yvalid", ")", "\n", "print", "(", "' Valid: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "valid_loss", ",", "100", "*", "valid_acc", ")", ",", "end", "=", "''", ")", "\n", "\n", "# save log for current task & old tasks at every epoch", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "t", "+", "1", ",", "valid_loss", "=", "valid_loss", ",", "valid_acc", "=", "valid_acc", ")", "\n", "for", "task", "in", "range", "(", "t", ")", ":", "\n", "                ", "xvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'x'", "]", ".", "cuda", "(", ")", "\n", "yvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'y'", "]", ".", "cuda", "(", ")", "\n", "\n", "valid_loss_t", ",", "valid_acc_t", "=", "self", ".", "eval", "(", "task", ",", "xvalid_t", ",", "yvalid_t", ")", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "task", "+", "1", ",", "valid_loss", "=", "valid_loss_t", ",", "\n", "valid_acc", "=", "valid_acc_t", ")", "\n", "\n", "", "if", "valid_loss", "<", "best_loss", ":", "\n", "                ", "best_loss", "=", "valid_loss", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "print", "(", "' *'", ",", "end", "=", "''", ")", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "if", "patience", "<=", "0", ":", "\n", "                    ", "lr", "/=", "self", ".", "lr_factor", "\n", "lr_rho", "/=", "self", ".", "lr_factor", "\n", "print", "(", "' lr={:.1e}'", ".", "format", "(", "lr", ")", ",", "end", "=", "''", ")", "\n", "if", "lr", "<", "self", ".", "lr_min", ":", "\n", "                        ", "print", "(", ")", "\n", "", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ",", "lr_rho", ")", "\n", "", "", "print", "(", ")", "\n", "\n", "utils", ".", "freeze_model", "(", "self", ".", "model_old", ")", "# Freeze the weights", "\n", "\n", "\n", "# Restore best", "\n", "", "utils", ".", "set_model_", "(", "self", ".", "model", ",", "best_model", ")", "\n", "self", ".", "model_old", "=", "deepcopy", "(", "self", ".", "model", ")", "\n", "self", ".", "saved", "=", "1", "\n", "\n", "self", ".", "logger", ".", "save", "(", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ucl.Appr.train_epoch": [[141, 176], ["ucl.Appr.model.train", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "len", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "ucl.Appr.custom_regularization", "ucl.Appr.optimizer.zero_grad", "ucl.Appr.backward", "ucl.Appr.optimizer.step", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "ucl.Appr.model", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "ucl.Appr.model.parameters", "ucl.Appr.model"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.custom_regularization", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step"], ["", "def", "train_epoch", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "r", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "self", ".", "iteration", "+=", "1", "\n", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "\n", "                ", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "", "else", ":", "\n", "                ", "b", "=", "r", "[", "i", ":", "]", "\n", "", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward current model", "\n", "mini_batch_size", "=", "len", "(", "targets", ")", "\n", "\n", "if", "self", ".", "split", ":", "\n", "                ", "output", "=", "F", ".", "log_softmax", "(", "self", ".", "model", "(", "images", ",", "sample", "=", "True", ")", "[", "t", "]", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "output", "=", "self", ".", "model", "(", "images", ",", "sample", "=", "True", ")", "\n", "", "loss", "=", "F", ".", "nll_loss", "(", "output", ",", "targets", ",", "reduction", "=", "'sum'", ")", "\n", "loss", "=", "self", ".", "custom_regularization", "(", "self", ".", "model_old", ",", "self", ".", "model", ",", "mini_batch_size", ",", "loss", ")", "\n", "# Backward", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", "or", "args", ".", "optimizer", "==", "'SGD_momentum_decay'", ":", "\n", "                ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "clipgrad", ")", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ucl.Appr.eval": [[177, 214], ["ucl.Appr.model.eval", "numpy.arange", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "x.size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "range", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "len", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "ucl.Appr.max", "torch.nll_loss.data.cpu().numpy", "hits.sum().data.cpu().numpy", "len", "len", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "ucl.Appr.model", "torch.nll_loss.data.cpu", "hits.sum().data.cpu", "ucl.Appr.model", "hits.sum"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "eval", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "total_loss", "=", "0", "\n", "total_acc", "=", "0", "\n", "total_num", "=", "0", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "                ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "\n", "                    ", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "", "else", ":", "\n", "                    ", "b", "=", "r", "[", "i", ":", "]", "\n", "", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward", "\n", "mini_batch_size", "=", "len", "(", "targets", ")", "\n", "if", "self", ".", "split", ":", "\n", "                    ", "output", "=", "F", ".", "log_softmax", "(", "self", ".", "model", "(", "images", ",", "sample", "=", "False", ")", "[", "t", "]", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                    ", "output", "=", "self", ".", "model", "(", "images", ",", "sample", "=", "False", ")", "\n", "", "loss", "=", "F", ".", "nll_loss", "(", "output", ",", "targets", ",", "reduction", "=", "'sum'", ")", "\n", "\n", "_", ",", "pred", "=", "output", ".", "max", "(", "1", ")", "\n", "hits", "=", "(", "pred", "==", "targets", ")", ".", "float", "(", ")", "\n", "\n", "total_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "total_acc", "+=", "hits", ".", "sum", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "total_num", "+=", "len", "(", "b", ")", "\n", "\n", "\n", "\n", "", "", "return", "total_loss", "/", "total_num", ",", "total_acc", "/", "total_num", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ucl.Appr.criterion": [[215, 223], ["zip", "ucl.Appr.ce", "ucl.Appr.model.named_parameters", "ucl.Appr.model_old.named_parameters", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "criterion", "(", "self", ",", "t", ",", "output", ",", "targets", ")", ":", "\n", "# Regularization for all previous tasks", "\n", "        ", "loss_reg", "=", "0", "\n", "if", "t", ">", "0", ":", "\n", "            ", "for", "(", "name", ",", "param", ")", ",", "(", "_", ",", "param_old", ")", "in", "zip", "(", "self", ".", "model", ".", "named_parameters", "(", ")", ",", "self", ".", "model_old", ".", "named_parameters", "(", ")", ")", ":", "\n", "                ", "loss_reg", "+=", "torch", ".", "sum", "(", "self", ".", "fisher", "[", "name", "]", "*", "(", "param_old", "-", "param", ")", ".", "pow", "(", "2", ")", ")", "/", "2", "\n", "\n", "", "", "return", "self", ".", "ce", "(", "output", ",", "targets", ")", "+", "self", ".", "lamb", "*", "loss_reg", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ucl.Appr.custom_regularization": [[226, 326], ["zip", "torch.Parameter", "torch.Parameter", "torch.Parameter", "saver_net.named_children", "trainer_net.named_children", "bayes_layer._calculate_fan_in_and_fan_out", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "isinstance", "isinstance", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "math.sqrt", "math.sqrt", "len", "saver_weight_strength.expand", "prev_weight_strength.reshape.reshape.permute().expand", "saver_weight_strength.expand", "prev_weight_strength.reshape.reshape.permute().expand", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "isinstance", "isinstance", "len", "prev_weight_strength.reshape.reshape.reshape", "prev_weight_strength.reshape.reshape.expand", "prev_weight_strength.reshape.reshape.reshape", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "prev_weight_strength.reshape.reshape.permute", "prev_weight_strength.reshape.reshape.permute", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.baye_layer._calculate_fan_in_and_fan_out"], ["", "def", "custom_regularization", "(", "self", ",", "saver_net", ",", "trainer_net", ",", "mini_batch_size", ",", "loss", "=", "None", ")", ":", "\n", "\n", "        ", "sigma_weight_reg_sum", "=", "0", "\n", "sigma_bias_reg_sum", "=", "0", "\n", "sigma_weight_normal_reg_sum", "=", "0", "\n", "sigma_bias_normal_reg_sum", "=", "0", "\n", "mu_weight_reg_sum", "=", "0", "\n", "mu_bias_reg_sum", "=", "0", "\n", "L1_mu_weight_reg_sum", "=", "0", "\n", "L1_mu_bias_reg_sum", "=", "0", "\n", "\n", "out_features_max", "=", "512", "\n", "alpha", "=", "args", ".", "alpha", "\n", "if", "self", ".", "saved", ":", "\n", "            ", "alpha", "=", "1", "\n", "\n", "", "if", "args", ".", "conv_net", ":", "\n", "            ", "if", "args", ".", "experiment", "==", "'omniglot'", ":", "\n", "                ", "prev_weight_strength", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "1", ",", "1", ",", "1", ",", "1", ")", ".", "uniform_", "(", "0", ",", "0", ")", ")", "\n", "", "else", ":", "\n", "                ", "prev_weight_strength", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "3", ",", "1", ",", "1", ",", "1", ")", ".", "uniform_", "(", "0", ",", "0", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "prev_weight_strength", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "28", "*", "28", ",", "1", ")", ".", "uniform_", "(", "0", ",", "0", ")", ")", "\n", "\n", "", "for", "(", "_", ",", "saver_layer", ")", ",", "(", "_", ",", "trainer_layer", ")", "in", "zip", "(", "saver_net", ".", "named_children", "(", ")", ",", "trainer_net", ".", "named_children", "(", ")", ")", ":", "\n", "            ", "if", "isinstance", "(", "trainer_layer", ",", "BayesianLinear", ")", "==", "False", "and", "isinstance", "(", "trainer_layer", ",", "BayesianConv2D", ")", "==", "False", ":", "\n", "                ", "continue", "\n", "# calculate mu regularization", "\n", "", "trainer_weight_mu", "=", "trainer_layer", ".", "weight_mu", "\n", "saver_weight_mu", "=", "saver_layer", ".", "weight_mu", "\n", "trainer_bias", "=", "trainer_layer", ".", "bias", "\n", "saver_bias", "=", "saver_layer", ".", "bias", "\n", "\n", "fan_in", ",", "fan_out", "=", "_calculate_fan_in_and_fan_out", "(", "trainer_weight_mu", ")", "\n", "\n", "trainer_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "trainer_layer", ".", "weight_rho", ")", ")", "\n", "saver_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "saver_layer", ".", "weight_rho", ")", ")", "\n", "\n", "if", "isinstance", "(", "trainer_layer", ",", "BayesianLinear", ")", ":", "\n", "                ", "std_init", "=", "math", ".", "sqrt", "(", "(", "2", "/", "fan_in", ")", "*", "args", ".", "ratio", ")", "\n", "", "if", "isinstance", "(", "trainer_layer", ",", "BayesianConv2D", ")", ":", "\n", "                ", "std_init", "=", "math", ".", "sqrt", "(", "(", "2", "/", "fan_out", ")", "*", "args", ".", "ratio", ")", "\n", "\n", "", "saver_weight_strength", "=", "(", "std_init", "/", "saver_weight_sigma", ")", "\n", "\n", "if", "len", "(", "saver_weight_mu", ".", "shape", ")", "==", "4", ":", "\n", "                ", "out_features", ",", "in_features", ",", "_", ",", "_", "=", "saver_weight_mu", ".", "shape", "\n", "curr_strength", "=", "saver_weight_strength", ".", "expand", "(", "out_features", ",", "in_features", ",", "1", ",", "1", ")", "\n", "prev_strength", "=", "prev_weight_strength", ".", "permute", "(", "1", ",", "0", ",", "2", ",", "3", ")", ".", "expand", "(", "out_features", ",", "in_features", ",", "1", ",", "1", ")", "\n", "\n", "", "else", ":", "\n", "                ", "out_features", ",", "in_features", "=", "saver_weight_mu", ".", "shape", "\n", "curr_strength", "=", "saver_weight_strength", ".", "expand", "(", "out_features", ",", "in_features", ")", "\n", "if", "len", "(", "prev_weight_strength", ".", "shape", ")", "==", "4", ":", "\n", "                    ", "feature_size", "=", "in_features", "//", "(", "prev_weight_strength", ".", "shape", "[", "0", "]", ")", "\n", "prev_weight_strength", "=", "prev_weight_strength", ".", "reshape", "(", "prev_weight_strength", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "prev_weight_strength", "=", "prev_weight_strength", ".", "expand", "(", "prev_weight_strength", ".", "shape", "[", "0", "]", ",", "feature_size", ")", "\n", "prev_weight_strength", "=", "prev_weight_strength", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "", "prev_strength", "=", "prev_weight_strength", ".", "permute", "(", "1", ",", "0", ")", ".", "expand", "(", "out_features", ",", "in_features", ")", "\n", "\n", "", "L2_strength", "=", "torch", ".", "max", "(", "curr_strength", ",", "prev_strength", ")", "\n", "bias_strength", "=", "torch", ".", "squeeze", "(", "saver_weight_strength", ")", "\n", "\n", "L1_sigma", "=", "saver_weight_sigma", "\n", "bias_sigma", "=", "torch", ".", "squeeze", "(", "saver_weight_sigma", ")", "\n", "\n", "prev_weight_strength", "=", "saver_weight_strength", "\n", "\n", "mu_weight_reg", "=", "(", "L2_strength", "*", "(", "trainer_weight_mu", "-", "saver_weight_mu", ")", ")", ".", "norm", "(", "2", ")", "**", "2", "\n", "mu_bias_reg", "=", "(", "bias_strength", "*", "(", "trainer_bias", "-", "saver_bias", ")", ")", ".", "norm", "(", "2", ")", "**", "2", "\n", "\n", "L1_mu_weight_reg", "=", "(", "torch", ".", "div", "(", "saver_weight_mu", "**", "2", ",", "L1_sigma", "**", "2", ")", "*", "(", "trainer_weight_mu", "-", "saver_weight_mu", ")", ")", ".", "norm", "(", "1", ")", "\n", "L1_mu_bias_reg", "=", "(", "torch", ".", "div", "(", "saver_bias", "**", "2", ",", "bias_sigma", "**", "2", ")", "*", "(", "trainer_bias", "-", "saver_bias", ")", ")", ".", "norm", "(", "1", ")", "\n", "\n", "L1_mu_weight_reg", "=", "L1_mu_weight_reg", "*", "(", "std_init", "**", "2", ")", "\n", "L1_mu_bias_reg", "=", "L1_mu_bias_reg", "*", "(", "std_init", "**", "2", ")", "\n", "\n", "weight_sigma", "=", "(", "trainer_weight_sigma", "**", "2", "/", "saver_weight_sigma", "**", "2", ")", "\n", "\n", "normal_weight_sigma", "=", "trainer_weight_sigma", "**", "2", "\n", "\n", "sigma_weight_reg_sum", "=", "sigma_weight_reg_sum", "+", "(", "weight_sigma", "-", "torch", ".", "log", "(", "weight_sigma", ")", ")", ".", "sum", "(", ")", "\n", "sigma_weight_normal_reg_sum", "=", "sigma_weight_normal_reg_sum", "+", "(", "normal_weight_sigma", "-", "torch", ".", "log", "(", "normal_weight_sigma", ")", ")", ".", "sum", "(", ")", "\n", "\n", "mu_weight_reg_sum", "=", "mu_weight_reg_sum", "+", "mu_weight_reg", "\n", "mu_bias_reg_sum", "=", "mu_bias_reg_sum", "+", "mu_bias_reg", "\n", "L1_mu_weight_reg_sum", "=", "L1_mu_weight_reg_sum", "+", "L1_mu_weight_reg", "\n", "L1_mu_bias_reg_sum", "=", "L1_mu_bias_reg_sum", "+", "L1_mu_bias_reg", "\n", "\n", "# elbo loss", "\n", "", "loss", "=", "loss", "/", "mini_batch_size", "\n", "# L2 loss", "\n", "loss", "=", "loss", "+", "alpha", "*", "(", "mu_weight_reg_sum", "+", "mu_bias_reg_sum", ")", "/", "(", "2", "*", "mini_batch_size", ")", "\n", "# L1 loss", "\n", "loss", "=", "loss", "+", "self", ".", "saved", "*", "(", "L1_mu_weight_reg_sum", "+", "L1_mu_bias_reg_sum", ")", "/", "(", "mini_batch_size", ")", "\n", "# sigma regularization", "\n", "loss", "=", "loss", "+", "self", ".", "beta", "*", "(", "sigma_weight_reg_sum", "+", "sigma_weight_normal_reg_sum", ")", "/", "(", "2", "*", "mini_batch_size", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ewc.Appr.__init__": [[24, 50], ["utils.logger", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "ewc.Appr._get_optimizer", "len", "args.parameter.split", "print", "float"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["def", "__init__", "(", "self", ",", "model", ",", "nepochs", "=", "100", ",", "sbatch", "=", "256", ",", "lr", "=", "0.001", ",", "lr_min", "=", "1e-6", ",", "lr_factor", "=", "3", ",", "lr_patience", "=", "5", ",", "clipgrad", "=", "100", ",", "args", "=", "None", ",", "log_name", "=", "None", ",", "split", "=", "False", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "model_old", "=", "model", "\n", "self", ".", "fisher", "=", "None", "\n", "\n", "file_name", "=", "log_name", "\n", "self", ".", "logger", "=", "utils", ".", "logger", "(", "file_name", "=", "file_name", ",", "resume", "=", "False", ",", "path", "=", "'./result_data/csvdata/'", ",", "data_format", "=", "'csv'", ")", "\n", "\n", "self", ".", "nepochs", "=", "nepochs", "\n", "self", ".", "sbatch", "=", "sbatch", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "lr_min", "=", "lr_min", "\n", "self", ".", "lr_factor", "=", "lr_factor", "\n", "self", ".", "lr_patience", "=", "lr_patience", "\n", "self", ".", "clipgrad", "=", "clipgrad", "\n", "self", ".", "split", "=", "split", "\n", "\n", "self", ".", "ce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", ")", "\n", "self", ".", "lamb", "=", "args", ".", "lamb", "\n", "if", "len", "(", "args", ".", "parameter", ")", ">=", "1", ":", "\n", "            ", "params", "=", "args", ".", "parameter", ".", "split", "(", "','", ")", "\n", "print", "(", "'Setting parameters to'", ",", "params", ")", "\n", "self", ".", "lamb", "=", "float", "(", "params", "[", "0", "]", ")", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ewc.Appr._get_optimizer": [[51, 58], ["torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "ewc.Appr.model.parameters", "ewc.Appr.model.parameters"], "methods", ["None"], ["", "def", "_get_optimizer", "(", "self", ",", "lr", "=", "None", ")", ":", "\n", "        ", "if", "lr", "is", "None", ":", "lr", "=", "self", ".", "lr", "\n", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "", "if", "args", ".", "optimizer", "==", "'Adam'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "#         return torch.optim.SGD(net.parameters(), lr=lr, momentum=0.9, weight_decay=5e-4)", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ewc.Appr.train": [[60, 141], ["utils.get_model", "ewc.Appr._get_optimizer", "range", "utils.set_model_", "ewc.Appr.logger.save", "copy.deepcopy", "ewc.Appr.model_old.eval", "utils.freeze_model", "utils.fisher_matrix_diag", "time.time", "xtrain.size", "ewc.Appr.train_epoch", "time.time", "ewc.Appr.eval", "time.time", "print", "ewc.Appr.eval", "print", "ewc.Appr.logger.add", "range", "print", "ewc.Appr.model.named_parameters", "ewc.Appr.model.named_parameters", "[].cuda", "[].cuda", "ewc.Appr.eval", "ewc.Appr.logger.add", "utils.get_model", "print", "ewc.Appr.fisher[].clone", "print", "ewc.Appr._get_optimizer", "print"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.set_model_", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.freeze_model", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.fisher_matrix_diag", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train_epoch", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.add", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["", "", "def", "train", "(", "self", ",", "t", ",", "xtrain", ",", "ytrain", ",", "xvalid", ",", "yvalid", ",", "data", ",", "input_size", ",", "taskcla", ")", ":", "\n", "        ", "best_loss", "=", "np", ".", "inf", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "lr", "=", "self", ".", "lr", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "\n", "# Loop epochs", "\n", "for", "e", "in", "range", "(", "self", ".", "nepochs", ")", ":", "\n", "# Train", "\n", "            ", "clock0", "=", "time", ".", "time", "(", ")", "\n", "\n", "# CUB 200 xtrain_cropped = crop(x_train)", "\n", "num_batch", "=", "xtrain", ".", "size", "(", "0", ")", "\n", "\n", "self", ".", "train_epoch", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "\n", "clock1", "=", "time", ".", "time", "(", ")", "\n", "train_loss", ",", "train_acc", "=", "self", ".", "eval", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "clock2", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "\n", "e", "+", "1", ",", "1000", "*", "self", ".", "sbatch", "*", "(", "clock1", "-", "clock0", ")", "/", "num_batch", ",", "\n", "1000", "*", "self", ".", "sbatch", "*", "(", "clock2", "-", "clock1", ")", "/", "num_batch", ",", "train_loss", ",", "100", "*", "train_acc", ")", ",", "end", "=", "''", ")", "\n", "# Valid", "\n", "valid_loss", ",", "valid_acc", "=", "self", ".", "eval", "(", "t", ",", "xvalid", ",", "yvalid", ")", "\n", "print", "(", "' Valid: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "valid_loss", ",", "100", "*", "valid_acc", ")", ",", "end", "=", "''", ")", "\n", "\n", "#save log for current task & old tasks at every epoch", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "t", "+", "1", ",", "valid_loss", "=", "valid_loss", ",", "valid_acc", "=", "valid_acc", ")", "\n", "for", "task", "in", "range", "(", "t", ")", ":", "\n", "                ", "xvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'x'", "]", ".", "cuda", "(", ")", "\n", "\n", "yvalid_t", "=", "data", "[", "task", "]", "[", "'valid'", "]", "[", "'y'", "]", ".", "cuda", "(", ")", "\n", "\n", "valid_loss_t", ",", "valid_acc_t", "=", "self", ".", "eval", "(", "task", ",", "xvalid_t", ",", "yvalid_t", ")", "\n", "self", ".", "logger", ".", "add", "(", "epoch", "=", "(", "t", "*", "self", ".", "nepochs", ")", "+", "e", ",", "task_num", "=", "task", "+", "1", ",", "valid_loss", "=", "valid_loss_t", ",", "valid_acc", "=", "valid_acc_t", ")", "\n", "\n", "# Adapt lr", "\n", "", "if", "valid_loss", "<", "best_loss", ":", "\n", "                ", "best_loss", "=", "valid_loss", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "print", "(", "' *'", ",", "end", "=", "''", ")", "\n", "\n", "", "else", ":", "\n", "                ", "patience", "-=", "1", "\n", "if", "patience", "<=", "0", ":", "\n", "                    ", "lr", "/=", "self", ".", "lr_factor", "\n", "print", "(", "' lr={:.1e}'", ".", "format", "(", "lr", ")", ",", "end", "=", "''", ")", "\n", "if", "lr", "<", "self", ".", "lr_min", ":", "\n", "                        ", "print", "(", ")", "\n", "if", "args", ".", "conv_net", ":", "\n", "                            ", "pass", "\n", "#                             break", "\n", "", "", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "", "", "print", "(", ")", "\n", "\n", "# Restore best", "\n", "", "utils", ".", "set_model_", "(", "self", ".", "model", ",", "best_model", ")", "\n", "\n", "self", ".", "logger", ".", "save", "(", ")", "\n", "\n", "# Update old", "\n", "self", ".", "model_old", "=", "deepcopy", "(", "self", ".", "model", ")", "\n", "self", ".", "model_old", ".", "eval", "(", ")", "\n", "utils", ".", "freeze_model", "(", "self", ".", "model_old", ")", "# Freeze the weights", "\n", "\n", "# Fisher ops", "\n", "if", "t", ">", "0", ":", "\n", "            ", "fisher_old", "=", "{", "}", "\n", "for", "n", ",", "_", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                ", "fisher_old", "[", "n", "]", "=", "self", ".", "fisher", "[", "n", "]", ".", "clone", "(", ")", "\n", "", "", "self", ".", "fisher", "=", "utils", ".", "fisher_matrix_diag", "(", "t", ",", "xtrain", ",", "ytrain", ",", "self", ".", "model", ",", "self", ".", "criterion", ",", "split", "=", "self", ".", "split", ")", "\n", "if", "t", ">", "0", ":", "\n", "# Watch out! We do not want to keep t models (or fisher diagonals) in memory, therefore we have to merge fisher diagonals", "\n", "            ", "for", "n", ",", "_", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                ", "self", ".", "fisher", "[", "n", "]", "=", "(", "self", ".", "fisher", "[", "n", "]", "+", "fisher_old", "[", "n", "]", "*", "t", ")", "/", "(", "t", "+", "1", ")", "# Checked: it is better than the other option", "\n", "#self.fisher[n]=0.5*(self.fisher[n]+fisher_old[n])", "\n", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ewc.Appr.train_epoch": [[142, 171], ["ewc.Appr.model.train", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "ewc.Appr.criterion", "ewc.Appr.optimizer.zero_grad", "ewc.Appr.backward", "ewc.Appr.optimizer.step", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "ewc.Appr.model.forward", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "ewc.Appr.model.forward", "ewc.Appr.model.parameters"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward"], ["", "def", "train_epoch", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "r", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward current model", "\n", "if", "self", ".", "split", ":", "\n", "                ", "outputs", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "                ", "outputs", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "\n", "", "loss", "=", "self", ".", "criterion", "(", "t", ",", "outputs", ",", "targets", ")", "\n", "\n", "# Backward", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", "or", "args", ".", "optimizer", "==", "'SGD_momentum_decay'", ":", "\n", "                ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "clipgrad", ")", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ewc.Appr.eval": [[172, 206], ["ewc.Appr.model.eval", "numpy.arange", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "ewc.Appr.criterion", "ewc.Appr.max", "hits.sum().data.cpu().numpy", "len", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "ewc.Appr.model.forward", "ewc.Appr.data.cpu().numpy", "len", "ewc.Appr.model.forward", "hits.sum().data.cpu", "ewc.Appr.data.cpu", "hits.sum"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward"], ["", "def", "eval", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "total_loss", "=", "0", "\n", "total_acc", "=", "0", "\n", "total_num", "=", "0", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "x", "[", "b", "]", "\n", "targets", "=", "y", "[", "b", "]", "\n", "\n", "# Forward", "\n", "if", "self", ".", "split", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "[", "t", "]", "\n", "", "else", ":", "\n", "                ", "output", "=", "self", ".", "model", ".", "forward", "(", "images", ")", "\n", "\n", "", "loss", "=", "self", ".", "criterion", "(", "t", ",", "output", ",", "targets", ")", "\n", "_", ",", "pred", "=", "output", ".", "max", "(", "1", ")", "\n", "hits", "=", "(", "pred", "==", "targets", ")", ".", "float", "(", ")", "\n", "\n", "# Log", "\n", "#             total_loss+=loss.data.cpu().numpy()[0]*len(b)", "\n", "#             total_acc+=hits.sum().data.cpu().numpy()[0]", "\n", "total_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "len", "(", "b", ")", "\n", "total_acc", "+=", "hits", ".", "sum", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "total_num", "+=", "len", "(", "b", ")", "\n", "\n", "", "return", "total_loss", "/", "total_num", ",", "total_acc", "/", "total_num", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ewc.Appr.criterion": [[207, 218], ["zip", "ewc.Appr.ce", "ewc.Appr.model.named_parameters", "ewc.Appr.model_old.named_parameters", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "criterion", "(", "self", ",", "t", ",", "output", ",", "targets", ")", ":", "\n", "# Regularization for all previous tasks", "\n", "        ", "loss_reg", "=", "0", "\n", "if", "t", ">", "0", ":", "\n", "            ", "for", "(", "name", ",", "param", ")", ",", "(", "_", ",", "param_old", ")", "in", "zip", "(", "self", ".", "model", ".", "named_parameters", "(", ")", ",", "self", ".", "model_old", ".", "named_parameters", "(", ")", ")", ":", "\n", "#                 if name.startswith('last'):", "\n", "#                     if not args.no_outputreg:", "\n", "#                         loss_reg+=torch.sum(self.fisher[name]*(param_old-param).pow(2))/2", "\n", "#                 else:", "\n", "                ", "loss_reg", "+=", "torch", ".", "sum", "(", "self", ".", "fisher", "[", "name", "]", "*", "(", "param_old", "-", "param", ")", ".", "pow", "(", "2", ")", ")", "/", "2", "\n", "", "", "return", "self", ".", "ce", "(", "output", ",", "targets", ")", "+", "self", ".", "lamb", "*", "loss_reg", "\n", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat.Appr.__init__": [[22, 52], ["utils.logger", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "hat.Appr._get_optimizer", "len", "args.parameter.split", "print", "float", "float"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "nepochs", "=", "100", ",", "sbatch", "=", "256", ",", "lr", "=", "0.05", ",", "lr_min", "=", "1e-4", ",", "lr_factor", "=", "3", ",", "\n", "lr_patience", "=", "5", ",", "clipgrad", "=", "10000", ",", "lamb", "=", "0.75", ",", "smax", "=", "400", ",", "args", "=", "None", ",", "log_name", "=", "None", ",", "split", "=", "False", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "\n", "self", ".", "nepochs", "=", "nepochs", "\n", "self", ".", "sbatch", "=", "sbatch", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "lr_min", "=", "lr_min", "\n", "self", ".", "lr_factor", "=", "lr_factor", "\n", "self", ".", "lr_patience", "=", "lr_patience", "\n", "self", ".", "clipgrad", "=", "clipgrad", "\n", "\n", "file_name", "=", "log_name", "\n", "self", ".", "logger", "=", "utils", ".", "logger", "(", "file_name", "=", "file_name", ",", "resume", "=", "False", ",", "path", "=", "'./result_data/csvdata/'", ",", "data_format", "=", "'csv'", ")", "\n", "\n", "self", ".", "ce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", ")", "\n", "\n", "self", ".", "lamb", "=", "args", ".", "gamma", "# Grid search = [0.1, 0.25, 0.5, 0.75, 1, 1.5, 2.5, 4]; chosen was 0.75", "\n", "self", ".", "smax", "=", "args", ".", "smax", "# Grid search = [25, 50, 100, 200, 400, 800]; chosen was 400", "\n", "if", "len", "(", "args", ".", "parameter", ")", ">=", "1", ":", "\n", "            ", "params", "=", "args", ".", "parameter", ".", "split", "(", "','", ")", "\n", "print", "(", "'Setting parameters to'", ",", "params", ")", "\n", "self", ".", "lamb", "=", "float", "(", "params", "[", "0", "]", ")", "\n", "self", ".", "smax", "=", "float", "(", "params", "[", "1", "]", ")", "\n", "\n", "", "self", ".", "mask_pre", "=", "None", "\n", "self", ".", "mask_back", "=", "None", "\n", "self", ".", "split", "=", "split", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat.Appr._get_optimizer": [[53, 59], ["torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "hat.Appr.model.parameters", "hat.Appr.model.parameters"], "methods", ["None"], ["", "def", "_get_optimizer", "(", "self", ",", "lr", "=", "None", ")", ":", "\n", "        ", "if", "lr", "is", "None", ":", "lr", "=", "self", ".", "lr", "\n", "if", "args", ".", "optimizer", "==", "'SGD'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "", "if", "args", ".", "optimizer", "==", "'Adam'", ":", "\n", "            ", "return", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat.Appr.train": [[60, 126], ["utils.get_model", "hat.Appr._get_optimizer", "utils.set_model_", "hat.Appr.logger.save", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "hat.Appr.model.mask", "range", "hat.Appr.model.named_parameters", "range", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "len", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "range", "hat.Appr.model.get_view_for", "time.time", "hat.Appr.train_epoch", "time.time", "hat.Appr.eval", "time.time", "print", "hat.Appr.eval", "print", "print", "print", "mask[].data.clone", "len", "torch.max", "torch.max", "torch.max", "torch.max", "utils.get_model", "print", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "print", "hat.Appr._get_optimizer", "xtrain.size", "xtrain.size", "print"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.set_model_", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.logger.save", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.mask", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.get_view_for", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train_epoch", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "", "def", "train", "(", "self", ",", "t", ",", "xtrain", ",", "ytrain", ",", "xvalid", ",", "yvalid", ",", "data", ",", "inputsize", ",", "taskcla", ")", ":", "\n", "        ", "best_loss", "=", "np", ".", "inf", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "lr", "=", "self", ".", "lr", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "\n", "# Loop epochs", "\n", "try", ":", "\n", "            ", "for", "e", "in", "range", "(", "self", ".", "nepochs", ")", ":", "\n", "# Train", "\n", "                ", "clock0", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "train_epoch", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "clock1", "=", "time", ".", "time", "(", ")", "\n", "train_loss", ",", "train_acc", "=", "self", ".", "eval", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "clock2", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "e", "+", "1", ",", "\n", "1000", "*", "self", ".", "sbatch", "*", "(", "clock1", "-", "clock0", ")", "/", "xtrain", ".", "size", "(", "0", ")", ",", "1000", "*", "self", ".", "sbatch", "*", "(", "clock2", "-", "clock1", ")", "/", "xtrain", ".", "size", "(", "0", ")", ",", "train_loss", ",", "100", "*", "train_acc", ")", ",", "end", "=", "''", ")", "\n", "# Valid", "\n", "valid_loss", ",", "valid_acc", "=", "self", ".", "eval", "(", "t", ",", "xvalid", ",", "yvalid", ")", "\n", "print", "(", "' Valid: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "valid_loss", ",", "100", "*", "valid_acc", ")", ",", "end", "=", "''", ")", "\n", "# Adapt lr", "\n", "if", "valid_loss", "<", "best_loss", ":", "\n", "                    ", "best_loss", "=", "valid_loss", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "print", "(", "' *'", ",", "end", "=", "''", ")", "\n", "", "else", ":", "\n", "                    ", "patience", "-=", "1", "\n", "if", "patience", "<=", "0", ":", "\n", "                        ", "lr", "/=", "self", ".", "lr_factor", "\n", "print", "(", "' lr={:.1e}'", ".", "format", "(", "lr", ")", ",", "end", "=", "''", ")", "\n", "if", "lr", "<", "self", ".", "lr_min", ":", "\n", "                            ", "print", "(", ")", "\n", "if", "args", ".", "conv_net", ":", "\n", "                                ", "pass", "\n", "#                                 break", "\n", "", "", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "", "", "print", "(", ")", "\n", "", "", "except", "KeyboardInterrupt", ":", "\n", "            ", "print", "(", ")", "\n", "\n", "# Restore best validation model", "\n", "", "utils", ".", "set_model_", "(", "self", ".", "model", ",", "best_model", ")", "\n", "self", ".", "logger", ".", "save", "(", ")", "\n", "# Activations mask", "\n", "#         task=torch.autograd.Variable(torch.LongTensor([t]).cuda(),volatile=False)", "\n", "task", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "t", "]", ")", ".", "cuda", "(", ")", ")", "\n", "mask", "=", "self", ".", "model", ".", "mask", "(", "task", ",", "s", "=", "self", ".", "smax", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "mask", ")", ")", ":", "\n", "            ", "mask", "[", "i", "]", "=", "torch", ".", "autograd", ".", "Variable", "(", "mask", "[", "i", "]", ".", "data", ".", "clone", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "", "if", "t", "==", "0", ":", "\n", "            ", "self", ".", "mask_pre", "=", "mask", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "mask_pre", ")", ")", ":", "\n", "                ", "self", ".", "mask_pre", "[", "i", "]", "=", "torch", ".", "max", "(", "self", ".", "mask_pre", "[", "i", "]", ",", "mask", "[", "i", "]", ")", "\n", "\n", "# Weights mask", "\n", "", "", "self", ".", "mask_back", "=", "{", "}", "\n", "for", "n", ",", "_", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "vals", "=", "self", ".", "model", ".", "get_view_for", "(", "n", ",", "self", ".", "mask_pre", ")", "\n", "if", "vals", "is", "not", "None", ":", "\n", "                ", "self", ".", "mask_back", "[", "n", "]", "=", "1", "-", "vals", "\n", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat.Appr.train_epoch": [[127, 185], ["hat.Appr.model.train", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "x.size", "len", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "hat.Appr.model.forward", "hat.Appr.criterion", "hat.Appr.optimizer.zero_grad", "loss.backward", "hat.Appr.model.named_parameters", "hat.Appr.optimizer.step", "hat.Appr.model.named_parameters", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "hat.Appr.model.named_parameters", "n.startswith", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "torch.nn.utils.clip_grad_norm", "n.startswith", "len", "hat.Appr.model.parameters", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.cosh", "torch.cosh", "torch.cosh", "torch.cosh", "torch.cosh", "torch.cosh", "torch.cosh", "torch.cosh", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step"], ["", "def", "train_epoch", "(", "self", ",", "t", ",", "x", ",", "y", ",", "thres_cosh", "=", "50", ",", "thres_emb", "=", "6", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "r", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "#             images=torch.autograd.Variable(x[b],volatile=False)", "\n", "#             targets=torch.autograd.Variable(y[b],volatile=False)", "\n", "#             task=torch.autograd.Variable(torch.LongTensor([t]).cuda(),volatile=False)", "\n", "images", "=", "torch", ".", "autograd", ".", "Variable", "(", "x", "[", "b", "]", ")", "\n", "targets", "=", "torch", ".", "autograd", ".", "Variable", "(", "y", "[", "b", "]", ")", "\n", "task", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "t", "]", ")", ".", "cuda", "(", ")", ")", "\n", "s", "=", "(", "self", ".", "smax", "-", "1", "/", "self", ".", "smax", ")", "*", "i", "/", "len", "(", "r", ")", "+", "1", "/", "self", ".", "smax", "\n", "\n", "# Forward", "\n", "output", ",", "masks", "=", "self", ".", "model", ".", "forward", "(", "task", ",", "images", ",", "s", "=", "s", ")", "\n", "if", "self", ".", "split", ":", "\n", "                ", "output", "=", "output", "[", "t", "]", "\n", "", "loss", ",", "_", "=", "self", ".", "criterion", "(", "output", ",", "targets", ",", "masks", ")", "\n", "\n", "# Backward", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# Restrict layer gradients in backprop", "\n", "if", "t", ">", "0", ":", "\n", "                ", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                    ", "if", "n", "in", "self", ".", "mask_back", ":", "\n", "                        ", "p", ".", "grad", ".", "data", "*=", "self", ".", "mask_back", "[", "n", "]", "\n", "\n", "# Compensate embedding gradients", "\n", "", "", "", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                ", "if", "n", ".", "startswith", "(", "'e'", ")", ":", "\n", "                    ", "num", "=", "torch", ".", "cosh", "(", "torch", ".", "clamp", "(", "s", "*", "p", ".", "data", ",", "-", "thres_cosh", ",", "thres_cosh", ")", ")", "+", "1", "\n", "den", "=", "torch", ".", "cosh", "(", "p", ".", "data", ")", "+", "1", "\n", "p", ".", "grad", ".", "data", "*=", "self", ".", "smax", "/", "s", "*", "num", "/", "den", "\n", "\n", "# Apply step", "\n", "", "", "if", "args", ".", "optimizer", "==", "'SGD'", "or", "args", ".", "optimizer", "==", "'SGD_momentum_decay'", ":", "\n", "                ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "clipgrad", ")", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Constrain embeddings", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                ", "if", "n", ".", "startswith", "(", "'e'", ")", ":", "\n", "                    ", "p", ".", "data", "=", "torch", ".", "clamp", "(", "p", ".", "data", ",", "-", "thres_emb", ",", "thres_emb", ")", "\n", "\n", "#print(masks[-1].data.view(1,-1))", "\n", "#if i>=5*self.sbatch: sys.exit()", "\n", "#if i==0: print(masks[-2].data.view(1,-1),masks[-2].data.max(),masks[-2].data.min())", "\n", "#print(masks[-2].data.view(1,-1))", "\n", "\n", "", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat.Appr.eval": [[186, 227], ["hat.Appr.model.eval", "numpy.arange", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "range", "print", "x.size", "len", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "hat.Appr.model.forward", "hat.Appr.criterion", "output.max", "hits.sum().data.cpu().numpy().item", "len", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "len", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "loss.data.cpu().numpy().item", "len", "reg.data.cpu().numpy().item", "len", "hits.sum().data.cpu().numpy", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "loss.data.cpu().numpy", "reg.data.cpu().numpy", "hits.sum().data.cpu", "loss.data.cpu", "reg.data.cpu", "hits.sum"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion"], ["", "def", "eval", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "total_loss", "=", "0", "\n", "total_acc", "=", "0", "\n", "total_num", "=", "0", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "total_reg", "=", "0", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "#             images=torch.autograd.Variable(x[b],volatile=True)", "\n", "#             targets=torch.autograd.Variable(y[b],volatile=True)", "\n", "#             task=torch.autograd.Variable(torch.LongTensor([t]).cuda(),volatile=True)", "\n", "images", "=", "torch", ".", "autograd", ".", "Variable", "(", "x", "[", "b", "]", ")", "\n", "targets", "=", "torch", ".", "autograd", ".", "Variable", "(", "y", "[", "b", "]", ")", "\n", "task", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "t", "]", ")", ".", "cuda", "(", ")", ")", "\n", "\n", "\n", "\n", "# Forward", "\n", "output", ",", "masks", "=", "self", ".", "model", ".", "forward", "(", "task", ",", "images", ",", "s", "=", "self", ".", "smax", ")", "\n", "if", "self", ".", "split", ":", "\n", "                ", "output", "=", "output", "[", "t", "]", "\n", "", "loss", ",", "reg", "=", "self", ".", "criterion", "(", "output", ",", "targets", ",", "masks", ")", "\n", "_", ",", "pred", "=", "output", ".", "max", "(", "1", ")", "\n", "hits", "=", "(", "pred", "==", "targets", ")", ".", "float", "(", ")", "\n", "\n", "# Log", "\n", "total_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "*", "len", "(", "b", ")", "\n", "total_acc", "+=", "hits", ".", "sum", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "\n", "total_num", "+=", "len", "(", "b", ")", "\n", "total_reg", "+=", "reg", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "*", "len", "(", "b", ")", "\n", "\n", "", "print", "(", "'  {:.3f}  '", ".", "format", "(", "total_reg", "/", "total_num", ")", ",", "end", "=", "''", ")", "\n", "\n", "return", "total_loss", "/", "total_num", ",", "total_acc", "/", "total_num", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat.Appr.criterion": [[228, 242], ["zip", "aux.sum", "m.sum", "numpy.prod().item", "hat.Appr.ce", "numpy.prod", "m.size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "criterion", "(", "self", ",", "outputs", ",", "targets", ",", "masks", ")", ":", "\n", "        ", "reg", "=", "0", "\n", "count", "=", "0", "\n", "if", "self", ".", "mask_pre", "is", "not", "None", ":", "\n", "            ", "for", "m", ",", "mp", "in", "zip", "(", "masks", ",", "self", ".", "mask_pre", ")", ":", "\n", "                ", "aux", "=", "1", "-", "mp", "\n", "reg", "+=", "(", "m", "*", "aux", ")", ".", "sum", "(", ")", "\n", "count", "+=", "aux", ".", "sum", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "m", "in", "masks", ":", "\n", "                ", "reg", "+=", "m", ".", "sum", "(", ")", "\n", "count", "+=", "np", ".", "prod", "(", "m", ".", "size", "(", ")", ")", ".", "item", "(", ")", "\n", "", "", "reg", "/=", "count", "\n", "return", "self", ".", "ce", "(", "outputs", ",", "targets", ")", "+", "self", ".", "lamb", "*", "reg", ",", "reg", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.__init__": [[13, 59], ["torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "print", "print", "print", "print", "actor_critic.parameters"], "methods", ["None"], ["class", "PPO_UCL", "(", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "\n", "actor_critic", ",", "\n", "clip_param", ",", "\n", "ppo_epoch", ",", "\n", "num_mini_batch", ",", "\n", "value_loss_coef", ",", "\n", "entropy_coef", ",", "\n", "lr", "=", "None", ",", "\n", "eps", "=", "None", ",", "\n", "max_grad_norm", "=", "None", ",", "\n", "use_clipped_value_loss", "=", "True", ",", "\n", "conv_net", "=", "False", ",", "\n", "beta", "=", "0.03", ",", "\n", "rho_init", "=", "-", "2.783", ",", "\n", ")", ":", "\n", "\n", "        ", "self", ".", "actor_critic", "=", "actor_critic", "\n", "self", ".", "old_actor_critic", "=", "deepcopy", "(", "self", ".", "actor_critic", ")", "\n", "\n", "self", ".", "conv_net", "=", "conv_net", "\n", "\n", "self", ".", "clip_param", "=", "clip_param", "\n", "self", ".", "ppo_epoch", "=", "ppo_epoch", "\n", "self", ".", "num_mini_batch", "=", "num_mini_batch", "\n", "\n", "self", ".", "value_loss_coef", "=", "value_loss_coef", "\n", "self", ".", "entropy_coef", "=", "entropy_coef", "\n", "\n", "self", ".", "max_grad_norm", "=", "max_grad_norm", "\n", "self", ".", "use_clipped_value_loss", "=", "use_clipped_value_loss", "\n", "\n", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "actor_critic", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "eps", "=", "eps", ")", "\n", "\n", "self", ".", "num_mini_batch", "=", "num_mini_batch", "\n", "self", ".", "saved", "=", "0", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "rho", "=", "rho_init", "\n", "\n", "print", "(", "'beta : '", ",", "self", ".", "beta", ")", "\n", "print", "(", "'rho : '", ",", "self", ".", "rho", ")", "\n", "\n", "", "def", "update", "(", "self", ",", "rollouts", ",", "task_num", ",", "sample_flag", "=", "True", ",", "sample_num", "=", "1", ")", ":", "\n", "        ", "advantages", "=", "rollouts", ".", "returns", "[", ":", "-", "1", "]", "-", "rollouts", ".", "value_preds", "[", ":", "-", "1", "]", "\n", "advantages", "=", "(", "advantages", "-", "advantages", ".", "mean", "(", ")", ")", "/", "(", "\n", "advantages", ".", "std", "(", ")", "+", "1e-5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.update": [[60, 125], ["range", "advantages.mean", "advantages.std", "rollouts.recurrent_generator", "rollouts.feed_forward_generator", "ppo_ucl.PPO_UCL.actor_critic.evaluate_actions", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "ppo_ucl.PPO_UCL.optimizer.zero_grad", "ppo_ucl.PPO_UCL.custom_regularization", "loss.backward", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "ppo_ucl.PPO_UCL.optimizer.step", "value_loss.item", "action_loss.item", "dist_entropy.item", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "torch.min().mean", "ppo_ucl.PPO_UCL.actor_critic.parameters", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.recurrent_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.storage.RolloutStorage.feed_forward_generator", "home.repos.pwc.inspect_result.hhihn_HVCL.rl_module.ppo_model.Policy.evaluate_actions", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.custom_regularization", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step"], ["value_loss_epoch", "=", "0", "\n", "action_loss_epoch", "=", "0", "\n", "dist_entropy_epoch", "=", "0", "\n", "\n", "for", "e", "in", "range", "(", "self", ".", "ppo_epoch", ")", ":", "\n", "            ", "if", "self", ".", "actor_critic", ".", "is_recurrent", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "recurrent_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "", "else", ":", "\n", "                ", "data_generator", "=", "rollouts", ".", "feed_forward_generator", "(", "\n", "advantages", ",", "self", ".", "num_mini_batch", ")", "\n", "\n", "", "for", "sample", "in", "data_generator", ":", "\n", "                ", "obs_batch", ",", "recurrent_hidden_states_batch", ",", "actions_batch", ",", "value_preds_batch", ",", "return_batch", ",", "masks_batch", ",", "old_action_log_probs_batch", ",", "adv_targ", "=", "sample", "\n", "\n", "# Reshape to do in a single forward pass for all steps", "\n", "values", ",", "action_log_probs", ",", "dist_entropy", ",", "_", "=", "self", ".", "actor_critic", ".", "evaluate_actions", "(", "\n", "inputs", "=", "obs_batch", ",", "rnn_hxs", "=", "recurrent_hidden_states_batch", ",", "masks", "=", "masks_batch", ",", "\n", "action", "=", "actions_batch", ",", "task_num", "=", "task_num", ")", "\n", "\n", "ratio", "=", "torch", ".", "exp", "(", "action_log_probs", "-", "\n", "old_action_log_probs_batch", ")", "\n", "surr1", "=", "ratio", "*", "adv_targ", "\n", "surr2", "=", "torch", ".", "clamp", "(", "ratio", ",", "1.0", "-", "self", ".", "clip_param", ",", "\n", "1.0", "+", "self", ".", "clip_param", ")", "*", "adv_targ", "\n", "action_loss", "=", "-", "torch", ".", "min", "(", "surr1", ",", "surr2", ")", ".", "mean", "(", ")", "\n", "\n", "if", "self", ".", "use_clipped_value_loss", ":", "\n", "                    ", "value_pred_clipped", "=", "value_preds_batch", "+", "(", "values", "-", "value_preds_batch", ")", ".", "clamp", "(", "-", "self", ".", "clip_param", ",", "self", ".", "clip_param", ")", "\n", "value_losses", "=", "(", "values", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_losses_clipped", "=", "(", "\n", "value_pred_clipped", "-", "return_batch", ")", ".", "pow", "(", "2", ")", "\n", "value_loss", "=", "0.5", "*", "torch", ".", "max", "(", "value_losses", ",", "\n", "value_losses_clipped", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                    ", "value_loss", "=", "0.5", "*", "(", "return_batch", "-", "values", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "reg_loss", "=", "self", ".", "custom_regularization", "(", "self", ".", "num_mini_batch", ")", "\n", "loss", "=", "value_loss", "*", "self", ".", "value_loss_coef", "+", "action_loss", "-", "dist_entropy", "*", "self", ".", "entropy_coef", "+", "reg_loss", "\n", "loss", ".", "backward", "(", ")", "\n", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "actor_critic", ".", "parameters", "(", ")", ",", "\n", "self", ".", "max_grad_norm", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "value_loss_epoch", "+=", "value_loss", ".", "item", "(", ")", "\n", "action_loss_epoch", "+=", "action_loss", ".", "item", "(", ")", "\n", "dist_entropy_epoch", "+=", "dist_entropy", ".", "item", "(", ")", "\n", "\n", "", "", "num_updates", "=", "self", ".", "ppo_epoch", "*", "self", ".", "num_mini_batch", "\n", "\n", "value_loss_epoch", "/=", "num_updates", "\n", "action_loss_epoch", "/=", "num_updates", "\n", "dist_entropy_epoch", "/=", "num_updates", "\n", "\n", "return", "value_loss_epoch", ",", "action_loss_epoch", ",", "dist_entropy_epoch", "\n", "\n", "", "def", "update_saved", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "saved", "=", "1", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.update_saved": [[126, 130], ["None"], "methods", ["None"], ["", "def", "update_old_actor_critic", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "old_actor_critic", "=", "deepcopy", "(", "self", ".", "actor_critic", ")", "\n", "\n", "", "def", "custom_regularization", "(", "self", ",", "mini_batch_size", ")", ":", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.update_old_actor_critic": [[131, 134], ["copy.deepcopy"], "methods", ["None"], ["\n", "        ", "sigma_weight_reg_sum", "=", "0", "\n", "sigma_bias_reg_sum", "=", "0", "\n", "mu_weight_reg_sum", "=", "0", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.ppo_ucl.PPO_UCL.custom_regularization": [[135, 223], ["zip", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "torch.log1p().cuda", "ppo_ucl.PPO_UCL.old_actor_critic.named_children", "ppo_ucl.PPO_UCL.actor_critic.named_children", "zip", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "torch.Tensor().uniform_", "saver_module.named_children", "trainer_module.named_children", "isinstance", "isinstance", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "isinstance", "isinstance", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p", "torch.log1p.expand", "torch.log1p.expand", "torch.log1p.expand", "torch.log1p.expand", "torch.log1p().cuda.expand", "torch.log1p().cuda.expand", "torch.log1p().cuda.expand", "torch.log1p().cuda.expand", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "numpy.log", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "torch.div().norm", "numpy.exp", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.div", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm", "home.repos.pwc.inspect_result.hhihn_HVCL.None.DenseMoVE.DenseMoVE.norm"], ["mu_bias_reg_sum", "=", "0", "\n", "L1_mu_weight_reg_sum", "=", "0", "\n", "L1_mu_bias_reg_sum", "=", "0", "\n", "#", "\n", "if", "self", ".", "conv_net", ":", "\n", "            ", "prev_rho", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "actor_critic", ".", "num_inputs", ")", ".", "uniform_", "(", "1", ",", "1", ")", ")", "\n", "prev_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "prev_rho", ")", ")", "\n", "\n", "if", "isinstance", "(", "self", ".", "old_actor_critic", ".", "base", ",", "CNNBase", ")", "==", "False", "or", "isinstance", "(", "self", ".", "actor_critic", ".", "base", ",", "\n", "CNNBase", ")", "==", "False", ":", "\n", "                ", "return", "\n", "\n", "", "", "else", ":", "\n", "            ", "prev_rho", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "actor_critic", ".", "num_inputs", ")", ".", "uniform_", "(", "1", ",", "1", ")", ")", "\n", "prev_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "prev_rho", ")", ")", ".", "cuda", "(", ")", "\n", "if", "not", "(", "isinstance", "(", "self", ".", "old_actor_critic", ".", "base", ",", "MLPBase", ")", "and", "isinstance", "(", "self", ".", "actor_critic", ".", "base", ",", "MLPBase", ")", ")", ":", "\n", "                ", "return", "\n", "\n", "", "", "for", "(", "module_name", ",", "saver_module", ")", ",", "(", "_", ",", "trainer_module", ")", "in", "zip", "(", "self", ".", "old_actor_critic", ".", "named_children", "(", ")", ",", "\n", "self", ".", "actor_critic", ".", "named_children", "(", ")", ")", ":", "\n", "            ", "for", "(", "layer_name", ",", "saver_layer", ")", ",", "(", "_", ",", "trainer_layer", ")", "in", "zip", "(", "saver_module", ".", "named_children", "(", ")", ",", "\n", "trainer_module", ".", "named_children", "(", ")", ")", ":", "\n", "\n", "                ", "if", "not", "(", "(", "(", "layer_name", "==", "'critic_linear'", ")", "or", "(", "module_name", "==", "'dist'", ")", ")", ")", ":", "\n", "\n", "# calculate mu regularization", "\n", "                    ", "trainer_weight_mu", "=", "trainer_layer", ".", "weight_mu", "\n", "saver_weight_mu", "=", "saver_layer", ".", "weight_mu", "\n", "# trainer_bias_mu = trainer_layer.bias_mu", "\n", "# saver_bias_mu = saver_layer.bias_mu", "\n", "\n", "trainer_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "trainer_layer", ".", "weight_rho", ")", ")", "\n", "saver_weight_sigma", "=", "torch", ".", "log1p", "(", "torch", ".", "exp", "(", "saver_layer", ".", "weight_rho", ")", ")", "\n", "# trainer_bias_sigma = torch.log1p(torch.exp(trainer_layer.bias_rho))", "\n", "# saver_bias_sigma = torch.log1p(torch.exp(saver_layer.bias_rho))", "\n", "\n", "out_features", ",", "in_features", "=", "saver_weight_mu", ".", "shape", "\n", "curr_sigma", "=", "saver_weight_sigma", ".", "expand", "(", "out_features", ",", "in_features", ")", "\n", "prev_sigma", "=", "prev_weight_sigma", ".", "expand", "(", "out_features", ",", "in_features", ")", "\n", "\n", "L1_sigma", "=", "saver_weight_sigma", "\n", "L2_sigma", "=", "torch", ".", "min", "(", "curr_sigma", ",", "prev_sigma", ")", "\n", "prev_weight_sigma", "=", "saver_weight_sigma", "\n", "\n", "mu_weight_reg", "=", "(", "torch", ".", "div", "(", "trainer_weight_mu", "-", "saver_weight_mu", ",", "L2_sigma", ")", ")", ".", "norm", "(", "2", ")", "**", "2", "\n", "# mu_bias_reg = (torch.div(trainer_bias_mu-saver_bias_mu, saver_bias_sigma)).norm(2)**2", "\n", "\n", "L1_mu_weight_reg", "=", "(", "torch", ".", "div", "(", "saver_weight_mu", "**", "2", ",", "L1_sigma", "**", "2", ")", "*", "(", "trainer_weight_mu", "-", "saver_weight_mu", ")", ")", ".", "norm", "(", "1", ")", "\n", "# L1_mu_bias_reg = (torch.div(saver_bias_mu**2,saver_bias_sigma**2)*(trainer_bias_mu - saver_bias_mu)).norm(1)", "\n", "\n", "std_init", "=", "np", ".", "log", "(", "1", "+", "np", ".", "exp", "(", "self", ".", "rho", ")", ")", "\n", "\n", "mu_weight_reg", "=", "mu_weight_reg", "*", "(", "std_init", "**", "2", ")", "\n", "# mu_bias_reg = mu_bias_reg * (std_init ** 2)", "\n", "L1_mu_weight_reg", "=", "L1_mu_weight_reg", "*", "(", "std_init", "**", "2", ")", "\n", "# L1_mu_bias_reg = L1_mu_bias_reg * (std_init ** 2)", "\n", "\n", "weight_sigma", "=", "trainer_weight_sigma", "**", "2", "/", "saver_weight_sigma", "**", "2", "\n", "# bias_sigma = trainer_bias_sigma**2 / saver_bias_sigma**2", "\n", "\n", "normal_weight_sigma", "=", "trainer_weight_sigma", "**", "2", "\n", "# normal_bias_sigma = trainer_bias_sigma**2", "\n", "\n", "sigma_weight_reg_sum", "+=", "(", "weight_sigma", "-", "torch", ".", "log", "(", "weight_sigma", ")", ")", ".", "sum", "(", ")", "\n", "sigma_weight_reg_sum", "+=", "(", "normal_weight_sigma", "-", "torch", ".", "log", "(", "normal_weight_sigma", ")", ")", ".", "sum", "(", ")", "\n", "# sigma_bias_reg_sum += (bias_sigma - torch.log(bias_sigma)).sum()", "\n", "# sigma_bias_reg_sum += (normal_bias_sigma - torch.log(normal_bias_sigma)).sum()", "\n", "\n", "mu_weight_reg_sum", "+=", "mu_weight_reg", "\n", "# mu_bias_reg_sum += mu_bias_reg", "\n", "L1_mu_weight_reg_sum", "+=", "L1_mu_weight_reg", "\n", "# L1_mu_bias_reg_sum += L1_mu_bias_reg", "\n", "\n", "# L2 loss", "\n", "", "", "", "loss", "=", "(", "mu_weight_reg_sum", "+", "mu_bias_reg_sum", ")", "/", "(", "2", "*", "mini_batch_size", ")", "\n", "# L1 loss", "\n", "loss", "=", "loss", "+", "self", ".", "saved", "*", "(", "L1_mu_weight_reg_sum", "+", "L1_mu_bias_reg_sum", ")", "/", "(", "mini_batch_size", ")", "\n", "# sigma regularization", "\n", "loss", "=", "loss", "+", "self", ".", "beta", "*", "(", "sigma_weight_reg_sum", "+", "sigma_bias_reg_sum", ")", "/", "(", "2", "*", "mini_batch_size", ")", "\n", "\n", "return", "loss", "", "", "", ""]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.__init__": [[11, 65], ["torch.nn.CrossEntropyLoss", "hat_test.Appr._get_optimizer", "len", "args.parameter.split", "print", "len", "utils.is_number", "utils.is_number", "float", "float", "utils.is_number", "int", "len", "utils.is_number", "len"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.is_number", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.is_number", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.is_number", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.is_number"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "nepochs", "=", "100", ",", "sbatch", "=", "64", ",", "lr", "=", "0.05", ",", "lr_min", "=", "1e-4", ",", "lr_factor", "=", "3", ",", "lr_patience", "=", "5", ",", "clipgrad", "=", "10000", ",", "lamb", "=", "0.75", ",", "smax", "=", "400", ",", "args", "=", "None", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "\n", "self", ".", "nepochs", "=", "nepochs", "\n", "self", ".", "sbatch", "=", "sbatch", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "lr_min", "=", "lr_min", "\n", "self", ".", "lr_factor", "=", "lr_factor", "\n", "self", ".", "lr_patience", "=", "lr_patience", "\n", "self", ".", "clipgrad", "=", "clipgrad", "\n", "\n", "self", ".", "ce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", ")", "\n", "\n", "self", ".", "lamb", "=", "lamb", "\n", "self", ".", "smax", "=", "smax", "\n", "self", ".", "logpath", "=", "None", "\n", "self", ".", "single_task", "=", "False", "\n", "if", "len", "(", "args", ".", "parameter", ")", ">=", "1", ":", "\n", "            ", "params", "=", "args", ".", "parameter", ".", "split", "(", "','", ")", "\n", "print", "(", "'Setting parameters to'", ",", "params", ")", "\n", "if", "len", "(", "params", ")", ">", "1", ":", "\n", "                ", "if", "utils", ".", "is_number", "(", "params", "[", "0", "]", ")", ":", "\n", "                    ", "self", ".", "lamb", "=", "float", "(", "params", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "logpath", "=", "params", "[", "0", "]", "\n", "", "if", "utils", ".", "is_number", "(", "params", "[", "1", "]", ")", ":", "\n", "                    ", "self", ".", "smax", "=", "float", "(", "params", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "logpath", "=", "params", "[", "1", "]", "\n", "", "if", "len", "(", "params", ")", ">", "2", "and", "not", "utils", ".", "is_number", "(", "params", "[", "2", "]", ")", ":", "\n", "                    ", "self", ".", "logpath", "=", "params", "[", "2", "]", "\n", "", "if", "len", "(", "params", ")", ">", "3", "and", "utils", ".", "is_number", "(", "params", "[", "3", "]", ")", ":", "\n", "                    ", "self", ".", "single_task", "=", "int", "(", "params", "[", "3", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "logpath", "=", "args", ".", "parameter", "\n", "\n", "", "", "if", "self", ".", "logpath", "is", "not", "None", ":", "\n", "            ", "self", ".", "logs", "=", "{", "}", "\n", "self", ".", "logs", "[", "'train_loss'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'train_acc'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'train_reg'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'valid_loss'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'valid_acc'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'valid_reg'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'mask'", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'mask_pre'", "]", "=", "{", "}", "\n", "", "else", ":", "\n", "            ", "self", ".", "logs", "=", "None", "\n", "\n", "", "self", ".", "mask_pre", "=", "None", "\n", "self", ".", "mask_back", "=", "None", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer": [[66, 69], ["torch.optim.SGD", "hat_test.Appr.model.parameters"], "methods", ["None"], ["", "def", "_get_optimizer", "(", "self", ",", "lr", "=", "None", ")", ":", "\n", "        ", "if", "lr", "is", "None", ":", "lr", "=", "self", ".", "lr", "\n", "return", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train": [[70, 178], ["utils.get_model", "hat_test.Appr._get_optimizer", "torch.autograd.Variable", "hat_test.Appr.model.mask", "range", "utils.set_model_", "torch.autograd.Variable", "hat_test.Appr.model.mask", "range", "hat_test.Appr.model.named_parameters", "torch.LongTensor().cuda", "len", "torch.autograd.Variable", "copy.deepcopy", "torch.LongTensor().cuda", "len", "torch.autograd.Variable", "range", "hat_test.Appr.model.get_view_for", "bmask[].data.clone", "bmask[].data.cpu().numpy().astype", "copy.deepcopy", "copy.deepcopy", "range", "mask[].data.clone", "len", "torch.max", "torch.LongTensor", "hat_test.Appr.mask_pre[].data.cpu().numpy().astype", "time.time", "hat_test.Appr.train_epoch", "time.time", "hat_test.Appr.eval_withreg", "time.time", "print", "hat_test.Appr.eval_withreg", "print", "losses_train.append", "acc_train.append", "reg_train.append", "losses_valid.append", "acc_valid.append", "reg_valid.append", "print", "torch.autograd.Variable", "hat_test.Appr.model.mask", "range", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "print", "torch.LongTensor", "bmask[].data.cpu().numpy", "utils.get_model", "print", "torch.LongTensor().cuda", "len", "copy.deepcopy", "hat_test.Appr.mask_pre[].data.cpu().numpy", "print", "hat_test.Appr._get_optimizer", "bmask[].data.cpu().numpy().astype", "bmask[].data.cpu", "xtrain.size", "xtrain.size", "print", "torch.LongTensor", "hat_test.Appr.mask_pre[].data.cpu", "bmask[].data.cpu().numpy", "bmask[].data.cpu"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.mask", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.set_model_", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.mask", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.get_view_for", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train_epoch", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval_withreg", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval_withreg", "home.repos.pwc.inspect_result.hhihn_HVCL.networks.mlp_hat.Net.mask", "home.repos.pwc.inspect_result.hhihn_HVCL.UCL_EWC_RL.utils.get_model", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr._get_optimizer", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "train", "(", "self", ",", "t", ",", "xtrain", ",", "ytrain", ",", "xvalid", ",", "yvalid", ")", ":", "\n", "        ", "best_loss", "=", "np", ".", "inf", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "lr", "=", "self", ".", "lr", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "\n", "#log", "\n", "losses_train", "=", "[", "]", "\n", "losses_valid", "=", "[", "]", "\n", "acc_train", "=", "[", "]", "\n", "acc_valid", "=", "[", "]", "\n", "reg_train", "=", "[", "]", "\n", "reg_valid", "=", "[", "]", "\n", "self", ".", "logs", "[", "'mask'", "]", "[", "t", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'mask_pre'", "]", "[", "t", "]", "=", "{", "}", "\n", "task", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "t", "]", ")", ".", "cuda", "(", ")", ",", "volatile", "=", "False", ")", "\n", "bmask", "=", "self", ".", "model", ".", "mask", "(", "task", ",", "s", "=", "self", ".", "smax", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "bmask", ")", ")", ":", "\n", "            ", "bmask", "[", "i", "]", "=", "torch", ".", "autograd", ".", "Variable", "(", "bmask", "[", "i", "]", ".", "data", ".", "clone", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "logs", "[", "'mask'", "]", "[", "t", "]", "[", "i", "]", "=", "{", "}", "\n", "self", ".", "logs", "[", "'mask'", "]", "[", "t", "]", "[", "i", "]", "[", "-", "1", "]", "=", "deepcopy", "(", "bmask", "[", "i", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "if", "t", "==", "0", ":", "\n", "                ", "self", ".", "logs", "[", "'mask_pre'", "]", "[", "t", "]", "[", "i", "]", "=", "deepcopy", "(", "(", "0", "*", "bmask", "[", "i", "]", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "logs", "[", "'mask_pre'", "]", "[", "t", "]", "[", "i", "]", "=", "deepcopy", "(", "self", ".", "mask_pre", "[", "i", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "", "", "if", "not", "self", ".", "single_task", "or", "(", "self", ".", "single_task", "and", "t", "==", "0", ")", ":", "\n", "# Loop epochs", "\n", "            ", "try", ":", "\n", "                ", "for", "e", "in", "range", "(", "self", ".", "nepochs", ")", ":", "\n", "# Train", "\n", "                    ", "clock0", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "train_epoch", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "clock1", "=", "time", ".", "time", "(", ")", "\n", "train_loss", ",", "train_acc", ",", "train_reg", "=", "self", ".", "eval_withreg", "(", "t", ",", "xtrain", ",", "ytrain", ")", "\n", "clock2", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "e", "+", "1", ",", "\n", "1000", "*", "self", ".", "sbatch", "*", "(", "clock1", "-", "clock0", ")", "/", "xtrain", ".", "size", "(", "0", ")", ",", "1000", "*", "self", ".", "sbatch", "*", "(", "clock2", "-", "clock1", ")", "/", "xtrain", ".", "size", "(", "0", ")", ",", "train_loss", ",", "100", "*", "train_acc", ")", ",", "end", "=", "''", ")", "\n", "# Valid", "\n", "valid_loss", ",", "valid_acc", ",", "valid_reg", "=", "self", ".", "eval_withreg", "(", "t", ",", "xvalid", ",", "yvalid", ")", "\n", "print", "(", "' Valid: loss={:.3f}, acc={:5.1f}% |'", ".", "format", "(", "valid_loss", ",", "100", "*", "valid_acc", ")", ",", "end", "=", "''", ")", "\n", "\n", "#log", "\n", "losses_train", ".", "append", "(", "train_loss", ")", "\n", "acc_train", ".", "append", "(", "train_acc", ")", "\n", "reg_train", ".", "append", "(", "train_reg", ")", "\n", "losses_valid", ".", "append", "(", "valid_loss", ")", "\n", "acc_valid", ".", "append", "(", "valid_acc", ")", "\n", "reg_valid", ".", "append", "(", "valid_reg", ")", "\n", "\n", "# Adapt lr", "\n", "if", "valid_loss", "<", "best_loss", ":", "\n", "                        ", "best_loss", "=", "valid_loss", "\n", "best_model", "=", "utils", ".", "get_model", "(", "self", ".", "model", ")", "\n", "patience", "=", "self", ".", "lr_patience", "\n", "print", "(", "' *'", ",", "end", "=", "''", ")", "\n", "", "else", ":", "\n", "                        ", "patience", "-=", "1", "\n", "if", "patience", "<=", "0", ":", "\n", "                            ", "lr", "/=", "self", ".", "lr_factor", "\n", "print", "(", "' lr={:.1e}'", ".", "format", "(", "lr", ")", ",", "end", "=", "''", ")", "\n", "if", "lr", "<", "self", ".", "lr_min", ":", "\n", "                                ", "print", "(", ")", "\n", "break", "\n", "", "patience", "=", "self", ".", "lr_patience", "\n", "self", ".", "optimizer", "=", "self", ".", "_get_optimizer", "(", "lr", ")", "\n", "", "", "print", "(", ")", "\n", "\n", "# Log activations mask", "\n", "task", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "t", "]", ")", ".", "cuda", "(", ")", ",", "volatile", "=", "False", ")", "\n", "bmask", "=", "self", ".", "model", ".", "mask", "(", "task", ",", "s", "=", "self", ".", "smax", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "bmask", ")", ")", ":", "\n", "                        ", "self", ".", "logs", "[", "'mask'", "]", "[", "t", "]", "[", "i", "]", "[", "e", "]", "=", "deepcopy", "(", "bmask", "[", "i", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "# Log losses", "\n", "", "", "if", "self", ".", "logs", "is", "not", "None", ":", "\n", "                    ", "self", ".", "logs", "[", "'train_loss'", "]", "[", "t", "]", "=", "np", ".", "array", "(", "losses_train", ")", "\n", "self", ".", "logs", "[", "'train_acc'", "]", "[", "t", "]", "=", "np", ".", "array", "(", "acc_train", ")", "\n", "self", ".", "logs", "[", "'train_reg'", "]", "[", "t", "]", "=", "np", ".", "array", "(", "reg_train", ")", "\n", "self", ".", "logs", "[", "'valid_loss'", "]", "[", "t", "]", "=", "np", ".", "array", "(", "losses_valid", ")", "\n", "self", ".", "logs", "[", "'valid_acc'", "]", "[", "t", "]", "=", "np", ".", "array", "(", "acc_valid", ")", "\n", "self", ".", "logs", "[", "'valid_reg'", "]", "[", "t", "]", "=", "np", ".", "array", "(", "reg_valid", ")", "\n", "", "", "except", "KeyboardInterrupt", ":", "\n", "                ", "print", "(", ")", "\n", "\n", "# Restore best validation model", "\n", "", "", "utils", ".", "set_model_", "(", "self", ".", "model", ",", "best_model", ")", "\n", "\n", "# Activations mask", "\n", "task", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "t", "]", ")", ".", "cuda", "(", ")", ",", "volatile", "=", "False", ")", "\n", "mask", "=", "self", ".", "model", ".", "mask", "(", "task", ",", "s", "=", "self", ".", "smax", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "mask", ")", ")", ":", "\n", "            ", "mask", "[", "i", "]", "=", "torch", ".", "autograd", ".", "Variable", "(", "mask", "[", "i", "]", ".", "data", ".", "clone", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "", "if", "t", "==", "0", ":", "\n", "            ", "self", ".", "mask_pre", "=", "mask", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "mask_pre", ")", ")", ":", "\n", "                ", "self", ".", "mask_pre", "[", "i", "]", "=", "torch", ".", "max", "(", "self", ".", "mask_pre", "[", "i", "]", ",", "mask", "[", "i", "]", ")", "\n", "\n", "# Weights mask", "\n", "", "", "self", ".", "mask_back", "=", "{", "}", "\n", "for", "n", ",", "_", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "vals", "=", "self", ".", "model", ".", "get_view_for", "(", "n", ",", "self", ".", "mask_pre", ")", "\n", "if", "vals", "is", "not", "None", ":", "\n", "                ", "self", ".", "mask_back", "[", "n", "]", "=", "1", "-", "vals", "\n", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train_epoch": [[179, 232], ["hat_test.Appr.model.train", "numpy.arange", "numpy.random.shuffle", "torch.LongTensor().cuda", "range", "x.size", "len", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "hat_test.Appr.model.forward", "hat_test.Appr.criterion", "hat_test.Appr.optimizer.zero_grad", "loss.backward", "hat_test.Appr.model.named_parameters", "torch.nn.utils.clip_grad_norm", "hat_test.Appr.optimizer.step", "hat_test.Appr.model.named_parameters", "torch.LongTensor", "len", "torch.LongTensor().cuda", "hat_test.Appr.model.named_parameters", "n.startswith", "hat_test.Appr.model.parameters", "n.startswith", "len", "torch.clamp", "torch.LongTensor", "torch.cosh", "torch.cosh", "torch.clamp"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.train", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.envs.TimeLimitMask.step"], ["", "def", "train_epoch", "(", "self", ",", "t", ",", "x", ",", "y", ",", "thres_cosh", "=", "50", ",", "thres_emb", "=", "6", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "r", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "torch", ".", "autograd", ".", "Variable", "(", "x", "[", "b", "]", ",", "volatile", "=", "False", ")", "\n", "targets", "=", "torch", ".", "autograd", ".", "Variable", "(", "y", "[", "b", "]", ",", "volatile", "=", "False", ")", "\n", "task", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "t", "]", ")", ".", "cuda", "(", ")", ",", "volatile", "=", "False", ")", "\n", "s", "=", "(", "self", ".", "smax", "-", "1", "/", "self", ".", "smax", ")", "*", "i", "/", "len", "(", "r", ")", "+", "1", "/", "self", ".", "smax", "\n", "\n", "# Forward", "\n", "outputs", ",", "masks", "=", "self", ".", "model", ".", "forward", "(", "task", ",", "images", ",", "s", "=", "s", ")", "\n", "output", "=", "outputs", "[", "t", "]", "\n", "loss", ",", "_", "=", "self", ".", "criterion", "(", "output", ",", "targets", ",", "masks", ")", "\n", "\n", "# Backward", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# Restrict layer gradients in backprop", "\n", "if", "t", ">", "0", ":", "\n", "                ", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                    ", "if", "n", "in", "self", ".", "mask_back", ":", "\n", "                        ", "p", ".", "grad", ".", "data", "*=", "self", ".", "mask_back", "[", "n", "]", "\n", "\n", "# Compensate embedding gradients", "\n", "", "", "", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                ", "if", "n", ".", "startswith", "(", "'e'", ")", ":", "\n", "                    ", "num", "=", "torch", ".", "cosh", "(", "torch", ".", "clamp", "(", "s", "*", "p", ".", "data", ",", "-", "thres_cosh", ",", "thres_cosh", ")", ")", "+", "1", "\n", "den", "=", "torch", ".", "cosh", "(", "p", ".", "data", ")", "+", "1", "\n", "p", ".", "grad", ".", "data", "*=", "self", ".", "smax", "/", "s", "*", "num", "/", "den", "\n", "\n", "# Apply step", "\n", "", "", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "clipgrad", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Constrain embeddings", "\n", "for", "n", ",", "p", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "                ", "if", "n", ".", "startswith", "(", "'e'", ")", ":", "\n", "                    ", "p", ".", "data", "=", "torch", ".", "clamp", "(", "p", ".", "data", ",", "-", "thres_emb", ",", "thres_emb", ")", "\n", "\n", "#print(masks[-1].data.view(1,-1))", "\n", "#if i>=5*self.sbatch: sys.exit()", "\n", "#if i==0: print(masks[-2].data.view(1,-1),masks[-2].data.max(),masks[-2].data.min())", "\n", "#print(masks[-2].data.view(1,-1))", "\n", "\n", "", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval": [[233, 270], ["hat_test.Appr.model.eval", "numpy.arange", "torch.LongTensor().cuda", "range", "print", "x.size", "len", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "hat_test.Appr.model.forward", "hat_test.Appr.criterion", "output.max", "hits.sum().data.cpu().numpy().item", "len", "torch.LongTensor", "len", "torch.LongTensor().cuda", "loss.data.cpu().numpy().item", "len", "reg.data.cpu().numpy().item", "len", "hits.sum().data.cpu().numpy", "torch.LongTensor", "loss.data.cpu().numpy", "reg.data.cpu().numpy", "hits.sum().data.cpu", "loss.data.cpu", "reg.data.cpu", "hits.sum"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion"], ["", "def", "eval", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "total_loss", "=", "0", "\n", "total_acc", "=", "0", "\n", "total_num", "=", "0", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "total_reg", "=", "0", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "torch", ".", "autograd", ".", "Variable", "(", "x", "[", "b", "]", ",", "volatile", "=", "True", ")", "\n", "targets", "=", "torch", ".", "autograd", ".", "Variable", "(", "y", "[", "b", "]", ",", "volatile", "=", "True", ")", "\n", "task", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "t", "]", ")", ".", "cuda", "(", ")", ",", "volatile", "=", "True", ")", "\n", "\n", "# Forward", "\n", "factor", "=", "1", "\n", "if", "self", ".", "single_task", ":", "factor", "=", "10000", "\n", "outputs", ",", "masks", "=", "self", ".", "model", ".", "forward", "(", "task", ",", "images", ",", "s", "=", "factor", "*", "self", ".", "smax", ")", "\n", "output", "=", "outputs", "[", "t", "]", "\n", "loss", ",", "reg", "=", "self", ".", "criterion", "(", "output", ",", "targets", ",", "masks", ")", "\n", "_", ",", "pred", "=", "output", ".", "max", "(", "1", ")", "\n", "hits", "=", "(", "pred", "==", "targets", ")", ".", "float", "(", ")", "\n", "\n", "# Log", "\n", "total_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "*", "len", "(", "b", ")", "\n", "total_acc", "+=", "hits", ".", "sum", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "\n", "total_num", "+=", "len", "(", "b", ")", "\n", "total_reg", "+=", "reg", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "*", "len", "(", "b", ")", "\n", "\n", "", "print", "(", "'  {:.3f}  '", ".", "format", "(", "total_reg", "/", "total_num", ")", ",", "end", "=", "''", ")", "\n", "\n", "return", "total_loss", "/", "total_num", ",", "total_acc", "/", "total_num", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval_withreg": [[271, 308], ["hat_test.Appr.model.eval", "numpy.arange", "torch.LongTensor().cuda", "range", "print", "x.size", "len", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "hat_test.Appr.model.forward", "hat_test.Appr.criterion", "output.max", "hits.sum().data.cpu().numpy().item", "len", "torch.LongTensor", "len", "torch.LongTensor().cuda", "loss.data.cpu().numpy().item", "len", "reg.data.cpu().numpy().item", "len", "hits.sum().data.cpu().numpy", "torch.LongTensor", "loss.data.cpu().numpy", "reg.data.cpu().numpy", "hits.sum().data.cpu", "loss.data.cpu", "reg.data.cpu", "hits.sum"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.eval", "home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size", "home.repos.pwc.inspect_result.hhihn_HVCL.a2c_ppo_acktr.utils.AddBias.forward", "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion"], ["", "def", "eval_withreg", "(", "self", ",", "t", ",", "x", ",", "y", ")", ":", "\n", "        ", "total_loss", "=", "0", "\n", "total_acc", "=", "0", "\n", "total_num", "=", "0", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "total_reg", "=", "0", "\n", "\n", "r", "=", "np", ".", "arange", "(", "x", ".", "size", "(", "0", ")", ")", "\n", "r", "=", "torch", ".", "LongTensor", "(", "r", ")", ".", "cuda", "(", ")", "\n", "\n", "# Loop batches", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "r", ")", ",", "self", ".", "sbatch", ")", ":", "\n", "            ", "if", "i", "+", "self", ".", "sbatch", "<=", "len", "(", "r", ")", ":", "b", "=", "r", "[", "i", ":", "i", "+", "self", ".", "sbatch", "]", "\n", "else", ":", "b", "=", "r", "[", "i", ":", "]", "\n", "images", "=", "torch", ".", "autograd", ".", "Variable", "(", "x", "[", "b", "]", ",", "volatile", "=", "True", ")", "\n", "targets", "=", "torch", ".", "autograd", ".", "Variable", "(", "y", "[", "b", "]", ",", "volatile", "=", "True", ")", "\n", "task", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "t", "]", ")", ".", "cuda", "(", ")", ",", "volatile", "=", "True", ")", "\n", "\n", "# Forward", "\n", "factor", "=", "1", "\n", "if", "self", ".", "single_task", ":", "factor", "=", "10000", "\n", "outputs", ",", "masks", "=", "self", ".", "model", ".", "forward", "(", "task", ",", "images", ",", "s", "=", "factor", "*", "self", ".", "smax", ")", "\n", "output", "=", "outputs", "[", "t", "]", "\n", "loss", ",", "reg", "=", "self", ".", "criterion", "(", "output", ",", "targets", ",", "masks", ")", "\n", "_", ",", "pred", "=", "output", ".", "max", "(", "1", ")", "\n", "hits", "=", "(", "pred", "==", "targets", ")", ".", "float", "(", ")", "\n", "\n", "# Log", "\n", "total_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "*", "len", "(", "b", ")", "\n", "total_acc", "+=", "hits", ".", "sum", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "\n", "total_num", "+=", "len", "(", "b", ")", "\n", "total_reg", "+=", "reg", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "*", "len", "(", "b", ")", "\n", "\n", "", "print", "(", "'  {:.3f}  '", ".", "format", "(", "total_reg", "/", "total_num", ")", ",", "end", "=", "''", ")", "\n", "\n", "return", "total_loss", "/", "total_num", ",", "total_acc", "/", "total_num", ",", "total_reg", "/", "total_num", "\n", "\n"]], "home.repos.pwc.inspect_result.hhihn_HVCL.approaches.hat_test.Appr.criterion": [[309, 323], ["zip", "aux.sum", "m.sum", "numpy.prod().item", "hat_test.Appr.ce", "numpy.prod", "m.size"], "methods", ["home.repos.pwc.inspect_result.hhihn_HVCL.None.HVCL_rl_utils.ReplayBuffer.size"], ["", "def", "criterion", "(", "self", ",", "outputs", ",", "targets", ",", "masks", ")", ":", "\n", "        ", "reg", "=", "0", "\n", "count", "=", "0", "\n", "if", "self", ".", "mask_pre", "is", "not", "None", ":", "\n", "            ", "for", "m", ",", "mp", "in", "zip", "(", "masks", ",", "self", ".", "mask_pre", ")", ":", "\n", "                ", "aux", "=", "1", "-", "mp", "\n", "reg", "+=", "(", "m", "*", "aux", ")", ".", "sum", "(", ")", "\n", "count", "+=", "aux", ".", "sum", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "m", "in", "masks", ":", "\n", "                ", "reg", "+=", "m", ".", "sum", "(", ")", "\n", "count", "+=", "np", ".", "prod", "(", "m", ".", "size", "(", ")", ")", ".", "item", "(", ")", "\n", "", "", "reg", "/=", "count", "\n", "return", "self", ".", "ce", "(", "outputs", ",", "targets", ")", "+", "self", ".", "lamb", "*", "reg", ",", "reg", "\n", "\n"]]}