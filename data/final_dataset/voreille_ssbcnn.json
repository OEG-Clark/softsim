{"home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.sh_conv3d": [[14, 67], ["X.get_shape().as_list", "sh_networks_utils.get_radials_dict", "sh_networks_utils.get_radial_volume", "sh_networks_utils.get_harmonics", "sh_networks_utils.conv3d_complex", "tensorflow.reshape", "range", "tensorflow.concat", "tensorflow.multiply", "tensorflow.reshape", "X.get_shape", "tf.multiply.append", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.multiply", "tensorflow.expand_dims", "tensorflow.shape", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.expand_dims"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_radials_dict", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_radial_volume", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_harmonics", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.conv3d_complex"], ["def", "sh_conv3d", "(", "X", ",", "out_ch", ",", "ksize", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", ",", "padding", "=", "'VALID'", ",", "degreeMax", "=", "1", ",", "stddev", "=", "0.4", ",", "name", "=", "'shconv3d'", ",", "\n", "is_trainable", "=", "True", ",", "is_hn", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n        3D Spherical Convolution used in S-LRI, SSE-LRI and bispectrum-LRI\n        returns responses to SHs hYnm\n        Parameters\n        ----------\n        X : tf tensor\n            shape [batch, in_depth, in_height, in_width, 2 (complex), in_channels]\n        out_ch : tf tensor\n            shape [filter_radius, in_channels, out_channels], the radial profiles of the spherical harmonic filters\n        ksize : int\n            size of the kernel\n        strides : tuple of int, optional\n            size of the stride\n        padding : string\n            size of the padding\n        degreeMax : int, optional\n            Maximal degree in the spherical harmonics expansion\n        stddev : float, optional\n            stdde for the weight initialisation\n        name : string, optional\n            name for the tf graph\n        is_trainable : bool, optional\n            if True optimize the paramters of the layer\n        is_hn : bool, optional\n            if True, compute a different radial profile for each degree in the spherical harmonic expansion\n\n        Returns\n        -------\n        _ : tf tensor\n            The tensor output of this layer with shape\n\n        \"\"\"", "\n", "\n", "xsh", "=", "X", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "in_ch", "=", "xsh", "[", "4", "]", "\n", "H", "=", "get_radials_dict", "(", "ksize", ",", "in_ch", ",", "out_ch", ",", "degreeMax", ",", "is_hn", ",", "is_trainable", ",", "std_mult", "=", "stddev", ",", "name", "=", "'H'", "+", "name", ")", "\n", "hn", "=", "get_radial_volume", "(", "H", ",", "ksize", ",", "is_hn", ")", "\n", "Y", "=", "get_harmonics", "(", "degreeMax", ",", "ksize", ")", "\n", "if", "is_hn", ":", "\n", "        ", "hY", "=", "[", "]", "\n", "for", "n", "in", "range", "(", "degreeMax", "+", "1", ")", ":", "\n", "            ", "hY", ".", "append", "(", "tf", ".", "multiply", "(", "tf", ".", "expand_dims", "(", "hn", "[", ":", ",", ":", ",", ":", ",", "n", ",", ":", ",", ":", "]", ",", "-", "1", ")", ",", "\n", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "Y", "[", "...", ",", "n", "**", "2", ":", "(", "n", "+", "1", ")", "**", "2", "]", ",", "3", ")", ",", "3", ")", ")", ")", "\n", "", "hY", "=", "tf", ".", "concat", "(", "hY", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "hY", "=", "tf", ".", "multiply", "(", "tf", ".", "expand_dims", "(", "hn", ",", "-", "1", ")", ",", "tf", ".", "expand_dims", "(", "tf", ".", "expand_dims", "(", "Y", ",", "3", ")", ",", "3", ")", ")", "\n", "# Convolve to all filters then add (first reshape hY in order to convolve all at once)", "\n", "", "R", "=", "conv3d_complex", "(", "X", ",", "tf", ".", "reshape", "(", "hY", ",", "[", "ksize", ",", "ksize", ",", "ksize", ",", "in_ch", ",", "out_ch", "*", "(", "degreeMax", "+", "1", ")", "**", "2", "]", ")", ",", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "name", "=", "name", ")", "\n", "\n", "return", "tf", ".", "reshape", "(", "R", ",", "[", "tf", ".", "shape", "(", "R", ")", "[", "0", "]", ",", "R", ".", "shape", "[", "1", "]", ",", "R", ".", "shape", "[", "2", "]", ",", "R", ".", "shape", "[", "3", "]", ",", "out_ch", ",", "(", "degreeMax", "+", "1", ")", "**", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.conv3d_complex": [[69, 96], ["W.get_shape().as_list", "tensorflow.stack", "tensorflow.reshape", "tensorflow.nn.conv3d", "tf.reshape.get_shape().as_list", "tensorflow.reshape", "tensorflow.complex", "W.get_shape", "tensorflow.math.real", "tensorflow.math.imag", "tf.reshape.get_shape", "int", "tensorflow.shape"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.conv3d"], ["", "def", "conv3d_complex", "(", "X", ",", "W", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "padding", "=", "'VALID'", ",", "name", "=", "'conv3d_complex'", ")", ":", "\n", "    ", "\"\"\"\n    Returns the 3D convolution of the inputs X with the complex filters W\n    Parameters\n    ----------\n    X : tf tensor\n        input of the layer with shape (bs,h,w,d,in_ch)\n    W : tf tensor\n        filters complex tensors of shape (h,w,d,in_ch,out_ch)\n\n    Returns\n    -------\n    complex tf tensor,\n        complex tensor shape (bs,h,w,d,out_ch)\n    \"\"\"", "\n", "\n", "Wsh", "=", "W", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "# Reshape filters", "\n", "W_", "=", "tf", ".", "stack", "(", "[", "tf", ".", "math", ".", "real", "(", "W", ")", ",", "tf", ".", "math", ".", "imag", "(", "W", ")", "]", ",", "4", ")", "\n", "W_", "=", "tf", ".", "reshape", "(", "W_", ",", "(", "Wsh", "[", "0", "]", ",", "Wsh", "[", "1", "]", ",", "Wsh", "[", "2", "]", ",", "Wsh", "[", "3", "]", ",", "2", "*", "Wsh", "[", "4", "]", ")", ")", "\n", "# Convolve", "\n", "Y", "=", "tf", ".", "nn", ".", "conv3d", "(", "X", ",", "W_", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "name", "=", "name", ")", "\n", "# Reshape result into appropriate shape", "\n", "Ysh", "=", "Y", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "Y", "=", "tf", ".", "reshape", "(", "Y", ",", "(", "tf", ".", "shape", "(", "Y", ")", "[", "0", "]", ",", "Ysh", "[", "1", "]", ",", "Ysh", "[", "2", "]", ",", "Ysh", "[", "3", "]", ",", "2", ",", "int", "(", "Ysh", "[", "4", "]", "/", "2", ")", ")", ")", "\n", "\n", "return", "tf", ".", "complex", "(", "Y", "[", ":", ",", ":", ",", ":", ",", ":", ",", "0", ",", ":", "]", ",", "Y", "[", ":", ",", ":", ",", ":", ",", ":", ",", "1", ",", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.s_conv3d": [[98, 129], ["sh_networks_utils.get_shcoeffs_dict", "sh_networks_utils.get_steering_matrix", "sh_networks_utils.sh_conv3d", "sh_networks_utils.steer", "X.get_shape().as_list", "X.get_shape"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_shcoeffs_dict", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_steering_matrix", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.sh_conv3d", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.steer"], ["", "def", "s_conv3d", "(", "X", ",", "out_ch", ",", "ksize", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", ",", "padding", "=", "'VALID'", ",", "degreeMax", "=", "1", ",", "stddev", "=", "0.4", ",", "name", "=", "'conv3d'", ",", "M", "=", "4", ",", "\n", "is_trainable", "=", "True", ",", "is_hn", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n        Returns the S-LRI convolution responses after orientation pooling.\n        Parameters\n        ----------\n        X : tf tensor\n            input tensor of shape (bs,w,h,d,in_ch)\n        out_ch : int\n            number of output channels\n        ksize : int\n            kernel size\n        degreeMax : int, optional\n            maximal SH degree\n        M : int, optional\n            number of orientation sampled on the sphere\n        is_trainable\n        is_hn : bool, optional\n             if True, compute a different radial profile for each degree in the spherical harmonic expansion\n\n        Returns\n        -------\n        _ :\n    \"\"\"", "\n", "\n", "in_ch", "=", "X", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "4", "]", "\n", "# Coefficients Cnm", "\n", "C", "=", "get_shcoeffs_dict", "(", "in_ch", ",", "out_ch", ",", "degreeMax", ",", "is_trainable", ",", "std_mult", "=", "stddev", ",", "name", "=", "'C'", "+", "name", ")", "\n", "Sr", "=", "get_steering_matrix", "(", "degreeMax", ",", "ksize", ",", "M", ")", "\n", "R", "=", "sh_conv3d", "(", "X", ",", "out_ch", ",", "ksize", ",", "strides", ",", "padding", ",", "degreeMax", ",", "stddev", ",", "name", ",", "is_trainable", ",", "is_hn", ")", "\n", "return", "steer", "(", "R", ",", "C", ",", "Sr", ",", "degreeMax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.sse_conv3d": [[131, 162], ["numpy.zeros", "range", "tensorflow.constant", "sh_networks_utils.sh_conv3d", "sh_networks_utils.get_sse_invariant_coeffs"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.sh_conv3d", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_sse_invariant_coeffs"], ["", "def", "sse_conv3d", "(", "X", ",", "out_ch", ",", "ksize", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", ",", "padding", "=", "'VALID'", ",", "degreeMax", "=", "1", ",", "stddev", "=", "0.4", ",", "name", "=", "'conv3d'", ",", "M", "=", "4", ",", "\n", "is_trainable", "=", "True", ",", "is_hn", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n\n    Parameters\n    ----------\n    X : tf tensor\n        input tensor of shape (bs,w,h,d,in_ch)\n     out_ch : int\n        number of output channels\n    ksize : int\n        kernel size\n    degreeMax : int, optional\n        maximal SH degree\n    M : int, optional\n        number of orientation sampled on the sphere\n    is_hn : bool, optional\n         if True, compute a different radial profile for each degree in the spherical harmonic expansion\n\n    Returns\n    -------\n    _ : tf tensor\n        the Solid Spherical Energy (SSE)-LRI convolution responses.\n    \"\"\"", "\n", "# Create a matrix for quickly summing the norms within degrees n", "\n", "mat", "=", "np", ".", "zeros", "(", "(", "(", "degreeMax", "+", "1", ")", "**", "2", ",", "degreeMax", "+", "1", ")", ")", "\n", "for", "n", "in", "range", "(", "degreeMax", "+", "1", ")", ":", "\n", "        ", "mat", "[", "n", "**", "2", ":", "(", "n", "+", "1", ")", "**", "2", ",", "n", "]", "=", "1", "\n", "", "mat", "=", "tf", ".", "constant", "(", "mat", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "R", "=", "sh_conv3d", "(", "X", ",", "out_ch", ",", "ksize", ",", "strides", ",", "padding", ",", "degreeMax", ",", "stddev", ",", "name", ",", "is_trainable", ",", "is_hn", ")", "\n", "return", "get_sse_invariant_coeffs", "(", "R", ",", "degreeMax", ",", "mat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.bispectrum_conv3d": [[164, 182], ["range", "sh_networks_utils.sh_conv3d", "sh_networks_utils.get_bispectrum_invariant_coeffs", "range", "tensorflow.constant", "sh_networks_utils.compute_cg_matrix"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.sh_conv3d", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_bispectrum_invariant_coeffs", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.compute_cg_matrix"], ["", "def", "bispectrum_conv3d", "(", "X", ",", "out_ch", ",", "ksize", ",", "strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", ",", "padding", "=", "'VALID'", ",", "degreeMax", "=", "1", ",", "stddev", "=", "0.4", ",", "\n", "name", "=", "'conv3d'", ",", "M", "=", "4", ",", "is_trainable", "=", "True", ",", "is_hn", "=", "False", ")", ":", "\n", "    ", "'''\n    Returns the bispectrum-LRI convolution responses.\n    X: input tensor of shape (bs,w,h,d,in_ch)\n    out_ch: number of output channels\n    ksize: kernel size\n    degreeMax: maximal SH degree\n    is_hn: Whether we have one radial profile per degree n (non-polar-separable)\n    '''", "\n", "cg_mat", "=", "{", "}", "# the set of cg matrices", "\n", "for", "n1", "in", "range", "(", "degreeMax", "+", "1", ")", ":", "\n", "        ", "for", "n2", "in", "range", "(", "degreeMax", "+", "1", ")", ":", "\n", "# print(n1,n2)", "\n", "# print(compute_cg_matrix(n1,n2))", "\n", "            ", "cg_mat", "[", "(", "n1", ",", "n2", ")", "]", "=", "tf", ".", "constant", "(", "compute_cg_matrix", "(", "n1", ",", "n2", ")", ",", "dtype", "=", "tf", ".", "complex64", ")", "\n", "", "", "R", "=", "sh_conv3d", "(", "X", ",", "out_ch", ",", "ksize", ",", "strides", ",", "padding", ",", "degreeMax", ",", "stddev", ",", "name", ",", "is_trainable", ",", "is_hn", ")", "\n", "return", "get_bispectrum_invariant_coeffs", "(", "R", ",", "degreeMax", ",", "cg_mat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_variables": [[184, 194], ["tensorflow.get_variable"], "function", ["None"], ["", "def", "get_variables", "(", "filter_shape", ",", "is_trainable", "=", "True", ",", "W_init", "=", "None", ",", "std_mult", "=", "0.4", ",", "\n", "name", "=", "'R'", ")", ":", "# this works for both radials and weights.", "\n", "    ", "\"\"\"\n    Initialize variable with He method\n    filter_shape: list of filter dimensions\n    W_init: numpy initial values (default None)\n    std_mult: multiplier for weight standard deviation (default 0.4)\n    name: (default W)\n    \"\"\"", "\n", "return", "tf", ".", "get_variable", "(", "name", ",", "dtype", "=", "tf", ".", "float32", ",", "shape", "=", "filter_shape", ",", "initializer", "=", "W_init", ",", "trainable", "=", "is_trainable", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_radial_volume": [[196, 243], ["tensorflow.zeros", "numpy.arange", "numpy.ones", "numpy.meshgrid", "numpy.reshape", "numpy.tile", "numpy.arange", "numpy.arange", "numpy.swapaxes", "tensorflow.constant", "tf.reshape.get_shape().as_list", "tf.reshape.get_shape().as_list", "numpy.sqrt", "numpy.meshgrid", "tf.constant.astype", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.complex", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.complex", "numpy.sum", "tensorflow.matmul", "tensorflow.zeros", "tensorflow.matmul", "tensorflow.zeros", "tf.reshape.get_shape", "tf.reshape.get_shape", "numpy.square", "numpy.abs", "numpy.floor", "numpy.abs"], "function", ["None"], ["", "def", "get_radial_volume", "(", "H", ",", "ksize", ",", "is_hn", ")", ":", "\n", "    ", "\"\"\"\n    Returns the 3d volume from the 1d polar separable radial profile for each in_ch, out_ch.\n    Output shape:\n        (ksize,ksize,ksize,in_ch,out_ch)\n        or if is_hn (ksize,ksize,ksize,degreeMax+1,in_ch,out_ch)\n    H: input tensor of shape:\n        (n_grid,out_ch)\n        or\n        if is_hn (n_grid, degreeMax+1,in_ch,out_ch)\n    is_hn: Whether we have one radial profile per degree n (non-polar-separable)\n    \"\"\"", "\n", "if", "is_hn", ":", "\n", "        ", "n_grid", ",", "degreeMax", ",", "in_ch", ",", "out_ch", "=", "H", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "degreeMax", "-=", "1", "# The shape has dimension degreeMax+1 because of degree 0.", "\n", "# Initialyze the volumes", "\n", "shape", "=", "[", "ksize", ",", "ksize", ",", "ksize", ",", "degreeMax", "+", "1", ",", "in_ch", ",", "out_ch", "]", "\n", "", "else", ":", "\n", "        ", "n_grid", ",", "in_ch", ",", "out_ch", "=", "H", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "# Initialyze the volumes", "\n", "shape", "=", "[", "ksize", ",", "ksize", ",", "ksize", ",", "in_ch", ",", "out_ch", "]", "\n", "", "radius", "=", "(", "ksize", "-", "1", ")", "/", "2", "\n", "radialVolume", "=", "tf", ".", "zeros", "(", "shape", ",", "dtype", "=", "tf", ".", "complex64", ")", "\n", "\n", "# Create the linear interpolation matrix y = |x-x1|y2+|x-x2|y1", "\n", "x", "=", "np", ".", "arange", "(", "-", "radius", ",", "radius", "+", "1", ",", "1", ")", "\n", "MG", "=", "np", ".", "ones", "(", "(", "3", ",", "ksize", ",", "ksize", ",", "ksize", ")", ")", "\n", "MG", "[", "0", ",", ":", ",", ":", ",", ":", "]", ",", "MG", "[", "1", ",", ":", ",", ":", ",", ":", "]", ",", "MG", "[", "2", ",", ":", ",", ":", ",", ":", "]", "=", "np", ".", "meshgrid", "(", "x", ",", "x", ",", "x", ")", "\n", "dist", "=", "np", ".", "reshape", "(", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "square", "(", "MG", ")", ",", "axis", "=", "0", ")", ")", ",", "(", "ksize", "**", "3", ")", ")", "# distance to the center (flattened)", "\n", "distMat", "=", "np", ".", "tile", "(", "dist", ",", "(", "n_grid", ",", "1", ")", ")", "# Replicate the distance for all n_grids", "\n", "a", "=", "np", ".", "arange", "(", "ksize", "**", "3", ")", "\n", "b", "=", "np", ".", "arange", "(", "n_grid", ")", "\n", "X", "=", "np", ".", "meshgrid", "(", "a", ",", "b", ")", "[", "1", "]", "\n", "M_interp", "=", "np", ".", "swapaxes", "(", "(", "1", "-", "np", ".", "abs", "(", "distMat", "-", "X", ")", ")", "*", "(", "np", ".", "floor", "(", "np", ".", "abs", "(", "distMat", "-", "X", ")", ")", "==", "0", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "0", ",", "1", ")", "\n", "M_interp", "=", "tf", ".", "constant", "(", "M_interp", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "if", "is_hn", ":", "\n", "# reshape H for matrix mult", "\n", "        ", "H", "=", "tf", ".", "reshape", "(", "H", ",", "[", "n_grid", ",", "(", "degreeMax", "+", "1", ")", "*", "in_ch", "*", "out_ch", "]", ")", "\n", "# Do the matrix multiplication", "\n", "radialVolume", "=", "tf", ".", "reshape", "(", "tf", ".", "matmul", "(", "M_interp", ",", "H", ")", ",", "[", "ksize", ",", "ksize", ",", "ksize", ",", "(", "degreeMax", "+", "1", ")", ",", "in_ch", ",", "out_ch", "]", ")", "\n", "return", "tf", ".", "complex", "(", "radialVolume", ",", "tf", ".", "zeros", "(", "(", "ksize", ",", "ksize", ",", "ksize", ",", "degreeMax", "+", "1", ",", "in_ch", ",", "out_ch", ")", ")", ")", "\n", "", "else", ":", "\n", "# reshape H for matrix mult", "\n", "        ", "H", "=", "tf", ".", "reshape", "(", "H", ",", "[", "n_grid", ",", "in_ch", "*", "out_ch", "]", ")", "\n", "# Do the matrix multiplication", "\n", "radialVolume", "=", "tf", ".", "reshape", "(", "tf", ".", "matmul", "(", "M_interp", ",", "H", ")", ",", "[", "ksize", ",", "ksize", ",", "ksize", ",", "in_ch", ",", "out_ch", "]", ")", "\n", "return", "tf", ".", "complex", "(", "radialVolume", ",", "tf", ".", "zeros", "(", "(", "ksize", ",", "ksize", ",", "ksize", ",", "in_ch", ",", "out_ch", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_harmonics": [[245, 262], ["sh_networks_utils.getSphCoordArrays", "range", "tensorflow.stack", "sh_networks_utils.legendre", "range", "numpy.cos", "sh_networks_utils.spherical_harmonics", "harmonics.append", "tensorflow.constant"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.getSphCoordArrays", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.legendre", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.spherical_harmonics"], ["", "", "def", "get_harmonics", "(", "degreeMax", ",", "ksize", ")", ":", "\n", "    ", "\"\"\"\n    Returns the spherical harmonics for all degrees (n) and orders (m) specified by the maximum degree degreeMax\n    Output: complex tensor of shape (ksize**3,(degreeMax+1)**2)\n    degreeMax: maximal SH degree (degreeMax)\n    ksize: kernel size\n    \"\"\"", "\n", "_", ",", "theta", ",", "phi", "=", "getSphCoordArrays", "(", "ksize", ")", "\n", "harmonics", "=", "[", "]", "\n", "for", "n", "in", "range", "(", "degreeMax", "+", "1", ")", ":", "\n", "        ", "P_legendre", "=", "legendre", "(", "n", ",", "np", ".", "cos", "(", "theta", ")", ")", "\n", "for", "m", "in", "range", "(", "-", "n", ",", "n", "+", "1", ")", ":", "\n", "# get the spherical harmonics (without radial profile)", "\n", "            ", "sh", "=", "spherical_harmonics", "(", "m", ",", "n", ",", "P_legendre", ",", "phi", ")", "\n", "# Reshape for multiplication with radial profile r", "\n", "harmonics", ".", "append", "(", "tf", ".", "constant", "(", "sh", ",", "dtype", "=", "tf", ".", "complex64", ")", ")", "\n", "", "", "return", "tf", ".", "stack", "(", "harmonics", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_steering_matrix": [[264, 293], ["int", "sh_networks_utils.get_euler_angles", "sh_networks_utils.getSphCoordArrays", "numpy.zeros", "range", "tensorflow.constant", "range", "numpy.ceil", "range", "range", "numpy.sqrt", "numpy.complex", "sympy.physics.quantum.spin.Rotation.D().doit", "sympy.physics.quantum.spin.Rotation.D"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_euler_angles", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.getSphCoordArrays"], ["", "def", "get_steering_matrix", "(", "degreeMax", ",", "ksize", ",", "M", ")", ":", "\n", "    ", "'''\n    Returns a tensor of a block diagonal matrix Sr for the M orientations: i.e. a matrix of weights of shape ((degreeMax+1)**2,(degreeMax+1)**2) for each orientation.\n    The output Sr has shape (M,(degreeMax+1)**2,(degreeMax+1)**2)).\n    (degreeMax+1)**2 is the total number of Ynm, it comes from the sum_n(2n+1)\n    degreeMax: maximal SH degree\n    ksize: kernel size\n    M: number of orientations\n    '''", "\n", "radius", "=", "(", "ksize", "-", "1", ")", "/", "2", "\n", "radiusAug", "=", "int", "(", "np", ".", "ceil", "(", "(", "radius", "-", "1", ")", "*", "np", ".", "sqrt", "(", "3", ")", ")", "+", "1", ")", "\n", "ksizeAug", "=", "radiusAug", "*", "2", "+", "1", "\n", "# define search space for angles.", "\n", "zyz", "=", "get_euler_angles", "(", "M", ")", "\n", "_", ",", "theta", ",", "phi", "=", "getSphCoordArrays", "(", "ksize", ")", "\n", "\n", "Sr", "=", "np", ".", "zeros", "(", "(", "M", ",", "(", "degreeMax", "+", "1", ")", "**", "2", ",", "(", "degreeMax", "+", "1", ")", "**", "2", ")", ",", "dtype", "=", "np", ".", "complex64", ")", "\n", "# scan through angles", "\n", "for", "a", "in", "range", "(", "zyz", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "alpha", ",", "beta", ",", "gamma", "=", "zyz", "[", "a", "]", "*", "pi", "/", "180", "\n", "# Import Wigner D matrix directly from simpy", "\n", "for", "n", "in", "range", "(", "degreeMax", "+", "1", ")", ":", "\n", "            ", "for", "k1", "in", "range", "(", "n", "*", "2", "+", "1", ")", ":", "\n", "                ", "m1", "=", "k1", "-", "n", "\n", "for", "k2", "in", "range", "(", "n", "*", "2", "+", "1", ")", ":", "\n", "                    ", "m2", "=", "k2", "-", "n", "\n", "Sr", "[", "a", ",", "n", "**", "2", "+", "k1", ",", "n", "**", "2", "+", "k2", "]", "=", "np", ".", "complex", "(", "Rotation", ".", "D", "(", "n", ",", "m1", ",", "m2", ",", "alpha", ",", "beta", ",", "gamma", ")", ".", "doit", "(", ")", ")", "\n", "\n", "", "", "", "", "return", "tf", ".", "constant", "(", "Sr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.legendre": [[295, 303], ["numpy.zeros", "range", "scipy.special.lpmv"], "function", ["None"], ["", "def", "legendre", "(", "n", ",", "X", ")", ":", "\n", "    ", "'''\n    Legendre polynomial used to define the SHs for degree n\n    '''", "\n", "res", "=", "np", ".", "zeros", "(", "(", "(", "n", "+", "1", ",", ")", "+", "(", "X", ".", "shape", ")", ")", ")", "\n", "for", "m", "in", "range", "(", "n", "+", "1", ")", ":", "\n", "        ", "res", "[", "m", "]", "=", "sp", ".", "lpmv", "(", "m", ",", "n", ",", "X", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.spherical_harmonics": [[305, 318], ["numpy.squeeze", "numpy.sqrt", "sh.astype", "numpy.sqrt", "numpy.sum", "numpy.exp", "numpy.abs", "numpy.abs", "numpy.math.factorial", "numpy.conj", "numpy.math.factorial", "numpy.abs", "numpy.abs"], "function", ["None"], ["", "def", "spherical_harmonics", "(", "m", ",", "n", ",", "P_legendre", ",", "phi", ")", ":", "\n", "    ", "'''\n    Returns the SH of degree n, order m\n    '''", "\n", "P_n_m", "=", "np", ".", "squeeze", "(", "P_legendre", "[", "np", ".", "abs", "(", "m", ")", "]", ")", "\n", "sign", "=", "(", "-", "1", ")", "**", "(", "(", "m", "+", "np", ".", "abs", "(", "m", ")", ")", "/", "2", ")", "\n", "# Normalization constant", "\n", "A", "=", "sign", "*", "np", ".", "sqrt", "(", "(", "2", "*", "n", "+", "1", ")", "/", "(", "4", "*", "pi", ")", "*", "np", ".", "math", ".", "factorial", "(", "n", "-", "np", ".", "abs", "(", "m", ")", ")", "/", "np", ".", "math", ".", "factorial", "(", "n", "+", "np", ".", "abs", "(", "m", ")", ")", ")", "\n", "# Spherical harmonics", "\n", "sh", "=", "A", "*", "np", ".", "exp", "(", "1j", "*", "m", "*", "phi", ")", "*", "P_n_m", "\n", "# Normalize the SH to unit norm", "\n", "sh", "/=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "sh", "*", "np", ".", "conj", "(", "sh", ")", ")", ")", "\n", "return", "sh", ".", "astype", "(", "np", ".", "complex64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.getSphCoordArrays": [[320, 335], ["numpy.mod", "numpy.ones", "numpy.meshgrid", "numpy.sqrt", "numpy.squeeze", "numpy.nan_to_num", "numpy.squeeze", "numpy.linspace", "numpy.linspace", "numpy.sum", "numpy.arctan2", "numpy.squeeze", "numpy.square", "numpy.arccos"], "function", ["None"], ["", "def", "getSphCoordArrays", "(", "ksize", ")", ":", "\n", "    ", "'''\n    Returns spherical coordinates (rho,theta,phi) from the kernel size ksize\n    '''", "\n", "if", "np", ".", "mod", "(", "ksize", ",", "2", ")", ":", "# ksize odd", "\n", "        ", "x", "=", "np", ".", "linspace", "(", "-", "1", ",", "1", ",", "ksize", ")", "\n", "", "else", ":", "# ksize even", "\n", "        ", "x", "=", "np", ".", "linspace", "(", "-", "1", ",", "1", ",", "ksize", ")", "#", "\n", "", "MG", "=", "np", ".", "ones", "(", "(", "3", ",", "ksize", ",", "ksize", ",", "ksize", ")", ")", "\n", "X", ",", "Y", ",", "Z", "=", "np", ".", "meshgrid", "(", "x", ",", "x", ",", "x", ")", "\n", "rho", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "square", "(", "[", "X", ",", "Y", ",", "Z", "]", ")", ",", "axis", "=", "0", ")", ")", "\n", "phi", "=", "np", ".", "squeeze", "(", "np", ".", "arctan2", "(", "Y", ",", "X", ")", ")", "\n", "theta", "=", "np", ".", "nan_to_num", "(", "np", ".", "squeeze", "(", "np", ".", "arccos", "(", "Z", "/", "rho", ")", ")", ")", "\n", "rho", "=", "np", ".", "squeeze", "(", "rho", ")", "\n", "return", "[", "rho", ",", "theta", ",", "phi", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_radials_dict": [[337, 356], ["int", "int", "tensorflow.random_normal_initializer", "sh_networks_utils.get_variables", "numpy.sqrt", "numpy.ceil", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_variables"], ["", "def", "get_radials_dict", "(", "ksize", ",", "in_ch", ",", "out_ch", ",", "degreeMax", ",", "is_hn", "=", "True", ",", "is_trainable", "=", "True", ",", "std_mult", "=", "0.4", ",", "name", "=", "'R'", ")", ":", "\n", "    ", "'''\n    Returns a tensor of radial profiles (trainable weights) of size (n_grid,degreeMax,in_ch,out_ch) if non-polar-separable (is_hn=True), or (n_grid,in_ch,out_ch) if polar-separable.\n    ksize: kernel size\n    in_ch: number of input channels\n    out_ch: number of output channels\n    degreeMax: maximal SH degree\n    is_hn: Whether we have one radial profile per degree n (non-polar-separable)\n    '''", "\n", "radius", "=", "int", "(", "(", "ksize", "+", "1", ")", "/", "2", ")", "\n", "n_grid", "=", "int", "(", "np", ".", "ceil", "(", "(", "radius", "-", "1", ")", "*", "np", ".", "sqrt", "(", "3", ")", ")", "+", "1", ")", "# number of points for the radial profile", "\n", "if", "is_hn", ":", "\n", "        ", "shape", "=", "[", "n_grid", ",", "degreeMax", "+", "1", ",", "in_ch", ",", "out_ch", "]", "#", "\n", "", "else", ":", "\n", "        ", "shape", "=", "[", "n_grid", ",", "in_ch", ",", "out_ch", "]", "#", "\n", "", "stddev", "=", "std_mult", "*", "np", ".", "sqrt", "(", "1.0", ")", "\n", "W_init", "=", "tf", ".", "random_normal_initializer", "(", "stddev", "=", "stddev", ")", "\n", "radials_dict", "=", "get_variables", "(", "shape", ",", "is_trainable", ",", "W_init", ",", "std_mult", "=", "std_mult", ",", "name", "=", "name", ")", "\n", "return", "radials_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_shcoeffs_dict": [[358, 391], ["tensorflow.random_normal_initializer", "range", "tensorflow.stack", "numpy.sqrt", "range", "range", "str", "sh_networks_utils.get_variables", "sh_networks_utils.get_variables", "C.append", "str", "tensorflow.complex", "C.append", "C.append", "tensorflow.complex", "tensorflow.scalar_mul", "tensorflow.math.conj", "tensorflow.complex"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_variables", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_variables"], ["", "def", "get_shcoeffs_dict", "(", "in_ch", ",", "out_ch", ",", "degreeMax", ",", "is_trainable", "=", "True", ",", "std_mult", "=", "0.4", ",", "name", "=", "'W'", ")", ":", "\n", "    ", "'''\n    Returns a tensor of expansion coefficients (C) of shape (out_ch,(degreeMax+1)^2), where (degreeMax+1)^2 is the total number of SHs (Ynm)\n    in_ch: number of input channels\n    out_ch number of output channels\n    degreeMax: maximal SH degree\n    '''", "\n", "coeffs_dict", "=", "{", "}", "\n", "C", "=", "[", "]", "\n", "stddev", "=", "std_mult", "*", "np", ".", "sqrt", "(", "2.0", "/", "in_ch", "*", "(", "\n", "degreeMax", "+", "1", ")", "**", "2", ")", "# This sets the variance to 2/(in_ch*(degreeMax+1)^2), (degreeMax+1)^2 being the total number of SHs", "\n", "W_init", "=", "tf", ".", "random_normal_initializer", "(", "stddev", "=", "stddev", ")", "\n", "for", "n", "in", "range", "(", "degreeMax", "+", "1", ")", ":", "\n", "# First define trainable variables for the coefficients that need it (m>=0)", "\n", "        ", "for", "m", "in", "range", "(", "n", "+", "1", ")", ":", "# Learn only half of the Cnm, the rest is calculated to obtain the symmetry", "\n", "            ", "name_nm", "=", "name", "+", "'_'", "+", "str", "(", "n", ")", "+", "str", "(", "m", ")", "\n", "if", "m", "==", "0", ":", "# The condition on C if m=0: Cn0=conj(Cn0). So Cn0 is real", "\n", "                ", "coeffs_dict", "[", "(", "n", ",", "m", ")", "]", "=", "get_variables", "(", "[", "out_ch", ",", "]", ",", "is_trainable", ",", "W_init", ",", "std_mult", "=", "std_mult", ",", "name", "=", "name_nm", ")", "\n", "", "else", ":", "\n", "                ", "coeffs_dict", "[", "(", "n", ",", "m", ")", "]", "=", "get_variables", "(", "[", "out_ch", ",", "2", "]", ",", "is_trainable", ",", "W_init", ",", "std_mult", "=", "std_mult", ",", "\n", "name", "=", "name_nm", ")", "# Now the coeffs are complex", "\n", "\n", "# Then fill a tensor with all Cnm values", "\n", "", "", "for", "k", "in", "range", "(", "n", "*", "2", "+", "1", ")", ":", "\n", "            ", "m", "=", "k", "-", "n", "\n", "if", "m", "==", "0", ":", "\n", "                ", "C", ".", "append", "(", "tf", ".", "complex", "(", "coeffs_dict", "[", "(", "n", ",", "m", ")", "]", ",", "0.", ")", ")", "\n", "", "elif", "m", ">=", "0", ":", "\n", "                ", "C", ".", "append", "(", "tf", ".", "complex", "(", "coeffs_dict", "[", "(", "n", ",", "m", ")", "]", "[", "...", ",", "0", "]", ",", "coeffs_dict", "[", "(", "n", ",", "m", ")", "]", "[", "...", ",", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "C", ".", "append", "(", "tf", ".", "scalar_mul", "(", "(", "-", "1", ")", "**", "(", "m", ")", ",", "tf", ".", "math", ".", "conj", "(", "\n", "tf", ".", "complex", "(", "coeffs_dict", "[", "(", "n", ",", "-", "m", ")", "]", "[", "...", ",", "0", "]", ",", "coeffs_dict", "[", "(", "n", ",", "-", "m", ")", "]", "[", "...", ",", "1", "]", ")", ")", ")", ")", "\n", "", "", "", "return", "tf", ".", "stack", "(", "C", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_sse_invariant_coeffs": [[393, 405], ["tf.matmul.get_shape().as_list", "tensorflow.reduce_sum", "tensorflow.matmul", "tensorflow.reshape", "tensorflow.shape", "tensorflow.square", "tensorflow.reshape", "tf.matmul.get_shape", "tensorflow.stack", "tensorflow.math.real", "tensorflow.math.imag"], "function", ["None"], ["", "def", "get_sse_invariant_coeffs", "(", "R", ",", "degreeMax", ",", "mat", ")", ":", "\n", "    ", "'''\n    Returns the bispectrum invariants from the responses to the SHs\n    R: features maps responses to the SHs (Ynm)\n    degreeMax: maximal SH degree (could be calculated from the shape of R)\n    mat: block diagonal matrix for fast multiplication.\n    '''", "\n", "bs", "=", "tf", ".", "shape", "(", "R", ")", "[", "0", "]", "\n", "rsh", "=", "R", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "R", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "tf", ".", "stack", "(", "(", "tf", ".", "math", ".", "real", "(", "R", ")", ",", "tf", ".", "math", ".", "imag", "(", "R", ")", ")", ",", "0", ")", ")", ",", "0", ")", "\n", "R", "=", "tf", ".", "matmul", "(", "tf", ".", "reshape", "(", "R", ",", "(", "bs", "*", "rsh", "[", "1", "]", "*", "rsh", "[", "2", "]", "*", "rsh", "[", "3", "]", "*", "rsh", "[", "4", "]", ",", "(", "degreeMax", "+", "1", ")", "**", "2", ")", ")", ",", "mat", ")", "\n", "return", "tf", ".", "reshape", "(", "R", ",", "(", "bs", ",", "rsh", "[", "1", "]", ",", "rsh", "[", "2", "]", ",", "rsh", "[", "3", "]", ",", "rsh", "[", "4", "]", "*", "(", "degreeMax", "+", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_bispectrum_invariant_coeffs": [[407, 446], ["tf.reshape.get_shape().as_list", "tensorflow.reshape", "range", "tensorflow.stack", "tensorflow.reshape", "tensorflow.shape", "range", "tf.reshape.get_shape", "math.floor", "tensorflow.matmul", "range", "math.ceil", "tensorflow.variable_scope", "sh_networks_utils.degreeToIndexes_range", "tensorflow.concat", "numpy.abs", "tensorflow.math.conj", "tf.concat.append", "tensorflow.variable_scope", "tf.stack.get_shape().as_list", "tensorflow.multiply", "tf.stack.append", "tf.stack.append", "tensorflow.expand_dims", "tensorflow.math.real", "tensorflow.math.imag", "tf.stack.get_shape", "sh_networks_utils.degreeToIndexes_slice", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.multiply", "tensorflow.multiply", "sh_networks_utils.degreeToIndexes_slice"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.degreeToIndexes_range", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.degreeToIndexes_slice", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.degreeToIndexes_slice"], ["", "def", "get_bispectrum_invariant_coeffs", "(", "R", ",", "degreeMax", ",", "cg_mat", ")", ":", "\n", "    ", "'''\n    Returns the bispectrum invariants from the responses to the SHs\n    R: features maps responses to the SHs (Ynm) shape: (bs, h, w, d, out_ch, (degreeMax+1)^2)\n    degreeMax: maximal SH degree (could be calculated from the shape of R, R[...,0])\n    cg_mat: Clebsch-Gordan matrices\n    '''", "\n", "bs", "=", "tf", ".", "shape", "(", "R", ")", "[", "0", "]", "\n", "rsh", "=", "R", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "R", "=", "tf", ".", "reshape", "(", "R", ",", "[", "-", "1", ",", "(", "degreeMax", "+", "1", ")", "**", "2", "]", ")", "\n", "b", "=", "[", "]", "# list of bispectrum coeffs", "\n", "\n", "# Full range of n1 n2", "\n", "#    for n1 in range(0, math.floor(degreeMax / 2) + 1):", "\n", "#        for n2 in range(n1, math.ceil(degreeMax / 2) + 1):", "\n", "for", "n1", "in", "range", "(", "0", ",", "math", ".", "floor", "(", "degreeMax", "/", "2", ")", "+", "1", ")", ":", "\n", "        ", "for", "n2", "in", "range", "(", "n1", ",", "math", ".", "ceil", "(", "degreeMax", "/", "2", ")", "+", "1", ")", ":", "\n", "            ", "with", "tf", ".", "variable_scope", "(", "\"compute_kronecker\"", ")", ":", "\n", "                ", "K", "=", "[", "]", "# list of Kronecker products", "\n", "for", "m1", "in", "degreeToIndexes_range", "(", "n1", ")", ":", "\n", "                    ", "K", ".", "append", "(", "tf", ".", "multiply", "(", "tf", ".", "expand_dims", "(", "R", "[", "...", ",", "m1", "]", ",", "-", "1", ")", ",", "R", "[", "...", ",", "degreeToIndexes_slice", "(", "n2", ")", "]", ")", ")", "\n", "", "K", "=", "tf", ".", "concat", "(", "K", ",", "axis", "=", "-", "1", ")", "\n", "", "KC", "=", "tf", ".", "matmul", "(", "K", ",", "cg_mat", "[", "(", "n1", ",", "n2", ")", "]", ")", "\n", "\n", "for", "i", "in", "range", "(", "np", ".", "abs", "(", "n1", "-", "n2", ")", ",", "n1", "+", "n2", "+", "1", ")", ":", "\n", "                ", "n_p", "=", "i", "**", "2", "-", "(", "n1", "-", "n2", ")", "**", "2", "\n", "Fi", "=", "tf", ".", "math", ".", "conj", "(", "R", "[", "...", ",", "degreeToIndexes_slice", "(", "i", ")", "]", ")", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "\"compute_KCFi\"", ")", ":", "\n", "                    ", "if", "(", "n1", "+", "n2", "+", "i", ")", "%", "2", "==", "0", ":", "\n", "                        ", "b", ".", "append", "(", "tf", ".", "math", ".", "real", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "KC", "[", ":", ",", "n_p", ":", "n_p", "+", "2", "*", "i", "+", "1", "]", ",", "Fi", ")", ",", "-", "1", ")", ")", ")", "\n", "", "else", ":", "\n", "                        ", "b", ".", "append", "(", "tf", ".", "math", ".", "imag", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "KC", "[", ":", ",", "n_p", ":", "n_p", "+", "2", "*", "i", "+", "1", "]", ",", "Fi", ")", ",", "-", "1", ")", ")", ")", "\n", "\n", "", "", "", "", "", "b", "=", "tf", ".", "stack", "(", "b", ",", "-", "1", ")", "\n", "\n", "# [1] A theory of phase-sensitive rotation invariance with spherical harmonic and moment-based representations", "\n", "\n", "return", "tf", ".", "reshape", "(", "b", ",", "[", "bs", ",", "rsh", "[", "1", "]", ",", "rsh", "[", "2", "]", ",", "rsh", "[", "3", "]", ",", "rsh", "[", "4", "]", "*", "b", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.steer": [[451, 478], ["tf.reshape.get_shape().as_list", "tensorflow.einsum", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.stack", "tensorflow.reshape", "tensorflow.stack", "tensorflow.reshape", "tensorflow.map_fn", "tensorflow.reshape", "tensorflow.transpose", "Sr.get_shape().as_list", "tensorflow.shape", "tensorflow.reshape", "tf.reshape.get_shape", "tensorflow.math.real", "tensorflow.math.imag", "tensorflow.math.real", "tensorflow.reduce_max", "Sr.get_shape", "tensorflow.math.imag", "tensorflow.matmul"], "function", ["None"], ["", "def", "steer", "(", "R", ",", "C", ",", "Sr", ",", "degreeMax", ",", "Ms", "=", "None", ")", ":", "\n", "    ", "'''\n    Returns the steered responses for the set of steering matrices Sr, max pooled on the orientation channels. Output shape: (bs,h,w,d,out_ch,M)\n    R: responses to the hYnm convolutions, complex tensor of shape (bs,h,w,d,out_ch,(degreeMax+1)^2)\n    C: complex tensor of shape: (out_ch,(degreeMax+1)^2)\n    Sr: block diagonal steering matrices of shape (M,(degreeMax+1)^2,(degreeMax+1)^2)\n    degreeMax: maximal SH degree\n    '''", "\n", "M", "=", "Sr", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "\n", "rsh", "=", "R", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "bs", "=", "tf", ".", "shape", "(", "R", ")", "[", "0", "]", "\n", "Cr", "=", "tf", ".", "einsum", "(", "'ij,ajk->aik'", ",", "C", ",", "Sr", ")", "# shape (M, out_ch, (degreeMax+1)^2)", "\n", "\n", "# Splitting real and imag", "\n", "R", "=", "tf", ".", "transpose", "(", "tf", ".", "reshape", "(", "R", ",", "[", "bs", "*", "rsh", "[", "1", "]", "*", "rsh", "[", "2", "]", "*", "rsh", "[", "3", "]", ",", "rsh", "[", "4", "]", ",", "rsh", "[", "5", "]", "]", ")", ",", "\n", "[", "1", ",", "0", ",", "2", "]", ")", "# shape (C, S, (degreeMax+1)^2), where C=bs.h.w.d", "\n", "Cr", "=", "tf", ".", "transpose", "(", "Cr", ",", "[", "1", ",", "2", ",", "0", "]", ")", "# shape (C, (degreeMax+1)^2, M)", "\n", "R", "=", "tf", ".", "stack", "(", "(", "tf", ".", "math", ".", "real", "(", "R", ")", ",", "tf", ".", "math", ".", "imag", "(", "R", ")", ")", ",", "-", "1", ")", "# shape (C, S, (degreeMax+1)^2, im)", "\n", "R", "=", "tf", ".", "reshape", "(", "R", ",", "(", "rsh", "[", "4", "]", ",", "bs", "*", "rsh", "[", "1", "]", "*", "rsh", "[", "2", "]", "*", "rsh", "[", "3", "]", ",", "rsh", "[", "5", "]", "*", "2", ")", ")", "# shape (C, S, (degreeMax+1)^2*im)", "\n", "Cr", "=", "tf", ".", "stack", "(", "(", "tf", ".", "math", ".", "real", "(", "Cr", ")", ",", "-", "tf", ".", "math", ".", "imag", "(", "Cr", ")", ")", ",", "\n", "2", ")", "# shape (C, (degreeMax+1)^2, im, M). There is a -tf.math.imag because i^2=-1", "\n", "Cr", "=", "tf", ".", "reshape", "(", "Cr", ",", "(", "rsh", "[", "4", "]", ",", "rsh", "[", "5", "]", "*", "2", ",", "M", ")", ")", "# shape (C, (degreeMax+1)^2*im, M)", "\n", "# loop over the channels out_ch", "\n", "Rs", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "reduce_max", "(", "tf", ".", "matmul", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ")", ",", "1", ")", ",", "(", "R", ",", "Cr", ")", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "swap_memory", "=", "True", ")", "# shape (out_ch, S)", "\n", "Rs", "=", "tf", ".", "reshape", "(", "Rs", ",", "(", "rsh", "[", "4", "]", ",", "bs", ",", "rsh", "[", "1", "]", ",", "rsh", "[", "2", "]", ",", "rsh", "[", "3", "]", ")", ")", "# shape (out_ch,bs,h,w,d)", "\n", "return", "tf", ".", "transpose", "(", "Rs", ",", "[", "1", ",", "2", ",", "3", ",", "4", ",", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.steer_M": [[480, 507], ["tf.reshape.get_shape().as_list", "tensorflow.einsum", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.stack", "tensorflow.reshape", "tensorflow.stack", "tensorflow.reshape", "tensorflow.map_fn", "tensorflow.transpose", "tensorflow.reshape", "Sr.get_shape().as_list", "tensorflow.shape", "tensorflow.reshape", "tf.reshape.get_shape", "tensorflow.math.real", "tensorflow.math.imag", "tensorflow.math.real", "tensorflow.matmul", "Sr.get_shape", "tensorflow.math.imag"], "function", ["None"], ["", "def", "steer_M", "(", "R", ",", "C", ",", "Sr", ",", "degreeMax", ",", "Ms", "=", "None", ")", ":", "\n", "    ", "'''\n    Returns the steered responses for the set of steering matrices Sr. Output shape: (bs,h,w,d,out_ch*M)\n    R: responses to the hYnm convolutions, complex tensor of shape (bs,h,w,d,out_ch,(degreeMax+1)^2)\n    C: complex tensor of shape: (out_ch,(degreeMax+1)^2)\n    Sr: block diagonal steering matrices of shape (M,(degreeMax+1)^2,(degreeMax+1)^2)\n    degreeMax: maximal SH degree\n    '''", "\n", "M", "=", "Sr", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "\n", "rsh", "=", "R", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "bs", "=", "tf", ".", "shape", "(", "R", ")", "[", "0", "]", "\n", "Cr", "=", "tf", ".", "einsum", "(", "'ij,ajk->aik'", ",", "C", ",", "Sr", ")", "# shape (M, out_ch, (degreeMax+1)^2)", "\n", "\n", "# Splitting real and imag", "\n", "R", "=", "tf", ".", "transpose", "(", "tf", ".", "reshape", "(", "R", ",", "[", "bs", "*", "rsh", "[", "1", "]", "*", "rsh", "[", "2", "]", "*", "rsh", "[", "3", "]", ",", "rsh", "[", "4", "]", ",", "rsh", "[", "5", "]", "]", ")", ",", "\n", "[", "1", ",", "0", ",", "2", "]", ")", "# shape (C, S, (degreeMax+1)^2), where C=bs.h.w.d", "\n", "Cr", "=", "tf", ".", "transpose", "(", "Cr", ",", "[", "1", ",", "2", ",", "0", "]", ")", "# shape (C, (degreeMax+1)^2, M)", "\n", "R", "=", "tf", ".", "stack", "(", "(", "tf", ".", "math", ".", "real", "(", "R", ")", ",", "tf", ".", "math", ".", "imag", "(", "R", ")", ")", ",", "-", "1", ")", "# shape (C, S, (degreeMax+1)^2, im)", "\n", "R", "=", "tf", ".", "reshape", "(", "R", ",", "(", "rsh", "[", "4", "]", ",", "bs", "*", "rsh", "[", "1", "]", "*", "rsh", "[", "2", "]", "*", "rsh", "[", "3", "]", ",", "rsh", "[", "5", "]", "*", "2", ")", ")", "# shape (C, S, (degreeMax+1)^2*im)", "\n", "Cr", "=", "tf", ".", "stack", "(", "(", "tf", ".", "math", ".", "real", "(", "Cr", ")", ",", "-", "tf", ".", "math", ".", "imag", "(", "Cr", ")", ")", ",", "\n", "2", ")", "# shape (C, (degreeMax+1)^2, im, M). There is a -tf.math.imag because i^2=-1", "\n", "Cr", "=", "tf", ".", "reshape", "(", "Cr", ",", "(", "rsh", "[", "4", "]", ",", "rsh", "[", "5", "]", "*", "2", ",", "M", ")", ")", "# shape (C, (degreeMax+1)^2*im, M)", "\n", "# loop over the channels out_ch", "\n", "Rs", "=", "tf", ".", "map_fn", "(", "lambda", "x", ":", "tf", ".", "matmul", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ")", ",", "(", "R", ",", "Cr", ")", ",", "dtype", "=", "tf", ".", "float32", ",", "swap_memory", "=", "True", ")", "# shape (out_ch, S,M)", "\n", "# import pdb;pdb.set_trace()", "\n", "Rs", "=", "tf", ".", "transpose", "(", "Rs", ",", "[", "1", ",", "0", ",", "2", "]", ")", "# shape (S,out_ch,M)", "\n", "return", "tf", ".", "reshape", "(", "Rs", ",", "(", "bs", ",", "rsh", "[", "1", "]", ",", "rsh", "[", "2", "]", ",", "rsh", "[", "3", "]", ",", "rsh", "[", "4", "]", "*", "M", ")", ")", "# shape (bs,h,w,d,out_ch*M)", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.get_euler_angles": [[509, 577], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "ValueError", "str"], "function", ["None"], ["", "def", "get_euler_angles", "(", "M", ")", ":", "\n", "    ", "'''\n    Returns the zyz Euler angles with shape (M, 3) for the defined number of orientations M.\n    (intrinsic Euler angles in the zyz convention)\n    '''", "\n", "if", "M", "==", "1", ":", "\n", "        ", "zyz", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "", "elif", "M", "==", "2", ":", "\n", "        ", "zyz", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "180", ",", "0", ",", "0", "]", "]", ")", "\n", "", "elif", "M", "==", "4", ":", "# Implement Klein's four group see Worrall and Brostow 2018", "\n", "        ", "zyz", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "180", ",", "0", ",", "0", "]", ",", "[", "0", ",", "180", ",", "0", "]", ",", "[", "180", ",", "180", ",", "0", "]", "]", ")", "\n", "", "elif", "M", "==", "8", ":", "# Test of theta and phi.", "\n", "        ", "zyz", "=", "np", ".", "array", "(", "\n", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "45", ",", "315", "]", ",", "[", "0", ",", "90", ",", "270", "]", ",", "[", "0", ",", "135", ",", "225", "]", ",", "[", "0", ",", "180", ",", "180", "]", ",", "[", "0", ",", "225", ",", "135", "]", ",", "[", "0", ",", "270", ",", "90", "]", ",", "\n", "[", "0", ",", "315", ",", "45", "]", "]", ")", "\n", "", "elif", "M", "==", "24", ":", "# as represented in Worrall and Brostow 2018, derived from the Caley's table", "\n", "# For intrinsic Euler angles (each row is for one of the six points on the sphere (theta,phi angles))", "\n", "        ", "zyz", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "90", "]", ",", "[", "0", ",", "0", ",", "180", "]", ",", "[", "0", ",", "0", ",", "270", "]", ",", "\n", "[", "0", ",", "90", ",", "0", "]", ",", "[", "0", ",", "90", ",", "90", "]", ",", "[", "0", ",", "90", ",", "180", "]", ",", "[", "0", ",", "90", ",", "270", "]", ",", "\n", "[", "0", ",", "180", ",", "0", "]", ",", "[", "0", ",", "180", ",", "90", "]", ",", "[", "0", ",", "180", ",", "180", "]", ",", "[", "0", ",", "180", ",", "270", "]", ",", "\n", "[", "0", ",", "270", ",", "0", "]", ",", "[", "0", ",", "270", ",", "90", "]", ",", "[", "0", ",", "270", ",", "180", "]", ",", "[", "0", ",", "270", ",", "270", "]", ",", "\n", "[", "90", ",", "90", ",", "0", "]", ",", "[", "90", ",", "90", ",", "90", "]", ",", "[", "90", ",", "90", ",", "180", "]", ",", "[", "90", ",", "90", ",", "270", "]", ",", "\n", "[", "90", ",", "270", ",", "0", "]", ",", "[", "90", ",", "270", ",", "90", "]", ",", "[", "90", ",", "270", ",", "180", "]", ",", "[", "90", ",", "270", ",", "270", "]", "\n", "]", ")", "\n", "\n", "", "elif", "M", "==", "72", ":", "# as represented in Worrall and Brostow 2018, derived from the Caley's table", "\n", "# For intrinsic Euler angles (each row is for one of the six points on the sphere (theta,phi angles))", "\n", "        ", "zyz", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "90", "]", ",", "[", "0", ",", "0", ",", "180", "]", ",", "[", "0", ",", "0", ",", "270", "]", ",", "\n", "[", "0", ",", "90", ",", "0", "]", ",", "[", "0", ",", "90", ",", "90", "]", ",", "[", "0", ",", "90", ",", "180", "]", ",", "[", "0", ",", "90", ",", "270", "]", ",", "\n", "[", "0", ",", "180", ",", "0", "]", ",", "[", "0", ",", "180", ",", "90", "]", ",", "[", "0", ",", "180", ",", "180", "]", ",", "[", "0", ",", "180", ",", "270", "]", ",", "\n", "[", "0", ",", "270", ",", "0", "]", ",", "[", "0", ",", "270", ",", "90", "]", ",", "[", "0", ",", "270", ",", "180", "]", ",", "[", "0", ",", "270", ",", "270", "]", ",", "\n", "[", "90", ",", "90", ",", "0", "]", ",", "[", "90", ",", "90", ",", "90", "]", ",", "[", "90", ",", "90", ",", "180", "]", ",", "[", "90", ",", "90", ",", "270", "]", ",", "\n", "[", "90", ",", "270", ",", "0", "]", ",", "[", "90", ",", "270", ",", "90", "]", ",", "[", "90", ",", "270", ",", "180", "]", ",", "[", "90", ",", "270", ",", "270", "]", ",", "\n", "\n", "[", "0", ",", "45", ",", "0", "]", ",", "[", "0", ",", "45", ",", "90", "]", ",", "[", "0", ",", "45", ",", "180", "]", ",", "[", "0", ",", "45", ",", "270", "]", ",", "\n", "[", "0", ",", "135", ",", "0", "]", ",", "[", "0", ",", "135", ",", "90", "]", ",", "[", "0", ",", "135", ",", "180", "]", ",", "[", "0", ",", "135", ",", "270", "]", ",", "\n", "[", "0", ",", "225", ",", "0", "]", ",", "[", "0", ",", "225", ",", "90", "]", ",", "[", "0", ",", "225", ",", "180", "]", ",", "[", "0", ",", "225", ",", "270", "]", ",", "\n", "[", "0", ",", "315", ",", "0", "]", ",", "[", "0", ",", "315", ",", "90", "]", ",", "[", "0", ",", "315", ",", "180", "]", ",", "[", "0", ",", "315", ",", "270", "]", ",", "\n", "\n", "[", "90", ",", "45", ",", "0", "]", ",", "[", "90", ",", "45", ",", "90", "]", ",", "[", "90", ",", "45", ",", "180", "]", ",", "[", "90", ",", "45", ",", "270", "]", ",", "\n", "[", "90", ",", "135", ",", "0", "]", ",", "[", "90", ",", "135", ",", "90", "]", ",", "[", "90", ",", "135", ",", "180", "]", ",", "[", "90", ",", "135", ",", "270", "]", ",", "\n", "[", "90", ",", "225", ",", "0", "]", ",", "[", "90", ",", "225", ",", "90", "]", ",", "[", "90", ",", "225", ",", "180", "]", ",", "[", "90", ",", "225", ",", "270", "]", ",", "\n", "[", "90", ",", "315", ",", "0", "]", ",", "[", "90", ",", "315", ",", "90", "]", ",", "[", "90", ",", "315", ",", "180", "]", ",", "[", "90", ",", "315", ",", "270", "]", ",", "\n", "\n", "[", "45", ",", "90", ",", "0", "]", ",", "[", "45", ",", "90", ",", "90", "]", ",", "[", "45", ",", "90", ",", "180", "]", ",", "[", "45", ",", "90", ",", "270", "]", ",", "\n", "[", "135", ",", "90", ",", "0", "]", ",", "[", "135", ",", "90", ",", "90", "]", ",", "[", "135", ",", "90", ",", "180", "]", ",", "[", "135", ",", "90", ",", "270", "]", ",", "\n", "[", "45", ",", "270", ",", "0", "]", ",", "[", "45", ",", "270", ",", "90", "]", ",", "[", "45", ",", "270", ",", "180", "]", ",", "[", "45", ",", "270", ",", "270", "]", ",", "\n", "[", "135", ",", "270", ",", "0", "]", ",", "[", "135", ",", "270", ",", "90", "]", ",", "[", "135", ",", "270", ",", "180", "]", ",", "[", "135", ",", "270", ",", "270", "]", "\n", "]", ")", "\n", "\n", "", "else", ":", "# TO DO", "\n", "        ", "raise", "ValueError", "(", "\"M = \"", "+", "str", "(", "M", ")", "+", "\" not yet implemented. Try 1, 4, 24 or 72\"", ")", "\n", "''' XXX\n        # Parametrized uniform triangulation of 3D circle/sphere:\n        n_gamma = 4\n\n        # No need for stlPoints AND A, B, C\n        stlPoints, _, _, _ = sphereTriangulation(M,n_gamma)\n        # Then do spherical coordinates to get the alpha and beta angles uniformly sampled on the sphere.\n        alpha,beta = change_vars(np.swapaxes(stlPoints,0,1)) # The Euler angles alpha and beta are respectively theta and phi in spherical coord.\n        # Then sample uniformly on gamma\n        step_gamma = 2*pi/n_gamma\n        gamma = np.tile(np.linspace(0,2*pi-step_gamma,n_gamma),alpha.shape[0])\n        alpha = np.repeat(alpha,n_gamma)\n        beta = np.repeat(beta,n_gamma)\n        zyz = np.stack((alpha,beta,gamma),axis=1)*180.0/pi\n        '''", "\n", "", "return", "zyz", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.degreeToIndexes_range": [[579, 581], ["range"], "function", ["None"], ["", "def", "degreeToIndexes_range", "(", "n", ")", ":", "\n", "    ", "return", "range", "(", "n", "*", "n", ",", "n", "*", "n", "+", "2", "*", "n", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.degreeToIndexes_slice": [[583, 585], ["slice"], "function", ["None"], ["", "def", "degreeToIndexes_slice", "(", "n", ")", ":", "\n", "    ", "return", "slice", "(", "n", "*", "n", ",", "n", "*", "n", "+", "2", "*", "n", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.compute_cg_matrix": [[587, 609], ["numpy.zeros", "range", "abs", "range", "range", "range", "sympy.physics.quantum.cg.CG().doit", "sympy.physics.quantum.cg.CG"], "function", ["None"], ["", "def", "compute_cg_matrix", "(", "k", ",", "l", ")", ":", "\n", "    ", "'''\n    Computes the matrix that block-diagonilizes the Kronecker product of Wigned D matrices of degree k and l respectively\n    Output size (2k+1)(2l+1)x(2k+1)(2l+1)\n    '''", "\n", "c_kl", "=", "np", ".", "zeros", "(", "[", "(", "2", "*", "k", "+", "1", ")", "*", "(", "2", "*", "l", "+", "1", ")", ",", "(", "2", "*", "k", "+", "1", ")", "*", "(", "2", "*", "l", "+", "1", ")", "]", ")", "\n", "\n", "n_off", "=", "0", "\n", "for", "J", "in", "range", "(", "abs", "(", "k", "-", "l", ")", ",", "k", "+", "l", "+", "1", ")", ":", "\n", "        ", "m_off", "=", "0", "\n", "for", "m1_i", "in", "range", "(", "2", "*", "k", "+", "1", ")", ":", "\n", "            ", "m1", "=", "m1_i", "-", "k", "\n", "for", "m2_i", "in", "range", "(", "2", "*", "l", "+", "1", ")", ":", "\n", "                ", "m2", "=", "m2_i", "-", "l", "\n", "for", "n_i", "in", "range", "(", "2", "*", "J", "+", "1", ")", ":", "\n", "                    ", "n", "=", "n_i", "-", "J", "\n", "if", "m1", "+", "m2", "==", "n", ":", "\n", "                        ", "c_kl", "[", "m_off", "+", "m2_i", ",", "n_off", "+", "n_i", "]", "=", "CG", "(", "k", ",", "m1", ",", "l", ",", "m2", ",", "J", ",", "m1", "+", "m2", ")", ".", "doit", "(", ")", "\n", "", "", "", "m_off", "=", "m_off", "+", "2", "*", "l", "+", "1", "\n", "", "n_off", "=", "n_off", "+", "2", "*", "J", "+", "1", "\n", "\n", "", "return", "c_kl", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.sphereTriangulation": [[613, 683], ["int", "numpy.asarray", "numpy.arange", "range", "numpy.arange", "numpy.stack", "numpy.swapaxes", "numpy.concatenate", "numpy.concatenate", "numpy.asarray", "numpy.asarray", "numpy.asarray", "sh_networks_utils.arsUnit", "sh_networks_utils.arsUnit", "sh_networks_utils.arsUnit", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.shape", "len"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.arsUnit", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.arsUnit", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.arsUnit"], ["", "def", "sphereTriangulation", "(", "M", ",", "n_gamma", ")", ":", "\n", "    ", "'''\n    Defines points on the sphere that we use for alpha (z) and beta (y') Euler angles sampling. We can have 24 points (numIterations=0), 72 (numIterations=1), 384 (numIterations=2) etc.\n    Copied from the matlab function https://ch.mathworks.com/matlabcentral/fileexchange/38909-parametrized-uniform-triangulation-of-3d-circle-sphere\n    M is the number total of orientation, i.e. number of points on the sphere + number of angles for the gamma angle (n_gamma).\n\n    '''", "\n", "#", "\n", "numIter", "=", "int", "(", "(", "M", "/", "24", ")", "**", "(", "1", "/", "n_gamma", ")", "-", "1", ")", "\n", "# function returns stlPoints fromat and ABC format if its needed,if not - just delete it and adapt to your needs", "\n", "radius", "=", "1", "\n", "# basic Octahedron reff:http://en.wikipedia.org/wiki/Octahedron", "\n", "# ( ?1, 0, 0 )", "\n", "# ( 0, ?1, 0 )", "\n", "# ( 0, 0, ?1 )", "\n", "A", "=", "np", ".", "asarray", "(", "[", "1", ",", "0", ",", "0", "]", ")", "*", "radius", "\n", "B", "=", "np", ".", "asarray", "(", "[", "0", ",", "1", ",", "0", "]", ")", "*", "radius", "\n", "C", "=", "np", ".", "asarray", "(", "[", "0", ",", "0", ",", "1", "]", ")", "*", "radius", "\n", "# from +-ABC create initial triangles which define oxahedron", "\n", "triangles", "=", "np", ".", "asarray", "(", "[", "A", ",", "B", ",", "C", ",", "\n", "A", ",", "B", ",", "-", "C", ",", "\n", "# -x, +y, +-Z quadrant", "\n", "-", "A", ",", "B", ",", "C", ",", "\n", "-", "A", ",", "B", ",", "-", "C", ",", "\n", "# -x, -y, +-Z quadrant", "\n", "-", "A", ",", "-", "B", ",", "C", ",", "\n", "-", "A", ",", "-", "B", ",", "-", "C", ",", "\n", "# +x, -y, +-Z quadrant", "\n", "A", ",", "-", "B", ",", "C", ",", "\n", "A", ",", "-", "B", ",", "-", "C", "]", ")", "# -----STL-similar format", "\n", "# for simplicity lets break into ABC points...", "\n", "selector", "=", "np", ".", "arange", "(", "0", ",", "len", "(", "triangles", "[", ":", ",", "1", "]", ")", "-", "2", ",", "3", ")", "\n", "Apoints", "=", "triangles", "[", "selector", ",", ":", "]", "\n", "Bpoints", "=", "triangles", "[", "selector", "+", "1", ",", ":", "]", "\n", "Cpoints", "=", "triangles", "[", "selector", "+", "2", ",", ":", "]", "\n", "# in every of numIterations", "\n", "for", "iteration", "in", "range", "(", "numIter", ")", ":", "\n", "# devide every of triangle on three new", "\n", "#        ^ C", "\n", "#       / \\", "\n", "# AC/2 /_4_\\CB/2", "\n", "#     /\\ 3 /\\", "\n", "#    / 1\\ /2 \\", "\n", "# A /____V____\\B           1st              2nd              3rd               4th", "\n", "#        AB/2", "\n", "# new triangleSteck is [ A AB/2 AC/2;     AB/2 B CB/2;     AC/2 AB/2 CB/2    AC/2 CB/2 C]", "\n", "        ", "AB_2", "=", "(", "Apoints", "+", "Bpoints", ")", "/", "2", "\n", "# do normalization of vector", "\n", "AB_2", "=", "arsUnit", "(", "AB_2", ",", "radius", ")", "# same for next 2 lines", "\n", "AC_2", "=", "(", "Apoints", "+", "Cpoints", ")", "/", "2", "\n", "AC_2", "=", "arsUnit", "(", "AC_2", ",", "radius", ")", "\n", "CB_2", "=", "(", "Cpoints", "+", "Bpoints", ")", "/", "2", "\n", "CB_2", "=", "arsUnit", "(", "CB_2", ",", "radius", ")", "\n", "Apoints", "=", "np", ".", "concatenate", "(", "(", "Apoints", ",", "# A point from 1st triangle", "\n", "AB_2", ",", "# A point from 2nd triangle", "\n", "AC_2", ",", "# A point from 3rd triangle", "\n", "AC_2", ")", ")", "# A point from 4th triangle..same for B and C", "\n", "Bpoints", "=", "np", ".", "concatenate", "(", "(", "AB_2", ",", "Bpoints", ",", "AB_2", ",", "CB_2", ")", ")", "\n", "Cpoints", "=", "np", ".", "concatenate", "(", "(", "AC_2", ",", "CB_2", ",", "CB_2", ",", "Cpoints", ")", ")", "\n", "# now tur points back to STL-like format....", "\n", "", "numPoints", "=", "np", ".", "shape", "(", "Apoints", ")", "[", "0", "]", "\n", "selector", "=", "np", ".", "arange", "(", "numPoints", ")", "\n", "selector", "=", "np", ".", "stack", "(", "(", "selector", ",", "selector", "+", "numPoints", ",", "selector", "+", "2", "*", "numPoints", ")", ")", "\n", "\n", "selector", "=", "np", ".", "swapaxes", "(", "selector", ",", "0", ",", "1", ")", "\n", "selector", "=", "np", ".", "concatenate", "(", "selector", ")", "\n", "stlPoints", "=", "np", ".", "concatenate", "(", "(", "Apoints", ",", "Bpoints", ",", "Cpoints", ")", ")", "\n", "stlPoints", "=", "stlPoints", "[", "selector", ",", ":", "]", "\n", "\n", "return", "stlPoints", ",", "Apoints", ",", "Bpoints", ",", "Cpoints", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.change_vars": [[685, 698], ["numpy.sqrt", "numpy.squeeze", "numpy.squeeze", "numpy.sum", "numpy.squeeze", "numpy.arccos", "numpy.square", "numpy.arctan2", "numpy.isnan"], "function", ["None"], ["", "def", "change_vars", "(", "MG", ")", ":", "\n", "    ", "'''\n    MG: np array of shape (3,...) containing 3D cartesian coordinates.\n    returns spherical coordinates theta and phi (could return rho if needed)\n    '''", "\n", "rho", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "square", "(", "MG", ")", ",", "axis", "=", "0", ")", ")", "\n", "phi", "=", "np", ".", "squeeze", "(", "np", ".", "arctan2", "(", "MG", "[", "1", ",", "...", "]", ",", "MG", "[", "0", ",", "...", "]", ")", ")", "+", "pi", "\n", "theta", "=", "np", ".", "squeeze", "(", "np", ".", "arccos", "(", "MG", "[", "2", ",", "...", "]", "/", "rho", ")", ")", "\n", "# The center value is Nan due to the 0/0. So make it 0.", "\n", "theta", "[", "np", ".", "isnan", "(", "theta", ")", "]", "=", "0", "\n", "rho", "=", "np", ".", "squeeze", "(", "rho", ")", "\n", "\n", "return", "theta", ",", "phi", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.arsNorm": [[700, 705], ["numpy.sqrt"], "function", ["None"], ["", "def", "arsNorm", "(", "A", ")", ":", "\n", "# vectorized norm() function", "\n", "    ", "rez", "=", "A", "[", ":", ",", "0", "]", "**", "2", "+", "A", "[", ":", ",", "1", "]", "**", "2", "+", "A", "[", ":", ",", "2", "]", "**", "2", "\n", "rez", "=", "np", ".", "sqrt", "(", "rez", ")", "\n", "return", "rez", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.arsUnit": [[707, 713], ["sh_networks_utils.arsNorm", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.arsNorm"], ["", "def", "arsUnit", "(", "A", ",", "radius", ")", ":", "\n", "# vectorized unit() functon", "\n", "    ", "normOfA", "=", "arsNorm", "(", "A", ")", "\n", "rez", "=", "A", "/", "np", ".", "stack", "(", "(", "normOfA", ",", "normOfA", ",", "normOfA", ")", ",", "1", ")", "\n", "rez", "=", "rez", "*", "radius", "\n", "return", "rez", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.conv3d": [[12, 16], ["tensorflow.nn.bias_add", "tensorflow.nn.conv3d"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.conv3d"], ["def", "conv3d", "(", "name", ",", "l_input", ",", "w", ",", "b", ",", "stride", "=", "1", ")", ":", "\n", "    ", "return", "tf", ".", "nn", ".", "bias_add", "(", "\n", "tf", ".", "nn", ".", "conv3d", "(", "l_input", ",", "w", ",", "strides", "=", "[", "1", ",", "stride", ",", "stride", ",", "stride", ",", "1", "]", ",", "padding", "=", "'VALID'", ")", ",", "\n", "b", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.gavg_pool": [[19, 28], ["tensorflow.reduce_mean", "len", "ValueError", "X.get_shape().as_list", "X.get_shape"], "function", ["None"], ["", "def", "gavg_pool", "(", "name", ",", "X", ")", ":", "\n", "    ", "\"\"\"\n    Returns the 3D global average pool of the feature maps, with or without orientation channel.\n    Ouptut shape: (bs,out_ch) or (bs,out_ch*M)\n    X: shape (bs,h,w,d,out_ch) or (bs,h,w,d,out_ch*M)\n    \"\"\"", "\n", "if", "len", "(", "X", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "!=", "5", ":", "\n", "        ", "raise", "ValueError", "(", "'X unexpected shape. Expected shape (bs,h,w,d,out_ch) or (bs,h,w,d,out_ch*M).'", ")", "\n", "", "return", "tf", ".", "reduce_mean", "(", "X", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.transform_matrix_offset_center_fixed": [[32, 47], ["numpy.array", "numpy.array", "numpy.dot", "numpy.dot", "float", "float", "float"], "function", ["None"], ["", "def", "transform_matrix_offset_center_fixed", "(", "matrix", ",", "x", ",", "y", ",", "z", ")", ":", "\n", "# Based on keras implementation that is wrong. It should be - 0.5 ", "\n", "    ", "o_x", "=", "float", "(", "x", ")", "/", "2", "-", "0.5", "\n", "o_y", "=", "float", "(", "y", ")", "/", "2", "-", "0.5", "\n", "o_z", "=", "float", "(", "z", ")", "/", "2", "-", "0.5", "\n", "offset_matrix", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", ",", "o_x", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "o_y", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "o_z", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "reset_matrix", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", ",", "-", "o_x", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "-", "o_y", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "-", "o_z", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "transform_matrix", "=", "np", ".", "dot", "(", "np", ".", "dot", "(", "offset_matrix", ",", "matrix", ")", ",", "reset_matrix", ")", "\n", "return", "transform_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.apply_affine_transform_fixed": [[49, 186], ["ImportError", "numpy.deg2rad", "numpy.array", "numpy.deg2rad", "numpy.asarray", "numpy.deg2rad", "numpy.asarray", "numpy.array", "numpy.deg2rad", "numpy.array", "numpy.deg2rad", "numpy.array", "numpy.deg2rad", "numpy.array", "numpy.array", "utils.transform_matrix_offset_center_fixed", "scipy.ndimage.interpolation.affine_transform", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.sin", "numpy.sin", "numpy.sin", "numpy.sin", "numpy.sin"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.transform_matrix_offset_center_fixed"], ["", "def", "apply_affine_transform_fixed", "(", "x", ",", "theta_xyz", "=", "(", "0", ",", "0", ",", "0", ")", ",", "tx", "=", "0", ",", "ty", "=", "0", ",", "tz", "=", "0", ",", "shear_xy", "=", "0", ",", "shear_xz", "=", "0", ",", "shear_yz", "=", "0", ",", "\n", "zx", "=", "1", ",", "zy", "=", "1", ",", "zz", "=", "1", ",", "row_axis", "=", "0", ",", "col_axis", "=", "1", ",", "z_axis", "=", "2", ",", "\n", "channel_axis", "=", "3", ",", "fill_mode", "=", "'nearest'", ",", "cval", "=", "0.", ",", "order", "=", "1", ")", ":", "\n", "    ", "\"\"\"Applies an affine transformation specified by the parameters given.\n\n    # Arguments\n        x: 3D numpy array, single image.\n        theta_xyz: rotation angles\n        theta: Azimutal rotation angle in degrees.\n        phi: Polar rotation angle in degrees.\n        tx: Width shift.\n        ty: Heigh shift.\n        tz: depth shift.\n        shear_xy: Shear angle in degrees on the xy plane.\n        shear_xz: Shear angle in degrees on the xz plane.\n        zx: Zoom in x direction.\n        zy: Zoom in y direction\n        zz: Zoom in z direction\n        row_axis: Index of axis for rows in the input image.\n        col_axis: Index of axis for columns in the input image.\n        z_axis: Index of axis for depth in the input image.\n        channel_axis: Index of axis for channels in the input image.\n        fill_mode: Points outside the boundaries of the input\n            are filled according to the given mode\n            (one of `{'constant', 'nearest', 'reflect', 'wrap'}`).\n        cval: Value used for points outside the boundaries\n            of the input if `mode='constant'`.\n\n    # Returns\n        The transformed version of the input.\n    \"\"\"", "\n", "theta_x", "=", "theta_xyz", "[", "0", "]", "\n", "theta_y", "=", "theta_xyz", "[", "1", "]", "\n", "theta_z", "=", "theta_xyz", "[", "2", "]", "\n", "if", "scipy", "is", "None", ":", "\n", "        ", "raise", "ImportError", "(", "'Image transformations require SciPy. '", "\n", "'Install SciPy.'", ")", "\n", "", "transform_matrix", "=", "None", "\n", "if", "theta_x", "!=", "0", ":", "\n", "        ", "theta", "=", "np", ".", "deg2rad", "(", "theta_x", ")", "\n", "rotation_matrix", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "np", ".", "cos", "(", "theta", ")", ",", "-", "np", ".", "sin", "(", "theta", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "np", ".", "sin", "(", "theta", ")", ",", "np", ".", "cos", "(", "theta", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "transform_matrix", "=", "rotation_matrix", "\n", "\n", "", "if", "theta_y", "!=", "0", ":", "\n", "\n", "        ", "theta", "=", "np", ".", "deg2rad", "(", "theta_y", ")", "\n", "rotation_matrix", "=", "np", ".", "asarray", "(", "[", "[", "np", ".", "cos", "(", "theta", ")", ",", "0", ",", "np", ".", "sin", "(", "theta", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "-", "np", ".", "sin", "(", "theta", ")", ",", "0", ",", "np", ".", "cos", "(", "theta", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "if", "transform_matrix", "is", "None", ":", "\n", "            ", "transform_matrix", "=", "rotation_matrix", "\n", "", "else", ":", "\n", "            ", "transform_matrix", "=", "np", ".", "dot", "(", "transform_matrix", ",", "rotation_matrix", ")", "\n", "\n", "", "", "if", "theta_z", "!=", "0", ":", "\n", "        ", "theta", "=", "np", ".", "deg2rad", "(", "theta_z", ")", "\n", "rotation_matrix", "=", "np", ".", "asarray", "(", "[", "[", "np", ".", "cos", "(", "theta", ")", ",", "-", "np", ".", "sin", "(", "theta", ")", ",", "0", ",", "0", "]", ",", "\n", "[", "np", ".", "sin", "(", "theta", ")", ",", "np", ".", "cos", "(", "theta", ")", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "if", "transform_matrix", "is", "None", ":", "\n", "            ", "transform_matrix", "=", "rotation_matrix", "\n", "", "else", ":", "\n", "            ", "transform_matrix", "=", "np", ".", "dot", "(", "transform_matrix", ",", "rotation_matrix", ")", "\n", "", "", "if", "tx", "!=", "0", "or", "ty", "!=", "0", "or", "tz", "!=", "0", ":", "\n", "        ", "shift_matrix", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", ",", "tx", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "ty", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "tz", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "if", "transform_matrix", "is", "None", ":", "\n", "            ", "transform_matrix", "=", "shift_matrix", "\n", "", "else", ":", "\n", "            ", "transform_matrix", "=", "np", ".", "dot", "(", "transform_matrix", ",", "shift_matrix", ")", "\n", "\n", "", "", "if", "shear_xy", "!=", "0", ":", "\n", "        ", "shear", "=", "np", ".", "deg2rad", "(", "shear_xy", ")", "\n", "shear_matrix", "=", "np", ".", "array", "(", "[", "[", "1", ",", "-", "np", ".", "sin", "(", "shear", ")", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "np", ".", "cos", "(", "shear", ")", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "if", "transform_matrix", "is", "None", ":", "\n", "            ", "transform_matrix", "=", "shear_matrix", "\n", "", "else", ":", "\n", "            ", "transform_matrix", "=", "np", ".", "dot", "(", "transform_matrix", ",", "shear_matrix", ")", "\n", "\n", "", "", "if", "shear_xz", "!=", "0", ":", "\n", "        ", "shear", "=", "np", ".", "deg2rad", "(", "shear_xz", ")", "\n", "shear_matrix", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "-", "np", ".", "sin", "(", "shear", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "np", ".", "cos", "(", "shear", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "if", "transform_matrix", "is", "None", ":", "\n", "            ", "transform_matrix", "=", "shear_matrix", "\n", "", "else", ":", "\n", "            ", "transform_matrix", "=", "np", ".", "dot", "(", "transform_matrix", ",", "shear_matrix", ")", "\n", "\n", "", "", "if", "shear_yz", "!=", "0", ":", "\n", "        ", "shear", "=", "np", ".", "deg2rad", "(", "shear_yz", ")", "\n", "shear_matrix", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "-", "np", ".", "sin", "(", "shear", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "np", ".", "cos", "(", "shear", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "if", "transform_matrix", "is", "None", ":", "\n", "            ", "transform_matrix", "=", "shear_matrix", "\n", "", "else", ":", "\n", "            ", "transform_matrix", "=", "np", ".", "dot", "(", "transform_matrix", ",", "shear_matrix", ")", "\n", "\n", "", "", "if", "zx", "!=", "1", "or", "zy", "!=", "1", "or", "zz", "!=", "1", ":", "\n", "        ", "zoom_matrix", "=", "np", ".", "array", "(", "[", "[", "zx", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "zy", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "zz", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "if", "transform_matrix", "is", "None", ":", "\n", "            ", "transform_matrix", "=", "zoom_matrix", "\n", "", "else", ":", "\n", "            ", "transform_matrix", "=", "np", ".", "dot", "(", "transform_matrix", ",", "zoom_matrix", ")", "\n", "\n", "", "", "if", "transform_matrix", "is", "not", "None", ":", "\n", "        ", "h", ",", "w", ",", "d", "=", "x", ".", "shape", "[", "row_axis", "]", ",", "x", ".", "shape", "[", "col_axis", "]", ",", "x", ".", "shape", "[", "z_axis", "]", "\n", "transform_matrix", "=", "transform_matrix_offset_center_fixed", "(", "\n", "transform_matrix", ",", "h", ",", "w", ",", "d", ")", "\n", "final_affine_matrix", "=", "transform_matrix", "[", ":", "3", ",", ":", "3", "]", "\n", "final_offset", "=", "transform_matrix", "[", ":", "3", ",", "3", "]", "\n", "\n", "x", "=", "scipy", ".", "ndimage", ".", "interpolation", ".", "affine_transform", "(", "\n", "x", ",", "\n", "final_affine_matrix", ",", "\n", "final_offset", ",", "\n", "order", "=", "order", ",", "\n", "mode", "=", "fill_mode", ",", "\n", "cval", "=", "cval", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.copy_template": [[188, 211], ["int", "max", "max", "max", "max", "max", "max", "max", "min", "max", "min", "max", "min"], "function", ["None"], ["", "def", "copy_template", "(", "cube", ",", "t", ",", "pos", ")", ":", "\n", "    ", "\"\"\"\n    Returns a cube with the template t copied at position pos\n    cube: 3D array of the cube\n    t: 3D array of the template\n    pos: [x y z] position in the cube\n    \"\"\"", "\n", "\n", "cube_size", "=", "cube", ".", "shape", "[", "0", "]", "\n", "margin", "=", "int", "(", "t", ".", "shape", "[", "0", "]", "/", "2", ")", "# if the position is on the side of the cube with this margin, the template won't be", "\n", "# copied entirely or it is outside the cube", "\n", "x_out1", "=", "max", "(", "0", ",", "margin", "-", "pos", "[", "0", "]", ")", "\n", "x_out2", "=", "max", "(", "0", ",", "pos", "[", "0", "]", "-", "(", "cube_size", "-", "margin", "-", "1", ")", ")", "\n", "y_out1", "=", "max", "(", "0", ",", "margin", "-", "pos", "[", "1", "]", ")", "\n", "y_out2", "=", "max", "(", "0", ",", "pos", "[", "1", "]", "-", "(", "cube_size", "-", "margin", "-", "1", ")", ")", "\n", "z_out1", "=", "max", "(", "0", ",", "margin", "-", "pos", "[", "2", "]", ")", "\n", "z_out2", "=", "max", "(", "0", ",", "pos", "[", "2", "]", "-", "(", "cube_size", "-", "margin", "-", "1", ")", ")", "\n", "cube", "[", "max", "(", "0", ",", "pos", "[", "0", "]", "-", "margin", ")", ":", "min", "(", "cube_size", ",", "pos", "[", "0", "]", "+", "margin", "+", "1", ")", ",", "\n", "max", "(", "0", ",", "pos", "[", "1", "]", "-", "margin", ")", ":", "min", "(", "cube_size", ",", "pos", "[", "1", "]", "+", "margin", "+", "1", ")", ",", "\n", "max", "(", "0", ",", "pos", "[", "2", "]", "-", "margin", ")", ":", "min", "(", "cube_size", ",", "pos", "[", "2", "]", "+", "margin", "+", "1", ")", "]", "=", "t", "[", "x_out1", ":", "t", ".", "shape", "[", "0", "]", "-", "x_out2", ",", "\n", "y_out1", ":", "t", ".", "shape", "[", "1", "]", "-", "y_out2", ",", "\n", "z_out1", ":", "t", ".", "shape", "[", "2", "]", "-", "z_out2", "]", "\n", "return", "cube", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.next_batch": [[213, 242], ["numpy.arange", "numpy.random.shuffle", "len", "numpy.array", "numpy.expand_dims", "numpy.asarray", "numpy.asarray", "utils.apply_affine_transform_fixed", "numpy.squeeze", "range", "numpy.random.randint", "len"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.apply_affine_transform_fixed"], ["", "def", "next_batch", "(", "num", ",", "data", ",", "labels", ",", "is_augment", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Returns a total of `num` random samples and labels.\n    num: number of samples returned (batch size)\n    data: volumes to sample from\n    labels: ground truth labels to sample from\n    augment: whether random 3D right-angle rotation (default=None)\n    \"\"\"", "\n", "idx", "=", "np", ".", "arange", "(", "0", ",", "len", "(", "data", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "idx", ")", "\n", "idx", "=", "idx", "[", ":", "num", "]", "\n", "# randomly generate right-angle rotations", "\n", "if", "is_augment", ":", "\n", "        ", "xyz", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "90", ",", "0", ",", "0", "]", ",", "[", "180", ",", "0", ",", "0", "]", ",", "[", "270", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "90", ",", "0", "]", ",", "[", "0", ",", "90", ",", "270", "]", ",", "[", "0", ",", "90", ",", "180", "]", ",", "[", "0", ",", "90", ",", "90", "]", ",", "\n", "[", "0", ",", "180", ",", "0", "]", ",", "[", "90", ",", "180", ",", "0", "]", ",", "[", "180", ",", "180", ",", "0", "]", ",", "[", "270", ",", "180", ",", "0", "]", ",", "\n", "[", "0", ",", "270", ",", "0", "]", ",", "[", "0", ",", "270", ",", "90", "]", ",", "[", "0", ",", "270", ",", "180", "]", ",", "[", "0", ",", "270", ",", "270", "]", ",", "\n", "[", "90", ",", "0", ",", "90", "]", ",", "[", "180", ",", "0", ",", "90", "]", ",", "[", "270", ",", "0", ",", "90", "]", ",", "[", "0", ",", "0", ",", "90", "]", ",", "\n", "[", "90", ",", "0", ",", "270", "]", ",", "[", "180", ",", "0", ",", "270", "]", ",", "[", "270", ",", "0", ",", "270", "]", ",", "[", "0", ",", "0", ",", "270", "]", "\n", "]", ")", "\n", "nxyz", "=", "xyz", ".", "shape", "[", "0", "]", "\n", "random_angles", "=", "[", "xyz", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "nxyz", ")", "]", "for", "i", "in", "idx", "]", "\n", "data_shuffle", "=", "[", "apply_affine_transform_fixed", "(", "np", ".", "squeeze", "(", "data", "[", "idx", "[", "i", "]", "]", ")", ",", "theta_xyz", "=", "random_angles", "[", "i", "]", ")", "for", "i", "in", "\n", "range", "(", "len", "(", "idx", ")", ")", "]", "\n", "data_shuffle", "=", "np", ".", "expand_dims", "(", "data_shuffle", ",", "axis", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "data_shuffle", "=", "[", "data", "[", "i", "]", "for", "i", "in", "idx", "]", "\n", "", "labels_shuffle", "=", "[", "labels", "[", "i", "]", "for", "i", "in", "idx", "]", "\n", "return", "np", ".", "asarray", "(", "data_shuffle", ")", ",", "np", ".", "asarray", "(", "labels_shuffle", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.normalize": [[246, 251], ["None"], "function", ["None"], ["", "def", "normalize", "(", "image", ",", "min_HU", ",", "max_HU", ")", ":", "\n", "    ", "image", "=", "(", "image", "-", "min_HU", ")", "/", "(", "max_HU", "-", "min_HU", ")", "\n", "image", "[", "image", ">", "1", "]", "=", "1.", "\n", "image", "[", "image", "<", "0", "]", "=", "0.", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.zero_center": [[253, 256], ["None"], "function", ["None"], ["", "def", "zero_center", "(", "image", ",", "mean_vox", ")", ":", "\n", "    ", "image", "=", "image", "-", "mean_vox", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.crop_center": [[258, 264], ["None"], "function", ["None"], ["", "def", "crop_center", "(", "vol", ",", "crop", ")", ":", "\n", "    ", "x", ",", "y", ",", "z", "=", "vol", ".", "shape", "\n", "startx", "=", "x", "//", "2", "-", "(", "crop", "//", "2", ")", "\n", "starty", "=", "y", "//", "2", "-", "(", "crop", "//", "2", ")", "\n", "startz", "=", "z", "//", "2", "-", "(", "crop", "//", "2", ")", "\n", "return", "vol", "[", "startx", ":", "startx", "+", "crop", ",", "starty", ":", "starty", "+", "crop", ",", "startz", ":", "startz", "+", "crop", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.region_pool": [[268, 275], ["tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.multiply"], "function", ["None"], ["", "def", "region_pool", "(", "name", ",", "X", ",", "Mask", ")", ":", "\n", "    ", "\"\"\"\n    Returns global average pool in a region of the feature maps.\n    X: feature maps\n    Mask: binary mask\n    \"\"\"", "\n", "return", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "X", ",", "Mask", ")", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "/", "tf", ".", "reduce_sum", "(", "Mask", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.region_poolext": [[277, 294], ["tf.transpose.get_shape().as_list", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.concat", "tensorflow.shape", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tf.transpose.get_shape", "tensorflow.multiply", "int", "tensorflow.multiply"], "function", ["None"], ["", "def", "region_poolext", "(", "name", ",", "X", ",", "Mask", ")", ":", "\n", "    ", "\"\"\"\n    Returns extended global average pool in a region of the feature maps.\n    X: feature maps\n    Mask: binary mask\n    \"\"\"", "\n", "Xsh", "=", "X", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "bs", "=", "tf", ".", "shape", "(", "X", ")", "[", "0", "]", "\n", "mean_region", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "X", ",", "Mask", ")", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "/", "tf", ".", "reduce_sum", "(", "Mask", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "size_region", "=", "tf", ".", "reduce_sum", "(", "Mask", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "/", "int", "(", "Mask", ".", "shape", "[", "1", "]", ")", "**", "3", "\n", "\n", "# Reshape the feature maps and the mask to compute the variance.", "\n", "X", "=", "tf", ".", "transpose", "(", "tf", ".", "reshape", "(", "X", ",", "[", "bs", ",", "Xsh", "[", "1", "]", "*", "Xsh", "[", "2", "]", "*", "Xsh", "[", "3", "]", ",", "Xsh", "[", "4", "]", "]", ")", ",", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "Mask", "=", "tf", ".", "transpose", "(", "tf", ".", "reshape", "(", "Mask", ",", "[", "bs", ",", "Xsh", "[", "1", "]", "*", "Xsh", "[", "2", "]", "*", "Xsh", "[", "3", "]", ",", "1", "]", ")", ",", "[", "1", ",", "0", ",", "2", "]", ")", "\n", "\n", "var_region", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "multiply", "(", "(", "X", "-", "mean_region", ")", "**", "2", ",", "Mask", ")", ",", "axis", "=", "[", "0", "]", ")", "/", "tf", ".", "reduce_sum", "(", "Mask", ",", "axis", "=", "[", "0", "]", ")", "\n", "return", "tf", ".", "concat", "(", "[", "mean_region", ",", "size_region", ",", "var_region", "]", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.region_poolsize": [[296, 303], ["tensorflow.reduce_sum", "int"], "function", ["None"], ["", "def", "region_poolsize", "(", "name", ",", "Mask", ")", ":", "\n", "    ", "\"\"\"\n    Returns the size of the region only\n    Mask: binary mask\n    \"\"\"", "\n", "size_region", "=", "tf", ".", "reduce_sum", "(", "Mask", ",", "axis", "=", "[", "1", ",", "2", ",", "3", "]", ")", "/", "int", "(", "Mask", ".", "shape", "[", "1", "]", ")", "**", "3", "\n", "return", "size_region", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.maskReshape": [[305, 312], ["tensorflow.nn.avg_pool3d"], "function", ["None"], ["", "def", "maskReshape", "(", "Mask", ",", "ksize", ",", "stride", ")", ":", "\n", "    ", "\"\"\"\n    Returns a reshaped version of the mask using avg pooling\n    Mask: binary mask\n    \"\"\"", "\n", "return", "tf", ".", "nn", ".", "avg_pool3d", "(", "Mask", ",", "ksize", "=", "[", "1", ",", "ksize", ",", "ksize", ",", "ksize", ",", "1", "]", ",", "strides", "=", "[", "1", ",", "stride", ",", "stride", ",", "stride", ",", "1", "]", ",", "\n", "padding", "=", "'VALID'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.sse_lri_model.SHconv3d": [[15, 18], ["tensorflow.nn.bias_add", "sse_conv3d"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.sse_conv3d"], ["def", "SHconv3d", "(", "name", ",", "l_input", ",", "ksize", ",", "b", ",", "out_channels", ",", "degreeMax", "=", "1", ",", "M", "=", "4", ",", "stride", "=", "1", ",", "is_trainable", "=", "True", ",", "is_hn", "=", "False", ")", ":", "\n", "    ", "stddev", "=", "1.", "\n", "return", "tf", ".", "nn", ".", "bias_add", "(", "sse_conv3d", "(", "l_input", ",", "out_channels", ",", "ksize", ",", "[", "1", ",", "stride", ",", "stride", ",", "stride", ",", "1", "]", ",", "'VALID'", ",", "degreeMax", ",", "stddev", ",", "name", ",", "M", ",", "is_trainable", ",", "is_hn", ")", ",", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.sse_lri_model.build_model": [[19, 54], ["tensorflow.nn.relu", "gavg_pool", "print", "tensorflow.get_variable", "tensorflow.get_variable", "sse_lri_model.SHconv3d", "print", "tensorflow.get_variable", "tensorflow.get_variable", "conv3d", "print", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.matmul", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.contrib.layers.xavier_initializer", "tensorflow.contrib.layers.xavier_initializer", "tensorflow.contrib.layers.xavier_initializer"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.gavg_pool", "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.bispectrum_lri_model.SHconv3d", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.conv3d"], ["", "def", "build_model", "(", "X", ",", "batch_size", ",", "n_class", ",", "nf1", ",", "ksize", ",", "stride", "=", "1", ",", "is_trainable", "=", "True", ",", "degreeMax", "=", "1", ",", "is_shconv", "=", "True", ",", "is_hn", "=", "False", ",", "M", "=", "None", ")", ":", "\n", "    ", "'''\n    Builds the model and returns the output for training and infering\n    X: input volumes\n    n_class: number of classes\n    degreeMax: maximum degree of the SHs (N)\n    nf1: number of filters\n    ksize: kernel size\n    is_hn: Whether we have one radial profile per degree n (non-polar-separable) \n    M: not used for the sse-lri\n    '''", "\n", "if", "is_shconv", ":", "\n", "        ", "bc1", "=", "tf", ".", "get_variable", "(", "'b_c1'", ",", "shape", "=", "nf1", "*", "(", "degreeMax", "+", "1", ")", ",", "initializer", "=", "tf", ".", "constant_initializer", "(", "0.", ")", ",", "trainable", "=", "is_trainable", ")", "\n", "conv1", "=", "SHconv3d", "(", "'conv1'", ",", "X", ",", "ksize", ",", "bc1", ",", "nf1", ",", "degreeMax", ",", "M", ",", "stride", ",", "is_trainable", ",", "is_hn", ")", "\n", "print", "(", "'conv1.shape: '", ",", "conv1", ".", "shape", ")", "\n", "\n", "", "else", ":", "# Normal conv layer", "\n", "        ", "bc1", "=", "tf", ".", "get_variable", "(", "'b_c1'", ",", "shape", "=", "nf1", ",", "initializer", "=", "tf", ".", "constant_initializer", "(", "1e-2", ")", ",", "trainable", "=", "is_trainable", ")", "\n", "wc1", "=", "tf", ".", "get_variable", "(", "'w_c1'", ",", "shape", "=", "[", "ksize", ",", "ksize", ",", "ksize", ",", "1", ",", "nf1", "]", ",", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", ",", "trainable", "=", "is_trainable", ")", "\n", "conv1", "=", "conv3d", "(", "'conv1'", ",", "X", ",", "wc1", ",", "bc1", ",", "stride", ")", "\n", "print", "(", "'conv1.shape: '", ",", "conv1", ".", "shape", ")", "\n", "", "conv1", "=", "tf", ".", "nn", ".", "relu", "(", "conv1", ",", "'relu1'", ")", "\n", "# global average pool", "\n", "pool1", "=", "gavg_pool", "(", "'pool1'", ",", "conv1", ")", "\n", "print", "(", "'gavgpool shape'", ",", "pool1", ".", "shape", ")", "\n", "# Output: class prediction", "\n", "bout", "=", "tf", ".", "get_variable", "(", "'b_out'", ",", "shape", "=", "n_class", ",", "initializer", "=", "tf", ".", "constant_initializer", "(", "1e-2", ")", ",", "trainable", "=", "True", ")", "\n", "\n", "if", "is_shconv", ":", "\n", "        ", "wout", "=", "tf", ".", "get_variable", "(", "'w_out'", ",", "shape", "=", "[", "nf1", "*", "(", "degreeMax", "+", "1", ")", ",", "n_class", "]", ",", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", ",", "trainable", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "wout", "=", "tf", ".", "get_variable", "(", "'w_out'", ",", "shape", "=", "[", "nf1", ",", "n_class", "]", ",", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", ",", "trainable", "=", "True", ")", "\n", "\n", "", "out", "=", "tf", ".", "matmul", "(", "pool1", ",", "wout", ")", "+", "bout", "\n", "return", "out", "\n", "", ""]], "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.create_synthetic_dataset.create_synthetic_dataset": [[7, 65], ["numpy.random.seed", "numpy.zeros", "range", "numpy.expand_dims", "numpy.asarray", "sklearn.preprocessing.LabelEncoder", "preprocessing.LabelEncoder.fit", "preprocessing.LabelEncoder.transform", "range", "numpy.asarray", "numpy.unique", "numpy.zeros", "numpy.random.uniform", "int", "int", "range", "np.expand_dims.append", "le.transform.append", "int", "int", "int", "numpy.array", "numpy.random.choice", "apply_affine_transform_fixed", "copy_template", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "numpy.sqrt", "numpy.random.uniform", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice", "range"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.apply_affine_transform_fixed", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.copy_template"], ["def", "create_synthetic_dataset", "(", "n_samples", "=", "500", ",", "cube_size", "=", "32", ",", "template_size", "=", "7", ",", "density_min", "=", ".1", ",", "density_max", "=", ".5", ",", "proportions", "=", "[", "0.3", ",", "0.7", "]", ")", ":", "\n", "    ", "'''\n    Creates a basic 3D texture synthetic dataset.\n    Returns the volumes X and labels y.\n    n_samples: number of samples per class (default 500)\n    cube_size: size of the cubes, i.e. training andtest volumes (default 32)\n    template_size: size of the templates rotated and pasted in the volumes (default 7)\n    density_min: minimum density of patterns (default 0.1)\n    density_max: maximum density of patterns (default 0.5)\n    proportions: proportion of template 1 for the two classes (the proportion of template 2 is 1-p) (default= [0.3,0.7])\n    '''", "\n", "np", ".", "random", ".", "seed", "(", "seed", "=", "0", ")", "\n", "# number of classes (only designed for 2 classes here)", "\n", "n_class", "=", "2", "\n", "# Rotation range ", "\n", "rot", "=", "360", "\n", "range_rot", "=", "[", "0", ",", "rot", "]", "\n", "# Generate empty templates", "\n", "template", "=", "np", ".", "zeros", "(", "(", "2", ",", "template_size", ",", "template_size", ",", "template_size", ")", ")", "\n", "# Fill the templates", "\n", "# For now a simple line for t1", "\n", "template", "[", "0", ",", "int", "(", "template_size", "/", "2", ")", "-", "1", ":", "int", "(", "template_size", "/", "2", ")", "+", "1", ",", "int", "(", "template_size", "/", "2", ")", "-", "1", ":", "int", "(", "template_size", "/", "2", ")", "+", "1", ",", ":", "]", "=", "1", "\n", "# And a cross for t2", "\n", "template", "[", "1", ",", "int", "(", "template_size", "/", "2", ")", "-", "1", ":", "int", "(", "template_size", "/", "2", ")", "+", "1", ",", "int", "(", "template_size", "/", "2", ")", "-", "1", ":", "int", "(", "template_size", "/", "2", ")", "+", "1", ",", "int", "(", "template_size", "/", "4", ")", ":", "int", "(", "3", "*", "template_size", "/", "4", ")", "+", "1", "]", "=", "1", "\n", "template", "[", "1", ",", "int", "(", "template_size", "/", "2", ")", "-", "1", ":", "int", "(", "template_size", "/", "2", ")", "+", "1", ",", "int", "(", "template_size", "/", "4", ")", ":", "int", "(", "3", "*", "template_size", "/", "4", ")", ",", "int", "(", "template_size", "/", "2", ")", "-", "1", ":", "int", "(", "template_size", "/", "2", ")", "+", "1", "]", "=", "1", "\n", "# Initialize dataset lists", "\n", "X", "=", "[", "]", "\n", "y", "=", "[", "]", "\n", "\n", "for", "c", "in", "range", "(", "n_class", ")", ":", "\n", "        ", "for", "s", "in", "range", "(", "n_samples", ")", ":", "\n", "# Generate an empty 64x64x64 cube", "\n", "            ", "cube", "=", "np", ".", "zeros", "(", "(", "cube_size", ",", "cube_size", ",", "cube_size", ")", ")", "\n", "# Generate random density", "\n", "density", "=", "np", ".", "random", ".", "uniform", "(", "density_min", ",", "density_max", ")", "\n", "# Number of patterns in volume based on the density", "\n", "n_templates", "=", "int", "(", "(", "cube_size", "**", "3", ")", "/", "(", "template_size", "**", "3", ")", "*", "density", ")", "\n", "# Crop size after rotation:", "\n", "crop_size", "=", "int", "(", "template_size", "*", "np", ".", "sqrt", "(", "3", ")", ")", "\n", "# place the rotated patterns in the cube", "\n", "for", "t", "in", "range", "(", "n_templates", ")", ":", "\n", "# random position", "\n", "                ", "position", "=", "np", ".", "array", "(", "[", "np", ".", "random", ".", "choice", "(", "cube_size", ")", ",", "np", ".", "random", ".", "choice", "(", "cube_size", ")", ",", "np", ".", "random", ".", "choice", "(", "cube_size", ")", "]", ")", "\n", "# is it template 1 or 2:", "\n", "template_type", "=", "np", ".", "random", ".", "choice", "(", "2", ",", "p", "=", "[", "proportions", "[", "c", "]", ",", "1", "-", "proportions", "[", "c", "]", "]", ")", "\n", "# Rotate the template 1 or 2", "\n", "random_angles", "=", "[", "np", ".", "random", ".", "uniform", "(", "range_rot", "[", "0", "]", ",", "range_rot", "[", "1", "]", ")", "for", "i", "in", "range", "(", "3", ")", "]", "\n", "rotated_template", "=", "apply_affine_transform_fixed", "(", "template", "[", "template_type", "]", ",", "random_angles", ")", "\n", "# copy the rotated template in the cube", "\n", "cube", "=", "copy_template", "(", "cube", ",", "rotated_template", ",", "position", ")", "\n", "", "X", ".", "append", "(", "cube", ")", "\n", "y", ".", "append", "(", "c", ")", "\n", "", "", "X", "=", "np", ".", "expand_dims", "(", "np", ".", "asarray", "(", "X", ")", ",", "axis", "=", "-", "1", ")", "\n", "y", "=", "np", ".", "asarray", "(", "y", ")", "\n", "le", "=", "preprocessing", ".", "LabelEncoder", "(", ")", "\n", "le", ".", "fit", "(", "np", ".", "unique", "(", "y", ")", ")", "\n", "y", "=", "le", ".", "transform", "(", "y", ")", "\n", "return", "X", ",", "y", "", "", ""]], "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.bispectrum_lri_model.compute_shape_bias": [[17, 26], ["range", "range", "math.floor", "range", "math.ceil", "np.abs"], "function", ["None"], ["def", "compute_shape_bias", "(", "n", ")", ":", "\n", "    ", "out", "=", "0", "\n", "#    for n1 in range(0, math.floor(n/2)+1):", "\n", "#        for n2 in range(n1,math.ceil(n/2)+1):", "\n", "for", "n1", "in", "range", "(", "0", ",", "math", ".", "floor", "(", "n", "/", "2", ")", "+", "1", ")", ":", "\n", "        ", "for", "n2", "in", "range", "(", "0", ",", "math", ".", "ceil", "(", "n", "/", "2", ")", "+", "1", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "np", ".", "abs", "(", "n2", "-", "n1", ")", ",", "n1", "+", "n2", "+", "1", ")", ":", "\n", "                ", "out", "+=", "1", "\n", "", "", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.bispectrum_lri_model.SHconv3d": [[28, 31], ["tensorflow.nn.bias_add", "bispectrum_conv3d"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.sh_networks_utils.bispectrum_conv3d"], ["", "def", "SHconv3d", "(", "name", ",", "l_input", ",", "ksize", ",", "b", ",", "out_channels", ",", "degreeMax", "=", "1", ",", "M", "=", "4", ",", "stride", "=", "1", ",", "is_trainable", "=", "True", ",", "is_hn", "=", "False", ")", ":", "\n", "    ", "stddev", "=", "1.", "\n", "return", "tf", ".", "nn", ".", "bias_add", "(", "bispectrum_conv3d", "(", "l_input", ",", "out_channels", ",", "ksize", ",", "[", "1", ",", "stride", ",", "stride", ",", "stride", ",", "1", "]", ",", "'VALID'", ",", "degreeMax", ",", "stddev", ",", "name", ",", "M", ",", "is_trainable", ",", "is_hn", ")", ",", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.bispectrum_lri_model.build_model": [[34, 69], ["tensorflow.nn.relu", "gavg_pool", "print", "tensorflow.get_variable", "tensorflow.get_variable", "bispectrum_lri_model.SHconv3d", "print", "tensorflow.get_variable", "tensorflow.get_variable", "conv3d", "print", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.matmul", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.constant_initializer", "tensorflow.contrib.layers.xavier_initializer", "tensorflow.contrib.layers.xavier_initializer", "tensorflow.contrib.layers.xavier_initializer", "bispectrum_lri_model.compute_shape_bias", "bispectrum_lri_model.compute_shape_bias"], "function", ["home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.gavg_pool", "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.bispectrum_lri_model.SHconv3d", "home.repos.pwc.inspect_result.voreille_ssbcnn.None.utils.conv3d", "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.bispectrum_lri_model.compute_shape_bias", "home.repos.pwc.inspect_result.voreille_ssbcnn.synthetic_experiments.bispectrum_lri_model.compute_shape_bias"], ["", "def", "build_model", "(", "X", ",", "batch_size", ",", "n_class", ",", "nf1", ",", "ksize", ",", "stride", "=", "1", ",", "is_trainable", "=", "True", ",", "degreeMax", "=", "1", ",", "is_shconv", "=", "True", ",", "is_hn", "=", "False", ",", "M", "=", "None", ")", ":", "\n", "    ", "'''\n    Builds the model and returns the output for training and infering\n    X: input volumes\n    n_class: number of classes\n    degreeMax: maximum degree of the SHs (N)\n    nf1: number of filters\n    ksize: kernel size\n    is_hn: Whether we have one radial profile per degree n (non-polar-separable)\n    M: not used for the sse-lri\n    '''", "\n", "if", "is_shconv", ":", "\n", "        ", "bc1", "=", "tf", ".", "get_variable", "(", "'b_c1'", ",", "shape", "=", "nf1", "*", "compute_shape_bias", "(", "degreeMax", ")", ",", "initializer", "=", "tf", ".", "constant_initializer", "(", "0.", ")", ",", "trainable", "=", "is_trainable", ")", "\n", "conv1", "=", "SHconv3d", "(", "'conv1'", ",", "X", ",", "ksize", ",", "bc1", ",", "nf1", ",", "degreeMax", ",", "M", ",", "stride", ",", "is_trainable", ",", "is_hn", ")", "\n", "print", "(", "'conv1.shape: '", ",", "conv1", ".", "shape", ")", "\n", "\n", "", "else", ":", "# Normal conv layer", "\n", "        ", "bc1", "=", "tf", ".", "get_variable", "(", "'b_c1'", ",", "shape", "=", "nf1", ",", "initializer", "=", "tf", ".", "constant_initializer", "(", "1e-2", ")", ",", "trainable", "=", "is_trainable", ")", "\n", "wc1", "=", "tf", ".", "get_variable", "(", "'w_c1'", ",", "shape", "=", "[", "ksize", ",", "ksize", ",", "ksize", ",", "1", ",", "nf1", "]", ",", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", ",", "trainable", "=", "is_trainable", ")", "\n", "conv1", "=", "conv3d", "(", "'conv1'", ",", "X", ",", "wc1", ",", "bc1", ",", "stride", ")", "\n", "print", "(", "'conv1.shape: '", ",", "conv1", ".", "shape", ")", "\n", "", "conv1", "=", "tf", ".", "nn", ".", "relu", "(", "conv1", ",", "'relu1'", ")", "\n", "# global average pool", "\n", "pool1", "=", "gavg_pool", "(", "'pool1'", ",", "conv1", ")", "\n", "print", "(", "'gavgpool shape'", ",", "pool1", ".", "shape", ")", "\n", "# Output: class prediction", "\n", "bout", "=", "tf", ".", "get_variable", "(", "'b_out'", ",", "shape", "=", "n_class", ",", "initializer", "=", "tf", ".", "constant_initializer", "(", "1e-2", ")", ",", "trainable", "=", "True", ")", "\n", "\n", "if", "is_shconv", ":", "\n", "        ", "wout", "=", "tf", ".", "get_variable", "(", "'w_out'", ",", "shape", "=", "[", "nf1", "*", "compute_shape_bias", "(", "degreeMax", ")", ",", "n_class", "]", ",", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", ",", "trainable", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "wout", "=", "tf", ".", "get_variable", "(", "'w_out'", ",", "shape", "=", "[", "nf1", ",", "n_class", "]", ",", "initializer", "=", "tf", ".", "contrib", ".", "layers", ".", "xavier_initializer", "(", ")", ",", "trainable", "=", "True", ")", "\n", "\n", "", "out", "=", "tf", ".", "matmul", "(", "pool1", ",", "wout", ")", "+", "bout", "\n", "return", "out", "\n", "", ""]]}