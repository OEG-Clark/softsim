{"home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGAN.__init__": [[28, 66], ["set", "irgan.gen_model.Generator", "irgan.dis_model.Discriminator", "torch.cuda.is_available", "range", "cf_gan.IRGAN.generator.cuda", "cf_gan.IRGAN.discriminator.cuda"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "user_num", ",", "\n", "item_num", ",", "\n", "gen_param", "=", "None", ",", "\n", "batch_size", "=", "16", ",", "\n", "emb_dim", "=", "5", ",", "\n", "lr", "=", "0.001", ",", "\n", "init_delta", "=", "0.05", ",", "\n", "g_epochs", "=", "50", ",", "\n", "d_epochs", "=", "100", ",", "\n", "n_epochs", "=", "15", ",", "\n", "# TODO normalize input", "\n", "# normalize_inputs=True,", "\n", "conditions", "=", "None", ",", "\n", "verbose", "=", "True", ")", ":", "\n", "\n", "# self.normalize_inputs = normalize_inputs", "\n", "        ", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "conditions", "=", "conditions", "\n", "self", ".", "emb_dim", "=", "emb_dim", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "init_delta", "=", "init_delta", "\n", "self", ".", "gen_param", "=", "gen_param", "\n", "self", ".", "n_epochs", "=", "n_epochs", "\n", "self", ".", "g_epochs", "=", "g_epochs", "\n", "self", ".", "d_epochs", "=", "d_epochs", "\n", "self", ".", "user_num", "=", "user_num", "\n", "self", ".", "item_num", "=", "item_num", "\n", "self", ".", "all_items", "=", "set", "(", "range", "(", "item_num", ")", ")", "\n", "\n", "self", ".", "generator", "=", "Generator", "(", "item_num", ",", "user_num", ",", "emb_dim", ",", "lamda", "=", "0.0", "/", "batch_size", ",", "param", "=", "gen_param", ",", "\n", "initdelta", "=", "init_delta", ",", "learning_rate", "=", "lr", ",", "conditions", "=", "conditions", ")", "\n", "self", ".", "discriminator", "=", "Discriminator", "(", "item_num", ",", "user_num", ",", "emb_dim", ",", "lamda", "=", "0.1", "/", "batch_size", ",", "param", "=", "gen_param", ",", "\n", "initdelta", "=", "init_delta", ",", "learning_rate", "=", "lr", ",", "conditions", "=", "conditions", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "generator", "=", "self", ".", "generator", ".", "cuda", "(", ")", "\n", "self", ".", "discriminator", "=", "self", ".", "discriminator", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGAN.simple_test_one_user": [[67, 86], ["list", "sorted", "sorted.reverse", "numpy.zeros", "sorted.append", "set"], "methods", ["None"], ["", "", "def", "simple_test_one_user", "(", "self", ",", "x", ")", ":", "\n", "        ", "rating", "=", "x", "[", "0", "]", "\n", "u", "=", "x", "[", "1", "]", "\n", "\n", "test_items", "=", "list", "(", "self", ".", "all_items", "-", "set", "(", "self", ".", "user_pos_train", "[", "u", "]", ")", ")", "\n", "item_score", "=", "[", "]", "\n", "for", "i", "in", "test_items", ":", "\n", "# pairs predicted item-score", "\n", "            ", "item_score", ".", "append", "(", "(", "i", ",", "rating", "[", "i", "]", ")", ")", "\n", "\n", "# sort predicted items by score", "\n", "", "item_score", "=", "sorted", "(", "item_score", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "\n", "item_score", ".", "reverse", "(", ")", "\n", "# generate a matrix row with score as probability", "\n", "pred", "=", "np", ".", "zeros", "(", "self", ".", "item_num", ")", "\n", "for", "item", "in", "item_score", ":", "\n", "            ", "pred", "[", "item", "[", "0", "]", "]", "=", "item", "[", "1", "]", "\n", "\n", "", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGAN.generate_for_d": [[87, 108], ["cf_gan.IRGAN.detach_().cpu().numpy", "numpy.exp", "numpy.random.choice", "range", "open", "fout.write", "cf_gan.IRGAN.generator.all_rating", "cf_gan.IRGAN.generator.all_rating", "numpy.array", "numpy.sum", "numpy.arange", "len", "data.append", "cf_gan.IRGAN.detach_().cpu", "len", "str", "cf_gan.IRGAN.detach_", "str", "str"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.all_rating", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.all_rating"], ["", "def", "generate_for_d", "(", "self", ",", "filename", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "data", "=", "[", "]", "\n", "\n", "for", "u", "in", "self", ".", "user_pos_train", ":", "\n", "            ", "pos", "=", "self", ".", "user_pos_train", "[", "u", "]", "\n", "if", "self", ".", "conditions", ":", "\n", "                ", "c_batch", "=", "[", "c", "[", "u", ",", ":", "]", "for", "c", "in", "condition_data", "]", "\n", "rating", "=", "self", ".", "generator", ".", "all_rating", "(", "u", ",", "c_batch", ")", "\n", "", "else", ":", "\n", "                ", "rating", "=", "self", ".", "generator", ".", "all_rating", "(", "u", ")", "\n", "", "rating", "=", "rating", ".", "detach_", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "rating", "=", "np", ".", "array", "(", "rating", "[", "0", "]", ")", "/", "0.2", "# Temperature", "\n", "exp_rating", "=", "np", ".", "exp", "(", "rating", ")", "\n", "prob", "=", "exp_rating", "/", "np", ".", "sum", "(", "exp_rating", ")", "\n", "\n", "neg", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "self", ".", "item_num", ")", ",", "size", "=", "len", "(", "pos", ")", ",", "p", "=", "prob", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "pos", ")", ")", ":", "\n", "                ", "data", ".", "append", "(", "str", "(", "u", ")", "+", "'\\t'", "+", "str", "(", "pos", "[", "i", "]", ")", "+", "'\\t'", "+", "str", "(", "neg", "[", "i", "]", ")", ")", "\n", "\n", "", "", "with", "open", "(", "filename", ",", "'w'", ")", "as", "fout", ":", "\n", "            ", "fout", ".", "write", "(", "'\\n'", ".", "join", "(", "data", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGAN.fit": [[109, 215], ["aaerec.condition._check_conditions", "range", "NotImplementedError", "print", "range", "range", "cf_gan.IRGAN.generate_for_d", "irgan.file_len", "torch.cuda.is_available", "cf_gan.IRGAN.discriminator.step", "print", "cf_gan.IRGAN.detach_().cpu().numpy", "numpy.exp", "pn.sum", "numpy.random.choice", "cf_gan.IRGAN.discriminator.get_reward", "torch.cuda.is_available", "cf_gan.IRGAN.generator.step", "print", "irgan.get_batch_data", "irgan.get_batch_data", "torch.tensor().cuda", "torch.tensor", "collections.OrderedDict", "cf_gan.IRGAN.discriminator", "cf_gan.IRGAN.discriminator", "cf_gan.IRGAN.generator.all_logits", "cf_gan.IRGAN.generator.all_logits", "numpy.sum", "len", "numpy.arange", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor", "torch.tensor", "cf_gan.IRGAN.generator", "cf_gan.IRGAN.generator", "set", "c_batch.append", "cf_gan.IRGAN.detach_().cpu", "len", "torch.tensor.detach_().cpu().numpy", "torch.tensor", "raw_c_batch.append", "numpy.asarray().repeat", "cf_gan.IRGAN.item", "torch.tensor", "torch.tensor", "cf_gan.IRGAN.item", "input_user.count", "set", "list", "cf_gan.IRGAN.detach_", "torch.tensor.detach_().cpu", "numpy.asarray", "collections.OrderedDict.values", "torch.tensor.detach_"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGAN.generate_for_d", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.file_len", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.dis_model.Discriminator.get_reward", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.get_batch_data", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.get_batch_data", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.all_logits", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.all_logits"], ["", "", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param X: np.array, the base data from Bag class\n        :param y: dummy variable, throws Error if used\n        :param condition_data: generic list of conditions\n        :return:\n        \"\"\"", "\n", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"(Semi-)supervised usage not supported\"", ")", "\n", "\n", "", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "self", ".", "user_pos_train", "=", "X", "\n", "\n", "# minimax training", "\n", "for", "epoch", "in", "range", "(", "self", ".", "n_epochs", ")", ":", "\n", "            ", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "\"Epoch\"", ",", "epoch", "+", "1", ")", "\n", "\n", "", "if", "epoch", ">=", "0", ":", "\n", "                ", "for", "d_epoch", "in", "range", "(", "self", ".", "d_epochs", ")", ":", "#100", "\n", "                    ", "if", "d_epoch", "%", "5", "==", "0", ":", "\n", "                        ", "self", ".", "generate_for_d", "(", "DIS_TRAIN_FILE", ",", "condition_data", ")", "\n", "train_size", "=", "ut", ".", "file_len", "(", "DIS_TRAIN_FILE", ")", "\n", "", "index", "=", "1", "\n", "while", "True", ":", "\n", "                        ", "if", "index", ">", "train_size", ":", "\n", "                            ", "break", "\n", "", "if", "index", "+", "self", ".", "batch_size", "<=", "train_size", "+", "1", ":", "\n", "                            ", "input_user", ",", "input_item", ",", "input_label", "=", "ut", ".", "get_batch_data", "(", "DIS_TRAIN_FILE", ",", "index", ",", "\n", "self", ".", "batch_size", ")", "\n", "", "else", ":", "\n", "                            ", "input_user", ",", "input_item", ",", "input_label", "=", "ut", ".", "get_batch_data", "(", "DIS_TRAIN_FILE", ",", "index", ",", "\n", "train_size", "-", "index", "+", "1", ")", "\n", "\n", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                            ", "input_label", "=", "torch", ".", "tensor", "(", "input_label", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "                            ", "input_label", "=", "torch", ".", "tensor", "(", "input_label", ")", "\n", "", "if", "use_condition", ":", "\n", "# Each user is repeated a varying number of times in dis_train.txt, users not ordered", "\n", "                            ", "user_cnt", "=", "collections", ".", "OrderedDict", "(", "[", "(", "u", ",", "input_user", ".", "count", "(", "u", ")", ")", "for", "u", "in", "set", "(", "input_user", ")", "]", ")", "\n", "c_batch", "=", "[", "]", "\n", "for", "c", "in", "condition_data", ":", "\n", "                                ", "raw_c_batch", "=", "[", "]", "\n", "for", "u", "in", "set", "(", "input_user", ")", ":", "\n", "                                    ", "raw_c_batch", ".", "append", "(", "c", "[", "u", "]", ")", "\n", "", "c_batch", ".", "append", "(", "np", ".", "asarray", "(", "raw_c_batch", ")", ".", "repeat", "(", "list", "(", "user_cnt", ".", "values", "(", ")", ")", ",", "axis", "=", "0", ")", ")", "\n", "", "D_loss", "=", "self", ".", "discriminator", "(", "input_user", ",", "input_item", ",", "input_label", ",", "c_batch", ")", "\n", "", "else", ":", "\n", "                            ", "D_loss", "=", "self", ".", "discriminator", "(", "input_user", ",", "input_item", ",", "input_label", ")", "\n", "", "self", ".", "discriminator", ".", "step", "(", "D_loss", ")", "\n", "index", "+=", "self", ".", "batch_size", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "                        ", "print", "(", "\"\\r[D Epoch %d/%d] [loss: %f]\"", "%", "(", "d_epoch", ",", "self", ".", "d_epochs", ",", "D_loss", ".", "item", "(", ")", ")", ")", "\n", "\n", "# Train G", "\n", "", "", "for", "g_epoch", "in", "range", "(", "self", ".", "g_epochs", ")", ":", "# 50", "\n", "                    ", "for", "u", "in", "self", ".", "user_pos_train", ":", "\n", "                        ", "sample_lambda", "=", "0.2", "\n", "pos", "=", "self", ".", "user_pos_train", "[", "u", "]", "\n", "\n", "if", "use_condition", ":", "\n", "                            ", "c_batch", "=", "[", "c", "[", "u", "]", "for", "c", "in", "condition_data", "]", "\n", "rating", "=", "self", ".", "generator", ".", "all_logits", "(", "u", ",", "c_batch", ")", "\n", "", "else", ":", "\n", "                            ", "rating", "=", "self", ".", "generator", ".", "all_logits", "(", "u", ")", "\n", "", "rating", "=", "rating", ".", "detach_", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "exp_rating", "=", "np", ".", "exp", "(", "rating", ")", "\n", "prob", "=", "exp_rating", "/", "np", ".", "sum", "(", "exp_rating", ")", "# prob is generator distribution p_\\theta", "\n", "\n", "pn", "=", "(", "1", "-", "sample_lambda", ")", "*", "prob", "\n", "pn", "[", "pos", "]", "+=", "sample_lambda", "*", "1.0", "/", "len", "(", "pos", ")", "\n", "# Now, pn is the Pn in importance sampling, prob is generator distribution p_\\theta", "\n", "\n", "# print('pn sum=',pn.sum())", "\n", "# Normilize by probability sum to avoid np.random.choice error 'probability do not sum to one'", "\n", "pn", "/=", "pn", ".", "sum", "(", ")", "\n", "sample", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "self", ".", "item_num", ")", ",", "2", "*", "len", "(", "pos", ")", ",", "p", "=", "pn", ")", "\n", "###########################################################################", "\n", "# Get reward and adapt it with importance sampling", "\n", "###########################################################################", "\n", "reward", "=", "self", ".", "discriminator", ".", "get_reward", "(", "u", ",", "sample", ")", "\n", "reward", "=", "reward", ".", "detach_", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "prob", "[", "sample", "]", "/", "pn", "[", "sample", "]", "\n", "###########################################################################", "\n", "# Update G", "\n", "###########################################################################", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                            ", "sample", "=", "torch", ".", "tensor", "(", "sample", ")", ".", "cuda", "(", ")", "\n", "reward", "=", "torch", ".", "tensor", "(", "reward", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "                            ", "sample", "=", "torch", ".", "tensor", "(", "sample", ")", "\n", "reward", "=", "torch", ".", "tensor", "(", "reward", ")", "\n", "", "if", "use_condition", ":", "\n", "                            ", "c_batch", "=", "[", "c", "[", "u", "]", "for", "c", "in", "condition_data", "]", "\n", "G_loss", "=", "self", ".", "generator", "(", "u", ",", "sample", ",", "reward", ",", "c_batch", ")", "\n", "", "else", ":", "\n", "                            ", "G_loss", "=", "self", ".", "generator", "(", "u", ",", "sample", ",", "reward", ")", "\n", "", "self", ".", "generator", ".", "step", "(", "G_loss", ")", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "                        ", "print", "(", "\"\\r[G Epoch %d/%d] [loss: %f]\"", "%", "(", "g_epoch", ",", "self", ".", "g_epochs", ",", "G_loss", ".", "item", "(", ")", ")", ")", "\n", "\n", "", "", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGAN.predict": [[216, 239], ["aaerec.condition._check_conditions", "list", "len", "X.keys", "cf_gan.IRGAN.generator.all_rating", "user_batch_rating.detach_().cpu().numpy.detach_().cpu().numpy.detach_().cpu().numpy", "zip", "pred.append", "user_batch_rating.detach_().cpu().numpy.detach_().cpu().numpy.detach_().cpu", "cf_gan.IRGAN.simple_test_one_user", "user_batch_rating.detach_().cpu().numpy.detach_().cpu().numpy.detach_"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.all_rating", "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGAN.simple_test_one_user"], ["", "def", "predict", "(", "self", ",", "X", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "batch_size", "=", "128", "\n", "test_users", "=", "list", "(", "X", ".", "keys", "(", ")", ")", "\n", "test_user_num", "=", "len", "(", "test_users", ")", "\n", "index", "=", "0", "\n", "pred", "=", "[", "]", "\n", "while", "True", ":", "\n", "            ", "if", "index", ">=", "test_user_num", ":", "\n", "                ", "break", "\n", "", "user_batch", "=", "test_users", "[", "index", ":", "index", "+", "batch_size", "]", "\n", "if", "use_condition", ":", "\n", "                ", "c_batch", "=", "[", "c", "[", "index", ":", "index", "+", "batch_size", "]", "for", "c", "in", "condition_data", "]", "\n", "", "index", "+=", "batch_size", "\n", "\n", "user_batch_rating", "=", "self", ".", "generator", ".", "all_rating", "(", "user_batch", ",", "c_batch", ",", "impose_dim", "=", "1", ")", "\n", "\n", "user_batch_rating", "=", "user_batch_rating", ".", "detach_", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "user_batch_rating_uid", "in", "zip", "(", "user_batch_rating", ",", "user_batch", ")", ":", "\n", "                ", "pred", ".", "append", "(", "self", ".", "simple_test_one_user", "(", "user_batch_rating_uid", ")", ")", "\n", "\n", "", "", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGANRecommender.__init__": [[259, 270], ["aaerec.base.Recommender.__init__", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "user_num", ",", "item_num", ",", "gen_param", "=", "None", ",", "conditions", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" tfidf_params get piped to either TfidfVectorizer or\n        EmbeddedVectorizer.  Remaining kwargs get passed to\n        AdversarialAutoencoder \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "verbose", "=", "kwargs", ".", "get", "(", "'verbose'", ",", "True", ")", "\n", "self", ".", "conditions", "=", "conditions", "\n", "self", ".", "model_params", "=", "kwargs", "\n", "self", ".", "gen_param", "=", "gen_param", "\n", "self", ".", "user_num", "=", "user_num", "\n", "self", ".", "item_num", "=", "item_num", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGANRecommender.__str__": [[271, 278], ["str", "cf_gan.IRGANRecommender.conditions.keys"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "       ", "desc", "=", "\"IRGAN\"", "\n", "\n", "if", "self", ".", "conditions", ":", "\n", "          ", "desc", "+=", "\" conditioned on: \"", "+", "', '", ".", "join", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "", "desc", "+=", "'\\nModel Params: '", "+", "str", "(", "self", ".", "model_params", ")", "\n", "return", "desc", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGANRecommender.train": [[279, 303], ["training_set.to_dict", "cf_gan.IRGAN", "print", "print", "print", "cf_gan.IRGANRecommender.model.fit", "training_set.get_attributes", "cf_gan.IRGANRecommender.conditions.fit_transform", "cf_gan.IRGANRecommender.conditions.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.to_dict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "train", "(", "self", ",", "training_set", ")", ":", "\n", "        ", "\"\"\"\n        1. get basic representation\n        2. ? add potential side_info in ??? representation\n        3. initialize a IRGAN variant\n        4. fit based on IRGAN\n        :param training_set: ???, Bag Class training set\n        :return: trained self\n        \"\"\"", "\n", "X", "=", "training_set", ".", "to_dict", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "condition_data_raw", "=", "training_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "condition_data", "=", "self", ".", "conditions", ".", "fit_transform", "(", "condition_data_raw", ")", "\n", "", "else", ":", "\n", "            ", "condition_data", "=", "None", "\n", "\n", "", "self", ".", "model", "=", "IRGAN", "(", "self", ".", "user_num", ",", "self", ".", "item_num", ",", "self", ".", "gen_param", ",", "conditions", "=", "self", ".", "conditions", ",", "\n", "**", "self", ".", "model_params", ")", "\n", "\n", "print", "(", "self", ")", "\n", "print", "(", "self", ".", "model", ")", "\n", "print", "(", "self", ".", "conditions", ")", "\n", "\n", "self", ".", "model", ".", "fit", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.IRGANRecommender.predict": [[304, 316], ["test_set.to_dict", "cf_gan.IRGANRecommender.model.predict", "test_set.get_attributes", "cf_gan.IRGANRecommender.conditions.transform", "cf_gan.IRGANRecommender.conditions.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.to_dict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.predict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "predict", "(", "self", ",", "test_set", ")", ":", "\n", "        ", "X", "=", "test_set", ".", "to_dict", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "condition_data_raw", "=", "test_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "# Important to not call fit here, but just transform", "\n", "condition_data", "=", "self", ".", "conditions", ".", "transform", "(", "condition_data_raw", ")", "\n", "", "else", ":", "\n", "            ", "condition_data", "=", "None", "\n", "\n", "", "pred", "=", "self", ".", "model", ".", "predict", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.cf_gan.main": [[318, 348], ["print", "gensim.models.keyedvectors.KeyedVectors.load_word2vec_format", "aaerec.condition.ConditionList", "argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "aaerec.datasets.Bags.load_tabcomma_format", "aaerec.evaluation.Evaluation().setup", "Evaluation().setup.", "Evaluation().setup.train_set.size", "cf_gan.IRGANRecommender", "aaerec.evaluation.Evaluation", "Evaluation().setup.train_set.size", "Evaluation().setup.test_set.size", "aaerec.condition.PretrainedWordEmbeddingCondition"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.load_tabcomma_format", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.setup", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "", "def", "main", "(", ")", ":", "\n", "\n", "    ", "CONFIG", "=", "{", "\n", "'pub'", ":", "(", "'/data21/lgalke/datasets/citations_pmc.tsv'", ",", "2011", ",", "50", ")", ",", "\n", "'eco'", ":", "(", "'/data21/lgalke/datasets/econbiz62k.tsv'", ",", "2012", ",", "1", ")", "\n", "}", "\n", "\n", "print", "(", "\"Loading pre-trained embedding\"", ",", "W2V_PATH", ")", "\n", "vectors", "=", "KeyedVectors", ".", "load_word2vec_format", "(", "W2V_PATH", ",", "binary", "=", "W2V_IS_BINARY", ")", "\n", "\n", "CONDITIONS", "=", "ConditionList", "(", "[", "\n", "(", "'title'", ",", "PretrainedWordEmbeddingCondition", "(", "vectors", ",", "dim", "=", "0", ")", ")", "\n", "]", ")", "\n", "\n", "PARSER", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "PARSER", ".", "add_argument", "(", "'data'", ",", "type", "=", "str", ",", "choices", "=", "[", "'pub'", ",", "'eco'", "]", ")", "\n", "args", "=", "PARSER", ".", "parse_args", "(", ")", "\n", "DATA", "=", "CONFIG", "[", "args", ".", "data", "]", "\n", "logfile", "=", "'/data22/ivagliano/test-irgan/'", "+", "args", ".", "data", "+", "'-decoder.log'", "\n", "bags", "=", "Bags", ".", "load_tabcomma_format", "(", "DATA", "[", "0", "]", ")", "\n", "c_year", "=", "DATA", "[", "1", "]", "\n", "\n", "evaluate", "=", "Evaluation", "(", "bags", ",", "\n", "year", "=", "c_year", ",", "\n", "logfile", "=", "logfile", ")", ".", "setup", "(", "min_count", "=", "DATA", "[", "2", "]", ",", "\n", "min_elements", "=", "2", ")", "\n", "user_num", "=", "evaluate", ".", "train_set", ".", "size", "(", ")", "[", "0", "]", "+", "evaluate", ".", "test_set", ".", "size", "(", ")", "[", "0", "]", "\n", "item_num", "=", "evaluate", ".", "train_set", ".", "size", "(", ")", "[", "1", "]", "\n", "models", "=", "[", "IRGANRecommender", "(", "user_num", ",", "item_num", ",", "g_epochs", "=", "1", ",", "d_epochs", "=", "1", ",", "n_epochs", "=", "1", ",", "conditions", "=", "CONDITIONS", ")", "]", "\n", "evaluate", "(", "models", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.dis_model.Discriminator.__init__": [[9, 47], ["torch.Module.__init__", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "utils.L2Loss", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.Linear", "torch.Linear", "torch.Linear", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "dis_model.Discriminator.D_user_embeddings.cuda", "dis_model.Discriminator.D_item_embeddings.cuda", "dis_model.Discriminator.D_item_bias.cuda", "dis_model.Discriminator.l2l.cuda", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "dis_model.Discriminator.conditions.size_increment", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment"], ["    ", "def", "__init__", "(", "self", ",", "itemNum", ",", "userNum", ",", "emb_dim", ",", "lamda", ",", "param", "=", "None", ",", "initdelta", "=", "0.05", ",", "learning_rate", "=", "0.05", ",", "\n", "conditions", "=", "None", ")", ":", "\n", "        ", "super", "(", "Discriminator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "itemNum", "=", "itemNum", "\n", "self", ".", "userNum", "=", "userNum", "\n", "self", ".", "emb_dim", "=", "emb_dim", "\n", "self", ".", "lamda", "=", "lamda", "# regularization parameters", "\n", "self", ".", "param", "=", "param", "\n", "self", ".", "initdelta", "=", "initdelta", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "conditions", "=", "conditions", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "lin", "=", "nn", ".", "Linear", "(", "self", ".", "emb_dim", "+", "self", ".", "conditions", ".", "size_increment", "(", ")", ",", "self", ".", "emb_dim", ")", "\n", "\n", "", "self", ".", "d_param", "=", "[", "]", "\n", "\n", "if", "self", ".", "param", "==", "None", ":", "\n", "            ", "self", ".", "D_user_embeddings", "=", "Variable", "(", "\n", "torch", ".", "FloatTensor", "(", "self", ".", "userNum", ",", "self", ".", "emb_dim", ")", ".", "uniform_", "(", "-", "self", ".", "initdelta", ",", "self", ".", "initdelta", ")", ",", "\n", "requires_grad", "=", "True", ")", "\n", "self", ".", "D_item_embeddings", "=", "Variable", "(", "\n", "torch", ".", "FloatTensor", "(", "self", ".", "itemNum", ",", "self", ".", "emb_dim", ")", ".", "uniform_", "(", "-", "self", ".", "initdelta", ",", "self", ".", "initdelta", ")", ",", "\n", "requires_grad", "=", "True", ")", "\n", "self", ".", "D_item_bias", "=", "Variable", "(", "torch", ".", "zeros", "(", "self", ".", "itemNum", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "requires_grad", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "D_user_embeddings", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "tensor", "(", "param", "[", "0", "]", ")", ".", "cuda", "(", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "D_item_embeddings", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "tensor", "(", "param", "[", "1", "]", ")", ".", "cuda", "(", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "D_item_bias", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "tensor", "(", "param", "[", "2", "]", ")", ".", "cuda", "(", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "", "self", ".", "d_param", "=", "[", "self", ".", "D_user_embeddings", ",", "self", ".", "D_item_embeddings", ",", "self", ".", "D_item_bias", "]", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "d_param", ",", "lr", "=", "self", ".", "learning_rate", ",", "momentum", "=", "0.9", ")", "\n", "self", ".", "l2l", "=", "L2Loss", "(", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "D_user_embeddings", "=", "self", ".", "D_user_embeddings", ".", "cuda", "(", ")", "\n", "self", ".", "D_item_embeddings", "=", "self", ".", "D_item_embeddings", ".", "cuda", "(", ")", "\n", "self", ".", "D_item_bias", "=", "self", ".", "D_item_bias", ".", "cuda", "(", ")", "\n", "self", ".", "l2l", "=", "self", ".", "l2l", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.dis_model.Discriminator.pre_logits": [[48, 62], ["dis_model.Discriminator.conditions.encode_impose", "dis_model.Discriminator.lin", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose"], ["", "", "def", "pre_logits", "(", "self", ",", "input_user", ",", "input_item", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "u_embedding", "=", "self", ".", "D_user_embeddings", "[", "input_user", ",", ":", "]", "\n", "if", "self", ".", "conditions", ":", "\n", "# In generator need to use dimension 0 in discriminator 1 so by default 0 (given in condition creation)", "\n", "# and here we use one through the dim parameter", "\n", "# TODO Better solution is to always use a batch instead of a specific user as for all other methods", "\n", "            ", "u_embedding", "=", "self", ".", "conditions", ".", "encode_impose", "(", "u_embedding", ",", "condition_data", ",", "dim", "=", "1", ")", "\n", "u_embedding", "=", "self", ".", "lin", "(", "u_embedding", ")", "\n", "\n", "", "item_embeddings", "=", "self", ".", "D_item_embeddings", "[", "input_item", ",", ":", "]", "\n", "D_item_bias", "=", "self", ".", "D_item_bias", "[", "input_item", "]", "\n", "\n", "score", "=", "torch", ".", "sum", "(", "u_embedding", "*", "item_embeddings", ",", "1", ")", "+", "D_item_bias", "\n", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.dis_model.Discriminator.forward": [[63, 67], ["torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "dis_model.Discriminator.pre_logits", "pred_data_label.float", "dis_model.Discriminator.l2l", "dis_model.Discriminator.l2l", "dis_model.Discriminator.l2l"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.dis_model.Discriminator.pre_logits"], ["", "def", "forward", "(", "self", ",", "input_user", ",", "input_item", ",", "pred_data_label", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "self", ".", "pre_logits", "(", "input_user", ",", "input_item", ",", "condition_data", ")", ",", "pred_data_label", ".", "float", "(", ")", ")", "+", "self", ".", "lamda", "*", "(", "self", ".", "l2l", "(", "self", ".", "D_user_embeddings", ")", "+", "self", ".", "l2l", "(", "self", ".", "D_item_embeddings", ")", "+", "self", ".", "l2l", "(", "self", ".", "D_item_bias", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.dis_model.Discriminator.get_reward": [[68, 76], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["", "def", "get_reward", "(", "self", ",", "user_index", ",", "sample", ")", ":", "\n", "        ", "u_embedding", "=", "self", ".", "D_user_embeddings", "[", "user_index", ",", ":", "]", "\n", "item_embeddings", "=", "self", ".", "D_item_embeddings", "[", "sample", ",", ":", "]", "\n", "D_item_bias", "=", "self", ".", "D_item_bias", "[", "sample", "]", "\n", "\n", "reward_logits", "=", "torch", ".", "sum", "(", "u_embedding", "*", "item_embeddings", ",", "1", ")", "+", "D_item_bias", "\n", "reward", "=", "2", "*", "(", "torch", ".", "sigmoid", "(", "reward_logits", ")", "-", "0.5", ")", "\n", "return", "reward", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.dis_model.Discriminator.step": [[77, 81], ["dis_model.Discriminator.optimizer.zero_grad", "loss.backward", "dis_model.Discriminator.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step"], ["", "def", "step", "(", "self", ",", "loss", ")", ":", "\n", "        ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.L2Loss.__init__": [[10, 16], ["torch.Module.__init__", "torch.MSELoss", "torch.MSELoss", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "utils.L2Loss.register_buffer", "utils.L2Loss.loss.cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "L2Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "loss", "=", "nn", ".", "MSELoss", "(", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "loss", "=", "self", ".", "loss", ".", "cuda", "(", ")", "\n", "", "self", ".", "register_buffer", "(", "'target'", ",", "torch", ".", "tensor", "(", "0.0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.L2Loss.get_target_tensor": [[17, 21], ["target_tensor.expand_as"], "methods", ["None"], ["", "def", "get_target_tensor", "(", "self", ",", "input", ")", ":", "\n", "        ", "target_tensor", "=", "self", ".", "target", "\n", "\n", "return", "target_tensor", ".", "expand_as", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.L2Loss.__call__": [[22, 25], ["utils.L2Loss.get_target_tensor", "utils.L2Loss.loss"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.L2Loss.get_target_tensor"], ["", "def", "__call__", "(", "self", ",", "input", ")", ":", "\n", "        ", "target_tensor", "=", "self", ".", "get_target_tensor", "(", "input", ")", "\n", "return", "self", ".", "loss", "(", "input", ",", "target_tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.file_len": [[27, 32], ["open", "enumerate"], "function", ["None"], ["", "", "def", "file_len", "(", "fname", ")", ":", "\n", "    ", "with", "open", "(", "fname", ")", "as", "f", ":", "\n", "        ", "for", "i", ",", "l", "in", "enumerate", "(", "f", ")", ":", "\n", "            ", "pass", "\n", "", "", "return", "i", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.get_batch_data": [[35, 50], ["range", "linecache.getline", "line.split.strip", "line.split.split", "user.append", "user.append", "item.append", "item.append", "label.append", "label.append", "int", "int", "int", "int"], "function", ["None"], ["", "def", "get_batch_data", "(", "file", ",", "index", ",", "size", ")", ":", "# 1,5->1,2,3,4,5", "\n", "    ", "user", "=", "[", "]", "\n", "item", "=", "[", "]", "\n", "label", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "index", ",", "index", "+", "size", ")", ":", "\n", "        ", "line", "=", "linecache", ".", "getline", "(", "file", ",", "i", ")", "\n", "line", "=", "line", ".", "strip", "(", ")", "\n", "line", "=", "line", ".", "split", "(", ")", "\n", "user", ".", "append", "(", "int", "(", "line", "[", "0", "]", ")", ")", "\n", "user", ".", "append", "(", "int", "(", "line", "[", "0", "]", ")", ")", "\n", "item", ".", "append", "(", "int", "(", "line", "[", "1", "]", ")", ")", "\n", "item", ".", "append", "(", "int", "(", "line", "[", "2", "]", ")", ")", "\n", "label", ".", "append", "(", "1.", ")", "\n", "label", ".", "append", "(", "0.", ")", "\n", "", "return", "user", ",", "item", ",", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.precision_at_k": [[52, 63], ["numpy.mean", "numpy.asarray"], "function", ["None"], ["", "def", "precision_at_k", "(", "r", ",", "k", ")", ":", "\n", "    ", "\"\"\"Score is precision @ k\n    Relevance is binary (nonzero is relevant).\n    Returns:\n        Precision @ k\n    Raises:\n        ValueError: len(r) must be >= k\n    \"\"\"", "\n", "assert", "k", ">=", "1", "\n", "r", "=", "np", ".", "asarray", "(", "r", ")", "[", ":", "k", "]", "\n", "return", "np", ".", "mean", "(", "r", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.average_precision": [[65, 76], ["numpy.asarray", "numpy.mean", "utils.precision_at_k", "range"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.precision_at_k"], ["", "def", "average_precision", "(", "r", ")", ":", "\n", "    ", "\"\"\"Score is average precision (area under PR curve)\n    Relevance is binary (nonzero is relevant).\n    Returns:\n        Average precision\n    \"\"\"", "\n", "r", "=", "np", ".", "asarray", "(", "r", ")", "\n", "out", "=", "[", "precision_at_k", "(", "r", ",", "k", "+", "1", ")", "for", "k", "in", "range", "(", "r", ".", "size", ")", "if", "r", "[", "k", "]", "]", "\n", "if", "not", "out", ":", "\n", "        ", "return", "0.", "\n", "", "return", "np", ".", "mean", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.mean_average_precision": [[78, 85], ["numpy.mean", "utils.average_precision"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.average_precision"], ["", "def", "mean_average_precision", "(", "rs", ")", ":", "\n", "    ", "\"\"\"Score is mean average precision\n    Relevance is binary (nonzero is relevant).\n    Returns:\n        Mean average precision\n    \"\"\"", "\n", "return", "np", ".", "mean", "(", "[", "average_precision", "(", "r", ")", "for", "r", "in", "rs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.dcg_at_k": [[87, 103], ["numpy.asfarray", "numpy.sum", "numpy.sum", "ValueError", "numpy.log2", "numpy.log2", "numpy.arange", "numpy.arange"], "function", ["None"], ["", "def", "dcg_at_k", "(", "r", ",", "k", ",", "method", "=", "1", ")", ":", "\n", "    ", "\"\"\"Score is discounted cumulative gain (dcg)\n    Relevance is positive real values.  Can use binary\n    as the previous methods.\n    Returns:\n        Discounted cumulative gain\n    \"\"\"", "\n", "r", "=", "np", ".", "asfarray", "(", "r", ")", "[", ":", "k", "]", "\n", "if", "r", ".", "size", ":", "\n", "        ", "if", "method", "==", "0", ":", "\n", "            ", "return", "r", "[", "0", "]", "+", "np", ".", "sum", "(", "r", "[", "1", ":", "]", "/", "np", ".", "log2", "(", "np", ".", "arange", "(", "2", ",", "r", ".", "size", "+", "1", ")", ")", ")", "\n", "", "elif", "method", "==", "1", ":", "\n", "            ", "return", "np", ".", "sum", "(", "r", "/", "np", ".", "log2", "(", "np", ".", "arange", "(", "2", ",", "r", ".", "size", "+", "2", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'method must be 0 or 1.'", ")", "\n", "", "", "return", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.ndcg_at_k": [[105, 116], ["utils.dcg_at_k", "sorted", "utils.dcg_at_k"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.dcg_at_k", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.dcg_at_k"], ["", "def", "ndcg_at_k", "(", "r", ",", "k", ",", "method", "=", "1", ")", ":", "\n", "    ", "\"\"\"Score is normalized discounted cumulative gain (ndcg)\n    Relevance is positive real values.  Can use binary\n    as the previous methods.\n    Returns:\n        Normalized discounted cumulative gain\n    \"\"\"", "\n", "dcg_max", "=", "dcg_at_k", "(", "sorted", "(", "r", ",", "reverse", "=", "True", ")", ",", "k", ",", "method", ")", "\n", "if", "not", "dcg_max", ":", "\n", "        ", "return", "0.", "\n", "", "return", "dcg_at_k", "(", "r", ",", "k", ",", "method", ")", "/", "dcg_max", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.recall_at_k": [[118, 121], ["numpy.asfarray", "numpy.sum"], "function", ["None"], ["", "def", "recall_at_k", "(", "r", ",", "k", ",", "all_pos_num", ")", ":", "\n", "    ", "r", "=", "np", ".", "asfarray", "(", "r", ")", "[", ":", "k", "]", "\n", "return", "np", ".", "sum", "(", "r", ")", "/", "all_pos_num", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.utils.F1": [[123, 128], ["None"], "function", ["None"], ["", "def", "F1", "(", "pre", ",", "rec", ")", ":", "\n", "    ", "if", "pre", "+", "rec", ">", "0", ":", "\n", "        ", "return", "(", "2.0", "*", "pre", "*", "rec", ")", "/", "(", "pre", "+", "rec", ")", "\n", "", "else", ":", "\n", "        ", "return", "0.", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.__init__": [[8, 45], ["torch.Module.__init__", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.Linear", "torch.Linear", "torch.Linear", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "gen_model.Generator.G_user_embeddings.cuda", "gen_model.Generator.G_item_embeddings.cuda", "gen_model.Generator.G_item_bias.cuda", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "gen_model.Generator.conditions.size_increment", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment"], ["    ", "def", "__init__", "(", "self", ",", "itemNum", ",", "userNum", ",", "emb_dim", ",", "lamda", ",", "param", "=", "None", ",", "initdelta", "=", "0.05", ",", "learning_rate", "=", "0.05", ",", "\n", "conditions", "=", "None", ")", ":", "\n", "        ", "super", "(", "Generator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "itemNum", "=", "itemNum", "\n", "self", ".", "userNum", "=", "userNum", "\n", "self", ".", "emb_dim", "=", "emb_dim", "\n", "self", ".", "lamda", "=", "lamda", "# regularization parameters", "\n", "self", ".", "param", "=", "param", "\n", "self", ".", "initdelta", "=", "initdelta", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "conditions", "=", "conditions", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "lin", "=", "nn", ".", "Linear", "(", "self", ".", "emb_dim", "+", "self", ".", "conditions", ".", "size_increment", "(", ")", ",", "self", ".", "emb_dim", ")", "\n", "\n", "", "self", ".", "g_params", "=", "[", "]", "\n", "\n", "if", "self", ".", "param", "==", "None", ":", "\n", "            ", "self", ".", "G_user_embeddings", "=", "Variable", "(", "\n", "torch", ".", "FloatTensor", "(", "self", ".", "userNum", ",", "self", ".", "emb_dim", ")", ".", "uniform_", "(", "-", "self", ".", "initdelta", ",", "self", ".", "initdelta", ")", ",", "\n", "requires_grad", "=", "True", ")", "\n", "self", ".", "G_item_embeddings", "=", "Variable", "(", "\n", "torch", ".", "FloatTensor", "(", "self", ".", "itemNum", ",", "self", ".", "emb_dim", ")", ".", "uniform_", "(", "-", "self", ".", "initdelta", ",", "self", ".", "initdelta", ")", ",", "\n", "requires_grad", "=", "True", ")", "\n", "self", ".", "G_item_bias", "=", "Variable", "(", "torch", ".", "zeros", "(", "self", ".", "itemNum", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "requires_grad", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "G_user_embeddings", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "tensor", "(", "param", "[", "0", "]", ")", ".", "cuda", "(", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "G_item_embeddings", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "tensor", "(", "param", "[", "1", "]", ")", ".", "cuda", "(", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "G_item_bias", "=", "torch", ".", "autograd", ".", "Variable", "(", "torch", ".", "tensor", "(", "param", "[", "2", "]", ")", ".", "cuda", "(", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "", "self", ".", "g_params", "=", "[", "self", ".", "G_user_embeddings", ",", "self", ".", "G_item_embeddings", ",", "self", ".", "G_item_bias", "]", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "g_params", ",", "lr", "=", "self", ".", "learning_rate", ",", "momentum", "=", "0.9", ")", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "G_user_embeddings", "=", "self", ".", "G_user_embeddings", ".", "cuda", "(", ")", "\n", "self", ".", "G_item_embeddings", "=", "self", ".", "G_item_embeddings", ".", "cuda", "(", ")", "\n", "self", ".", "G_item_bias", "=", "self", ".", "G_item_bias", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.all_rating": [[46, 56], ["gen_model.Generator.conditions.encode_impose", "gen_model.Generator.lin", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "gen_model.Generator.view", "item_embeddings.t"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose"], ["", "", "def", "all_rating", "(", "self", ",", "user_index", ",", "condition_data", "=", "None", ",", "impose_dim", "=", "None", ")", ":", "\n", "        ", "u_embedding", "=", "self", ".", "G_user_embeddings", "[", "user_index", ",", ":", "]", "\n", "item_embeddings", "=", "self", ".", "G_item_embeddings", "\n", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "u_embedding", "=", "self", ".", "conditions", ".", "encode_impose", "(", "u_embedding", ",", "condition_data", ",", "dim", "=", "impose_dim", ")", "\n", "u_embedding", "=", "self", ".", "lin", "(", "u_embedding", ")", "\n", "\n", "", "all_rating", "=", "torch", ".", "mm", "(", "u_embedding", ".", "view", "(", "-", "1", ",", "5", ")", ",", "item_embeddings", ".", "t", "(", ")", ")", "+", "self", ".", "G_item_bias", "\n", "return", "all_rating", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.all_logits": [[57, 67], ["gen_model.Generator.conditions.encode_impose", "gen_model.Generator.lin", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose"], ["", "def", "all_logits", "(", "self", ",", "user_index", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "u_embedding", "=", "self", ".", "G_user_embeddings", "[", "user_index", "]", "\n", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "u_embedding", "=", "self", ".", "conditions", ".", "encode_impose", "(", "u_embedding", ",", "condition_data", ")", "\n", "u_embedding", "=", "self", ".", "lin", "(", "u_embedding", ")", "\n", "", "item_embeddings", "=", "self", ".", "G_item_embeddings", "\n", "\n", "score", "=", "torch", ".", "sum", "(", "u_embedding", "*", "item_embeddings", ",", "1", ")", "+", "self", ".", "G_item_bias", "\n", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.forward": [[68, 74], ["torch.softmax", "torch.softmax", "torch.softmax", "torch.gather().clamp", "torch.gather().clamp", "torch.gather().clamp", "torch.gather().clamp", "torch.gather().clamp", "torch.gather().clamp", "torch.gather().clamp", "torch.gather().clamp", "torch.gather().clamp", "gen_model.Generator.all_logits().view", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "gen_model.Generator.all_logits", "torch.softmax.view", "sample.long", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.all_logits", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log"], ["", "def", "forward", "(", "self", ",", "user_index", ",", "sample", ",", "reward", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "softmax_score", "=", "F", ".", "softmax", "(", "self", ".", "all_logits", "(", "user_index", ",", "condition_data", ")", ".", "view", "(", "1", ",", "-", "1", ")", ",", "-", "1", ")", "\n", "gan_prob", "=", "torch", ".", "gather", "(", "softmax_score", ".", "view", "(", "-", "1", ")", ",", "0", ",", "sample", ".", "long", "(", ")", ")", ".", "clamp", "(", "min", "=", "1e-8", ")", "\n", "loss", "=", "-", "torch", ".", "mean", "(", "torch", ".", "log", "(", "gan_prob", ")", "*", "reward", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.irgan.gen_model.Generator.step": [[75, 79], ["gen_model.Generator.optimizer.zero_grad", "loss.backward", "gen_model.Generator.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step"], ["", "def", "step", "(", "self", ",", "loss", ")", ":", "\n", "        ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.stats.compute_stats": [[54, 59], ["print", "numpy.ravel", "numpy.argsort", "np.ravel.min", "np.ravel.max", "numpy.median", "np.ravel.mean", "np.ravel.std"], "function", ["None"], ["def", "compute_stats", "(", "A", ")", ":", "\n", "    ", "print", "(", "\"A Shape\"", ",", "A", ".", "shape", ")", "\n", "A", "=", "np", ".", "ravel", "(", "A", ")", "\n", "top3", "=", "np", ".", "argsort", "(", "A", ")", "[", "-", "3", ":", "]", "\n", "return", "A", ".", "size", ",", "A", ".", "min", "(", ")", ",", "A", ".", "max", "(", ")", ",", "np", ".", "median", "(", "A", ")", ",", "A", ".", "mean", "(", ")", ",", "A", ".", "std", "(", ")", ",", "A", "[", "top3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.stats.power_law_exponent": [[61, 77], ["print", "print", "print", "print", "degrees.min", "numpy.log().sum", "numpy.log"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log"], ["", "def", "power_law_exponent", "(", "degrees", ",", "dmin", "=", "None", ")", ":", "\n", "# TODO At now array from dict that has not a key for every x but only for the one > 0. Is that ok?", "\n", "    ", "print", "(", "\"Computing power law exponent\"", ")", "\n", "\n", "if", "dmin", "is", "None", ":", "\n", "        ", "dmin", "=", "degrees", ".", "min", "(", ")", "\n", "", "else", ":", "\n", "        ", "degrees", "=", "degrees", "[", "degrees", ">=", "dmin", "]", "\n", "\n", "# N must be number of values that go into computation", "\n", "# Not total number of nodes", "\n", "", "n", "=", "degrees", ".", "size", "\n", "print", "(", "\"d_min =\"", ",", "dmin", ")", "\n", "print", "(", "\"N =\"", ",", "n", ")", "\n", "gamma", "=", "1", "+", "n", "/", "np", ".", "log", "(", "degrees", "/", "dmin", ")", ".", "sum", "(", ")", "\n", "print", "(", "\"Gamma = {:.4f}\"", ".", "format", "(", "gamma", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.stats.plot": [[79, 94], ["matplotlib.bar", "matplotlib.ylabel", "matplotlib.xlabel", "matplotlib.savefig", "matplotlib.close", "objects.keys", "objects.values", "objects.items", "x_dim.replace", "print", "matplotlib.text", "str"], "function", ["None"], ["", "def", "plot", "(", "objects", ",", "dataset", ",", "x_dim", ",", "y_dim", ",", "x", "=", "None", ")", ":", "\n", "    ", "plt", ".", "bar", "(", "objects", ".", "keys", "(", ")", ",", "objects", ".", "values", "(", ")", ",", "align", "=", "'center'", ",", "alpha", "=", "0.5", ")", "\n", "plt", ".", "ylabel", "(", "y_dim", ")", "\n", "plt", ".", "xlabel", "(", "x_dim", ")", "\n", "\n", "# print the y value of bar at a given x", "\n", "if", "x", "!=", "None", ":", "\n", "        ", "for", "x_i", ",", "y_i", "in", "objects", ".", "items", "(", ")", ":", "\n", "            ", "if", "x_i", "==", "x", ":", "\n", "                ", "print", "(", "\"For x={} y={}\"", ".", "format", "(", "x", ",", "y_i", ")", ")", "\n", "plt", ".", "text", "(", "x_i", ",", "y_i", ",", "str", "(", "y_i", ")", "+", "\"\\n\"", ",", "ha", "=", "'center'", ")", "\n", "\n", "", "", "", "plt", ".", "savefig", "(", "'papers_by_{}_{}.pdf'", ".", "format", "(", "x_dim", ".", "replace", "(", "\" \"", ",", "\"_\"", ")", ",", "dataset", ")", ")", "\n", "# plt.show()", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.stats.paper_by_n_citations": [[96, 109], ["citations.keys"], "function", ["None"], ["", "def", "paper_by_n_citations", "(", "citations", ")", ":", "\n", "    ", "'''\n    From a dictionary with paper IDs as keys and citation numbers as values\n    to a dictionary with citation numbers as keys and paper numbers as values\n    '''", "\n", "papers_by_citations", "=", "{", "}", "\n", "for", "paper", "in", "citations", ".", "keys", "(", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "papers_by_citations", "[", "citations", "[", "paper", "]", "]", "+=", "1", "\n", "", "except", "KeyError", ":", "\n", "            ", "papers_by_citations", "[", "citations", "[", "paper", "]", "]", "=", "1", "\n", "\n", "", "", "return", "papers_by_citations", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.stats.from_to_key": [[111, 132], ["print", "print", "print"], "function", ["None"], ["", "def", "from_to_key", "(", "objects", ",", "min_key", ",", "max_key", "=", "None", ")", ":", "\n", "    ", "'''\n    From a dictionary create a new dictionary with only items with key greater\n    than min_key and optionally smaller than max_key. If min_key = max_key,\n    it returns a dictionaly with only that key\n    '''", "\n", "print", "(", "\"Filtering dictionary's keys from {} to {}\"", ".", "format", "(", "min_key", ",", "max_key", ")", ")", "\n", "# It assumes only positive integers as keys", "\n", "if", "max_key", "!=", "None", "and", "max_key", "<", "min_key", ":", "\n", "        ", "print", "(", "\"Error: max_key has to be greater than min_key. Dictionary unchanged\"", ")", "\n", "return", "objects", "\n", "\n", "", "if", "max_key", "==", "None", "and", "min_key", "<=", "0", ":", "\n", "        ", "print", "(", "\"Warning: min_key lower or equal to 0 and no max_key has no effect.\"", "\n", "+", "\"Dictionary unchanged\"", ")", "\n", "return", "objects", "\n", "\n", "", "if", "max_key", "!=", "None", ":", "\n", "        ", "return", "{", "x", ":", "objects", "[", "x", "]", "for", "x", "in", "objects", "if", "x", ">=", "min_key", "and", "x", "<=", "max_key", "}", "\n", "\n", "", "return", "{", "x", ":", "objects", "[", "x", "]", "for", "x", "in", "objects", "if", "x", ">=", "min_key", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.stats.generate_years_citations_set_cnts": [[134, 202], ["len", "paper.keys", "len", "len", "len", "paper.keys", "paper.keys", "paper.keys"], "function", ["None"], ["", "def", "generate_years_citations_set_cnts", "(", "papers", ",", "dataset", ")", ":", "\n", "    ", "'''\n    Return the distribution of papers by years and by citations\n    '''", "\n", "years", ",", "citations", ",", "set_cnts", "=", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "\n", "for", "paper", "in", "papers", ":", "\n", "        ", "if", "dataset", "!=", "\"econis\"", ":", "\n", "            ", "try", ":", "\n", "                 ", "years", "[", "paper", "[", "\"year\"", "]", "]", "+=", "1", "\n", "", "except", "KeyError", ":", "\n", "                ", "if", "\"year\"", "not", "in", "paper", ".", "keys", "(", ")", "and", "dataset", "!=", "\"mpd\"", ":", "\n", "# skip papers without a year", "\n", "# unless dataset is MPD, which has no year", "\n", "                    ", "continue", "\n", "", "if", "dataset", "!=", "\"mpd\"", ":", "\n", "                    ", "years", "[", "paper", "[", "\"year\"", "]", "]", "=", "0", "\n", "", "", "", "else", ":", "\n", "            ", "try", ":", "\n", "                ", "years", "[", "paper", "[", "\"date\"", "]", "]", "+=", "1", "\n", "", "except", "KeyError", ":", "\n", "                ", "if", "\"date\"", "not", "in", "paper", ".", "keys", "(", ")", ":", "\n", "# skip papers without a year", "\n", "                    ", "continue", "\n", "", "years", "[", "paper", "[", "\"date\"", "]", "]", "=", "0", "\n", "", "", "if", "dataset", "==", "\"dblp\"", ":", "\n", "# DBLP has the citations for each paper", "\n", "            ", "try", ":", "\n", "                ", "citations", "[", "paper", "[", "\"n_citation\"", "]", "]", "+=", "1", "\n", "", "except", "KeyError", ":", "\n", "                ", "citations", "[", "paper", "[", "\"n_citation\"", "]", "]", "=", "1", "\n", "", "try", ":", "\n", "                ", "set_cnts", "[", "paper", "[", "\"id\"", "]", "]", "=", "len", "(", "paper", "[", "\"references\"", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "                ", "set_cnts", "[", "paper", "[", "\"id\"", "]", "]", "=", "0", "\n", "", "", "elif", "dataset", "==", "\"acm\"", ":", "\n", "# For ACM we need to compute the citations for each paper", "\n", "            ", "if", "\"references\"", "not", "in", "paper", ".", "keys", "(", ")", ":", "\n", "                ", "continue", "\n", "", "for", "ref", "in", "paper", "[", "\"references\"", "]", ":", "\n", "                ", "try", ":", "\n", "                    ", "citations", "[", "ref", "]", "+=", "1", "\n", "", "except", "KeyError", ":", "\n", "                    ", "citations", "[", "ref", "]", "=", "1", "\n", "", "", "try", ":", "\n", "                ", "set_cnts", "[", "paper", "[", "\"id\"", "]", "]", "=", "len", "(", "paper", "[", "\"references\"", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "                ", "set_cnts", "[", "paper", "[", "\"id\"", "]", "]", "=", "0", "\n", "", "", "elif", "dataset", "==", "\"swp\"", ":", "\n", "# For SWP we need to compute the occurrences for each subject", "\n", "            ", "if", "\"subjects\"", "not", "in", "paper", ".", "keys", "(", ")", ":", "\n", "                ", "continue", "\n", "", "for", "subject", "in", "paper", "[", "\"subjects\"", "]", ":", "\n", "                ", "try", ":", "\n", "                    ", "citations", "[", "subject", "]", "+=", "1", "\n", "", "except", "KeyError", ":", "\n", "                    ", "citations", "[", "subject", "]", "=", "1", "\n", "", "", "set_cnts", "[", "paper", "[", "\"id\"", "]", "]", "=", "len", "(", "paper", "[", "\"subjects\"", "]", ")", "\n", "", "else", ":", "\n", "# For MPD we need to compute the occurrences for each track", "\n", "            ", "for", "track", "in", "paper", "[", "\"tracks\"", "]", ":", "\n", "                ", "try", ":", "\n", "                    ", "citations", "[", "track", "[", "\"track_uri\"", "]", "]", "+=", "1", "\n", "", "except", "KeyError", ":", "\n", "                    ", "citations", "[", "track", "[", "\"track_uri\"", "]", "]", "=", "1", "\n", "", "", "set_cnts", "[", "paper", "[", "\"pid\"", "]", "]", "=", "len", "(", "paper", "[", "\"tracks\"", "]", ")", "\n", "\n", "", "", "return", "years", ",", "citations", ",", "set_cnts", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.stats.generate_citations": [[204, 219], ["df.iterrows", "paper[].split"], "function", ["None"], ["", "def", "generate_citations", "(", "df", ",", "dataset", ")", ":", "\n", "    ", "citations", "=", "{", "}", "\n", "\n", "key", "=", "\"cited\"", "if", "dataset", "==", "\"pubmed\"", "else", "\"set\"", "\n", "\n", "for", "index", ",", "paper", "in", "df", ".", "iterrows", "(", ")", ":", "\n", "        ", "for", "ref", "in", "paper", "[", "key", "]", ".", "split", "(", "\",\"", ")", ":", "\n", "            ", "if", "ref", "==", "\"\"", ":", "\n", "                ", "continue", "\n", "", "try", ":", "\n", "                ", "citations", "[", "ref", "]", "+=", "1", "\n", "", "except", "KeyError", ":", "\n", "                ", "citations", "[", "ref", "]", "=", "1", "\n", "\n", "", "", "", "return", "citations", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.stats.set_count": [[221, 231], ["df.iterrows", "len", "paper[].split"], "function", ["None"], ["", "def", "set_count", "(", "df", ",", "dataset", ")", ":", "\n", "    ", "set_cnts", "=", "{", "}", "\n", "\n", "owner", "=", "\"pmId\"", "if", "dataset", "==", "\"pubmed\"", "else", "\"owner\"", "\n", "set", "=", "\"cited\"", "if", "dataset", "==", "\"pubmed\"", "else", "\"set\"", "\n", "\n", "for", "index", ",", "paper", "in", "df", ".", "iterrows", "(", ")", ":", "\n", "        ", "set_cnts", "[", "paper", "[", "owner", "]", "]", "=", "len", "(", "paper", "[", "set", "]", ".", "split", "(", "\",\"", ")", ")", "\n", "\n", "", "return", "set_cnts", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.stats.set_path": [[233, 250], ["None"], "function", ["None"], ["", "def", "set_path", "(", "ds", ")", ":", "\n", "    ", "if", "ds", "==", "\"dblp\"", "or", "ds", "==", "\"acm\"", ":", "\n", "        ", "p", "=", "'/data22/ivagliano/aminer/'", "\n", "p", "+=", "(", "\"dblp-ref/\"", "if", "ds", "==", "\"dblp\"", "else", "\"acm.txt\"", ")", "\n", "", "elif", "ds", "==", "\"swp\"", ":", "\n", "        ", "p", "=", "\"/data22/ivagliano/SWP/FivMetadata_clean.json\"", "\n", "", "elif", "ds", "==", "\"mpd\"", ":", "\n", "        ", "p", "=", "\"/data21/lgalke/datasets/MPD/data/\"", "\n", "", "elif", "ds", "==", "\"pubmed\"", ":", "\n", "# p = \"/data21/lgalke/datasets/PMC/citations_pmc.tsv\"", "\n", "        ", "p", "=", "\"/data22/ggerstenkorn/citation_data_preprocessing/final_data/owner_list_cleaned.csv\"", "\n", "", "elif", "ds", "==", "\"econbiz\"", ":", "\n", "        ", "p", "=", "\"/data21/lgalke/datasets/econbiz62k.tsv\"", "\n", "", "else", ":", "\n", "        ", "p", "=", "\"/data22/ivagliano/Reuters/rcv1.tsv\"", "\n", "\n", "", "return", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.parse_reuters.return_text": [[7, 21], ["filter"], "function", ["None"], ["def", "return_text", "(", "xmldict", ")", ":", "\n", "    ", "ni", "=", "xmldict", "[", "'newsitem'", "]", "\n", "text", "=", "ni", "[", "'text'", "]", "\n", "headline", "=", "ni", "[", "'headline'", "]", "\n", "title", "=", "ni", "[", "'title'", "]", "\n", "if", "not", "title", ":", "\n", "        ", "title", "=", "''", "\n", "", "if", "not", "headline", ":", "\n", "        ", "headline", "=", "''", "\n", "", "if", "text", ":", "\n", "        ", "text", "=", "' '", ".", "join", "(", "filter", "(", "None", ",", "text", "[", "'p'", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "text", "=", "''", "\n", "", "return", "'\\n'", ".", "join", "(", "[", "title", ",", "headline", ",", "text", "]", ")", ",", "' '", ".", "join", "(", "[", "title", ",", "headline", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.parse_reuters.gold": [[31, 53], ["isinstance", "isinstance", "isinstance"], "function", ["None"], ["", "", "def", "gold", "(", "xmldict", ")", ":", "\n", "    ", "md", "=", "xmldict", "[", "'newsitem'", "]", "[", "'metadata'", "]", "\n", "codes_md", "=", "md", "[", "'codes'", "]", "\n", "if", "isinstance", "(", "codes_md", ",", "OrderedDict", ")", ":", "\n", "        ", "if", "'topics'", "in", "codes_md", "[", "'@class'", "]", ":", "\n", "            ", "codes", "=", "codes_md", "[", "'code'", "]", "\n", "if", "isinstance", "(", "codes_md", ",", "OrderedDict", ")", ":", "\n", "                ", "return", "[", "codes", "[", "'@code'", "]", "]", "\n", "", "else", ":", "\n", "                ", "return", "[", "c", "[", "'@code'", "]", "for", "c", "in", "codes", "]", "\n", "", "", "else", ":", "\n", "            ", "return", "''", "\n", "", "", "codes", "=", "[", "c", "for", "c", "in", "codes_md", "if", "'topics'", "in", "c", "[", "'@class'", "]", "]", "\n", "if", "not", "codes", ":", "\n", "        ", "return", "[", "''", "]", "\n", "", "codes", "=", "codes", "[", "0", "]", "\n", "code_list", "=", "codes", "[", "'code'", "]", "\n", "if", "isinstance", "(", "code_list", ",", "list", ")", ":", "\n", "        ", "code_ids", "=", "[", "c", "[", "'@code'", "]", "for", "c", "in", "code_list", "]", "\n", "", "else", ":", "\n", "        ", "code_ids", "=", "[", "code_list", "[", "'@code'", "]", "]", "\n", "", "return", "code_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.utils.parse_reuters.asdict": [[55, 59], ["open", "xmltodict.parse", "fd.read"], "function", ["None"], ["", "def", "asdict", "(", "file_path", ")", ":", "\n", "    ", "with", "open", "(", "file_path", ",", "errors", "=", "'ignore'", ")", "as", "fd", ":", "\n", "        ", "xmldict", "=", "xmltodict", ".", "parse", "(", "fd", ".", "read", "(", ")", ")", "\n", "", "return", "xmldict", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.star": [[9, 19], ["tuple", "map"], "function", ["None"], ["def", "star", "(", "fn", ")", ":", "\n", "    ", "\"\"\"\n    Allows other functions to deal with multiple arguments.\n    >>> f =lambda x: x + 1\n    >>> f(0)\n    1\n    >>> star(f)(1,2)\n    (2, 3)\n    \"\"\"", "\n", "return", "lambda", "*", "input", ":", "tuple", "(", "map", "(", "fn", ",", "input", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.pipe": [[21, 29], ["transforms.compose", "reversed"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.compose"], ["", "def", "pipe", "(", "*", "transforms", ")", ":", "\n", "    ", "\"\"\"\n    Left-to-right execution of transforming functions\n    >>> pipe = pipe(lambda x: x+1, lambda x: x*2)\n    >>> pipe(0)\n    2\n    \"\"\"", "\n", "return", "compose", "(", "*", "reversed", "(", "transforms", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.compose": [[31, 43], ["functools.reduce", "f", "g"], "function", ["None"], ["", "def", "compose", "(", "*", "functions", ")", ":", "\n", "    ", "\"\"\"\n    Composition of functions\n    >>> f = lambda x: x + 1\n    >>> g = lambda x: x * 2\n    >>> c = compose(f,g)\n    >>> c(0)\n    1\n    >>> compose(g,f)(0)\n    2\n    \"\"\"", "\n", "return", "reduce", "(", "lambda", "f", ",", "g", ":", "lambda", "x", ":", "f", "(", "g", "(", "x", ")", ")", ",", "functions", ",", "lambda", "x", ":", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.sparse2lists": [[45, 67], ["zip", "hasattr", "hasattr", "len", "lists[].append", "range", "input.nonzero", "int", "int"], "function", ["None"], ["", "def", "sparse2lists", "(", "input", ")", ":", "\n", "    ", "\"\"\"\n    Transforms sparse matrix into list of lists.\n    Only the indices of nonzero entries are considered, not their values.\n    >>> import numpy, scipy.sparse\n    >>> A = numpy.diag(numpy.ones([3]))\n    >>> A[2,0] = 7.0\n    >>> A\n    array([[ 1.,  0.,  0.],\n           [ 0.,  1.,  0.],\n           [ 7.,  0.,  1.]])\n    >>> C = scipy.sparse.csr_matrix(A)\n    >>> sparse2lists(C)\n    [[0], [1], [0, 2]]\n    \"\"\"", "\n", "assert", "hasattr", "(", "input", ",", "'shape'", ")", "and", "hasattr", "(", "input", ",", "'nonzero'", ")", "\n", "assert", "len", "(", "input", ".", "shape", ")", "==", "2", "\n", "lists", "=", "[", "[", "]", "for", "_", "in", "range", "(", "input", ".", "shape", "[", "0", "]", ")", "]", "\n", "for", "i", ",", "j", "in", "zip", "(", "*", "input", ".", "nonzero", "(", ")", ")", ":", "\n", "        ", "lists", "[", "int", "(", "i", ")", "]", ".", "append", "(", "int", "(", "j", ")", ")", "\n", "\n", "", "return", "lists", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2indices": [[69, 88], ["tuple", "enumerate", "zip"], "function", ["None"], ["", "def", "lists2indices", "(", "input", ")", ":", "\n", "    ", "\"\"\"\n    Extracts typical rows, cols from list of lists\n    >>> lists = [[1,2], [2,3], [0,1]]\n    >>> lists2indices(lists)\n    ((0, 0, 1, 1, 2, 2), (1, 2, 2, 3, 0, 1))\n    >>> lists = [[], [1], [1,2], []]\n    >>> lists2indices(lists)\n    ((1, 2, 2), (1, 1, 2))\n    >>> lists = [[], []]\n    >>> lists2indices(lists)\n    ((), ())\n\n    \"\"\"", "\n", "ind", "=", "[", "(", "r", ",", "c", ")", "for", "r", ",", "cs", "in", "enumerate", "(", "input", ")", "for", "c", "in", "cs", "]", "\n", "if", "not", "ind", ":", "\n", "        ", "return", "(", "(", ")", ",", "(", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "tuple", "(", "zip", "(", "*", "ind", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms._check_shape": [[90, 120], ["isinstance", "len", "len", "ValueError", "tuple", "len", "len"], "function", ["None"], ["", "", "def", "_check_shape", "(", "input", ",", "size", ")", ":", "\n", "    ", "\"\"\" Convenient usage of shape attributes.\n    It is also ok to just provide 2nd dimension\n    >>> bags = [[1],[2],[3], [27]]\n    >>> _check_shape(bags, 3)\n    (4, 3)\n    >>> _check_shape(bags, [4, 3])\n    (4, 3)\n    >>> _check_shape(bags, [-1, 3])\n    (4, 3)\n    >>> _check_shape(bags, [None, 3])\n    (4, 3)\n    \"\"\"", "\n", "\n", "if", "isinstance", "(", "size", ",", "int", ")", ":", "\n", "# dim", "\n", "        ", "return", "len", "(", "input", ")", ",", "size", "\n", "# might be too relaxed", "\n", "# elif len(size) == 1:", "\n", "#     return len(input), int(size[0])", "\n", "", "elif", "len", "(", "size", ")", "==", "2", ":", "\n", "        ", "if", "size", "[", "0", "]", "is", "None", "or", "size", "[", "0", "]", "==", "-", "1", ":", "\n", "# [-1, dim] or [None, dim]", "\n", "            ", "return", "len", "(", "input", ")", ",", "size", "[", "1", "]", "\n", "", "else", ":", "\n", "# [N, dim]", "\n", "            ", "assert", "len", "(", "input", ")", "==", "size", "[", "0", "]", "\n", "return", "tuple", "(", "size", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Incorrect Shape\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2sparse": [[122, 138], ["transforms._check_shape", "transforms.lists2indices", "numpy.ones", "scipy.coo_matrix", "len"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms._check_shape", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2indices"], ["", "", "def", "lists2sparse", "(", "input", ",", "size", ")", ":", "\n", "    ", "\"\"\"\n    Transforms a list of lists into sparse coo format.\n    Shape may not be ommitted.\n    >>> bags = [[0], [1], [0, 2]]\n    >>> X = lists2sparse(bags, (3,3))\n    >>> X.toarray()\n    array([[ 1.,  0.,  0.],\n           [ 0.,  1.,  0.],\n           [ 1.,  0.,  1.]])\n    \"\"\"", "\n", "shape", "=", "_check_shape", "(", "input", ",", "size", ")", "\n", "ind", "=", "lists2indices", "(", "input", ")", "\n", "v", "=", "np", ".", "ones", "(", "len", "(", "ind", "[", "0", "]", ")", ")", "\n", "sparse", "=", "sp", ".", "coo_matrix", "(", "(", "v", ",", "ind", ")", ",", "shape", "=", "shape", ")", "\n", "return", "sparse", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2dense": [[140, 166], ["transforms._check_shape", "zero_gen", "transforms.lists2indices"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms._check_shape", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2indices"], ["", "def", "lists2dense", "(", "input", ",", "size", ",", "zero_gen", "=", "np", ".", "zeros", ")", ":", "\n", "    ", "\"\"\"\n    Arguments\n    =========\n\n    input : set of sets\n    size : desired dimensionality\n    zero_gen: a function (shape) -> zero array\n    >>> bags = [[0], [1], [0, 2]]\n    >>> (lists2sparse(bags, (3,3)).toarray() == lists2dense(bags, (3,3))).all()\n    True\n    >>> import torch\n    >>> lists2dense(bags, 4, torch.zeros)\n    <BLANKLINE>\n     1  0  0  0\n     0  1  0  0\n     1  0  1  0\n    [torch.FloatTensor of size 3x4]\n    <BLANKLINE>\n    \"\"\"", "\n", "shape", "=", "_check_shape", "(", "input", ",", "size", ")", "\n", "A", "=", "zero_gen", "(", "shape", ")", "\n", "ind", "=", "lists2indices", "(", "input", ")", "\n", "# TODO FIXME IndexError when executing recursive.py", "\n", "A", "[", "ind", "]", "=", "1.0", "\n", "return", "A", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.to_strings": [[168, 175], ["str"], "function", ["None"], ["", "def", "to_strings", "(", "input", ")", ":", "\n", "    ", "\"\"\"\n    >>> x = [[3, 4, 2], [1, 2], [], [1, 1, 1, 1]]\n    >>> to_strings(x)\n    [['3', '4', '2'], ['1', '2'], [], ['1', '1', '1', '1']]\n    \"\"\"", "\n", "return", "[", "[", "str", "(", "tok", ")", "for", "tok", "in", "bag", "]", "for", "bag", "in", "input", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.padded_sequence": [[177, 194], ["torch.LongTensor", "torch.LongTensor().fill_", "enumerate", "sorted", "list", "zip", "torch.LongTensor", "seq_tensor.transpose.transpose", "map", "torch.LongTensor", "len", "torch.LongTensor.max"], "function", ["None"], ["", "def", "padded_sequence", "(", "lists", ",", "\n", "pad_with", "=", "0", ",", "\n", "sort", "=", "True", ",", "\n", "batch_first", "=", "False", ")", ":", "\n", "    ", "import", "torch", "\n", "if", "sort", ":", "\n", "        ", "lists", "=", "sorted", "(", "lists", ",", "key", "=", "len", ",", "reverse", "=", "True", ")", "\n", "", "seq_lengths", "=", "torch", ".", "LongTensor", "(", "list", "(", "map", "(", "len", ",", "lists", ")", ")", ")", "\n", "seq_tensor", "=", "torch", ".", "LongTensor", "(", "len", "(", "lists", ")", ",", "seq_lengths", ".", "max", "(", ")", ")", ".", "fill_", "(", "pad_with", ")", "\n", "for", "idx", ",", "(", "seq", ",", "seqlen", ")", "in", "enumerate", "(", "zip", "(", "lists", ",", "seq_lengths", ")", ")", ":", "\n", "        ", "seq_tensor", "[", "idx", ",", ":", "seqlen", "]", "=", "torch", ".", "LongTensor", "(", "seq", ")", "\n", "\n", "", "if", "not", "batch_first", ":", "\n", "        ", "seq_tensor", "=", "seq_tensor", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n", "", "return", "seq_tensor", ",", "seq_lengths", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.ToSparseTensor": [[196, 222], ["isinstance", "scipy.issparse", "input.tocoo.tocoo", "numpy.vstack", "print", "torch.from_numpy", "torch.FloatTensor", "torch.sparse.FloatTensor", "isinstance", "torch.LongTensor().t.astype", "torch.Size", "numpy.nonzero", "torch.LongTensor", "torch.FloatTensor", "torch.sparse.FloatTensor", "enumerate", "torch.LongTensor().t", "torch.ones", "torch.sparse.FloatTensor", "len", "numpy.vstack", "torch.Size", "ind.extend", "len", "torch.Size", "torch.LongTensor", "len", "int"], "function", ["None"], ["", "def", "ToSparseTensor", "(", "input", ",", "dim", "=", "None", ")", ":", "\n", "    ", "import", "torch", "\n", "if", "isinstance", "(", "input", ",", "torch", ".", "sparse", ".", "FloatTensor", ")", ":", "\n", "        ", "return", "input", "\n", "", "elif", "sp", ".", "issparse", "(", "input", ")", ":", "# any of scipy.sparse", "\n", "        ", "input", "=", "input", ".", "tocoo", "(", ")", "\n", "i", "=", "np", ".", "vstack", "(", "[", "input", ".", "row", ",", "input", ".", "col", "]", ")", "\n", "print", "(", "i", ")", "\n", "i", "=", "torch", ".", "from_numpy", "(", "i", ".", "astype", "(", "np", ".", "int64", ")", ")", "\n", "v", "=", "torch", ".", "FloatTensor", "(", "input", ".", "data", ")", "\n", "output", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "i", ",", "v", ",", "torch", ".", "Size", "(", "input", ".", "shape", ")", ")", "\n", "", "elif", "isinstance", "(", "input", ",", "np", ".", "ndarray", ")", ":", "# nd array", "\n", "        ", "assert", "len", "(", "input", ".", "shape", ")", "==", "2", ",", "\"Invalid input shape: \"", "+", "input", ".", "shape", "\n", "nz", "=", "np", ".", "nonzero", "(", "input", ")", "\n", "i", "=", "torch", ".", "LongTensor", "(", "np", ".", "vstack", "(", "*", "nz", ")", ")", "\n", "v", "=", "torch", ".", "FloatTensor", "(", "input", "[", "nz", "]", ")", "\n", "output", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "i", ",", "v", ",", "torch", ".", "Size", "(", "input", ".", "shape", ")", ")", "\n", "", "else", ":", "# assume list of list", "\n", "        ", "assert", "dim", "is", "not", "None", ",", "\"Dimensions undefined\"", "\n", "ind", "=", "[", "]", "\n", "for", "row", ",", "tokens", "in", "enumerate", "(", "input", ")", ":", "\n", "            ", "ind", ".", "extend", "(", "[", "(", "row", ",", "int", "(", "token", ")", ")", "for", "token", "in", "tokens", "]", ")", "\n", "", "i", "=", "torch", ".", "LongTensor", "(", "ind", ")", ".", "t", "(", ")", "\n", "v", "=", "torch", ".", "ones", "(", "len", "(", "ind", ")", ")", "\n", "output", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "i", ",", "v", ",", "torch", ".", "Size", "(", "[", "len", "(", "input", ")", ",", "dim", "]", ")", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.ToTensor": [[224, 231], ["isinstance", "torch.from_numpy", "scipy.issparse", "input.toarray", "input.astype"], "function", ["None"], ["", "def", "ToTensor", "(", "input", ")", ":", "\n", "    ", "import", "torch", "\n", "if", "isinstance", "(", "input", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "input", "\n", "", "input", "=", "input", ".", "toarray", "(", ")", "if", "sp", ".", "issparse", "(", "input", ")", "else", "input", "\n", "tensor", "=", "torch", ".", "from_numpy", "(", "input", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.base.Recommender.__init__": [[8, 10], ["abc.ABC.__init__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.base.Recommender.train": [[11, 15], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "train", "(", "self", ",", "X_train", ")", ":", "\n", "        ", "\"\"\" Uses training set (Bags instance) for training \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.base.Recommender.predict": [[16, 20], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "predict", "(", "self", ",", "X_test", ")", ":", "\n", "        ", "\"\"\" Recommend items \"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.svd.SVDRecommender.__init__": [[17, 24], ["base.Recommender.__init__", "sklearn.decomposition.TruncatedSVD", "sklearn.feature_extraction.text.TfidfVectorizer"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "dims", "=", "1000", ",", "use_title", "=", "False", ",", "tfidf_params", "=", "{", "}", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "SVDRecommender", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "use_title", ":", "\n", "            ", "self", ".", "tfidf", "=", "TfidfVectorizer", "(", "input", "=", "'content'", ",", "**", "tfidf_params", ")", "\n", "\n", "", "self", ".", "svd", "=", "TruncatedSVD", "(", "dims", ",", "**", "kwargs", ")", "\n", "self", ".", "use_title", "=", "use_title", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.svd.SVDRecommender.__str__": [[25, 27], ["str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "svd", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.svd.SVDRecommender.fit": [[28, 31], ["svd.SVDRecommender.svd.fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ")", ":", "\n", "        ", "self", ".", "svd", ".", "fit", "(", "X", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.svd.SVDRecommender.transform": [[32, 34], ["svd.SVDRecommender.svd.transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "transform", "(", "self", ",", "X", ",", "y", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "svd", ".", "transform", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.svd.SVDRecommender.inverse_transform": [[35, 37], ["svd.SVDRecommender.svd.inverse_transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.svd.SVDRecommender.inverse_transform"], ["", "def", "inverse_transform", "(", "self", ",", "X", ",", "y", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "svd", ".", "inverse_transform", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.svd.SVDRecommender.train": [[38, 46], ["training_set.tocsr", "svd.SVDRecommender.fit", "training_set.get_single_attribute", "svd.SVDRecommender.tfidf.fit_transform", "scipy.hstack"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_single_attribute", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "train", "(", "self", ",", "training_set", ")", ":", "\n", "        ", "x_train", "=", "training_set", ".", "tocsr", "(", ")", "\n", "self", ".", "n_classes", "=", "x_train", ".", "shape", "[", "1", "]", "\n", "if", "self", ".", "use_title", ":", "\n", "            ", "titles", "=", "training_set", ".", "get_single_attribute", "(", "\"title\"", ")", "\n", "titles", "=", "self", ".", "tfidf", ".", "fit_transform", "(", "titles", ")", "\n", "x_train", "=", "sp", ".", "hstack", "(", "[", "x_train", ",", "titles", "]", ")", "\n", "", "self", ".", "fit", "(", "x_train", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.svd.SVDRecommender.predict": [[47, 58], ["test_set.tocsr", "svd.SVDRecommender.reconstruct", "test_set.get_single_attribute", "svd.SVDRecommender.tfidf.transform", "scipy.hstack"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.AutoEncoderMixin.reconstruct", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_single_attribute", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "predict", "(", "self", ",", "test_set", ")", ":", "\n", "        ", "x_test", "=", "test_set", ".", "tocsr", "(", ")", "\n", "if", "self", ".", "use_title", ":", "\n", "            ", "titles", "=", "test_set", ".", "get_single_attribute", "(", "\"title\"", ")", "\n", "titles", "=", "self", ".", "tfidf", ".", "transform", "(", "titles", ")", "\n", "x_test", "=", "sp", ".", "hstack", "(", "[", "x_test", ",", "titles", "]", ")", "\n", "# hidden = self.svd.transform(x_test)", "\n", "# y_pred = self.svd.inverse_transform(hidden)", "\n", "", "y_pred", "=", "self", ".", "reconstruct", "(", "x_test", ")", "\n", "y_pred", "=", "y_pred", "[", ":", ",", ":", "self", ".", "n_classes", "]", "\n", "return", "y_pred", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.mean_reciprocal_rank": [[13, 42], ["numpy.array", "numpy.asarray().nonzero", "np.array.mean", "np.array.std", "numpy.asarray"], "function", ["None"], ["def", "mean_reciprocal_rank", "(", "rs", ",", "average", "=", "True", ")", ":", "\n", "    ", "\"\"\"Score is reciprocal of the rank of the first relevant item\n\n    First element is 'rank 1'.  Relevance is binary (nonzero is relevant).\n\n    Example from http://en.wikipedia.org/wiki/Mean_reciprocal_rank\n    >>> rs = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\n    >>> mean_reciprocal_rank(rs)\n    0.61111111111111105\n    >>> rs = np.array([[0, 0, 0], [0, 1, 0], [1, 0, 0]])\n    >>> mean_reciprocal_rank(rs)\n    0.5\n    >>> rs = [[0, 0, 0, 1], [1, 0, 0], [1, 0, 0]]\n    >>> mean_reciprocal_rank(rs)\n    0.75\n\n    Args:\n        rs: Iterator of relevance scores (list or numpy) in rank order\n            (first element is the first item)\n\n    Returns:\n        Mean reciprocal rank\n    \"\"\"", "\n", "rs", "=", "(", "np", ".", "asarray", "(", "r", ")", ".", "nonzero", "(", ")", "[", "0", "]", "for", "r", "in", "rs", ")", "\n", "mrrs", "=", "np", ".", "array", "(", "[", "1.", "/", "(", "r", "[", "0", "]", "+", "1", ")", "if", "r", ".", "size", "else", "0.", "for", "r", "in", "rs", "]", ")", "\n", "if", "average", ":", "\n", "        ", "return", "mrrs", ".", "mean", "(", ")", ",", "mrrs", ".", "std", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "mrrs", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.r_precision": [[44, 71], ["numpy.mean", "numpy.asarray", "r.nonzero"], "function", ["None"], ["", "", "def", "r_precision", "(", "r", ")", ":", "\n", "    ", "\"\"\"Score is precision after all relevant documents have been retrieved\n\n    Relevance is binary (nonzero is relevant).\n\n    >>> r = [0, 0, 1]\n    >>> r_precision(r)\n    0.33333333333333331\n    >>> r = [0, 1, 0]\n    >>> r_precision(r)\n    0.5\n    >>> r = [1, 0, 0]\n    >>> r_precision(r)\n    1.0\n\n    Args:\n        r: Relevance scores (list or numpy) in rank order\n            (first element is the first item)\n\n    Returns:\n        R Precision\n    \"\"\"", "\n", "r", "=", "np", ".", "asarray", "(", "r", ")", "!=", "0", "\n", "z", "=", "r", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "if", "not", "z", ".", "size", ":", "\n", "        ", "return", "0.", "\n", "", "return", "np", ".", "mean", "(", "r", "[", ":", "z", "[", "-", "1", "]", "+", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.precision_at_k": [[73, 106], ["r.mean", "ValueError", "numpy.asarray"], "function", ["None"], ["", "def", "precision_at_k", "(", "r", ",", "k", ")", ":", "\n", "    ", "\"\"\"Score is precision @ k\n\n    Relevance is binary (nonzero is relevant).\n\n    >>> r = [0, 0, 1]\n    >>> precision_at_k(r, 1)\n    0.0\n    >>> precision_at_k(r, 2)\n    0.0\n    >>> precision_at_k(r, 3)\n    0.33333333333333331\n    >>> precision_at_k(r, 4)\n    Traceback (most recent call last):\n        File \"<stdin>\", line 1, in ?\n    ValueError: Relevance score length < k\n\n\n    Args:\n        r: Relevance scores (list or numpy) in rank order\n            (first element is the first item)\n\n    Returns:\n        Precision @ k\n\n    Raises:\n        ValueError: len(r) must be >= k\n    \"\"\"", "\n", "assert", "k", ">=", "1", "\n", "r", "=", "np", ".", "asarray", "(", "r", ")", "[", ":", "k", "]", "!=", "0", "\n", "if", "r", ".", "size", "!=", "k", ":", "\n", "        ", "raise", "ValueError", "(", "'Relevance score length < k'", ")", "\n", "", "return", "r", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.average_precision": [[108, 132], ["numpy.mean", "numpy.asarray", "rank_metrics_with_std.precision_at_k", "range"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.precision_at_k"], ["", "def", "average_precision", "(", "r", ")", ":", "\n", "    ", "\"\"\"Score is average precision (area under PR curve)\n\n    Relevance is binary (nonzero is relevant).\n\n    >>> r = [1, 1, 0, 1, 0, 1, 0, 0, 0, 1]\n    >>> delta_r = 1. / sum(r)\n    >>> sum([sum(r[:x + 1]) / (x + 1.) * delta_r for x, y in enumerate(r) if y])\n    0.7833333333333333\n    >>> average_precision(r)\n    0.78333333333333333\n\n    Args:\n        r: Relevance scores (list or numpy) in rank order\n            (first element is the first item)\n\n    Returns:\n        Average precision\n    \"\"\"", "\n", "r", "=", "np", ".", "asarray", "(", "r", ")", "!=", "0", "\n", "out", "=", "[", "precision_at_k", "(", "r", ",", "k", "+", "1", ")", "for", "k", "in", "range", "(", "r", ".", "size", ")", "if", "r", "[", "k", "]", "]", "\n", "if", "not", "out", ":", "\n", "        ", "return", "0.", "\n", "", "return", "np", ".", "mean", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.mean_average_precision": [[134, 155], ["numpy.array", "np.array.mean", "np.array.std", "rank_metrics_with_std.average_precision"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.average_precision"], ["", "def", "mean_average_precision", "(", "rs", ")", ":", "\n", "    ", "\"\"\"Score is mean average precision\n\n    Relevance is binary (nonzero is relevant).\n\n    >>> rs = [[1, 1, 0, 1, 0, 1, 0, 0, 0, 1]]\n    >>> mean_average_precision(rs)\n    0.78333333333333333\n    >>> rs = [[1, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0]]\n    >>> mean_average_precision(rs)\n    0.39166666666666666\n\n    Args:\n        rs: Iterator of relevance scores (list or numpy) in rank order\n            (first element is the first item)\n\n    Returns:\n        Mean average precision\n    \"\"\"", "\n", "aps", "=", "np", ".", "array", "(", "[", "average_precision", "(", "r", ")", "for", "r", "in", "rs", "]", ")", "\n", "return", "aps", ".", "mean", "(", ")", ",", "aps", ".", "std", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.dcg_at_k": [[157, 198], ["numpy.asfarray", "numpy.sum", "numpy.sum", "ValueError", "numpy.log2", "numpy.log2", "numpy.arange", "numpy.arange"], "function", ["None"], ["", "def", "dcg_at_k", "(", "r", ",", "k", ",", "method", "=", "0", ")", ":", "\n", "    ", "\"\"\"Score is discounted cumulative gain (dcg)\n\n    Relevance is positive real values.  Can use binary\n    as the previous methods.\n\n    Example from\n    http://www.stanford.edu/class/cs276/handouts/EvaluationNew-handout-6-per.pdf\n    >>> r = [3, 2, 3, 0, 0, 1, 2, 2, 3, 0]\n    >>> dcg_at_k(r, 1)\n    3.0\n    >>> dcg_at_k(r, 1, method=1)\n    3.0\n    >>> dcg_at_k(r, 2)\n    5.0\n    >>> dcg_at_k(r, 2, method=1)\n    4.2618595071429155\n    >>> dcg_at_k(r, 10)\n    9.6051177391888114\n    >>> dcg_at_k(r, 11)\n    9.6051177391888114\n\n    Args:\n        r: Relevance scores (list or numpy) in rank order\n            (first element is the first item)\n        k: Number of results to consider\n        method: If 0 then weights are [1.0, 1.0, 0.6309, 0.5, 0.4307, ...]\n                If 1 then weights are [1.0, 0.6309, 0.5, 0.4307, ...]\n\n    Returns:\n        Discounted cumulative gain\n    \"\"\"", "\n", "r", "=", "np", ".", "asfarray", "(", "r", ")", "[", ":", "k", "]", "\n", "if", "r", ".", "size", ":", "\n", "        ", "if", "method", "==", "0", ":", "\n", "            ", "return", "r", "[", "0", "]", "+", "np", ".", "sum", "(", "r", "[", "1", ":", "]", "/", "np", ".", "log2", "(", "np", ".", "arange", "(", "2", ",", "r", ".", "size", "+", "1", ")", ")", ")", "\n", "", "elif", "method", "==", "1", ":", "\n", "            ", "return", "np", ".", "sum", "(", "r", "/", "np", ".", "log2", "(", "np", ".", "arange", "(", "2", ",", "r", ".", "size", "+", "2", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'method must be 0 or 1.'", ")", "\n", "", "", "return", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.ndcg_at_k": [[200, 235], ["rank_metrics_with_std.dcg_at_k", "sorted", "rank_metrics_with_std.dcg_at_k"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.dcg_at_k", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.dcg_at_k"], ["", "def", "ndcg_at_k", "(", "r", ",", "k", ",", "method", "=", "0", ")", ":", "\n", "    ", "\"\"\"Score is normalized discounted cumulative gain (ndcg)\n\n    Relevance is positive real values.  Can use binary\n    as the previous methods.\n\n    Example from\n    http://www.stanford.edu/class/cs276/handouts/EvaluationNew-handout-6-per.pdf\n    >>> r = [3, 2, 3, 0, 0, 1, 2, 2, 3, 0]\n    >>> ndcg_at_k(r, 1)\n    1.0\n    >>> r = [2, 1, 2, 0]\n    >>> ndcg_at_k(r, 4)\n    0.9203032077642922\n    >>> ndcg_at_k(r, 4, method=1)\n    0.96519546960144276\n    >>> ndcg_at_k([0], 1)\n    0.0\n    >>> ndcg_at_k([1], 2)\n    1.0\n\n    Args:\n        r: Relevance scores (list or numpy) in rank order\n            (first element is the first item)\n        k: Number of results to consider\n        method: If 0 then weights are [1.0, 1.0, 0.6309, 0.5, 0.4307, ...]\n                If 1 then weights are [1.0, 0.6309, 0.5, 0.4307, ...]\n\n    Returns:\n        Normalized discounted cumulative gain\n    \"\"\"", "\n", "dcg_max", "=", "dcg_at_k", "(", "sorted", "(", "r", ",", "reverse", "=", "True", ")", ",", "k", ",", "method", ")", "\n", "if", "not", "dcg_max", ":", "\n", "        ", "return", "0.", "\n", "", "return", "dcg_at_k", "(", "r", ",", "k", ",", "method", ")", "/", "dcg_max", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.RandomBaseline.__str__": [[10, 12], ["None"], "methods", ["None"], ["def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"RNDM baseline\"", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.RandomBaseline.train": [[13, 15], ["None"], "methods", ["None"], ["", "def", "train", "(", "self", ",", "X", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.RandomBaseline.predict": [[16, 20], ["X.tocsr.tocsr.tocsr", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "X", "=", "X", ".", "tocsr", "(", ")", "\n", "random_predictions", "=", "rand", "(", "X", ".", "shape", "[", "0", "]", ",", "X", ".", "shape", "[", "1", "]", ")", "\n", "return", "random_predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.Countbased.__init__": [[24, 27], ["base.Recommender.__init__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "order", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "order", "=", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.Countbased.__str__": [[28, 32], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "\"Count-based Predictor\"", "\n", "s", "+=", "\" (order {})\"", ".", "format", "(", "self", ".", "order", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.Countbased.train": [[33, 39], ["X.tocsr.tocsr.tocsr", "range"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr"], ["", "def", "train", "(", "self", ",", "X", ")", ":", "\n", "        ", "X", "=", "X", ".", "tocsr", "(", ")", "\n", "# Construct cooccurrence matrix", "\n", "self", ".", "cooccurences", "=", "X", ".", "T", "@", "X", "\n", "for", "__", "in", "range", "(", "0", ",", "self", ".", "order", "-", "1", ")", ":", "\n", "            ", "self", ".", "cooccurences", "=", "self", ".", "cooccurences", ".", "T", "@", "self", ".", "cooccurences", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.Countbased.predict": [[40, 44], ["X.tocsr.tocsr.tocsr"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr"], ["", "", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "# Sum up values of coocurrences", "\n", "        ", "X", "=", "X", ".", "tocsr", "(", ")", "\n", "return", "X", "@", "self", ".", "cooccurences", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.MostPopular.__init__": [[48, 50], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "most_popular", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.MostPopular.__str__": [[51, 53], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"Most Popular baseline\"", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.MostPopular.train": [[54, 56], ["X.tocsr().sum", "X.tocsr"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr"], ["", "def", "train", "(", "self", ",", "X", ")", ":", "\n", "        ", "self", ".", "most_popular", "=", "X", ".", "tocsr", "(", ")", ".", "sum", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.baselines.MostPopular.predict": [[57, 59], ["numpy.broadcast_to", "X.size"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "np", ".", "broadcast_to", "(", "self", ".", "most_popular", ",", "X", ".", "size", "(", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.__init__": [[49, 107], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "optimizer_gen", "vae.VAE.conditions.size_increment", "vae.VAE.parameters", "getattr", "getattr", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "optimizer.lower", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment"], ["    ", "def", "__init__", "(", "self", ",", "\n", "inp", ",", "\n", "out", ",", "\n", "n_hidden", "=", "100", ",", "\n", "n_code", "=", "50", ",", "\n", "lr", "=", "0.001", ",", "\n", "batch_size", "=", "100", ",", "\n", "n_epochs", "=", "500", ",", "\n", "optimizer", "=", "'adam'", ",", "\n", "normalize_inputs", "=", "True", ",", "\n", "activation", "=", "'ReLU'", ",", "\n", "final_activation", "=", "'Sigmoid'", ",", "\n", "# TODO try later", "\n", "# dropout=(.2,.2),", "\n", "conditions", "=", "None", ",", "\n", "verbose", "=", "True", ",", "\n", "log_interval", "=", "1", ",", "\n", "device", "=", "None", ")", ":", "\n", "\n", "        ", "super", "(", "VAE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "normalize_inputs", "=", "normalize_inputs", "\n", "self", ".", "inp", "=", "inp", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "n_code", "=", "n_code", "\n", "self", ".", "n_epochs", "=", "n_epochs", "\n", "self", ".", "verbose", "=", "verbose", "\n", "# TODO try later", "\n", "# self.dropout = dropout", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "activation", "=", "activation", "\n", "self", ".", "conditions", "=", "conditions", "\n", "\n", "# 2-layers Encoder", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "inp", ",", "n_hidden", ")", "\n", "self", ".", "fc21", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_code", ")", "\n", "self", ".", "fc22", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_code", ")", "\n", "\n", "# 2-layers Decoder", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "n_code", "+=", "self", ".", "conditions", ".", "size_increment", "(", ")", "\n", "", "self", ".", "fc3", "=", "nn", ".", "Linear", "(", "n_code", ",", "n_hidden", ")", "\n", "self", ".", "fc4", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "out", ")", "\n", "optimizer_gen", "=", "TORCH_OPTIMIZERS", "[", "optimizer", ".", "lower", "(", ")", "]", "\n", "self", ".", "optimizer", "=", "optimizer_gen", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n", "self", ".", "act", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "self", ".", "final_act", "=", "getattr", "(", "nn", ",", "final_activation", ")", "(", ")", "\n", "\n", "self", ".", "log_interval", "=", "log_interval", "\n", "\n", "if", "device", "is", "not", "None", ":", "\n", "            ", "self", ".", "device", "=", "device", "\n", "", "elif", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "device", "=", "torch", ".", "device", "(", "'cuda'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.encode": [[108, 111], ["vae.VAE.act", "vae.VAE.fc1", "vae.VAE.fc21", "vae.VAE.fc22"], "methods", ["None"], ["", "", "def", "encode", "(", "self", ",", "x", ")", ":", "\n", "        ", "h1", "=", "self", ".", "act", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "return", "self", ".", "fc21", "(", "h1", ")", ",", "self", ".", "fc22", "(", "h1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.reparametrize": [[112, 116], ["logvar.mul().exp_", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like.mul().add_", "torch.randn_like.mul().add_", "torch.randn_like.mul().add_", "torch.randn_like.mul().add_", "torch.randn_like.mul().add_", "logvar.mul", "torch.randn_like.mul", "torch.randn_like.mul", "torch.randn_like.mul", "torch.randn_like.mul", "torch.randn_like.mul"], "methods", ["None"], ["", "def", "reparametrize", "(", "self", ",", "mu", ",", "logvar", ")", ":", "\n", "        ", "std", "=", "logvar", ".", "mul", "(", "0.5", ")", ".", "exp_", "(", ")", "\n", "eps", "=", "torch", ".", "randn_like", "(", "std", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ")", "\n", "return", "eps", ".", "mul", "(", "std", ")", ".", "add_", "(", "mu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.decode": [[117, 120], ["vae.VAE.act", "vae.VAE.final_act", "vae.VAE.fc3", "vae.VAE.fc4"], "methods", ["None"], ["", "def", "decode", "(", "self", ",", "z", ")", ":", "\n", "        ", "h3", "=", "self", ".", "act", "(", "self", ".", "fc3", "(", "z", ")", ")", "\n", "return", "self", ".", "final_act", "(", "self", ".", "fc4", "(", "h3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.forward": [[121, 131], ["vae.VAE.encode", "vae.VAE.reparametrize", "_check_conditions", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize.view", "vae.VAE.conditions.encode_impose", "vae.VAE.decode"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.reparametrize", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.decode"], ["", "def", "forward", "(", "self", ",", "x", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "normalize_inputs", ":", "\n", "            ", "x", "=", "F", ".", "normalize", "(", "x", ",", "1", ")", "\n", "# TODO could I use x instead of self.inp? Do we need x.view?", "\n", "", "mu", ",", "logvar", "=", "self", ".", "encode", "(", "x", ".", "view", "(", "-", "1", ",", "self", ".", "inp", ")", ")", "\n", "z", "=", "self", ".", "reparametrize", "(", "mu", ",", "logvar", ")", "\n", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "if", "use_condition", ":", "\n", "            ", "z", "=", "self", ".", "conditions", ".", "encode_impose", "(", "z", ",", "condition_data", ")", "\n", "", "return", "self", ".", "decode", "(", "z", ")", ",", "mu", ",", "logvar", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.loss_function": [[132, 146], ["torch.BCELoss", "torch.BCELoss", "torch.BCELoss", "torch.BCELoss", "torch.BCELoss", "torch.BCELoss.", "mu.pow().add_().mul_().add_().add_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "torch.sum().mul_", "mu.pow().add_().mul_().add_", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "mu.pow().add_().mul_", "mu.pow().add_", "logvar.exp", "mu.pow"], "methods", ["None"], ["", "def", "loss_function", "(", "self", ",", "recon_x", ",", "x", ",", "mu", ",", "logvar", ")", ":", "\n", "        ", "reconstruction_function", "=", "nn", ".", "BCELoss", "(", ")", "\n", "reconstruction_function", ".", "size_average", "=", "False", "\n", "\n", "BCE", "=", "reconstruction_function", "(", "recon_x", ",", "x", ")", "\n", "\n", "# see Appendix B from VAE paper:", "\n", "# Kingma and Welling. Auto-Encoding Variational Bayes. ICLR, 2014", "\n", "# https://arxiv.org/abs/1312.6114", "\n", "# 0.5 * sum(1 + log(sigma^2) - mu^2 - sigma^2)", "\n", "KLD_element", "=", "mu", ".", "pow", "(", "2", ")", ".", "add_", "(", "logvar", ".", "exp", "(", ")", ")", ".", "mul_", "(", "-", "1", ")", ".", "add_", "(", "1", ")", ".", "add_", "(", "logvar", ")", "\n", "KLD", "=", "torch", ".", "sum", "(", "KLD_element", ")", ".", "mul_", "(", "-", "0.5", ")", "\n", "\n", "return", "BCE", "+", "KLD", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.partial_fit": [[147, 186], ["_check_conditions", "scipy.issparse", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "vae.VAE.train", "vae.VAE.optimizer.zero_grad", "vae.VAE.loss_function", "vae.VAE.backward", "vae.VAE.optimizer.step", "ValueError", "X.toarray.toarray.toarray", "vae.VAE.", "vae.VAE.", "vae.VAE.conditions.zero_grad", "vae.VAE.conditions.step", "vae.log_losses", "vae.VAE.item", "len"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.loss_function", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.log_losses"], ["", "def", "partial_fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n            Performs reconstrction, discimination, generator training steps\n        :param X: np.array, the base data from Bag class\n        :param y: dummy variable, throws Error if used\n        :param condition_data: generic list of conditions\n        :return:\n        \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"(Semi-)supervised usage not supported\"", ")", "\n", "\n", "# Transform to Torch (Cuda) Variable, shift batch to GPU", "\n", "", "if", "sp", ".", "issparse", "(", "X", ")", ":", "\n", "            ", "X", "=", "X", ".", "toarray", "(", ")", "\n", "", "X", "=", "torch", ".", "as_tensor", "(", "X", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# Make sure we are in training mode and zero leftover gradients", "\n", "self", ".", "train", "(", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "# Build the model on the concatenated data, compute BCE without concatenation", "\n", "if", "use_condition", ":", "\n", "            ", "recon_batch", ",", "mu", ",", "logvar", "=", "self", "(", "X", ",", "condition_data", ")", "\n", "", "else", ":", "\n", "            ", "recon_batch", ",", "mu", ",", "logvar", "=", "self", "(", "X", ")", "\n", "\n", "", "loss", "=", "self", ".", "loss_function", "(", "recon_batch", ",", "X", ",", "mu", ",", "logvar", ")", "\n", "if", "use_condition", ":", "\n", "            ", "self", ".", "conditions", ".", "zero_grad", "(", ")", "\n", "", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "if", "use_condition", ":", "\n", "            ", "self", ".", "conditions", ".", "step", "(", ")", "\n", "", "if", "self", ".", "verbose", ":", "\n", "# Log batch loss", "\n", "            ", "log_losses", "(", "loss", ".", "item", "(", ")", "/", "len", "(", "X", ")", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.fit": [[187, 228], ["_check_conditions", "range", "NotImplementedError", "range", "print", "sklearn.utils.shuffle", "sklearn.utils.shuffle", "print", "vae.VAE.partial_fit", "vae.VAE.partial_fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param X: np.array, the base data from Bag class\n        :param y: dummy variable, throws Error if used\n        :param condition_data: generic list of conditions\n        :return:\n        \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "# TODO: check how X representation and numpy.array work together", "\n", "# TODO: adapt combining X and new_conditions_name", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"(Semi-)supervised usage not supported\"", ")", "\n", "\n", "", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "# do the actual training", "\n", "for", "epoch", "in", "range", "(", "self", ".", "n_epochs", ")", ":", "\n", "            ", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "\"Epoch\"", ",", "epoch", "+", "1", ")", "\n", "\n", "", "if", "use_condition", ":", "\n", "# shuffle(*arrays) takes several arrays and shuffles them so indices are still matching", "\n", "                ", "X_shuf", ",", "*", "condition_data_shuf", "=", "sklearn", ".", "utils", ".", "shuffle", "(", "X", ",", "*", "condition_data", ")", "\n", "", "else", ":", "\n", "                ", "X_shuf", "=", "sklearn", ".", "utils", ".", "shuffle", "(", "X", ")", "\n", "\n", "", "for", "start", "in", "range", "(", "0", ",", "X", ".", "shape", "[", "0", "]", ",", "self", ".", "batch_size", ")", ":", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "X_batch", "=", "X_shuf", "[", "start", ":", "end", "]", "\n", "# condition may be None", "\n", "if", "use_condition", ":", "\n", "# c_batch = condition_shuf[start:(start+self.batch_size)]", "\n", "                    ", "c_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data_shuf", "]", "\n", "self", ".", "partial_fit", "(", "X_batch", ",", "condition_data", "=", "c_batch", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "partial_fit", "(", "X_batch", ")", "\n", "\n", "", "", "if", "self", ".", "verbose", ":", "\n", "# Clean up after flushing batch loss printings", "\n", "                ", "print", "(", ")", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.predict": [[229, 267], ["_check_conditions", "vae.VAE.eval", "numpy.vstack", "vae.VAE.conditions.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "range", "print", "scipy.issparse", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "vae.VAE.loss_function().item", "pred.append", "X_batch.toarray.toarray.toarray", "vae.VAE.", "vae.VAE.", "recon_batch.data.cpu().numpy", "vae.VAE.loss_function", "recon_batch.data.cpu"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAE.loss_function"], ["", "def", "predict", "(", "self", ",", "X", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param X: np.array, the base data from Bag class\n        :param condition_data: generic list of conditions\n        :return:\n        \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "self", ".", "eval", "(", ")", "# Deactivate dropout", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "eval", "(", ")", "\n", "", "pred", "=", "[", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "test_loss", "=", "0", "\n", "for", "start", "in", "range", "(", "0", ",", "X", ".", "shape", "[", "0", "]", ",", "self", ".", "batch_size", ")", ":", "\n", "# batched predictions, yet inclusive", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "X_batch", "=", "X", "[", "start", ":", "end", "]", "\n", "if", "sp", ".", "issparse", "(", "X_batch", ")", ":", "\n", "                    ", "X_batch", "=", "X_batch", ".", "toarray", "(", ")", "\n", "# as_tensor does not make a copy of X_batch", "\n", "", "X_batch", "=", "torch", ".", "as_tensor", "(", "X_batch", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "if", "use_condition", ":", "\n", "                    ", "c_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data", "]", "\n", "\n", "", "if", "use_condition", ":", "\n", "                    ", "recon_batch", ",", "mu", ",", "logvar", "=", "self", "(", "X_batch", ",", "c_batch", ")", "\n", "", "else", ":", "\n", "                    ", "recon_batch", ",", "mu", ",", "logvar", "=", "self", "(", "X_batch", ")", "\n", "", "test_loss", "+=", "self", ".", "loss_function", "(", "recon_batch", ",", "X_batch", ",", "mu", ",", "logvar", ")", ".", "item", "(", ")", "\n", "pred", ".", "append", "(", "recon_batch", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "", "test_loss", "/=", "X", ".", "shape", "[", "0", "]", "\n", "print", "(", "'====> Test set loss: {:.4f}'", ".", "format", "(", "test_loss", ")", ")", "\n", "\n", "", "return", "np", ".", "vstack", "(", "pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAERecommender.__init__": [[287, 295], ["Recommender.__init__", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "conditions", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "verbose", "=", "kwargs", ".", "get", "(", "'verbose'", ",", "True", ")", "\n", "self", ".", "conditions", "=", "conditions", "\n", "self", ".", "model_params", "=", "kwargs", "\n", "self", ".", "model", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAERecommender.__str__": [[296, 302], ["str", "vae.VAERecommender.conditions.keys"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "desc", "=", "\"Variational Autoencoder\"", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "desc", "+=", "\" conditioned on: \"", "+", "', '", ".", "join", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "", "desc", "+=", "'\\nModel Params: '", "+", "str", "(", "self", ".", "model_params", ")", "\n", "return", "desc", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAERecommender.train": [[303, 331], ["training_set.tocsr", "vae.VAE", "print", "print", "print", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "vae.VAERecommender.model.fit", "training_set.get_attributes", "vae.VAERecommender.conditions.fit_transform", "vae.VAERecommender.model.cuda", "vae.VAERecommender.conditions.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "train", "(", "self", ",", "training_set", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "\"\"\"\n        1. get basic representation\n        2. ? add potential side_info in ??? representation\n        3. initialize a Variational Autoencoder\n        4. fit based on Variational Autoencoder\n        :param training_set: ???, Bag Class training set\n        :return: trained self\n        \"\"\"", "\n", "X", "=", "training_set", ".", "tocsr", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "condition_data_raw", "=", "training_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "condition_data", "=", "self", ".", "conditions", ".", "fit_transform", "(", "condition_data_raw", ")", "\n", "#self.model = VAE(X.shape[1] + self.conditions.size_increment(), X.shape[1],", "\n", "#                 conditions=self.conditions, **self.model_params)", "\n", "", "else", ":", "\n", "            ", "condition_data", "=", "None", "\n", "#self.model = VAE(X.shape[1], X.shape[1], **self.model_params)", "\n", "", "self", ".", "model", "=", "VAE", "(", "X", ".", "shape", "[", "1", "]", ",", "X", ".", "shape", "[", "1", "]", ",", "conditions", "=", "self", ".", "conditions", ",", "**", "self", ".", "model_params", ")", "\n", "\n", "print", "(", "self", ")", "\n", "print", "(", "self", ".", "model", ")", "\n", "print", "(", "self", ".", "conditions", ")", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "model", ".", "cuda", "(", ")", "\n", "", "self", ".", "model", ".", "fit", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.VAERecommender.predict": [[332, 344], ["test_set.tocsr", "vae.VAERecommender.model.predict", "test_set.get_attributes", "vae.VAERecommender.conditions.transform", "vae.VAERecommender.conditions.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.predict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "predict", "(", "self", ",", "test_set", ")", ":", "\n", "        ", "X", "=", "test_set", ".", "tocsr", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "condition_data_raw", "=", "test_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "# Important to not call fit here, but just transform", "\n", "condition_data", "=", "self", ".", "conditions", ".", "transform", "(", "condition_data_raw", ")", "\n", "", "else", ":", "\n", "            ", "condition_data", "=", "None", "\n", "\n", "", "pred", "=", "self", ".", "model", ".", "predict", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.log_losses": [[43, 45], ["print", "STATUS_FORMAT.format"], "function", ["None"], ["def", "log_losses", "(", "loss", ")", ":", "\n", "    ", "print", "(", "'\\r'", "+", "STATUS_FORMAT", ".", "format", "(", "loss", ")", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.vae.main": [[346, 394], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "Bags.load_tabcomma_format", "Evaluation().setup", "print", "gensim.models.keyedvectors.KeyedVectors.load_word2vec_format", "ConditionList", "Evaluation().setup.", "vae.VAERecommender", "Evaluation", "itertools.product", "PretrainedWordEmbeddingCondition"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.load_tabcomma_format", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.setup"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\" Evaluates the VAE Recommender \"\"\"", "\n", "CONFIG", "=", "{", "\n", "'pub'", ":", "(", "'/data21/lgalke/datasets/citations_pmc.tsv'", ",", "2011", ",", "50", ")", ",", "\n", "'eco'", ":", "(", "'/data21/lgalke/datasets/econbiz62k.tsv'", ",", "2012", ",", "1", ")", "\n", "}", "\n", "\n", "PARSER", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "PARSER", ".", "add_argument", "(", "'data'", ",", "type", "=", "str", ",", "choices", "=", "[", "'pub'", ",", "'eco'", "]", ")", "\n", "args", "=", "PARSER", ".", "parse_args", "(", ")", "\n", "DATA", "=", "CONFIG", "[", "args", ".", "data", "]", "\n", "logfile", "=", "'/data22/ivagliano/test-vae/'", "+", "args", ".", "data", "+", "'-hyperparams-opt.log'", "\n", "bags", "=", "Bags", ".", "load_tabcomma_format", "(", "DATA", "[", "0", "]", ")", "\n", "c_year", "=", "DATA", "[", "1", "]", "\n", "\n", "evaluate", "=", "Evaluation", "(", "bags", ",", "\n", "year", "=", "c_year", ",", "\n", "logfile", "=", "logfile", ")", ".", "setup", "(", "min_count", "=", "DATA", "[", "2", "]", ",", "\n", "min_elements", "=", "2", ")", "\n", "print", "(", "\"Loading pre-trained embedding\"", ",", "W2V_PATH", ")", "\n", "vectors", "=", "KeyedVectors", ".", "load_word2vec_format", "(", "W2V_PATH", ",", "binary", "=", "W2V_IS_BINARY", ")", "\n", "\n", "params", "=", "{", "\n", "#'n_epochs': 10,", "\n", "'batch_size'", ":", "100", ",", "\n", "'optimizer'", ":", "'adam'", ",", "\n", "# 'normalize_inputs': True,", "\n", "}", "\n", "\n", "CONDITIONS", "=", "ConditionList", "(", "[", "\n", "(", "'title'", ",", "PretrainedWordEmbeddingCondition", "(", "vectors", ")", ")", "\n", "]", ")", "\n", "\n", "# 100 hidden units, 200 epochs, bernoulli prior, normalized inputs -> 0.174", "\n", "# activations = ['ReLU','SELU']", "\n", "# lrs = [(0.001, 0.0005), (0.001, 0.001)]", "\n", "hcs", "=", "[", "(", "100", ",", "50", ")", ",", "(", "300", ",", "100", ")", "]", "\n", "epochs", "=", "[", "50", ",", "100", ",", "200", ",", "500", "]", "\n", "\n", "# dropouts = [(.2,.2), (.1,.1), (.1, .2), (.25, .25), (.3,.3)] # .2,.2 is best", "\n", "# priors = ['categorical'] # gauss is best", "\n", "# normal = [True, False]", "\n", "# bernoulli was good, letz see if categorical is better... No", "\n", "import", "itertools", "\n", "models", "=", "[", "VAERecommender", "(", "conditions", "=", "CONDITIONS", ",", "**", "params", ",", "n_hidden", "=", "hc", "[", "0", "]", ",", "n_code", "=", "hc", "[", "1", "]", ",", "n_epochs", "=", "e", ")", "\n", "for", "hc", ",", "e", "in", "itertools", ".", "product", "(", "hcs", ",", "epochs", ")", "]", "\n", "# models = [VAERecommender(conditions=CONDITIONS, **params)]", "\n", "evaluate", "(", "models", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.Encoder.__init__": [[68, 91], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "getattr", "getattr", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "ValueError"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "n_input", ",", "n_hidden", ",", "n_code", ",", "final_activation", "=", "None", ",", "\n", "normalize_inputs", "=", "True", ",", "dropout", "=", "(", ".2", ",", ".2", ")", ",", "activation", "=", "'ReLU'", ")", ":", "\n", "        ", "super", "(", "Encoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "n_input", ",", "n_hidden", ")", "\n", "self", ".", "act1", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_hidden", ")", "\n", "self", ".", "act2", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "if", "activation", "==", "'SELU'", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "Dropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "Dropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "self", ".", "lin3", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_code", ")", "\n", "self", ".", "normalize_inputs", "=", "normalize_inputs", "\n", "if", "final_activation", "==", "'linear'", "or", "final_activation", "is", "None", ":", "\n", "            ", "self", ".", "final_activation", "=", "None", "\n", "", "elif", "final_activation", "==", "'softmax'", ":", "\n", "            ", "self", ".", "final_activation", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "", "elif", "final_activation", "==", "'sigmoid'", ":", "\n", "            ", "self", ".", "final_activation", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Final activation unknown:\"", ",", "activation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.Encoder.forward": [[92, 109], ["dae.Encoder.lin1", "dae.Encoder.drop1", "dae.Encoder.act1", "dae.Encoder.lin2", "dae.Encoder.drop2", "dae.Encoder.act2", "dae.Encoder.lin3", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "dae.Encoder.final_activation"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\" Forward method implementation of 3-layer encoder \"\"\"", "\n", "if", "self", ".", "normalize_inputs", ":", "\n", "            ", "inp", "=", "F", ".", "normalize", "(", "inp", ",", "1", ")", "\n", "# first layer", "\n", "", "act", "=", "self", ".", "lin1", "(", "inp", ")", "\n", "act", "=", "self", ".", "drop1", "(", "act", ")", "\n", "act", "=", "self", ".", "act1", "(", "act", ")", "\n", "# second layer", "\n", "act", "=", "self", ".", "lin2", "(", "act", ")", "\n", "act", "=", "self", ".", "drop2", "(", "act", ")", "\n", "act", "=", "self", ".", "act2", "(", "act", ")", "\n", "# third layer", "\n", "act", "=", "self", ".", "lin3", "(", "act", ")", "\n", "if", "self", ".", "final_activation", ":", "\n", "            ", "act", "=", "self", ".", "final_activation", "(", "act", ")", "\n", "", "return", "act", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.Decoder.__init__": [[114, 127], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "n_code", ",", "n_hidden", ",", "n_output", ",", "dropout", "=", "(", ".2", ",", ".2", ")", ",", "activation", "=", "'ReLU'", ")", ":", "\n", "        ", "super", "(", "Decoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "n_code", ",", "n_hidden", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_hidden", ")", "\n", "self", ".", "lin3", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "if", "activation", "==", "'SELU'", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "Dropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "Dropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "self", ".", "act1", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "self", ".", "act2", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.Decoder.forward": [[128, 142], ["dae.Decoder.lin1", "dae.Decoder.drop1", "dae.Decoder.act1", "dae.Decoder.lin2", "dae.Decoder.drop2", "dae.Decoder.act2", "dae.Decoder.lin3", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\" Forward implementation of 3-layer decoder \"\"\"", "\n", "# first layer", "\n", "act", "=", "self", ".", "lin1", "(", "inp", ")", "\n", "act", "=", "self", ".", "drop1", "(", "act", ")", "\n", "act", "=", "self", ".", "act1", "(", "act", ")", "\n", "# second layer", "\n", "act", "=", "self", ".", "lin2", "(", "act", ")", "\n", "act", "=", "self", ".", "drop2", "(", "act", ")", "\n", "act", "=", "self", ".", "act2", "(", "act", ")", "\n", "# final layer", "\n", "act", "=", "self", ".", "lin3", "(", "act", ")", "\n", "act", "=", "F", ".", "sigmoid", "(", "act", ")", "\n", "return", "act", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DenoisingAutoEncoder.__init__": [[145, 174], ["optimizer.lower", "corrupt.lower"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_hidden", "=", "100", ",", "\n", "n_code", "=", "50", ",", "\n", "lr", "=", "0.001", ",", "\n", "batch_size", "=", "100", ",", "\n", "n_epochs", "=", "500", ",", "\n", "optimizer", "=", "'adam'", ",", "\n", "normalize_inputs", "=", "True", ",", "\n", "activation", "=", "'ReLU'", ",", "\n", "dropout", "=", "(", ".2", ",", ".2", ")", ",", "\n", "noise_factor", "=", "0.2", ",", "\n", "corrupt", "=", "'zeros'", ",", "\n", "conditions", "=", "None", ",", "\n", "verbose", "=", "True", ")", ":", "\n", "\n", "        ", "self", ".", "enc", ",", "self", ".", "dec", "=", "None", ",", "None", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "n_code", "=", "n_code", "\n", "self", ".", "n_epochs", "=", "n_epochs", "\n", "self", ".", "optimizer", "=", "optimizer", ".", "lower", "(", ")", "\n", "self", ".", "normalize_inputs", "=", "normalize_inputs", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "activation", "=", "activation", "\n", "self", ".", "noise_factor", "=", "noise_factor", "\n", "self", ".", "corrupt", "=", "NOISE_TYPES", "[", "corrupt", ".", "lower", "(", ")", "]", "\n", "self", ".", "conditions", "=", "conditions", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DenoisingAutoEncoder.eval": [[175, 181], ["dae.DenoisingAutoEncoder.enc.eval", "dae.DenoisingAutoEncoder.dec.eval", "dae.DenoisingAutoEncoder.conditions.eval"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "\"\"\" Put all NN modules into eval mode \"\"\"", "\n", "self", ".", "enc", ".", "eval", "(", ")", "\n", "self", ".", "dec", ".", "eval", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DenoisingAutoEncoder.train": [[182, 188], ["dae.DenoisingAutoEncoder.enc.train", "dae.DenoisingAutoEncoder.dec.train", "dae.DenoisingAutoEncoder.conditions.train"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train"], ["", "", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\" Put all NN modules into train mode \"\"\"", "\n", "self", ".", "enc", ".", "train", "(", ")", "\n", "self", ".", "dec", ".", "train", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DenoisingAutoEncoder.ae_step": [[189, 211], ["dae.DenoisingAutoEncoder.enc", "aaerec.condition._check_conditions", "dae.DenoisingAutoEncoder.dec", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "dae.DenoisingAutoEncoder.enc_optim.zero_grad", "dae.DenoisingAutoEncoder.dec_optim.zero_grad", "torch.binary_cross_entropy.backward", "dae.DenoisingAutoEncoder.enc_optim.step", "dae.DenoisingAutoEncoder.dec_optim.step", "torch.binary_cross_entropy.item", "dae.DenoisingAutoEncoder.corrupt", "dae.DenoisingAutoEncoder.conditions.encode_impose", "dae.DenoisingAutoEncoder.conditions.zero_grad", "dae.DenoisingAutoEncoder.conditions.step", "batch.view", "batch.size", "batch.size"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "", "def", "ae_step", "(", "self", ",", "batch", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "\"\"\" Perform one autoencoder training step \"\"\"", "\n", "z_sample", "=", "self", ".", "enc", "(", "self", ".", "corrupt", "(", "batch", ",", "self", ".", "noise_factor", ")", ")", "\n", "\n", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "if", "use_condition", ":", "\n", "            ", "z_sample", "=", "self", ".", "conditions", ".", "encode_impose", "(", "z_sample", ",", "condition_data", ")", "\n", "\n", "", "x_sample", "=", "self", ".", "dec", "(", "z_sample", ")", "\n", "recon_loss", "=", "F", ".", "binary_cross_entropy", "(", "x_sample", "+", "TINY", ",", "\n", "batch", ".", "view", "(", "batch", ".", "size", "(", "0", ")", ",", "\n", "batch", ".", "size", "(", "1", ")", ")", "+", "TINY", ")", "\n", "self", ".", "enc_optim", ".", "zero_grad", "(", ")", "\n", "self", ".", "dec_optim", ".", "zero_grad", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "zero_grad", "(", ")", "\n", "", "recon_loss", ".", "backward", "(", ")", "\n", "self", ".", "enc_optim", ".", "step", "(", ")", "\n", "self", ".", "dec_optim", ".", "step", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "step", "(", ")", "\n", "", "return", "recon_loss", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DenoisingAutoEncoder.partial_fit": [[212, 231], ["aaerec.condition._check_conditions", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "dae.DenoisingAutoEncoder.train", "dae.DenoisingAutoEncoder.ae_step", "ValueError", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "X.cuda.cuda.cuda", "dae.log_losses"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.ae_step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.log_losses"], ["", "def", "partial_fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "\"\"\" Performs reconstrction, discimination, generator training steps \"\"\"", "\n", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"(Semi-)supervised usage not supported\"", ")", "\n", "# Transform to Torch (Cuda) Variable, shift batch to GPU", "\n", "", "X", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "X", ")", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "X", "=", "X", ".", "cuda", "(", ")", "\n", "\n", "\n", "# Make sure we are in training mode and zero leftover gradients", "\n", "", "self", ".", "train", "(", ")", "\n", "# One step each, could balance", "\n", "recon_loss", "=", "self", ".", "ae_step", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "log_losses", "(", "recon_loss", ",", "0", ",", "0", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DenoisingAutoEncoder.fit": [[232, 285], ["aaerec.condition._check_conditions", "dae.Encoder", "dae.Decoder", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "optimizer_gen", "optimizer_gen", "range", "NotImplementedError", "dae.DenoisingAutoEncoder.enc.cuda", "dae.DenoisingAutoEncoder.dec.cuda", "dae.DenoisingAutoEncoder.enc.parameters", "dae.DenoisingAutoEncoder.dec.parameters", "range", "dae.DenoisingAutoEncoder.conditions.size_increment", "print", "sklearn.utils.shuffle", "sklearn.utils.shuffle", "X_shuf[].toarray", "print", "dae.DenoisingAutoEncoder.partial_fit", "dae.DenoisingAutoEncoder.partial_fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "if", "y", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"(Semi-)supervised usage not supported\"", ")", "\n", "\n", "", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "if", "use_condition", ":", "\n", "            ", "code_size", "=", "self", ".", "n_code", "+", "self", ".", "conditions", ".", "size_increment", "(", ")", "\n", "", "else", ":", "\n", "            ", "code_size", "=", "self", ".", "n_code", "\n", "\n", "", "self", ".", "enc", "=", "Encoder", "(", "X", ".", "shape", "[", "1", "]", ",", "self", ".", "n_hidden", ",", "self", ".", "n_code", ",", "\n", "final_activation", "=", "'linear'", ",", "\n", "normalize_inputs", "=", "self", ".", "normalize_inputs", ",", "\n", "dropout", "=", "self", ".", "dropout", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "dec", "=", "Decoder", "(", "code_size", ",", "self", ".", "n_hidden", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "dropout", "=", "self", ".", "dropout", ",", "activation", "=", "self", ".", "activation", ")", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "enc", "=", "self", ".", "enc", ".", "cuda", "(", ")", "\n", "self", ".", "dec", "=", "self", ".", "dec", ".", "cuda", "(", ")", "\n", "", "optimizer_gen", "=", "TORCH_OPTIMIZERS", "[", "self", ".", "optimizer", "]", "\n", "# Reconstruction", "\n", "self", ".", "enc_optim", "=", "optimizer_gen", "(", "self", ".", "enc", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "self", ".", "dec_optim", "=", "optimizer_gen", "(", "self", ".", "dec", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "\n", "# do the actual training", "\n", "for", "epoch", "in", "range", "(", "self", ".", "n_epochs", ")", ":", "\n", "            ", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "\"Epoch\"", ",", "epoch", "+", "1", ")", "\n", "\n", "# Shuffle on each new epoch", "\n", "", "if", "use_condition", ":", "\n", "# shuffle(*arrays) takes several arrays and shuffles them so indices are still matching", "\n", "                ", "X_shuf", ",", "*", "condition_data_shuf", "=", "sklearn", ".", "utils", ".", "shuffle", "(", "X", ",", "*", "condition_data", ")", "\n", "", "else", ":", "\n", "                ", "X_shuf", "=", "sklearn", ".", "utils", ".", "shuffle", "(", "X", ")", "\n", "\n", "", "for", "start", "in", "range", "(", "0", ",", "X", ".", "shape", "[", "0", "]", ",", "self", ".", "batch_size", ")", ":", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "X_batch", "=", "X_shuf", "[", "start", ":", "end", "]", ".", "toarray", "(", ")", "\n", "# condition may be None", "\n", "if", "use_condition", ":", "\n", "# c_batch = condition_shuf[start:(start+self.batch_size)]", "\n", "                    ", "c_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data_shuf", "]", "\n", "self", ".", "partial_fit", "(", "X_batch", ",", "condition_data", "=", "c_batch", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "partial_fit", "(", "X_batch", ")", "\n", "\n", "", "", "if", "self", ".", "verbose", ":", "\n", "# Clean up after flushing batch loss printings", "\n", "                ", "print", "(", ")", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DenoisingAutoEncoder.predict": [[286, 315], ["aaerec.condition._check_conditions", "dae.DenoisingAutoEncoder.eval", "numpy.vstack", "dae.DenoisingAutoEncoder.conditions.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "range", "X[].toarray", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "dae.DenoisingAutoEncoder.enc", "dae.DenoisingAutoEncoder.dec", "X_reconstuction.data.cpu().numpy.data.cpu().numpy.data.cpu().numpy", "pred.append", "X_batch.cuda.cuda.cuda", "dae.DenoisingAutoEncoder.conditions.encode_impose", "X_reconstuction.data.cpu().numpy.data.cpu().numpy.data.cpu"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose"], ["", "def", "predict", "(", "self", ",", "X", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "self", ".", "eval", "(", ")", "# Deactivate dropout", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "eval", "(", ")", "\n", "", "pred", "=", "[", "]", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "start", "in", "range", "(", "0", ",", "X", ".", "shape", "[", "0", "]", ",", "self", ".", "batch_size", ")", ":", "\n", "# batched predictions, yet inclusive", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "X_batch", "=", "X", "[", "start", ":", "end", "]", ".", "toarray", "(", ")", "\n", "X_batch", "=", "torch", ".", "FloatTensor", "(", "X_batch", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                    ", "X_batch", "=", "X_batch", ".", "cuda", "(", ")", "\n", "", "X_batch", "=", "Variable", "(", "X_batch", ")", "\n", "\n", "if", "use_condition", ":", "\n", "                    ", "c_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data", "]", "\n", "\n", "", "z", "=", "self", ".", "enc", "(", "X_batch", ")", "\n", "if", "use_condition", ":", "\n", "                    ", "z", "=", "self", ".", "conditions", ".", "encode_impose", "(", "z", ",", "c_batch", ")", "\n", "# reconstruct", "\n", "", "X_reconstuction", "=", "self", ".", "dec", "(", "z", ")", "\n", "# shift", "\n", "X_reconstuction", "=", "X_reconstuction", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred", ".", "append", "(", "X_reconstuction", ")", "\n", "", "", "return", "np", ".", "vstack", "(", "pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DAERecommender.__init__": [[336, 345], ["aaerec.base.Recommender.__init__", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "conditions", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" tfidf_params get piped to either TfidfVectorizer or\n        EmbeddedVectorizer.  Remaining kwargs get passed to\n        AdversarialAutoencoder \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "verbose", "=", "kwargs", ".", "get", "(", "'verbose'", ",", "True", ")", "\n", "self", ".", "model_params", "=", "kwargs", "\n", "self", ".", "conditions", "=", "conditions", "\n", "self", ".", "dae", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DAERecommender.__str__": [[346, 353], ["str", "dae.DAERecommender.conditions.keys"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "desc", "=", "\"Denoising Autoencoder\"", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "desc", "+=", "\" conditioned on: \"", "+", "', '", ".", "join", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "", "desc", "+=", "'\\nDAE Params: '", "+", "str", "(", "self", ".", "model_params", ")", "\n", "\n", "return", "desc", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DAERecommender.train": [[354, 369], ["training_set.tocsr", "dae.DenoisingAutoEncoder", "print", "print", "print", "dae.DAERecommender.dae.fit", "training_set.get_attributes", "dae.DAERecommender.conditions.fit_transform", "dae.DAERecommender.conditions.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "train", "(", "self", ",", "training_set", ")", ":", "\n", "        ", "X", "=", "training_set", ".", "tocsr", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "condition_data_raw", "=", "training_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "condition_data", "=", "self", ".", "conditions", ".", "fit_transform", "(", "condition_data_raw", ")", "\n", "", "else", ":", "\n", "            ", "condition_data", "=", "None", "\n", "\n", "", "self", ".", "dae", "=", "DenoisingAutoEncoder", "(", "conditions", "=", "self", ".", "conditions", ",", "**", "self", ".", "model_params", ")", "\n", "\n", "print", "(", "self", ")", "\n", "print", "(", "self", ".", "dae", ")", "\n", "print", "(", "self", ".", "conditions", ")", "\n", "\n", "self", ".", "dae", ".", "fit", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.DAERecommender.predict": [[370, 382], ["test_set.tocsr", "dae.DAERecommender.dae.predict", "test_set.get_attributes", "dae.DAERecommender.conditions.transform", "dae.DAERecommender.conditions.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.predict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "predict", "(", "self", ",", "test_set", ")", ":", "\n", "        ", "X", "=", "test_set", ".", "tocsr", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "condition_data_raw", "=", "test_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "# Important to not call fit here, but just transform", "\n", "condition_data", "=", "self", ".", "conditions", ".", "transform", "(", "condition_data_raw", ")", "\n", "", "else", ":", "\n", "            ", "condition_data", "=", "None", "\n", "\n", "", "pred", "=", "self", ".", "dae", ".", "predict", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.log_losses": [[36, 38], ["print", "STATUS_FORMAT.format"], "function", ["None"], ["def", "log_losses", "(", "*", "losses", ")", ":", "\n", "    ", "print", "(", "'\\r'", "+", "STATUS_FORMAT", ".", "format", "(", "*", "losses", ")", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.gauss_noise": [[40, 46], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "noise.cuda.cuda", "batch.size"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "gauss_noise", "(", "batch", ",", "noise_factor", ")", ":", "\n", "    ", "'''Add gaussian noise to the input'''", "\n", "noise", "=", "torch", ".", "randn", "(", "batch", ".", "size", "(", ")", ")", "*", "noise_factor", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "noise", "=", "noise", ".", "cuda", "(", ")", "\n", "", "return", "(", "batch", "+", "noise", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.zeros_noise": [[48, 53], ["torch.rand", "torch.rand", "torch.rand", "torch.rand", "batch.size"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "zeros_noise", "(", "batch", ",", "noise_factor", ")", ":", "\n", "    ", "'''Randomly zeros some of the 1s with p=noise_factor'''", "\n", "mask", "=", "torch", ".", "rand", "(", "batch", ".", "size", "(", ")", ")", "<", "noise_factor", "\n", "batch", "[", "mask", "]", "=", "0", "\n", "return", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.dae.main": [[384, 433], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "aaerec.datasets.Bags.load_tabcomma_format", "aaerec.evaluation.Evaluation().setup", "gensim.models.keyedvectors.KeyedVectors.load_word2vec_format", "aaerec.condition.ConditionList", "Evaluation().setup.", "dae.DAERecommender", "aaerec.evaluation.Evaluation", "aaerec.condition.PretrainedWordEmbeddingCondition"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.load_tabcomma_format", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.setup"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\" Evaluates the DAE Recommender \"\"\"", "\n", "CONFIG", "=", "{", "\n", "'pub'", ":", "(", "'/data21/lgalke/datasets/citations_pmc.tsv'", ",", "2011", ",", "50", ")", ",", "\n", "'eco'", ":", "(", "'/data21/lgalke/datasets/econbiz62k.tsv'", ",", "2012", ",", "1", ")", "\n", "}", "\n", "\n", "PARSER", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "PARSER", ".", "add_argument", "(", "'data'", ",", "type", "=", "str", ",", "choices", "=", "[", "'pub'", ",", "'eco'", "]", ")", "\n", "args", "=", "PARSER", ".", "parse_args", "(", ")", "\n", "DATA", "=", "CONFIG", "[", "args", ".", "data", "]", "\n", "logfile", "=", "'/data22/ivagliano/test-vae/'", "+", "args", ".", "data", "+", "'-decoder.log'", "\n", "bags", "=", "Bags", ".", "load_tabcomma_format", "(", "DATA", "[", "0", "]", ")", "\n", "c_year", "=", "DATA", "[", "1", "]", "\n", "\n", "evaluate", "=", "Evaluation", "(", "bags", ",", "\n", "year", "=", "c_year", ",", "\n", "logfile", "=", "logfile", ")", ".", "setup", "(", "min_count", "=", "DATA", "[", "2", "]", ",", "\n", "min_elements", "=", "2", ")", "\n", "# print(\"Loading pre-trained embedding\", W2V_PATH)", "\n", "vectors", "=", "KeyedVectors", ".", "load_word2vec_format", "(", "W2V_PATH", ",", "binary", "=", "W2V_IS_BINARY", ")", "\n", "\n", "params", "=", "{", "\n", "'n_epochs'", ":", "100", ",", "\n", "'batch_size'", ":", "100", ",", "\n", "'optimizer'", ":", "'adam'", ",", "\n", "'normalize_inputs'", ":", "True", ",", "\n", "# 'prior': 'gauss',", "\n", "}", "\n", "# 100 hidden units, 200 epochs, bernoulli prior, normalized inputs -> 0.174", "\n", "activations", "=", "[", "'ReLU'", ",", "'SELU'", "]", "\n", "lrs", "=", "[", "(", "0.001", ",", "0.0005", ")", ",", "(", "0.001", ",", "0.001", ")", "]", "\n", "hcs", "=", "[", "(", "100", ",", "50", ")", ",", "(", "300", ",", "100", ")", "]", "\n", "\n", "CONDITIONS", "=", "ConditionList", "(", "[", "\n", "(", "'title'", ",", "PretrainedWordEmbeddingCondition", "(", "vectors", ")", ")", "\n", "]", ")", "\n", "\n", "# dropouts = [(.2,.2), (.1,.1), (.1, .2), (.25, .25), (.3,.3)] # .2,.2 is best", "\n", "# priors = ['categorical'] # gauss is best", "\n", "# normal = [True, False]", "\n", "# bernoulli was good, letz see if categorical is better... No", "\n", "# import itertools", "\n", "# models = [DAERecommender(**params,", "\n", "#                          use_title=ut, embedding=vectors)", "\n", "#           for ut in (True, False)]", "\n", "models", "=", "[", "DAERecommender", "(", "conditions", "=", "CONDITIONS", ",", "**", "params", ")", "]", "\n", "# models = [DecodingRecommender(embedding=vectors)]", "\n", "evaluate", "(", "models", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.__init__": [[67, 70], ["collections.OrderedDict.__init__", "all", "isinstance", "condition.ConditionList.values"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "items", ")", ":", "\n", "        ", "super", "(", "ConditionList", ",", "self", ")", ".", "__init__", "(", "items", ")", "\n", "assert", "all", "(", "isinstance", "(", "v", ",", "ConditionBase", ")", "for", "v", "in", "self", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.fit": [[71, 77], ["zip", "len", "len", "condition.ConditionList.values", "cond.fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit"], ["", "def", "fit", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "\"\"\" Fits all conditions to data \"\"\"", "\n", "assert", "len", "(", "raw_inputs", ")", "==", "len", "(", "self", ")", "\n", "for", "cond", ",", "cond_inp", "in", "zip", "(", "self", ".", "values", "(", ")", ",", "raw_inputs", ")", ":", "\n", "            ", "cond", ".", "fit", "(", "cond_inp", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.transform": [[78, 82], ["len", "len", "c.transform", "zip", "condition.ConditionList.values"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "\"\"\" Transforms `raw_inputs` with all conditions \"\"\"", "\n", "assert", "len", "(", "raw_inputs", ")", "==", "len", "(", "self", ")", "\n", "return", "[", "c", ".", "transform", "(", "inp", ")", "for", "c", ",", "inp", "in", "zip", "(", "self", ".", "values", "(", ")", ",", "raw_inputs", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.fit_transform": [[83, 89], ["len", "len", "cond.fit_transform", "zip", "condition.ConditionList.values"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "fit_transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "\"\"\" Forwards to fit_transform of all conditions,\n        returns list of transformed condition inputs\"\"\"", "\n", "assert", "len", "(", "raw_inputs", ")", "==", "len", "(", "self", ")", "\n", "return", "[", "cond", ".", "fit_transform", "(", "inp", ")", "for", "cond", ",", "inp", "\n", "in", "zip", "(", "self", ".", "values", "(", ")", ",", "raw_inputs", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.encode_impose": [[90, 100], ["zip", "len", "len", "condition.ConditionList.values", "condition.encode_impose"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose"], ["", "def", "encode_impose", "(", "self", ",", "x", ",", "condition_inputs", ",", "dim", "=", "None", ")", ":", "\n", "        ", "\"\"\" Subsequently conduct encode & impose with all conditions\n        in order.\n        : param x: the normal data not the condition ones\n        : param condition_inputs: the condition inputs (should be transformed before)\n        \"\"\"", "\n", "assert", "len", "(", "condition_inputs", ")", "==", "len", "(", "self", ")", "\n", "for", "condition", ",", "condition_input", "in", "zip", "(", "self", ".", "values", "(", ")", ",", "condition_inputs", ")", ":", "\n", "            ", "x", "=", "condition", ".", "encode_impose", "(", "x", ",", "condition_input", ",", "dim", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.encode": [[101, 105], ["len", "len", "condition.encode", "zip", "condition.ConditionList.values"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode"], ["", "def", "encode", "(", "self", ",", "condition_inputs", ")", ":", "\n", "        ", "assert", "len", "(", "condition_inputs", ")", "==", "len", "(", "self", ")", "\n", "return", "[", "condition", ".", "encode", "(", "condition_input", ")", "for", "condition", ",", "condition_input", "\n", "in", "zip", "(", "self", ".", "values", "(", ")", ",", "condition_inputs", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.zero_grad": [[107, 113], ["condition.ConditionList.values", "condition.zero_grad"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "\"\"\" Forward the zero_grad call to all conditions in list\n        such they can reset their gradients \"\"\"", "\n", "for", "condition", "in", "self", ".", "values", "(", ")", ":", "\n", "            ", "condition", ".", "zero_grad", "(", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.step": [[114, 120], ["condition.ConditionList.values", "condition.step"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step"], ["", "def", "step", "(", "self", ")", ":", "\n", "        ", "\"\"\" Forward the step call to all conditions in list,\n        such that these can update their individual parameters\"\"\"", "\n", "for", "condition", "in", "self", ".", "values", "(", ")", ":", "\n", "            ", "condition", ".", "step", "(", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.size_increment": [[121, 126], ["sum", "v.size_increment", "condition.ConditionList.values"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment"], ["", "def", "size_increment", "(", "self", ")", ":", "\n", "        ", "\"\"\" Aggregates sizes from various conditions\n        for convenience use in determining decoder properties\n        \"\"\"", "\n", "return", "sum", "(", "v", ".", "size_increment", "(", ")", "for", "v", "in", "self", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.train": [[127, 132], ["condition.ConditionList.values", "hasattr", "condition.train"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train"], ["", "def", "train", "(", "self", ")", ":", "\n", "# Put all modules into train mode, if they has such a method", "\n", "        ", "for", "condition", "in", "self", ".", "values", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "condition", ",", "'train'", ")", ":", "\n", "                ", "condition", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionList.eval": [[133, 138], ["condition.ConditionList.values", "hasattr", "condition.eval"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval"], ["", "", "", "def", "eval", "(", "self", ")", ":", "\n", "# Put all modules into train mode, if they have such a method", "\n", "        ", "for", "condition", "in", "self", ".", "values", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "condition", ",", "'eval'", ")", ":", "\n", "                ", "condition", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.fit": [[151, 156], ["None"], "methods", ["None"], ["def", "fit", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "\"\"\" Prepares the condition wrt to the whole raw data for the condition\n        To be called *once* on the whole (condition)-data.\n        \"\"\"", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.transform": [[157, 161], ["None"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "\"\"\" Returns transformed raw_inputs, can be applied globally as\n        preprocessing step \"\"\"", "\n", "return", "raw_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.fit_transform": [[162, 165], ["condition.ConditionBase.fit().transform", "condition.ConditionBase.fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit"], ["", "def", "fit_transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "\"\"\" Fit to `raw_inputs`, then transform `raw_inputs`. \"\"\"", "\n", "return", "self", ".", "fit", "(", "raw_inputs", ")", ".", "transform", "(", "raw_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.size_increment": [[168, 176], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "size_increment", "(", "self", ")", ":", "\n", "        ", "\"\"\" Returns the output dimension of the condition,\n        such that:\n        code.size(1) + condition.size_increment() = conditioned_code.size(1)\n        Note that for additive or multiplicative conditions,\n        size_increment should be zero.\n        \"\"\"", "\n", "#####################################################################", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode": [[180, 183], ["None"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\" Encodes the input for the condition \"\"\"", "\n", "return", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.impose": [[184, 190], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "impose", "(", "self", ",", "inputs", ",", "encoded_condition", ",", "dim", "=", "None", ")", ":", "\n", "        ", "\"\"\" Applies the condition, for instance by concatenation.\n        Could also use multiplicative or additive conditioning.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose": [[191, 195], ["condition.ConditionBase.impose", "condition.ConditionBase.encode"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode"], ["", "def", "encode_impose", "(", "self", ",", "inputs", ",", "condition_input", ",", "dim", "=", "None", ")", ":", "\n", "        ", "\"\"\" First encodes `condition_input`, then applies condition to `inputs`.\n        \"\"\"", "\n", "return", "self", ".", "impose", "(", "inputs", ",", "self", ".", "encode", "(", "condition_input", ")", ",", "dim", "=", "None", ")", "\n", "###########################################################################", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.zero_grad": [[199, 207], ["None"], "methods", ["None"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Clear out gradients.\n        Per default does nothing on step\n        (optional for subclasses to implement).\n        To be called before each batch.\n        \"\"\"", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.step": [[208, 216], ["None"], "methods", ["None"], ["", "def", "step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Update condition's associated parameters.\n        Per default does nothing on step (optional for subclasses to implement.\n\n        To be called after each batch.\n        \"\"\"", "\n", "return", "self", "\n", "################################################", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.train": [[220, 227], ["None"], "methods", ["None"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Put into training mode.\n        Per default does nothing.\n        To be called before training.\n        \"\"\"", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.eval": [[228, 235], ["None"], "methods", ["None"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Put into evaluation mode\n        Per default does nothing.\n        To be called before evaluation.\n        \"\"\"", "\n", "return", "self", "\n", "################################################", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.__subclasshook__": [[238, 256], ["all", "any", "any", "any", "any", "any", "any", "any", "any", "any", "any", "any"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "__subclasshook__", "(", "cls", ",", "C", ")", ":", "\n", "        ", "if", "cls", "is", "ConditionBase", ":", "\n", "# Check if abstract parts of interface are satisified", "\n", "            ", "mro", "=", "C", ".", "__mro__", "\n", "if", "all", "(", "[", "any", "(", "\"encode\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"impose\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"encode_impose\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"size_increment\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"fit\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"transform\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"fit_transform\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"zero_grad\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"step\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"train\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", ",", "\n", "any", "(", "\"eval\"", "in", "B", ".", "__dict__", "for", "B", "in", "mro", ")", "]", ")", ":", "\n", "                ", "return", "True", "\n", "", "", "return", "NotImplemented", "# Proceed with usual mechanisms", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CountCondition.__init__": [[259, 265], ["abc.ABC.__init__", "sklearn.feature_extraction.text.CountVectorizer"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "cv_params", ")", ":", "\n", "        ", "\"\"\" CV Params as in:\n        https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html\n        \"\"\"", "\n", "super", "(", "CountCondition", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cv", "=", "CountVectorizer", "(", "binary", "=", "True", ",", "**", "cv_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CountCondition.fit": [[266, 269], ["condition.CountCondition.cv.fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit"], ["", "def", "fit", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "self", ".", "cv", ".", "fit", "(", "raw_inputs", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CountCondition.transform": [[270, 272], ["condition.CountCondition.cv.transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "return", "self", ".", "cv", ".", "transform", "(", "raw_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CountCondition.fit_transform": [[273, 275], ["condition.CountCondition.cv.fit_transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "fit_transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "return", "self", ".", "cv", ".", "fit_transform", "(", "raw_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CountCondition.impose": [[276, 279], ["scipy.hstack"], "methods", ["None"], ["", "def", "impose", "(", "self", ",", "x", ",", "encoded_inputs", ",", "dim", "=", "None", ")", ":", "\n", "        ", "assert", "dim", "is", "None", ",", "\"dim not supported for scipy.sparse based imposing\"", "\n", "return", "sp", ".", "hstack", "(", "[", "x", ",", "encoded_inputs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CountCondition.size_increment": [[280, 282], ["len"], "methods", ["None"], ["", "def", "size_increment", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "cv", ".", "vocabulary_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConcatenationBasedConditioning.size_increment": [[308, 311], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "size_increment", "(", "self", ")", ":", "\n", "        ", "\"\"\" Subclasses need to specify size increment \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConcatenationBasedConditioning.impose": [[312, 317], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "impose", "(", "self", ",", "inputs", ",", "encoded_condition", ",", "dim", "=", "None", ")", ":", "\n", "        ", "\"\"\" Concat condition at specified dimension (default 1) \"\"\"", "\n", "if", "dim", "is", "None", ":", "\n", "            ", "dim", "=", "self", ".", "dim", "\n", "", "return", "torch", ".", "cat", "(", "[", "inputs", ",", "encoded_condition", "]", ",", "dim", "=", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionalBiasing.impose": [[323, 326], ["None"], "methods", ["None"], ["def", "impose", "(", "self", ",", "inputs", ",", "encoded_condition", ",", "dim", "=", "None", ")", ":", "\n", "        ", "\"\"\" Applies condition by addition \"\"\"", "\n", "return", "inputs", "+", "encoded_condition", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionalBiasing.size_increment": [[327, 330], ["None"], "methods", ["None"], ["", "def", "size_increment", "(", "self", ")", ":", "\n", "        ", "\"\"\" Biasing does not increase vector size \"\"\"", "\n", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionalScaling.impose": [[336, 339], ["None"], "methods", ["None"], ["def", "impose", "(", "self", ",", "inputs", ",", "encoded_condition", ",", "dim", "=", "None", ")", ":", "\n", "        ", "\"\"\" Applies condition by multiplication \"\"\"", "\n", "return", "inputs", "*", "encoded_condition", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionalScaling.size_increment": [[340, 343], ["None"], "methods", ["None"], ["", "def", "size_increment", "(", "self", ")", ":", "\n", "        ", "\"\"\" Scaling does not increase vector size \"\"\"", "\n", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.PretrainedWordEmbeddingCondition.__init__": [[348, 352], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "ub.GensimEmbeddedVectorizer", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "vectors", ",", "dim", "=", "1", ",", "use_cuda", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "**", "tfidf_params", ")", ":", "\n", "        ", "self", ".", "vect", "=", "GensimEmbeddedVectorizer", "(", "vectors", ",", "**", "tfidf_params", ")", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ")", "if", "use_cuda", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.PretrainedWordEmbeddingCondition.fit": [[353, 356], ["condition.PretrainedWordEmbeddingCondition.vect.fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit"], ["", "def", "fit", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "self", ".", "vect", ".", "fit", "(", "raw_inputs", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.PretrainedWordEmbeddingCondition.transform": [[357, 359], ["condition.PretrainedWordEmbeddingCondition.vect.transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "return", "self", ".", "vect", ".", "transform", "(", "raw_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.PretrainedWordEmbeddingCondition.fit_transform": [[360, 362], ["condition.PretrainedWordEmbeddingCondition.vect.fit_transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "fit_transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "return", "self", ".", "vect", ".", "fit_transform", "(", "raw_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.PretrainedWordEmbeddingCondition.encode": [[363, 366], ["torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "inputs", ")", ":", "\n", "# GensimEmbeddedVectorizer yields numpy array", "\n", "        ", "return", "torch", ".", "as_tensor", "(", "inputs", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.PretrainedWordEmbeddingCondition.size_increment": [[367, 370], ["None"], "methods", ["None"], ["", "def", "size_increment", "(", "self", ")", ":", "\n", "# Return embedding dimension", "\n", "        ", "return", "self", ".", "vect", ".", "embedding", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.EmbeddingBagCondition.__init__": [[375, 381], ["torch.EmbeddingBag", "torch.EmbeddingBag", "torch.EmbeddingBag", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "condition.EmbeddingBagCondition.embedding_bag.parameters"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_embeddings", ",", "embedding_dim", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "embedding_bag", "=", "nn", ".", "EmbeddingBag", "(", "num_embeddings", ",", "\n", "embedding_dim", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "embedding_bag", ".", "parameters", "(", ")", ")", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.EmbeddingBagCondition.encode": [[382, 384], ["condition.EmbeddingBagCondition.embedding_bag"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "return", "self", ".", "embedding_bag", "(", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.EmbeddingBagCondition.zero_grad": [[385, 387], ["condition.EmbeddingBagCondition.optimizer.zero_grad"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.EmbeddingBagCondition.step": [[388, 392], ["condition.EmbeddingBagCondition.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step"], ["", "def", "step", "(", "self", ")", ":", "\n", "# loss.backward() to be called before by client (such as in ae_step)", "\n", "# The condition object can update its own parameters wrt global loss", "\n", "        ", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.EmbeddingBagCondition.size_increment": [[393, 395], ["None"], "methods", ["None"], ["", "def", "size_increment", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "embedding_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CategoricalCondition.__init__": [[402, 440], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "embedding_dim", ",", "vocab_size", "=", "None", ",", "\n", "sparse", "=", "True", ",", "\n", "use_cuda", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\n", "embedding_on_gpu", "=", "False", ",", "\n", "lr", "=", "1e-3", ",", "\n", "reduce", "=", "None", ",", "\n", "**", "embedding_params", ")", ":", "\n", "        ", "\"\"\"\n        Arguments\n        ---------\n        - embedding_dim: int - Size of the embedding\n        - vocab_size: int - Vocabulary size limit (if given)\n        - ignore_oov: bool - If given, set oov embedding to zero\n        - lr: float - initial learning rate for Adam / SparseAdam\n        - sparse: bool - If given, use sparse embedding & optimizer\n        - reduce: None or str - if given, expect list-of-list like inputs\n                  and aggregate according to `reduce` in 'mean', 'sum', 'max'\n        \"\"\"", "\n", "# register this module's parameters with the optimizer", "\n", "self", ".", "vocab_size", "=", "vocab_size", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "self", ".", "vocab", "=", "None", "\n", "self", ".", "embedding", "=", "None", "\n", "self", ".", "optimizer", "=", "None", "\n", "self", ".", "lr", "=", "lr", "\n", "\n", "# Optimization and memory storay", "\n", "self", ".", "sparse", "=", "sparse", "\n", "self", ".", "use_cuda", "=", "use_cuda", "\n", "self", ".", "embedding_on_gpu", "=", "embedding_on_gpu", "\n", "\n", "# We take care of vocab handling & padding ourselves", "\n", "assert", "\"padding_idx\"", "not", "in", "embedding_params", ",", "\"Padding is fixed with token 0\"", "\n", "self", ".", "embedding_params", "=", "embedding_params", "\n", "\n", "\n", "assert", "reduce", "is", "None", "or", "reduce", "in", "[", "'mean'", ",", "'sum'", ",", "'max'", "]", ",", "\"Reduce neither None nor in 'mean','sum','max'\"", "\n", "self", ".", "reduce", "=", "reduce", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CategoricalCondition.fit": [[441, 473], ["print", "collections.Counter().most_common", "torch.Embedding", "torch.Embedding", "torch.Embedding", "print", "list", "len", "isinstance", "len", "condition.CategoricalCondition.embedding.cuda", "torch.optim.SparseAdam", "torch.optim.SparseAdam", "torch.optim.SparseAdam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "itertools.chain.from_iterable", "int", "int", "collections.Counter", "enumerate", "condition.CategoricalCondition.embedding.parameters", "condition.CategoricalCondition.embedding.parameters", "len", "len"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "\"\"\" Learn a vocabulary \"\"\"", "\n", "flat_items", "=", "raw_inputs", "if", "self", ".", "reduce", "is", "None", "else", "list", "(", "it", ".", "chain", ".", "from_iterable", "(", "raw_inputs", ")", ")", "\n", "if", "self", ".", "vocab_size", "is", "None", ":", "\n", "# if vocab size is None, use all items", "\n", "            ", "cutoff", "=", "len", "(", "flat_items", ")", "\n", "", "elif", "isinstance", "(", "self", ".", "vocab_size", ",", "float", ")", ":", "\n", "# if vocab size is float, interprete it as percentage of top items (authors)", "\n", "            ", "cutoff", "=", "int", "(", "self", ".", "vocab_size", "*", "len", "(", "flat_items", ")", ")", "\n", "", "else", ":", "\n", "# else use fixed vocab size or None, which is fine aswell", "\n", "            ", "cutoff", "=", "int", "(", "self", ".", "vocab_size", ")", "\n", "", "print", "(", "\"Using top {:.2f}% authors ({})\"", ".", "format", "(", "cutoff", "/", "len", "(", "flat_items", ")", "*", "100", ",", "cutoff", ")", ")", "\n", "\n", "item_cnt", "=", "Counter", "(", "flat_items", ")", ".", "most_common", "(", "cutoff", ")", "\n", "# index 0 is reserved for unk idx", "\n", "self", ".", "vocab", "=", "{", "value", ":", "idx", "+", "1", "for", "idx", ",", "(", "value", ",", "__", ")", "in", "enumerate", "(", "item_cnt", ")", "}", "\n", "num_embeddings", "=", "len", "(", "self", ".", "vocab", ")", "+", "1", "\n", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "num_embeddings", ",", "\n", "self", ".", "embedding_dim", ",", "\n", "padding_idx", "=", "self", ".", "padding_idx", ",", "\n", "**", "self", ".", "embedding_params", ",", "\n", "sparse", "=", "self", ".", "sparse", ")", "\n", "if", "self", ".", "use_cuda", "and", "self", ".", "embedding_on_gpu", ":", "\n", "# Put the embedding on GPU only when wanted", "\n", "            ", "self", ".", "embedding", "=", "self", ".", "embedding", ".", "cuda", "(", ")", "\n", "", "print", "(", "\"Embedding before creating optimizer:\"", ",", "self", ".", "embedding", ",", "sep", "=", "'\\n'", ")", "\n", "if", "self", ".", "sparse", ":", "\n", "            ", "self", ".", "optimizer", "=", "optim", ".", "SparseAdam", "(", "self", ".", "embedding", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "embedding", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CategoricalCondition.transform": [[474, 481], ["condition.CategoricalCondition.vocab.get", "condition.CategoricalCondition.vocab.get"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "# Actually np.array is not needed,", "\n", "# else we would need to do the padding globally", "\n", "        ", "if", "self", ".", "reduce", "is", "None", ":", "\n", "            ", "return", "[", "self", ".", "vocab", ".", "get", "(", "x", ",", "self", ".", "padding_idx", ")", "for", "x", "in", "raw_inputs", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "[", "self", ".", "vocab", ".", "get", "(", "x", ",", "self", ".", "padding_idx", ")", "for", "x", "in", "l", "]", "for", "l", "in", "raw_inputs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CategoricalCondition._pad_batch": [[482, 485], ["max", "len", "len"], "methods", ["None"], ["", "", "def", "_pad_batch", "(", "self", ",", "batch_inputs", ")", ":", "\n", "        ", "maxlen", "=", "max", "(", "len", "(", "l", ")", "for", "l", "in", "batch_inputs", ")", "\n", "return", "[", "l", "+", "[", "self", ".", "padding_idx", "]", "*", "(", "maxlen", "-", "len", "(", "l", ")", ")", "for", "l", "in", "batch_inputs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CategoricalCondition.encode": [[486, 498], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "condition.CategoricalCondition.embedding", "condition.CategoricalCondition._pad_batch", "h.cuda.cuda.cuda", "getattr"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CategoricalCondition._pad_batch"], ["", "def", "encode", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "self", ".", "reduce", "is", "not", "None", ":", "\n", "# inputs may have variable lengths, pad them", "\n", "            ", "inputs", "=", "self", ".", "_pad_batch", "(", "inputs", ")", "\n", "", "inputs", "=", "torch", ".", "tensor", "(", "inputs", ",", "device", "=", "self", ".", "embedding", ".", "weight", ".", "device", ")", "\n", "h", "=", "self", ".", "embedding", "(", "inputs", ")", "\n", "if", "self", ".", "reduce", "is", "not", "None", ":", "\n", "# self.reduce in ['mean','sum','max']", "\n", "            ", "h", "=", "getattr", "(", "h", ",", "self", ".", "reduce", ")", "(", "1", ")", "\n", "", "if", "self", ".", "use_cuda", ":", "\n", "            ", "h", "=", "h", ".", "cuda", "(", ")", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CategoricalCondition.zero_grad": [[499, 501], ["condition.CategoricalCondition.optimizer.zero_grad"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CategoricalCondition.step": [[502, 506], ["condition.CategoricalCondition.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step"], ["", "def", "step", "(", "self", ")", ":", "\n", "# loss.backward() to be called before by client (such as in ae_step)", "\n", "# The condition object can update its own parameters wrt global loss", "\n", "        ", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.CategoricalCondition.size_increment": [[507, 509], ["None"], "methods", ["None"], ["", "def", "size_increment", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "embedding_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.__init__": [[529, 554], ["callable", "hasattr", "hasattr", "hasattr", "hasattr", "hasattr"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "preprocessor", "=", "None", ",", "encoder", "=", "None", ",", "optimizer", "=", "None", ",", "\n", "mode", "=", "\"concat\"", ",", "size_increment", "=", "0", ",", "dim", "=", "1", ")", ":", "\n", "        ", "if", "encoder", "is", "not", "None", ":", "\n", "            ", "assert", "callable", "(", "encoder", ")", "\n", "", "assert", "mode", "in", "[", "\"concat\"", ",", "\"bias\"", ",", "\"scale\"", "]", "\n", "if", "mode", "==", "\"concat\"", ":", "\n", "            ", "assert", "size_increment", ">", "0", ",", "\"Specify size increment in concat mode\"", "\n", "", "else", ":", "\n", "            ", "assert", "size_increment", "==", "0", ",", "\"Size increment should be zero in bias or scale modes\"", "\n", "", "if", "preprocessor", "is", "not", "None", ":", "\n", "            ", "assert", "hasattr", "(", "preprocessor", ",", "'fit'", ")", ",", "\"Preprocessor has no fit method\"", "\n", "assert", "hasattr", "(", "preprocessor", ",", "'transform'", ")", ",", "\"Preprocessor has no transform method\"", "\n", "assert", "hasattr", "(", "preprocessor", ",", "'fit_transform'", ")", ",", "\"Preprocessor has no fit_transform method\"", "\n", "", "if", "optimizer", "is", "not", "None", ":", "\n", "            ", "assert", "hasattr", "(", "optimizer", ",", "'zero_grad'", ")", "\n", "assert", "hasattr", "(", "optimizer", ",", "'step'", ")", "\n", "", "self", ".", "preprocessor", "=", "preprocessor", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "mode_", "=", "mode", "\n", "self", ".", "dim", "=", "dim", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.fit": [[555, 559], ["condition.Condition.preprocessor.fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit"], ["", "def", "fit", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "if", "self", ".", "preprocessor", "is", "not", "None", ":", "\n", "            ", "self", ".", "preprocessor", ".", "fit", "(", "raw_inputs", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.transform": [[560, 564], ["condition.Condition.preprocessor.transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "if", "self", ".", "preprocessor", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "preprocessor", ".", "transform", "(", "raw_inputs", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.fit_transform": [[565, 569], ["condition.Condition.preprocessor.fit_transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "fit_transform", "(", "self", ",", "raw_inputs", ")", ":", "\n", "        ", "if", "self", ".", "preprocessor", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "preprocessor", ".", "fit_transform", "(", "raw_inputs", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode": [[570, 574], ["condition.Condition.encoder"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "if", "self", ".", "encoder", "is", "not", "None", ":", "\n", "            ", "return", "self", ".", "encoder", "(", "inputs", ")", "\n", "", "return", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.impose": [[575, 585], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "ValueError"], "methods", ["None"], ["", "def", "impose", "(", "self", ",", "inputs", ",", "encoded_condition", ",", "dim", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "mode_", "==", "\"concat\"", ":", "\n", "            ", "out", "=", "torch", ".", "cat", "(", "[", "inputs", ",", "encoded_condition", "]", ",", "dim", "=", "self", ".", "dim", ")", "\n", "", "elif", "self", ".", "mode_", "==", "\"bias\"", ":", "\n", "            ", "out", "=", "inputs", "+", "encoded_condition", "\n", "", "elif", "self", ".", "mode_", "==", "\"scale\"", ":", "\n", "            ", "out", "=", "inputs", "*", "encoded_condition", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown mode: \"", "+", "self", ".", "mode_", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment": [[586, 588], ["None"], "methods", ["None"], ["", "def", "size_increment", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size_increment", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.zero_grad": [[589, 592], ["condition.Condition.optimizer.zero_grad"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "optimizer", "is", "not", "None", ":", "\n", "            ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step": [[593, 596], ["condition.Condition.optimizer.step"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step"], ["", "", "def", "step", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "optimizer", "is", "not", "None", ":", "\n", "            ", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.train": [[597, 600], ["condition.Condition.encoder.train"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train"], ["", "", "def", "train", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "encoder", "is", "not", "None", ":", "\n", "            ", "self", ".", "encoder", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.eval": [[601, 604], ["condition.Condition.encoder.eval"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval"], ["", "", "def", "eval", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "encoder", "is", "not", "None", ":", "\n", "            ", "self", ".", "encoder", ".", "eval", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions": [[31, 58], ["isinstance", "len", "len"], "function", ["None"], ["def", "_check_conditions", "(", "conditions", ",", "condition_data", ")", ":", "\n", "    ", "\"\"\" Checks condition list and condition data for validity.\n    Arguments\n    =========\n    conditions: a condition list instance\n    condition_data: condition data that should correspond to conditions\n\n    Returns\n    =======\n    use_condition:\n        - True if conditions are present and condition_data matches,\n        - False if neither conditions nor condition_data is supplied.\n\n    Raises\n    ======\n    AssertionError, when `conditions` does not match with `condition_data`\n\n    \"\"\"", "\n", "if", "not", "conditions", "and", "not", "condition_data", ":", "\n", "# Neither supplied, do not use conditions", "\n", "        ", "return", "False", "\n", "\n", "", "assert", "isinstance", "(", "conditions", ",", "ConditionList", ")", ",", "\"`conditions` no instance of ConditionList\"", "\n", "assert", "condition_data", "and", "conditions", ",", "\"Mismatch between condition spec and supplied condition data.\"", "\n", "assert", "len", "(", "condition_data", ")", "==", "len", "(", "conditions", ")", ",", "\"Unexpected number of supplied condition data\"", "\n", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.Encoder.__init__": [[106, 129], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "getattr", "getattr", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "ValueError"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "n_input", ",", "n_hidden", ",", "n_code", ",", "final_activation", "=", "None", ",", "\n", "normalize_inputs", "=", "True", ",", "dropout", "=", "(", ".2", ",", ".2", ")", ",", "activation", "=", "'ReLU'", ")", ":", "\n", "        ", "super", "(", "Encoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "n_input", ",", "n_hidden", ")", "\n", "self", ".", "act1", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_hidden", ")", "\n", "self", ".", "act2", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "if", "activation", "==", "'SELU'", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "Dropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "Dropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "self", ".", "lin3", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_code", ")", "\n", "self", ".", "normalize_inputs", "=", "normalize_inputs", "\n", "if", "final_activation", "==", "'linear'", "or", "final_activation", "is", "None", ":", "\n", "            ", "self", ".", "final_activation", "=", "None", "\n", "", "elif", "final_activation", "==", "'softmax'", ":", "\n", "            ", "self", ".", "final_activation", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "", "elif", "final_activation", "==", "'sigmoid'", ":", "\n", "            ", "self", ".", "final_activation", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Final activation unknown:\"", ",", "activation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.Encoder.forward": [[130, 147], ["aae.Encoder.lin1", "aae.Encoder.drop1", "aae.Encoder.act1", "aae.Encoder.lin2", "aae.Encoder.drop2", "aae.Encoder.act2", "aae.Encoder.lin3", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "aae.Encoder.final_activation"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\" Forward method implementation of 3-layer encoder \"\"\"", "\n", "if", "self", ".", "normalize_inputs", ":", "\n", "            ", "inp", "=", "F", ".", "normalize", "(", "inp", ",", "1", ")", "\n", "# first layer", "\n", "", "act", "=", "self", ".", "lin1", "(", "inp", ")", "\n", "act", "=", "self", ".", "drop1", "(", "act", ")", "\n", "act", "=", "self", ".", "act1", "(", "act", ")", "\n", "# second layer", "\n", "act", "=", "self", ".", "lin2", "(", "act", ")", "\n", "act", "=", "self", ".", "drop2", "(", "act", ")", "\n", "act", "=", "self", ".", "act2", "(", "act", ")", "\n", "# third layer", "\n", "act", "=", "self", ".", "lin3", "(", "act", ")", "\n", "if", "self", ".", "final_activation", ":", "\n", "            ", "act", "=", "self", ".", "final_activation", "(", "act", ")", "\n", "", "return", "act", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.Decoder.__init__": [[151, 164], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "n_code", ",", "n_hidden", ",", "n_output", ",", "dropout", "=", "(", ".2", ",", ".2", ")", ",", "activation", "=", "'ReLU'", ")", ":", "\n", "        ", "super", "(", "Decoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "n_code", ",", "n_hidden", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_hidden", ")", "\n", "self", ".", "lin3", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "if", "activation", "==", "'SELU'", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "Dropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "Dropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "self", ".", "act1", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "self", ".", "act2", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.Decoder.forward": [[165, 179], ["aae.Decoder.lin1", "aae.Decoder.drop1", "aae.Decoder.act1", "aae.Decoder.lin2", "aae.Decoder.drop2", "aae.Decoder.act2", "aae.Decoder.lin3", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\" Forward implementation of 3-layer decoder \"\"\"", "\n", "# first layer", "\n", "act", "=", "self", ".", "lin1", "(", "inp", ")", "\n", "act", "=", "self", ".", "drop1", "(", "act", ")", "\n", "act", "=", "self", ".", "act1", "(", "act", ")", "\n", "# second layer", "\n", "act", "=", "self", ".", "lin2", "(", "act", ")", "\n", "act", "=", "self", ".", "drop2", "(", "act", ")", "\n", "act", "=", "self", ".", "act2", "(", "act", ")", "\n", "# final layer", "\n", "act", "=", "self", ".", "lin3", "(", "act", ")", "\n", "act", "=", "torch", ".", "sigmoid", "(", "act", ")", "\n", "return", "act", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.Discriminator.__init__": [[183, 196], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.AlphaDropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "n_code", ",", "n_hidden", ",", "dropout", "=", "(", ".2", ",", ".2", ")", ",", "activation", "=", "'ReLU'", ")", ":", "\n", "        ", "super", "(", "Discriminator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "n_code", ",", "n_hidden", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_hidden", ")", "\n", "self", ".", "lin3", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "1", ")", "\n", "if", "activation", "==", "'SELU'", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "AlphaDropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "drop1", "=", "nn", ".", "Dropout", "(", "dropout", "[", "0", "]", ")", "\n", "self", ".", "drop2", "=", "nn", ".", "Dropout", "(", "dropout", "[", "1", "]", ")", "\n", "", "self", ".", "act1", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "self", ".", "act2", "=", "getattr", "(", "nn", ",", "activation", ")", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.Discriminator.forward": [[197, 214], ["aae.Discriminator.lin1", "aae.Discriminator.drop1", "aae.Discriminator.act1", "aae.Discriminator.lin2", "aae.Discriminator.drop2", "aae.Discriminator.act2", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "aae.Discriminator.lin3"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\" Forward of 3-layer discriminator \"\"\"", "\n", "act", "=", "self", ".", "lin1", "(", "inp", ")", "\n", "act", "=", "self", ".", "drop1", "(", "act", ")", "\n", "act", "=", "self", ".", "act1", "(", "act", ")", "\n", "\n", "act", "=", "self", ".", "lin2", "(", "act", ")", "\n", "act", "=", "self", ".", "drop2", "(", "act", ")", "\n", "act", "=", "self", ".", "act2", "(", "act", ")", "\n", "\n", "\n", "\n", "# act = F.dropout(self.lin1(inp), p=self.dropout[0], training=self.training)", "\n", "# act = F.relu(act)", "\n", "# act = F.dropout(self.lin2(act), p=self.dropout[1], training=self.training)", "\n", "# act = F.relu(act)", "\n", "return", "torch", ".", "sigmoid", "(", "self", ".", "lin3", "(", "act", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AutoEncoder.__init__": [[223, 249], ["optimizer.lower"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_hidden", "=", "100", ",", "\n", "n_code", "=", "50", ",", "\n", "lr", "=", "0.001", ",", "\n", "batch_size", "=", "100", ",", "\n", "n_epochs", "=", "500", ",", "\n", "optimizer", "=", "'adam'", ",", "\n", "normalize_inputs", "=", "True", ",", "\n", "activation", "=", "'ReLU'", ",", "\n", "dropout", "=", "(", ".2", ",", ".2", ")", ",", "\n", "conditions", "=", "None", ",", "\n", "verbose", "=", "True", ")", ":", "\n", "\n", "        ", "self", ".", "enc", ",", "self", ".", "dec", "=", "None", ",", "None", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "n_code", "=", "n_code", "\n", "self", ".", "n_epochs", "=", "n_epochs", "\n", "self", ".", "optimizer", "=", "optimizer", ".", "lower", "(", ")", "\n", "self", ".", "normalize_inputs", "=", "normalize_inputs", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "self", ".", "conditions", "=", "conditions", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AutoEncoder.eval": [[250, 257], ["aae.AutoEncoder.enc.eval", "aae.AutoEncoder.dec.eval", "aae.AutoEncoder.conditions.eval"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "\"\"\" Put all NN modules into eval mode \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "self", ".", "enc", ".", "eval", "(", ")", "\n", "self", ".", "dec", ".", "eval", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AutoEncoder.train": [[258, 265], ["aae.AutoEncoder.enc.train", "aae.AutoEncoder.dec.train", "aae.AutoEncoder.conditions.train"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train"], ["", "", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\" Put all NN modules into train mode \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "self", ".", "enc", ".", "train", "(", ")", "\n", "self", ".", "dec", ".", "train", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AutoEncoder.ae_step": [[267, 307], ["aae.AutoEncoder.enc", "condition._check_conditions", "aae.AutoEncoder.dec", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "aae.AutoEncoder.enc_optim.zero_grad", "aae.AutoEncoder.dec_optim.zero_grad", "torch.binary_cross_entropy.backward", "aae.AutoEncoder.enc_optim.step", "aae.AutoEncoder.dec_optim.step", "torch.binary_cross_entropy.item", "aae.AutoEncoder.conditions.encode_impose", "aae.AutoEncoder.conditions.zero_grad", "aae.AutoEncoder.conditions.step", "batch.view", "batch.size", "batch.size"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "", "def", "ae_step", "(", "self", ",", "batch", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Perform one autoencoder training step\n            :param batch: np.array, the base data from Bag class\n            :param condition: condition_matrix: np.array, feature space of side_info\n            :return: binary_cross_entropy for this step\n            \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "\n", "# why is this double to AdversarialAutoEncoder? Lukas: it's likely the two models will diverge", "\n", "# what is relationship to train in DecodingRecommender? Train only uses Condition. Those are implementet seperately", "\n", "# assert_condition_callabilities(condition_matrix)", "\n", "z_sample", "=", "self", ".", "enc", "(", "batch", ")", "\n", "\n", "# condition_matrix is already a matrix and doesn't need to be concatenated again", "\n", "# TODO: think/ask: where is it better to do concat? Here or when first  setted up for training", "\n", "# IMO: when setting up for training, because it's the used downstream all the same", "\n", "\n", "# concat base data with side_info", "\n", "# z_sample = torch.cat((z_sample, condition_matrix), 1)", "\n", "\n", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "if", "use_condition", ":", "\n", "            ", "z_sample", "=", "self", ".", "conditions", ".", "encode_impose", "(", "z_sample", ",", "condition_data", ")", "\n", "\n", "", "x_sample", "=", "self", ".", "dec", "(", "z_sample", ")", "\n", "recon_loss", "=", "F", ".", "binary_cross_entropy", "(", "x_sample", "+", "TINY", ",", "\n", "batch", ".", "view", "(", "batch", ".", "size", "(", "0", ")", ",", "\n", "batch", ".", "size", "(", "1", ")", ")", "+", "TINY", ")", "\n", "self", ".", "enc_optim", ".", "zero_grad", "(", ")", "\n", "self", ".", "dec_optim", ".", "zero_grad", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "zero_grad", "(", ")", "\n", "", "recon_loss", ".", "backward", "(", ")", "\n", "self", ".", "enc_optim", ".", "step", "(", ")", "\n", "self", ".", "dec_optim", ".", "step", "(", ")", "\n", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "step", "(", ")", "\n", "", "return", "recon_loss", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AutoEncoder.partial_fit": [[308, 345], ["condition._check_conditions", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "aae.AutoEncoder.train", "aae.AutoEncoder.ae_step", "ValueError", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "X.cuda.cuda.cuda", "wandb.log", "aae.log_losses"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.ae_step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.log_losses"], ["", "def", "partial_fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "condition_data", "=", "None", ",", "step", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n            Performs reconstrction, discimination, generator training steps\n        :param X: np.array, the base data from Bag class\n        :param y: dummy variable, throws Error if used\n        :param condition_matrix: np.array, feature space of side_info\n        :return:\n        \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"(Semi-)supervised usage not supported\"", ")", "\n", "# Transform to Torch (Cuda) Variable, shift batch to GPU", "\n", "", "X", "=", "Variable", "(", "torch", ".", "FloatTensor", "(", "X", ")", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "X", "=", "X", ".", "cuda", "(", ")", "\n", "\n", "# if condition_matrix is not None:", "\n", "#     condition_matrix = condition_matrix.astype('float32')", "\n", "#     if sp.issparse(condition_matrix):", "\n", "#         condition_matrix = condition_matrix.toarray()", "\n", "#     condition_matrix = Variable(torch.from_numpy(condition_matrix))", "\n", "#     if torch.cuda.is_available():", "\n", "#         condition_matrix = condition_matrix.cuda()", "\n", "\n", "# Make sure we are in training mode and zero leftover gradients", "\n", "", "self", ".", "train", "(", ")", "\n", "# One step each, could balance", "\n", "recon_loss", "=", "self", ".", "ae_step", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "if", "USE_WANDB", ":", "\n", "            ", "assert", "step", "is", "not", "None", "\n", "wandb", ".", "log", "(", "{", "\"step\"", ":", "step", ",", "\"loss\"", ":", "recon_loss", "}", ")", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "log_losses", "(", "recon_loss", ",", "0", ",", "0", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AutoEncoder.fit": [[346, 422], ["condition._check_conditions", "aae.Encoder", "aae.Decoder", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "optimizer_gen", "optimizer_gen", "range", "NotImplementedError", "print", "print", "aae.AutoEncoder.enc.cuda", "aae.AutoEncoder.dec.cuda", "aae.AutoEncoder.enc.parameters", "aae.AutoEncoder.dec.parameters", "range", "aae.AutoEncoder.conditions.size_increment", "print", "sklearn.utils.shuffle", "sklearn.utils.shuffle", "X_shuf[].toarray", "print", "aae.AutoEncoder.partial_fit", "aae.AutoEncoder.partial_fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param X: np.array, the base data from Bag class\n        :param y: dummy variable, throws Error if used\n        :param condition_matrix: np.array, feature space of side_info\n        :return:\n        \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "# TODO: check how X representation and numpy.array work together", "\n", "# TODO: adapt combining X and new_conditions_name", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"(Semi-)supervised usage not supported\"", ")", "\n", "\n", "", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "if", "use_condition", ":", "\n", "            ", "code_size", "=", "self", ".", "n_code", "+", "self", ".", "conditions", ".", "size_increment", "(", ")", "\n", "print", "(", "\"[ae] Using condition, code size:\"", ",", "code_size", ")", "\n", "", "else", ":", "\n", "            ", "code_size", "=", "self", ".", "n_code", "\n", "print", "(", "\"[ae] Not using condition, code size:\"", ",", "code_size", ")", "\n", "\n", "", "self", ".", "enc", "=", "Encoder", "(", "X", ".", "shape", "[", "1", "]", ",", "self", ".", "n_hidden", ",", "self", ".", "n_code", ",", "\n", "final_activation", "=", "'linear'", ",", "\n", "normalize_inputs", "=", "self", ".", "normalize_inputs", ",", "\n", "dropout", "=", "self", ".", "dropout", ",", "activation", "=", "self", ".", "activation", ")", "\n", "# if condition_matrix is not None:", "\n", "#     # seems to be not enough TODO: check what is done in decoder so that dims fit", "\n", "#     # TODO: find out why dims are arbitrary", "\n", "#     # [100 x 381], m2: [1616 x 100] vs [100 x 376], m2: [1628 x 100]", "\n", "#     assert condition_matrix.shape[0] == X.shape[0]", "\n", "#     print(\"condition_matrix shape: \",condition_matrix.shape,\"X.shape\", X.shape)", "\n", "#     # (3600, 1567) (3600, 88323), (3600, 1566) (3600, 87305),  (3600, 1575) (3600, 86911)", "\n", "#     # data set is stable: total: 4000 records with 269755 ratings", "\n", "#     # on master branch there are values in all [ R: 0.6524 | D: 1.3585 | G: 0.7273 ]", "\n", "#     # shape[1] is the length of feature space --> this prob gives how many dims for Decoder", "\n", "self", ".", "dec", "=", "Decoder", "(", "code_size", ",", "self", ".", "n_hidden", ",", "\n", "X", ".", "shape", "[", "1", "]", ",", "dropout", "=", "self", ".", "dropout", ",", "activation", "=", "self", ".", "activation", ")", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "enc", "=", "self", ".", "enc", ".", "cuda", "(", ")", "\n", "self", ".", "dec", "=", "self", ".", "dec", ".", "cuda", "(", ")", "\n", "", "optimizer_gen", "=", "TORCH_OPTIMIZERS", "[", "self", ".", "optimizer", "]", "\n", "# Reconstruction", "\n", "self", ".", "enc_optim", "=", "optimizer_gen", "(", "self", ".", "enc", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "self", ".", "dec_optim", "=", "optimizer_gen", "(", "self", ".", "dec", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "\n", "# do the actual training", "\n", "step", "=", "0", "\n", "for", "epoch", "in", "range", "(", "self", ".", "n_epochs", ")", ":", "\n", "            ", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "\"Epoch\"", ",", "epoch", "+", "1", ")", "\n", "\n", "", "if", "use_condition", ":", "\n", "# shuffle(*arrays) takes several arrays and shuffles them so indices are still matching", "\n", "                ", "X_shuf", ",", "*", "condition_data_shuf", "=", "sklearn", ".", "utils", ".", "shuffle", "(", "X", ",", "*", "condition_data", ")", "\n", "", "else", ":", "\n", "                ", "X_shuf", "=", "sklearn", ".", "utils", ".", "shuffle", "(", "X", ")", "\n", "\n", "\n", "", "for", "start", "in", "range", "(", "0", ",", "X", ".", "shape", "[", "0", "]", ",", "self", ".", "batch_size", ")", ":", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "X_batch", "=", "X_shuf", "[", "start", ":", "end", "]", ".", "toarray", "(", ")", "\n", "# condition may be None", "\n", "if", "use_condition", ":", "\n", "# c_batch = condition_shuf[start:(start+self.batch_size)]", "\n", "                    ", "c_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data_shuf", "]", "\n", "self", ".", "partial_fit", "(", "X_batch", ",", "condition_data", "=", "c_batch", ",", "step", "=", "step", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "partial_fit", "(", "X_batch", ",", "step", "=", "step", ")", "\n", "", "step", "+=", "1", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "# Clean up after flushing batch loss printings", "\n", "                ", "print", "(", ")", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AutoEncoder.predict": [[423, 459], ["condition._check_conditions", "aae.AutoEncoder.eval", "numpy.vstack", "aae.AutoEncoder.conditions.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "range", "X[].toarray", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "aae.AutoEncoder.enc", "aae.AutoEncoder.dec", "X_reconstuction.data.cpu().numpy.data.cpu().numpy.data.cpu().numpy", "pred.append", "X_batch.cuda.cuda.cuda", "aae.AutoEncoder.conditions.encode_impose", "X_reconstuction.data.cpu().numpy.data.cpu().numpy.data.cpu"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose"], ["", "def", "predict", "(", "self", ",", "X", ",", "condition_data", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n\n        :param X: np.array, the base data from Bag class\n        :param condition_matrix: np.array, feature space of side_info\n        :return:\n        \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "# TODO: first look into fit, as predict is based on that!!!", "\n", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "self", ".", "eval", "(", ")", "# Deactivate dropout", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "eval", "(", ")", "\n", "", "pred", "=", "[", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "start", "in", "range", "(", "0", ",", "X", ".", "shape", "[", "0", "]", ",", "self", ".", "batch_size", ")", ":", "\n", "# batched predictions, yet inclusive", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "X_batch", "=", "X", "[", "start", ":", "end", "]", ".", "toarray", "(", ")", "\n", "X_batch", "=", "torch", ".", "FloatTensor", "(", "X_batch", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                    ", "X_batch", "=", "X_batch", ".", "cuda", "(", ")", "\n", "", "X_batch", "=", "Variable", "(", "X_batch", ")", "\n", "\n", "if", "use_condition", ":", "\n", "                    ", "c_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data", "]", "\n", "\n", "", "z", "=", "self", ".", "enc", "(", "X_batch", ")", "\n", "if", "use_condition", ":", "\n", "                    ", "z", "=", "self", ".", "conditions", ".", "encode_impose", "(", "z", ",", "c_batch", ")", "\n", "# reconstruct", "\n", "", "X_reconstuction", "=", "self", ".", "dec", "(", "z", ")", "\n", "# shift", "\n", "X_reconstuction", "=", "X_reconstuction", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred", ".", "append", "(", "X_reconstuction", ")", "\n", "", "", "return", "np", ".", "vstack", "(", "pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.DecodingRecommender.__init__": [[464, 478], ["optimizer.lower", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "conditions", ",", "n_epochs", "=", "100", ",", "batch_size", "=", "100", ",", "optimizer", "=", "'adam'", ",", "\n", "n_hidden", "=", "100", ",", "lr", "=", "0.001", ",", "verbose", "=", "True", ",", "**", "mlp_params", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "self", ".", "n_epochs", "=", "n_epochs", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "optimizer", "=", "optimizer", ".", "lower", "(", ")", "\n", "self", ".", "model_params", "=", "mlp_params", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "assert", "len", "(", "conditions", ")", ",", "\"Minimum 1 condition is necessary for MLP\"", "\n", "self", ".", "conditions", "=", "conditions", "\n", "\n", "self", ".", "mlp", ",", "self", ".", "mlp_optim", ",", "self", ".", "vect", "=", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.DecodingRecommender.__str__": [[479, 488], ["str", "str", "str", "str", "len", "aae.DecodingRecommender.conditions.keys"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "desc", "=", "\"MLP-2 Decoder with \"", "+", "str", "(", "self", ".", "n_hidden", ")", "+", "\" hidden units\"", "\n", "desc", "+=", "\" training for \"", "+", "str", "(", "self", ".", "n_epochs", ")", "\n", "desc", "+=", "\" optimized by \"", "+", "self", ".", "optimizer", "\n", "desc", "+=", "\" with learning rate \"", "+", "str", "(", "self", ".", "lr", ")", "\n", "desc", "+=", "\" with %d conditions: %s \"", "%", "(", "len", "(", "self", ".", "conditions", ")", ",", "', '", ".", "join", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", ")", "\n", "desc", "+=", "\"\\n MLP Params: \"", "+", "str", "(", "self", ".", "model_params", ")", "\n", "return", "desc", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.DecodingRecommender.partial_fit": [[489, 518], ["aae.DecodingRecommender.mlp.train", "aae.DecodingRecommender.conditions.train", "aae.DecodingRecommender.conditions.encode", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "aae.DecodingRecommender.mlp", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "aae.DecodingRecommender.mlp_optim.zero_grad", "aae.DecodingRecommender.conditions.zero_grad", "torch.binary_cross_entropy.backward", "aae.DecodingRecommender.mlp_optim.step", "aae.DecodingRecommender.conditions.step", "list", "zip", "wandb.log", "print", "aae.DecodingRecommender.conditions.values", "cond.impose", "cond.impose.cuda", "y.cuda", "torch.binary_cross_entropy.item", "torch.binary_cross_entropy.data.item"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.impose"], ["", "def", "partial_fit", "(", "self", ",", "condition_data", ",", "y", ",", "step", "=", "None", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "self", ".", "mlp", ".", "train", "(", ")", "\n", "self", ".", "conditions", ".", "train", "(", ")", "\n", "# Encode ALL condition data with respective condition", "\n", "encoded_cdata", "=", "self", ".", "conditions", ".", "encode", "(", "condition_data", ")", "\n", "remaining_conditions", "=", "list", "(", "self", ".", "conditions", ".", "values", "(", ")", ")", "[", "1", ":", "]", "\n", "# Start with first encoded condition (since we need one)", "\n", "inputs", "=", "encoded_cdata", "[", "0", "]", "\n", "if", "remaining_conditions", ":", "\n", "            ", "for", "cond", ",", "cdata", "in", "zip", "(", "remaining_conditions", ",", "encoded_cdata", "[", "1", ":", "]", ")", ":", "\n", "# Impose all remaining conditions", "\n", "                ", "inputs", "=", "cond", ".", "impose", "(", "inputs", ",", "cdata", ")", "\n", "\n", "", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "inputs", ",", "y", "=", "inputs", ".", "cuda", "(", ")", ",", "y", ".", "cuda", "(", ")", "\n", "", "y_pred", "=", "self", ".", "mlp", "(", "inputs", ")", "\n", "loss", "=", "F", ".", "binary_cross_entropy", "(", "y_pred", "+", "TINY", ",", "y", "+", "TINY", ")", "\n", "self", ".", "mlp_optim", ".", "zero_grad", "(", ")", "\n", "self", ".", "conditions", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "mlp_optim", ".", "step", "(", ")", "\n", "self", ".", "conditions", ".", "step", "(", ")", "\n", "if", "USE_WANDB", ":", "\n", "            ", "assert", "step", "is", "not", "None", "\n", "wandb", ".", "log", "(", "{", "\"step\"", ":", "step", ",", "\"loss\"", ":", "loss", ".", "item", "(", ")", "}", ")", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"\\rLoss: {}\"", ".", "format", "(", "loss", ".", "data", ".", "item", "(", ")", ")", ",", "flush", "=", "True", ",", "end", "=", "''", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.DecodingRecommender.fit": [[519, 545], ["aae.Decoder", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "optimizer_cls", "range", "aae.DecodingRecommender.conditions.size_increment", "aae.DecodingRecommender.mlp.cuda", "aae.DecodingRecommender.mlp.parameters", "sklearn.utils.shuffle", "range", "scipy.issparse", "aae.DecodingRecommender.partial_fit", "print", "Y_batch.toarray.toarray.toarray", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit"], ["", "def", "fit", "(", "self", ",", "condition_data", ",", "Y", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "self", ".", "mlp", "=", "Decoder", "(", "self", ".", "conditions", ".", "size_increment", "(", ")", ",", "\n", "self", ".", "n_hidden", ",", "\n", "Y", ".", "shape", "[", "1", "]", ",", "\n", "**", "self", ".", "model_params", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "mlp", "=", "self", ".", "mlp", ".", "cuda", "(", ")", "\n", "", "optimizer_cls", "=", "TORCH_OPTIMIZERS", "[", "self", ".", "optimizer", "]", "\n", "self", ".", "mlp_optim", "=", "optimizer_cls", "(", "self", ".", "mlp", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "step", "=", "0", "\n", "for", "__epoch", "in", "range", "(", "self", ".", "n_epochs", ")", ":", "\n", "            ", "Y_shuf", ",", "*", "condition_data_shuf", "=", "sklearn", ".", "utils", ".", "shuffle", "(", "Y", ",", "*", "condition_data", ")", "\n", "for", "start", "in", "range", "(", "0", ",", "Y", ".", "shape", "[", "0", "]", ",", "self", ".", "batch_size", ")", ":", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "Y_batch", "=", "Y_shuf", "[", "start", ":", "end", "]", "\n", "C_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data_shuf", "]", "\n", "if", "sp", ".", "issparse", "(", "Y_batch", ")", ":", "\n", "                    ", "Y_batch", "=", "Y_batch", ".", "toarray", "(", ")", "\n", "", "self", ".", "partial_fit", "(", "C_batch", ",", "torch", ".", "FloatTensor", "(", "Y_batch", ")", ",", "step", "=", "step", ")", "\n", "step", "+=", "1", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", ")", "\n", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.DecodingRecommender.train": [[546, 553], ["training_set.tocsr", "training_set.get_attributes", "aae.DecodingRecommender.conditions.fit_transform", "aae.DecodingRecommender.fit", "aae.DecodingRecommender.conditions.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit"], ["", "def", "train", "(", "self", ",", "training_set", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "# Fit function from condition to X", "\n", "        ", "Y", "=", "training_set", ".", "tocsr", "(", ")", "\n", "condition_data_raw", "=", "training_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "condition_data", "=", "self", ".", "conditions", ".", "fit_transform", "(", "condition_data_raw", ")", "\n", "self", ".", "fit", "(", "condition_data", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.DecodingRecommender.predict": [[555, 585], ["test_set.size", "test_set.get_attributes", "aae.DecodingRecommender.conditions.transform", "aae.DecodingRecommender.mlp.eval", "aae.DecodingRecommender.conditions.eval", "numpy.vstack", "aae.DecodingRecommender.conditions.keys", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "range", "aae.DecodingRecommender.conditions.encode", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "aae.DecodingRecommender.mlp", "batch_results.append", "list", "zip", "cond.impose.cuda", "aae.DecodingRecommender.cpu().numpy", "aae.DecodingRecommender.conditions.values", "cond.impose", "aae.DecodingRecommender.cpu"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.impose"], ["", "def", "predict", "(", "self", ",", "test_set", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "n_users", "=", "test_set", ".", "size", "(", "0", ")", "\n", "condition_data_raw", "=", "test_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "condition_data", "=", "self", ".", "conditions", ".", "transform", "(", "condition_data_raw", ")", "\n", "self", ".", "mlp", ".", "eval", "(", ")", "\n", "self", ".", "conditions", ".", "eval", "(", ")", "\n", "batch_results", "=", "[", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "start", "in", "range", "(", "0", ",", "n_users", ",", "self", ".", "batch_size", ")", ":", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "c_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data", "]", "\n", "encoded_cdata", "=", "self", ".", "conditions", ".", "encode", "(", "c_batch", ")", "\n", "remaining_conditions", "=", "list", "(", "self", ".", "conditions", ".", "values", "(", ")", ")", "[", "1", ":", "]", "\n", "# Start with first encoded condition (since we need one)", "\n", "inputs", "=", "encoded_cdata", "[", "0", "]", "\n", "if", "remaining_conditions", ":", "\n", "                    ", "for", "cond", ",", "cdata", "in", "zip", "(", "remaining_conditions", ",", "encoded_cdata", "[", "1", ":", "]", ")", ":", "\n", "# Impose all remaining conditions", "\n", "                        ", "inputs", "=", "cond", ".", "impose", "(", "inputs", ",", "cdata", ")", "\n", "\n", "# Shift data to gpu", "\n", "", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                    ", "inputs", "=", "inputs", ".", "cuda", "(", ")", "\n", "", "res", "=", "self", ".", "mlp", "(", "inputs", ")", "\n", "# Shift results back to cpu", "\n", "batch_results", ".", "append", "(", "res", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "", "", "y_pred", "=", "np", ".", "vstack", "(", "batch_results", ")", "\n", "return", "y_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.__init__": [[592, 634], ["prior.lower", "optimizer.lower"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "n_hidden", "=", "100", ",", "\n", "n_code", "=", "50", ",", "\n", "gen_lr", "=", "0.001", ",", "\n", "reg_lr", "=", "0.001", ",", "\n", "prior", "=", "'gauss'", ",", "\n", "prior_scale", "=", "None", ",", "\n", "batch_size", "=", "100", ",", "\n", "n_epochs", "=", "500", ",", "\n", "optimizer", "=", "'adam'", ",", "\n", "normalize_inputs", "=", "True", ",", "\n", "activation", "=", "'ReLU'", ",", "\n", "dropout", "=", "(", ".2", ",", ".2", ")", ",", "\n", "conditions", "=", "None", ",", "\n", "verbose", "=", "True", ")", ":", "\n", "# Build models", "\n", "        ", "self", ".", "prior", "=", "prior", ".", "lower", "(", ")", "\n", "self", ".", "prior_scale", "=", "prior_scale", "\n", "\n", "# Encoder final activation depends on prior distribution", "\n", "self", ".", "prior_sampler", "=", "PRIOR_SAMPLERS", "[", "self", ".", "prior", "]", "\n", "self", ".", "encoder_activation", "=", "PRIOR_ACTIVATIONS", "[", "self", ".", "prior", "]", "\n", "self", ".", "optimizer", "=", "optimizer", ".", "lower", "(", ")", "\n", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "n_code", "=", "n_code", "\n", "self", ".", "gen_lr", "=", "gen_lr", "\n", "self", ".", "reg_lr", "=", "reg_lr", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "gen_lr", ",", "self", ".", "reg_lr", "=", "gen_lr", ",", "reg_lr", "\n", "self", ".", "n_epochs", "=", "n_epochs", "\n", "\n", "self", ".", "enc", ",", "self", ".", "dec", ",", "self", ".", "disc", "=", "None", ",", "None", ",", "None", "\n", "self", ".", "enc_optim", ",", "self", ".", "dec_optim", "=", "None", ",", "None", "\n", "self", ".", "gen_optim", ",", "self", ".", "disc_optim", "=", "None", ",", "None", "\n", "self", ".", "normalize_inputs", "=", "normalize_inputs", "\n", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "activation", "=", "activation", "\n", "\n", "self", ".", "conditions", "=", "conditions", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.__str__": [[636, 649], ["aae.AdversarialAutoEncoder.conditions.keys"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "desc", "=", "\"Adversarial Autoencoder\"", "\n", "n_h", ",", "n_c", "=", "self", ".", "n_hidden", ",", "self", ".", "n_code", "\n", "gen", ",", "reg", "=", "self", ".", "gen_lr", ",", "self", ".", "reg_lr", "\n", "desc", "+=", "\" ({}, {}, {}, {}, {})\"", ".", "format", "(", "n_h", ",", "n_h", ",", "n_c", ",", "n_h", ",", "n_h", ")", "\n", "desc", "+=", "\" optimized by \"", "+", "self", ".", "optimizer", "\n", "desc", "+=", "\" with learning rates Gen, Reg = {}, {}\"", ".", "format", "(", "gen", ",", "reg", ")", "\n", "desc", "+=", "\", using a batch size of {}\"", ".", "format", "(", "self", ".", "batch_size", ")", "\n", "desc", "+=", "\"\\nMatching the {} distribution\"", ".", "format", "(", "self", ".", "prior", ")", "\n", "desc", "+=", "\" by {} activation.\"", ".", "format", "(", "self", ".", "encoder_activation", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "desc", "+=", "\"\\nConditioned on \"", "+", "', '", ".", "join", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "", "return", "desc", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval": [[650, 659], ["aae.AdversarialAutoEncoder.enc.eval", "aae.AdversarialAutoEncoder.dec.eval", "aae.AdversarialAutoEncoder.disc.eval", "aae.AdversarialAutoEncoder.conditions.eval"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "\"\"\" Put all NN modules into eval mode \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "self", ".", "enc", ".", "eval", "(", ")", "\n", "self", ".", "dec", ".", "eval", "(", ")", "\n", "self", ".", "disc", ".", "eval", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "# Forward call to condition modules", "\n", "            ", "self", ".", "conditions", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.train": [[660, 669], ["aae.AdversarialAutoEncoder.enc.train", "aae.AdversarialAutoEncoder.dec.train", "aae.AdversarialAutoEncoder.disc.train", "aae.AdversarialAutoEncoder.conditions.train"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train"], ["", "", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\" Put all NN modules into train mode \"\"\"", "\n", "### DONE Adapt to generic condition ###", "\n", "self", ".", "enc", ".", "train", "(", ")", "\n", "self", ".", "dec", ".", "train", "(", ")", "\n", "self", ".", "disc", ".", "train", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "# Forward call to condition modules", "\n", "            ", "self", ".", "conditions", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad": [[670, 675], ["aae.AdversarialAutoEncoder.enc.zero_grad", "aae.AdversarialAutoEncoder.dec.zero_grad", "aae.AdversarialAutoEncoder.disc.zero_grad"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad"], ["", "", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "\"\"\" Zeros gradients of all NN modules \"\"\"", "\n", "self", ".", "enc", ".", "zero_grad", "(", ")", "\n", "self", ".", "dec", ".", "zero_grad", "(", ")", "\n", "self", ".", "disc", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.ae_step": [[676, 712], ["aae.AdversarialAutoEncoder.enc", "condition._check_conditions", "aae.AdversarialAutoEncoder.dec", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "aae.AdversarialAutoEncoder.enc.zero_grad", "aae.AdversarialAutoEncoder.dec.zero_grad", "torch.binary_cross_entropy.backward", "aae.AdversarialAutoEncoder.enc_optim.step", "aae.AdversarialAutoEncoder.dec_optim.step", "torch.binary_cross_entropy.data.item", "aae.AdversarialAutoEncoder.conditions.encode_impose", "aae.AdversarialAutoEncoder.conditions.zero_grad", "aae.AdversarialAutoEncoder.conditions.step", "batch.view", "batch.size", "batch.size"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "ae_step", "(", "self", ",", "batch", ",", "condition_data", "=", "None", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "\"\"\"\n        # why is this double? to AdversarialAutoEncoder => THe AE Step is very different from plain AEs\n        # what is relationship to train?\n        # Condition is used explicitly here, and hard coded but non-explicitly here\n        Perform one autoencoder training step\n        :param batch:\n        :param condition: ??? ~ training_set.get_single_attribute(\"title\") <~ side_info = unpack_playlists(playlists)\n        :return:\n        \"\"\"", "\n", "z_sample", "=", "self", ".", "enc", "(", "batch", ")", "\n", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "if", "use_condition", ":", "\n", "            ", "z_sample", "=", "self", ".", "conditions", ".", "encode_impose", "(", "z_sample", ",", "condition_data", ")", "\n", "\n", "", "x_sample", "=", "self", ".", "dec", "(", "z_sample", ")", "\n", "recon_loss", "=", "F", ".", "binary_cross_entropy", "(", "x_sample", "+", "TINY", ",", "\n", "batch", ".", "view", "(", "batch", ".", "size", "(", "0", ")", ",", "\n", "batch", ".", "size", "(", "1", ")", ")", "+", "TINY", ")", "\n", "# Clear all related gradients", "\n", "self", ".", "enc", ".", "zero_grad", "(", ")", "\n", "self", ".", "dec", ".", "zero_grad", "(", ")", "\n", "if", "use_condition", ":", "\n", "            ", "self", ".", "conditions", ".", "zero_grad", "(", ")", "\n", "\n", "# Compute gradients", "\n", "", "recon_loss", ".", "backward", "(", ")", "\n", "\n", "# Update parameters", "\n", "self", ".", "enc_optim", ".", "step", "(", ")", "\n", "self", ".", "dec_optim", ".", "step", "(", ")", "\n", "if", "use_condition", ":", "\n", "            ", "self", ".", "conditions", ".", "step", "(", ")", "\n", "\n", "", "return", "recon_loss", ".", "data", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.disc_step": [[713, 733], ["aae.AdversarialAutoEncoder.enc.eval", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "aae.AdversarialAutoEncoder.enc", "aae.AdversarialAutoEncoder.disc_optim.zero_grad", "disc_loss.backward", "aae.AdversarialAutoEncoder.disc_optim.step", "disc_loss.data.item", "aae.AdversarialAutoEncoder.prior_sampler", "z_real.cuda.cuda.cuda", "aae.AdversarialAutoEncoder.disc", "aae.AdversarialAutoEncoder.disc", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "batch.size", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log"], ["", "def", "disc_step", "(", "self", ",", "batch", ")", ":", "\n", "        ", "\"\"\" Perform one discriminator step on batch \"\"\"", "\n", "self", ".", "enc", ".", "eval", "(", ")", "\n", "z_real", "=", "Variable", "(", "self", ".", "prior_sampler", "(", "(", "batch", ".", "size", "(", "0", ")", ",", "self", ".", "n_code", ")", ")", ")", "\n", "if", "self", ".", "prior_scale", "is", "not", "None", ":", "\n", "            ", "z_real", "=", "z_real", "*", "self", ".", "prior_scale", "\n", "\n", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "z_real", "=", "z_real", ".", "cuda", "(", ")", "\n", "", "z_fake", "=", "self", ".", "enc", "(", "batch", ")", "\n", "\n", "# Compute discrimnator outputs and loss", "\n", "disc_real_out", ",", "disc_fake_out", "=", "self", ".", "disc", "(", "z_real", ")", ",", "self", ".", "disc", "(", "z_fake", ")", "\n", "disc_loss", "=", "-", "torch", ".", "mean", "(", "torch", ".", "log", "(", "disc_real_out", "+", "TINY", ")", "\n", "+", "torch", ".", "log", "(", "1", "-", "disc_fake_out", "+", "TINY", ")", ")", "\n", "self", ".", "disc_optim", ".", "zero_grad", "(", ")", "\n", "disc_loss", ".", "backward", "(", ")", "\n", "self", ".", "disc_optim", ".", "step", "(", ")", "\n", "\n", "return", "disc_loss", ".", "data", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.gen_step": [[734, 744], ["aae.AdversarialAutoEncoder.enc.train", "aae.AdversarialAutoEncoder.enc", "aae.AdversarialAutoEncoder.disc", "aae.AdversarialAutoEncoder.gen_optim.zero_grad", "gen_loss.backward", "aae.AdversarialAutoEncoder.gen_optim.step", "gen_loss.data.item", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log"], ["", "def", "gen_step", "(", "self", ",", "batch", ")", ":", "\n", "        ", "self", ".", "enc", ".", "train", "(", ")", "\n", "z_fake_dist", "=", "self", ".", "enc", "(", "batch", ")", "\n", "disc_fake_out", "=", "self", ".", "disc", "(", "z_fake_dist", ")", "\n", "gen_loss", "=", "-", "torch", ".", "mean", "(", "torch", ".", "log", "(", "disc_fake_out", "+", "TINY", ")", ")", "\n", "self", ".", "gen_optim", ".", "zero_grad", "(", ")", "\n", "gen_loss", ".", "backward", "(", ")", "\n", "self", ".", "gen_optim", ".", "step", "(", ")", "\n", "\n", "return", "gen_loss", ".", "data", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit": [[745, 767], ["torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "aae.AdversarialAutoEncoder.train", "aae.AdversarialAutoEncoder.ae_step", "aae.AdversarialAutoEncoder.disc_step", "aae.AdversarialAutoEncoder.gen_step", "NotImplementedError", "X.cuda.cuda.cuda", "aae.log_losses", "wandb.log"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.ae_step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.disc_step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.gen_step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.log_losses", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log"], ["", "def", "partial_fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "condition_data", "=", "None", ",", "step", "=", "None", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "\"\"\" Performs reconstrction, discimination, generator training steps \"\"\"", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"(Semi-)supervised usage not supported\"", ")", "\n", "# Transform to Torch (Cuda) Variable, shift batch to GPU", "\n", "", "X", "=", "torch", ".", "FloatTensor", "(", "X", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "# Put batch on CUDA device!", "\n", "            ", "X", "=", "X", ".", "cuda", "(", ")", "\n", "# Make sure we are in training mode and zero leftover gradients", "\n", "", "self", ".", "train", "(", ")", "\n", "# One step each, could balance", "\n", "recon_loss", "=", "self", ".", "ae_step", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "disc_loss", "=", "self", ".", "disc_step", "(", "X", ")", "\n", "gen_loss", "=", "self", ".", "gen_step", "(", "X", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "log_losses", "(", "recon_loss", ",", "disc_loss", ",", "gen_loss", ")", "\n", "", "if", "USE_WANDB", ":", "\n", "            ", "assert", "step", "is", "not", "None", "\n", "wandb", ".", "log", "(", "{", "\"step\"", ":", "step", ",", "\"loss\"", ":", "recon_loss", ",", "\"disc_loss\"", ":", "disc_loss", ",", "\"gen_loss\"", ":", "gen_loss", "}", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.fit": [[768, 838], ["condition._check_conditions", "aae.Encoder", "aae.Decoder", "aae.Discriminator", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "optimizer_gen", "optimizer_gen", "optimizer_gen", "optimizer_gen", "range", "NotImplementedError", "print", "print", "aae.AdversarialAutoEncoder.enc.cuda", "aae.AdversarialAutoEncoder.dec.cuda", "aae.AdversarialAutoEncoder.disc.cuda", "aae.AdversarialAutoEncoder.enc.parameters", "aae.AdversarialAutoEncoder.dec.parameters", "aae.AdversarialAutoEncoder.enc.parameters", "aae.AdversarialAutoEncoder.disc.parameters", "range", "aae.AdversarialAutoEncoder.conditions.size_increment", "print", "sklearn.utils.shuffle", "sklearn.utils.shuffle", "X_shuf[].toarray", "print", "aae.AdversarialAutoEncoder.partial_fit", "aae.AdversarialAutoEncoder.partial_fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.partial_fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "condition_data", "=", "None", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "if", "y", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"(Semi-)supervised usage not supported\"", ")", "\n", "\n", "", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "\n", "if", "use_condition", ":", "\n", "            ", "code_size", "=", "self", ".", "n_code", "+", "self", ".", "conditions", ".", "size_increment", "(", ")", "\n", "print", "(", "\"Using condition, code size:\"", ",", "code_size", ")", "\n", "", "else", ":", "\n", "            ", "code_size", "=", "self", ".", "n_code", "\n", "print", "(", "\"Not using condition, code size:\"", ",", "code_size", ")", "\n", "\n", "", "self", ".", "enc", "=", "Encoder", "(", "X", ".", "shape", "[", "1", "]", ",", "self", ".", "n_hidden", ",", "self", ".", "n_code", ",", "\n", "final_activation", "=", "self", ".", "encoder_activation", ",", "\n", "normalize_inputs", "=", "self", ".", "normalize_inputs", ",", "\n", "activation", "=", "self", ".", "activation", ",", "\n", "dropout", "=", "self", ".", "dropout", ")", "\n", "self", ".", "dec", "=", "Decoder", "(", "code_size", ",", "self", ".", "n_hidden", ",", "X", ".", "shape", "[", "1", "]", ",", "\n", "activation", "=", "self", ".", "activation", ",", "dropout", "=", "self", ".", "dropout", ")", "\n", "\n", "self", ".", "disc", "=", "Discriminator", "(", "self", ".", "n_code", ",", "self", ".", "n_hidden", ",", "\n", "dropout", "=", "self", ".", "dropout", ",", "\n", "activation", "=", "self", ".", "activation", ")", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "enc", "=", "self", ".", "enc", ".", "cuda", "(", ")", "\n", "self", ".", "dec", "=", "self", ".", "dec", ".", "cuda", "(", ")", "\n", "self", ".", "disc", "=", "self", ".", "disc", ".", "cuda", "(", ")", "\n", "", "optimizer_gen", "=", "TORCH_OPTIMIZERS", "[", "self", ".", "optimizer", "]", "\n", "# Reconstruction", "\n", "self", ".", "enc_optim", "=", "optimizer_gen", "(", "self", ".", "enc", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "gen_lr", ")", "\n", "self", ".", "dec_optim", "=", "optimizer_gen", "(", "self", ".", "dec", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "gen_lr", ")", "\n", "# Regularization", "\n", "self", ".", "gen_optim", "=", "optimizer_gen", "(", "self", ".", "enc", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "reg_lr", ")", "\n", "self", ".", "disc_optim", "=", "optimizer_gen", "(", "self", ".", "disc", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "reg_lr", ")", "\n", "\n", "# do the actual training", "\n", "step", "=", "0", "\n", "for", "epoch", "in", "range", "(", "self", ".", "n_epochs", ")", ":", "\n", "            ", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "\"Epoch\"", ",", "epoch", "+", "1", ")", "\n", "\n", "# Shuffle on each new epoch", "\n", "", "if", "use_condition", ":", "\n", "# shuffle(*arrays) takes several arrays and shuffles them so indices are still matching", "\n", "                ", "X_shuf", ",", "*", "condition_data_shuf", "=", "sklearn", ".", "utils", ".", "shuffle", "(", "X", ",", "*", "condition_data", ")", "\n", "", "else", ":", "\n", "                ", "X_shuf", "=", "sklearn", ".", "utils", ".", "shuffle", "(", "X", ")", "\n", "\n", "", "for", "start", "in", "range", "(", "0", ",", "X_shuf", ".", "shape", "[", "0", "]", ",", "self", ".", "batch_size", ")", ":", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "\n", "# Make the batch dense!", "\n", "X_batch", "=", "X_shuf", "[", "start", ":", "end", "]", ".", "toarray", "(", ")", "\n", "\n", "# condition may be None", "\n", "if", "use_condition", ":", "\n", "# c_batch = condition_shuf[start:(start+self.batch_size)]", "\n", "                    ", "c_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data_shuf", "]", "\n", "self", ".", "partial_fit", "(", "X_batch", ",", "condition_data", "=", "c_batch", ",", "step", "=", "step", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "partial_fit", "(", "X_batch", ",", "step", "=", "step", ")", "\n", "", "step", "+=", "1", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "# Clean up after flushing batch loss printings", "\n", "                ", "print", "(", ")", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.predict": [[840, 871], ["aae.AdversarialAutoEncoder.eval", "condition._check_conditions", "numpy.vstack", "aae.AdversarialAutoEncoder.conditions.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "range", "scipy.issparse", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "aae.AdversarialAutoEncoder.enc", "aae.AdversarialAutoEncoder.dec", "X_reconstuction.data.cpu().numpy.data.cpu().numpy.data.cpu().numpy", "pred.append", "X_batch.cuda.cuda.toarray", "X_batch.cuda.cuda.cuda", "aae.AdversarialAutoEncoder.conditions.encode_impose", "X_reconstuction.data.cpu().numpy.data.cpu().numpy.data.cpu"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition._check_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.eval", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose"], ["", "def", "predict", "(", "self", ",", "X", ",", "condition_data", "=", "None", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "self", ".", "eval", "(", ")", "# Deactivate dropout", "\n", "# In case some of the conditions has dropout", "\n", "use_condition", "=", "_check_conditions", "(", "self", ".", "conditions", ",", "condition_data", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "self", ".", "conditions", ".", "eval", "(", ")", "\n", "", "pred", "=", "[", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "start", "in", "range", "(", "0", ",", "X", ".", "shape", "[", "0", "]", ",", "self", ".", "batch_size", ")", ":", "\n", "                ", "end", "=", "start", "+", "self", ".", "batch_size", "\n", "# batched predictions, yet inclusive", "\n", "X_batch", "=", "X", "[", "start", ":", "(", "start", "+", "self", ".", "batch_size", ")", "]", "\n", "if", "sp", ".", "issparse", "(", "X_batch", ")", ":", "\n", "                    ", "X_batch", "=", "X_batch", ".", "toarray", "(", ")", "\n", "", "X_batch", "=", "torch", ".", "FloatTensor", "(", "X_batch", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "                    ", "X_batch", "=", "X_batch", ".", "cuda", "(", ")", "\n", "\n", "", "if", "use_condition", ":", "\n", "                    ", "c_batch", "=", "[", "c", "[", "start", ":", "end", "]", "for", "c", "in", "condition_data", "]", "\n", "# reconstruct", "\n", "", "z", "=", "self", ".", "enc", "(", "X_batch", ")", "\n", "if", "use_condition", ":", "\n", "# z = torch.cat((z, c_batch), 1)", "\n", "                    ", "z", "=", "self", ".", "conditions", ".", "encode_impose", "(", "z", ",", "c_batch", ")", "\n", "", "X_reconstuction", "=", "self", ".", "dec", "(", "z", ")", "\n", "# shift", "\n", "X_reconstuction", "=", "X_reconstuction", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred", ".", "append", "(", "X_reconstuction", ")", "\n", "", "", "return", "np", ".", "vstack", "(", "pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.__init__": [[892, 913], ["base.Recommender.__init__", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "adversarial", "=", "True", ",", "conditions", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "\"\"\" tfidf_params get piped to either TfidfVectorizer or\n        EmbeddedVectorizer.  Remaining kwargs get passed to\n        AdversarialAutoencoder \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "verbose", "=", "kwargs", ".", "get", "(", "'verbose'", ",", "True", ")", "\n", "\n", "# self.use_side_info = kwargs.pop('use_side_info', False)", "\n", "\n", "self", ".", "conditions", "=", "conditions", "\n", "\n", "# assert_condition_callabilities(self.use_side_info)", "\n", "# Embedding is now part of a condition", "\n", "# self.embedding = kwargs.pop('embedding', None)", "\n", "# Vectorizer also...", "\n", "# self.vect = None", "\n", "self", ".", "model_params", "=", "kwargs", "\n", "# tfidf params now need to be in the respective *condition* of condition_list", "\n", "# self.tfidf_params = tfidf_params", "\n", "self", ".", "adversarial", "=", "adversarial", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.__str__": [[914, 929], ["str", "aae.AAERecommender.conditions.keys"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "if", "self", ".", "adversarial", ":", "\n", "            ", "desc", "=", "\"Adversarial Autoencoder\"", "\n", "", "else", ":", "\n", "            ", "desc", "=", "\"Autoencoder\"", "\n", "\n", "", "if", "self", ".", "conditions", ":", "\n", "            ", "desc", "+=", "\" conditioned on: \"", "+", "', '", ".", "join", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "", "desc", "+=", "'\\nModel Params: '", "+", "str", "(", "self", ".", "model_params", ")", "\n", "# TODO: is it correct for self.tfidf_params to be an EMPTY dict", "\n", "# DONE: Yes it is only the *default*!", "\n", "# desc += '\\nTfidf Params: ' + str(self.tfidf_params)", "\n", "# Anyways, this kind of stuff goes into the condition itself", "\n", "return", "desc", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train": [[931, 964], ["print", "training_set.tocsr", "print", "print", "aae.AAERecommender.model.fit", "print", "training_set.get_attributes", "aae.AAERecommender.conditions.fit_transform", "print", "aae.AdversarialAutoEncoder", "aae.AutoEncoder", "aae.AAERecommender.conditions.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "train", "(", "self", ",", "training_set", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "\"\"\"\n        1. get basic representation\n        2. ? add potential side_info in ??? representation\n        3. initialize a (Adversarial) Autoencoder variant\n        4. fit based on Autoencoder\n        :param training_set: ???, Bag Class training set\n        :return: trained self\n        \"\"\"", "\n", "print", "(", "self", ")", "\n", "X", "=", "training_set", ".", "tocsr", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "print", "(", "\"Fit transforming conditions:\"", ",", "self", ".", "conditions", ")", "\n", "condition_data_raw", "=", "training_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "condition_data", "=", "self", ".", "conditions", ".", "fit_transform", "(", "condition_data_raw", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Start of training, not using condition...\"", ",", "self", ".", "conditions", ")", "\n", "condition_data", "=", "None", "\n", "\n", "", "if", "self", ".", "adversarial", ":", "\n", "# Pass conditions through along with hyperparams", "\n", "            ", "self", ".", "model", "=", "AdversarialAutoEncoder", "(", "conditions", "=", "self", ".", "conditions", ",", "**", "self", ".", "model_params", ")", "\n", "", "else", ":", "\n", "# Pass conditions through along with hyperparams!", "\n", "            ", "self", ".", "model", "=", "AutoEncoder", "(", "conditions", "=", "self", ".", "conditions", ",", "**", "self", ".", "model_params", ")", "\n", "\n", "", "print", "(", "self", ".", "model", ")", "\n", "print", "(", "self", ".", "conditions", ")", "\n", "\n", "\n", "# gives (Adversarial) Autoencoder BaseData (--> X: <???> representation) and side_info (attr_vect: numpy)", "\n", "self", ".", "model", ".", "fit", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.predict": [[965, 978], ["test_set.tocsr", "aae.AAERecommender.model.predict", "test_set.get_attributes", "aae.AAERecommender.conditions.transform", "aae.AAERecommender.conditions.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.predict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "predict", "(", "self", ",", "test_set", ")", ":", "\n", "### DONE Adapt to generic condition ###", "\n", "        ", "X", "=", "test_set", ".", "tocsr", "(", ")", "\n", "if", "self", ".", "conditions", ":", "\n", "            ", "condition_data_raw", "=", "test_set", ".", "get_attributes", "(", "self", ".", "conditions", ".", "keys", "(", ")", ")", "\n", "# Important to not call fit here, but just transform", "\n", "condition_data", "=", "self", ".", "conditions", ".", "transform", "(", "condition_data_raw", ")", "\n", "", "else", ":", "\n", "            ", "condition_data", "=", "None", "\n", "\n", "", "pred", "=", "self", ".", "model", ".", "predict", "(", "X", ",", "condition_data", "=", "condition_data", ")", "\n", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.assert_condition_callabilities": [[43, 49], ["DeprecationWarning", "type", "type", "hasattr", "type", "type", "type"], "function", ["None"], ["", "def", "assert_condition_callabilities", "(", "conditions", ")", ":", "\n", "    ", "raise", "DeprecationWarning", "(", "\"Use _check_conditions(conditions, condition_data) instead\"", ")", "\n", "if", "type", "(", "conditions", ")", "==", "type", "(", "True", ")", ":", "\n", "        ", "pass", "\n", "", "else", ":", "\n", "        ", "assert", "type", "(", "conditions", ")", "!=", "type", "(", "\"\"", ")", "and", "hasattr", "(", "conditions", ",", "'__iter__'", ")", ",", "\"Conditions needs to be a list of different conditions. It is a {} now.\"", ".", "format", "(", "type", "(", "conditions", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.concat_side_info": [[54, 72], ["DeprecationWarning", "enumerate", "training_set.get_single_attribute", "vectorizer.fit_transform", "numpy.concatenate", "vectorizer.fit_transform"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_single_attribute", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "", "def", "concat_side_info", "(", "vectorizer", ",", "training_set", ",", "side_info_subset", ")", ":", "\n", "    ", "\"\"\"\n    Constructing an np.array with having the concatenated features in shape[1]\n    :param training_set: Bag class dataset,\n    :side_info_subset: list of str, the attribute keys in Bag class\n    :return:\n    \"\"\"", "\n", "raise", "DeprecationWarning", "(", "\"Use ConditionList.encode_impose(...) instead\"", ")", "\n", "attr_vect", "=", "[", "]", "\n", "# ugly substitute for do_until pattern", "\n", "for", "i", ",", "attribute", "in", "enumerate", "(", "side_info_subset", ")", ":", "\n", "        ", "attr_data", "=", "training_set", ".", "get_single_attribute", "(", "attribute", ")", "\n", "if", "i", "<", "1", ":", "\n", "            ", "attr_vect", "=", "vectorizer", ".", "fit_transform", "(", "attr_data", ")", "\n", "", "else", ":", "\n", "# rows are instances, cols are features --> adding cols makes up new features", "\n", "            ", "attr_vect", "=", "np", ".", "concatenate", "(", "(", "attr_vect", ",", "vectorizer", ".", "fit_transform", "(", "attr_data", ")", ")", ",", "axis", "=", "1", ")", "\n", "", "", "return", "attr_vect", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.log_losses": [[74, 76], ["print", "STATUS_FORMAT.format"], "function", ["None"], ["", "def", "log_losses", "(", "*", "losses", ")", ":", "\n", "    ", "print", "(", "'\\r'", "+", "STATUS_FORMAT", ".", "format", "(", "*", "losses", ")", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.sample_categorical": [[78, 84], ["numpy.random.randint", "[].astype", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.eye"], "function", ["None"], ["", "def", "sample_categorical", "(", "size", ")", ":", "\n", "    ", "batch_size", ",", "n_classes", "=", "size", "\n", "cat", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "n_classes", ",", "batch_size", ")", "\n", "cat", "=", "np", ".", "eye", "(", "n_classes", ")", "[", "cat", "]", ".", "astype", "(", "'float32'", ")", "\n", "cat", "=", "torch", ".", "from_numpy", "(", "cat", ")", "\n", "return", "cat", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.sample_bernoulli": [[86, 89], ["numpy.random.randint().astype", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.random.randint"], "function", ["None"], ["", "def", "sample_bernoulli", "(", "size", ")", ":", "\n", "    ", "ber", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "1", ",", "size", ")", ".", "astype", "(", "'float32'", ")", "\n", "return", "torch", ".", "from_numpy", "(", "ber", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.main": [[980, 1026], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "datasets.Bags.load_tabcomma_format", "evaluation.Evaluation().setup", "gensim.models.keyedvectors.KeyedVectors.load_word2vec_format", "Evaluation().setup.", "aae.AAERecommender", "evaluation.Evaluation", "itertools.product"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.load_tabcomma_format", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.setup"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\" Evaluates the AAE Recommender \"\"\"", "\n", "CONFIG", "=", "{", "\n", "'pub'", ":", "(", "'../Data/PMC/citations_pmc.tsv'", ",", "2011", ",", "50", ")", ",", "\n", "'eco'", ":", "(", "'../Data/Economics/econbiz62k.tsv'", ",", "2012", ",", "1", ")", "\n", "}", "\n", "\n", "PARSER", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "PARSER", ".", "add_argument", "(", "'data'", ",", "type", "=", "str", ",", "choices", "=", "[", "'pub'", ",", "'eco'", "]", ")", "\n", "args", "=", "PARSER", ".", "parse_args", "(", ")", "\n", "DATA", "=", "CONFIG", "[", "args", ".", "data", "]", "\n", "logfile", "=", "'results/'", "+", "args", ".", "data", "+", "'-decoder.log'", "\n", "bags", "=", "Bags", ".", "load_tabcomma_format", "(", "DATA", "[", "0", "]", ")", "\n", "c_year", "=", "DATA", "[", "1", "]", "\n", "\n", "\n", "evaluate", "=", "Evaluation", "(", "bags", ",", "\n", "year", "=", "c_year", ",", "\n", "logfile", "=", "logfile", ")", ".", "setup", "(", "min_count", "=", "DATA", "[", "2", "]", ",", "\n", "min_elements", "=", "2", ")", "\n", "# print(\"Loading pre-trained embedding\", W2V_PATH)", "\n", "vectors", "=", "KeyedVectors", ".", "load_word2vec_format", "(", "W2V_PATH", ",", "binary", "=", "W2V_IS_BINARY", ")", "\n", "\n", "params", "=", "{", "\n", "'n_epochs'", ":", "100", ",", "\n", "'batch_size'", ":", "100", ",", "\n", "'optimizer'", ":", "'adam'", ",", "\n", "'normalize_inputs'", ":", "True", ",", "\n", "'prior'", ":", "'gauss'", ",", "\n", "}", "\n", "# 100 hidden units, 200 epochs, bernoulli prior, normalized inputs -> 0.174", "\n", "activations", "=", "[", "'ReLU'", ",", "'SELU'", "]", "\n", "lrs", "=", "[", "(", "0.001", ",", "0.0005", ")", ",", "(", "0.001", ",", "0.001", ")", "]", "\n", "hcs", "=", "[", "(", "100", ",", "50", ")", ",", "(", "300", ",", "100", ")", "]", "\n", "\n", "# dropouts = [(.2,.2), (.1,.1), (.1, .2), (.25, .25), (.3,.3)] # .2,.2 is best", "\n", "# priors = ['categorical'] # gauss is best", "\n", "# normal = [True, False]", "\n", "# bernoulli was good, letz see if categorical is better... No", "\n", "import", "itertools", "\n", "models", "=", "[", "AAERecommender", "(", "**", "params", ",", "n_hidden", "=", "hc", "[", "0", "]", ",", "n_code", "=", "hc", "[", "1", "]", ",", "\n", "use_title", "=", "ut", ",", "embedding", "=", "vectors", ",", "\n", "gen_lr", "=", "lr", "[", "0", "]", ",", "reg_lr", "=", "lr", "[", "1", "]", ",", "activation", "=", "a", ")", "\n", "for", "ut", ",", "lr", ",", "hc", ",", "a", "in", "itertools", ".", "product", "(", "(", "True", ",", "False", ")", ",", "lrs", ",", "hcs", ",", "activations", ")", "]", "\n", "# models = [DecodingRecommender(embedding=vectors)]", "\n", "evaluate", "(", "models", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.utils.compute_mutual_info": [[10, 72], ["isinstance", "print", "bags.tocsr", "print", "numpy.asarray", "print", "print", "print", "print", "sklearn.metrics.mutual_info_score", "print", "print", "isinstance", "print", "bags.get_attributes", "conditions.fit_transform", "print", "scipy.stats.entropy", "print", "print", "list", "conditions.keys", "print", "conditions.encode_impose", "print", "conditions.encode", "numpy.asarray().ravel", "conditions.keys", "list", "zip", "conditions.values", "cond.impose", "numpy.asarray", "cond.impose.sum"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.impose"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "L2Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "loss", "=", "nn", ".", "MSELoss", "(", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "loss", "=", "self", ".", "loss", ".", "cuda", "(", ")", "\n", "", "self", ".", "register_buffer", "(", "'target'", ",", "torch", ".", "tensor", "(", "0.0", ")", ")", "\n", "\n", "", "def", "get_target_tensor", "(", "self", ",", "input", ")", ":", "\n", "        ", "target_tensor", "=", "self", ".", "target", "\n", "\n", "return", "target_tensor", ".", "expand_as", "(", "input", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "input", ")", ":", "\n", "        ", "target_tensor", "=", "self", ".", "get_target_tensor", "(", "input", ")", "\n", "return", "self", ".", "loss", "(", "input", ",", "target_tensor", ")", "\n", "\n", "\n", "", "", "def", "file_len", "(", "fname", ")", ":", "\n", "    ", "with", "open", "(", "fname", ")", "as", "f", ":", "\n", "        ", "for", "i", ",", "l", "in", "enumerate", "(", "f", ")", ":", "\n", "            ", "pass", "\n", "", "", "return", "i", "+", "1", "\n", "\n", "\n", "# Get batch data from training set", "\n", "", "def", "get_batch_data", "(", "file", ",", "index", ",", "size", ")", ":", "# 1,5->1,2,3,4,5", "\n", "    ", "user", "=", "[", "]", "\n", "item", "=", "[", "]", "\n", "label", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "index", ",", "index", "+", "size", ")", ":", "\n", "        ", "line", "=", "linecache", ".", "getline", "(", "file", ",", "i", ")", "\n", "line", "=", "line", ".", "strip", "(", ")", "\n", "line", "=", "line", ".", "split", "(", ")", "\n", "user", ".", "append", "(", "int", "(", "line", "[", "0", "]", ")", ")", "\n", "user", ".", "append", "(", "int", "(", "line", "[", "0", "]", ")", ")", "\n", "item", ".", "append", "(", "int", "(", "line", "[", "1", "]", ")", ")", "\n", "item", ".", "append", "(", "int", "(", "line", "[", "2", "]", ")", ")", "\n", "label", ".", "append", "(", "1.", ")", "\n", "label", ".", "append", "(", "0.", ")", "\n", "", "return", "user", ",", "item", ",", "label", "\n", "\n", "\n", "", "def", "precision_at_k", "(", "r", ",", "k", ")", ":", "\n", "    ", "\"\"\"Score is precision @ k\n    Relevance is binary (nonzero is relevant).\n    Returns:\n        Precision @ k\n    Raises:\n        ValueError: len(r) must be >= k\n    \"\"\"", "\n", "assert", "k", ">=", "1", "\n", "r", "=", "np", ".", "asarray", "(", "r", ")", "[", ":", "k", "]", "\n", "return", "np", ".", "mean", "(", "r", ")", "\n", "\n", "\n", "", "def", "average_precision", "(", "r", ")", ":", "\n", "    ", "\"\"\"Score is average precision (area under PR curve)\n    Relevance is binary (nonzero is relevant).\n    Returns:\n        Average precision\n    \"\"\"", "\n", "r", "=", "np", ".", "asarray", "(", "r", ")", "\n", "out", "=", "[", "precision_at_k", "(", "r", ",", "k", "+", "1", ")", "for", "k", "in", "range", "(", "r", ".", "size", ")", "if", "r", "[", "k", "]", "]", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Metric.__init__": [[62, 64], ["abc.ABC.__init__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Metric.__call__": [[65, 68], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "y_true", ",", "y_pred", ",", "average", "=", "True", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.RankingMetric.__init__": [[76, 79], ["kwargs.pop", "evaluation.Metric.__init__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "k", "=", "kwargs", ".", "pop", "(", "'k'", ",", "None", ")", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.RankingMetric.__call__": [[80, 92], ["evaluation.argtopk"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.argtopk"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_pred", ",", "average", "=", "True", ")", ":", "\n", "        ", "\"\"\" Gets relevance scores,\n        Sort based on y_pred, then lookup in y_true\n        >>> Y_true = np.array([[1,0,0],[0,0,1]])\n        >>> Y_pred = np.array([[0.2,0.3,0.1],[0.2,0.5,0.7]])\n        >>> RankingMetric(k=2)(Y_true, Y_pred)\n        array([[0, 1],\n               [1, 0]])\n        \"\"\"", "\n", "ind", "=", "argtopk", "(", "y_pred", ",", "self", ".", "k", ")", "\n", "rs", "=", "y_true", "[", "ind", "]", "\n", "return", "rs", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.MRR.__init__": [[109, 111], ["evaluation.RankingMetric.__init__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "k", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "k", "=", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.MRR.__call__": [[112, 116], ["evaluation.RankingMetric.__call__", "rank_metrics_with_std.mean_reciprocal_rank"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.__call__", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.mean_reciprocal_rank"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_pred", ",", "average", "=", "True", ")", ":", "\n", "# compute mrr wrt k", "\n", "        ", "rs", "=", "super", "(", ")", ".", "__call__", "(", "y_true", ",", "y_pred", ")", "\n", "return", "rm", ".", "mean_reciprocal_rank", "(", "rs", ",", "average", "=", "average", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.MAP.__init__": [[120, 122], ["evaluation.RankingMetric.__init__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "k", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "k", "=", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.MAP.__call__": [[123, 143], ["evaluation.RankingMetric.__call__", "rank_metrics_with_std.mean_average_precision", "numpy.array", "rank_metrics_with_std.average_precision"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.__call__", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.mean_average_precision", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.rank_metrics_with_std.average_precision"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_pred", ",", "average", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        >>> Y_true = np.array([[1,0,0],[0,0,1]])\n        >>> Y_pred = np.array([[0.2,0.3,0.1],[0.2,0.5,0.7]])\n        >>> MAP(2)(Y_true, Y_pred)\n        (0.75, 0.25)\n        >>> Y_true = np.array([[1,0,1],[1,0,1]])\n        >>> Y_pred = np.array([[0.3,0.2,0.3],[0.6,0.5,0.7]])\n        >>> MAP(3)(Y_true, Y_pred)\n        (1.0, 0.0)\n        >>> Y_true = np.array([[1,0,1],[1,1,1]])\n        >>> Y_pred = np.array([[0.4,0.3,0.2],[0.4,0.3,0.2]])\n        >>> MAP(3)(Y_true, Y_pred)\n        (0.9166666666666666, 0.08333333333333337)\n        \"\"\"", "\n", "rs", "=", "super", "(", ")", ".", "__call__", "(", "y_true", ",", "y_pred", ")", "\n", "if", "average", ":", "\n", "            ", "return", "rm", ".", "mean_average_precision", "(", "rs", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "rm", ".", "average_precision", "(", "r", ")", "for", "r", "in", "rs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.P.__init__": [[146, 148], ["evaluation.RankingMetric.__init__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "k", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "k", "=", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.P.__call__": [[149, 165], ["evaluation.RankingMetric.__call__", "ps.mean", "ps.std"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.__call__"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_pred", ",", "average", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        >>> Y_true = np.array([[1,0,1,0],[1,0,1,0]])\n        >>> Y_pred = np.array([[0.2,0.3,0.1,0.05],[0.2,0.5,0.7,0.05]])\n        >>> P(2)(Y_true, Y_pred)\n        (0.5, 0.0)\n        >>> P(4)(Y_true, Y_pred)\n        (0.5, 0.0)\n        \"\"\"", "\n", "# compute p wrt k", "\n", "rs", "=", "super", "(", ")", ".", "__call__", "(", "y_true", ",", "y_pred", ")", "\n", "ps", "=", "(", "rs", ">", "0", ")", ".", "mean", "(", "axis", "=", "1", ")", "\n", "if", "average", ":", "\n", "            ", "return", "ps", ".", "mean", "(", ")", ",", "ps", ".", "std", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "ps", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.__init__": [[264, 278], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "dataset", ",", "\n", "year", ",", "\n", "metrics", "=", "METRICS", ",", "\n", "logfile", "=", "sys", ".", "stdout", ",", "\n", "logdir", "=", "None", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "year", "=", "year", "\n", "self", ".", "metrics", "=", "metrics", "\n", "self", ".", "logfile", "=", "logfile", "\n", "self", ".", "logdir", "=", "logdir", "\n", "\n", "self", ".", "train_set", ",", "self", ".", "test_set", "=", "None", ",", "None", "\n", "self", ".", "x_test", ",", "self", ".", "y_test", "=", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.setup": [[279, 329], ["evaluation.maybe_open", "random.seed", "numpy.random.seed", "evaluation.Evaluation.dataset.train_test_split", "print", "print", "print", "print", "train_set.build_vocab.build_vocab.build_vocab", "test_set.apply_vocab.apply_vocab.apply_vocab", "train_set.build_vocab.build_vocab.prune_", "test_set.apply_vocab.apply_vocab.prune_", "print", "print", "print", "print", "datasets.corrupt_sets", "print", "evaluation.maybe_close", "transforms.lists2sparse().tocsr", "transforms.lists2sparse().tocsr", "len", "len", "len", "transforms.lists2sparse", "transforms.lists2sparse", "test_set.apply_vocab.apply_vocab.size", "train_set.build_vocab.build_vocab.size"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.maybe_open", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.train_test_split", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.prune_", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.prune_", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.corrupt_sets", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.maybe_close", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2sparse", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2sparse", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "setup", "(", "self", ",", "seed", "=", "42", ",", "min_elements", "=", "1", ",", "max_features", "=", "None", ",", "\n", "min_count", "=", "None", ",", "drop", "=", "1", ")", ":", "\n", "\n", "        ", "self", ".", "min_elements", "=", "min_elements", "\n", "self", ".", "max_features", "=", "max_features", "\n", "self", ".", "min_count", "=", "min_count", "\n", "self", ".", "drop", "=", "drop", "\n", "\n", "# we could specify split criterion and drop choice here", "\n", "\"\"\" Splits and corrupts the data accordion to criterion \"\"\"", "\n", "log_fh", "=", "maybe_open", "(", "self", ".", "logfile", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "# train_set, test_set = self.dataset.split(self.split_test,", "\n", "#                                          self.split_train)", "\n", "train_set", ",", "test_set", "=", "self", ".", "dataset", ".", "train_test_split", "(", "on_year", "=", "self", ".", "year", ")", "\n", "print", "(", "\"=\"", "*", "80", ",", "file", "=", "log_fh", ")", "\n", "print", "(", "\"Train:\"", ",", "train_set", ",", "file", "=", "log_fh", ")", "\n", "print", "(", "\"Test:\"", ",", "test_set", ",", "file", "=", "log_fh", ")", "\n", "print", "(", "\"Next Pruning:\\n\\tmin_count: {}\\n\\tmax_features: {}\\n\\tmin_elements: {}\"", "\n", ".", "format", "(", "min_count", ",", "max_features", ",", "min_elements", ")", ",", "file", "=", "log_fh", ")", "\n", "train_set", "=", "train_set", ".", "build_vocab", "(", "min_count", "=", "min_count", ",", "\n", "max_features", "=", "max_features", ",", "\n", "apply", "=", "True", ")", "\n", "test_set", "=", "test_set", ".", "apply_vocab", "(", "train_set", ".", "vocab", ")", "\n", "# Train and test sets are now BagsWithVocab", "\n", "train_set", ".", "prune_", "(", "min_elements", "=", "min_elements", ")", "\n", "test_set", ".", "prune_", "(", "min_elements", "=", "min_elements", ")", "\n", "print", "(", "\"Train:\"", ",", "train_set", ",", "file", "=", "log_fh", ")", "\n", "print", "(", "\"Test:\"", ",", "test_set", ",", "file", "=", "log_fh", ")", "\n", "print", "(", "\"Drop parameter:\"", ",", "drop", ")", "\n", "print", "(", "\"Drop parameter:\"", ",", "drop", ",", "file", "=", "log_fh", ")", "\n", "\n", "noisy", ",", "missing", "=", "corrupt_sets", "(", "test_set", ".", "data", ",", "drop", "=", "drop", ")", "\n", "\n", "assert", "len", "(", "noisy", ")", "==", "len", "(", "missing", ")", "==", "len", "(", "test_set", ")", "\n", "\n", "test_set", ".", "data", "=", "noisy", "\n", "print", "(", "\"-\"", "*", "80", ",", "file", "=", "log_fh", ")", "\n", "maybe_close", "(", "log_fh", ")", "\n", "\n", "# THE GOLD", "\n", "self", ".", "y_test", "=", "lists2sparse", "(", "missing", ",", "test_set", ".", "size", "(", "1", ")", ")", ".", "tocsr", "(", "copy", "=", "False", ")", "\n", "\n", "self", ".", "train_set", "=", "train_set", "\n", "self", ".", "test_set", "=", "test_set", "\n", "\n", "# just store for not recomputing the stuff", "\n", "self", ".", "x_test", "=", "lists2sparse", "(", "noisy", ",", "train_set", ".", "size", "(", "1", ")", ")", ".", "tocsr", "(", "copy", "=", "False", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.__call__": [[330, 405], ["UserWarning", "os.makedirs", "os.path.join", "os.path.join", "scipy.save_npz", "evaluation.maybe_open", "print", "evaluation.maybe_close", "evaluation.Evaluation.train_set.clone", "evaluation.Evaluation.test_set.clone", "timeit.default_timer", "recommender.train", "evaluation.maybe_open", "print", "timeit.default_timer", "recommender.predict", "scipy.issparse", "evaluation.remove_non_missing", "print", "timeit.default_timer", "evaluation.evaluate", "print", "print", "zip", "print", "print", "evaluation.maybe_close", "open", "print", "wandb.init", "vars().items", "numpy.asarray.toarray", "numpy.asarray", "timeit.default_timer", "os.path.join", "numpy.save", "print", "print", "wandb.init.finish", "setattr", "datetime.timedelta", "datetime.timedelta", "repr", "datetime.timedelta", "wandb.log", "datetime.timedelta", "vars", "datetime.timedelta", "timeit.default_timer", "timeit.default_timer", "timeit.default_timer", "timeit.default_timer", "timeit.default_timer"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.maybe_open", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.maybe_close", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.clone", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.clone", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.maybe_open", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.predict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.remove_non_missing", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.evaluate", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.maybe_close", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log"], ["", "def", "__call__", "(", "self", ",", "recommenders", ",", "batch_size", "=", "None", ")", ":", "\n", "        ", "if", "None", "in", "(", "self", ".", "train_set", ",", "self", ".", "test_set", ",", "self", ".", "x_test", ",", "self", ".", "y_test", ")", ":", "\n", "            ", "raise", "UserWarning", "(", "\"Call .setup() before running the experiment\"", ")", "\n", "\n", "", "if", "self", ".", "logdir", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "logdir", ",", "exist_ok", "=", "True", ")", "\n", "vocab_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "logdir", ",", "\"vocab.txt\"", ")", "\n", "with", "open", "(", "vocab_path", ",", "'w'", ")", "as", "vocab_fh", ":", "\n", "                ", "print", "(", "*", "self", ".", "train_set", ".", "index2token", ",", "sep", "=", "'\\n'", ",", "file", "=", "vocab_fh", ")", "\n", "", "gold_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "logdir", ",", "\"gold\"", ")", "\n", "sp", ".", "save_npz", "(", "gold_path", ",", "self", ".", "y_test", ")", "\n", "\n", "", "for", "recommender", "in", "recommenders", ":", "\n", "            ", "if", "wandb_is_available", ":", "\n", "                ", "run", "=", "wandb", ".", "init", "(", "project", "=", "\"aaerec\"", ",", "reinit", "=", "True", ")", "\n", "wandb", ".", "config", ".", "dataset", "=", "self", ".", "dataset", "\n", "wandb", ".", "config", ".", "year", "=", "self", ".", "year", "\n", "wandb", ".", "config", ".", "min_elements", "=", "self", ".", "min_elements", "\n", "wandb", ".", "config", ".", "max_features", "=", "self", ".", "max_features", "\n", "wandb", ".", "config", ".", "min_count", "=", "self", ".", "min_count", "\n", "wandb", ".", "config", ".", "drop", "=", "self", ".", "drop", "\n", "wandb", ".", "config", ".", "model_class", "=", "recommender", ".", "__class__", ".", "__name__", "\n", "for", "attr", ",", "value", "in", "vars", "(", "recommender", ")", ".", "items", "(", ")", ":", "\n", "                    ", "setattr", "(", "wandb", ".", "config", ",", "attr", ",", "value", ")", "\n", "", "", "log_fh", "=", "maybe_open", "(", "self", ".", "logfile", ")", "\n", "print", "(", "recommender", ",", "file", "=", "log_fh", ")", "\n", "maybe_close", "(", "log_fh", ")", "\n", "train_set", "=", "self", ".", "train_set", ".", "clone", "(", ")", "\n", "test_set", "=", "self", ".", "test_set", ".", "clone", "(", ")", "\n", "t_0", "=", "timer", "(", ")", "\n", "recommender", ".", "train", "(", "train_set", ")", "\n", "log_fh", "=", "maybe_open", "(", "self", ".", "logfile", ")", "\n", "print", "(", "\"Training took {} seconds.\"", "\n", ".", "format", "(", "timedelta", "(", "seconds", "=", "timer", "(", ")", "-", "t_0", ")", ")", ",", "file", "=", "log_fh", ")", "\n", "\n", "t_1", "=", "timer", "(", ")", "\n", "y_pred", "=", "recommender", ".", "predict", "(", "test_set", ")", "\n", "if", "sp", ".", "issparse", "(", "y_pred", ")", ":", "\n", "                ", "y_pred", "=", "y_pred", ".", "toarray", "(", ")", "\n", "", "else", ":", "\n", "# dont hide that we are assuming an ndarray to be returned", "\n", "                ", "y_pred", "=", "np", ".", "asarray", "(", "y_pred", ")", "\n", "\n", "# set likelihood of documents that are already cited to zero, so", "\n", "# they don't influence evaluation", "\n", "", "y_pred", "=", "remove_non_missing", "(", "y_pred", ",", "self", ".", "x_test", ",", "copy", "=", "True", ")", "\n", "\n", "print", "(", "\"Prediction took {} seconds.\"", "\n", ".", "format", "(", "timedelta", "(", "seconds", "=", "timer", "(", ")", "-", "t_1", ")", ")", ",", "file", "=", "log_fh", ")", "\n", "\n", "if", "self", ".", "logdir", ":", "\n", "                ", "t_1", "=", "timer", "(", ")", "\n", "pred_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "logdir", ",", "repr", "(", "recommender", ")", ")", "\n", "np", ".", "save", "(", "pred_file", ",", "y_pred", ")", "\n", "print", "(", "\"Storing predictions took {} seconds.\"", "\n", ".", "format", "(", "timedelta", "(", "seconds", "=", "timer", "(", ")", "-", "t_1", ")", ")", ",", "file", "=", "log_fh", ")", "\n", "\n", "", "t_1", "=", "timer", "(", ")", "\n", "results", "=", "evaluate", "(", "self", ".", "y_test", ",", "y_pred", ",", "metrics", "=", "self", ".", "metrics", ",", "batch_size", "=", "batch_size", ")", "\n", "print", "(", "\"Evaluation took {} seconds.\"", "\n", ".", "format", "(", "timedelta", "(", "seconds", "=", "timer", "(", ")", "-", "t_1", ")", ")", ",", "file", "=", "log_fh", ")", "\n", "\n", "print", "(", "\"\\nResults:\\n\"", ",", "file", "=", "log_fh", ")", "\n", "for", "metric", ",", "(", "mean", ",", "std", ")", "in", "zip", "(", "self", ".", "metrics", ",", "results", ")", ":", "\n", "                ", "print", "(", "\"- {}: {} ({})\"", ".", "format", "(", "metric", ",", "mean", ",", "std", ")", ",", "\n", "file", "=", "log_fh", ")", "\n", "if", "wandb_is_available", ":", "\n", "                    ", "wandb", ".", "log", "(", "{", "metric", ":", "mean", ",", "metric", "+", "\"-SD\"", ":", "std", "}", ")", "\n", "\n", "", "", "print", "(", "\"\\nOverall time: {} seconds.\"", "\n", ".", "format", "(", "timedelta", "(", "seconds", "=", "timer", "(", ")", "-", "t_0", ")", ")", ",", "file", "=", "log_fh", ")", "\n", "print", "(", "'-'", "*", "79", ",", "file", "=", "log_fh", ")", "\n", "maybe_close", "(", "log_fh", ")", "\n", "if", "wandb_is_available", ":", "\n", "                ", "run", ".", "finish", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.argtopk": [[20, 59], ["len", "numpy.arange", "numpy.argpartition", "numpy.argsort", "numpy.argsort"], "function", ["None"], ["", "def", "argtopk", "(", "X", ",", "k", ")", ":", "\n", "    ", "\"\"\"\n    Picks the top k elements of (sparse) matrix X\n\n    >>> X = np.arange(10).reshape(1, -1)\n    >>> i = argtopk(X, 3)\n    >>> i\n    (array([[0]]), array([[9, 8, 7]]))\n    >>> X[argtopk(X, 3)]\n    array([[9, 8, 7]])\n    >>> X = np.arange(20).reshape(2,10)\n    >>> ix, iy = argtopk(X, 3)\n    >>> ix\n    array([[0],\n           [1]])\n    >>> iy\n    array([[9, 8, 7],\n           [9, 8, 7]])\n    >>> X[ix, iy]\n    array([[ 9,  8,  7],\n           [19, 18, 17]])\n    >>> X = np.arange(6).reshape(2,3)\n    >>> X[argtopk(X, 123123)]\n    array([[2, 1, 0],\n           [5, 4, 3]])\n    \"\"\"", "\n", "assert", "len", "(", "X", ".", "shape", ")", "==", "2", ",", "\"X should be two-dimensional array-like\"", "\n", "rows", "=", "np", ".", "arange", "(", "X", ".", "shape", "[", "0", "]", ")", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "if", "k", "is", "None", "or", "k", ">=", "X", ".", "size", ":", "\n", "        ", "ind", "=", "np", ".", "argsort", "(", "X", ",", "axis", "=", "1", ")", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "return", "rows", ",", "ind", "\n", "\n", "", "assert", "k", ">", "0", ",", "\"k should be positive integer or None\"", "\n", "\n", "\n", "ind", "=", "np", ".", "argpartition", "(", "X", ",", "-", "k", ",", "axis", "=", "1", ")", "[", ":", ",", "-", "k", ":", "]", "\n", "# sort indices depending on their X values", "\n", "cols", "=", "ind", "[", "rows", ",", "np", ".", "argsort", "(", "X", "[", "rows", ",", "ind", "]", ",", "axis", "=", "1", ")", "]", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "return", "rows", ",", "cols", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.remove_non_missing": [[183, 200], ["sklearn.preprocessing.minmax_scale", "X_test.nonzero"], "function", ["None"], ["def", "remove_non_missing", "(", "Y_pred", ",", "X_test", ",", "copy", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Scales the predicted values between 0 and 1 and  sets the known values to\n    zero.\n    >>> Y_pred = np.array([[0.6,0.5,-1], [40,-20,10]])\n    >>> X_test = np.array([[1, 0, 1], [0, 1, 0]])\n    >>> remove_non_missing(Y_pred, X_test)\n    array([[0.    , 0.9375, 0.    ],\n           [1.    , 0.    , 0.5   ]])\n    \"\"\"", "\n", "Y_pred_scaled", "=", "minmax_scale", "(", "Y_pred", ",", "\n", "feature_range", "=", "(", "0", ",", "1", ")", ",", "\n", "axis", "=", "1", ",", "# Super important!", "\n", "copy", "=", "copy", ")", "\n", "# we remove the ones that were already present in the orig set", "\n", "Y_pred_scaled", "[", "X_test", ".", "nonzero", "(", ")", "]", "=", "0.", "\n", "return", "Y_pred_scaled", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.evaluate": [[202, 241], ["int", "range", "scipy.issparse", "scipy.issparse", "callable", "min", "scipy.issparse", "scipy.issparse", "enumerate", "ground_truth.toarray.toarray", "predictions.toarray.toarray", "metric", "range", "pred_batch.toarray.toarray", "gold_batch.toarray.toarray", "results_per_metric[].extend", "x.mean", "x.std", "map", "len", "metric"], "function", ["None"], ["", "def", "evaluate", "(", "ground_truth", ",", "predictions", ",", "metrics", ",", "batch_size", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Main evaluation function, used by Evaluation class but can also be\n    reused to recompute metrics\n    \"\"\"", "\n", "\n", "n_samples", "=", "ground_truth", ".", "shape", "[", "0", "]", "\n", "assert", "predictions", ".", "shape", "[", "0", "]", "==", "n_samples", "\n", "\n", "metrics", "=", "[", "m", "if", "callable", "(", "m", ")", "else", "METRICS", "[", "m", "]", "for", "m", "in", "metrics", "]", "\n", "\n", "if", "batch_size", "is", "not", "None", ":", "\n", "        ", "batch_size", "=", "int", "(", "batch_size", ")", "\n", "\n", "# Important: Results consist of Mean + Std dev", "\n", "# Add all results per sample to array", "\n", "# Average later", "\n", "results_per_metric", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "metrics", ")", ")", "]", "\n", "for", "start", "in", "range", "(", "0", ",", "n_samples", ",", "batch_size", ")", ":", "\n", "            ", "end", "=", "min", "(", "start", "+", "batch_size", ",", "n_samples", ")", "\n", "pred_batch", "=", "predictions", "[", "start", ":", "end", ",", ":", "]", "\n", "gold_batch", "=", "ground_truth", "[", "start", ":", "end", ",", ":", "]", "\n", "if", "sp", ".", "issparse", "(", "pred_batch", ")", ":", "\n", "                ", "pred_batch", "=", "pred_batch", ".", "toarray", "(", ")", "\n", "", "if", "sp", ".", "issparse", "(", "gold_batch", ")", ":", "\n", "                ", "gold_batch", "=", "gold_batch", ".", "toarray", "(", ")", "\n", "\n", "", "for", "i", ",", "metric", "in", "enumerate", "(", "metrics", ")", ":", "\n", "                ", "results_per_metric", "[", "i", "]", ".", "extend", "(", "metric", "(", "gold_batch", ",", "pred_batch", ",", "average", "=", "False", ")", ")", "\n", "\n", "", "", "results", "=", "[", "(", "x", ".", "mean", "(", ")", ",", "x", ".", "std", "(", ")", ")", "for", "x", "in", "map", "(", "np", ".", "array", ",", "results_per_metric", ")", "]", "\n", "", "else", ":", "\n", "        ", "if", "sp", ".", "issparse", "(", "ground_truth", ")", ":", "\n", "            ", "ground_truth", "=", "ground_truth", ".", "toarray", "(", ")", "\n", "", "if", "sp", ".", "issparse", "(", "predictions", ")", ":", "\n", "            ", "predictions", "=", "predictions", ".", "toarray", "(", ")", "\n", "", "results", "=", "[", "metric", "(", "ground_truth", ",", "predictions", ")", "for", "metric", "in", "metrics", "]", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.reevaluate": [[243, 248], ["scipy.load_npz", "numpy.load", "evaluation.evaluate"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.evaluate"], ["", "def", "reevaluate", "(", "gold_file", ",", "predictions_file", ",", "metrics", ")", ":", "\n", "    ", "\"\"\" Recompute metrics from files \"\"\"", "\n", "Y_test", "=", "sp", ".", "load_npz", "(", "gold_file", ")", "\n", "Y_pred", "=", "np", ".", "load", "(", "predictions_file", ")", "\n", "return", "evaluate", "(", "Y_test", ",", "Y_pred", ",", "metrics", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.maybe_open": [[250, 255], ["open"], "function", ["None"], ["", "def", "maybe_open", "(", "logfile", ",", "mode", "=", "'a'", ")", ":", "\n", "    ", "\"\"\"\n    If logfile is something that can be opened, do so else return STDOUT\n    \"\"\"", "\n", "return", "open", "(", "logfile", ",", "mode", ")", "if", "logfile", "else", "sys", ".", "stdout", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.maybe_close": [[257, 261], ["log_fh.close"], "function", ["None"], ["", "def", "maybe_close", "(", "log_fh", ")", ":", "\n", "    ", "\"\"\" Close if log_fh is not STDOUT \"\"\"", "\n", "if", "log_fh", "is", "not", "sys", ".", "stdout", ":", "\n", "        ", "log_fh", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.AutoEncoderMixin.reconstruct": [[8, 12], ["ub.AutoEncoderMixin.transform", "ub.AutoEncoderMixin.inverse_transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.svd.SVDRecommender.inverse_transform"], ["def", "reconstruct", "(", "self", ",", "X", ",", "y", "=", "None", ")", ":", "\n", "        ", "\"\"\" Transform data, then inverse transform it \"\"\"", "\n", "hidden", "=", "self", ".", "transform", "(", "X", ")", "\n", "return", "self", ".", "inverse_transform", "(", "hidden", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.__init__": [[42, 53], ["sklearn.feature_extraction.text.TfidfVectorizer.__init__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "embedding", ",", "index2word", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Arguments\n        ---------\n\n        embedding: V x D embedding matrix\n        index2word: list of words with indices matching V\n        \"\"\"", "\n", "self", ".", "embedding", "=", "embedding", "\n", "super", "(", "EmbeddedVectorizer", ",", "self", ")", ".", "__init__", "(", "self", ",", "vocabulary", "=", "index2word", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit": [[54, 57], ["super().fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit"], ["", "def", "fit", "(", "self", ",", "raw_documents", ",", "y", "=", "None", ")", ":", "\n", "        ", "super", "(", "EmbeddedVectorizer", ",", "self", ")", ".", "fit", "(", "raw_documents", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform": [[58, 63], ["super().transform"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform"], ["", "def", "transform", "(", "self", ",", "raw_documents", ",", "__y", "=", "None", ")", ":", "\n", "        ", "sparse_scores", "=", "super", "(", "EmbeddedVectorizer", ",", "\n", "self", ")", ".", "transform", "(", "raw_documents", ")", "\n", "# Xt is sparse counts", "\n", "return", "sparse_scores", "@", "self", ".", "embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform": [[64, 66], ["ub.EmbeddedVectorizer.fit().transform", "ub.EmbeddedVectorizer.fit"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit"], ["", "def", "fit_transform", "(", "self", ",", "raw_documents", ",", "y", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "fit", "(", "raw_documents", ",", "y", ")", ".", "transform", "(", "raw_documents", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.__repr__": [[67, 69], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"Embedded Vectorizer with embedding shape {self.embedding.shape}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.GensimEmbeddedVectorizer.__init__": [[77, 88], ["ub.EmbeddedVectorizer.__init__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["def", "__init__", "(", "self", ",", "gensim_vectors", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Arguments\n        ---------\n        `gensim_vectors` is expected to have index2word and syn0 defined\n        \"\"\"", "\n", "index2word", "=", "gensim_vectors", ".", "index2word", "\n", "embedding", "=", "gensim_vectors", ".", "vectors", "\n", "super", "(", "GensimEmbeddedVectorizer", ",", "self", ")", ".", "__init__", "(", "embedding", ",", "\n", "index2word", ",", "\n", "**", "kwargs", ")", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.GensimEmbeddedVectorizer.__repr__": [[88, 90], ["ub.EmbeddedVectorizer.__repr__"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.GensimEmbeddedVectorizer.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"Gensim \"", "+", "super", "(", ")", ".", "__repr__", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.peek_word2vec_format": [[14, 36], ["gzip.open", "map", "open", "map", "next().strip().split", "next().strip().split", "next().strip", "next().strip", "next", "next"], "function", ["None"], ["", "", "def", "peek_word2vec_format", "(", "path", ",", "binary", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Function to peek at the first line of a serialized embedding in\n    word2vec format\n\n    Arguments\n    ---------\n    path: The path to the file to peek\n    binary: Whether the file is gzipped\n\n    Returns\n    -------\n    Tuple of ints split by white space in the first line,\n    i.e., for word2vec format the dimensions of the embedding.\n    \"\"\"", "\n", "if", "binary", ":", "\n", "        ", "import", "gzip", "\n", "with", "gzip", ".", "open", "(", "path", ",", "'r'", ")", "as", "peek", ":", "\n", "            ", "return", "map", "(", "int", ",", "next", "(", "peek", ")", ".", "strip", "(", ")", ".", "split", "(", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "with", "open", "(", "path", ",", "'r'", ")", "as", "peek", ":", "\n", "            ", "return", "map", "(", "int", ",", "next", "(", "peek", ")", ".", "strip", "(", ")", ".", "split", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.__init__": [[156, 172], ["len", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "data", ",", "\n", "owners", ",", "\n", "owner_attributes", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n\n        :param data: ???, ???\n        :param owners: iterable (prob list), of ids\n        :param owner_attributes: dict, of dicts in form of {attribute: {id: <unknown>}}\n        \"\"\"", "\n", "# TODO: think about: split between prediction relevant attributes and data splitting infos like year", "\n", "assert", "len", "(", "owners", ")", "==", "len", "(", "data", ")", "\n", "self", ".", "data", "=", "data", "\n", "self", ".", "bag_owners", "=", "owners", "\n", "# attributes are called by keys --> just adding new key will suffice", "\n", "self", ".", "owner_attributes", "=", "owner_attributes", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.clone": [[176, 185], ["datasets.Bags", "datasets.Bags.owner_attributes.items", "value_by_token.items"], "methods", ["None"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "\"\"\" Creates a really deep copy \"\"\"", "\n", "data", "=", "[", "[", "t", "for", "t", "in", "b", "]", "for", "b", "in", "self", ".", "data", "]", "\n", "bag_owners", "=", "[", "o", "for", "o", "in", "self", ".", "bag_owners", "]", "\n", "if", "self", ".", "owner_attributes", "is", "not", "None", ":", "\n", "            ", "owner_attributes", "=", "{", "attr", ":", "{", "token", ":", "value", "for", "token", ",", "value", "in", "value_by_token", ".", "items", "(", ")", "}", "\n", "for", "attr", ",", "value_by_token", "in", "self", ".", "owner_attributes", ".", "items", "(", ")", "}", "\n", "\n", "", "return", "Bags", "(", "data", ",", "bag_owners", ",", "owner_attributes", "=", "owner_attributes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.__len__": [[186, 188], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.__str__": [[189, 191], ["len", "datasets.Bags.numel"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.numel"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"{} records with {} ratings\"", ".", "format", "(", "len", "(", "self", ")", ",", "self", ".", "numel", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.__getitem__": [[192, 194], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "data", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.maxlen": [[195, 198], ["max", "map"], "methods", ["None"], ["", "def", "maxlen", "(", "self", ")", ":", "\n", "        ", "\"\"\" Returns the maximum bag length \"\"\"", "\n", "return", "max", "(", "map", "(", "len", ",", "self", ".", "data", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.numel": [[199, 202], ["sum", "map"], "methods", ["None"], ["", "def", "numel", "(", "self", ")", ":", "\n", "        ", "\"\"\" Computes the number of (non-zero) elements \"\"\"", "\n", "return", "sum", "(", "map", "(", "len", ",", "self", ".", "data", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_single_attribute": [[203, 226], ["ValueError", "attribute_l.append"], "methods", ["None"], ["", "def", "get_single_attribute", "(", "self", ",", "attribute", ")", ":", "\n", "# TODO: rename to get_attribute() again? at least check for all other calls", "\n", "# TODO: find representation in owner_attributes for doctex", "\n", "        ", "\"\"\"\n        Retrieves the attribute 'attribute' of each bag owner and returns them as a list\n        in the same order as self.bag_owners.\n        :param attribute: hashable (str), key in owner_attributes (~ side_info)\n        :return: vectorizable, ordered like Bag data containing respective attribute\n        \"\"\"", "\n", "if", "self", ".", "owner_attributes", "is", "None", "or", "self", ".", "bag_owners", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Owners not present\"", ")", "\n", "\n", "# find how attributes are used --> starting at top level to see what is needed", "\n", "# Answer: vectorizable", "\n", "# use it like before, it worked there", "\n", "\n", "\n", "\n", "", "attribute_l", "=", "[", "]", "\n", "for", "owner", "in", "self", ".", "bag_owners", ":", "\n", "            ", "attribute_l", ".", "append", "(", "self", ".", "owner_attributes", "[", "attribute", "]", "[", "owner", "]", ")", "\n", "\n", "", "return", "attribute_l", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_attributes": [[227, 229], ["datasets.Bags.get_single_attribute"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_single_attribute"], ["", "def", "get_attributes", "(", "self", ",", "attribute_list", ")", ":", "\n", "        ", "return", "[", "self", ".", "get_single_attribute", "(", "a", ")", "for", "a", "in", "attribute_list", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.to_dict": [[230, 232], ["dict", "enumerate"], "methods", ["None"], ["", "def", "to_dict", "(", "self", ")", ":", "\n", "        ", "return", "dict", "(", "enumerate", "(", "self", ".", "data", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.load_tabcomma_format": [[233, 324], ["pandas.read_csv", "df.fillna.fillna.fillna", "list", "dict", "print", "list", "print", "range", "datasets.Bags", "map", "print", "len", "meta_vals.append", "len", "enumerate", "meta_data_dic.keys", "list", "print", "pandas.read_csv.iterrows", "print", "pandas.read_csv", "print", "dict.update", "x.split", "set", "df[].count", "len", "collections.defaultdict", "zip", "datasets.Bags.load_tabcomma_format.iterate_metadata"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "load_tabcomma_format", "(", "self", ",", "path", ",", "meta_data_dic", "=", "False", ",", "unique", "=", "False", ",", "owner_str", "=", "\"owner\"", ",", "set_str", "=", "\"set\"", ")", ":", "\n", "        ", "\"\"\"\n\n        Returns ordered lists for Owner, Set of Owner and a\n        Arguments\n        =========\n\n        \"\"\"", "\n", "# loading", "\n", "\n", "df", "=", "pd", ".", "read_csv", "(", "path", ",", "sep", "=", "\"\\t\"", ",", "dtype", "=", "str", ",", "error_bad_lines", "=", "False", ")", "\n", "df", "=", "df", ".", "fillna", "(", "\"\"", ")", "\n", "\n", "set_owners", "=", "df", "[", "owner_str", "]", ".", "values", "\n", "sets", "=", "df", "[", "set_str", "]", ".", "values", "\n", "sets", "=", "list", "(", "map", "(", "lambda", "x", ":", "x", ".", "split", "(", "\",\"", ")", ",", "sets", ")", ")", "\n", "if", "unique", ":", "\n", "            ", "print", "(", "\"Making items unique within user.\"", ")", "\n", "sets", "=", "[", "list", "(", "set", "(", "s", ")", ")", "for", "s", "in", "sets", "]", "\n", "\n", "\n", "", "owner_attributes", "=", "dict", "(", ")", "\n", "print", "(", "\"Found\"", ",", "len", "(", "sets", ")", ",", "'rows'", ")", "\n", "\n", "header", "=", "list", "(", "df", ".", "columns", ".", "values", ")", "\n", "fields_freqs", "=", "[", "\"{}={}\"", ".", "format", "(", "h", ",", "df", "[", "h", "]", ".", "count", "(", ")", "/", "len", "(", "df", ")", ")", "for", "h", "in", "header", "]", "\n", "print", "(", "\"Metadata-fields' frequencies: \"", "+", "\", \"", ".", "join", "(", "fields_freqs", ")", ")", "\n", "\n", "meta_vals", "=", "[", "]", "\n", "for", "meta_header", "in", "header", "[", "2", ":", "]", ":", "\n", "            ", "meta_vals", ".", "append", "(", "df", "[", "meta_header", "]", ".", "values", ")", "\n", "#print(\"with\", len(header) - 2, \"metadata columns.\")", "\n", "\n", "", "for", "i", "in", "range", "(", "2", ",", "len", "(", "header", ")", ")", ":", "\n", "            ", "owner_attributes", "[", "header", "[", "i", "]", "]", "=", "{", "}", "\n", "for", "j", ",", "owner", "in", "enumerate", "(", "set_owners", ")", ":", "\n", "                ", "owner_attributes", "[", "header", "[", "i", "]", "]", "[", "owner", "]", "=", "meta_vals", "[", "i", "-", "2", "]", "[", "j", "]", "\n", "\n", "\n", "", "", "if", "meta_data_dic", ":", "\n", "\n", "\n", "            ", "def", "iterate_metadata", "(", "meta_data", ",", "mtdt_transform_table", ")", ":", "\n", "                ", "\"\"\"\n                    accumulates lists for specified attributes per \"owner\"\n                    Warning: not working if dependent on other additional keys\n                :param meta_data: pandas DataFrame with the columns for each attribute\n                :param mtdt_transform_table: a dictionary with information which attributes are relevant\n                    # key: name of a table\n                    # owner_id: ID of citing paper\n                    # fields: list of column names in table\n                    # target names: key for these data in the owner_attributes dictionary\n                    # path: absolute path to the csv file\n                :return: dict owner_attributes[<attr_name>][<documentID>].append(<attribute(s)>)\n                \"\"\"", "\n", "print", "(", "\"create dict from df\"", ")", "\n", "owner_attributes", "=", "{", "}", "\n", "for", "target_attr_name", "in", "mtdt_transform_table", "[", "\"target_names\"", "]", ":", "\n", "                    ", "owner_attributes", "[", "target_attr_name", "]", "=", "defaultdict", "(", "list", ")", "\n", "\n", "", "for", "index", ",", "row", "in", "meta_data", ".", "iterrows", "(", ")", ":", "\n", "# owner_attributes[<attr_name>][<documentID>].append(<attribute(s)>)", "\n", "                    ", "for", "attr", ",", "target_name", "in", "zip", "(", "mtdt_transform_table", "[", "\"fields\"", "]", ",", "mtdt_transform_table", "[", "\"target_names\"", "]", ")", ":", "\n", "                        ", "owner_id", "=", "row", "[", "mtdt_transform_table", "[", "\"owner_id\"", "]", "]", "\n", "attr_value", "=", "row", "[", "attr", "]", "\n", "owner_attributes", "[", "target_name", "]", "[", "owner_id", "]", ".", "append", "(", "attr_value", ")", "\n", "\n", "\n", "\n", "", "", "print", "(", "\"creating dict finished\"", ")", "\n", "return", "owner_attributes", "\n", "\n", "# loads each table from file, selects the relevant attributes and adds them to the owner_attributes", "\n", "", "for", "key", "in", "meta_data_dic", ".", "keys", "(", ")", ":", "\n", "                ", "mtdt_transform_table", "=", "meta_data_dic", "[", "key", "]", "\n", "# loading meta data and select the relevant", "\n", "auth_path", "=", "mtdt_transform_table", "[", "\"path\"", "]", "\n", "meta_data", "=", "pd", ".", "read_csv", "(", "auth_path", ",", "error_bad_lines", "=", "False", ",", "dtype", "=", "str", ")", "\n", "print", "(", "\"Metadata-fields' frequencies: {}={}\"", ".", "format", "(", "key", ",", "\n", "meta_data", "[", "mtdt_transform_table", "[", "\"owner_id\"", "]", "]", ".", "nunique", "(", ")", "/", "len", "(", "df", ")", ")", ")", "\n", "\n", "targets", "=", "[", "mtdt_transform_table", "[", "\"owner_id\"", "]", "]", "+", "mtdt_transform_table", "[", "\"fields\"", "]", "\n", "meta_data", "=", "meta_data", "[", "targets", "]", "\n", "# add the additional attributes", "\n", "\n", "owner_attributes", ".", "update", "(", "iterate_metadata", "(", "meta_data", ",", "mtdt_transform_table", ")", ")", "\n", "\n", "", "", "bags", "=", "Bags", "(", "sets", ",", "set_owners", ",", "owner_attributes", "=", "owner_attributes", ")", "\n", "\n", "return", "bags", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.train_test_split": [[325, 353], ["print", "list", "datasets.Bags", "datasets.Bags", "print", "int", "datasets.split_by_mask", "datasets.split_by_mask", "print", "sklearn.model_selection.train_test_split", "datasets.Bags.owner_attributes.keys", "len", "len", "int", "datasets.Bags.get_single_attribute"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.split_by_mask", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.split_by_mask", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.train_test_split", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.get_single_attribute"], ["", "def", "train_test_split", "(", "self", ",", "on_year", "=", "None", ",", "**", "split_params", ")", ":", "\n", "        ", "\"\"\" Returns one training bag instance and one test bag instance.\n        Builds the vocabulary from the training set.\n\n        :param on_year: int, split on this year\n        :param **split_params:\n        :return: tuple, first training bag instance, second test bag instance\n        \"\"\"", "\n", "if", "on_year", "is", "not", "None", ":", "\n", "            ", "print", "(", "\"Splitting data on year:\"", ",", "on_year", ")", "\n", "assert", "self", ".", "owner_attributes", "[", "'year'", "]", ",", "\"Cant split on non-existing 'year'\"", "\n", "on_year", "=", "int", "(", "on_year", ")", "\n", "is_train", "=", "[", "int", "(", "y", ")", "<", "on_year", "for", "y", "in", "self", ".", "get_single_attribute", "(", "'year'", ")", "]", "\n", "train_data", ",", "test_data", "=", "split_by_mask", "(", "self", ".", "data", ",", "is_train", ")", "\n", "train_owners", ",", "test_owners", "=", "split_by_mask", "(", "self", ".", "bag_owners", ",", "is_train", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Splitting on params:\"", ",", "split_params", ")", "\n", "split", "=", "train_test_split", "(", "self", ".", "data", ",", "self", ".", "bag_owners", ",", "**", "split_params", ")", "\n", "train_data", ",", "test_data", ",", "train_owners", ",", "test_owners", "=", "split", "\n", "", "print", "(", "\"{} train, {} test documents.\"", ".", "format", "(", "len", "(", "train_data", ")", ",", "len", "(", "test_data", ")", ")", ")", "\n", "metadata_columns", "=", "list", "(", "self", ".", "owner_attributes", ".", "keys", "(", ")", ")", "\n", "train_attributes", "=", "{", "k", ":", "{", "owner", ":", "self", ".", "owner_attributes", "[", "k", "]", "[", "owner", "]", "for", "owner", "in", "\n", "train_owners", "}", "for", "k", "in", "metadata_columns", "}", "\n", "test_attributes", "=", "{", "k", ":", "{", "owner", ":", "self", ".", "owner_attributes", "[", "k", "]", "[", "owner", "]", "for", "owner", "in", "\n", "test_owners", "}", "for", "k", "in", "metadata_columns", "}", "\n", "train_set", "=", "Bags", "(", "train_data", ",", "train_owners", ",", "owner_attributes", "=", "train_attributes", ")", "\n", "test_set", "=", "Bags", "(", "test_data", ",", "test_owners", ",", "owner_attributes", "=", "test_attributes", ")", "\n", "return", "train_set", ",", "test_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.build_vocab": [[354, 364], ["datasets.Bags.build_vocab"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab"], ["", "def", "build_vocab", "(", "self", ",", "min_count", "=", "None", ",", "max_features", "=", "None", ",", "apply", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Returns BagsWithVocab instance if apply is True, else vocabulary along with counts.\n        \"\"\"", "\n", "vocab", ",", "counts", "=", "build_vocab", "(", "self", ".", "data", ",", "min_count", "=", "min_count", ",", "\n", "max_features", "=", "max_features", ")", "\n", "if", "apply", ":", "\n", "            ", "return", "self", ".", "apply_vocab", "(", "vocab", ")", "\n", "\n", "", "return", "vocab", ",", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.apply_vocab": [[366, 373], ["datasets.filter_apply_vocab", "datasets.BagsWithVocab"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.filter_apply_vocab"], ["", "def", "apply_vocab", "(", "self", ",", "vocab", ")", ":", "\n", "        ", "\"\"\"\n        Applies `vocab` and returns `BagsWithVocab` instance\n        \"\"\"", "\n", "data_ix", "=", "filter_apply_vocab", "(", "self", ".", "data", ",", "vocab", ")", "\n", "return", "BagsWithVocab", "(", "data_ix", ",", "vocab", ",", "owners", "=", "self", ".", "bag_owners", ",", "\n", "attributes", "=", "self", ".", "owner_attributes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.prune_": [[374, 388], ["datasets.filter_length", "list", "datasets.Bags.owner_attributes.keys"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.filter_length"], ["", "def", "prune_", "(", "self", ",", "min_elements", "=", "0", ")", ":", "\n", "        ", "\"\"\" Prunes data and set_owners according such that only rows with\n        min_elements in data are retained \"\"\"", "\n", "data", "=", "self", ".", "data", "\n", "owners", "=", "self", ".", "bag_owners", "\n", "if", "min_elements", ":", "\n", "            ", "data", ",", "owners", "=", "filter_length", "(", "data", ",", "min_elements", ",", "owners", ")", "\n", "attributes", "=", "{", "k", ":", "{", "owner", ":", "self", ".", "owner_attributes", "[", "k", "]", "[", "owner", "]", "for", "owner", "\n", "in", "owners", "}", "for", "k", "in", "\n", "list", "(", "self", ".", "owner_attributes", ".", "keys", "(", ")", ")", "}", "\n", "", "self", ".", "data", "=", "data", "\n", "self", ".", "bag_owners", "=", "owners", "\n", "self", ".", "owner_attributes", "=", "attributes", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.inflate": [[389, 415], ["DeprecationWarning", "range", "datasets.Bags.data.extend", "datasets.Bags.bag_owners.extend"], "methods", ["None"], ["", "def", "inflate", "(", "self", ",", "factor", ")", ":", "\n", "# TODO FIXME", "\n", "        ", "\"\"\"\n        Inflates the bag by injecting 'factor' repetitions of the current data (and respective owner) into the bag.\n\n        Parameters:\n        =============\n        factor : int\n            Determines how often the data is repeated in the bag.\n\n\n        Returns:\n        =============\n        inflated_bag : The same Bags instance on which the function is called.\n        \"\"\"", "\n", "\n", "# no", "\n", "# current_data = self.data.copy()", "\n", "# current_owners = self.bag_owners.copy()", "\n", "raise", "DeprecationWarning", "(", "\"This method should not be used\"", ")", "\n", "\n", "for", "__i", "in", "range", "(", "1", ",", "factor", ")", ":", "\n", "            ", "self", ".", "data", ".", "extend", "(", "[", "[", "t", "for", "t", "in", "b", "]", "for", "b", "in", "self", ".", "data", "]", ")", "\n", "self", ".", "bag_owners", ".", "extend", "(", "[", "o", "for", "o", "in", "self", ".", "bag_owners", "]", ")", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__": [[418, 424], ["datasets.Bags.__init__", "vocab.items"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "data", ",", "vocab", ",", "owners", "=", "None", ",", "attributes", "=", "None", ")", ":", "\n", "        ", "super", "(", "BagsWithVocab", ",", "self", ")", ".", "__init__", "(", "data", ",", "owners", ",", "\n", "owner_attributes", "=", "attributes", ")", "\n", "self", ".", "vocab", "=", "vocab", "\n", "# array of tokens which acts as reverse vocab", "\n", "self", ".", "index2token", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "vocab", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.clone": [[425, 438], ["datasets.BagsWithVocab", "datasets.BagsWithVocab.vocab.items", "datasets.BagsWithVocab.owner_attributes.items", "value_by_token.items"], "methods", ["None"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "\"\"\" Creates a really deep copy \"\"\"", "\n", "# safe cloning of an instance", "\n", "# deepcopy is NOT enough", "\n", "data", "=", "[", "[", "t", "for", "t", "in", "b", "]", "for", "b", "in", "self", ".", "data", "]", "\n", "vocab", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "self", ".", "vocab", ".", "items", "(", ")", "}", "\n", "bag_owners", "=", "[", "o", "for", "o", "in", "self", ".", "bag_owners", "]", "\n", "if", "self", ".", "owner_attributes", "is", "not", "None", ":", "\n", "            ", "attributes", "=", "{", "attr", ":", "{", "token", ":", "value", "for", "token", ",", "value", "in", "value_by_token", ".", "items", "(", ")", "}", "\n", "for", "attr", ",", "value_by_token", "in", "self", ".", "owner_attributes", ".", "items", "(", ")", "}", "\n", "\n", "", "return", "BagsWithVocab", "(", "data", ",", "vocab", ",", "owners", "=", "bag_owners", ",", "\n", "attributes", "=", "attributes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.build_vocab": [[439, 442], ["ValueError"], "methods", ["None"], ["", "def", "build_vocab", "(", "self", ",", "min_count", "=", "None", ",", "max_features", "=", "None", ",", "apply", "=", "True", ")", ":", "\n", "        ", "\"\"\" Override to prevent errors like building vocab of indices \"\"\"", "\n", "raise", "ValueError", "(", "\"Instance already has vocabulary.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.apply_vocab": [[443, 446], ["ValueError"], "methods", ["None"], ["", "def", "apply_vocab", "(", "self", ",", "vocab", ")", ":", "\n", "        ", "\"\"\" Override to prevent errors like building vocab of indices \"\"\"", "\n", "raise", "ValueError", "(", "\"A vocabulary has already been applied.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.__str__": [[447, 450], ["s.format", "datasets.BagsWithVocab.numel", "datasets.BagsWithVocab.density", "datasets.BagsWithVocab.size"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.numel", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.density", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "\"{} elements in [{}, {}] [data_points,vocabulary_size] with density {}\"", "\n", "return", "s", ".", "format", "(", "self", ".", "numel", "(", ")", ",", "*", "self", ".", "size", "(", ")", ",", "self", ".", "density", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size": [[451, 458], ["len", "len"], "methods", ["None"], ["", "def", "size", "(", "self", ",", "dim", "=", "None", ")", ":", "\n", "        ", "sizes", "=", "(", "len", "(", "self", ".", "data", ")", ",", "len", "(", "self", ".", "vocab", ")", ")", "\n", "\n", "if", "dim", "is", "not", "None", ":", "\n", "            ", "return", "sizes", "[", "dim", "]", "\n", "", "else", ":", "\n", "            ", "return", "sizes", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr": [[459, 471], ["lists2sparse().tocsr", "datasets.BagsWithVocab.size", "len", "datasets.BagsWithVocab.size", "lists2sparse"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2sparse"], ["", "", "def", "tocsr", "(", "self", ",", "data", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Use ``size`` to transform into scipy.sparse format\n        \"\"\"", "\n", "\n", "if", "data", "is", "None", ":", "\n", "            ", "data", "=", "self", ".", "data", "\n", "size", "=", "self", ".", "size", "(", ")", "\n", "", "else", ":", "\n", "            ", "size", "=", "len", "(", "data", ")", ",", "self", ".", "size", "(", "1", ")", "\n", "\n", "", "return", "lists2sparse", "(", "data", ",", "size", ")", ".", "tocsr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.train_test_split": [[472, 482], ["datasets.Bags.train_test_split", "datasets.BagsWithVocab", "datasets.BagsWithVocab"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.train_test_split"], ["", "def", "train_test_split", "(", "self", ",", "**", "split_params", ")", ":", "\n", "        ", "\"\"\" Returns one training bags instance and one test bag instance.\n        Builds the vocabulary from the training set.\n        \"\"\"", "\n", "train_bags", ",", "test_bags", "=", "super", "(", ")", ".", "train_test_split", "(", "**", "split_params", ")", "\n", "train_set", "=", "BagsWithVocab", "(", "train_bags", ".", "data", ",", "self", ".", "vocab", ",", "owners", "=", "train_bags", ".", "bag_owners", ",", "\n", "attributes", "=", "train_bags", ".", "owner_attributes", ")", "\n", "test_set", "=", "BagsWithVocab", "(", "test_bags", ".", "data", ",", "self", ".", "vocab", ",", "owners", "=", "test_bags", ".", "bag_owners", ",", "\n", "attributes", "=", "test_bags", ".", "owner_attributes", ")", "\n", "return", "train_set", ",", "test_set", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.density": [[483, 486], ["datasets.BagsWithVocab.numel", "numpy.product", "datasets.BagsWithVocab.size"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.numel", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "density", "(", "self", ")", ":", "\n", "        ", "\"\"\" Computes the density: number of elements divided by dimensions \"\"\"", "\n", "return", "self", ".", "numel", "(", ")", "/", "np", ".", "product", "(", "self", ".", "size", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.magic_number": [[487, 497], ["numpy.array", "numpy.array.mean", "list", "int", "map", "numpy.array.std", "datasets.magic", "datasets.BagsWithVocab.size"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.magic", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "magic_number", "(", "self", ",", "std_factor", "=", "None", ",", "alpha", "=", "0.05", ")", ":", "\n", "        ", "\"\"\" Computes the magic number for sparse retrieval with given error\n        probability :code:`alpha`. Optionally adds fractions of the standard deviation of set length \"\"\"", "\n", "lens", "=", "np", ".", "array", "(", "list", "(", "map", "(", "len", ",", "self", ".", "data", ")", ")", ")", "\n", "S", "=", "lens", ".", "mean", "(", ")", "\n", "\n", "if", "std_factor", ":", "\n", "            ", "S", "+=", "std_factor", "*", "lens", ".", "std", "(", ")", "\n", "\n", "", "return", "int", "(", "magic", "(", "S", ",", "self", ".", "size", "(", "1", ")", ",", "alpha", "=", "alpha", ")", ")", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.to_index": [[498, 505], ["DeprecationWarning", "datasets.BagsWithVocab.apply_vocab"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab"], ["", "def", "to_index", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"\n        Uses 'vocabulary' to transforms a list of\n         sets of tokens ('data') to a list of sets of indices.\n        \"\"\"", "\n", "raise", "DeprecationWarning", "(", "\"Use apply_vocab(data, self.vocab) instead\"", ")", "\n", "return", "apply_vocab", "(", "data", ",", "self", ".", "vocab", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.to_tokens": [[506, 513], ["DeprecationWarning", "datasets.BagsWithVocab.apply_vocab"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab"], ["", "def", "to_tokens", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"\n        Uses 'index2token' to transforms a list of\n         sets of indices ('data') to a list of sets of tokens.\n        \"\"\"", "\n", "raise", "DeprecationWarning", "(", "\"Use apply_vocab(data, self.index2token) instead\"", ")", "\n", "return", "apply_vocab", "(", "data", ",", "self", ".", "index2token", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.raw": [[514, 518], ["datasets.BagsWithVocab.apply_vocab"], "methods", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab"], ["", "def", "raw", "(", "self", ")", ":", "\n", "        ", "\"\"\" Returns the data with original identifiers instead of indices \"\"\"", "\n", "# important not to filter here, better raise if something wrong", "\n", "return", "apply_vocab", "(", "self", ".", "data", ",", "self", ".", "index2token", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.split_by_mask": [[19, 24], ["enumerate", "enumerate"], "function", ["None"], ["", "def", "split_by_mask", "(", "data", ",", "condition", ")", ":", "\n", "    ", "\"\"\" Splits data on index depending on condition \"\"\"", "\n", "truthy", "=", "[", "d", "for", "i", ",", "d", "in", "enumerate", "(", "data", ")", "if", "condition", "[", "i", "]", "]", "\n", "falsy", "=", "[", "d", "for", "i", ",", "d", "in", "enumerate", "(", "data", ")", "if", "not", "condition", "[", "i", "]", "]", "\n", "return", "truthy", ",", "falsy", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.magic": [[27, 29], ["math.log"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log"], ["", "def", "magic", "(", "S", ",", "N", ",", "alpha", "=", "0.05", ")", ":", "\n", "    ", "return", "S", "**", "2", "*", "math", ".", "log", "(", "S", "*", "N", "/", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab": [[31, 50], ["collections.Counter().most_common", "list", "len", "collections.Counter", "itertools.takewhile", "itertools.chain.from_iterable"], "function", ["None"], ["", "def", "build_vocab", "(", "sets", ",", "min_count", "=", "None", ",", "max_features", "=", "None", ")", ":", "\n", "    ", "\"\"\" Builds the vocabulary with respect to :code:`max_features` most common\n    tokens and :code:`min_count` minimal set length \"\"\"", "\n", "# sort descending by frequency and only keep max_features", "\n", "counts", "=", "Counter", "(", "it", ".", "chain", ".", "from_iterable", "(", "sets", ")", ")", ".", "most_common", "(", "max_features", ")", "\n", "# [ ('token', 42) ]", "\n", "\n", "# can be optimized", "\n", "if", "min_count", ":", "\n", "        ", "counts", "=", "list", "(", "it", ".", "takewhile", "(", "lambda", "c", ":", "c", "[", "1", "]", ">=", "min_count", ",", "counts", ")", ")", "\n", "# counts = list(filter(lambda c: c[1] >= min_count, counts))", "\n", "\n", "# incrementally assign indicies to tokens", "\n", "", "vocab", "=", "{", "}", "\n", "\n", "for", "token", ",", "__", "in", "counts", ":", "\n", "        ", "vocab", "[", "token", "]", "=", "len", "(", "vocab", ")", "\n", "\n", "", "return", "vocab", ",", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.filter_vocab": [[52, 58], ["None"], "function", ["None"], ["", "def", "filter_vocab", "(", "lists", ",", "vocab", ")", ":", "\n", "    ", "\"\"\"\n    Filters out-of-vocabulary tokens from iterable of iterables.\n    We could impose special UNK treatment here.\n    \"\"\"", "\n", "return", "[", "[", "t", "for", "t", "in", "tokens", "if", "t", "in", "vocab", "]", "for", "tokens", "in", "lists", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab": [[60, 64], ["None"], "function", ["None"], ["", "def", "apply_vocab", "(", "lists", ",", "vocab", ")", ":", "\n", "    ", "\"\"\" Applys vocab to iterable of iterables. This function can also be used\n    to invert the mapping. \"\"\"", "\n", "return", "[", "[", "vocab", "[", "t", "]", "for", "t", "in", "l", "]", "for", "l", "in", "lists", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.filter_apply_vocab": [[65, 69], ["None"], "function", ["None"], ["", "def", "filter_apply_vocab", "(", "lists", ",", "vocab", ")", ":", "\n", "    ", "\"\"\" Filters for valid tokens and transforms them to index. Faster then\n    first filter then apply. \"\"\"", "\n", "return", "[", "[", "vocab", "[", "t", "]", "for", "t", "in", "tokens", "if", "t", "in", "vocab", "]", "for", "tokens", "in", "lists", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.filter_length": [[70, 83], ["sup_reduced.append", "len", "enumerate", "enumerate"], "function", ["None"], ["", "def", "filter_length", "(", "lists", ",", "min_length", ",", "*", "supplements", ")", ":", "\n", "    ", "\"\"\"\n    Filters lists and supplements with respect to len(list) > min_length\n    \"\"\"", "\n", "enough", "=", "[", "len", "(", "bag", ")", ">=", "min_length", "for", "bag", "in", "lists", "]", "\n", "lists_reduced", "=", "[", "bag", "for", "i", ",", "bag", "in", "enumerate", "(", "lists", ")", "if", "enough", "[", "i", "]", "]", "\n", "if", "not", "supplements", ":", "\n", "        ", "return", "lists_reduced", "\n", "\n", "", "sup_reduced", "=", "[", "]", "\n", "for", "supplement", "in", "supplements", ":", "\n", "        ", "sup_reduced", ".", "append", "(", "[", "o", "for", "i", ",", "o", "in", "enumerate", "(", "supplement", ")", "if", "enough", "[", "i", "]", "]", ")", "\n", "", "return", "(", "lists_reduced", ",", "*", "sup_reduced", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.split_set": [[86, 113], ["set", "callable", "set", "type", "criterion", "type", "ValueError", "random.sample", "random.random"], "function", ["None"], ["", "def", "split_set", "(", "s", ",", "criterion", ")", ":", "\n", "    ", "\"\"\"\n    Splits a set according to criterion\n    if criterion is float: toss a coin for each element\n    if criterion is an int: drop as many random elements\n    if criterion is callable: drop each element iff criterion(element) returns\n    False\n\n    In either case, the result is (remainder_set, dropped_elements)\n    \"\"\"", "\n", "s", "=", "set", "(", "s", ")", "\n", "\n", "if", "callable", "(", "criterion", ")", ":", "\n", "        ", "todrop", "=", "{", "e", "for", "e", "in", "s", "if", "criterion", "(", "e", ")", "}", "\n", "", "elif", "type", "(", "criterion", ")", "==", "float", ":", "\n", "        ", "assert", "criterion", ">", "0", "and", "criterion", "<", "1", ",", "\"Float not bounded in (0,1)\"", "\n", "todrop", "=", "{", "e", "for", "e", "in", "s", "if", "random", ".", "random", "(", ")", "<", "criterion", "}", "\n", "", "elif", "type", "(", "criterion", ")", "==", "int", ":", "\n", "        ", "try", ":", "\n", "            ", "todrop", "=", "random", ".", "sample", "(", "s", ",", "criterion", ")", "\n", "", "except", "ValueError", ":", "# too few elements in s", "\n", "            ", "todrop", "=", "s", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'int, float, or callable expected'", ")", "\n", "\n", "", "todrop", "=", "set", "(", "todrop", ")", "\n", "return", "s", "-", "todrop", ",", "todrop", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.corrupt_sets": [[115, 124], ["tuple", "datasets.split_set", "zip"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.split_set"], ["", "def", "corrupt_sets", "(", "sets", ",", "drop", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n\n    Splits a list of sets into two sub-sets each,\n    one containing corrupted sets and one retaining the removed elements\n    \"\"\"", "\n", "split", "=", "[", "split_set", "(", "s", ",", "drop", ")", "for", "s", "in", "sets", "]", "\n", "\n", "return", "tuple", "(", "zip", "(", "*", "split", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.econis.log": [[19, 25], ["print", "open", "print"], "function", ["None"], ["def", "log", "(", "*", "print_args", ",", "logfile", "=", "None", ")", ":", "\n", "    ", "\"\"\" Maybe logs the output also in the file `outfile` \"\"\"", "\n", "if", "logfile", ":", "\n", "        ", "with", "open", "(", "logfile", ",", "'a'", ")", "as", "fhandle", ":", "\n", "            ", "print", "(", "*", "print_args", ",", "file", "=", "fhandle", ")", "\n", "", "", "print", "(", "*", "print_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.econis.load": [[109, 114], ["open", "json.load"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load"], ["", "def", "load", "(", "path", ")", ":", "\n", "    ", "\"\"\" Loads a single file \"\"\"", "\n", "with", "open", "(", "path", ",", "'r'", ")", "as", "fhandle", ":", "\n", "        ", "obj", "=", "json", ".", "load", "(", "fhandle", ")", "\n", "", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.econis.parse_en_labels": [[116, 126], ["labels.append"], "function", ["None"], ["", "def", "parse_en_labels", "(", "subjects", ")", ":", "\n", "    ", "\"\"\"\n    From subjects in the json formats to a list of english descriptors of subjects\n    \"\"\"", "\n", "labels", "=", "[", "]", "\n", "for", "subject", "in", "subjects", ":", "\n", "        ", "if", "subject", "[", "\"name_en\"", "]", "!=", "\"\"", ":", "\n", "            ", "labels", ".", "append", "(", "subject", "[", "\"name_en\"", "]", ")", "\n", "\n", "", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.econis.parse_authors": [[128, 146], ["p.pop", "p.pop", "authors.append", "authors.append", "creator.pop", "contributor.pop"], "function", ["None"], ["", "def", "parse_authors", "(", "p", ")", ":", "\n", "    ", "\"\"\"\n    From Marc21-IDs in the json formats to a list of authors\n    \"\"\"", "\n", "authors", "=", "[", "]", "\n", "try", ":", "\n", "        ", "for", "creator", "in", "p", ".", "pop", "(", "\"creator_personal\"", ")", ":", "\n", "            ", "authors", ".", "append", "(", "creator", ".", "pop", "(", "\"name\"", ")", ")", "\n", "", "", "except", "KeyError", ":", "\n", "        ", "pass", "\n", "\n", "", "try", ":", "\n", "        ", "for", "contributor", "in", "p", ".", "pop", "(", "\"contributor_personal\"", ")", ":", "\n", "            ", "authors", ".", "append", "(", "contributor", ".", "pop", "(", "\"name\"", ")", ")", "\n", "", "", "except", "KeyError", ":", "\n", "        ", "pass", "\n", "\n", "", "return", "authors", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.econis.unpack_papers_conditions": [[148, 195], ["print", "ids.append", "econis.parse_authors", "econis.parse_en_labels", "bags_of_labels.append", "len", "len", "bags_of_labels.append", "type", "int", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.parse_authors", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.parse_en_labels"], ["", "def", "unpack_papers_conditions", "(", "papers", ")", ":", "\n", "    ", "\"\"\"\n    Unpacks list of papers in a way that is compatible with our Bags dataset\n    format. It is not mandatory that papers are sorted.\n    \"\"\"", "\n", "\n", "bags_of_labels", ",", "ids", ",", "side_info", ",", "years", ",", "authors", "=", "[", "]", ",", "[", "]", ",", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "subjects_cnt", ",", "title_cnt", ",", "authors_cnt", "=", "0", ",", "0", ",", "0", "\n", "for", "paper", "in", "papers", ":", "\n", "# Extract ids", "\n", "        ", "ids", ".", "append", "(", "paper", "[", "\"econbiz_id\"", "]", ")", "\n", "# Put all subjects assigned to the paper in here", "\n", "try", ":", "\n", "# Subject may be missing", "\n", "            ", "subjects", "=", "parse_en_labels", "(", "paper", "[", "\"subject_stw\"", "]", ")", "\n", "bags_of_labels", ".", "append", "(", "subjects", ")", "\n", "if", "len", "(", "subjects", ")", ">", "0", ":", "\n", "                ", "subjects_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "bags_of_labels", ".", "append", "(", "[", "]", ")", "\n", "\n", "# Use dict here such that we can also deal with unsorted ids", "\n", "", "try", ":", "\n", "            ", "side_info", "[", "paper", "[", "\"econbiz_id\"", "]", "]", "=", "paper", "[", "\"title\"", "]", "\n", "if", "paper", "[", "\"title\"", "]", "!=", "\"\"", ":", "\n", "                ", "title_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "side_info", "[", "paper", "[", "\"econbiz_id\"", "]", "]", "=", "\"\"", "\n", "", "try", ":", "\n", "# Sometimes data in format yyyy.mm.dd (usually only year)", "\n", "            ", "if", "type", "(", "paper", "[", "\"date\"", "]", ")", "is", "str", ":", "\n", "                ", "paper", "[", "\"date\"", "]", "=", "int", "(", "paper", "[", "\"date\"", "]", "[", ":", "4", "]", ")", "\n", "", "years", "[", "paper", "[", "\"econbiz_id\"", "]", "]", "=", "paper", "[", "\"date\"", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "years", "[", "paper", "[", "\"econbiz_id\"", "]", "]", "=", "-", "1", "\n", "\n", "", "authors", "[", "paper", "[", "\"econbiz_id\"", "]", "]", "=", "parse_authors", "(", "paper", ")", "\n", "if", "len", "(", "authors", "[", "paper", "[", "\"econbiz_id\"", "]", "]", ")", ">", "0", ":", "\n", "            ", "authors_cnt", "+=", "1", "\n", "\n", "", "", "print", "(", "\"Metadata-fields' frequencies: subjects={}, title={}, authors={}\"", "\n", ".", "format", "(", "subjects_cnt", "/", "len", "(", "papers", ")", ",", "title_cnt", "/", "len", "(", "papers", ")", ",", "authors_cnt", "/", "len", "(", "papers", ")", ")", ")", "\n", "\n", "# bag_of_labels and ids should have corresponding indices", "\n", "# In side_info the id is the key", "\n", "# Re-use 'title' and year here because methods rely on it", "\n", "return", "bags_of_labels", ",", "ids", ",", "{", "\"title\"", ":", "side_info", ",", "\"year\"", ":", "years", ",", "\"author\"", ":", "authors", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.econis.main": [[197, 233], ["print", "econis.load", "print", "econis.unpack_papers_conditions", "aaerec.datasets.Bags", "econis.log", "econis.log", "aaerec.evaluation.Evaluation", "aaerec.evaluation.Evaluation.setup", "aaerec.evaluation.Evaluation.", "print", "print", "aaerec.datasets.Bags.build_vocab", "compute_mutual_info", "print", "exit", "open", "print", "open", "print"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.unpack_papers_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.setup", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.utils.compute_mutual_info"], ["", "def", "main", "(", "year", ",", "min_count", "=", "None", ",", "outfile", "=", "None", ",", "drop", "=", "1", ")", ":", "\n", "    ", "\"\"\" Main function for training and evaluating AAE methods on IREON data \"\"\"", "\n", "print", "(", "\"Loading data from\"", ",", "DATA_PATH", ")", "\n", "papers", "=", "load", "(", "DATA_PATH", ")", "\n", "print", "(", "\"Unpacking data...\"", ")", "\n", "# bags_of_papers, ids, side_info = unpack_papers(papers)", "\n", "bags_of_papers", ",", "ids", ",", "side_info", "=", "unpack_papers_conditions", "(", "papers", ")", "\n", "del", "papers", "\n", "bags", "=", "Bags", "(", "bags_of_papers", ",", "ids", ",", "side_info", ")", "\n", "if", "args", ".", "compute_mi", ":", "\n", "        ", "from", "aaerec", ".", "utils", "import", "compute_mutual_info", "\n", "print", "(", "\"[MI] Dataset: ECONIS\"", ")", "\n", "print", "(", "\"[MI] min Count:\"", ",", "min_count", ")", "\n", "tmp", "=", "bags", ".", "build_vocab", "(", "min_count", "=", "min_count", ",", "max_features", "=", "None", ")", "\n", "mi", "=", "compute_mutual_info", "(", "tmp", ",", "conditions", "=", "None", ",", "include_labels", "=", "True", ",", "\n", "normalize", "=", "True", ")", "\n", "with", "open", "(", "'mi.csv'", ",", "'a'", ")", "as", "mifile", ":", "\n", "            ", "print", "(", "'EconBiz'", ",", "min_count", ",", "mi", ",", "sep", "=", "','", ",", "file", "=", "mifile", ")", "\n", "", "print", "(", "\"=\"", "*", "78", ")", "\n", "exit", "(", "0", ")", "\n", "\n", "", "log", "(", "\"Whole dataset:\"", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "bags", ",", "logfile", "=", "outfile", ")", "\n", "\n", "evaluation", "=", "Evaluation", "(", "bags", ",", "year", ",", "logfile", "=", "outfile", ")", "\n", "evaluation", ".", "setup", "(", "min_count", "=", "min_count", ",", "min_elements", "=", "2", ",", "drop", "=", "drop", ")", "\n", "\n", "# Use only partial citations/labels list (no additional metadata)", "\n", "# with open(outfile, 'a') as fh:", "\n", "#     print(\"~ Partial List\", \"~\" * 42, file=fh)", "\n", "# evaluation(BASELINES + RECOMMENDERS)", "\n", "\n", "# Use additional metadata (as defined in CONDITIONS for all models but SVD, which uses only titles)", "\n", "with", "open", "(", "outfile", ",", "'a'", ")", "as", "fh", ":", "\n", "        ", "print", "(", "\"~ Conditioned Models\"", ",", "\"~\"", "*", "42", ",", "file", "=", "fh", ")", "\n", "", "evaluation", "(", "CONDITIONED_MODELS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.evaluate_dev.load_submission": [[9, 20], ["open", "line.strip.strip", "line.strip.split", "line.strip.startswith", "int"], "function", ["None"], ["def", "load_submission", "(", "path", ")", ":", "\n", "    ", "\"\"\" Returns dict of list: pid -> track_ids \"\"\"", "\n", "sub", "=", "{", "}", "\n", "with", "open", "(", "path", ",", "'r'", ")", "as", "fh", ":", "\n", "        ", "for", "line", "in", "fh", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "[", "0", "]", "==", "'#'", "or", "line", ".", "startswith", "(", "'team_info'", ")", ":", "\n", "                ", "continue", "\n", "", "pid", ",", "*", "tracks", "=", "line", ".", "split", "(", "','", ")", "\n", "sub", "[", "int", "(", "pid", ")", "]", "=", "tracks", "\n", "", "", "return", "sub", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.evaluate_dev.main": [[21, 73], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "eval.mpd.mpd.playlists_from_slices", "evaluate_dev.load_submission", "set", "set", "mpd_metrics.aggregate_metrics", "print", "argparse.ArgumentParser.parse_args", "line.strip", "print", "eval.mpd.mpd.playlists_from_slices.keys", "load_submission.keys", "print", "exit", "print", "print", "print", "len", "len", "argparse.FileType", "len", "len", "len", "set.intersection"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.playlists_from_slices", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.evaluate_dev.load_submission", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.aggregate_metrics"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'exclude'", ",", "type", "=", "argparse", ".", "FileType", "(", "'r'", ")", ",", "\n", "help", "=", "\"Path to exclude file, determines ground truth.\"", ")", "\n", "parser", ".", "add_argument", "(", "'submission'", ",", "type", "=", "str", ",", "\n", "help", "=", "\"Path to dev submission file\"", ")", "\n", "parser", ".", "add_argument", "(", "'-v'", ",", "'--verbose'", ",", "default", "=", "0", ",", "type", "=", "int", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "dev_slices", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "args", ".", "exclude", "]", "\n", "if", "args", ".", "verbose", ":", "\n", "        ", "print", "(", "\"Loading ground truth from\"", ",", "dev_slices", ")", "\n", "\n", "", "ground_truth", "=", "playlists_from_slices", "(", "DATA_PATH", ",", "only", "=", "dev_slices", ",", "verbose", "=", "args", ".", "verbose", ")", "\n", "# Make the json stuff dictionaries from pid to track uris", "\n", "ground_truth", "=", "{", "p", "[", "'pid'", "]", ":", "[", "t", "[", "'track_uri'", "]", "for", "t", "in", "p", "[", "'tracks'", "]", "]", "for", "p", "in", "ground_truth", "}", "\n", "\n", "predictions", "=", "load_submission", "(", "args", ".", "submission", ")", "\n", "\n", "\n", "# Verify that pids match", "\n", "pids", "=", "set", "(", "ground_truth", ".", "keys", "(", ")", ")", "\n", "pids_pred", "=", "set", "(", "predictions", ".", "keys", "(", ")", ")", "\n", "if", "not", "pids_pred", ":", "\n", "        ", "print", "(", "args", ".", "submission", ",", "'is empty.'", ")", "\n", "exit", "(", "1", ")", "\n", "", "if", "args", ".", "verbose", ":", "\n", "        ", "print", "(", "len", "(", "pids", ")", ",", "\"pids in ground truth\"", ")", "\n", "print", "(", "len", "(", "pids_pred", ")", ",", "\"pids in predictions\"", ")", "\n", "print", "(", "len", "(", "set", ".", "intersection", "(", "pids", ",", "pids_pred", ")", ")", ",", "\"pids in intersection\"", ")", "\n", "# Super strict: All pids in both are the same", "\n", "", "assert", "len", "(", "pids", "^", "pids_pred", ")", "==", "0", "\n", "\n", "# Less strict: all predicted pids should be also in gold", "\n", "assert", "len", "(", "pids_pred", "-", "pids", ")", "==", "0", "\n", "\n", "\n", "\n", "summary", "=", "aggregate_metrics", "(", "ground_truth", ",", "predictions", ",", "\n", "500", ",", "pids", ")", "\n", "\n", "print", "(", "summary", ")", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.create_dev_set.random_keep": [[22, 48], ["zip", "zip", "sum", "numpy.random.choice", "random.shuffle", "len", "print", "dist.items", "dist.items", "len"], "function", ["None"], ["def", "random_keep", "(", "tracks", ",", "dist", ")", ":", "\n", "    ", "\"\"\"\n    Returns randomly sampled tracks according to dist and the number of\n    holdouts\n    \"\"\"", "\n", "# Unzip distribution", "\n", "values", ",", "weights", "=", "zip", "(", "*", "dist", ".", "items", "(", ")", ")", "\n", "\n", "# Brute-force fix for too small playlists, might skew distribution a little", "\n", "# Always drop at least some...", "\n", "red_dist", "=", "[", "(", "val", ",", "p", ")", "for", "(", "val", ",", "p", ")", "in", "dist", ".", "items", "(", ")", "if", "val", "<", "len", "(", "tracks", ")", "]", "\n", "values", ",", "weights", "=", "zip", "(", "*", "red_dist", ")", "\n", "# Renormalize such that weights sum up to 1", "\n", "weights_sum", "=", "sum", "(", "weights", ")", "\n", "weights", "=", "[", "w", "/", "weights_sum", "for", "w", "in", "weights", "]", "\n", "\n", "# Determine number of tracks to keep according to (reduced) dist", "\n", "keep", "=", "np", ".", "random", ".", "choice", "(", "values", ",", "p", "=", "weights", ")", "\n", "\n", "# in-place shuffle", "\n", "random", ".", "shuffle", "(", "tracks", ")", "\n", "retain", "=", "tracks", "[", ":", "keep", "]", "\n", "num_holdouts", "=", "len", "(", "tracks", "[", "keep", ":", "]", ")", "\n", "if", "num_holdouts", "==", "0", ":", "\n", "        ", "print", "(", "\"WARNING: no holdouts\"", ")", "\n", "", "return", "retain", ",", "num_holdouts", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.create_dev_set.corrupt_playlists": [[50, 94], ["max", "random.shuffle", "int", "DIST_NAMELESS.keys", "create_dev_set.random_keep", "dev_playlists.append", "create_dev_set.random_keep", "dev_playlists.append", "len", "len", "len", "long_enough.append", "too_short.append", "len", "len", "max", "playlist.items", "playlist.items", "DIST_NAMELESS.keys"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.create_dev_set.random_keep", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.create_dev_set.random_keep"], ["", "def", "corrupt_playlists", "(", "playlists", ")", ":", "\n", "# Name-less playlists should have more than 10 tracks", "\n", "    ", "long_enough", "=", "[", "p", "for", "p", "in", "playlists", "if", "len", "(", "p", ")", ">", "max", "(", "DIST_NAMELESS", ".", "keys", "(", ")", ")", "]", "\n", "long_enough", "=", "[", "]", "\n", "too_short", "=", "[", "]", "\n", "len_threshold", "=", "max", "(", "DIST_NAMELESS", ".", "keys", "(", ")", ")", "\n", "\n", "# Split playlists into the ones that are long enough for nameless", "\n", "# treatment and the ones that are too short", "\n", "for", "playlist", "in", "playlists", ":", "\n", "        ", "if", "len", "(", "playlist", "[", "'tracks'", "]", ")", ">", "len_threshold", ":", "\n", "            ", "long_enough", ".", "append", "(", "playlist", ")", "\n", "", "else", ":", "\n", "            ", "too_short", ".", "append", "(", "playlist", ")", "\n", "\n", "", "", "dev_playlists", "=", "[", "]", "\n", "\n", "# Random sample n_nameless among long enough ones", "\n", "random", ".", "shuffle", "(", "long_enough", ")", "\n", "n_nameless", "=", "int", "(", "P_NAMELESS", "*", "len", "(", "playlists", ")", ")", "\n", "for", "playlist", "in", "long_enough", "[", ":", "n_nameless", "]", ":", "\n", "        ", "pcopy", "=", "{", "k", ":", "v", "for", "(", "k", ",", "v", ")", "in", "playlist", ".", "items", "(", ")", "}", "\n", "del", "pcopy", "[", "'name'", "]", "\n", "retained_tracks", ",", "num_holdouts", "=", "random_keep", "(", "pcopy", "[", "'tracks'", "]", ",", "\n", "DIST_NAMELESS", ")", "\n", "pcopy", "[", "'tracks'", "]", "=", "retained_tracks", "\n", "pcopy", "[", "'num_holdouts'", "]", "=", "num_holdouts", "\n", "dev_playlists", ".", "append", "(", "pcopy", ")", "\n", "\n", "# Merge remaining and too short playlists", "\n", "", "remainder", "=", "long_enough", "[", "n_nameless", ":", "]", "+", "too_short", "\n", "\n", "# Treat named, in place", "\n", "for", "playlist", "in", "remainder", ":", "\n", "        ", "pcopy", "=", "{", "k", ":", "v", "for", "(", "k", ",", "v", ")", "in", "playlist", ".", "items", "(", ")", "}", "\n", "retained_tracks", ",", "num_holdouts", "=", "random_keep", "(", "pcopy", "[", "'tracks'", "]", ",", "\n", "DIST_NAMED", ")", "\n", "pcopy", "[", "'tracks'", "]", "=", "retained_tracks", "\n", "pcopy", "[", "'num_holdouts'", "]", "=", "num_holdouts", "\n", "dev_playlists", ".", "append", "(", "pcopy", ")", "\n", "\n", "", "assert", "len", "(", "dev_playlists", ")", "==", "len", "(", "playlists", ")", "\n", "\n", "return", "dev_playlists", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.create_dev_set.main": [[96, 129], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "eval.mpd.mpd.playlists_from_slices", "create_dev_set.corrupt_playlists", "print", "os.path.exists", "exit", "s.strip", "str", "open", "json.dump", "argparse.FileType", "input", "datetime.date.today", "str"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.playlists_from_slices", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.create_dev_set.corrupt_playlists"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'slices'", ",", "type", "=", "argparse", ".", "FileType", "(", "'r'", ")", ",", "\n", "help", "=", "\"Path to file with one slice filename per line\"", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--output'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"File to put output\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "if", "args", ".", "output", "is", "None", ":", "\n", "        ", "print", "(", "\"No output file specified, performing a dry run\"", ")", "\n", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "args", ".", "output", ")", "and", "input", "(", "\"Path '{}' exists. Overwrite? [y/N]\"", "\n", ".", "format", "(", "args", ".", "output", ")", ")", "!=", "'y'", ":", "\n", "        ", "exit", "(", "-", "1", ")", "\n", "\n", "# strip newlines from exclude names", "\n", "", "slices", "=", "[", "s", ".", "strip", "(", ")", "for", "s", "in", "args", ".", "slices", "]", "\n", "print", "(", "\"Creating dev set from slices:\"", ",", "slices", ")", "\n", "\n", "playlists", "=", "playlists_from_slices", "(", "DATA_PATH", ",", "only", "=", "slices", ")", "\n", "\n", "dev_playlists", "=", "corrupt_playlists", "(", "playlists", ")", "\n", "\n", "dev_set", "=", "{", "\n", "'date'", ":", "str", "(", "date", ".", "today", "(", ")", ")", ",", "\n", "'version'", ":", "'dev set created from: '", "+", "str", "(", "slices", ")", ",", "\n", "'playlists'", ":", "dev_playlists", "\n", "}", "\n", "\n", "with", "open", "(", "args", ".", "output", ",", "'w'", ")", "as", "fhandle", ":", "\n", "        ", "json", ".", "dump", "(", "dev_set", ",", "fhandle", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.log": [[18, 24], ["print", "open", "print"], "function", ["None"], ["def", "log", "(", "*", "print_args", ",", "logfile", "=", "None", ")", ":", "\n", "    ", "\"\"\" Maybe logs the output also in the file `outfile` \"\"\"", "\n", "if", "logfile", ":", "\n", "        ", "with", "open", "(", "logfile", ",", "'a'", ")", "as", "fhandle", ":", "\n", "            ", "print", "(", "*", "print_args", ",", "file", "=", "fhandle", ")", "\n", "", "", "print", "(", "*", "print_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.load": [[111, 116], ["open", "json.loads", "line.rstrip"], "function", ["None"], ["", "def", "load", "(", "path", ")", ":", "\n", "    ", "\"\"\" Loads a single file \"\"\"", "\n", "with", "open", "(", "path", ",", "'r'", ")", "as", "fhandle", ":", "\n", "        ", "obj", "=", "[", "json", ".", "loads", "(", "line", ".", "rstrip", "(", "'\\n'", ")", ")", "for", "line", "in", "fhandle", "]", "\n", "", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.clean": [[118, 144], ["open", "fiv.parse_en_labels", "fiv.parse_authors", "write_file.write", "p.pop", "p.pop", "len", "len", "re.findall", "print", "json.dumps", "len", "len", "int", "print"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.parse_en_labels", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.parse_authors"], ["", "def", "clean", "(", "path", ",", "papers", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "\"w\"", ")", "as", "write_file", ":", "\n", "        ", "for", "p", "in", "papers", ":", "\n", "            ", "try", ":", "\n", "                ", "p", "[", "\"year\"", "]", "=", "p", ".", "pop", "(", "\"date\"", ")", "\n", "", "except", "KeyError", ":", "\n", "                ", "continue", "\n", "", "p", "[", "\"subjects\"", "]", "=", "parse_en_labels", "(", "p", ".", "pop", "(", "\"subject\"", ")", ")", "\n", "p", "[", "\"authors\"", "]", "=", "parse_authors", "(", "p", ")", "\n", "if", "len", "(", "p", "[", "\"year\"", "]", ")", "<", "4", ":", "\n", "                ", "continue", "\n", "", "if", "len", "(", "p", "[", "\"year\"", "]", ")", ">=", "4", ":", "\n", "                ", "matches", "=", "re", ".", "findall", "(", "r'.*([1-2][0-9]{3})'", ",", "p", "[", "\"year\"", "]", ")", "\n", "# if no or more than one match skip string", "\n", "if", "len", "(", "matches", ")", "==", "0", "or", "len", "(", "matches", ")", ">", "1", ":", "\n", "                    ", "print", "(", "\"no match for {}\"", ".", "format", "(", "p", "[", "\"year\"", "]", ")", ")", "\n", "continue", "\n", "", "else", ":", "\n", "                    ", "try", ":", "\n", "                        ", "p", "[", "\"year\"", "]", "=", "int", "(", "matches", "[", "0", "]", ")", "\n", "", "except", "ValueError", ":", "\n", "                        ", "print", "(", "\"Value error for {}\"", ".", "format", "(", "matches", "[", "0", "]", ")", ")", "\n", "continue", "\n", "", "", "", "if", "(", "p", "[", "\"year\"", "]", ">", "2016", ")", ":", "\n", "                ", "continue", "\n", "", "write_file", ".", "write", "(", "json", ".", "dumps", "(", "p", ")", "+", "\"\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.parse_en_labels": [[146, 156], ["labels.append"], "function", ["None"], ["", "", "", "def", "parse_en_labels", "(", "subjects", ")", ":", "\n", "    ", "\"\"\"\n    From subjects in the json formats to a list of english descriptors of subjects\n    \"\"\"", "\n", "labels", "=", "[", "]", "\n", "for", "subject", "in", "subjects", ":", "\n", "        ", "if", "subject", "[", "\"name_en\"", "]", "!=", "\"\"", ":", "\n", "            ", "labels", ".", "append", "(", "subject", "[", "\"name_en\"", "]", ")", "\n", "\n", "", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.parse_authors": [[157, 177], ["p.pop", "p.pop", "authors.append", "obj.pop().pop", "authors.append", "creator.pop", "obj.pop().pop.replace", "obj.pop"], "function", ["None"], ["", "def", "parse_authors", "(", "p", ")", ":", "\n", "    ", "\"\"\"\n    From Marc21-IDs in the json formats to a list of authors\n    \"\"\"", "\n", "authors", "=", "[", "]", "\n", "try", ":", "\n", "        ", "for", "creator", "in", "p", ".", "pop", "(", "\"creator_personal\"", ")", ":", "\n", "            ", "authors", ".", "append", "(", "creator", ".", "pop", "(", "\"name\"", ")", ")", "\n", "", "", "except", "KeyError", ":", "\n", "        ", "pass", "\n", "\n", "", "for", "obj", "in", "p", ".", "pop", "(", "\"Marc21-IDs\"", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "author", "=", "obj", ".", "pop", "(", "\"700\"", ")", ".", "pop", "(", "\"entry\"", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "continue", "\n", "", "if", "\"Author aut\"", "in", "author", ":", "\n", "           ", "authors", ".", "append", "(", "author", ".", "replace", "(", "\", Author aut\"", ",", "\"\"", ")", ")", "\n", "\n", "", "", "return", "authors", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.unpack_papers_conditions": [[179, 212], ["ids.append", "bags_of_labels.append", "bags_of_labels.append"], "function", ["None"], ["", "def", "unpack_papers_conditions", "(", "papers", ")", ":", "\n", "    ", "\"\"\"\n    Unpacks list of papers in a way that is compatible with our Bags dataset\n    format. It is not mandatory that papers are sorted.\n    \"\"\"", "\n", "\n", "bags_of_labels", ",", "ids", ",", "side_info", ",", "years", ",", "authors", "=", "[", "]", ",", "[", "]", ",", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "for", "paper", "in", "papers", ":", "\n", "# Extract ids", "\n", "        ", "ids", ".", "append", "(", "paper", "[", "\"id\"", "]", ")", "\n", "# Put all subjects assigned to the paper in here", "\n", "try", ":", "\n", "# Subject may be missing", "\n", "            ", "bags_of_labels", ".", "append", "(", "paper", "[", "\"subjects\"", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "bags_of_labels", ".", "append", "(", "[", "]", ")", "\n", "\n", "# Use dict here such that we can also deal with unsorted ids", "\n", "", "try", ":", "\n", "            ", "side_info", "[", "paper", "[", "\"id\"", "]", "]", "=", "paper", "[", "\"title\"", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "side_info", "[", "paper", "[", "\"id\"", "]", "]", "=", "\"\"", "\n", "", "try", ":", "\n", "            ", "years", "[", "paper", "[", "\"id\"", "]", "]", "=", "paper", "[", "\"year\"", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "years", "[", "paper", "[", "\"id\"", "]", "]", "=", "-", "1", "\n", "\n", "", "authors", "[", "paper", "[", "\"id\"", "]", "]", "=", "paper", "[", "\"authors\"", "]", "\n", "\n", "# bag_of_labels and ids should have corresponding indices", "\n", "# In side_info the id is the key", "\n", "# Re-use 'title' and year here because methods rely on it", "\n", "", "return", "bags_of_labels", ",", "ids", ",", "{", "\"title\"", ":", "side_info", ",", "\"year\"", ":", "years", ",", "\"author\"", ":", "authors", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.unpack_papers": [[214, 258], ["print", "ids.append", "bags_of_labels.append", "len", "bags_of_labels.append", "len", "len", "len", "len"], "function", ["None"], ["", "def", "unpack_papers", "(", "papers", ")", ":", "\n", "    ", "\"\"\"\n    Unpacks list of papers in a way that is compatible with our Bags dataset\n    format. It is not mandatory that papers are sorted.\n    \"\"\"", "\n", "\n", "bags_of_labels", ",", "ids", ",", "side_info", ",", "years", "=", "[", "]", ",", "[", "]", ",", "{", "}", ",", "{", "}", "\n", "subject_cnt", ",", "title_cnt", ",", "author_cnt", ",", "venue_cnt", "=", "0", ",", "0", ",", "0", ",", "0", "\n", "for", "paper", "in", "papers", ":", "\n", "# Extract ids", "\n", "        ", "ids", ".", "append", "(", "paper", "[", "\"id\"", "]", ")", "\n", "# Put all subjects assigned to the paper in here", "\n", "try", ":", "\n", "# Subject may be missing", "\n", "            ", "bags_of_labels", ".", "append", "(", "paper", "[", "\"subjects\"", "]", ")", "\n", "if", "len", "(", "paper", "[", "\"subjects\"", "]", ")", ">", "0", ":", "\n", "                ", "subject_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "bags_of_labels", ".", "append", "(", "[", "]", ")", "\n", "# Use dict here such that we can also deal with unsorted ids", "\n", "", "try", ":", "\n", "            ", "side_info", "[", "paper", "[", "\"id\"", "]", "]", "=", "paper", "[", "\"title\"", "]", "\n", "if", "paper", "[", "\"title\"", "]", "!=", "\"\"", ":", "\n", "                ", "title_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "side_info", "[", "paper", "[", "\"id\"", "]", "]", "=", "\"\"", "\n", "", "try", ":", "\n", "            ", "years", "[", "paper", "[", "\"id\"", "]", "]", "=", "paper", "[", "\"year\"", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "years", "[", "paper", "[", "\"id\"", "]", "]", "=", "-", "1", "\n", "\n", "", "try", ":", "\n", "            ", "if", "len", "(", "paper", "[", "\"authors\"", "]", ")", ">", "0", ":", "\n", "                ", "author_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "pass", "\n", "\n", "", "", "print", "(", "\"Metadata-fields' frequencies: references={}, title={}, authors={}\"", "\n", ".", "format", "(", "subject_cnt", "/", "len", "(", "papers", ")", ",", "title_cnt", "/", "len", "(", "papers", ")", ",", "author_cnt", "/", "len", "(", "papers", ")", ")", ")", "\n", "\n", "# bag_of_labels and ids should have corresponding indices", "\n", "# In side_info the id is the key", "\n", "# Re-use 'title' and year here because methods rely on it", "\n", "return", "bags_of_labels", ",", "ids", ",", "{", "\"title\"", ":", "side_info", ",", "\"year\"", ":", "years", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.main": [[260, 303], ["print", "fiv.load", "print", "fiv.unpack_papers_conditions", "aaerec.datasets.Bags", "fiv.log", "fiv.log", "aaerec.evaluation.Evaluation", "aaerec.evaluation.Evaluation.setup", "aaerec.evaluation.Evaluation.", "aaerec.evaluation.Evaluation.", "print", "fiv.load", "print", "fiv.clean", "print", "print", "print", "aaerec.datasets.Bags.build_vocab", "compute_mutual_info", "print", "exit", "open", "print", "open", "print", "open", "print"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.unpack_papers_conditions", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.setup", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.fiv.clean", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.utils.compute_mutual_info"], ["", "def", "main", "(", "year", ",", "min_count", "=", "None", ",", "outfile", "=", "None", ",", "drop", "=", "1", ")", ":", "\n", "    ", "\"\"\" Main function for training and evaluating AAE methods on IREON data \"\"\"", "\n", "if", "(", "CLEAN", "==", "True", ")", ":", "\n", "        ", "print", "(", "\"Loading data from\"", ",", "DATA_PATH", ")", "\n", "papers", "=", "load", "(", "DATA_PATH", ")", "\n", "print", "(", "\"Cleaning data...\"", ")", "\n", "clean", "(", "CLEAN_DATA_PATH", ",", "papers", ")", "\n", "print", "(", "\"Clean data in {}\"", ".", "format", "(", "CLEAN_DATA_PATH", ")", ")", "\n", "return", "\n", "\n", "", "print", "(", "\"Loading data from\"", ",", "CLEAN_DATA_PATH", ")", "\n", "papers", "=", "load", "(", "CLEAN_DATA_PATH", ")", "\n", "print", "(", "\"Unpacking IREON data...\"", ")", "\n", "# bags_of_papers, ids, side_info = unpack_papers(papers)", "\n", "bags_of_papers", ",", "ids", ",", "side_info", "=", "unpack_papers_conditions", "(", "papers", ")", "\n", "del", "papers", "\n", "bags", "=", "Bags", "(", "bags_of_papers", ",", "ids", ",", "side_info", ")", "\n", "if", "args", ".", "compute_mi", ":", "\n", "        ", "from", "aaerec", ".", "utils", "import", "compute_mutual_info", "\n", "print", "(", "\"[MI] Dataset: IREON (fiv)\"", ")", "\n", "print", "(", "\"[MI] min Count:\"", ",", "min_count", ")", "\n", "tmp", "=", "bags", ".", "build_vocab", "(", "min_count", "=", "min_count", ",", "max_features", "=", "None", ")", "\n", "mi", "=", "compute_mutual_info", "(", "tmp", ",", "conditions", "=", "None", ",", "include_labels", "=", "True", ",", "\n", "normalize", "=", "True", ")", "\n", "with", "open", "(", "'mi.csv'", ",", "'a'", ")", "as", "mifile", ":", "\n", "            ", "print", "(", "'IREON'", ",", "min_count", ",", "mi", ",", "sep", "=", "','", ",", "file", "=", "mifile", ")", "\n", "", "print", "(", "\"=\"", "*", "78", ")", "\n", "exit", "(", "0", ")", "\n", "\n", "", "log", "(", "\"Whole dataset:\"", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "bags", ",", "logfile", "=", "outfile", ")", "\n", "\n", "evaluation", "=", "Evaluation", "(", "bags", ",", "year", ",", "logfile", "=", "outfile", ")", "\n", "evaluation", ".", "setup", "(", "min_count", "=", "min_count", ",", "min_elements", "=", "2", ",", "drop", "=", "drop", ")", "\n", "\n", "# Use only partial citations/labels list (no additional metadata)", "\n", "with", "open", "(", "outfile", ",", "'a'", ")", "as", "fh", ":", "\n", "        ", "print", "(", "\"~ Partial List\"", ",", "\"~\"", "*", "42", ",", "file", "=", "fh", ")", "\n", "", "evaluation", "(", "BASELINES", "+", "RECOMMENDERS", ")", "\n", "# Use additional metadata (as defined in CONDITIONS for all models but SVD, which uses only titles)", "\n", "with", "open", "(", "outfile", ",", "'a'", ")", "as", "fh", ":", "\n", "        ", "print", "(", "\"~ Conditioned Models\"", ",", "\"~\"", "*", "42", ",", "file", "=", "fh", ")", "\n", "", "evaluation", "(", "CONDITIONED_MODELS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.log": [[34, 40], ["print", "open", "print"], "function", ["None"], ["def", "log", "(", "*", "print_args", ",", "logfile", "=", "None", ")", ":", "\n", "    ", "\"\"\" Maybe logs the output also in the file `outfile` \"\"\"", "\n", "if", "logfile", ":", "\n", "        ", "with", "open", "(", "logfile", ",", "'a'", ")", "as", "fhandle", ":", "\n", "            ", "print", "(", "*", "print_args", ",", "file", "=", "fhandle", ")", "\n", "", "", "print", "(", "*", "print_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.load_dblp": [[72, 77], ["open", "json.loads", "line.rstrip"], "function", ["None"], ["", "def", "load_dblp", "(", "path", ")", ":", "\n", "    ", "\"\"\" Loads a single file \"\"\"", "\n", "with", "open", "(", "path", ",", "'r'", ")", "as", "fhandle", ":", "\n", "        ", "obj", "=", "[", "json", ".", "loads", "(", "line", ".", "rstrip", "(", "'\\n'", ")", ")", "for", "line", "in", "fhandle", "]", "\n", "", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.load_acm": [[79, 108], ["open", "line.rstrip.rstrip", "len", "obj.append", "line[].split", "int", "paper[].append"], "function", ["None"], ["", "def", "load_acm", "(", "path", ")", ":", "\n", "    ", "\"\"\" Loads a single file \"\"\"", "\n", "with", "open", "(", "path", ",", "'r'", ")", "as", "fhandle", ":", "\n", "        ", "obj", "=", "[", "]", "\n", "paper", "=", "{", "}", "\n", "paper", "[", "\"references\"", "]", "=", "[", "]", "\n", "\n", "for", "line", "in", "fhandle", ":", "\n", "            ", "line", "=", "line", ".", "rstrip", "(", "'\\n'", ")", "\n", "\n", "if", "len", "(", "line", ")", "==", "0", ":", "\n", "                ", "obj", ".", "append", "(", "paper", ")", "\n", "paper", "=", "{", "}", "\n", "paper", "[", "\"references\"", "]", "=", "[", "]", "\n", "\n", "", "elif", "line", "[", "1", "]", "==", "'*'", ":", "\n", "                ", "paper", "[", "\"title\"", "]", "=", "line", "[", "2", ":", "]", "\n", "", "elif", "line", "[", "1", "]", "==", "'@'", ":", "\n", "                ", "paper", "[", "\"authors\"", "]", "=", "line", "[", "2", ":", "]", ".", "split", "(", "\",\"", ")", "\n", "", "elif", "line", "[", "1", "]", "==", "'t'", ":", "\n", "                ", "paper", "[", "\"year\"", "]", "=", "int", "(", "line", "[", "2", ":", "]", ")", "\n", "", "elif", "line", "[", "1", "]", "==", "'c'", ":", "\n", "                ", "paper", "[", "\"venue\"", "]", "=", "line", "[", "2", ":", "]", "\n", "", "elif", "line", "[", "1", "]", "==", "'i'", ":", "\n", "                ", "paper", "[", "\"id\"", "]", "=", "line", "[", "6", ":", "]", "\n", "", "else", ":", "\n", "                ", "paper", "[", "\"references\"", "]", ".", "append", "(", "line", "[", "2", ":", "]", ")", "\n", "\n", "", "", "", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.papers_from_files": [[110, 138], ["glob.iglob", "int", "list", "aminer.load_acm", "os.path.join", "print", "itertools.islice", "enumerate", "print", "itertools.chain.from_iterable", "itertools.chain.from_iterable.extend", "print", "joblib.Parallel", "aminer.load_dblp", "joblib.delayed"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.load_acm", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.load_dblp"], ["", "def", "papers_from_files", "(", "path", ",", "dataset", ",", "n_jobs", "=", "1", ",", "debug", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Loads a bunch of files into a list of papers,\n    optionally sorted by id\n    \"\"\"", "\n", "if", "dataset", "==", "\"acm\"", ":", "\n", "        ", "return", "load_acm", "(", "path", ")", "\n", "\n", "", "it", "=", "glob", ".", "iglob", "(", "os", ".", "path", ".", "join", "(", "path", ",", "'*.json'", ")", ")", "\n", "if", "debug", ":", "\n", "        ", "print", "(", "\"Debug mode: using only two slices\"", ")", "\n", "it", "=", "itertools", ".", "islice", "(", "it", ",", "2", ")", "\n", "", "n_jobs", "=", "int", "(", "n_jobs", ")", "\n", "if", "n_jobs", "==", "1", ":", "\n", "        ", "papers", "=", "[", "]", "\n", "for", "i", ",", "fpath", "in", "enumerate", "(", "it", ")", ":", "\n", "            ", "papers", ".", "extend", "(", "load_dblp", "(", "fpath", ")", ")", "\n", "print", "(", "\"\\r{}\"", ".", "format", "(", "i", "+", "1", ")", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "if", "DEBUG_LIMIT", "and", "i", ">", "DEBUG_LIMIT", ":", "\n", "# Stop after `DEBUG_LIMIT` files", "\n", "# (for quick testing)", "\n", "                ", "break", "\n", "", "", "print", "(", ")", "\n", "", "else", ":", "\n", "        ", "pps", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "5", ")", "(", "delayed", "(", "load_dblp", ")", "(", "p", ")", "for", "p", "in", "it", ")", "\n", "papers", "=", "itertools", ".", "chain", ".", "from_iterable", "(", "pps", ")", "\n", "\n", "", "return", "list", "(", "papers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.aggregate_paper_info": [[140, 146], ["acc.append"], "function", ["None"], ["", "def", "aggregate_paper_info", "(", "paper", ",", "attributes", ")", ":", "\n", "    ", "acc", "=", "[", "]", "\n", "for", "attribute", "in", "attributes", ":", "\n", "        ", "if", "attribute", "in", "paper", ":", "\n", "            ", "acc", ".", "append", "(", "paper", "[", "attribute", "]", ")", "\n", "", "", "return", "' '", ".", "join", "(", "acc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.unpack_papers": [[148, 216], ["print", "ids.append", "bags_of_refs.append", "aminer.aggregate_paper_info", "len", "len", "bags_of_refs.append", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.aggregate_paper_info"], ["", "def", "unpack_papers", "(", "papers", ",", "aggregate", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Unpacks list of papers in a way that is compatible with our Bags dataset\n    format. It is not mandatory that papers are sorted.\n    \"\"\"", "\n", "# Assume track_uri is primary key for track", "\n", "if", "aggregate", "is", "not", "None", ":", "\n", "        ", "for", "attr", "in", "aggregate", ":", "\n", "            ", "assert", "attr", "in", "PAPER_INFO", "\n", "\n", "", "", "bags_of_refs", ",", "ids", ",", "side_info", ",", "years", ",", "authors", ",", "venue", "=", "[", "]", ",", "[", "]", ",", "{", "}", ",", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "title_cnt", "=", "author_cnt", "=", "ref_cnt", "=", "venue_cnt", "=", "one_ref_cnt", "=", "0", "\n", "for", "paper", "in", "papers", ":", "\n", "# Extract ids", "\n", "        ", "ids", ".", "append", "(", "paper", "[", "\"id\"", "]", ")", "\n", "# Put all ids of cited papers in here", "\n", "try", ":", "\n", "# References may be missing", "\n", "            ", "bags_of_refs", ".", "append", "(", "paper", "[", "\"references\"", "]", ")", "\n", "if", "len", "(", "paper", "[", "\"references\"", "]", ")", ">", "0", ":", "\n", "                ", "ref_cnt", "+=", "1", "\n", "", "if", "len", "(", "paper", "[", "\"references\"", "]", ")", "==", "1", ":", "\n", "                ", "one_ref_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "bags_of_refs", ".", "append", "(", "[", "]", ")", "\n", "# Use dict here such that we can also deal with unsorted ids", "\n", "", "try", ":", "\n", "            ", "side_info", "[", "paper", "[", "\"id\"", "]", "]", "=", "paper", "[", "\"title\"", "]", "\n", "if", "paper", "[", "\"title\"", "]", "!=", "\"\"", ":", "\n", "                ", "title_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "side_info", "[", "paper", "[", "\"id\"", "]", "]", "=", "\"\"", "\n", "", "try", ":", "\n", "            ", "years", "[", "paper", "[", "\"id\"", "]", "]", "=", "paper", "[", "\"year\"", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "years", "[", "paper", "[", "\"id\"", "]", "]", "=", "-", "1", "\n", "", "try", ":", "\n", "            ", "authors", "[", "paper", "[", "\"id\"", "]", "]", "=", "paper", "[", "\"authors\"", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "authors", "[", "paper", "[", "\"id\"", "]", "]", "=", "[", "]", "\n", "", "try", ":", "\n", "            ", "venue", "[", "paper", "[", "\"id\"", "]", "]", "=", "paper", "[", "\"venue\"", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "venue", "[", "paper", "[", "\"id\"", "]", "]", "=", "\"\"", "\n", "\n", "", "try", ":", "\n", "            ", "if", "len", "(", "paper", "[", "\"authors\"", "]", ")", ">", "0", ":", "\n", "                ", "author_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "pass", "\n", "", "try", ":", "\n", "            ", "if", "len", "(", "paper", "[", "\"venue\"", "]", ")", ">", "0", ":", "\n", "                ", "venue_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "pass", "\n", "\n", "# We could assemble even more side info here from the track names", "\n", "", "if", "aggregate", "is", "not", "None", ":", "\n", "            ", "aggregated_paper_info", "=", "aggregate_paper_info", "(", "paper", ",", "aggregate", ")", "\n", "side_info", "[", "paper", "[", "\"id\"", "]", "]", "+=", "' '", "+", "aggregated_paper_info", "\n", "\n", "", "", "print", "(", "\"Metadata-fields' frequencies: references={}, title={}, authors={}, venue={}, one-reference={}\"", "\n", ".", "format", "(", "ref_cnt", "/", "len", "(", "papers", ")", ",", "title_cnt", "/", "len", "(", "papers", ")", ",", "author_cnt", "/", "len", "(", "papers", ")", ",", "venue_cnt", "/", "len", "(", "papers", ")", ",", "one_ref_cnt", "/", "len", "(", "papers", ")", ")", ")", "\n", "\n", "# bag_of_refs and ids should have corresponding indices", "\n", "# In side info the id is the key", "\n", "# Re-use 'title' and year here because methods rely on it", "\n", "return", "bags_of_refs", ",", "ids", ",", "{", "\"title\"", ":", "side_info", ",", "\"year\"", ":", "years", ",", "\"author\"", ":", "authors", ",", "\"venue\"", ":", "venue", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.main": [[218, 327], ["print", "print", "aminer.papers_from_files", "print", "aminer.unpack_papers", "aaerec.datasets.Bags", "aminer.log", "aminer.log", "aaerec.evaluation.Evaluation", "aaerec.evaluation.Evaluation.setup", "aaerec.evaluation.Evaluation.", "aaerec.condition.ConditionList", "aaerec.condition.ConditionList", "print", "print", "aaerec.datasets.Bags.build_vocab", "compute_mutual_info", "print", "exit", "open", "print", "aaerec.baselines.Countbased", "aaerec.svd.SVDRecommender", "aaerec.aae.AAERecommender", "aaerec.aae.AAERecommender", "aaerec.vae.VAERecommender", "aaerec.dae.DAERecommender", "aaerec.aae.AAERecommender", "aaerec.aae.AAERecommender", "aaerec.aae.DecodingRecommender", "aaerec.vae.VAERecommender", "aaerec.dae.DAERecommender", "open", "print", "aaerec.svd.SVDRecommender", "aaerec.condition.PretrainedWordEmbeddingCondition", "aaerec.condition.PretrainedWordEmbeddingCondition", "aaerec.condition.CategoricalCondition", "aaerec.condition.PretrainedWordEmbeddingCondition"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.papers_from_files", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.aminer.unpack_papers", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.Evaluation.setup", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.utils.compute_mutual_info"], ["", "def", "main", "(", "year", ",", "dataset", ",", "min_count", "=", "None", ",", "outfile", "=", "None", ",", "drop", "=", "1", ",", "\n", "baselines", "=", "False", ",", "\n", "autoencoders", "=", "False", ",", "\n", "conditioned_autoencoders", "=", "False", ",", "\n", "all_metadata", "=", "True", ")", ":", "\n", "    ", "\"\"\" Main function for training and evaluating AAE methods on DBLP data \"\"\"", "\n", "\n", "assert", "baselines", "or", "autoencoders", "or", "conditioned_autoencoders", ",", "\"Please specify what to run\"", "\n", "\n", "\n", "if", "all_metadata", ":", "\n", "# V2 - all metadata", "\n", "        ", "CONDITIONS", "=", "ConditionList", "(", "[", "\n", "(", "'title'", ",", "PretrainedWordEmbeddingCondition", "(", "VECTORS", ")", ")", ",", "\n", "(", "'venue'", ",", "PretrainedWordEmbeddingCondition", "(", "VECTORS", ")", ")", ",", "\n", "(", "'author'", ",", "CategoricalCondition", "(", "embedding_dim", "=", "32", ",", "reduce", "=", "\"sum\"", ",", "# vocab_size=0.01,", "\n", "sparse", "=", "False", ",", "embedding_on_gpu", "=", "True", ")", ")", "\n", "]", ")", "\n", "", "else", ":", "\n", "# V1 - only title metadata", "\n", "        ", "CONDITIONS", "=", "ConditionList", "(", "[", "(", "'title'", ",", "PretrainedWordEmbeddingCondition", "(", "VECTORS", ")", ")", "]", ")", "\n", "#### CONDITOINS defined", "\n", "\n", "", "ALL_MODELS", "=", "[", "]", "\n", "\n", "if", "baselines", ":", "\n", "# Models without metadata", "\n", "        ", "BASELINES", "=", "[", "\n", "# RandomBaseline(),", "\n", "# MostPopular(),", "\n", "Countbased", "(", ")", ",", "\n", "SVDRecommender", "(", "1000", ",", "use_title", "=", "False", ")", "\n", "]", "\n", "\n", "\n", "ALL_MODELS", "+=", "BASELINES", "\n", "\n", "if", "not", "all_metadata", ":", "\n", "# SVD can use only titles not generic conditions", "\n", "            ", "ALL_MODELS", "+=", "[", "SVDRecommender", "(", "1000", ",", "use_title", "=", "True", ")", "]", "\n", "\n", "", "", "if", "autoencoders", ":", "\n", "        ", "AUTOENCODERS", "=", "[", "\n", "AAERecommender", "(", "adversarial", "=", "False", ",", "\n", "conditions", "=", "None", ",", "\n", "lr", "=", "0.001", ",", "\n", "**", "AE_PARAMS", ")", ",", "\n", "AAERecommender", "(", "adversarial", "=", "True", ",", "\n", "conditions", "=", "None", ",", "\n", "gen_lr", "=", "0.001", ",", "\n", "reg_lr", "=", "0.001", ",", "\n", "**", "AE_PARAMS", ")", ",", "\n", "VAERecommender", "(", "conditions", "=", "None", ",", "**", "AE_PARAMS", ")", ",", "\n", "DAERecommender", "(", "conditions", "=", "None", ",", "**", "AE_PARAMS", ")", "\n", "]", "\n", "ALL_MODELS", "+=", "AUTOENCODERS", "\n", "\n", "", "if", "conditioned_autoencoders", ":", "\n", "# Model with metadata (metadata used as set in CONDITIONS above)", "\n", "        ", "CONDITIONED_AUTOENCODERS", "=", "[", "\n", "AAERecommender", "(", "adversarial", "=", "False", ",", "\n", "conditions", "=", "CONDITIONS", ",", "\n", "lr", "=", "0.001", ",", "\n", "**", "AE_PARAMS", ")", ",", "\n", "AAERecommender", "(", "adversarial", "=", "True", ",", "\n", "conditions", "=", "CONDITIONS", ",", "\n", "gen_lr", "=", "0.001", ",", "\n", "reg_lr", "=", "0.001", ",", "\n", "**", "AE_PARAMS", ")", ",", "\n", "DecodingRecommender", "(", "CONDITIONS", ",", "\n", "n_epochs", "=", "100", ",", "batch_size", "=", "1000", ",", "optimizer", "=", "'adam'", ",", "\n", "n_hidden", "=", "100", ",", "lr", "=", "0.001", ",", "verbose", "=", "True", ")", ",", "\n", "VAERecommender", "(", "conditions", "=", "CONDITIONS", ",", "**", "AE_PARAMS", ")", ",", "\n", "DAERecommender", "(", "conditions", "=", "CONDITIONS", ",", "**", "AE_PARAMS", ")", "\n", "]", "\n", "ALL_MODELS", "+=", "CONDITIONED_AUTOENCODERS", "\n", "\n", "\n", "", "print", "(", "\"Finished preparing models:\"", ",", "*", "ALL_MODELS", ",", "sep", "=", "'\\n\\t'", ")", "\n", "\n", "\n", "path", "=", "DATA_PATH", "+", "(", "\"dblp-ref/\"", "if", "dataset", "==", "\"dblp\"", "else", "\"acm.txt\"", ")", "\n", "print", "(", "\"Loading data from\"", ",", "path", ")", "\n", "papers", "=", "papers_from_files", "(", "path", ",", "dataset", ",", "n_jobs", "=", "4", ")", "\n", "print", "(", "\"Unpacking {} data...\"", ".", "format", "(", "dataset", ")", ")", "\n", "bags_of_papers", ",", "ids", ",", "side_info", "=", "unpack_papers", "(", "papers", ")", "\n", "del", "papers", "\n", "bags", "=", "Bags", "(", "bags_of_papers", ",", "ids", ",", "side_info", ")", "\n", "if", "args", ".", "compute_mi", ":", "\n", "        ", "from", "aaerec", ".", "utils", "import", "compute_mutual_info", "\n", "print", "(", "\"[MI] Dataset:\"", ",", "dataset", ")", "\n", "print", "(", "\"[MI] min Count:\"", ",", "min_count", ")", "\n", "tmp", "=", "bags", ".", "build_vocab", "(", "min_count", "=", "min_count", ",", "max_features", "=", "None", ")", "\n", "mi", "=", "compute_mutual_info", "(", "tmp", ",", "conditions", "=", "None", ",", "include_labels", "=", "True", ",", "\n", "normalize", "=", "True", ")", "\n", "with", "open", "(", "'mi.csv'", ",", "'a'", ")", "as", "mifile", ":", "\n", "            ", "print", "(", "dataset", ",", "min_count", ",", "mi", ",", "sep", "=", "','", ",", "file", "=", "mifile", ")", "\n", "\n", "", "print", "(", "\"=\"", "*", "78", ")", "\n", "exit", "(", "0", ")", "\n", "\n", "", "log", "(", "\"Whole dataset:\"", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "bags", ",", "logfile", "=", "outfile", ")", "\n", "\n", "evaluation", "=", "Evaluation", "(", "bags", ",", "year", ",", "logfile", "=", "outfile", ")", "\n", "evaluation", ".", "setup", "(", "min_count", "=", "min_count", ",", "min_elements", "=", "2", ",", "drop", "=", "drop", ")", "\n", "with", "open", "(", "outfile", ",", "'a'", ")", "as", "fh", ":", "\n", "        ", "print", "(", "\"~ Partial List + Titles + Author + Venue\"", ",", "\"~\"", "*", "42", ",", "file", "=", "fh", ")", "\n", "", "evaluation", "(", "ALL_MODELS", ",", "batch_size", "=", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.prepare_evaluation": [[87, 113], ["bags.train_test_split", "train_set.apply_vocab.build_vocab", "train_set.apply_vocab.apply_vocab", "dev_set.apply_vocab.apply_vocab", "print", "aaerec.datasets.corrupt_sets", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.train_test_split", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.corrupt_sets"], ["def", "prepare_evaluation", "(", "bags", ",", "test_size", "=", "0.1", ",", "n_items", "=", "None", ",", "min_count", "=", "None", ",", "drop", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Split data into train and dev set.\n    Build vocab on train set and applies it to both train and test set.\n    \"\"\"", "\n", "# Split 10% validation data, one submission per day is too much.", "\n", "train_set", ",", "dev_set", "=", "bags", ".", "train_test_split", "(", "test_size", "=", "test_size", ")", "\n", "# Builds vocabulary only on training set", "\n", "# Limit of most frequent 50000 distinct items is for testing purposes", "\n", "vocab", ",", "__counts", "=", "train_set", ".", "build_vocab", "(", "max_features", "=", "n_items", ",", "\n", "min_count", "=", "min_count", ",", "\n", "apply", "=", "False", ")", "\n", "\n", "# Apply vocab (turn track ids into indices)", "\n", "train_set", "=", "train_set", ".", "apply_vocab", "(", "vocab", ")", "\n", "# Discard unknown tokens in the test set", "\n", "dev_set", "=", "dev_set", ".", "apply_vocab", "(", "vocab", ")", "\n", "\n", "# Drop one track off each playlist within test set", "\n", "print", "(", "\"Drop parameter:\"", ",", "drop", ")", "\n", "noisy", ",", "missing", "=", "corrupt_sets", "(", "dev_set", ".", "data", ",", "drop", "=", "drop", ")", "\n", "assert", "len", "(", "noisy", ")", "==", "len", "(", "missing", ")", "==", "len", "(", "dev_set", ")", "\n", "# Replace test data with corrupted data", "\n", "dev_set", ".", "data", "=", "noisy", "\n", "\n", "return", "train_set", ",", "dev_set", ",", "missing", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log": [[115, 121], ["print", "open", "print"], "function", ["None"], ["", "def", "log", "(", "*", "print_args", ",", "logfile", "=", "None", ")", ":", "\n", "    ", "\"\"\" Maybe logs the output also in the file `outfile` \"\"\"", "\n", "if", "logfile", ":", "\n", "        ", "with", "open", "(", "logfile", ",", "'a'", ")", "as", "fhandle", ":", "\n", "            ", "print", "(", "*", "print_args", ",", "file", "=", "fhandle", ")", "\n", "", "", "print", "(", "*", "print_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.main": [[123, 183], ["print", "aaerec.datasets.Bags.load_tabcomma_format", "rcv.log", "rcv.log", "rcv.prepare_evaluation", "rcv.log", "rcv.log", "rcv.log", "rcv.log", "aaerec.transforms.lists2sparse().tocsr", "aaerec.transforms.lists2sparse().tocsr", "print", "print", "Bags.load_tabcomma_format.build_vocab", "compute_mutual_info", "print", "exit", "rcv.log", "rcv.log", "model.train", "model.predict", "scipy.issparse", "aaerec.evaluation.remove_non_missing", "aaerec.evaluation.evaluate", "rcv.log", "zip", "rcv.log", "open", "print", "aaerec.transforms.lists2sparse", "aaerec.transforms.lists2sparse", "np.asarray.toarray", "numpy.asarray", "rcv.log", "dev_set.size", "dev_set.size"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.Bags.load_tabcomma_format", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.prepare_evaluation", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.utils.compute_mutual_info", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.predict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.remove_non_missing", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.evaluate", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2sparse", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2sparse", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "main", "(", "outfile", "=", "None", ",", "min_count", "=", "None", ",", "drop", "=", "1", ")", ":", "\n", "    ", "\"\"\" Main function for training and evaluating AAE methods on Reuters data \"\"\"", "\n", "print", "(", "\"Loading data from\"", ",", "DATA_PATH", ")", "\n", "bags", "=", "Bags", ".", "load_tabcomma_format", "(", "DATA_PATH", ",", "unique", "=", "True", ")", "\n", "if", "args", ".", "compute_mi", ":", "\n", "        ", "from", "aaerec", ".", "utils", "import", "compute_mutual_info", "\n", "print", "(", "\"[MI] Dataset: Reuters\"", ")", "\n", "print", "(", "\"[MI] min Count:\"", ",", "min_count", ")", "\n", "tmp", "=", "bags", ".", "build_vocab", "(", "min_count", "=", "min_count", ",", "max_features", "=", "None", ")", "\n", "mi", "=", "compute_mutual_info", "(", "tmp", ",", "conditions", "=", "None", ",", "include_labels", "=", "True", ",", "\n", "normalize", "=", "True", ")", "\n", "with", "open", "(", "'mi.csv'", ",", "'a'", ")", "as", "mifile", ":", "\n", "            ", "print", "(", "'Reuters'", ",", "min_count", ",", "mi", ",", "sep", "=", "','", ",", "file", "=", "mifile", ")", "\n", "", "print", "(", "\"=\"", "*", "78", ")", "\n", "exit", "(", "0", ")", "\n", "", "log", "(", "\"Whole dataset:\"", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "bags", ",", "logfile", "=", "outfile", ")", "\n", "train_set", ",", "dev_set", ",", "y_test", "=", "prepare_evaluation", "(", "bags", ",", "\n", "min_count", "=", "min_count", ",", "\n", "drop", "=", "drop", ")", "\n", "\n", "log", "(", "\"Train set:\"", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "train_set", ",", "logfile", "=", "outfile", ")", "\n", "\n", "log", "(", "\"Dev set:\"", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "dev_set", ",", "logfile", "=", "outfile", ")", "\n", "\n", "# THE GOLD (put into sparse matrix)", "\n", "y_test", "=", "lists2sparse", "(", "y_test", ",", "dev_set", ".", "size", "(", "1", ")", ")", ".", "tocsr", "(", "copy", "=", "False", ")", "\n", "\n", "# the known items in the test set, just to not recompute", "\n", "x_test", "=", "lists2sparse", "(", "dev_set", ".", "data", ",", "dev_set", ".", "size", "(", "1", ")", ")", ".", "tocsr", "(", "copy", "=", "False", ")", "\n", "\n", "for", "model", "in", "MODELS", ":", "\n", "        ", "log", "(", "'='", "*", "78", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "model", ",", "logfile", "=", "outfile", ")", "\n", "\n", "# Training", "\n", "model", ".", "train", "(", "train_set", ")", "\n", "\n", "# Prediction", "\n", "y_pred", "=", "model", ".", "predict", "(", "dev_set", ")", "\n", "\n", "# Sanity-fix #1, make sparse stuff dense, expect array", "\n", "if", "sp", ".", "issparse", "(", "y_pred", ")", ":", "\n", "            ", "y_pred", "=", "y_pred", ".", "toarray", "(", ")", "\n", "", "else", ":", "\n", "            ", "y_pred", "=", "np", ".", "asarray", "(", "y_pred", ")", "\n", "\n", "# Sanity-fix, remove predictions for already present items", "\n", "", "y_pred", "=", "remove_non_missing", "(", "y_pred", ",", "x_test", ",", "copy", "=", "False", ")", "\n", "\n", "# Evaluate metrics", "\n", "results", "=", "evaluate", "(", "y_test", ",", "y_pred", ",", "METRICS", ")", "\n", "\n", "log", "(", "\"-\"", "*", "78", ",", "logfile", "=", "outfile", ")", "\n", "for", "metric", ",", "stats", "in", "zip", "(", "METRICS", ",", "results", ")", ":", "\n", "            ", "log", "(", "\"* {}: {} ({})\"", ".", "format", "(", "metric", ",", "*", "stats", ")", ",", "logfile", "=", "outfile", ")", "\n", "\n", "", "log", "(", "'='", "*", "78", ",", "logfile", "=", "outfile", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_stats.main": [[9, 39], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "eval.mpd.mpd.load", "print", "print", "print", "print", "print", "len", "len", "collections.Counter", "collections.Counter", "len", "collections.Counter", "len", "collections.Counter", "numpy.array", "print", "print", "np.array.mean", "np.array.std"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'jsonfile'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "playlists", "=", "load", "(", "args", ".", "jsonfile", ")", "\n", "\n", "print", "(", "\"N =\"", ",", "len", "(", "playlists", ")", ")", "\n", "\n", "lens", "=", "[", "len", "(", "p", "[", "'tracks'", "]", ")", "for", "p", "in", "playlists", "]", "\n", "\n", "print", "(", "\"Playlist track count:\"", ",", "Counter", "(", "lens", ")", ")", "\n", "\n", "has_playlist", "=", "[", "'name'", "in", "p", "for", "p", "in", "playlists", "]", "\n", "print", "(", "\"Has playlist name:\"", ",", "Counter", "(", "has_playlist", ")", ")", "\n", "\n", "nameless_lens", "=", "[", "len", "(", "p", "[", "'tracks'", "]", ")", "for", "p", "in", "playlists", "if", "'name'", "not", "in", "p", "]", "\n", "print", "(", "\"Playlist track count among nameless:\"", ",", "Counter", "(", "nameless_lens", ")", ")", "\n", "\n", "named_lens", "=", "[", "len", "(", "p", "[", "'tracks'", "]", ")", "for", "p", "in", "playlists", "if", "'name'", "in", "p", "]", "\n", "print", "(", "\"Playlist track count among nameless:\"", ",", "Counter", "(", "named_lens", ")", ")", "\n", "\n", "\n", "try", ":", "\n", "        ", "holdouts", "=", "np", ".", "array", "(", "[", "p", "[", "'num_holdouts'", "]", "for", "p", "in", "playlists", "]", ")", "\n", "print", "(", "\"Holdouts: {:.2f} {:.2f}\"", ".", "format", "(", "holdouts", ".", "mean", "(", ")", ",", "holdouts", ".", "std", "(", ")", ")", ")", "\n", "", "except", "KeyError", ":", "\n", "        ", "print", "(", "\"[warn] Num holdouts property missing\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load": [[85, 90], ["open", "json.load"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load"], ["", "def", "load", "(", "path", ")", ":", "\n", "    ", "\"\"\" Loads a single slice \"\"\"", "\n", "with", "open", "(", "path", ",", "'r'", ")", "as", "fhandle", ":", "\n", "        ", "obj", "=", "json", ".", "load", "(", "fhandle", ")", "\n", "", "return", "obj", "[", "\"playlists\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.playlists_from_slices": [[92, 138], ["glob.glob", "int", "os.path.join", "print", "print", "enumerate", "len", "playlists.extend", "print", "joblib.Parallel", "mpd.load", "print", "itertools.chain.from_iterable", "joblib.delayed", "os.path.split", "os.path.split"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load"], ["", "def", "playlists_from_slices", "(", "slices_dir", ",", "n_jobs", "=", "1", ",", "debug", "=", "False", ",", "only", "=", "None", ",", "without", "=", "None", ",", "verbose", "=", "5", ")", ":", "\n", "    ", "\"\"\"\n    Loads a bunch of slices into a list of playlists,\n    optionally sorted by id\n\n    :param slices_dir:\n    :param n_jobs:\n    :param debug:\n    :param only:\n    :param without:\n    :param verbose:\n    :return:\n    \"\"\"", "\n", "\n", "it", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "slices_dir", ",", "'*.json'", ")", ")", "\n", "\n", "# Stuff to deal with dev set penc", "\n", "if", "only", ":", "\n", "        ", "it", "=", "[", "path", "for", "path", "in", "it", "if", "os", ".", "path", ".", "split", "(", "path", ")", "[", "1", "]", "in", "only", "]", "\n", "", "if", "without", ":", "\n", "        ", "it", "=", "[", "path", "for", "path", "in", "it", "if", "os", ".", "path", ".", "split", "(", "path", ")", "[", "1", "]", "not", "in", "without", "]", "\n", "\n", "", "if", "debug", ":", "\n", "        ", "print", "(", "\"Debug mode: using only two slices\"", ")", "\n", "it", "=", "it", "[", ":", "2", "]", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Loading\"", ",", "len", "(", "it", ")", ",", "\"slices using\"", ",", "n_jobs", ",", "\"jobs.\"", ")", "\n", "", "n_jobs", "=", "int", "(", "n_jobs", ")", "\n", "if", "n_jobs", "==", "1", ":", "\n", "        ", "playlists", "=", "[", "]", "\n", "for", "i", ",", "fpath", "in", "enumerate", "(", "it", ")", ":", "\n", "            ", "playlists", ".", "extend", "(", "load", "(", "fpath", ")", ")", "\n", "if", "verbose", ":", "\n", "                ", "print", "(", "\"\\r{}\"", ".", "format", "(", "i", "+", "1", ")", ",", "end", "=", "''", ",", "flush", "=", "True", ")", "\n", "", "if", "DEBUG_LIMIT", "and", "i", ">", "DEBUG_LIMIT", ":", "\n", "# Stop after `DEBUG_LIMIT` files", "\n", "# (for quick testing)", "\n", "                ", "break", "\n", "", "", "if", "verbose", ":", "\n", "            ", "print", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "pps", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "verbose", ")", "(", "delayed", "(", "load", ")", "(", "p", ")", "for", "p", "in", "it", ")", "\n", "playlists", "=", "[", "l", "for", "l", "in", "itertools", ".", "chain", ".", "from_iterable", "(", "pps", ")", "]", "\n", "\n", "", "return", "playlists", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.aggregate_track_info": [[140, 155], ["acc.append"], "function", ["None"], ["", "def", "aggregate_track_info", "(", "playlist", ",", "attributes", ")", ":", "\n", "    ", "\"\"\"\n\n    :param playlist: dict, one playlist instance with it's information\n    :param attributes: iterable, keys of 'tracks' in playlist\n    :return: str, bag of words all side info combined\n    \"\"\"", "\n", "if", "'tracks'", "not", "in", "playlist", ":", "\n", "        ", "return", "''", "\n", "", "acc", "=", "[", "]", "\n", "for", "track", "in", "playlist", "[", "'tracks'", "]", ":", "\n", "        ", "for", "attribute", "in", "attributes", ":", "\n", "            ", "if", "attribute", "in", "track", ":", "\n", "                ", "acc", ".", "append", "(", "track", "[", "attribute", "]", ")", "\n", "", "", "", "return", "' '", ".", "join", "(", "acc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.unpack_playlists": [[157, 224], ["print", "print", "pids.append", "bags_of_tracks.append", "len", "mpd.aggregate_track_info", "len", "len", "len", "len", "len", "counted_tracks.keys", "counted_tracks.keys", "counted_tracks.keys"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.aggregate_track_info"], ["", "def", "unpack_playlists", "(", "playlists", ",", "aggregate", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Unpacks list of playlists in a way that is compatible with our Bags dataset\n    format. It is not mandatory that playlists are sorted.\n    \"\"\"", "\n", "# Assume track_uri is primary key for track", "\n", "if", "aggregate", "is", "not", "None", ":", "\n", "        ", "for", "attr", "in", "aggregate", ":", "\n", "            ", "assert", "attr", "in", "TRACK_INFO", "\n", "\n", "", "", "bags_of_tracks", ",", "pids", ",", "side_info", "=", "[", "]", ",", "[", "]", ",", "{", "}", "\n", "tracks_cnt", ",", "playlist_name_cnt", ",", "track_name_cnt", ",", "artist_cnt", ",", "album_cnt", "=", "0", ",", "0", ",", "0", ",", "0", ",", "0", "\n", "counted_tracks", "=", "{", "}", "\n", "for", "playlist", "in", "playlists", ":", "\n", "# Extract pids", "\n", "        ", "pids", ".", "append", "(", "playlist", "[", "\"pid\"", "]", ")", "\n", "# Put all tracks of the playlists in here", "\n", "bags_of_tracks", ".", "append", "(", "[", "t", "[", "\"track_uri\"", "]", "for", "t", "in", "playlist", "[", "\"tracks\"", "]", "]", ")", "\n", "if", "len", "(", "playlist", "[", "\"tracks\"", "]", ")", ">", "0", ":", "\n", "            ", "tracks_cnt", "+=", "1", "\n", "# Use dict here such that we can also deal with unsorted pids", "\n", "", "try", ":", "\n", "            ", "side_info", "[", "playlist", "[", "\"pid\"", "]", "]", "=", "playlist", "[", "\"name\"", "]", "\n", "if", "playlist", "[", "\"name\"", "]", "!=", "\"\"", ":", "\n", "                ", "playlist_name_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "            ", "side_info", "[", "playlist", "[", "\"pid\"", "]", "]", "=", "\"\"", "\n", "\n", "# We could assemble even more side info here from the track names", "\n", "", "if", "aggregate", "is", "not", "None", ":", "\n", "            ", "aggregated_track_info", "=", "aggregate_track_info", "(", "playlist", ",", "aggregate", ")", "\n", "side_info", "[", "playlist", "[", "\"pid\"", "]", "]", "+=", "' '", "+", "aggregated_track_info", "\n", "\n", "", "for", "t", "in", "playlist", "[", "\"tracks\"", "]", ":", "\n", "            ", "try", ":", "\n", "                ", "if", "counted_tracks", "[", "t", "[", "\"track_uri\"", "]", "]", "is", "True", ":", "\n", "                    ", "continue", "\n", "", "", "except", "KeyError", ":", "\n", "                ", "pass", "\n", "", "counted_tracks", "[", "t", "[", "\"track_uri\"", "]", "]", "=", "True", "\n", "try", ":", "\n", "                ", "if", "t", "[", "\"track_name\"", "]", "!=", "\"\"", ":", "\n", "                    ", "track_name_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "                ", "pass", "\n", "", "try", ":", "\n", "                ", "if", "t", "[", "\"artist_name\"", "]", "!=", "\"\"", ":", "\n", "                    ", "artist_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "                ", "pass", "\n", "", "try", ":", "\n", "                ", "if", "t", "[", "\"album_name\"", "]", "!=", "\"\"", ":", "\n", "                    ", "album_cnt", "+=", "1", "\n", "", "", "except", "KeyError", ":", "\n", "                ", "pass", "\n", "\n", "", "", "", "print", "(", "\"Metadata-fields' frequencies: tracks={}, playlist title={}, track title={}, artist={}, album={}\"", "\n", ".", "format", "(", "tracks_cnt", "/", "len", "(", "playlists", ")", ",", "playlist_name_cnt", "/", "len", "(", "playlists", ")", ",", "\n", "track_name_cnt", "/", "len", "(", "counted_tracks", ".", "keys", "(", ")", ")", ",", "\n", "artist_cnt", "/", "len", "(", "counted_tracks", ".", "keys", "(", ")", ")", ",", "album_cnt", "/", "len", "(", "counted_tracks", ".", "keys", "(", ")", ")", ")", ")", "\n", "print", "(", "\"Tracks and playlist-titles' frequency computed over the playlist number; \"", "\n", "\"track title, artist, album over the track number\"", ")", "\n", "\n", "# bag_of_tracks and pids should have corresponding indices", "\n", "# In side info the pid is the key", "\n", "# Re-use 'title' property here because methods rely on it", "\n", "return", "bags_of_tracks", ",", "pids", ",", "{", "\"title\"", ":", "side_info", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.unpack_playlists_for_models_concatenated": [[226, 274], ["print", "pids.append", "bags_of_tracks.append", "enlisted_track_info.append"], "function", ["None"], ["", "def", "unpack_playlists_for_models_concatenated", "(", "playlists", ")", ":", "\n", "    ", "\"\"\"\n    Unpacks list of playlists in a way that makes them ready for the models .train step.\n    It is not mandatory that playlists are sorted.\n    :param playlists: a dictionary, of playlists\n    :param aggregate: an iterable, of potential names in the track model name space\n    :param condition_name: a string, side info name, which to retrieve\n    :return:\n    \"\"\"", "\n", "# Assume track_uri is primary key for track", "\n", "\n", "condition_names", "=", "PLAYLIST_INFO", "+", "TRACK_INFO", "\n", "print", "(", "condition_names", ")", "\n", "bags_of_tracks", ",", "pids", "=", "[", "]", ",", "[", "]", "\n", "side_infos", "=", "{", "condition", ":", "{", "}", "for", "condition", "in", "condition_names", "}", "\n", "for", "playlist", "in", "playlists", ":", "\n", "# Extract pids", "\n", "        ", "pids", ".", "append", "(", "playlist", "[", "\"pid\"", "]", ")", "\n", "# Put all tracks of the playlists in here", "\n", "bags_of_tracks", ".", "append", "(", "[", "t", "[", "\"track_uri\"", "]", "for", "t", "in", "playlist", "[", "\"tracks\"", "]", "]", ")", "\n", "# Use dict here such that we can also deal with unsorted pids", "\n", "\n", "for", "condition", "in", "condition_names", ":", "\n", "            ", "if", "condition", "in", "PLAYLIST_INFO", ":", "\n", "# stored: self.owner_attributes = side_info", "\n", "# called: self.owner_attributes[attribute][owner] # owner == pid", "\n", "# before: side_info[playlist[\"pid\"]] = playlist[\"name\"]", "\n", "# ordering doesn't matter as it's always called with pid together", "\n", "                ", "extracted_condition", "=", "playlist", "[", "condition", "]", "# whats coming out of playlist here? a string", "\n", "# TODO: think about more efficient handling via numpy/pandas in Bag class through slicing availability", "\n", "", "else", ":", "\n", "# TODO: add it in doctex", "\n", "                ", "enlisted_track_info", "=", "[", "]", "\n", "for", "track", "in", "playlist", "[", "\"tracks\"", "]", ":", "\n", "                    ", "enlisted_track_info", ".", "append", "(", "track", "[", "condition", "]", ")", "\n", "", "extracted_condition", "=", "\" \"", ".", "join", "(", "enlisted_track_info", ")", "\n", "\n", "", "side_infos", "[", "condition", "]", "[", "playlist", "[", "\"pid\"", "]", "]", "=", "extracted_condition", "\n", "\n", "# for attr in side_infos:", "\n", "#     print(attr)", "\n", "#     for pid in list(side_infos[attr].keys())[:3]:", "\n", "#         print(pid,side_infos[attr][pid])", "\n", "\n", "# bag_of_tracks and pids should have corresponding indices", "\n", "# In side info the pid is the key", "\n", "# Re-use 'title' property here because methods rely on it", "\n", "", "", "return", "bags_of_tracks", ",", "pids", ",", "side_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.prepare_evaluation": [[276, 301], ["bags.train_test_split", "train_set.apply_vocab.build_vocab", "train_set.apply_vocab.apply_vocab", "dev_set.apply_vocab.apply_vocab", "aaerec.datasets.corrupt_sets", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.train_test_split", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.corrupt_sets"], ["", "def", "prepare_evaluation", "(", "bags", ",", "test_size", "=", "0.1", ",", "n_items", "=", "None", ",", "min_count", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Split data into train and dev set.\n    Build vocab on train set and applies it to both train and test set.\n    \"\"\"", "\n", "# Split 10% validation data, one submission per day is too much.", "\n", "train_set", ",", "dev_set", "=", "bags", ".", "train_test_split", "(", "test_size", "=", "test_size", ")", "\n", "# Builds vocabulary only on training set", "\n", "# Limit of most frequent 50000 distinct items is for testing purposes", "\n", "vocab", ",", "__counts", "=", "train_set", ".", "build_vocab", "(", "max_features", "=", "n_items", ",", "\n", "min_count", "=", "min_count", ",", "\n", "apply", "=", "False", ")", "\n", "\n", "# Apply vocab (turn track ids into indices)", "\n", "train_set", "=", "train_set", ".", "apply_vocab", "(", "vocab", ")", "\n", "# Discard unknown tokens in the test set", "\n", "dev_set", "=", "dev_set", ".", "apply_vocab", "(", "vocab", ")", "\n", "\n", "# Drop one track off each playlist within test set", "\n", "noisy", ",", "missing", "=", "corrupt_sets", "(", "dev_set", ".", "data", ",", "drop", "=", "1", ")", "\n", "assert", "len", "(", "noisy", ")", "==", "len", "(", "missing", ")", "==", "len", "(", "dev_set", ")", "\n", "# Replace test data with corrupted data", "\n", "dev_set", ".", "data", "=", "noisy", "\n", "\n", "return", "train_set", ",", "dev_set", ",", "missing", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.main": [[305, 376], ["print", "mpd.playlists_from_slices", "print", "mpd.unpack_playlists_for_models_concatenated", "aaerec.datasets.Bags", "log", "log", "mpd.prepare_evaluation", "log", "log", "log", "log", "aaerec.transforms.lists2sparse().tocsr", "aaerec.transforms.lists2sparse().tocsr", "print", "aaerec.datasets.Bags.build_vocab().tocsr", "print", "print", "exit", "log", "log", "log", "model.train", "print", "model.predict", "print", "print", "scipy.issparse", "print", "aaerec.evaluation.remove_non_missing", "print", "aaerec.evaluation.evaluate", "print", "log", "zip", "log", "mutual_info_score", "aaerec.transforms.lists2sparse", "aaerec.transforms.lists2sparse", "scipy.issparse", "np.asarray.toarray", "numpy.asarray", "log", "aaerec.datasets.Bags.build_vocab", "dev_set.size", "dev_set.size"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.playlists_from_slices", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.unpack_playlists_for_models_concatenated", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.prepare_evaluation", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.predict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.remove_non_missing", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.evaluate", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2sparse", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.transforms.lists2sparse", "home.repos.pwc.inspect_result.lgalke_aae-recommender.eval.rcv.log", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "main", "(", "outfile", "=", "None", ",", "min_count", "=", "None", ",", "aggregate", "=", "None", ")", ":", "\n", "    ", "\"\"\" Main function for training and evaluating AAE methods on MDP data \"\"\"", "\n", "print", "(", "\"Loading data from\"", ",", "DATA_PATH", ")", "\n", "playlists", "=", "playlists_from_slices", "(", "DATA_PATH", ",", "n_jobs", "=", "4", ")", "\n", "print", "(", "\"Unpacking json data...\"", ")", "\n", "bags_of_tracks", ",", "pids", ",", "side_info", "=", "unpack_playlists_for_models_concatenated", "(", "playlists", ")", "\n", "\n", "del", "playlists", "\n", "bags", "=", "Bags", "(", "data", "=", "bags_of_tracks", ",", "owners", "=", "pids", ",", "owner_attributes", "=", "side_info", ")", "\n", "if", "args", ".", "compute_mi", ":", "\n", "        ", "from", "sklearn", ".", "metrics", "import", "mutual_info_score", "\n", "print", "(", "\"Computing MI\"", ")", "\n", "X", "=", "bags", ".", "build_vocab", "(", "min_count", "=", "args", ".", "min_count", ",", "max_features", "=", "None", ")", ".", "tocsr", "(", ")", "\n", "C", "=", "X", ".", "T", "@", "X", "\n", "print", "(", "\"(Pairwise) mutual information:\"", ",", "mutual_info_score", "(", "None", ",", "None", ",", "contingency", "=", "C", ")", ")", "\n", "# Exit in this case", "\n", "print", "(", "\"Bye.\"", ")", "\n", "exit", "(", "0", ")", "\n", "\n", "", "log", "(", "\"Whole dataset:\"", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "bags", ",", "logfile", "=", "outfile", ")", "\n", "train_set", ",", "dev_set", ",", "y_test", "=", "prepare_evaluation", "(", "bags", ",", "\n", "n_items", "=", "N_ITEMS", ",", "\n", "min_count", "=", "min_count", ")", "\n", "\n", "log", "(", "\"Train set:\"", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "train_set", ",", "logfile", "=", "outfile", ")", "\n", "\n", "log", "(", "\"Dev set:\"", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "dev_set", ",", "logfile", "=", "outfile", ")", "\n", "\n", "# THE GOLD (put into sparse matrix)", "\n", "y_test", "=", "lists2sparse", "(", "y_test", ",", "dev_set", ".", "size", "(", "1", ")", ")", ".", "tocsr", "(", "copy", "=", "False", ")", "\n", "\n", "# the known items in the test set, just to not recompute", "\n", "x_test", "=", "lists2sparse", "(", "dev_set", ".", "data", ",", "dev_set", ".", "size", "(", "1", ")", ")", ".", "tocsr", "(", "copy", "=", "False", ")", "\n", "\n", "for", "model", "in", "MODELS", ":", "\n", "        ", "log", "(", "'='", "*", "78", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "model", ",", "logfile", "=", "outfile", ")", "\n", "log", "(", "model", ".", "model_params", ",", "logfile", "=", "outfile", ")", "\n", "\n", "# Training", "\n", "model", ".", "train", "(", "train_set", ")", "\n", "print", "(", "\"training finished\"", ")", "\n", "\n", "# Prediction", "\n", "y_pred", "=", "model", ".", "predict", "(", "dev_set", ")", "\n", "print", "(", "\"prediction finished\"", ")", "\n", "\n", "print", "(", "\" prediction sparse?:\"", ",", "sp", ".", "issparse", "(", "y_pred", ")", ")", "\n", "# Sanity-fix #1, make sparse stuff dense, expect array", "\n", "if", "sp", ".", "issparse", "(", "y_pred", ")", ":", "\n", "            ", "y_pred", "=", "y_pred", ".", "toarray", "(", ")", "\n", "", "else", ":", "\n", "            ", "y_pred", "=", "np", ".", "asarray", "(", "y_pred", ")", "\n", "\n", "", "print", "(", "\"remove non-missing:\"", ")", "\n", "# Sanity-fix, remove predictions for already present items", "\n", "y_pred", "=", "remove_non_missing", "(", "y_pred", ",", "x_test", ",", "copy", "=", "False", ")", "\n", "\n", "print", "(", "\"evaluate:\"", ")", "\n", "# Evaluate metrics", "\n", "results", "=", "evaluate", "(", "y_test", ",", "y_pred", ",", "METRICS", ",", "batch_size", "=", "500", ")", "\n", "\n", "print", "(", "\"metrics: \"", ")", "\n", "log", "(", "\"-\"", "*", "78", ",", "logfile", "=", "outfile", ")", "\n", "for", "metric", ",", "stats", "in", "zip", "(", "METRICS", ",", "results", ")", ":", "\n", "            ", "log", "(", "\"* {}: {} ({})\"", ".", "format", "(", "metric", ",", "*", "stats", ")", ",", "logfile", "=", "outfile", ")", "\n", "\n", "", "log", "(", "'='", "*", "78", ",", "logfile", "=", "outfile", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.r_precision": [[43, 52], ["set", "len", "float", "len", "set().intersection", "set"], "function", ["None"], ["def", "r_precision", "(", "targets", ",", "predictions", ",", "max_n_predictions", "=", "500", ")", ":", "\n", "# Assumes predictions are sorted by relevance", "\n", "# First, cap the number of predictions", "\n", "    ", "predictions", "=", "predictions", "[", ":", "max_n_predictions", "]", "\n", "\n", "# Calculate metric", "\n", "target_set", "=", "set", "(", "targets", ")", "\n", "target_count", "=", "len", "(", "target_set", ")", "\n", "return", "float", "(", "len", "(", "set", "(", "predictions", "[", ":", "target_count", "]", ")", ".", "intersection", "(", "target_set", ")", ")", ")", "/", "target_count", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.dcg": [[53, 81], ["mpd_metrics.__get_unique", "mpd_metrics.__get_unique", "numpy.sum", "float", "len", "len", "numpy.log2", "numpy.arange", "len"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.__get_unique", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.__get_unique"], ["", "def", "dcg", "(", "relevant_elements", ",", "retrieved_elements", ",", "k", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Compute the Discounted Cumulative Gain.\n\n    Rewards elements being retrieved in descending order of relevance.\n    \\[ DCG = rel_1 + \\sum_{i=2}^{|R|} \\frac{rel_i}{\\log_2(i + 1)} \\]\n\n    Args:\n        retrieved_elements (list): List of retrieved elements\n        relevant_elements (list): List of relevant elements\n        k (int): 1-based index of the maximum element in retrieved_elements\n        taken in the computation\n\n    Note: The vector `retrieved_elements` is truncated at first, THEN\n    deduplication is done, keeping only the first occurence of each element.\n\n    Returns:\n        DCG value\n\n    \"\"\"", "\n", "retrieved_elements", "=", "__get_unique", "(", "retrieved_elements", "[", ":", "k", "]", ")", "\n", "relevant_elements", "=", "__get_unique", "(", "relevant_elements", ")", "\n", "if", "len", "(", "retrieved_elements", ")", "==", "0", "or", "len", "(", "relevant_elements", ")", "==", "0", ":", "\n", "        ", "return", "0.0", "\n", "# Computes an ordered vector of 1.0 and 0.0", "\n", "", "score", "=", "[", "float", "(", "el", "in", "relevant_elements", ")", "for", "el", "in", "retrieved_elements", "]", "\n", "# return score[0] + np.sum(score[1:] / np.log2(", "\n", "#     1 + np.arange(2, len(score) + 1)))", "\n", "return", "np", ".", "sum", "(", "score", "/", "np", ".", "log2", "(", "1", "+", "np", ".", "arange", "(", "1", ",", "len", "(", "score", ")", "+", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.ndcg": [[83, 120], ["mpd_metrics.dcg", "mpd_metrics.dcg", "min", "ValueError", "len"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.dcg", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.dcg"], ["", "def", "ndcg", "(", "relevant_elements", ",", "retrieved_elements", ",", "k", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "r\"\"\"Compute the Normalized Discounted Cumulative Gain.\n\n    Rewards elements being retrieved in descending order of relevance.\n    The metric is determined by calculating the DCG and dividing it by the\n    ideal or optimal DCG in the case that all recommended tracks are relevant.\n\n    Note:\n    The ideal DCG or IDCG is on our case equal to:\n    \\[ IDCG = 1+\\sum_{i=2}^{min(\\left| G \\right|, k)}\\frac{1}{\\log_2(i +1)}\\]\n    If the size of the set intersection of \\( G \\) and \\( R \\), is empty, then\n    the IDCG is equal to 0. The NDCG metric is now calculated as:\n    \\[ NDCG = \\frac{DCG}{IDCG + \\delta} \\]\n    with \\( \\delta \\) a (very) small constant.\n    The vector `retrieved_elements` is truncated at first, THEN\n    deduplication is done, keeping only the first occurence of each element.\n\n    Args:\n        retrieved_elements (list): List of retrieved elements\n        relevant_elements (list): List of relevant elements\n        k (int): 1-based index of the maximum element in retrieved_elements\n        taken in the computation\n\n    Returns:\n        NDCG value\n\n    \"\"\"", "\n", "\n", "# TODO: When https://github.com/scikit-learn/scikit-learn/pull/9951 is", "\n", "# merged...", "\n", "idcg", "=", "dcg", "(", "\n", "relevant_elements", ",", "relevant_elements", ",", "min", "(", "k", ",", "len", "(", "relevant_elements", ")", ")", ")", "\n", "if", "idcg", "==", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\"relevent_elements is empty, the metric is\"", "\n", "\"not defined\"", ")", "\n", "", "true_dcg", "=", "dcg", "(", "relevant_elements", ",", "retrieved_elements", ",", "k", ")", "\n", "return", "true_dcg", "/", "idcg", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.__get_unique": [[122, 127], ["list", "collections.OrderedDict.fromkeys"], "function", ["None"], ["", "def", "__get_unique", "(", "original_list", ")", ":", "\n", "    ", "\"\"\"Get only unique values of a list but keep the order of the first\n    occurence of each element\n    \"\"\"", "\n", "return", "list", "(", "OrderedDict", ".", "fromkeys", "(", "original_list", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.playlist_extender_clicks": [[133, 145], ["set().intersection", "enumerate", "float", "set", "set", "float", "int"], "function", ["None"], ["def", "playlist_extender_clicks", "(", "targets", ",", "predictions", ",", "max_n_predictions", "=", "500", ")", ":", "\n", "# Assumes predictions are sorted by relevance", "\n", "# First, cap the number of predictions", "\n", "    ", "predictions", "=", "predictions", "[", ":", "max_n_predictions", "]", "\n", "\n", "# Calculate metric", "\n", "i", "=", "set", "(", "predictions", ")", ".", "intersection", "(", "set", "(", "targets", ")", ")", "\n", "for", "index", ",", "t", "in", "enumerate", "(", "predictions", ")", ":", "\n", "        ", "for", "track", "in", "i", ":", "\n", "            ", "if", "t", "==", "track", ":", "\n", "                ", "return", "float", "(", "int", "(", "index", "/", "10", ")", ")", "\n", "", "", "", "return", "float", "(", "max_n_predictions", "/", "10.0", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.get_all_metrics": [[148, 152], ["Metrics", "mpd_metrics.r_precision", "mpd_metrics.ndcg", "mpd_metrics.playlist_extender_clicks"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.r_precision", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.ndcg", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.playlist_extender_clicks"], ["", "def", "get_all_metrics", "(", "targets", ",", "predictions", ",", "k", ")", ":", "\n", "    ", "return", "Metrics", "(", "r_precision", "(", "targets", ",", "predictions", ",", "k", ")", ",", "\n", "ndcg", "(", "targets", ",", "predictions", ",", "k", ")", ",", "\n", "playlist_extender_clicks", "(", "targets", ",", "predictions", ",", "k", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.aggregate_metrics": [[160, 183], ["MetricsSummary", "r_precision.append", "ndcg.append", "plex_clicks.append", "Metrics", "mpd_metrics.get_all_metrics", "float", "scipy.stats.describe", "scipy.stats.describe", "scipy.stats.describe"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd_metrics.get_all_metrics"], ["def", "aggregate_metrics", "(", "ground_truth", ",", "sub", ",", "k", ",", "candidates", ")", ":", "\n", "    ", "r_precision", "=", "[", "]", "\n", "ndcg", "=", "[", "]", "\n", "plex_clicks", "=", "[", "]", "\n", "miss", "=", "0", "\n", "cnt", "=", "0", "\n", "for", "p", "in", "candidates", ":", "\n", "        ", "cnt", "+=", "1", "\n", "if", "p", "not", "in", "sub", ":", "\n", "            ", "miss", "+=", "1", "\n", "m", "=", "Metrics", "(", "0", ",", "0", ",", "0", ")", "# TODO: make sure this is right", "\n", "", "else", ":", "\n", "            ", "m", "=", "get_all_metrics", "(", "ground_truth", "[", "p", "]", ",", "sub", "[", "p", "]", ",", "k", ")", "\n", "", "r_precision", ".", "append", "(", "m", ".", "r_precision", ")", "\n", "ndcg", ".", "append", "(", "m", ".", "ndcg", ")", "\n", "plex_clicks", ".", "append", "(", "m", ".", "plex_clicks", ")", "\n", "\n", "", "cov", "=", "1", "-", "miss", "/", "float", "(", "cnt", ")", "\n", "return", "MetricsSummary", "(", "\n", "stats", ".", "describe", "(", "r_precision", ")", ".", "mean", ",", "\n", "stats", ".", "describe", "(", "ndcg", ")", ".", "mean", ",", "\n", "stats", ".", "describe", "(", "plex_clicks", ")", ".", "mean", ",", "\n", "cov", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.make_submission.make_submission": [[36, 54], ["print", "aaerec.evaluation.argtopk", "print", "open", "csv.writer", "csv.writer.writerow", "enumerate", "csv.writer.writerow"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.argtopk"], ["def", "make_submission", "(", "predictions", ",", "\n", "index2playlist", ",", "\n", "index2trackid", ",", "\n", "outfile", "=", "None", ",", "\n", "topk", "=", "500", ")", ":", "\n", "    ", "\"\"\" Writes the predictions as submission file to disk \"\"\"", "\n", "print", "(", "\"Sorting top {} items for each playlist\"", ".", "format", "(", "topk", ")", ")", "\n", "__", ",", "topk_iy", "=", "argtopk", "(", "predictions", ",", "topk", ")", "\n", "print", "(", "\"Writing rows to\"", ",", "outfile", ")", "\n", "with", "open", "(", "outfile", ",", "'a'", ")", "as", "csvfile", ":", "\n", "        ", "csv_writer", "=", "csv", ".", "writer", "(", "csvfile", ",", "delimiter", "=", "','", ")", "\n", "csv_writer", ".", "writerow", "(", "SUBMISSION_HEADER", ")", "\n", "# Line format", "\n", "# playlist_id, trackid1, trackid2, trackid500", "\n", "for", "row_ix", ",", "item_ixs", "in", "enumerate", "(", "topk_iy", ")", ":", "\n", "            ", "playlist", "=", "index2playlist", "[", "row_ix", "]", "\n", "items", "=", "[", "index2trackid", "[", "ix", "]", "for", "ix", "in", "item_ixs", "]", "\n", "csv_writer", ".", "writerow", "(", "[", "playlist", "]", "+", "items", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.make_submission.main": [[56, 210], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "eval.mpd.mpd.playlists_from_slices", "print", "aaerec.datasets.Bags", "print", "train_set.apply_vocab.build_vocab", "train_set.apply_vocab.apply_vocab", "print", "print", "aaerec.datasets.Bags", "test_set.apply_vocab.apply_vocab", "print", "model.predict", "scipy.issparse", "print", "aaerec.evaluation.remove_non_missing", "print", "make_submission.make_submission", "print", "print", "print", "os.path.isfile", "os.path.exists", "exit", "open", "print", "print", "gensim.models.keyedvectors.KeyedVectors.load_word2vec_format", "model.train", "print", "eval.mpd.mpd.unpack_playlists", "print", "eval.mpd.mpd.unpack_playlists", "np.asarray.toarray", "numpy.asarray", "test_set.apply_vocab.tocsr", "argparse.FileType", "input", "aaerec.baselines.Countbased", "aaerec.svd.SVDRecommender", "aaerec.aae.AAERecommender", "aaerec.aae.AAERecommender", "aaerec.aae.DecodingRecommender", "line.strip", "eval.mpd.mpd.unpack_playlists", "print", "eval.mpd.mpd.load", "eval.mpd.mpd.load", "vocab.items"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.playlists_from_slices", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.build_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.apply_vocab", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.predict", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.remove_non_missing", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.make_submission.make_submission", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AAERecommender.train", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.unpack_playlists", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.unpack_playlists", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.tocsr", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.unpack_playlists", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load", "home.repos.pwc.inspect_result.lgalke_aae-recommender.mpd.mpd.load"], ["", "", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'--model'", ",", "type", "=", "str", ",", "default", "=", "'aae'", ",", "\n", "# All possible method should appear here", "\n", "choices", "=", "[", "'cm'", ",", "'svd'", ",", "'ae'", ",", "'aae'", ",", "'mlp'", "]", ",", "\n", "help", "=", "\"Specify the model to use [aae]\"", ")", "\n", "parser", ".", "add_argument", "(", "'--epochs'", ",", "type", "=", "int", ",", "default", "=", "20", ",", "\n", "help", "=", "\"Specify the number of training epochs [50]\"", ")", "\n", "parser", ".", "add_argument", "(", "'--hidden'", ",", "type", "=", "int", ",", "default", "=", "200", ",", "\n", "help", "=", "\"Number of hidden units [100]\"", ")", "\n", "parser", ".", "add_argument", "(", "'--no-title'", ",", "action", "=", "'store_false'", ",", "default", "=", "True", ",", "\n", "dest", "=", "'use_title'", ",", "\n", "help", "=", "\"Do not use the playlist titles\"", ")", "\n", "parser", ".", "add_argument", "(", "'--max-items'", ",", "type", "=", "int", ",", "default", "=", "75000", ",", "\n", "help", "=", "\"Limit the max number of considered items\"", ")", "\n", "parser", ".", "add_argument", "(", "'--vocab-size'", ",", "type", "=", "int", ",", "default", "=", "50000", ",", "\n", "help", "=", "\"Limit the max number of distinct condition words\"", ")", "\n", "parser", ".", "add_argument", "(", "'-j'", ",", "'--jobs'", ",", "type", "=", "int", ",", "default", "=", "4", ",", "\n", "help", "=", "\"Number of jobs for data loading [4].\"", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--outfile'", ",", "default", "=", "\"submission.csv\"", ",", "\n", "type", "=", "str", ",", "help", "=", "\"Write submissions to this path\"", ")", "\n", "parser", ".", "add_argument", "(", "'--use-embedding'", ",", "default", "=", "False", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Use embedding (SGNS GoogleNews) [false]\"", ")", "\n", "parser", ".", "add_argument", "(", "'--dont-aggregate'", ",", "action", "=", "'store_false'", ",", "dest", "=", "'aggregate'", ",", "default", "=", "True", ",", "\n", "help", "=", "\"Aggregate track metadata as side info input\"", ")", "\n", "parser", ".", "add_argument", "(", "'--debug'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "\n", "help", "=", "\"Activate debug mode, run only on small sample\"", ")", "\n", "parser", ".", "add_argument", "(", "'-x'", ",", "'--exclude'", ",", "type", "=", "argparse", ".", "FileType", "(", "'r'", ")", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Path to file with slice filenames to exclude for training\"", ")", "\n", "parser", ".", "add_argument", "(", "'--dev'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "'Path to dev set, use in combination with (-x, --exclude)'", ")", "\n", "parser", ".", "add_argument", "(", "'--no-idf'", ",", "action", "=", "'store_false'", ",", "default", "=", "True", ",", "\n", "dest", "=", "'use_idf'", ",", "help", "=", "\"Do **not** use idf re-weighting\"", ")", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "type", "=", "float", ",", "default", "=", "0.001", ",", "\n", "help", "=", "\"Initial learning rate [0.001]\"", ")", "\n", "parser", ".", "add_argument", "(", "'--code'", ",", "type", "=", "int", ",", "default", "=", "100", ",", "\n", "help", "=", "\"Code dimension [100]\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# Either exclude and dev set, or no exclude and test set", "\n", "assert", "(", "args", ".", "dev", "is", "None", ")", "==", "(", "args", ".", "exclude", "is", "None", ")", "\n", "if", "args", ".", "dev", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"Making submission for dev set:\"", ",", "args", ".", "dev", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "args", ".", "dev", ")", "\n", "\n", "\n", "# Dump args into submission file", "\n", "", "if", "os", ".", "path", ".", "exists", "(", "args", ".", "outfile", ")", "and", "input", "(", "\"Path '{}' exists. Overwrite? [y/N]\"", "\n", ".", "format", "(", "args", ".", "outfile", ")", ")", "!=", "'y'", ":", "\n", "        ", "exit", "(", "-", "1", ")", "\n", "\n", "", "with", "open", "(", "args", ".", "outfile", ",", "'w'", ")", "as", "out", ":", "\n", "        ", "print", "(", "'#'", ",", "args", ",", "file", "=", "out", ")", "\n", "\n", "", "if", "args", ".", "use_embedding", ":", "\n", "        ", "print", "(", "\"Loading embedding:\"", ",", "W2V_PATH", ")", "\n", "vectors", "=", "KeyedVectors", ".", "load_word2vec_format", "(", "W2V_PATH", ",", "binary", "=", "W2V_IS_BINARY", ")", "\n", "", "else", ":", "\n", "        ", "vectors", "=", "None", "\n", "\n", "# Create the model as specified by command line args", "\n", "# Count-based never uses title", "\n", "# Decoding recommender always uses title", "\n", "\n", "", "tfidf_params", "=", "{", "\n", "'max_features'", ":", "args", ".", "vocab_size", ",", "\n", "'use_idf'", ":", "args", ".", "use_idf", "\n", "}", "\n", "\n", "model", "=", "{", "\n", "'cm'", ":", "Countbased", "(", ")", ",", "\n", "'svd'", ":", "SVDRecommender", "(", "use_title", "=", "args", ".", "use_title", ")", ",", "\n", "'ae'", ":", "AAERecommender", "(", "use_title", "=", "args", ".", "use_title", ",", "\n", "adversarial", "=", "False", ",", "\n", "n_hidden", "=", "args", ".", "hidden", ",", "\n", "n_code", "=", "args", ".", "code", ",", "\n", "n_epochs", "=", "args", ".", "epochs", ",", "\n", "embedding", "=", "vectors", ",", "\n", "lr", "=", "args", ".", "lr", ",", "\n", "tfidf_params", "=", "tfidf_params", ")", ",", "\n", "'aae'", ":", "AAERecommender", "(", "use_title", "=", "args", ".", "use_title", ",", "\n", "adversarial", "=", "True", ",", "\n", "n_hidden", "=", "args", ".", "hidden", ",", "\n", "n_code", "=", "args", ".", "code", ",", "\n", "n_epochs", "=", "args", ".", "epochs", ",", "\n", "gen_lr", "=", "args", ".", "lr", ",", "\n", "reg_lr", "=", "args", ".", "lr", ",", "# same gen and reg lrs", "\n", "embedding", "=", "vectors", ",", "\n", "tfidf_params", "=", "tfidf_params", ")", ",", "\n", "'mlp'", ":", "DecodingRecommender", "(", "n_epochs", "=", "args", ".", "epochs", ",", "\n", "n_hidden", "=", "args", ".", "hidden", ",", "\n", "embedding", "=", "vectors", ",", "\n", "tfidf_params", "=", "tfidf_params", ")", "\n", "}", "[", "args", ".", "model", "]", "\n", "\n", "track_attrs", "=", "TRACK_INFO", "if", "args", ".", "aggregate", "else", "None", "\n", "\n", "if", "args", ".", "exclude", "is", "not", "None", ":", "\n", "# Dev set case, exclude dev set data", "\n", "        ", "exclude", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "args", ".", "exclude", "]", "\n", "", "else", ":", "\n", "# Real submission case, do not exclude any training data", "\n", "        ", "exclude", "=", "None", "\n", "\n", "# = Training =", "\n", "", "print", "(", "\"Loading data from {} using {} jobs\"", ".", "format", "(", "DATA_PATH", ",", "args", ".", "jobs", ")", ")", "\n", "playlists", "=", "playlists_from_slices", "(", "DATA_PATH", ",", "n_jobs", "=", "args", ".", "jobs", ",", "debug", "=", "args", ".", "debug", ",", "\n", "without", "=", "exclude", ")", "\n", "print", "(", "\"Unpacking playlists\"", ")", "\n", "train_set", "=", "Bags", "(", "*", "unpack_playlists", "(", "playlists", ",", "aggregate", "=", "track_attrs", ")", ")", "\n", "\n", "print", "(", "\"Building vocabulary of {} most frequent items\"", ".", "format", "(", "args", ".", "max_items", ")", ")", "\n", "vocab", ",", "__counts", "=", "train_set", ".", "build_vocab", "(", "max_features", "=", "args", ".", "max_items", ",", "\n", "apply", "=", "False", ")", "\n", "train_set", "=", "train_set", ".", "apply_vocab", "(", "vocab", ")", "\n", "print", "(", "\"Training set:\"", ",", "train_set", ",", "sep", "=", "'\\n'", ")", "\n", "\n", "print", "(", "\"Training for {} epochs\"", ".", "format", "(", "args", ".", "epochs", ")", ")", "\n", "try", ":", "\n", "        ", "model", ".", "train", "(", "train_set", ")", "\n", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "print", "(", "\"Training interrupted by keyboard, pass.\"", ")", "\n", "\n", "# Not required anymore", "\n", "", "del", "train_set", "\n", "\n", "# = Predictions =", "\n", "if", "args", ".", "dev", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"Loading and unpacking DEV set\"", ")", "\n", "data", ",", "index2playlist", ",", "side_info", "=", "unpack_playlists", "(", "load", "(", "args", ".", "dev", ")", ",", "\n", "aggregate", "=", "track_attrs", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Loading and unpacking test set\"", ")", "\n", "data", ",", "index2playlist", ",", "side_info", "=", "unpack_playlists", "(", "load", "(", "TEST_PATH", ")", ",", "\n", "aggregate", "=", "track_attrs", ")", "\n", "", "test_set", "=", "Bags", "(", "data", ",", "index2playlist", ",", "side_info", ")", "\n", "# Apply same vocabulary as in training", "\n", "test_set", "=", "test_set", ".", "apply_vocab", "(", "vocab", ")", "\n", "print", "(", "\"Test set:\"", ",", "test_set", ",", "sep", "=", "'\\n'", ")", "\n", "\n", "pred", "=", "model", ".", "predict", "(", "test_set", ")", "\n", "if", "sp", ".", "issparse", "(", "pred", ")", ":", "\n", "        ", "pred", "=", "pred", ".", "toarray", "(", ")", "\n", "", "else", ":", "\n", "        ", "pred", "=", "np", ".", "asarray", "(", "pred", ")", "\n", "", "print", "(", "\"Scaling and removing non-missing items\"", ")", "\n", "pred", "=", "remove_non_missing", "(", "pred", ",", "test_set", ".", "tocsr", "(", ")", ",", "copy", "=", "False", ")", "\n", "\n", "index2trackid", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "vocab", ".", "items", "(", ")", "}", "\n", "print", "(", "\"Making submission:\"", ",", "args", ".", "outfile", ")", "\n", "make_submission", "(", "pred", ",", "index2playlist", ",", "index2trackid", ",", "outfile", "=", "args", ".", "outfile", ")", "\n", "print", "(", "\"Success.\"", ")", "\n", "print", "(", "\"Make sure to verify the submission format via\"", ",", "VERIFY_SCRIPT", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_evaluation.test_batching": [[9, 26], ["sklearn.datasets.make_multilabel_classification", "numpy.random.rand", "aaerec.evaluation.evaluate", "aaerec.evaluation.evaluate", "zip", "zip", "aaerec.evaluation.MRR", "aaerec.evaluation.MAP", "aaerec.evaluation.P", "aaerec.evaluation.P", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.evaluate", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.evaluation.evaluate"], ["def", "test_batching", "(", ")", ":", "\n", "    ", "\"\"\" Test whether batched evaluation yields same results as non-batched \"\"\"", "\n", "n_samples", "=", "120", "\n", "n_classes", "=", "10", "\n", "X", ",", "Y", "=", "make_multilabel_classification", "(", "n_samples", ",", "20", ",", "n_classes", ")", "\n", "\n", "predictions", "=", "np", ".", "random", ".", "rand", "(", "n_samples", ",", "n_classes", ")", "\n", "metrics", "=", "[", "MRR", "(", ")", ",", "MAP", "(", ")", ",", "P", "(", "1", ")", ",", "P", "(", "5", ")", "]", "\n", "\n", "results", "=", "evaluate", "(", "Y", ",", "predictions", ",", "metrics", ",", "batch_size", "=", "None", ")", "\n", "results_batched", "=", "evaluate", "(", "Y", ",", "predictions", ",", "metrics", ",", "batch_size", "=", "25", ")", "\n", "\n", "results_mean", ",", "results_std", "=", "zip", "(", "*", "results", ")", "\n", "results_batched_mean", ",", "results_batched_std", "=", "zip", "(", "*", "results_batched", ")", "\n", "\n", "assert", "(", "(", "np", ".", "array", "(", "results_batched_mean", ")", "-", "np", ".", "array", "(", "results_mean", ")", ")", "<", "EPS", ")", ".", "all", "(", ")", "\n", "assert", "(", "(", "np", ".", "array", "(", "results_batched_std", ")", "-", "np", ".", "array", "(", "results_std", ")", ")", "<", "EPS", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_condition_abc": [[18, 26], ["issubclass", "issubclass", "issubclass", "issubclass", "issubclass"], "function", ["None"], ["def", "test_condition_abc", "(", ")", ":", "\n", "\n", "    ", "assert", "issubclass", "(", "ConcatenationBasedConditioning", ",", "ConditionBase", ")", "\n", "assert", "issubclass", "(", "ConditionalBiasing", ",", "ConditionBase", ")", "\n", "assert", "issubclass", "(", "ConditionalScaling", ",", "ConditionBase", ")", "\n", "\n", "assert", "issubclass", "(", "EmbeddingBagCondition", ",", "ConditionBase", ")", "\n", "assert", "issubclass", "(", "PretrainedWordEmbeddingCondition", ",", "ConditionBase", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_condition_simple": [[28, 47], ["torch.rand", "aaerec.condition.EmbeddingBagCondition", "isinstance", "isinstance", "aaerec.condition.EmbeddingBagCondition.encode", "aaerec.condition.EmbeddingBagCondition.impose", "ebc.impose.size", "torch.rand.size", "ebc.impose.size", "torch.rand.size", "aaerec.condition.EmbeddingBagCondition.size_increment", "torch.rand"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment"], ["", "def", "test_condition_simple", "(", ")", ":", "\n", "    ", "code", "=", "torch", ".", "rand", "(", "100", ",", "10", ")", "\n", "# 2 random values with vocabulary 0, 1 per sample", "\n", "c_batch", "=", "(", "torch", ".", "rand", "(", "100", ",", "2", ")", "<", "0.5", ")", ".", "long", "(", ")", "\n", "\n", "ebc", "=", "EmbeddingBagCondition", "(", "2", ",", "10", ")", "\n", "\n", "assert", "isinstance", "(", "ebc", ",", "ConditionBase", ")", "\n", "assert", "isinstance", "(", "ebc", ",", "ConcatenationBasedConditioning", ")", "\n", "\n", "condition_encoded", "=", "ebc", ".", "encode", "(", "c_batch", ")", "\n", "\n", "conditioned_code", "=", "ebc", ".", "impose", "(", "code", ",", "condition_encoded", ")", "\n", "\n", "# Dim 1 is expected to increase by condition size", "\n", "assert", "conditioned_code", ".", "size", "(", "1", ")", "==", "code", ".", "size", "(", "1", ")", "+", "ebc", ".", "size_increment", "(", ")", "\n", "\n", "# Batch dim should not be changed", "\n", "assert", "code", ".", "size", "(", "0", ")", "==", "conditioned_code", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_condition_list": [[49, 79], ["torch.rand", "aaerec.condition.EmbeddingBagCondition", "aaerec.condition.EmbeddingBagCondition", "aaerec.condition.ConditionList", "aaerec.condition.ConditionList.encode_impose", "list", "list", "aaerec.condition.ConditionList.size_increment", "condition_list.encode_impose.size", "torch.rand.size", "condition_list.encode_impose.size", "aaerec.condition.ConditionList.keys", "aaerec.condition.ConditionList.values", "torch.rand.size", "aaerec.condition.ConditionList.size_increment", "torch.rand", "torch.rand"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment"], ["", "def", "test_condition_list", "(", ")", ":", "\n", "    ", "\"\"\" Test list of conditions \"\"\"", "\n", "code", "=", "torch", ".", "rand", "(", "100", ",", "10", ")", "\n", "c1_batch", "=", "(", "torch", ".", "rand", "(", "100", ",", "2", ")", "<", "0.5", ")", ".", "long", "(", ")", "\n", "c2_batch", "=", "(", "torch", ".", "rand", "(", "100", ",", "2", ")", "<", "0.5", ")", ".", "long", "(", ")", "\n", "\n", "ebc1", "=", "EmbeddingBagCondition", "(", "2", ",", "10", ")", "\n", "ebc2", "=", "EmbeddingBagCondition", "(", "2", ",", "10", ")", "\n", "\n", "condition_list", "=", "ConditionList", "(", "[", "\n", "(", "'title'", ",", "ebc1", ")", ",", "\n", "(", "'something'", ",", "ebc2", ")", "\n", "]", ")", "\n", "\n", "# keys of attributes should be accessible from cond list", "\n", "assert", "list", "(", "condition_list", ".", "keys", "(", ")", ")", "==", "[", "'title'", ",", "'something'", "]", "\n", "# the actual conditions are also accessible as a whole..", "\n", "assert", "list", "(", "condition_list", ".", "values", "(", ")", ")", "==", "[", "ebc1", ",", "ebc2", "]", "\n", "# .. or individually by name", "\n", "assert", "condition_list", "[", "'title'", "]", "==", "ebc1", "\n", "assert", "condition_list", "[", "'something'", "]", "==", "ebc2", "\n", "\n", "assert", "condition_list", ".", "size_increment", "(", ")", "==", "20", "\n", "\n", "conditioned_code", "=", "condition_list", ".", "encode_impose", "(", "code", ",", "[", "c1_batch", ",", "c2_batch", "]", ")", "\n", "\n", "assert", "conditioned_code", ".", "size", "(", "1", ")", "==", "code", ".", "size", "(", "1", ")", "+", "condition_list", ".", "size_increment", "(", ")", "\n", "\n", "assert", "code", ".", "size", "(", "0", ")", "==", "conditioned_code", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_optim_step_callback": [[81, 104], ["torch.rand", "aaerec.condition.EmbeddingBagCondition", "torch.zeros", "range", "aaerec.condition.EmbeddingBagCondition.zero_grad", "torch.nn.MSELoss", "aaerec.condition.EmbeddingBagCondition.encode_impose", "torch.nn.MSELoss.", "criterion.backward", "losses.append", "aaerec.condition.EmbeddingBagCondition.step", "len", "criterion.item", "torch.rand"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step"], ["", "def", "test_optim_step_callback", "(", ")", ":", "\n", "    ", "\"\"\" Test zero_grad / step optimization \"\"\"", "\n", "code", "=", "torch", ".", "rand", "(", "100", ",", "10", ")", "\n", "# 2 random values with vocabulary 0, 1 per sample", "\n", "c_batch", "=", "(", "torch", ".", "rand", "(", "100", ",", "2", ")", "<", "0.5", ")", ".", "long", "(", ")", "\n", "ebc", "=", "EmbeddingBagCondition", "(", "2", ",", "10", ")", "\n", "\n", "target", "=", "torch", ".", "zeros", "(", "20", ")", "\n", "\n", "losses", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "2", ")", ":", "\n", "# dummy training loop", "\n", "        ", "ebc", ".", "zero_grad", "(", ")", "\n", "criterion", "=", "torch", ".", "nn", ".", "MSELoss", "(", ")", "\n", "conditioned_code", "=", "ebc", ".", "encode_impose", "(", "code", ",", "c_batch", ")", "\n", "loss", "=", "criterion", "(", "conditioned_code", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "losses", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "ebc", ".", "step", "(", ")", "\n", "\n", "", "assert", "len", "(", "losses", ")", "==", "2", "\n", "# One loss improvement should be possible", "\n", "assert", "losses", "[", "1", "]", "<", "losses", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_word_emb_condition": [[106, 125], ["gensim.models.word2vec.Word2Vec", "aaerec.condition.PretrainedWordEmbeddingCondition", "aaerec.condition.PretrainedWordEmbeddingCondition.fit_transform", "torch.rand", "aaerec.condition.PretrainedWordEmbeddingCondition.encode_impose", "len", "condition.encode_impose.size", "s.split", "torch.rand.size", "aaerec.condition.PretrainedWordEmbeddingCondition.size_increment"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment"], ["", "def", "test_word_emb_condition", "(", ")", ":", "\n", "    ", "import", "gensim", "\n", "sentences", "=", "[", "\n", "\"the quick brown fox jumps over the lazy dog\"", ",", "\n", "\"the cat sits on the mat\"", ",", "\n", "\"if it fits, I sits\"", "\n", "]", "\n", "emb_dim", "=", "10", "\n", "model", "=", "gensim", ".", "models", ".", "word2vec", ".", "Word2Vec", "(", "\n", "[", "s", ".", "split", "(", ")", "for", "s", "in", "sentences", "]", ",", "\n", "min_count", "=", "1", ",", "window", "=", "2", ",", "size", "=", "emb_dim", "\n", ")", "\n", "condition", "=", "PretrainedWordEmbeddingCondition", "(", "model", ".", "wv", ",", "use_cuda", "=", "False", ")", "\n", "sentences_trf", "=", "condition", ".", "fit_transform", "(", "sentences", ")", "\n", "\n", "code", "=", "torch", ".", "rand", "(", "len", "(", "sentences", ")", ",", "5", ")", "\n", "conditioned_code", "=", "condition", ".", "encode_impose", "(", "code", ",", "sentences_trf", ")", "\n", "\n", "assert", "conditioned_code", ".", "size", "(", "1", ")", "==", "code", ".", "size", "(", "1", ")", "+", "condition", ".", "size_increment", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_full_pipeline": [[127, 186], ["gensim.models.word2vec.Word2Vec", "aaerec.condition.PretrainedWordEmbeddingCondition", "aaerec.condition.CategoricalCondition", "aaerec.condition.ConditionList", "aaerec.condition.ConditionList.fit_transform", "torch.rand", "torch.nn.MSELoss", "torch.nn.Linear", "torch.optim.Adam", "range", "torch.rand.size", "torch.nn.Linear.parameters", "range", "s.split", "torch.rand.size", "aaerec.condition.ConditionList.size_increment", "len", "aaerec.condition.ConditionList.zero_grad", "torch.optim.Adam.zero_grad", "aaerec.condition.ConditionList.encode_impose", "torch.nn.Linear.", "torch.nn.MSELoss.", "criterion.backward", "losses.append", "aaerec.condition.ConditionList.step", "torch.optim.Adam.step", "aaerec.condition.ConditionList.keys", "aaerec.condition.ConditionList.size_increment", "criterion.item", "clist.encode_impose.size", "code_batch.size"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.ConditionBase.encode_impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.size_increment", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "def", "test_full_pipeline", "(", ")", ":", "\n", "    ", "\"\"\" This test shows how to use condition (-list) in a complete pipeline \"\"\"", "\n", "import", "gensim", "\n", "data", "=", "{", "\n", "'titles'", ":", "[", "\n", "\"the quick brown fox jumps over the lazy dog\"", ",", "\n", "\"the cat sits on the mat\"", ",", "\n", "\"if it fits, I sits\"", "\n", "]", ",", "\n", "'authors'", ":", "[", "\n", "\"Iacopo\"", ",", "\n", "\"Gunnar\"", ",", "\n", "\"Lukas\"", ",", "\n", "]", "\n", "}", "\n", "\n", "emb_dim", "=", "10", "\n", "model", "=", "gensim", ".", "models", ".", "word2vec", ".", "Word2Vec", "(", "\n", "[", "s", ".", "split", "(", ")", "for", "s", "in", "data", "[", "'titles'", "]", "]", ",", "\n", "min_count", "=", "1", ",", "window", "=", "2", ",", "size", "=", "emb_dim", "\n", ")", "\n", "cond1", "=", "PretrainedWordEmbeddingCondition", "(", "model", ".", "wv", ",", "use_cuda", "=", "False", ")", "\n", "cond2", "=", "CategoricalCondition", "(", "emb_dim", ",", "vocab_size", "=", "3", ",", "use_cuda", "=", "False", ")", "\n", "\n", "clist", "=", "ConditionList", "(", "[", "(", "'titles'", ",", "cond1", ")", ",", "\n", "(", "'authors'", ",", "cond2", ")", "]", ")", "\n", "\n", "# Apply fit_transform on all conditions, store results", "\n", "prepped_inputs", "=", "clist", ".", "fit_transform", "(", "[", "data", "[", "k", "]", "for", "k", "in", "clist", ".", "keys", "(", ")", "]", ")", "\n", "\n", "# Let's assume the encoder produced these codes originally", "\n", "codes", "=", "torch", ".", "rand", "(", "3", ",", "10", ")", "\n", "\n", "criterion", "=", "torch", ".", "nn", ".", "MSELoss", "(", ")", "\n", "\n", "decoder", "=", "torch", ".", "nn", ".", "Linear", "(", "codes", ".", "size", "(", "1", ")", "+", "clist", ".", "size_increment", "(", ")", ",", "\n", "codes", ".", "size", "(", "1", ")", ")", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "decoder", ".", "parameters", "(", ")", ")", "\n", "\n", "losses", "=", "[", "]", "\n", "for", "__epoch", "in", "range", "(", "10", ")", ":", "\n", "        ", "for", "start", "in", "range", "(", "len", "(", "codes", ")", ")", ":", "\n", "            ", "end", "=", "start", "+", "1", "\n", "code_batch", "=", "codes", "[", "start", ":", "end", "]", "\n", "# Batch all condition inputs", "\n", "cinputs_batch", "=", "[", "inp", "[", "start", ":", "end", "]", "for", "inp", "in", "prepped_inputs", "]", "\n", "clist", ".", "zero_grad", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "conditioned_code", "=", "clist", ".", "encode_impose", "(", "code_batch", ",", "cinputs_batch", ")", "\n", "# assert dim is predictable for decoder", "\n", "assert", "conditioned_code", ".", "size", "(", "1", ")", "-", "code_batch", ".", "size", "(", "1", ")", "==", "clist", ".", "size_increment", "(", ")", "\n", "out", "=", "decoder", "(", "conditioned_code", ")", "\n", "# Reconstruction loss", "\n", "loss", "=", "criterion", "(", "out", ",", "code_batch", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "losses", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "clist", ".", "step", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_categorical_condition": [[188, 204], ["aaerec.condition.CategoricalCondition", "aaerec.condition.CategoricalCondition.fit_transform", "torch.rand", "aaerec.condition.CategoricalCondition.encode", "aaerec.condition.CategoricalCondition.impose", "len", "catcond.encode.size", "len", "catcond.encode.size", "catcond.impose.size", "len", "catcond.impose.size"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.impose", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.datasets.BagsWithVocab.size"], ["", "", "", "def", "test_categorical_condition", "(", ")", ":", "\n", "\n", "    ", "authors", "=", "[", "\"Mr X\"", ",", "\"Falafel\"", ",", "\"Pizza\"", ",", "\"Am I hungry?\"", ",", "\"Mr X\"", "]", "\n", "catcond", "=", "CategoricalCondition", "(", "20", ",", "vocab_size", "=", "10", ",", "use_cuda", "=", "False", ")", "\n", "author_ids", "=", "catcond", ".", "fit_transform", "(", "authors", ")", "\n", "some_code", "=", "torch", ".", "rand", "(", "len", "(", "authors", ")", ",", "10", ")", "\n", "\n", "encoded_authors", "=", "catcond", ".", "encode", "(", "author_ids", ")", "\n", "assert", "encoded_authors", ".", "size", "(", "0", ")", "==", "len", "(", "authors", ")", "and", "encoded_authors", ".", "size", "(", "1", ")", "==", "20", "\n", "\n", "# Mr X is Mr X", "\n", "assert", "(", "(", "encoded_authors", "[", "0", "]", "-", "encoded_authors", "[", "-", "1", "]", ")", ".", "abs", "(", ")", "<", "1e-8", ")", ".", "all", "(", ")", "\n", "\n", "cond_code", "=", "catcond", ".", "impose", "(", "some_code", ",", "encoded_authors", ")", "\n", "# 20 + 10 should turn out to be 30", "\n", "assert", "cond_code", ".", "size", "(", "0", ")", "==", "len", "(", "authors", ")", "and", "cond_code", ".", "size", "(", "1", ")", "==", "30", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_categorical_condition_unk_treatment": [[206, 222], ["aaerec.condition.CategoricalCondition", "aaerec.condition.CategoricalCondition.fit_transform", "aaerec.condition.CategoricalCondition.encode", "pytest.raises", "aaerec.condition.CategoricalCondition", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode"], ["", "def", "test_categorical_condition_unk_treatment", "(", ")", ":", "\n", "    ", "authors", "=", "[", "\"A\"", ",", "\"A\"", ",", "\"B\"", ",", "\"B\"", ",", "\"C\"", "]", "\n", "\n", "\n", "## OOV SHOULD BE IGNORE", "\n", "catcond", "=", "CategoricalCondition", "(", "20", ",", "vocab_size", "=", "2", ",", "use_cuda", "=", "False", ")", "\n", "# Vocab should only hold A and B", "\n", "author_ids", "=", "catcond", ".", "fit_transform", "(", "authors", ")", "\n", "assert", "author_ids", "[", "-", "1", "]", "==", "0", "\n", "\n", "enc_authors", "=", "catcond", ".", "encode", "(", "author_ids", ")", "\n", "# C token should be zero", "\n", "assert", "(", "(", "enc_authors", "[", "-", "1", "]", "-", "torch", ".", "zeros", "(", "20", ")", ")", ".", "abs", "(", ")", "<", "1e-8", ")", ".", "all", "(", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "catcond", "=", "CategoricalCondition", "(", "12", ",", "use_cuda", "=", "False", ",", "padding_idx", "=", "1231", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_categorical_condition_sparse": [[225, 244], ["aaerec.condition.CategoricalCondition", "aaerec.condition.CategoricalCondition.fit_transform", "aaerec.condition.CategoricalCondition.encode", "torch.nn.functional.mse_loss", "aaerec.condition.CategoricalCondition.zero_grad", "torch.nn.functional.mse_loss.backward", "aaerec.condition.CategoricalCondition.step", "aaerec.condition.CategoricalCondition.encode", "torch.zeros", "catcond.encode.abs().sum", "catcond.encode.abs().sum", "catcond.encode.abs", "catcond.encode.abs"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode"], ["", "", "def", "test_categorical_condition_sparse", "(", ")", ":", "\n", "    ", "authors", "=", "[", "\"A\"", ",", "\"A\"", ",", "\"B\"", ",", "\"B\"", ",", "\"C\"", "]", "\n", "catcond", "=", "CategoricalCondition", "(", "20", ",", "use_cuda", "=", "False", ",", "\n", "sparse", "=", "True", ")", "\n", "\n", "author_ids", "=", "catcond", ".", "fit_transform", "(", "authors", ")", "\n", "\n", "enc_authors_1", "=", "catcond", ".", "encode", "(", "author_ids", ")", "\n", "\n", "loss", "=", "torch", ".", "nn", ".", "functional", ".", "mse_loss", "(", "enc_authors_1", ",", "torch", ".", "zeros", "(", "5", ",", "20", ")", ")", "\n", "\n", "catcond", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "catcond", ".", "step", "(", ")", "\n", "\n", "# Encoded authors should now be closer to zero", "\n", "enc_authors_2", "=", "catcond", ".", "encode", "(", "author_ids", ")", "\n", "\n", "assert", "(", "enc_authors_2", ".", "abs", "(", ")", ".", "sum", "(", ")", "<", "enc_authors_1", ".", "abs", "(", ")", ".", "sum", "(", ")", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_categorical_condition_listoflists": [[245, 269], ["aaerec.condition.CategoricalCondition", "aaerec.condition.CategoricalCondition.fit_transform", "aaerec.condition.CategoricalCondition.encode", "torch.nn.functional.mse_loss", "aaerec.condition.CategoricalCondition.zero_grad", "torch.nn.functional.mse_loss.backward", "aaerec.condition.CategoricalCondition.step", "aaerec.condition.CategoricalCondition.encode", "torch.zeros", "len", "catcond.encode.abs().sum", "catcond.encode.abs().sum", "catcond.encode.abs", "catcond.encode.abs"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.aae.AdversarialAutoEncoder.zero_grad", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode"], ["", "def", "test_categorical_condition_listoflists", "(", ")", ":", "\n", "    ", "authors", "=", "[", "[", "\"A\"", ",", "\"B\"", "]", ",", "\n", "[", "\"A\"", ",", "\"C\"", "]", ",", "\n", "[", "\"B\"", ",", "\"C\"", "]", ",", "\n", "[", "\"A\"", "]", ",", "\n", "[", "\"B\"", "]", ",", "\n", "[", "\"A\"", ",", "\"B\"", ",", "\"C\"", "]", "]", "\n", "catcond", "=", "CategoricalCondition", "(", "20", ",", "use_cuda", "=", "False", ",", "\n", "sparse", "=", "True", ",", "reduce", "=", "'mean'", ")", "\n", "\n", "author_ids", "=", "catcond", ".", "fit_transform", "(", "authors", ")", "\n", "\n", "enc_authors_1", "=", "catcond", ".", "encode", "(", "author_ids", ")", "\n", "\n", "loss", "=", "torch", ".", "nn", ".", "functional", ".", "mse_loss", "(", "enc_authors_1", ",", "torch", ".", "zeros", "(", "len", "(", "authors", ")", ",", "20", ")", ")", "\n", "\n", "catcond", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "catcond", ".", "step", "(", ")", "\n", "\n", "# Encoded authors should now be closer to zero", "\n", "enc_authors_2", "=", "catcond", ".", "encode", "(", "author_ids", ")", "\n", "\n", "assert", "(", "enc_authors_2", ".", "abs", "(", ")", ".", "sum", "(", ")", "<", "enc_authors_1", ".", "abs", "(", ")", ".", "sum", "(", ")", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_categorical_condition_with_sklearn_shuffle": [[270, 297], ["aaerec.condition.CategoricalCondition", "aaerec.condition.CategoricalCondition.fit_transform", "numpy.arange", "sklearn.utils.shuffle", "zip", "len"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform"], ["", "def", "test_categorical_condition_with_sklearn_shuffle", "(", ")", ":", "\n", "    ", "authors", "=", "[", "[", "\"A\"", ",", "\"B\"", "]", ",", "\n", "[", "\"A\"", ",", "\"C\"", "]", ",", "\n", "[", "\"B\"", ",", "\"C\"", "]", ",", "\n", "[", "\"A\"", "]", ",", "# 3", "\n", "[", "\"B\"", "]", ",", "# 4", "\n", "[", "\"A\"", ",", "\"B\"", ",", "\"C\"", "]", "]", "\n", "catcond", "=", "CategoricalCondition", "(", "20", ",", "use_cuda", "=", "False", ",", "\n", "sparse", "=", "True", ",", "reduce", "=", "'mean'", ")", "\n", "\n", "author_ids", "=", "catcond", ".", "fit_transform", "(", "authors", ")", "\n", "\n", "labels", "=", "np", ".", "arange", "(", "len", "(", "authors", ")", ")", "\n", "\n", "labels_shf", ",", "authors_shf", ",", "author_ids_shf", "=", "shuffle", "(", "labels", ",", "authors", ",", "author_ids", ")", "\n", "\n", "for", "l", ",", "a", ",", "i", "in", "zip", "(", "labels_shf", ",", "authors_shf", ",", "author_ids_shf", ")", ":", "\n", "        ", "if", "l", "==", "0", ":", "\n", "            ", "assert", "a", "[", "0", "]", "==", "\"A\"", "and", "a", "[", "1", "]", "==", "\"B\"", "\n", "assert", "i", "[", "0", "]", "==", "catcond", ".", "vocab", "[", "a", "[", "0", "]", "]", "\n", "assert", "i", "[", "1", "]", "==", "catcond", ".", "vocab", "[", "a", "[", "1", "]", "]", "\n", "", "if", "l", "==", "3", ":", "\n", "            ", "assert", "a", "[", "0", "]", "==", "\"A\"", "\n", "assert", "i", "[", "0", "]", "==", "catcond", ".", "vocab", "[", "a", "[", "0", "]", "]", "\n", "", "if", "l", "==", "4", ":", "\n", "            ", "assert", "a", "[", "0", "]", "==", "\"B\"", "\n", "assert", "i", "[", "0", "]", "==", "catcond", ".", "vocab", "[", "a", "[", "0", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.lgalke_aae-recommender.tests.test_condition.test_assemble_condition": [[300, 330], ["torch.tensor", "sklearn.feature_extraction.text.TfidfVectorizer", "torch.nn.Linear", "torch.optim.Adam", "aaerec.condition.Condition", "torch.nn.CrossEntropyLoss", "range", "torch.nn.Linear.parameters", "torch.nn.Linear.", "aaerec.condition.Condition.fit_transform", "aaerec.condition.Condition.encode", "torch.nn.CrossEntropyLoss.", "criterion.backward", "aaerec.condition.Condition.step", "torch.FloatTensor", "x.toarray"], "function", ["home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.ub.EmbeddedVectorizer.fit_transform", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.encode", "home.repos.pwc.inspect_result.lgalke_aae-recommender.aaerec.condition.Condition.step"], ["", "", "", "def", "test_assemble_condition", "(", ")", ":", "\n", "    ", "documents", "=", "[", "\n", "\"Spam Spam Spam\"", ",", "\n", "\"Ham Ham Ham and cheese\"", ",", "\n", "\"Cookies cookies\"", ",", "\n", "\"Nothing else but cookies\"", ",", "\n", "\"Cheese\"", ",", "\n", "\"am I hungry\"", ",", "\n", "\"Cookies Spam\"", ",", "\n", "\"Cheese Spam\"", ",", "\n", "\"I Spam\"", "\n", "]", "\n", "labels", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "\n", "tfidf", "=", "TfidfVectorizer", "(", ")", "\n", "# 10 distinct words, 2 classes", "\n", "encoder", "=", "torch", ".", "nn", ".", "Linear", "(", "10", ",", "2", ")", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "encoder", ".", "parameters", "(", ")", ")", "\n", "def", "enc_fn", "(", "x", ")", ":", "\n", "        ", "return", "encoder", "(", "torch", ".", "FloatTensor", "(", "x", ".", "toarray", "(", ")", ")", ")", "\n", "", "condition", "=", "Condition", "(", "tfidf", ",", "enc_fn", ",", "optimizer", ",", "size_increment", "=", "2", ")", "\n", "\n", "criterion", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "for", "__", "in", "range", "(", "3", ")", ":", "\n", "        ", "x_trf", "=", "condition", ".", "fit_transform", "(", "documents", ")", "\n", "x_enc", "=", "condition", ".", "encode", "(", "x_trf", ")", "\n", "loss", "=", "criterion", "(", "x_enc", ",", "labels", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "condition", ".", "step", "(", ")", "\n", "\n"]]}