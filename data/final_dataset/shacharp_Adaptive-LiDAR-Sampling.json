{"home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.main.predict": [[49, 79], ["curr_model.eval", "enumerate", "curr_model", "val.to", "enumerate", "batch_data.items", "curr_model.cpu().detach().numpy", "os.path.abspath", "os.path.abspath", "os.path.abspath", "os.path.basename", "os.path.abspath", "os.path.abspath", "os.path.abspath", "aux_functions.depth_write", "os.path.dirname", "os.path.isdir", "os.makedirs", "curr_model.cpu().detach", "len", "curr_model.cpu"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.depth_write"], ["def", "predict", "(", "curr_args", ",", "loader", ",", "curr_model", ")", ":", "\n", "    ", "curr_model", ".", "eval", "(", ")", "\n", "\n", "for", "i", ",", "batch_data", "in", "enumerate", "(", "loader", ")", ":", "\n", "        ", "batch_data", "=", "{", "\n", "key", ":", "val", ".", "to", "(", "device", ")", "\n", "for", "key", ",", "val", "in", "batch_data", ".", "items", "(", ")", "if", "val", "is", "not", "None", "\n", "}", "\n", "\n", "pred", "=", "curr_model", "(", "batch_data", ")", "\n", "pred_out_dir", "=", "curr_args", ".", "pred_dir", "\n", "\n", "if", "pred_out_dir", "is", "not", "''", ":", "\n", "            ", "pred1", "=", "pred", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "for", "im_idx", ",", "pred_im", "in", "enumerate", "(", "pred1", ")", ":", "\n", "                ", "data_folder1", "=", "os", ".", "path", ".", "abspath", "(", "curr_args", ".", "data_folder", ")", "\n", "pred_out_dir1", "=", "os", ".", "path", ".", "abspath", "(", "pred_out_dir", ")", "\n", "cur_path", "=", "os", ".", "path", ".", "abspath", "(", "(", "loader", ".", "dataset", ".", "paths", ")", "[", "'d'", "]", "[", "(", "curr_args", ".", "batch_size", "*", "i", ")", "+", "im_idx", "]", ")", "\n", "basename", "=", "os", ".", "path", ".", "basename", "(", "cur_path", ")", "\n", "cur_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "cur_path", ")", ")", "\n", "cur_dir", "=", "cur_dir", "[", "len", "(", "data_folder1", ")", ":", "]", "\n", "new_dir", "=", "os", ".", "path", ".", "abspath", "(", "pred_out_dir1", "+", "'/'", "+", "cur_dir", ")", "\n", "new_path", "=", "os", ".", "path", ".", "abspath", "(", "new_dir", "+", "'/'", "+", "basename", ")", "\n", "if", "os", ".", "path", ".", "isdir", "(", "new_dir", ")", "==", "False", ":", "\n", "                    ", "os", ".", "makedirs", "(", "new_dir", ")", "\n", "\n", "", "depth_write", "(", "new_path", ",", "pred_im", ")", "\n", "\n", "", "del", "pred", "# helps run with a bigger batch size", "\n", "continue", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.vis_utils.depth_colorize": [[13, 17], ["depth.astype", "numpy.min", "numpy.max", "numpy.min", "cmap"], "function", ["None"], ["def", "depth_colorize", "(", "depth", ")", ":", "\n", "    ", "depth", "=", "(", "depth", "-", "np", ".", "min", "(", "depth", ")", ")", "/", "(", "np", ".", "max", "(", "depth", ")", "-", "np", ".", "min", "(", "depth", ")", ")", "\n", "depth", "=", "255", "*", "cmap", "(", "depth", ")", "[", ":", ",", ":", ",", ":", "3", "]", "# H, W, C", "\n", "return", "depth", ".", "astype", "(", "'uint8'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.vis_utils.merge_into_row": [[19, 42], ["img_list.append", "numpy.hstack", "np.hstack.astype", "numpy.squeeze", "vis_utils.depth_colorize", "numpy.squeeze", "numpy.transpose", "img_list.append", "img_list.append", "vis_utils.merge_into_row.preprocess_depth"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.depth_colorize"], ["", "def", "merge_into_row", "(", "ele", ",", "pred", ")", ":", "\n", "    ", "def", "preprocess_depth", "(", "x", ")", ":", "\n", "        ", "y", "=", "np", ".", "squeeze", "(", "x", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "return", "depth_colorize", "(", "y", ")", "\n", "\n", "# if is gray, transforms to rgb", "\n", "", "img_list", "=", "[", "]", "\n", "if", "'rgb'", "in", "ele", ":", "\n", "        ", "rgb", "=", "np", ".", "squeeze", "(", "ele", "[", "'rgb'", "]", "[", "0", ",", "...", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "rgb", "=", "np", ".", "transpose", "(", "rgb", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "img_list", ".", "append", "(", "rgb", ")", "\n", "", "elif", "'g'", "in", "ele", ":", "\n", "        ", "g", "=", "np", ".", "squeeze", "(", "ele", "[", "'g'", "]", "[", "0", ",", "...", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "g", "=", "np", ".", "array", "(", "Image", ".", "fromarray", "(", "g", ")", ".", "convert", "(", "'RGB'", ")", ")", "\n", "img_list", ".", "append", "(", "g", ")", "\n", "", "if", "'d'", "in", "ele", ":", "\n", "        ", "img_list", ".", "append", "(", "preprocess_depth", "(", "ele", "[", "'d'", "]", "[", "0", ",", "...", "]", ")", ")", "\n", "", "img_list", ".", "append", "(", "preprocess_depth", "(", "pred", "[", "0", ",", "...", "]", ")", ")", "\n", "if", "'gt'", "in", "ele", ":", "\n", "        ", "img_list", ".", "append", "(", "preprocess_depth", "(", "ele", "[", "'gt'", "]", "[", "0", ",", "...", "]", ")", ")", "\n", "\n", "", "img_merge", "=", "np", ".", "hstack", "(", "img_list", ")", "\n", "return", "img_merge", ".", "astype", "(", "'uint8'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.vis_utils.add_row": [[44, 46], ["numpy.vstack"], "function", ["None"], ["", "def", "add_row", "(", "img_merge", ",", "row", ")", ":", "\n", "    ", "return", "np", ".", "vstack", "(", "[", "img_merge", ",", "row", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.vis_utils.save_image": [[48, 51], ["cv2.cvtColor", "cv2.imwrite"], "function", ["None"], ["", "def", "save_image", "(", "img_merge", ",", "filename", ")", ":", "\n", "    ", "image_to_write", "=", "cv2", ".", "cvtColor", "(", "img_merge", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "cv2", ".", "imwrite", "(", "filename", ",", "image_to_write", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.vis_utils.save_depth_as_uint16png": [[53, 56], ["cv2.imwrite"], "function", ["None"], ["", "def", "save_depth_as_uint16png", "(", "img", ",", "filename", ")", ":", "\n", "    ", "img", "=", "(", "img", "*", "256", ")", ".", "astype", "(", "'uint16'", ")", "\n", "cv2", ".", "imwrite", "(", "filename", ",", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.vis_utils.display_warping": [[64, 114], ["vis_utils.display_warping.preprocess"], "function", ["None"], ["", "def", "display_warping", "(", "rgb_tgt", ",", "pred_tgt", ",", "warped", ")", ":", "\n", "    ", "def", "preprocess", "(", "rgb_tgt", ",", "pred_tgt", ",", "warped", ")", ":", "\n", "        ", "rgb_tgt", "=", "255", "*", "np", ".", "transpose", "(", "np", ".", "squeeze", "(", "rgb_tgt", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "(", "1", ",", "2", ",", "0", ")", ")", "# H, W, C", "\n", "# depth = np.squeeze(depth.cpu().numpy())", "\n", "# depth = depth_colorize(depth)", "\n", "\n", "# convert to log-scale", "\n", "pred_tgt", "=", "np", ".", "squeeze", "(", "pred_tgt", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "# pred_tgt[pred_tgt<=0] = 0.9 # remove negative predictions", "\n", "# pred_tgt = np.log10(pred_tgt)", "\n", "\n", "pred_tgt", "=", "depth_colorize", "(", "pred_tgt", ")", "\n", "\n", "warped", "=", "255", "*", "np", ".", "transpose", "(", "np", ".", "squeeze", "(", "warped", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "(", "1", ",", "2", ",", "0", ")", ")", "# H, W, C", "\n", "recon_err", "=", "np", ".", "absolute", "(", "\n", "warped", ".", "astype", "(", "'float'", ")", "-", "rgb_tgt", ".", "astype", "(", "'float'", ")", ")", "*", "(", "warped", ">", "0", ")", "\n", "recon_err", "=", "recon_err", "[", ":", ",", ":", ",", "0", "]", "+", "recon_err", "[", ":", ",", ":", ",", "1", "]", "+", "recon_err", "[", ":", ",", ":", ",", "2", "]", "\n", "recon_err", "=", "depth_colorize", "(", "recon_err", ")", "\n", "return", "rgb_tgt", ".", "astype", "(", "'uint8'", ")", ",", "warped", ".", "astype", "(", "\n", "'uint8'", ")", ",", "recon_err", ",", "pred_tgt", "\n", "\n", "", "rgb_tgt", ",", "warped", ",", "recon_err", ",", "pred_tgt", "=", "preprocess", "(", "rgb_tgt", ",", "pred_tgt", ",", "\n", "warped", ")", "\n", "\n", "# 1st column", "\n", "column", "=", "0", "\n", "axarr", "[", "0", "]", ".", "imshow", "(", "rgb_tgt", ")", "\n", "axarr", "[", "0", "]", ".", "axis", "(", "'off'", ")", "\n", "axarr", "[", "0", "]", ".", "axis", "(", "'equal'", ")", "\n", "# axarr[0, column].set_title('rgb_tgt')", "\n", "\n", "axarr", "[", "1", "]", ".", "imshow", "(", "warped", ")", "\n", "axarr", "[", "1", "]", ".", "axis", "(", "'off'", ")", "\n", "axarr", "[", "1", "]", ".", "axis", "(", "'equal'", ")", "\n", "# axarr[1, column].set_title('warped')", "\n", "\n", "axarr", "[", "2", "]", ".", "imshow", "(", "recon_err", ",", "'hot'", ")", "\n", "axarr", "[", "2", "]", ".", "axis", "(", "'off'", ")", "\n", "axarr", "[", "2", "]", ".", "axis", "(", "'equal'", ")", "\n", "# axarr[2, column].set_title('recon_err error')", "\n", "\n", "axarr", "[", "3", "]", ".", "imshow", "(", "pred_tgt", ",", "'hot'", ")", "\n", "axarr", "[", "3", "]", ".", "axis", "(", "'off'", ")", "\n", "axarr", "[", "3", "]", ".", "axis", "(", "'equal'", ")", "\n", "# axarr[3, column].set_title('pred_tgt')", "\n", "\n", "# plt.show()", "\n", "plt", ".", "pause", "(", "0.001", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.criteria.MaskedMSELoss.__init__": [[8, 10], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "MaskedMSELoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.criteria.MaskedMSELoss.forward": [[11, 18], ["pred.dim", "target.dim"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ")", ":", "\n", "        ", "assert", "pred", ".", "dim", "(", ")", "==", "target", ".", "dim", "(", ")", ",", "\"inconsistent dimensions\"", "\n", "valid_mask", "=", "(", "target", ">", "0", ")", ".", "detach", "(", ")", "\n", "diff", "=", "target", "-", "pred", "\n", "diff", "=", "diff", "[", "valid_mask", "]", "\n", "self", ".", "loss", "=", "(", "diff", "**", "2", ")", ".", "mean", "(", ")", "\n", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.criteria.MaskedL1Loss.__init__": [[21, 23], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "MaskedL1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.criteria.MaskedL1Loss.forward": [[24, 31], ["diff.abs().mean", "pred.dim", "target.dim", "diff.abs"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "weight", "=", "None", ")", ":", "\n", "        ", "assert", "pred", ".", "dim", "(", ")", "==", "target", ".", "dim", "(", ")", ",", "\"inconsistent dimensions\"", "\n", "valid_mask", "=", "(", "target", ">", "0", ")", ".", "detach", "(", ")", "\n", "diff", "=", "target", "-", "pred", "\n", "diff", "=", "diff", "[", "valid_mask", "]", "\n", "self", ".", "loss", "=", "diff", ".", "abs", "(", ")", ".", "mean", "(", ")", "\n", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.criteria.PhotometricLoss.__init__": [[34, 36], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "PhotometricLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.criteria.PhotometricLoss.forward": [[37, 69], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "valid_mask.byte().detach.byte().detach.byte().detach", "recon.dim", "recon.dim", "target.dim", "target.dim", "recon.size", "target.size", "recon.size", "target.size", "valid_mask.byte().detach.byte().detach.numel", "print", "torch.squeeze().float", "torch.squeeze().float", "torch.squeeze().float", "torch.squeeze().float", "valid_mask.byte().detach.byte().detach.byte", "torch.sum.nelement", "torch.sum.nelement", "torch.sum.mean", "torch.sum.mean", "print", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "target", ",", "recon", ",", "mask", "=", "None", ")", ":", "\n", "\n", "        ", "assert", "recon", ".", "dim", "(", "\n", ")", "==", "4", ",", "\"expected recon dimension to be 4, but instead got {}.\"", ".", "format", "(", "\n", "recon", ".", "dim", "(", ")", ")", "\n", "assert", "target", ".", "dim", "(", "\n", ")", "==", "4", ",", "\"expected target dimension to be 4, but instead got {}.\"", ".", "format", "(", "\n", "target", ".", "dim", "(", ")", ")", "\n", "assert", "recon", ".", "size", "(", ")", "==", "target", ".", "size", "(", ")", ",", "\"expected recon and target to have the same size, but got {} and {} instead\"", ".", "format", "(", "recon", ".", "size", "(", ")", ",", "target", ".", "size", "(", ")", ")", "\n", "diff", "=", "(", "target", "-", "recon", ")", ".", "abs", "(", ")", "\n", "diff", "=", "torch", ".", "sum", "(", "diff", ",", "1", ")", "# sum along the color channel", "\n", "\n", "# compare only pixels that are not black", "\n", "valid_mask", "=", "(", "torch", ".", "sum", "(", "recon", ",", "1", ")", ">", "0", ")", ".", "float", "(", ")", "*", "(", "torch", ".", "sum", "(", "target", ",", "1", ")", "\n", ">", "0", ")", ".", "float", "(", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "valid_mask", "=", "valid_mask", "*", "torch", ".", "squeeze", "(", "mask", ")", ".", "float", "(", ")", "\n", "", "valid_mask", "=", "valid_mask", ".", "byte", "(", ")", ".", "detach", "(", ")", "\n", "if", "valid_mask", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "diff", "=", "diff", "[", "valid_mask", "]", "\n", "if", "diff", ".", "nelement", "(", ")", ">", "0", ":", "\n", "                ", "self", ".", "loss", "=", "diff", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\n", "\"warning: diff.nelement()==0 in PhotometricLoss (this is expected during early stage of training, try larger batch size).\"", "\n", ")", "\n", "self", ".", "loss", "=", "0", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "\"warning: 0 valid pixel in PhotometricLoss\"", ")", "\n", "self", ".", "loss", "=", "0", "\n", "", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.criteria.SmoothnessLoss.__init__": [[72, 74], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "SmoothnessLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.criteria.SmoothnessLoss.forward": [[75, 89], ["criteria.SmoothnessLoss.forward.second_derivative"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "depth", ")", ":", "\n", "        ", "def", "second_derivative", "(", "x", ")", ":", "\n", "            ", "assert", "x", ".", "dim", "(", "\n", ")", "==", "4", ",", "\"expected 4-dimensional data, but instead got {}\"", ".", "format", "(", "\n", "x", ".", "dim", "(", ")", ")", "\n", "horizontal", "=", "2", "*", "x", "[", ":", ",", ":", ",", "1", ":", "-", "1", ",", "1", ":", "-", "1", "]", "-", "x", "[", ":", ",", ":", ",", "1", ":", "-", "1", ",", ":", "\n", "-", "2", "]", "-", "x", "[", ":", ",", ":", ",", "1", ":", "-", "1", ",", "2", ":", "]", "\n", "vertical", "=", "2", "*", "x", "[", ":", ",", ":", ",", "1", ":", "-", "1", ",", "1", ":", "-", "1", "]", "-", "x", "[", ":", ",", ":", ",", ":", "-", "2", ",", "1", ":", "\n", "-", "1", "]", "-", "x", "[", ":", ",", ":", ",", "2", ":", ",", "1", ":", "-", "1", "]", "\n", "der_2nd", "=", "horizontal", ".", "abs", "(", ")", "+", "vertical", ".", "abs", "(", ")", "\n", "return", "der_2nd", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "loss", "=", "second_derivative", "(", "depth", ")", "\n", "return", "self", ".", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.create_custom_depth_maps": [[29, 143], ["iter", "range", "sorted", "sorted", "sorted", "int", "range", "numpy.asarray", "reshaped_predictions_of_same_image.squeeze().transpose.squeeze().transpose", "aux_functions.depth_read", "int", "os.makedirs", "aux_functions.depth_write", "glob.glob", "glob.glob", "glob.glob", "len", "sorted", "sorted", "sorted", "int", "sorted", "sorted", "sorted", "int", "predictions_of_same_image.append", "round", "numpy.reshape", "numpy.zeros", "aux_functions.depth_read", "depth_read.copy", "numpy.reshape", "aux_functions.lidar_choose", "numpy.reshape", "numpy.expand_dims().transpose", "numpy.reshape", "os.path.dirname", "paths_gt[].split", "numpy.reshape", "aux_functions.show_prob_map_and_sampling_indices_on_image", "len", "len", "glob.glob", "glob.glob", "glob.glob", "len", "glob.glob", "glob.glob", "glob.glob", "len", "aux_functions.depth_read", "numpy.reshape", "reshaped_predictions_of_same_image.squeeze().transpose.squeeze", "depth_read.copy", "numpy.zeros", "np.reshape.squeeze", "aux_functions.lidar_choose", "print", "exit", "numpy.zeros", "numpy.reshape", "print", "x.copy", "numpy.reshape", "len", "len", "len", "len", "next", "range", "print", "exit", "np.reshape.squeeze", "numpy.expand_dims", "paths_d_pred[].split", "paths_d_pred[].split", "x.split", "current_pred_dir.split", "current_pred_dir.split", "[].split", "numpy.sum", "x.split", "x.split", "[].replace", "current_depth_dir.split", "filename.split"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.depth_read", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.depth_write", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.depth_read", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.lidar_choose", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.show_prob_map_and_sampling_indices_on_image", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.depth_read", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.lidar_choose"], ["def", "create_custom_depth_maps", "(", "current_pred_dir", ",", "current_depth_dir", ",", "num_of_NN", ",", "phase", ",", "budget", ",", "samp_method", ",", "metric", ",", "is_test", "=", "False", ",", "save_probs_and_sample_maps", "=", "False", ",", "first_phase_rgbd", "=", "False", ")", ":", "\n", "    ", "if", "'val_select'", "in", "current_pred_dir", ":", "# dealing with val_select", "\n", "        ", "glob_d", "=", "\"\"", ".", "join", "(", "current_depth_dir", "+", "'/depth_selection/val_selection_cropped/velodyne_raw/*.png'", ")", "# velodyne from the current phase (based on last phase's predictions)", "\n", "paths_d", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_d", ")", ")", "\n", "\n", "glob_gt", "=", "'../data_new/phase_1/mini_set_1/depth_selection/val_selection_cropped/groundtruth_depth/*.png'", "# the gt aren't changing", "\n", "paths_gt", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_gt", ")", ")", "\n", "\n", "glob_d_pred", "=", "\"\"", ".", "join", "(", "current_pred_dir", "+", "'/NN*/depth_selection/val_selection_cropped/velodyne_raw/*.png'", ")", "# the NNs prediction on the current phase's images", "\n", "paths_d_pred", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_d_pred", ")", ",", "key", "=", "lambda", "x", ":", "x", ".", "split", "(", "'velodyne_raw/'", ")", "[", "1", "]", ")", "# the sort makes sure same images in different NN* are arranged together", "\n", "\n", "predictions", "=", "num_of_NN", "\n", "num_different_images", "=", "int", "(", "len", "(", "paths_d_pred", ")", "/", "num_of_NN", ")", "\n", "assert", "len", "(", "paths_d_pred", ")", "==", "len", "(", "paths_gt", ")", "*", "num_of_NN", ",", "\"create_custom_depth_maps: there are not enough predictions per image for val_select\"", "\n", "", "elif", "is_test", "==", "False", ":", "# dealing with train", "\n", "        ", "glob_d", "=", "\"\"", ".", "join", "(", "current_depth_dir", "+", "'/data_depth_velodyne/train/*_sync/proj_depth/velodyne_raw/image_0[2,3]/*.png'", ")", "\n", "paths_d", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_d", ")", ")", "\n", "\n", "glob_gt", "=", "\"\"", ".", "join", "(", "'../data_new/phase_1/mini_set_'", "+", "current_depth_dir", ".", "split", "(", "'mini_set_'", ")", "[", "1", "]", "[", "0", "]", "+", "'/data_depth_annotated/train/*_sync/proj_depth/groundtruth/image_0[2,3]/*.png'", ")", "\n", "paths_gt", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_gt", ")", ")", "\n", "\n", "glob_d_pred", "=", "\"\"", ".", "join", "(", "current_pred_dir", "+", "'/NN*/data_depth_velodyne/train/*_sync/proj_depth/velodyne_raw/image_0[2,3]/*.png'", ")", "\n", "paths_d_pred", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_d_pred", ")", ",", "key", "=", "lambda", "x", ":", "x", ".", "split", "(", "'train/'", ")", "[", "1", "]", ")", "\n", "\n", "predictions", "=", "num_of_NN", "-", "1", "\n", "num_different_images", "=", "int", "(", "len", "(", "paths_d_pred", ")", "/", "(", "num_of_NN", "-", "1", ")", ")", "\n", "assert", "len", "(", "paths_d_pred", ")", "==", "len", "(", "paths_gt", ")", "*", "(", "num_of_NN", "-", "1", ")", ",", "\"create_custom_depth_maps: there are not enough predictions per image for train\"", "\n", "", "else", ":", "# dealing with test", "\n", "        ", "glob_d", "=", "\"\"", ".", "join", "(", "current_depth_dir", "+", "'/data_depth_velodyne/test/*_sync/proj_depth/velodyne_raw/image_0[2,3]/*.png'", ")", "\n", "paths_d", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_d", ")", ")", "\n", "\n", "glob_gt", "=", "\"\"", ".", "join", "(", "'../data_new/phase_1/mini_set_1/data_depth_annotated/test/*_sync/proj_depth/groundtruth/image_0[2,3]/*.png'", ")", "\n", "paths_gt", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_gt", ")", ")", "\n", "\n", "glob_d_pred", "=", "\"\"", ".", "join", "(", "current_pred_dir", "+", "'/NN*/data_depth_velodyne/test/*_sync/proj_depth/velodyne_raw/image_0[2,3]/*.png'", ")", "\n", "paths_d_pred", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_d_pred", ")", ",", "key", "=", "lambda", "x", ":", "x", ".", "split", "(", "'test/'", ")", "[", "1", "]", ")", "\n", "\n", "predictions", "=", "num_of_NN", "\n", "num_different_images", "=", "int", "(", "len", "(", "paths_d_pred", ")", "/", "num_of_NN", ")", "\n", "assert", "len", "(", "paths_d_pred", ")", "==", "len", "(", "paths_gt", ")", "*", "num_of_NN", ",", "\"create_custom_depth_maps: there are not enough predictions per image for test\"", "\n", "\n", "", "paths_d_pred_itr", "=", "iter", "(", "paths_d_pred", ")", "\n", "for", "image", "in", "range", "(", "num_different_images", ")", ":", "\n", "        ", "predictions_of_same_image", "=", "[", "]", "# will be: [num_of_images][row][col]", "\n", "for", "i", "in", "range", "(", "predictions", ")", ":", "\n", "            ", "predictions_of_same_image", ".", "append", "(", "depth_read", "(", "next", "(", "paths_d_pred_itr", ")", ")", ")", "\n", "\n", "# creating inputs for lidar_choose function", "\n", "", "h", ",", "w", "=", "predictions_of_same_image", "[", "0", "]", ".", "shape", "# should be 352x1216", "\n", "reshaped_predictions_of_same_image", "=", "np", ".", "asarray", "(", "[", "np", ".", "reshape", "(", "predictions_of_same_image", "[", "j", "]", ",", "(", "h", "*", "w", ",", "1", ")", ")", "for", "j", "in", "range", "(", "predictions", ")", "]", ")", "\n", "reshaped_predictions_of_same_image", "=", "(", "reshaped_predictions_of_same_image", ".", "squeeze", "(", "axis", "=", "2", ")", ")", ".", "transpose", "(", ")", "# shape should be: (h*w, predictions)", "\n", "\n", "current_gt", "=", "depth_read", "(", "paths_gt", "[", "image", "]", ")", "# should be bigger than 352x1216 if train, else exactly 352x1216 (validation & test sets came from val_select_cropped)", "\n", "m", "=", "current_gt", ".", "shape", "[", "0", "]", "-", "352", "\n", "n", "=", "int", "(", "round", "(", "(", "current_gt", ".", "shape", "[", "1", "]", "-", "1216", ")", "/", "2.", ")", ")", "\n", "current_gt", "=", "current_gt", "[", "m", ":", "(", "m", "+", "352", ")", ",", "n", ":", "(", "n", "+", "1216", ")", "]", "\n", "\n", "if", "(", "phase", "==", "1", ")", "and", "(", "not", "first_phase_rgbd", ")", ":", "# no d inputs", "\n", "            ", "valid_mask", "=", "np", ".", "reshape", "(", "current_gt", ".", "copy", "(", ")", ",", "(", "h", "*", "w", ",", "1", ")", ")", "# the whole gt samples are valid, changing to a vector", "\n", "current_velodyne", "=", "np", ".", "zeros", "(", "current_gt", ".", "shape", ")", "# we don't have samples yet", "\n", "", "else", ":", "# cropping, make sure we don't give option to sample pixels that we've already sampled, changing to a vector", "\n", "            ", "current_velodyne", "=", "depth_read", "(", "paths_d", "[", "image", "]", ")", "# should be 352x1216 because our predictions are already cropped and we made the last velodyne to be the same shape as them", "\n", "if", "first_phase_rgbd", "and", "current_velodyne", ".", "shape", "[", "0", "]", "!=", "352", ":", "# if first phase is RGBD so we just need to be sure the first d-maps (with 0 samples) are in the right shape", "\n", "                ", "current_velodyne", "=", "np", ".", "zeros", "(", "current_gt", ".", "shape", ")", "\n", "if", "phase", ">", "1", ":", "\n", "                    ", "print", "(", "\"Create map: should not enter here after first phase\"", ")", "\n", "exit", "(", ")", "\n", "", "", "assert", "current_velodyne", ".", "shape", "==", "current_gt", ".", "shape", ",", "\"'create_custom_depth_maps' function: current_velodyne & current_gt shapes are different\"", "\n", "valid_mask", "=", "current_gt", ".", "copy", "(", ")", "\n", "valid_mask", "[", "current_velodyne", ">", "0", "]", "=", "0", "# can be 0 or -1, lidar_choose doesn't care. if we have valid samples in velodyne we don't want to choose them again", "\n", "valid_mask", "=", "np", ".", "reshape", "(", "valid_mask", ",", "(", "h", "*", "w", ",", "1", ")", ")", "\n", "current_velodyne", "[", "current_velodyne", "<=", "0", "]", "=", "0", "# keep only valid samples (pixels that are >=0)", "\n", "\n", "", "if", "metric", "==", "'rmse'", ":", "\n", "            ", "inds_to_sample_next", ",", "prob_only_valid_for_next_sampling", ",", "x", "=", "lidar_choose", "(", "reshaped_predictions_of_same_image", ",", "valid_mask", ".", "squeeze", "(", ")", ",", "budget", ",", "'var'", ",", "samp_method", ")", "\n", "", "elif", "metric", "==", "'mae'", ":", "\n", "            ", "inds_to_sample_next", ",", "prob_only_valid_for_next_sampling", ",", "x", "=", "lidar_choose", "(", "reshaped_predictions_of_same_image", ",", "valid_mask", ".", "squeeze", "(", ")", ",", "budget", ",", "'median'", ",", "samp_method", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Wrong criterion, exiting...\"", ")", "\n", "exit", "(", ")", "\n", "\n", "", "if", "inds_to_sample_next", ".", "size", "!=", "0", ":", "# we have samples", "\n", "            ", "next_velodyne", "=", "np", ".", "reshape", "(", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ")", ",", "(", "h", "*", "w", ",", "1", ")", ")", "# vector of zeros (non valid depth)", "\n", "inds_to_sample_next", "=", "np", ".", "expand_dims", "(", "inds_to_sample_next", ",", "0", ")", ".", "transpose", "(", ")", "\n", "next_velodyne", "[", "inds_to_sample_next", "]", "=", "np", ".", "reshape", "(", "current_gt", ",", "(", "h", "*", "w", ",", "1", ")", ")", "[", "inds_to_sample_next", "]", "\n", "next_velodyne", "=", "np", ".", "reshape", "(", "next_velodyne", ",", "(", "h", ",", "w", ")", ")", "\n", "next_velodyne", "=", "next_velodyne", "+", "current_velodyne", "# we want to add the previous samples", "\n", "", "else", ":", "# we don't have (already took all valid samples), take current velodyne instead", "\n", "            ", "next_velodyne", "=", "current_velodyne", "\n", "\n", "", "if", "'val_select'", "in", "current_pred_dir", ":", "\n", "            ", "filename", "=", "current_pred_dir", ".", "split", "(", "'/predictions_tmp_val_select'", ")", "[", "0", "]", "+", "'/depth_selection'", "+", "paths_d_pred", "[", "(", "(", "predictions", ")", "*", "image", ")", "+", "i", "]", ".", "split", "(", "'/depth_selection'", ")", "[", "1", "]", "\n", "", "else", ":", "\n", "            ", "filename", "=", "current_pred_dir", ".", "split", "(", "'/predictions_tmp'", ")", "[", "0", "]", "+", "'/data_depth_velodyne'", "+", "paths_d_pred", "[", "(", "(", "predictions", ")", "*", "image", ")", "+", "i", "]", ".", "split", "(", "'/data_depth_velodyne'", ")", "[", "1", "]", "\n", "", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "filename", ")", ",", "exist_ok", "=", "True", ")", "\n", "depth_write", "(", "filename", ",", "next_velodyne", ")", "# if we've opened with depth_read, we need to save with depth_write. This will be cropped", "\n", "\n", "if", "save_probs_and_sample_maps", "==", "True", ":", "# to debug or look at the semi-results (only on mini-set 1)", "\n", "            ", "if", "'val_select'", "in", "current_pred_dir", ":", "\n", "                ", "print", "(", "\"create_custom_depth_maps: save probs and sample maps of val_select is not available yet. Need to make some modifications. Continue without saving...\"", ")", "\n", "continue", "\n", "", "elif", "filename", ".", "split", "(", "'set_'", ")", "[", "1", "]", ".", "split", "(", "'/'", ")", "[", "0", "]", "!=", "'1'", ":", "# we are saving only things in miniset-1", "\n", "                ", "continue", "\n", "\n", "", "next_velodyne", "[", "next_velodyne", ">", "0", "]", "=", "1", "\n", "ps", "=", "paths_gt", "[", "image", "]", ".", "split", "(", "'/'", ")", "\n", "if", "is_test", ":", "\n", "                ", "rgb_path", "=", "'/'", ".", "join", "(", "ps", "[", ":", "-", "7", "]", "+", "[", "'data_rgb'", "]", "+", "ps", "[", "-", "6", ":", "-", "4", "]", "+", "ps", "[", "-", "2", ":", "-", "1", "]", "+", "[", "'data'", "]", "+", "[", "ps", "[", "-", "1", ":", "]", "[", "0", "]", ".", "replace", "(", "'groundtruth_depth'", ",", "'image'", ")", "]", ")", "\n", "", "else", ":", "\n", "                ", "rgb_path", "=", "'/'", ".", "join", "(", "ps", "[", ":", "-", "7", "]", "+", "[", "'data_rgb'", "]", "+", "ps", "[", "-", "6", ":", "-", "4", "]", "+", "ps", "[", "-", "2", ":", "-", "1", "]", "+", "[", "'data'", "]", "+", "ps", "[", "-", "1", ":", "]", ")", "\n", "", "x_only_gt_valid", "=", "np", ".", "reshape", "(", "x", ".", "copy", "(", ")", ",", "(", "h", ",", "w", ")", ")", "# will be only valid", "\n", "x_only_gt_valid", "[", "current_gt", "<", "0", "]", "=", "0", "\n", "show_prob_map_and_sampling_indices_on_image", "(", "phase", ",", "rgb_path", ",", "next_velodyne", ",", "np", ".", "reshape", "(", "x", "/", "np", ".", "sum", "(", "x", ")", ",", "(", "h", ",", "w", ")", ")", ",", "\n", "x_only_gt_valid", ",", "show_results", "=", "False", ",", "save_results", "=", "True", ")", "# if want the variance map, take x instead of x / np.sum(x)", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.lidar_choose": [[160, 227], ["numpy.all", "numpy.sort().astype", "np.mean.copy", "numpy.where", "numpy.sum", "numpy.var().astype", "print", "print", "numpy.random.choice", "numpy.sort", "numpy.array", "numpy.array", "numpy.array().astype", "valid_mask.sum", "numpy.concatenate", "numpy.random.choice", "numpy.var", "numpy.median", "numpy.transpose", "numpy.mean", "numpy.array", "numpy.random.choice", "numpy.argpartition", "numpy.tile", "numpy.absolute", "numpy.argpartition", "numpy.array"], "function", ["None"], ["def", "lidar_choose", "(", "scores", ",", "valid_mask", ",", "budget", ",", "method", ",", "pm_greedy", ")", ":", "\n", "    ", "assert", "method", "in", "[", "'var'", ",", "'median'", "]", ",", "\"unknown method:\"", "+", "method", "\n", "assert", "pm_greedy", "in", "[", "'pm'", ",", "'greedy'", "]", ",", "\"unknown pm_greedy:\"", "+", "pm_greedy", "\n", "assert", "scores", ".", "shape", "[", "0", "]", "==", "valid_mask", ".", "shape", "[", "0", "]", ",", "\"scores.shape[0] != valid_mask.shape[0]\"", "\n", "assert", "np", ".", "all", "(", "scores", ">=", "0.", ")", ",", "\"non-positive predictions found!\"", "\n", "\n", "n", ",", "k", "=", "scores", ".", "shape", "\n", "scores", "=", "np", ".", "sort", "(", "scores", ",", "axis", "=", "1", ")", ".", "astype", "(", "'float32'", ")", "# sort each cell (depth predictions of a pixel) from small to large value", "\n", "\n", "if", "method", "==", "'var'", ":", "# relates to L2", "\n", "        ", "x", "=", "np", ".", "var", "(", "scores", ",", "axis", "=", "1", ")", ".", "astype", "(", "'float32'", ")", "\n", "", "elif", "method", "==", "'quantiles'", ":", "\n", "        ", "x", "=", "(", "scores", "[", ":", ",", "-", "1", "]", "-", "scores", "[", ":", ",", "0", "]", ")", "**", "2", "\n", "", "elif", "method", "==", "'median'", ":", "# relates to L1", "\n", "        ", "med", "=", "np", ".", "median", "(", "scores", ",", "axis", "=", "1", ")", "# median of even array is a non existing element (the middle)", "\n", "medians", "=", "np", ".", "transpose", "(", "np", ".", "tile", "(", "med", ",", "(", "scores", ".", "shape", "[", "1", "]", ",", "1", ")", ")", ")", "\n", "x", "=", "np", ".", "mean", "(", "np", ".", "absolute", "(", "scores", "-", "medians", ")", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "        ", "assert", "(", "1", ")", "\n", "\n", "", "prob_only_valid", "=", "x", ".", "copy", "(", ")", "# will contain cues where it's best to sample (based on the predictors)", "\n", "\n", "# give zero prob to invalid points", "\n", "bad_inds", ",", "=", "np", ".", "where", "(", "valid_mask", "<=", "0", ")", "\n", "good_inds", "=", "scores", ".", "shape", "[", "0", "]", "-", "bad_inds", ".", "shape", "[", "0", "]", "# something to sample from", "\n", "prob_only_valid", "[", "bad_inds", "]", "=", "0.", "\n", "s", "=", "np", ".", "sum", "(", "prob_only_valid", ")", "\n", "\n", "if", "budget", ">", "good_inds", ":", "# we want to sample more then we can", "\n", "        ", "print", "(", "\"Warning: lidar_choose: taking {} instead of {} samples, because not enough valid pixels to sample from gt\"", ".", "format", "(", "good_inds", ",", "budget", ")", ")", "\n", "budget", "=", "good_inds", "\n", "if", "budget", "==", "0", ":", "# nothing to sample", "\n", "            ", "prob_only_valid", "=", "np", ".", "array", "(", "[", "]", ")", "# nothing is valid. We don't have valid prob map", "\n", "return", "(", "np", ".", "array", "(", "[", "]", ")", ",", "prob_only_valid", ",", "x", ")", "\n", "\n", "", "", "if", "budget", ">", "prob_only_valid", "[", "prob_only_valid", ">", "0", "]", ".", "shape", "[", "0", "]", ":", "# not enough pixels in prob_map (not much difference between predictors). We'll have to take some random samples because", "\n", "        ", "budget_prob", "=", "prob_only_valid", "[", "prob_only_valid", ">", "0", "]", ".", "shape", "[", "0", "]", "\n", "budget_rand", "=", "budget", "-", "budget_prob", "# prob map == 0 for them", "\n", "print", "(", "\"Warning: lidar_choose: only {} different valid pixels to sample from (probability map is zero elsewhere). {} remaining samples will be taken randomly uniform from {} \"", "\n", "\"valid pixels\"", ".", "format", "(", "budget_prob", ",", "budget_rand", ",", "good_inds", "-", "budget_prob", ")", ")", "\n", "if", "budget_prob", "!=", "0", ":", "# samples based on the probability map", "\n", "            ", "prob_only_valid", "=", "prob_only_valid", "/", "s", "\n", "if", "pm_greedy", "==", "'pm'", ":", "\n", "                ", "inds1", "=", "np", ".", "random", ".", "choice", "(", "n", ",", "budget_prob", ",", "False", ",", "prob_only_valid", ")", "# len(inds) = budget. Choose budget numbers from n array (np.arange(n)),", "\n", "# based on the probabilities prob. No replacements", "\n", "", "else", ":", "# greedy-MAX", "\n", "                ", "inds1", "=", "np", ".", "argpartition", "(", "prob_only_valid", ",", "-", "budget_prob", ")", "[", "-", "budget_prob", ":", "]", "# get 'budget' max indices of 'prob'", "\n", "", "valid_mask", "[", "inds1", "]", "=", "0", "# remove indices we took already", "\n", "", "else", ":", "# we'll take only random (everything valid is zeros)", "\n", "            ", "prob_only_valid", "=", "np", ".", "array", "(", "[", "]", ")", "# we don't have valid prob map", "\n", "inds1", "=", "np", ".", "array", "(", "[", "]", ")", ".", "astype", "(", "'int'", ")", "\n", "\n", "# sample randomly - no matter PM or greedy (all have the same weights - uniform)", "\n", "", "valid_mask", "[", "valid_mask", ">", "0", "]", "=", "1", "\n", "valid_mask", "[", "valid_mask", "<", "0", "]", "=", "0", "\n", "valid_mask", "=", "valid_mask", "/", "valid_mask", ".", "sum", "(", ")", "# uniform", "\n", "inds2", "=", "np", ".", "random", ".", "choice", "(", "n", ",", "budget_rand", ",", "False", ",", "valid_mask", ")", "\n", "return", "(", "np", ".", "concatenate", "(", "[", "inds1", ",", "inds2", "]", ")", ",", "prob_only_valid", ",", "x", ")", "\n", "\n", "", "else", ":", "# enough pixels in prob_map", "\n", "        ", "prob_only_valid", "=", "prob_only_valid", "/", "s", "\n", "if", "pm_greedy", "==", "'pm'", ":", "\n", "            ", "inds", "=", "np", ".", "random", ".", "choice", "(", "n", ",", "budget", ",", "False", ",", "prob_only_valid", ")", "\n", "", "else", ":", "# greedy-MAX", "\n", "            ", "inds", "=", "np", ".", "argpartition", "(", "prob_only_valid", ",", "-", "budget", ")", "[", "-", "budget", ":", "]", "\n", "\n", "", "", "return", "(", "inds", ",", "prob_only_valid", ",", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.depth_write": [[231, 240], ["np.minimum.astype", "cv2.imwrite", "numpy.max", "print", "numpy.minimum", "numpy.max", "filename.split"], "function", ["None"], ["def", "depth_write", "(", "filename", ",", "img", ")", ":", "\n", "    ", "img", "[", "img", "<", "0", "]", "=", "0", "# negative depth is like 0 depth", "\n", "img", "=", "img", "*", "256", "\n", "if", "np", ".", "max", "(", "img", ")", ">=", "2", "**", "16", ":", "\n", "        ", "print", "(", "'Warning: {} pixels in {} have depth >= 2**16 (max is: {}).Truncating before saving.'", ".", "format", "(", "img", "[", "img", ">=", "2", "**", "16", "]", ".", "shape", "[", "0", "]", ",", "\"/\"", ".", "join", "(", "filename", ".", "split", "(", "'/'", ")", "[", "-", "5", ":", "]", ")", ",", "np", ".", "max", "(", "img", ")", ")", ")", "\n", "img", "=", "np", ".", "minimum", "(", "img", ",", "2", "**", "16", "-", "1", ")", "\n", "\n", "", "img", "=", "img", ".", "astype", "(", "'uint16'", ")", "\n", "cv2", ".", "imwrite", "(", "filename", ",", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.depth_read": [[244, 253], ["numpy.array", "PIL.Image.open", "numpy.max", "print", "np.array.astype", "numpy.max"], "function", ["None"], ["def", "depth_read", "(", "filename", ")", ":", "\n", "    ", "depth_png", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "filename", ")", ",", "dtype", "=", "int", ")", "\n", "# make sure we have a proper 16bit depth map here.. not 8bit!", "\n", "if", "np", ".", "max", "(", "depth_png", ")", ">", "65536", ":", "# not relevant for debug (when NNs don't predict good depth), leading to 0.9m in all of the image, resulting this error OR when we insert black image to the NN", "\n", "        ", "print", "(", "\"warning: max depth {} in while reading image{} in depth_read\"", ".", "format", "(", "np", ".", "max", "(", "depth_png", ")", ",", "filename", ")", ")", "\n", "\n", "", "depth", "=", "depth_png", ".", "astype", "(", "np", ".", "float", ")", "/", "256.", "\n", "depth", "[", "depth_png", "==", "0", "]", "=", "-", "1.", "\n", "return", "depth", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.get_train_val_drive_list": [[257, 268], ["os.listdir", "list", "aux_functions.train_and_val", "pathlib.Path().rglob", "len", "img_count.keys", "list", "pathlib.Path", "aux_functions.get_train_val_type_dirs"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.train_and_val", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.get_train_val_type_dirs"], ["def", "get_train_val_drive_list", "(", "src_path", ",", "dir_type", ")", ":", "\n", "    ", "assert", "(", "dir_type", "in", "train_and_val", "(", ")", ")", "\n", "dirname", "=", "src_path", "+", "'/'", "+", "get_train_val_type_dirs", "(", ")", "[", "0", "]", "+", "'/'", "+", "dir_type", "# takes data_depth_annotated", "\n", "drives", "=", "os", ".", "listdir", "(", "dirname", ")", "\n", "img_count", "=", "{", "}", "\n", "for", "drive", "in", "drives", ":", "\n", "        ", "g", "=", "Path", "(", "dirname", "+", "'/'", "+", "drive", ")", ".", "rglob", "(", "'*.png'", ")", "\n", "img_count", "[", "drive", "]", "=", "len", "(", "list", "(", "g", ")", ")", "\n", "\n", "", "drives", "=", "list", "(", "img_count", ".", "keys", "(", ")", ")", "\n", "return", "(", "drives", ",", "img_count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.copy_partial_train_val": [[283, 316], ["list", "aux_functions.train_and_val", "aux_functions.get_train_val_type_dirs", "set", "len", "os.path.join", "os.path.join", "print", "aux_functions.get_train_val_type_dirs", "os.path.isdir", "shutil.copytree", "shutil.rmtree", "os.path.isdir"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.train_and_val", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.get_train_val_type_dirs", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.get_train_val_type_dirs"], ["def", "copy_partial_train_val", "(", "src_path", ",", "dest_path", ",", "drive_list", ",", "set_type", ",", "dirs", "=", "None", ")", ":", "\n", "    ", "assert", "(", "set_type", "in", "train_and_val", "(", ")", ")", "\n", "\n", "if", "dirs", "is", "None", ":", "\n", "        ", "dirs", "=", "get_train_val_type_dirs", "(", ")", "\n", "dirs_exist_ok", "=", "False", "\n", "", "else", ":", "\n", "        ", "assert", "(", "len", "(", "dirs", ")", ">", "0", ")", "\n", "for", "dir", "in", "dirs", ":", "\n", "            ", "assert", "(", "dir", "in", "get_train_val_type_dirs", "(", ")", ")", "\n", "\n", "", "dirs_exist_ok", "=", "True", "\n", "\n", "# make list of unique values", "\n", "", "drive_list", "=", "list", "(", "set", "(", "drive_list", ")", ")", "\n", "\n", "for", "drive", "in", "drive_list", ":", "\n", "        ", "success", "=", "True", "\n", "for", "dir", "in", "dirs", ":", "\n", "            ", "cur_src", "=", "os", ".", "path", ".", "join", "(", "src_path", ",", "dir", ",", "set_type", ",", "drive", ")", "\n", "cur_dest", "=", "os", ".", "path", ".", "join", "(", "dest_path", ",", "dir", ",", "set_type", ",", "drive", ")", "\n", "if", "os", ".", "path", ".", "isdir", "(", "cur_src", ")", "==", "False", ":", "\n", "                ", "success", "=", "False", "\n", "", "else", ":", "\n", "# make sure we are replacing an existing directory", "\n", "                ", "if", "dirs_exist_ok", "==", "True", ":", "\n", "                    ", "assert", "(", "os", ".", "path", ".", "isdir", "(", "cur_dest", ")", "==", "True", ")", "\n", "shutil", ".", "rmtree", "(", "cur_dest", ")", "\n", "\n", "", "shutil", ".", "copytree", "(", "cur_src", ",", "cur_dest", ")", "\n", "\n", "", "", "if", "success", "==", "False", ":", "\n", "            ", "print", "(", "'Warning: invalid drive '", "+", "drive", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.create_dir_tree_skeleton": [[320, 338], ["aux_functions.get_train_val_type_dirs", "os.walk", "os.path.exists", "print", "os.path.isdir", "print", "aux_functions.train_and_val_and_test", "os.makedirs", "os.makedirs", "len"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.get_train_val_type_dirs", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.train_and_val_and_test"], ["def", "create_dir_tree_skeleton", "(", "root_path", ",", "example_path", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "exists", "(", "root_path", ")", "==", "True", ":", "\n", "        ", "print", "(", "'path '", "+", "root_path", "+", "' already exists. Exiting.'", ")", "\n", "return", "\n", "\n", "", "if", "os", ".", "path", ".", "isdir", "(", "example_path", ")", "==", "False", ":", "\n", "        ", "print", "(", "example_path", "+", "'is not a directory or does not exist. Exiting.'", ")", "\n", "return", "\n", "\n", "", "for", "dir", "in", "get_train_val_type_dirs", "(", ")", ":", "\n", "        ", "for", "subdir", "in", "train_and_val_and_test", "(", ")", ":", "\n", "            ", "dirname", "=", "root_path", "+", "'/'", "+", "dir", "+", "'/'", "+", "subdir", "\n", "os", ".", "makedirs", "(", "dirname", ")", "\n", "\n", "", "", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "example_path", "+", "'/depth_selection'", ")", ":", "\n", "        ", "for", "name", "in", "dirs", ":", "\n", "            ", "dirname", "=", "root_path", "+", "'/'", "+", "root", "[", "len", "(", "example_path", ")", "+", "1", ":", "]", "+", "'/'", "+", "name", "\n", "os", ".", "makedirs", "(", "dirname", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.train_and_val": [[339, 341], ["None"], "function", ["None"], ["", "", "", "def", "train_and_val", "(", ")", ":", "\n", "    ", "return", "[", "'train'", ",", "'val'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.train_and_val_and_test": [[342, 344], ["None"], "function", ["None"], ["", "def", "train_and_val_and_test", "(", ")", ":", "\n", "    ", "return", "[", "'train'", ",", "'val'", ",", "'test'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.divide_drives_to_mini_sets": [[353, 383], ["aux_functions.get_train_val_drive_list", "list", "list", "numpy.argsort", "sorted", "range", "numpy.zeros", "numpy.arange", "img_count.keys", "img_count.values", "numpy.array", "drives_sorted_by_nums.append", "len", "numpy.argmin", "sets[].append", "list", "range"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.get_train_val_drive_list"], ["def", "divide_drives_to_mini_sets", "(", "n_sets", ",", "min_imgs_per_set", ",", "src_path", ",", "dir_type", ",", "add_descending", "=", "True", ")", ":", "\n", "    ", "drives", ",", "img_count", "=", "get_train_val_drive_list", "(", "src_path", ",", "dir_type", ")", "\n", "keys", "=", "list", "(", "img_count", ".", "keys", "(", ")", ")", "\n", "values", "=", "list", "(", "img_count", ".", "values", "(", ")", ")", "\n", "order", "=", "np", ".", "argsort", "(", "np", ".", "array", "(", "list", "(", "values", ")", ")", ")", "\n", "\n", "drives_sorted_by_nums", "=", "[", "]", "\n", "nums_sorted", "=", "sorted", "(", "values", ")", "\n", "success", "=", "False", "\n", "\n", "for", "i", "in", "range", "(", "order", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "drives_sorted_by_nums", ".", "append", "(", "keys", "[", "order", "[", "i", "]", "]", ")", "\n", "\n", "", "sets", "=", "[", "[", "]", "for", "i", "in", "range", "(", "n_sets", ")", "]", "\n", "sizes", "=", "np", ".", "zeros", "(", "n_sets", ",", "dtype", "=", "'int'", ")", "\n", "\n", "indices", "=", "np", ".", "arange", "(", "0", ",", "len", "(", "nums_sorted", ")", ")", "\n", "if", "add_descending", "==", "True", ":", "# bigger syncs first", "\n", "        ", "indices", "=", "indices", "[", ":", ":", "-", "1", "]", "\n", "\n", "", "for", "i", "in", "indices", ":", "\n", "        ", "smallest", "=", "np", ".", "argmin", "(", "sizes", ")", "\n", "if", "sizes", "[", "smallest", "]", ">=", "min_imgs_per_set", ":", "\n", "            ", "success", "=", "True", "\n", "break", "\n", "\n", "", "sets", "[", "smallest", "]", ".", "append", "(", "drives_sorted_by_nums", "[", "i", "]", ")", "\n", "sizes", "[", "smallest", "]", "+=", "nums_sorted", "[", "i", "]", "\n", "\n", "", "return", "(", "sets", ",", "sizes", ",", "success", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.get_train_val_type_dirs": [[387, 389], ["None"], "function", ["None"], ["def", "get_train_val_type_dirs", "(", ")", ":", "\n", "    ", "return", "[", "'data_depth_annotated'", ",", "'data_depth_velodyne'", ",", "'data_rgb'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.get_sorted_ls": [[393, 395], ["sorted", "os.listdir"], "function", ["None"], ["def", "get_sorted_ls", "(", "src_path", ")", ":", "\n", "    ", "return", "sorted", "(", "os", ".", "listdir", "(", "src_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.copy_partial_val_selection_cropped": [[405, 434], ["os.path.join", "len", "os.listdir", "os.path.join", "type", "type", "len", "list", "str", "os.listdir", "sys.exit", "set", "pathlib.Path().rglob", "os.path.join", "aux_functions.get_sorted_ls", "shutil.copyfile", "str", "shutil.copyfile", "print", "os.path.join", "os.path.join", "os.path.join", "pathlib.Path", "os.path.join", "os.path.join", "len"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.get_sorted_ls"], ["def", "copy_partial_val_selection_cropped", "(", "src_path", ",", "dest_path", ",", "subset_params", ")", ":", "\n", "    ", "vsc_suf", "=", "os", ".", "path", ".", "join", "(", "'depth_selection'", ",", "'val_selection_cropped'", ")", "\n", "\n", "# find if params specify range or drive list", "\n", "if", "len", "(", "subset_params", ")", ">", "0", ":", "\n", "        ", "dirnames", "=", "os", ".", "listdir", "(", "\n", "os", ".", "path", ".", "join", "(", "src_path", ",", "vsc_suf", ")", ")", "# ['velodyne_raw', 'image', 'groundtruth_depth', 'intrinsics']", "\n", "if", "type", "(", "subset_params", "[", "0", "]", ")", "!=", "type", "(", "str", "(", ")", ")", ":", "# images range", "\n", "            ", "n", "=", "len", "(", "os", ".", "listdir", "(", "os", ".", "path", ".", "join", "(", "src_path", ",", "vsc_suf", ",", "dirnames", "[", "0", "]", ")", ")", ")", "# number of files inside 'velodyne_raw' folder. Should be 1000", "\n", "start", ",", "end", "=", "subset_params", "\n", "if", "start", "<", "0", "or", "end", ">", "n", ":", "\n", "                ", "sys", ".", "exit", "(", "'copy_partial_val_selection_cropped: invalid range'", ")", "# probably there are not enough images to copy", "\n", "\n", "", "for", "dirname", "in", "dirnames", ":", "\n", "                ", "for", "filename", "in", "get_sorted_ls", "(", "os", ".", "path", ".", "join", "(", "src_path", ",", "vsc_suf", ",", "dirname", ")", ")", "[", "start", ":", "end", "]", ":", "\n", "                    ", "shutil", ".", "copyfile", "(", "os", ".", "path", ".", "join", "(", "src_path", ",", "vsc_suf", ",", "dirname", ",", "filename", ")", ",", "\n", "os", ".", "path", ".", "join", "(", "dest_path", ",", "vsc_suf", ",", "dirname", ",", "filename", ")", ")", "\n", "", "", "", "else", ":", "# drive list", "\n", "            ", "drive_list", "=", "list", "(", "set", "(", "subset_params", ")", ")", "# make unique", "\n", "for", "drive", "in", "drive_list", ":", "\n", "                ", "found", "=", "False", "\n", "for", "filename", "in", "Path", "(", "os", ".", "path", ".", "join", "(", "src_path", ",", "vsc_suf", ")", ")", ".", "rglob", "(", "drive", "+", "'*'", ")", ":", "\n", "                    ", "found", "=", "True", "\n", "strname", "=", "str", "(", "filename", ")", "\n", "shutil", ".", "copyfile", "(", "strname", ",", "os", ".", "path", ".", "join", "(", "dest_path", ",", "strname", "[", "len", "(", "src_path", ")", "+", "1", ":", "]", ")", ")", "\n", "", "if", "found", "==", "False", ":", "\n", "                    ", "print", "(", "'Warning: invalid drive: '", "+", "drive", ")", "\n", "", "", "", "", "else", ":", "\n", "        ", "assert", "1", ",", "'invalid params'", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.copypath": [[438, 451], ["os.path.isdir", "shutil.copytree", "shutil.copyfile", "os.path.exists", "shutil.rmtree", "sys.exit", "sys.exit"], "function", ["None"], ["def", "copypath", "(", "src", ",", "dest", ",", "overwrite_dest_dir", "=", "False", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "isdir", "(", "src", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "if", "overwrite_dest_dir", "and", "os", ".", "path", ".", "exists", "(", "dest", ")", ":", "\n", "                ", "shutil", ".", "rmtree", "(", "dest", ")", "\n", "", "shutil", ".", "copytree", "(", "src", ",", "dest", ")", "\n", "", "except", ":", "\n", "            ", "sys", ".", "exit", "(", "'FAILED copytree. Exiting.'", ")", "\n", "", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "shutil", ".", "copyfile", "(", "src", ",", "dest", ")", "\n", "", "except", ":", "\n", "            ", "sys", ".", "exit", "(", "'FAILED copyfile. Exiting.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.apply_empty_d_maps_to_data": [[455, 460], ["time.time", "aux_functions.apply_empty_d_maps_to_directory", "aux_functions.apply_empty_d_maps_to_directory", "print", "os.path.join", "os.path.join", "time.time"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.apply_empty_d_maps_to_directory", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.apply_empty_d_maps_to_directory"], ["def", "apply_empty_d_maps_to_data", "(", "src_path_to_overwrite", ")", ":", "\n", "    ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "apply_empty_d_maps_to_directory", "(", "os", ".", "path", ".", "join", "(", "src_path_to_overwrite", ",", "'data_depth_velodyne'", ")", ")", "\n", "apply_empty_d_maps_to_directory", "(", "os", ".", "path", ".", "join", "(", "src_path_to_overwrite", ",", "'depth_selection'", ",", "'val_selection_cropped'", ",", "'velodyne_raw'", ")", ")", "\n", "print", "(", "\"Finished after {:.2f} hours\"", ".", "format", "(", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", "/", "3600", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.apply_empty_d_maps_to_directory": [[461, 469], ["print", "os.system", "numpy.zeros", "pathlib.Path().rglob", "str", "aux_functions.depth_write", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.depth_write"], ["", "def", "apply_empty_d_maps_to_directory", "(", "dirpath", ")", ":", "\n", "    ", "print", "(", "\"number of images in folder {}: \"", ".", "format", "(", "dirpath", ")", ",", "flush", "=", "True", ")", "\n", "os", ".", "system", "(", "'find '", "+", "dirpath", "+", "' -name \\'*.png\\' | wc -l'", ")", "# we'll get 0 when trying to deal with val_select that is not in mini-set 1 (because they should not be there - so it's ok)", "\n", "empty_map", "=", "np", ".", "zeros", "(", "(", "352", ",", "1216", ")", ",", "dtype", "=", "int", ")", "\n", "\n", "for", "filename", "in", "Path", "(", "dirpath", ")", ".", "rglob", "(", "'*.png'", ")", ":", "\n", "        ", "strname", "=", "str", "(", "filename", ")", "\n", "depth_write", "(", "strname", ",", "empty_map", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.show_prob_map_and_sampling_indices_on_image": [[473, 507], ["dataloaders.kitti_loader.rgb_read", "int", "aux_functions.show_img_effect", "matplotlib.cm.get_cmap", "round", "os.makedirs", "PIL.Image.fromarray", "Image.fromarray.save", "plt.cm.get_cmap.", "PIL.Image.fromarray", "Image.fromarray.save", "plt.cm.get_cmap.", "PIL.Image.fromarray", "Image.fromarray.save", "matplotlib.close", "matplotlib.figure", "matplotlib.imshow", "matplotlib.figure", "matplotlib.imshow", "os.path.dirname", "rgb_path.split", "x_gt_valid.min", "x_gt_valid.max", "x_gt_valid.min", "prob_map.min", "prob_map.max", "prob_map.min", "path.split", "path.split", "path.split", "rgb_path.split", "str"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.rgb_read", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.show_img_effect"], ["def", "show_prob_map_and_sampling_indices_on_image", "(", "phase", ",", "rgb_path", ",", "samples_map", ",", "prob_map", ",", "x_gt_valid", ",", "show_results", "=", "False", ",", "save_results", "=", "False", ")", ":", "\n", "    ", "rgb", "=", "rgb_read", "(", "rgb_path", ")", "\n", "m", "=", "rgb", ".", "shape", "[", "0", "]", "-", "352", "\n", "n", "=", "int", "(", "round", "(", "(", "rgb", ".", "shape", "[", "1", "]", "-", "1216", ")", "/", "2.", ")", ")", "\n", "rgb", "=", "rgb", "[", "m", ":", "(", "m", "+", "352", ")", ",", "n", ":", "(", "n", "+", "1216", ")", ",", ":", "]", "\n", "samples_on_image", "=", "show_img_effect", "(", "rgb", ",", "samples_map", ",", "enlarge_samples", "=", "True", ")", "\n", "cmap", "=", "plt", ".", "cm", ".", "get_cmap", "(", "\"jet\"", ")", "# color map name. Red is higher, blue is lower", "\n", "\n", "if", "save_results", "==", "True", ":", "\n", "        ", "path", "=", "'../data_new/phase_'", "+", "str", "(", "phase", "+", "1", ")", "+", "'/'", "+", "rgb_path", ".", "split", "(", "'/'", ")", "[", "3", "]", "+", "'/prob_and_sampling_maps_results'", "+", "rgb_path", ".", "split", "(", "'data_rgb'", ")", "[", "1", "]", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "path", ")", ",", "exist_ok", "=", "True", ")", "\n", "samples_on_image", "=", "(", "255", "*", "samples_on_image", ")", ".", "astype", "(", "'uint8'", ")", "\n", "im", "=", "Image", ".", "fromarray", "(", "samples_on_image", ")", "\n", "im", ".", "save", "(", "path", ".", "split", "(", "'.png'", ")", "[", "0", "]", "+", "'_samples.png'", ")", "\n", "\n", "prob_gt_valid", "=", "(", "x_gt_valid", "-", "x_gt_valid", ".", "min", "(", ")", ")", "/", "(", "x_gt_valid", ".", "max", "(", ")", "-", "x_gt_valid", ".", "min", "(", ")", ")", "\n", "# depth_write(path.split('.png')[0] + '_prob_gt_valid.png', prob_gt_valid)  # real values (rather than visualization - in the next lines)", "\n", "colored_prob_valid_map", "=", "cmap", "(", "prob_gt_valid", ")", "# apply the colormap, will result 4-channel image (R,G,B,A) in float [0,1]", "\n", "im", "=", "Image", ".", "fromarray", "(", "(", "colored_prob_valid_map", "[", ":", ",", ":", ",", ":", "3", "]", "*", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "# convert to RGB in uint8", "\n", "im", ".", "save", "(", "path", ".", "split", "(", "'.png'", ")", "[", "0", "]", "+", "'_prob_gt_valid.png'", ")", "\n", "\n", "# np.save(path.split('.png')[0] + '_prob.npy', prob_map)  # real values (rather than visualization - in the next lines)", "\n", "prob_map", "=", "(", "prob_map", "-", "prob_map", ".", "min", "(", ")", ")", "/", "(", "prob_map", ".", "max", "(", ")", "-", "prob_map", ".", "min", "(", ")", ")", "\n", "# depth_write(path.split('.png')[0] + '_prob.png', prob_map)  # real values (rather than visualization - in the next lines)", "\n", "colored_prob_map", "=", "cmap", "(", "prob_map", ")", "# apply the colormap, will result 4-channel image (R,G,B,A) in float [0,1]", "\n", "im", "=", "Image", ".", "fromarray", "(", "(", "colored_prob_map", "[", ":", ",", ":", ",", ":", "3", "]", "*", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "# convert to RGB in uint8", "\n", "im", ".", "save", "(", "path", ".", "split", "(", "'.png'", ")", "[", "0", "]", "+", "'_prob.png'", ")", "\n", "\n", "", "if", "show_results", "==", "True", ":", "\n", "        ", "plt", ".", "close", "(", ")", "\n", "plt", ".", "figure", "(", "1", ")", "\n", "plt", ".", "imshow", "(", "samples_on_image", ")", "\n", "plt", ".", "figure", "(", "2", ")", "\n", "plt", ".", "imshow", "(", "prob_map", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.show_img_effect": [[522, 592], ["np.zeros.min", "np.zeros.max", "numpy.zeros", "numpy.roll", "numpy.roll", "numpy.roll", "numpy.roll", "numpy.dot", "numpy.zeros", "numpy.zeros", "np.zeros.min", "np.zeros.max", "numpy.zeros", "numpy.roll", "numpy.roll", "numpy.roll", "numpy.roll", "numpy.max", "matplotlib.cm.get_cmap", "numpy.min", "numpy.max", "numpy.min", "numpy.min", "numpy.max", "numpy.min", "plt.cm.get_cmap.", "numpy.min", "numpy.max", "numpy.min"], "function", ["None"], ["def", "show_img_effect", "(", "rgb", ",", "effect", ",", "enlarge_samples", "=", "False", ",", "gs", "=", "None", ",", "jet_mode", "=", "False", ",", "previous_effect", "=", "None", ")", ":", "\n", "# normalize to [0, 1]", "\n", "    ", "if", "effect", ".", "min", "(", ")", "==", "effect", ".", "max", "(", ")", ":", "# no effect at all", "\n", "        ", "effect", "=", "np", ".", "zeros", "(", "effect", ".", "shape", ")", "\n", "", "else", ":", "\n", "        ", "effect", "=", "(", "effect", "-", "np", ".", "min", "(", "effect", ")", ")", "/", "(", "np", ".", "max", "(", "effect", ")", "-", "np", ".", "min", "(", "effect", ")", ")", "\n", "\n", "", "if", "previous_effect", "is", "not", "None", ":", "\n", "        ", "if", "previous_effect", ".", "min", "(", ")", "==", "previous_effect", ".", "max", "(", ")", ":", "# no effect at all", "\n", "            ", "previous_effect", "=", "np", ".", "zeros", "(", "previous_effect", ".", "shape", ")", "\n", "", "else", ":", "\n", "            ", "previous_effect", "=", "(", "previous_effect", "-", "np", ".", "min", "(", "previous_effect", ")", ")", "/", "(", "np", ".", "max", "(", "previous_effect", ")", "-", "np", ".", "min", "(", "previous_effect", ")", ")", "\n", "\n", "# enlarge a pixel to a '+' sign (on top of the image) - to make it clearer to the viewer", "\n", "", "", "if", "enlarge_samples", "==", "True", ":", "\n", "        ", "if", "previous_effect", "is", "not", "None", ":", "\n", "            ", "effect", "=", "effect", "-", "previous_effect", "# only what's new", "\n", "add_to_right", "=", "np", ".", "roll", "(", "previous_effect", ",", "1", ",", "axis", "=", "1", ")", "# cyclic shift 1 column to the right", "\n", "add_to_right", "[", ":", ",", "0", "]", "=", "0", "# ignore leftmost col (due to cyclic)", "\n", "add_to_left", "=", "np", ".", "roll", "(", "previous_effect", ",", "-", "1", ",", "axis", "=", "1", ")", "# 1 column to the left", "\n", "add_to_left", "[", ":", ",", "-", "1", "]", "=", "0", "# ignore rightmost col", "\n", "\n", "add_to_up", "=", "np", ".", "roll", "(", "previous_effect", ",", "-", "1", ",", "axis", "=", "0", ")", "# 1 row up", "\n", "add_to_up", "[", "-", "1", ",", ":", "]", "=", "0", "# ignore lower row", "\n", "add_to_down", "=", "np", ".", "roll", "(", "previous_effect", ",", "1", ",", "axis", "=", "0", ")", "# 1 row down", "\n", "add_to_down", "[", "0", ",", ":", "]", "=", "0", "# ignore upper row", "\n", "\n", "previous_effect", "=", "previous_effect", "+", "add_to_right", "+", "add_to_left", "+", "add_to_up", "+", "add_to_down", "\n", "\n", "", "add_to_right", "=", "np", ".", "roll", "(", "effect", ",", "1", ",", "axis", "=", "1", ")", "# cyclic shift 1 column to the right", "\n", "add_to_right", "[", ":", ",", "0", "]", "=", "0", "# ignore leftmost col (due to cyclic)", "\n", "add_to_left", "=", "np", ".", "roll", "(", "effect", ",", "-", "1", ",", "axis", "=", "1", ")", "# 1 column to the left", "\n", "add_to_left", "[", ":", ",", "-", "1", "]", "=", "0", "# ignore rightmost col", "\n", "\n", "add_to_up", "=", "np", ".", "roll", "(", "effect", ",", "-", "1", ",", "axis", "=", "0", ")", "# 1 row up", "\n", "add_to_up", "[", "-", "1", ",", ":", "]", "=", "0", "# ignore lower row", "\n", "add_to_down", "=", "np", ".", "roll", "(", "effect", ",", "1", ",", "axis", "=", "0", ")", "# 1 row down", "\n", "add_to_down", "[", "0", ",", ":", "]", "=", "0", "# ignore upper row", "\n", "\n", "effect", "=", "effect", "+", "add_to_right", "+", "add_to_left", "+", "add_to_up", "+", "add_to_down", "\n", "\n", "", "if", "gs", "is", "None", ":", "# rgb image", "\n", "        ", "assert", "(", "rgb", ".", "shape", "[", "0", ":", "2", "]", "==", "effect", ".", "shape", ")", "\n", "if", "np", ".", "max", "(", "rgb", ")", ">", "1.", ":", "\n", "            ", "rgb", "=", "rgb", "/", "255.", "# to [0, 1]", "\n", "\n", "", "gs", "=", "np", ".", "dot", "(", "rgb", ",", "[", "0.299", ",", "0.587", ",", "0.114", "]", ")", "# the ratios between channels. need to sum up to 1 in order to get a true gray scale", "\n", "img", "=", "np", ".", "zeros", "(", "rgb", ".", "shape", ")", "\n", "", "else", ":", "# gray scale image", "\n", "        ", "img", "=", "np", ".", "zeros", "(", "(", "gs", ".", "shape", "[", "0", "]", ",", "gs", ".", "shape", "[", "1", "]", ",", "3", ")", ")", "\n", "gs", "=", "(", "gs", "-", "np", ".", "min", "(", "gs", ")", ")", "/", "(", "np", ".", "max", "(", "gs", ")", "-", "np", ".", "min", "(", "gs", ")", ")", "# to [0, 1]", "\n", "\n", "if", "jet_mode", "==", "True", ":", "# only possible in with gs", "\n", "            ", "cmap", "=", "plt", ".", "cm", ".", "get_cmap", "(", "\"jet\"", ")", "\n", "colored_gs", "=", "cmap", "(", "gs", ")", "[", ":", ",", ":", ",", ":", "3", "]", "# apply the colormap + take only RGB in float [0,1]", "\n", "if", "previous_effect", "is", "not", "None", ":", "\n", "                ", "(", "colored_gs", "[", ":", ",", ":", ",", "0", "]", ")", "[", "previous_effect", ">", "0", "]", "=", "0.45", "# the old sample points will be gray-ish. this won't show value, but a binary - there is a data, or not", "\n", "(", "colored_gs", "[", ":", ",", ":", ",", "1", "]", ")", "[", "previous_effect", ">", "0", "]", "=", "0.45", "\n", "(", "colored_gs", "[", ":", ",", ":", ",", "2", "]", ")", "[", "previous_effect", ">", "0", "]", "=", "0.45", "\n", "\n", "", "(", "colored_gs", "[", ":", ",", ":", ",", "0", "]", ")", "[", "effect", ">", "0", "]", "=", "1", "# the new sample points will be white. this won't show value, but a binary - there is a data, or not", "\n", "(", "colored_gs", "[", ":", ",", ":", ",", "1", "]", ")", "[", "effect", ">", "0", "]", "=", "1", "\n", "(", "colored_gs", "[", ":", ",", ":", ",", "2", "]", ")", "[", "effect", ">", "0", "]", "=", "1", "\n", "\n", "\n", "return", "colored_gs", "\n", "\n", "", "", "img", "[", ":", ",", ":", ",", "0", "]", "=", "effect", "\n", "img", "[", ":", ",", ":", ",", "1", "]", "=", "gs", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.read_weights": [[597, 624], ["weights.append", "range", "print", "open", "f.read().splitlines", "len", "len", "NN_in_stage.append", "weights.append", "len", "len", "len", "len", "len", "len", "f.read", "len"], "function", ["None"], ["def", "read_weights", "(", "file_path", ",", "phases", ",", "predictors", ")", ":", "\n", "    ", "if", "file_path", "==", "\"\"", ":", "# we are not inferencing", "\n", "        ", "return", "[", "]", "\n", "\n", "", "weights", "=", "[", "]", "\n", "NN_in_stage", "=", "[", "]", "\n", "\n", "with", "open", "(", "file_path", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "read", "(", ")", ".", "splitlines", "(", ")", "\n", "\n", "", "for", "line", "in", "lines", ":", "\n", "        ", "if", "line", "!=", "\"\"", ":", "# as long as we don't encounter empty line (means a new stage)", "\n", "            ", "NN_in_stage", ".", "append", "(", "line", ")", "\n", "", "else", ":", "\n", "            ", "weights", ".", "append", "(", "NN_in_stage", ")", "\n", "NN_in_stage", "=", "[", "]", "\n", "\n", "", "", "weights", ".", "append", "(", "NN_in_stage", ")", "# final net", "\n", "\n", "for", "phase", "in", "range", "(", "len", "(", "weights", ")", "-", "2", ")", ":", "\n", "        ", "assert", "len", "(", "weights", "[", "phase", "]", ")", "==", "len", "(", "weights", "[", "phase", "+", "1", "]", ")", ",", "\"read_weights: number of weights isn't match between phases\"", "\n", "", "assert", "len", "(", "weights", "[", "-", "1", "]", ")", "==", "1", ",", "\"read_weights: there should be 1 final net weights\"", "\n", "assert", "phases", "==", "len", "(", "weights", ")", "-", "1", ",", "\"read_weights: given argument K isn't match to the number of given phases in .txt\"", "\n", "assert", "len", "(", "weights", "[", "0", "]", ")", "==", "predictors", ",", "\"read_weights: given argument M isn't match to the number of given weights inside each phase in .txt\"", "\n", "\n", "print", "(", "\"Detects {} weights in each phase, total {} phases, in addition to {} final net weights\\n\"", ".", "format", "(", "len", "(", "weights", "[", "0", "]", ")", ",", "len", "(", "weights", ")", "-", "1", ",", "len", "(", "weights", "[", "-", "1", "]", ")", ")", ")", "\n", "return", "weights", "", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.metrics.Result.__init__": [[14, 30], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "irmse", "=", "0", "\n", "self", ".", "imae", "=", "0", "\n", "self", ".", "mse", "=", "0", "\n", "self", ".", "rmse", "=", "0", "\n", "self", ".", "mae", "=", "0", "\n", "self", ".", "absrel", "=", "0", "\n", "self", ".", "squared_rel", "=", "0", "\n", "self", ".", "lg10", "=", "0", "\n", "self", ".", "delta1", "=", "0", "\n", "self", ".", "delta2", "=", "0", "\n", "self", ".", "delta3", "=", "0", "\n", "self", ".", "data_time", "=", "0", "\n", "self", ".", "gpu_time", "=", "0", "\n", "self", ".", "silog", "=", "0", "# Scale invariant logarithmic error [log(m)*100]", "\n", "self", ".", "photometric", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.metrics.Result.set_to_worst": [[31, 46], ["None"], "methods", ["None"], ["", "def", "set_to_worst", "(", "self", ")", ":", "\n", "        ", "self", ".", "irmse", "=", "np", ".", "inf", "\n", "self", ".", "imae", "=", "np", ".", "inf", "\n", "self", ".", "mse", "=", "np", ".", "inf", "\n", "self", ".", "rmse", "=", "np", ".", "inf", "\n", "self", ".", "mae", "=", "np", ".", "inf", "\n", "self", ".", "absrel", "=", "np", ".", "inf", "\n", "self", ".", "squared_rel", "=", "np", ".", "inf", "\n", "self", ".", "lg10", "=", "np", ".", "inf", "\n", "self", ".", "silog", "=", "np", ".", "inf", "\n", "self", ".", "delta1", "=", "0", "\n", "self", ".", "delta2", "=", "0", "\n", "self", ".", "delta3", "=", "0", "\n", "self", ".", "data_time", "=", "0", "\n", "self", ".", "gpu_time", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.metrics.Result.update": [[47, 64], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "irmse", ",", "imae", ",", "mse", ",", "rmse", ",", "mae", ",", "absrel", ",", "squared_rel", ",", "lg10", ",", "delta1", ",", "delta2", ",", "delta3", ",", "gpu_time", ",", "data_time", ",", "silog", ",", "photometric", "=", "0", ")", ":", "\n", "        ", "self", ".", "irmse", "=", "irmse", "\n", "self", ".", "imae", "=", "imae", "\n", "self", ".", "mse", "=", "mse", "\n", "self", ".", "rmse", "=", "rmse", "\n", "self", ".", "mae", "=", "mae", "\n", "self", ".", "absrel", "=", "absrel", "\n", "self", ".", "squared_rel", "=", "squared_rel", "\n", "self", ".", "lg10", "=", "lg10", "\n", "self", ".", "delta1", "=", "delta1", "\n", "self", ".", "delta2", "=", "delta2", "\n", "self", ".", "delta3", "=", "delta3", "\n", "self", ".", "data_time", "=", "data_time", "\n", "self", ".", "gpu_time", "=", "gpu_time", "\n", "self", ".", "silog", "=", "silog", "\n", "self", ".", "photometric", "=", "photometric", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.metrics.Result.evaluate": [[66, 104], ["float", "math.sqrt", "float", "float", "float", "float", "torch.max", "float", "float", "float", "err_log.mean", "math.sqrt", "float", "float", "torch.pow().mean", "abs_diff.mean", "torch.log", "torch.log", "math.sqrt", "torch.pow().mean", "abs_inv_diff.mean", "torch.pow", "torch.pow", "metrics.log10", "metrics.log10"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.log10", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.log10"], ["", "def", "evaluate", "(", "self", ",", "output", ",", "target", ",", "photometric", "=", "0", ")", ":", "\n", "        ", "valid_mask", "=", "target", ">", "0.1", "\n", "\n", "# convert from meters to mm", "\n", "output_mm", "=", "1e3", "*", "output", "[", "valid_mask", "]", "\n", "target_mm", "=", "1e3", "*", "target", "[", "valid_mask", "]", "\n", "\n", "abs_diff", "=", "(", "output_mm", "-", "target_mm", ")", ".", "abs", "(", ")", "\n", "\n", "self", ".", "mse", "=", "float", "(", "(", "torch", ".", "pow", "(", "abs_diff", ",", "2", ")", ")", ".", "mean", "(", ")", ")", "# mse for the entire batch", "\n", "self", ".", "rmse", "=", "math", ".", "sqrt", "(", "self", ".", "mse", ")", "\n", "self", ".", "mae", "=", "float", "(", "abs_diff", ".", "mean", "(", ")", ")", "\n", "self", ".", "lg10", "=", "float", "(", "(", "log10", "(", "output_mm", ")", "-", "log10", "(", "target_mm", ")", ")", ".", "abs", "(", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "absrel", "=", "float", "(", "(", "abs_diff", "/", "target_mm", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "squared_rel", "=", "float", "(", "(", "(", "abs_diff", "/", "target_mm", ")", "**", "2", ")", ".", "mean", "(", ")", ")", "\n", "\n", "maxRatio", "=", "torch", ".", "max", "(", "output_mm", "/", "target_mm", ",", "target_mm", "/", "output_mm", ")", "\n", "self", ".", "delta1", "=", "float", "(", "(", "maxRatio", "<", "1.25", ")", ".", "float", "(", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "delta2", "=", "float", "(", "(", "maxRatio", "<", "1.25", "**", "2", ")", ".", "float", "(", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "delta3", "=", "float", "(", "(", "maxRatio", "<", "1.25", "**", "3", ")", ".", "float", "(", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "data_time", "=", "0", "\n", "self", ".", "gpu_time", "=", "0", "\n", "\n", "# silog uses meters", "\n", "err_log", "=", "torch", ".", "log", "(", "target", "[", "valid_mask", "]", ")", "-", "torch", ".", "log", "(", "output", "[", "valid_mask", "]", ")", "\n", "normalized_squared_log", "=", "(", "err_log", "**", "2", ")", ".", "mean", "(", ")", "\n", "log_mean", "=", "err_log", ".", "mean", "(", ")", "\n", "self", ".", "silog", "=", "math", ".", "sqrt", "(", "normalized_squared_log", "-", "\n", "log_mean", "*", "log_mean", ")", "*", "100", "\n", "\n", "# convert from meters to km", "\n", "inv_output_km", "=", "(", "1e-3", "*", "output", "[", "valid_mask", "]", ")", "**", "(", "-", "1", ")", "\n", "inv_target_km", "=", "(", "1e-3", "*", "target", "[", "valid_mask", "]", ")", "**", "(", "-", "1", ")", "\n", "abs_inv_diff", "=", "(", "inv_output_km", "-", "inv_target_km", ")", ".", "abs", "(", ")", "\n", "self", ".", "irmse", "=", "math", ".", "sqrt", "(", "(", "torch", ".", "pow", "(", "abs_inv_diff", ",", "2", ")", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "imae", "=", "float", "(", "abs_inv_diff", ".", "mean", "(", ")", ")", "\n", "\n", "self", ".", "photometric", "=", "float", "(", "photometric", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.metrics.AverageMeter.__init__": [[107, 109], ["metrics.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.reset"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.metrics.AverageMeter.reset": [[110, 127], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "count", "=", "0.0", "\n", "self", ".", "sum_irmse", "=", "0", "\n", "self", ".", "sum_imae", "=", "0", "\n", "self", ".", "sum_mse", "=", "0", "\n", "self", ".", "sum_rmse", "=", "0", "\n", "self", ".", "sum_mae", "=", "0", "\n", "self", ".", "sum_absrel", "=", "0", "\n", "self", ".", "sum_squared_rel", "=", "0", "\n", "self", ".", "sum_lg10", "=", "0", "\n", "self", ".", "sum_delta1", "=", "0", "\n", "self", ".", "sum_delta2", "=", "0", "\n", "self", ".", "sum_delta3", "=", "0", "\n", "self", ".", "sum_data_time", "=", "0", "\n", "self", ".", "sum_gpu_time", "=", "0", "\n", "self", ".", "sum_photometric", "=", "0", "\n", "self", ".", "sum_silog", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.metrics.AverageMeter.update": [[128, 145], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "result", ",", "gpu_time", ",", "data_time", ",", "n", "=", "1", ")", ":", "\n", "        ", "self", ".", "count", "+=", "n", "\n", "self", ".", "sum_irmse", "+=", "n", "*", "result", ".", "irmse", "\n", "self", ".", "sum_imae", "+=", "n", "*", "result", ".", "imae", "\n", "self", ".", "sum_mse", "+=", "n", "*", "result", ".", "mse", "\n", "self", ".", "sum_rmse", "+=", "n", "*", "result", ".", "rmse", "\n", "self", ".", "sum_mae", "+=", "n", "*", "result", ".", "mae", "\n", "self", ".", "sum_absrel", "+=", "n", "*", "result", ".", "absrel", "\n", "self", ".", "sum_squared_rel", "+=", "n", "*", "result", ".", "squared_rel", "\n", "self", ".", "sum_lg10", "+=", "n", "*", "result", ".", "lg10", "\n", "self", ".", "sum_delta1", "+=", "n", "*", "result", ".", "delta1", "\n", "self", ".", "sum_delta2", "+=", "n", "*", "result", ".", "delta2", "\n", "self", ".", "sum_delta3", "+=", "n", "*", "result", ".", "delta3", "\n", "self", ".", "sum_data_time", "+=", "n", "*", "data_time", "\n", "self", ".", "sum_gpu_time", "+=", "n", "*", "gpu_time", "\n", "self", ".", "sum_silog", "+=", "n", "*", "result", ".", "silog", "\n", "self", ".", "sum_photometric", "+=", "n", "*", "result", ".", "photometric", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.metrics.AverageMeter.average": [[146, 159], ["metrics.Result", "metrics.Result.update"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.update"], ["", "def", "average", "(", "self", ")", ":", "\n", "        ", "avg", "=", "Result", "(", ")", "\n", "if", "self", ".", "count", ">", "0", ":", "\n", "            ", "avg", ".", "update", "(", "\n", "self", ".", "sum_irmse", "/", "self", ".", "count", ",", "self", ".", "sum_imae", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_mse", "/", "self", ".", "count", ",", "self", ".", "sum_rmse", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_mae", "/", "self", ".", "count", ",", "self", ".", "sum_absrel", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_squared_rel", "/", "self", ".", "count", ",", "self", ".", "sum_lg10", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_delta1", "/", "self", ".", "count", ",", "self", ".", "sum_delta2", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_delta3", "/", "self", ".", "count", ",", "self", ".", "sum_gpu_time", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_data_time", "/", "self", ".", "count", ",", "self", ".", "sum_silog", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_photometric", "/", "self", ".", "count", ")", "\n", "", "return", "avg", "\n", "", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.metrics.log10": [[8, 11], ["torch.log"], "function", ["None"], ["def", "log10", "(", "x", ")", ":", "\n", "    ", "\"\"\"Convert a new tensor with the base-10 logarithm of the elements of x. \"\"\"", "\n", "return", "torch", ".", "log", "(", "x", ")", "/", "lg_e_10", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.black_box_main.iterate": [[88, 188], ["metrics.AverageMeter", "metrics.AverageMeter", "enumerate", "logger.conditional_save_info", "logger.rank_conditional_save_best", "logger.conditional_summarize", "model.train", "helper.adjust_learning_rate", "model.eval", "time.time", "time.time", "model", "logger.save_img_comparison_as_best", "val.to", "time.time", "optimizer.zero_grad", "loss.backward", "optimizer.step", "time.time", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "next().size", "metrics.Result", "logger.conditional_print", "logger.conditional_save_img_comparison", "logger.conditional_save_pred", "batch_data.items", "depth_criterion", "helper.multiscale", "helper.multiscale", "helper.multiscale", "len", "range", "smoothness_criterion", "metrics.Result.evaluate", "m.update", "len", "depth_criterion", "helper.multiscale", "len", "kitti_intrinsics.scale", "inverse_warp.homography_from", "next", "pred_.size", "pred_.size", "photometric_criterion", "iter", "batch_data.values"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_save_info", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.rank_conditional_save_best", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_summarize", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.adjust_learning_rate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_img_comparison_as_best", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_print", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_save_img_comparison", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_save_pred", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.multiscale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.multiscale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.multiscale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.Result.evaluate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.update", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.multiscale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.scale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.homography_from"], ["", "", "def", "iterate", "(", "mode", ",", "args", ",", "loader", ",", "model", ",", "optimizer", ",", "logger", ",", "epoch", ")", ":", "\n", "    ", "block_average_meter", "=", "AverageMeter", "(", ")", "\n", "average_meter", "=", "AverageMeter", "(", ")", "\n", "meters", "=", "[", "block_average_meter", ",", "average_meter", "]", "\n", "\n", "# switch to appropriate mode", "\n", "assert", "mode", "in", "[", "\"train\"", ",", "\"val\"", ",", "\"eval\"", ",", "\"test_prediction\"", ",", "\"test_completion\"", "]", ",", "\"unsupported mode: {}\"", ".", "format", "(", "mode", ")", "\n", "if", "mode", "==", "'train'", ":", "\n", "        ", "model", ".", "train", "(", ")", "\n", "lr", "=", "helper", ".", "adjust_learning_rate", "(", "args", ".", "lr", ",", "optimizer", ",", "epoch", ")", "\n", "", "else", ":", "\n", "        ", "model", ".", "eval", "(", ")", "# batchnorm or dropout layers will work in eval mode instead of training mode", "\n", "lr", "=", "0", "\n", "\n", "", "for", "i", ",", "batch_data", "in", "enumerate", "(", "loader", ")", ":", "# batch_data keys: 'd' (depth), 'gt' (ground truth), 'g' (gray)", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "batch_data", "=", "{", "\n", "key", ":", "val", ".", "to", "(", "device", ")", "\n", "for", "key", ",", "val", "in", "batch_data", ".", "items", "(", ")", "if", "val", "is", "not", "None", "\n", "}", "\n", "\n", "gt", "=", "batch_data", "[", "'gt'", "]", "if", "mode", "!=", "'test_prediction'", "and", "mode", "!=", "'test_completion'", "else", "None", "\n", "data_time", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "pred", "=", "model", "(", "batch_data", ")", "\n", "\n", "depth_loss", ",", "photometric_loss", ",", "smooth_loss", ",", "mask", "=", "0", ",", "0", ",", "0", ",", "None", "\n", "if", "mode", "==", "'train'", ":", "\n", "# Loss 1: the direct depth supervision from ground truth label", "\n", "# mask=1 indicates that a pixel does not ground truth labels", "\n", "            ", "if", "'sparse'", "in", "args", ".", "train_mode", ":", "\n", "                ", "depth_loss", "=", "depth_criterion", "(", "pred", ",", "batch_data", "[", "'d'", "]", ")", "\n", "mask", "=", "(", "batch_data", "[", "'d'", "]", "<", "1e-3", ")", ".", "float", "(", ")", "\n", "", "elif", "'dense'", "in", "args", ".", "train_mode", ":", "\n", "                ", "depth_loss", "=", "depth_criterion", "(", "pred", ",", "gt", ")", "\n", "mask", "=", "(", "gt", "<", "1e-3", ")", ".", "float", "(", ")", "\n", "\n", "# Loss 2: the self-supervised photometric loss", "\n", "", "if", "args", ".", "use_pose", ":", "\n", "# create multi-scale pyramids", "\n", "                ", "pred_array", "=", "helper", ".", "multiscale", "(", "pred", ")", "\n", "rgb_curr_array", "=", "helper", ".", "multiscale", "(", "batch_data", "[", "'rgb'", "]", ")", "\n", "rgb_near_array", "=", "helper", ".", "multiscale", "(", "batch_data", "[", "'rgb_near'", "]", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "                    ", "mask_array", "=", "helper", ".", "multiscale", "(", "mask", ")", "\n", "", "num_scales", "=", "len", "(", "pred_array", ")", "\n", "\n", "# compute photometric loss at multiple scales", "\n", "for", "scale", "in", "range", "(", "len", "(", "pred_array", ")", ")", ":", "\n", "                    ", "pred_", "=", "pred_array", "[", "scale", "]", "\n", "rgb_curr_", "=", "rgb_curr_array", "[", "scale", "]", "\n", "rgb_near_", "=", "rgb_near_array", "[", "scale", "]", "\n", "mask_", "=", "None", "\n", "if", "mask", "is", "not", "None", ":", "\n", "                        ", "mask_", "=", "mask_array", "[", "scale", "]", "\n", "\n", "# compute the corresponding intrinsic parameters", "\n", "", "height_", ",", "width_", "=", "pred_", ".", "size", "(", "2", ")", ",", "pred_", ".", "size", "(", "3", ")", "\n", "intrinsics_", "=", "kitti_intrinsics", ".", "scale", "(", "height_", ",", "width_", ")", "\n", "\n", "# inverse warp from a nearby frame to the current frame", "\n", "warped_", "=", "homography_from", "(", "rgb_near_", ",", "pred_", ",", "batch_data", "[", "'r_mat'", "]", ",", "batch_data", "[", "'t_vec'", "]", ",", "intrinsics_", ")", "\n", "photometric_loss", "+=", "photometric_criterion", "(", "rgb_curr_", ",", "warped_", ",", "mask_", ")", "*", "(", "2", "**", "(", "scale", "-", "num_scales", ")", ")", "\n", "\n", "# Loss 3: the depth smoothness loss", "\n", "", "", "smooth_loss", "=", "smoothness_criterion", "(", "pred", ")", "if", "args", ".", "w2", ">", "0", "else", "0", "\n", "\n", "# backprop", "\n", "loss", "=", "depth_loss", "+", "args", ".", "w1", "*", "photometric_loss", "+", "args", ".", "w2", "*", "smooth_loss", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "gpu_time", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "# measure accuracy and record loss", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "# impacts the autograd engine and deactivate it (will reduce memory usage and speed up computations)", "\n", "            ", "mini_batch_size", "=", "next", "(", "iter", "(", "batch_data", ".", "values", "(", ")", ")", ")", ".", "size", "(", "0", ")", "\n", "result", "=", "Result", "(", ")", "\n", "if", "mode", "!=", "'test_prediction'", "and", "mode", "!=", "'test_completion'", ":", "\n", "                ", "result", ".", "evaluate", "(", "pred", ".", "data", ",", "gt", ".", "data", ",", "photometric_loss", ")", "\n", "", "[", "\n", "m", ".", "update", "(", "result", ",", "gpu_time", ",", "data_time", ",", "mini_batch_size", ")", "\n", "for", "m", "in", "meters", "\n", "]", "\n", "logger", ".", "conditional_print", "(", "mode", ",", "i", ",", "epoch", ",", "args", ".", "epochs", ",", "lr", ",", "len", "(", "loader", ")", ",", "block_average_meter", ",", "average_meter", ")", "\n", "logger", ".", "conditional_save_img_comparison", "(", "mode", ",", "i", ",", "batch_data", ",", "pred", ",", "epoch", ")", "\n", "logger", ".", "conditional_save_pred", "(", "mode", ",", "i", ",", "pred", ",", "epoch", ")", "\n", "\n", "", "del", "pred", "# allows increasing batch size", "\n", "\n", "", "avg", "=", "logger", ".", "conditional_save_info", "(", "mode", ",", "average_meter", ",", "epoch", ")", "\n", "is_best", "=", "logger", ".", "rank_conditional_save_best", "(", "mode", ",", "avg", ",", "epoch", ",", "args", ".", "epochs", ")", "\n", "if", "is_best", "and", "not", "(", "mode", "==", "\"train\"", ")", ":", "\n", "        ", "logger", ".", "save_img_comparison_as_best", "(", "mode", ",", "epoch", ")", "\n", "", "logger", ".", "conditional_summarize", "(", "mode", ",", "avg", ",", "is_best", ")", "\n", "\n", "return", "avg", ",", "is_best", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.black_box_main.main": [[190, 273], ["print", "model.DepthCompletionNet().to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "print", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "print", "dataloaders.kitti_loader.KittiDepth", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "helper.logger", "print", "print", "range", "os.path.join", "os.remove", "os.path.isfile", "torch.nn.DataParallel.load_state_dict", "torch.optim.Adam.load_state_dict", "print", "dataloaders.kitti_loader.KittiDepth", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "print", "black_box_main.iterate", "print", "black_box_main.iterate", "black_box_main.iterate", "helper.save_checkpoint", "print", "torch.load", "torch.load", "torch.load", "torch.load", "print", "print", "os.path.isfile", "model.DepthCompletionNet", "torch.nn.DataParallel.named_parameters", "torch.nn.DataParallel.__dict__.items", "len", "print", "torch.load", "torch.load", "torch.load", "torch.load", "print", "print", "len", "torch.nn.DataParallel.module.state_dict", "torch.optim.Adam.state_dict", "str"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.main_test.iterate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.main_test.iterate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.main_test.iterate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.save_checkpoint"], ["", "def", "main", "(", ")", ":", "\n", "    ", "global", "args", "\n", "checkpoint", "=", "None", "\n", "is_eval", "=", "False", "\n", "if", "args", ".", "evaluate", ":", "# test a finished model", "\n", "        ", "args_new", "=", "args", "# copies", "\n", "if", "os", ".", "path", ".", "isfile", "(", "args", ".", "evaluate", ")", ":", "# path is an existing regular file", "\n", "            ", "print", "(", "\"=> loading finished model from '{}' ... \"", ".", "format", "(", "args", ".", "evaluate", ")", ",", "end", "=", "''", ")", "# \"end=''\" disables the newline", "\n", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "evaluate", ",", "map_location", "=", "device", ")", "\n", "args", "=", "checkpoint", "[", "'args'", "]", "\n", "args", ".", "data_folder", "=", "args_new", ".", "data_folder", "\n", "args", ".", "val", "=", "args_new", ".", "val", "\n", "is_eval", "=", "True", "\n", "print", "(", "\"Completed.\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"No model found at '{}'\"", ".", "format", "(", "args", ".", "evaluate", ")", ")", "\n", "return", "\n", "", "", "elif", "args", ".", "resume", ":", "# resume from a checkpoint", "\n", "        ", "args_new", "=", "args", "\n", "if", "os", ".", "path", ".", "isfile", "(", "args", ".", "resume", ")", ":", "\n", "            ", "print", "(", "\"=> loading checkpoint from '{}' ... \"", ".", "format", "(", "args", ".", "resume", ")", ",", "end", "=", "''", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "resume", ",", "map_location", "=", "device", ")", "\n", "args", ".", "start_epoch", "=", "checkpoint", "[", "'epoch'", "]", "+", "1", "\n", "args", ".", "data_folder", "=", "args_new", ".", "data_folder", "\n", "args", ".", "val", "=", "args_new", ".", "val", "\n", "print", "(", "\"Completed. Resuming from epoch {}.\"", ".", "format", "(", "checkpoint", "[", "'epoch'", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"No checkpoint found at '{}'\"", ".", "format", "(", "args", ".", "resume", ")", ")", "\n", "return", "\n", "\n", "", "", "print", "(", "\"=> creating model and optimizer ... \"", ",", "end", "=", "''", ")", "\n", "model", "=", "DepthCompletionNet", "(", "args", ")", ".", "to", "(", "device", ")", "\n", "model_named_params", "=", "[", "p", "\n", "for", "_", ",", "p", "in", "model", ".", "named_parameters", "(", ")", "# \"_, p\" is a direct analogy to an assignment statement k, _ = (0, 1). Unpack a tuple object", "\n", "if", "p", ".", "requires_grad", "]", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model_named_params", ",", "lr", "=", "args", ".", "lr", ",", "weight_decay", "=", "args", ".", "weight_decay", ")", "\n", "print", "(", "\"completed.\"", ")", "\n", "[", "f'{k:<20}: {v}'", "for", "k", ",", "v", "in", "model", ".", "__dict__", ".", "items", "(", ")", "]", "\n", "\n", "if", "checkpoint", "is", "not", "None", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'model'", "]", ")", "\n", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer'", "]", ")", "\n", "print", "(", "\"=> checkpoint state loaded.\"", ")", "\n", "\n", "", "model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "model", ")", "# make the model run parallelly: splits your data automatically and sends job orders to multiple models on several GPUs.", "\n", "# After each model finishes their job, DataParallel collects and merges the results before returning it to you", "\n", "\n", "# data loading code", "\n", "print", "(", "\"=> creating data loaders ... \"", ")", "\n", "if", "not", "is_eval", ":", "# we're not evaluating", "\n", "        ", "train_dataset", "=", "KittiDepth", "(", "'train'", ",", "args", ")", "# get the paths for the files", "\n", "train_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "train_dataset", ",", "batch_size", "=", "args", ".", "batch_size", ",", "shuffle", "=", "True", ",", "num_workers", "=", "args", ".", "workers", ",", "pin_memory", "=", "True", ",", "sampler", "=", "None", ")", "# load them", "\n", "print", "(", "\"\\t==> train_loader size: {} batches, each of {} images\"", ".", "format", "(", "len", "(", "train_loader", ")", ",", "train_loader", ".", "batch_size", ")", ")", "\n", "", "val_dataset", "=", "KittiDepth", "(", "'val'", ",", "args", ")", "\n", "val_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "val_dataset", ",", "batch_size", "=", "args", ".", "batch_size", ",", "shuffle", "=", "False", ",", "num_workers", "=", "args", ".", "workers", ",", "pin_memory", "=", "True", ")", "# set batch size to be 1 for validation", "\n", "print", "(", "\"\\t==> val_loader size: {} batches, each of {} images\"", ".", "format", "(", "len", "(", "val_loader", ")", ",", "val_loader", ".", "batch_size", ")", ")", "\n", "\n", "# create backups and results folder", "\n", "logger", "=", "helper", ".", "logger", "(", "args", ")", "\n", "if", "checkpoint", "is", "not", "None", ":", "\n", "        ", "logger", ".", "best_result", "=", "checkpoint", "[", "'best_result'", "]", "\n", "", "print", "(", "\"=> logger created.\"", ")", "# logger records sequential data to a log file", "\n", "\n", "# main code - run the NN", "\n", "if", "is_eval", ":", "\n", "        ", "print", "(", "\"=> starting model evaluation ...\"", ")", "\n", "result", ",", "is_best", "=", "iterate", "(", "\"val\"", ",", "args", ",", "val_loader", ",", "model", ",", "None", ",", "logger", ",", "checkpoint", "[", "'epoch'", "]", ")", "\n", "return", "\n", "\n", "", "print", "(", "\"=> starting model training ...\"", ")", "\n", "for", "epoch", "in", "range", "(", "args", ".", "start_epoch", ",", "args", ".", "epochs", ")", ":", "\n", "        ", "print", "(", "\"=> start training epoch {}\"", ".", "format", "(", "epoch", "+", "1", ")", "+", "\"/{}..\"", ".", "format", "(", "args", ".", "epochs", ")", ")", "\n", "iterate", "(", "\"train\"", ",", "args", ",", "train_loader", ",", "model", ",", "optimizer", ",", "logger", ",", "epoch", ")", "# train for one epoch", "\n", "result", ",", "is_best", "=", "iterate", "(", "\"val\"", ",", "args", ",", "val_loader", ",", "model", ",", "None", ",", "logger", ",", "epoch", ")", "# evaluate on validation set", "\n", "helper", ".", "save_checkpoint", "(", "{", "# save checkpoint", "\n", "'epoch'", ":", "epoch", ",", "\n", "'model'", ":", "model", ".", "module", ".", "state_dict", "(", ")", ",", "\n", "'best_result'", ":", "logger", ".", "best_result", ",", "\n", "'optimizer'", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'args'", ":", "args", ",", "\n", "}", ",", "is_best", ",", "epoch", ",", "logger", ".", "output_directory", ")", "\n", "", "last_checkpoint", "=", "os", ".", "path", ".", "join", "(", "logger", ".", "output_directory", ",", "'checkpoint-'", "+", "str", "(", "epoch", ")", "+", "'.pth.tar'", ")", "# delete last checkpoint because we have the best_model and we dont need it", "\n", "os", ".", "remove", "(", "last_checkpoint", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.__init__": [[16, 45], ["helper.get_folder_name", "metrics.Result", "helper.logger.best_result.set_to_worst", "os.path.join", "os.path.join", "os.path.join", "os.path.exists", "os.makedirs", "print", "os.path.join", "helper.backup_source_code", "print", "open", "csv.DictWriter", "csv.DictWriter.writeheader", "open", "csv.DictWriter", "csv.DictWriter.writeheader"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.get_folder_name", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.Result.set_to_worst", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.backup_source_code"], ["    ", "def", "__init__", "(", "self", ",", "args", ",", "prepare", "=", "True", ")", ":", "\n", "        ", "self", ".", "args", "=", "args", "\n", "output_directory", "=", "get_folder_name", "(", "args", ")", "\n", "self", ".", "output_directory", "=", "output_directory", "\n", "self", ".", "best_result", "=", "Result", "(", ")", "\n", "self", ".", "best_result", ".", "set_to_worst", "(", ")", "\n", "\n", "if", "not", "prepare", ":", "\n", "            ", "return", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "output_directory", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "output_directory", ")", "\n", "", "self", ".", "train_csv", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "'train.csv'", ")", "\n", "self", ".", "val_csv", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "'val.csv'", ")", "\n", "self", ".", "best_txt", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "'best.txt'", ")", "\n", "\n", "# backup the source code", "\n", "if", "args", ".", "resume", "==", "''", ":", "\n", "            ", "print", "(", "\"=> creating source code backup ...\"", ")", "\n", "backup_directory", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "\"code_backup\"", ")", "\n", "self", ".", "backup_directory", "=", "backup_directory", "\n", "backup_source_code", "(", "backup_directory", ")", "\n", "# create new csv files with only header", "\n", "with", "open", "(", "self", ".", "train_csv", ",", "'w'", ")", "as", "csvfile", ":", "\n", "                ", "writer", "=", "csv", ".", "DictWriter", "(", "csvfile", ",", "fieldnames", "=", "fieldnames", ")", "\n", "writer", ".", "writeheader", "(", ")", "\n", "", "with", "open", "(", "self", ".", "val_csv", ",", "'w'", ")", "as", "csvfile", ":", "\n", "                ", "writer", "=", "csv", ".", "DictWriter", "(", "csvfile", ",", "fieldnames", "=", "fieldnames", ")", "\n", "writer", ".", "writeheader", "(", ")", "\n", "", "print", "(", "\"=> finished creating source code backup.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.conditional_print": [[46, 76], ["avg_meter.average", "blk_avg_meter.average", "print", "print", "blk_avg_meter.reset", "split.capitalize"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.average", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.average", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.reset"], ["", "", "def", "conditional_print", "(", "self", ",", "split", ",", "i", ",", "epoch", ",", "total_epochs", ",", "lr", ",", "n_set", ",", "blk_avg_meter", ",", "\n", "avg_meter", ")", ":", "\n", "        ", "if", "(", "i", "+", "1", ")", "%", "self", ".", "args", ".", "print_freq", "==", "0", ":", "\n", "            ", "avg", "=", "avg_meter", ".", "average", "(", ")", "\n", "blk_avg", "=", "blk_avg_meter", ".", "average", "(", ")", "\n", "print", "(", "'=> output: {}'", ".", "format", "(", "self", ".", "output_directory", ")", ")", "\n", "print", "(", "\n", "'{split} Epoch: {}/{} [Batch {}/{}]\\tlr={lr} '", "\n", "'t_Data={blk_avg.data_time:.3f}({average.data_time:.3f}) '", "\n", "'t_GPU={blk_avg.gpu_time:.3f}({average.gpu_time:.3f})\\n\\t'", "\n", "'RMSE={blk_avg.rmse:.2f}({average.rmse:.2f}) '", "\n", "'MAE={blk_avg.mae:.2f}({average.mae:.2f}) '", "\n", "'iRMSE={blk_avg.irmse:.2f}({average.irmse:.2f}) '", "\n", "'iMAE={blk_avg.imae:.2f}({average.imae:.2f})\\n\\t'", "\n", "'silog={blk_avg.silog:.2f}({average.silog:.2f}) '", "\n", "'squared_rel={blk_avg.squared_rel:.2f}({average.squared_rel:.2f}) '", "\n", "'Delta1={blk_avg.delta1:.3f}({average.delta1:.3f}) '", "\n", "'Delta2={blk_avg.delta2:.3f}({average.delta2:.3f}) '", "\n", "'REL={blk_avg.absrel:.3f}({average.absrel:.3f})\\n\\t'", "\n", "'Lg10={blk_avg.lg10:.3f}({average.lg10:.3f}) '", "\n", "'Photometric={blk_avg.photometric:.3f}({average.photometric:.3f}) '", "\n", ".", "format", "(", "epoch", "+", "1", ",", "\n", "total_epochs", ",", "\n", "i", "+", "1", ",", "\n", "n_set", ",", "\n", "lr", "=", "lr", ",", "\n", "blk_avg", "=", "blk_avg", ",", "\n", "average", "=", "avg", ",", "\n", "split", "=", "split", ".", "capitalize", "(", ")", ")", ")", "\n", "blk_avg_meter", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.conditional_save_info": [[77, 112], ["average_meter.average", "open", "csv.DictWriter", "csv.DictWriter.writerow", "os.path.join", "helper.logger.save_single_txt", "ValueError"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.average", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_single_txt"], ["", "", "def", "conditional_save_info", "(", "self", ",", "split", ",", "average_meter", ",", "epoch", ")", ":", "\n", "        ", "avg", "=", "average_meter", ".", "average", "(", ")", "\n", "if", "split", "==", "\"train\"", ":", "\n", "            ", "csvfile_name", "=", "self", ".", "train_csv", "\n", "", "elif", "split", "==", "\"val\"", ":", "\n", "            ", "csvfile_name", "=", "self", ".", "val_csv", "\n", "", "elif", "split", "==", "\"eval\"", ":", "\n", "            ", "eval_filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_directory", ",", "'eval.txt'", ")", "\n", "self", ".", "save_single_txt", "(", "eval_filename", ",", "avg", ",", "epoch", ")", "\n", "return", "avg", "\n", "", "elif", "\"test\"", "in", "split", ":", "\n", "            ", "return", "avg", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"wrong split provided to logger\"", ")", "\n", "", "with", "open", "(", "csvfile_name", ",", "'a'", ")", "as", "csvfile", ":", "\n", "            ", "writer", "=", "csv", ".", "DictWriter", "(", "csvfile", ",", "fieldnames", "=", "fieldnames", ")", "\n", "writer", ".", "writerow", "(", "{", "\n", "'epoch'", ":", "epoch", "+", "1", ",", "\n", "'rmse'", ":", "avg", ".", "rmse", ",", "\n", "'photo'", ":", "avg", ".", "photometric", ",", "\n", "'mae'", ":", "avg", ".", "mae", ",", "\n", "'irmse'", ":", "avg", ".", "irmse", ",", "\n", "'imae'", ":", "avg", ".", "imae", ",", "\n", "'mse'", ":", "avg", ".", "mse", ",", "\n", "'silog'", ":", "avg", ".", "silog", ",", "\n", "'squared_rel'", ":", "avg", ".", "squared_rel", ",", "\n", "'absrel'", ":", "avg", ".", "absrel", ",", "\n", "'lg10'", ":", "avg", ".", "lg10", ",", "\n", "'delta1'", ":", "avg", ".", "delta1", ",", "\n", "'delta2'", ":", "avg", ".", "delta2", ",", "\n", "'delta3'", ":", "avg", ".", "delta3", ",", "\n", "'gpu_time'", ":", "avg", ".", "gpu_time", ",", "\n", "'data_time'", ":", "avg", ".", "data_time", "\n", "}", ")", "\n", "", "return", "avg", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.save_single_txt": [[113, 126], ["open", "txtfile.write"], "methods", ["None"], ["", "def", "save_single_txt", "(", "self", ",", "filename", ",", "result", ",", "epoch", ",", "total_epochs", ")", ":", "\n", "        ", "with", "open", "(", "filename", ",", "'w'", ")", "as", "txtfile", ":", "\n", "            ", "txtfile", ".", "write", "(", "\n", "(", "\"rank_metric={}\\n\"", "+", "\"epoch={}/{}\\n\"", "+", "\"rmse={:.3f}\\n\"", "+", "\n", "\"mae={:.3f}\\n\"", "+", "\"silog={:.3f}\\n\"", "+", "\"squared_rel={:.3f}\\n\"", "+", "\n", "\"irmse={:.3f}\\n\"", "+", "\"imae={:.3f}\\n\"", "+", "\"mse={:.3f}\\n\"", "+", "\n", "\"absrel={:.3f}\\n\"", "+", "\"lg10={:.3f}\\n\"", "+", "\"delta1={:.3f}\\n\"", "+", "\"delta2={:.3f}\\n\"", "+", "\n", "\"t_gpu={:.4f}\"", ")", ".", "format", "(", "self", ".", "args", ".", "rank_metric", ",", "epoch", "+", "1", ",", "total_epochs", ",", "\n", "result", ".", "rmse", ",", "result", ".", "mae", ",", "result", ".", "silog", ",", "\n", "result", ".", "squared_rel", ",", "result", ".", "irmse", ",", "\n", "result", ".", "imae", ",", "result", ".", "mse", ",", "result", ".", "absrel", ",", "\n", "result", ".", "lg10", ",", "result", ".", "delta1", ",", "result", ".", "delta2", ",", "\n", "result", ".", "gpu_time", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.save_best_txt": [[127, 129], ["helper.logger.save_single_txt"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_single_txt"], ["", "", "def", "save_best_txt", "(", "self", ",", "result", ",", "epoch", ",", "total_epochs", ")", ":", "\n", "        ", "self", ".", "save_single_txt", "(", "self", ".", "best_txt", ",", "result", ",", "epoch", ",", "total_epochs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger._get_img_comparison_name": [[130, 139], ["str"], "methods", ["None"], ["", "def", "_get_img_comparison_name", "(", "self", ",", "mode", ",", "epoch", ",", "is_best", "=", "False", ")", ":", "\n", "        ", "if", "mode", "==", "'eval'", ":", "\n", "            ", "return", "self", ".", "output_directory", "+", "'/comparison_eval.png'", "\n", "", "if", "mode", "==", "'val'", ":", "\n", "            ", "if", "is_best", ":", "\n", "                ", "return", "self", ".", "output_directory", "+", "'/comparison_best.png'", "\n", "", "else", ":", "\n", "                ", "return", "self", ".", "output_directory", "+", "'/comparison_'", "+", "str", "(", "\n", "epoch", ")", "+", "'.png'", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.conditional_save_img_comparison": [[140, 152], ["vis_utils.merge_into_row", "vis_utils.merge_into_row", "vis_utils.add_row", "helper.logger._get_img_comparison_name", "vis_utils.save_image"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.merge_into_row", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.merge_into_row", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.add_row", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger._get_img_comparison_name", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.save_image"], ["", "", "", "def", "conditional_save_img_comparison", "(", "self", ",", "mode", ",", "i", ",", "ele", ",", "pred", ",", "epoch", ")", ":", "\n", "# save 8 images for visualization", "\n", "        ", "if", "mode", "==", "'val'", "or", "mode", "==", "'eval'", ":", "\n", "            ", "skip", "=", "100", "\n", "if", "i", "==", "0", ":", "\n", "                ", "self", ".", "img_merge", "=", "vis_utils", ".", "merge_into_row", "(", "ele", ",", "pred", ")", "\n", "", "elif", "i", "%", "skip", "==", "0", "and", "i", "<", "8", "*", "skip", ":", "\n", "                ", "row", "=", "vis_utils", ".", "merge_into_row", "(", "ele", ",", "pred", ")", "\n", "self", ".", "img_merge", "=", "vis_utils", ".", "add_row", "(", "self", ".", "img_merge", ",", "row", ")", "\n", "", "elif", "i", "==", "8", "*", "skip", ":", "\n", "                ", "filename", "=", "self", ".", "_get_img_comparison_name", "(", "mode", ",", "epoch", ")", "\n", "vis_utils", ".", "save_image", "(", "self", ".", "img_merge", ",", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.save_img_comparison_as_best": [[153, 157], ["helper.logger._get_img_comparison_name", "vis_utils.save_image"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger._get_img_comparison_name", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.save_image"], ["", "", "", "def", "save_img_comparison_as_best", "(", "self", ",", "mode", ",", "epoch", ")", ":", "\n", "        ", "if", "mode", "==", "'val'", ":", "\n", "            ", "filename", "=", "self", ".", "_get_img_comparison_name", "(", "mode", ",", "epoch", ",", "is_best", "=", "True", ")", "\n", "vis_utils", ".", "save_image", "(", "self", ".", "img_merge", ",", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.get_ranking_error": [[158, 160], ["getattr"], "methods", ["None"], ["", "", "def", "get_ranking_error", "(", "self", ",", "result", ")", ":", "\n", "        ", "return", "getattr", "(", "result", ",", "self", ".", "args", ".", "rank_metric", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.rank_conditional_save_best": [[161, 170], ["helper.logger.get_ranking_error", "helper.logger.get_ranking_error", "helper.logger.save_best_txt"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.get_ranking_error", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.get_ranking_error", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_best_txt"], ["", "def", "rank_conditional_save_best", "(", "self", ",", "mode", ",", "result", ",", "epoch", ",", "total_epochs", ")", ":", "\n", "        ", "error", "=", "self", ".", "get_ranking_error", "(", "result", ")", "\n", "best_error", "=", "self", ".", "get_ranking_error", "(", "self", ".", "best_result", ")", "\n", "is_best", "=", "error", "<", "best_error", "\n", "if", "is_best", "and", "mode", "==", "\"val\"", ":", "\n", "            ", "self", ".", "old_best_result", "=", "self", ".", "best_result", "\n", "self", ".", "best_result", "=", "result", "\n", "self", ".", "save_best_txt", "(", "result", ",", "epoch", ",", "total_epochs", ")", "\n", "", "return", "is_best", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.conditional_save_pred": [[171, 182], ["os.path.join", "torch.squeeze().numpy", "os.path.join", "vis_utils.save_depth_as_uint16png", "os.path.exists", "os.makedirs", "torch.squeeze", "pred.data.cpu"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.save_depth_as_uint16png"], ["", "def", "conditional_save_pred", "(", "self", ",", "mode", ",", "i", ",", "pred", ",", "epoch", ")", ":", "\n", "        ", "if", "(", "\"test\"", "in", "mode", "or", "mode", "==", "\"eval\"", ")", "and", "self", ".", "args", ".", "save_pred", ":", "\n", "\n", "# save images for visualization/ testing", "\n", "            ", "image_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_directory", ",", "\n", "mode", "+", "\"_output\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "image_folder", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "image_folder", ")", "\n", "", "img", "=", "torch", ".", "squeeze", "(", "pred", ".", "data", ".", "cpu", "(", ")", ")", ".", "numpy", "(", ")", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "image_folder", ",", "'{0:010d}.png'", ".", "format", "(", "i", ")", ")", "\n", "vis_utils", ".", "save_depth_as_uint16png", "(", "img", ",", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.logger.conditional_summarize": [[183, 207], ["print", "print", "print", "print", "print", "helper.logger.get_ranking_error", "helper.logger.get_ranking_error"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.get_ranking_error", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.get_ranking_error"], ["", "", "def", "conditional_summarize", "(", "self", ",", "mode", ",", "avg", ",", "is_best", ")", ":", "\n", "        ", "print", "(", "\"\\n*\\nSummary of\"", ",", "mode", ",", "\"round:\"", ")", "\n", "print", "(", "''", "\n", "'RMSE={average.rmse:.3f}\\n'", "\n", "'MAE={average.mae:.3f}\\n'", "\n", "'Photo={average.photometric:.3f}\\n'", "\n", "'iRMSE={average.irmse:.3f}\\n'", "\n", "'iMAE={average.imae:.3f}\\n'", "\n", "'squared_rel={average.squared_rel}\\n'", "\n", "'silog={average.silog}\\n'", "\n", "'Delta1={average.delta1:.3f}\\n'", "\n", "'Delta2={average.delta2:.3f}\\n'", "\n", "'REL={average.absrel:.3f}\\n'", "\n", "'Lg10={average.lg10:.3f}\\n'", "\n", "'t_GPU={time:.3f}'", ".", "format", "(", "average", "=", "avg", ",", "time", "=", "avg", ".", "gpu_time", ")", ")", "\n", "if", "is_best", "and", "mode", "==", "\"val\"", ":", "\n", "            ", "print", "(", "\"New best model by %s (was %.3f)\"", "%", "\n", "(", "self", ".", "args", ".", "rank_metric", ",", "\n", "self", ".", "get_ranking_error", "(", "self", ".", "old_best_result", ")", ")", ")", "\n", "", "elif", "mode", "==", "\"val\"", ":", "\n", "            ", "print", "(", "\"(best %s is %.3f)\"", "%", "\n", "(", "self", ".", "args", ".", "rank_metric", ",", "\n", "self", ".", "get_ranking_error", "(", "self", ".", "best_result", ")", ")", ")", "\n", "", "print", "(", "\"*\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.backup_source_code": [[213, 217], ["os.path.exists", "shutil.copytree", "shutil.rmtree"], "function", ["None"], ["def", "backup_source_code", "(", "backup_directory", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "exists", "(", "backup_directory", ")", ":", "\n", "        ", "shutil", ".", "rmtree", "(", "backup_directory", ")", "\n", "", "shutil", ".", "copytree", "(", "'.'", ",", "backup_directory", ",", "ignore", "=", "ignore_hidden", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.adjust_learning_rate": [[219, 225], ["None"], "function", ["None"], ["", "def", "adjust_learning_rate", "(", "lr_init", ",", "optimizer", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"Sets the learning rate to the initial LR decayed by 10 every 5 epochs\"\"\"", "\n", "lr", "=", "lr_init", "*", "(", "0.1", "**", "(", "epoch", "//", "5", ")", ")", "\n", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "        ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "", "return", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.save_checkpoint": [[227, 239], ["os.path.join", "torch.save", "os.path.join", "shutil.copyfile", "os.path.join", "os.path.exists", "os.remove", "str", "str"], "function", ["None"], ["", "def", "save_checkpoint", "(", "state", ",", "is_best", ",", "epoch", ",", "output_directory", ")", ":", "\n", "    ", "checkpoint_filename", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "\n", "'checkpoint-'", "+", "str", "(", "epoch", ")", "+", "'.pth.tar'", ")", "\n", "torch", ".", "save", "(", "state", ",", "checkpoint_filename", ")", "\n", "if", "is_best", ":", "\n", "        ", "best_filename", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "'model_best.pth.tar'", ")", "\n", "shutil", ".", "copyfile", "(", "checkpoint_filename", ",", "best_filename", ")", "\n", "", "if", "epoch", ">", "0", ":", "\n", "        ", "prev_checkpoint_filename", "=", "os", ".", "path", ".", "join", "(", "\n", "output_directory", ",", "'checkpoint-'", "+", "str", "(", "epoch", "-", "1", ")", "+", "'.pth.tar'", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "prev_checkpoint_filename", ")", ":", "\n", "            ", "os", ".", "remove", "(", "prev_checkpoint_filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.get_folder_name": [[241, 252], ["time.strftime", "os.path.join"], "function", ["None"], ["", "", "", "def", "get_folder_name", "(", "args", ")", ":", "\n", "    ", "current_time", "=", "time", ".", "strftime", "(", "'%Y-%m-%d@%H-%M'", ")", "\n", "if", "args", ".", "use_pose", ":", "\n", "        ", "prefix", "=", "\"var.mode={}.w1={}.w2={}.\"", ".", "format", "(", "args", ".", "train_mode", ",", "args", ".", "w1", ",", "args", ".", "w2", ")", "\n", "", "elif", "args", ".", "sample_method", "!=", "''", ":", "\n", "        ", "prefix", "=", "\"var.mode={}.budget={}.samp.method={}.\"", ".", "format", "(", "args", ".", "train_mode", ",", "args", ".", "budget", ",", "args", ".", "sample_method", ")", "\n", "", "else", ":", "\n", "        ", "prefix", "=", "\"var.mode={}.budget={}.\"", ".", "format", "(", "args", ".", "train_mode", ",", "args", ".", "budget", ")", "\n", "", "return", "os", ".", "path", ".", "join", "(", "args", ".", "result", ",", "\n", "prefix", "+", "'input={}.resnet{}.bs={}.pretrained={}.time={}'", ".", "\n", "format", "(", "args", ".", "input", ",", "args", ".", "layers", ",", "args", ".", "batch_size", ",", "args", ".", "pretrained", ",", "current_time", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.helper.multiscale": [[258, 265], ["avgpool", "avgpool", "avgpool", "avgpool", "avgpool"], "function", ["None"], ["def", "multiscale", "(", "img", ")", ":", "\n", "    ", "img1", "=", "avgpool", "(", "img", ")", "\n", "img2", "=", "avgpool", "(", "img1", ")", "\n", "img3", "=", "avgpool", "(", "img2", ")", "\n", "img4", "=", "avgpool", "(", "img3", ")", "\n", "img5", "=", "avgpool", "(", "img4", ")", "\n", "return", "img5", ",", "img4", ",", "img3", ",", "img2", ",", "img1", "\n", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.model.DepthCompletionNet.__init__": [[70, 160], ["torch.Module.__init__", "model.conv_bn_relu", "model.convt_bn_relu", "model.convt_bn_relu", "model.convt_bn_relu", "model.convt_bn_relu", "model.convt_bn_relu", "model.conv_bn_relu", "model.conv_bn_relu", "model.conv_bn_relu", "pretrained_model.apply", "len", "len", "model.conv_bn_relu", "len"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu"], ["    ", "def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "assert", "(", "\n", "args", ".", "layers", "in", "[", "18", ",", "34", ",", "50", ",", "101", ",", "152", "]", "\n", ")", ",", "'Only layers 18, 34, 50, 101, and 152 are defined, but got {}'", ".", "format", "(", "\n", "args", ".", "layers", ")", "\n", "super", "(", "DepthCompletionNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "modality", "=", "args", ".", "input", "\n", "\n", "if", "'d'", "in", "self", ".", "modality", ":", "\n", "            ", "channels", "=", "64", "//", "len", "(", "self", ".", "modality", ")", "\n", "self", ".", "conv1_d", "=", "conv_bn_relu", "(", "1", ",", "\n", "channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "", "if", "'rgb'", "in", "self", ".", "modality", ":", "\n", "            ", "channels", "=", "64", "*", "3", "//", "len", "(", "self", ".", "modality", ")", "\n", "self", ".", "conv1_img", "=", "conv_bn_relu", "(", "3", ",", "\n", "channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "", "elif", "'g'", "in", "self", ".", "modality", ":", "\n", "            ", "channels", "=", "64", "//", "len", "(", "self", ".", "modality", ")", "\n", "self", ".", "conv1_img", "=", "conv_bn_relu", "(", "1", ",", "\n", "channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "\n", "", "pretrained_model", "=", "resnet", ".", "__dict__", "[", "'resnet{}'", ".", "format", "(", "\n", "args", ".", "layers", ")", "]", "(", "pretrained", "=", "args", ".", "pretrained", ")", "\n", "if", "not", "args", ".", "pretrained", ":", "\n", "            ", "pretrained_model", ".", "apply", "(", "init_weights", ")", "\n", "#self.maxpool = pretrained_model._modules['maxpool']", "\n", "", "self", ".", "conv2", "=", "pretrained_model", ".", "_modules", "[", "'layer1'", "]", "\n", "self", ".", "conv3", "=", "pretrained_model", ".", "_modules", "[", "'layer2'", "]", "\n", "self", ".", "conv4", "=", "pretrained_model", ".", "_modules", "[", "'layer3'", "]", "\n", "self", ".", "conv5", "=", "pretrained_model", ".", "_modules", "[", "'layer4'", "]", "\n", "del", "pretrained_model", "# clear memory", "\n", "\n", "# define number of intermediate channels", "\n", "if", "args", ".", "layers", "<=", "34", ":", "\n", "            ", "num_channels", "=", "512", "\n", "", "elif", "args", ".", "layers", ">=", "50", ":", "\n", "            ", "num_channels", "=", "2048", "\n", "", "self", ".", "conv6", "=", "conv_bn_relu", "(", "num_channels", ",", "\n", "512", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ")", "\n", "\n", "# decoding layers", "\n", "kernel_size", "=", "3", "\n", "stride", "=", "2", "\n", "self", ".", "convt5", "=", "convt_bn_relu", "(", "in_channels", "=", "512", ",", "\n", "out_channels", "=", "256", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "output_padding", "=", "1", ")", "\n", "self", ".", "convt4", "=", "convt_bn_relu", "(", "in_channels", "=", "768", ",", "\n", "out_channels", "=", "128", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "output_padding", "=", "1", ")", "\n", "self", ".", "convt3", "=", "convt_bn_relu", "(", "in_channels", "=", "(", "256", "+", "128", ")", ",", "\n", "out_channels", "=", "64", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "output_padding", "=", "1", ")", "\n", "self", ".", "convt2", "=", "convt_bn_relu", "(", "in_channels", "=", "(", "128", "+", "64", ")", ",", "\n", "out_channels", "=", "64", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "output_padding", "=", "1", ")", "\n", "self", ".", "convt1", "=", "convt_bn_relu", "(", "in_channels", "=", "128", ",", "\n", "out_channels", "=", "64", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "convtf", "=", "conv_bn_relu", "(", "in_channels", "=", "128", ",", "\n", "out_channels", "=", "1", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "bn", "=", "False", ",", "\n", "relu", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.model.DepthCompletionNet.forward": [[161, 206], ["model.DepthCompletionNet.conv2", "model.DepthCompletionNet.conv3", "model.DepthCompletionNet.conv4", "model.DepthCompletionNet.conv5", "model.DepthCompletionNet.conv6", "model.DepthCompletionNet.convt5", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convt4", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convt3", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convt2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convt1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convtf", "model.DepthCompletionNet.conv1_d", "model.DepthCompletionNet.conv1_img", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.conv1_img", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# first layer", "\n", "        ", "if", "'d'", "in", "self", ".", "modality", ":", "\n", "            ", "conv1_d", "=", "self", ".", "conv1_d", "(", "x", "[", "'d'", "]", ")", "\n", "", "if", "'rgb'", "in", "self", ".", "modality", ":", "\n", "            ", "conv1_img", "=", "self", ".", "conv1_img", "(", "x", "[", "'rgb'", "]", ")", "\n", "", "elif", "'g'", "in", "self", ".", "modality", ":", "\n", "            ", "conv1_img", "=", "self", ".", "conv1_img", "(", "x", "[", "'g'", "]", ")", "\n", "\n", "", "if", "self", ".", "modality", "==", "'rgbd'", "or", "self", ".", "modality", "==", "'gd'", ":", "\n", "            ", "conv1", "=", "torch", ".", "cat", "(", "(", "conv1_d", ",", "conv1_img", ")", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "conv1", "=", "conv1_d", "if", "(", "self", ".", "modality", "==", "'d'", ")", "else", "conv1_img", "\n", "\n", "", "conv2", "=", "self", ".", "conv2", "(", "conv1", ")", "\n", "conv3", "=", "self", ".", "conv3", "(", "conv2", ")", "# batchsize * ? * 176 * 608", "\n", "conv4", "=", "self", ".", "conv4", "(", "conv3", ")", "# batchsize * ? * 88 * 304", "\n", "conv5", "=", "self", ".", "conv5", "(", "conv4", ")", "# batchsize * ? * 44 * 152", "\n", "conv6", "=", "self", ".", "conv6", "(", "conv5", ")", "# batchsize * ? * 22 * 76", "\n", "\n", "# decoder", "\n", "convt5", "=", "self", ".", "convt5", "(", "conv6", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt5", ",", "conv5", ")", ",", "1", ")", "\n", "\n", "convt4", "=", "self", ".", "convt4", "(", "y", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt4", ",", "conv4", ")", ",", "1", ")", "\n", "\n", "convt3", "=", "self", ".", "convt3", "(", "y", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt3", ",", "conv3", ")", ",", "1", ")", "\n", "\n", "convt2", "=", "self", ".", "convt2", "(", "y", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt2", ",", "conv2", ")", ",", "1", ")", "\n", "\n", "convt1", "=", "self", ".", "convt1", "(", "y", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt1", ",", "conv1", ")", ",", "1", ")", "\n", "\n", "y", "=", "self", ".", "convtf", "(", "y", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "100", "*", "y", "# output can be nagative & zero", "\n", "", "else", ":", "# during eval", "\n", "            ", "min_distance", "=", "0.9", "\n", "return", "F", ".", "relu", "(", "\n", "100", "*", "y", "-", "min_distance", "\n", ")", "+", "min_distance", "# the minimum range of Velodyne is around 3 feet ~= 0.9m", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.model.init_weights": [[8, 20], ["isinstance", "isinstance", "m.weight.data.normal_", "isinstance", "m.bias.data.zero_", "m.weight.data.normal_", "isinstance", "m.bias.data.zero_", "m.weight.data.fill_", "m.bias.data.zero_"], "function", ["None"], ["def", "init_weights", "(", "m", ")", ":", "\n", "    ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "        ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "1e-3", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "            ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "        ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "1e-3", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "            ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "        ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.model.conv_bn_relu": [[21, 43], ["nn.Sequential.append", "torch.Sequential", "nn.Sequential.modules", "torch.Conv2d", "nn.Sequential.append", "nn.Sequential.append", "model.init_weights", "torch.BatchNorm2d", "torch.LeakyReLU"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.init_weights"], ["", "", "def", "conv_bn_relu", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bn", "=", "True", ",", "relu", "=", "True", ")", ":", "\n", "    ", "bias", "=", "not", "bn", "\n", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", ",", "\n", "padding", ",", "\n", "bias", "=", "bias", ")", ")", "\n", "if", "bn", ":", "\n", "        ", "layers", ".", "append", "(", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", ")", "\n", "", "if", "relu", ":", "\n", "        ", "layers", ".", "append", "(", "nn", ".", "LeakyReLU", "(", "0.2", ",", "inplace", "=", "True", ")", ")", "\n", "", "layers", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "# initialize the weights", "\n", "for", "m", "in", "layers", ".", "modules", "(", ")", ":", "\n", "        ", "init_weights", "(", "m", ")", "\n", "\n", "", "return", "layers", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.model.convt_bn_relu": [[44, 67], ["nn.Sequential.append", "torch.Sequential", "nn.Sequential.modules", "torch.ConvTranspose2d", "nn.Sequential.append", "nn.Sequential.append", "model.init_weights", "torch.BatchNorm2d", "torch.LeakyReLU"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.init_weights"], ["", "def", "convt_bn_relu", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "output_padding", "=", "0", ",", "bn", "=", "True", ",", "relu", "=", "True", ")", ":", "\n", "    ", "bias", "=", "not", "bn", "\n", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "nn", ".", "ConvTranspose2d", "(", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", ",", "\n", "padding", ",", "\n", "output_padding", ",", "\n", "bias", "=", "bias", ")", ")", "\n", "if", "bn", ":", "\n", "        ", "layers", ".", "append", "(", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", ")", "\n", "", "if", "relu", ":", "\n", "        ", "layers", ".", "append", "(", "nn", ".", "LeakyReLU", "(", "0.2", ",", "inplace", "=", "True", ")", ")", "\n", "", "layers", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "# initialize the weights", "\n", "for", "m", "in", "layers", ".", "modules", "(", ")", ":", "\n", "        ", "init_weights", "(", "m", ")", "\n", "\n", "", "return", "layers", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.inverse_warp.Intrinsics.__init__": [[6, 24], ["torch.arange().expand().float", "torch.arange().expand().float", "torch.arange().expand().float", "torch.arange().expand().float", "torch.arange().expand().t().float", "torch.arange().expand().t().float", "torch.arange().expand().t().float", "torch.arange().expand().t().float", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand().t", "torch.arange().expand().t", "torch.arange().expand().t", "torch.arange().expand().t", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "width", ",", "height", ",", "fu", ",", "fv", ",", "cu", "=", "0", ",", "cv", "=", "0", ")", ":", "\n", "        ", "self", ".", "height", ",", "self", ".", "width", "=", "height", ",", "width", "\n", "self", ".", "fu", ",", "self", ".", "fv", "=", "fu", ",", "fv", "# fu, fv: focal length along the horizontal and vertical axes", "\n", "\n", "# cu, cv: optical center along the horizontal and vertical axes", "\n", "self", ".", "cu", "=", "cu", "if", "cu", ">", "0", "else", "(", "width", "-", "1", ")", "/", "2.0", "\n", "self", ".", "cv", "=", "cv", "if", "cv", ">", "0", "else", "(", "height", "-", "1", ")", "/", "2.0", "\n", "\n", "# U, V represent the homogeneous horizontal and vertical coordinates in the pixel space", "\n", "self", ".", "U", "=", "torch", ".", "arange", "(", "start", "=", "0", ",", "end", "=", "width", ")", ".", "expand", "(", "height", ",", "width", ")", ".", "float", "(", ")", "\n", "self", ".", "V", "=", "torch", ".", "arange", "(", "start", "=", "0", ",", "end", "=", "height", ")", ".", "expand", "(", "width", ",", "\n", "height", ")", ".", "t", "(", ")", ".", "float", "(", ")", "\n", "\n", "# X_cam, Y_cam represent the homogeneous x, y coordinates (assuming depth z=1) in the camera coordinate system", "\n", "self", ".", "X_cam", "=", "(", "self", ".", "U", "-", "self", ".", "cu", ")", "/", "self", ".", "fu", "\n", "self", ".", "Y_cam", "=", "(", "self", ".", "V", "-", "self", ".", "cv", ")", "/", "self", ".", "fv", "\n", "\n", "self", ".", "is_cuda", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.inverse_warp.Intrinsics.cuda": [[25, 30], ["inverse_warp.Intrinsics.X_cam.data.cuda", "inverse_warp.Intrinsics.Y_cam.data.cuda"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.cuda", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.cuda"], ["", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "self", ".", "X_cam", ".", "data", "=", "self", ".", "X_cam", ".", "data", ".", "cuda", "(", ")", "\n", "self", ".", "Y_cam", ".", "data", "=", "self", ".", "Y_cam", ".", "data", ".", "cuda", "(", ")", "\n", "self", ".", "is_cuda", "=", "True", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.inverse_warp.Intrinsics.scale": [[31, 43], ["inverse_warp.Intrinsics", "float", "float", "inverse_warp.Intrinsics.cuda"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.cuda"], ["", "def", "scale", "(", "self", ",", "height", ",", "width", ")", ":", "\n", "# return a new set of corresponding intrinsic parameters for the scaled image", "\n", "        ", "ratio_u", "=", "float", "(", "width", ")", "/", "self", ".", "width", "\n", "ratio_v", "=", "float", "(", "height", ")", "/", "self", ".", "height", "\n", "fu", "=", "ratio_u", "*", "self", ".", "fu", "\n", "fv", "=", "ratio_v", "*", "self", ".", "fv", "\n", "cu", "=", "ratio_u", "*", "self", ".", "cu", "\n", "cv", "=", "ratio_v", "*", "self", ".", "cv", "\n", "new_intrinsics", "=", "Intrinsics", "(", "width", ",", "height", ",", "fu", ",", "fv", ",", "cu", ",", "cv", ")", "\n", "if", "self", ".", "is_cuda", ":", "\n", "            ", "new_intrinsics", ".", "cuda", "(", ")", "\n", "", "return", "new_intrinsics", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.inverse_warp.Intrinsics.__print__": [[44, 48], ["print"], "methods", ["None"], ["", "def", "__print__", "(", "self", ")", ":", "\n", "        ", "print", "(", "'size=({},{})\\nfocal length=({},{})\\noptical center=({},{})'", ".", "\n", "format", "(", "self", ".", "height", ",", "self", ".", "width", ",", "self", ".", "fv", ",", "self", ".", "fu", ",", "self", ".", "cv", ",", "\n", "self", ".", "cu", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.inverse_warp.image_to_pointcloud": [[50, 57], ["torch.cat", "torch.cat", "depth.dim", "depth.size"], "function", ["None"], ["", "", "def", "image_to_pointcloud", "(", "depth", ",", "intrinsics", ")", ":", "\n", "    ", "assert", "depth", ".", "dim", "(", ")", "==", "4", "\n", "assert", "depth", ".", "size", "(", "1", ")", "==", "1", "\n", "\n", "X", "=", "depth", "*", "intrinsics", ".", "X_cam", "\n", "Y", "=", "depth", "*", "intrinsics", ".", "Y_cam", "\n", "return", "torch", ".", "cat", "(", "(", "X", ",", "Y", ",", "depth", ")", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.inverse_warp.pointcloud_to_image": [[59, 89], ["pointcloud.size", "pointcloud[].clamp", "torch.stack", "torch.stack", "torch.stack.view", "pointcloud.dim"], "function", ["None"], ["", "def", "pointcloud_to_image", "(", "pointcloud", ",", "intrinsics", ")", ":", "\n", "    ", "assert", "pointcloud", ".", "dim", "(", ")", "==", "4", "\n", "\n", "batch_size", "=", "pointcloud", ".", "size", "(", "0", ")", "\n", "X", "=", "pointcloud", "[", ":", ",", "0", ",", ":", ",", ":", "]", "#.view(batch_size, -1)", "\n", "Y", "=", "pointcloud", "[", ":", ",", "1", ",", ":", ",", ":", "]", "#.view(batch_size, -1)", "\n", "Z", "=", "pointcloud", "[", ":", ",", "2", ",", ":", ",", ":", "]", ".", "clamp", "(", "min", "=", "1e-3", ")", "#.view(batch_size, -1)", "\n", "\n", "# compute pixel coordinates", "\n", "U_proj", "=", "intrinsics", ".", "fu", "*", "X", "/", "Z", "+", "intrinsics", ".", "cu", "# horizontal pixel coordinate", "\n", "V_proj", "=", "intrinsics", ".", "fv", "*", "Y", "/", "Z", "+", "intrinsics", ".", "cv", "# vertical pixel coordinate", "\n", "\n", "# normalization to [-1, 1], required by torch.nn.functional.grid_sample", "\n", "U_proj_normalized", "=", "(", "2", "*", "U_proj", "/", "(", "intrinsics", ".", "width", "-", "1", ")", "-", "1", ")", ".", "view", "(", "\n", "batch_size", ",", "-", "1", ")", "\n", "V_proj_normalized", "=", "(", "2", "*", "V_proj", "/", "(", "intrinsics", ".", "height", "-", "1", ")", "-", "1", ")", ".", "view", "(", "\n", "batch_size", ",", "-", "1", ")", "\n", "\n", "# This was important since PyTorch didn't do as it claimed for points out of boundary", "\n", "# See https://github.com/ClementPinard/SfmLearner-Pytorch/blob/master/inverse_warp.py", "\n", "# Might not be necessary any more", "\n", "U_proj_mask", "=", "(", "(", "U_proj_normalized", ">", "1", ")", "+", "(", "U_proj_normalized", "<", "-", "1", ")", ")", ".", "detach", "(", ")", "\n", "U_proj_normalized", "[", "U_proj_mask", "]", "=", "2", "\n", "V_proj_mask", "=", "(", "(", "V_proj_normalized", ">", "1", ")", "+", "(", "V_proj_normalized", "<", "-", "1", ")", ")", ".", "detach", "(", ")", "\n", "V_proj_normalized", "[", "V_proj_mask", "]", "=", "2", "\n", "\n", "pixel_coords", "=", "torch", ".", "stack", "(", "[", "U_proj_normalized", ",", "V_proj_normalized", "]", ",", "\n", "dim", "=", "2", ")", "# [B, H*W, 2]", "\n", "return", "pixel_coords", ".", "view", "(", "batch_size", ",", "intrinsics", ".", "height", ",", "intrinsics", ".", "width", ",", "\n", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.inverse_warp.batch_multiply": [[91, 99], ["batch_scalar.size", "batch_matrix.clone", "range"], "function", ["None"], ["", "def", "batch_multiply", "(", "batch_scalar", ",", "batch_matrix", ")", ":", "\n", "# input: batch_scalar of size b, batch_matrix of size b * 3 * 3", "\n", "# output: batch_matrix of size b * 3 * 3", "\n", "    ", "batch_size", "=", "batch_scalar", ".", "size", "(", "0", ")", "\n", "output", "=", "batch_matrix", ".", "clone", "(", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "output", "[", "i", "]", "=", "batch_scalar", "[", "i", "]", "*", "batch_matrix", "[", "i", "]", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.inverse_warp.transform_curr_to_near": [[101, 116], ["pointcloud_curr.size", "torch.bmm", "torch.bmm", "torch.cat", "torch.cat", "pointcloud_curr.view", "t_vec[].unsqueeze", "t_vec[].unsqueeze", "t_vec[].unsqueeze"], "function", ["None"], ["", "def", "transform_curr_to_near", "(", "pointcloud_curr", ",", "r_mat", ",", "t_vec", ",", "intrinsics", ")", ":", "\n", "# translation and rotmat represent the transformation from tgt pose to src pose", "\n", "    ", "batch_size", "=", "pointcloud_curr", ".", "size", "(", "0", ")", "\n", "XYZ_", "=", "torch", ".", "bmm", "(", "r_mat", ",", "pointcloud_curr", ".", "view", "(", "batch_size", ",", "3", ",", "-", "1", ")", ")", "\n", "\n", "X", "=", "(", "XYZ_", "[", ":", ",", "0", ",", ":", "]", "+", "t_vec", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", ")", ".", "view", "(", "\n", "-", "1", ",", "1", ",", "intrinsics", ".", "height", ",", "intrinsics", ".", "width", ")", "\n", "Y", "=", "(", "XYZ_", "[", ":", ",", "1", ",", ":", "]", "+", "t_vec", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", ")", ".", "view", "(", "\n", "-", "1", ",", "1", ",", "intrinsics", ".", "height", ",", "intrinsics", ".", "width", ")", "\n", "Z", "=", "(", "XYZ_", "[", ":", ",", "2", ",", ":", "]", "+", "t_vec", "[", ":", ",", "2", "]", ".", "unsqueeze", "(", "1", ")", ")", ".", "view", "(", "\n", "-", "1", ",", "1", ",", "intrinsics", ".", "height", ",", "intrinsics", ".", "width", ")", "\n", "\n", "pointcloud_near", "=", "torch", ".", "cat", "(", "(", "X", ",", "Y", ",", "Z", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "pointcloud_near", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.inverse_warp.homography_from": [[118, 135], ["r_mat.view.view", "t_vec.view.view", "inverse_warp.image_to_pointcloud", "inverse_warp.transform_curr_to_near", "inverse_warp.pointcloud_to_image", "torch.grid_sample"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.image_to_pointcloud", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.transform_curr_to_near", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.pointcloud_to_image"], ["", "def", "homography_from", "(", "rgb_near", ",", "depth_curr", ",", "r_mat", ",", "t_vec", ",", "intrinsics", ")", ":", "\n", "# inverse warp the RGB image from the nearby frame to the current frame", "\n", "\n", "# to ensure dimension consistency", "\n", "    ", "r_mat", "=", "r_mat", ".", "view", "(", "-", "1", ",", "3", ",", "3", ")", "\n", "t_vec", "=", "t_vec", ".", "view", "(", "-", "1", ",", "3", ")", "\n", "\n", "# compute source pixel coordinate", "\n", "pointcloud_curr", "=", "image_to_pointcloud", "(", "depth_curr", ",", "intrinsics", ")", "\n", "pointcloud_near", "=", "transform_curr_to_near", "(", "pointcloud_curr", ",", "r_mat", ",", "t_vec", ",", "\n", "intrinsics", ")", "\n", "pixel_coords_near", "=", "pointcloud_to_image", "(", "pointcloud_near", ",", "intrinsics", ")", "\n", "\n", "# the warping", "\n", "warped", "=", "F", ".", "grid_sample", "(", "rgb_near", ",", "pixel_coords_near", ")", "\n", "\n", "return", "warped", "\n", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.main_test.iterate": [[90, 205], ["metrics.AverageMeter", "metrics.AverageMeter", "enumerate", "logger.conditional_save_info", "logger.rank_conditional_save_best", "logger.conditional_summarize", "model.train", "helper.adjust_learning_rate", "model.eval", "time.time", "time.time", "model", "logger.save_img_comparison_as_best", "val.to", "time.time", "enumerate", "optimizer.zero_grad", "loss.backward", "optimizer.step", "time.time", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "next().size", "metrics.Result", "logger.conditional_print", "logger.conditional_save_img_comparison", "logger.conditional_save_pred", "batch_data.items", "max", "model.cpu().detach().numpy", "os.path.abspath", "os.path.abspath", "os.path.basename", "os.path.abspath", "os.path.abspath", "os.path.abspath", "aux_functions.depth_write", "depth_criterion", "helper.multiscale", "helper.multiscale", "helper.multiscale", "len", "range", "smoothness_criterion", "metrics.Result.evaluate", "m.update", "len", "glob.glob", "os.path.dirname", "os.path.abspath.split", "os.path.isdir", "os.makedirs", "depth_criterion", "helper.multiscale", "len", "kitti_intrinsics.scale", "inverse_warp.homography_from", "next", "model.cpu().detach", "pred_.size", "pred_.size", "photometric_criterion", "iter", "batch_data.values", "model.cpu"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_save_info", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.rank_conditional_save_best", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_summarize", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.adjust_learning_rate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_img_comparison_as_best", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_print", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_save_img_comparison", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_save_pred", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.None.aux_functions.depth_write", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.multiscale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.multiscale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.multiscale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.Result.evaluate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.update", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.multiscale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.scale", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.homography_from"], ["", "", "def", "iterate", "(", "mode", ",", "args", ",", "loader", ",", "model", ",", "optimizer", ",", "logger", ",", "epoch", ")", ":", "\n", "    ", "block_average_meter", "=", "AverageMeter", "(", ")", "\n", "average_meter", "=", "AverageMeter", "(", ")", "\n", "meters", "=", "[", "block_average_meter", ",", "average_meter", "]", "\n", "\n", "# switch to appropriate mode", "\n", "assert", "mode", "in", "[", "\"train\"", ",", "\"val\"", ",", "\"eval\"", ",", "\"test_prediction\"", ",", "\"test_completion\"", "]", ",", "\"unsupported mode: {}\"", ".", "format", "(", "mode", ")", "\n", "if", "mode", "==", "'train'", ":", "\n", "        ", "model", ".", "train", "(", ")", "\n", "lr", "=", "helper", ".", "adjust_learning_rate", "(", "args", ".", "lr", ",", "optimizer", ",", "epoch", ")", "\n", "", "else", ":", "\n", "        ", "model", ".", "eval", "(", ")", "# batchnorm or dropout layers will work in eval mode instead of training mode", "\n", "lr", "=", "0", "\n", "\n", "", "for", "i", ",", "batch_data", "in", "enumerate", "(", "loader", ")", ":", "# batch_data keys: 'd' (depth), 'gt' (ground truth), 'g' (gray)", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "batch_data", "=", "{", "\n", "key", ":", "val", ".", "to", "(", "device", ")", "\n", "for", "key", ",", "val", "in", "batch_data", ".", "items", "(", ")", "if", "val", "is", "not", "None", "\n", "}", "\n", "\n", "gt", "=", "batch_data", "[", "'gt'", "]", "if", "mode", "!=", "'test_prediction'", "and", "mode", "!=", "'test_completion'", "else", "None", "\n", "data_time", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "pred", "=", "model", "(", "batch_data", ")", "\n", "if", "args", ".", "save_images", ":", "# save depth predictions", "\n", "            ", "pred_out_dir", "=", "max", "(", "glob", ".", "glob", "(", "'../outputs/var_final_NN/var.test*'", ")", ",", "key", "=", "os", ".", "path", ".", "getmtime", ")", "+", "'/dense_depth_images'", "\n", "pred1", "=", "pred", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "for", "im_idx", ",", "pred_im", "in", "enumerate", "(", "pred1", ")", ":", "\n", "                ", "pred_out_dir1", "=", "os", ".", "path", ".", "abspath", "(", "pred_out_dir", ")", "\n", "cur_path", "=", "os", ".", "path", ".", "abspath", "(", "(", "loader", ".", "dataset", ".", "paths", ")", "[", "'d'", "]", "[", "i", "]", ")", "\n", "basename", "=", "os", ".", "path", ".", "basename", "(", "cur_path", ")", "\n", "cur_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "cur_path", ")", ")", "\n", "cur_dir", "=", "cur_dir", ".", "split", "(", "'var_final_NN/'", ")", "[", "1", "]", "\n", "new_dir", "=", "os", ".", "path", ".", "abspath", "(", "pred_out_dir1", "+", "'/'", "+", "cur_dir", ")", "\n", "new_path", "=", "os", ".", "path", ".", "abspath", "(", "new_dir", "+", "'/'", "+", "basename", ")", "\n", "if", "os", ".", "path", ".", "isdir", "(", "new_dir", ")", "==", "False", ":", "\n", "                    ", "os", ".", "makedirs", "(", "new_dir", ")", "\n", "\n", "", "depth_write", "(", "new_path", ",", "pred_im", ")", "\n", "\n", "", "", "depth_loss", ",", "photometric_loss", ",", "smooth_loss", ",", "mask", "=", "0", ",", "0", ",", "0", ",", "None", "\n", "if", "mode", "==", "'train'", ":", "\n", "# Loss 1: the direct depth supervision from ground truth label", "\n", "# mask=1 indicates that a pixel does not ground truth labels", "\n", "            ", "if", "'sparse'", "in", "args", ".", "train_mode", ":", "\n", "                ", "depth_loss", "=", "depth_criterion", "(", "pred", ",", "batch_data", "[", "'d'", "]", ")", "\n", "mask", "=", "(", "batch_data", "[", "'d'", "]", "<", "1e-3", ")", ".", "float", "(", ")", "\n", "", "elif", "'dense'", "in", "args", ".", "train_mode", ":", "\n", "                ", "depth_loss", "=", "depth_criterion", "(", "pred", ",", "gt", ")", "\n", "mask", "=", "(", "gt", "<", "1e-3", ")", ".", "float", "(", ")", "\n", "\n", "# Loss 2: the self-supervised photometric loss", "\n", "", "if", "args", ".", "use_pose", ":", "\n", "# create multi-scale pyramids", "\n", "                ", "pred_array", "=", "helper", ".", "multiscale", "(", "pred", ")", "\n", "rgb_curr_array", "=", "helper", ".", "multiscale", "(", "batch_data", "[", "'rgb'", "]", ")", "\n", "rgb_near_array", "=", "helper", ".", "multiscale", "(", "batch_data", "[", "'rgb_near'", "]", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "                    ", "mask_array", "=", "helper", ".", "multiscale", "(", "mask", ")", "\n", "", "num_scales", "=", "len", "(", "pred_array", ")", "\n", "\n", "# compute photometric loss at multiple scales", "\n", "for", "scale", "in", "range", "(", "len", "(", "pred_array", ")", ")", ":", "\n", "                    ", "pred_", "=", "pred_array", "[", "scale", "]", "\n", "rgb_curr_", "=", "rgb_curr_array", "[", "scale", "]", "\n", "rgb_near_", "=", "rgb_near_array", "[", "scale", "]", "\n", "mask_", "=", "None", "\n", "if", "mask", "is", "not", "None", ":", "\n", "                        ", "mask_", "=", "mask_array", "[", "scale", "]", "\n", "\n", "# compute the corresponding intrinsic parameters", "\n", "", "height_", ",", "width_", "=", "pred_", ".", "size", "(", "2", ")", ",", "pred_", ".", "size", "(", "3", ")", "\n", "intrinsics_", "=", "kitti_intrinsics", ".", "scale", "(", "height_", ",", "width_", ")", "\n", "\n", "# inverse warp from a nearby frame to the current frame", "\n", "warped_", "=", "homography_from", "(", "rgb_near_", ",", "pred_", ",", "batch_data", "[", "'r_mat'", "]", ",", "batch_data", "[", "'t_vec'", "]", ",", "intrinsics_", ")", "\n", "photometric_loss", "+=", "photometric_criterion", "(", "rgb_curr_", ",", "warped_", ",", "mask_", ")", "*", "(", "2", "**", "(", "scale", "-", "num_scales", ")", ")", "\n", "\n", "# Loss 3: the depth smoothness loss", "\n", "", "", "smooth_loss", "=", "smoothness_criterion", "(", "pred", ")", "if", "args", ".", "w2", ">", "0", "else", "0", "\n", "\n", "# backprop", "\n", "loss", "=", "depth_loss", "+", "args", ".", "w1", "*", "photometric_loss", "+", "args", ".", "w2", "*", "smooth_loss", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "gpu_time", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "\n", "# measure accuracy and record loss of each batch", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "# impacts the autograd engine and deactivate it (will reduce memory usage and speed up computations)", "\n", "            ", "mini_batch_size", "=", "next", "(", "iter", "(", "batch_data", ".", "values", "(", ")", ")", ")", ".", "size", "(", "0", ")", "\n", "result", "=", "Result", "(", ")", "# metrics", "\n", "if", "mode", "!=", "'test_prediction'", "and", "mode", "!=", "'test_completion'", ":", "\n", "                ", "result", ".", "evaluate", "(", "pred", ".", "data", ",", "gt", ".", "data", ",", "photometric_loss", ")", "\n", "", "[", "\n", "m", ".", "update", "(", "result", ",", "gpu_time", ",", "data_time", ",", "mini_batch_size", ")", "\n", "for", "m", "in", "meters", "\n", "]", "\n", "logger", ".", "conditional_print", "(", "mode", ",", "i", ",", "epoch", ",", "args", ".", "epochs", ",", "lr", ",", "len", "(", "loader", ")", ",", "block_average_meter", ",", "average_meter", ")", "\n", "logger", ".", "conditional_save_img_comparison", "(", "mode", ",", "i", ",", "batch_data", ",", "pred", ",", "epoch", ")", "\n", "logger", ".", "conditional_save_pred", "(", "mode", ",", "i", ",", "pred", ",", "epoch", ")", "\n", "", "del", "pred", "\n", "\n", "", "avg", "=", "logger", ".", "conditional_save_info", "(", "mode", ",", "average_meter", ",", "epoch", ")", "# take the avg of all the batches, to get the epoch metrics", "\n", "is_best", "=", "logger", ".", "rank_conditional_save_best", "(", "mode", ",", "avg", ",", "epoch", ",", "args", ".", "epochs", ")", "\n", "if", "is_best", "and", "not", "(", "mode", "==", "\"train\"", ")", ":", "\n", "        ", "logger", ".", "save_img_comparison_as_best", "(", "mode", ",", "epoch", ")", "\n", "", "logger", ".", "conditional_summarize", "(", "mode", ",", "avg", ",", "is_best", ")", "\n", "\n", "return", "avg", ",", "is_best", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.main_test.main": [[207, 312], ["print", "time.time", "print", "model.DepthCompletionNet().to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "print", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "print", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "helper.logger", "print", "print", "range", "os.path.join", "os.remove", "print", "print", "print", "os.path.isfile", "torch.nn.DataParallel.load_state_dict", "torch.optim.Adam.load_state_dict", "print", "dataloaders.kitti_loader.KittiDepth", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "dataloaders.kitti_loader.KittiDepth", "dataloaders.kitti_loader.KittiDepth", "print", "main_test.iterate", "print", "time.time", "main_test.iterate", "main_test.iterate", "helper.save_checkpoint", "print", "print", "torch.load", "torch.load", "torch.load", "torch.load", "print", "print", "os.path.isfile", "model.DepthCompletionNet", "torch.nn.DataParallel.named_parameters", "torch.nn.DataParallel.__dict__.items", "len", "print", "torch.load", "torch.load", "torch.load", "torch.load", "print", "print", "len", "torch.nn.DataParallel.module.state_dict", "torch.optim.Adam.state_dict", "str", "time.time", "time.time"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.main_test.iterate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.main_test.iterate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.main_test.iterate", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.save_checkpoint"], ["", "def", "main", "(", ")", ":", "\n", "    ", "global", "args", "\n", "if", "args", ".", "partial_train", "==", "'yes'", ":", "# train on a part of the whole train set", "\n", "        ", "print", "(", "\"Can't use partial train here. It is used only for test check. Exit...\"", ")", "\n", "return", "\n", "\n", "", "if", "args", ".", "test", "!=", "\"yes\"", ":", "\n", "        ", "print", "(", "\"This main should use only for testing, but test=yes wat not given. Exit...\"", ")", "\n", "return", "\n", "\n", "", "print", "(", "\"Evaluating test set with main_test:\"", ")", "\n", "whole_ts", "=", "time", ".", "time", "(", ")", "\n", "checkpoint", "=", "None", "\n", "is_eval", "=", "False", "\n", "if", "args", ".", "evaluate", ":", "# test a finished model", "\n", "        ", "args_new", "=", "args", "# copies", "\n", "if", "os", ".", "path", ".", "isfile", "(", "args", ".", "evaluate", ")", ":", "# path is an existing regular file", "\n", "            ", "print", "(", "\"=> loading finished model from '{}' ... \"", ".", "format", "(", "args", ".", "evaluate", ")", ",", "end", "=", "''", ")", "# \"end=''\" disables the newline", "\n", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "evaluate", ",", "map_location", "=", "device", ")", "\n", "args", "=", "checkpoint", "[", "'args'", "]", "\n", "args", ".", "data_folder", "=", "args_new", ".", "data_folder", "\n", "args", ".", "val", "=", "args_new", ".", "val", "\n", "args", ".", "save_images", "=", "args_new", ".", "save_images", "\n", "args", ".", "result", "=", "args_new", ".", "result", "\n", "is_eval", "=", "True", "\n", "print", "(", "\"Completed.\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"No model found at '{}'\"", ".", "format", "(", "args", ".", "evaluate", ")", ")", "\n", "return", "\n", "", "", "elif", "args", ".", "resume", ":", "# resume from a checkpoint", "\n", "        ", "args_new", "=", "args", "\n", "if", "os", ".", "path", ".", "isfile", "(", "args", ".", "resume", ")", ":", "\n", "            ", "print", "(", "\"=> loading checkpoint from '{}' ... \"", ".", "format", "(", "args", ".", "resume", ")", ",", "end", "=", "''", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "resume", ",", "map_location", "=", "device", ")", "\n", "args", ".", "start_epoch", "=", "checkpoint", "[", "'epoch'", "]", "+", "1", "\n", "args", ".", "data_folder", "=", "args_new", ".", "data_folder", "\n", "args", ".", "val", "=", "args_new", ".", "val", "\n", "print", "(", "\"Completed. Resuming from epoch {}.\"", ".", "format", "(", "checkpoint", "[", "'epoch'", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"No checkpoint found at '{}'\"", ".", "format", "(", "args", ".", "resume", ")", ")", "\n", "return", "\n", "\n", "", "", "print", "(", "\"=> creating model and optimizer ... \"", ",", "end", "=", "''", ")", "\n", "model", "=", "DepthCompletionNet", "(", "args", ")", ".", "to", "(", "device", ")", "\n", "model_named_params", "=", "[", "p", "\n", "for", "_", ",", "p", "in", "model", ".", "named_parameters", "(", ")", "# \"_, p\" is a direct analogy to an assignment statement k, _ = (0, 1). Unpack a tuple object", "\n", "if", "p", ".", "requires_grad", "]", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model_named_params", ",", "lr", "=", "args", ".", "lr", ",", "weight_decay", "=", "args", ".", "weight_decay", ")", "\n", "print", "(", "\"completed.\"", ")", "\n", "[", "f'{k:<20}: {v}'", "for", "k", ",", "v", "in", "model", ".", "__dict__", ".", "items", "(", ")", "]", "\n", "\n", "if", "checkpoint", "is", "not", "None", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'model'", "]", ")", "\n", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer'", "]", ")", "\n", "print", "(", "\"=> checkpoint state loaded.\"", ")", "\n", "\n", "", "model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "model", ")", "# make the model run parallelly: splits your data automatically and sends job orders to multiple models on several GPUs.", "\n", "# After each model finishes their job, DataParallel collects and merges the results before returning it to you", "\n", "\n", "# data loading code", "\n", "print", "(", "\"=> creating data loaders ... \"", ")", "\n", "if", "not", "is_eval", ":", "# we're not evaluating", "\n", "        ", "train_dataset", "=", "KittiDepth", "(", "'train'", ",", "args", ")", "# get the paths for the files", "\n", "train_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "train_dataset", ",", "batch_size", "=", "args", ".", "batch_size", ",", "shuffle", "=", "True", ",", "num_workers", "=", "args", ".", "workers", ",", "pin_memory", "=", "True", ",", "sampler", "=", "None", ")", "# load them", "\n", "print", "(", "\"\\t==> train_loader size:{}\"", ".", "format", "(", "len", "(", "train_loader", ")", ")", ")", "\n", "\n", "\n", "", "if", "args_new", ".", "test", "==", "\"yes\"", ":", "# will take the data from the \"test\" folders", "\n", "        ", "val_dataset", "=", "KittiDepth", "(", "'test'", ",", "args", ")", "\n", "is_test", "=", "'yes'", "\n", "", "else", ":", "\n", "        ", "val_dataset", "=", "KittiDepth", "(", "'val'", ",", "args", ")", "\n", "is_test", "=", "'no'", "\n", "", "val_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "val_dataset", ",", "batch_size", "=", "1", ",", "shuffle", "=", "False", ",", "num_workers", "=", "2", ",", "pin_memory", "=", "True", ")", "# set batch size to be 1 for validation", "\n", "print", "(", "\"\\t==> val_loader size:{}\"", ".", "format", "(", "len", "(", "val_loader", ")", ")", ")", "\n", "\n", "# create backups and results folder", "\n", "logger", "=", "helper", ".", "logger", "(", "args", ",", "is_test", ")", "\n", "if", "checkpoint", "is", "not", "None", ":", "\n", "        ", "logger", ".", "best_result", "=", "checkpoint", "[", "'best_result'", "]", "\n", "", "print", "(", "\"=> logger created.\"", ")", "# logger records sequential data to a log file", "\n", "\n", "# main code - run the NN", "\n", "if", "is_eval", ":", "\n", "        ", "print", "(", "\"=> starting model evaluation ...\"", ")", "\n", "result", ",", "is_best", "=", "iterate", "(", "\"val\"", ",", "args", ",", "val_loader", ",", "model", ",", "None", ",", "logger", ",", "checkpoint", "[", "'epoch'", "]", ")", "\n", "return", "\n", "\n", "", "print", "(", "\"=> starting model training ...\"", ")", "\n", "for", "epoch", "in", "range", "(", "args", ".", "start_epoch", ",", "args", ".", "epochs", ")", ":", "\n", "        ", "print", "(", "\"=> start training epoch {}\"", ".", "format", "(", "epoch", ")", "+", "\"/{}..\"", ".", "format", "(", "args", ".", "epochs", ")", ")", "\n", "train_ts", "=", "time", ".", "time", "(", ")", "\n", "iterate", "(", "\"train\"", ",", "args", ",", "train_loader", ",", "model", ",", "optimizer", ",", "logger", ",", "epoch", ")", "# train for one epoch", "\n", "result", ",", "is_best", "=", "iterate", "(", "\"val\"", ",", "args", ",", "val_loader", ",", "model", ",", "None", ",", "logger", ",", "epoch", ")", "# evaluate on validation set", "\n", "helper", ".", "save_checkpoint", "(", "{", "# save checkpoint", "\n", "'epoch'", ":", "epoch", ",", "\n", "'model'", ":", "model", ".", "module", ".", "state_dict", "(", ")", ",", "\n", "'best_result'", ":", "logger", ".", "best_result", ",", "\n", "'optimizer'", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'args'", ":", "args", ",", "\n", "}", ",", "is_best", ",", "epoch", ",", "logger", ".", "output_directory", ")", "\n", "print", "(", "\"finish training epoch {}, time elapsed {:.2f} hours, \\n\"", ".", "format", "(", "epoch", ",", "(", "time", ".", "time", "(", ")", "-", "train_ts", ")", "/", "3600", ")", ")", "\n", "", "last_checkpoint", "=", "os", ".", "path", ".", "join", "(", "logger", ".", "output_directory", ",", "'checkpoint-'", "+", "str", "(", "epoch", ")", "+", "'.pth.tar'", ")", "# delete last checkpoint because we have the best_model and we dont need it", "\n", "os", ".", "remove", "(", "last_checkpoint", ")", "\n", "print", "(", "\"finished model training, time elapsed {0:.2f} hours, \\n\"", ".", "format", "(", "(", "time", ".", "time", "(", ")", "-", "whole_ts", ")", "/", "3600", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.depth_colorize": [[13, 17], ["depth.astype", "numpy.min", "numpy.max", "numpy.min", "cmap"], "function", ["None"], ["def", "depth_colorize", "(", "depth", ")", ":", "\n", "    ", "depth", "=", "(", "depth", "-", "np", ".", "min", "(", "depth", ")", ")", "/", "(", "np", ".", "max", "(", "depth", ")", "-", "np", ".", "min", "(", "depth", ")", ")", "\n", "depth", "=", "255", "*", "cmap", "(", "depth", ")", "[", ":", ",", ":", ",", ":", "3", "]", "# H, W, C", "\n", "return", "depth", ".", "astype", "(", "'uint8'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.merge_into_row": [[19, 42], ["img_list.append", "numpy.hstack", "np.hstack.astype", "numpy.squeeze", "vis_utils.depth_colorize", "numpy.squeeze", "numpy.transpose", "img_list.append", "img_list.append", "vis_utils.merge_into_row.preprocess_depth"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.depth_colorize"], ["", "def", "merge_into_row", "(", "ele", ",", "pred", ")", ":", "\n", "    ", "def", "preprocess_depth", "(", "x", ")", ":", "\n", "        ", "y", "=", "np", ".", "squeeze", "(", "x", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "return", "depth_colorize", "(", "y", ")", "\n", "\n", "# if is gray, transforms to rgb", "\n", "", "img_list", "=", "[", "]", "\n", "if", "'rgb'", "in", "ele", ":", "\n", "        ", "rgb", "=", "np", ".", "squeeze", "(", "ele", "[", "'rgb'", "]", "[", "0", ",", "...", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "rgb", "=", "np", ".", "transpose", "(", "rgb", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "img_list", ".", "append", "(", "rgb", ")", "\n", "", "elif", "'g'", "in", "ele", ":", "\n", "        ", "g", "=", "np", ".", "squeeze", "(", "ele", "[", "'g'", "]", "[", "0", ",", "...", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "g", "=", "np", ".", "array", "(", "Image", ".", "fromarray", "(", "g", ")", ".", "convert", "(", "'RGB'", ")", ")", "\n", "img_list", ".", "append", "(", "g", ")", "\n", "", "if", "'d'", "in", "ele", ":", "\n", "        ", "img_list", ".", "append", "(", "preprocess_depth", "(", "ele", "[", "'d'", "]", "[", "0", ",", "...", "]", ")", ")", "\n", "", "img_list", ".", "append", "(", "preprocess_depth", "(", "pred", "[", "0", ",", "...", "]", ")", ")", "\n", "if", "'gt'", "in", "ele", ":", "\n", "        ", "img_list", ".", "append", "(", "preprocess_depth", "(", "ele", "[", "'gt'", "]", "[", "0", ",", "...", "]", ")", ")", "\n", "\n", "", "img_merge", "=", "np", ".", "hstack", "(", "img_list", ")", "\n", "return", "img_merge", ".", "astype", "(", "'uint8'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.add_row": [[44, 46], ["numpy.vstack"], "function", ["None"], ["", "def", "add_row", "(", "img_merge", ",", "row", ")", ":", "\n", "    ", "return", "np", ".", "vstack", "(", "[", "img_merge", ",", "row", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.save_image": [[48, 51], ["cv2.cvtColor", "cv2.imwrite"], "function", ["None"], ["", "def", "save_image", "(", "img_merge", ",", "filename", ")", ":", "\n", "    ", "image_to_write", "=", "cv2", ".", "cvtColor", "(", "img_merge", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "cv2", ".", "imwrite", "(", "filename", ",", "image_to_write", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.save_depth_as_uint16png": [[53, 56], ["cv2.imwrite"], "function", ["None"], ["", "def", "save_depth_as_uint16png", "(", "img", ",", "filename", ")", ":", "\n", "    ", "img", "=", "(", "img", "*", "256", ")", ".", "astype", "(", "'uint16'", ")", "\n", "cv2", ".", "imwrite", "(", "filename", ",", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.display_warping": [[64, 114], ["vis_utils.display_warping.preprocess"], "function", ["None"], ["", "def", "display_warping", "(", "rgb_tgt", ",", "pred_tgt", ",", "warped", ")", ":", "\n", "    ", "def", "preprocess", "(", "rgb_tgt", ",", "pred_tgt", ",", "warped", ")", ":", "\n", "        ", "rgb_tgt", "=", "255", "*", "np", ".", "transpose", "(", "np", ".", "squeeze", "(", "rgb_tgt", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "(", "1", ",", "2", ",", "0", ")", ")", "# H, W, C", "\n", "# depth = np.squeeze(depth.cpu().numpy())", "\n", "# depth = depth_colorize(depth)", "\n", "\n", "# convert to log-scale", "\n", "pred_tgt", "=", "np", ".", "squeeze", "(", "pred_tgt", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "# pred_tgt[pred_tgt<=0] = 0.9 # remove negative predictions", "\n", "# pred_tgt = np.log10(pred_tgt)", "\n", "\n", "pred_tgt", "=", "depth_colorize", "(", "pred_tgt", ")", "\n", "\n", "warped", "=", "255", "*", "np", ".", "transpose", "(", "np", ".", "squeeze", "(", "warped", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "(", "1", ",", "2", ",", "0", ")", ")", "# H, W, C", "\n", "recon_err", "=", "np", ".", "absolute", "(", "\n", "warped", ".", "astype", "(", "'float'", ")", "-", "rgb_tgt", ".", "astype", "(", "'float'", ")", ")", "*", "(", "warped", ">", "0", ")", "\n", "recon_err", "=", "recon_err", "[", ":", ",", ":", ",", "0", "]", "+", "recon_err", "[", ":", ",", ":", ",", "1", "]", "+", "recon_err", "[", ":", ",", ":", ",", "2", "]", "\n", "recon_err", "=", "depth_colorize", "(", "recon_err", ")", "\n", "return", "rgb_tgt", ".", "astype", "(", "'uint8'", ")", ",", "warped", ".", "astype", "(", "\n", "'uint8'", ")", ",", "recon_err", ",", "pred_tgt", "\n", "\n", "", "rgb_tgt", ",", "warped", ",", "recon_err", ",", "pred_tgt", "=", "preprocess", "(", "rgb_tgt", ",", "pred_tgt", ",", "\n", "warped", ")", "\n", "\n", "# 1st column", "\n", "column", "=", "0", "\n", "axarr", "[", "0", "]", ".", "imshow", "(", "rgb_tgt", ")", "\n", "axarr", "[", "0", "]", ".", "axis", "(", "'off'", ")", "\n", "axarr", "[", "0", "]", ".", "axis", "(", "'equal'", ")", "\n", "# axarr[0, column].set_title('rgb_tgt')", "\n", "\n", "axarr", "[", "1", "]", ".", "imshow", "(", "warped", ")", "\n", "axarr", "[", "1", "]", ".", "axis", "(", "'off'", ")", "\n", "axarr", "[", "1", "]", ".", "axis", "(", "'equal'", ")", "\n", "# axarr[1, column].set_title('warped')", "\n", "\n", "axarr", "[", "2", "]", ".", "imshow", "(", "recon_err", ",", "'hot'", ")", "\n", "axarr", "[", "2", "]", ".", "axis", "(", "'off'", ")", "\n", "axarr", "[", "2", "]", ".", "axis", "(", "'equal'", ")", "\n", "# axarr[2, column].set_title('recon_err error')", "\n", "\n", "axarr", "[", "3", "]", ".", "imshow", "(", "pred_tgt", ",", "'hot'", ")", "\n", "axarr", "[", "3", "]", ".", "axis", "(", "'off'", ")", "\n", "axarr", "[", "3", "]", ".", "axis", "(", "'equal'", ")", "\n", "# axarr[3, column].set_title('pred_tgt')", "\n", "\n", "# plt.show()", "\n", "plt", ".", "pause", "(", "0.001", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.criteria.MaskedMSELoss.__init__": [[8, 10], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "MaskedMSELoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.criteria.MaskedMSELoss.forward": [[11, 18], ["pred.dim", "target.dim"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ")", ":", "\n", "        ", "assert", "pred", ".", "dim", "(", ")", "==", "target", ".", "dim", "(", ")", ",", "\"inconsistent dimensions\"", "\n", "valid_mask", "=", "(", "target", ">", "0", ")", ".", "detach", "(", ")", "\n", "diff", "=", "target", "-", "pred", "\n", "diff", "=", "diff", "[", "valid_mask", "]", "\n", "self", ".", "loss", "=", "(", "diff", "**", "2", ")", ".", "mean", "(", ")", "\n", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.criteria.MaskedL1Loss.__init__": [[21, 23], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "MaskedL1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.criteria.MaskedL1Loss.forward": [[24, 31], ["diff.abs().mean", "pred.dim", "target.dim", "diff.abs"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "weight", "=", "None", ")", ":", "\n", "        ", "assert", "pred", ".", "dim", "(", ")", "==", "target", ".", "dim", "(", ")", ",", "\"inconsistent dimensions\"", "\n", "valid_mask", "=", "(", "target", ">", "0", ")", ".", "detach", "(", ")", "\n", "diff", "=", "target", "-", "pred", "\n", "diff", "=", "diff", "[", "valid_mask", "]", "\n", "self", ".", "loss", "=", "diff", ".", "abs", "(", ")", ".", "mean", "(", ")", "\n", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.criteria.PhotometricLoss.__init__": [[34, 36], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "PhotometricLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.criteria.PhotometricLoss.forward": [[37, 69], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "valid_mask.byte().detach.byte().detach.byte().detach", "recon.dim", "recon.dim", "target.dim", "target.dim", "recon.size", "target.size", "recon.size", "target.size", "valid_mask.byte().detach.byte().detach.numel", "print", "torch.squeeze().float", "torch.squeeze().float", "torch.squeeze().float", "torch.squeeze().float", "valid_mask.byte().detach.byte().detach.byte", "torch.sum.nelement", "torch.sum.nelement", "torch.sum.mean", "torch.sum.mean", "print", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "target", ",", "recon", ",", "mask", "=", "None", ")", ":", "\n", "\n", "        ", "assert", "recon", ".", "dim", "(", "\n", ")", "==", "4", ",", "\"expected recon dimension to be 4, but instead got {}.\"", ".", "format", "(", "\n", "recon", ".", "dim", "(", ")", ")", "\n", "assert", "target", ".", "dim", "(", "\n", ")", "==", "4", ",", "\"expected target dimension to be 4, but instead got {}.\"", ".", "format", "(", "\n", "target", ".", "dim", "(", ")", ")", "\n", "assert", "recon", ".", "size", "(", ")", "==", "target", ".", "size", "(", ")", ",", "\"expected recon and target to have the same size, but got {} and {} instead\"", ".", "format", "(", "recon", ".", "size", "(", ")", ",", "target", ".", "size", "(", ")", ")", "\n", "diff", "=", "(", "target", "-", "recon", ")", ".", "abs", "(", ")", "\n", "diff", "=", "torch", ".", "sum", "(", "diff", ",", "1", ")", "# sum along the color channel", "\n", "\n", "# compare only pixels that are not black", "\n", "valid_mask", "=", "(", "torch", ".", "sum", "(", "recon", ",", "1", ")", ">", "0", ")", ".", "float", "(", ")", "*", "(", "torch", ".", "sum", "(", "target", ",", "1", ")", "\n", ">", "0", ")", ".", "float", "(", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "valid_mask", "=", "valid_mask", "*", "torch", ".", "squeeze", "(", "mask", ")", ".", "float", "(", ")", "\n", "", "valid_mask", "=", "valid_mask", ".", "byte", "(", ")", ".", "detach", "(", ")", "\n", "if", "valid_mask", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "diff", "=", "diff", "[", "valid_mask", "]", "\n", "if", "diff", ".", "nelement", "(", ")", ">", "0", ":", "\n", "                ", "self", ".", "loss", "=", "diff", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\n", "\"warning: diff.nelement()==0 in PhotometricLoss (this is expected during early stage of training, try larger batch size).\"", "\n", ")", "\n", "self", ".", "loss", "=", "0", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "\"warning: 0 valid pixel in PhotometricLoss\"", ")", "\n", "self", ".", "loss", "=", "0", "\n", "", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.criteria.SmoothnessLoss.__init__": [[72, 74], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "SmoothnessLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.criteria.SmoothnessLoss.forward": [[75, 89], ["criteria.SmoothnessLoss.forward.second_derivative"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "depth", ")", ":", "\n", "        ", "def", "second_derivative", "(", "x", ")", ":", "\n", "            ", "assert", "x", ".", "dim", "(", "\n", ")", "==", "4", ",", "\"expected 4-dimensional data, but instead got {}\"", ".", "format", "(", "\n", "x", ".", "dim", "(", ")", ")", "\n", "horizontal", "=", "2", "*", "x", "[", ":", ",", ":", ",", "1", ":", "-", "1", ",", "1", ":", "-", "1", "]", "-", "x", "[", ":", ",", ":", ",", "1", ":", "-", "1", ",", ":", "\n", "-", "2", "]", "-", "x", "[", ":", ",", ":", ",", "1", ":", "-", "1", ",", "2", ":", "]", "\n", "vertical", "=", "2", "*", "x", "[", ":", ",", ":", ",", "1", ":", "-", "1", ",", "1", ":", "-", "1", "]", "-", "x", "[", ":", ",", ":", ",", ":", "-", "2", ",", "1", ":", "\n", "-", "1", "]", "-", "x", "[", ":", ",", ":", ",", "2", ":", ",", "1", ":", "-", "1", "]", "\n", "der_2nd", "=", "horizontal", ".", "abs", "(", ")", "+", "vertical", ".", "abs", "(", ")", "\n", "return", "der_2nd", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "loss", "=", "second_derivative", "(", "depth", ")", "\n", "return", "self", ".", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.Result.__init__": [[14, 30], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "irmse", "=", "0", "\n", "self", ".", "imae", "=", "0", "\n", "self", ".", "mse", "=", "0", "\n", "self", ".", "rmse", "=", "0", "\n", "self", ".", "mae", "=", "0", "\n", "self", ".", "absrel", "=", "0", "\n", "self", ".", "squared_rel", "=", "0", "\n", "self", ".", "lg10", "=", "0", "\n", "self", ".", "delta1", "=", "0", "\n", "self", ".", "delta2", "=", "0", "\n", "self", ".", "delta3", "=", "0", "\n", "self", ".", "data_time", "=", "0", "\n", "self", ".", "gpu_time", "=", "0", "\n", "self", ".", "silog", "=", "0", "# Scale invariant logarithmic error [log(m)*100]", "\n", "self", ".", "photometric", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.Result.set_to_worst": [[31, 46], ["None"], "methods", ["None"], ["", "def", "set_to_worst", "(", "self", ")", ":", "\n", "        ", "self", ".", "irmse", "=", "np", ".", "inf", "\n", "self", ".", "imae", "=", "np", ".", "inf", "\n", "self", ".", "mse", "=", "np", ".", "inf", "\n", "self", ".", "rmse", "=", "np", ".", "inf", "\n", "self", ".", "mae", "=", "np", ".", "inf", "\n", "self", ".", "absrel", "=", "np", ".", "inf", "\n", "self", ".", "squared_rel", "=", "np", ".", "inf", "\n", "self", ".", "lg10", "=", "np", ".", "inf", "\n", "self", ".", "silog", "=", "np", ".", "inf", "\n", "self", ".", "delta1", "=", "0", "\n", "self", ".", "delta2", "=", "0", "\n", "self", ".", "delta3", "=", "0", "\n", "self", ".", "data_time", "=", "0", "\n", "self", ".", "gpu_time", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.Result.update": [[47, 64], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "irmse", ",", "imae", ",", "mse", ",", "rmse", ",", "mae", ",", "absrel", ",", "squared_rel", ",", "lg10", ",", "delta1", ",", "delta2", ",", "delta3", ",", "gpu_time", ",", "data_time", ",", "silog", ",", "photometric", "=", "0", ")", ":", "\n", "        ", "self", ".", "irmse", "=", "irmse", "\n", "self", ".", "imae", "=", "imae", "\n", "self", ".", "mse", "=", "mse", "\n", "self", ".", "rmse", "=", "rmse", "\n", "self", ".", "mae", "=", "mae", "\n", "self", ".", "absrel", "=", "absrel", "\n", "self", ".", "squared_rel", "=", "squared_rel", "\n", "self", ".", "lg10", "=", "lg10", "\n", "self", ".", "delta1", "=", "delta1", "\n", "self", ".", "delta2", "=", "delta2", "\n", "self", ".", "delta3", "=", "delta3", "\n", "self", ".", "data_time", "=", "data_time", "\n", "self", ".", "gpu_time", "=", "gpu_time", "\n", "self", ".", "silog", "=", "silog", "\n", "self", ".", "photometric", "=", "photometric", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.Result.evaluate": [[65, 103], ["float", "math.sqrt", "float", "float", "float", "float", "torch.max", "float", "float", "float", "err_log.mean", "math.sqrt", "float", "float", "torch.pow().mean", "abs_diff.mean", "torch.log", "torch.log", "math.sqrt", "torch.pow().mean", "abs_inv_diff.mean", "torch.pow", "torch.pow", "metrics.log10", "metrics.log10"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.log10", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.log10"], ["# output is prediction, target is the GT", "\n", "", "def", "evaluate", "(", "self", ",", "output", ",", "target", ",", "photometric", "=", "0", ")", ":", "\n", "        ", "valid_mask", "=", "target", ">", "0.1", "\n", "\n", "# convert from meters to mm", "\n", "output_mm", "=", "1e3", "*", "output", "[", "valid_mask", "]", "\n", "target_mm", "=", "1e3", "*", "target", "[", "valid_mask", "]", "\n", "\n", "abs_diff", "=", "(", "output_mm", "-", "target_mm", ")", ".", "abs", "(", ")", "\n", "\n", "self", ".", "mse", "=", "float", "(", "(", "torch", ".", "pow", "(", "abs_diff", ",", "2", ")", ")", ".", "mean", "(", ")", ")", "# mse for the entire batch", "\n", "self", ".", "rmse", "=", "math", ".", "sqrt", "(", "self", ".", "mse", ")", "\n", "self", ".", "mae", "=", "float", "(", "abs_diff", ".", "mean", "(", ")", ")", "\n", "self", ".", "lg10", "=", "float", "(", "(", "log10", "(", "output_mm", ")", "-", "log10", "(", "target_mm", ")", ")", ".", "abs", "(", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "absrel", "=", "float", "(", "(", "abs_diff", "/", "target_mm", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "squared_rel", "=", "float", "(", "(", "(", "abs_diff", "/", "target_mm", ")", "**", "2", ")", ".", "mean", "(", ")", ")", "\n", "\n", "maxRatio", "=", "torch", ".", "max", "(", "output_mm", "/", "target_mm", ",", "target_mm", "/", "output_mm", ")", "\n", "self", ".", "delta1", "=", "float", "(", "(", "maxRatio", "<", "1.25", ")", ".", "float", "(", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "delta2", "=", "float", "(", "(", "maxRatio", "<", "1.25", "**", "2", ")", ".", "float", "(", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "delta3", "=", "float", "(", "(", "maxRatio", "<", "1.25", "**", "3", ")", ".", "float", "(", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "data_time", "=", "0", "\n", "self", ".", "gpu_time", "=", "0", "\n", "\n", "# silog uses meters", "\n", "err_log", "=", "torch", ".", "log", "(", "target", "[", "valid_mask", "]", ")", "-", "torch", ".", "log", "(", "output", "[", "valid_mask", "]", ")", "\n", "normalized_squared_log", "=", "(", "err_log", "**", "2", ")", ".", "mean", "(", ")", "\n", "log_mean", "=", "err_log", ".", "mean", "(", ")", "\n", "self", ".", "silog", "=", "math", ".", "sqrt", "(", "normalized_squared_log", "-", "\n", "log_mean", "*", "log_mean", ")", "*", "100", "\n", "\n", "# convert from meters to km", "\n", "inv_output_km", "=", "(", "1e-3", "*", "output", "[", "valid_mask", "]", ")", "**", "(", "-", "1", ")", "\n", "inv_target_km", "=", "(", "1e-3", "*", "target", "[", "valid_mask", "]", ")", "**", "(", "-", "1", ")", "\n", "abs_inv_diff", "=", "(", "inv_output_km", "-", "inv_target_km", ")", ".", "abs", "(", ")", "\n", "self", ".", "irmse", "=", "math", ".", "sqrt", "(", "(", "torch", ".", "pow", "(", "abs_inv_diff", ",", "2", ")", ")", ".", "mean", "(", ")", ")", "\n", "self", ".", "imae", "=", "float", "(", "abs_inv_diff", ".", "mean", "(", ")", ")", "\n", "\n", "self", ".", "photometric", "=", "float", "(", "photometric", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.__init__": [[106, 108], ["metrics.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.reset"], ["", "", "class", "AverageMeter", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.reset": [[109, 126], ["None"], "methods", ["None"], ["\n", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "count", "=", "0.0", "\n", "self", ".", "sum_irmse", "=", "0", "\n", "self", ".", "sum_imae", "=", "0", "\n", "self", ".", "sum_mse", "=", "0", "\n", "self", ".", "sum_rmse", "=", "0", "\n", "self", ".", "sum_mae", "=", "0", "\n", "self", ".", "sum_absrel", "=", "0", "\n", "self", ".", "sum_squared_rel", "=", "0", "\n", "self", ".", "sum_lg10", "=", "0", "\n", "self", ".", "sum_delta1", "=", "0", "\n", "self", ".", "sum_delta2", "=", "0", "\n", "self", ".", "sum_delta3", "=", "0", "\n", "self", ".", "sum_data_time", "=", "0", "\n", "self", ".", "sum_gpu_time", "=", "0", "\n", "self", ".", "sum_photometric", "=", "0", "\n", "self", ".", "sum_silog", "=", "0", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.update": [[127, 144], ["None"], "methods", ["None"], ["\n", "", "def", "update", "(", "self", ",", "result", ",", "gpu_time", ",", "data_time", ",", "n", "=", "1", ")", ":", "\n", "        ", "self", ".", "count", "+=", "n", "\n", "self", ".", "sum_irmse", "+=", "n", "*", "result", ".", "irmse", "\n", "self", ".", "sum_imae", "+=", "n", "*", "result", ".", "imae", "\n", "self", ".", "sum_mse", "+=", "n", "*", "result", ".", "mse", "\n", "self", ".", "sum_rmse", "+=", "n", "*", "result", ".", "rmse", "\n", "self", ".", "sum_mae", "+=", "n", "*", "result", ".", "mae", "\n", "self", ".", "sum_absrel", "+=", "n", "*", "result", ".", "absrel", "\n", "self", ".", "sum_squared_rel", "+=", "n", "*", "result", ".", "squared_rel", "\n", "self", ".", "sum_lg10", "+=", "n", "*", "result", ".", "lg10", "\n", "self", ".", "sum_delta1", "+=", "n", "*", "result", ".", "delta1", "\n", "self", ".", "sum_delta2", "+=", "n", "*", "result", ".", "delta2", "\n", "self", ".", "sum_delta3", "+=", "n", "*", "result", ".", "delta3", "\n", "self", ".", "sum_data_time", "+=", "n", "*", "data_time", "\n", "self", ".", "sum_gpu_time", "+=", "n", "*", "gpu_time", "\n", "self", ".", "sum_silog", "+=", "n", "*", "result", ".", "silog", "\n", "self", ".", "sum_photometric", "+=", "n", "*", "result", ".", "photometric", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.average": [[145, 158], ["metrics.Result", "metrics.Result.update"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.update"], ["\n", "", "def", "average", "(", "self", ")", ":", "\n", "        ", "avg", "=", "Result", "(", ")", "\n", "if", "self", ".", "count", ">", "0", ":", "\n", "            ", "avg", ".", "update", "(", "\n", "self", ".", "sum_irmse", "/", "self", ".", "count", ",", "self", ".", "sum_imae", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_mse", "/", "self", ".", "count", ",", "self", ".", "sum_rmse", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_mae", "/", "self", ".", "count", ",", "self", ".", "sum_absrel", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_squared_rel", "/", "self", ".", "count", ",", "self", ".", "sum_lg10", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_delta1", "/", "self", ".", "count", ",", "self", ".", "sum_delta2", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_delta3", "/", "self", ".", "count", ",", "self", ".", "sum_gpu_time", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_data_time", "/", "self", ".", "count", ",", "self", ".", "sum_silog", "/", "self", ".", "count", ",", "\n", "self", ".", "sum_photometric", "/", "self", ".", "count", ")", "\n", "", "return", "avg", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.log10": [[8, 11], ["torch.log"], "function", ["None"], ["def", "log10", "(", "x", ")", ":", "\n", "    ", "\"\"\"Convert a new tensor with the base-10 logarithm of the elements of x. \"\"\"", "\n", "return", "torch", ".", "log", "(", "x", ")", "/", "lg_e_10", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.__init__": [[17, 49], ["helper.get_folder_name", "metrics.Result", "helper.logger.best_result.set_to_worst", "os.path.join", "os.path.join", "os.path.exists", "os.makedirs", "os.path.join", "os.path.join", "print", "os.path.join", "helper.backup_source_code", "print", "open", "csv.DictWriter", "csv.DictWriter.writeheader", "open", "csv.DictWriter", "csv.DictWriter.writeheader"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.get_folder_name", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.Result.set_to_worst", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.backup_source_code"], ["        ", "self", ".", "args", "=", "args", "\n", "output_directory", "=", "get_folder_name", "(", "args", ")", "\n", "self", ".", "output_directory", "=", "output_directory", "\n", "self", ".", "best_result", "=", "Result", "(", ")", "\n", "self", ".", "best_result", ".", "set_to_worst", "(", ")", "\n", "\n", "if", "not", "prepare", ":", "\n", "            ", "return", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "output_directory", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "output_directory", ")", "\n", "", "self", ".", "train_csv", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "'train.csv'", ")", "\n", "self", ".", "val_csv", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "'val.csv'", ")", "\n", "self", ".", "best_txt", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "'best.txt'", ")", "\n", "\n", "# backup the source code", "\n", "if", "args", ".", "resume", "==", "''", ":", "\n", "            ", "print", "(", "\"=> creating source code backup ...\"", ")", "\n", "backup_directory", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "\"code_backup\"", ")", "\n", "self", ".", "backup_directory", "=", "backup_directory", "\n", "backup_source_code", "(", "backup_directory", ")", "\n", "# create new csv files with only header", "\n", "with", "open", "(", "self", ".", "train_csv", ",", "'w'", ")", "as", "csvfile", ":", "\n", "                ", "writer", "=", "csv", ".", "DictWriter", "(", "csvfile", ",", "fieldnames", "=", "fieldnames", ")", "\n", "writer", ".", "writeheader", "(", ")", "\n", "", "with", "open", "(", "self", ".", "val_csv", ",", "'w'", ")", "as", "csvfile", ":", "\n", "                ", "writer", "=", "csv", ".", "DictWriter", "(", "csvfile", ",", "fieldnames", "=", "fieldnames", ")", "\n", "writer", ".", "writeheader", "(", ")", "\n", "", "print", "(", "\"=> finished creating source code backup.\"", ")", "\n", "\n", "", "", "def", "conditional_print", "(", "self", ",", "split", ",", "i", ",", "epoch", ",", "total_epochs", ",", "lr", ",", "n_set", ",", "blk_avg_meter", ",", "\n", "avg_meter", ")", ":", "\n", "        ", "if", "(", "i", "+", "1", ")", "%", "self", ".", "args", ".", "print_freq", "==", "0", ":", "\n", "            ", "avg", "=", "avg_meter", ".", "average", "(", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_print": [[50, 79], ["avg_meter.average", "blk_avg_meter.average", "print", "print", "blk_avg_meter.reset", "split.capitalize"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.average", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.average", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.reset"], ["blk_avg", "=", "blk_avg_meter", ".", "average", "(", ")", "\n", "print", "(", "'=> output: {}'", ".", "format", "(", "self", ".", "output_directory", ")", ")", "\n", "print", "(", "\n", "'{split} Epoch: {}/{} [Batch {}/{}]\\tlr={lr} '", "\n", "'t_Data={blk_avg.data_time:.3f}({average.data_time:.3f}) '", "\n", "'t_GPU={blk_avg.gpu_time:.3f}({average.gpu_time:.3f})\\n\\t'", "\n", "'RMSE={blk_avg.rmse:.2f}({average.rmse:.2f}) '", "\n", "'MAE={blk_avg.mae:.2f}({average.mae:.2f}) '", "\n", "'iRMSE={blk_avg.irmse:.2f}({average.irmse:.2f}) '", "\n", "'iMAE={blk_avg.imae:.2f}({average.imae:.2f})\\n\\t'", "\n", "'silog={blk_avg.silog:.2f}({average.silog:.2f}) '", "\n", "'squared_rel={blk_avg.squared_rel:.2f}({average.squared_rel:.2f}) '", "\n", "'Delta1={blk_avg.delta1:.3f}({average.delta1:.3f}) '", "\n", "'Delta2={blk_avg.delta2:.3f}({average.delta2:.3f}) '", "\n", "'REL={blk_avg.absrel:.3f}({average.absrel:.3f})\\n\\t'", "\n", "'Lg10={blk_avg.lg10:.3f}({average.lg10:.3f}) '", "\n", "'Photometric={blk_avg.photometric:.3f}({average.photometric:.3f}) '", "\n", ".", "format", "(", "epoch", "+", "1", ",", "\n", "total_epochs", ",", "\n", "i", "+", "1", ",", "\n", "n_set", ",", "\n", "lr", "=", "lr", ",", "\n", "blk_avg", "=", "blk_avg", ",", "\n", "average", "=", "avg", ",", "\n", "split", "=", "split", ".", "capitalize", "(", ")", ")", ")", "\n", "blk_avg_meter", ".", "reset", "(", ")", "\n", "\n", "", "", "def", "conditional_save_info", "(", "self", ",", "split", ",", "average_meter", ",", "epoch", ")", ":", "\n", "        ", "avg", "=", "average_meter", ".", "average", "(", ")", "\n", "if", "split", "==", "\"train\"", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_save_info": [[80, 115], ["average_meter.average", "open", "csv.DictWriter", "csv.DictWriter.writerow", "os.path.join", "helper.logger.save_single_txt", "ValueError"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.metrics.AverageMeter.average", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_single_txt"], ["            ", "csvfile_name", "=", "self", ".", "train_csv", "\n", "", "elif", "split", "==", "\"val\"", ":", "\n", "            ", "csvfile_name", "=", "self", ".", "val_csv", "\n", "", "elif", "split", "==", "\"eval\"", ":", "\n", "            ", "eval_filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_directory", ",", "'eval.txt'", ")", "\n", "self", ".", "save_single_txt", "(", "eval_filename", ",", "avg", ",", "epoch", ")", "\n", "return", "avg", "\n", "", "elif", "\"test\"", "in", "split", ":", "\n", "            ", "return", "avg", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"wrong split provided to logger\"", ")", "\n", "", "with", "open", "(", "csvfile_name", ",", "'a'", ")", "as", "csvfile", ":", "\n", "            ", "writer", "=", "csv", ".", "DictWriter", "(", "csvfile", ",", "fieldnames", "=", "fieldnames", ")", "\n", "writer", ".", "writerow", "(", "{", "\n", "'epoch'", ":", "epoch", "+", "1", ",", "\n", "'rmse'", ":", "avg", ".", "rmse", ",", "\n", "'photo'", ":", "avg", ".", "photometric", ",", "\n", "'mae'", ":", "avg", ".", "mae", ",", "\n", "'irmse'", ":", "avg", ".", "irmse", ",", "\n", "'imae'", ":", "avg", ".", "imae", ",", "\n", "'mse'", ":", "avg", ".", "mse", ",", "\n", "'silog'", ":", "avg", ".", "silog", ",", "\n", "'squared_rel'", ":", "avg", ".", "squared_rel", ",", "\n", "'absrel'", ":", "avg", ".", "absrel", ",", "\n", "'lg10'", ":", "avg", ".", "lg10", ",", "\n", "'delta1'", ":", "avg", ".", "delta1", ",", "\n", "'delta2'", ":", "avg", ".", "delta2", ",", "\n", "'delta3'", ":", "avg", ".", "delta3", ",", "\n", "'gpu_time'", ":", "avg", ".", "gpu_time", ",", "\n", "'data_time'", ":", "avg", ".", "data_time", "\n", "}", ")", "\n", "", "return", "avg", "\n", "\n", "", "def", "save_single_txt", "(", "self", ",", "filename", ",", "result", ",", "epoch", ",", "total_epochs", ")", ":", "\n", "        ", "with", "open", "(", "filename", ",", "'w'", ")", "as", "txtfile", ":", "\n", "            ", "txtfile", ".", "write", "(", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_single_txt": [[116, 129], ["open", "txtfile.write"], "methods", ["None"], ["(", "\"rank_metric={}\\n\"", "+", "\"epoch={}/{}\\n\"", "+", "\"rmse={:.3f}\\n\"", "+", "\n", "\"mae={:.3f}\\n\"", "+", "\"silog={:.3f}\\n\"", "+", "\"squared_rel={:.3f}\\n\"", "+", "\n", "\"irmse={:.3f}\\n\"", "+", "\"imae={:.3f}\\n\"", "+", "\"mse={:.3f}\\n\"", "+", "\n", "\"absrel={:.3f}\\n\"", "+", "\"lg10={:.3f}\\n\"", "+", "\"delta1={:.3f}\\n\"", "+", "\"delta2={:.3f}\\n\"", "+", "\n", "\"t_gpu={:.4f}\"", ")", ".", "format", "(", "self", ".", "args", ".", "rank_metric", ",", "epoch", "+", "1", ",", "total_epochs", ",", "\n", "result", ".", "rmse", ",", "result", ".", "mae", ",", "result", ".", "silog", ",", "\n", "result", ".", "squared_rel", ",", "result", ".", "irmse", ",", "\n", "result", ".", "imae", ",", "result", ".", "mse", ",", "result", ".", "absrel", ",", "\n", "result", ".", "lg10", ",", "result", ".", "delta1", ",", "result", ".", "delta2", ",", "\n", "result", ".", "gpu_time", ")", ")", "\n", "\n", "", "", "def", "save_best_txt", "(", "self", ",", "result", ",", "epoch", ",", "total_epochs", ")", ":", "\n", "        ", "self", ".", "save_single_txt", "(", "self", ".", "best_txt", ",", "result", ",", "epoch", ",", "total_epochs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_best_txt": [[130, 132], ["helper.logger.save_single_txt"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_single_txt"], ["", "def", "_get_img_comparison_name", "(", "self", ",", "mode", ",", "epoch", ",", "is_best", "=", "False", ")", ":", "\n", "        ", "if", "mode", "==", "'eval'", ":", "\n", "            ", "return", "self", ".", "output_directory", "+", "'/comparison_eval.png'", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger._get_img_comparison_name": [[133, 142], ["str"], "methods", ["None"], ["", "if", "mode", "==", "'val'", ":", "\n", "            ", "if", "is_best", ":", "\n", "                ", "return", "self", ".", "output_directory", "+", "'/comparison_best.png'", "\n", "", "else", ":", "\n", "                ", "return", "self", ".", "output_directory", "+", "'/comparison_'", "+", "str", "(", "\n", "epoch", ")", "+", "'.png'", "\n", "\n", "", "", "", "def", "conditional_save_img_comparison", "(", "self", ",", "mode", ",", "i", ",", "ele", ",", "pred", ",", "epoch", ")", ":", "\n", "# save 8 images for visualization", "\n", "        ", "if", "mode", "==", "'val'", "or", "mode", "==", "'eval'", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_save_img_comparison": [[143, 155], ["vis_utils.merge_into_row", "vis_utils.merge_into_row", "vis_utils.add_row", "helper.logger._get_img_comparison_name", "vis_utils.save_image"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.merge_into_row", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.merge_into_row", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.add_row", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger._get_img_comparison_name", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.save_image"], ["            ", "skip", "=", "100", "\n", "if", "i", "==", "0", ":", "\n", "                ", "self", ".", "img_merge", "=", "vis_utils", ".", "merge_into_row", "(", "ele", ",", "pred", ")", "\n", "", "elif", "i", "%", "skip", "==", "0", "and", "i", "<", "8", "*", "skip", ":", "\n", "                ", "row", "=", "vis_utils", ".", "merge_into_row", "(", "ele", ",", "pred", ")", "\n", "self", ".", "img_merge", "=", "vis_utils", ".", "add_row", "(", "self", ".", "img_merge", ",", "row", ")", "\n", "", "elif", "i", "==", "8", "*", "skip", ":", "\n", "                ", "filename", "=", "self", ".", "_get_img_comparison_name", "(", "mode", ",", "epoch", ")", "\n", "vis_utils", ".", "save_image", "(", "self", ".", "img_merge", ",", "filename", ")", "\n", "\n", "", "", "", "def", "save_img_comparison_as_best", "(", "self", ",", "mode", ",", "epoch", ")", ":", "\n", "        ", "if", "mode", "==", "'val'", ":", "\n", "            ", "filename", "=", "self", ".", "_get_img_comparison_name", "(", "mode", ",", "epoch", ",", "is_best", "=", "True", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_img_comparison_as_best": [[156, 160], ["helper.logger._get_img_comparison_name", "vis_utils.save_image"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger._get_img_comparison_name", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.save_image"], ["vis_utils", ".", "save_image", "(", "self", ".", "img_merge", ",", "filename", ")", "\n", "\n", "", "", "def", "get_ranking_error", "(", "self", ",", "result", ")", ":", "\n", "        ", "return", "getattr", "(", "result", ",", "self", ".", "args", ".", "rank_metric", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.get_ranking_error": [[161, 163], ["getattr"], "methods", ["None"], ["", "def", "rank_conditional_save_best", "(", "self", ",", "mode", ",", "result", ",", "epoch", ",", "total_epochs", ")", ":", "\n", "        ", "error", "=", "self", ".", "get_ranking_error", "(", "result", ")", "\n", "best_error", "=", "self", ".", "get_ranking_error", "(", "self", ".", "best_result", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.rank_conditional_save_best": [[164, 173], ["helper.logger.get_ranking_error", "helper.logger.get_ranking_error", "helper.logger.save_best_txt"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.get_ranking_error", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.get_ranking_error", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.save_best_txt"], ["is_best", "=", "error", "<", "best_error", "\n", "if", "is_best", "and", "mode", "==", "\"val\"", ":", "\n", "            ", "self", ".", "old_best_result", "=", "self", ".", "best_result", "\n", "self", ".", "best_result", "=", "result", "\n", "self", ".", "save_best_txt", "(", "result", ",", "epoch", ",", "total_epochs", ")", "\n", "", "return", "is_best", "\n", "\n", "", "def", "conditional_save_pred", "(", "self", ",", "mode", ",", "i", ",", "pred", ",", "epoch", ")", ":", "\n", "        ", "if", "(", "\"test\"", "in", "mode", "or", "mode", "==", "\"eval\"", ")", "and", "self", ".", "args", ".", "save_pred", ":", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_save_pred": [[174, 185], ["os.path.join", "torch.squeeze().numpy", "os.path.join", "vis_utils.save_depth_as_uint16png", "os.path.exists", "os.makedirs", "torch.squeeze", "pred.data.cpu"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.vis_utils.save_depth_as_uint16png"], ["# save images for visualization/ testing", "\n", "            ", "image_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_directory", ",", "\n", "mode", "+", "\"_output\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "image_folder", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "image_folder", ")", "\n", "", "img", "=", "torch", ".", "squeeze", "(", "pred", ".", "data", ".", "cpu", "(", ")", ")", ".", "numpy", "(", ")", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "image_folder", ",", "'{0:010d}.png'", ".", "format", "(", "i", ")", ")", "\n", "vis_utils", ".", "save_depth_as_uint16png", "(", "img", ",", "filename", ")", "\n", "\n", "", "", "def", "conditional_summarize", "(", "self", ",", "mode", ",", "avg", ",", "is_best", ")", ":", "\n", "        ", "print", "(", "\"\\n*\\nSummary of\"", ",", "mode", ",", "\"round:\"", ")", "\n", "print", "(", "''", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.conditional_summarize": [[186, 209], ["print", "print", "print", "print", "print", "helper.logger.get_ranking_error", "helper.logger.get_ranking_error"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.get_ranking_error", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.logger.get_ranking_error"], ["'RMSE={average.rmse:.3f}\\n'", "\n", "'MAE={average.mae:.3f}\\n'", "\n", "'Photo={average.photometric:.3f}\\n'", "\n", "'iRMSE={average.irmse:.3f}\\n'", "\n", "'iMAE={average.imae:.3f}\\n'", "\n", "'squared_rel={average.squared_rel}\\n'", "\n", "'silog={average.silog}\\n'", "\n", "'Delta1={average.delta1:.3f}\\n'", "\n", "'Delta2={average.delta2:.3f}\\n'", "\n", "'REL={average.absrel:.3f}\\n'", "\n", "'Lg10={average.lg10:.3f}\\n'", "\n", "'t_GPU={time:.3f}'", ".", "format", "(", "average", "=", "avg", ",", "time", "=", "avg", ".", "gpu_time", ")", ")", "\n", "if", "is_best", "and", "mode", "==", "\"val\"", ":", "\n", "            ", "print", "(", "\"New best model by %s (was %.3f)\"", "%", "\n", "(", "self", ".", "args", ".", "rank_metric", ",", "\n", "self", ".", "get_ranking_error", "(", "self", ".", "old_best_result", ")", ")", ")", "\n", "", "elif", "mode", "==", "\"val\"", ":", "\n", "            ", "print", "(", "\"(best %s is %.3f)\"", "%", "\n", "(", "self", ".", "args", ".", "rank_metric", ",", "\n", "self", ".", "get_ranking_error", "(", "self", ".", "best_result", ")", ")", ")", "\n", "", "print", "(", "\"*\\n\"", ")", "\n", "\n", "\n", "", "", "ignore_hidden", "=", "shutil", ".", "ignore_patterns", "(", "\".\"", ",", "\"..\"", ",", "\".git*\"", ",", "\"*pycache*\"", ",", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.backup_source_code": [[215, 219], ["os.path.exists", "shutil.copytree", "shutil.rmtree"], "function", ["None"], ["        ", "shutil", ".", "rmtree", "(", "backup_directory", ")", "\n", "", "shutil", ".", "copytree", "(", "'.'", ",", "backup_directory", ",", "ignore", "=", "ignore_hidden", ")", "\n", "\n", "\n", "", "def", "adjust_learning_rate", "(", "lr_init", ",", "optimizer", ",", "epoch", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.adjust_learning_rate": [[221, 227], ["None"], "function", ["None"], ["lr", "=", "lr_init", "*", "(", "0.1", "**", "(", "epoch", "//", "5", ")", ")", "\n", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "        ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "", "return", "lr", "\n", "\n", "\n", "", "def", "save_checkpoint", "(", "state", ",", "is_best", ",", "epoch", ",", "output_directory", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.save_checkpoint": [[229, 241], ["os.path.join", "torch.save", "os.path.join", "shutil.copyfile", "os.path.join", "os.path.exists", "os.remove", "str", "str"], "function", ["None"], ["'checkpoint-'", "+", "str", "(", "epoch", ")", "+", "'.pth.tar'", ")", "\n", "torch", ".", "save", "(", "state", ",", "checkpoint_filename", ")", "\n", "if", "is_best", ":", "\n", "        ", "best_filename", "=", "os", ".", "path", ".", "join", "(", "output_directory", ",", "'model_best.pth.tar'", ")", "\n", "shutil", ".", "copyfile", "(", "checkpoint_filename", ",", "best_filename", ")", "\n", "", "if", "epoch", ">", "0", ":", "\n", "        ", "prev_checkpoint_filename", "=", "os", ".", "path", ".", "join", "(", "\n", "output_directory", ",", "'checkpoint-'", "+", "str", "(", "epoch", "-", "1", ")", "+", "'.pth.tar'", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "prev_checkpoint_filename", ")", ":", "\n", "            ", "os", ".", "remove", "(", "prev_checkpoint_filename", ")", "\n", "\n", "\n", "", "", "", "def", "get_folder_name", "(", "args", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.get_folder_name": [[243, 251], ["time.strftime", "os.path.join"], "function", ["None"], ["if", "args", ".", "use_pose", ":", "\n", "        ", "prefix", "=", "\"var.mode={}.w1={}.w2={}.\"", ".", "format", "(", "args", ".", "train_mode", ",", "args", ".", "w1", ",", "args", ".", "w2", ")", "\n", "", "elif", "args", ".", "sample_method", "!=", "''", ":", "\n", "        ", "prefix", "=", "\"var.mode={}.budget={}.samp.method={}.\"", ".", "format", "(", "args", ".", "train_mode", ",", "args", ".", "budget", ",", "args", ".", "sample_method", ")", "\n", "", "else", ":", "\n", "        ", "prefix", "=", "\"var.mode={}.budget={}.\"", ".", "format", "(", "args", ".", "train_mode", ",", "args", ".", "budget", ")", "\n", "", "return", "os", ".", "path", ".", "join", "(", "args", ".", "result", ",", "\n", "prefix", "+", "'input={}.resnet{}.bs={}.pretrained={}.time={}'", ".", "\n", "format", "(", "args", ".", "input", ",", "args", ".", "layers", ",", "args", ".", "batch_size", ",", "args", ".", "pretrained", ",", "current_time", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.helper.multiscale": [[256, 263], ["avgpool", "avgpool", "avgpool", "avgpool", "avgpool"], "function", ["None"], ["\n", "\n", "def", "multiscale", "(", "img", ")", ":", "\n", "    ", "img1", "=", "avgpool", "(", "img", ")", "\n", "img2", "=", "avgpool", "(", "img1", ")", "\n", "img3", "=", "avgpool", "(", "img2", ")", "\n", "img4", "=", "avgpool", "(", "img3", ")", "\n", "img5", "=", "avgpool", "(", "img4", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.DepthCompletionNet.__init__": [[71, 161], ["torch.Module.__init__", "model.conv_bn_relu", "model.convt_bn_relu", "model.convt_bn_relu", "model.convt_bn_relu", "model.convt_bn_relu", "model.convt_bn_relu", "model.conv_bn_relu", "model.conv_bn_relu", "model.conv_bn_relu", "pretrained_model.apply", "len", "len", "model.conv_bn_relu", "len"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu"], ["        ", "assert", "(", "\n", "args", ".", "layers", "in", "[", "18", ",", "34", ",", "50", ",", "101", ",", "152", "]", "\n", ")", ",", "'Only layers 18, 34, 50, 101, and 152 are defined, but got {}'", ".", "format", "(", "\n", "args", ".", "layers", ")", "\n", "super", "(", "DepthCompletionNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "modality", "=", "args", ".", "input", "\n", "\n", "if", "'d'", "in", "self", ".", "modality", ":", "\n", "            ", "channels", "=", "64", "//", "len", "(", "self", ".", "modality", ")", "\n", "self", ".", "conv1_d", "=", "conv_bn_relu", "(", "1", ",", "\n", "channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "", "if", "'rgb'", "in", "self", ".", "modality", ":", "\n", "            ", "channels", "=", "64", "*", "3", "//", "len", "(", "self", ".", "modality", ")", "\n", "self", ".", "conv1_img", "=", "conv_bn_relu", "(", "3", ",", "\n", "channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "", "elif", "'g'", "in", "self", ".", "modality", ":", "\n", "            ", "channels", "=", "64", "//", "len", "(", "self", ".", "modality", ")", "\n", "self", ".", "conv1_img", "=", "conv_bn_relu", "(", "1", ",", "\n", "channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "\n", "", "pretrained_model", "=", "resnet", ".", "__dict__", "[", "'resnet{}'", ".", "format", "(", "\n", "args", ".", "layers", ")", "]", "(", "pretrained", "=", "args", ".", "pretrained", ")", "\n", "if", "not", "args", ".", "pretrained", ":", "\n", "            ", "pretrained_model", ".", "apply", "(", "init_weights", ")", "\n", "#self.maxpool = pretrained_model._modules['maxpool']", "\n", "", "self", ".", "conv2", "=", "pretrained_model", ".", "_modules", "[", "'layer1'", "]", "\n", "self", ".", "conv3", "=", "pretrained_model", ".", "_modules", "[", "'layer2'", "]", "\n", "self", ".", "conv4", "=", "pretrained_model", ".", "_modules", "[", "'layer3'", "]", "\n", "self", ".", "conv5", "=", "pretrained_model", ".", "_modules", "[", "'layer4'", "]", "\n", "del", "pretrained_model", "# clear memory", "\n", "\n", "# define number of intermediate channels", "\n", "if", "args", ".", "layers", "<=", "34", ":", "\n", "            ", "num_channels", "=", "512", "\n", "", "elif", "args", ".", "layers", ">=", "50", ":", "\n", "            ", "num_channels", "=", "2048", "\n", "", "self", ".", "conv6", "=", "conv_bn_relu", "(", "num_channels", ",", "\n", "512", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ")", "\n", "\n", "# decoding layers", "\n", "kernel_size", "=", "3", "\n", "stride", "=", "2", "\n", "self", ".", "convt5", "=", "convt_bn_relu", "(", "in_channels", "=", "512", ",", "\n", "out_channels", "=", "256", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "output_padding", "=", "1", ")", "\n", "self", ".", "convt4", "=", "convt_bn_relu", "(", "in_channels", "=", "768", ",", "\n", "out_channels", "=", "128", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "output_padding", "=", "1", ")", "\n", "self", ".", "convt3", "=", "convt_bn_relu", "(", "in_channels", "=", "(", "256", "+", "128", ")", ",", "\n", "out_channels", "=", "64", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "output_padding", "=", "1", ")", "\n", "self", ".", "convt2", "=", "convt_bn_relu", "(", "in_channels", "=", "(", "128", "+", "64", ")", ",", "\n", "out_channels", "=", "64", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "output_padding", "=", "1", ")", "\n", "self", ".", "convt1", "=", "convt_bn_relu", "(", "in_channels", "=", "128", ",", "\n", "out_channels", "=", "64", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "convtf", "=", "conv_bn_relu", "(", "in_channels", "=", "128", ",", "\n", "out_channels", "=", "1", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "bn", "=", "False", ",", "\n", "relu", "=", "False", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.DepthCompletionNet.forward": [[162, 207], ["model.DepthCompletionNet.conv2", "model.DepthCompletionNet.conv3", "model.DepthCompletionNet.conv4", "model.DepthCompletionNet.conv5", "model.DepthCompletionNet.conv6", "model.DepthCompletionNet.convt5", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convt4", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convt3", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convt2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convt1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.convtf", "model.DepthCompletionNet.conv1_d", "model.DepthCompletionNet.conv1_img", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.DepthCompletionNet.conv1_img", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["# first layer", "\n", "        ", "if", "'d'", "in", "self", ".", "modality", ":", "\n", "            ", "conv1_d", "=", "self", ".", "conv1_d", "(", "x", "[", "'d'", "]", ")", "\n", "", "if", "'rgb'", "in", "self", ".", "modality", ":", "\n", "            ", "conv1_img", "=", "self", ".", "conv1_img", "(", "x", "[", "'rgb'", "]", ")", "\n", "", "elif", "'g'", "in", "self", ".", "modality", ":", "\n", "            ", "conv1_img", "=", "self", ".", "conv1_img", "(", "x", "[", "'g'", "]", ")", "\n", "\n", "", "if", "self", ".", "modality", "==", "'rgbd'", "or", "self", ".", "modality", "==", "'gd'", ":", "\n", "            ", "conv1", "=", "torch", ".", "cat", "(", "(", "conv1_d", ",", "conv1_img", ")", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "conv1", "=", "conv1_d", "if", "(", "self", ".", "modality", "==", "'d'", ")", "else", "conv1_img", "\n", "\n", "", "conv2", "=", "self", ".", "conv2", "(", "conv1", ")", "\n", "conv3", "=", "self", ".", "conv3", "(", "conv2", ")", "# batchsize * ? * 176 * 608", "\n", "conv4", "=", "self", ".", "conv4", "(", "conv3", ")", "# batchsize * ? * 88 * 304", "\n", "conv5", "=", "self", ".", "conv5", "(", "conv4", ")", "# batchsize * ? * 44 * 152", "\n", "conv6", "=", "self", ".", "conv6", "(", "conv5", ")", "# batchsize * ? * 22 * 76", "\n", "\n", "# decoder", "\n", "convt5", "=", "self", ".", "convt5", "(", "conv6", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt5", ",", "conv5", ")", ",", "1", ")", "\n", "\n", "convt4", "=", "self", ".", "convt4", "(", "y", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt4", ",", "conv4", ")", ",", "1", ")", "\n", "\n", "convt3", "=", "self", ".", "convt3", "(", "y", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt3", ",", "conv3", ")", ",", "1", ")", "\n", "\n", "convt2", "=", "self", ".", "convt2", "(", "y", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt2", ",", "conv2", ")", ",", "1", ")", "\n", "\n", "convt1", "=", "self", ".", "convt1", "(", "y", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "convt1", ",", "conv1", ")", ",", "1", ")", "\n", "\n", "y", "=", "self", ".", "convtf", "(", "y", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "return", "100", "*", "y", "# output can be nagative & zero", "\n", "", "else", ":", "# during eval", "\n", "            ", "min_distance", "=", "0.9", "\n", "return", "F", ".", "relu", "(", "\n", "100", "*", "y", "-", "min_distance", "\n", ")", "+", "min_distance", "# the minimum range of Velodyne is around 3 feet ~= 0.9m", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.init_weights": [[9, 21], ["isinstance", "isinstance", "m.weight.data.normal_", "isinstance", "m.bias.data.zero_", "m.weight.data.normal_", "isinstance", "m.bias.data.zero_", "m.weight.data.fill_", "m.bias.data.zero_"], "function", ["None"], ["    ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "        ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "1e-3", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "            ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "        ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "1e-3", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "            ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "        ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "", "", "def", "conv_bn_relu", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ","]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.conv_bn_relu": [[22, 44], ["nn.Sequential.append", "torch.Sequential", "nn.Sequential.modules", "torch.Conv2d", "nn.Sequential.append", "nn.Sequential.append", "model.init_weights", "torch.BatchNorm2d", "torch.LeakyReLU"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.init_weights"], ["stride", "=", "1", ",", "padding", "=", "0", ",", "bn", "=", "True", ",", "relu", "=", "True", ")", ":", "\n", "    ", "bias", "=", "not", "bn", "\n", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", ",", "\n", "padding", ",", "\n", "bias", "=", "bias", ")", ")", "\n", "if", "bn", ":", "\n", "        ", "layers", ".", "append", "(", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", ")", "\n", "", "if", "relu", ":", "\n", "        ", "layers", ".", "append", "(", "nn", ".", "LeakyReLU", "(", "0.2", ",", "inplace", "=", "True", ")", ")", "\n", "", "layers", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "# initialize the weights", "\n", "for", "m", "in", "layers", ".", "modules", "(", ")", ":", "\n", "        ", "init_weights", "(", "m", ")", "\n", "\n", "", "return", "layers", "\n", "\n", "", "def", "convt_bn_relu", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ","]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.convt_bn_relu": [[45, 68], ["nn.Sequential.append", "torch.Sequential", "nn.Sequential.modules", "torch.ConvTranspose2d", "nn.Sequential.append", "nn.Sequential.append", "model.init_weights", "torch.BatchNorm2d", "torch.LeakyReLU"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.model.init_weights"], ["stride", "=", "1", ",", "padding", "=", "0", ",", "output_padding", "=", "0", ",", "bn", "=", "True", ",", "relu", "=", "True", ")", ":", "\n", "    ", "bias", "=", "not", "bn", "\n", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "nn", ".", "ConvTranspose2d", "(", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", ",", "\n", "stride", ",", "\n", "padding", ",", "\n", "output_padding", ",", "\n", "bias", "=", "bias", ")", ")", "\n", "if", "bn", ":", "\n", "        ", "layers", ".", "append", "(", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", ")", "\n", "", "if", "relu", ":", "\n", "        ", "layers", ".", "append", "(", "nn", ".", "LeakyReLU", "(", "0.2", ",", "inplace", "=", "True", ")", ")", "\n", "", "layers", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "# initialize the weights", "\n", "for", "m", "in", "layers", ".", "modules", "(", ")", ":", "\n", "        ", "init_weights", "(", "m", ")", "\n", "\n", "", "return", "layers", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.__init__": [[6, 24], ["torch.arange().expand().float", "torch.arange().expand().float", "torch.arange().expand().float", "torch.arange().expand().float", "torch.arange().expand().t().float", "torch.arange().expand().t().float", "torch.arange().expand().t().float", "torch.arange().expand().t().float", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand().t", "torch.arange().expand().t", "torch.arange().expand().t", "torch.arange().expand().t", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "width", ",", "height", ",", "fu", ",", "fv", ",", "cu", "=", "0", ",", "cv", "=", "0", ")", ":", "\n", "        ", "self", ".", "height", ",", "self", ".", "width", "=", "height", ",", "width", "\n", "self", ".", "fu", ",", "self", ".", "fv", "=", "fu", ",", "fv", "# fu, fv: focal length along the horizontal and vertical axes", "\n", "\n", "# cu, cv: optical center along the horizontal and vertical axes", "\n", "self", ".", "cu", "=", "cu", "if", "cu", ">", "0", "else", "(", "width", "-", "1", ")", "/", "2.0", "\n", "self", ".", "cv", "=", "cv", "if", "cv", ">", "0", "else", "(", "height", "-", "1", ")", "/", "2.0", "\n", "\n", "# U, V represent the homogeneous horizontal and vertical coordinates in the pixel space", "\n", "self", ".", "U", "=", "torch", ".", "arange", "(", "start", "=", "0", ",", "end", "=", "width", ")", ".", "expand", "(", "height", ",", "width", ")", ".", "float", "(", ")", "\n", "self", ".", "V", "=", "torch", ".", "arange", "(", "start", "=", "0", ",", "end", "=", "height", ")", ".", "expand", "(", "width", ",", "\n", "height", ")", ".", "t", "(", ")", ".", "float", "(", ")", "\n", "\n", "# X_cam, Y_cam represent the homogeneous x, y coordinates (assuming depth z=1) in the camera coordinate system", "\n", "self", ".", "X_cam", "=", "(", "self", ".", "U", "-", "self", ".", "cu", ")", "/", "self", ".", "fu", "\n", "self", ".", "Y_cam", "=", "(", "self", ".", "V", "-", "self", ".", "cv", ")", "/", "self", ".", "fv", "\n", "\n", "self", ".", "is_cuda", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.cuda": [[25, 30], ["inverse_warp.Intrinsics.X_cam.data.cuda", "inverse_warp.Intrinsics.Y_cam.data.cuda"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.cuda", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.cuda"], ["", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "self", ".", "X_cam", ".", "data", "=", "self", ".", "X_cam", ".", "data", ".", "cuda", "(", ")", "\n", "self", ".", "Y_cam", ".", "data", "=", "self", ".", "Y_cam", ".", "data", ".", "cuda", "(", ")", "\n", "self", ".", "is_cuda", "=", "True", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.scale": [[31, 43], ["inverse_warp.Intrinsics", "float", "float", "inverse_warp.Intrinsics.cuda"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.cuda"], ["", "def", "scale", "(", "self", ",", "height", ",", "width", ")", ":", "\n", "# return a new set of corresponding intrinsic parameters for the scaled image", "\n", "        ", "ratio_u", "=", "float", "(", "width", ")", "/", "self", ".", "width", "\n", "ratio_v", "=", "float", "(", "height", ")", "/", "self", ".", "height", "\n", "fu", "=", "ratio_u", "*", "self", ".", "fu", "\n", "fv", "=", "ratio_v", "*", "self", ".", "fv", "\n", "cu", "=", "ratio_u", "*", "self", ".", "cu", "\n", "cv", "=", "ratio_v", "*", "self", ".", "cv", "\n", "new_intrinsics", "=", "Intrinsics", "(", "width", ",", "height", ",", "fu", ",", "fv", ",", "cu", ",", "cv", ")", "\n", "if", "self", ".", "is_cuda", ":", "\n", "            ", "new_intrinsics", ".", "cuda", "(", ")", "\n", "", "return", "new_intrinsics", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.Intrinsics.__print__": [[44, 48], ["print"], "methods", ["None"], ["", "def", "__print__", "(", "self", ")", ":", "\n", "        ", "print", "(", "'size=({},{})\\nfocal length=({},{})\\noptical center=({},{})'", ".", "\n", "format", "(", "self", ".", "height", ",", "self", ".", "width", ",", "self", ".", "fv", ",", "self", ".", "fu", ",", "self", ".", "cv", ",", "\n", "self", ".", "cu", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.image_to_pointcloud": [[50, 57], ["torch.cat", "torch.cat", "depth.dim", "depth.size"], "function", ["None"], ["", "", "def", "image_to_pointcloud", "(", "depth", ",", "intrinsics", ")", ":", "\n", "    ", "assert", "depth", ".", "dim", "(", ")", "==", "4", "\n", "assert", "depth", ".", "size", "(", "1", ")", "==", "1", "\n", "\n", "X", "=", "depth", "*", "intrinsics", ".", "X_cam", "\n", "Y", "=", "depth", "*", "intrinsics", ".", "Y_cam", "\n", "return", "torch", ".", "cat", "(", "(", "X", ",", "Y", ",", "depth", ")", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.pointcloud_to_image": [[59, 89], ["pointcloud.size", "pointcloud[].clamp", "torch.stack", "torch.stack", "torch.stack.view", "pointcloud.dim"], "function", ["None"], ["", "def", "pointcloud_to_image", "(", "pointcloud", ",", "intrinsics", ")", ":", "\n", "    ", "assert", "pointcloud", ".", "dim", "(", ")", "==", "4", "\n", "\n", "batch_size", "=", "pointcloud", ".", "size", "(", "0", ")", "\n", "X", "=", "pointcloud", "[", ":", ",", "0", ",", ":", ",", ":", "]", "#.view(batch_size, -1)", "\n", "Y", "=", "pointcloud", "[", ":", ",", "1", ",", ":", ",", ":", "]", "#.view(batch_size, -1)", "\n", "Z", "=", "pointcloud", "[", ":", ",", "2", ",", ":", ",", ":", "]", ".", "clamp", "(", "min", "=", "1e-3", ")", "#.view(batch_size, -1)", "\n", "\n", "# compute pixel coordinates", "\n", "U_proj", "=", "intrinsics", ".", "fu", "*", "X", "/", "Z", "+", "intrinsics", ".", "cu", "# horizontal pixel coordinate", "\n", "V_proj", "=", "intrinsics", ".", "fv", "*", "Y", "/", "Z", "+", "intrinsics", ".", "cv", "# vertical pixel coordinate", "\n", "\n", "# normalization to [-1, 1], required by torch.nn.functional.grid_sample", "\n", "U_proj_normalized", "=", "(", "2", "*", "U_proj", "/", "(", "intrinsics", ".", "width", "-", "1", ")", "-", "1", ")", ".", "view", "(", "\n", "batch_size", ",", "-", "1", ")", "\n", "V_proj_normalized", "=", "(", "2", "*", "V_proj", "/", "(", "intrinsics", ".", "height", "-", "1", ")", "-", "1", ")", ".", "view", "(", "\n", "batch_size", ",", "-", "1", ")", "\n", "\n", "# This was important since PyTorch didn't do as it claimed for points out of boundary", "\n", "# See https://github.com/ClementPinard/SfmLearner-Pytorch/blob/master/inverse_warp.py", "\n", "# Might not be necessary any more", "\n", "U_proj_mask", "=", "(", "(", "U_proj_normalized", ">", "1", ")", "+", "(", "U_proj_normalized", "<", "-", "1", ")", ")", ".", "detach", "(", ")", "\n", "U_proj_normalized", "[", "U_proj_mask", "]", "=", "2", "\n", "V_proj_mask", "=", "(", "(", "V_proj_normalized", ">", "1", ")", "+", "(", "V_proj_normalized", "<", "-", "1", ")", ")", ".", "detach", "(", ")", "\n", "V_proj_normalized", "[", "V_proj_mask", "]", "=", "2", "\n", "\n", "pixel_coords", "=", "torch", ".", "stack", "(", "[", "U_proj_normalized", ",", "V_proj_normalized", "]", ",", "\n", "dim", "=", "2", ")", "# [B, H*W, 2]", "\n", "return", "pixel_coords", ".", "view", "(", "batch_size", ",", "intrinsics", ".", "height", ",", "intrinsics", ".", "width", ",", "\n", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.batch_multiply": [[91, 99], ["batch_scalar.size", "batch_matrix.clone", "range"], "function", ["None"], ["", "def", "batch_multiply", "(", "batch_scalar", ",", "batch_matrix", ")", ":", "\n", "# input: batch_scalar of size b, batch_matrix of size b * 3 * 3", "\n", "# output: batch_matrix of size b * 3 * 3", "\n", "    ", "batch_size", "=", "batch_scalar", ".", "size", "(", "0", ")", "\n", "output", "=", "batch_matrix", ".", "clone", "(", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "output", "[", "i", "]", "=", "batch_scalar", "[", "i", "]", "*", "batch_matrix", "[", "i", "]", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.transform_curr_to_near": [[101, 116], ["pointcloud_curr.size", "torch.bmm", "torch.bmm", "torch.cat", "torch.cat", "pointcloud_curr.view", "t_vec[].unsqueeze", "t_vec[].unsqueeze", "t_vec[].unsqueeze"], "function", ["None"], ["", "def", "transform_curr_to_near", "(", "pointcloud_curr", ",", "r_mat", ",", "t_vec", ",", "intrinsics", ")", ":", "\n", "# translation and rotmat represent the transformation from tgt pose to src pose", "\n", "    ", "batch_size", "=", "pointcloud_curr", ".", "size", "(", "0", ")", "\n", "XYZ_", "=", "torch", ".", "bmm", "(", "r_mat", ",", "pointcloud_curr", ".", "view", "(", "batch_size", ",", "3", ",", "-", "1", ")", ")", "\n", "\n", "X", "=", "(", "XYZ_", "[", ":", ",", "0", ",", ":", "]", "+", "t_vec", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", ")", ".", "view", "(", "\n", "-", "1", ",", "1", ",", "intrinsics", ".", "height", ",", "intrinsics", ".", "width", ")", "\n", "Y", "=", "(", "XYZ_", "[", ":", ",", "1", ",", ":", "]", "+", "t_vec", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", ")", ".", "view", "(", "\n", "-", "1", ",", "1", ",", "intrinsics", ".", "height", ",", "intrinsics", ".", "width", ")", "\n", "Z", "=", "(", "XYZ_", "[", ":", ",", "2", ",", ":", "]", "+", "t_vec", "[", ":", ",", "2", "]", ".", "unsqueeze", "(", "1", ")", ")", ".", "view", "(", "\n", "-", "1", ",", "1", ",", "intrinsics", ".", "height", ",", "intrinsics", ".", "width", ")", "\n", "\n", "pointcloud_near", "=", "torch", ".", "cat", "(", "(", "X", ",", "Y", ",", "Z", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "pointcloud_near", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.homography_from": [[118, 135], ["r_mat.view.view", "t_vec.view.view", "inverse_warp.image_to_pointcloud", "inverse_warp.transform_curr_to_near", "inverse_warp.pointcloud_to_image", "torch.grid_sample"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.image_to_pointcloud", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.transform_curr_to_near", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.varNN-test.inverse_warp.pointcloud_to_image"], ["", "def", "homography_from", "(", "rgb_near", ",", "depth_curr", ",", "r_mat", ",", "t_vec", ",", "intrinsics", ")", ":", "\n", "# inverse warp the RGB image from the nearby frame to the current frame", "\n", "\n", "# to ensure dimension consistency", "\n", "    ", "r_mat", "=", "r_mat", ".", "view", "(", "-", "1", ",", "3", ",", "3", ")", "\n", "t_vec", "=", "t_vec", ".", "view", "(", "-", "1", ",", "3", ")", "\n", "\n", "# compute source pixel coordinate", "\n", "pointcloud_curr", "=", "image_to_pointcloud", "(", "depth_curr", ",", "intrinsics", ")", "\n", "pointcloud_near", "=", "transform_curr_to_near", "(", "pointcloud_curr", ",", "r_mat", ",", "t_vec", ",", "\n", "intrinsics", ")", "\n", "pixel_coords_near", "=", "pointcloud_to_image", "(", "pointcloud_near", ",", "intrinsics", ")", "\n", "\n", "# the warping", "\n", "warped", "=", "F", ".", "grid_sample", "(", "rgb_near", ",", "pixel_coords_near", ")", "\n", "\n", "return", "warped", "\n", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Compose.__init__": [[189, 191], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transforms", ")", ":", "\n", "        ", "self", ".", "transforms", "=", "transforms", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Compose.__call__": [[192, 196], ["t"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "img", "=", "t", "(", "img", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.ToTensor.__call__": [[203, 227], ["isinstance", "transforms._is_numpy_image", "TypeError", "torch.from_numpy", "type", "torch.from_numpy.transpose().copy", "torch.from_numpy", "RuntimeError", "torch.from_numpy.copy", "torch.from_numpy.transpose"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_numpy_image"], ["def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Convert a ``numpy.ndarray`` to tensor.\n\n        Args:\n            img (numpy.ndarray): Image to be converted to tensor.\n\n        Returns:\n            Tensor: Converted image.\n        \"\"\"", "\n", "if", "not", "(", "_is_numpy_image", "(", "img", ")", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'img should be ndarray. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "\n", "", "if", "isinstance", "(", "img", ",", "np", ".", "ndarray", ")", ":", "\n", "# handle numpy array", "\n", "            ", "if", "img", ".", "ndim", "==", "3", ":", "\n", "                ", "img", "=", "torch", ".", "from_numpy", "(", "img", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", ".", "copy", "(", ")", ")", "\n", "", "elif", "img", ".", "ndim", "==", "2", ":", "\n", "                ", "img", "=", "torch", ".", "from_numpy", "(", "img", ".", "copy", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "'img should be ndarray with 2 or 3 dimensions. Got {}'", ".", "\n", "format", "(", "img", ".", "ndim", ")", ")", "\n", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.NormalizeNumpyArray.__init__": [[239, 242], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "self", ".", "std", "=", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.NormalizeNumpyArray.__call__": [[243, 258], ["print", "range", "transforms._is_numpy_image", "TypeError", "type"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_numpy_image"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (numpy.ndarray): Image of size (H, W, C) to be normalized.\n\n        Returns:\n            Tensor: Normalized image.\n        \"\"\"", "\n", "if", "not", "(", "_is_numpy_image", "(", "img", ")", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'img should be ndarray. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "# TODO: make efficient", "\n", "", "print", "(", "img", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "            ", "img", "[", ":", ",", ":", ",", "i", "]", "=", "(", "img", "[", ":", ",", ":", ",", "i", "]", "-", "self", ".", "mean", "[", "i", "]", ")", "/", "self", ".", "std", "[", "i", "]", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.NormalizeTensor.__init__": [[270, 273], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "self", ".", "std", "=", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.NormalizeTensor.__call__": [[274, 288], ["zip", "transforms._is_tensor_image", "TypeError", "t.sub_().div_", "t.sub_"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_tensor_image"], ["", "def", "__call__", "(", "self", ",", "tensor", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            tensor (Tensor): Tensor image of size (C, H, W) to be normalized.\n\n        Returns:\n            Tensor: Normalized Tensor image.\n        \"\"\"", "\n", "if", "not", "_is_tensor_image", "(", "tensor", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'tensor is not a torch image.'", ")", "\n", "# TODO: make efficient", "\n", "", "for", "t", ",", "m", ",", "s", "in", "zip", "(", "tensor", ",", "self", ".", "mean", ",", "self", ".", "std", ")", ":", "\n", "            ", "t", ".", "sub_", "(", "m", ")", ".", "div_", "(", "s", ")", "\n", "", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Rotate.__init__": [[296, 298], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "angle", ")", ":", "\n", "        ", "self", ".", "angle", "=", "angle", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Rotate.__call__": [[299, 310], ["skimage.transform.rotate"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (numpy.ndarray (C x H x W)): Image to be rotated.\n\n        Returns:\n            img (numpy.ndarray (C x H x W)): Rotated image.\n        \"\"\"", "\n", "\n", "# order=0 means nearest-neighbor type interpolation", "\n", "return", "skimage", ".", "transform", ".", "rotate", "(", "img", ",", "self", ".", "angle", ",", "resize", "=", "False", ",", "order", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Resize.__init__": [[323, 327], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", ",", "interpolation", "=", "'nearest'", ")", ":", "\n", "        ", "assert", "isinstance", "(", "size", ",", "float", ")", "\n", "self", ".", "size", "=", "size", "\n", "self", ".", "interpolation", "=", "interpolation", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Resize.__call__": [[328, 343], ["skimage.transform.rescale", "skimage.transform.rescale", "RuntimeError"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (numpy.ndarray (C x H x W)): Image to be scaled.\n        Returns:\n            img (numpy.ndarray (C x H x W)): Rescaled image.\n        \"\"\"", "\n", "if", "img", ".", "ndim", "==", "3", ":", "\n", "            ", "return", "skimage", ".", "transform", ".", "rescale", "(", "img", ",", "self", ".", "size", ",", "order", "=", "0", ")", "\n", "", "elif", "img", ".", "ndim", "==", "2", ":", "\n", "            ", "return", "skimage", ".", "transform", ".", "rescale", "(", "img", ",", "self", ".", "size", ",", "order", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "RuntimeError", "(", "\n", "'img should be ndarray with 2 or 3 dimensions. Got {}'", ".", "format", "(", "\n", "img", ".", "ndim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.CenterCrop.__init__": [[353, 358], ["isinstance", "int", "int"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", ")", ":", "\n", "        ", "if", "isinstance", "(", "size", ",", "numbers", ".", "Number", ")", ":", "\n", "            ", "self", ".", "size", "=", "(", "int", "(", "size", ")", ",", "int", "(", "size", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "size", "=", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.CenterCrop.get_params": [[359, 381], ["int", "int", "round", "round"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "get_params", "(", "img", ",", "output_size", ")", ":", "\n", "        ", "\"\"\"Get parameters for ``crop`` for center crop.\n\n        Args:\n            img (numpy.ndarray (C x H x W)): Image to be cropped.\n            output_size (tuple): Expected output size of the crop.\n\n        Returns:\n            tuple: params (i, j, h, w) to be passed to ``crop`` for center crop.\n        \"\"\"", "\n", "h", "=", "img", ".", "shape", "[", "0", "]", "\n", "w", "=", "img", ".", "shape", "[", "1", "]", "\n", "th", ",", "tw", "=", "output_size", "\n", "i", "=", "int", "(", "round", "(", "(", "h", "-", "th", ")", "/", "2.", ")", ")", "\n", "j", "=", "int", "(", "round", "(", "(", "w", "-", "tw", ")", "/", "2.", ")", ")", "\n", "\n", "# # randomized cropping", "\n", "# i = np.random.randint(i-3, i+4)", "\n", "# j = np.random.randint(j-3, j+4)", "\n", "\n", "return", "i", ",", "j", ",", "th", ",", "tw", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.CenterCrop.__call__": [[382, 407], ["transforms.CenterCrop.get_params", "transforms._is_numpy_image", "TypeError", "RuntimeError", "type"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Crop.get_params", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_numpy_image"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (numpy.ndarray (C x H x W)): Image to be cropped.\n\n        Returns:\n            img (numpy.ndarray (C x H x W)): Cropped image.\n        \"\"\"", "\n", "i", ",", "j", ",", "h", ",", "w", "=", "self", ".", "get_params", "(", "img", ",", "self", ".", "size", ")", "\n", "\"\"\"\n        i: Upper pixel coordinate.\n        j: Left pixel coordinate.\n        h: Height of the cropped image.\n        w: Width of the cropped image.\n        \"\"\"", "\n", "if", "not", "(", "_is_numpy_image", "(", "img", ")", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'img should be ndarray. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "", "if", "img", ".", "ndim", "==", "3", ":", "\n", "            ", "return", "img", "[", "i", ":", "i", "+", "h", ",", "j", ":", "j", "+", "w", ",", ":", "]", "\n", "", "elif", "img", ".", "ndim", "==", "2", ":", "\n", "            ", "return", "img", "[", "i", ":", "i", "+", "h", ",", "j", ":", "j", "+", "w", "]", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "'img should be ndarray with 2 or 3 dimensions. Got {}'", ".", "format", "(", "\n", "img", ".", "ndim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.BottomCrop.__init__": [[419, 424], ["isinstance", "int", "int"], "methods", ["None"], ["            ", "self", ".", "size", "=", "(", "int", "(", "size", ")", ",", "int", "(", "size", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "size", "=", "size", "\n", "\n", "", "", "@", "staticmethod", "\n", "def", "get_params", "(", "img", ",", "output_size", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.BottomCrop.get_params": [[425, 447], ["int", "round"], "methods", ["None"], ["        ", "\"\"\"Get parameters for ``crop`` for bottom crop.\n\n        Args:\n            img (numpy.ndarray (C x H x W)): Image to be cropped.\n            output_size (tuple): Expected output size of the crop.\n\n        Returns:\n            tuple: params (i, j, h, w) to be passed to ``crop`` for bottom crop.\n        \"\"\"", "\n", "h", "=", "img", ".", "shape", "[", "0", "]", "\n", "w", "=", "img", ".", "shape", "[", "1", "]", "\n", "th", ",", "tw", "=", "output_size", "\n", "i", "=", "h", "-", "th", "\n", "j", "=", "int", "(", "round", "(", "(", "w", "-", "tw", ")", "/", "2.", ")", ")", "\n", "\n", "# randomized left and right cropping", "\n", "# i = np.random.randint(i-3, i+4)", "\n", "# j = np.random.randint(j-1, j+1)", "\n", "\n", "return", "i", ",", "j", ",", "th", ",", "tw", "\n", "\n", "", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.BottomCrop.__call__": [[448, 473], ["transforms.BottomCrop.get_params", "transforms._is_numpy_image", "TypeError", "RuntimeError", "type"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Crop.get_params", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_numpy_image"], ["\n", "i", ",", "j", ",", "h", ",", "w", "=", "self", ".", "get_params", "(", "img", ",", "self", ".", "size", ")", "\n", "\"\"\"\n        i: Upper pixel coordinate.\n        j: Left pixel coordinate.\n        h: Height of the cropped image.\n        w: Width of the cropped image.\n        \"\"\"", "\n", "if", "not", "(", "_is_numpy_image", "(", "img", ")", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'img should be ndarray. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "", "if", "img", ".", "ndim", "==", "3", ":", "\n", "            ", "return", "img", "[", "i", ":", "i", "+", "h", ",", "j", ":", "j", "+", "w", ",", ":", "]", "\n", "", "elif", "img", ".", "ndim", "==", "2", ":", "\n", "            ", "return", "img", "[", "i", ":", "i", "+", "h", ",", "j", ":", "j", "+", "w", "]", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "'img should be ndarray with 2 or 3 dimensions. Got {}'", ".", "format", "(", "\n", "img", ".", "ndim", ")", ")", "\n", "\n", "\n", "", "", "", "class", "Crop", "(", "object", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Crop.__init__": [[483, 485], ["None"], "methods", ["None"], ["\n", "", "@", "staticmethod", "\n", "def", "get_params", "(", "img", ",", "crop", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Crop.get_params": [[486, 507], ["None"], "methods", ["None"], ["        ", "\"\"\"Get parameters for ``crop`` for center crop.\n\n        Args:\n            img (numpy.ndarray (C x H x W)): Image to be cropped.\n            output_size (tuple): Expected output size of the crop.\n\n        Returns:\n            tuple: params (i, j, h, w) to be passed to ``crop`` for center crop.\n        \"\"\"", "\n", "x_l", ",", "x_r", ",", "y_b", ",", "y_t", "=", "crop", "\n", "h", "=", "img", ".", "shape", "[", "0", "]", "\n", "w", "=", "img", ".", "shape", "[", "1", "]", "\n", "assert", "x_l", ">=", "0", "and", "x_l", "<", "w", "\n", "assert", "x_r", ">=", "0", "and", "x_r", "<", "w", "\n", "assert", "y_b", ">=", "0", "and", "y_b", "<", "h", "\n", "assert", "y_t", ">=", "0", "and", "y_t", "<", "h", "\n", "assert", "x_l", "<", "x_r", "and", "y_b", "<", "y_t", "\n", "\n", "return", "x_l", ",", "x_r", ",", "y_b", ",", "y_t", "\n", "\n", "", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Crop.__call__": [[508, 533], ["transforms.Crop.get_params", "transforms._is_numpy_image", "TypeError", "RuntimeError", "type"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Crop.get_params", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_numpy_image"], ["\n", "x_l", ",", "x_r", ",", "y_b", ",", "y_t", "=", "self", ".", "get_params", "(", "img", ",", "self", ".", "crop", ")", "\n", "\"\"\"\n        i: Upper pixel coordinate.\n        j: Left pixel coordinate.\n        h: Height of the cropped image.\n        w: Width of the cropped image.\n        \"\"\"", "\n", "if", "not", "(", "_is_numpy_image", "(", "img", ")", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'img should be ndarray. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "", "if", "img", ".", "ndim", "==", "3", ":", "\n", "            ", "return", "img", "[", "y_b", ":", "y_t", ",", "x_l", ":", "x_r", ",", ":", "]", "\n", "", "elif", "img", ".", "ndim", "==", "2", ":", "\n", "            ", "return", "img", "[", "y_b", ":", "y_t", ",", "x_l", ":", "x_r", "]", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "'img should be ndarray with 2 or 3 dimensions. Got {}'", ".", "format", "(", "\n", "img", ".", "ndim", ")", ")", "\n", "\n", "\n", "", "", "", "class", "Lambda", "(", "object", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Lambda.__init__": [[541, 544], ["isinstance"], "methods", ["None"], ["self", ".", "lambd", "=", "lambd", "\n", "\n", "", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "return", "self", ".", "lambd", "(", "img", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.Lambda.__call__": [[545, 547], ["transforms.Lambda.lambd"], "methods", ["None"], ["\n", "\n", "", "", "class", "HorizontalFlip", "(", "object", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.HorizontalFlip.__init__": [[556, 558], ["None"], "methods", ["None"], ["\n", "", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.HorizontalFlip.__call__": [[559, 574], ["transforms._is_numpy_image", "TypeError", "numpy.fliplr", "type"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_numpy_image"], ["\n", "if", "not", "(", "_is_numpy_image", "(", "img", ")", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'img should be ndarray. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "do_flip", ":", "\n", "            ", "return", "np", ".", "fliplr", "(", "img", ")", "\n", "", "else", ":", "\n", "            ", "return", "img", "\n", "\n", "\n", "", "", "", "class", "ColorJitter", "(", "object", ")", ":", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.ColorJitter.__init__": [[589, 599], ["transforms.append", "transforms.append", "transforms.append", "transforms.append", "numpy.random.shuffle", "transforms.Compose", "transforms.Lambda", "transforms.Lambda", "transforms.Lambda", "transforms.Lambda", "transforms.adjust_brightness", "transforms.adjust_contrast", "transforms.adjust_saturation", "transforms.adjust_hue"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.adjust_brightness", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.adjust_contrast", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.adjust_saturation", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.adjust_hue"], ["transforms", ".", "append", "(", "\n", "Lambda", "(", "lambda", "img", ":", "adjust_brightness", "(", "img", ",", "brightness", ")", ")", ")", "\n", "transforms", ".", "append", "(", "Lambda", "(", "lambda", "img", ":", "adjust_contrast", "(", "img", ",", "contrast", ")", ")", ")", "\n", "transforms", ".", "append", "(", "\n", "Lambda", "(", "lambda", "img", ":", "adjust_saturation", "(", "img", ",", "saturation", ")", ")", ")", "\n", "transforms", ".", "append", "(", "Lambda", "(", "lambda", "img", ":", "adjust_hue", "(", "img", ",", "hue", ")", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "transforms", ")", "\n", "self", ".", "transform", "=", "Compose", "(", "transforms", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.ColorJitter.__call__": [[600, 613], ["PIL.Image.fromarray", "numpy.array", "transforms._is_numpy_image", "TypeError", "transforms.ColorJitter.transform", "type"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_numpy_image"], ["\n", "if", "not", "(", "_is_numpy_image", "(", "img", ")", ")", ":", "\n", "            ", "raise", "TypeError", "(", "'img should be ndarray. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "\n", "", "pil", "=", "Image", ".", "fromarray", "(", "img", ")", "\n", "return", "np", ".", "array", "(", "self", ".", "transform", "(", "pil", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_numpy_image": [[22, 24], ["isinstance"], "function", ["None"], ["def", "_is_numpy_image", "(", "img", ")", ":", "\n", "    ", "return", "isinstance", "(", "img", ",", "np", ".", "ndarray", ")", "and", "(", "img", ".", "ndim", "in", "{", "2", ",", "3", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_pil_image": [[26, 31], ["isinstance", "isinstance"], "function", ["None"], ["", "def", "_is_pil_image", "(", "img", ")", ":", "\n", "    ", "if", "accimage", "is", "not", "None", ":", "\n", "        ", "return", "isinstance", "(", "img", ",", "(", "Image", ".", "Image", ",", "accimage", ".", "Image", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_tensor_image": [[33, 35], ["torch.is_tensor", "img.ndimension"], "function", ["None"], ["", "", "def", "_is_tensor_image", "(", "img", ")", ":", "\n", "    ", "return", "torch", ".", "is_tensor", "(", "img", ")", "and", "img", ".", "ndimension", "(", ")", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.adjust_brightness": [[37, 55], ["PIL.ImageEnhance.Brightness", "ImageEnhance.Brightness.enhance", "transforms._is_pil_image", "TypeError", "type"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_pil_image"], ["", "def", "adjust_brightness", "(", "img", ",", "brightness_factor", ")", ":", "\n", "    ", "\"\"\"Adjust brightness of an Image.\n\n    Args:\n        img (PIL Image): PIL Image to be adjusted.\n        brightness_factor (float):  How much to adjust the brightness. Can be\n            any non negative number. 0 gives a black image, 1 gives the\n            original image while 2 increases the brightness by a factor of 2.\n\n    Returns:\n        PIL Image: Brightness adjusted image.\n    \"\"\"", "\n", "if", "not", "_is_pil_image", "(", "img", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'img should be PIL Image. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "\n", "", "enhancer", "=", "ImageEnhance", ".", "Brightness", "(", "img", ")", "\n", "img", "=", "enhancer", ".", "enhance", "(", "brightness_factor", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.adjust_contrast": [[57, 75], ["PIL.ImageEnhance.Contrast", "ImageEnhance.Contrast.enhance", "transforms._is_pil_image", "TypeError", "type"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_pil_image"], ["", "def", "adjust_contrast", "(", "img", ",", "contrast_factor", ")", ":", "\n", "    ", "\"\"\"Adjust contrast of an Image.\n\n    Args:\n        img (PIL Image): PIL Image to be adjusted.\n        contrast_factor (float): How much to adjust the contrast. Can be any\n            non negative number. 0 gives a solid gray image, 1 gives the\n            original image while 2 increases the contrast by a factor of 2.\n\n    Returns:\n        PIL Image: Contrast adjusted image.\n    \"\"\"", "\n", "if", "not", "_is_pil_image", "(", "img", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'img should be PIL Image. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "\n", "", "enhancer", "=", "ImageEnhance", ".", "Contrast", "(", "img", ")", "\n", "img", "=", "enhancer", ".", "enhance", "(", "contrast_factor", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.adjust_saturation": [[77, 95], ["PIL.ImageEnhance.Color", "ImageEnhance.Color.enhance", "transforms._is_pil_image", "TypeError", "type"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_pil_image"], ["", "def", "adjust_saturation", "(", "img", ",", "saturation_factor", ")", ":", "\n", "    ", "\"\"\"Adjust color saturation of an image.\n\n    Args:\n        img (PIL Image): PIL Image to be adjusted.\n        saturation_factor (float):  How much to adjust the saturation. 0 will\n            give a black and white image, 1 will give the original image while\n            2 will enhance the saturation by a factor of 2.\n\n    Returns:\n        PIL Image: Saturation adjusted image.\n    \"\"\"", "\n", "if", "not", "_is_pil_image", "(", "img", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'img should be PIL Image. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "\n", "", "enhancer", "=", "ImageEnhance", ".", "Color", "(", "img", ")", "\n", "img", "=", "enhancer", ".", "enhance", "(", "saturation_factor", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.adjust_hue": [[97, 141], ["Image.merge().convert.convert().split", "numpy.array", "PIL.Image.fromarray", "PIL.Image.merge().convert", "ValueError", "transforms._is_pil_image", "TypeError", "numpy.errstate", "numpy.uint8", "Image.merge().convert.convert", "PIL.Image.merge", "type"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_pil_image"], ["", "def", "adjust_hue", "(", "img", ",", "hue_factor", ")", ":", "\n", "    ", "\"\"\"Adjust hue of an image.\n\n    The image hue is adjusted by converting the image to HSV and\n    cyclically shifting the intensities in the hue channel (H).\n    The image is then converted back to original image mode.\n\n    `hue_factor` is the amount of shift in H channel and must be in the\n    interval `[-0.5, 0.5]`.\n\n    See https://en.wikipedia.org/wiki/Hue for more details on Hue.\n\n    Args:\n        img (PIL Image): PIL Image to be adjusted.\n        hue_factor (float):  How much to shift the hue channel. Should be in\n            [-0.5, 0.5]. 0.5 and -0.5 give complete reversal of hue channel in\n            HSV space in positive and negative direction respectively.\n            0 means no shift. Therefore, both -0.5 and 0.5 will give an image\n            with complementary colors while 0 gives the original image.\n\n    Returns:\n        PIL Image: Hue adjusted image.\n    \"\"\"", "\n", "if", "not", "(", "-", "0.5", "<=", "hue_factor", "<=", "0.5", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "'hue_factor is not in [-0.5, 0.5].'", ".", "format", "(", "hue_factor", ")", ")", "\n", "\n", "", "if", "not", "_is_pil_image", "(", "img", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'img should be PIL Image. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "\n", "", "input_mode", "=", "img", ".", "mode", "\n", "if", "input_mode", "in", "{", "'L'", ",", "'1'", ",", "'I'", ",", "'F'", "}", ":", "\n", "        ", "return", "img", "\n", "\n", "", "h", ",", "s", ",", "v", "=", "img", ".", "convert", "(", "'HSV'", ")", ".", "split", "(", ")", "\n", "\n", "np_h", "=", "np", ".", "array", "(", "h", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "# uint8 addition take cares of rotation across boundaries", "\n", "with", "np", ".", "errstate", "(", "over", "=", "'ignore'", ")", ":", "\n", "        ", "np_h", "+=", "np", ".", "uint8", "(", "hue_factor", "*", "255", ")", "\n", "", "h", "=", "Image", ".", "fromarray", "(", "np_h", ",", "'L'", ")", "\n", "\n", "img", "=", "Image", ".", "merge", "(", "'HSV'", ",", "(", "h", ",", "s", ",", "v", ")", ")", ".", "convert", "(", "input_mode", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms.adjust_gamma": [[143, 175], ["Image.fromarray().convert.convert", "numpy.array", "numpy.uint8", "PIL.Image.fromarray().convert", "transforms._is_pil_image", "TypeError", "ValueError", "numpy.clip", "PIL.Image.fromarray", "type"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.transforms._is_pil_image"], ["", "def", "adjust_gamma", "(", "img", ",", "gamma", ",", "gain", "=", "1", ")", ":", "\n", "    ", "\"\"\"Perform gamma correction on an image.\n\n    Also known as Power Law Transform. Intensities in RGB mode are adjusted\n    based on the following equation:\n\n        I_out = 255 * gain * ((I_in / 255) ** gamma)\n\n    See https://en.wikipedia.org/wiki/Gamma_correction for more details.\n\n    Args:\n        img (PIL Image): PIL Image to be adjusted.\n        gamma (float): Non negative real number. gamma larger than 1 make the\n            shadows darker, while gamma smaller than 1 make dark regions\n            lighter.\n        gain (float): The constant multiplier.\n    \"\"\"", "\n", "if", "not", "_is_pil_image", "(", "img", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'img should be PIL Image. Got {}'", ".", "format", "(", "type", "(", "img", ")", ")", ")", "\n", "\n", "", "if", "gamma", "<", "0", ":", "\n", "        ", "raise", "ValueError", "(", "'Gamma should be a non-negative real number'", ")", "\n", "\n", "", "input_mode", "=", "img", ".", "mode", "\n", "img", "=", "img", ".", "convert", "(", "'RGB'", ")", "\n", "\n", "np_img", "=", "np", ".", "array", "(", "img", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "np_img", "=", "255", "*", "gain", "*", "(", "(", "np_img", "/", "255", ")", "**", "gamma", ")", "\n", "np_img", "=", "np", ".", "uint8", "(", "np", ".", "clip", "(", "np_img", ",", "0", ",", "255", ")", ")", "\n", "\n", "img", "=", "Image", ".", "fromarray", "(", "np_img", ",", "'RGB'", ")", ".", "convert", "(", "input_mode", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.pose_estimator.rgb2gray": [[5, 7], ["numpy.dot"], "function", ["None"], ["def", "rgb2gray", "(", "rgb", ")", ":", "\n", "    ", "return", "np", ".", "dot", "(", "rgb", "[", "...", ",", ":", "3", "]", ",", "[", "0.299", ",", "0.587", ",", "0.114", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.pose_estimator.convert_2d_to_3d": [[9, 17], ["None"], "function", ["None"], ["", "def", "convert_2d_to_3d", "(", "u", ",", "v", ",", "z", ",", "K", ")", ":", "\n", "    ", "v0", "=", "K", "[", "1", "]", "[", "2", "]", "\n", "u0", "=", "K", "[", "0", "]", "[", "2", "]", "\n", "fy", "=", "K", "[", "1", "]", "[", "1", "]", "\n", "fx", "=", "K", "[", "0", "]", "[", "0", "]", "\n", "x", "=", "(", "u", "-", "u0", ")", "*", "z", "/", "fx", "\n", "y", "=", "(", "v", "-", "v0", ")", "*", "z", "/", "fy", "\n", "return", "(", "x", ",", "y", ",", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.pose_estimator.feature_match": [[19, 60], ["cv2.xfeatures2d.SIFT_create", "cv2.xfeatures2d.SIFT_create.detectAndCompute", "cv2.xfeatures2d.SIFT_create.detectAndCompute", "des1.astype.astype", "des2.astype.astype", "enumerate", "numpy.int32", "numpy.int32", "dict", "dict", "cv2.FlannBasedMatcher", "cv2.FlannBasedMatcher.knnMatch", "cv2.DescriptorMatcher().create", "cv2.DescriptorMatcher().create.knnMatch", "good.append", "np.int32.append", "np.int32.append", "cv2.DescriptorMatcher"], "function", ["None"], ["", "def", "feature_match", "(", "img1", ",", "img2", ")", ":", "\n", "    ", "r''' Find features on both images and match them pairwise\n   '''", "\n", "max_n_features", "=", "1000", "\n", "# max_n_features = 500", "\n", "use_flann", "=", "False", "# better not use flann", "\n", "\n", "detector", "=", "cv2", ".", "xfeatures2d", ".", "SIFT_create", "(", "max_n_features", ")", "\n", "\n", "# find the keypoints and descriptors with SIFT", "\n", "kp1", ",", "des1", "=", "detector", ".", "detectAndCompute", "(", "img1", ",", "None", ")", "\n", "kp2", ",", "des2", "=", "detector", ".", "detectAndCompute", "(", "img2", ",", "None", ")", "\n", "if", "(", "des1", "is", "None", ")", "or", "(", "des2", "is", "None", ")", ":", "\n", "        ", "return", "[", "]", ",", "[", "]", "\n", "", "des1", "=", "des1", ".", "astype", "(", "np", ".", "float32", ")", "\n", "des2", "=", "des2", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "if", "use_flann", ":", "\n", "# FLANN parameters", "\n", "        ", "FLANN_INDEX_KDTREE", "=", "0", "\n", "index_params", "=", "dict", "(", "algorithm", "=", "FLANN_INDEX_KDTREE", ",", "trees", "=", "5", ")", "\n", "search_params", "=", "dict", "(", "checks", "=", "50", ")", "\n", "flann", "=", "cv2", ".", "FlannBasedMatcher", "(", "index_params", ",", "search_params", ")", "\n", "matches", "=", "flann", ".", "knnMatch", "(", "des1", ",", "des2", ",", "k", "=", "2", ")", "\n", "", "else", ":", "\n", "        ", "matcher", "=", "cv2", ".", "DescriptorMatcher", "(", ")", ".", "create", "(", "'BruteForce'", ")", "\n", "matches", "=", "matcher", ".", "knnMatch", "(", "des1", ",", "des2", ",", "k", "=", "2", ")", "\n", "\n", "", "good", "=", "[", "]", "\n", "pts1", "=", "[", "]", "\n", "pts2", "=", "[", "]", "\n", "# ratio test as per Lowe's paper", "\n", "for", "i", ",", "(", "m", ",", "n", ")", "in", "enumerate", "(", "matches", ")", ":", "\n", "        ", "if", "m", ".", "distance", "<", "0.8", "*", "n", ".", "distance", ":", "\n", "            ", "good", ".", "append", "(", "m", ")", "\n", "pts2", ".", "append", "(", "kp2", "[", "m", ".", "trainIdx", "]", ".", "pt", ")", "\n", "pts1", ".", "append", "(", "kp1", "[", "m", ".", "queryIdx", "]", ".", "pt", ")", "\n", "\n", "", "", "pts1", "=", "np", ".", "int32", "(", "pts1", ")", "\n", "pts2", "=", "np", ".", "int32", "(", "pts2", ")", "\n", "return", "pts1", ",", "pts2", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.pose_estimator.get_pose_pnp": [[62, 105], ["rgb2gray().astype", "rgb2gray().astype", "pose_estimator.feature_match", "numpy.ones", "cv2.dilate", "enumerate", "numpy.expand_dims", "numpy.expand_dims", "cv2.solvePnPRansac", "pose_estimator.rgb2gray", "pose_estimator.rgb2gray", "pose_estimator.convert_2d_to_3d", "np.expand_dims.append", "np.expand_dims.append", "len", "len", "numpy.array().astype", "numpy.array().astype", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.pose_estimator.feature_match", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.pose_estimator.rgb2gray", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.pose_estimator.rgb2gray", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.pose_estimator.convert_2d_to_3d"], ["", "def", "get_pose_pnp", "(", "rgb_curr", ",", "rgb_near", ",", "depth_curr", ",", "K", ")", ":", "\n", "    ", "gray_curr", "=", "rgb2gray", "(", "rgb_curr", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "gray_near", "=", "rgb2gray", "(", "rgb_near", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "height", ",", "width", "=", "gray_curr", ".", "shape", "\n", "\n", "pts2d_curr", ",", "pts2d_near", "=", "feature_match", "(", "gray_curr", ",", "\n", "gray_near", ")", "# feature matching", "\n", "\n", "# dilation of depth", "\n", "kernel", "=", "np", ".", "ones", "(", "(", "4", ",", "4", ")", ",", "np", ".", "uint8", ")", "\n", "depth_curr_dilated", "=", "cv2", ".", "dilate", "(", "depth_curr", ",", "kernel", ")", "\n", "\n", "# extract 3d pts", "\n", "pts3d_curr", "=", "[", "]", "\n", "pts2d_near_filtered", "=", "[", "\n", "]", "# keep only feature points with depth in the current frame", "\n", "for", "i", ",", "pt2d", "in", "enumerate", "(", "pts2d_curr", ")", ":", "\n", "# print(pt2d)", "\n", "        ", "u", ",", "v", "=", "pt2d", "[", "0", "]", ",", "pt2d", "[", "1", "]", "\n", "z", "=", "depth_curr_dilated", "[", "v", ",", "u", "]", "\n", "if", "z", ">", "0", ":", "\n", "            ", "xyz_curr", "=", "convert_2d_to_3d", "(", "u", ",", "v", ",", "z", ",", "K", ")", "\n", "pts3d_curr", ".", "append", "(", "xyz_curr", ")", "\n", "pts2d_near_filtered", ".", "append", "(", "pts2d_near", "[", "i", "]", ")", "\n", "\n", "# the minimal number of points accepted by solvePnP is 4:", "\n", "", "", "if", "len", "(", "pts3d_curr", ")", ">=", "4", "and", "len", "(", "pts2d_near_filtered", ")", ">=", "4", ":", "\n", "        ", "pts3d_curr", "=", "np", ".", "expand_dims", "(", "np", ".", "array", "(", "pts3d_curr", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "axis", "=", "1", ")", "\n", "pts2d_near_filtered", "=", "np", ".", "expand_dims", "(", "\n", "np", ".", "array", "(", "pts2d_near_filtered", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "axis", "=", "1", ")", "\n", "\n", "# ransac", "\n", "ret", "=", "cv2", ".", "solvePnPRansac", "(", "pts3d_curr", ",", "\n", "pts2d_near_filtered", ",", "\n", "K", ",", "\n", "distCoeffs", "=", "None", ")", "\n", "success", "=", "ret", "[", "0", "]", "\n", "rotation_vector", "=", "ret", "[", "1", "]", "\n", "translation_vector", "=", "ret", "[", "2", "]", "\n", "return", "(", "success", ",", "rotation_vector", ",", "translation_vector", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "0", ",", "None", ",", "None", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__init__": [[299, 307], ["kitti_loader.get_paths_and_transform", "kitti_loader.load_calib"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.get_paths_and_transform", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.load_calib"], ["self", ".", "paths", "=", "paths", "\n", "self", ".", "transform", "=", "transform", "\n", "self", ".", "K", "=", "load_calib", "(", ")", "\n", "self", ".", "threshold_translation", "=", "0.1", "\n", "\n", "", "def", "__getraw__", "(", "self", ",", "index", ")", ":", "\n", "        ", "rgb", "=", "rgb_read", "(", "self", ".", "paths", "[", "'rgb'", "]", "[", "index", "]", ")", "if", "(", "self", ".", "paths", "[", "'rgb'", "]", "[", "index", "]", "is", "not", "None", "and", "(", "self", ".", "args", ".", "use_rgb", "or", "self", ".", "args", ".", "use_g", ")", ")", "else", "None", "\n", "sparse", "=", "depth_read", "(", "self", ".", "paths", "[", "'d'", "]", "[", "index", "]", ")", "if"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__getraw__": [[308, 318], ["kitti_loader.rgb_read", "kitti_loader.depth_read", "kitti_loader.depth_read", "kitti_loader.get_rgb_near"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.rgb_read", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.depth_read", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.depth_read", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.get_rgb_near"], ["(", "self", ".", "paths", "[", "'d'", "]", "[", "index", "]", "is", "not", "None", "and", "self", ".", "args", ".", "use_d", ")", "else", "None", "\n", "target", "=", "depth_read", "(", "self", ".", "paths", "[", "'gt'", "]", "[", "index", "]", ")", "if", "self", ".", "paths", "[", "'gt'", "]", "[", "index", "]", "is", "not", "None", "else", "None", "\n", "rgb_near", "=", "get_rgb_near", "(", "self", ".", "paths", "[", "'rgb'", "]", "[", "index", "]", ",", "self", ".", "args", ")", "if", "self", ".", "split", "==", "'train'", "and", "self", ".", "args", ".", "use_pose", "else", "None", "\n", "return", "rgb", ",", "sparse", ",", "target", ",", "rgb_near", "\n", "\n", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "rgb", ",", "sparse", ",", "target", ",", "rgb_near", "=", "self", ".", "__getraw__", "(", "index", ")", "\n", "rgb", ",", "sparse", ",", "target", ",", "rgb_near", "=", "self", ".", "transform", "(", "rgb", ",", "sparse", ",", "target", ",", "\n", "rgb_near", ",", "self", ".", "args", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__getitem__": [[319, 345], ["kitti_loader.KittiDepth.__getraw__", "kitti_loader.KittiDepth.transform", "kitti_loader.handle_gray", "dataloaders.pose_estimator.get_pose_pnp", "to_float_tensor", "cv2.Rodrigues", "numpy.zeros", "numpy.eye", "candidates.items", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__getraw__", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.handle_gray", "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.pose_estimator.get_pose_pnp"], ["r_mat", ",", "t_vec", "=", "None", ",", "None", "\n", "if", "self", ".", "split", "==", "'train'", "and", "self", ".", "args", ".", "use_pose", ":", "\n", "            ", "success", ",", "r_vec", ",", "t_vec", "=", "get_pose_pnp", "(", "rgb", ",", "rgb_near", ",", "sparse", ",", "self", ".", "K", ")", "\n", "# discard if translation is too small", "\n", "success", "=", "success", "and", "LA", ".", "norm", "(", "t_vec", ")", ">", "self", ".", "threshold_translation", "\n", "if", "success", ":", "\n", "                ", "r_mat", ",", "_", "=", "cv2", ".", "Rodrigues", "(", "r_vec", ")", "\n", "", "else", ":", "\n", "# return the same image and no motion when PnP fails", "\n", "                ", "rgb_near", "=", "rgb", "\n", "t_vec", "=", "np", ".", "zeros", "(", "(", "3", ",", "1", ")", ")", "\n", "r_mat", "=", "np", ".", "eye", "(", "3", ")", "\n", "\n", "", "", "rgb", ",", "gray", "=", "handle_gray", "(", "rgb", ",", "self", ".", "args", ")", "\n", "candidates", "=", "{", "\"rgb\"", ":", "rgb", ",", "\"d\"", ":", "sparse", ",", "\"gt\"", ":", "target", ",", "\"g\"", ":", "gray", ",", "\"r_mat\"", ":", "r_mat", ",", "\"t_vec\"", ":", "t_vec", ",", "\"rgb_near\"", ":", "rgb_near", "}", "\n", "items", "=", "{", "\n", "key", ":", "to_float_tensor", "(", "val", ")", "\n", "for", "key", ",", "val", "in", "candidates", ".", "items", "(", ")", "if", "val", "is", "not", "None", "\n", "}", "\n", "\n", "return", "items", "\n", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "paths", "[", "'gt'", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.KittiDepth.__len__": [[346, 348], ["len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.load_calib": [[17, 39], ["open", "open.readlines", "numpy.reshape().astype", "[].split", "numpy.reshape", "numpy.array", "P_rect_line.split", "float"], "function", ["None"], ["\n", "def", "load_calib", "(", ")", ":", "\n", "    ", "\"\"\"\n    Temporarily hardcoding the calibration matrix using calib file from 2011_09_26\n    \"\"\"", "\n", "calib", "=", "open", "(", "\"dataloaders/calib_cam_to_cam.txt\"", ",", "\"r\"", ")", "\n", "lines", "=", "calib", ".", "readlines", "(", ")", "\n", "P_rect_line", "=", "lines", "[", "25", "]", "\n", "\n", "Proj_str", "=", "P_rect_line", ".", "split", "(", "\":\"", ")", "[", "1", "]", ".", "split", "(", "\" \"", ")", "[", "1", ":", "]", "\n", "Proj", "=", "np", ".", "reshape", "(", "np", ".", "array", "(", "[", "float", "(", "p", ")", "for", "p", "in", "Proj_str", "]", ")", ",", "\n", "(", "3", ",", "4", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "K", "=", "Proj", "[", ":", "3", ",", ":", "3", "]", "# camera matrix", "\n", "\n", "# note: we will take the center crop of the images during augmentation", "\n", "# that changes the optical centers, but not focal lengths", "\n", "K", "[", "0", ",", "2", "]", "=", "K", "[", "\n", "0", ",", "\n", "2", "]", "-", "13", "# from width = 1242 to 1216, with a 13-pixel cut on both sides", "\n", "K", "[", "1", ",", "2", "]", "=", "K", "[", "\n", "1", ",", "\n", "2", "]", "-", "11.5", "# from width = 375 to 352, with a 11.5-pixel cut on both sides", "\n", "return", "K", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.get_paths_and_transform": [[41, 155], ["os.path.join", "os.path.join", "sorted", "sorted", "sorted", "RuntimeError", "RuntimeError", "RuntimeError", "RuntimeError", "RuntimeError", "os.path.join", "os.path.join", "p.split", "glob.glob", "glob.glob", "kitti_loader.get_paths_and_transform.get_rgb_paths"], "function", ["None"], ["\n", "", "def", "get_paths_and_transform", "(", "split", ",", "args", ")", ":", "\n", "    ", "assert", "(", "args", ".", "use_d", "or", "args", ".", "use_rgb", "\n", "or", "args", ".", "use_g", ")", ",", "'no proper input selected'", "\n", "\n", "if", "split", "==", "\"train\"", ":", "\n", "        ", "transform", "=", "train_transform", "\n", "if", "args", ".", "partial_train", "==", "'yes'", ":", "\n", "            ", "glob_d", "=", "\"not_relevant\"", "\n", "glob_gt", "=", "\"not_relevant\"", "\n", "", "else", ":", "\n", "            ", "glob_d", "=", "os", ".", "path", ".", "join", "(", "\n", "args", ".", "data_folder", ",", "\n", "'not_relevant'", ")", "\n", "glob_gt", "=", "os", ".", "path", ".", "join", "(", "\n", "args", ".", "data_folder", ",", "\n", "'not_relevant'", ")", "\n", "\n", "", "def", "get_rgb_paths", "(", "p", ")", ":", "\n", "            ", "ps", "=", "p", ".", "split", "(", "'/'", ")", "\n", "pnew", "=", "'/'", ".", "join", "(", "[", "args", ".", "data_folder", "]", "+", "[", "'data_rgb'", "]", "+", "ps", "[", "-", "6", ":", "-", "4", "]", "+", "ps", "[", "-", "2", ":", "-", "1", "]", "+", "[", "'data'", "]", "+", "ps", "[", "-", "1", ":", "]", ")", "\n", "return", "pnew", "\n", "", "", "elif", "split", "==", "\"val\"", ":", "\n", "        ", "if", "args", ".", "val", "==", "\"full\"", ":", "\n", "            ", "transform", "=", "val_transform", "\n", "glob_d", "=", "os", ".", "path", ".", "join", "(", "\n", "args", ".", "data_folder", ",", "\n", "'not_relevant'", "\n", ")", "\n", "glob_gt", "=", "os", ".", "path", ".", "join", "(", "\n", "args", ".", "data_folder", ",", "\n", "'not_relevant'", "\n", ")", "\n", "def", "get_rgb_paths", "(", "p", ")", ":", "\n", "                ", "ps", "=", "p", ".", "split", "(", "'/'", ")", "\n", "pnew", "=", "'/'", ".", "join", "(", "ps", "[", ":", "-", "7", "]", "+", "\n", "[", "'data_rgb'", "]", "+", "ps", "[", "-", "6", ":", "-", "4", "]", "+", "ps", "[", "-", "2", ":", "-", "1", "]", "+", "[", "'data'", "]", "+", "ps", "[", "-", "1", ":", "]", ")", "\n", "return", "pnew", "\n", "", "", "elif", "args", ".", "val", "==", "\"select\"", ":", "\n", "            ", "transform", "=", "no_transform", "\n", "if", "args", ".", "partial_train", "==", "'yes'", ":", "\n", "                ", "glob_d", "=", "\"not_relevant\"", "\n", "glob_gt", "=", "\"not_relevant\"", "\n", "", "else", ":", "\n", "                ", "glob_d", "=", "os", ".", "path", ".", "join", "(", "\n", "args", ".", "data_folder", ",", "\n", "\"not_relevant\"", ")", "\n", "glob_gt", "=", "os", ".", "path", ".", "join", "(", "\n", "args", ".", "data_folder", ",", "\n", "\"not_relevant\"", "\n", ")", "\n", "", "def", "get_rgb_paths", "(", "p", ")", ":", "\n", "                ", "return", "p", ".", "replace", "(", "\"groundtruth_depth\"", ",", "\"image\"", ")", "\n", "", "", "", "elif", "split", "==", "\"test\"", ":", "\n", "        ", "transform", "=", "val_transform", "# for the bottom crop", "\n", "glob_d", "=", "'../data_new/var_final_NN/data_depth_velodyne/test/*_sync/proj_depth/velodyne_raw/image_0[2,3]/*.png'", "\n", "glob_gt", "=", "'../data_new/var_final_NN/data_depth_annotated/test/*_sync/proj_depth/groundtruth/image_0[2,3]/*.png'", "\n", "\n", "def", "get_rgb_paths", "(", "p", ")", ":", "\n", "            ", "ps", "=", "p", ".", "split", "(", "'/'", ")", "\n", "pnew", "=", "'/'", ".", "join", "(", "[", "args", ".", "data_folder", "]", "+", "[", "'data_rgb'", "]", "+", "ps", "[", "-", "6", ":", "-", "4", "]", "+", "ps", "[", "-", "2", ":", "-", "1", "]", "+", "[", "'data'", "]", "+", "[", "(", "ps", "[", "-", "1", ":", "]", "[", "0", "]", ")", ".", "replace", "(", "\"groundtruth_depth\"", ",", "\"image\"", ")", "]", ")", "\n", "return", "pnew", "\n", "\n", "", "", "elif", "split", "==", "\"test_completion\"", ":", "\n", "        ", "transform", "=", "no_transform", "\n", "glob_d", "=", "os", ".", "path", ".", "join", "(", "\n", "args", ".", "data_folder", ",", "\n", "\"depth_selection/test_depth_completion_anonymous/velodyne_raw/*.png\"", "\n", ")", "\n", "glob_gt", "=", "None", "#\"test_depth_completion_anonymous/\"", "\n", "glob_rgb", "=", "os", ".", "path", ".", "join", "(", "\n", "args", ".", "data_folder", ",", "\n", "\"depth_selection/test_depth_completion_anonymous/image/*.png\"", ")", "\n", "", "elif", "split", "==", "\"test_prediction\"", ":", "\n", "        ", "transform", "=", "no_transform", "\n", "glob_d", "=", "None", "\n", "glob_gt", "=", "None", "#\"test_depth_completion_anonymous/\"", "\n", "glob_rgb", "=", "os", ".", "path", ".", "join", "(", "\n", "args", ".", "data_folder", ",", "\n", "\"depth_selection/test_depth_prediction_anonymous/image/*.png\"", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unrecognized split \"", "+", "str", "(", "split", ")", ")", "\n", "\n", "", "if", "glob_gt", "is", "not", "None", ":", "\n", "# train or val-full or val-select", "\n", "        ", "paths_d", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_d", ")", ")", "\n", "paths_gt", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_gt", ")", ")", "\n", "paths_rgb", "=", "[", "get_rgb_paths", "(", "p", ")", "for", "p", "in", "paths_gt", "]", "\n", "", "else", ":", "\n", "# test only has d or rgb", "\n", "        ", "paths_rgb", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_rgb", ")", ")", "\n", "paths_gt", "=", "[", "None", "]", "*", "len", "(", "paths_rgb", ")", "\n", "if", "split", "==", "\"test_prediction\"", ":", "\n", "            ", "paths_d", "=", "[", "None", "]", "*", "len", "(", "\n", "paths_rgb", ")", "# test_prediction has no sparse depth", "\n", "", "else", ":", "\n", "            ", "paths_d", "=", "sorted", "(", "glob", ".", "glob", "(", "glob_d", ")", ")", "\n", "\n", "", "", "if", "len", "(", "paths_d", ")", "==", "0", "and", "len", "(", "paths_rgb", ")", "==", "0", "and", "len", "(", "paths_gt", ")", "==", "0", ":", "\n", "        ", "raise", "(", "RuntimeError", "(", "\"Found 0 images under {}\"", ".", "format", "(", "glob_gt", ")", ")", ")", "\n", "", "if", "len", "(", "paths_d", ")", "==", "0", "and", "args", ".", "use_d", ":", "\n", "        ", "raise", "(", "RuntimeError", "(", "\"Requested sparse depth but none was found\"", ")", ")", "\n", "", "if", "len", "(", "paths_rgb", ")", "==", "0", "and", "args", ".", "use_rgb", ":", "\n", "        ", "raise", "(", "RuntimeError", "(", "\"Requested rgb images but none was found\"", ")", ")", "\n", "", "if", "len", "(", "paths_rgb", ")", "==", "0", "and", "args", ".", "use_g", ":", "\n", "        ", "raise", "(", "RuntimeError", "(", "\"Requested gray images but no rgb was found\"", ")", ")", "\n", "", "if", "len", "(", "paths_rgb", ")", "!=", "len", "(", "paths_d", ")", "or", "len", "(", "paths_rgb", ")", "!=", "len", "(", "paths_gt", ")", ":", "\n", "        ", "raise", "(", "RuntimeError", "(", "\"Produced different sizes for datasets\"", ")", ")", "\n", "\n", "", "paths", "=", "{", "\"rgb\"", ":", "paths_rgb", ",", "\"d\"", ":", "paths_d", ",", "\"gt\"", ":", "paths_gt", "}", "\n", "return", "paths", ",", "transform", "\n", "\n", "\n", "", "def", "rgb_read", "(", "filename", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "filename", ")", ",", "\"file not found: {}\"", ".", "format", "(", "filename", ")", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.rgb_read": [[157, 164], ["os.path.exists", "os.path.exists", "PIL.Image.open", "numpy.array", "Image.open.close"], "function", ["None"], ["# rgb_png = np.array(img_file, dtype=float) / 255.0 # scale pixels to the range [0,1]", "\n", "rgb_png", "=", "np", ".", "array", "(", "img_file", ",", "dtype", "=", "'uint8'", ")", "# in the range [0,255]", "\n", "img_file", ".", "close", "(", ")", "\n", "return", "rgb_png", "\n", "\n", "\n", "", "def", "depth_read", "(", "filename", ")", ":", "\n", "# loads depth map D from png file", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.depth_read": [[166, 183], ["os.path.exists", "os.path.exists", "PIL.Image.open", "numpy.array", "Image.open.close", "numpy.expand_dims", "numpy.max", "np.array.astype", "numpy.max", "numpy.max"], "function", ["None"], ["# for details see readme.txt", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "filename", ")", ",", "\"file not found: {}\"", ".", "format", "(", "filename", ")", "\n", "img_file", "=", "Image", ".", "open", "(", "filename", ")", "\n", "depth_png", "=", "np", ".", "array", "(", "img_file", ",", "dtype", "=", "int", ")", "\n", "img_file", ".", "close", "(", ")", "\n", "# make sure we have a proper 16bit depth map here.. not 8bit!", "\n", "assert", "np", ".", "max", "(", "depth_png", ")", ">", "255", ",", "\"np.max(depth_png)={}, path={}\"", ".", "format", "(", "np", ".", "max", "(", "depth_png", ")", ",", "filename", ")", "\n", "\n", "depth", "=", "depth_png", ".", "astype", "(", "np", ".", "float", ")", "/", "256.", "\n", "# depth[depth_png == 0] = -1.", "\n", "depth", "=", "np", ".", "expand_dims", "(", "depth", ",", "-", "1", ")", "\n", "return", "depth", "\n", "\n", "\n", "", "oheight", ",", "owidth", "=", "352", ",", "1216", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.drop_depth_measurements": [[188, 192], ["numpy.random.binomial"], "function", ["None"], ["\n", "\n", "", "def", "train_transform", "(", "rgb", ",", "sparse", ",", "target", ",", "rgb_near", ",", "args", ")", ":", "\n", "# s = np.random.uniform(1.0, 1.5) # random scaling", "\n", "# angle = np.random.uniform(-5.0, 5.0) # random rotation degrees", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.train_transform": [[194, 224], ["dataloaders.transforms.Compose", "transforms.Compose.", "numpy.random.uniform", "transforms.Compose.", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "dataloaders.transforms.Compose", "transforms.Compose.", "dataloaders.transforms.BottomCrop", "dataloaders.transforms.HorizontalFlip", "max", "max", "max", "transforms.Compose.", "dataloaders.transforms.ColorJitter"], "function", ["None"], ["\n", "transform_geometric", "=", "transforms", ".", "Compose", "(", "[", "\n", "# transforms.Rotate(angle),", "\n", "# transforms.Resize(s),", "\n", "transforms", ".", "BottomCrop", "(", "(", "oheight", ",", "owidth", ")", ")", ",", "\n", "transforms", ".", "HorizontalFlip", "(", "do_flip", ")", "\n", "]", ")", "\n", "if", "sparse", "is", "not", "None", ":", "\n", "        ", "sparse", "=", "transform_geometric", "(", "sparse", ")", "\n", "", "target", "=", "transform_geometric", "(", "target", ")", "\n", "if", "rgb", "is", "not", "None", ":", "\n", "        ", "brightness", "=", "np", ".", "random", ".", "uniform", "(", "max", "(", "0", ",", "1", "-", "args", ".", "jitter", ")", ",", "\n", "1", "+", "args", ".", "jitter", ")", "\n", "contrast", "=", "np", ".", "random", ".", "uniform", "(", "max", "(", "0", ",", "1", "-", "args", ".", "jitter", ")", ",", "1", "+", "args", ".", "jitter", ")", "\n", "saturation", "=", "np", ".", "random", ".", "uniform", "(", "max", "(", "0", ",", "1", "-", "args", ".", "jitter", ")", ",", "\n", "1", "+", "args", ".", "jitter", ")", "\n", "transform_rgb", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ColorJitter", "(", "brightness", ",", "contrast", ",", "saturation", ",", "0", ")", ",", "\n", "transform_geometric", "\n", "]", ")", "\n", "rgb", "=", "transform_rgb", "(", "rgb", ")", "\n", "if", "rgb_near", "is", "not", "None", ":", "\n", "            ", "rgb_near", "=", "transform_rgb", "(", "rgb_near", ")", "\n", "# sparse = drop_depth_measurements(sparse, 0.9)", "\n", "\n", "", "", "return", "rgb", ",", "sparse", ",", "target", ",", "rgb_near", "\n", "\n", "\n", "", "def", "val_transform", "(", "rgb", ",", "sparse", ",", "target", ",", "rgb_near", ",", "args", ")", ":", "\n", "    ", "transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "BottomCrop", "(", "(", "oheight", ",", "owidth", ")", ")", ",", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.val_transform": [[226, 239], ["dataloaders.transforms.Compose", "transforms.Compose.", "transforms.Compose.", "transforms.Compose.", "transforms.Compose.", "dataloaders.transforms.BottomCrop"], "function", ["None"], ["if", "rgb", "is", "not", "None", ":", "\n", "        ", "rgb", "=", "transform", "(", "rgb", ")", "\n", "", "if", "sparse", "is", "not", "None", ":", "\n", "        ", "sparse", "=", "transform", "(", "sparse", ")", "\n", "", "if", "target", "is", "not", "None", ":", "\n", "        ", "target", "=", "transform", "(", "target", ")", "\n", "", "if", "rgb_near", "is", "not", "None", ":", "\n", "        ", "rgb_near", "=", "transform", "(", "rgb_near", ")", "\n", "", "return", "rgb", ",", "sparse", ",", "target", ",", "rgb_near", "\n", "\n", "\n", "", "def", "no_transform", "(", "rgb", ",", "sparse", ",", "target", ",", "rgb_near", ",", "args", ")", ":", "\n", "    ", "return", "rgb", ",", "sparse", ",", "target", ",", "rgb_near", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.no_transform": [[241, 243], ["None"], "function", ["None"], ["", "to_tensor", "=", "transforms", ".", "ToTensor", "(", ")", "\n", "to_float_tensor", "=", "lambda", "x", ":", "to_tensor", "(", "x", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.handle_gray": [[249, 262], ["numpy.array", "numpy.expand_dims", "PIL.Image.fromarray().convert", "PIL.Image.fromarray"], "function", ["None"], ["        ", "return", "rgb", ",", "None", "\n", "", "else", ":", "\n", "        ", "img", "=", "np", ".", "array", "(", "Image", ".", "fromarray", "(", "rgb", ")", ".", "convert", "(", "'L'", ")", ")", "\n", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "-", "1", ")", "\n", "if", "not", "args", ".", "use_rgb", ":", "\n", "            ", "rgb_ret", "=", "None", "\n", "", "else", ":", "\n", "            ", "rgb_ret", "=", "rgb", "\n", "", "return", "rgb_ret", ",", "img", "\n", "\n", "\n", "", "", "def", "get_rgb_near", "(", "path", ",", "args", ")", ":", "\n", "    ", "assert", "path", "is", "not", "None", ",", "\"path is None\"", "\n", "\n"]], "home.repos.pwc.inspect_result.shacharp_Adaptive-LiDAR-Sampling.dataloaders.kitti_loader.get_rgb_near": [[264, 294], ["kitti_loader.get_rgb_near.extract_frame_id"], "function", ["None"], ["        ", "head", ",", "tail", "=", "os", ".", "path", ".", "split", "(", "filename", ")", "\n", "number_string", "=", "tail", "[", "0", ":", "tail", ".", "find", "(", "'.'", ")", "]", "\n", "number", "=", "int", "(", "number_string", ")", "\n", "return", "head", ",", "number", "\n", "\n", "", "def", "get_nearby_filename", "(", "filename", ",", "new_id", ")", ":", "\n", "        ", "head", ",", "_", "=", "os", ".", "path", ".", "split", "(", "filename", ")", "\n", "new_filename", "=", "os", ".", "path", ".", "join", "(", "head", ",", "'%010d.png'", "%", "new_id", ")", "\n", "return", "new_filename", "\n", "\n", "", "head", ",", "number", "=", "extract_frame_id", "(", "path", ")", "\n", "count", "=", "0", "\n", "max_frame_diff", "=", "3", "\n", "candidates", "=", "[", "\n", "i", "-", "max_frame_diff", "for", "i", "in", "range", "(", "max_frame_diff", "*", "2", "+", "1", ")", "\n", "if", "i", "-", "max_frame_diff", "!=", "0", "\n", "]", "\n", "while", "True", ":", "\n", "        ", "random_offset", "=", "choice", "(", "candidates", ")", "\n", "path_near", "=", "get_nearby_filename", "(", "path", ",", "number", "+", "random_offset", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "path_near", ")", ":", "\n", "            ", "break", "\n", "", "assert", "count", "<", "20", ",", "\"cannot find a nearby frame in 20 trials for {}\"", ".", "format", "(", "\n", "path_rgb_tgt", ")", "\n", "\n", "", "return", "rgb_read", "(", "path_near", ")", "\n", "\n", "\n", "", "class", "KittiDepth", "(", "data", ".", "Dataset", ")", ":", "\n", "    ", "\"\"\"A data loader for the Kitti dataset\n    \"\"\"", "\n"]]}