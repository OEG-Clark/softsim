{"home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.main.get_parser": [[7, 37], ["ArgumentParser", "ArgumentParser.add_argument", "ArgumentParser.add_argument", "ArgumentParser.add_argument", "ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "\"\"\"Get parser object.\"\"\"", "\n", "from", "argparse", "import", "ArgumentParser", ",", "ArgumentDefaultsHelpFormatter", "\n", "parser", "=", "ArgumentParser", "(", "description", "=", "'Neural Diffusion Equation Implementation'", ",", "\n", "formatter_class", "=", "ArgumentDefaultsHelpFormatter", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"-f\"", ",", "\"--file\"", ",", "\n", "dest", "=", "\"filename\"", ",", "\n", "help", "=", "\"experiment definition file (YAML format)\"", ",", "\n", "metavar", "=", "\"FILE\"", ",", "\n", "# default=\"LA.yaml\",", "\n", "default", "=", "\"SD.yaml\"", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--model_path\"", ",", "\n", "dest", "=", "\"modelpath\"", ",", "\n", "help", "=", "\"load pretrained model\"", ",", "\n", "default", "=", "False", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--comment\"", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "\"comment\"", ",", "\n", "default", "=", "\"\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--gpu\"", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "\"gpu num\"", ",", "\n", "default", "=", "\"0\"", ")", "\n", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.main.main": [[72, 338], ["os.path.join", "os.path.join", "os.path.join", "logging.basicConfig", "tensorboardX.SummaryWriter", "logging.info", "logging.info", "logging.info", "numpy.load", "numpy.load", "numpy.load", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "utils.get_laplacian().to", "torch.zeros", "torch.zeros", "torch.zeros", "range", "sum", "logging.info", "logging.info", "model.ODENet.to", "model.ODENet.train", "torch.RMSprop", "range", "logging.info", "logging.info", "os.path.exists", "os.makedirs", "os.path.exists", "os.makedirs", "open", "pprint.PrettyPrinter", "pprint.PrettyPrinter.pprint", "set", "len", "model.ODENet", "model.ODENet.load_state_dict", "logging.info", "model.ODENet", "logging.info", "model.ODENet.parameters", "numpy.random.randint", "model.ODENet.", "losses_save.append", "tensorboardX.SummaryWriter.add_scalars", "tensorboardX.SummaryWriter.add_scalars", "optim.RMSprop.zero_grad", "loss.backward", "optim.RMSprop.step", "torch.tensor.tolist", "utils.get_laplacian", "torch.load", "torch.load", "torch.load", "p.numel", "torch_geometric.data.Data", "sum", "len", "loss.item", "model.ODENet.", "losses_val_save.append", "val_losses_save.append", "tensorboardX.SummaryWriter.add_scalars", "tensorboardX.SummaryWriter.add_scalars", "logging.info", "logging.info", "numpy.min", "numpy.argmin", "len", "numpy.min", "numpy.argmin", "len", "str", "str", "str", "str", "str", "datetime.datetime.now().isoformat", "model.ODENet.parameters", "torch_geometric.data.Data", "torch_geometric.data.Data", "range", "torch.save", "torch.save", "torch.save", "torch_geometric.data.Data", "sum", "len", "val_loss.item", "model.ODENet.", "tensorboardX.SummaryWriter.add_scalars", "tensorboardX.SummaryWriter.add_scalars", "logging.info", "logging.info", "numpy.mean", "numpy.min", "numpy.min", "range", "range", "torch.tensor", "torch.tensor", "torch.tensor", "sum", "len", "enumerate", "sum", "len", "enumerate", "model.ODENet.state_dict", "os.path.join", "torch.save", "torch.save", "torch.save", "torch_geometric.data.Data", "torch_geometric.data.Data", "range", "len", "numpy.mean", "numpy.min", "torch.save", "torch.save", "torch.save", "torch_geometric.data.Data", "sum", "len", "te_loss.item", "te_loss.item", "numpy.mean", "datetime.datetime.now", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "model.ODENet.state_dict", "os.path.join", "torch.save", "torch.save", "torch.save", "range", "range", "torch.tensor", "torch.tensor", "torch.tensor", "sum", "len", "enumerate", "sum", "len", "enumerate", "model.ODENet.state_dict", "os.path.join", "torch.save", "torch.save", "torch.save", "torch_geometric.data.Data", "torch_geometric.data.Data", "range", "te_loss.item", "numpy.mean", "te_loss.item", "numpy.mean", "numpy.concatenate", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "model.ODENet.state_dict", "os.path.join", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "model.ODENet.state_dict", "os.path.join", "torch.save", "torch.save", "torch.save", "range", "range", "torch.tensor", "torch.tensor", "torch.tensor", "sum", "len", "enumerate", "sum", "len", "enumerate", "te_loss.item", "numpy.mean", "te_loss.item", "enumerate", "enumerate", "numpy.concatenate", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "model.ODENet.state_dict", "os.path.join", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "enumerate", "enumerate", "numpy.concatenate", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "enumerate", "enumerate", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.get_laplacian"], ["def", "main", "(", "cfg", ")", ":", "\n", "\n", "    ", "use_mini", "=", "cfg", "[", "'model'", "]", "[", "'MINI_NN'", "]", "\n", "use_physics", "=", "cfg", "[", "'model'", "]", "[", "'PHY_EQ'", "]", "\n", "MODE_DESC", "=", "cfg", "[", "'model'", "]", "[", "'MODE_desc'", "]", "\n", "REGION", "=", "cfg", "[", "'dataset'", "]", "[", "'REGION'", "]", "# LA or SD", "\n", "\n", "dirname", "=", "\"_\"", ".", "join", "(", "[", "cfg", "[", "'comment'", "]", ",", "MODE_DESC", ",", "REGION", ",", "\"NN\"", "+", "str", "(", "use_mini", ")", ",", "\"PHY\"", "+", "str", "(", "cfg", "[", "'model'", "]", "[", "'PHY_EQ'", "]", ")", ",", "\"Enc\"", "+", "str", "(", "cfg", "[", "'model'", "]", "[", "'enc_node_feat'", "]", ")", ",", "\"lr\"", "+", "str", "(", "cfg", "[", "'optimizer'", "]", "[", "'initial_lr'", "]", ")", ",", "\"decay\"", "+", "str", "(", "cfg", "[", "'optimizer'", "]", "[", "'weight_decay'", "]", ")", ",", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "isoformat", "(", ")", "[", ":", "19", "]", "]", ")", "\n", "logdir", "=", "os", ".", "path", ".", "join", "(", "\"results\"", ",", "dirname", ")", "\n", "modeldir", "=", "os", ".", "path", ".", "join", "(", "logdir", ",", "\"model\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "logdir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "logdir", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "modeldir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "modeldir", ")", "\n", "", "logfilename", "=", "os", ".", "path", ".", "join", "(", "logdir", ",", "'log.txt'", ")", "\n", "# Print the configuration - just to make sure that you loaded what you wanted to load", "\n", "with", "open", "(", "logfilename", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "pp", "=", "pprint", ".", "PrettyPrinter", "(", "indent", "=", "4", ",", "stream", "=", "f", ")", "\n", "pp", ".", "pprint", "(", "cfg", ")", "\n", "\n", "", "logging", ".", "basicConfig", "(", "filename", "=", "logfilename", ",", "\n", "filemode", "=", "'a'", ",", "\n", "format", "=", "'%(asctime)s %(levelname)s %(message)s'", ",", "\n", "level", "=", "logging", ".", "DEBUG", ")", "\n", "writer", "=", "SummaryWriter", "(", "logdir", ")", "\n", "\n", "logging", ".", "info", "(", "\"USE MINI: {} USE PHYSICS: {} ({}) REGION: {}\"", ".", "format", "(", "use_mini", ",", "use_physics", ",", "MODE_DESC", ",", "REGION", ")", ")", "\n", "logging", ".", "info", "(", "\"logdir: {}\"", ".", "format", "(", "logdir", ")", ")", "\n", "logging", ".", "info", "(", "\"modeldir: {}\"", ".", "format", "(", "modeldir", ")", ")", "\n", "\n", "########## Load data and edge attributes ##########", "\n", "# edge attribute not used in current version", "\n", "X", "=", "np", ".", "load", "(", "cfg", "[", "'dataset'", "]", "[", "'X_path'", "]", ")", "\n", "edge_index", "=", "np", ".", "load", "(", "cfg", "[", "'dataset'", "]", "[", "'edge_index_path'", "]", ")", "\n", "edge_attr", "=", "np", ".", "load", "(", "cfg", "[", "'dataset'", "]", "[", "'edge_attr_path'", "]", ")", "\n", "edge_attr_type", "=", "len", "(", "set", "(", "edge_attr", ".", "tolist", "(", ")", ")", ")", "\n", "edge_index", "=", "torch", ".", "tensor", "(", "edge_index", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "edge_attr", "=", "torch", ".", "tensor", "(", "edge_attr", ")", "\n", "num_nodes", "=", "X", ".", "shape", "[", "1", "]", "\n", "###################################################", "\n", "\n", "\n", "########## Architecture setting ##########", "\n", "node_features", "=", "X", ".", "shape", "[", "2", "]", "-", "1", "# Temperature is not considered as input", "\n", "enc_node_features", "=", "cfg", "[", "'model'", "]", "[", "'enc_node_feat'", "]", "\n", "mininet_dim_size", "=", "cfg", "[", "'model'", "]", "[", "'mininet_dim'", "]", "\n", "output_size", "=", "1", "# predict Temperature", "\n", "sp_L", "=", "get_laplacian", "(", "edge_index", ",", "type", "=", "\"aug\"", ",", "sparse", "=", "False", ")", ".", "to", "(", "device", ")", "\n", "time_dependent", "=", "cfg", "[", "'model'", "]", "[", "'time_dependent'", "]", "\n", "nonlinear", "=", "cfg", "[", "'model'", "]", "[", "'nonlinear'", "]", "\n", "activation", "=", "cfg", "[", "'model'", "]", "[", "'activation'", "]", "\n", "method", "=", "cfg", "[", "'model'", "]", "[", "'method'", "]", "\n", "tol", "=", "cfg", "[", "'model'", "]", "[", "'tol'", "]", "\n", "adjoint", "=", "cfg", "[", "'model'", "]", "[", "'adjoint'", "]", "\n", "use_initial", "=", "cfg", "[", "'model'", "]", "[", "'use_initial'", "]", "\n", "dropout_rate", "=", "cfg", "[", "'model'", "]", "[", "'dropout_rate'", "]", "\n", "##########################################", "\n", "\n", "############ Training setting ############", "\n", "num_processing_steps", "=", "cfg", "[", "'train'", "]", "[", "'num_processing_steps'", "]", "# Forecast horizon", "\n", "num_iterations", "=", "cfg", "[", "'train'", "]", "[", "'num_iter'", "]", "\n", "multistep", "=", "cfg", "[", "'train'", "]", "[", "'multistep'", "]", "\n", "input_seq", "=", "cfg", "[", "'train'", "]", "[", "'input_sequence'", "]", "\n", "valid_iter", "=", "cfg", "[", "'train'", "]", "[", "'valid_iter'", "]", "\n", "##########################################", "\n", "\n", "losses_save", "=", "[", "]", "\n", "val_losses_save", "=", "[", "]", "\n", "\n", "####### create physics coefficient matrix using edge attribute shape ###########", "\n", "one_hot_encoder", "=", "torch", ".", "zeros", "(", "size", "=", "(", "num_nodes", "*", "num_nodes", ",", "edge_attr_type", ")", ",", "device", "=", "device", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "edge_attr", ")", ")", ":", "\n", "        ", "one_hot_encoder", "[", "edge_index", "[", ":", ",", "i", "]", "[", "0", "]", "*", "num_nodes", "+", "edge_index", "[", ":", ",", "i", "]", "[", "1", "]", ",", "edge_attr", "[", "i", "]", "]", "=", "1", "\n", "\n", "#### Model ####", "\n", "", "if", "cfg", "[", "'modelpath'", "]", ":", "\n", "        ", "model", "=", "ODENet", "(", "node_features", ",", "\n", "enc_node_features", ",", "\n", "sp_L", ",", "\n", "one_hot_encoder", ",", "\n", "edge_attr_type", ",", "\n", "num_nodes", ",", "\n", "use_mini", "=", "use_mini", ",", "\n", "use_physics", "=", "use_physics", ",", "\n", "augment_dim", "=", "0", ",", "\n", "enc_desc", "=", "[", "[", "'relu'", "]", "]", ",", "\n", "#    enc_desc=None,", "\n", "dec_desc", "=", "[", "[", "32", ",", "'relu'", "]", ",", "[", "None", "]", "]", ",", "\n", "#    dec_desc=None,", "\n", "mini_nn_desc", "=", "[", "[", "128", ",", "'relu'", "]", ",", "[", "'tanh'", "]", "]", ",", "\n", "k_enc_desc", "=", "None", ",", "\n", "time_dependent", "=", "time_dependent", ",", "\n", "num_processing_steps", "=", "num_processing_steps", ",", "\n", "use_initial", "=", "use_initial", ",", "\n", "multistep", "=", "multistep", ",", "\n", "method", "=", "method", ",", "\n", "adjoint", "=", "adjoint", ",", "\n", "tol", "=", "tol", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "device", "=", "device", ")", "\n", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "cfg", "[", "'modelpath'", "]", ",", "map_location", "=", "device", ")", ")", "\n", "logging", ".", "info", "(", "\"pretrained model is loaded. {}\"", ".", "format", "(", "cfg", "[", "'modelpath'", "]", ")", ")", "\n", "\n", "", "else", ":", "\n", "        ", "model", "=", "ODENet", "(", "node_features", "*", "input_seq", ",", "\n", "enc_node_features", ",", "\n", "sp_L", ",", "\n", "one_hot_encoder", ",", "\n", "edge_attr_type", ",", "\n", "num_nodes", ",", "\n", "use_mini", "=", "use_mini", ",", "\n", "use_physics", "=", "use_physics", ",", "\n", "augment_dim", "=", "0", ",", "\n", "enc_desc", "=", "[", "[", "'relu'", "]", "]", ",", "#[TODO] LA", "\n", "#    enc_desc=[['relu']],       #[TODO] SD", "\n", "dec_desc", "=", "[", "[", "32", ",", "'relu'", "]", ",", "[", "None", "]", "]", ",", "#[TODO] LA", "\n", "#                       dec_desc=[[32, 'relu'], [None]],       #[TODO] SD", "\n", "mini_nn_desc", "=", "[", "[", "128", ",", "'relu'", "]", ",", "[", "'tanh'", "]", "]", ",", "#[TODO] LA", "\n", "#    mini_nn_desc=[[256, 'relu'], ['tanh']],          #[TODO] SD", "\n", "time_dependent", "=", "time_dependent", ",", "\n", "num_processing_steps", "=", "num_processing_steps", ",", "\n", "use_initial", "=", "use_initial", ",", "\n", "multistep", "=", "multistep", ",", "\n", "method", "=", "method", ",", "\n", "adjoint", "=", "adjoint", ",", "\n", "tol", "=", "tol", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "device", "=", "device", ")", "\n", "logging", ".", "info", "(", "\"new model is initialized. {}\"", ".", "format", "(", "modeldir", ")", ")", "\n", "\n", "", "num_total_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "logging", ".", "info", "(", "\"# params in model: {}\"", ".", "format", "(", "num_total_params", ")", ")", "\n", "logging", ".", "info", "(", "\"new model : \\n{}\"", ".", "format", "(", "model", ")", ")", "\n", "model", ".", "to", "(", "device", ")", "\n", "model", ".", "train", "(", ")", "\n", "phy_params", "=", "[", "]", "\n", "best_result", "=", "np", ".", "inf", "\n", "\n", "optimizer", "=", "optim", ".", "RMSprop", "(", "model", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "0.001", ",", "\n", "weight_decay", "=", "cfg", "[", "'optimizer'", "]", "[", "'weight_decay'", "]", ")", "\n", "tr_ind", ",", "val_ind", ",", "te_ind", "=", "250", ",", "300", ",", "TIME_DIM", "-", "1", "# training/validation/test split", "\n", "\n", "epoch_iter", "=", "(", "tr_ind", "-", "num_processing_steps", "-", "multistep", ")", "//", "num_processing_steps", "\n", "\n", "#### Training", "\n", "for", "iter_", "in", "range", "(", "num_iterations", ")", ":", "\n", "        ", "t", "=", "np", ".", "random", ".", "randint", "(", "input_seq", "-", "1", ",", "tr_ind", "-", "num_processing_steps", "-", "multistep", ")", "\n", "\n", "if", "input_seq", "==", "1", ":", "\n", "            ", "input_data", "=", "[", "Data", "(", "x", "=", "torch", ".", "tensor", "(", "X", "[", "t", "+", "step_t", ",", ":", ",", "1", ":", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "\n", "for", "step_t", "in", "range", "(", "num_processing_steps", ")", "]", "\n", "", "else", ":", "\n", "            ", "input_data", "=", "[", "Data", "(", "x", "=", "torch", ".", "tensor", "(", "np", ".", "concatenate", "(", "[", "X", "[", "t", "+", "step_t", "+", "i", ",", ":", ",", "1", ":", "]", "for", "i", "in", "range", "(", "input_seq", ")", "]", ",", "1", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "\n", "for", "step_t", "in", "range", "(", "num_processing_steps", ")", "]", "\n", "\n", "", "eval_times", "=", "[", "Data", "(", "t", "=", "torch", ".", "tensor", "(", "[", "t", "+", "step_t", "+", "input_seq", "-", "1", ",", "t", "+", "step_t", "+", "input_seq", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "\n", "for", "step_t", "in", "range", "(", "num_processing_steps", ")", "]", "\n", "\n", "outputs", ",", "phy_params", "=", "model", "(", "input_data", ",", "eval_times", ",", "num_processing_steps", ")", "\n", "\n", "if", "use_initial", ":", "\n", "            ", "losses", "=", "[", "sum", "(", "[", "torch", ".", "sum", "(", "(", "out", "-", "torch", ".", "tensor", "(", "X", "[", "t", "+", "step_t", "+", "multi", "+", "input_seq", "-", "1", ",", ":", ",", ":", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "**", "2", ")", "\n", "for", "multi", ",", "out", "in", "enumerate", "(", "output", ")", "]", ")", "/", "len", "(", "output", ")", "for", "step_t", ",", "output", "in", "enumerate", "(", "outputs", ")", "]", "\n", "", "else", ":", "\n", "            ", "losses", "=", "[", "sum", "(", "[", "torch", ".", "sum", "(", "(", "out", "-", "torch", ".", "tensor", "(", "X", "[", "t", "+", "1", "+", "step_t", "+", "multi", "+", "input_seq", ",", ":", ",", ":", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "**", "2", ")", "\n", "for", "multi", ",", "out", "in", "enumerate", "(", "output", ")", "]", ")", "/", "len", "(", "output", ")", "for", "step_t", ",", "output", "in", "enumerate", "(", "outputs", ")", "]", "\n", "\n", "", "loss", "=", "sum", "(", "losses", ")", "/", "len", "(", "losses", ")", "\n", "losses_save", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "\n", "writer", ".", "add_scalars", "(", "'loss/train'", ",", "{", "'loss'", ":", "losses_save", "[", "-", "1", "]", "}", ",", "iter_", ")", "\n", "writer", ".", "add_scalars", "(", "'loss/train'", ",", "{", "'loss_per_node'", ":", "losses_save", "[", "-", "1", "]", "/", "num_nodes", "}", ",", "iter_", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "iter_", "==", "0", ":", "\n", "            ", "if", "use_mini", "and", "use_physics", ":", "\n", "                ", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "modeldir", ",", "\"MINI NN + PHY\"", ")", ")", "\n", "", "elif", "use_mini", "and", "not", "use_physics", ":", "\n", "                ", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "modeldir", ",", "\"MINI NN\"", ")", ")", "\n", "", "elif", "not", "use_mini", "and", "use_physics", ":", "\n", "                ", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "modeldir", ",", "\"PHY\"", ")", ")", "\n", "\n", "#### Validation", "\n", "", "", "if", "iter_", "%", "valid_iter", "==", "0", ":", "\n", "            ", "losses_val_save", "=", "[", "]", "\n", "\n", "if", "input_seq", "==", "1", ":", "\n", "                ", "input_data", "=", "[", "Data", "(", "x", "=", "torch", ".", "tensor", "(", "X", "[", "tr_ind", "+", "step_t", ",", ":", ",", "1", ":", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "\n", "for", "step_t", "in", "range", "(", "50", "-", "multistep", ")", "]", "\n", "", "else", ":", "\n", "                ", "input_data", "=", "[", "Data", "(", "x", "=", "torch", ".", "tensor", "(", "np", ".", "concatenate", "(", "[", "X", "[", "tr_ind", "+", "step_t", "+", "i", ",", ":", ",", "1", ":", "]", "for", "i", "in", "range", "(", "input_seq", ")", "]", ",", "1", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "\n", "for", "step_t", "in", "range", "(", "51", "-", "multistep", "-", "input_seq", ")", "]", "\n", "", "eval_times", "=", "[", "Data", "(", "t", "=", "torch", ".", "tensor", "(", "[", "tr_ind", "+", "step_t", "+", "input_seq", "-", "1", ",", "tr_ind", "+", "step_t", "+", "input_seq", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "\n", "for", "step_t", "in", "range", "(", "50", "-", "multistep", ")", "]", "\n", "outputs", ",", "phy_params", "=", "model", "(", "input_data", ",", "eval_times", ",", "51", "-", "multistep", "-", "input_seq", ")", "\n", "\n", "if", "use_initial", ":", "\n", "                ", "val_losses", "=", "[", "sum", "(", "[", "torch", ".", "sum", "(", "(", "out", "-", "torch", ".", "tensor", "(", "X", "[", "tr_ind", "+", "multi", "+", "step_t", "+", "input_seq", ",", ":", ",", ":", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "**", "2", ")", "\n", "for", "multi", ",", "out", "in", "enumerate", "(", "output", "[", "1", ":", "]", ")", "]", ")", "/", "len", "(", "output", "[", "1", ":", "]", ")", "for", "step_t", ",", "output", "in", "enumerate", "(", "outputs", ")", "]", "\n", "", "else", ":", "\n", "                ", "val_losses", "=", "[", "sum", "(", "[", "torch", ".", "sum", "(", "(", "out", "-", "torch", ".", "tensor", "(", "X", "[", "tr_ind", "+", "multi", "+", "step_t", "+", "input_seq", ",", ":", ",", ":", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "**", "2", ")", "\n", "for", "multi", ",", "out", "in", "enumerate", "(", "output", ")", "]", ")", "/", "len", "(", "output", ")", "for", "step_t", ",", "output", "in", "enumerate", "(", "outputs", ")", "]", "\n", "\n", "", "val_loss", "=", "sum", "(", "val_losses", ")", "/", "len", "(", "val_losses", ")", "\n", "losses_val_save", ".", "append", "(", "val_loss", ".", "item", "(", ")", ")", "\n", "\n", "#### Test", "\n", "if", "(", "len", "(", "val_losses_save", ")", ">", "0", ")", "and", "(", "np", ".", "mean", "(", "losses_val_save", ")", "<", "np", ".", "min", "(", "val_losses_save", ")", ")", ":", "\n", "                ", "if", "use_mini", "and", "use_physics", ":", "\n", "                    ", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "modeldir", ",", "\"MINI NN + PHY\"", ")", ")", "\n", "", "elif", "use_mini", "and", "not", "use_physics", ":", "\n", "                    ", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "modeldir", ",", "\"MINI NN\"", ")", ")", "\n", "", "elif", "not", "use_mini", "and", "use_physics", ":", "\n", "                    ", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "modeldir", ",", "\"PHY\"", ")", ")", "\n", "\n", "", "if", "input_seq", "==", "1", ":", "\n", "                    ", "input_data", "=", "[", "Data", "(", "x", "=", "torch", ".", "tensor", "(", "X", "[", "val_ind", "+", "step_t", ",", ":", ",", "1", ":", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "\n", "for", "step_t", "in", "range", "(", "te_ind", "-", "val_ind", "-", "multistep", "-", "1", ")", "]", "\n", "", "else", ":", "\n", "                    ", "input_data", "=", "[", "Data", "(", "x", "=", "torch", ".", "tensor", "(", "np", ".", "concatenate", "(", "[", "X", "[", "val_ind", "+", "step_t", "+", "i", ",", ":", ",", "1", ":", "]", "for", "i", "in", "range", "(", "input_seq", ")", "]", ",", "1", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "\n", "for", "step_t", "in", "range", "(", "te_ind", "-", "val_ind", "-", "multistep", "-", "input_seq", ")", "]", "\n", "", "eval_times", "=", "[", "Data", "(", "t", "=", "torch", ".", "tensor", "(", "[", "val_ind", "+", "step_t", "+", "input_seq", "-", "1", ",", "val_ind", "+", "step_t", "+", "input_seq", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "\n", "for", "step_t", "in", "range", "(", "te_ind", "-", "val_ind", "-", "multistep", "-", "1", ")", "]", "\n", "\n", "outputs", ",", "phy_params", "=", "model", "(", "input_data", ",", "eval_times", ",", "te_ind", "-", "val_ind", "-", "multistep", "-", "input_seq", ")", "\n", "\n", "if", "use_initial", ":", "\n", "                    ", "te_losses", "=", "[", "sum", "(", "[", "torch", ".", "sum", "(", "(", "out", "-", "torch", ".", "tensor", "(", "X", "[", "val_ind", "+", "multi", "+", "step_t", "+", "1", ",", ":", ",", ":", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "**", "2", ")", "\n", "for", "multi", ",", "out", "in", "enumerate", "(", "output", "[", "1", ":", "]", ")", "]", ")", "/", "len", "(", "output", "[", "1", ":", "]", ")", "for", "step_t", ",", "output", "in", "enumerate", "(", "outputs", ")", "]", "\n", "", "else", ":", "\n", "                    ", "te_losses", "=", "[", "sum", "(", "[", "torch", ".", "sum", "(", "(", "out", "-", "torch", ".", "tensor", "(", "X", "[", "val_ind", "+", "multi", "+", "step_t", "+", "1", ",", ":", ",", ":", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", ")", "**", "2", ")", "\n", "for", "multi", ",", "out", "in", "enumerate", "(", "output", ")", "]", ")", "/", "len", "(", "output", ")", "for", "step_t", ",", "output", "in", "enumerate", "(", "outputs", ")", "]", "\n", "", "te_loss", "=", "sum", "(", "te_losses", ")", "/", "len", "(", "te_losses", ")", "\n", "\n", "if", "te_loss", ".", "item", "(", ")", "<=", "best_result", ":", "\n", "                    ", "best_result", "=", "te_loss", ".", "item", "(", ")", "\n", "\n", "", "writer", ".", "add_scalars", "(", "'loss/test'", ",", "{", "'loss_sup'", ":", "te_loss", ".", "item", "(", ")", "}", ",", "iter_", ")", "\n", "writer", ".", "add_scalars", "(", "'loss/test'", ",", "{", "'loss_sup_per_node'", ":", "te_loss", ".", "item", "(", ")", "/", "num_nodes", "}", ",", "iter_", ")", "\n", "logging", ".", "info", "(", "\"{}/{} iterations.\"", ".", "format", "(", "iter_", ",", "num_iterations", ")", ")", "\n", "logging", ".", "info", "(", "\"[Train]Loss: {:.4f} [Vali]Loss_sup: {:.4f}({:.4f}) [Test]Loss_sup: {:.4f}({:.4f})\"", "\n", ".", "format", "(", "loss", ",", "\n", "np", ".", "mean", "(", "losses_val_save", ")", ",", "np", ".", "mean", "(", "losses_val_save", ")", "/", "num_nodes", ",", "\n", "te_loss", ".", "item", "(", ")", ",", "te_loss", ".", "item", "(", ")", "/", "num_nodes", ")", ")", "\n", "\n", "", "val_losses_save", ".", "append", "(", "np", ".", "mean", "(", "losses_val_save", ")", ")", "\n", "writer", ".", "add_scalars", "(", "'loss/valid'", ",", "{", "'loss_sup'", ":", "val_losses_save", "[", "-", "1", "]", "}", ",", "iter_", ")", "\n", "writer", ".", "add_scalars", "(", "'loss/valid'", ",", "{", "'loss_sup_per_node'", ":", "val_losses_save", "[", "-", "1", "]", "/", "num_nodes", "}", ",", "iter_", ")", "\n", "\n", "\n", "", "if", "iter_", "%", "epoch_iter", "==", "0", ":", "\n", "            ", "logging", ".", "info", "(", "\"{}/{} iterations.\"", ".", "format", "(", "iter_", ",", "num_iterations", ")", ")", "\n", "logging", ".", "info", "(", "\"[Train]Loss: {:.4f} [Vali]Loss_sup: {:.4f}({:.4f})\"", "\n", ".", "format", "(", "loss", ",", "np", ".", "mean", "(", "losses_val_save", ")", ",", "np", ".", "mean", "(", "losses_val_save", ")", "/", "num_nodes", ")", ")", "\n", "\n", "\n", "", "", "logging", ".", "info", "(", "\"[Training]The smallest supervised loss: {:.4e}({:.4e}) at {}/{}\"", "\n", ".", "format", "(", "np", ".", "min", "(", "losses", ")", ",", "np", ".", "min", "(", "losses", ")", "/", "num_nodes", ",", "np", ".", "argmin", "(", "losses", ")", ",", "len", "(", "losses", ")", ")", ")", "\n", "logging", ".", "info", "(", "\"[Vali]The smallest supervised loss: {:.4e}({:.4e}) at {}/{}\"", "\n", ".", "format", "(", "np", ".", "min", "(", "val_losses_save", ")", ",", "np", ".", "min", "(", "val_losses_save", ")", "/", "num_nodes", ",", "np", ".", "argmin", "(", "val_losses_save", ")", ",", "len", "(", "val_losses_save", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.main.load_cfg": [[340, 358], ["os.path.dirname", "os.path.join", "os.path.abspath", "str", "open", "yaml.load"], "function", ["None"], ["", "def", "load_cfg", "(", "yaml_filepath", ")", ":", "\n", "    ", "\"\"\"\n    Load a YAML configuration file.\n\n    Parameters\n    ----------\n    yaml_filepath : str\n\n    Returns\n    -------\n    cfg : dict\n    \"\"\"", "\n", "root_path", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "yaml_filepath", "=", "os", ".", "path", ".", "join", "(", "root_path", ",", "str", "(", "yaml_filepath", ")", ")", "\n", "# Read YAML experiment definition file", "\n", "with", "open", "(", "yaml_filepath", ",", "'r'", ")", "as", "stream", ":", "\n", "        ", "cfg", "=", "yaml", ".", "load", "(", "stream", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.main.make_paths_absolute": [[359, 381], ["cfg.keys", "key.endswith", "os.path.join", "os.path.abspath", "type", "main.make_paths_absolute", "os.path.isfile", "logging.error"], "function", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.main.make_paths_absolute"], ["", "def", "make_paths_absolute", "(", "dir_", ",", "cfg", ")", ":", "\n", "    ", "\"\"\"\n    Make all values for keys ending with `_path` absolute to dir_.\n\n    Parameters\n    ----------\n    dir_ : str\n    cfg : dict\n\n    Returns\n    -------\n    cfg : dict\n    \"\"\"", "\n", "for", "key", "in", "cfg", ".", "keys", "(", ")", ":", "\n", "        ", "if", "key", ".", "endswith", "(", "\"_path\"", ")", ":", "\n", "            ", "cfg", "[", "key", "]", "=", "os", ".", "path", ".", "join", "(", "dir_", ",", "cfg", "[", "key", "]", ")", "\n", "cfg", "[", "key", "]", "=", "os", ".", "path", ".", "abspath", "(", "cfg", "[", "key", "]", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "cfg", "[", "key", "]", ")", ":", "\n", "                ", "logging", ".", "error", "(", "\"%s does not exist.\"", ",", "cfg", "[", "key", "]", ")", "\n", "", "", "if", "type", "(", "cfg", "[", "key", "]", ")", "is", "dict", ":", "\n", "            ", "cfg", "[", "key", "]", "=", "make_paths_absolute", "(", "dir_", ",", "cfg", "[", "key", "]", ")", "\n", "", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.blocks.FFNN.__init__": [[12, 43], ["super().__init__", "utils.get_ffnn", "print", "int", "ValueError", "int", "ValueError"], "methods", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.model.ODENet.__init__", "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.get_ffnn"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "output_size", ",", "nn_desc", ",", "dropout_rate", "=", "0.0", ",", "\n", "bias", "=", "True", ",", "residual", "=", "False", ",", "bn", "=", "False", ",", "input_tanh", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# create feed-forward NN", "\n", "in_size", "=", "input_size", "\n", "self", ".", "ffnn", "=", "get_ffnn", "(", "\n", "input_size", "=", "in_size", ",", "output_size", "=", "output_size", ",", "\n", "nn_desc", "=", "nn_desc", ",", "dropout_rate", "=", "dropout_rate", ",", "bias", "=", "bias", ",", "bn", "=", "bn", "\n", ")", "\n", "self", ".", "input_tanh", "=", "input_tanh", "\n", "if", "residual", ":", "\n", "            ", "print", "(", "'use residual network: input_size={}, output_size={}'", ".", "format", "(", "\n", "input_size", ",", "output_size", ")", ")", "\n", "if", "input_size", "<=", "output_size", ":", "\n", "                ", "if", "output_size", "%", "input_size", "==", "0", ":", "\n", "                    ", "self", ".", "case", "=", "1", "\n", "self", ".", "mult", "=", "int", "(", "output_size", "/", "input_size", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'for residual: output_size needs to be '", "\n", "'multiple of input_size'", ")", "\n", "\n", "", "", "if", "input_size", ">", "output_size", ":", "\n", "                ", "if", "input_size", "%", "output_size", "==", "0", ":", "\n", "                    ", "self", ".", "case", "=", "2", "\n", "self", ".", "mult", "=", "int", "(", "input_size", "/", "output_size", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'for residual: input_size needs to be '", "\n", "'multiple of output_size'", ")", "\n", "", "", "", "else", ":", "\n", "            ", "self", ".", "case", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.blocks.FFNN.forward": [[44, 59], ["blocks.FFNN.ffnn", "blocks.FFNN.ffnn", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "nn_input.repeat", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "nn_input.chunk"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "nn_input", ",", "mask", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "input_tanh", ":", "\n", "            ", "out", "=", "self", ".", "ffnn", "(", "torch", ".", "tanh", "(", "nn_input", ")", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "ffnn", "(", "nn_input", ")", "\n", "\n", "", "if", "self", ".", "case", "==", "0", ":", "\n", "            ", "return", "out", "\n", "", "elif", "self", ".", "case", "==", "1", ":", "\n", "            ", "identity", "=", "nn_input", ".", "repeat", "(", "1", ",", "self", ".", "mult", ")", "\n", "return", "identity", "+", "out", "\n", "", "elif", "self", ".", "case", "==", "2", ":", "\n", "            ", "identity", "=", "torch", ".", "mean", "(", "torch", ".", "stack", "(", "nn_input", ".", "chunk", "(", "self", ".", "mult", ",", "dim", "=", "1", ")", ")", ",", "\n", "dim", "=", "0", ")", "\n", "return", "identity", "+", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.blocks.ODEfunc.__init__": [[62, 110], ["torch.Module.__init__", "blocks.FFNN", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.Parameter().to", "torch.Parameter().to", "blocks.FFNN", "torch.Parameter", "torch.Parameter"], "methods", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.model.ODENet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "enc_node_feat", ",", "\n", "laplacian", ",", "\n", "one_hot_encoder", ",", "\n", "edge_attr_type", ",", "\n", "num_nodes", ",", "\n", "use_mini", ",", "\n", "use_physics", ",", "\n", "augment_dim", ",", "\n", "mini_nn_desc", ",", "\n", "dropout", ",", "\n", "time_dependent", ",", "\n", "device", ")", ":", "\n", "        ", "super", "(", "ODEfunc", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "nfe", "=", "0", "\n", "self", ".", "input_dim", "=", "enc_node_feat", "\n", "self", ".", "laplacian", "=", "laplacian", "\n", "self", ".", "one_hot_encoder", "=", "one_hot_encoder", "\n", "self", ".", "time_dependent", "=", "time_dependent", "\n", "self", ".", "num_nodes", "=", "num_nodes", "\n", "self", ".", "use_mini", "=", "use_mini", "\n", "self", ".", "use_physics", "=", "use_physics", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "augment_dim", "=", "augment_dim", "\n", "\n", "if", "self", ".", "use_mini", "and", "self", ".", "time_dependent", ":", "\n", "            ", "self", ".", "mini_net", "=", "FFNN", "(", "self", ".", "input_dim", "+", "self", ".", "augment_dim", "+", "1", ",", "self", ".", "input_dim", ",", "mini_nn_desc", ",", "input_tanh", "=", "False", ")", "\n", "\n", "", "elif", "self", ".", "use_mini", "and", "not", "self", ".", "time_dependent", ":", "\n", "            ", "self", ".", "mini_net", "=", "FFNN", "(", "self", ".", "input_dim", "+", "self", ".", "augment_dim", ",", "self", ".", "input_dim", ",", "mini_nn_desc", ",", "input_tanh", "=", "False", ")", "\n", "\n", "", "else", ":", "\n", "            ", "self", ".", "mini_net", "=", "None", "\n", "\n", "", "if", "self", ".", "use_physics", "==", "1", ":", "\n", "# [TODO] for edge attr - wise k <LA>", "\n", "            ", "_", "=", "torch", ".", "rand", "(", "size", "=", "(", "edge_attr_type", ",", "1", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# [TODO] for edge wise k - random initialize <SD, NOAA>", "\n", "# _ = torch.rand(size=(num_nodes,num_nodes), dtype=torch.float32, device=self.device, requires_grad=True)", "\n", "\n", "# [TODO] for single scalar k", "\n", "# _ = (torch.rand(1, dtype=torch.float32, device=self.device, requires_grad=True))", "\n", "\n", "self", ".", "phy_params", "=", "nn", ".", "Parameter", "(", "_", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "else", ":", "\n", "            ", "self", ".", "phy_params", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.blocks.ODEfunc.forward": [[111, 148], ["blocks.ODEfunc.one_hot_encoder.mm().reshape", "torch.mul().mm", "torch.mul().mm", "torch.mul().mm", "torch.mul().mm", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "blocks.ODEfunc.mini_net", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "blocks.ODEfunc.one_hot_encoder.mm", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "t", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "augment_dim", "!=", "0", "and", "self", ".", "use_mini", ":", "\n", "            ", "augment", "=", "x", "[", ":", ",", "self", ".", "input_dim", ":", "]", "\n", "x_phy", "=", "x", "[", ":", ",", ":", "self", ".", "input_dim", "]", "#228,64", "\n", "forward_x", "=", "x_phy", "\n", "", "else", ":", "\n", "            ", "augment", "=", "None", "\n", "x_phy", "=", "x", "\n", "forward_x", "=", "x_phy", "\n", "\n", "", "if", "self", ".", "use_physics", "==", "1", ":", "\n", "# [TODO] for edge attributes <LA>", "\n", "             ", "_", "=", "self", ".", "one_hot_encoder", ".", "mm", "(", "self", ".", "phy_params", ")", ".", "reshape", "(", "self", ".", "num_nodes", ",", "self", ".", "num_nodes", ")", "\n", "phy_forward", "=", "torch", ".", "mul", "(", "_", ",", "self", ".", "laplacian", ")", ".", "mm", "(", "x_phy", ")", "\n", "\n", "# [TODO] for edgewise laplacian <SD, NOAA>", "\n", "# phy_forward = (self.phy_params*self.laplacian).mm(x_phy)", "\n", "\n", "", "else", ":", "\n", "            ", "phy_forward", "=", "torch", ".", "zeros", "(", "x", ".", "shape", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "#228,64", "\n", "", "if", "self", ".", "time_dependent", ":", "\n", "            ", "t_vec", "=", "torch", ".", "ones", "(", "forward_x", ".", "shape", "[", "0", "]", ",", "1", ")", ".", "to", "(", "self", ".", "device", ")", "*", "t", "\n", "t_and_x", "=", "torch", ".", "cat", "(", "[", "t_vec", ",", "forward_x", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "t_and_x", "=", "forward_x", "\n", "\n", "# return", "\n", "", "if", "self", ".", "use_mini", ":", "\n", "            ", "new_x", "=", "phy_forward", "+", "self", ".", "mini_net", "(", "t_and_x", ")", "\n", "if", "augment", "!=", "None", ":", "\n", "                ", "return", "torch", ".", "cat", "(", "[", "new_x", ",", "torch", ".", "zeros_like", "(", "augment", ")", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "return", "new_x", "\n", "", "", "else", ":", "\n", "            ", "return", "phy_forward", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.blocks.ODEBlock.__init__": [[163, 176], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.model.ODENet.__init__"], ["def", "__init__", "(", "self", ",", "\n", "device", "=", "'cuda'", ",", "\n", "odefunc", "=", "None", ",", "\n", "method", "=", "'rk4'", ",", "\n", "adjoint", "=", "True", ",", "\n", "tol", "=", "1e-3", ")", ":", "\n", "        ", "super", "(", "ODEBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "odefunc", "=", "odefunc", "\n", "self", ".", "tol", "=", "tol", "\n", "self", ".", "method", "=", "method", "\n", "self", ".", "adjoint", "=", "adjoint", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.blocks.ODEBlock.forward": [[177, 219], ["torch.tensor().float().type_as", "torch.tensor().float().type_as", "torch.tensor().float().type_as", "torch.tensor().float().type_as", "eval_times.type_as", "torchdiffeq.odeint_adjoint", "torchdiffeq.odeint_adjoint", "torchdiffeq.odeint", "torchdiffeq.odeint", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "eval_times", "=", "None", ")", ":", "\n", "        ", "\"\"\"Solves ODE starting from x.\n        Parameters\n        ----------\n        x : torch.Tensor\n            Shape (batch_size, self.odefunc.data_dim)\n        eval_times : None or torch.Tensor\n            If None, returns solution of ODE at final time t=1. If torch.Tensor\n            then returns full ODE trajectory evaluated at points in eval_times.\n        \"\"\"", "\n", "# Forward pass corresponds to solving ODE, so reset number of function", "\n", "# evaluations counter", "\n", "self", ".", "odefunc", ".", "nfe", "=", "0", "\n", "aug_x", "=", "x", "\n", "\n", "# self.odefunc.phy_features = phy_coeff_mat", "\n", "if", "eval_times", "is", "None", ":", "\n", "            ", "integration_time", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "float", "(", ")", ".", "type_as", "(", "aug_x", ")", "\n", "", "else", ":", "\n", "            ", "integration_time", "=", "eval_times", ".", "type_as", "(", "aug_x", ")", "\n", "\n", "", "if", "self", ".", "adjoint", ":", "\n", "            ", "if", "self", ".", "method", "==", "'dopri5'", ":", "\n", "                ", "out", "=", "odeint_adjoint", "(", "self", ".", "odefunc", ",", "aug_x", ",", "integration_time", ",", "\n", "rtol", "=", "self", ".", "tol", ",", "atol", "=", "self", ".", "tol", ",", "method", "=", "self", ".", "method", ",", "\n", "options", "=", "{", "'max_num_steps'", ":", "MAX_NUM_STEPS", "}", ")", "\n", "", "else", ":", "\n", "                ", "out", "=", "odeint_adjoint", "(", "self", ".", "odefunc", ",", "aug_x", ",", "integration_time", ",", "\n", "rtol", "=", "self", ".", "tol", ",", "atol", "=", "self", ".", "tol", ",", "method", "=", "self", ".", "method", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "if", "self", ".", "method", "==", "'dopri5'", ":", "\n", "                ", "out", "=", "odeint", "(", "self", ".", "odefunc", ",", "aug_x", ",", "integration_time", ",", "\n", "rtol", "=", "self", ".", "tol", ",", "atol", "=", "self", ".", "tol", ",", "method", "=", "self", ".", "method", ",", "\n", "options", "=", "{", "'max_num_steps'", ":", "MAX_NUM_STEPS", "}", ")", "\n", "", "else", ":", "\n", "                ", "out", "=", "odeint", "(", "self", ".", "odefunc", ",", "aug_x", ",", "integration_time", ",", "\n", "rtol", "=", "self", ".", "tol", ",", "atol", "=", "self", ".", "tol", ",", "method", "=", "self", ".", "method", ")", "\n", "\n", "", "", "phy_params", "=", "self", ".", "odefunc", ".", "phy_params", "\n", "\n", "return", "out", ",", "phy_params", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.model.ODENet.__init__": [[35, 71], ["torch.Module.__init__", "blocks.ODEfunc", "blocks.FFNN", "blocks.FFNN", "blocks.ODEBlock"], "methods", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.model.ODENet.__init__"], ["def", "__init__", "(", "self", ",", "\n", "node_features", ",", "\n", "enc_node_features", ",", "\n", "laplacian", ",", "\n", "one_hot_encoder", ",", "\n", "edge_attr_type", ",", "\n", "num_nodes", ",", "\n", "use_mini", "=", "True", ",", "\n", "use_physics", "=", "True", ",", "\n", "augment_dim", "=", "0", ",", "\n", "enc_desc", "=", "None", ",", "\n", "dec_desc", "=", "None", ",", "\n", "mini_nn_desc", "=", "None", ",", "\n", "time_dependent", "=", "False", ",", "\n", "num_processing_steps", "=", "10", ",", "\n", "use_initial", "=", "False", ",", "\n", "multistep", "=", "1", ",", "\n", "method", "=", "'rk4'", ",", "\n", "adjoint", "=", "True", ",", "\n", "tol", "=", "1e-3", ",", "\n", "dropout_rate", "=", "0", ",", "\n", "device", "=", "'cpu'", ",", "\n", ")", ":", "\n", "        ", "super", "(", "ODENet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_processing_steps", "=", "num_processing_steps", "\n", "self", ".", "multistep", "=", "multistep", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "odefunc", "=", "ODEfunc", "(", "enc_node_features", ",", "laplacian", ",", "one_hot_encoder", ",", "edge_attr_type", ",", "\n", "num_nodes", ",", "use_mini", ",", "use_physics", ",", "augment_dim", ",", "mini_nn_desc", ",", "dropout_rate", ",", "\n", "time_dependent", ",", "device", ")", "\n", "self", ".", "use_initial", "=", "use_initial", "\n", "self", ".", "augment_dim", "=", "augment_dim", "\n", "self", ".", "node_enc", "=", "FFNN", "(", "node_features", ",", "enc_node_features", ",", "enc_desc", ",", "dropout_rate", ",", "True", ",", "False", ",", "input_tanh", "=", "False", ")", "\n", "self", ".", "node_dec", "=", "FFNN", "(", "enc_node_features", ",", "1", ",", "dec_desc", ",", "dropout_rate", ",", "True", ",", "False", ",", "input_tanh", "=", "False", ")", "\n", "\n", "self", ".", "odeblock", "=", "ODEBlock", "(", "device", ",", "self", ".", "odefunc", ",", "method", ",", "adjoint", ",", "tol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.model.ODENet.forward": [[72, 102], ["range", "model.ODENet.node_enc", "range", "range", "model.ODENet.node_dec", "model.ODENet.odeblock", "model.ODENet.odeblock", "model.ODENet.node_dec", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "model.ODENet.node_dec", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "eval_times", ",", "num_processing_steps", ")", ":", "\n", "        ", "encoded_inputs", "=", "[", "]", "\n", "outs", "=", "[", "]", "\n", "self", ".", "num_processing_steps", "=", "num_processing_steps", "\n", "\n", "for", "step_t", "in", "range", "(", "self", ".", "num_processing_steps", ")", ":", "\n", "            ", "outs_tmp", "=", "[", "]", "\n", "encoded_input", "=", "self", ".", "node_enc", "(", "x", "[", "step_t", "]", ".", "x", ")", "\n", "time_integral", "=", "eval_times", "[", "step_t", "]", ".", "t", "\n", "\n", "if", "self", ".", "use_initial", ":", "\n", "                ", "outs_tmp", "+=", "[", "self", ".", "node_dec", "(", "encoded_input", ")", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "multistep", ")", ":", "\n", "                    ", "ode_out", ",", "phy_params", "=", "self", ".", "odeblock", "(", "encoded_input", ",", "time_integral", ")", "\n", "encoded_input", "=", "ode_out", "[", "-", "1", "]", "\n", "tmp_out", "=", "self", ".", "node_dec", "(", "ode_out", ")", "[", "-", "1", "]", "\n", "outs_tmp", "+=", "[", "tmp_out", "]", "\n", "time_integral", "=", "torch", ".", "ones", "(", "2", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ")", "+", "time_integral", "\n", "", "outs", "+=", "[", "outs_tmp", "]", "\n", "\n", "", "else", ":", "\n", "                ", "for", "i", "in", "range", "(", "self", ".", "multistep", ")", ":", "\n", "                    ", "ode_out", ",", "phy_params", "=", "self", ".", "odeblock", "(", "encoded_input", ",", "time_integral", ")", "\n", "encoded_input", "=", "ode_out", "[", "-", "1", "]", "\n", "tmp_out", "=", "self", ".", "node_dec", "(", "ode_out", ")", "[", "-", "1", "]", "\n", "outs_tmp", "+=", "[", "tmp_out", "]", "\n", "time_integral", "=", "torch", ".", "ones", "(", "2", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "self", ".", "device", ")", "+", "time_integral", "\n", "", "outs", "+=", "[", "outs_tmp", "]", "\n", "\n", "", "", "return", "outs", ",", "phy_params", "", "", "", ""]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.get_edge_index_from_nxG": [[18, 28], ["networkx.adj_matrix", "nx.adj_matrix.nonzero", "torch.tensor", "torch.tensor", "torch.stack"], "function", ["None"], ["def", "get_edge_index_from_nxG", "(", "G", ")", ":", "\n", "    ", "\"\"\"return edge_index for torch_geometric.data.data.Data\n    G is networkx Graph.\n    \"\"\"", "\n", "A", "=", "nx", ".", "adj_matrix", "(", "G", ")", "# A: sparse.csr_matrix", "\n", "r", ",", "c", "=", "A", ".", "nonzero", "(", ")", "\n", "r", "=", "torch", ".", "tensor", "(", "r", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "c", "=", "torch", ".", "tensor", "(", "c", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "return", "torch", ".", "stack", "(", "[", "r", ",", "c", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.maybe_num_nodes": [[30, 32], ["edge_index.max().item", "edge_index.max"], "function", ["None"], ["", "def", "maybe_num_nodes", "(", "edge_index", ",", "num_nodes", "=", "None", ")", ":", "\n", "    ", "return", "edge_index", ".", "max", "(", ")", ".", "item", "(", ")", "+", "1", "if", "num_nodes", "is", "None", "else", "num_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.remove_self_loops": [[34, 42], ["mask.unsqueeze().expand_as.unsqueeze().expand_as", "edge_index[].view", "mask.unsqueeze().expand_as.unsqueeze"], "function", ["None"], ["", "def", "remove_self_loops", "(", "edge_index", ",", "edge_attr", "=", "None", ")", ":", "\n", "    ", "row", ",", "col", "=", "edge_index", "\n", "mask", "=", "row", "!=", "col", "\n", "edge_attr", "=", "edge_attr", "if", "edge_attr", "is", "None", "else", "edge_attr", "[", "mask", "]", "\n", "mask", "=", "mask", ".", "unsqueeze", "(", "0", ")", ".", "expand_as", "(", "edge_index", ")", "\n", "edge_index", "=", "edge_index", "[", "mask", "]", ".", "view", "(", "2", ",", "-", "1", ")", "\n", "\n", "return", "edge_index", ",", "edge_attr", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.add_self_loops": [[44, 53], ["utils.maybe_num_nodes", "torch.arange", "loop.unsqueeze().repeat.unsqueeze().repeat", "torch.cat", "loop.unsqueeze().repeat.unsqueeze"], "function", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.maybe_num_nodes"], ["", "def", "add_self_loops", "(", "edge_index", ",", "num_nodes", "=", "None", ")", ":", "\n", "    ", "num_nodes", "=", "maybe_num_nodes", "(", "edge_index", ",", "num_nodes", ")", "\n", "\n", "dtype", ",", "device", "=", "edge_index", ".", "dtype", ",", "edge_index", ".", "device", "\n", "loop", "=", "torch", ".", "arange", "(", "0", ",", "num_nodes", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "loop", "=", "loop", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "2", ",", "1", ")", "\n", "edge_index", "=", "torch", ".", "cat", "(", "[", "edge_index", ",", "loop", "]", ",", "dim", "=", "1", ")", "\n", "\n", "return", "edge_index", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.edge_index_from_dict": [[55, 66], ["graph_dict.items", "torch.stack", "utils..", "torch_sparse.coalesce", "itertools.repeat", "len", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "def", "edge_index_from_dict", "(", "graph_dict", ",", "num_nodes", "=", "None", ")", ":", "\n", "    ", "row", ",", "col", "=", "[", "]", ",", "[", "]", "\n", "for", "key", ",", "value", "in", "graph_dict", ".", "items", "(", ")", ":", "\n", "        ", "row", "+=", "repeat", "(", "key", ",", "len", "(", "value", ")", ")", "\n", "col", "+=", "value", "\n", "", "edge_index", "=", "torch", ".", "stack", "(", "[", "torch", ".", "tensor", "(", "row", ")", ",", "torch", ".", "tensor", "(", "col", ")", "]", ",", "dim", "=", "0", ")", "\n", "# NOTE: There are duplicated edges and self loops in the datasets. Other", "\n", "# implementations do not remove them!", "\n", "edge_index", ",", "_", "=", "remove_self_loops", "(", "edge_index", ")", "\n", "edge_index", ",", "_", "=", "coalesce", "(", "edge_index", ",", "None", ",", "num_nodes", ",", "num_nodes", ")", "\n", "return", "edge_index", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.degree": [[68, 92], ["utils.maybe_num_nodes", "torch.zeros", "torch.zeros.scatter_add_", "torch.zeros.new_ones", "index.size"], "function", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.maybe_num_nodes"], ["", "def", "degree", "(", "index", ",", "num_nodes", "=", "None", ",", "dtype", "=", "None", ",", "device", "=", "None", ")", ":", "\n", "    ", "\"\"\"Computes the degree of a given index tensor.\n    Args:\n        index (LongTensor): Source or target indices of edges.\n        num_nodes (int, optional): The number of nodes in :attr:`index`.\n            (default: :obj:`None`)\n        dtype (:obj:`torch.dtype`, optional). The desired data type of returned\n            tensor.\n        device (:obj:`torch.device`, optional): The desired device of returned\n            tensor.\n    :rtype: :class:`Tensor`\n    .. testsetup::\n        import torch\n    .. testcode::\n        from torch_geometric.utils import degree\n        index = torch.tensor([0, 1, 0, 2, 0])\n        output = degree(index)\n        print(output)\n    .. testoutput::\n       tensor([ 3.,  1.,  1.])\n    \"\"\"", "\n", "num_nodes", "=", "maybe_num_nodes", "(", "index", ",", "num_nodes", ")", "\n", "out", "=", "torch", ".", "zeros", "(", "(", "num_nodes", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "return", "out", ".", "scatter_add_", "(", "0", ",", "index", ",", "out", ".", "new_ones", "(", "(", "index", ".", "size", "(", "0", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.normalized_cut": [[94, 100], ["utils.degree"], "function", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.degree"], ["", "def", "normalized_cut", "(", "edge_index", ",", "edge_attr", ",", "num_nodes", "=", "None", ")", ":", "\n", "    ", "row", ",", "col", "=", "edge_index", "\n", "deg", "=", "1", "/", "degree", "(", "row", ",", "num_nodes", ",", "edge_attr", ".", "dtype", ",", "edge_attr", ".", "device", ")", "\n", "deg", "=", "deg", "[", "row", "]", "+", "deg", "[", "col", "]", "\n", "cut", "=", "edge_attr", "*", "deg", "\n", "return", "cut", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.to_sparse": [[102, 113], ["getattr", "torch.nonzero", "indices.t.t", "getattr.", "torch.typename().split", "len", "getattr.", "x.size", "tuple", "torch.typename", "range"], "function", ["None"], ["", "def", "to_sparse", "(", "x", ")", ":", "\n", "    ", "\"\"\" converts dense tensor x to sparse format \"\"\"", "\n", "x_typename", "=", "torch", ".", "typename", "(", "x", ")", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "sparse_tensortype", "=", "getattr", "(", "torch", ".", "sparse", ",", "x_typename", ")", "\n", "\n", "indices", "=", "torch", ".", "nonzero", "(", "x", ")", "\n", "if", "len", "(", "indices", ".", "shape", ")", "==", "0", ":", "# if all elements are zeros", "\n", "        ", "return", "sparse_tensortype", "(", "*", "x", ".", "shape", ")", "\n", "", "indices", "=", "indices", ".", "t", "(", ")", "\n", "values", "=", "x", "[", "tuple", "(", "indices", "[", "i", "]", "for", "i", "in", "range", "(", "indices", ".", "shape", "[", "0", "]", ")", ")", "]", "\n", "return", "sparse_tensortype", "(", "indices", ",", "values", ",", "x", ".", "size", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.get_adj": [[114, 130], ["torch.sparse.FloatTensor", "torch.eye().to_sparse", "torch.ones", "torch.eye"], "function", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.to_sparse"], ["", "def", "get_adj", "(", "edge_index", ",", "weight", "=", "None", ",", "augmented", "=", "False", ",", "undirected", "=", "True", ")", ":", "\n", "    ", "\"\"\"return adjacency matrix\"\"\"", "\n", "if", "not", "weight", ":", "\n", "        ", "weight", "=", "torch", ".", "ones", "(", "edge_index", ".", "shape", "[", "1", "]", ")", "\n", "\n", "", "row", ",", "col", "=", "edge_index", "\n", "# if undirected:", "\n", "#     adj = np.maximum.reduce([adj.asarray(), adj.T]).to_sparse()", "\n", "# else:", "\n", "adj", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "edge_index", ",", "weight", ")", "\n", "identity", "=", "torch", ".", "eye", "(", "adj", ".", "shape", "[", "0", "]", ")", ".", "to_sparse", "(", ")", "\n", "\n", "if", "augmented", "==", "True", ":", "\n", "        ", "return", "adj", "+", "identity", "\n", "", "else", ":", "\n", "        ", "return", "adj", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.get_laplacian": [[131, 170], ["utils.get_adj", "torch_scatter.scatter_add", "torch.sparse.FloatTensor", "deg.pow.pow", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor.mm", "torch.ones", "torch.tensor", "torch.tensor", "Laplacian.mm", "torch.sparse.FloatTensor.to_dense", "Laplacian.to_dense", "range", "range", "float", "range", "range", "utils.to_sparse", "utils.get_adj", "torch_scatter.scatter_add", "torch.sparse.FloatTensor", "deg.pow.pow", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor.mm", "ValueError", "torch.ones", "torch.tensor", "torch.tensor", "Laplacian.mm", "utils.to_sparse", "torch.sparse.FloatTensor.to_dense", "range", "range", "float", "range", "range"], "function", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.get_adj", "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.to_sparse", "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.get_adj", "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.to_sparse"], ["", "", "def", "get_laplacian", "(", "edge_index", ",", "weight", "=", "None", ",", "type", "=", "'norm'", ",", "sparse", "=", "True", ")", ":", "\n", "    ", "\"\"\"return Laplacian (sparse tensor)\n    type: 'comb' or 'norm' for combinatorial or normalized one.\n    \"\"\"", "\n", "adj", "=", "get_adj", "(", "edge_index", ",", "weight", "=", "weight", ")", "# torch.sparse.FloatTensor", "\n", "num_nodes", "=", "adj", ".", "shape", "[", "1", "]", "\n", "senders", ",", "receivers", "=", "edge_index", "\n", "num_edges", "=", "edge_index", ".", "shape", "[", "1", "]", "\n", "\n", "deg", "=", "scatter_add", "(", "torch", ".", "ones", "(", "num_edges", ")", ",", "senders", ")", "\n", "sp_deg", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "torch", ".", "tensor", "(", "[", "range", "(", "num_nodes", ")", ",", "range", "(", "num_nodes", ")", "]", ")", ",", "deg", ")", "\n", "Laplacian", "=", "sp_deg", "-", "adj", "# L = D-A", "\n", "\n", "deg", "=", "deg", ".", "pow", "(", "-", "0.5", ")", "\n", "deg", "[", "deg", "==", "float", "(", "'inf'", ")", "]", "=", "0", "\n", "sp_deg", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "torch", ".", "tensor", "(", "[", "range", "(", "num_nodes", ")", ",", "range", "(", "num_nodes", ")", "]", ")", ",", "deg", ")", "\n", "Laplacian_norm", "=", "sp_deg", ".", "mm", "(", "Laplacian", ".", "mm", "(", "sp_deg", ".", "to_dense", "(", ")", ")", ")", "# Lsym = (D^-1/2)L(D^-1/2)", "\n", "\n", "if", "type", "==", "\"comb\"", ":", "\n", "        ", "return", "Laplacian", "if", "sparse", "else", "Laplacian", ".", "to_dense", "(", ")", "\n", "", "elif", "type", "==", "\"norm\"", ":", "\n", "        ", "return", "to_sparse", "(", "Laplacian_norm", ")", "if", "sparse", "else", "Laplacian_norm", "\n", "", "elif", "type", "==", "\"aug\"", ":", "\n", "        ", "aug_adj", "=", "get_adj", "(", "edge_index", ",", "weight", "=", "weight", ",", "augmented", "=", "True", ")", "\n", "num_nodes", "=", "aug_adj", ".", "shape", "[", "1", "]", "\n", "senders", ",", "receivers", "=", "edge_index", "\n", "num_edges", "=", "edge_index", ".", "shape", "[", "1", "]", "\n", "\n", "deg", "=", "scatter_add", "(", "torch", ".", "ones", "(", "num_edges", ")", ",", "senders", ")", "\n", "sp_deg", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "torch", ".", "tensor", "(", "[", "range", "(", "num_nodes", ")", ",", "range", "(", "num_nodes", ")", "]", ")", ",", "deg", ")", "\n", "Laplacian", "=", "sp_deg", "-", "aug_adj", "\n", "\n", "deg", "=", "deg", ".", "pow", "(", "-", "0.5", ")", "\n", "deg", "[", "deg", "==", "float", "(", "'inf'", ")", "]", "=", "0", "\n", "sp_deg", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "torch", ".", "tensor", "(", "[", "range", "(", "num_nodes", ")", ",", "range", "(", "num_nodes", ")", "]", ")", ",", "deg", ")", "\n", "aug_Laplacian_norm", "=", "sp_deg", ".", "mm", "(", "Laplacian", ".", "mm", "(", "sp_deg", ".", "to_dense", "(", ")", ")", ")", "\n", "return", "to_sparse", "(", "aug_Laplacian_norm", ")", "if", "sparse", "else", "aug_Laplacian_norm", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"type should be one of ['comb', 'norm']\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.decompose_graph": [[171, 186], ["None"], "function", ["None"], ["", "", "def", "decompose_graph", "(", "graph", ")", ":", "\n", "# graph: torch_geometric.data.data.Data", "\n", "    ", "x", ",", "edge_index", ",", "edge_attr", ",", "global_attr", "=", "None", ",", "None", ",", "None", ",", "None", "\n", "for", "key", "in", "graph", ".", "keys", ":", "\n", "        ", "if", "key", "==", "\"x\"", ":", "\n", "            ", "x", "=", "graph", ".", "x", "\n", "", "elif", "key", "==", "\"edge_index\"", ":", "\n", "            ", "edge_index", "=", "graph", ".", "edge_index", "\n", "", "elif", "key", "==", "\"edge_attr\"", ":", "\n", "            ", "edge_attr", "=", "graph", ".", "edge_attr", "\n", "", "elif", "key", "==", "\"global_attr\"", ":", "\n", "            ", "global_attr", "=", "graph", ".", "global_attr", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "", "", "return", "(", "x", ",", "edge_index", ",", "edge_attr", ",", "global_attr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.graph_concat": [[188, 228], ["torch_geometric.data.Data", "torch.cat", "torch.cat", "torch.cat", "ValueError", "ValueError", "ValueError"], "function", ["None"], ["", "def", "graph_concat", "(", "graph1", ",", "graph2", ",", "\n", "node_cat", "=", "True", ",", "edge_cat", "=", "True", ",", "global_cat", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        graph1: torch_geometric.data.data.Data\n        graph2: torch_geometric.data.data.Data\n        node_cat: True if concat node_attr\n        edge_cat: True if concat edge_attr\n        global_cat: True if concat global_attr\n    Return:\n        new graph: concat(graph1, graph2)\n    \"\"\"", "\n", "# graph2 attr is used for attr that is not concated.", "\n", "_x", "=", "graph2", ".", "x", "\n", "_edge_attr", "=", "graph2", ".", "edge_attr", "\n", "_global_attr", "=", "graph2", ".", "global_attr", "\n", "_edge_index", "=", "graph2", ".", "edge_index", "\n", "\n", "if", "node_cat", ":", "\n", "        ", "try", ":", "\n", "            ", "_x", "=", "torch", ".", "cat", "(", "[", "graph1", ".", "x", ",", "graph2", ".", "x", "]", ",", "dim", "=", "-", "1", ")", "\n", "", "except", ":", "\n", "            ", "raise", "ValueError", "(", "\"Both graph1 and graph2 should have 'x' key.\"", ")", "\n", "\n", "", "", "if", "edge_cat", ":", "\n", "        ", "try", ":", "\n", "            ", "_edge_attr", "=", "torch", ".", "cat", "(", "[", "graph1", ".", "edge_attr", ",", "graph2", ".", "edge_attr", "]", ",", "dim", "=", "-", "1", ")", "\n", "", "except", ":", "\n", "            ", "raise", "ValueError", "(", "\"Both graph1 and graph2 should have 'edge_attr' key.\"", ")", "\n", "\n", "", "", "if", "global_cat", ":", "\n", "        ", "try", ":", "\n", "            ", "_global_attr", "=", "torch", ".", "cat", "(", "[", "graph1", ".", "global_attr", ",", "graph2", ".", "global_attr", "]", ",", "dim", "=", "-", "1", ")", "\n", "", "except", ":", "\n", "            ", "raise", "ValueError", "(", "\"Both graph1 and graph2 should have 'global_attr' key.\"", ")", "\n", "\n", "", "", "ret", "=", "Data", "(", "x", "=", "_x", ",", "edge_attr", "=", "_edge_attr", ",", "edge_index", "=", "_edge_index", ")", "\n", "ret", ".", "global_attr", "=", "_global_attr", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.copy_geometric_data": [[230, 241], ["utils.decompose_graph", "torch_geometric.data.Data"], "function", ["home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.decompose_graph"], ["", "def", "copy_geometric_data", "(", "graph", ")", ":", "\n", "    ", "\"\"\"return a copy of torch_geometric.data.data.Data\n    This function should be carefully used based on\n    which keys in a given graph.\n    \"\"\"", "\n", "node_attr", ",", "edge_index", ",", "edge_attr", ",", "global_attr", "=", "decompose_graph", "(", "graph", ")", "\n", "\n", "ret", "=", "Data", "(", "x", "=", "node_attr", ",", "edge_index", "=", "edge_index", ",", "edge_attr", "=", "edge_attr", ")", "\n", "ret", ".", "global_attr", "=", "global_attr", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.z_score": [[242, 249], ["torch.tensor", "torch.tensor", "torch.div", "torch.subtract"], "function", ["None"], ["", "def", "z_score", "(", "x", ",", "mean", ",", "std", ",", "dtype", "=", "None", ",", "device", "=", "None", ")", ":", "\n", "    ", "if", "dtype", "==", "'tensor'", ":", "\n", "        ", "mean", "=", "torch", ".", "tensor", "(", "mean", ",", "dtype", "=", "torch", ".", "float64", ",", "device", "=", "device", ")", "\n", "std", "=", "torch", ".", "tensor", "(", "std", ",", "dtype", "=", "torch", ".", "float64", ",", "device", "=", "device", ")", "\n", "return", "torch", ".", "div", "(", "torch", ".", "subtract", "(", "x", ",", "mean", ")", ",", "std", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "x", "-", "mean", ")", "/", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.z_inverse": [[250, 257], ["torch.tensor", "torch.tensor", "torch.add", "torch.mul"], "function", ["None"], ["", "", "def", "z_inverse", "(", "x", ",", "mean", ",", "std", ",", "dtype", "=", "None", ",", "device", "=", "None", ")", ":", "\n", "    ", "if", "dtype", "==", "'tensor'", ":", "\n", "        ", "mean", "=", "torch", ".", "tensor", "(", "mean", ",", "dtype", "=", "torch", ".", "float64", ",", "device", "=", "device", ")", "\n", "std", "=", "torch", ".", "tensor", "(", "std", ",", "dtype", "=", "torch", ".", "float64", ",", "device", "=", "device", ")", "\n", "return", "torch", ".", "add", "(", "torch", ".", "mul", "(", "x", ",", "std", ")", ",", "mean", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "x", "*", "std", ")", "+", "mean", "\n", "\n"]], "home.repos.pwc.inspect_result.jeehyunhwang_neural-diffusion-equation.None.utils.get_ffnn": [[258, 298], ["torch.nn.Sequential", "layers.append", "layers.append", "layers.append", "torch.nn.Linear", "len", "layers.append", "torch.nn.Linear", "layers.append", "len", "range", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Sequential", "layers.append", "len", "len", "torch.nn.BatchNorm1d", "layers.append", "layers.append", "layers.append", "len", "torch.nn.Dropout", "torch.nn.Linear"], "function", ["None"], ["", "", "def", "get_ffnn", "(", "input_size", ",", "output_size", ",", "nn_desc", ",", "dropout_rate", ",", "bias", ",", "bn", ")", ":", "\n", "    ", "\"\"\"\n    Derived from \"https://github.com/HerreraKrachTeichmann/NJODE\"\n    function to get a feed-forward neural network with the given description\n    :param input_size: int, input dimension\n    :param output_size: int, output dimension\n    :param nn_desc: list of lists or None, each inner list defines one hidden\n            layer and has 2 elements: 1. int, the hidden dim, 2. str, the\n            activation function that should be applied (see dict nonlinears for\n            possible options)\n    :param dropout_rate: float,\n    :param bias: bool, whether a bias is used in the layers\n    :return: torch.nn.Sequential, the NN function\n    \"\"\"", "\n", "nonlinears", "=", "{", "\n", "'tanh'", ":", "torch", ".", "nn", ".", "Tanh", ",", "\n", "'relu'", ":", "torch", ".", "nn", ".", "ReLU", "\n", "}", "\n", "if", "nn_desc", "is", "None", "or", "(", "len", "(", "nn_desc", ")", "==", "1", "and", "len", "(", "nn_desc", "[", "0", "]", ")", "==", "1", ")", ":", "\n", "        ", "layers", "=", "[", "torch", ".", "nn", ".", "Linear", "(", "input_size", ",", "output_size", ",", "bias", "=", "bias", ")", "]", "\n", "if", "len", "(", "nn_desc", ")", "==", "1", ":", "\n", "            ", "layers", ".", "append", "(", "nonlinears", "[", "nn_desc", "[", "0", "]", "[", "0", "]", "]", "(", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "layers", "=", "[", "torch", ".", "nn", ".", "Linear", "(", "input_size", ",", "nn_desc", "[", "0", "]", "[", "0", "]", ",", "bias", "=", "bias", ")", "]", "\n", "if", "bn", ":", "\n", "            ", "layers", ".", "append", "(", "torch", ".", "nn", ".", "BatchNorm1d", "(", "nn_desc", "[", "0", "]", "[", "0", "]", ")", ")", "\n", "", "if", "len", "(", "nn_desc", ")", ">", "1", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "nn_desc", ")", "-", "2", ")", ":", "\n", "                ", "layers", ".", "append", "(", "nonlinears", "[", "nn_desc", "[", "i", "]", "[", "1", "]", "]", "(", ")", ")", "\n", "layers", ".", "append", "(", "torch", ".", "nn", ".", "Dropout", "(", "p", "=", "dropout_rate", ")", ")", "\n", "layers", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "nn_desc", "[", "i", "]", "[", "0", "]", ",", "nn_desc", "[", "i", "+", "1", "]", "[", "0", "]", ",", "\n", "bias", "=", "bias", ")", ")", "\n", "", "", "layers", ".", "append", "(", "nonlinears", "[", "nn_desc", "[", "-", "2", "]", "[", "1", "]", "]", "(", ")", ")", "\n", "layers", ".", "append", "(", "torch", ".", "nn", ".", "Dropout", "(", "p", "=", "dropout_rate", ")", ")", "\n", "layers", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "nn_desc", "[", "-", "2", "]", "[", "0", "]", ",", "output_size", ",", "bias", "=", "bias", ")", ")", "\n", "if", "nn_desc", "[", "-", "1", "]", "[", "0", "]", "==", "None", ":", "\n", "            ", "return", "torch", ".", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "", "else", ":", "\n", "            ", "layers", ".", "append", "(", "nonlinears", "[", "nn_desc", "[", "-", "1", "]", "[", "0", "]", "]", "(", ")", ")", "\n", "", "", "return", "torch", ".", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "", ""]]}