{"home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.MyHMM.__init__": [[136, 138], ["autodetect.AutogradHmm.__init__"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.__init__"], ["def", "__init__", "(", "self", ",", "n_states", ")", ":", "\n", "        ", "super", "(", "MyHMM", ",", "self", ")", ".", "__init__", "(", "n_states", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.MyHMM.loglike_emission": [[139, 143], ["simulations.MyHMM.get_emission", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_emission"], ["", "def", "loglike_emission", "(", "self", ",", "obs", ",", "states", ")", ":", "\n", "        ", "emis", "=", "self", ".", "get_emission", "(", ")", "[", "states", ",", ":", "]", "\n", "return", "-", "(", "(", "obs", "-", "emis", "[", "0", "]", ")", "/", "emis", "[", "1", "]", ")", "**", "2", "/", "2", "-", "torch", ".", "tensor", "(", "np", ".", "log", "(", "2", "*", "math", ".", "pi", ")", ")", "/", "2", "-", "torch", ".", "log", "(", "emis", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.initialization": [[25, 44], ["print", "print", "numpy.zeros", "numpy.zeros", "numpy.zeros", "print", "print", "print", "print", "print", "print"], "function", ["None"], ["def", "initialization", "(", "model", ",", "n", ",", "dim", ",", "num", ",", "dim2", "=", "None", ")", ":", "\n", "# print parameters", "\n", "    ", "print", "(", "model", ")", "\n", "print", "(", "f\"n = {n}\"", ")", "\n", "if", "model", "==", "'arma'", ":", "\n", "        ", "print", "(", "f\"p = {dim}\"", ")", "\n", "print", "(", "f\"q = {dim2}\"", ")", "\n", "", "if", "model", "==", "'brown'", ":", "\n", "        ", "print", "(", "f\"N = {dim}\"", ")", "\n", "print", "(", "f\"M = {dim2}\"", ")", "\n", "", "if", "model", "==", "'hmm'", ":", "\n", "        ", "print", "(", "f\"N = {dim}\"", ")", "\n", "", "if", "model", "==", "'linear'", ":", "\n", "        ", "print", "(", "f\"dim = {dim}\"", ")", "\n", "\n", "", "rej", "=", "np", ".", "zeros", "(", "(", "3", ",", "num", ")", ")", "\n", "tau_dist", "=", "np", ".", "zeros", "(", "(", "3", ",", "num", ")", ")", "\n", "run_time", "=", "np", ".", "zeros", "(", "num", ")", "\n", "return", "rej", ",", "tau_dist", ",", "run_time", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.get_file_name": [[46, 56], ["str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["None"], ["", "def", "get_file_name", "(", "model", ",", "n", ",", "dim", ",", "rep", ",", "postfix", "=", "''", ",", "dim2", "=", "None", ")", ":", "\n", "    ", "if", "model", "==", "'arma'", ":", "\n", "        ", "file_name", "=", "'text_files/arma'", "+", "str", "(", "n", ")", "+", "'p'", "+", "str", "(", "dim", ")", "+", "'q'", "+", "str", "(", "dim2", ")", "+", "postfix", "+", "'_results_'", "+", "str", "(", "rep", ")", "+", "'.txt'", "\n", "", "elif", "model", "==", "'brown'", ":", "\n", "        ", "file_name", "=", "'text_files/brown'", "+", "str", "(", "n", ")", "+", "'S'", "+", "str", "(", "dim", ")", "+", "postfix", "+", "'_results_'", "+", "str", "(", "rep", ")", "+", "'.txt'", "\n", "", "elif", "model", "==", "'hmm'", ":", "\n", "        ", "file_name", "=", "'text_files/hmm'", "+", "str", "(", "n", ")", "+", "'S'", "+", "str", "(", "dim", ")", "+", "postfix", "+", "'_results_'", "+", "str", "(", "rep", ")", "+", "'.txt'", "\n", "", "elif", "model", "==", "'linear'", ":", "\n", "        ", "file_name", "=", "'text_files/linear'", "+", "str", "(", "n", ")", "+", "'_dim'", "+", "str", "(", "dim", ")", "+", "postfix", "+", "'_results_'", "+", "str", "(", "rep", ")", "+", "'.txt'", "\n", "", "return", "file_name", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.run_arma": [[58, 96], ["max", "utils.pars_for_arma", "numpy.zeros", "numpy.linspace", "simulations.initialization", "enumerate", "numpy.row_stack", "simulations.get_file_name", "numpy.savetxt", "utils.change_for_ar", "utils.synthetic_data_arma", "print", "range", "time.perf_counter", "autodetect.autograd_arma", "time.perf_counter", "print", "print", "numpy.abs", "utils.check_rejections", "range", "numpy.zeros", "int"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.pars_for_arma", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.initialization", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.get_file_name", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_ar", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.synthetic_data_arma", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.autograd_arma", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejections"], ["", "def", "run_arma", "(", "rep", ",", "n", ",", "tau0", ",", "P", ",", "Q", ",", "num", ",", "seed", ",", "postfix", "=", "''", ")", ":", "\n", "    ", "\"\"\"Run experiments for ARMA model.\"\"\"", "\n", "\n", "# decides parameters", "\n", "dim", "=", "1", "\n", "lag", "=", "max", "(", "P", ",", "Q", ")", "\n", "phi", ",", "the", ",", "ar_root", ",", "_", "=", "pars_for_arma", "(", "P", ",", "Q", ",", "seed", ")", "\n", "\n", "de_range", "=", "np", ".", "zeros", "(", "num", ")", "\n", "root_range", "=", "np", ".", "linspace", "(", "0", ",", "0.25", ",", "num", ")", "\n", "rej", ",", "tau_dist", ",", "run_time", "=", "initialization", "(", "'arma'", ",", "n", ",", "P", ",", "num", ",", "Q", ")", "\n", "for", "s", ",", "r", "in", "enumerate", "(", "root_range", ")", ":", "\n", "# decides change", "\n", "        ", "delta", ",", "de_range", "[", "s", "]", "=", "change_for_ar", "(", "phi", ",", "ar_root", ",", "r", ")", "\n", "delta", "=", "np", ".", "r_", "[", "delta", ",", "np", ".", "zeros", "(", "Q", ")", "]", "\n", "# delta, de_range[s] = change_for_ma(the, ma_root, r)", "\n", "# delta = np.r_[np.zeros(P), delta]", "\n", "\n", "# generates data", "\n", "y", ",", "theta_hat", ",", "sig2", "=", "synthetic_data_arma", "(", "n", ",", "dim", ",", "tau0", ",", "phi", "[", "1", ":", "]", ",", "delta", ",", "\n", "the", "[", "1", ":", "]", ",", "s", "+", "num", "*", "int", "(", "rep", ")", ")", "\n", "\n", "print", "(", "'Finished generating data'", ")", "\n", "idx", "=", "range", "(", "P", "+", "Q", ")", "\n", "if", "postfix", "==", "'_idx'", ":", "\n", "            ", "idx", "=", "range", "(", "P", ",", "P", "+", "Q", ")", "\n", "", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "stat", ",", "tau", ",", "_", "=", "autograd_arma", "(", "theta_hat", ",", "sig2", ",", "y", ",", "P", ",", "Q", ",", "idx", "=", "idx", ",", "stat_type", "=", "'all'", ")", "\n", "end", "=", "time", ".", "perf_counter", "(", ")", "\n", "run_time", "[", "s", "]", "=", "end", "-", "start", "\n", "\n", "print", "(", "f'de = {de_range[s]}'", ")", "\n", "print", "(", "stat", ",", "tau", ")", "\n", "tau_dist", "[", ":", ",", "s", "]", "=", "np", ".", "abs", "(", "tau", "-", "tau0", ")", "\n", "rej", "[", ":", ",", "s", "]", "=", "check_rejections", "(", "stat", ")", "\n", "", "res", "=", "np", ".", "row_stack", "(", "(", "de_range", ",", "rej", ",", "tau_dist", ",", "run_time", ")", ")", "\n", "file_name", "=", "get_file_name", "(", "'arma'", ",", "n", ",", "P", ",", "rep", ",", "postfix", ",", "Q", ")", "\n", "np", ".", "savetxt", "(", "file_name", ",", "res", ",", "delimiter", "=", "','", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.run_brown": [[98, 132], ["utils.load_parameters", "numpy.linspace", "simulations.initialization", "enumerate", "numpy.row_stack", "simulations.get_file_name", "numpy.savetxt", "utils.synthetic_data_hmm", "print", "autodetect.AutogradTopic", "autodetect.AutogradTopic.train", "time.perf_counter", "autodetect.AutogradTopic.compute_stats", "time.perf_counter", "print", "print", "numpy.abs", "utils.check_rejections", "str"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.load_parameters", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.initialization", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.get_file_name", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.synthetic_data_hmm", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.train", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejections"], ["", "def", "run_brown", "(", "rep", ",", "n", ",", "tau0", ",", "n_states", ",", "num", ",", "postfix", "=", "''", ")", ":", "\n", "    ", "\"\"\"Run experiments for text topic (Brown) model.\"\"\"", "\n", "\n", "# load parameters", "\n", "tran_pars", ",", "emis_pars", "=", "load_parameters", "(", "'text_files/brownS'", "+", "str", "(", "n_states", ")", "+", "'_pars.txt'", ")", "\n", "tran0", ",", "delta_tran", ",", "max_tran", "=", "tran_pars", "[", "0", "]", ",", "tran_pars", "[", "1", "]", ",", "tran_pars", "[", "2", "]", "\n", "emis0", "=", "emis_pars", "[", "0", "]", "\n", "de_range", "=", "np", ".", "linspace", "(", "0", ",", "0.25", ",", "num", ")", "\n", "\n", "n_cats", "=", "emis0", ".", "shape", "[", "1", "]", "\n", "rej", ",", "tau_dist", ",", "run_time", "=", "initialization", "(", "'brown'", ",", "n", ",", "n_states", ",", "num", ",", "n_cats", ")", "\n", "for", "s", ",", "de", "in", "enumerate", "(", "de_range", ")", ":", "\n", "# generates data", "\n", "        ", "delta", "=", "de", "*", "delta_tran", "\n", "seed", "=", "s", "+", "num", "*", "rep", "\n", "x", ",", "y", "=", "synthetic_data_hmm", "(", "n", ",", "1", ",", "tau0", ",", "tran0", ",", "delta", ",", "emis0", ",", "\n", "'Discrete'", ",", "80", ",", "seed", ")", "\n", "print", "(", "'Finished generating data'", ")", "\n", "# train the model", "\n", "model", "=", "AutogradTopic", "(", "n_cats", ",", "n_states", ")", "\n", "model", ".", "train", "(", "y", ")", "\n", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "stat", ",", "tau", ",", "_", "=", "model", ".", "compute_stats", "(", "y", ",", "stat_type", "=", "'all'", ")", "\n", "end", "=", "time", ".", "perf_counter", "(", ")", "\n", "run_time", "[", "s", "]", "=", "end", "-", "start", "\n", "\n", "print", "(", "f'de = {de}'", ")", "\n", "print", "(", "stat", ",", "tau", ")", "\n", "tau_dist", "[", ":", ",", "s", "]", "=", "np", ".", "abs", "(", "tau", "-", "tau0", ")", "\n", "rej", "[", ":", ",", "s", "]", "=", "check_rejections", "(", "stat", ")", "\n", "", "res", "=", "np", ".", "row_stack", "(", "(", "de_range", ",", "rej", ",", "tau_dist", ",", "run_time", ")", ")", "\n", "file_name", "=", "get_file_name", "(", "'brown'", ",", "n", ",", "n_states", ",", "rep", ",", "postfix", "=", "postfix", ")", "\n", "np", ".", "savetxt", "(", "file_name", ",", "res", ",", "delimiter", "=", "','", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.run_hmm": [[145, 202], ["utils.load_parameters", "enumerate", "simulations.get_file_name", "numpy.savetxt", "print", "print", "print", "int", "print", "numpy.zeros", "numpy.zeros", "numpy.linspace", "simulations.initialization", "utils.synthetic_data_hmm", "print", "utils.hmm_mle", "simulations.MyHMM", "MyHMM.setup", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "MyHMM.filtering", "time.perf_counter", "MyHMM.compute_stats", "time.perf_counter", "print", "print", "numpy.concatenate", "numpy.row_stack", "numpy.linspace", "numpy.abs", "utils.check_rejections", "numpy.abs", "utils.check_rejections", "str", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "len"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.load_parameters", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.get_file_name", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.initialization", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.synthetic_data_hmm", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.hmm_mle", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.setup", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.filtering", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejections", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejections"], ["", "", "def", "run_hmm", "(", "rep", ",", "n", ",", "tau0", ",", "n_states", ",", "num", ",", "single", "=", "False", ",", "postfix", "=", "''", ")", ":", "\n", "    ", "\"\"\"Run experiments for HMM.\"\"\"", "\n", "\n", "# load parameters", "\n", "tran_pars", ",", "emis_pars", "=", "load_parameters", "(", "'text_files/hmmS'", "+", "str", "(", "n_states", ")", "+", "'_pars.txt'", ")", "\n", "tran0", ",", "delta_tran", ",", "_", "=", "tran_pars", "[", "0", "]", ",", "tran_pars", "[", "1", "]", ",", "tran_pars", "[", "2", "]", "\n", "emis0", "=", "emis_pars", "[", "0", "]", "\n", "\n", "if", "single", ":", "\n", "        ", "print", "(", "\"hmm\"", ")", "\n", "print", "(", "f\"n = {n}\"", ")", "\n", "print", "(", "f\"N = {len(tran0)}\"", ")", "\n", "batch", "=", "int", "(", "(", "rep", "-", "1", ")", "/", "200", ")", "\n", "print", "(", "f\"batch = {batch}\"", ")", "\n", "postfix", "=", "'_single'", "\n", "de_range", "=", "np", ".", "linspace", "(", "0", ",", "0.25", ",", "num", ")", "[", "batch", ":", "(", "batch", "+", "1", ")", "]", "\n", "rej", "=", "np", ".", "zeros", "(", "3", ",", "int", ")", "\n", "run_time", "=", "np", ".", "zeros", "(", "num", ")", "\n", "seed", "=", "rep", "\n", "", "else", ":", "\n", "        ", "de_range", "=", "np", ".", "linspace", "(", "0", ",", "0.25", ",", "num", ")", "\n", "rej", ",", "tau_dist", ",", "run_time", "=", "initialization", "(", "'hmm'", ",", "n", ",", "n_states", ",", "num", ")", "\n", "\n", "", "for", "s", ",", "de", "in", "enumerate", "(", "de_range", ")", ":", "\n", "# generates data", "\n", "        ", "delta", "=", "de", "*", "delta_tran", "\n", "if", "not", "single", ":", "seed", "=", "s", "+", "num", "*", "rep", "\n", "x", ",", "y", "=", "synthetic_data_hmm", "(", "n", ",", "1", ",", "tau0", ",", "tran0", ",", "delta", ",", "emis0", ",", "\n", "'Normal'", ",", "80", ",", "seed", ")", "\n", "print", "(", "'Finished generating data'", ")", "\n", "# computes mle", "\n", "tran", ",", "emis", "=", "hmm_mle", "(", "y", ",", "n_states", ")", "\n", "# set up the model", "\n", "model", "=", "MyHMM", "(", "n_states", ")", "\n", "model", ".", "setup", "(", "tran", ",", "emis", ",", "False", ")", "\n", "inputs", "=", "torch", ".", "from_numpy", "(", "y", ")", ".", "float", "(", ")", "\n", "model", ".", "filtering", "(", "inputs", ")", "\n", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "stat", ",", "tau", ",", "_", "=", "model", ".", "compute_stats", "(", "inputs", ",", "stat_type", "=", "'all'", ")", "\n", "end", "=", "time", ".", "perf_counter", "(", ")", "\n", "run_time", "[", "s", "]", "=", "end", "-", "start", "\n", "\n", "print", "(", "f'de = {de}'", ")", "\n", "print", "(", "stat", ",", "tau", ")", "\n", "if", "single", ":", "\n", "            ", "tau_dist", "=", "np", ".", "abs", "(", "tau", "-", "tau0", ")", "\n", "rej", "=", "check_rejections", "(", "stat", ")", "\n", "", "else", ":", "\n", "            ", "tau_dist", "[", ":", ",", "s", "]", "=", "np", ".", "abs", "(", "tau", "-", "tau0", ")", "\n", "rej", "[", ":", ",", "s", "]", "=", "check_rejections", "(", "stat", ")", "\n", "", "", "if", "single", ":", "\n", "        ", "res", "=", "np", ".", "concatenate", "(", "(", "de_range", ",", "rej", ",", "tau_dist", ",", "run_time", ")", ")", "\n", "", "else", ":", "\n", "        ", "res", "=", "np", ".", "row_stack", "(", "(", "de_range", ",", "rej", ",", "tau_dist", ",", "run_time", ")", ")", "\n", "", "file_name", "=", "get_file_name", "(", "'hmm'", ",", "n", ",", "n_states", ",", "rep", ",", "postfix", "=", "postfix", ")", "\n", "np", ".", "savetxt", "(", "file_name", ",", "res", ",", "delimiter", "=", "','", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.run_linear": [[204, 241], ["autodetect.data.Generator", "numpy.zeros", "numpy.linspace", "numpy.zeros", "simulations.initialization", "enumerate", "numpy.row_stack", "simulations.get_file_name", "numpy.savetxt", "numpy.random.seed", "autodetect.data.Generator.linear", "range", "time.perf_counter", "autodetect.autograd_test", "time.perf_counter", "print", "print", "numpy.abs", "utils.check_rejections", "range", "range", "int"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.initialization", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.get_file_name", "home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.linear", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.autograd_test", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejections"], ["", "def", "run_linear", "(", "rep", ",", "n", ",", "tau0", ",", "dim", ",", "num", ",", "postfix", "=", "''", ")", ":", "\n", "    ", "\"\"\"Run experiments for linear regression model.\"\"\"", "\n", "\n", "# decides parameters", "\n", "gen", "=", "Generator", "(", "n", ",", "dim", ",", "tau0", ")", "\n", "beta0", "=", "np", ".", "zeros", "(", "dim", "+", "1", ")", "\n", "# decides changes", "\n", "de_range", "=", "np", ".", "linspace", "(", "0", ",", "0.5", ",", "num", ")", "\n", "sign", "=", "np", ".", "zeros", "(", "dim", "+", "1", ")", "\n", "sign", "[", "0", "]", "=", "1.0", "\n", "if", "postfix", "==", "'_p20'", ":", "\n", "        ", "sign", "[", "0", ":", "20", "]", "=", "1.0", "\n", "\n", "", "rej", ",", "tau_dist", ",", "run_time", "=", "initialization", "(", "'linear'", ",", "n", ",", "dim", ",", "num", ")", "\n", "for", "s", ",", "de", "in", "enumerate", "(", "de_range", ")", ":", "\n", "# generates data", "\n", "        ", "np", ".", "random", ".", "seed", "(", "s", "+", "num", "*", "int", "(", "rep", ")", ")", "\n", "delta", "=", "de", "*", "sign", "\n", "obs", ",", "beta_hat", "=", "gen", ".", "linear", "(", "beta0", ",", "delta", ")", "\n", "idx", "=", "range", "(", "dim", ")", "\n", "if", "postfix", "==", "'_idx'", ":", "\n", "            ", "idx", "=", "range", "(", "50", ")", "\n", "", "if", "postfix", "==", "'_idx_wrong'", ":", "\n", "            ", "idx", "=", "range", "(", "50", ",", "100", ")", "\n", "\n", "", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "stat", ",", "tau", ",", "_", "=", "autograd_test", "(", "beta_hat", ",", "obs", ",", "loglike_linear", ",", "idx", "=", "idx", ",", "stat_type", "=", "'all'", ")", "\n", "end", "=", "time", ".", "perf_counter", "(", ")", "\n", "run_time", "[", "s", "]", "=", "end", "-", "start", "\n", "\n", "print", "(", "f'de = {de}'", ")", "\n", "print", "(", "stat", ",", "tau", ")", "\n", "tau_dist", "[", ":", ",", "s", "]", "=", "np", ".", "abs", "(", "tau", "-", "tau0", ")", "\n", "rej", "[", ":", ",", "s", "]", "=", "check_rejections", "(", "stat", ")", "\n", "", "res", "=", "np", ".", "row_stack", "(", "(", "de_range", ",", "rej", ",", "tau_dist", ",", "run_time", ")", ")", "\n", "file_name", "=", "get_file_name", "(", "'linear'", ",", "n", ",", "dim", ",", "rep", ",", "postfix", "=", "postfix", ")", "\n", "np", ".", "savetxt", "(", "file_name", ",", "res", ",", "delimiter", "=", "','", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.loglike": [[244, 247], ["torch.MSELoss", "nn.MSELoss."], "function", ["None"], ["", "def", "loglike", "(", "out", ",", "tar", ")", ":", "\n", "    ", "loss_fn", "=", "nn", ".", "MSELoss", "(", "size_average", "=", "False", ")", "\n", "return", "-", "loss_fn", "(", "out", ",", "tar", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.simulations.run_autocusum": [[249, 302], ["print", "print", "print", "print", "print", "numpy.linspace", "torch.zeros", "torch.zeros", "torch.zeros", "numpy.zeros", "enumerate", "numpy.row_stack", "numpy.savetxt", "numpy.ones", "numpy.random.seed", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "autodetect.data.Linear", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "range", "autodetect.AutogradCuSum", "time.perf_counter", "autodetect.AutogradCuSum.initial_model", "range", "time.perf_counter", "print", "print", "autodetect.data.Linear.parameters", "torch.optim.Adam.zero_grad", "autodetect.data.Linear.", "loss.backward", "torch.optim.Adam.step", "autodetect.AutogradCuSum.compute_stats", "str", "simulations.loglike", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.initial_model", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.parameters", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.loglike"], ["", "def", "run_autocusum", "(", "rep", ",", "n", ",", "tau", ",", "train_size", ",", "dim", ",", "thresh", ",", "num", ")", ":", "\n", "    ", "\"\"\"Run experiments for autograd-test-CuSum.\n    \"\"\"", "\n", "print", "(", "f\"n = {n}\"", ")", "\n", "print", "(", "f\"tau = {tau}\"", ")", "\n", "print", "(", "f\"dim = {dim}\"", ")", "\n", "print", "(", "f\"thresh = {thresh}\"", ")", "\n", "\n", "N", "=", "n", "+", "train_size", "\n", "print", "(", "f\"sample size of training set {train_size}\"", ")", "\n", "tau", "=", "tau", "+", "train_size", "\n", "de_range", "=", "np", ".", "linspace", "(", "0", ",", "0.5", ",", "num", ")", "\n", "sign", "=", "torch", ".", "zeros", "(", "dim", ")", "\n", "sign", "[", "0", "]", "=", "1.0", "\n", "\n", "rej_length", "=", "np", ".", "ones", "(", "num", ",", "int", ")", "*", "n", "# initialize with n", "\n", "run_time", "=", "np", ".", "zeros", "(", "num", ")", "\n", "for", "s", ",", "de", "in", "enumerate", "(", "de_range", ")", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "s", "+", "num", "*", "rep", ")", "\n", "delta", "=", "de", "*", "sign", "\n", "inputs", "=", "torch", ".", "randn", "(", "(", "N", ",", "dim", ")", ")", "\n", "\n", "# generates targets with change", "\n", "targets", "=", "torch", ".", "randn", "(", "N", ")", "\n", "targets", "[", "tau", ":", "]", "+=", "inputs", "[", "tau", ":", "]", "@", "delta", "\n", "#targets = targets.view(-1)", "\n", "\n", "# pre-trains the model", "\n", "linear", "=", "Linear", "(", "dim", ",", "1", ")", "\n", "optim", "=", "torch", ".", "optim", ".", "Adam", "(", "linear", ".", "parameters", "(", ")", ")", "\n", "for", "_", "in", "range", "(", "10000", ")", ":", "\n", "            ", "optim", ".", "zero_grad", "(", ")", "\n", "outs", "=", "linear", "(", "inputs", "[", ":", "train_size", "]", ")", "\n", "loss", "=", "-", "loglike", "(", "outs", ",", "targets", "[", ":", "train_size", "]", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optim", ".", "step", "(", ")", "\n", "", "autocusum", "=", "AutogradCuSum", "(", "linear", ",", "loglike", ")", "\n", "\n", "# change detection", "\n", "start", "=", "time", ".", "perf_counter", "(", ")", "\n", "autocusum", ".", "initial_model", "(", "inputs", "[", ":", "train_size", "]", ",", "targets", "[", ":", "train_size", "]", ",", "N", ")", "\n", "for", "i", "in", "range", "(", "train_size", ",", "N", ")", ":", "\n", "            ", "stat", "=", "autocusum", ".", "compute_stats", "(", "inputs", "[", "i", ":", "(", "i", "+", "1", ")", "]", ",", "targets", "[", "i", ":", "(", "i", "+", "1", ")", "]", ",", "thresh", ")", "\n", "if", "stat", ">", "1.0", ":", "\n", "                ", "rej_length", "[", "s", "]", "=", "i", "-", "tau", "\n", "break", "\n", "", "", "end", "=", "time", ".", "perf_counter", "(", ")", "\n", "run_time", "[", "s", "]", "=", "end", "-", "start", "\n", "print", "(", "f'de = {de}'", ")", "\n", "print", "(", "stat", ",", "rej_length", "[", "s", "]", ")", "\n", "", "res", "=", "np", ".", "row_stack", "(", "(", "de_range", ",", "rej_length", ",", "run_time", ")", ")", "\n", "file_name", "=", "'text_files/autocusum'", "+", "str", "(", "dim", ")", "+", "'_'", "+", "str", "(", "n", ")", "+", "'_'", "+", "str", "(", "tau", ")", "+", "'_'", "+", "str", "(", "train_size", ")", "+", "'_results_'", "+", "str", "(", "rep", ")", "+", "'.txt'", "\n", "np", ".", "savetxt", "(", "file_name", ",", "res", ",", "delimiter", "=", "','", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.prob_matrix": [[27, 52], ["numpy.zeros", "range", "numpy.ones", "numpy.max", "numpy.argmax", "numpy.dirichlet", "numpy.ones"], "function", ["None"], ["def", "prob_matrix", "(", "n", ",", "m", ",", "alpha", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generate a probability matrix.\n\n    This function generates a probability matrix whose each row has a Dirichlet\n    distribution.\n\n    Parameters\n    ----------\n    d: int\n        Dimension of the matrix.\n    alpha: array-like, shape (d,)\n        Parameters of the Dirichlet distribution.\n    \"\"\"", "\n", "\n", "alpha", "=", "alpha", "or", "np", ".", "ones", "(", "m", ")", "\n", "prob_mat", "=", "np", ".", "zeros", "(", "(", "n", ",", "m", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "temp", "=", "np", ".", "ones", "(", "m", ")", "/", "2", "/", "m", "\n", "temp", "+=", "npr", ".", "dirichlet", "(", "alpha", ")", "/", "2", "\n", "temp_max", "=", "np", ".", "max", "(", "temp", ")", "\n", "temp_ind", "=", "np", ".", "argmax", "(", "temp", ")", "\n", "prob_mat", "[", "i", "]", "=", "temp", "\n", "prob_mat", "[", "i", ",", "i", "]", "=", "temp_max", "\n", "prob_mat", "[", "i", ",", "temp_ind", "]", "=", "temp", "[", "i", "]", "\n", "", "return", "prob_mat", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_prob_vec": [[54, 91], ["numpy.zeros", "numpy.argsort", "int", "len", "min", "min", "min"], "function", ["None"], ["", "def", "change_for_prob_vec", "(", "vec", ",", "p", ")", ":", "\n", "    ", "\"\"\"Generate change for probability vector.\n\n    The number of positive changes is equal to the one of negative changes, or\n    their difference is one.\n\n    Parameters\n    ----------\n    vec: array-like, shape (d)\n        Probability vector in which the change is generated.\n    p: int\n        Number of changed components. Must be positive.\n    \"\"\"", "\n", "\n", "delta", "=", "np", ".", "zeros", "(", "len", "(", "vec", ")", ")", "\n", "order", "=", "np", ".", "argsort", "(", "vec", "[", ":", "-", "1", "]", ")", "# the last element is not considered as parameter.", "\n", "pos_num", "=", "neg_num", "=", "int", "(", "p", "/", "2", ")", "\n", "\n", "if", "pos_num", ">", "0", ":", "\n", "        ", "delta", "[", "order", "[", ":", "pos_num", "]", "]", "=", "1.0", "\n", "delta", "[", "order", "[", "-", "neg_num", ":", "]", "]", "=", "-", "1.0", "\n", "maximum", "=", "min", "(", "1", "-", "vec", "[", "order", "[", "pos_num", "-", "1", "]", "]", ",", "vec", "[", "order", "[", "-", "neg_num", "]", "]", ")", "\n", "", "else", ":", "\n", "        ", "maximum", "=", "1.0", "\n", "# decide the last change", "\n", "", "if", "p", ">", "2", "*", "pos_num", ":", "\n", "        ", "if", "vec", "[", "order", "[", "-", "(", "neg_num", "+", "1", ")", "]", "]", ">=", "vec", "[", "-", "1", "]", ":", "\n", "            ", "neg_num", "+=", "1", "\n", "delta", "[", "-", "1", "]", "=", "1.0", "\n", "delta", "[", "order", "[", "-", "neg_num", "]", "]", "=", "-", "1.0", "\n", "maximum", "=", "min", "(", "maximum", ",", "vec", "[", "order", "[", "-", "neg_num", "]", "]", ",", "1", "-", "vec", "[", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "delta", "[", "-", "1", "]", "=", "-", "1.0", "\n", "delta", "[", "order", "[", "pos_num", "]", "]", "=", "1.0", "\n", "maximum", "=", "min", "(", "maximum", ",", "1", "-", "vec", "[", "order", "[", "pos_num", "]", "]", ",", "vec", "[", "-", "1", "]", ")", "\n", "pos_num", "+=", "1", "\n", "", "", "return", "delta", ",", "maximum", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_prob_matrix": [[93, 121], ["numpy.zeros", "int", "range", "utils.change_for_prob_vec", "min"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_prob_vec"], ["", "def", "change_for_prob_matrix", "(", "prob_mat", ",", "p", ")", ":", "\n", "    ", "\"\"\"Generate change for probability matrix.\n\n    Components of change are as even as possible across rows. Given a row, the\n    number of positive changes is equal to the one of negative changes, or\n    their difference is one.\n\n    Parameters\n    ----------\n    prob_mat: array-like, shape (d, d)\n        Probability matrix in which the change is generated.\n    p: int\n        Number of changed components. Must be smaller than :math:`d(d-1)`.\n    \"\"\"", "\n", "\n", "d", ",", "c", "=", "prob_mat", ".", "shape", "\n", "delta", "=", "np", ".", "zeros", "(", "(", "d", ",", "c", ")", ")", "\n", "maximum", "=", "1", "\n", "quot", "=", "int", "(", "p", "/", "d", ")", "# number of changed components of each row", "\n", "for", "k", "in", "range", "(", "d", ")", ":", "\n", "        ", "if", "k", "<", "p", "%", "d", ":", "\n", "            ", "num", "=", "quot", "+", "1", "\n", "", "else", ":", "\n", "            ", "num", "=", "quot", "\n", "", "if", "num", ">", "0", ":", "\n", "            ", "delta", "[", "k", "]", ",", "new_max", "=", "change_for_prob_vec", "(", "prob_mat", "[", "k", "]", ",", "num", ")", "\n", "maximum", "=", "min", "(", "maximum", ",", "new_max", ")", "\n", "", "", "return", "delta", ",", "maximum", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_brown_keep_zero": [[123, 153], ["numpy.zeros", "int", "range", "numpy.arange", "len", "RuntimeError", "utils.change_for_prob_vec", "min"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_prob_vec"], ["", "def", "change_for_brown_keep_zero", "(", "prob_mat", ",", "p", ")", ":", "\n", "    ", "\"\"\"Generate change for probability matrix in Brown model.\n\n    This function does not impose changes in component that is zero.\n    Components of change are as even as possible across rows.\n\n    Parameters\n    ----------\n    prob_mat: array-like, shape (d, d)\n        Probability matrix in which the change is generated.\n    p: int\n        Number of changed components. Must be smaller than :math:`d(d-1)`.\n    \"\"\"", "\n", "\n", "d", ",", "c", "=", "prob_mat", ".", "shape", "\n", "delta", "=", "np", ".", "zeros", "(", "(", "d", ",", "c", ")", ")", "\n", "maximum", "=", "1", "\n", "quot", "=", "int", "(", "p", "/", "d", ")", "# number of changed components of each row", "\n", "for", "k", "in", "range", "(", "d", ")", ":", "\n", "        ", "if", "k", "<", "p", "%", "d", ":", "\n", "            ", "num", "=", "quot", "+", "1", "\n", "", "else", ":", "\n", "            ", "num", "=", "quot", "\n", "", "non_zero", "=", "np", ".", "arange", "(", "c", ")", "[", "prob_mat", "[", "k", "]", ">", "0", "]", "\n", "if", "num", ">=", "len", "(", "non_zero", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"Too many zero entries in {k+1}th row of prob_mat\"", ")", "\n", "", "if", "num", ">", "0", ":", "\n", "            ", "delta", "[", "k", ",", "non_zero", "]", ",", "new_max", "=", "change_for_prob_vec", "(", "prob_mat", "[", "k", ",", "non_zero", "]", ",", "num", ")", "\n", "maximum", "=", "min", "(", "maximum", ",", "new_max", ")", "\n", "", "", "return", "delta", ",", "maximum", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.pars_for_hmm": [[155, 188], ["utils.prob_matrix", "utils.change_for_prob_matrix", "numpy.zeros", "numpy.zeros", "numpy.arange", "numpy.linspace", "utils.prob_matrix", "utils.change_for_prob_matrix", "range"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.prob_matrix", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_prob_matrix", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.prob_matrix", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_prob_matrix"], ["", "def", "pars_for_hmm", "(", "n", ",", "c", ",", "p_tran", ",", "p_emis", ",", "emission", "=", "\"Normal\"", ",", "alpha", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generate parameters for HMM.\n\n    This function generates the transition matrix and emission matrix by\n    using Dirichlet distribution.\n\n    Parameters\n    ----------\n    n: int\n        Number of hidden states.\n    c: int\n        Number of parameters.\n    emission: string\n        Emission distribution. Default is \"Normal\".\n    alpha: array-like, shape (n,)\n        Parameters of the Dirichlet distribution for transition matrix.\n    \"\"\"", "\n", "\n", "tran", "=", "prob_matrix", "(", "n", ",", "n", ",", "alpha", ")", "\n", "delta_tran", ",", "max_tran", "=", "change_for_prob_matrix", "(", "tran", ",", "p_tran", ")", "\n", "\n", "emis", "=", "np", ".", "zeros", "(", "(", "n", ",", "2", ")", ")", "\n", "delta_emis", "=", "np", ".", "zeros", "(", "(", "n", ",", "c", ")", ")", "\n", "if", "emission", "==", "\"Normal\"", ":", "\n", "        ", "emis", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "n", ")", "\n", "emis", "[", ":", ",", "1", "]", "=", "np", ".", "linspace", "(", "0.01", ",", "0.1", ",", "n", ")", "\n", "delta_emis", "[", "range", "(", "p_emis", ")", ",", "0", "]", "=", "-", "1.0", "\n", "max_emis", "=", "p_emis", "\n", "", "elif", "emission", "==", "\"Discrete\"", ":", "\n", "        ", "emis", "=", "prob_matrix", "(", "n", ",", "c", ",", "alpha", ")", "\n", "delta_emis", ",", "max_emis", "=", "change_for_prob_matrix", "(", "emis", ",", "p_emis", ")", "\n", "\n", "", "return", "{", "\"transition\"", ":", "[", "tran", ",", "delta_tran", ",", "max_tran", "]", ",", "\"emission\"", ":", "[", "emis", ",", "delta_emis", ",", "max_emis", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.pars_for_brown": [[190, 236], ["utils.prob_matrix", "utils.change_for_prob_matrix", "numpy.zeros", "numpy.choice", "range", "numpy.shuffle", "range", "utils.change_for_brown_keep_zero", "int", "range", "numpy.sum", "numpy.dirichlet", "numpy.ones", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.prob_matrix", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_prob_matrix", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_brown_keep_zero"], ["", "def", "pars_for_brown", "(", "n", ",", "c", ",", "p_tran", ",", "p_emis", ",", "alpha", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generate parameters for Brown model.\n\n    This function generates the transition matrix and emission matrix by\n    using Dirichlet distribution.\n\n    Parameters\n    ----------\n    n: int\n        Number of hidden states.\n    c: int\n        Number of categories of emission distribution.\n    p: int\n        Number of changed components.\n    alpha: array-like, shape (n,)\n        Parameters of the Dirichlet distribution for transition matrix.\n\n    Returns\n    -------\n    A dictionary containing all parameters.\n    \"\"\"", "\n", "\n", "tran", "=", "prob_matrix", "(", "n", ",", "n", ",", "alpha", ")", "\n", "delta_tran", ",", "max_tran", "=", "change_for_prob_matrix", "(", "tran", ",", "p_tran", ")", "\n", "\n", "emis", "=", "np", ".", "zeros", "(", "(", "n", ",", "c", ")", ")", "\n", "min_state", "=", "int", "(", "p_emis", "/", "n", ")", "+", "1", "\n", "resi", "=", "p_emis", "%", "n", "\n", "asign_states", "=", "npr", ".", "choice", "(", "range", "(", "n", ")", ",", "c", ")", "\n", "lo", "=", "0", "\n", "for", "s", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "s", "<", "resi", ":", "\n", "            ", "num", "=", "min_state", "+", "1", "\n", "", "else", ":", "\n", "            ", "num", "=", "min_state", "\n", "", "asign_states", "[", "lo", ":", "(", "lo", "+", "num", ")", "]", "=", "s", "\n", "lo", "=", "lo", "+", "num", "\n", "", "npr", ".", "shuffle", "(", "asign_states", ")", "\n", "for", "s", "in", "range", "(", "n", ")", ":", "\n", "        ", "in_state_s", "=", "asign_states", "==", "s", "\n", "num_of_s", "=", "np", ".", "sum", "(", "in_state_s", ")", "\n", "emis", "[", "s", ",", "in_state_s", "]", "=", "np", ".", "ones", "(", "num_of_s", ")", "*", "3", "/", "num_of_s", "/", "4", "\n", "emis", "[", "s", ",", "in_state_s", "]", "+=", "npr", ".", "dirichlet", "(", "np", ".", "ones", "(", "num_of_s", ")", ")", "/", "4", "\n", "\n", "", "delta_emis", ",", "max_emis", "=", "change_for_brown_keep_zero", "(", "emis", ",", "p_emis", ")", "\n", "return", "{", "\"transition\"", ":", "[", "tran", ",", "delta_tran", ",", "max_tran", "]", ",", "\"emission\"", ":", "[", "emis", ",", "delta_emis", ",", "max_emis", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.pars_for_arma": [[238, 250], ["numpy.seed", "numpy.random.choice", "numpy.random.choice", "numpy.polynomial.polynomial.polyfromroots", "numpy.polynomial.polynomial.polyfromroots", "numpy.random.exponential", "numpy.random.exponential"], "function", ["None"], ["", "def", "pars_for_arma", "(", "p", ",", "q", ",", "seed", ")", ":", "\n", "    ", "\"\"\"Generate parameters for ARMA model.\"\"\"", "\n", "npr", ".", "seed", "(", "seed", ")", "\n", "ar_root", "=", "np", ".", "random", ".", "exponential", "(", "0.5", ",", "p", ")", "+", "1.0", "\n", "ar_root", "*=", "np", ".", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ",", "p", ")", "\n", "ma_root", "=", "np", ".", "random", ".", "exponential", "(", "0.5", ",", "q", ")", "+", "1.0", "\n", "ma_root", "*=", "np", ".", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ",", "q", ")", "\n", "phi", "=", "np", ".", "polynomial", ".", "polynomial", ".", "polyfromroots", "(", "ar_root", ")", "\n", "phi", "/=", "-", "phi", "[", "0", "]", "\n", "the", "=", "np", ".", "polynomial", ".", "polynomial", ".", "polyfromroots", "(", "ma_root", ")", "\n", "the", "/=", "the", "[", "0", "]", "\n", "return", "phi", ",", "the", ",", "ar_root", ",", "ma_root", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_ar": [[252, 260], ["numpy.polynomial.polynomial.polyfromroots", "numpy.sqrt", "numpy.sqrt", "numpy.sum", "len"], "function", ["None"], ["", "def", "change_for_ar", "(", "phi", ",", "ar_root", ",", "r", ")", ":", "\n", "    ", "\"\"\"Generate change for AR model.\"\"\"", "\n", "ar_new_root", "=", "(", "1", "+", "r", ")", "*", "ar_root", "\n", "phi_new", "=", "np", ".", "polynomial", ".", "polynomial", ".", "polyfromroots", "(", "ar_new_root", ")", "\n", "phi_new", "/=", "-", "phi_new", "[", "0", "]", "\n", "delta", "=", "phi_new", "-", "phi", "\n", "de", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "delta", "**", "2", ")", ")", "/", "np", ".", "sqrt", "(", "len", "(", "phi", ")", ")", "\n", "return", "delta", ",", "de", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.change_for_ma": [[262, 270], ["numpy.polynomial.polynomial.polyfromroots", "numpy.sqrt", "numpy.sqrt", "numpy.sum", "len"], "function", ["None"], ["", "def", "change_for_ma", "(", "the", ",", "ma_root", ",", "r", ")", ":", "\n", "    ", "\"\"\"Generate change for MA model.\"\"\"", "\n", "ma_new_root", "=", "ma_root", "+", "r", "*", "ma_root", "\n", "the_new", "=", "np", ".", "polynomial", ".", "polynomial", ".", "polyfromroots", "(", "ma_new_root", ")", "\n", "the_new", "/=", "the_new", "[", "0", "]", "\n", "delta", "=", "the_new", "-", "the", "\n", "de", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "delta", "**", "2", ")", ")", "/", "np", ".", "sqrt", "(", "len", "(", "the", ")", ")", "\n", "return", "delta", ",", "de", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.load_parameters": [[277, 313], ["int", "numpy.zeros", "numpy.zeros", "range", "range", "float", "numpy.zeros", "numpy.zeros", "range", "range", "float", "open", "f.readlines", "range", "range", "int", "int", "range", "range", "float", "float", "float", "float"], "function", ["None"], ["", "def", "load_parameters", "(", "file_name", ")", ":", "\n", "    ", "\"\"\"Load parameters for HMM and Brown\"\"\"", "\n", "with", "open", "(", "file_name", ")", "as", "f", ":", "\n", "        ", "pars", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "# transition parameters", "\n", "", "d", "=", "int", "(", "pars", "[", "0", "]", ")", "\n", "tran", "=", "np", ".", "zeros", "(", "(", "d", ",", "d", ")", ")", "\n", "delta_tran", "=", "np", ".", "zeros", "(", "(", "d", ",", "d", ")", ")", "\n", "loc", "=", "2", "\n", "for", "i", "in", "range", "(", "d", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "d", ")", ":", "\n", "            ", "tran", "[", "i", ",", "j", "]", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "loc", "+=", "1", "\n", "", "", "for", "i", "in", "range", "(", "d", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "d", ")", ":", "\n", "            ", "delta_tran", "[", "i", ",", "j", "]", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "loc", "+=", "1", "\n", "", "", "max_tran", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "loc", "+=", "1", "\n", "\n", "# emission parameters", "\n", "p", ",", "q", "=", "int", "(", "pars", "[", "loc", "]", ")", ",", "int", "(", "pars", "[", "loc", "+", "1", "]", ")", "\n", "emis", "=", "np", ".", "zeros", "(", "(", "p", ",", "q", ")", ")", "\n", "delta_emis", "=", "np", ".", "zeros", "(", "(", "p", ",", "q", ")", ")", "\n", "loc", "+=", "2", "\n", "for", "i", "in", "range", "(", "p", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "q", ")", ":", "\n", "            ", "emis", "[", "i", ",", "j", "]", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "loc", "+=", "1", "\n", "", "", "for", "i", "in", "range", "(", "p", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "q", ")", ":", "\n", "            ", "delta_emis", "[", "i", ",", "j", "]", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "loc", "+=", "1", "\n", "", "", "max_emis", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "return", "[", "tran", ",", "delta_tran", ",", "max_tran", "]", ",", "[", "emis", ",", "delta_emis", ",", "max_emis", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.synthetic_data_hmm": [[315, 370], ["len", "autodetect.data.Generator", "numpy.random.seed", "numpy.ones", "autodetect.data.Generator.hmm_transition", "range", "range", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.hmm_transition"], ["", "def", "synthetic_data_hmm", "(", "n", ",", "dim", ",", "tau", ",", "tran", ",", "delta", ",", "emis", ",", "model", ",", "obs_per_state", ",", "seed", ")", ":", "\n", "    ", "\"\"\"Generate synthetic data for HMM with change in emission parameters.\n\n    Parameters\n    ----------\n    n: int\n        Sample size.\n    dim: int\n        Dimension of observations.\n    tau: int\n        Location of the changepoint.\n    tran: numpy.ndarray, shape (n_states, n_states)\n        Transition matrix.\n    delta: numpy.ndarray, shape (n_states, n_states)\n        Value of change in transition matrix.\n    emis: array-like, shape (n_states, n_emissions or n_pars)\n        Emission parameters.\n        For discrete emission distribution, it is the emission matrix;\n        for normal distribution, it is the normal parameters.\n    model: str\n        Model of emission distribution. Must be ``\"Normal\"`` or ``\"Discrete\"``.\n    obs_per_state: int\n        For each state must appear at least this number times in the generated data.\n    seed: str\n        Random seed.\n\n    Returns\n    -------\n    states: numpy.ndarray, shape (n,)\n        Hidden states associated with observations.\n    obs: numpy.ndarray, shape (n,)\n        Generated observations.\n    \"\"\"", "\n", "\n", "N", "=", "len", "(", "tran", ")", "\n", "n_cats", "=", "emis", ".", "shape", "[", "1", "]", "\n", "# generate data with change in transition parameters", "\n", "nu", "=", "np", ".", "ones", "(", "N", ")", "/", "N", "\n", "gen", "=", "Generator", "(", "n", ",", "dim", ",", "tau", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "bad", "=", "True", "\n", "while", "bad", ":", "\n", "        ", "states", ",", "obs", "=", "gen", ".", "hmm_transition", "(", "tran", ",", "delta", ",", "emis", ",", "model", ",", "nu", ")", "\n", "bad", "=", "False", "\n", "for", "state", "in", "range", "(", "N", ")", ":", "\n", "            ", "if", "np", ".", "sum", "(", "states", "==", "state", ")", "<", "obs_per_state", ":", "\n", "                ", "bad", "=", "True", "\n", "break", "\n", "", "", "if", "model", "==", "'Discrete'", ":", "\n", "            ", "for", "cat", "in", "range", "(", "n_cats", ")", ":", "\n", "                ", "if", "np", ".", "sum", "(", "obs", "==", "cat", ")", "<", "obs_per_state", ":", "\n", "                    ", "bad", "=", "True", "\n", "break", "\n", "", "", "", "", "return", "states", ",", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.synthetic_data_arma": [[372, 417], ["autodetect.data.Generator", "numpy.random.seed", "autodetect.data.Generator.arma", "torch.from_numpy().float", "torch.tensor().float", "len", "len", "statsmodels.tsa.arima_model.ARMA().fit", "torch.from_numpy", "torch.tensor", "autodetect.data.Generator.arma", "print", "numpy.column_stack", "statsmodels.tsa.arima_model.ARMA", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.arma", "home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.arma"], ["", "def", "synthetic_data_arma", "(", "n", ",", "dim", ",", "tau", ",", "phi", ",", "delta", ",", "the", ",", "seed", ")", ":", "\n", "    ", "\"\"\"Generate synthetic data for ARMA with change in AR parameters.\n\n    Parameters\n    ----------\n    n: int\n        Sample size.\n    dim: int\n        Dimension of observations.\n    tau: int\n        Location of the changepoint.\n    phi: numpy.ndarray, shape (p,)\n        AR parameters.\n    delta: numpy.ndarray, shape (p,)\n        Value of change in AR parameters.\n    the: numpy.ndarray, shape (q,)\n        MA parameters.\n    seed: str\n        Random seed.\n\n    Returns\n    -------\n    obs: torch.Tensor, shape (n,)\n        Generated observations.\n    theta_hat: torch.Tensor, shape (p+q,)\n        Estimated parameters.\n    sigma2: float\n        Estimated variance of the error term.\n    \"\"\"", "\n", "p", ",", "q", "=", "len", "(", "phi", ")", ",", "len", "(", "the", ")", "\n", "gen", "=", "Generator", "(", "n", ",", "dim", ",", "tau", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "y", "=", "gen", ".", "arma", "(", "phi", ",", "delta", ",", "the", ")", "\n", "while", "True", ":", "\n", "        ", "try", ":", "\n", "            ", "cmle", "=", "ARMA", "(", "y", ",", "order", "=", "(", "p", ",", "q", ")", ")", ".", "fit", "(", "method", "=", "'css'", ",", "trend", "=", "'nc'", ")", "\n", "break", "\n", "", "except", "ValueError", ":", "\n", "            ", "y", "=", "gen", ".", "arma", "(", "phi", ",", "delta", ",", "the", ")", "\n", "print", "(", "y", "[", "0", "]", ")", "\n", "", "", "obs", "=", "torch", ".", "from_numpy", "(", "np", ".", "column_stack", "(", "[", "y", ",", "np", ".", "zeros", "(", "n", ")", "]", ")", ")", ".", "float", "(", ")", "\n", "theta_hat", "=", "torch", ".", "tensor", "(", "cmle", ".", "params", ")", ".", "float", "(", ")", "\n", "theta_hat", ".", "requires_grad", "=", "True", "\n", "sigma2", "=", "cmle", ".", "sigma2", "\n", "return", "obs", ",", "theta_hat", ",", "sigma2", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.write_mat": [[424, 429], ["enumerate", "f.write", "str"], "function", ["None"], ["", "def", "write_mat", "(", "matrix", ",", "f", ")", ":", "\n", "    ", "\"\"\"Write matrix to file.\"\"\"", "\n", "for", "_", ",", "mat", "in", "enumerate", "(", "matrix", ")", ":", "\n", "        ", "for", "v", "in", "mat", ":", "\n", "            ", "f", ".", "write", "(", "\"%s\\n\"", "%", "str", "(", "v", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.hmm_mle": [[431, 442], ["pomegranate.HiddenMarkovModel", "model.from_samples.from_samples", "range", "numpy.array().reshape", "model.from_samples.dense_transition_matrix", "model.from_samples.get_params", "numpy.array"], "function", ["None"], ["", "", "", "def", "hmm_mle", "(", "y", ",", "N", ")", ":", "\n", "    ", "\"\"\"Compute the MLE of normal HMMs.\"\"\"", "\n", "model", "=", "HiddenMarkovModel", "(", ")", "\n", "model", "=", "model", ".", "from_samples", "(", "NormalDistribution", ",", "N", ",", "[", "y", "]", ")", "\n", "tran", "=", "model", ".", "dense_transition_matrix", "(", ")", "[", ":", "N", ",", ":", "N", "]", "\n", "emis", "=", "[", "]", "\n", "states", "=", "model", ".", "get_params", "(", ")", "[", "'states'", "]", "\n", "for", "s", "in", "range", "(", "N", ")", ":", "\n", "        ", "emis", "+=", "states", "[", "s", "]", ".", "distribution", ".", "parameters", "\n", "", "emis", "=", "np", ".", "array", "(", "emis", ")", ".", "reshape", "(", "N", ",", "-", "1", ")", "\n", "return", "tran", ",", "emis", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejection": [[444, 452], ["print"], "function", ["None"], ["", "def", "check_rejection", "(", "stat", ",", "type_stat", "=", "''", ")", ":", "\n", "    ", "\"\"\"Check rejection given the statistic.\"\"\"", "\n", "rej", "=", "0", "\n", "if", "stat", ">", "1", ":", "\n", "        ", "rej", "=", "1", "\n", "", "if", "stat", "==", "1", ":", "\n", "        ", "print", "(", "\"{}non-invertible rejection.\"", ".", "format", "(", "type_stat", ")", ")", "\n", "", "return", "rej", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejections": [[454, 462], ["numpy.zeros", "utils.check_rejection", "utils.check_rejection", "utils.check_rejection", "print"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejection", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejection", "home.repos.pwc.inspect_result.langliu95_autodetect.simulation.utils.check_rejection"], ["", "def", "check_rejections", "(", "stats", ")", ":", "\n", "    ", "\"\"\"Check rejections given three statistics.\"\"\"", "\n", "rej", "=", "np", ".", "zeros", "(", "3", ",", "int", ")", "\n", "rej", "[", "0", "]", "=", "check_rejection", "(", "stats", "[", "0", "]", ",", "'Linear '", ")", "\n", "rej", "[", "1", "]", "=", "check_rejection", "(", "stats", "[", "1", "]", ",", "'Scan '", ")", "\n", "rej", "[", "2", "]", "=", "check_rejection", "(", "stats", "[", "2", "]", ",", "'Autograd '", ")", "\n", "print", "(", "\"\"", ")", "\n", "return", "rej", "\n", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.__init__": [[63, 72], ["super().__init__", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.__init__"], ["def", "__init__", "(", "self", ",", "num_cat", ",", "num_hid", ",", "init", "=", "None", ")", ":", "\n", "        ", "super", "(", "AutogradTopic", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_init", "=", "init", "\n", "self", ".", "_emis", "=", "np", ".", "zeros", "(", "num_cat", "-", "num_hid", ")", "# effective parameters of the emission matrix", "\n", "self", ".", "_cats", "=", "np", ".", "zeros", "(", "num_cat", "-", "num_hid", ",", "int", ")", "# corresponding category of _emis", "\n", "self", ".", "_tran", "=", "np", ".", "zeros", "(", "num_hid", "*", "(", "num_hid", "-", "1", ")", ")", "\n", "self", ".", "embed", "=", "np", ".", "zeros", "(", "num_cat", ",", "int", ")", "\n", "self", ".", "num_cat", "=", "num_cat", "\n", "self", ".", "num_hid", "=", "num_hid", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.get_transition": [[73, 80], ["topic.AutogradTopic._tran.reshape", "numpy.zeros", "numpy.sum"], "methods", ["None"], ["", "def", "get_transition", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get transition matrix.\"\"\"", "\n", "subQ", "=", "self", ".", "_tran", ".", "reshape", "(", "self", ".", "num_hid", ",", "-", "1", ")", "\n", "Q", "=", "np", ".", "zeros", "(", "(", "self", ".", "num_hid", ",", "self", ".", "num_hid", ")", ")", "\n", "Q", "[", ":", ",", ":", "-", "1", "]", "=", "subQ", "\n", "Q", "[", ":", ",", "-", "1", "]", "=", "1.0", "-", "np", ".", "sum", "(", "subQ", ",", "1", ")", "\n", "return", "Q", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.get_emission": [[81, 94], ["len", "numpy.zeros", "range", "numpy.max", "numpy.sum"], "methods", ["None"], ["", "def", "get_emission", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get emission matrix.\"\"\"", "\n", "num_cat", "=", "len", "(", "self", ".", "embed", ")", "\n", "num_hid", "=", "np", ".", "max", "(", "self", ".", "embed", ")", "+", "1", "\n", "G", "=", "np", ".", "zeros", "(", "(", "num_hid", ",", "num_cat", ")", ")", "\n", "pos", "=", "0", "\n", "for", "k", "in", "range", "(", "num_cat", ")", ":", "\n", "            ", "if", "k", "in", "self", ".", "_cats", ":", "\n", "                ", "G", "[", "self", ".", "embed", "[", "k", "]", ",", "k", "]", "=", "self", ".", "_emis", "[", "pos", "]", "\n", "pos", "+=", "1", "\n", "", "else", ":", "\n", "                ", "G", "[", "self", ".", "embed", "[", "k", "]", ",", "k", "]", "=", "1.0", "-", "np", ".", "sum", "(", "G", "[", "self", ".", "embed", "[", "k", "]", ",", ":", "]", ")", "\n", "", "", "return", "G", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.write_transition": [[95, 99], ["Q.reshape"], "methods", ["None"], ["", "def", "write_transition", "(", "self", ",", "tran", ")", ":", "\n", "        ", "\"\"\"Write transition matrix.\"\"\"", "\n", "Q", "=", "tran", "[", ":", ",", ":", "-", "1", "]", "\n", "self", ".", "_tran", "=", "Q", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.write_emission": [[100, 128], ["numpy.arange", "numpy.where", "numpy.zeros", "numpy.arange", "numpy.zeros", "range", "len", "ValueError"], "methods", ["None"], ["", "def", "write_emission", "(", "self", ",", "emis", ")", ":", "\n", "        ", "\"\"\"Write emission matrix.\n\n        Also updates the embedding scheme from categories to hidden states.\n        \"\"\"", "\n", "# constructs embedding scheme.", "\n", "embed", "=", "np", ".", "arange", "(", "self", ".", "num_cat", ")", "\n", "states", ",", "obs", "=", "np", ".", "where", "(", "emis", "!=", "0", ")", "\n", "if", "len", "(", "states", ")", "!=", "self", ".", "num_cat", ":", "\n", "            ", "raise", "ValueError", "(", "'The emission matrix does not satisfy the\\\n                             constraint for the topic model'", ")", "\n", "", "embed", "[", "obs", "]", "=", "states", "\n", "self", ".", "embed", "=", "embed", "\n", "# write emission parameters and corresponding categories of them", "\n", "pos", "=", "self", ".", "num_cat", "-", "self", ".", "num_hid", "-", "1", "# current position of self_emis", "\n", "self_emis", "=", "np", ".", "zeros", "(", "pos", "+", "1", ")", "\n", "self_cats", "=", "np", ".", "arange", "(", "pos", "+", "1", ")", "\n", "# exclude the last non-zero entry for each column in emission matrix.", "\n", "exclude", "=", "np", ".", "zeros", "(", "self", ".", "num_hid", ")", "\n", "for", "k", "in", "range", "(", "self", ".", "num_cat", "-", "1", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "            ", "if", "exclude", "[", "embed", "[", "k", "]", "]", "!=", "0", ":", "\n", "                ", "self_emis", "[", "pos", "]", "=", "emis", "[", "embed", "[", "k", "]", ",", "k", "]", "\n", "self_cats", "[", "pos", "]", "=", "k", "\n", "pos", "-=", "1", "\n", "", "else", ":", "\n", "                ", "exclude", "[", "embed", "[", "k", "]", "]", "=", "1", "\n", "", "", "self", ".", "_emis", "=", "self_emis", "\n", "self", ".", "_cats", "=", "self_cats", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.spectral_method": [[129, 173], ["numpy.zeros", "numpy.arange", "transform", "transform", "transform", "numpy.linalg.svd", "sklearn.cluster.AgglomerativeClustering().fit", "len", "transform.sum", "transform.sum", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "sklearn.cluster.AgglomerativeClustering", "len", "numpy.arange", "numpy.sum", "c_alpha.sum", "transform.sum"], "methods", ["None"], ["", "def", "spectral_method", "(", "self", ",", "obs", ",", "transform", "=", "np", ".", "sqrt", ",", "alpha", "=", "0.75", ")", ":", "\n", "        ", "\"\"\"Spectral embedding method.\n\n        Parameters\n        ----------\n        obs: array-like, 1D\n            Integer sequence of observations taking values from 0 to\n            ``num_cat - 1``.\n        transform: function, optional\n            Transformation method performed on the frequency of pairs of\n            adjacent observations and the frequency of observations. Default\n            is ``np.sqrt``.\n        alpha: double, optional\n            Smoothing parameter. Default is 0.75.\n\n        Returns\n        -------\n        embed: numpy.ndarray, 1D\n            Embedding scheme from categories to hidden states.\n        \"\"\"", "\n", "\n", "# counts data.", "\n", "count", "=", "np", ".", "zeros", "(", "(", "self", ".", "num_cat", ",", "self", ".", "num_cat", ")", ",", "int", ")", "# count pairs", "\n", "for", "w", "in", "np", ".", "arange", "(", "len", "(", "obs", ")", ")", ":", "\n", "            ", "if", "w", "!=", "len", "(", "obs", ")", "-", "1", ":", "\n", "                ", "count", "[", "obs", "[", "w", "]", ",", "obs", "[", "w", "+", "1", "]", "]", "+=", "1", "\n", "", "if", "w", "!=", "0", ":", "\n", "                ", "count", "[", "obs", "[", "w", "]", ",", "obs", "[", "w", "-", "1", "]", "]", "+=", "1", "\n", "", "", "num_of_content", "=", "transform", "(", "count", ".", "sum", "(", "1", ")", ")", "\n", "num_of_context", "=", "transform", "(", "count", ".", "sum", "(", "0", ")", ")", "\n", "count", "=", "transform", "(", "count", ")", "\n", "\n", "# constructs matrix :math:`\\\\Omega`.", "\n", "c_alpha", "=", "num_of_context", "**", "alpha", "\n", "omega", "=", "count", "*", "np", ".", "sqrt", "(", "c_alpha", ".", "sum", "(", ")", "/", "num_of_context", ".", "sum", "(", ")", ")", "/", "np", ".", "sqrt", "(", "num_of_content", "[", ":", ",", "np", ".", "newaxis", "]", "*", "c_alpha", "[", "np", ".", "newaxis", ",", ":", "]", ")", "\n", "# SVD.", "\n", "u", ",", "_", ",", "_", "=", "np", ".", "linalg", ".", "svd", "(", "omega", ",", "full_matrices", "=", "False", ")", "\n", "U", "=", "u", "[", ":", ",", "np", ".", "arange", "(", "self", ".", "num_hid", ")", "]", "\n", "E", "=", "U", "/", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "U", "**", "2", ",", "1", ")", "[", ":", ",", "np", ".", "newaxis", "]", ")", "\n", "# agglomerative clustering", "\n", "clustering", "=", "AgglomerativeClustering", "(", "n_clusters", "=", "self", ".", "num_hid", ")", ".", "fit", "(", "E", ")", "\n", "embed", "=", "clustering", ".", "labels_", "\n", "return", "embed", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.mle": [[174, 209], ["numpy.zeros", "numpy.zeros", "topic._count_freq", "topic._count_freq", "range", "range", "range", "len"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic._count_freq", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic._count_freq"], ["", "def", "mle", "(", "self", ",", "obs", ",", "embed", ",", "interpolation", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute maximum likelihood estimator assuming no change exists.\n\n        Parameters\n        ----------\n        obs: array-like, 1D\n            Integer sequence of observations taking values from 0 to\n            ``num_cat - 1``.\n        embed: array-like, 1D\n            Embedding scheme from categories to hidden states.\n\n        Returns\n        -------\n        G: numpy.ndarray, shape (num_hid, num_cat)\n            Emission matrix.\n        Q: numpy.ndarray, shape (num_hid, num_hid)\n            Transition matrix.\n        \"\"\"", "\n", "\n", "M", "=", "self", ".", "num_cat", "\n", "N", "=", "self", ".", "num_hid", "\n", "G", "=", "np", ".", "zeros", "(", "(", "N", ",", "M", ")", ")", "# emission matrix", "\n", "Q", "=", "np", ".", "zeros", "(", "(", "N", ",", "N", ")", ")", "# transition matrix", "\n", "county", ",", "_", "=", "_count_freq", "(", "obs", ",", "M", ")", "# observations", "\n", "countx", ",", "countq", "=", "_count_freq", "(", "embed", "[", "obs", "]", ",", "N", ")", "# states and state pairs", "\n", "# compute G and Q", "\n", "for", "w", "in", "range", "(", "M", ")", ":", "\n", "            ", "G", "[", "embed", "[", "w", "]", ",", "w", "]", "=", "county", "[", "w", "]", "/", "countx", "[", "embed", "[", "w", "]", "]", "\n", "", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "N", ")", ":", "\n", "                ", "if", "interpolation", ":", "\n", "                    ", "Q", "[", "i", ",", "j", "]", "=", "0.9", "*", "countq", "[", "i", ",", "j", "]", "/", "(", "countx", "[", "i", "]", "-", "(", "embed", "[", "obs", "[", "-", "1", "]", "]", "==", "i", ")", ")", "+", "0.1", "*", "countx", "[", "j", "]", "/", "len", "(", "obs", ")", "\n", "", "else", ":", "\n", "                    ", "Q", "[", "i", ",", "j", "]", "=", "countq", "[", "i", ",", "j", "]", "/", "(", "countx", "[", "i", "]", "-", "(", "embed", "[", "obs", "[", "-", "1", "]", "]", "==", "i", ")", ")", "\n", "", "", "", "return", "G", ",", "Q", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.train": [[210, 230], ["topic.AutogradTopic.spectral_method", "topic.AutogradTopic.mle", "topic.AutogradTopic.write_transition", "topic.AutogradTopic.write_emission"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.spectral_method", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.mle", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.write_transition", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.write_emission"], ["", "def", "train", "(", "self", ",", "obs", ",", "transform", "=", "np", ".", "sqrt", ",", "alpha", "=", "0.75", ",", "interpolation", "=", "False", ")", ":", "\n", "        ", "\"\"\"Train the model.\n\n        Parameters\n        ----------\n        obs: array-like, 1D\n            Integer sequence of observations taking values from 0 to\n            ``num_cat - 1``.\n        transform: function, optional\n            Transformation method performed on the frequency of pairs of\n            adjacent observations and the frequency of observations. Default\n            is ``np.sqrt``.\n        alpha: double, optional\n            Smoothing parameter. Default is 0.75.\n        \"\"\"", "\n", "\n", "embed", "=", "self", ".", "spectral_method", "(", "obs", ",", "transform", ",", "alpha", ")", "\n", "G", ",", "Q", "=", "self", ".", "mle", "(", "obs", ",", "embed", ",", "interpolation", ")", "\n", "self", ".", "write_transition", "(", "Q", ")", "\n", "self", ".", "write_emission", "(", "G", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.cond_loglike": [[231, 239], ["topic.AutogradTopic.get_emission", "topic.AutogradTopic.get_transition", "numpy.sum", "numpy.sum", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_emission", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_transition"], ["", "def", "cond_loglike", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"Compute conditional (on ``obs[0]``) log-likelihood.\"\"\"", "\n", "G", "=", "self", ".", "get_emission", "(", ")", "\n", "Q", "=", "self", ".", "get_transition", "(", ")", "\n", "states", "=", "self", ".", "embed", "[", "obs", "]", "\n", "cond_loglike", "=", "np", ".", "sum", "(", "np", ".", "log", "(", "Q", "[", "states", "[", ":", "-", "1", "]", ",", "states", "[", "1", ":", "]", "]", ")", ")", "+", "np", ".", "sum", "(", "np", ".", "log", "(", "G", "[", "states", "[", "1", ":", "]", ",", "obs", "[", "1", ":", "]", "]", ")", ")", "\n", "return", "cond_loglike", ",", "states", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.log_like": [[240, 249], ["topic.AutogradTopic.get_emission", "ValueError", "topic.AutogradTopic.cond_loglike", "topic.AutogradTopic.cond_loglike"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_emission", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.cond_loglike", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.cond_loglike"], ["", "def", "log_like", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"Compute log-likelihood.\"\"\"", "\n", "nu", "=", "self", ".", "_init", "\n", "G", "=", "self", ".", "get_emission", "(", ")", "\n", "if", "nu", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"No initial distribution is given\"", ")", "\n", "", "else", ":", "\n", "            ", "cond_loglike", ",", "states", "=", "self", ".", "cond_loglike", "(", "obs", ")", "\n", "return", "np", ".", "log", "(", "nu", "[", "states", "[", "0", "]", "]", ")", "+", "np", ".", "log", "(", "G", "[", "states", "[", "0", "]", ",", "obs", "[", "0", "]", "]", ")", "+", "cond_loglike", "(", "obs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.information": [[250, 296], ["topic.AutogradTopic.get_emission", "topic.AutogradTopic.get_transition", "numpy.setdiff1d", "numpy.arange", "numpy.zeros", "numpy.zeros", "enumerate", "range", "topic._count_freq", "topic._count_freq", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.ix_"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_emission", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_transition", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic._count_freq", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic._count_freq"], ["", "", "def", "information", "(", "self", ",", "obs", ",", "freq_cats", "=", "None", ",", "freq_pairs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute score and information.\n\n        Parameters\n        ----------\n        obs: array-like, 1D\n            Integer sequence of observations taking values from 0 to\n            ``num_cat - 1``.\n        freq_cats: array-like, shape (num_cat,), optional\n            Category frequency in observations. Default is None.\n        freq_pairs: array-like, shape (num_hid, num_hid), optional\n            Frequency of pairs of adjacent hidden states.\n        \"\"\"", "\n", "\n", "M", "=", "self", ".", "num_cat", "\n", "N", "=", "self", ".", "num_hid", "\n", "embed", "=", "self", ".", "embed", "\n", "cats", "=", "self", ".", "_cats", "\n", "G", "=", "self", ".", "get_emission", "(", ")", "\n", "Q", "=", "self", ".", "get_transition", "(", ")", "\n", "\n", "if", "freq_cats", "is", "None", ":", "\n", "            ", "freq_cats", ",", "_", "=", "_count_freq", "(", "obs", ",", "M", ")", "\n", "", "if", "freq_pairs", "is", "None", ":", "\n", "            ", "_", ",", "freq_pairs", "=", "_count_freq", "(", "embed", "[", "obs", "]", ",", "N", ")", "\n", "# construct the last word types in each column of emission matrix.", "\n", "", "last_word", "=", "np", ".", "setdiff1d", "(", "np", ".", "arange", "(", "M", ")", ",", "cats", ")", "\n", "last_hid2word", "=", "np", ".", "arange", "(", "N", ")", "\n", "last_hid2word", "[", "embed", "[", "last_word", "]", "]", "=", "last_word", "\n", "\n", "dim", "=", "M", "-", "N", "+", "N", "*", "(", "N", "-", "1", ")", "\n", "score", "=", "np", ".", "zeros", "(", "dim", ")", "\n", "info", "=", "np", ".", "zeros", "(", "(", "dim", ",", "dim", ")", ")", "\n", "for", "d", ",", "w", "in", "enumerate", "(", "cats", ")", ":", "\n", "            ", "last", "=", "last_hid2word", "[", "embed", "[", "w", "]", "]", "# last category with state ``embed[w]``", "\n", "score", "[", "d", "]", "=", "freq_cats", "[", "w", "]", "/", "G", "[", "embed", "[", "w", "]", ",", "w", "]", "-", "freq_cats", "[", "last", "]", "/", "G", "[", "embed", "[", "w", "]", ",", "last", "]", "\n", "catsembedw", "=", "np", ".", "arange", "(", "M", "-", "N", ")", "[", "embed", "[", "cats", "]", "==", "embed", "[", "w", "]", "]", "# categories with state embed[w]", "\n", "info", "[", "d", ",", "catsembedw", "]", "=", "freq_cats", "[", "last", "]", "/", "G", "[", "embed", "[", "w", "]", ",", "last", "]", "**", "2", "\n", "info", "[", "catsembedw", ",", "d", "]", "=", "freq_cats", "[", "last", "]", "/", "G", "[", "embed", "[", "w", "]", ",", "last", "]", "**", "2", "\n", "info", "[", "d", ",", "d", "]", "+=", "freq_cats", "[", "w", "]", "/", "G", "[", "embed", "[", "w", "]", ",", "w", "]", "**", "2", "\n", "", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "ind", "=", "M", "-", "N", "+", "np", ".", "arange", "(", "i", "*", "(", "N", "-", "1", ")", ",", "(", "i", "+", "1", ")", "*", "(", "N", "-", "1", ")", ")", "\n", "score", "[", "ind", "]", "=", "freq_pairs", "[", "i", ",", ":", "-", "1", "]", "/", "Q", "[", "i", ",", ":", "-", "1", "]", "-", "freq_pairs", "[", "i", ",", "N", "-", "1", "]", "/", "Q", "[", "i", ",", "N", "-", "1", "]", "\n", "info", "[", "np", ".", "ix_", "(", "ind", ",", "ind", ")", "]", "=", "freq_pairs", "[", "i", ",", "N", "-", "1", "]", "/", "Q", "[", "i", ",", "N", "-", "1", "]", "**", "2", "\n", "info", "[", "ind", ",", "ind", "]", "+=", "freq_pairs", "[", "i", ",", ":", "-", "1", "]", "/", "Q", "[", "i", ",", ":", "-", "1", "]", "**", "2", "\n", "", "return", "score", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.compute_stats": [[297, 389], ["utils._exceptions_handling", "topic._count_freq", "topic._count_freq", "numpy.identity", "topic.AutogradTopic.information", "utils.compute_thresholds", "numpy.concatenate", "numpy.zeros", "numpy.array", "enumerate", "utils._return_results", "len", "len", "max", "numpy.arange", "range", "topic.AutogradTopic.information", "utils._compute_stats", "utils._update_res", "numpy.linalg.solve", "numpy.array", "max", "numpy.isnan().any", "numpy.array", "print", "print", "max", "min", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._exceptions_handling", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic._count_freq", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic._count_freq", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.compute_thresholds", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._return_results", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res"], ["", "def", "compute_stats", "(", "self", ",", "obs", ",", "alpha", "=", "0.05", ",", "idx", "=", "None", ",", "prange", "=", "None", ",", "trange", "=", "None", ",", "stat_type", "=", "'autograd'", ")", ":", "\n", "        ", "\"\"\"Compute test statistics.\n\n        This function performs score-based hypothesis tests to detect the existence of a change in a text topic (Brown) model as it learns from\n        a continuous, possibly evolving, stream of data.\n        Three tests are implemented: the linear test, the scan test, and the autograd-test. The\n        linear statistic is the maximum score statistic over all possible locations of\n        change. The scan statistic is the maximum score statistic over all possible\n        locations of change, and over all possible subsets of parameters in which change occurs.\n\n        Parameters\n        ----------\n        obs: torch.Tensor, shape (size, dim)\n            Observations.\n        alpha: double or list, optional\n            Significance level(s). For the autograd-test it should be a list of length two,\n            where the first element is the significance level for the linear statistic and\n            the second is for the scan statistic. Default is 0.05.\n        idx: array-like, optional\n            Indices of parameters of interest (the rest parameters are considered constants)\n            in the parameter vector.\n            Default is ``None``, which will be set to ``range(dim)``.\n        prange: array-like, optional\n            Change cardinality set over which the scan statistic is maximized.\n            Default is ``None``,\n            which will be set to ``range(1, min([int(np.sqrt(d)), len(idx)]) + 1)``.\n        trange: array-like, optional\n            Change location set over which the statistic is maximized. Default is ``None``,\n            which will be set to ``range(int(n / 10) + lag, int(n * 9 / 10))``.\n        stat_type: str, optional\n            Type of statistic that is computed. It can take values in ``['linear', 'scan',\n            'autograd', 'all']``, where ``'all'`` indicates calculating all of them. Default is ``'autograd'``.\n\n        Returns\n        -------\n        stat: torch.Tensor\n            Test statistic at level ``alpha``. Reject null if it is larger than 1.\n        tau: int\n            Location of changepoint corresponds to the test statistic.\n        index: array-like\n            Indices of parameters correspond to the test statistic. It will be omitted for the linear test.\n\n        Raises\n        ------\n        NameError\n            If ``stat_type`` is not in ``['linear', 'scan', 'autograd', 'all']``.\n        ValueError\n            If ``alpha`` is not an instance of ``float`` or ``list``; or if ``prange``\n            is not within ``range(1, len(idx)+1)``; or if ``trange`` is not within\n            ``range(lag, size)``.\n        \"\"\"", "\n", "\n", "embed", "=", "self", ".", "embed", "\n", "dim", "=", "self", ".", "num_cat", "+", "self", ".", "num_hid", "*", "(", "self", ".", "num_hid", "-", "2", ")", "\n", "alpha", ",", "idx", ",", "prange", ",", "trange", "=", "_exceptions_handling", "(", "len", "(", "obs", ")", ",", "dim", ",", "alpha", ",", "\n", "0", ",", "idx", ",", "prange", ",", "\n", "trange", ",", "stat_type", ")", "\n", "# compute the inverse of information matrix once", "\n", "county", ",", "_", "=", "_count_freq", "(", "obs", ",", "self", ".", "num_cat", ")", "\n", "_", ",", "countq", "=", "_count_freq", "(", "embed", "[", "obs", "]", ",", "self", ".", "num_hid", ")", "\n", "ident", "=", "np", ".", "identity", "(", "dim", ")", "\n", "_", ",", "info", "=", "self", ".", "information", "(", "obs", ",", "county", ",", "countq", ")", "\n", "const", "=", "0", "\n", "while", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "Iinv", "=", "np", ".", "linalg", ".", "solve", "(", "info", "+", "const", "*", "ident", ",", "ident", ")", "\n", "break", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "                ", "const", "+=", "0.1", "\n", "if", "np", ".", "isnan", "(", "info", ")", ".", "any", "(", ")", ":", "\n", "                    ", "print", "(", "\"NAN while computing the information matrix.\"", ")", "\n", "print", "(", "\"Please increase the sample size.\"", ")", "\n", "return", "0", "\n", "# compute thresholds once", "\n", "", "", "", "thresh", "=", "compute_thresholds", "(", "len", "(", "idx", ")", ",", "\n", "max", "(", "[", "1", ",", "max", "(", "trange", ")", "-", "min", "(", "trange", ")", "]", ")", ",", "\n", "alpha", ",", "prange", ",", "stat_type", ")", "\n", "# compute test statistic", "\n", "seg", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "[", "0", "]", ")", ",", "np", ".", "array", "(", "trange", ")", "+", "1", ")", ")", "# two consecutive changepoints", "\n", "stat", "=", "np", ".", "zeros", "(", "3", ")", "\n", "tau", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "index", "=", "[", "idx", ",", "np", ".", "arange", "(", "max", "(", "prange", ")", ")", ",", "idx", "]", "\n", "for", "k", ",", "t", "in", "enumerate", "(", "trange", ")", ":", "\n", "            ", "for", "s", "in", "range", "(", "seg", "[", "k", "]", ",", "seg", "[", "k", "+", "1", "]", ")", ":", "\n", "                ", "county", "[", "obs", "[", "s", "]", "]", "-=", "1", "\n", "if", "s", ">", "0", ":", "countq", "[", "embed", "[", "obs", "[", "s", "-", "1", "]", "]", ",", "embed", "[", "obs", "[", "s", "]", "]", "]", "-=", "1", "\n", "", "score", ",", "info", "=", "self", ".", "information", "(", "obs", "[", "trange", "[", "k", "]", ":", "]", ",", "county", ",", "countq", ")", "\n", "new_stat", ",", "new_index", "=", "_compute_stats", "(", "prange", ",", "idx", ",", "score", ",", "info", ",", "\n", "Iinv", ",", "thresh", ",", "stat_type", ")", "\n", "stat", ",", "index", ",", "tau", "=", "_update_res", "(", "new_stat", ",", "stat", ",", "new_index", ",", "index", ",", "\n", "t", ",", "tau", ")", "\n", "", "return", "_return_results", "(", "stat", ",", "index", ",", "tau", ",", "stat_type", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic._count_freq": [[19, 39], ["numpy.zeros", "numpy.zeros", "numpy.unique", "numpy.unique"], "function", ["None"], ["def", "_count_freq", "(", "seq", ",", "num", ")", ":", "\n", "    ", "\"\"\"Count frequencies and pairs.\n\n    Parameters\n    ----------\n    seq: numpy.ndarray, 1D\n        A sequence of categorical variables.\n    num: int\n        Number of categories.\n    \"\"\"", "\n", "\n", "countz", "=", "np", ".", "zeros", "(", "num", ",", "int", ")", "\n", "count_pair", "=", "np", ".", "zeros", "(", "(", "num", ",", "num", ")", ",", "int", ")", "\n", "# count seq", "\n", "unique", ",", "counts", "=", "np", ".", "unique", "(", "seq", ",", "return_counts", "=", "True", ")", "\n", "countz", "[", "unique", "]", "=", "counts", "\n", "# count pairs", "\n", "unique", ",", "counts", "=", "np", ".", "unique", "(", "np", ".", "c_", "[", "seq", "[", ":", "-", "1", "]", ",", "seq", "[", "1", ":", "]", "]", ",", "return_counts", "=", "True", ",", "axis", "=", "0", ")", "\n", "count_pair", "[", "unique", "[", ":", ",", "0", "]", ",", "unique", "[", ":", ",", "1", "]", "]", "=", "counts", "\n", "return", "countz", ",", "count_pair", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc.__init__": [[40, 48], ["object.__init__", "sum", "range", "p.clone().detach().requires_grad_", "p.numel", "p.clone().detach", "p.clone"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.__init__"], ["def", "__init__", "(", "self", ",", "loglike", ",", "pars", ")", ":", "\n", "        ", "super", "(", "AutogradFunc", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_loglike", "=", "loglike", "\n", "self", ".", "_dim", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "pars", "]", ")", "\n", "self", ".", "_pars", "=", "[", "p", ".", "clone", "(", ")", ".", "detach", "(", ")", ".", "requires_grad_", "(", "True", ")", "for", "p", "in", "pars", "]", "\n", "self", ".", "_max_iter", "=", "2", "*", "self", ".", "_dim", "\n", "self", ".", "_accuracy", "=", "1e-7", "\n", "self", ".", "_indices", "=", "range", "(", "self", ".", "_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc.log_likelihood": [[49, 52], ["autotest_func.AutogradFunc._loglike"], "methods", ["None"], ["", "def", "log_likelihood", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"Compute log-likelihood.\"\"\"", "\n", "return", "self", ".", "_loglike", "(", "self", ".", "_pars", ",", "obs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc.gradients": [[53, 57], ["p.grad.detach().view", "torch.cat", "p.grad.detach"], "methods", ["None"], ["", "def", "gradients", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get gradient of model parameters.\"\"\"", "\n", "grads", "=", "[", "p", ".", "grad", ".", "detach", "(", ")", ".", "view", "(", "-", "1", ")", "for", "p", "in", "self", ".", "_pars", "]", "\n", "return", "torch", ".", "cat", "(", "grads", ")", "[", "self", ".", "_indices", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc.zero_grad": [[58, 63], ["p.grad.data.zero_"], "methods", ["None"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set gradient of model parameters to zero.\"\"\"", "\n", "for", "p", "in", "self", ".", "_pars", ":", "\n", "            ", "if", "p", ".", "grad", "is", "not", "None", ":", "\n", "                ", "p", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc.score_func": [[64, 70], ["autotest_func.AutogradFunc.zero_grad", "autotest_func.AutogradFunc.log_likelihood", "autotest_func.AutogradFunc.backward", "autotest_func.AutogradFunc.gradients"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.log_likelihood", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.gradients"], ["", "", "", "def", "score_func", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"Compute score function.\"\"\"", "\n", "self", ".", "zero_grad", "(", ")", "\n", "obj", "=", "self", ".", "log_likelihood", "(", "obs", ")", "\n", "obj", ".", "backward", "(", ")", "\n", "return", "self", ".", "gradients", "(", ")", "[", "self", ".", "_indices", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc._score_func": [[71, 77], ["autotest_func.AutogradFunc.log_likelihood", "torch.autograd.grad", "torch.cat", "g.view"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.log_likelihood"], ["", "def", "_score_func", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"Compute score function.\"\"\"", "\n", "obj", "=", "self", ".", "log_likelihood", "(", "obs", ")", "\n", "grads", "=", "grad", "(", "obj", ",", "self", ".", "_pars", ",", "create_graph", "=", "True", ")", "\n", "grads", "=", "torch", ".", "cat", "(", "[", "g", ".", "view", "(", "-", "1", ")", "for", "g", "in", "grads", "]", ")", "[", "self", ".", "_indices", "]", "\n", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc.information": [[78, 90], ["autotest_func.AutogradFunc.zero_grad", "autotest_func.AutogradFunc._score_func", "len", "torch.zeros", "torch.eye", "range", "autotest_func.AutogradFunc.backward", "autotest_func.AutogradFunc.zero_grad", "autotest_func.AutogradFunc.detach", "torch.zeros.detach", "autotest_func.AutogradFunc.gradients"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._score_func", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.gradients"], ["", "def", "information", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"Compute score function and information matrix.\"\"\"", "\n", "self", ".", "zero_grad", "(", ")", "\n", "grads", "=", "self", ".", "_score_func", "(", "obs", ")", "\n", "dim", "=", "len", "(", "self", ".", "_indices", ")", "\n", "info", "=", "torch", ".", "zeros", "(", "(", "dim", ",", "dim", ")", ")", "\n", "ident", "=", "torch", ".", "eye", "(", "dim", ")", "\n", "for", "i", "in", "range", "(", "dim", ")", ":", "\n", "            ", "grads", ".", "backward", "(", "ident", "[", "i", ",", ":", "]", ",", "retain_graph", "=", "True", ")", "\n", "info", "[", "i", ",", ":", "]", "=", "-", "self", ".", "gradients", "(", ")", "\n", "self", ".", "zero_grad", "(", ")", "\n", "", "return", "grads", ".", "detach", "(", ")", ",", "info", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc.vec_info_prod": [[91, 101], ["autotest_func.AutogradFunc.zero_grad", "loss.backward", "autotest_func.AutogradFunc.gradients", "autotest_func.AutogradFunc._score_func"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.gradients", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._score_func"], ["", "def", "vec_info_prod", "(", "self", ",", "obs", ",", "vec", ",", "create_graph", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute vector-information product.\"\"\"", "\n", "self", ".", "zero_grad", "(", ")", "\n", "if", "create_graph", ":", "\n", "            ", "grads", "=", "self", ".", "_score_func", "(", "obs", ")", "\n", "", "else", ":", "\n", "            ", "grads", "=", "self", ".", "_grads", "[", "self", ".", "_indices", "]", "\n", "", "loss", "=", "-", "grads", "@", "vec", "\n", "loss", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "return", "self", ".", "gradients", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc.inv_info_vec_prod": [[102, 122], ["len", "autotest_func.AutogradFunc.zero_grad", "autotest_func.AutogradFunc._score_func", "torch.randn", "utils.conjugate_grad", "utils.conjugate_grad.detach", "autotest_func.AutogradFunc.vec_info_prod", "torch.tensor", "autotest_func.AutogradFunc.vec_info_prod"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._score_func", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.conjugate_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod"], ["", "def", "inv_info_vec_prod", "(", "self", ",", "obs", ",", "vec", ",", "max_iter", "=", "100", ",", "accuracy", "=", "1e-7", ")", ":", "\n", "        ", "\"\"\"Compute inverse-information-vector product.\"\"\"", "\n", "npar", "=", "len", "(", "vec", ")", "\n", "if", "npar", "==", "1", ":", "\n", "            ", "diag_info", "=", "self", ".", "vec_info_prod", "(", "obs", ",", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ")", "\n", "return", "vec", "/", "diag_info", "\n", "\n", "", "self", ".", "zero_grad", "(", ")", "\n", "self", ".", "_grads", "=", "self", ".", "_score_func", "(", "obs", ")", "\n", "\n", "def", "quad_grad", "(", "x", ")", ":", "\n", "            ", "r", "=", "self", ".", "vec_info_prod", "(", "obs", ",", "x", ",", "create_graph", "=", "False", ")", "-", "vec", "\n", "return", "r", "\n", "\n", "", "init", "=", "torch", ".", "randn", "(", "npar", ")", "\n", "x", "=", "conjugate_grad", "(", "init", ",", "quad_grad", ",", "max_iter", "=", "max_iter", ",", "\n", "accuracy", "=", "accuracy", ")", "\n", "\n", "self", ".", "_grads", "=", "None", "\n", "return", "x", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc.compute_stats": [[123, 218], ["utils._exceptions_handling", "autotest_func.AutogradFunc._configuration", "autotest_func.AutogradFunc.information", "utils.compute_thresholds", "obs[].size", "len", "max", "autotest_func.AutogradFunc._conjugate_stats", "autotest_func.AutogradFunc._standard_stats", "max", "min"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._exceptions_handling", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._configuration", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.compute_thresholds", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._standard_stats"], ["", "def", "compute_stats", "(", "self", ",", "obs", ",", "alpha", "=", "0.05", ",", "lag", "=", "0", ",", "idx", "=", "None", ",", "prange", "=", "None", ",", "\n", "trange", "=", "None", ",", "stat_type", "=", "'autograd'", ",", "computation", "=", "'standard'", ",", "\n", "normalization", "=", "'schur'", ",", "max_iter", "=", "None", ",", "accuracy", "=", "1e-7", ")", ":", "\n", "        ", "\"\"\"Compute test statistics.\n\n        This function performs score-based hypothesis tests to detect the\n        existence of a change in machine learning systems as they learn from\n        a continuous, possibly evolving, stream of data.\n        Three tests are implemented: the linear test, the scan test, and the\n        autograd-test. The linear statistic is the maximum score statistic over\n        all possible locations of change. The scan statistic is the maximum\n        score statistic over all possible locations of change, and over all\n        possible subsets of parameters in which change occurs.\n\n        Parameters\n        ----------\n        obs: list of torch.Tensors\n        alpha: double or list, optional\n            Significance level(s). For the autograd-test it should be a list of length two,\n            where the first element is the significance level for the linear statistic and\n            the second is for the scan statistic. Default is 0.05.\n        lag: int, optional\n            Order of Markovian dependency. The distribution of ``obs[k]`` only\n            depends on ``obs[(k-lag):k]``. Use ``None`` to represent\n            non-Markovian dependency. Default is 0.\n        idx: array-like, optional\n            Indices of parameters of interest (the rest parameters are considered constants)\n            in the parameter vector.\n            Default is ``None``, which will be set to ``range(dim)``.\n        prange: array-like, optional\n            Change cardinality set over which the scan statistic is maximized.\n            Default is ``None``,\n            which will be set to ``range(1, min([int(np.sqrt(d)), len(idx)]) + 1)``.\n        trange: array-like, optional\n            Change location set over which the statistic is maximized. Default is ``None``,\n            which will be set to ``range(int(n / 10) + lag, int(n * 9 / 10))``.\n        stat_type: str, optional\n            Type of statistic that is computed. It can take values in ``['linear', 'scan',\n            'autograd', 'all']``, where ``'all'`` indicates calculating all of them. Default is ``'autograd'``.\n        computation: str, optional\n            Strategy to compute the test statistic. If ``'conjugate'``, then use\n            the conjugate gradient algorithm to compute inverse-Hessian-vector\n            product; if ``'standard'``, then use the full Fisher information to\n            compute the statistic. We recommend ``'standard'`` if data are\n            independent and ``'conjugate'`` otherwise. Default is ``'standard'``.\n        normalization: str, optional\n            Normalization matrix. If ``'schur'``, then use the Schur complement\n            as the normalization matrix; if ``'additive'``, then use\n            :math:`I_{1:\\\\tau}^{-1} + I_{\\\\tau+1:n}^{-1}`. Default is ``'schur'``.\n        max_iter: int, optional\n            Maximum number of iterations in the conjugate gradient algorithm.\n            Default is `None`, which will be set to ``2 * dim``.\n        accuracy: float, optional\n            Accuracy in the conjugate gradient algorithm.\n            Default is `1e-7`.\n\n        Returns\n        -------\n        stat: torch.Tensor\n            Test statistic at level ``alpha``. Reject null if it is larger than 1.\n        tau: int\n            Location of changepoint corresponds to the test statistic.\n        index: array-like\n            Indices of parameters correspond to the test statistic. It will be omitted for the linear test.\n\n        Raises\n        ------\n        NameError\n            If ``stat_type`` is not in ``['linear', 'scan', 'autograd', 'all']``;\n            or if ``computation`` is not in ``['conjugate, 'standard']``.\n        ValueError\n            If ``alpha`` is not an instance of ``float`` or ``list``; or if ``prange``\n            is not within ``range(1, len(idx)+1)``; or if ``trange`` is not within\n            ``range(lag, size)``.\n        \"\"\"", "\n", "\n", "alpha", ",", "idx", ",", "prange", ",", "trange", "=", "_exceptions_handling", "(", "\n", "obs", "[", "0", "]", ".", "size", "(", "0", ")", ",", "self", ".", "_dim", ",", "alpha", ",", "lag", ",", "idx", ",", "prange", ",", "trange", ",", "\n", "stat_type", ",", "computation", ")", "\n", "\n", "self", ".", "_configuration", "(", "\n", "lag", ",", "idx", ",", "prange", ",", "trange", ",", "stat_type", ",", "max_iter", ",", "accuracy", ")", "\n", "\n", "# computes the score and information matrix once", "\n", "score", ",", "info", "=", "self", ".", "information", "(", "obs", ")", "\n", "# computes thresholds once", "\n", "thresh", "=", "compute_thresholds", "(", "\n", "len", "(", "idx", ")", ",", "max", "(", "[", "1", ",", "max", "(", "trange", ")", "-", "min", "(", "trange", ")", "]", ")", ",", "\n", "alpha", ",", "prange", ",", "stat_type", ")", "\n", "\n", "if", "computation", "==", "'conjugate'", ":", "\n", "            ", "res", "=", "self", ".", "_conjugate_stats", "(", "obs", ",", "score", ",", "info", ",", "thresh", ")", "\n", "", "else", ":", "\n", "            ", "res", "=", "self", ".", "_standard_stats", "(", "obs", ",", "score", ",", "info", ",", "thresh", ",", "normalization", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc._configuration": [[219, 232], ["len"], "methods", ["None"], ["", "def", "_configuration", "(", "self", ",", "lag", ",", "idx", ",", "prange", ",", "trange", ",", "\n", "stat_type", ",", "max_iter", ",", "accuracy", ")", ":", "\n", "        ", "\"\"\"Configure class attributes.\"\"\"", "\n", "self", ".", "_lag", "=", "lag", "\n", "self", ".", "_idx", "=", "idx", "\n", "self", ".", "_prange", "=", "prange", "\n", "self", ".", "_trange", "=", "trange", "\n", "self", ".", "_stat_type", "=", "stat_type", "\n", "if", "max_iter", "is", "not", "None", ":", "\n", "            ", "self", ".", "_max_iter", "=", "max_iter", "\n", "", "else", ":", "\n", "            ", "self", ".", "_max_iter", "=", "2", "*", "len", "(", "idx", ")", "\n", "", "self", ".", "_accuracy", "=", "accuracy", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc._standard_stats": [[233, 261], ["torch.eye", "torch.zeros", "numpy.array", "torch.clone", "torch.clone", "enumerate", "utils._return_results", "utils._compute_inv", "numpy.arange", "utils._compute_stats", "utils._update_res", "max", "autotest_func.AutogradFunc.information", "autotest_func.AutogradFunc.information", "utils._get_batch", "utils._get_batch"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._return_results", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_inv", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._get_batch", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._get_batch"], ["", "def", "_standard_stats", "(", "self", ",", "obs", ",", "score", ",", "info", ",", "thresh", ",", "normalization", ")", ":", "\n", "        ", "\"\"\"Compute test statistics using the full Fisher information.\"\"\"", "\n", "# computes the inverse of information matrix once", "\n", "Iinv", "=", "torch", ".", "eye", "(", "self", ".", "_dim", ")", "\n", "if", "normalization", "==", "'schur'", ":", "\n", "            ", "Iinv", "=", "_compute_inv", "(", "Iinv", ",", "info", ")", "\n", "# computes test statistic", "\n", "", "stat", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "tau", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "index", "=", "[", "self", ".", "_idx", ",", "np", ".", "arange", "(", "max", "(", "self", ".", "_prange", ")", ")", ",", "self", ".", "_idx", "]", "\n", "score_t", "=", "torch", ".", "clone", "(", "score", ")", "\n", "info_t", "=", "torch", ".", "clone", "(", "info", ")", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "self", ".", "_trange", ")", ":", "\n", "            ", "if", "self", ".", "_lag", "is", "not", "None", ":", "\n", "                ", "lo", "=", "self", ".", "_trange", "[", "i", "-", "1", "]", "if", "i", ">", "0", "else", "self", ".", "_lag", "\n", "_score", ",", "_info", "=", "self", ".", "information", "(", "_get_batch", "(", "obs", ",", "lo", "-", "self", ".", "_lag", ",", "t", ")", ")", "\n", "score_t", "-=", "_score", "\n", "info_t", "-=", "_info", "\n", "", "else", ":", "\n", "                ", "score_t", ",", "info_t", "=", "self", ".", "information", "(", "_get_batch", "(", "obs", ",", "0", ",", "t", ")", ")", "\n", "score_t", "=", "score", "-", "score_t", "\n", "info_t", "=", "info", "-", "info_t", "\n", "", "new_stat", ",", "new_index", "=", "_compute_stats", "(", "\n", "self", ".", "_prange", ",", "self", ".", "_idx", ",", "score_t", ",", "info_t", ",", "Iinv", ",", "\n", "thresh", ",", "self", ".", "_stat_type", ",", "normalization", ",", "finfo", "=", "info", ")", "\n", "stat", ",", "index", ",", "tau", "=", "_update_res", "(", "\n", "new_stat", ",", "stat", ",", "new_index", ",", "index", ",", "t", ",", "tau", ")", "\n", "", "return", "_return_results", "(", "stat", ",", "index", ",", "tau", ",", "self", ".", "_stat_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc._conjugate_stats": [[262, 298], ["numpy.array", "list", "autotest_func.AutogradFunc._compute_info_diag", "utils._return_results", "torch.zeros", "torch.zeros", "numpy.arange", "int", "utils._get_batch", "autotest_func.AutogradFunc._score_func", "autotest_func.AutogradFunc._grads.detach", "utils._update_res", "max", "autotest_func.AutogradFunc._conjugate_raw_stat", "utils._compute_normalized_stat", "utils._compute_normalized_stat", "autotest_func.AutogradFunc._sort_diag", "autotest_func.AutogradFunc._conjugate_scan_stat", "len", "len", "len", "numpy.ix_"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._compute_info_diag", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._return_results", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._get_batch", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._score_func", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_raw_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._sort_diag", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_scan_stat"], ["", "def", "_conjugate_stats", "(", "self", ",", "obs", ",", "score", ",", "info", ",", "thresh", ")", ":", "\n", "        ", "\"\"\"Compute test statistics using the conjugate gradient method.\"\"\"", "\n", "idx", "=", "self", ".", "_idx", "\n", "# computes test statistic", "\n", "stat", ",", "new_stat", "=", "torch", ".", "zeros", "(", "3", ")", ",", "torch", ".", "zeros", "(", "3", ")", "\n", "tau", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "index", "=", "[", "idx", ",", "np", ".", "arange", "(", "max", "(", "self", ".", "_prange", ")", ")", ",", "idx", "]", "\n", "new_index", "=", "list", "(", "index", ")", "\n", "# compute the diagonal information in the middle once", "\n", "info_diag", "=", "self", ".", "_compute_info_diag", "(", "obs", ",", "int", "(", "len", "(", "obs", "[", "0", "]", ")", "/", "2", ")", ",", "info", ",", "idx", ")", "\n", "for", "t", "in", "self", ".", "_trange", ":", "\n", "            ", "batch", "=", "_get_batch", "(", "obs", ",", "0", ",", "t", ")", "\n", "self", ".", "_grads", "=", "self", ".", "_score_func", "(", "batch", ")", "\n", "score_t", "=", "self", ".", "_grads", ".", "detach", "(", ")", "\n", "score_t", "=", "score", "-", "score_t", "\n", "# linear statistics", "\n", "if", "self", ".", "_stat_type", "in", "[", "'linear'", ",", "'autograd'", ",", "'all'", "]", ":", "\n", "                ", "_stat", "=", "self", ".", "_conjugate_raw_stat", "(", "\n", "batch", ",", "score_t", "[", "idx", "]", ",", "info", "[", "np", ".", "ix_", "(", "idx", ",", "idx", ")", "]", ",", "idx", ")", "\n", "new_stat", "[", "0", "]", "=", "_compute_normalized_stat", "(", "_stat", ",", "len", "(", "idx", ")", ",", "thresh", "[", "0", "]", ")", "\n", "new_stat", "[", "2", "]", "=", "_compute_normalized_stat", "(", "_stat", ",", "len", "(", "idx", ")", ",", "thresh", "[", "2", "]", ")", "\n", "new_index", "[", "2", "]", "=", "idx", "\n", "# scan statistics ([I_{1:tau}]_{T, T}^{-1} + [I_{tau+1:n}]_{T, T}^{-1})", "\n", "", "if", "self", ".", "_stat_type", "in", "[", "'scan'", ",", "'autograd'", ",", "'all'", "]", ":", "\n", "                ", "order", "=", "self", ".", "_sort_diag", "(", "score_t", "[", "idx", "]", ",", "info_diag", ")", "\n", "_stat", ",", "_index", "=", "self", ".", "_conjugate_scan_stat", "(", "\n", "batch", ",", "score_t", ",", "info", ",", "thresh", ",", "order", ")", "\n", "new_stat", "[", "1", "]", ",", "new_index", "[", "1", "]", "=", "_stat", "[", "1", "]", ",", "_index", "[", "1", "]", "\n", "if", "_stat", "[", "2", "]", ">", "new_stat", "[", "2", "]", ":", "\n", "                    ", "new_stat", "[", "2", "]", ",", "new_index", "[", "2", "]", "=", "_stat", "[", "2", "]", ",", "_index", "[", "2", "]", "\n", "\n", "", "", "stat", ",", "index", ",", "tau", "=", "_update_res", "(", "\n", "new_stat", ",", "stat", ",", "new_index", ",", "index", ",", "t", ",", "tau", ")", "\n", "\n", "", "self", ".", "_grads", "=", "None", "\n", "return", "_return_results", "(", "stat", ",", "index", ",", "tau", ",", "self", ".", "_stat_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc._conjugate_raw_stat": [[299, 308], ["autotest_func.AutogradFunc.zero_grad", "range", "autotest_func.AutogradFunc._inv_info_vec_prod", "autotest_func.AutogradFunc._inv_info_vec_prod"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._inv_info_vec_prod", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._inv_info_vec_prod"], ["", "def", "_conjugate_raw_stat", "(", "self", ",", "obs", ",", "score", ",", "full_info", ",", "indices", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute the unnormalized score statistic at a given changepoint.\"\"\"", "\n", "self", ".", "zero_grad", "(", ")", "\n", "if", "indices", "is", "not", "None", ":", "\n", "            ", "self", ".", "_indices", "=", "indices", "\n", "", "stat", "=", "score", "@", "self", ".", "_inv_info_vec_prod", "(", "obs", ",", "score", ")", "\n", "stat", "+=", "score", "@", "self", ".", "_inv_info_vec_prod", "(", "obs", ",", "score", ",", "info", "=", "full_info", ")", "\n", "self", ".", "_indices", "=", "range", "(", "self", ".", "_dim", ")", "\n", "return", "stat", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc._conjugate_scan_stat": [[309, 326], ["torch.zeros", "enumerate", "numpy.arange", "autotest_func.AutogradFunc._conjugate_raw_stat", "max", "torch.tensor", "utils._compute_normalized_stat", "utils._compute_normalized_stat", "int", "int", "numpy.ix_"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_raw_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat"], ["", "def", "_conjugate_scan_stat", "(", "self", ",", "obs", ",", "score", ",", "full_info", ",", "thresh", ",", "order", ")", ":", "\n", "        ", "\"\"\"Compute the scan statistic given the ordering and the changepoint.\"\"\"", "\n", "stat", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "index", "=", "[", "self", ".", "_idx", ",", "np", ".", "arange", "(", "max", "(", "self", ".", "_prange", ")", ")", ",", "self", ".", "_idx", "]", "\n", "for", "j", ",", "p", "in", "enumerate", "(", "self", ".", "_prange", ")", ":", "\n", "            ", "_idx", "=", "torch", ".", "tensor", "(", "self", ".", "_idx", ")", "[", "order", "[", "-", "p", ":", "]", "]", "\n", "_stat", "=", "self", ".", "_conjugate_raw_stat", "(", "\n", "obs", ",", "score", "[", "_idx", "]", ",", "full_info", "[", "np", ".", "ix_", "(", "_idx", ",", "_idx", ")", "]", ",", "_idx", ")", "\n", "if", "self", ".", "_stat_type", "in", "[", "'scan'", ",", "'all'", "]", ":", "\n", "                ", "new_stat", "=", "_compute_normalized_stat", "(", "_stat", ",", "int", "(", "p", ")", ",", "thresh", "[", "1", "]", "[", "j", "]", ")", "\n", "if", "new_stat", ">", "stat", "[", "1", "]", ":", "\n", "                    ", "stat", "[", "1", "]", ",", "index", "[", "1", "]", "=", "new_stat", ",", "_idx", "\n", "", "", "if", "self", ".", "_stat_type", "in", "[", "'autograd'", ",", "'all'", "]", ":", "\n", "                ", "new_stat", "=", "_compute_normalized_stat", "(", "_stat", ",", "int", "(", "p", ")", ",", "thresh", "[", "3", "]", "[", "j", "]", ")", "\n", "if", "new_stat", ">", "stat", "[", "2", "]", ":", "\n", "                    ", "stat", "[", "2", "]", ",", "index", "[", "2", "]", "=", "new_stat", ",", "_idx", "\n", "", "", "", "return", "stat", ",", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc._compute_info_diag": [[327, 334], ["utils._get_batch", "autotest_func.AutogradFunc.information", "torch.diag", "torch.diag"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._get_batch", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information"], ["", "def", "_compute_info_diag", "(", "self", ",", "obs", ",", "t", ",", "info", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Compute the diagonal information matrices at time ``t``.\"\"\"", "\n", "batch", "=", "_get_batch", "(", "obs", ",", "0", ",", "t", ")", "\n", "_", ",", "half_info", "=", "self", ".", "information", "(", "batch", ")", "\n", "info_diag", "=", "[", "\n", "torch", ".", "diag", "(", "half_info", ")", "[", "idx", "]", ",", "torch", ".", "diag", "(", "info", "-", "half_info", ")", "[", "idx", "]", "]", "\n", "return", "info_diag", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc._sort_diag": [[335, 348], ["torch.sort"], "methods", ["None"], ["", "def", "_sort_diag", "(", "self", ",", "score", ",", "info_diag", ")", ":", "\n", "        ", "\"\"\"Sort the score statistic according to the diagonal terms.\"\"\"", "\n", "# old_info_diag = torch.zeros(len(self._idx))", "\n", "# for i, ind in enumerate(self._idx):", "\n", "#     vec = torch.zeros(self._dim)", "\n", "#     vec[ind] = 1", "\n", "#     old_info_diag[i] = self.vec_info_prod(obs, vec)[ind]", "\n", "# stat_diag = score**2 / old_info_diag", "\n", "# stat_diag += score**2 / (torch.diag(full_info) - old_info_diag)", "\n", "stat_diag", "=", "score", "**", "2", "/", "info_diag", "[", "0", "]", "\n", "stat_diag", "+=", "score", "**", "2", "/", "info_diag", "[", "1", "]", "\n", "_", ",", "order", "=", "torch", ".", "sort", "(", "stat_diag", ")", "\n", "return", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autotest_func.AutogradFunc._inv_info_vec_prod": [[349, 371], ["len", "torch.randn", "utils.conjugate_grad", "utils.conjugate_grad.detach", "autotest_func.AutogradFunc.vec_info_prod", "torch.tensor", "autotest_func.AutogradFunc.vec_info_prod", "autotest_func.AutogradFunc.vec_info_prod"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.conjugate_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod"], ["", "def", "_inv_info_vec_prod", "(", "self", ",", "obs", ",", "vec", ",", "info", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute inverse-information-vector product.\"\"\"", "\n", "npar", "=", "len", "(", "vec", ")", "\n", "if", "npar", "==", "1", ":", "\n", "            ", "diag_info", "=", "self", ".", "vec_info_prod", "(", "obs", ",", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ")", "\n", "if", "info", "is", "not", "None", ":", "\n", "                ", "diag_info", "=", "info", "[", "0", "]", "-", "diag_info", "\n", "", "return", "vec", "/", "diag_info", "\n", "\n", "", "if", "info", "is", "None", ":", "# for I_{1:tau}", "\n", "            ", "def", "quad_grad", "(", "x", ")", ":", "\n", "                ", "r", "=", "self", ".", "vec_info_prod", "(", "obs", ",", "x", ",", "create_graph", "=", "False", ")", "-", "vec", "\n", "return", "r", "\n", "", "", "else", ":", "# for I_{1:n} - I_{1:tau}", "\n", "            ", "def", "quad_grad", "(", "x", ")", ":", "\n", "                ", "r", "=", "info", "@", "x", "-", "self", ".", "vec_info_prod", "(", "obs", ",", "x", ",", "create_graph", "=", "False", ")", "-", "vec", "\n", "return", "r", "\n", "\n", "", "", "init", "=", "torch", ".", "randn", "(", "npar", ")", "\n", "x", "=", "conjugate_grad", "(", "init", ",", "quad_grad", ",", "max_iter", "=", "self", ".", "_max_iter", ",", "\n", "accuracy", "=", "self", ".", "_accuracy", ")", "\n", "return", "x", ".", "detach", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.__init__": [[56, 65], ["object.__init__", "sum", "copy.deepcopy", "range", "par.numel", "pretrained_model.parameters"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.__init__", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.parameters"], ["def", "__init__", "(", "self", ",", "pretrained_model", ",", "loglike", ")", ":", "\n", "        ", "super", "(", "AutogradTest", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_dim", "=", "sum", "(", "[", "par", ".", "numel", "(", ")", "for", "par", "in", "pretrained_model", ".", "parameters", "(", ")", "if", "\n", "par", ".", "requires_grad", "]", ")", "\n", "self", ".", "_model", "=", "copy", ".", "deepcopy", "(", "pretrained_model", ")", "\n", "self", ".", "_loglike", "=", "loglike", "\n", "self", ".", "_max_iter", "=", "2", "*", "self", ".", "_dim", "\n", "self", ".", "_accuracy", "=", "1e-7", "\n", "self", ".", "_indices", "=", "range", "(", "self", ".", "_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.log_likelihood": [[66, 70], ["autograd.AutogradTest._model().view", "autograd.AutogradTest._loglike", "autograd.AutogradTest._model"], "methods", ["None"], ["", "def", "log_likelihood", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"Compute log-likelihood.\"\"\"", "\n", "outputs", "=", "self", ".", "_model", "(", "inputs", ")", ".", "view", "(", "-", "1", ")", "\n", "return", "self", ".", "_loglike", "(", "outputs", ",", "targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.gradients": [[71, 78], ["p.grad.detach().view", "torch.cat", "autograd.AutogradTest._model.parameters", "p.grad.detach"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.parameters"], ["", "def", "gradients", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get gradient of model parameters.\n\n        Returns an 1D ``Tensor`` contains the gradient of parameters.\n        \"\"\"", "\n", "grads", "=", "[", "p", ".", "grad", ".", "detach", "(", ")", ".", "view", "(", "-", "1", ")", "for", "p", "in", "self", ".", "_model", ".", "parameters", "(", ")", "]", "\n", "return", "torch", ".", "cat", "(", "grads", ")", "[", "self", ".", "_indices", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.zero_grad": [[79, 82], ["autograd.AutogradTest._model.zero_grad"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set gradient of the model to zero.\"\"\"", "\n", "self", ".", "_model", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.score_func": [[83, 89], ["autograd.AutogradTest.zero_grad", "autograd.AutogradTest.log_likelihood", "autograd.AutogradTest.backward", "autograd.AutogradTest.gradients"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.log_likelihood", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.gradients"], ["", "def", "score_func", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"Compute score function.\"\"\"", "\n", "self", ".", "zero_grad", "(", ")", "\n", "like", "=", "self", ".", "log_likelihood", "(", "inputs", ",", "targets", ")", "\n", "like", ".", "backward", "(", ")", "\n", "return", "self", ".", "gradients", "(", ")", "[", "self", ".", "_indices", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._score_func": [[90, 95], ["autograd.AutogradTest.log_likelihood", "torch.autograd.grad", "autograd.AutogradTest._model.parameters", "torch.cat", "g.view"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.log_likelihood", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.parameters"], ["", "def", "_score_func", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "obj", "=", "self", ".", "log_likelihood", "(", "inputs", ",", "targets", ")", "\n", "grads", "=", "grad", "(", "obj", ",", "self", ".", "_model", ".", "parameters", "(", ")", ",", "create_graph", "=", "True", ")", "\n", "grads", "=", "torch", ".", "cat", "(", "[", "g", ".", "view", "(", "-", "1", ")", "for", "g", "in", "grads", "]", ")", "[", "self", ".", "_indices", "]", "\n", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.information": [[96, 108], ["autograd.AutogradTest.zero_grad", "autograd.AutogradTest._score_func", "len", "torch.zeros", "torch.eye", "range", "autograd.AutogradTest.backward", "autograd.AutogradTest.zero_grad", "autograd.AutogradTest.detach", "torch.zeros.detach", "autograd.AutogradTest.gradients"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._score_func", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.gradients"], ["", "def", "information", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"Compute score function and information matrix.\"\"\"", "\n", "self", ".", "zero_grad", "(", ")", "\n", "grads", "=", "self", ".", "_score_func", "(", "inputs", ",", "targets", ")", "\n", "dim", "=", "len", "(", "self", ".", "_indices", ")", "\n", "info", "=", "torch", ".", "zeros", "(", "(", "dim", ",", "dim", ")", ")", "\n", "ident", "=", "torch", ".", "eye", "(", "dim", ")", "\n", "for", "i", "in", "range", "(", "dim", ")", ":", "\n", "            ", "grads", ".", "backward", "(", "ident", "[", "i", ",", ":", "]", ",", "retain_graph", "=", "True", ")", "\n", "info", "[", "i", ",", ":", "]", "=", "-", "self", ".", "gradients", "(", ")", "\n", "self", ".", "zero_grad", "(", ")", "\n", "", "return", "grads", ".", "detach", "(", ")", ",", "info", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod": [[109, 119], ["autograd.AutogradTest.zero_grad", "obj.backward", "autograd.AutogradTest.gradients", "autograd.AutogradTest._score_func"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.gradients", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._score_func"], ["", "def", "vec_info_prod", "(", "self", ",", "inputs", ",", "targets", ",", "vec", ",", "create_graph", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute vector-information product.\"\"\"", "\n", "self", ".", "zero_grad", "(", ")", "\n", "if", "create_graph", ":", "\n", "            ", "grads", "=", "self", ".", "_score_func", "(", "inputs", ",", "targets", ")", "\n", "", "else", ":", "\n", "            ", "grads", "=", "self", ".", "_grads", "[", "self", ".", "_indices", "]", "\n", "", "obj", "=", "-", "grads", "@", "vec", "\n", "obj", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "return", "self", ".", "gradients", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.inv_info_vec_prod": [[121, 142], ["len", "autograd.AutogradTest.zero_grad", "autograd.AutogradTest._score_func", "torch.randn", "utils.conjugate_grad", "utils.conjugate_grad.detach", "autograd.AutogradTest.vec_info_prod", "torch.tensor", "autograd.AutogradTest.vec_info_prod"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._score_func", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.conjugate_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod"], ["", "def", "inv_info_vec_prod", "(", "self", ",", "inputs", ",", "targets", ",", "vec", ",", "\n", "max_iter", "=", "100", ",", "accuracy", "=", "1e-7", ")", ":", "\n", "        ", "\"\"\"Compute inverse-information-vector product.\"\"\"", "\n", "npar", "=", "len", "(", "vec", ")", "\n", "if", "npar", "==", "1", ":", "\n", "            ", "info", "=", "self", ".", "vec_info_prod", "(", "inputs", ",", "targets", ",", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ")", "\n", "return", "(", "vec", "/", "info", ")", ".", "detach", "(", ")", "\n", "\n", "", "self", ".", "zero_grad", "(", ")", "\n", "self", ".", "_grads", "=", "self", ".", "_score_func", "(", "inputs", ",", "targets", ")", "\n", "\n", "def", "quad_grad", "(", "x", ")", ":", "\n", "            ", "r", "=", "self", ".", "vec_info_prod", "(", "inputs", ",", "targets", ",", "x", ",", "create_graph", "=", "False", ")", "-", "vec", "\n", "return", "r", "\n", "\n", "", "init", "=", "torch", ".", "randn", "(", "npar", ")", "\n", "x", "=", "conjugate_grad", "(", "init", ",", "quad_grad", ",", "max_iter", "=", "max_iter", ",", "\n", "accuracy", "=", "accuracy", ")", "\n", "\n", "self", ".", "_grads", "=", "None", "\n", "return", "x", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.compute_stats": [[143, 240], ["utils._exceptions_handling", "autograd.AutogradTest._configuration", "autograd.AutogradTest.information", "utils.compute_thresholds", "inputs.size", "len", "max", "autograd.AutogradTest._conjugate_stats", "autograd.AutogradTest._standard_stats", "max", "min"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._exceptions_handling", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._configuration", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.compute_thresholds", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._standard_stats"], ["", "def", "compute_stats", "(", "self", ",", "inputs", ",", "targets", ",", "alpha", "=", "0.05", ",", "lag", "=", "0", ",", "idx", "=", "None", ",", "\n", "prange", "=", "None", ",", "trange", "=", "None", ",", "stat_type", "=", "'autograd'", ",", "\n", "computation", "=", "'standard'", ",", "normalization", "=", "'schur'", ",", "\n", "max_iter", "=", "None", ",", "accuracy", "=", "1e-7", ")", ":", "\n", "        ", "\"\"\"Compute test statistics.\n\n        This function performs score-based hypothesis tests to detect the\n        existence of a change in machine learning systems as they learn from\n        a continuous, possibly evolving, stream of data.\n        Three tests are implemented: the linear test, the scan test, and the autograd-test. The\n        linear statistic is the maximum score statistic over all possible locations of\n        change. The scan statistic is the maximum score statistic over all possible\n        locations of change, and over all possible subsets of parameters in which change occurs.\n\n        Parameters\n        ----------\n        inputs: torch.Tensor, shape (size, dim)\n        targets: torch.Tensor, shape (size, \\*)\n        alpha: double or list, optional\n            Significance level(s). For the autograd-test it should be a list of length two,\n            where the first element is the significance level for the linear statistic and\n            the second is for the scan statistic. Default is 0.05.\n        lag: int, optional\n            Order of Markovian dependency. The distribution of ``obs[k]`` only\n            depends on ``obs[(k-lag):k]``. Use ``None`` to represent\n            non-Markovian dependency. Default is 0.\n        idx: array-like, optional\n            Indices of parameters of interest (the rest parameters are considered constants)\n            in the parameter vector.\n            Default is ``None``, which will be set to ``range(dim)``.\n        prange: array-like, optional\n            Change cardinality set over which the scan statistic is maximized.\n            Default is ``None``,\n            which will be set to ``range(1, min([int(np.sqrt(d)), len(idx)]) + 1)``.\n        trange: array-like, optional\n            Change location set over which the statistic is maximized. Default is ``None``,\n            which will be set to ``range(int(n / 10) + lag, int(n * 9 / 10))``.\n        stat_type: str, optional\n            Type of statistic that is computed. It can take values in ``['linear', 'scan',\n            'autograd', 'all']``, where ``'all'`` indicates calculating all of them. Default is ``'autograd'``.\n        computation: str, optional\n            Strategy to compute the test statistic. If ``'conjugate'``, then use\n            the conjugate gradient algorithm to compute inverse-Hessian-vector\n            product; if ``'standard'``, then use the full Fisher information to\n            compute the statistic. We recommend ``'standard'`` if data are\n            independent and ``'conjugate'`` otherwise. Default is ``'standard'``.\n        normalization: str, optional\n            Normalization matrix. If ``'schur'``, then use the Schur complement\n            as the normalization matrix; if ``'additive'``, then use\n            :math:`I_{1:\\\\tau}^{-1} + I_{\\\\tau+1:n}^{-1}`. Default is ``'schur'``.\n        max_iter: int, optional\n            Maximum number of iterations in the conjugate gradient algorithm.\n            Default is `None`, which will be set to ``2 * dim``.\n        accuracy: float, optional\n            Accuracy in the conjugate gradient algorithm.\n            Default is `1e-7`.\n\n        Returns\n        -------\n        stat: torch.Tensor\n            Test statistic at level ``alpha``. Reject null if it is larger than 1.\n        tau: int\n            Location of changepoint corresponds to the test statistic.\n        index: array-like\n            Indices of parameters correspond to the test statistic. It will be omitted for the linear test.\n\n        Raises\n        ------\n        NameError\n            If ``stat_type`` is not in ``['linear', 'scan', 'autograd', 'all']``;\n            or if ``computation`` is not in ``['conjugate, 'standard']``.\n        ValueError\n            If ``alpha`` is not an instance of ``float`` or ``list``; or if ``prange``\n            is not within ``range(1, len(idx)+1)``; or if ``trange`` is not within\n            ``range(lag, size)``.\n        \"\"\"", "\n", "\n", "alpha", ",", "idx", ",", "prange", ",", "trange", "=", "_exceptions_handling", "(", "\n", "inputs", ".", "size", "(", "0", ")", ",", "self", ".", "_dim", ",", "alpha", ",", "lag", ",", "idx", ",", "prange", ",", "trange", ",", "\n", "stat_type", ",", "computation", ")", "\n", "\n", "self", ".", "_configuration", "(", "\n", "lag", ",", "idx", ",", "prange", ",", "trange", ",", "stat_type", ",", "max_iter", ",", "accuracy", ")", "\n", "\n", "# computes the score and information matrix once", "\n", "score", ",", "info", "=", "self", ".", "information", "(", "inputs", ",", "targets", ")", "\n", "# computes thresholds once", "\n", "thresh", "=", "compute_thresholds", "(", "\n", "len", "(", "idx", ")", ",", "max", "(", "[", "1", ",", "max", "(", "trange", ")", "-", "min", "(", "trange", ")", "]", ")", ",", "\n", "alpha", ",", "prange", ",", "stat_type", ")", "\n", "\n", "if", "computation", "==", "'conjugate'", ":", "\n", "            ", "res", "=", "self", ".", "_conjugate_stats", "(", "inputs", ",", "targets", ",", "score", ",", "info", ",", "thresh", ")", "\n", "", "else", ":", "\n", "            ", "res", "=", "self", ".", "_standard_stats", "(", "inputs", ",", "targets", ",", "score", ",", "info", ",", "\n", "thresh", ",", "normalization", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._configuration": [[241, 254], ["len"], "methods", ["None"], ["", "def", "_configuration", "(", "self", ",", "lag", ",", "idx", ",", "prange", ",", "trange", ",", "\n", "stat_type", ",", "max_iter", ",", "accuracy", ")", ":", "\n", "        ", "\"\"\"Configure class attributes.\"\"\"", "\n", "self", ".", "_lag", "=", "lag", "\n", "self", ".", "_idx", "=", "idx", "\n", "self", ".", "_prange", "=", "prange", "\n", "self", ".", "_trange", "=", "trange", "\n", "self", ".", "_stat_type", "=", "stat_type", "\n", "if", "max_iter", "is", "not", "None", ":", "\n", "            ", "self", ".", "_max_iter", "=", "max_iter", "\n", "", "else", ":", "\n", "            ", "self", ".", "_max_iter", "=", "2", "*", "len", "(", "idx", ")", "\n", "", "self", ".", "_accuracy", "=", "accuracy", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._standard_stats": [[255, 284], ["torch.eye", "torch.zeros", "numpy.array", "torch.clone", "torch.clone", "enumerate", "utils._return_results", "utils._compute_inv", "numpy.arange", "utils._compute_stats", "utils._update_res", "max", "autograd.AutogradTest.information", "autograd.AutogradTest.information"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._return_results", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_inv", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information"], ["", "def", "_standard_stats", "(", "self", ",", "inputs", ",", "targets", ",", "score", ",", "info", ",", "thresh", ",", "normalization", ")", ":", "\n", "        ", "\"\"\"Compute test statistics using the full Fisher information.\"\"\"", "\n", "# computes the inverse of information matrix once", "\n", "Iinv", "=", "torch", ".", "eye", "(", "self", ".", "_dim", ")", "\n", "if", "normalization", "==", "'schur'", ":", "\n", "            ", "Iinv", "=", "_compute_inv", "(", "Iinv", ",", "info", ")", "\n", "# computes test statistic", "\n", "", "stat", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "tau", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "index", "=", "[", "self", ".", "_idx", ",", "np", ".", "arange", "(", "max", "(", "self", ".", "_prange", ")", ")", ",", "self", ".", "_idx", "]", "\n", "score_t", "=", "torch", ".", "clone", "(", "score", ")", "\n", "info_t", "=", "torch", ".", "clone", "(", "info", ")", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "self", ".", "_trange", ")", ":", "\n", "            ", "if", "self", ".", "_lag", "is", "not", "None", ":", "\n", "                ", "lo", "=", "self", ".", "_trange", "[", "i", "-", "1", "]", "if", "i", ">", "0", "else", "self", ".", "_lag", "\n", "_score", ",", "_info", "=", "self", ".", "information", "(", "\n", "inputs", "[", "(", "lo", "-", "self", ".", "_lag", ")", ":", "t", "]", ",", "targets", "[", "(", "lo", "-", "self", ".", "_lag", ")", ":", "t", "]", ")", "\n", "score_t", "-=", "_score", "\n", "info_t", "-=", "_info", "\n", "", "else", ":", "\n", "                ", "score_t", ",", "info_t", "=", "self", ".", "information", "(", "inputs", "[", ":", "t", "]", ",", "targets", "[", ":", "t", "]", ")", "\n", "score_t", "=", "score", "-", "score_t", "\n", "info_t", "=", "info", "-", "info_t", "\n", "", "new_stat", ",", "new_index", "=", "_compute_stats", "(", "\n", "self", ".", "_prange", ",", "self", ".", "_idx", ",", "score_t", ",", "info_t", ",", "Iinv", ",", "\n", "thresh", ",", "self", ".", "_stat_type", ",", "normalization", ",", "finfo", "=", "info", ")", "\n", "stat", ",", "index", ",", "tau", "=", "_update_res", "(", "\n", "new_stat", ",", "stat", ",", "new_index", ",", "index", ",", "t", ",", "tau", ")", "\n", "", "return", "_return_results", "(", "stat", ",", "index", ",", "tau", ",", "self", ".", "_stat_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_stats": [[285, 325], ["numpy.array", "list", "int", "autograd.AutogradTest._compute_info_diag", "utils._return_results", "torch.zeros", "torch.zeros", "numpy.arange", "autograd.AutogradTest._score_func", "autograd.AutogradTest._grads.detach", "utils._update_res", "max", "len", "autograd.AutogradTest._conjugate_raw_stat", "utils._compute_normalized_stat", "utils._compute_normalized_stat", "autograd.AutogradTest._sort_diag", "autograd.AutogradTest._conjugate_scan_stat", "len", "len", "numpy.ix_"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._compute_info_diag", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._return_results", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._score_func", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_raw_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._sort_diag", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_scan_stat"], ["", "def", "_conjugate_stats", "(", "self", ",", "inputs", ",", "targets", ",", "score", ",", "info", ",", "thresh", ")", ":", "\n", "        ", "\"\"\"Compute test statistics using the conjugate gradient algorithm.\"\"\"", "\n", "idx", "=", "self", ".", "_idx", "\n", "# computes test statistic", "\n", "stat", ",", "new_stat", "=", "torch", ".", "zeros", "(", "3", ")", ",", "torch", ".", "zeros", "(", "3", ")", "\n", "tau", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "index", "=", "[", "idx", ",", "np", ".", "arange", "(", "max", "(", "self", ".", "_prange", ")", ")", ",", "idx", "]", "\n", "new_index", "=", "list", "(", "index", ")", "\n", "# compute the diagonal information in the middle once", "\n", "half", "=", "int", "(", "len", "(", "inputs", ")", "/", "2", ")", "\n", "info_diag", "=", "self", ".", "_compute_info_diag", "(", "\n", "inputs", "[", ":", "half", "]", ",", "targets", "[", ":", "half", "]", ",", "info", ",", "idx", ")", "\n", "for", "t", "in", "self", ".", "_trange", ":", "\n", "            ", "self", ".", "_grads", "=", "self", ".", "_score_func", "(", "inputs", "[", ":", "t", "]", ",", "targets", "[", ":", "t", "]", ")", "\n", "score_t", "=", "self", ".", "_grads", ".", "detach", "(", ")", "\n", "score_t", "=", "score", "-", "score_t", "\n", "# linear statistics", "\n", "if", "self", ".", "_stat_type", "in", "[", "'linear'", ",", "'autograd'", ",", "'all'", "]", ":", "\n", "                ", "_stat", "=", "self", ".", "_conjugate_raw_stat", "(", "\n", "inputs", "[", ":", "t", "]", ",", "targets", "[", ":", "t", "]", ",", "score_t", "[", "idx", "]", ",", "\n", "info", "[", "np", ".", "ix_", "(", "idx", ",", "idx", ")", "]", ",", "idx", ")", "\n", "new_stat", "[", "0", "]", "=", "_compute_normalized_stat", "(", "_stat", ",", "len", "(", "idx", ")", ",", "thresh", "[", "0", "]", ")", "\n", "new_stat", "[", "2", "]", "=", "_compute_normalized_stat", "(", "_stat", ",", "len", "(", "idx", ")", ",", "thresh", "[", "2", "]", ")", "\n", "new_index", "[", "2", "]", "=", "idx", "\n", "# scan statistics ([I_{1:tau}]_{T, T}^{-1} + [I_{tau+1:n}]_{T, T}^{-1})", "\n", "", "if", "self", ".", "_stat_type", "in", "[", "'scan'", ",", "'autograd'", ",", "'all'", "]", ":", "\n", "# order = self._conjugate_sort_diag(", "\n", "#     inputs[:t], targets[:t], score_t[idx], info[np.ix_(idx, idx)])", "\n", "                ", "order", "=", "self", ".", "_sort_diag", "(", "score_t", "[", "idx", "]", ",", "info_diag", ")", "\n", "_stat", ",", "_index", "=", "self", ".", "_conjugate_scan_stat", "(", "\n", "inputs", "[", ":", "t", "]", ",", "targets", "[", ":", "t", "]", ",", "score_t", ",", "info", ",", "thresh", ",", "order", ")", "\n", "new_stat", "[", "1", "]", ",", "new_index", "[", "1", "]", "=", "_stat", "[", "1", "]", ",", "_index", "[", "1", "]", "\n", "if", "_stat", "[", "2", "]", ">", "new_stat", "[", "2", "]", ":", "\n", "                    ", "new_stat", "[", "2", "]", ",", "new_index", "[", "2", "]", "=", "_stat", "[", "2", "]", ",", "_index", "[", "2", "]", "\n", "\n", "", "", "stat", ",", "index", ",", "tau", "=", "_update_res", "(", "\n", "new_stat", ",", "stat", ",", "new_index", ",", "index", ",", "t", ",", "tau", ")", "\n", "\n", "", "self", ".", "_grads", "=", "None", "\n", "return", "_return_results", "(", "stat", ",", "index", ",", "tau", ",", "self", ".", "_stat_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_raw_stat": [[326, 336], ["autograd.AutogradTest.zero_grad", "range", "autograd.AutogradTest._inv_info_vec_prod", "autograd.AutogradTest._inv_info_vec_prod"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._inv_info_vec_prod", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._inv_info_vec_prod"], ["", "def", "_conjugate_raw_stat", "(", "self", ",", "inputs", ",", "targets", ",", "score", ",", "full_info", ",", "indices", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute the unnormalized score statistic at a given changepoint.\"\"\"", "\n", "self", ".", "zero_grad", "(", ")", "\n", "if", "indices", "is", "not", "None", ":", "\n", "            ", "self", ".", "_indices", "=", "indices", "\n", "", "stat", "=", "score", "@", "self", ".", "_inv_info_vec_prod", "(", "inputs", ",", "targets", ",", "score", ")", "\n", "stat", "+=", "score", "@", "self", ".", "_inv_info_vec_prod", "(", "\n", "inputs", ",", "targets", ",", "score", ",", "info", "=", "full_info", ")", "\n", "self", ".", "_indices", "=", "range", "(", "self", ".", "_dim", ")", "\n", "return", "stat", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_scan_stat": [[337, 355], ["torch.zeros", "enumerate", "numpy.arange", "autograd.AutogradTest._conjugate_raw_stat", "max", "torch.tensor", "utils._compute_normalized_stat", "utils._compute_normalized_stat", "int", "int", "numpy.ix_"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._conjugate_raw_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat"], ["", "def", "_conjugate_scan_stat", "(", "self", ",", "inputs", ",", "targets", ",", "score", ",", "full_info", ",", "\n", "thresh", ",", "order", ")", ":", "\n", "        ", "\"\"\"Compute the scan statistic given the ordering and the changepoint.\"\"\"", "\n", "stat", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "index", "=", "[", "self", ".", "_idx", ",", "np", ".", "arange", "(", "max", "(", "self", ".", "_prange", ")", ")", ",", "self", ".", "_idx", "]", "\n", "for", "j", ",", "p", "in", "enumerate", "(", "self", ".", "_prange", ")", ":", "\n", "            ", "_idx", "=", "torch", ".", "tensor", "(", "self", ".", "_idx", ")", "[", "order", "[", "-", "p", ":", "]", "]", "\n", "_stat", "=", "self", ".", "_conjugate_raw_stat", "(", "\n", "inputs", ",", "targets", ",", "score", "[", "_idx", "]", ",", "full_info", "[", "np", ".", "ix_", "(", "_idx", ",", "_idx", ")", "]", ",", "_idx", ")", "\n", "if", "self", ".", "_stat_type", "in", "[", "'scan'", ",", "'all'", "]", ":", "\n", "                ", "new_stat", "=", "_compute_normalized_stat", "(", "_stat", ",", "int", "(", "p", ")", ",", "thresh", "[", "1", "]", "[", "j", "]", ")", "\n", "if", "new_stat", ">", "stat", "[", "1", "]", ":", "\n", "                    ", "stat", "[", "1", "]", ",", "index", "[", "1", "]", "=", "new_stat", ",", "_idx", "\n", "", "", "if", "self", ".", "_stat_type", "in", "[", "'autograd'", ",", "'all'", "]", ":", "\n", "                ", "new_stat", "=", "_compute_normalized_stat", "(", "_stat", ",", "int", "(", "p", ")", ",", "thresh", "[", "3", "]", "[", "j", "]", ")", "\n", "if", "new_stat", ">", "stat", "[", "2", "]", ":", "\n", "                    ", "stat", "[", "2", "]", ",", "index", "[", "2", "]", "=", "new_stat", ",", "_idx", "\n", "", "", "", "return", "stat", ",", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._compute_info_diag": [[356, 362], ["autograd.AutogradTest.information", "torch.diag", "torch.diag"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information"], ["", "def", "_compute_info_diag", "(", "self", ",", "inputs", ",", "targets", ",", "info", ",", "idx", ")", ":", "\n", "        ", "\"\"\"Compute the diagonal information matrices.\"\"\"", "\n", "_", ",", "half_info", "=", "self", ".", "information", "(", "inputs", ",", "targets", ")", "\n", "info_diag", "=", "[", "\n", "torch", ".", "diag", "(", "half_info", ")", "[", "idx", "]", ",", "torch", ".", "diag", "(", "info", "-", "half_info", ")", "[", "idx", "]", "]", "\n", "return", "info_diag", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._sort_diag": [[363, 369], ["torch.sort"], "methods", ["None"], ["", "def", "_sort_diag", "(", "self", ",", "score", ",", "info_diag", ")", ":", "\n", "        ", "\"\"\"Sort the score statistic according to the diagonal terms.\"\"\"", "\n", "stat_diag", "=", "score", "**", "2", "/", "info_diag", "[", "0", "]", "\n", "stat_diag", "+=", "score", "**", "2", "/", "info_diag", "[", "1", "]", "\n", "_", ",", "order", "=", "torch", ".", "sort", "(", "stat_diag", ")", "\n", "return", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest._inv_info_vec_prod": [[370, 394], ["len", "torch.randn", "utils.conjugate_grad", "utils.conjugate_grad.detach", "autograd.AutogradTest.vec_info_prod", "torch.tensor", "autograd.AutogradTest.vec_info_prod", "autograd.AutogradTest.vec_info_prod"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.conjugate_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autograd.AutogradTest.vec_info_prod"], ["", "def", "_inv_info_vec_prod", "(", "self", ",", "inputs", ",", "targets", ",", "vec", ",", "info", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute inverse-information-vector product.\"\"\"", "\n", "npar", "=", "len", "(", "vec", ")", "\n", "if", "npar", "==", "1", ":", "\n", "            ", "diag_info", "=", "self", ".", "vec_info_prod", "(", "inputs", ",", "targets", ",", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ")", "\n", "if", "info", "is", "not", "None", ":", "\n", "                ", "diag_info", "=", "info", "[", "0", "]", "-", "diag_info", "\n", "", "return", "vec", "/", "diag_info", "\n", "\n", "", "if", "info", "is", "None", ":", "# for I_{1:tau}", "\n", "            ", "def", "quad_grad", "(", "x", ")", ":", "\n", "                ", "r", "=", "self", ".", "vec_info_prod", "(", "\n", "inputs", ",", "targets", ",", "x", ",", "create_graph", "=", "False", ")", "-", "vec", "\n", "return", "r", "\n", "", "", "else", ":", "# for I_{1:n} - I_{1:tau}", "\n", "            ", "def", "quad_grad", "(", "x", ")", ":", "\n", "                ", "r", "=", "info", "@", "x", "-", "self", ".", "vec_info_prod", "(", "\n", "inputs", ",", "targets", ",", "x", ",", "create_graph", "=", "False", ")", "-", "vec", "\n", "return", "r", "\n", "\n", "", "", "init", "=", "torch", ".", "randn", "(", "npar", ")", "\n", "x", "=", "conjugate_grad", "(", "init", ",", "quad_grad", ",", "max_iter", "=", "self", ".", "_max_iter", ",", "\n", "accuracy", "=", "self", ".", "_accuracy", ")", "\n", "return", "x", ".", "detach", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.__init__": [[86, 95], ["object.__init__", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.__init__"], ["def", "__init__", "(", "self", ",", "n_states", ",", "init", "=", "None", ")", ":", "\n", "        ", "super", "(", "AutogradHmm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_n_states", "=", "n_states", "\n", "self", ".", "_init", "=", "init", "or", "torch", ".", "ones", "(", "n_states", ")", "/", "n_states", "\n", "self", ".", "_tran", "=", "torch", ".", "tensor", "(", "[", "]", ")", "\n", "self", ".", "_emis", "=", "torch", ".", "tensor", "(", "[", "]", ")", "\n", "self", ".", "_is_discrete", "=", "None", "\n", "self", ".", "_forward", "=", "torch", ".", "tensor", "(", "[", "]", ")", "\n", "self", ".", "_const", "=", "torch", ".", "tensor", "(", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.parameters": [[96, 100], ["None"], "methods", ["None"], ["", "def", "parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get model parameters.\"\"\"", "\n", "if", "self", ".", "_tran", ".", "requires_grad", ":", "yield", "self", ".", "_tran", "\n", "if", "self", ".", "_emis", ".", "requires_grad", ":", "yield", "self", ".", "_emis", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_transition": [[101, 104], ["hmm._construct_prob_mat"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm._construct_prob_mat"], ["", "def", "get_transition", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get transition matrix.\"\"\"", "\n", "return", "_construct_prob_mat", "(", "self", ".", "_tran", ",", "self", ".", "_n_states", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_emission": [[105, 115], ["hmm.AutogradHmm._emis.view", "hmm._construct_prob_mat"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm._construct_prob_mat"], ["", "def", "get_emission", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get emission parameters.\n\n        If the emission distribution is discrete, returns the emission matrix;\n        otherwise returns a matrix whose :math:`k`-th row contains parameters\n        of emission distribution given hidden state :math:`k`.\n        \"\"\"", "\n", "if", "self", ".", "_is_discrete", "==", "\"Discrete\"", ":", "\n", "            ", "return", "_construct_prob_mat", "(", "self", ".", "_emis", ",", "self", ".", "_n_states", ")", "\n", "", "return", "self", ".", "_emis", ".", "view", "(", "self", ".", "_n_states", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_normalized_forward": [[116, 119], ["None"], "methods", ["None"], ["", "def", "get_normalized_forward", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get normalized forward probabilities (filtering).\"\"\"", "\n", "return", "self", ".", "_forward", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_normalizing_constant": [[120, 123], ["None"], "methods", ["None"], ["", "def", "get_normalizing_constant", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get normalizing constants of forward quantities.\"\"\"", "\n", "return", "self", ".", "_const", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.write_transition": [[124, 139], ["hmm._prob_mat_pars"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm._prob_mat_pars"], ["", "def", "write_transition", "(", "self", ",", "tran", ",", "requires_grad", "=", "False", ")", ":", "\n", "        ", "\"\"\"Write transition parameters of the model.\n\n        Parameters\n        ----------\n        tran: array-like, shape (n_states, n_states)\n            Transition matrix (``tran[i, j]`` is the conditional probability\n            :math:`p(j|i)`).\n        requires_grad: bool, optional\n            Gradient status of the transition parameters (set to ``False`` if\n            true values are known and provided). Default is ``False``.\n        \"\"\"", "\n", "\n", "self", ".", "_tran", "=", "_prob_mat_pars", "(", "tran", ")", "\n", "self", ".", "_tran", ".", "requires_grad", "=", "requires_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.write_emission": [[140, 161], ["torch.tensor().float", "torch.tensor().float.view", "torch.tensor().float().view", "torch.tensor", "torch.tensor().float", "torch.tensor"], "methods", ["None"], ["", "def", "write_emission", "(", "self", ",", "emis", ",", "discrete", ",", "requires_grad", "=", "False", ")", ":", "\n", "        ", "\"\"\"Write emission parameters of the model.\n\n        Parameters\n        ----------\n        emis: array-like, shape (n_states, *)\n            Emission parameters. Its :math:`k`-th row contains parameters of emission distribution given hidden state :math:`k`.\n        discrete: bool\n            Indicates if the emission distribution is discrete.\n        requires_grad: bool, optional\n            Gradient status of the emission parameters (set to ``False`` if\n            true values are known and provided). Default is ``False``.\n        \"\"\"", "\n", "\n", "if", "discrete", ":", "\n", "            ", "G", "=", "torch", ".", "tensor", "(", "emis", "[", ":", ",", ":", "-", "1", "]", ")", ".", "float", "(", ")", "\n", "self", ".", "_emis", "=", "G", ".", "view", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_emis", "=", "torch", ".", "tensor", "(", "emis", ")", ".", "float", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "", "self", ".", "_emis", ".", "requires_grad", "=", "requires_grad", "\n", "self", ".", "_is_discrete", "=", "discrete", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.setup": [[162, 190], ["hmm.AutogradHmm.write_transition", "hmm.AutogradHmm.write_emission"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.write_transition", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.write_emission"], ["", "def", "setup", "(", "self", ",", "tran", ",", "emis", ",", "discrete", ",", "true_train", "=", "False", ",", "true_emis", "=", "False", ")", ":", "\n", "        ", "\"\"\"Set up the model.\n\n        This method constructs the HMM based on the transition parameters and\n        emission parameters provided. You should indicate if they are true\n        values or estimates (unknown). True values will not be considered as\n        model parameters.\n\n        Parameters\n        ----------\n        tran: array-like, shape (n_states, n_states)\n            Transition matrix.\n        emis: array-like, shape (n_states, *)\n            Emission parameters. If emission distribution is discrete, it\n            should be emission matrix; otherwise it is a matrix whose\n            :math:`k`-th row contains parameters of emission distribution\n            given hidden state :math:`k`.\n        discrete: bool\n            Indicates if emission distribution is discrete.\n        true_train: bool, optional\n            Indicates if the transition matrix provided is the true value or\n            estimate from data. Default is ``False``.\n        true_emis: bool, optional\n            Indicates if the emission parameters provided are true values or\n            estimates from data. Default is ``False``.\n        \"\"\"", "\n", "self", ".", "write_transition", "(", "tran", ",", "not", "true_train", ")", "\n", "self", ".", "write_emission", "(", "emis", ",", "discrete", ",", "not", "true_emis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.gradients": [[191, 202], ["torch.cat", "grads.append", "grads.append"], "methods", ["None"], ["", "def", "gradients", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get gradients of model parameters.\n\n        Returns an 1D ``Tensor`` contains the gradient of parameters.\n        \"\"\"", "\n", "grads", "=", "[", "]", "\n", "tran_grad", "=", "self", ".", "_tran", ".", "grad", "\n", "emit_grad", "=", "self", ".", "_emis", ".", "grad", "\n", "if", "tran_grad", "is", "not", "None", ":", "grads", ".", "append", "(", "tran_grad", ")", "\n", "if", "emit_grad", "is", "not", "None", ":", "grads", ".", "append", "(", "emit_grad", ")", "\n", "return", "torch", ".", "cat", "(", "grads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.loglike_emission": [[203, 219], ["None"], "methods", ["None"], ["", "def", "loglike_emission", "(", "self", ",", "obs", ",", "states", ")", ":", "\n", "        ", "\"\"\"Compute log-likelihood for the emission distribution.\n\n        Should be overridden by all subclasses. Use the method ``get_emission``\n        to get emission parameters.\n\n        It should at least support a single observation and associated hidden state.\n\n        Parameters\n        ----------\n        obs: torch.Tensor\n            Observations.\n        states: array-like (integer)\n            Hidden states associated with ``obs``.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.information_emission": [[220, 252], ["hmm.AutogradHmm._par_length", "torch.zeros", "torch.zeros", "hmm.AutogradHmm.loglike_emission", "torch.eye", "range", "torch.autograd.grad", "len", "len", "torch.zeros.detach", "torch.zeros.detach", "hmm.AutogradHmm._emis.grad.data.zero_", "grads.backward", "grads.backward", "len"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._par_length", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.loglike_emission"], ["", "def", "information_emission", "(", "self", ",", "obs", ",", "states", ")", ":", "\n", "        ", "\"\"\"Compute score and information for the emission distribution.\n\n        Parameters\n        ----------\n        obs: torch.Tensor\n            Observations.\n        states: array-like (integer)\n            Hidden states associated with ``obs``.\n        \"\"\"", "\n", "lpar", "=", "self", ".", "_par_length", "(", ")", "\n", "score", "=", "torch", ".", "zeros", "(", "lpar", ")", "\n", "information", "=", "torch", ".", "zeros", "(", "(", "lpar", ",", "lpar", ")", ")", "\n", "emis", "=", "self", ".", "_emis", "\n", "if", "not", "emis", ".", "requires_grad", ":", "\n", "            ", "return", "score", ",", "information", "\n", "\n", "", "loglike", "=", "self", ".", "loglike_emission", "(", "obs", ",", "states", ")", "\n", "grads", "=", "grad", "(", "loglike", ",", "emis", ",", "allow_unused", "=", "True", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "# stores gradients and information matrix", "\n", "n_states", "=", "self", ".", "_n_states", "\n", "start", "=", "n_states", "*", "(", "n_states", "-", "1", ")", "\n", "ident", "=", "torch", ".", "eye", "(", "len", "(", "emis", ")", ")", "\n", "score", "[", "start", ":", "]", "=", "grads", "\n", "for", "j", "in", "range", "(", "len", "(", "emis", ")", ")", ":", "\n", "            ", "if", "self", ".", "_emis", ".", "grad", "is", "not", "None", ":", "self", ".", "_emis", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "if", "j", "<", "len", "(", "emis", ")", "-", "1", ":", "\n", "                ", "grads", ".", "backward", "(", "ident", "[", "j", "]", ",", "retain_graph", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "grads", ".", "backward", "(", "ident", "[", "j", "]", ")", "\n", "", "information", "[", "start", "+", "j", ",", "start", ":", "]", "=", "-", "emis", ".", "grad", "\n", "", "return", "score", ".", "detach", "(", ")", ",", "information", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.filtering": [[253, 286], ["len", "hmm.AutogradHmm.get_transition().detach", "torch.zeros", "torch.zeros", "torch.tensor", "torch.sum", "range", "torch.tensor", "torch.sum", "hmm.AutogradHmm.get_transition", "torch.exp", "hmm.AutogradHmm.loglike_emission", "range", "torch.exp", "hmm.AutogradHmm.loglike_emission", "range"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_transition", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.loglike_emission", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.loglike_emission"], ["", "def", "filtering", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"Perform normalized forward algorithm (filtering).\n\n        This method implements the normalized forward algorithm for\n        observations provided and stores the forward probabilities and\n        normalizing constants as model attributes. See the book\n        \"`Inference in Hidden Markov Models <http://people.bordeaux.inria.fr/pierre.delmoral/hmm-cappe-moulines-ryden.pdf>`_\"\n        for more details.\n\n        Parameters\n        ----------\n        obs: torch.Tensor\n            Observations.\n        \"\"\"", "\n", "\n", "n", "=", "len", "(", "obs", ")", "\n", "N", "=", "self", ".", "_n_states", "\n", "Q", "=", "self", ".", "get_transition", "(", ")", ".", "detach", "(", ")", "\n", "c", "=", "torch", ".", "zeros", "(", "n", ")", "# normalizing constant", "\n", "forwards", "=", "torch", ".", "zeros", "(", "(", "n", ",", "N", ")", ")", "# filtering", "\n", "g", "=", "torch", ".", "tensor", "(", "[", "torch", ".", "exp", "(", "self", ".", "loglike_emission", "(", "obs", "[", "0", "]", ",", "state", ")", ")", "for", "\n", "state", "in", "range", "(", "N", ")", "]", ")", "# emission probabilities", "\n", "# initialization", "\n", "c", "[", "0", "]", "=", "torch", ".", "sum", "(", "g", "*", "self", ".", "_init", ")", "\n", "forwards", "[", "0", ",", ":", "]", "=", "g", "*", "self", ".", "_init", "/", "c", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "            ", "g", "=", "torch", ".", "tensor", "(", "[", "torch", ".", "exp", "(", "self", ".", "loglike_emission", "(", "obs", "[", "i", "]", ",", "state", ")", ")", "\n", "for", "state", "in", "range", "(", "N", ")", "]", ")", "\n", "alpha", "=", "forwards", "[", "i", "-", "1", ",", ":", "]", "@", "Q", "*", "g", "\n", "c", "[", "i", "]", "=", "torch", ".", "sum", "(", "alpha", ")", "\n", "forwards", "[", "i", ",", ":", "]", "=", "alpha", "/", "c", "[", "i", "]", "\n", "", "self", ".", "_forward", "=", "forwards", "\n", "self", ".", "_const", "=", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad": [[287, 293], ["hmm.AutogradHmm._tran.grad.data.zero_", "hmm.AutogradHmm._emis.grad.data.zero_"], "methods", ["None"], ["", "def", "zero_grad", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set gradients of the model to zero.\"\"\"", "\n", "if", "self", ".", "_tran", ".", "grad", "is", "not", "None", ":", "\n", "            ", "self", ".", "_tran", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "", "if", "self", ".", "_emis", ".", "grad", "is", "not", "None", ":", "\n", "            ", "self", ".", "_emis", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.log_likelihood": [[294, 307], ["torch.sum", "hmm.AutogradHmm.filtering", "torch.log"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.filtering"], ["", "", "def", "log_likelihood", "(", "self", ",", "obs", ",", "filtered", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute log-likelihood.\n\n        Parameters\n        ----------\n        obs: torch.Tensor\n            Observations.\n        filtered: bool, optional\n            Indicates if the method ``filtering`` has been called for ``obs``.\n        \"\"\"", "\n", "if", "not", "filtered", ":", "\n", "            ", "self", ".", "filtering", "(", "obs", ")", "\n", "", "return", "torch", ".", "sum", "(", "torch", ".", "log", "(", "self", ".", "_const", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.information": [[308, 324], ["hmm.AutogradHmm._recursive_smoother", "torch.sum", "hmm.AutogradHmm.filtering", "torch.outer", "torch.sum", "torch.sum.detach", "info.detach"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._recursive_smoother", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.filtering"], ["", "def", "information", "(", "self", ",", "obs", ",", "filtered", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute score and information matrix.\n\n        Parameters\n        ----------\n        obs: torch.Tensor\n            Observations.\n        filtered: bool, optional\n            Indicates if the method ``filtering`` has been called for ``obs``.\n        \"\"\"", "\n", "if", "not", "filtered", ":", "\n", "            ", "self", ".", "filtering", "(", "obs", ")", "\n", "", "tau1", ",", "tau2", ",", "tau3", "=", "self", ".", "_recursive_smoother", "(", "obs", ")", "\n", "score", "=", "torch", ".", "sum", "(", "tau1", ",", "0", ")", "\n", "info", "=", "torch", ".", "outer", "(", "score", ",", "score", ")", "+", "torch", ".", "sum", "(", "tau2", "-", "tau3", ",", "0", ")", "\n", "return", "score", ".", "detach", "(", ")", ",", "info", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.compute_stats": [[325, 412], ["len", "utils._exceptions_handling", "torch.eye", "hmm.AutogradHmm.filtering", "hmm.AutogradHmm.information", "utils._compute_inv", "utils.compute_thresholds", "torch.zeros", "numpy.array", "zip", "utils._return_results", "hmm.AutogradHmm._par_length", "hmm.AutogradHmm._par_length", "len", "max", "numpy.arange", "torch.sum", "utils._compute_stats", "utils._update_res", "max", "hmm.AutogradHmm._recursive_smoother", "hmm.AutogradHmm._smoother_interval", "torch.outer", "torch.sum", "max", "min"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._exceptions_handling", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.filtering", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_inv", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.compute_thresholds", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._return_results", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._par_length", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._par_length", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._recursive_smoother", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._smoother_interval"], ["", "def", "compute_stats", "(", "self", ",", "obs", ",", "alpha", "=", "0.05", ",", "idx", "=", "None", ",", "prange", "=", "None", ",", "trange", "=", "None", ",", "stat_type", "=", "'autograd'", ")", ":", "\n", "        ", "\"\"\"Compute test statistics.\n\n        This function performs score-based hypothesis tests to detect the existence of a change in a hidden Markov model as it learns from\n        a continuous, possibly evolving, stream of data.\n        Three tests are implemented: the linear test, the scan test, and the autograd-test. The\n        linear statistic is the maximum score statistic over all possible locations of\n        change. The scan statistic is the maximum score statistic over all possible\n        locations of change, and over all possible subsets of parameters in which change occurs.\n\n        .. note::\n            This method will run the ``filtering`` method for ``obs``.\n\n        Parameters\n        ----------\n        obs: torch.Tensor\n            Observations (can be multi-dimensional).\n        alpha: double or list, optional\n            Significance level(s). For the autograd-test it should be a list of length two,\n            where the first element is the significance level for the linear statistic and\n            the second is for the scan statistic. Default is 0.05.\n        idx: array-like, optional\n            Indices of parameters of interest (the rest parameters are considered constants)\n            in the parameter vector.\n            Default is ``None``, which will be set to ``range(dim)``.\n        prange: array-like, optional\n            Change cardinality set over which the scan statistic is maximized.\n            Default is ``None``,\n            which will be set to ``range(1, min([int(np.sqrt(d)), len(idx)]) + 1)``.\n        trange: array-like, optional\n            Change location set over which the statistic is maximized. Default is ``None``,\n            which will be set to ``range(int(n / 10) + lag, int(n * 9 / 10))``.\n        stat_type: str, optional\n            Type of statistic that is computed. It can take values in ``['linear', 'scan',\n            'autograd', 'all']``, where ``'all'`` indicates calculating all of them. Default is ``'autograd'``.\n\n        Returns\n        -------\n        stat: torch.Tensor\n            Test statistic at level ``alpha``. Reject null if it is larger than 1.\n        tau: int\n            Location of changepoint corresponds to the test statistic.\n        index: array-like\n            Indices of parameters correspond to the test statistic. It will be omitted for the linear test.\n\n        Raises\n        ------\n        NameError\n            If ``stat_type`` is not in ``['linear', 'scan', 'autograd', 'all']``.\n        ValueError\n            If ``alpha`` is not an instance of ``float`` or ``list``; or if ``prange``\n            is not within ``range(1, len(idx)+1)``; or if ``trange`` is not within\n            ``range(lag, size)``.\n        \"\"\"", "\n", "\n", "n", "=", "len", "(", "obs", ")", "\n", "alpha", ",", "idx", ",", "prange", ",", "trange", "=", "_exceptions_handling", "(", "n", ",", "self", ".", "_par_length", "(", ")", ",", "\n", "alpha", ",", "0", ",", "idx", ",", "prange", ",", "\n", "trange", ",", "stat_type", ")", "\n", "# compute the inverse of information matrix once", "\n", "ident", "=", "torch", ".", "eye", "(", "self", ".", "_par_length", "(", ")", ")", "\n", "self", ".", "filtering", "(", "obs", ")", "\n", "score", ",", "info", "=", "self", ".", "information", "(", "obs", ",", "True", ")", "\n", "Iinv", "=", "_compute_inv", "(", "ident", ",", "info", ")", "\n", "# compute thresholds once", "\n", "thresh", "=", "compute_thresholds", "(", "len", "(", "idx", ")", ",", "\n", "max", "(", "[", "1", ",", "max", "(", "trange", ")", "-", "min", "(", "trange", ")", "]", ")", ",", "\n", "alpha", ",", "prange", ",", "stat_type", ")", "\n", "# compute test statistic", "\n", "stat", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "tau", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "index", "=", "[", "idx", ",", "np", ".", "arange", "(", "max", "(", "prange", ")", ")", ",", "idx", "]", "\n", "for", "lo", ",", "hi", "in", "zip", "(", "[", "0", ",", "*", "trange", "[", ":", "-", "1", "]", "]", ",", "trange", ")", ":", "\n", "            ", "if", "lo", "==", "0", ":", "\n", "                ", "tau1", ",", "tau2", ",", "tau3", "=", "self", ".", "_recursive_smoother", "(", "obs", "[", ":", "hi", "]", ")", "\n", "", "else", ":", "\n", "                ", "tau1", ",", "tau2", ",", "tau3", "=", "self", ".", "_smoother_interval", "(", "obs", "[", "lo", ":", "hi", "]", ",", "lo", ",", "hi", ",", "\n", "tau1", ",", "tau2", ",", "tau3", ")", "\n", "", "temp", "=", "torch", ".", "sum", "(", "tau1", ",", "0", ")", "\n", "cond_score", "=", "score", "-", "temp", "# conditional score", "\n", "temp", "=", "torch", ".", "outer", "(", "temp", ",", "temp", ")", "+", "torch", ".", "sum", "(", "tau2", "-", "tau3", ",", "0", ")", "\n", "cond_info", "=", "info", "-", "temp", "# conditional information", "\n", "new_stat", ",", "new_index", "=", "_compute_stats", "(", "prange", ",", "idx", ",", "cond_score", ",", "\n", "cond_info", ",", "Iinv", ",", "thresh", ",", "\n", "stat_type", ")", "\n", "stat", ",", "index", ",", "tau", "=", "_update_res", "(", "new_stat", ",", "stat", ",", "new_index", ",", "index", ",", "hi", ",", "tau", ")", "\n", "", "return", "_return_results", "(", "stat", ",", "index", ",", "tau", ",", "stat_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._par_length": [[413, 421], ["len", "len"], "methods", ["None"], ["", "def", "_par_length", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get length of parameter vector.\"\"\"", "\n", "lpar", "=", "0", "\n", "if", "self", ".", "_emis", ".", "requires_grad", ":", "\n", "            ", "lpar", "+=", "len", "(", "self", ".", "_emis", ")", "\n", "", "if", "self", ".", "_tran", ".", "requires_grad", ":", "\n", "            ", "lpar", "+=", "len", "(", "self", ".", "_tran", ")", "\n", "", "return", "lpar", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._emission_dist": [[422, 431], ["len", "torch.zeros", "range", "torch.zeros.detach", "range", "torch.exp", "hmm.AutogradHmm.loglike_emission"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.loglike_emission"], ["", "def", "_emission_dist", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"Compute emission distribution of observations conditioning on each state.\"\"\"", "\n", "n", "=", "len", "(", "obs", ")", "\n", "n_states", "=", "self", ".", "_n_states", "\n", "g", "=", "torch", ".", "zeros", "(", "(", "n", ",", "n_states", ")", ")", "\n", "for", "k", "in", "range", "(", "n", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "n_states", ")", ":", "\n", "                ", "g", "[", "k", ",", "i", "]", "=", "torch", ".", "exp", "(", "self", ".", "loglike_emission", "(", "obs", "[", "k", "]", ",", "i", ")", ")", "\n", "", "", "return", "g", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._init_smoother": [[432, 447], ["hmm.AutogradHmm._par_length", "torch.zeros", "torch.zeros", "torch.zeros", "range", "hmm.AutogradHmm.information_emission", "torch.outer"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._par_length", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.information_emission"], ["", "def", "_init_smoother", "(", "self", ",", "obs", ",", "phi", ")", ":", "\n", "        ", "\"\"\"Compute initial smoother.\n        \"\"\"", "\n", "\n", "n_states", "=", "self", ".", "_n_states", "\n", "lpar", "=", "self", ".", "_par_length", "(", ")", "\n", "tau1", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "lpar", ")", ")", "\n", "tau2", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "lpar", ",", "lpar", ")", ")", "\n", "tau3", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "lpar", ",", "lpar", ")", ")", "\n", "for", "j", "in", "range", "(", "n_states", ")", ":", "\n", "            ", "tau1", "[", "j", "]", ",", "tau2", "[", "j", "]", "=", "self", ".", "information_emission", "(", "obs", ",", "j", ")", "\n", "tau3", "[", "j", "]", "=", "torch", ".", "outer", "(", "tau1", "[", "j", "]", ",", "tau1", "[", "j", "]", ")", "*", "phi", "[", "j", "]", "\n", "tau1", "[", "j", "]", "=", "tau1", "[", "j", "]", "*", "phi", "[", "j", "]", "\n", "tau2", "[", "j", "]", "=", "tau2", "[", "j", "]", "*", "phi", "[", "j", "]", "\n", "", "return", "tau1", ",", "tau2", ",", "tau3", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._next_smoother": [[448, 496], ["hmm.AutogradHmm._par_length", "hmm.AutogradHmm._emission_dist().view().detach", "hmm.AutogradHmm.get_transition().detach", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "range", "range", "range", "hmm.AutogradHmm._emission_dist().view", "hmm.AutogradHmm.get_transition", "torch.outer", "torch.outer", "hmm.AutogradHmm.information_emission", "torch.sum", "torch.sum", "hmm.AutogradHmm._emission_dist", "obs.view", "torch.outer.transpose"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._par_length", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.get_transition", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.information_emission", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._emission_dist"], ["", "def", "_next_smoother", "(", "self", ",", "obs", ",", "k", ",", "tau1", ",", "tau2", ",", "tau3", ")", ":", "\n", "        ", "\"\"\"Compute next smoother.\n\n        Parameters\n        ----------\n        obs: Next observation.\n        k: Index of next observation.\n        tau1, tau2, tau3: current smoother.\n        \"\"\"", "\n", "\n", "n_states", "=", "self", ".", "_n_states", "\n", "lpar", "=", "self", ".", "_par_length", "(", ")", "\n", "g", "=", "self", ".", "_emission_dist", "(", "obs", ".", "view", "(", "1", ",", "-", "1", ")", ")", ".", "view", "(", "-", "1", ")", ".", "detach", "(", ")", "\n", "phi", "=", "self", ".", "_forward", "[", "k", "-", "1", "]", "\n", "c", "=", "self", ".", "_const", "[", "k", "]", "\n", "q", "=", "self", ".", "get_transition", "(", ")", ".", "detach", "(", ")", "\n", "# for score", "\n", "s1", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "n_states", ",", "lpar", ")", ")", "\n", "new1", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "lpar", ")", ")", "\n", "# for information", "\n", "s2", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "n_states", ",", "lpar", ",", "lpar", ")", ")", "\n", "new2", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "lpar", ",", "lpar", ")", ")", "\n", "new3", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "lpar", ",", "lpar", ")", ")", "\n", "# computes addtive parts of the smoothing functional", "\n", "for", "i", "in", "range", "(", "n_states", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "n_states", ")", ":", "\n", "                ", "if", "i", "==", "0", ":", "\n", "                    ", "s1", "[", ":", ",", "j", "]", ",", "s2", "[", ":", ",", "j", "]", "=", "self", ".", "information_emission", "(", "obs", ",", "j", ")", "\n", "", "if", "j", "<", "n_states", "-", "1", ":", "\n", "                    ", "ind", "=", "i", "*", "(", "n_states", "-", "1", ")", "+", "j", "\n", "s1", "[", "i", ",", "j", ",", "ind", "]", "=", "1", "/", "q", "[", "i", ",", "j", "]", "\n", "s2", "[", "i", ",", "j", ",", "ind", ",", "ind", "]", "=", "1", "/", "q", "[", "i", ",", "j", "]", "**", "2", "\n", "", "else", ":", "\n", "                    ", "low", "=", "i", "*", "(", "n_states", "-", "1", ")", "\n", "high", "=", "(", "i", "+", "1", ")", "*", "(", "n_states", "-", "1", ")", "\n", "s1", "[", "i", ",", "j", ",", "low", ":", "high", "]", "=", "-", "1", "/", "q", "[", "i", ",", "j", "]", "\n", "s2", "[", "i", ",", "j", ",", "low", ":", "high", ",", "low", ":", "high", "]", "=", "1", "/", "q", "[", "i", ",", "j", "]", "**", "2", "\n", "\n", "", "", "", "for", "j", "in", "range", "(", "n_states", ")", ":", "\n", "            ", "new1", "[", "j", "]", "=", "(", "q", "[", ":", ",", "j", "]", "@", "tau1", "+", "(", "phi", "*", "q", "[", ":", ",", "j", "]", ")", "@", "s1", "[", ":", ",", "j", "]", ")", "*", "g", "[", "j", "]", "/", "c", "\n", "new2", "[", "j", "]", "=", "torch", ".", "sum", "(", "q", "[", ":", ",", "j", "]", "[", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", "*", "tau2", ",", "0", ")", "*", "g", "[", "j", "]", "/", "c", "\n", "new2", "[", "j", "]", "+=", "torch", ".", "sum", "(", "(", "phi", "*", "q", "[", ":", ",", "j", "]", ")", "[", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", "*", "s2", "[", ":", ",", "j", "]", ",", "0", ")", "*", "g", "[", "j", "]", "/", "c", "\n", "for", "i", "in", "range", "(", "n_states", ")", ":", "\n", "                ", "sxtau", "=", "torch", ".", "outer", "(", "s1", "[", "i", ",", "j", ",", ":", "]", ",", "tau1", "[", "i", "]", ")", "\n", "s1xs1", "=", "torch", ".", "outer", "(", "s1", "[", "i", ",", "j", ",", ":", "]", ",", "s1", "[", "i", ",", "j", ",", ":", "]", ")", "\n", "new3", "[", "j", "]", "+=", "(", "tau3", "[", "i", "]", "+", "sxtau", ".", "transpose", "(", "0", ",", "1", ")", "+", "sxtau", "+", "phi", "[", "i", "]", "*", "s1xs1", ")", "*", "q", "[", "i", ",", "j", "]", "*", "g", "[", "j", "]", "\n", "", "new3", "[", "j", "]", "/=", "c", "\n", "", "return", "new1", ",", "new2", ",", "new3", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._smoother_interval": [[497, 503], ["enumerate", "range", "hmm.AutogradHmm._next_smoother"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._next_smoother"], ["", "def", "_smoother_interval", "(", "self", ",", "obs", ",", "lo", ",", "hi", ",", "tau1", ",", "tau2", ",", "tau3", ")", ":", "\n", "        ", "\"\"\"Compute smoother within an interval.\"\"\"", "\n", "new1", ",", "new2", ",", "new3", "=", "tau1", ",", "tau2", ",", "tau3", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "range", "(", "lo", ",", "hi", ")", ")", ":", "\n", "            ", "new1", ",", "new2", ",", "new3", "=", "self", ".", "_next_smoother", "(", "obs", "[", "i", "]", ",", "t", ",", "new1", ",", "new2", ",", "new3", ")", "\n", "", "return", "new1", ",", "new2", ",", "new3", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._recursive_smoother": [[504, 523], ["len", "hmm.AutogradHmm._par_length", "torch.zeros", "torch.zeros", "torch.zeros", "hmm.AutogradHmm._init_smoother", "range", "hmm.AutogradHmm._next_smoother"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._par_length", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._init_smoother", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm._next_smoother"], ["", "def", "_recursive_smoother", "(", "self", ",", "obs", ")", ":", "\n", "        ", "\"\"\"Compute recursive smoother associated with score and information.\n\n        Run the method ``filtering`` first.\n        \"\"\"", "\n", "n", "=", "len", "(", "obs", ")", "\n", "n_states", "=", "self", ".", "_n_states", "\n", "lpar", "=", "self", ".", "_par_length", "(", ")", "\n", "phi", "=", "self", ".", "_forward", "[", "0", "]", "\n", "# for score", "\n", "tau1", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "lpar", ")", ")", "\n", "# for information", "\n", "tau2", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "lpar", ",", "lpar", ")", ")", "\n", "tau3", "=", "torch", ".", "zeros", "(", "(", "n_states", ",", "lpar", ",", "lpar", ")", ")", "\n", "# initialization", "\n", "tau1", ",", "tau2", ",", "tau3", "=", "self", ".", "_init_smoother", "(", "obs", "[", "0", "]", ",", "phi", ")", "\n", "for", "k", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "            ", "tau1", ",", "tau2", ",", "tau3", "=", "self", ".", "_next_smoother", "(", "obs", "[", "k", "]", ",", "k", ",", "tau1", ",", "tau2", ",", "tau3", ")", "\n", "", "return", "tau1", ",", "tau2", ",", "tau3", "\n", "", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm._prob_mat_pars": [[21, 30], ["torch.tensor().float", "torch.tensor().float.view", "torch.tensor"], "function", ["None"], ["def", "_prob_mat_pars", "(", "mat", ")", ":", "\n", "    ", "\"\"\"Convert probability matrix to tensor of effective parameters.\n\n    The effective parameters are the elements of the :math:`n \\\\times (n - 1)`\n    submatrix, where constraints on the probability matrix are removed.\n    The conversion to a 1D tensor is done by row.\n    \"\"\"", "\n", "Q", "=", "torch", ".", "tensor", "(", "mat", "[", ":", ",", ":", "-", "1", "]", ")", ".", "float", "(", ")", "\n", "return", "Q", ".", "view", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm._construct_prob_mat": [[32, 52], ["pars.view", "torch.zeros", "torch.sum", "int", "len"], "function", ["None"], ["", "def", "_construct_prob_mat", "(", "pars", ",", "dim", "=", "None", ")", ":", "\n", "    ", "\"\"\"Construct probability matrix based on effective parameters.\n\n    The effective parameters should be attained by reshaping the ``dim`` by\n    ``dim - 1`` submatrix as a 1D vector by row.\n\n    Parameters\n    ----------\n    pars: torch.Tensor, 1D\n        Effective parameters.\n    dim: int, optional\n        Dimension of the probability matrix. Default is None.\n    \"\"\"", "\n", "if", "dim", "is", "None", ":", "\n", "        ", "dim", "=", "int", "(", "len", "(", "pars", ")", "**", "0.5", ")", "+", "1", "\n", "", "subQ", "=", "pars", ".", "view", "(", "dim", ",", "-", "1", ")", "\n", "Q", "=", "torch", ".", "zeros", "(", "(", "dim", ",", "dim", ")", ")", "\n", "Q", "[", ":", ",", ":", "-", "1", "]", "=", "subQ", "\n", "Q", "[", ":", ",", "-", "1", "]", "=", "1", "-", "torch", ".", "sum", "(", "subQ", ",", "1", ")", "\n", "return", "Q", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic._score_information": [[21, 34], ["torch.zeros", "torch.zeros", "len", "loglike", "torch.outer", "torch.zeros.detach", "torch.zeros.detach", "len", "len", "ob.view", "torch.autograd.grad"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.loglike"], ["def", "_score_information", "(", "theta", ",", "obs", ",", "loglike", ")", ":", "\n", "    ", "\"\"\"Compute score function and information matrix.\n\n    The information matrix here is computed by the outer product of the score function.\n    \"\"\"", "\n", "score", "=", "torch", ".", "zeros", "(", "len", "(", "theta", ")", ")", "\n", "info", "=", "torch", ".", "zeros", "(", "(", "len", "(", "theta", ")", ",", "len", "(", "theta", ")", ")", ")", "\n", "for", "ob", "in", "obs", ":", "\n", "        ", "like", "=", "loglike", "(", "theta", ",", "ob", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "temp", "=", "grad", "(", "like", ",", "theta", ")", "[", "0", "]", "\n", "score", "+=", "temp", "\n", "info", "+=", "torch", ".", "outer", "(", "temp", ",", "temp", ")", "\n", "", "return", "score", ".", "detach", "(", ")", ",", "info", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.score_function": [[36, 51], ["loglike", "score.detach", "torch.autograd.grad"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.loglike"], ["", "def", "score_function", "(", "theta", ",", "obs", ",", "loglike", ")", ":", "\n", "    ", "\"\"\"Compute score function.\n\n    Parameters\n    ----------\n    theta: torch.Tensor, shape (dim,)\n        Values of parameters at which score and information are computed.\n    obs: torch.Tensor, shape (size, dim)\n        Observations.\n    loglike: function\n        ``loglike(theta, obs)`` is the log-likelihood of ``theta`` given ``obs``.\n    \"\"\"", "\n", "like", "=", "loglike", "(", "theta", ",", "obs", ")", "\n", "score", "=", "grad", "(", "like", ",", "theta", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "return", "score", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information": [[53, 79], ["len", "loglike", "torch.zeros", "range", "torch.autograd.grad", "torch.eye", "score.backward", "theta.grad.data.zero_", "score.detach", "torch.zeros.detach"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.loglike"], ["", "def", "information", "(", "theta", ",", "obs", ",", "loglike", ",", "ident", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute score function and information matrix.\n\n    Parameters\n    ----------\n    theta: torch.Tensor, shape (dim,)\n        Values of parameters at which score and information are computed.\n    obs: torch.Tensor, shape (size, dim)\n        Observations.\n    loglike: function\n        ``loglike(theta, obs)`` is the log-likelihood of ``theta`` given ``obs``.\n    ident: torch.Tensor, shape (dim, dim), optional\n        Identity matrix. Default is ``None``.\n    \"\"\"", "\n", "\n", "d", "=", "len", "(", "theta", ")", "\n", "like", "=", "loglike", "(", "theta", ",", "obs", ")", "\n", "score", "=", "grad", "(", "like", ",", "theta", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "\n", "info", "=", "torch", ".", "zeros", "(", "(", "d", ",", "d", ")", ")", "\n", "if", "ident", "is", "None", ":", "ident", "=", "torch", ".", "eye", "(", "d", ")", "\n", "for", "i", "in", "range", "(", "d", ")", ":", "\n", "        ", "score", ".", "backward", "(", "ident", "[", "i", ",", ":", "]", ",", "retain_graph", "=", "True", ")", "\n", "info", "[", "i", ",", ":", "]", "=", "-", "theta", ".", "grad", "\n", "theta", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "", "return", "score", ".", "detach", "(", ")", ",", "info", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.autograd_test": [[81, 182], ["theta.requires_grad_", "utils._exceptions_handling", "torch.eye", "basic.information", "utils._compute_inv", "utils.compute_thresholds", "torch.zeros", "numpy.array", "utils._return_results", "len", "len", "len", "len", "max", "numpy.arange", "zip", "max", "basic.information", "utils._compute_stats", "utils._update_res", "basic.information", "utils._compute_stats", "utils._update_res", "max", "min"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._exceptions_handling", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_inv", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.compute_thresholds", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._return_results", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res"], ["", "def", "autograd_test", "(", "theta", ",", "obs", ",", "loglike", ",", "alpha", "=", "0.05", ",", "lag", "=", "0", ",", "idx", "=", "None", ",", "prange", "=", "None", ",", "\n", "trange", "=", "None", ",", "stat_type", "=", "'autograd'", ")", ":", "\n", "    ", "\"\"\"Compute autograd-test statistics.\n\n    This function performs score-based hypothesis tests to detect the existence of\n    a change in machine learning systems as they learn from\n    a continuous, possibly evolving, stream of data.\n    Three tests are implemented: the linear test, the scan test, and the autograd-test. The\n    linear statistic is the maximum score statistic over all possible locations of\n    change. The scan statistic is the maximum score statistic over all possible\n    locations of change, and over all possible subsets of parameters in which change occurs.\n\n    .. note::\n        The log-likelihood function ``loglike`` needs to be implemented in\n        :class:`PyTorch`.\n\n    Parameters\n    ----------\n    theta: torch.Tensor, shape (dim,)\n        Maximum likelihood estimator of model parameters under null hypothesis\n        (no change exists).\n    obs: torch.Tensor, shape (size, dim)\n        Observations.\n    loglike: function\n        ``loglike(theta, obs)`` is the log-likelihood of ``theta`` given ``obs``.\n    alpha: double or list, optional\n        Significance level(s). For the autograd-test it should be a list of length two,\n        where the first element is the significance level for the linear statistic and\n        the second is for the scan statistic. Default is 0.05.\n    lag: int, optional\n        Order of Markovian dependency. The distribution of ``obs[k]`` only\n        depends on ``obs[(k-lag):k]``. Use ``None`` to represent\n        non-Markovian dependency. Default is 0.\n    idx: array-like, optional\n        Indices of parameters of interest (the rest parameters are considered constants)\n        in the parameter vector.\n        Default is ``None``, which will be set to ``range(dim)``.\n    prange: array-like, optional\n        Change cardinality set over which the scan statistic is maximized.\n        Default is ``None``,\n        which will be set to ``range(1, min([int(np.sqrt(d)), len(idx)]) + 1)``.\n    trange: array-like, optional\n        Change location set over which the statistic is maximized. Default is ``None``,\n        which will be set to ``range(int(n / 10) + lag, int(n * 9 / 10))``.\n    stat_type: str, optional\n        Type of statistic that is computed. It can take values in ``['linear', 'scan',\n        'autograd', 'all']``, where ``'all'`` indicates calculating all of them. Default is ``'autograd'``.\n\n    Returns\n    -------\n    stat: torch.Tensor\n        Test statistic at level ``alpha``. Reject null if it is larger than 1.\n    tau: int\n        Location of changepoint corresponds to the test statistic.\n    index: array-like\n        Indices of parameters correspond to the test statistic. It will be omitted for the linear test.\n\n    Raises\n    ------\n    NameError\n        If ``stat_type`` is not in ``['linear', 'scan', 'autograd', 'all']``.\n    ValueError\n        If ``alpha`` is not an instance of ``float`` or ``list``; or if ``prange``\n        is not within ``range(1, len(idx)+1)``; or if ``trange`` is not within\n        ``range(lag, size)``.\n    \"\"\"", "\n", "# creates results for [linear, scan, autograd],", "\n", "# then returns the one(s) based on ``stat_type``.", "\n", "theta", ".", "requires_grad_", "(", "True", ")", "\n", "alpha", ",", "idx", ",", "prange", ",", "trange", "=", "_exceptions_handling", "(", "len", "(", "obs", ")", ",", "len", "(", "theta", ")", ",", "alpha", ",", "\n", "lag", ",", "idx", ",", "prange", ",", "trange", ",", "\n", "stat_type", ")", "\n", "# computes the inverse of information matrix once", "\n", "ident", "=", "torch", ".", "eye", "(", "len", "(", "theta", ")", ")", "\n", "score", ",", "info", "=", "information", "(", "theta", ",", "obs", ",", "loglike", ",", "ident", ")", "\n", "Iinv", "=", "_compute_inv", "(", "ident", ",", "info", ")", "\n", "# computes thresholds once", "\n", "thresh", "=", "compute_thresholds", "(", "len", "(", "idx", ")", ",", "max", "(", "[", "1", ",", "max", "(", "trange", ")", "-", "min", "(", "trange", ")", "]", ")", ",", "\n", "alpha", ",", "prange", ",", "stat_type", ")", "\n", "# computes test statistic", "\n", "stat", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "tau", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "index", "=", "[", "idx", ",", "np", ".", "arange", "(", "max", "(", "prange", ")", ")", ",", "idx", "]", "\n", "if", "lag", "is", "not", "None", ":", "\n", "        ", "for", "lo", ",", "hi", "in", "zip", "(", "[", "lag", ",", "*", "trange", "[", ":", "-", "1", "]", "]", ",", "trange", ")", ":", "\n", "# computes conditional score and information", "\n", "            ", "score_t", ",", "info_t", "=", "information", "(", "theta", ",", "obs", "[", "(", "lo", "-", "lag", ")", ":", "hi", "]", ",", "loglike", ",", "ident", ")", "\n", "score", "-=", "score_t", "\n", "info", "-=", "info_t", "\n", "new_stat", ",", "new_index", "=", "_compute_stats", "(", "prange", ",", "idx", ",", "score", ",", "info", ",", "Iinv", ",", "\n", "thresh", ",", "stat_type", ")", "\n", "stat", ",", "index", ",", "tau", "=", "_update_res", "(", "new_stat", ",", "stat", ",", "new_index", ",", "index", ",", "hi", ",", "tau", ")", "\n", "", "", "else", ":", "# non-Markovian dependency", "\n", "        ", "for", "t", "in", "trange", ":", "\n", "            ", "score_t", ",", "info_t", "=", "information", "(", "theta", ",", "obs", "[", ":", "t", "]", ",", "loglike", ",", "ident", ")", "\n", "score_t", "=", "score", "-", "score_t", "\n", "info_t", "=", "info", "-", "info_t", "\n", "new_stat", ",", "new_index", "=", "_compute_stats", "(", "prange", ",", "idx", ",", "score", ",", "info", ",", "Iinv", ",", "\n", "thresh", ",", "stat_type", ")", "\n", "stat", ",", "index", ",", "tau", "=", "_update_res", "(", "new_stat", ",", "stat", ",", "new_index", ",", "index", ",", "t", ",", "tau", ")", "\n", "", "", "return", "_return_results", "(", "stat", ",", "index", ",", "tau", ",", "stat_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic._arma_einformation": [[184, 220], ["len", "torch.zeros", "torch.zeros", "range", "torch.eye", "max", "len", "torch.arange().long", "torch.arange().long", "error.detach", "[].detach", "range", "torch.zeros.detach", "torch.zeros.detach", "len", "len", "torch.sum", "torch.sum", "torch.sum", "torch.arange", "torch.arange", "torch.sum", "torch.autograd.grad", "theta[].detach", "theta[].detach"], "function", ["None"], ["", "def", "_arma_einformation", "(", "theta", ",", "obs", ",", "p", ",", "q", ",", "ident", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute score function and information matrix for error term.\n\n    The observations must be one-dimensional.\n\n    Parameters\n    ----------\n    theta: torch.Tensor, shape (dim,)\n        Values of parameters at which score and information are computed.\n    obs: torch.Tensor, shape (size, 2)\n        The first column is observations and the second one is errors.\n    p, q: int\n        Order of ARMA model.\n    ident: torch.Tensor, shape (dim, dim), optional\n        Identity matrix. Default is ``None``.\n    \"\"\"", "\n", "\n", "x", ",", "e", "=", "obs", "[", ":", ",", "0", "]", ",", "obs", "[", ":", ",", "1", "]", "\n", "d", "=", "len", "(", "theta", ")", "\n", "if", "ident", "is", "None", ":", "ident", "=", "torch", ".", "eye", "(", "d", ")", "\n", "score", "=", "torch", ".", "zeros", "(", "(", "len", "(", "x", ")", ",", "d", ")", ")", "\n", "info", "=", "torch", ".", "zeros", "(", "(", "len", "(", "x", ")", ",", "d", ",", "d", ")", ")", "\n", "for", "t", "in", "range", "(", "max", "(", "p", ",", "q", ")", ",", "len", "(", "x", ")", ")", ":", "\n", "# computes errors", "\n", "        ", "inv_idx", "=", "torch", ".", "arange", "(", "t", "-", "1", ",", "t", "-", "p", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "inv_ide", "=", "torch", ".", "arange", "(", "t", "-", "1", ",", "t", "-", "q", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "error", "=", "x", "[", "t", "]", "-", "torch", ".", "sum", "(", "theta", "[", ":", "p", "]", "*", "x", "[", "inv_idx", "]", ")", "-", "torch", ".", "sum", "(", "theta", "[", "p", ":", "(", "p", "+", "q", ")", "]", "*", "e", "[", "inv_ide", "]", ")", "\n", "e", "[", "t", "]", "=", "error", ".", "detach", "(", ")", "\n", "# computes score", "\n", "score_t", "=", "grad", "(", "error", ",", "theta", ")", "[", "0", "]", ".", "detach", "(", ")", "\n", "score", "[", "t", "]", "=", "score_t", "-", "torch", ".", "sum", "(", "theta", "[", "p", ":", "(", "p", "+", "q", ")", ",", "np", ".", "newaxis", "]", ".", "detach", "(", ")", "*", "score", "[", "inv_ide", "]", ",", "0", ")", "\n", "# computes information", "\n", "info", "[", "t", "]", "=", "-", "torch", ".", "sum", "(", "theta", "[", "p", ":", "(", "p", "+", "q", ")", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", ".", "detach", "(", ")", "*", "info", "[", "inv_ide", "]", ",", "0", ")", "\n", "for", "i", "in", "range", "(", "q", ")", ":", "\n", "            ", "info", "[", "t", ",", ":", ",", "i", "+", "p", "]", "+=", "score", "[", "t", "-", "i", "-", "1", "]", "\n", "", "", "return", "score", ".", "detach", "(", ")", ",", "info", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.arma_information": [[222, 229], ["torch.sum", "torch.sum", "escore.transpose"], "function", ["None"], ["", "def", "arma_information", "(", "error", ",", "escore", ",", "einfo", ",", "sig2", ")", ":", "\n", "    ", "\"\"\"Compute the score and information for ARMA based on the ones of errors.\n    \"\"\"", "\n", "score", "=", "-", "(", "torch", ".", "sum", "(", "error", "[", ":", ",", "np", ".", "newaxis", "]", "*", "escore", ",", "0", ")", ")", "/", "sig2", "\n", "info", "=", "(", "escore", ".", "transpose", "(", "0", ",", "1", ")", "@", "escore", "-", "\n", "torch", ".", "sum", "(", "error", "[", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", "*", "einfo", ",", "0", ")", ")", "/", "sig2", "\n", "return", "score", ",", "info", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.autograd_arma": [[231, 320], ["theta.requires_grad_", "utils._exceptions_handling", "torch.eye", "basic._arma_einformation", "basic.arma_information", "utils._compute_inv", "utils.compute_thresholds", "torch.zeros", "numpy.array", "utils._return_results", "ValueError", "len", "len", "max", "len", "len", "max", "numpy.arange", "basic.arma_information", "utils._compute_stats", "utils._update_res", "max", "max", "min"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._exceptions_handling", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic._arma_einformation", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.arma_information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_inv", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.compute_thresholds", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._return_results", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.basic.arma_information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_stats", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res"], ["", "def", "autograd_arma", "(", "theta", ",", "sig2", ",", "obs", ",", "p", ",", "q", ",", "alpha", "=", "0.05", ",", "idx", "=", "None", ",", "prange", "=", "None", ",", "trange", "=", "None", ",", "\n", "stat_type", "=", "'autograd'", ")", ":", "\n", "    ", "\"\"\"Compute autograd-test statistics for autoregressive--moving-average model.\n\n    This function performs score-based hypothesis tests to detect the existence of\n    a change in an autoregressive--moving-average model as\n    it learns from a continuous, possibly evolving, stream of data.\n    Three tests are implemented: the linear test, the scan test, and the autograd-test. The\n    linear statistic is the maximum score statistic over all possible locations of\n    change. The scan statistic is the maximum score statistic over all possible\n    locations of change, and over all possible subsets of parameters in which change\n    occurs.\n\n    Parameters\n    ----------\n    theta: torch.Tensor, shape (dim,)\n        Conditional maximum likelihood estimator of model parameters under null\n        hypothesis (condition on the first ``max(p, q)`` observations).\n    sig2: torch.Tensor\n        Variance of the residuals.\n    obs: torch.Tensor, shape (size, 2)\n        The first column is observations and the second one is errors.\n    p, q: int\n        Order of ARMA model.\n    alpha: double or list, optional\n        Significance level(s). For the autograd-test it should be a list of length two,\n        where the first element is the significance level for the linear statistic and\n        the second is for the scan statistic. Default is 0.05.\n    idx: array-like, optional\n        Indices of parameters of interest (the rest parameters are considered constants)\n        in the parameter vector.\n        Default is ``None``, which will be set to ``range(dim)``.\n    prange: array-like, optional\n        Change cardinality set over which the scan statistic is maximized.\n        Default is ``None``,\n        which will be set to ``range(1, min([int(np.sqrt(d)), len(idx)]) + 1)``.\n    trange: array-like, optional\n        Change location set over which the statistic is maximized. Default is ``None``,\n        which will be set to ``range(int(n / 10) + lag, int(n * 9 / 10))``.\n    stat_type: str, optional\n        Type of statistic that is computed. It can take values in ``['linear', 'scan',\n        'autograd', 'all']``, where ``'all'`` indicates calculating all of them. Default is ``'autograd'``.\n\n    Returns\n    -------\n    stat: torch.Tensor\n        Test statistic at level ``alpha``. Reject null if it is larger than 1.\n    tau: int\n        Location of changepoint corresponds to the test statistic.\n    index: array-like\n        Indices of parameters correspond to the test statistic. It will be omitted for the linear test.\n\n    Raises\n    ------\n    NameError\n        If ``stat_type`` is not in ``['linear', 'scan', 'autograd', 'all']``.\n    ValueError\n        If ``alpha`` is not an instance of ``float`` or ``list``; or if ``prange``\n        is not within ``range(1, len(idx)+1)``; or if ``trange`` is not within\n        ``range(lag, size)``.\n    \"\"\"", "\n", "\n", "theta", ".", "requires_grad_", "(", "True", ")", "\n", "if", "obs", ".", "shape", "[", "1", "]", "!=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "'Only one-dimensional time series is supported.'", ")", "\n", "", "alpha", ",", "idx", ",", "prange", ",", "trange", "=", "_exceptions_handling", "(", "len", "(", "obs", ")", ",", "len", "(", "theta", ")", ",", "alpha", ",", "\n", "max", "(", "p", ",", "q", ")", ",", "idx", ",", "prange", ",", "\n", "trange", ",", "stat_type", ")", "\n", "# computes the inverse of information matrix once", "\n", "ident", "=", "torch", ".", "eye", "(", "len", "(", "theta", ")", ")", "\n", "escore", ",", "einfo", "=", "_arma_einformation", "(", "theta", ",", "obs", ",", "p", ",", "q", ",", "ident", ")", "\n", "score", ",", "info", "=", "arma_information", "(", "obs", "[", ":", ",", "1", "]", ",", "escore", ",", "einfo", ",", "sig2", ")", "\n", "Iinv", "=", "_compute_inv", "(", "ident", ",", "info", ")", "\n", "# computes thresholds once", "\n", "thresh", "=", "compute_thresholds", "(", "len", "(", "idx", ")", ",", "max", "(", "[", "1", ",", "max", "(", "trange", ")", "-", "min", "(", "trange", ")", "]", ")", ",", "\n", "alpha", ",", "prange", ",", "stat_type", ")", "\n", "# computes test statistic", "\n", "stat", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "tau", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "index", "=", "[", "idx", ",", "np", ".", "arange", "(", "max", "(", "prange", ")", ")", ",", "idx", "]", "\n", "for", "t", "in", "trange", ":", "\n", "# computes conditional score and information", "\n", "        ", "score_t", ",", "info_t", "=", "arma_information", "(", "obs", "[", ":", "t", ",", "1", "]", ",", "escore", "[", ":", "t", "]", ",", "einfo", "[", ":", "t", "]", ",", "sig2", ")", "\n", "score_t", "=", "score", "-", "score_t", "\n", "info_t", "=", "info", "-", "info_t", "\n", "new_stat", ",", "new_index", "=", "_compute_stats", "(", "prange", ",", "idx", ",", "score_t", ",", "info_t", ",", "Iinv", ",", "\n", "thresh", ",", "stat_type", ")", "\n", "stat", ",", "index", ",", "tau", "=", "_update_res", "(", "new_stat", ",", "stat", ",", "new_index", ",", "index", ",", "t", ",", "tau", ")", "\n", "", "return", "_return_results", "(", "stat", ",", "index", ",", "tau", ",", "stat_type", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.loglike": [[22, 26], ["torch.MSELoss", "nn.MSELoss."], "function", ["None"], ["##########################################################################", "\n", "# functions for generating parameters", "\n", "##########################################################################", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.loglike_linear": [[28, 34], ["torch.cat", "torch.cat", "utils.loglike", "torch.ones", "torch.ones", "len"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.loglike"], ["    "]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.loglike_hmm": [[36, 70], ["torch.cat", "torch.cat", "len", "torch.zeros", "torch.zeros", "torch.exp", "torch.exp", "torch.sum", "torch.sum", "torch.log", "torch.log", "enumerate", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.rand", "torch.rand", "len", "utils.loglike_hmm.loglike_emission"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.loglike_emission"], ["\n", "\n", "alpha", "=", "alpha", "or", "np", ".", "ones", "(", "m", ")", "\n", "prob_mat", "=", "np", ".", "zeros", "(", "(", "n", ",", "m", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "temp", "=", "np", ".", "ones", "(", "m", ")", "/", "2", "/", "m", "\n", "temp", "+=", "npr", ".", "dirichlet", "(", "alpha", ")", "/", "2", "\n", "temp_max", "=", "np", ".", "max", "(", "temp", ")", "\n", "temp_ind", "=", "np", ".", "argmax", "(", "temp", ")", "\n", "prob_mat", "[", "i", "]", "=", "temp", "\n", "prob_mat", "[", "i", ",", "i", "]", "=", "temp_max", "\n", "prob_mat", "[", "i", ",", "temp_ind", "]", "=", "temp", "[", "i", "]", "\n", "", "return", "prob_mat", "\n", "\n", "\n", "", "def", "change_for_prob_vec", "(", "vec", ",", "p", ")", ":", "\n", "    ", "\"\"\"Generate change for probability vector.\n\n    The number of positive changes is equal to the one of negative changes, or\n    their difference is one.\n\n    Parameters\n    ----------\n    vec: array-like, shape (d)\n        Probability vector in which the change is generated.\n    p: int\n        Number of changed components. Must be positive.\n    \"\"\"", "\n", "\n", "delta", "=", "np", ".", "zeros", "(", "len", "(", "vec", ")", ")", "\n", "order", "=", "np", ".", "argsort", "(", "vec", "[", ":", "-", "1", "]", ")", "# the last element is not considered as parameter.", "\n", "pos_num", "=", "neg_num", "=", "int", "(", "p", "/", "2", ")", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._log_comb": [[76, 87], ["None"], "function", ["None"], ["", "else", ":", "\n", "        ", "maximum", "=", "1.0", "\n", "# decide the last change", "\n", "", "if", "p", ">", "2", "*", "pos_num", ":", "\n", "        ", "if", "vec", "[", "order", "[", "-", "(", "neg_num", "+", "1", ")", "]", "]", ">=", "vec", "[", "-", "1", "]", ":", "\n", "            ", "neg_num", "+=", "1", "\n", "delta", "[", "-", "1", "]", "=", "1.0", "\n", "delta", "[", "order", "[", "-", "neg_num", "]", "]", "=", "-", "1.0", "\n", "maximum", "=", "min", "(", "maximum", ",", "vec", "[", "order", "[", "-", "neg_num", "]", "]", ",", "1", "-", "vec", "[", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "delta", "[", "-", "1", "]", "=", "-", "1.0", "\n", "delta", "[", "order", "[", "pos_num", "]", "]", "=", "1.0", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._log_card": [[89, 105], ["numpy.concatenate", "utils._log_comb", "numpy.array", "numpy.cumsum", "numpy.log", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._log_comb"], ["pos_num", "+=", "1", "\n", "", "", "return", "delta", ",", "maximum", "\n", "\n", "\n", "", "def", "change_for_prob_matrix", "(", "prob_mat", ",", "p", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._theo_crit": [[107, 120], ["math.sqrt", "utils._log_card", "math.log", "scipy.special.chdtri", "math.log", "math.log", "math.exp"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._log_card"], ["\n", "d", ",", "c", "=", "prob_mat", ".", "shape", "\n", "delta", "=", "np", ".", "zeros", "(", "(", "d", ",", "c", ")", ")", "\n", "maximum", "=", "1", "\n", "quot", "=", "int", "(", "p", "/", "d", ")", "# number of changed components of each row", "\n", "for", "k", "in", "range", "(", "d", ")", ":", "\n", "        ", "if", "k", "<", "p", "%", "d", ":", "\n", "            ", "num", "=", "quot", "+", "1", "\n", "", "else", ":", "\n", "            ", "num", "=", "quot", "\n", "", "if", "num", ">", "0", ":", "\n", "            ", "delta", "[", "k", "]", ",", "new_max", "=", "change_for_prob_vec", "(", "prob_mat", "[", "k", "]", ",", "num", ")", "\n", "maximum", "=", "min", "(", "maximum", ",", "new_max", ")", "\n", "", "", "return", "delta", ",", "maximum", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._lin_threshold": [[122, 125], ["math.sqrt", "scipy.stats.chi2.ppf"], "function", ["None"], ["\n", "", "def", "change_for_brown_keep_zero", "(", "prob_mat", ",", "p", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._scan_thresholds": [[127, 133], ["numpy.zeros", "enumerate", "len", "utils._theo_crit"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._theo_crit"], []], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.compute_thresholds": [[135, 145], ["utils._lin_threshold", "utils._scan_thresholds", "utils._lin_threshold", "utils._scan_thresholds"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._lin_threshold", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._scan_thresholds", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._lin_threshold", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._scan_thresholds"], ["\n", "\n", "d", ",", "c", "=", "prob_mat", ".", "shape", "\n", "delta", "=", "np", ".", "zeros", "(", "(", "d", ",", "c", ")", ")", "\n", "maximum", "=", "1", "\n", "quot", "=", "int", "(", "p", "/", "d", ")", "# number of changed components of each row", "\n", "for", "k", "in", "range", "(", "d", ")", ":", "\n", "        ", "if", "k", "<", "p", "%", "d", ":", "\n", "            ", "num", "=", "quot", "+", "1", "\n", "", "else", ":", "\n", "            ", "num", "=", "quot", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.sample_square_Bessel": [[147, 166], ["numpy.random.randn", "numpy.zeros", "range", "numpy.sqrt"], "function", ["None"], ["if", "num", ">=", "len", "(", "non_zero", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"Too many zero entries in {k+1}th row of prob_mat\"", ")", "\n", "", "if", "num", ">", "0", ":", "\n", "            ", "delta", "[", "k", ",", "non_zero", "]", ",", "new_max", "=", "change_for_prob_vec", "(", "prob_mat", "[", "k", ",", "non_zero", "]", ",", "num", ")", "\n", "maximum", "=", "min", "(", "maximum", ",", "new_max", ")", "\n", "", "", "return", "delta", ",", "maximum", "\n", "\n", "\n", "", "def", "pars_for_hmm", "(", "n", ",", "c", ",", "p_tran", ",", "p_emis", ",", "emission", "=", "\"Normal\"", ",", "alpha", "=", "None", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.sample_max_square_Bessel": [[168, 188], ["numpy.random.uniform", "numpy.zeros", "range", "numpy.exp", "utils.sample_square_Bessel", "numpy.max", "numpy.log", "numpy.sqrt", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.sample_square_Bessel"], ["\n", "\n", "tran", "=", "prob_matrix", "(", "n", ",", "n", ",", "alpha", ")", "\n", "delta_tran", ",", "max_tran", "=", "change_for_prob_matrix", "(", "tran", ",", "p_tran", ")", "\n", "\n", "emis", "=", "np", ".", "zeros", "(", "(", "n", ",", "2", ")", ")", "\n", "delta_emis", "=", "np", ".", "zeros", "(", "(", "n", ",", "c", ")", ")", "\n", "if", "emission", "==", "\"Normal\"", ":", "\n", "        ", "emis", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "n", ")", "\n", "emis", "[", ":", ",", "1", "]", "=", "np", ".", "linspace", "(", "0.01", ",", "0.1", ",", "n", ")", "\n", "delta_emis", "[", "range", "(", "p_emis", ")", ",", "0", "]", "=", "-", "1.0", "\n", "max_emis", "=", "p_emis", "\n", "", "elif", "emission", "==", "\"Discrete\"", ":", "\n", "        ", "emis", "=", "prob_matrix", "(", "n", ",", "c", ",", "alpha", ")", "\n", "delta_emis", ",", "max_emis", "=", "change_for_prob_matrix", "(", "emis", ",", "p_emis", ")", "\n", "\n", "", "return", "{", "\"transition\"", ":", "[", "tran", ",", "delta_tran", ",", "max_tran", "]", ",", "\"emission\"", ":", "[", "emis", ",", "delta_emis", ",", "max_emis", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.quantile_max_square_Bessel": [[190, 213], ["numpy.zeros", "numpy.zeros", "range", "int", "utils.sample_max_square_Bessel", "int", "numpy.quantile", "int"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.sample_max_square_Bessel"], ["", "def", "pars_for_brown", "(", "n", ",", "c", ",", "p_tran", ",", "p_emis", ",", "alpha", "=", "None", ")", ":", "\n", "    ", "\"\"\"Generate parameters for Brown model.\n\n    This function generates the transition matrix and emission matrix by\n    using Dirichlet distribution.\n\n    Parameters\n    ----------\n    n: int\n        Number of hidden states.\n    c: int\n        Number of categories of emission distribution.\n    p: int\n        Number of changed components.\n    alpha: array-like, shape (n,)\n        Parameters of the Dirichlet distribution for transition matrix.\n\n    Returns\n    -------\n    A dictionary containing all parameters.\n    \"\"\"", "\n", "\n", "tran", "=", "prob_matrix", "(", "n", ",", "n", ",", "alpha", ")", "\n", "delta_tran", ",", "max_tran", "=", "change_for_prob_matrix", "(", "tran", ",", "p_tran", ")", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._get_batch": [[219, 222], ["None"], "function", ["None"], ["lo", "=", "0", "\n", "for", "s", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "s", "<", "resi", ":", "\n", "            ", "num", "=", "min_state", "+", "1", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_inv": [[223, 235], ["torch.solve", "torch.solve", "print", "print", "print"], "function", ["None"], ["", "else", ":", "\n", "            ", "num", "=", "min_state", "\n", "", "asign_states", "[", "lo", ":", "(", "lo", "+", "num", ")", "]", "=", "s", "\n", "lo", "=", "lo", "+", "num", "\n", "", "npr", ".", "shuffle", "(", "asign_states", ")", "\n", "for", "s", "in", "range", "(", "n", ")", ":", "\n", "        ", "in_state_s", "=", "asign_states", "==", "s", "\n", "num_of_s", "=", "np", ".", "sum", "(", "in_state_s", ")", "\n", "emis", "[", "s", ",", "in_state_s", "]", "=", "np", ".", "ones", "(", "num_of_s", ")", "*", "3", "/", "num_of_s", "/", "4", "\n", "emis", "[", "s", ",", "in_state_s", "]", "+=", "npr", ".", "dirichlet", "(", "np", ".", "ones", "(", "num_of_s", ")", ")", "/", "4", "\n", "\n", "", "delta_emis", ",", "max_emis", "=", "change_for_brown_keep_zero", "(", "emis", ",", "p_emis", ")", "\n", "return", "{", "\"transition\"", ":", "[", "tran", ",", "delta_tran", ",", "max_tran", "]", ",", "\"emission\"", ":", "[", "emis", ",", "delta_emis", ",", "max_emis", "]", "}", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._max_score": [[237, 271], ["numpy.ix_", "numpy.linalg.solve", "torch.solve", "torch.solve", "type", "sub_score.view"], "function", ["None"], ["\n", "", "def", "pars_for_arma", "(", "p", ",", "q", ",", "seed", ")", ":", "\n", "    ", "\"\"\"Generate parameters for ARMA model.\"\"\"", "\n", "npr", ".", "seed", "(", "seed", ")", "\n", "ar_root", "=", "np", ".", "random", ".", "exponential", "(", "0.5", ",", "p", ")", "+", "1.0", "\n", "ar_root", "*=", "np", ".", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ",", "p", ")", "\n", "ma_root", "=", "np", ".", "random", ".", "exponential", "(", "0.5", ",", "q", ")", "+", "1.0", "\n", "ma_root", "*=", "np", ".", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ",", "q", ")", "\n", "phi", "=", "np", ".", "polynomial", ".", "polynomial", ".", "polyfromroots", "(", "ar_root", ")", "\n", "phi", "/=", "-", "phi", "[", "0", "]", "\n", "the", "=", "np", ".", "polynomial", ".", "polynomial", ".", "polyfromroots", "(", "ma_root", ")", "\n", "the", "/=", "the", "[", "0", "]", "\n", "return", "phi", ",", "the", ",", "ar_root", ",", "ma_root", "\n", "\n", "\n", "", "def", "change_for_ar", "(", "phi", ",", "ar_root", ",", "r", ")", ":", "\n", "    ", "\"\"\"Generate change for AR model.\"\"\"", "\n", "ar_new_root", "=", "(", "1", "+", "r", ")", "*", "ar_root", "\n", "phi_new", "=", "np", ".", "polynomial", ".", "polynomial", ".", "polyfromroots", "(", "ar_new_root", ")", "\n", "phi_new", "/=", "-", "phi_new", "[", "0", "]", "\n", "delta", "=", "phi_new", "-", "phi", "\n", "de", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "delta", "**", "2", ")", ")", "/", "np", ".", "sqrt", "(", "len", "(", "phi", ")", ")", "\n", "return", "delta", ",", "de", "\n", "\n", "\n", "", "def", "change_for_ma", "(", "the", ",", "ma_root", ",", "r", ")", ":", "\n", "    ", "\"\"\"Generate change for MA model.\"\"\"", "\n", "ma_new_root", "=", "ma_root", "+", "r", "*", "ma_root", "\n", "the_new", "=", "np", ".", "polynomial", ".", "polynomial", ".", "polyfromroots", "(", "ma_new_root", ")", "\n", "the_new", "/=", "the_new", "[", "0", "]", "\n", "delta", "=", "the_new", "-", "the", "\n", "de", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "delta", "**", "2", ")", ")", "/", "np", ".", "sqrt", "(", "len", "(", "the", ")", ")", "\n", "return", "delta", ",", "de", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat": [[273, 292], ["math.sqrt"], "function", ["None"], ["# functions for generating data", "\n", "##########################################################################", "\n", "\n", "\n", "", "def", "load_parameters", "(", "file_name", ")", ":", "\n", "    ", "\"\"\"Load parameters for HMM and Brown\"\"\"", "\n", "with", "open", "(", "file_name", ")", "as", "f", ":", "\n", "        ", "pars", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "# transition parameters", "\n", "", "d", "=", "int", "(", "pars", "[", "0", "]", ")", "\n", "tran", "=", "np", ".", "zeros", "(", "(", "d", ",", "d", ")", ")", "\n", "delta_tran", "=", "np", ".", "zeros", "(", "(", "d", ",", "d", ")", ")", "\n", "loc", "=", "2", "\n", "for", "i", "in", "range", "(", "d", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "d", ")", ":", "\n", "            ", "tran", "[", "i", ",", "j", "]", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "loc", "+=", "1", "\n", "", "", "for", "i", "in", "range", "(", "d", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "d", ")", ":", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_stats": [[294, 372], ["len", "utils._compute_normalized_stat", "utils._compute_normalized_stat", "numpy.zeros", "numpy.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "numpy.arange", "utils._max_score", "utils._max_score", "utils._max_score", "enumerate", "type", "max", "range", "range", "range", "type", "numpy.argsort", "numpy.argsort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "utils._max_score", "utils._max_score", "utils._max_score", "torch.tensor", "torch.tensor", "utils._compute_normalized_stat", "utils._compute_normalized_stat", "numpy.ix_", "numpy.ix_", "numpy.ix_", "int", "int", "int", "int", "int", "numpy.diag", "numpy.diag", "numpy.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "numpy.ix_", "numpy.ix_", "int"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._max_score", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._max_score", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._max_score", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._max_score", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._max_score", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._max_score", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_normalized_stat"], ["loc", "+=", "1", "\n", "", "", "max_tran", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "loc", "+=", "1", "\n", "\n", "# emission parameters", "\n", "p", ",", "q", "=", "int", "(", "pars", "[", "loc", "]", ")", ",", "int", "(", "pars", "[", "loc", "+", "1", "]", ")", "\n", "emis", "=", "np", ".", "zeros", "(", "(", "p", ",", "q", ")", ")", "\n", "delta_emis", "=", "np", ".", "zeros", "(", "(", "p", ",", "q", ")", ")", "\n", "loc", "+=", "2", "\n", "for", "i", "in", "range", "(", "p", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "q", ")", ":", "\n", "            ", "emis", "[", "i", ",", "j", "]", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "loc", "+=", "1", "\n", "", "", "for", "i", "in", "range", "(", "p", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "q", ")", ":", "\n", "            ", "delta_emis", "[", "i", ",", "j", "]", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "loc", "+=", "1", "\n", "", "", "max_emis", "=", "float", "(", "pars", "[", "loc", "]", ")", "\n", "return", "[", "tran", ",", "delta_tran", ",", "max_tran", "]", ",", "[", "emis", ",", "delta_emis", ",", "max_emis", "]", "\n", "\n", "\n", "", "def", "synthetic_data_hmm", "(", "n", ",", "dim", ",", "tau", ",", "tran", ",", "delta", ",", "emis", ",", "model", ",", "obs_per_state", ",", "seed", ")", ":", "\n", "    ", "\"\"\"Generate synthetic data for HMM with change in emission parameters.\n\n    Parameters\n    ----------\n    n: int\n        Sample size.\n    dim: int\n        Dimension of observations.\n    tau: int\n        Location of the changepoint.\n    tran: numpy.ndarray, shape (n_states, n_states)\n        Transition matrix.\n    delta: numpy.ndarray, shape (n_states, n_states)\n        Value of change in transition matrix.\n    emis: array-like, shape (n_states, n_emissions or n_pars)\n        Emission parameters.\n        For discrete emission distribution, it is the emission matrix;\n        for normal distribution, it is the normal parameters.\n    model: str\n        Model of emission distribution. Must be ``\"Normal\"`` or ``\"Discrete\"``.\n    obs_per_state: int\n        For each state must appear at least this number times in the generated data.\n    seed: str\n        Random seed.\n\n    Returns\n    -------\n    states: numpy.ndarray, shape (n,)\n        Hidden states associated with observations.\n    obs: numpy.ndarray, shape (n,)\n        Generated observations.\n    \"\"\"", "\n", "\n", "N", "=", "len", "(", "tran", ")", "\n", "n_cats", "=", "emis", ".", "shape", "[", "1", "]", "\n", "# generate data with change in transition parameters", "\n", "nu", "=", "np", ".", "ones", "(", "N", ")", "/", "N", "\n", "gen", "=", "Generator", "(", "n", ",", "dim", ",", "tau", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "bad", "=", "True", "\n", "while", "bad", ":", "\n", "        ", "states", ",", "obs", "=", "gen", ".", "hmm_transition", "(", "tran", ",", "delta", ",", "emis", ",", "model", ",", "nu", ")", "\n", "bad", "=", "False", "\n", "for", "state", "in", "range", "(", "N", ")", ":", "\n", "            ", "if", "np", ".", "sum", "(", "states", "==", "state", ")", "<", "obs_per_state", ":", "\n", "                ", "bad", "=", "True", "\n", "break", "\n", "", "", "if", "model", "==", "'Discrete'", ":", "\n", "            ", "for", "cat", "in", "range", "(", "n_cats", ")", ":", "\n", "                ", "if", "np", ".", "sum", "(", "obs", "==", "cat", ")", "<", "obs_per_state", ":", "\n", "                    ", "bad", "=", "True", "\n", "break", "\n", "", "", "", "", "return", "states", ",", "obs", "\n", "\n", "\n", "", "def", "synthetic_data_arma", "(", "n", ",", "dim", ",", "tau", ",", "phi", ",", "delta", ",", "the", ",", "seed", ")", ":", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_mean": [[374, 382], ["len", "type", "numpy.sum", "torch.sum", "torch.sum"], "function", ["None"], []], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_culinear_stat": [[384, 395], ["numpy.linalg.solve", "torch.solve", "torch.solve", "type", "score.view"], "function", ["None"], []], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils.conjugate_grad": [[397, 428], ["range", "grad", "grad", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.zeros_like", "torch.zeros_like", "grad", "torch.norm", "torch.norm", "torch.dot", "torch.dot"], "function", ["None"], ["\n", "p", ",", "q", "=", "len", "(", "phi", ")", ",", "len", "(", "the", ")", "\n", "gen", "=", "Generator", "(", "n", ",", "dim", ",", "tau", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "y", "=", "gen", ".", "arma", "(", "phi", ",", "delta", ",", "the", ")", "\n", "while", "True", ":", "\n", "        ", "try", ":", "\n", "            ", "cmle", "=", "ARMA", "(", "y", ",", "order", "=", "(", "p", ",", "q", ")", ")", ".", "fit", "(", "method", "=", "'css'", ",", "trend", "=", "'nc'", ")", "\n", "break", "\n", "", "except", "ValueError", ":", "\n", "            ", "y", "=", "gen", ".", "arma", "(", "phi", ",", "delta", ",", "the", ")", "\n", "print", "(", "y", "[", "0", "]", ")", "\n", "", "", "obs", "=", "torch", ".", "from_numpy", "(", "np", ".", "column_stack", "(", "[", "y", ",", "np", ".", "zeros", "(", "n", ")", "]", ")", ")", ".", "float", "(", ")", "\n", "theta_hat", "=", "torch", ".", "tensor", "(", "cmle", ".", "params", ")", ".", "float", "(", ")", "\n", "theta_hat", ".", "requires_grad", "=", "True", "\n", "sigma2", "=", "cmle", ".", "sigma2", "\n", "return", "obs", ",", "theta_hat", ",", "sigma2", "\n", "\n", "\n", "##########################################################################", "\n", "# miscellaneous", "\n", "##########################################################################", "\n", "\n", "\n", "", "def", "write_mat", "(", "matrix", ",", "f", ")", ":", "\n", "    ", "\"\"\"Write matrix to file.\"\"\"", "\n", "for", "_", ",", "mat", "in", "enumerate", "(", "matrix", ")", ":", "\n", "        ", "for", "v", "in", "mat", ":", "\n", "            ", "f", ".", "write", "(", "\"%s\\n\"", "%", "str", "(", "v", ")", ")", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._exceptions_handling": [[434, 462], ["isinstance", "NameError", "NameError", "range", "range", "range", "isinstance", "ValueError", "ValueError", "int", "ValueError", "len", "sum", "sum", "min", "min", "max", "len", "int", "min", "max", "int", "len", "numpy.sqrt"], "function", ["None"], ["model", "=", "model", ".", "from_samples", "(", "NormalDistribution", ",", "N", ",", "[", "y", "]", ")", "\n", "tran", "=", "model", ".", "dense_transition_matrix", "(", ")", "[", ":", "N", ",", ":", "N", "]", "\n", "emis", "=", "[", "]", "\n", "states", "=", "model", ".", "get_params", "(", ")", "[", "'states'", "]", "\n", "for", "s", "in", "range", "(", "N", ")", ":", "\n", "        ", "emis", "+=", "states", "[", "s", "]", ".", "distribution", ".", "parameters", "\n", "", "emis", "=", "np", ".", "array", "(", "emis", ")", ".", "reshape", "(", "N", ",", "-", "1", ")", "\n", "return", "tran", ",", "emis", "\n", "\n", "\n", "", "def", "check_rejection", "(", "stat", ",", "type_stat", "=", "''", ")", ":", "\n", "    ", "\"\"\"Check rejection given the statistic.\"\"\"", "\n", "rej", "=", "0", "\n", "if", "stat", ">", "1", ":", "\n", "        ", "rej", "=", "1", "\n", "", "if", "stat", "==", "1", ":", "\n", "        ", "print", "(", "\"{}non-invertible rejection.\"", ".", "format", "(", "type_stat", ")", ")", "\n", "", "return", "rej", "\n", "\n", "\n", "", "def", "check_rejections", "(", "stats", ")", ":", "\n", "    ", "\"\"\"Check rejections given three statistics.\"\"\"", "\n", "rej", "=", "np", ".", "zeros", "(", "3", ",", "int", ")", "\n", "rej", "[", "0", "]", "=", "check_rejection", "(", "stats", "[", "0", "]", ",", "'Linear '", ")", "\n", "rej", "[", "1", "]", "=", "check_rejection", "(", "stats", "[", "1", "]", ",", "'Scan '", ")", "\n", "rej", "[", "2", "]", "=", "check_rejection", "(", "stats", "[", "2", "]", ",", "'Autograd '", ")", "\n", "print", "(", "\"\"", ")", "\n", "return", "rej", "\n", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._update_res": [[464, 472], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._return_results": [[474, 483], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.__init__": [[43, 50], ["object.__init__", "sum", "copy.deepcopy", "autocusum.AutogradCuSum._initialization", "par.numel", "pretrained_model.parameters"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.__init__", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum._initialization", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.parameters"], ["def", "__init__", "(", "self", ",", "pretrained_model", ",", "loglike", ")", ":", "\n", "        ", "super", "(", "AutogradCuSum", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_dim", "=", "sum", "(", "par", ".", "numel", "(", ")", "for", "par", "in", "pretrained_model", ".", "parameters", "(", ")", "if", "\n", "par", ".", "requires_grad", ")", "\n", "self", ".", "_model", "=", "copy", ".", "deepcopy", "(", "pretrained_model", ")", "\n", "self", ".", "_loglike", "=", "loglike", "\n", "self", ".", "_initialization", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.model_parameters": [[51, 59], ["autocusum.AutogradCuSum._model.parameters", "torch.cat().detach", "par.view.view.view", "pars.append", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.parameters"], ["", "def", "model_parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get model parameters.\n        \"\"\"", "\n", "pars", "=", "[", "]", "\n", "for", "par", "in", "self", ".", "_model", ".", "parameters", "(", ")", ":", "\n", "            ", "par", "=", "par", ".", "view", "(", "-", "1", ")", "\n", "pars", ".", "append", "(", "par", ")", "\n", "", "return", "torch", ".", "cat", "(", "pars", ")", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.log_likelihood": [[60, 64], ["autocusum.AutogradCuSum._model", "autocusum.AutogradCuSum._loglike"], "methods", ["None"], ["", "def", "log_likelihood", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"Compute log-likelihood.\"\"\"", "\n", "outputs", "=", "self", ".", "_model", "(", "inputs", ")", "\n", "return", "self", ".", "_loglike", "(", "outputs", ",", "targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.gradients": [[65, 75], ["autocusum.AutogradCuSum._model.parameters", "torch.cat", "grads.append", "par.grad.view"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.parameters"], ["", "def", "gradients", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get gradients of model parameters.\n\n        Returns a 1D ``Tensor`` contains the derivatives of each parameters in\n        the parameter vector.\n        \"\"\"", "\n", "grads", "=", "[", "]", "\n", "for", "par", "in", "self", ".", "_model", ".", "parameters", "(", ")", ":", "\n", "            ", "grads", ".", "append", "(", "par", ".", "grad", ".", "view", "(", "-", "1", ")", ")", "# removed grad[0]", "\n", "", "return", "torch", ".", "cat", "(", "grads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum._initialization": [[76, 85], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "_initialization", "(", "self", ")", ":", "\n", "        ", "self", ".", "_size", "=", "0", "\n", "self", ".", "_max_size", "=", "0", "\n", "self", ".", "_rest_size", "=", "0", "\n", "self", ".", "_score", "=", "torch", ".", "zeros", "(", "self", ".", "_dim", ")", "\n", "self", ".", "_info", "=", "torch", ".", "zeros", "(", "(", "self", ".", "_dim", ",", "self", ".", "_dim", ")", ")", "\n", "self", ".", "_full_score", "=", "torch", ".", "zeros", "(", "self", ".", "_dim", ")", "\n", "self", ".", "_full_info", "=", "torch", ".", "zeros", "(", "(", "self", ".", "_dim", ",", "self", ".", "_dim", ")", ")", "\n", "self", ".", "_min_stat", "=", "-", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.initial_model": [[86, 104], ["autocusum.AutogradCuSum._initialization", "zip", "autocusum.AutogradCuSum._model.zero_grad", "autocusum.AutogradCuSum.log_likelihood", "autocusum.AutogradCuSum.backward", "autocusum.AutogradCuSum.gradients().detach", "torch.outer", "torch.outer", "autocusum.AutogradCuSum.gradients"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum._initialization", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.log_likelihood", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.gradients"], ["", "def", "initial_model", "(", "self", ",", "inputs", ",", "targets", ",", "max_size", ")", ":", "\n", "        ", "\"\"\"Set up inital model.\n\n        Inputs and targets are the data used for training, and they must be\n        iterable.\n        \"\"\"", "\n", "self", ".", "_initialization", "(", ")", "\n", "self", ".", "_rest_size", "=", "self", ".", "_max_size", "=", "max_size", "\n", "for", "x", ",", "y", "in", "zip", "(", "inputs", ",", "targets", ")", ":", "\n", "            ", "self", ".", "_model", ".", "zero_grad", "(", ")", "\n", "like", "=", "self", ".", "log_likelihood", "(", "x", ",", "y", ")", "\n", "like", ".", "backward", "(", ")", "\n", "temp", "=", "self", ".", "gradients", "(", ")", ".", "detach", "(", ")", "\n", "self", ".", "_score", "+=", "temp", "\n", "self", ".", "_info", "+=", "torch", ".", "outer", "(", "temp", ",", "temp", ")", "\n", "self", ".", "_full_score", "+=", "temp", "\n", "self", ".", "_full_info", "+=", "torch", ".", "outer", "(", "temp", ",", "temp", ")", "\n", "self", ".", "_size", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum._update_model": [[105, 115], ["torch.optim.Adam", "torch.optim.Adam.zero_grad", "loss.backward", "torch.optim.Adam.step", "autocusum.AutogradCuSum._model.parameters", "autocusum.AutogradCuSum.log_likelihood"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.parameters", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.log_likelihood"], ["", "", "def", "_update_model", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"Update model given new (inputs, targets).\n\n        This method takes one step update of Adam using new (inputs, targets).\n        \"\"\"", "\n", "optim", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "_model", ".", "parameters", "(", ")", ")", "\n", "optim", ".", "zero_grad", "(", ")", "\n", "loss", "=", "-", "self", ".", "log_likelihood", "(", "inputs", ",", "targets", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optim", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.update_information": [[116, 143], ["zip", "autocusum.AutogradCuSum._update_model", "autocusum.AutogradCuSum._model.zero_grad", "autocusum.AutogradCuSum.log_likelihood", "autocusum.AutogradCuSum.backward", "autocusum.AutogradCuSum.gradients().detach", "torch.outer", "torch.outer", "autocusum.AutogradCuSum.gradients"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum._update_model", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.hmm.AutogradHmm.zero_grad", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.log_likelihood", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.gradients"], ["", "def", "update_information", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"Compute score function and information matrix (first derivatives).\n\n        .. note::\n            This function will set gradients of the model to zero.\n\n        Parameters\n        ----------\n        inputs: torch.Tensor, shape (size, dim)\n        targets: torch.Tensor, shape (size, *)\n\n        \"\"\"", "\n", "# do no update existing score and info", "\n", "for", "x", ",", "y", "in", "zip", "(", "inputs", ",", "targets", ")", ":", "\n", "# updates model", "\n", "            ", "self", ".", "_update_model", "(", "x", ",", "y", ")", "\n", "self", ".", "_model", ".", "zero_grad", "(", ")", "\n", "# computes score", "\n", "like", "=", "self", ".", "log_likelihood", "(", "x", ",", "y", ")", "\n", "like", ".", "backward", "(", ")", "\n", "temp", "=", "self", ".", "gradients", "(", ")", ".", "detach", "(", ")", "\n", "# updates statistics", "\n", "self", ".", "_score", "+=", "temp", "\n", "self", ".", "_info", "+=", "torch", ".", "outer", "(", "temp", ",", "temp", ")", "\n", "self", ".", "_full_score", "+=", "temp", "\n", "self", ".", "_full_info", "+=", "torch", ".", "outer", "(", "temp", ",", "temp", ")", "\n", "self", ".", "_size", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.compute_stats": [[144, 185], ["autocusum.AutogradCuSum.update_information", "utils._compute_culinear_stat", "utils._compute_culinear_stat", "range", "max", "max", "torch.zeros", "torch.zeros", "numpy.ix_", "numpy.ix_"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.update_information", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_culinear_stat", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.utils._compute_culinear_stat"], ["", "", "def", "compute_stats", "(", "self", ",", "inputs", ",", "targets", ",", "thresh", ",", "min_thresh", "=", "0.0", ",", "idx", "=", "None", ")", ":", "\n", "        ", "\"\"\"Compute statistics given new (inputs, targets).\n\n        Currently only the linear statistic is supported.\n\n        Parameters\n        ----------\n        inputs: torch.Tensor, shape (size, dim)\n        targets: torch.Tensor, shape (size, *)\n        thresh: float\n            Threshold for the stopping criterion. Use the method ``quantile_max_square_Bessel`` to compute it.\n        min_thresh: float, optional\n            Reinitialize the process whenever the current statistic is\n            below this threshold. Default is zero.\n        idx: array-like, optional\n            Indices of parameters of interest (the rest parameters are considered constants)\n            in the parameter vector.\n            Default is ``None``, which will be set to ``range(dim)``.\n        \"\"\"", "\n", "if", "idx", "is", "None", ":", "\n", "            ", "idx", "=", "range", "(", "self", ".", "_dim", ")", "\n", "", "self", ".", "update_information", "(", "inputs", ",", "targets", ")", "\n", "\n", "stat", "=", "_compute_culinear_stat", "(", "self", ".", "_full_score", "[", "idx", "]", ",", "\n", "self", ".", "_full_info", "[", "np", ".", "ix_", "(", "idx", ",", "idx", ")", "]", ",", "\n", "thresh", ")", "\n", "if", "self", ".", "_min_stat", ">=", "min_thresh", ":", "\n", "            ", "if", "stat", "<=", "self", ".", "_min_stat", ":", "\n", "                ", "self", ".", "_min_stat", "=", "max", "(", "stat", ",", "min_thresh", ")", "\n", "self", ".", "_score", "=", "torch", ".", "zeros", "(", "self", ".", "_dim", ")", "\n", "self", ".", "_info", "=", "torch", ".", "zeros", "(", "(", "self", ".", "_dim", ",", "self", ".", "_dim", ")", ")", "\n", "#self._rest_size -= self._size", "\n", "#self._size = 0", "\n", "return", "0.0", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "_min_stat", "=", "max", "(", "stat", ",", "min_thresh", ")", "\n", "\n", "", "stat", "=", "_compute_culinear_stat", "(", "self", ".", "_score", "[", "idx", "]", ",", "\n", "self", ".", "_info", "[", "np", ".", "ix_", "(", "idx", ",", "idx", ")", "]", ",", "\n", "thresh", ")", "\n", "return", "stat", "*", "self", ".", "_size", "/", "self", ".", "_rest_size", "\n", "", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.models.Linear.__init__": [[29, 32], ["torch.Module.__init__", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.__init__"], ["def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ")", ":", "\n", "        ", "super", "(", "Linear", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.models.Linear.forward": [[33, 36], ["models.Linear.fc().view", "models.Linear.fc"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "inputs", "=", "self", ".", "fc", "(", "inputs", ")", ".", "view", "(", "-", "1", ")", "\n", "return", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.models.loglike_gaussian": [[13, 16], ["torch.sum", "torch.sum"], "function", ["None"], ["def", "loglike_gaussian", "(", "theta", ",", "obs", ",", "sig", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"Log-likelihood for Gaussian model (without constant term).\"\"\"", "\n", "return", "-", "torch", ".", "sum", "(", "(", "obs", "-", "theta", "[", "np", ".", "newaxis", ",", ":", "]", ")", "**", "2", ")", "/", "2", "/", "sig", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.models.loglike_linear": [[18, 25], ["torch.MSELoss", "nn.MSELoss.", "y.view"], "function", ["None"], ["", "def", "loglike_linear", "(", "theta", ",", "data", ")", ":", "\n", "    ", "\"\"\"Log-likelihood for linear regression.\"\"\"", "\n", "x", ",", "y", "=", "data", "[", ":", ",", ":", "-", "1", "]", ",", "data", "[", ":", ",", "-", "1", "]", "\n", "y_pred", "=", "x", "@", "theta", "\n", "criterion", "=", "nn", ".", "MSELoss", "(", "size_average", "=", "False", ")", "\n", "loglike", "=", "-", "criterion", "(", "y_pred", ",", "y", ".", "view", "(", "-", "1", ")", ")", "/", "2", "\n", "return", "loglike", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.models.loglike_arma": [[43, 71], ["torch.zeros", "torch.zeros", "range", "len", "len", "torch.arange().long", "torch.arange().long", "torch.arange().long", "torch.arange().long", "resi[].detach", "torch.sum", "torch.sum", "torch.log", "torch.log", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "function", ["None"], ["def", "loglike_arma", "(", "theta", ",", "data", ")", ":", "\n", "    ", "\"\"\"Log-likelihood for ARMA model.\n\n    This log-likelihood is computed by conditioning on :math:`x_0 = \\\\cdots =\n    x_{-p+1} = \\\\epsilon_0 = \\\\cdots = \\\\epsilon_{-q+1} = 0`.\n\n    Residuals in data will be updated (``data[LAG:, 1]``).\n\n    Parameters\n    ----------\n    theta:  torch.Tensor (P+Q, )\n        ARMA coefficients and mean and SD of white noise.\n    data: torch.Tensor, shape (size+LAG, 2)\n        The first column is observation and the second column is residual.\n    \"\"\"", "\n", "\n", "x", ",", "e", "=", "data", "[", ":", ",", "0", "]", ",", "data", "[", ":", ",", "1", "]", "\n", "length", "=", "len", "(", "x", ")", "-", "LAG", "\n", "resi", "=", "torch", ".", "zeros", "(", "length", ",", "requires_grad", "=", "True", ")", "\n", "for", "t", "in", "range", "(", "LAG", ",", "len", "(", "x", ")", ")", ":", "\n", "        ", "inv_idx", "=", "torch", ".", "arange", "(", "t", "-", "1", ",", "t", "-", "P", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "inv_ide", "=", "torch", ".", "arange", "(", "t", "-", "1", ",", "t", "-", "Q", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "resi", "[", "t", "-", "LAG", "]", "=", "x", "[", "t", "]", "-", "theta", "[", "-", "2", "]", "-", "torch", ".", "sum", "(", "theta", "[", ":", "P", "]", "*", "x", "[", "inv_idx", "]", ")", "-", "torch", ".", "sum", "(", "theta", "[", "P", ":", "(", "P", "+", "Q", ")", "]", "*", "e", "[", "inv_ide", "]", ")", "\n", "e", "[", "t", "]", "=", "resi", "[", "t", "-", "LAG", "]", ".", "detach", "(", ")", "\n", "", "loglike", "=", "-", "length", "*", "torch", ".", "log", "(", "theta", "[", "-", "1", "]", ")", "-", "torch", ".", "sum", "(", "resi", "**", "2", ")", "/", "theta", "[", "-", "1", "]", "**", "2", "/", "2", "\n", "return", "loglike", "\n", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.__init__": [[28, 32], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", ",", "dim", ",", "tau", ")", ":", "\n", "        ", "self", ".", "_size", "=", "size", "\n", "self", ".", "_dim", "=", "dim", "\n", "self", ".", "_tau", "=", "tau", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.gaussian": [[33, 64], ["numpy.normal", "numpy.normal", "torch.from_numpy().float", "torch.mean", "torch.mean.requires_grad_", "torch.from_numpy"], "methods", ["None"], ["", "def", "gaussian", "(", "self", ",", "mu", ",", "delta", ",", "sig", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"Generates observations from multivariate normal with change in mean.\n\n        Observations are independent and identically distributed, and\n        the covariance matrix is a scalar matrix.\n\n        Parameters\n        ----------\n        mu: array-like, shape (dim,)\n            Mean of the model.\n        delta: array-like, shape (dim,)\n            Value of change in mean. After the change point, the mean of the\n            model becomes ``mu + delta``.\n        sig: double, optional\n            Standard deviation of the model. :math:`sig^2` is the scalar\n            of the covariance matrix. Default is 1.0.\n\n        Returns\n        -------\n        obs: torch.Tensor, shape (size, dim)\n            Generated observations.\n        mu_hat: torch.Tensor, shape (dim,)\n            Maximum likelihood estimate (MLE) of the mean assuming no change.\n        \"\"\"", "\n", "\n", "x", "=", "npr", ".", "normal", "(", "loc", "=", "mu", ",", "scale", "=", "sig", ",", "size", "=", "(", "self", ".", "_size", ",", "self", ".", "_dim", ")", ")", "\n", "x", "[", "self", ".", "_tau", ":", "self", ".", "_size", ",", ":", "]", "+=", "delta", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "obs", "=", "torch", ".", "from_numpy", "(", "x", ")", ".", "float", "(", ")", "\n", "mu_hat", "=", "torch", ".", "mean", "(", "obs", ",", "0", ")", "\n", "mu_hat", ".", "requires_grad_", "(", "True", ")", "\n", "return", "obs", ",", "mu_hat", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.linear": [[65, 104], ["numpy.column_stack", "numpy.column_stack", "numpy.normal", "numpy.normal", "numpy.identity", "numpy.identity", "numpy.linalg.solve", "numpy.linalg.solve", "torch.from_numpy().float", "torch.from_numpy().float.requires_grad_", "torch.cat().float", "numpy.normal", "numpy.normal", "numpy.ones", "numpy.ones", "torch.from_numpy", "torch.cat", "torch.from_numpy", "torch.from_numpy", "response.reshape"], "methods", ["None"], ["", "def", "linear", "(", "self", ",", "beta", ",", "delta", ",", "sig", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"Generates observations from linear model with change in coefficients.\n\n        Covariates are sampled from multivariate normal, and the covariance\n        matrix is the identity matrix. Errors are sampled from normal distribution.\n\n        Parameters\n        ----------\n        beta: numpy.ndarray, shape (dim,)\n            Coefficients of the linear model.\n        delta: numpy.ndarray shape (dim+1,)\n            Value of change in coefficients and intercept (the last element).\n        sig: double, optional\n            Standard deviation of errors. Default is 1.0.\n\n        Returns\n        -------\n        obs: torch.Tensor, shape (size, dim+2)\n            Generated observations. The first ``dim + 1`` columns form the\n            design matrix, and the last column contains responses.\n        beta_hat: torch.Tensor, shape(dim+1,)\n            MLE of the coefficients and intercept assuming no change.\n        \"\"\"", "\n", "\n", "n", "=", "self", ".", "_size", "\n", "d", "=", "self", ".", "_dim", "\n", "tau", "=", "self", ".", "_tau", "\n", "design", "=", "np", ".", "column_stack", "(", "(", "npr", ".", "normal", "(", "size", "=", "(", "n", ",", "d", ")", ")", ",", "np", ".", "ones", "(", "n", ")", ")", ")", "\n", "e", "=", "npr", ".", "normal", "(", "scale", "=", "sig", ",", "size", "=", "n", ")", "\n", "response", "=", "design", "@", "beta", "+", "e", "\n", "response", "[", "tau", ":", "n", "]", "+=", "design", "[", "tau", ":", "n", ",", ":", "]", "@", "delta", "\n", "# compute MLE under H_0", "\n", "ident", "=", "np", ".", "identity", "(", "d", "+", "1", ")", "\n", "inv", "=", "np", ".", "linalg", ".", "solve", "(", "design", ".", "T", "@", "design", ",", "ident", ")", "\n", "beta_hat", "=", "torch", ".", "from_numpy", "(", "inv", "@", "(", "design", ".", "T", "@", "response", ")", ")", ".", "float", "(", ")", "\n", "beta_hat", ".", "requires_grad_", "(", "True", ")", "\n", "obs", "=", "torch", ".", "cat", "(", "[", "torch", ".", "from_numpy", "(", "design", ")", ",", "torch", ".", "from_numpy", "(", "response", ".", "reshape", "(", "n", ",", "1", ")", ")", "]", ",", "1", ")", ".", "float", "(", ")", "\n", "return", "obs", ",", "beta_hat", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.hmm_transition": [[105, 160], ["numpy.zeros", "numpy.zeros", "numpy.multinomial().argmax", "numpy.multinomial().argmax", "range", "ValueError", "numpy.zeros", "numpy.zeros", "range", "numpy.multinomial", "numpy.multinomial", "numpy.multinomial().argmax", "numpy.multinomial().argmax", "numpy.multinomial().argmax", "numpy.multinomial().argmax", "numpy.normal", "numpy.normal", "numpy.zeros", "numpy.zeros", "range", "ValueError", "numpy.choice", "numpy.choice", "numpy.multinomial", "numpy.multinomial", "numpy.multinomial", "numpy.multinomial"], "methods", ["None"], ["", "def", "hmm_transition", "(", "self", ",", "tran", ",", "delta", ",", "emit", ",", "emission", ",", "nu", ")", ":", "\n", "        ", "\"\"\"Generates observations from Hidden Markov model (HMM) with change in transition matrix.\n\n        Observations must be one-dimensional.\n\n        Parameters\n        ----------\n        tran: numpy.ndarray, shape (n_states, n_states)\n            Transition matrix.\n        delta: numpy.ndarray, shape (n_states, n_states)\n            Value of change in transition matrix.\n        emit: array-like, shape (n_states, n_emissions or n_pars)\n            Emission parameters.\n            For discrete emission distribution, it is the emission matrix;\n            for normal distribution, it is the normal parameters.\n        emission: str\n            Type of emission distribution. Must be ``\"Normal\"`` or ``\"Discrete\"``.\n        nu: array-like, shape (n_states,)\n            Initial distribution.\n\n        Returns\n        -------\n        states: numpy.ndarray, shape (size,)\n            Hidden states associated with observations.\n        obs: numpy.ndarray, shape (size,)\n            Generated observations.\n        \"\"\"", "\n", "\n", "n", "=", "self", ".", "_size", "\n", "tau", "=", "self", ".", "_tau", "\n", "if", "self", ".", "_dim", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Only one dimensional HMMs are supported'", ")", "\n", "# generates states", "\n", "", "states", "=", "np", ".", "zeros", "(", "n", ",", "int", ")", "\n", "states", "[", "0", "]", "=", "npr", ".", "multinomial", "(", "1", ",", "nu", ")", ".", "argmax", "(", ")", "\n", "for", "k", "in", "range", "(", "n", "-", "1", ")", ":", "\n", "            ", "if", "k", "<", "tau", "-", "1", ":", "\n", "                ", "states", "[", "k", "+", "1", "]", "=", "npr", ".", "multinomial", "(", "1", ",", "tran", "[", "states", "[", "k", "]", ",", ":", "]", ")", ".", "argmax", "(", ")", "\n", "", "else", ":", "\n", "                ", "states", "[", "k", "+", "1", "]", "=", "npr", ".", "multinomial", "(", "1", ",", "tran", "[", "states", "[", "k", "]", ",", ":", "]", "+", "delta", "[", "states", "[", "k", "]", ",", ":", "]", ")", ".", "argmax", "(", ")", "\n", "# generates observations", "\n", "", "", "if", "emission", "==", "\"Normal\"", ":", "\n", "            ", "obs", "=", "np", ".", "zeros", "(", "n", ")", "\n", "for", "k", "in", "range", "(", "n", ")", ":", "\n", "                ", "obs", "[", "k", "]", "=", "npr", ".", "normal", "(", "emit", "[", "states", "[", "k", "]", ",", "0", "]", ",", "emit", "[", "states", "[", "k", "]", ",", "1", "]", ")", "\n", "", "", "elif", "emission", "==", "\"Discrete\"", ":", "\n", "            ", "obs", "=", "np", ".", "zeros", "(", "n", ",", "int", ")", "\n", "emit_num", "=", "emit", ".", "shape", "[", "1", "]", "\n", "for", "k", "in", "range", "(", "n", ")", ":", "\n", "                ", "obs", "[", "k", "]", "=", "npr", ".", "choice", "(", "emit_num", ",", "size", "=", "1", ",", "p", "=", "emit", "[", "states", "[", "k", "]", ",", ":", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only 'Normal' and 'Discrete' distributions\\\n                                 are supported\"", ")", "\n", "", "return", "states", ",", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.hmm_emission": [[161, 219], ["numpy.zeros", "numpy.zeros", "numpy.multinomial().argmax", "numpy.multinomial().argmax", "range", "ValueError", "numpy.multinomial().argmax", "numpy.multinomial().argmax", "numpy.zeros", "numpy.zeros", "range", "numpy.multinomial", "numpy.multinomial", "numpy.zeros", "numpy.zeros", "range", "ValueError", "numpy.multinomial", "numpy.multinomial", "numpy.normal", "numpy.normal", "numpy.normal", "numpy.normal", "numpy.choice", "numpy.choice", "numpy.choice", "numpy.choice"], "methods", ["None"], ["", "def", "hmm_emission", "(", "self", ",", "tran", ",", "delta", ",", "emit", ",", "emission", ",", "nu", ")", ":", "\n", "        ", "\"\"\"Generates observations from Hidden Markov model (HMM) with change in emission parameters.\n\n        Observations must be one-dimensional.\n\n        Parameters\n        ----------\n        tran: array-like, shape (n_states, n_states)\n            Transition matrix.\n        delta: numpy.ndarray, shape (n_states, n_states)\n            Value of change in emission parameters.\n        emit: numpy.ndarray, shape (n_states, n_emissions or n_pars)\n            Emission parameters.\n            For discrete emission distribution, it is the emission matrix;\n            for normal distribution, it is the normal parameters.\n        emission: str\n            Type of emission distribution. Must be ``\"Normal\"`` or ``\"Discrete\"``.\n        nu: array-like, shape (n_states,)\n            Initial distribution.\n\n        Returns\n        -------\n        states: numpy.ndarray, shape (size,)\n            Hidden states associated with observations.\n        obs: numpy.ndarray, shape (size,)\n            Generated observations.\n        \"\"\"", "\n", "\n", "n", "=", "self", ".", "_size", "\n", "tau", "=", "self", ".", "_tau", "\n", "if", "self", ".", "_dim", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Only one dimensional HMMs are supported'", ")", "\n", "# generates states", "\n", "", "states", "=", "np", ".", "zeros", "(", "n", ",", "int", ")", "\n", "states", "[", "0", "]", "=", "npr", ".", "multinomial", "(", "1", ",", "nu", ")", ".", "argmax", "(", ")", "\n", "for", "k", "in", "range", "(", "n", "-", "1", ")", ":", "\n", "            ", "states", "[", "k", "+", "1", "]", "=", "npr", ".", "multinomial", "(", "1", ",", "tran", "[", "states", "[", "k", "]", ",", ":", "]", ")", ".", "argmax", "(", ")", "\n", "# generates observations", "\n", "", "if", "emission", "==", "\"Normal\"", ":", "\n", "            ", "obs", "=", "np", ".", "zeros", "(", "n", ")", "\n", "for", "k", "in", "range", "(", "n", ")", ":", "\n", "                ", "if", "k", "<", "tau", ":", "\n", "                    ", "obs", "[", "k", "]", "=", "npr", ".", "normal", "(", "emit", "[", "states", "[", "k", "]", ",", "0", "]", ",", "emit", "[", "states", "[", "k", "]", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "                    ", "obs", "[", "k", "]", "=", "npr", ".", "normal", "(", "(", "emit", "+", "delta", ")", "[", "states", "[", "k", "]", ",", "0", "]", ",", "\n", "(", "emit", "+", "delta", ")", "[", "states", "[", "k", "]", ",", "1", "]", ")", "\n", "", "", "", "elif", "emission", "==", "\"Discrete\"", ":", "\n", "            ", "obs", "=", "np", ".", "zeros", "(", "n", ",", "int", ")", "\n", "emit_num", "=", "emit", ".", "shape", "[", "1", "]", "\n", "for", "k", "in", "range", "(", "n", ")", ":", "\n", "                ", "if", "k", "<", "tau", ":", "\n", "                    ", "obs", "[", "k", "]", "=", "npr", ".", "choice", "(", "emit_num", ",", "size", "=", "1", ",", "p", "=", "emit", "[", "states", "[", "k", "]", ",", ":", "]", ")", "\n", "", "else", ":", "\n", "                    ", "obs", "[", "k", "]", "=", "npr", ".", "choice", "(", "emit_num", ",", "size", "=", "1", ",", "\n", "p", "=", "(", "emit", "+", "delta", ")", "[", "states", "[", "k", "]", ",", ":", "]", ")", "\n", "", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Only 'Normal' and 'Discrete' distributions are supported\"", ")", "\n", "", "return", "states", ",", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.data.generator.Generator.arma": [[220, 260], ["len", "numpy.normal", "numpy.normal", "numpy.zeros", "numpy.zeros", "numpy.arange", "numpy.arange", "ValueError", "min", "min", "numpy.fliplr", "numpy.fliplr", "numpy.fliplr", "numpy.fliplr", "len", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum"], "methods", ["None"], ["", "def", "arma", "(", "self", ",", "phi", ",", "delta", ",", "theta", ")", ":", "\n", "        ", "\"\"\"Generates observations from ARMA with change in AR parameters.\n\n        Observations must be one-dimensional.\n\n        Parameters\n        ----------\n        phi: numpy.ndarray, shape (p,)\n            AR parameters.\n        delta: numpy.ndarray, shape (p,)\n            Value of change in AR parameters.\n        theta: numpy.ndarray, shape (q,)\n            MA parameters.\n\n        Returns\n        -------\n        obs: numpy.ndarray, shape (size,)\n            Generated observations.\n        \"\"\"", "\n", "p", "=", "len", "(", "phi", ")", "\n", "if", "self", ".", "_dim", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Only one dimensional ARMAs are supported'", ")", "\n", "", "e", "=", "npr", ".", "normal", "(", "scale", "=", "0.1", ",", "size", "=", "self", ".", "_size", ")", "\n", "obs", "=", "np", ".", "zeros", "(", "self", ".", "_size", ")", "\n", "obs", "[", "0", "]", "=", "e", "[", "0", "]", "\n", "for", "t", "in", "np", ".", "arange", "(", "1", ",", "self", ".", "_size", ")", ":", "\n", "            ", "pm", "=", "min", "(", "[", "t", ",", "p", "]", ")", "\n", "qm", "=", "min", "(", "[", "t", ",", "len", "(", "theta", ")", "]", ")", "\n", "yflip", "=", "np", ".", "fliplr", "(", "[", "obs", "[", "(", "t", "-", "pm", ")", ":", "t", "]", "]", ")", "[", "0", "]", "\n", "eflip", "=", "np", ".", "fliplr", "(", "[", "e", "[", "(", "t", "-", "qm", ")", ":", "t", "]", "]", ")", "[", "0", "]", "\n", "#print(eflip.shape)", "\n", "#print(delta[p:(p+qm)].shape)", "\n", "#print(theta[0:qm].shape)", "\n", "if", "t", "<", "self", ".", "_tau", ":", "\n", "                ", "obs", "[", "t", "]", "=", "np", ".", "sum", "(", "phi", "[", "0", ":", "pm", "]", "*", "yflip", ")", "+", "e", "[", "t", "]", "+", "np", ".", "sum", "(", "theta", "[", "0", ":", "qm", "]", "*", "eflip", ")", "\n", "", "else", ":", "\n", "                ", "obs", "[", "t", "]", "=", "np", ".", "sum", "(", "(", "phi", "[", "0", ":", "pm", "]", "+", "delta", "[", "0", ":", "pm", "]", ")", "*", "yflip", ")", "+", "e", "[", "t", "]", "+", "np", ".", "sum", "(", "(", "theta", "[", "0", ":", "qm", "]", "+", "delta", "[", "p", ":", "(", "p", "+", "qm", ")", "]", ")", "*", "eflip", ")", "\n", "", "", "return", "obs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.tv_shows.shuffle_episodes": [[36, 39], ["numpy.random.seed", "numpy.random.shuffle"], "function", ["None"], ["def", "shuffle_episodes", "(", "eps", ",", "seed", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.tv_shows.load_text": [[41, 65], ["pandas.read_csv", "pandas.read_csv", "range", "tv_shows.shuffle_episodes", "pandas.concat", "range", "tv_shows.shuffle_episodes", "pandas.concat", "pd.concat.append", "pd.concat.append", "pandas.read_csv", "pandas.read_csv", "str", "str"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.application.tv_shows.shuffle_episodes", "home.repos.pwc.inspect_result.langliu95_autodetect.application.tv_shows.shuffle_episodes"], ["", "def", "load_text", "(", "i", ",", "j", ",", "seed", "=", "None", ")", ":", "\n", "    ", "path", "=", "'processed_subtitles/'", "# change path to the directory containing the dataset", "\n", "\n", "if", "seed", "is", "None", ":", "\n", "        ", "path", "=", "'../autodetect/data/subtitles/'", "\n", "show1", "=", "pd", ".", "read_csv", "(", "path", "+", "NAME", "[", "i", "]", "+", "'.txt'", ",", "sep", "=", "'\\n'", ",", "header", "=", "None", ",", "\n", "names", "=", "[", "'words'", "]", ")", "\n", "show2", "=", "pd", ".", "read_csv", "(", "path", "+", "NAME", "[", "j", "]", "+", "'.txt'", ",", "sep", "=", "'\\n'", ",", "header", "=", "None", ",", "\n", "names", "=", "[", "'words'", "]", ")", "\n", "", "else", ":", "\n", "        ", "show1", "=", "[", "]", "\n", "for", "e", "in", "range", "(", "NUM", "[", "i", "]", ")", ":", "\n", "            ", "show1", ".", "append", "(", "pd", ".", "read_csv", "(", "path", "+", "NAME", "[", "i", "]", "+", "'E'", "+", "str", "(", "e", "+", "1", ")", "+", "'.txt'", ",", "\n", "sep", "=", "'\\n'", ",", "header", "=", "None", ",", "names", "=", "[", "'words'", "]", ")", ")", "\n", "", "shuffle_episodes", "(", "show1", ",", "seed", ")", "\n", "show1", "=", "pd", ".", "concat", "(", "show1", ",", "ignore_index", "=", "True", ")", "\n", "\n", "show2", "=", "[", "]", "\n", "for", "e", "in", "range", "(", "NUM", "[", "j", "]", ")", ":", "\n", "            ", "show2", ".", "append", "(", "pd", ".", "read_csv", "(", "path", "+", "NAME", "[", "j", "]", "+", "'E'", "+", "str", "(", "e", "+", "1", ")", "+", "'.txt'", ",", "\n", "sep", "=", "'\\n'", ",", "header", "=", "None", ",", "names", "=", "[", "'words'", "]", ")", ")", "\n", "", "shuffle_episodes", "(", "show2", ",", "seed", ")", "\n", "show2", "=", "pd", ".", "concat", "(", "show2", ",", "ignore_index", "=", "True", ")", "\n", "", "return", "show1", ",", "show2", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.tv_shows.remove_infrequent": [[67, 78], ["text1.append", "text1.append.iloc[].value_counts", "len", "text1.append.words[].isin().sum", "text1.append.words[].isin", "text1.append.iloc[].isin"], "function", ["None"], ["", "def", "remove_infrequent", "(", "text1", ",", "text2", ",", "times", ")", ":", "\n", "    ", "\"\"\"Combine two pieces of text and remove infrequent words (< times)\"\"\"", "\n", "\n", "text", "=", "text1", ".", "append", "(", "text2", ",", "ignore_index", "=", "True", ")", "\n", "counts", "=", "text", ".", "iloc", "[", ":", ",", "0", "]", ".", "value_counts", "(", ")", "\n", "rare", "=", "counts", "[", "counts", "<", "times", "]", ".", "index", "\n", "# compute the length of text1 after removal", "\n", "n1", "=", "len", "(", "text1", ")", "\n", "n1", "=", "n1", "-", "text", ".", "words", "[", ":", "n1", "]", ".", "isin", "(", "rare", ")", ".", "sum", "(", ")", "\n", "text", "=", "text", "[", "~", "text", ".", "iloc", "[", ":", ",", "0", "]", ".", "isin", "(", "rare", ")", "]", "\n", "return", "text", ",", "n1", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.tv_shows.change_detection": [[80, 104], ["tv_shows.load_text", "numpy.random.seed", "tv_shows.remove_infrequent", "text.iloc[].astype", "autodetect.AutogradTopic", "autodetect.AutogradTopic.train", "numpy.arange", "numpy.arange", "range", "autodetect.AutogradTopic.compute_stats", "print", "int", "y.max", "numpy.min", "numpy.max", "numpy.sqrt", "len", "int", "int", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.application.tv_shows.load_text", "home.repos.pwc.inspect_result.langliu95_autodetect.application.tv_shows.remove_infrequent", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.topic.AutogradTopic.train", "home.repos.pwc.inspect_result.langliu95_autodetect.autodetect.autocusum.AutogradCuSum.compute_stats"], ["", "def", "change_detection", "(", "i", ",", "j", ",", "N", "=", "None", ",", "obs_per_state", "=", "100", ",", "seed", "=", "None", ")", ":", "\n", "    ", "show1", ",", "show2", "=", "load_text", "(", "i", ",", "j", ",", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "i", "*", "len", "(", "NAME", ")", "+", "j", ")", "\n", "text", ",", "n1", "=", "remove_infrequent", "(", "show1", ",", "show2", ",", "args", ".", "freq", ")", "\n", "if", "N", "is", "None", ":", "\n", "        ", "N", "=", "int", "(", "np", ".", "sqrt", "(", "len", "(", "text", ")", "/", "obs_per_state", ")", ")", "\n", "", "dchange", "=", "N", "*", "(", "N", "-", "1", ")", "\n", "text", ".", "iloc", "[", ":", ",", "0", "]", "=", "text", ".", "iloc", "[", ":", ",", "0", "]", ".", "astype", "(", "'category'", ")", "\n", "ints", "=", "text", ".", "iloc", "[", ":", ",", "0", "]", ".", "cat", ".", "codes", "\n", "y", "=", "ints", ".", "values", "\n", "M", "=", "y", ".", "max", "(", ")", "+", "1", "\n", "# embedding", "\n", "model", "=", "AutogradTopic", "(", "M", ",", "N", ")", "\n", "model", ".", "train", "(", "y", ",", "interpolation", "=", "False", ")", "\n", "# detection", "\n", "trange", "=", "np", ".", "arange", "(", "np", ".", "min", "(", "[", "int", "(", "len", "(", "y", ")", "/", "4", ")", ",", "n1", "]", ")", ",", "\n", "np", ".", "max", "(", "[", "int", "(", "len", "(", "y", ")", "/", "4", "*", "3", ")", ",", "n1", "]", ")", ",", "\n", "10", ")", "\n", "prange", "=", "np", ".", "arange", "(", "1", ",", "N", ")", "\n", "idx", "=", "range", "(", "M", "-", "N", ",", "M", "-", "N", "+", "dchange", ")", "\n", "res", "=", "model", ".", "compute_stats", "(", "y", ",", "idx", "=", "idx", ",", "prange", "=", "prange", ",", "trange", "=", "trange", ",", "\n", "stat_type", "=", "'scan'", ")", "\n", "print", "(", "res", ")", "\n", "return", "res", ",", "(", "N", ",", "M", ",", "n1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing._read_lines": [[26, 32], ["open", "f.readlines", "x.strip"], "function", ["None"], ["def", "_read_lines", "(", "path", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "out", "=", "f", ".", "readlines", "(", ")", "\n", "# remove whitespace characters like `\\n` at the end of each line", "\n", "", "out", "=", "[", "x", ".", "strip", "(", ")", "for", "x", "in", "out", "]", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing._save_lines": [[34, 38], ["open", "f.write"], "function", ["None"], ["", "def", "_save_lines", "(", "text", ",", "path", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "'w+'", ")", "as", "f", ":", "\n", "        ", "for", "item", "in", "text", ":", "\n", "            ", "f", ".", "write", "(", "f\"{item}\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.strip_html": [[45, 50], ["text.replace.replace", "text.replace.replace"], "function", ["None"], ["", "", "", "def", "strip_html", "(", "text", ")", ":", "\n", "    ", "\"\"\"Remove HTML marks.\"\"\"", "\n", "text", "=", "text", ".", "replace", "(", "\"<i>\"", ",", "''", ")", "\n", "text", "=", "text", ".", "replace", "(", "\"</i>\"", ",", "''", ")", "\n", "return", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.replace_contractions": [[52, 58], ["text.replace.replace", "text.replace.replace", "text.replace.replace", "contractions.fix"], "function", ["None"], ["", "def", "replace_contractions", "(", "text", ")", ":", "\n", "    ", "\"\"\"Replace contractions in the text.\"\"\"", "\n", "text", "=", "text", ".", "replace", "(", "\"ain't\"", ",", "'are not'", ")", "\n", "text", "=", "text", ".", "replace", "(", "\"in'\"", ",", "'ing'", ")", "\n", "text", "=", "text", ".", "replace", "(", "\"\\'cause\"", ",", "\"because\"", ")", "\n", "return", "contractions", ".", "fix", "(", "text", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_non_ascii": [[60, 64], ["unicodedata.normalize().encode().decode", "unicodedata.normalize().encode", "unicodedata.normalize"], "function", ["None"], ["", "def", "remove_non_ascii", "(", "text", ")", ":", "\n", "    ", "\"\"\"Remove non-ASCII characters in the text.\"\"\"", "\n", "new_text", "=", "unicodedata", ".", "normalize", "(", "'NFKD'", ",", "text", ")", ".", "encode", "(", "'ascii'", ",", "'ignore'", ")", ".", "decode", "(", "'utf-8'", ",", "'ignore'", ")", "\n", "return", "new_text", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_punctuation": [[66, 68], ["re.sub"], "function", ["None"], ["", "def", "remove_punctuation", "(", "text", ")", ":", "\n", "    ", "return", "re", ".", "sub", "(", "r'[^\\w\\s]'", ",", "''", ",", "text", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_stopwords": [[76, 79], ["preprocessing._read_lines"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing._read_lines"], ["", "def", "remove_stopwords", "(", "words", ")", ":", "\n", "    ", "stop_words", "=", "_read_lines", "(", "'stopwords.txt'", ")", "\n", "return", "[", "word", "for", "word", "in", "words", "if", "word", "not", "in", "stop_words", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing._convert_ordinal_num": [[81, 88], ["re.findall", "re.sub", "len"], "function", ["None"], ["", "def", "_convert_ordinal_num", "(", "word", ")", ":", "\n", "    ", "\"\"\"Convert ordinal numbers to cardinal numbers.\"\"\"", "\n", "ths", "=", "re", ".", "findall", "(", "r'\\d+st|\\d+nd|\\d+rd|\\d+th'", ",", "word", ")", "# find -st, -nd, -rd, -th", "\n", "for", "th", "in", "ths", ":", "\n", "        ", "num", "=", "th", "[", ":", "(", "len", "(", "th", ")", "-", "2", ")", "]", "\n", "word", "=", "re", ".", "sub", "(", "th", ",", "num", ",", "word", ")", "\n", "", "return", "word", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing._my_num_to_words": [[90, 99], ["inflect.engine", "inflect.engine.number_to_words", "remove_stopwords.replace", "preprocessing.remove_punctuation", "nltk.word_tokenize", "preprocessing.remove_stopwords"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_punctuation", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_stopwords"], ["", "def", "_my_num_to_words", "(", "word", ")", ":", "\n", "    ", "\"\"\"Convert numbers to their words equivalent.\"\"\"", "\n", "p", "=", "inflect", ".", "engine", "(", ")", "\n", "nums", "=", "p", ".", "number_to_words", "(", "word", ")", "\n", "nums", "=", "nums", ".", "replace", "(", "'-'", ",", "' '", ")", "\n", "nums", "=", "remove_punctuation", "(", "nums", ")", "\n", "nums", "=", "nltk", ".", "word_tokenize", "(", "nums", ")", "\n", "nums", "=", "remove_stopwords", "(", "nums", ")", "\n", "return", "nums", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.replace_numbers": [[101, 120], ["_convert_ordinal_num.isdigit", "preprocessing._my_num_to_words", "word[].isdigit", "preprocessing._convert_ordinal_num", "re.split", "new_words.append", "s.isdigit", "preprocessing._my_num_to_words", "new_words.append"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing._my_num_to_words", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing._convert_ordinal_num", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing._my_num_to_words"], ["", "def", "replace_numbers", "(", "words", ")", ":", "\n", "    ", "\"\"\"Replace numbers with their words equivalent.\"\"\"", "\n", "new_words", "=", "[", "]", "\n", "for", "word", "in", "words", ":", "\n", "        ", "if", "word", ".", "isdigit", "(", ")", ":", "# '123'", "\n", "            ", "nums", "=", "_my_num_to_words", "(", "word", ")", "\n", "new_words", "+=", "nums", "\n", "", "elif", "word", "[", "0", "]", ".", "isdigit", "(", ")", ":", "# '24inches'", "\n", "            ", "word", "=", "_convert_ordinal_num", "(", "word", ")", "\n", "seps", "=", "re", ".", "split", "(", "r'(\\d+)'", ",", "word", ")", "\n", "for", "s", "in", "seps", ":", "\n", "                ", "if", "s", ".", "isdigit", "(", ")", ":", "\n", "                    ", "nums", "=", "_my_num_to_words", "(", "s", ")", "\n", "new_words", "+=", "nums", "\n", "", "elif", "s", "!=", "''", ":", "\n", "                    ", "new_words", ".", "append", "(", "s", ")", "\n", "", "", "", "else", ":", "\n", "            ", "new_words", ".", "append", "(", "word", ")", "\n", "", "", "return", "new_words", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_numbers": [[122, 124], ["re.sub", "word[].isdigit", "word[].isdigit"], "function", ["None"], ["", "def", "remove_numbers", "(", "words", ")", ":", "\n", "    ", "return", "[", "re", ".", "sub", "(", "r'\\d+'", ",", "''", ",", "word", ")", "for", "word", "in", "words", "if", "not", "word", "[", "0", "]", ".", "isdigit", "(", ")", "and", "not", "word", "[", "-", "1", "]", ".", "isdigit", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.lemmatize_verbs": [[126, 129], ["nltk.stem.WordNetLemmatizer", "nltk.stem.WordNetLemmatizer.lemmatize"], "function", ["None"], ["", "def", "lemmatize_verbs", "(", "words", ")", ":", "\n", "    ", "lemmatizer", "=", "WordNetLemmatizer", "(", ")", "\n", "return", "[", "lemmatizer", ".", "lemmatize", "(", "word", ",", "pos", "=", "'v'", ")", "for", "word", "in", "words", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_names": [[131, 136], ["nltk.tag.stanford.StanfordNERTagger", "nltk.tag.stanford.StanfordNERTagger.tag"], "function", ["None"], ["", "def", "remove_names", "(", "words", ")", ":", "\n", "    ", "st", "=", "StanfordNERTagger", "(", "'stanford-ner/english.all.3class.distsim.crf.ser.gz'", ",", "'stanford-ner/stanford-ner.jar'", ")", "\n", "tags", "=", "st", ".", "tag", "(", "words", ")", "\n", "new_words", "=", "[", "word", "for", "(", "word", ",", "tag", ")", "in", "tags", "if", "tag", "!=", "'PERSON'", "]", "\n", "return", "new_words", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.to_lowercase": [[138, 140], ["word.lower"], "function", ["None"], ["", "def", "to_lowercase", "(", "words", ")", ":", "\n", "    ", "return", "[", "word", ".", "lower", "(", ")", "for", "word", "in", "words", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.preprocess": [[147, 167], ["preprocessing.strip_html", "preprocessing.replace_contractions", "preprocessing.remove_non_ascii", "remove_punctuation.replace", "preprocessing.remove_punctuation", "nltk.word_tokenize", "preprocessing.remove_names", "preprocessing.to_lowercase", "preprocessing.replace_numbers", "preprocessing.remove_stopwords", "preprocessing.lemmatize_verbs"], "function", ["home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.strip_html", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.replace_contractions", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_non_ascii", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_punctuation", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_names", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.to_lowercase", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.replace_numbers", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.remove_stopwords", "home.repos.pwc.inspect_result.langliu95_autodetect.application.preprocessing.lemmatize_verbs"], ["", "def", "preprocess", "(", "text", ")", ":", "\n", "    ", "\"\"\"Preprocesse text data.\n\n    Including removing HTML marks, replacing contractions with their original\n    forms, removing non-ASCII characters, removing punctuations, tokenizing text\n    into words, remove person names, converting to lower case letters, replacing numbers with\n    their words equivalent, removing stopwords, and lemmatizing verbs.\n    \"\"\"", "\n", "text", "=", "strip_html", "(", "text", ")", "\n", "text", "=", "replace_contractions", "(", "text", ")", "\n", "text", "=", "remove_non_ascii", "(", "text", ")", "\n", "text", "=", "text", ".", "replace", "(", "'-'", ",", "' '", ")", "\n", "text", "=", "remove_punctuation", "(", "text", ")", "\n", "words", "=", "nltk", ".", "word_tokenize", "(", "text", ")", "# tokenization", "\n", "words", "=", "remove_names", "(", "words", ")", "\n", "words", "=", "to_lowercase", "(", "words", ")", "\n", "words", "=", "replace_numbers", "(", "words", ")", "\n", "words", "=", "remove_stopwords", "(", "words", ")", "\n", "words", "=", "lemmatize_verbs", "(", "words", ")", "\n", "return", "words", "\n", "\n"]]}