{"home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSequence.from_tree": [[13, 29], ["tetra_tag.tree_to_tags_helper", "cls", "len", "len"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.tree_to_tags_helper"], ["@", "classmethod", "\n", "def", "from_tree", "(", "\n", "cls", ",", "\n", "tree", ",", "\n", "is_right_branch", "=", "False", ",", "\n", "ignore_labels", "=", "default_ignore_labels", ",", "\n", "right_branching_binarization", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Construct a TetraTagSequence from an nltk.Tree object.\"\"\"", "\n", "internal_tags", ",", "leaf_tags", "=", "tree_to_tags_helper", "(", "\n", "tree", ",", "is_right_branch", ",", "ignore_labels", ",", "right_branching_binarization", "\n", ")", "\n", "res", "=", "[", "None", "]", "*", "(", "len", "(", "internal_tags", ")", "+", "len", "(", "leaf_tags", ")", ")", "\n", "res", "[", ":", ":", "2", "]", "=", "leaf_tags", "\n", "res", "[", "1", ":", ":", "2", "]", "=", "internal_tags", "\n", "return", "cls", "(", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSequence.to_tree": [[30, 44], ["tetra_tag.tags_to_tree_helper", "nltk.Tree", "tags_to_tree_helper.convert"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.tags_to_tree_helper", "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.convert"], ["", "def", "to_tree", "(", "self", ",", "leaf_nodes", ",", "top_label", "=", "\"TOP\"", ")", ":", "\n", "        ", "\"\"\"Convert this sequence of tags to a tree.\n\n        Args:\n          leaf_nodes: The leaf nodes for the words in a sentence, which may be\n            strings or nltk.Tree objects that each consist of a part-of-speech\n            tag and a word.\n          top_label: label for the root node of the created tree\n\n        Returns:\n          An nltk.Tree object.\n        \"\"\"", "\n", "tree_fragment", "=", "tags_to_tree_helper", "(", "self", ",", "leaf_nodes", ")", "\n", "return", "nltk", ".", "Tree", "(", "top_label", ",", "tree_fragment", ".", "convert", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.__init__": [[49, 99], ["len", "len", "numpy.concatenate", "numpy.asarray", "numpy.asarray", "enumerate", "numpy.array", "len", "tag.startswith", "ValueError", "set", "sorted", "numpy.zeros", "numpy.ones", "tag.startswith", "tetra_tag.TetraTagSequence.from_tree", "set.add"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSequence.from_tree"], ["def", "__init__", "(", "self", ",", "tag_vocab", "=", "None", ",", "trees", "=", "None", ")", ":", "\n", "        ", "\"\"\"Constructs a new TetraTagSystem object.\n\n        Args:\n          tag_vocab: (optional) A list of all possible tags.\n          trees: (optional) An iterable of nltk.Tree objects. If tag_vocab is\n            None, a new tag vocabulary will be constructed by iterating these\n            trees.\n        \"\"\"", "\n", "if", "tag_vocab", "is", "not", "None", ":", "\n", "            ", "self", ".", "tag_vocab", "=", "tag_vocab", "\n", "", "elif", "trees", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Need either tag_vocab or trees\"", ")", "\n", "", "else", ":", "\n", "# Construct tag inventory", "\n", "            ", "tag_vocab", "=", "set", "(", ")", "\n", "for", "tree", "in", "trees", ":", "\n", "                ", "for", "tag", "in", "TetraTagSequence", ".", "from_tree", "(", "tree", ")", ":", "\n", "                    ", "tag_vocab", ".", "add", "(", "tag", ")", "\n", "", "", "self", ".", "tag_vocab", "=", "sorted", "(", "tag_vocab", ")", "\n", "\n", "", "self", ".", "internal_tag_vocab_size", "=", "len", "(", "\n", "[", "tag", "for", "tag", "in", "self", ".", "tag_vocab", "if", "tag", "[", "0", "]", "in", "\"LR\"", "]", "\n", ")", "\n", "self", ".", "leaf_tag_vocab_size", "=", "len", "(", "\n", "[", "tag", "for", "tag", "in", "self", ".", "tag_vocab", "if", "tag", "[", "0", "]", "in", "\"lr\"", "]", "\n", ")", "\n", "\n", "is_leaf_mask", "=", "np", ".", "concatenate", "(", "\n", "[", "\n", "np", ".", "zeros", "(", "self", ".", "internal_tag_vocab_size", ")", ",", "\n", "np", ".", "ones", "(", "self", ".", "leaf_tag_vocab_size", ")", ",", "\n", "]", "\n", ")", "\n", "self", ".", "_internal_tags_only", "=", "np", ".", "asarray", "(", "-", "1e9", "*", "is_leaf_mask", ",", "dtype", "=", "float", ")", "\n", "self", ".", "_leaf_tags_only", "=", "np", ".", "asarray", "(", "\n", "-", "1e9", "*", "(", "1", "-", "is_leaf_mask", ")", ",", "dtype", "=", "float", "\n", ")", "\n", "\n", "stack_depth_change_by_id", "=", "[", "None", "]", "*", "len", "(", "self", ".", "tag_vocab", ")", "\n", "for", "i", ",", "tag", "in", "enumerate", "(", "self", ".", "tag_vocab", ")", ":", "\n", "            ", "if", "tag", ".", "startswith", "(", "\"l\"", ")", ":", "\n", "                ", "stack_depth_change_by_id", "[", "i", "]", "=", "+", "1", "\n", "", "elif", "tag", ".", "startswith", "(", "\"R\"", ")", ":", "\n", "                ", "stack_depth_change_by_id", "[", "i", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "                ", "stack_depth_change_by_id", "[", "i", "]", "=", "0", "\n", "", "", "assert", "None", "not", "in", "stack_depth_change_by_id", "\n", "self", ".", "_stack_depth_change_by_id", "=", "np", ".", "array", "(", "\n", "stack_depth_change_by_id", ",", "dtype", "=", "np", ".", "int32", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.tags_from_tree": [[101, 104], ["tetra_tag.TetraTagSequence.from_tree"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSequence.from_tree"], ["", "def", "tags_from_tree", "(", "self", ",", "tree", ")", ":", "\n", "        ", "\"\"\"Returns a TetraTagSequence object given an nltk.Tree object.\"\"\"", "\n", "return", "TetraTagSequence", ".", "from_tree", "(", "tree", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.ids_from_tree": [[105, 129], ["tetra_tag.TetraTagSystem.tag_vocab.index", "tetra_tag.TetraTagSystem.tag_vocab.index", "tetra_tag.TetraTagSystem.tag_vocab.index", "tetra_tag.TetraTagSystem.tags_from_tree", "tetra_tag.TetraTagSystem.tags_from_tree"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.tags_from_tree", "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.tags_from_tree"], ["", "def", "ids_from_tree", "(", "self", ",", "tree", ",", "ignore_unknown", "=", "True", ")", ":", "\n", "        ", "\"\"\"Returns a list of label ids given a tree.\n\n        Args:\n          tree: An nltk.Tree object\n          ignore_unknown: If set to True (the default), syntactic categories\n            that can't be represented using the tag vocabulary will be collapsed\n            out. If set to False, trees that can't be represented exactly will\n            lead to an exception being thrown.\n\n        Returns:\n          A list of integer tag ids\n        \"\"\"", "\n", "if", "not", "ignore_unknown", ":", "\n", "            ", "return", "[", "\n", "self", ".", "tag_vocab", ".", "index", "(", "tag", ")", "for", "tag", "in", "self", ".", "tags_from_tree", "(", "tree", ")", "\n", "]", "\n", "", "return", "[", "\n", "(", "\n", "self", ".", "tag_vocab", ".", "index", "(", "tag", ")", "\n", "if", "tag", "in", "self", ".", "tag_vocab", "\n", "else", "self", ".", "tag_vocab", ".", "index", "(", "tag", "[", "0", "]", ")", "\n", ")", "\n", "for", "tag", "in", "self", ".", "tags_from_tree", "(", "tree", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.tree_from_tags": [[131, 149], ["tetra_tag.TetraTagSequence.to_tree", "ValueError", "tetra_tag.TetraTagSequence", "nltk.Tree"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSequence.to_tree"], ["", "def", "tree_from_tags", "(", "self", ",", "tags", ",", "leaf_nodes", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "\"\"\"Constructs a tree from a tag sequence.\n\n        Args:\n          tags: an iterable of tetra-tags\n          leaf_nodes: the leaf nodes to use in the constructed tree\n          pos: a list of (word, tag) tuples. If leaf_nodes is None, these will\n            be used to construct the leaf nodes in the tree.\n\n        Returns:\n          An nltk.Tree object.\n        \"\"\"", "\n", "if", "leaf_nodes", "is", "None", "and", "pos", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Either leaf_nodes or pos argument is required.\"", ")", "\n", "", "elif", "leaf_nodes", "is", "None", "and", "pos", "is", "not", "None", ":", "\n", "            ", "leaf_nodes", "=", "[", "nltk", ".", "Tree", "(", "tag", ",", "[", "word", "]", ")", "for", "word", ",", "tag", "in", "pos", "]", "\n", "", "tree", "=", "TetraTagSequence", "(", "tags", ")", ".", "to_tree", "(", "leaf_nodes", ")", "\n", "return", "tree", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.tree_from_ids": [[150, 166], ["tetra_tag.TetraTagSystem.tree_from_tags", "tags[].startswith", "len"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.tree_from_tags"], ["", "def", "tree_from_ids", "(", "self", ",", "ids", ",", "leaf_nodes", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "\"\"\"Constructs a tree from a tag id sequence.\n\n        Args:\n          ids: an iterable of integer tag ids\n          leaf_nodes: the leaf nodes to use in the constructed tree\n          pos: a list of (word, tag) tuples. If leaf_nodes is None, these will\n            be used to construct the leaf nodes in the tree.\n\n        Returns:\n          An nltk.Tree object.\n        \"\"\"", "\n", "tags", "=", "[", "self", ".", "tag_vocab", "[", "tag_id", "]", "for", "tag_id", "in", "ids", "]", "\n", "if", "len", "(", "tags", ")", "==", "1", "and", "tags", "[", "0", "]", ".", "startswith", "(", "\"r\"", ")", ":", "\n", "            ", "tags", "=", "[", "\"l\"", "+", "tags", "[", "0", "]", "[", "1", ":", "]", "]", "\n", "", "return", "self", ".", "tree_from_tags", "(", "tags", ",", "leaf_nodes", "=", "leaf_nodes", ",", "pos", "=", "pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.tree_from_logits": [[167, 186], ["tetra_tag.TetraTagSystem.ids_from_logits", "tetra_tag.TetraTagSystem.tree_from_ids"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.ids_from_logits", "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.tree_from_ids"], ["", "def", "tree_from_logits", "(", "self", ",", "logits", ",", "mask", "=", "None", ",", "leaf_nodes", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "\"\"\"Constructs a tree from a table of logits.\n\n        Args:\n          logits: a numpy array of shape (length, tag_vocab_size)\n          mask: (optional) a boolean numpy array of shape (length,). Only logits\n            corresponding to True entries in the mask will be used. This\n            argument may be useful for models that use subword tokenization or\n            padding, where not every output location requires a labeling\n            decision.\n          leaf_nodes: the leaf nodes to use in the constructed tree\n          pos: a list of (word, tag) tuples. If leaf_nodes is None, these will\n            be used to construct the leaf nodes in the tree.\n\n        Returns:\n          An nltk.Tree object.\n        \"\"\"", "\n", "tag_ids", "=", "self", ".", "ids_from_logits", "(", "logits", ",", "mask", ")", "\n", "return", "self", ".", "tree_from_ids", "(", "tag_ids", ",", "leaf_nodes", "=", "leaf_nodes", ",", "pos", "=", "pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.TetraTagSystem.ids_from_logits": [[187, 221], ["tetra_tag.BeamSearch", "range", "tetra_tag.BeamSearch.get_path", "tetra_tag.BeamSearch.advance", "tetra_tag.BeamSearch.advance"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.BeamSearch.get_path", "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.BeamSearch.advance", "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.BeamSearch.advance"], ["", "def", "ids_from_logits", "(", "self", ",", "logits", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"Returns the tag ids for the highest-scoring tree given logits.\n\n        Args:\n          logits: a numpy array of shape (length, tag_vocab_size)\n        mask: (optional) a boolean numpy array of shape (length,). Only logits\n          corresponding to True entries in the mask will be used. This\n          argument may be useful for models that use subword tokenization or\n          padding, where not every output location requires a labeling\n          decision.\n\n        Returns:\n          A list of integer tag ids\n        \"\"\"", "\n", "beam_search", "=", "BeamSearch", "(", "\n", "initial_stack_depth", "=", "0", ",", "\n", "stack_depth_change_by_id", "=", "self", ".", "_stack_depth_change_by_id", ",", "\n", "max_depth", "=", "12", ",", "\n", "keep_per_depth", "=", "1", ",", "\n", ")", "\n", "\n", "last_t", "=", "None", "\n", "for", "t", "in", "range", "(", "logits", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "mask", "is", "not", "None", "and", "not", "mask", "[", "t", "]", ":", "\n", "                ", "continue", "\n", "", "if", "last_t", "is", "not", "None", ":", "\n", "                ", "beam_search", ".", "advance", "(", "\n", "logits", "[", "last_t", ",", ":", "]", "+", "self", ".", "_internal_tags_only", "\n", ")", "\n", "", "beam_search", ".", "advance", "(", "logits", "[", "t", ",", ":", "]", "+", "self", ".", "_leaf_tags_only", ")", "\n", "last_t", "=", "t", "\n", "\n", "", "score", ",", "best_tag_ids", "=", "beam_search", ".", "get_path", "(", ")", "\n", "return", "best_tag_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.LeafStackElement.__init__": [[298, 302], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "node", ")", ":", "\n", "        ", "self", ".", "node", "=", "node", "\n", "self", ".", "label", "=", "(", ")", "\n", "self", ".", "valency", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.LeafStackElement.set_label": [[303, 305], ["tuple"], "methods", ["None"], ["", "def", "set_label", "(", "self", ",", "label", ")", ":", "\n", "        ", "self", ".", "label", "=", "tuple", "(", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.LeafStackElement.fill_valency": [[306, 308], ["ValueError"], "methods", ["None"], ["", "def", "fill_valency", "(", "self", ",", "other", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"No valency to fill!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.LeafStackElement.convert": [[309, 314], ["reversed", "nltk.Tree"], "methods", ["None"], ["", "def", "convert", "(", "self", ")", ":", "\n", "        ", "node", "=", "self", ".", "node", "\n", "for", "sublabel", "in", "reversed", "(", "self", ".", "label", ")", ":", "\n", "            ", "node", "=", "nltk", ".", "Tree", "(", "sublabel", ",", "[", "node", "]", ")", "\n", "", "return", "[", "node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.__init__": [[317, 334], ["isinstance", "isinstance"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "left_child", ",", "right_child", ")", ":", "\n", "        ", "assert", "isinstance", "(", "left_child", ",", "StackElement", ")", "\n", "assert", "left_child", ".", "valency", "is", "None", "\n", "\n", "self", ".", "label", "=", "(", ")", "\n", "\n", "self", ".", "left_child", "=", "left_child", "\n", "if", "right_child", "is", "None", ":", "\n", "            ", "self", ".", "right_child_cell", "=", "[", "None", "]", "\n", "self", ".", "valency", "=", "self", ".", "right_child_cell", "\n", "", "elif", "isinstance", "(", "right_child", ",", "StackElement", ")", ":", "\n", "            ", "self", ".", "right_child_cell", "=", "[", "right_child", "]", "\n", "self", ".", "valency", "=", "right_child", ".", "valency", "\n", "right_child", ".", "valency", "=", "None", "\n", "", "else", ":", "\n", "            ", "self", ".", "right_child_cell", "=", "[", "right_child", "]", "\n", "self", ".", "valency", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.set_label": [[335, 337], ["tuple"], "methods", ["None"], ["", "", "def", "set_label", "(", "self", ",", "label", ")", ":", "\n", "        ", "self", ".", "label", "=", "tuple", "(", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.fill_valency": [[338, 343], ["None"], "methods", ["None"], ["", "def", "fill_valency", "(", "self", ",", "other", ")", ":", "\n", "        ", "assert", "self", ".", "valency", "is", "not", "None", "\n", "self", ".", "valency", "[", "0", "]", "=", "other", "\n", "self", ".", "valency", "=", "other", ".", "valency", "\n", "other", ".", "valency", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.convert": [[344, 354], ["tetra_tag.InternalStackElement.left_child.convert", "tetra_tag.InternalStackElement.right_child_cell[].convert", "reversed", "nltk.Tree"], "methods", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.convert", "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.convert"], ["", "def", "convert", "(", "self", ")", ":", "\n", "        ", "assert", "self", ".", "valency", "is", "None", "\n", "assert", "self", ".", "right_child_cell", "[", "0", "]", "is", "not", "None", "\n", "\n", "res", "=", "[", "]", "\n", "res", "+=", "self", ".", "left_child", ".", "convert", "(", ")", "\n", "res", "+=", "self", ".", "right_child_cell", "[", "0", "]", ".", "convert", "(", ")", "\n", "for", "sublabel", "in", "reversed", "(", "self", ".", "label", ")", ":", "\n", "            ", "res", "=", "[", "nltk", ".", "Tree", "(", "sublabel", ",", "res", ")", "]", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.Beam.__init__": [[390, 396], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "scores", ",", "stack_depths", ",", "prev", ",", "backptrs", ",", "labels", ")", ":", "\n", "        ", "self", ".", "scores", "=", "scores", "\n", "self", ".", "stack_depths", "=", "stack_depths", "\n", "self", ".", "prev", "=", "prev", "\n", "self", ".", "backptrs", "=", "backptrs", "\n", "self", ".", "labels", "=", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.BeamSearch.__init__": [[399, 419], ["numpy.arange", "numpy.zeros", "numpy.full", "tetra_tag.Beam", "numpy.full"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "initial_stack_depth", ",", "\n", "stack_depth_change_by_id", ",", "\n", "max_depth", "=", "12", ",", "\n", "keep_per_depth", "=", "1", ",", "\n", "initial_label", "=", "None", ",", "\n", ")", ":", "\n", "# Save parameters", "\n", "        ", "self", ".", "stack_depth_change_by_id", "=", "stack_depth_change_by_id", "\n", "self", ".", "valid_depths", "=", "np", ".", "arange", "(", "1", ",", "max_depth", ")", "\n", "self", ".", "keep_per_depth", "=", "keep_per_depth", "\n", "\n", "# Initialize the beam", "\n", "scores", "=", "np", ".", "zeros", "(", "1", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "stack_depths", "=", "np", ".", "full", "(", "1", ",", "initial_stack_depth", ")", "\n", "prev", "=", "backptrs", "=", "labels", "=", "None", "\n", "if", "initial_label", "is", "not", "None", ":", "\n", "            ", "labels", "=", "np", ".", "full", "(", "1", ",", "initial_label", ")", "\n", "", "self", ".", "beam", "=", "Beam", "(", "scores", ",", "stack_depths", ",", "prev", ",", "backptrs", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.BeamSearch.advance": [[420, 452], ["masked_scores.reshape.reshape.reshape", "[].flatten", "numpy.unravel_index", "tetra_tag.Beam", "numpy.where", "tetra_tag.BeamSearch.valid_depths.repeat", "numpy.argsort"], "methods", ["None"], ["", "def", "advance", "(", "self", ",", "label_logits", ")", ":", "\n", "        ", "label_log_probs", "=", "label_logits", "\n", "\n", "all_new_scores", "=", "self", ".", "beam", ".", "scores", "[", ":", ",", "None", "]", "+", "label_log_probs", "\n", "all_new_stack_depths", "=", "(", "\n", "self", ".", "beam", ".", "stack_depths", "[", ":", ",", "None", "]", "\n", "+", "self", ".", "stack_depth_change_by_id", "[", "None", ",", ":", "]", "\n", ")", "\n", "\n", "masked_scores", "=", "all_new_scores", "[", "None", ",", ":", ",", ":", "]", "+", "np", ".", "where", "(", "\n", "all_new_stack_depths", "[", "None", ",", ":", ",", ":", "]", "\n", "==", "self", ".", "valid_depths", "[", ":", ",", "None", ",", "None", "]", ",", "\n", "0.0", ",", "\n", "-", "np", ".", "inf", ",", "\n", ")", "\n", "masked_scores", "=", "masked_scores", ".", "reshape", "(", "self", ".", "valid_depths", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "idxs", "=", "np", ".", "argsort", "(", "-", "masked_scores", ")", "[", ":", ",", ":", "self", ".", "keep_per_depth", "]", ".", "flatten", "(", ")", "\n", "backptrs", ",", "labels", "=", "np", ".", "unravel_index", "(", "idxs", ",", "all_new_scores", ".", "shape", ")", "\n", "\n", "transition_valid", "=", "all_new_stack_depths", "[", "\n", "backptrs", ",", "labels", "\n", "]", "==", "self", ".", "valid_depths", ".", "repeat", "(", "self", ".", "keep_per_depth", ")", "\n", "\n", "backptrs", "=", "backptrs", "[", "transition_valid", "]", "\n", "labels", "=", "labels", "[", "transition_valid", "]", "\n", "\n", "self", ".", "beam", "=", "Beam", "(", "\n", "all_new_scores", "[", "backptrs", ",", "labels", "]", ",", "\n", "all_new_stack_depths", "[", "backptrs", ",", "labels", "]", ",", "\n", "self", ".", "beam", ",", "\n", "backptrs", ",", "\n", "labels", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.BeamSearch.get_path": [[454, 468], ["label_idxs.insert"], "methods", ["None"], ["", "def", "get_path", "(", "self", ",", "idx", "=", "0", ",", "required_stack_depth", "=", "1", ")", ":", "\n", "        ", "if", "required_stack_depth", "is", "not", "None", ":", "\n", "            ", "assert", "self", ".", "beam", ".", "stack_depths", "[", "idx", "]", "==", "required_stack_depth", "\n", "", "score", "=", "self", ".", "beam", ".", "scores", "[", "idx", "]", "\n", "assert", "score", ">", "-", "np", ".", "inf", "\n", "\n", "beam", "=", "self", ".", "beam", "\n", "label_idxs", "=", "[", "]", "\n", "while", "beam", ".", "prev", "is", "not", "None", ":", "\n", "            ", "label_idxs", ".", "insert", "(", "0", ",", "beam", ".", "labels", "[", "idx", "]", ")", "\n", "idx", "=", "beam", ".", "backptrs", "[", "idx", "]", "\n", "beam", "=", "beam", ".", "prev", "\n", "\n", "", "return", "score", ",", "label_idxs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.tree_to_tags_helper": [[226, 291], ["isinstance", "enumerate", "isinstance", "isinstance", "len", "tetra_tag.tree_to_tags_helper", "tree.label", "tree.label", "len", "tree.label", "sublabels.append", "len", "isinstance", "isinstance", "internal_tags.append", "tree.label", "len", "len"], "function", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.tree_to_tags_helper"], ["", "", "def", "tree_to_tags_helper", "(", "\n", "tree", ",", "\n", "is_right_branch", "=", "False", ",", "\n", "ignore_labels", "=", "(", ")", ",", "\n", "right_branching_binarization", "=", "True", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Helper function for converting a tree to a tag sequence.\"\"\"", "\n", "if", "not", "isinstance", "(", "tree", ",", "nltk", ".", "Tree", ")", ":", "\n", "        ", "tag", "=", "f\"r\"", "if", "is_right_branch", "else", "f\"l\"", "\n", "return", "[", "]", ",", "[", "tag", "]", "\n", "\n", "", "sublabels", "=", "[", "tree", ".", "label", "(", ")", "]", "if", "tree", ".", "label", "(", ")", "not", "in", "ignore_labels", "else", "[", "]", "\n", "while", "len", "(", "tree", ")", "==", "1", "and", "isinstance", "(", "tree", "[", "0", "]", ",", "nltk", ".", "Tree", ")", ":", "\n", "        ", "tree", "=", "tree", "[", "0", "]", "\n", "if", "tree", ".", "label", "(", ")", "not", "in", "ignore_labels", ":", "\n", "            ", "sublabels", ".", "append", "(", "tree", ".", "label", "(", ")", ")", "\n", "\n", "", "", "if", "len", "(", "tree", ")", "==", "1", "and", "not", "isinstance", "(", "tree", "[", "0", "]", ",", "nltk", ".", "Tree", ")", ":", "\n", "        ", "sublabels", "=", "sublabels", "[", ":", "-", "1", "]", "# Strip POS tag", "\n", "\n", "", "if", "sublabels", ":", "\n", "        ", "label", "=", "\"/\"", "+", "\"/\"", ".", "join", "(", "sublabels", ")", "\n", "", "else", ":", "\n", "        ", "label", "=", "\"\"", "\n", "\n", "", "if", "len", "(", "tree", ")", "==", "1", ":", "\n", "        ", "child", "=", "tree", "[", "0", "]", "\n", "assert", "not", "isinstance", "(", "child", ",", "nltk", ".", "Tree", ")", "\n", "tag", "=", "f\"r{label}\"", "if", "is_right_branch", "else", "f\"l{label}\"", "\n", "return", "[", "]", ",", "[", "tag", "]", "\n", "\n", "", "assert", "isinstance", "(", "tree", ",", "nltk", ".", "Tree", ")", "\n", "\n", "internal_tags", "=", "[", "]", "\n", "leaf_tags", "=", "[", "]", "\n", "for", "i", ",", "child", "in", "enumerate", "(", "tree", ")", ":", "\n", "        ", "is_first_child", "=", "i", "==", "0", "\n", "is_last_child", "=", "i", "==", "len", "(", "tree", ")", "-", "1", "\n", "if", "right_branching_binarization", ":", "\n", "            ", "child_is_right_branch", "=", "is_last_child", "\n", "", "else", ":", "\n", "            ", "child_is_right_branch", "=", "not", "is_first_child", "\n", "\n", "", "child_internal_tags", ",", "child_leaf_tags", "=", "tree_to_tags_helper", "(", "\n", "child", ",", "\n", "is_right_branch", "=", "child_is_right_branch", ",", "\n", "ignore_labels", "=", "ignore_labels", ",", "\n", "right_branching_binarization", "=", "right_branching_binarization", ",", "\n", ")", "\n", "internal_tags", "+=", "child_internal_tags", "\n", "leaf_tags", "+=", "child_leaf_tags", "\n", "if", "not", "is_last_child", ":", "\n", "            ", "if", "right_branching_binarization", ":", "\n", "                ", "if", "i", "==", "0", ":", "\n", "                    ", "action", "=", "f\"R{label}\"", "if", "is_right_branch", "else", "f\"L{label}\"", "\n", "", "else", ":", "\n", "                    ", "action", "=", "\"R\"", "\n", "", "", "else", ":", "\n", "                ", "if", "i", "==", "len", "(", "tree", ".", "children", ")", "-", "2", ":", "\n", "                    ", "action", "=", "f\"R{label}\"", "if", "is_right_branch", "else", "f\"L{label}\"", "\n", "", "else", ":", "\n", "                    ", "action", "=", "\"L\"", "\n", "", "", "internal_tags", ".", "append", "(", "action", ")", "\n", "\n", "", "", "return", "internal_tags", ",", "leaf_tags", "\n", "\n"]], "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.tags_to_tree_helper": [[356, 384], ["tags[].startswith", "all", "all", "tags[].startswith", "tetra_tag.LeafStackElement", "tag.startswith", "tetra_tag.InternalStackElement.set_label", "len", "len", "len", "len", "leaf_nodes.pop", "stack.append", "tag.startswith", "t.startswith", "t.startswith", "t.startswith", "t.startswith", "leaf_nodes.pop", "stack[].fill_valency", "tag.startswith", "tag.split", "tetra_tag.InternalStackElement", "tag.startswith", "tetra_tag.InternalStackElement", "stack[].fill_valency", "len", "stack.pop"], "function", ["home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.set_label", "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.fill_valency", "home.repos.pwc.inspect_result.nikitakit_tetra-tagging.None.tetra_tag.InternalStackElement.fill_valency"], ["", "", "def", "tags_to_tree_helper", "(", "tags", ",", "leaf_nodes", ")", ":", "\n", "    ", "assert", "len", "(", "tags", ")", "%", "2", "==", "1", ",", "\"Number of actions must be odd\"", "\n", "assert", "tags", "[", "0", "]", ".", "startswith", "(", "\"l\"", ")", "\n", "assert", "len", "(", "tags", ")", "==", "1", "or", "tags", "[", "-", "1", "]", ".", "startswith", "(", "\"r\"", ")", "\n", "assert", "all", "(", "[", "(", "t", ".", "startswith", "(", "\"l\"", ")", "or", "t", ".", "startswith", "(", "\"r\"", ")", ")", "for", "t", "in", "tags", "[", ":", ":", "2", "]", "]", ")", "\n", "assert", "all", "(", "[", "(", "t", ".", "startswith", "(", "\"L\"", ")", "or", "t", ".", "startswith", "(", "\"R\"", ")", ")", "for", "t", "in", "tags", "[", "1", ":", ":", "2", "]", "]", ")", "\n", "\n", "leaf_nodes", "=", "[", "LeafStackElement", "(", "leaf", ")", "for", "leaf", "in", "leaf_nodes", "]", "\n", "\n", "stack", "=", "[", "]", "\n", "for", "tag", "in", "tags", ":", "\n", "        ", "if", "tag", ".", "startswith", "(", "\"l\"", ")", ":", "\n", "            ", "node", "=", "leaf_nodes", ".", "pop", "(", "0", ")", "\n", "stack", ".", "append", "(", "node", ")", "\n", "", "elif", "tag", ".", "startswith", "(", "\"r\"", ")", ":", "\n", "            ", "node", "=", "leaf_nodes", ".", "pop", "(", "0", ")", "\n", "stack", "[", "-", "1", "]", ".", "fill_valency", "(", "node", ")", "\n", "", "elif", "tag", ".", "startswith", "(", "\"L\"", ")", ":", "\n", "            ", "node", "=", "InternalStackElement", "(", "stack", "[", "-", "1", "]", ",", "None", ")", "\n", "stack", "[", "-", "1", "]", "=", "node", "\n", "", "elif", "tag", ".", "startswith", "(", "\"R\"", ")", ":", "\n", "            ", "assert", "len", "(", "stack", ")", ">", "1", "\n", "node", "=", "InternalStackElement", "(", "stack", ".", "pop", "(", ")", ",", "None", ")", "\n", "stack", "[", "-", "1", "]", ".", "fill_valency", "(", "node", ")", "\n", "", "node", ".", "set_label", "(", "tag", ".", "split", "(", "\"/\"", ")", "[", "1", ":", "]", ")", "\n", "\n", "", "assert", "len", "(", "stack", ")", "==", "1", ",", "\"Bad final stack size: {}\"", ".", "format", "(", "len", "(", "stack", ")", ")", "\n", "return", "stack", "[", "0", "]", "\n", "\n"]]}