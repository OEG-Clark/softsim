{"home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.None.code_template.calc_score": [[76, 96], ["None"], "function", ["None"], ["def", "calc_score", "(", "state", ")", ":", "\n", "\t", "\"\"\"\n\tReward function for your problem.\n\n    Input: a 0-1 vector of length DECISIONS. It represents the graph (or other object) you have created.\n\n    Output: the reward/score for your construction. See files in the *demos* folder for examples.\t\n\t\"\"\"", "\n", "\n", "\n", "#", "\n", "#", "\n", "#", "\n", "# -----Your code goes here-----", "\n", "#", "\n", "#", "\n", "#", "\n", "\n", "\n", "return", "reward", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.None.code_template.play_game": [[103, 129], ["range", "numpy.random.rand", "jitted_calc_score"], "function", ["None"], ["def", "play_game", "(", "n_sessions", ",", "actions", ",", "state_next", ",", "states", ",", "prob", ",", "step", ",", "total_score", ")", ":", "\n", "\n", "\t", "for", "i", "in", "range", "(", "n_sessions", ")", ":", "\n", "\n", "\t\t", "if", "np", ".", "random", ".", "rand", "(", ")", "<", "prob", "[", "i", "]", ":", "\n", "\t\t\t", "action", "=", "1", "\n", "", "else", ":", "\n", "\t\t\t", "action", "=", "0", "\n", "", "actions", "[", "i", "]", "[", "step", "-", "1", "]", "=", "action", "\n", "state_next", "[", "i", "]", "=", "states", "[", "i", ",", ":", ",", "step", "-", "1", "]", "\n", "\n", "if", "(", "action", ">", "0", ")", ":", "\n", "\t\t\t", "state_next", "[", "i", "]", "[", "step", "-", "1", "]", "=", "action", "\n", "", "state_next", "[", "i", "]", "[", "DECISIONS", "+", "step", "-", "1", "]", "=", "0", "\n", "if", "(", "step", "<", "DECISIONS", ")", ":", "\n", "\t\t\t", "state_next", "[", "i", "]", "[", "DECISIONS", "+", "step", "]", "=", "1", "\n", "#calculate final score", "\n", "", "terminal", "=", "step", "==", "DECISIONS", "\n", "if", "terminal", ":", "\n", "\t\t\t", "total_score", "[", "i", "]", "=", "jitted_calc_score", "(", "state_next", "[", "i", "]", ")", "\n", "\n", "# record sessions ", "\n", "", "if", "not", "terminal", ":", "\n", "\t\t\t", "states", "[", "i", ",", ":", ",", "step", "]", "=", "state_next", "[", "i", "]", "\n", "\n", "", "", "return", "actions", ",", "state_next", ",", "states", ",", "total_score", ",", "terminal", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.None.code_template.generate_session": [[132, 163], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "time.time", "agent.predict", "time.time", "jitted_play_game", "print", "time.time", "time.time", "str", "str"], "function", ["None"], ["def", "generate_session", "(", "agent", ",", "n_sessions", ",", "verbose", "=", "1", ")", ":", "\n", "\t", "\"\"\"\n\tPlay n_session games using agent neural network.\n\tTerminate when games finish \n\t\n\tCode inspired by https://github.com/yandexdataschool/Practical_RL/blob/master/week01_intro/deep_crossentropy_method.ipynb\n\t\"\"\"", "\n", "states", "=", "np", ".", "zeros", "(", "[", "n_sessions", ",", "observation_space", ",", "len_game", "]", ",", "dtype", "=", "int", ")", "\n", "actions", "=", "np", ".", "zeros", "(", "[", "n_sessions", ",", "len_game", "]", ",", "dtype", "=", "int", ")", "\n", "state_next", "=", "np", ".", "zeros", "(", "[", "n_sessions", ",", "observation_space", "]", ",", "dtype", "=", "int", ")", "\n", "prob", "=", "np", ".", "zeros", "(", "n_sessions", ")", "\n", "states", "[", ":", ",", "DECISIONS", ",", "0", "]", "=", "1", "\n", "step", "=", "0", "\n", "total_score", "=", "np", ".", "zeros", "(", "[", "n_sessions", "]", ")", "\n", "pred_time", "=", "0", "\n", "play_time", "=", "0", "\n", "\n", "while", "(", "True", ")", ":", "\n", "\t\t", "step", "+=", "1", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "prob", "=", "agent", ".", "predict", "(", "states", "[", ":", ",", ":", ",", "step", "-", "1", "]", ",", "batch_size", "=", "n_sessions", ")", "\n", "pred_time", "+=", "time", ".", "time", "(", ")", "-", "tic", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "actions", ",", "state_next", ",", "states", ",", "total_score", ",", "terminal", "=", "jitted_play_game", "(", "n_sessions", ",", "actions", ",", "state_next", ",", "states", ",", "prob", ",", "step", ",", "total_score", ")", "\n", "play_time", "+=", "time", ".", "time", "(", ")", "-", "tic", "\n", "\n", "if", "terminal", ":", "\n", "\t\t\t", "break", "\n", "", "", "if", "(", "verbose", ")", ":", "\n", "\t\t", "print", "(", "\"Predict: \"", "+", "str", "(", "pred_time", ")", "+", "\", play: \"", "+", "str", "(", "play_time", ")", ")", "\n", "", "return", "states", ",", "actions", ",", "total_score", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.None.code_template.select_elites": [[165, 194], ["numpy.percentile", "range", "numpy.array", "numpy.array", "len", "np.array.append", "np.array.append", "item.tolist"], "function", ["None"], ["", "def", "select_elites", "(", "states_batch", ",", "actions_batch", ",", "rewards_batch", ",", "percentile", "=", "50", ")", ":", "\n", "\t", "\"\"\"\n\tSelect states and actions from games that have rewards >= percentile\n\t:param states_batch: list of lists of states, states_batch[session_i][t]\n\t:param actions_batch: list of lists of actions, actions_batch[session_i][t]\n\t:param rewards_batch: list of rewards, rewards_batch[session_i]\n\n\t:returns: elite_states,elite_actions, both 1D lists of states and respective actions from elite sessions\n\t\n\tThis function was mostly taken from https://github.com/yandexdataschool/Practical_RL/blob/master/week01_intro/deep_crossentropy_method.ipynb\n\tIf this function is the bottleneck, it can easily be sped up using numba\n\t\"\"\"", "\n", "counter", "=", "n_sessions", "*", "(", "100.0", "-", "percentile", ")", "/", "100.0", "\n", "reward_threshold", "=", "np", ".", "percentile", "(", "rewards_batch", ",", "percentile", ")", "\n", "\n", "elite_states", "=", "[", "]", "\n", "elite_actions", "=", "[", "]", "\n", "elite_rewards", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "states_batch", ")", ")", ":", "\n", "\t\t", "if", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "-", "0.0000001", ":", "\n", "\t\t\t", "if", "(", "counter", ">", "0", ")", "or", "(", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "+", "0.0000001", ")", ":", "\n", "\t\t\t\t", "for", "item", "in", "states_batch", "[", "i", "]", ":", "\n", "\t\t\t\t\t", "elite_states", ".", "append", "(", "item", ".", "tolist", "(", ")", ")", "\n", "", "for", "item", "in", "actions_batch", "[", "i", "]", ":", "\n", "\t\t\t\t\t", "elite_actions", ".", "append", "(", "item", ")", "\n", "", "", "counter", "-=", "1", "\n", "", "", "elite_states", "=", "np", ".", "array", "(", "elite_states", ",", "dtype", "=", "int", ")", "\n", "elite_actions", "=", "np", ".", "array", "(", "elite_actions", ",", "dtype", "=", "int", ")", "\n", "return", "elite_states", ",", "elite_actions", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.None.code_template.select_super_sessions": [[195, 219], ["numpy.percentile", "range", "numpy.array", "numpy.array", "numpy.array", "len", "np.array.append", "np.array.append", "np.array.append"], "function", ["None"], ["", "def", "select_super_sessions", "(", "states_batch", ",", "actions_batch", ",", "rewards_batch", ",", "percentile", "=", "90", ")", ":", "\n", "\t", "\"\"\"\n\tSelect all the sessions that will survive to the next generation\n\tSimilar to select_elites function\n\tIf this function is the bottleneck, it can easily be sped up using numba\n\t\"\"\"", "\n", "\n", "counter", "=", "n_sessions", "*", "(", "100.0", "-", "percentile", ")", "/", "100.0", "\n", "reward_threshold", "=", "np", ".", "percentile", "(", "rewards_batch", ",", "percentile", ")", "\n", "\n", "super_states", "=", "[", "]", "\n", "super_actions", "=", "[", "]", "\n", "super_rewards", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "states_batch", ")", ")", ":", "\n", "\t\t", "if", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "-", "0.0000001", ":", "\n", "\t\t\t", "if", "(", "counter", ">", "0", ")", "or", "(", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "+", "0.0000001", ")", ":", "\n", "\t\t\t\t", "super_states", ".", "append", "(", "states_batch", "[", "i", "]", ")", "\n", "super_actions", ".", "append", "(", "actions_batch", "[", "i", "]", ")", "\n", "super_rewards", ".", "append", "(", "rewards_batch", "[", "i", "]", ")", "\n", "counter", "-=", "1", "\n", "", "", "", "super_states", "=", "np", ".", "array", "(", "super_states", ",", "dtype", "=", "int", ")", "\n", "super_actions", "=", "np", ".", "array", "(", "super_actions", ",", "dtype", "=", "int", ")", "\n", "super_rewards", "=", "np", ".", "array", "(", "super_rewards", ")", "\n", "return", "super_states", ",", "super_actions", ",", "super_rewards", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj21.calcScore": [[78, 130], ["networkx.Graph", "nx.Graph.add_nodes_from", "range", "numpy.linalg.eigvalsh", "numpy.zeros_like", "range", "max", "networkx.max_weight_matching", "len", "list", "range", "networkx.is_connected", "networkx.adjacency_matrix().todense", "len", "abs", "print", "networkx.draw_kamada_kawai", "matplotlib.show", "exit", "range", "nx.Graph.add_edge", "networkx.adjacency_matrix", "math.sqrt"], "function", ["None"], ["def", "calcScore", "(", "state", ")", ":", "\n", "\t", "\"\"\"\n\tCalculates the reward for a given word. \n\tThis function is very slow, it can be massively sped up with numba -- but numba doesn't support networkx yet, which is very convenient to use here\n\t:param state: the first MYN letters of this param are the word that the neural network has constructed.\n\n\n\t:returns: the reward (a real number). Higher is better, the network will try to maximize this.\n\t\"\"\"", "\n", "\n", "#Example reward function, for Conjecture 2.1", "\n", "#Given a graph, it minimizes lambda_1 + mu.", "\n", "#Takes a few hours  (between 300 and 10000 iterations) to converge (loss < 0.01) on my computer with these parameters if not using parallelization.", "\n", "#There is a lot of run-to-run variance.", "\n", "#Finds the counterexample some 30% (?) of the time with these parameters, but you can run several instances in parallel.", "\n", "\n", "#Construct the graph ", "\n", "G", "=", "nx", ".", "Graph", "(", ")", "\n", "G", ".", "add_nodes_from", "(", "list", "(", "range", "(", "N", ")", ")", ")", "\n", "count", "=", "0", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "\t\t", "for", "j", "in", "range", "(", "i", "+", "1", ",", "N", ")", ":", "\n", "\t\t\t", "if", "state", "[", "count", "]", "==", "1", ":", "\n", "\t\t\t\t", "G", ".", "add_edge", "(", "i", ",", "j", ")", "\n", "", "count", "+=", "1", "\n", "\n", "#G is assumed to be connected in the conjecture. If it isn't, return a very negative reward.", "\n", "", "", "if", "not", "(", "nx", ".", "is_connected", "(", "G", ")", ")", ":", "\n", "\t\t", "return", "-", "INF", "\n", "\n", "#Calculate the eigenvalues of G", "\n", "", "evals", "=", "np", ".", "linalg", ".", "eigvalsh", "(", "nx", ".", "adjacency_matrix", "(", "G", ")", ".", "todense", "(", ")", ")", "\n", "evalsRealAbs", "=", "np", ".", "zeros_like", "(", "evals", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "evals", ")", ")", ":", "\n", "\t\t", "evalsRealAbs", "[", "i", "]", "=", "abs", "(", "evals", "[", "i", "]", ")", "\n", "", "lambda1", "=", "max", "(", "evalsRealAbs", ")", "\n", "\n", "#Calculate the matching number of G", "\n", "maxMatch", "=", "nx", ".", "max_weight_matching", "(", "G", ")", "\n", "mu", "=", "len", "(", "maxMatch", ")", "\n", "\n", "#Calculate the reward. Since we want to minimize lambda_1 + mu, we return the negative of this.", "\n", "#We add to this the conjectured best value. This way if the reward is positive we know we have a counterexample.", "\n", "myScore", "=", "math", ".", "sqrt", "(", "N", "-", "1", ")", "+", "1", "-", "lambda1", "-", "mu", "\n", "if", "myScore", ">", "0", ":", "\n", "#You have found a counterexample. Do something with it.", "\n", "\t\t", "print", "(", "state", ")", "\n", "nx", ".", "draw_kamada_kawai", "(", "G", ")", "\n", "plt", ".", "show", "(", ")", "\n", "exit", "(", ")", "\n", "\n", "", "return", "myScore", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj21.generate_session": [[138, 194], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "time.time", "agent.predict", "range", "print", "time.time", "time.time", "time.time", "time.time", "numpy.random.rand", "time.time", "cem_binary_conj21.calcScore", "time.time", "time.time", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj23_with_numba.calcScore"], ["", "def", "generate_session", "(", "agent", ",", "n_sessions", ",", "verbose", "=", "1", ")", ":", "\n", "\t", "\"\"\"\n\tPlay n_session games using agent neural network.\n\tTerminate when games finish \n\t\n\tCode inspired by https://github.com/yandexdataschool/Practical_RL/blob/master/week01_intro/deep_crossentropy_method.ipynb\n\t\"\"\"", "\n", "states", "=", "np", ".", "zeros", "(", "[", "n_sessions", ",", "observation_space", ",", "len_game", "]", ",", "dtype", "=", "int", ")", "\n", "actions", "=", "np", ".", "zeros", "(", "[", "n_sessions", ",", "len_game", "]", ",", "dtype", "=", "int", ")", "\n", "state_next", "=", "np", ".", "zeros", "(", "[", "n_sessions", ",", "observation_space", "]", ",", "dtype", "=", "int", ")", "\n", "prob", "=", "np", ".", "zeros", "(", "n_sessions", ")", "\n", "states", "[", ":", ",", "MYN", ",", "0", "]", "=", "1", "\n", "step", "=", "0", "\n", "total_score", "=", "np", ".", "zeros", "(", "[", "n_sessions", "]", ")", "\n", "recordsess_time", "=", "0", "\n", "play_time", "=", "0", "\n", "scorecalc_time", "=", "0", "\n", "pred_time", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "\t\t", "step", "+=", "1", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "prob", "=", "agent", ".", "predict", "(", "states", "[", ":", ",", ":", ",", "step", "-", "1", "]", ",", "batch_size", "=", "n_sessions", ")", "\n", "pred_time", "+=", "time", ".", "time", "(", ")", "-", "tic", "\n", "\n", "for", "i", "in", "range", "(", "n_sessions", ")", ":", "\n", "\n", "\t\t\t", "if", "np", ".", "random", ".", "rand", "(", ")", "<", "prob", "[", "i", "]", ":", "\n", "\t\t\t\t", "action", "=", "1", "\n", "", "else", ":", "\n", "\t\t\t\t", "action", "=", "0", "\n", "", "actions", "[", "i", "]", "[", "step", "-", "1", "]", "=", "action", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "state_next", "[", "i", "]", "=", "states", "[", "i", ",", ":", ",", "step", "-", "1", "]", "\n", "play_time", "+=", "time", ".", "time", "(", ")", "-", "tic", "\n", "if", "(", "action", ">", "0", ")", ":", "\n", "\t\t\t\t", "state_next", "[", "i", "]", "[", "step", "-", "1", "]", "=", "action", "\n", "", "state_next", "[", "i", "]", "[", "MYN", "+", "step", "-", "1", "]", "=", "0", "\n", "if", "(", "step", "<", "MYN", ")", ":", "\n", "\t\t\t\t", "state_next", "[", "i", "]", "[", "MYN", "+", "step", "]", "=", "1", "\n", "", "terminal", "=", "step", "==", "MYN", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "if", "terminal", ":", "\n", "\t\t\t\t", "total_score", "[", "i", "]", "=", "calcScore", "(", "state_next", "[", "i", "]", ")", "\n", "", "scorecalc_time", "+=", "time", ".", "time", "(", ")", "-", "tic", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "terminal", ":", "\n", "\t\t\t\t", "states", "[", "i", ",", ":", ",", "step", "]", "=", "state_next", "[", "i", "]", "\n", "", "recordsess_time", "+=", "time", ".", "time", "(", ")", "-", "tic", "\n", "\n", "\n", "", "if", "terminal", ":", "\n", "\t\t\t", "break", "\n", "#If you want, print out how much time each step has taken. This is useful to find the bottleneck in the program.\t\t", "\n", "", "", "if", "(", "verbose", ")", ":", "\n", "\t\t", "print", "(", "\"Predict: \"", "+", "str", "(", "pred_time", ")", "+", "\", play: \"", "+", "str", "(", "play_time", ")", "+", "\", scorecalc: \"", "+", "str", "(", "scorecalc_time", ")", "+", "\", recordsess: \"", "+", "str", "(", "recordsess_time", ")", ")", "\n", "", "return", "states", ",", "actions", ",", "total_score", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj21.select_elites": [[197, 226], ["numpy.percentile", "range", "numpy.array", "numpy.array", "len", "np.array.append", "np.array.append", "item.tolist"], "function", ["None"], ["", "def", "select_elites", "(", "states_batch", ",", "actions_batch", ",", "rewards_batch", ",", "percentile", "=", "50", ")", ":", "\n", "\t", "\"\"\"\n\tSelect states and actions from games that have rewards >= percentile\n\t:param states_batch: list of lists of states, states_batch[session_i][t]\n\t:param actions_batch: list of lists of actions, actions_batch[session_i][t]\n\t:param rewards_batch: list of rewards, rewards_batch[session_i]\n\n\t:returns: elite_states,elite_actions, both 1D lists of states and respective actions from elite sessions\n\t\n\tThis function was mostly taken from https://github.com/yandexdataschool/Practical_RL/blob/master/week01_intro/deep_crossentropy_method.ipynb\n\tIf this function is the bottleneck, it can easily be sped up using numba\n\t\"\"\"", "\n", "counter", "=", "n_sessions", "*", "(", "100.0", "-", "percentile", ")", "/", "100.0", "\n", "reward_threshold", "=", "np", ".", "percentile", "(", "rewards_batch", ",", "percentile", ")", "\n", "\n", "elite_states", "=", "[", "]", "\n", "elite_actions", "=", "[", "]", "\n", "elite_rewards", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "states_batch", ")", ")", ":", "\n", "\t\t", "if", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "-", "0.0000001", ":", "\n", "\t\t\t", "if", "(", "counter", ">", "0", ")", "or", "(", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "+", "0.0000001", ")", ":", "\n", "\t\t\t\t", "for", "item", "in", "states_batch", "[", "i", "]", ":", "\n", "\t\t\t\t\t", "elite_states", ".", "append", "(", "item", ".", "tolist", "(", ")", ")", "\n", "", "for", "item", "in", "actions_batch", "[", "i", "]", ":", "\n", "\t\t\t\t\t", "elite_actions", ".", "append", "(", "item", ")", "\n", "", "", "counter", "-=", "1", "\n", "", "", "elite_states", "=", "np", ".", "array", "(", "elite_states", ",", "dtype", "=", "int", ")", "\n", "elite_actions", "=", "np", ".", "array", "(", "elite_actions", ",", "dtype", "=", "int", ")", "\n", "return", "elite_states", ",", "elite_actions", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj21.select_super_sessions": [[227, 251], ["numpy.percentile", "range", "numpy.array", "numpy.array", "numpy.array", "len", "np.array.append", "np.array.append", "np.array.append"], "function", ["None"], ["", "def", "select_super_sessions", "(", "states_batch", ",", "actions_batch", ",", "rewards_batch", ",", "percentile", "=", "90", ")", ":", "\n", "\t", "\"\"\"\n\tSelect all the sessions that will survive to the next generation\n\tSimilar to select_elites function\n\tIf this function is the bottleneck, it can easily be sped up using numba\n\t\"\"\"", "\n", "\n", "counter", "=", "n_sessions", "*", "(", "100.0", "-", "percentile", ")", "/", "100.0", "\n", "reward_threshold", "=", "np", ".", "percentile", "(", "rewards_batch", ",", "percentile", ")", "\n", "\n", "super_states", "=", "[", "]", "\n", "super_actions", "=", "[", "]", "\n", "super_rewards", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "states_batch", ")", ")", ":", "\n", "\t\t", "if", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "-", "0.0000001", ":", "\n", "\t\t\t", "if", "(", "counter", ">", "0", ")", "or", "(", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "+", "0.0000001", ")", ":", "\n", "\t\t\t\t", "super_states", ".", "append", "(", "states_batch", "[", "i", "]", ")", "\n", "super_actions", ".", "append", "(", "actions_batch", "[", "i", "]", ")", "\n", "super_rewards", ".", "append", "(", "rewards_batch", "[", "i", "]", ")", "\n", "counter", "-=", "1", "\n", "", "", "", "super_states", "=", "np", ".", "array", "(", "super_states", ",", "dtype", "=", "int", ")", "\n", "super_actions", "=", "np", ".", "array", "(", "super_actions", ",", "dtype", "=", "int", ")", "\n", "super_rewards", "=", "np", ".", "array", "(", "super_rewards", ")", "\n", "return", "super_states", ",", "super_actions", ",", "super_rewards", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj23_with_numba.bfs": [[84, 120], ["numpy.zeros", "range", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "range"], "function", ["None"], ["def", "bfs", "(", "Gdeg", ",", "edgeListG", ")", ":", "\n", "#simple breadth first search algorithm, from each vertex", "\n", "\n", "\t", "distMat1", "=", "np", ".", "zeros", "(", "(", "N", ",", "N", ")", ")", "\n", "conn", "=", "True", "\n", "for", "s", "in", "range", "(", "N", ")", ":", "\n", "\t\t", "visited", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "np", ".", "int8", ")", "\n", "\n", "# Create a queue for BFS. Queues are not suported with njit yet so do it manually", "\n", "myQueue", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "np", ".", "int8", ")", "\n", "dist", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "np", ".", "int8", ")", "\n", "startInd", "=", "0", "\n", "endInd", "=", "0", "\n", "\n", "# Mark the source node as visited and enqueue it ", "\n", "myQueue", "[", "endInd", "]", "=", "s", "\n", "endInd", "+=", "1", "\n", "visited", "[", "s", "]", "=", "1", "\n", "\n", "while", "endInd", ">", "startInd", ":", "\n", "\t\t\t", "pivot", "=", "myQueue", "[", "startInd", "]", "\n", "startInd", "+=", "1", "\n", "\n", "for", "i", "in", "range", "(", "Gdeg", "[", "pivot", "]", ")", ":", "\n", "\t\t\t\t", "if", "visited", "[", "edgeListG", "[", "pivot", "]", "[", "i", "]", "]", "==", "0", ":", "\n", "\t\t\t\t\t", "myQueue", "[", "endInd", "]", "=", "edgeListG", "[", "pivot", "]", "[", "i", "]", "\n", "dist", "[", "edgeListG", "[", "pivot", "]", "[", "i", "]", "]", "=", "dist", "[", "pivot", "]", "+", "1", "\n", "endInd", "+=", "1", "\n", "visited", "[", "edgeListG", "[", "pivot", "]", "[", "i", "]", "]", "=", "1", "\n", "", "", "", "if", "endInd", "<", "N", ":", "\n", "\t\t\t", "conn", "=", "False", "#not connected", "\n", "\n", "", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "\t\t\t", "distMat1", "[", "s", "]", "[", "i", "]", "=", "dist", "[", "i", "]", "\n", "\n", "", "", "return", "distMat1", ",", "conn", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj23_with_numba.calcScore": [[125, 165], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "jitted_bfs", "numpy.amax", "numpy.zeros", "numpy.sum", "numpy.linalg.eigvalsh", "range", "numpy.sort", "numpy.amin", "math.floor"], "function", ["None"], ["def", "calcScore", "(", "state", ")", ":", "\n", "\t", "\"\"\"\n\tReward function for Conjecture 2.3, using numba\n\tWith n=30 it took a day to converge to the graph in figure 5, I don't think it will ever find the best graph\n\t(which I believe is when the neigbourhood of that almost middle vertex is one big clique).\n\t(This is not the best graph for all n, but seems to be for n=30)\n\t\n\t\"\"\"", "\n", "#construct the graph G", "\n", "adjMatG", "=", "np", ".", "zeros", "(", "(", "N", ",", "N", ")", ",", "dtype", "=", "np", ".", "int8", ")", "#adjacency matrix determined by the state", "\n", "edgeListG", "=", "np", ".", "zeros", "(", "(", "N", ",", "N", ")", ",", "dtype", "=", "np", ".", "int8", ")", "#neighbor list", "\n", "Gdeg", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "np", ".", "int8", ")", "#degree sequence", "\n", "count", "=", "0", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "\t\t", "for", "j", "in", "range", "(", "i", "+", "1", ",", "N", ")", ":", "\n", "\t\t\t", "if", "state", "[", "count", "]", "==", "1", ":", "\n", "\t\t\t\t", "adjMatG", "[", "i", "]", "[", "j", "]", "=", "1", "\n", "adjMatG", "[", "j", "]", "[", "i", "]", "=", "1", "\n", "edgeListG", "[", "i", "]", "[", "Gdeg", "[", "i", "]", "]", "=", "j", "\n", "edgeListG", "[", "j", "]", "[", "Gdeg", "[", "j", "]", "]", "=", "i", "\n", "Gdeg", "[", "i", "]", "+=", "1", "\n", "Gdeg", "[", "j", "]", "+=", "1", "\n", "", "count", "+=", "1", "\n", "\n", "\n", "", "", "distMat", ",", "conn", "=", "jitted_bfs", "(", "Gdeg", ",", "edgeListG", ")", "\n", "#G has to be connected", "\n", "if", "not", "conn", ":", "\n", "\t\t", "return", "-", "INF", "\n", "\n", "", "diam", "=", "np", ".", "amax", "(", "distMat", ")", "\n", "sumLengths", "=", "np", ".", "zeros", "(", "N", ",", "dtype", "=", "np", ".", "int8", ")", "\n", "sumLengths", "=", "np", ".", "sum", "(", "distMat", ",", "axis", "=", "0", ")", "\n", "evals", "=", "np", ".", "linalg", ".", "eigvalsh", "(", "distMat", ")", "\n", "evals", "=", "-", "np", ".", "sort", "(", "-", "evals", ")", "\n", "proximity", "=", "np", ".", "amin", "(", "sumLengths", ")", "/", "(", "N", "-", "1.0", ")", "\n", "\n", "ans", "=", "-", "(", "proximity", "+", "evals", "[", "math", ".", "floor", "(", "2", "*", "diam", "/", "3", ")", "-", "1", "]", ")", "\n", "\n", "return", "ans", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj23_with_numba.play_game": [[172, 198], ["range", "numpy.random.rand", "jitted_calcScore"], "function", ["None"], ["def", "play_game", "(", "n_sessions", ",", "actions", ",", "state_next", ",", "states", ",", "prob", ",", "step", ",", "total_score", ")", ":", "\n", "\n", "\t", "for", "i", "in", "range", "(", "n_sessions", ")", ":", "\n", "\n", "\t\t", "if", "np", ".", "random", ".", "rand", "(", ")", "<", "prob", "[", "i", "]", ":", "\n", "\t\t\t", "action", "=", "1", "\n", "", "else", ":", "\n", "\t\t\t", "action", "=", "0", "\n", "", "actions", "[", "i", "]", "[", "step", "-", "1", "]", "=", "action", "\n", "state_next", "[", "i", "]", "=", "states", "[", "i", ",", ":", ",", "step", "-", "1", "]", "\n", "\n", "if", "(", "action", ">", "0", ")", ":", "\n", "\t\t\t", "state_next", "[", "i", "]", "[", "step", "-", "1", "]", "=", "action", "\n", "", "state_next", "[", "i", "]", "[", "MYN", "+", "step", "-", "1", "]", "=", "0", "\n", "if", "(", "step", "<", "MYN", ")", ":", "\n", "\t\t\t", "state_next", "[", "i", "]", "[", "MYN", "+", "step", "]", "=", "1", "\n", "#calculate final score", "\n", "", "terminal", "=", "step", "==", "MYN", "\n", "if", "terminal", ":", "\n", "\t\t\t", "total_score", "[", "i", "]", "=", "jitted_calcScore", "(", "state_next", "[", "i", "]", ")", "\n", "\n", "# record sessions ", "\n", "", "if", "not", "terminal", ":", "\n", "\t\t\t", "states", "[", "i", ",", ":", ",", "step", "]", "=", "state_next", "[", "i", "]", "\n", "\n", "", "", "return", "actions", ",", "state_next", ",", "states", ",", "total_score", ",", "terminal", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj23_with_numba.generate_session": [[201, 232], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "time.time", "agent.predict", "time.time", "jitted_play_game", "print", "time.time", "time.time", "str", "str"], "function", ["None"], ["def", "generate_session", "(", "agent", ",", "n_sessions", ",", "verbose", "=", "1", ")", ":", "\n", "\t", "\"\"\"\n\tPlay n_session games using agent neural network.\n\tTerminate when games finish \n\t\n\tCode inspired by https://github.com/yandexdataschool/Practical_RL/blob/master/week01_intro/deep_crossentropy_method.ipynb\n\t\"\"\"", "\n", "states", "=", "np", ".", "zeros", "(", "[", "n_sessions", ",", "observation_space", ",", "len_game", "]", ",", "dtype", "=", "int", ")", "\n", "actions", "=", "np", ".", "zeros", "(", "[", "n_sessions", ",", "len_game", "]", ",", "dtype", "=", "int", ")", "\n", "state_next", "=", "np", ".", "zeros", "(", "[", "n_sessions", ",", "observation_space", "]", ",", "dtype", "=", "int", ")", "\n", "prob", "=", "np", ".", "zeros", "(", "n_sessions", ")", "\n", "states", "[", ":", ",", "MYN", ",", "0", "]", "=", "1", "\n", "step", "=", "0", "\n", "total_score", "=", "np", ".", "zeros", "(", "[", "n_sessions", "]", ")", "\n", "pred_time", "=", "0", "\n", "play_time", "=", "0", "\n", "\n", "while", "(", "True", ")", ":", "\n", "\t\t", "step", "+=", "1", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "prob", "=", "agent", ".", "predict", "(", "states", "[", ":", ",", ":", ",", "step", "-", "1", "]", ",", "batch_size", "=", "n_sessions", ")", "\n", "pred_time", "+=", "time", ".", "time", "(", ")", "-", "tic", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "actions", ",", "state_next", ",", "states", ",", "total_score", ",", "terminal", "=", "jitted_play_game", "(", "n_sessions", ",", "actions", ",", "state_next", ",", "states", ",", "prob", ",", "step", ",", "total_score", ")", "\n", "play_time", "+=", "time", ".", "time", "(", ")", "-", "tic", "\n", "\n", "if", "terminal", ":", "\n", "\t\t\t", "break", "\n", "", "", "if", "(", "verbose", ")", ":", "\n", "\t\t", "print", "(", "\"Predict: \"", "+", "str", "(", "pred_time", ")", "+", "\", play: \"", "+", "str", "(", "play_time", ")", ")", "\n", "", "return", "states", ",", "actions", ",", "total_score", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj23_with_numba.select_elites": [[234, 263], ["numpy.percentile", "range", "numpy.array", "numpy.array", "len", "np.array.append", "np.array.append", "item.tolist"], "function", ["None"], ["", "def", "select_elites", "(", "states_batch", ",", "actions_batch", ",", "rewards_batch", ",", "percentile", "=", "50", ")", ":", "\n", "\t", "\"\"\"\n\tSelect states and actions from games that have rewards >= percentile\n\t:param states_batch: list of lists of states, states_batch[session_i][t]\n\t:param actions_batch: list of lists of actions, actions_batch[session_i][t]\n\t:param rewards_batch: list of rewards, rewards_batch[session_i]\n\n\t:returns: elite_states,elite_actions, both 1D lists of states and respective actions from elite sessions\n\t\n\tThis function was mostly taken from https://github.com/yandexdataschool/Practical_RL/blob/master/week01_intro/deep_crossentropy_method.ipynb\n\tIf this function is the bottleneck, it can easily be sped up using numba\n\t\"\"\"", "\n", "counter", "=", "n_sessions", "*", "(", "100.0", "-", "percentile", ")", "/", "100.0", "\n", "reward_threshold", "=", "np", ".", "percentile", "(", "rewards_batch", ",", "percentile", ")", "\n", "\n", "elite_states", "=", "[", "]", "\n", "elite_actions", "=", "[", "]", "\n", "elite_rewards", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "states_batch", ")", ")", ":", "\n", "\t\t", "if", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "-", "0.0000001", ":", "\n", "\t\t\t", "if", "(", "counter", ">", "0", ")", "or", "(", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "+", "0.0000001", ")", ":", "\n", "\t\t\t\t", "for", "item", "in", "states_batch", "[", "i", "]", ":", "\n", "\t\t\t\t\t", "elite_states", ".", "append", "(", "item", ".", "tolist", "(", ")", ")", "\n", "", "for", "item", "in", "actions_batch", "[", "i", "]", ":", "\n", "\t\t\t\t\t", "elite_actions", ".", "append", "(", "item", ")", "\n", "", "", "counter", "-=", "1", "\n", "", "", "elite_states", "=", "np", ".", "array", "(", "elite_states", ",", "dtype", "=", "int", ")", "\n", "elite_actions", "=", "np", ".", "array", "(", "elite_actions", ",", "dtype", "=", "int", ")", "\n", "return", "elite_states", ",", "elite_actions", "\n", "\n"]], "home.repos.pwc.inspect_result.zawagner22_cross-entropy-for-combinatorics.demos.cem_binary_conj23_with_numba.select_super_sessions": [[264, 288], ["numpy.percentile", "range", "numpy.array", "numpy.array", "numpy.array", "len", "np.array.append", "np.array.append", "np.array.append"], "function", ["None"], ["", "def", "select_super_sessions", "(", "states_batch", ",", "actions_batch", ",", "rewards_batch", ",", "percentile", "=", "90", ")", ":", "\n", "\t", "\"\"\"\n\tSelect all the sessions that will survive to the next generation\n\tSimilar to select_elites function\n\tIf this function is the bottleneck, it can easily be sped up using numba\n\t\"\"\"", "\n", "\n", "counter", "=", "n_sessions", "*", "(", "100.0", "-", "percentile", ")", "/", "100.0", "\n", "reward_threshold", "=", "np", ".", "percentile", "(", "rewards_batch", ",", "percentile", ")", "\n", "\n", "super_states", "=", "[", "]", "\n", "super_actions", "=", "[", "]", "\n", "super_rewards", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "states_batch", ")", ")", ":", "\n", "\t\t", "if", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "-", "0.0000001", ":", "\n", "\t\t\t", "if", "(", "counter", ">", "0", ")", "or", "(", "rewards_batch", "[", "i", "]", ">=", "reward_threshold", "+", "0.0000001", ")", ":", "\n", "\t\t\t\t", "super_states", ".", "append", "(", "states_batch", "[", "i", "]", ")", "\n", "super_actions", ".", "append", "(", "actions_batch", "[", "i", "]", ")", "\n", "super_rewards", ".", "append", "(", "rewards_batch", "[", "i", "]", ")", "\n", "counter", "-=", "1", "\n", "", "", "", "super_states", "=", "np", ".", "array", "(", "super_states", ",", "dtype", "=", "int", ")", "\n", "super_actions", "=", "np", ".", "array", "(", "super_actions", ",", "dtype", "=", "int", ")", "\n", "super_rewards", "=", "np", ".", "array", "(", "super_rewards", ")", "\n", "return", "super_states", ",", "super_actions", ",", "super_rewards", "\n", "\n"]]}